import {
  k as e,
  s as a,
  m as t,
  r as s,
  g as n,
  x as r,
  n as l,
  o,
  d as u,
  z as i,
  L as d,
  v as c,
  A as m,
} from './rsa-plugins-common.min.js';
import { R as v } from './rsa-plugins-RetryQueue.min.js';
const p = {
    maxRetryDelay: 36e4,
    minRetryDelay: 1e3,
    backoffFactor: 2,
    maxAttempts: 10,
    maxItems: 100,
  },
  h = 'v1',
  y = (e, t, s) => a({ batch: e, sentAt: t }, !0, void 0, s),
  $ = (e, a) => {
    const t = new URL(e);
    return new URL(s([t.pathname, '/', h, '/', a].join('')), t).href;
  },
  f = (a, t, s, l, o, u) => {
    if (n(null == a ? void 0 : a.error) || n(u)) return;
    const i = r(a);
    let d = ((a, t) => `${a}${e}Failed to deliver event(s) to ${t}.`)('XhrQueuePlugin', t);
    const c = 'The event(s) will be dropped.';
    i
      ? s
        ? ((d = `${d} It/they will be retried.`), l > 0 && (d = `${d} Retry attempt ${l} of ${o}.`))
        : (d = `${d} Retries exhausted (${o}). ${c}`)
      : (d = `${d} ${c}`),
      null == u || u.error(d);
  },
  R = (e, a, t) => {
    let s, n, r;
    const d = l();
    if (Array.isArray(e)) {
      const l = e.map((e) => o(e.event, d));
      (s = y(l, d, t)),
        (n = e[0] ? u(e[0].headers) : {}),
        (c = a.lifecycle.activeDataplaneUrl.value),
        (r = $(c, 'batch'));
    } else {
      const { url: a, event: l, headers: c } = e,
        m = o(l, d);
      (s = i(m, t)), (n = u(c)), (r = a);
    }
    var c;
    return { data: s, headers: n, url: r };
  },
  g = 'XhrQueue',
  A = () => ({
    name: g,
    deps: [],
    initialize: (e) => {
      e.plugins.loadedPlugins.value = [...e.plugins.loadedPlugins.value, g];
    },
    dataplaneEventsQueue: {
      init(e, a, s, n, o) {
        const u = e.lifecycle.writeKey.value;
        a.setAuthHeader(u);
        const i = ((c = e.loadOptions.value.queueOptions), t(p, c));
        var c;
        return new v(
          `rudder_${u}`,
          i,
          (t, s, n, l, u) => {
            const { data: i, url: d, headers: c } = R(t, e, o);
            a.getAsyncData({
              url: d,
              options: { method: 'POST', headers: c, data: i, sendRawData: !0 },
              isRawResponse: !0,
              timeout: 3e4,
              callback: (e, a) => {
                const t = r(a) ? a : null;
                f(a, d, u, n, l, o), s(t, e);
              },
            });
          },
          s,
          d,
          o,
          (e) => {
            var a;
            const t = l(),
              s = e.map((e) => e.event);
            return null === (a = y(s, t, o)) || void 0 === a ? void 0 : a.length;
          }
        );
      },
      enqueue(e, a, t, s, n) {
        (t.sentAt = l()), c(t, n);
        const r = e.lifecycle.activeDataplaneUrl.value,
          o = $(r, t.type),
          u = { AnonymousId: m(t.anonymousId) };
        a.addItem({ url: o, headers: u, event: t });
      },
    },
  });
export { A as XhrQueue, A as default };
//# sourceMappingURL=rsa-plugins-remote-XhrQueue.min.js.map
