try {
  let e =
      'undefined' != typeof window
        ? window
        : 'undefined' != typeof global
          ? global
          : 'undefined' != typeof globalThis
            ? globalThis
            : 'undefined' != typeof self
              ? self
              : {},
    t = new e.Error().stack;
  t &&
    ((e._sentryDebugIds = e._sentryDebugIds || {}),
    (e._sentryDebugIds[t] = '08c83adc-e958-4cf0-b0eb-5085bc94f45d'),
    (e._sentryDebugIdIdentifier = 'sentry-dbid-08c83adc-e958-4cf0-b0eb-5085bc94f45d'));
} catch (e) {}
(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
  [1299],
  {
    80681: function (e, t, i) {
      Promise.resolve().then(i.bind(i, 1208)),
        Promise.resolve().then(i.bind(i, 46997)),
        Promise.resolve().then(i.bind(i, 3849)),
        Promise.resolve().then(i.bind(i, 60647)),
        Promise.resolve().then(i.bind(i, 93665)),
        Promise.resolve().then(i.bind(i, 391)),
        Promise.resolve().then(i.bind(i, 39507)),
        Promise.resolve().then(i.bind(i, 30344)),
        Promise.resolve().then(i.bind(i, 69351)),
        Promise.resolve().then(i.bind(i, 43640)),
        Promise.resolve().then(i.bind(i, 60846)),
        Promise.resolve().then(i.bind(i, 92275)),
        Promise.resolve().then(i.bind(i, 73635)),
        Promise.resolve().then(i.bind(i, 72008)),
        Promise.resolve().then(i.bind(i, 8052)),
        Promise.resolve().then(i.bind(i, 10111)),
        Promise.resolve().then(i.bind(i, 10747)),
        Promise.resolve().then(i.bind(i, 75688)),
        Promise.resolve().then(i.bind(i, 40405)),
        Promise.resolve().then(i.bind(i, 50544)),
        Promise.resolve().then(i.bind(i, 38071)),
        Promise.resolve().then(i.bind(i, 35038)),
        Promise.resolve().then(i.bind(i, 13180)),
        Promise.resolve().then(i.bind(i, 77843)),
        Promise.resolve().then(i.bind(i, 18530)),
        Promise.resolve().then(i.bind(i, 87982)),
        Promise.resolve().then(i.bind(i, 31950)),
        Promise.resolve().then(i.bind(i, 57864)),
        Promise.resolve().then(i.bind(i, 47205)),
        Promise.resolve().then(i.bind(i, 78707)),
        Promise.resolve().then(i.bind(i, 68283)),
        Promise.resolve().then(i.bind(i, 15408)),
        Promise.resolve().then(i.bind(i, 28971)),
        Promise.resolve().then(i.bind(i, 96188)),
        Promise.resolve().then(i.bind(i, 86096)),
        Promise.resolve().then(i.bind(i, 15176)),
        Promise.resolve().then(i.bind(i, 68987)),
        Promise.resolve().then(i.bind(i, 89690)),
        Promise.resolve().then(i.bind(i, 77834)),
        Promise.resolve().then(i.bind(i, 9894)),
        Promise.resolve().then(i.bind(i, 45751)),
        Promise.resolve().then(i.bind(i, 39306)),
        Promise.resolve().then(i.bind(i, 4015)),
        Promise.resolve().then(i.bind(i, 3167)),
        Promise.resolve().then(i.bind(i, 89778)),
        Promise.resolve().then(i.bind(i, 11901)),
        Promise.resolve().then(i.bind(i, 52754)),
        Promise.resolve().then(i.bind(i, 94098)),
        Promise.resolve().then(i.bind(i, 84215)),
        Promise.resolve().then(i.bind(i, 91747)),
        Promise.resolve().then(i.bind(i, 77051)),
        Promise.resolve().then(i.bind(i, 94108)),
        Promise.resolve().then(i.bind(i, 57261)),
        Promise.resolve().then(i.bind(i, 46831)),
        Promise.resolve().then(i.bind(i, 61512)),
        Promise.resolve().then(i.bind(i, 20147)),
        Promise.resolve().then(i.bind(i, 70058)),
        Promise.resolve().then(i.bind(i, 92093)),
        Promise.resolve().then(i.bind(i, 75794)),
        Promise.resolve().then(i.bind(i, 39228)),
        Promise.resolve().then(i.bind(i, 84478)),
        Promise.resolve().then(i.bind(i, 43609)),
        Promise.resolve().then(i.bind(i, 49482)),
        Promise.resolve().then(i.t.bind(i, 23293, 23)),
        Promise.resolve().then(i.bind(i, 92529)),
        Promise.resolve().then(i.bind(i, 66911)),
        Promise.resolve().then(i.bind(i, 29015)),
        Promise.resolve().then(i.bind(i, 16164)),
        Promise.resolve().then(i.bind(i, 94282)),
        Promise.resolve().then(i.bind(i, 15642)),
        Promise.resolve().then(i.bind(i, 72355)),
        Promise.resolve().then(i.bind(i, 99e3)),
        Promise.resolve().then(i.bind(i, 16560)),
        Promise.resolve().then(i.bind(i, 18386)),
        Promise.resolve().then(i.bind(i, 13722)),
        Promise.resolve().then(i.bind(i, 65386)),
        Promise.resolve().then(i.bind(i, 7887)),
        Promise.resolve().then(i.bind(i, 58811)),
        Promise.resolve().then(i.bind(i, 81082)),
        Promise.resolve().then(i.bind(i, 38254)),
        Promise.resolve().then(i.bind(i, 16937)),
        Promise.resolve().then(i.bind(i, 84480)),
        Promise.resolve().then(i.bind(i, 1318)),
        Promise.resolve().then(i.bind(i, 18074)),
        Promise.resolve().then(i.bind(i, 3985)),
        Promise.resolve().then(i.bind(i, 63154)),
        Promise.resolve().then(i.bind(i, 70911)),
        Promise.resolve().then(i.bind(i, 24505)),
        Promise.resolve().then(i.bind(i, 95715)),
        Promise.resolve().then(i.bind(i, 55968)),
        Promise.resolve().then(i.bind(i, 82405)),
        Promise.resolve().then(i.bind(i, 67598)),
        Promise.resolve().then(i.bind(i, 32615)),
        Promise.resolve().then(i.bind(i, 92241)),
        Promise.resolve().then(i.bind(i, 95308)),
        Promise.resolve().then(i.bind(i, 33734)),
        Promise.resolve().then(i.bind(i, 54537)),
        Promise.resolve().then(i.bind(i, 40327)),
        Promise.resolve().then(i.bind(i, 23837)),
        Promise.resolve().then(i.bind(i, 50964)),
        Promise.resolve().then(i.bind(i, 14754)),
        Promise.resolve().then(i.bind(i, 45445)),
        Promise.resolve().then(i.bind(i, 76269)),
        Promise.resolve().then(i.bind(i, 89013)),
        Promise.resolve().then(i.bind(i, 12518)),
        Promise.resolve().then(i.bind(i, 74332)),
        Promise.resolve().then(i.bind(i, 39613)),
        Promise.resolve().then(i.bind(i, 68889)),
        Promise.resolve().then(i.bind(i, 84408)),
        Promise.resolve().then(i.bind(i, 62726)),
        Promise.resolve().then(i.bind(i, 22490)),
        Promise.resolve().then(i.bind(i, 7401)),
        Promise.resolve().then(i.bind(i, 17293)),
        Promise.resolve().then(i.bind(i, 79686)),
        Promise.resolve().then(i.bind(i, 9541)),
        Promise.resolve().then(i.bind(i, 42292)),
        Promise.resolve().then(i.bind(i, 36511)),
        Promise.resolve().then(i.bind(i, 31678)),
        Promise.resolve().then(i.bind(i, 53618)),
        Promise.resolve().then(i.bind(i, 10758)),
        Promise.resolve().then(i.bind(i, 47312)),
        Promise.resolve().then(i.bind(i, 59761)),
        Promise.resolve().then(i.bind(i, 98642)),
        Promise.resolve().then(i.bind(i, 16282)),
        Promise.resolve().then(i.bind(i, 86538)),
        Promise.resolve().then(i.bind(i, 36468)),
        Promise.resolve().then(i.bind(i, 68083)),
        Promise.resolve().then(i.bind(i, 59002)),
        Promise.resolve().then(i.bind(i, 9009)),
        Promise.resolve().then(i.bind(i, 30726)),
        Promise.resolve().then(i.bind(i, 95955)),
        Promise.resolve().then(i.bind(i, 59586)),
        Promise.resolve().then(i.bind(i, 68843)),
        Promise.resolve().then(i.bind(i, 1017)),
        Promise.resolve().then(i.bind(i, 87859)),
        Promise.resolve().then(i.bind(i, 61837)),
        Promise.resolve().then(i.bind(i, 71338)),
        Promise.resolve().then(i.bind(i, 38662)),
        Promise.resolve().then(i.bind(i, 87251)),
        Promise.resolve().then(i.bind(i, 84125)),
        Promise.resolve().then(i.bind(i, 16903)),
        Promise.resolve().then(i.bind(i, 40408)),
        Promise.resolve().then(i.bind(i, 10827)),
        Promise.resolve().then(i.bind(i, 48634)),
        Promise.resolve().then(i.bind(i, 95919)),
        Promise.resolve().then(i.bind(i, 15862)),
        Promise.resolve().then(i.bind(i, 14978)),
        Promise.resolve().then(i.bind(i, 62763)),
        Promise.resolve().then(i.bind(i, 71324)),
        Promise.resolve().then(i.bind(i, 66436)),
        Promise.resolve().then(i.bind(i, 53777)),
        Promise.resolve().then(i.bind(i, 17395)),
        Promise.resolve().then(i.bind(i, 67414)),
        Promise.resolve().then(i.bind(i, 17722)),
        Promise.resolve().then(i.bind(i, 19991)),
        Promise.resolve().then(i.bind(i, 80841)),
        Promise.resolve().then(i.bind(i, 31369)),
        Promise.resolve().then(i.bind(i, 45667)),
        Promise.resolve().then(i.bind(i, 60706)),
        Promise.resolve().then(i.bind(i, 71463)),
        Promise.resolve().then(i.bind(i, 24537)),
        Promise.resolve().then(i.bind(i, 40673)),
        Promise.resolve().then(i.bind(i, 40756)),
        Promise.resolve().then(i.bind(i, 36866)),
        Promise.resolve().then(i.bind(i, 2383)),
        Promise.resolve().then(i.bind(i, 63122)),
        Promise.resolve().then(i.bind(i, 47810)),
        Promise.resolve().then(i.bind(i, 14223)),
        Promise.resolve().then(i.bind(i, 43228)),
        Promise.resolve().then(i.bind(i, 35510)),
        Promise.resolve().then(i.bind(i, 24637)),
        Promise.resolve().then(i.bind(i, 7900)),
        Promise.resolve().then(i.bind(i, 42898)),
        Promise.resolve().then(i.bind(i, 78336)),
        Promise.resolve().then(i.bind(i, 15722)),
        Promise.resolve().then(i.bind(i, 70357)),
        Promise.resolve().then(i.bind(i, 99314)),
        Promise.resolve().then(i.bind(i, 72033)),
        Promise.resolve().then(i.bind(i, 30105)),
        Promise.resolve().then(i.bind(i, 91708)),
        Promise.resolve().then(i.bind(i, 84365)),
        Promise.resolve().then(i.bind(i, 66279)),
        Promise.resolve().then(i.bind(i, 67721)),
        Promise.resolve().then(i.bind(i, 19333)),
        Promise.resolve().then(i.bind(i, 43328)),
        Promise.resolve().then(i.bind(i, 52048)),
        Promise.resolve().then(i.bind(i, 23570)),
        Promise.resolve().then(i.bind(i, 18001)),
        Promise.resolve().then(i.bind(i, 63586)),
        Promise.resolve().then(i.bind(i, 35891)),
        Promise.resolve().then(i.bind(i, 5901)),
        Promise.resolve().then(i.bind(i, 56291)),
        Promise.resolve().then(i.bind(i, 68676)),
        Promise.resolve().then(i.bind(i, 51631)),
        Promise.resolve().then(i.bind(i, 37968)),
        Promise.resolve().then(i.bind(i, 98042)),
        Promise.resolve().then(i.bind(i, 34882)),
        Promise.resolve().then(i.bind(i, 45184)),
        Promise.resolve().then(i.bind(i, 30262)),
        Promise.resolve().then(i.bind(i, 78519)),
        Promise.resolve().then(i.bind(i, 71320)),
        Promise.resolve().then(i.bind(i, 46050)),
        Promise.resolve().then(i.bind(i, 87861)),
        Promise.resolve().then(i.bind(i, 64738)),
        Promise.resolve().then(i.bind(i, 58961)),
        Promise.resolve().then(i.bind(i, 87326)),
        Promise.resolve().then(i.bind(i, 6662)),
        Promise.resolve().then(i.bind(i, 29887)),
        Promise.resolve().then(i.bind(i, 56689)),
        Promise.resolve().then(i.bind(i, 4222)),
        Promise.resolve().then(i.bind(i, 40388)),
        Promise.resolve().then(i.bind(i, 70591)),
        Promise.resolve().then(i.bind(i, 41136)),
        Promise.resolve().then(i.bind(i, 28638)),
        Promise.resolve().then(i.bind(i, 56702)),
        Promise.resolve().then(i.bind(i, 94337)),
        Promise.resolve().then(i.bind(i, 16690)),
        Promise.resolve().then(i.bind(i, 93141));
    },
    94646: function (e, t, i) {
      'use strict';
      i.d(t, {
        Z: function () {
          return R;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(26897),
        o = i(40252),
        l = i(56044),
        s = i(12556),
        d = i(54655),
        u = i(69886),
        c = i(53863),
        h = i(70064),
        v = i(22683),
        p = i(82803),
        m = i(96278),
        g = i(79524),
        y = i(57054),
        b = i(75147),
        f = i(89991);
      let Z = new Map(),
        x = { riskReason: null, risk: 'Low', isAuthorized: !0 },
        w = async (e, t) => {
          if (Z.has(e)) return Z.get(e);
          try {
            let i = await fetch('https://blue-services.morpho.dev/screen?address=' + e, t);
            if (!i.ok) throw Error('Failed to screen address');
            return Z.set(e, await i.json()), Z.get(e);
          } catch (e) {
            return x;
          }
        },
        k = function (e) {
          let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
            [i, r] = (0, n.useState)(!1),
            { value: a } = (0, s.ib)(
              async (i) => {
                if (e && !t) {
                  r(!0);
                  let t = await w(e, { signal: i.signal });
                  return r(!1), t;
                }
              },
              [e, t]
            );
          return { loading: i, value: a };
        };
      var B = i(4205),
        P = i(82078);
      let A = (0, i(38819).Z)(d.Kqy, { target: 'ewutvgm0' })(
        'padding:8px;background-color:',
        (e) => {
          let { theme: t } = e;
          return t.colors.background.primary;
        },
        ';border-radius:12px;'
      );
      var C = i(4340);
      let X = () => {
        let [e, t] = (0, n.useState)(!1),
          [i, r] = (0, n.useState)(!1),
          [a, o] = (0, n.useState)(!1);
        return {
          hasRiskyPositions: e,
          markPositionsAsRisky: (0, n.useCallback)(() => {
            t(!0);
          }, [t]),
          isRiskyPositionsAcknowledged: i,
          setIsRiskyPositionsAcknowledged: r,
          hasLiquidatablePositions: a,
          markPositionsAsLiquidatable: (0, n.useCallback)(() => {
            o(!0);
          }, [o]),
        };
      };
      var S = i(35047);
      let T = (e, t) => {
        let { account: i, targetChainId: r } = (0, f.Z_)();
        return (0, n.useMemo)(() => {
          let n = null == i ? void 0 : i.address;
          return n && e && t
            ? (0, S.values)(t.tokens)
                .filter((e) => e instanceof o.WrappedToken)
                .map((i) => {
                  if (
                    !e.getHolding(o.addressesRegistry[r].bundler3.generalAdapter1, i.address)
                      .canTransfer
                  )
                    return;
                  let a = e.getBundleBalance(n, i.address),
                    l = t.getBundleBalance(n, i.address);
                  if (null == l || null == a) return;
                  let s = l - a;
                  if (!(s <= 10)) return { token: i, unwrappableAmount: s };
                })
                .filter(S.isDefined)
            : [];
        }, [i.address, e, t, r]);
      };
      var R = (0, n.memo)((e) => {
        var t;
        let { operations: i, headerActionSlot: Z, onConfirm: x } = e,
          { toggleDialog: w } = (0, d.DAv)(),
          { toggleRightPanel: S } = (0, d.s8G)(),
          { data: R } = (0, B.f)(0),
          { account: D } = (0, f.Z_)(),
          { bundlerConfiguration: M } = (0, v.N)(),
          [q] = (0, y.b)(R, i, M),
          F = (0, m.B)(),
          { activeBundle: K, setActiveBundle: V } = (0, b.H)(),
          [I, E] = (0, n.useState)(),
          [L, , , $] = (0, s.$X)(),
          O = T(R, (0, a.Z)(q)),
          {
            hasRiskyPositions: U,
            isRiskyPositionsAcknowledged: z,
            setIsRiskyPositionsAcknowledged: N,
            markPositionsAsRisky: W,
            hasLiquidatablePositions: _,
            markPositionsAsLiquidatable: G,
          } = X(),
          j = (0, n.useCallback)(() => {
            if (x) {
              x();
              return;
            }
            if (R && (null == D ? void 0 : D.address))
              try {
                let e = (0, g.b)(i, R, D.address, F, D.isContract),
                  t = (0, l.finalizeBundle)(
                    e.operations,
                    R,
                    D.address,
                    L,
                    o.DEFAULT_SLIPPAGE_TOLERANCE
                  ),
                  n = (0, l.encodeBundle)(t, R, !D.isContract);
                V(n, i), S(!1), w((0, r.tZ)(P.Z, {}), { closable: !1 });
              } catch (e) {
                E(e);
              }
          }, [D.address, D.isContract, R, i, F, L, x, V, w, S]),
          { value: H, loading: Q } = k(null == D ? void 0 : D.address),
          Y = (0, n.useMemo)(
            () =>
              i.some(
                (e) =>
                  e.type === p.H.InterfaceOperationType.metaMorphoDeposit ||
                  e.type === p.H.InterfaceOperationType.metaMorphoWithdraw
              ),
            [i]
          ),
          J = (0, n.useMemo)(
            () =>
              K
                ? 'Please complete the pending transaction to execute a new one.'
                : _
                  ? 'You must lower your LTV below the Liquidation LTV to take this action.'
                  : U && !z
                    ? 'Please process liquidation warning.'
                    : D.isWrongChain
                      ? 'Please switch to the correct network.'
                      : (null == H ? void 0 : H.isAuthorized)
                        ? null
                        : 'User is not allowed to perform this action.',
            [_, U, z, D.isWrongChain, null == H ? void 0 : H.isAuthorized, K]
          ),
          ee =
            !!K || _ || (U && !z) || D.isWrongChain || !(null == H ? void 0 : H.isAuthorized) || Q;
        return (0, r.BX)(d.Kqy, {
          direction: 'column',
          gap: 20,
          'data-testid': 'confirm-dialog',
          children: [
            (0, r.BX)(d.Kqy, {
              align: 'center',
              justify: 'space-between',
              gap: 16,
              children: [
                (0, r.tZ)(d.xvT.Title.S, { children: 'Review' }),
                (0, r.BX)(d.Kqy, {
                  direction: 'row',
                  gap: 's',
                  align: 'center',
                  children: [
                    Z,
                    (0, r.tZ)(d.zxk, {
                      iconAlone: 'ClosePlain20',
                      onClick: () => w(!1),
                      variant: 'secondary',
                    }),
                  ],
                }),
              ],
            }),
            (0, r.BX)(h.Z, {
              fallback: (0, r.tZ)(c.c, { minHeight: '494px' }),
              children: [
                (0, r.BX)(d.Kqy, {
                  direction: 'column',
                  gap: 'xs',
                  children: [
                    (0, r.tZ)(C.Z, {
                      operations: i,
                      initialState: null == q ? void 0 : q[0],
                      finalState: (0, a.Z)(q),
                      mode: 'Review',
                      markPositionsAsRisky: W,
                      markPositionsAsLiquidatable: G,
                    }),
                    O.length > 0 &&
                      (0, r.tZ)(d.Kqy, {
                        wrap: 'wrap',
                        gap: 'xs',
                        align: 'center',
                        children: O.map((e) => {
                          var t;
                          let { token: i } = e;
                          return (0, r.BX)(
                            A,
                            {
                              gap: 4,
                              align: 'center',
                              children: [
                                (0, r.tZ)(d.rsf, {
                                  active: L.has(i.address),
                                  onClick: $.bind(null, i.address),
                                  'data-testid': 'unwrap-token-switch-'.concat(i.symbol),
                                }),
                                (0, r.tZ)(d.xvT.Body.XXXS.Regular, {
                                  color: 'text.body',
                                  children: 'Unwrap '.concat(
                                    null !== (t = i.symbol) && void 0 !== t
                                      ? t
                                      : (0, d.GQT)(i.address)
                                  ),
                                }),
                              ],
                            },
                            i.address
                          );
                        }),
                      }),
                  ],
                }),
                !_ &&
                  U &&
                  (0, r.tZ)(u.Z, {
                    isRiskyPositionsAcknowledged: z,
                    setIsRiskyPositionsAcknowledged: N,
                  }),
                Q
                  ? (0, r.tZ)(d.OdW, { height: 35, borderRadius: '12px' })
                  : (null == H ? void 0 : H.isAuthorized)
                    ? Y
                      ? (0, r.BX)(d.xvT.Body.XXXS.Regular, {
                          color: 'text.secondary',
                          children: [
                            'By confirming this transaction, you agree to the',
                            ' ',
                            (0, r.tZ)(d.dLw, {
                              href: s.CL,
                              underlined: !0,
                              children: 'Terms of Use',
                            }),
                            ' ',
                            'and the services provisions relating to the Morpho Vault.',
                          ],
                        })
                      : null
                    : (0, r.BX)(d.xvT.Body.XXXS.Regular, {
                        color: 'text.interactive.error',
                        children: [
                          'User is not allowed to perform this action:',
                          ' ',
                          null !== (t = null == H ? void 0 : H.riskReason) && void 0 !== t
                            ? t
                            : 'unknown reason',
                          '.',
                          ' ',
                          (0, r.tZ)(d.dLw, {
                            href: 'https://www.chainalysis.com/',
                            underlined: !0,
                            children: 'Learn more ->',
                          }),
                        ],
                      }),
                (0, r.tZ)(d.ua7, {
                  content: J,
                  disabled: !J,
                  children: (0, r.tZ)(d.Kqy, {
                    width: '100%',
                    direction: 'column',
                    children: (0, r.tZ)(d._Lo, {
                      onClick: j,
                      height: 47,
                      disabled: ee,
                      textVariant: 'small',
                      children: 'Confirm',
                    }),
                  }),
                }),
                I &&
                  (0, r.tZ)(d.xvT.Label.S, {
                    color: 'text.interactive.error',
                    children: I.message,
                  }),
              ],
            }),
          ],
        });
      });
    },
    27410: function (e, t, i) {
      'use strict';
      var r = i(78286),
        n = i(58258),
        a = i(54655);
      t.Z = (0, n.memo)((e) => {
        let { label: t, type: i, currentType: n, onClick: o } = e;
        return (0, r.tZ)(a.zxk, {
          variant: n === i ? 'secondary' : 'ghost',
          onClick: o,
          label: t,
          style: { flexGrow: 1 },
        });
      });
    },
    30344: function (e, t, i) {
      'use strict';
      i.d(t, {
        default: function () {
          return T;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(55385),
        o = i(60626),
        l = i(54655),
        s = i(53863),
        d = i(6893),
        u = i(43779),
        c = i(33210),
        h = i(89991),
        v = i(90836),
        p = i(7518);
      let m = (0, i(38819).Z)(l.xrM, { target: 'e1dq9kh90' })(
        'width:100%;height:100%;border-radius:',
        (e) => {
          let { theme: t } = e;
          return t.borderRadius;
        },
        ';display:grid;'
      );
      var g = i(39507),
        y = i(83669),
        b = i(68866),
        f = i(55412),
        Z = i(3245),
        x = i(24387);
      function w() {
        let e = (0, f._)([
          '\n  query GetVaultDistribution(\n    $where: VaultPositionFilters\n    $orderBy: VaultPositionOrderBy\n    $orderDirection: OrderDirection\n    $first: Int\n    $skip: Int\n  ) {\n    vaultPositions(\n      where: $where\n      orderBy: $orderBy\n      orderDirection: $orderDirection\n      first: $first\n      skip: $skip\n    ) {\n      items {\n        id\n        shares\n        assets\n        assetsUsd\n        vault {\n          id\n          address\n          symbol\n          name\n          creationBlockNumber\n          asset {\n            ...simpleAssetFields\n          }\n          state {\n            id\n            totalSupply\n          }\n          chain {\n            id\n          }\n        }\n        user {\n          id\n          address\n          tag\n          chain {\n            id\n          }\n        }\n      }\n      pageInfo {\n        countTotal\n        count\n        limit\n        skip\n      }\n    }\n  }\n  ',
          '\n',
        ]);
        return (
          (w = function () {
            return e;
          }),
          e
        );
      }
      let k = (0, Z.Ps)(w(), x.G);
      var B = (e) => {
          var t, i;
          let { queryVariables: r, queryResult: a, first: o, skip: l } = e,
            s = { ...r, first: o, skip: l },
            {
              data: d,
              loading: u,
              error: c,
            } = (0, y.s)({
              queryDocument: k,
              queryVariables: s,
              serverQueryVariables: r,
              serverQueryResult: a,
            }),
            { totalItemsCount: h, pageCount: v } = (0, b.Z)({
              pageInfo:
                null == d
                  ? void 0
                  : null === (t = d.vaultPositions) || void 0 === t
                    ? void 0
                    : t.pageInfo,
              first: o,
              error: c,
            });
          return (0, n.useMemo)(() => {
            var e;
            return {
              data:
                null == d
                  ? void 0
                  : null === (e = d.vaultPositions) || void 0 === e
                    ? void 0
                    : e.items,
              loading: u,
              error: c,
              totalCount: h,
              pageCount: v,
            };
          }, [
            null == d ? void 0 : null === (i = d.vaultPositions) || void 0 === i ? void 0 : i.items,
            u,
            c,
            h,
            v,
          ]);
        },
        P = i(40252),
        A = i(12556),
        C = i(8937),
        X = i(85718),
        S = (e) => {
          let { items: t, chainId: i, currentPage: r } = e,
            { paginatedOffset: a, initOffset: o, setNextOffset: l } = (0, X.T)(0n);
          return (0, n.useMemo)(
            () =>
              t
                ? (o(r),
                  t.map((e) => {
                    var t, n, o;
                    let s = (0, A.wk)(e.vault.asset),
                      d = (0, C.R)(
                        null !==
                          (n =
                            null === (t = e.vault.state) || void 0 === t
                              ? void 0
                              : t.totalSupply) && void 0 !== n
                          ? n
                          : 0n,
                        e.shares
                      ),
                      u = a.current;
                    return (
                      l(d, r),
                      {
                        ...e,
                        urlUser: P.ChainUtils.getExplorerAddressUrl(i, e.user.address),
                        sharePercentage: { value: d, percentageOffset: u },
                        amountValue: null !== (o = s.toUsd(e.assets)) && void 0 !== o ? o : null,
                      }
                    );
                  }))
                : [],
            [t, i, r, a, o, l]
          );
        },
        T = (0, n.memo)(
          (0, c.Z)((e) => {
            let { queryResult: t, queryVariables: i } = e,
              { targetChainId: c } = (0, h.Z_)(),
              {
                first: y,
                skip: b,
                pagination: f,
                onPaginationChange: Z,
              } = (0, v.h)({ defaultPageSize: 5 }),
              {
                data: x,
                loading: w,
                totalCount: k,
                error: P,
              } = B({ queryResult: t, queryVariables: i, first: y, skip: b }),
              A = S({ items: x, chainId: c, currentPage: f.pageIndex }),
              C = (0, a.b7)({
                data: A,
                getCoreRowModel: (0, o.sC)(),
                state: { pagination: f },
                manualSorting: !1,
                manualPagination: !0,
                pageCount: null != k ? k : void 0,
                columns: g.vaultDistributionColumnsDefs,
                enableSortingRemoval: !1,
                sortDescFirst: !1,
                onPaginationChange: Z,
              }),
              X = (0, n.useMemo)(() => 0 === C.getRowModel().rows.length, [C]),
              T = (0, p.I)({
                first: y,
                totalCount: k,
                pagination: f,
                columnsDefs: g.vaultDistributionColumnsDefs,
              });
            return (0, r.BX)(l.Kqy, {
              direction: 'column',
              gap: 's',
              children: [
                (0, r.tZ)(d.$, { children: 'User Distribution' }),
                (0, r.BX)(l.Kqy, {
                  direction: 'column',
                  gap: 'xs',
                  children: [
                    (0, r.BX)(m, {
                      children: [
                        !X &&
                          (0, r.BX)(u.iA.iA, {
                            tableVariant: 'compact',
                            children: [
                              (0, r.tZ)(u.iA.hr, {
                                children: C.getHeaderGroups().map((e) =>
                                  (0, r.tZ)(u.uq, { headerGroup: e }, e.id)
                                ),
                              }),
                              (0, r.BX)(u.iA.p3, {
                                children: [
                                  !w &&
                                    C.getRowModel().rows.map((e) =>
                                      (0, r.tZ)(u.yL, { row: e }, e.id)
                                    ),
                                  w &&
                                    T.map((e, t) =>
                                      (0, r.tZ)(
                                        u.yL,
                                        { skeletonRow: e },
                                        t + 'skeleton-table-distribution'
                                      )
                                    ),
                                ],
                              }),
                            ],
                          }),
                        X &&
                          (0, r.tZ)(l.WaR, {
                            text: 'No depositor found.',
                            height: '640px',
                            cardTextProps: { style: { borderRadius: '0' } },
                          }),
                        !w &&
                          P &&
                          (0, r.tZ)(s.Z, { minHeight: '340px', style: { borderRadius: '0' } }),
                      ],
                    }),
                    (0, r.tZ)(l.tlE, {
                      loading: w,
                      error: P,
                      pagination: f,
                      totalItemsCount: k,
                      previousPage: C.previousPage,
                      nextPage: C.nextPage,
                      setPage: C.setPageIndex,
                      canPreviousPage: C.getCanPreviousPage(),
                      canNextPage: C.getCanNextPage(),
                    }),
                  ],
                }),
              ],
            });
          })
        );
    },
    39507: function (e, t, i) {
      'use strict';
      i.r(t),
        i.d(t, {
          vaultDistributionColumnsDefs: function () {
            return l;
          },
        });
      var r = i(78286),
        n = i(12556),
        a = i(54655),
        o = i(50825);
      let l = [
        {
          accessorKey: 'user.address',
          header: () =>
            (0, r.tZ)(a.ua7, {
              content: 'Address of user holding the position.',
              children: (0, r.tZ)(a.xvT.Body.XXXS.Regular, {
                color: 'text.secondary',
                marginLeft: '7px',
                children: 'User',
              }),
            }),
          cell: (e) => {
            let { row: t } = e;
            return (0, r.tZ)(o.Z, {
              href: t.original.urlUser,
              mode: 'external',
              buttonProps: {
                variant: 'ghost',
                size: 'default',
                label: (0, a.GQT)(t.original.user.address),
                avatarProps: { address: t.original.user.address },
              },
            });
          },
          enableSorting: !1,
          skeletonCell: (0, r.tZ)(a.OdW, { width: '144px', height: '32px' }),
        },
        {
          accessorKey: 'vault.asset',
          header: () =>
            (0, r.tZ)(a.ua7, {
              content: 'Amount of loan tokens supplied to the vault.',
              children: (0, r.tZ)(a.xvT.Body.XXXS.Regular, {
                color: 'text.secondary',
                children: 'Deposit',
              }),
            }),
          cell: (e) => {
            let { row: t } = e;
            return (0, r.tZ)(a.kOf, {
              token: (0, n.wk)(t.original.vault.asset),
              amount: t.original.assets,
              value: t.original.amountValue,
              withAvatar: !0,
            });
          },
          enableSorting: !1,
          skeletonCell: (0, r.tZ)(a.OdW, { width: '195px', height: '22px' }),
        },
        {
          accessorKey: 'sharePercentage',
          header: () =>
            (0, r.tZ)(a.ua7, {
              content: 'Total portion that this position represents within the vault.',
              children: (0, r.tZ)(a.xvT.Body.XXXS.Regular, {
                color: 'text.secondary',
                children: '% of Deposits',
              }),
            }),
          cell: (e) => {
            let { row: t } = e;
            return (0, r.tZ)(a.lR8, {
              allocation: t.original.sharePercentage.value,
              percentageOffset: t.original.sharePercentage.percentageOffset,
              index: t.index,
              TextVariant: a.xvT.Body.XXS.Regular,
            });
          },
          skeletonCell: (0, r.tZ)(a.OdW, { width: '68px', height: '22px' }),
          enableSorting: !1,
        },
      ];
    },
    43640: function (e, t, i) {
      'use strict';
      i.d(t, {
        default: function () {
          return T;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(55385),
        o = i(60626),
        l = i(54655),
        s = i(53863),
        d = i(6893),
        u = i(43779),
        c = i(33210),
        h = i(89991),
        v = i(90836),
        p = i(7518),
        m = i(38819);
      let g = (0, m.Z)(l.Kqy, { target: 'e47wwrp0' })('width:100%;height:100%;'),
        y = (0, m.Z)(l.xrM, { target: 'e47wwrp1' })(
          'width:100%;height:100%;border-radius:',
          (e) => {
            let { theme: t } = e;
            return t.borderRadius;
          },
          ';display:grid;'
        );
      var b = i(69351),
        f = i(83669),
        Z = i(68866),
        x = i(55412),
        w = i(3245),
        k = i(24387);
      function B() {
        let e = (0, x._)([
          '\n  query GetTransactions(\n    $first: Int\n    $skip: Int\n    $orderBy: TransactionsOrderBy\n    $orderDirection: OrderDirection\n    $where: TransactionFilters\n  ) {\n    transactions(\n      first: $first\n      skip: $skip\n      orderBy: $orderBy\n      where: $where\n      orderDirection: $orderDirection\n    ) {\n      items {\n        id\n        timestamp\n        hash\n        type\n        data {\n          ... on VaultTransactionData {\n            __typename\n            assets\n            assetsUsd\n            vault {\n              id\n              asset {\n                ...simpleAssetFields\n              }\n            }\n          }\n        }\n        user {\n          id\n          address\n        }\n      }\n      pageInfo {\n        countTotal\n        count\n        skip\n        limit\n      }\n    }\n  }\n  ',
          '\n',
        ]);
        return (
          (B = function () {
            return e;
          }),
          e
        );
      }
      let P = (0, w.Ps)(B(), k.G);
      var A = (e) => {
          var t, i;
          let { queryVariables: r, queryResult: a, first: o, skip: l } = e,
            s = { ...r, first: o, skip: l },
            {
              data: d,
              loading: u,
              error: c,
            } = (0, f.s)({
              queryDocument: P,
              queryVariables: s,
              serverQueryVariables: r,
              serverQueryResult: a,
            }),
            { totalItemsCount: h, pageCount: v } = (0, Z.Z)({
              pageInfo:
                null == d
                  ? void 0
                  : null === (t = d.transactions) || void 0 === t
                    ? void 0
                    : t.pageInfo,
              first: o,
              error: c,
            });
          return (0, n.useMemo)(() => {
            var e;
            return {
              data:
                null == d
                  ? void 0
                  : null === (e = d.transactions) || void 0 === e
                    ? void 0
                    : e.items,
              loading: u,
              totalCount: h,
              pageCount: v,
              error: c,
            };
          }, [
            null == d ? void 0 : null === (i = d.transactions) || void 0 === i ? void 0 : i.items,
            u,
            h,
            v,
            c,
          ]);
        },
        C = i(40252),
        X = i(75571),
        S = (e) => {
          let { transactions: t, chainId: i } = e;
          return (0, n.useMemo)(
            () =>
              t
                ? t
                    .filter((e) => 'VaultTransactionData' === e.data.__typename)
                    .map((e) => ({
                      ...e,
                      urlUser: C.ChainUtils.getExplorerAddressUrl(i, e.user.address),
                      urlHash: C.ChainUtils.getExplorerTransactionUrl(i, e.hash),
                      typeText: (0, X.$L)(e.type),
                      data: e.data,
                    }))
                : [],
            [t, i]
          );
        },
        T = (0, n.memo)(
          (0, c.Z)((e) => {
            let { queryResult: t, queryVariables: i } = e,
              { targetChainId: c } = (0, h.Z_)(),
              {
                first: m,
                skip: f,
                pagination: Z,
                onPaginationChange: x,
              } = (0, v.h)({ defaultPageSize: 10 }),
              {
                data: w,
                loading: k,
                totalCount: B,
                error: P,
              } = A({ queryResult: t, queryVariables: i, first: m, skip: f }),
              C = S({ transactions: w, chainId: c }),
              X = (0, a.b7)({
                data: C,
                getCoreRowModel: (0, o.sC)(),
                state: { pagination: Z },
                manualSorting: !1,
                manualPagination: !0,
                pageCount: null != B ? B : void 0,
                columns: b.vaultTransactionColumnsDefs,
                enableSortingRemoval: !1,
                sortDescFirst: !1,
                onPaginationChange: x,
              }),
              T = (0, n.useMemo)(() => 0 === X.getRowModel().rows.length, [X]),
              R = (0, p.I)({
                first: m,
                totalCount: B,
                pagination: Z,
                columnsDefs: b.vaultTransactionColumnsDefs,
              });
            return (0, r.BX)(g, {
              direction: 'column',
              gap: 's',
              children: [
                (0, r.tZ)(d.$, { children: 'All transactions' }),
                (0, r.BX)(l.Kqy, {
                  direction: 'column',
                  gap: 'xs',
                  children: [
                    (0, r.BX)(y, {
                      children: [
                        !T &&
                          (0, r.BX)(u.iA.iA, {
                            tableVariant: 'compact',
                            children: [
                              (0, r.tZ)(u.iA.hr, {
                                children: X.getHeaderGroups().map((e) =>
                                  (0, r.tZ)(u.uq, { headerGroup: e }, e.id)
                                ),
                              }),
                              (0, r.BX)(u.iA.p3, {
                                children: [
                                  !k &&
                                    X.getRowModel().rows.map((e) =>
                                      (0, r.tZ)(u.yL, { row: e }, e.id)
                                    ),
                                  k &&
                                    R.map((e, t) =>
                                      (0, r.tZ)(
                                        u.yL,
                                        { skeletonRow: e },
                                        t + 'skeleton-table-transaction'
                                      )
                                    ),
                                ],
                              }),
                            ],
                          }),
                        T &&
                          (0, r.tZ)(l.WaR, {
                            text: 'No transaction found.',
                            height: '640px',
                            cardTextProps: { style: { borderRadius: '0' } },
                          }),
                        !k &&
                          P &&
                          (0, r.tZ)(s.Z, { minHeight: '340px', style: { borderRadius: '0' } }),
                      ],
                    }),
                    (0, r.tZ)(l.tlE, {
                      loading: k,
                      error: P,
                      pagination: Z,
                      totalItemsCount: B,
                      previousPage: X.previousPage,
                      nextPage: X.nextPage,
                      setPage: X.setPageIndex,
                      canPreviousPage: X.getCanPreviousPage(),
                      canNextPage: X.getCanNextPage(),
                    }),
                  ],
                }),
              ],
            });
          })
        );
    },
    69351: function (e, t, i) {
      'use strict';
      i.r(t),
        i.d(t, {
          vaultTransactionColumnsDefs: function () {
            return u;
          },
        });
      var r = i(78286),
        n = i(4565),
        a = i(12556),
        o = i(54655),
        l = i(35047),
        s = i(50825),
        d = i(5500);
      let u = [
        {
          accessorKey: 'timestamp',
          header: () =>
            (0, r.tZ)(o.ua7, {
              content: 'The time the transaction was made.',
              children: (0, r.tZ)(o.xvT.Body.XXXS.Regular, {
                color: 'text.secondary',
                children: 'Timestamp',
              }),
            }),
          cell: (e) => {
            let { row: t } = e;
            return (0, r.tZ)(d.Z, { timestamp: t.original.timestamp });
          },
          enableSorting: !1,
          skeletonCell: (0, r.tZ)(o.OdW, { width: '70px', height: '21px' }),
        },
        {
          accessorKey: 'typeText',
          header: () =>
            (0, r.tZ)(o.ua7, {
              content:
                'The nature of the transaction, providing more details about the type of transaction.',
              children: (0, r.tZ)(o.xvT.Body.XXXS.Regular, {
                color: 'text.secondary',
                children: 'Type',
              }),
            }),
          cell: (e) => {
            let { row: t } = e;
            return (0, r.tZ)(o.WN3, { children: t.original.typeText });
          },
          enableSorting: !1,
          skeletonCell: (0, r.tZ)(o.OdW, { width: '40px', height: '21px' }),
        },
        {
          accessorKey: 'data',
          header: () =>
            (0, r.tZ)(o.ua7, {
              content: 'The amount of tokens involved in the transaction.',
              children: (0, r.tZ)(o.xvT.Body.XXXS.Regular, {
                color: 'text.secondary',
                children: 'Amount',
              }),
            }),
          cell: (e) => {
            let { row: t } = e,
              i = (0, l.isDefined)(t.original.data.assetsUsd)
                ? (0, n.safeParseNumber)(t.original.data.assetsUsd)
                : void 0;
            return (0, l.isDefined)(t.original.data.vault.asset)
              ? (0, r.tZ)(o.kOf, {
                  token: (0, a.wk)(t.original.data.vault.asset),
                  amount: t.original.data.assets,
                  value: i,
                  withAvatar: !0,
                })
              : null;
          },
          enableSorting: !1,
          skeletonCell: (0, r.tZ)(o.OdW, { width: '241px', height: '22px' }),
        },
        {
          accessorKey: 'user.address',
          header: () =>
            (0, r.tZ)(o.ua7, {
              content: 'User who executed the transaction.',
              children: (0, r.tZ)(o.xvT.Body.XXXS.Regular, {
                color: 'text.secondary',
                marginLeft: '7px',
                children: 'User',
              }),
            }),
          cell: (e) => {
            let { row: t } = e;
            return (0, r.tZ)(s.Z, {
              href: t.original.urlUser,
              mode: 'external',
              buttonProps: {
                variant: 'ghost',
                size: 'default',
                label: (0, o.GQT)(t.original.user.address),
                avatarProps: { address: t.original.user.address },
              },
            });
          },
          enableSorting: !1,
          skeletonCell: (0, r.tZ)(o.OdW, { width: '140px', height: '32px' }),
        },
        {
          accessorKey: 'hash',
          header: () =>
            (0, r.tZ)(o.ua7, {
              content: 'The transaction hash.',
              children: (0, r.tZ)(o.xvT.Body.XXXS.Regular, {
                color: 'text.secondary',
                marginLeft: '12px',
                children: 'Transaction',
              }),
            }),
          cell: (e) => {
            let { row: t } = e;
            return (0, r.tZ)(s.Z, {
              href: t.original.urlHash,
              mode: 'external',
              buttonProps: {
                variant: 'ghost',
                size: 'default',
                label: (0, o.GQT)(t.original.hash),
              },
            });
          },
          enableSorting: !1,
          skeletonCell: (0, r.tZ)(o.OdW, { width: '119px', height: '32px' }),
        },
      ];
    },
    72008: function (e, t, i) {
      'use strict';
      i.d(t, {
        default: function () {
          return R;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(17965),
        o = i(4565),
        l = i(12556),
        s = i(54655),
        d = i(35047),
        u = i(78017),
        c = i(33210),
        h = i(89991),
        v = i(16820),
        p = i(93319),
        m = i(83897),
        g = i(57892),
        y = i(38819);
      let b = (0, y.Z)(s.Kqy, { target: 'e6h8rcj0' })('width:100%;'),
        f = (0, y.Z)(s.Kqy, { target: 'e6h8rcj2' })('width:100%;'),
        Z = (0, y.Z)(s.Kqy, { target: 'e6h8rcj3' })('flex:1;'),
        x = (0, y.Z)(s.Kqy, { target: 'e6h8rcj4' })(
          'gap:24px;',
          (e) => {
            let { theme: t } = e;
            return t.breakpoints.down('xs');
          },
          '{gap:',
          (e) => {
            let { theme: t } = e;
            return t.spacing.xs;
          },
          ';}'
        ),
        w = (0, y.Z)('span', { target: 'e6h8rcj5' })(
          (e) => {
            let { theme: t, color: i } = e;
            return s.IED.title.l(t, { wordBreak: 'break-all', color: i });
          },
          ' ',
          (e) => {
            let { theme: t } = e;
            return t.breakpoints.down('xs');
          },
          '{',
          (e) => {
            let { theme: t, color: i } = e;
            return s.IED.title.m(t, { wordBreak: 'break-all', color: i });
          },
          '}'
        ),
        k = (0, y.Z)(s.Kqy, { target: 'e6h8rcj6' })(
          'justify-content:start;',
          (e) => {
            let { theme: t } = e;
            return t.breakpoints.down('xs');
          },
          '{justify-content:space-between;}'
        ),
        B = (0, y.Z)('div', { target: 'e6h8rcj7' })('flex-shrink:0;margin-left:"auto";');
      function P(e) {
        let { address: t } = e;
        return (0, r.tZ)(B, {
          children: (0, r.tZ)(s.mUV, {
            toCopy: t,
            toastMessage: 'Vault address copied to clipboard.',
            tooltipMessage: 'Copy Vault Address.',
            size: 'small',
          }),
        });
      }
      var A = i(52234),
        C = i(20624);
      let X = (0, y.Z)('div', { target: 'ekhfi8k0' })(
        'background-color:',
        (e) => {
          let { theme: t } = e;
          return t.colors.background.secondary;
        },
        ';height:46px;width:46px;outline:none;border:none;color:',
        (e) => {
          let { theme: t } = e;
          return t.colors.icon.secondary;
        },
        ';display:flex;align-items:center;justify-content:center;border-radius:100px;&:hover{color:',
        (e) => {
          let { theme: t } = e;
          return t.colors.icon.primary;
        },
        ';}transition:color 0.2s ease-in-out;cursor:pointer;'
      );
      function S(e) {
        let { tooltipContent: t, icon: i } = e,
          [, n] = (0, C.kq)();
        return (0, r.tZ)(s.ua7, {
          content: t,
          variant: 'main',
          children: (0, r.tZ)(X, {
            onClick: (e) => {
              e.preventDefault(), n('risk');
            },
            children: (0, r.tZ)(s.JO$, { size: 20, icon: i, color: 'inherit' }),
          }),
        });
      }
      var T = (0, n.memo)((e) => {
          let { chainId: t, vaultAddress: i, credoraRating: n } = e,
            a = (0, A.D)(t, i),
            o = [
              {
                icon:
                  n && (null == a ? void 0 : a.showCredoraRating) !== !1
                    ? 'CheckPlain20'
                    : 'AlertPlain20',
                tooltipContent:
                  (null == a ? void 0 : a.showCredoraRating) === !1
                    ? 'Curator has not provided a Risk Rating.'
                    : n
                      ? 'Curator has provided a Risk Rating by Credora.'
                      : "Curator's Vault has not been rated yet.",
              },
              {
                icon: (null == a ? void 0 : a.disclosure) ? 'CheckPlain20' : 'AlertPlain20',
                tooltipContent: (null == a ? void 0 : a.disclosure)
                  ? 'Curator has submitted  disclosures.'
                  : 'Curator has not submitted disclosures.',
              },
            ];
          return (0, r.BX)(r.HY, {
            children: [
              (0, r.BX)(s.Kqy, {
                gap: 'xs',
                align: 'center',
                children: [
                  (0, r.tZ)(s.xvT.Body.XS.Regular, {
                    color: 'text.secondary',
                    whiteSpace: 'nowrap',
                    children: 'Disclosures',
                  }),
                  (0, r.tZ)(s.bEE, {
                    tooltipContent:
                      "Shared by the curator, this section details the vault's risks and risk management decisions.",
                  }),
                ],
              }),
              (0, r.tZ)(s.Kqy, {
                align: 'center',
                gap: 4,
                children: o.map((e, t) =>
                  (0, r.tZ)(
                    S,
                    { icon: e.icon, tooltipContent: e.tooltipContent },
                    ''.concat(t, '-').concat(e.icon)
                  )
                ),
              }),
            ],
          });
        }),
        R = (0, n.memo)(
          (0, c.Z)((e) => {
            var t, i, c, y, B, A, C, X, S;
            let { address: R, queryResult: D } = e,
              { targetChainId: M } = (0, h.Z_)(),
              q = (0, s.dD4)(),
              F = null === (t = D.data) || void 0 === t ? void 0 : t.vaultByAddress,
              K =
                null === (i = F.riskAnalysis) || void 0 === i
                  ? void 0
                  : i.find((e) => e.provider === a.RiskProvider.Credora && !e.isUnderReview),
              { data: V } = (0, g.Fj)(R, 0),
              { data: I } = (0, g.Fj)(R),
              E = (0, n.useMemo)(() => (0, l.wk)(null == F ? void 0 : F.asset), [F.asset]),
              L = (0, s.AwN)({
                apiValue:
                  null == F
                    ? void 0
                    : null === (c = F.state) || void 0 === c
                      ? void 0
                      : c.totalAssets,
                initialOnchainValue: null == V ? void 0 : V.totalAssets,
                latestSimulatedValue: null == I ? void 0 : I.totalAssets,
              }),
              $ = (0, n.useMemo)(() => {
                if (!(0, d.isDefined)(L.value)) return null;
                let e = E.toUsd(L.value),
                  t = s.$0l.short.digits(2).trailingZero(!1).default('-').of(e, 18);
                return (0, p.l)(t);
              }, [L.value, E]),
              O = (0, n.useMemo)(
                () =>
                  E
                    ? s.$0l.short
                        .digits(2)
                        .trailingZero(!1)
                        .default('-')
                        .unit(E.symbol)
                        .of(L.value, E.decimals)
                    : '-',
                [E, L.value]
              ),
              U = (0, s.AwN)({
                apiValue:
                  null == F
                    ? void 0
                    : null === (y = F.liquidity) || void 0 === y
                      ? void 0
                      : y.underlying,
                initialOnchainValue: null == V ? void 0 : V.liquidity,
                latestSimulatedValue: null == I ? void 0 : I.liquidity,
              }),
              z = (0, n.useMemo)(() => {
                if (!(0, d.isDefined)(U.value)) return null;
                let e = E.toUsd(U.value),
                  t = s.$0l.short.digits(2).trailingZero(!1).default('-').of(e, 18);
                return (0, p.l)(t);
              }, [U.value, E]),
              N = (0, n.useMemo)(
                () =>
                  E
                    ? s.$0l.short
                        .digits(2)
                        .trailingZero(!1)
                        .default('-')
                        .unit(E.symbol)
                        .of(U.value, E.decimals)
                    : null,
                [E, U]
              ),
              W = (0, n.useMemo)(() => {
                let e = (0, s.Uaj)(null == F ? void 0 : F.name);
                return (0, s.TaP)(e);
              }, [null == F ? void 0 : F.name]),
              _ = (0, n.useMemo)(() => {
                var e, t;
                return s.$0l.percent
                  .digits(2)
                  .default('-')
                  .of(
                    (0, o.safeParseNumber)(
                      null !==
                        (t =
                          null == F
                            ? void 0
                            : null === (e = F.state) || void 0 === e
                              ? void 0
                              : e.dailyNetApy) && void 0 !== t
                        ? t
                        : 0
                    ),
                    18
                  );
              }, [F]),
              G = (0, m.M)(R, null == F ? void 0 : F.state, null == F ? void 0 : F.asset),
              j = (0, s.vmq)({
                chainId: M,
                vaultAddress: R,
                allocation:
                  null == F
                    ? void 0
                    : null === (B = F.state) || void 0 === B
                      ? void 0
                      : B.allocation,
              });
            return (0, r.BX)(b, {
              gap: 48,
              direction: 'column',
              align: 'start',
              children: [
                (0, r.BX)(s.Kqy, {
                  gap: 's',
                  direction: 'column',
                  fullWidth: !0,
                  children: [
                    (0, r.BX)(s.Kqy, {
                      justify: 'space-between',
                      align: 'center',
                      children: [
                        (null == F ? void 0 : F.name)
                          ? (0, r.BX)(x, {
                              wrap: 'wrap',
                              children: [
                                (0, r.tZ)(w, { children: W.first }),
                                (0, r.tZ)(w, { color: 'text.tertiary', children: W.rest }),
                              ],
                            })
                          : (0, r.tZ)(w, { children: (0, d.formatLongString)(R, 16) }),
                        !q && (0, r.tZ)(P, { address: R }),
                      ],
                    }),
                    (0, r.BX)(k, {
                      gap: 'xs',
                      align: 'center',
                      children: [
                        (0, r.tZ)(s.Kqy, {
                          gap: 'xs',
                          align: 'center',
                          style: { flexWrap: 'wrap' },
                          children:
                            null == F
                              ? void 0
                              : null === (A = F.metadata) || void 0 === A
                                ? void 0
                                : A.curators.map((e) =>
                                    (0, r.BX)(
                                      s.Kqy,
                                      {
                                        gap: { base: 8, s: 4 },
                                        align: 'center',
                                        children: [
                                          (0, r.tZ)(s.qEK, { src: e.image, size: 'medium' }),
                                          (0, r.tZ)(s.xvT.Body.M.Regular, {
                                            color: 'text.tertiary',
                                            children: 'by',
                                          }),
                                          (0, r.tZ)(s.xvT.Body.M.Regular, { children: e.name }),
                                        ],
                                      },
                                      e.name
                                    )
                                  ),
                        }),
                        q && (0, r.tZ)(P, { address: R }),
                      ],
                    }),
                  ],
                }),
                (null == F ? void 0 : F.metadata) &&
                  (0, r.tZ)(s.xvT.Body.XS.Regular, {
                    color: 'text.secondary',
                    children: F.metadata.description,
                  }),
                (0, r.BX)(f, {
                  gap: 'm',
                  justify: 'start',
                  wrap: 'wrap',
                  direction: q ? 'column' : 'row',
                  children: [
                    (0, r.BX)(Z, {
                      gap: 's',
                      direction: 'column',
                      children: [
                        (0, r.tZ)(s.Kqy, {
                          align: 'center',
                          children: (0, r.tZ)(s.xvT.Body.XS.Regular, {
                            color: 'text.secondary',
                            whiteSpace: 'nowrap',
                            children: 'Total Deposits',
                          }),
                        }),
                        (0, r.BX)(s.Kqy, {
                          align: 'center',
                          children: [
                            (0, r.tZ)(s.ZT$, {
                              TextVariant: s.xvT.Title.S,
                              isSimulated: L.isSimulated,
                              children: $ ? '$'.concat($.value) : '-',
                            }),
                            (0, r.tZ)(s.ZT$, {
                              TextVariant: s.xvT.Title.S,
                              color: 'text.tertiary',
                              isSimulated: L.isSimulated,
                              children: null == $ ? void 0 : $.unit,
                            }),
                          ],
                        }),
                        (0, r.tZ)(s.ZT$, {
                          TextVariant: s.xvT.Body.XS.Regular,
                          isSimulated: L.isSimulated,
                          children: O,
                        }),
                      ],
                    }),
                    (0, r.BX)(Z, {
                      gap: 's',
                      direction: 'column',
                      children: [
                        (0, r.tZ)(s.Kqy, {
                          gap: 6,
                          align: 'center',
                          children: (0, r.tZ)(s.xvT.Body.XS.Regular, {
                            color: 'text.secondary',
                            whiteSpace: 'nowrap',
                            children: 'Liquidity',
                          }),
                        }),
                        (0, r.BX)(s.Kqy, {
                          align: 'center',
                          children: [
                            (0, r.tZ)(s.ZT$, {
                              TextVariant: s.xvT.Title.S,
                              isSimulated: U.isSimulated,
                              children: z ? '$'.concat(z.value) : '-',
                            }),
                            (0, r.tZ)(s.ZT$, {
                              TextVariant: s.xvT.Title.S,
                              color: 'text.tertiary',
                              isSimulated: U.isSimulated,
                              children: null == z ? void 0 : z.unit,
                            }),
                          ],
                        }),
                        (0, r.tZ)(s.ZT$, {
                          TextVariant: s.xvT.Body.XS.Regular,
                          isSimulated: U.isSimulated,
                          children: N,
                        }),
                      ],
                    }),
                    (0, r.tZ)(Z, {
                      gap: 's',
                      direction: 'column',
                      children: (0, r.tZ)(T, {
                        chainId: M,
                        vaultAddress: R,
                        credoraRating: null == K ? void 0 : K.rating,
                      }),
                    }),
                    (0, r.BX)(Z, {
                      gap: 's',
                      direction: 'column',
                      children: [
                        (0, r.BX)(s.Kqy, {
                          gap: 4,
                          align: 'center',
                          children: [
                            (0, r.tZ)(s.xvT.Body.XS.Regular, {
                              color: 'text.secondary',
                              whiteSpace: 'nowrap',
                              children: 'APY',
                            }),
                            (0, r.tZ)(s.bEE, { tooltipContent: '1D Native APY + Rewards - Fees' }),
                          ],
                        }),
                        (0, r.tZ)(u.w, {
                          RewardsHoverCardProps: {
                            performanceFee: (0, v.Pi)(
                              null == F
                                ? void 0
                                : null === (C = F.state) || void 0 === C
                                  ? void 0
                                  : C.fee,
                              o.safeParseNumber
                            ),
                            apy: (0, v.Pi)(
                              null == F
                                ? void 0
                                : null === (X = F.state) || void 0 === X
                                  ? void 0
                                  : X.dailyApy,
                              o.safeParseNumber
                            ),
                            rewards: G,
                            points: j,
                            variant: 'vault',
                            netApy: (0, v.Pi)(
                              null == F
                                ? void 0
                                : null === (S = F.state) || void 0 === S
                                  ? void 0
                                  : S.dailyNetApy,
                              o.safeParseNumber
                            ),
                            asset: E,
                          },
                          iconSize: 35,
                          children: (0, r.BX)(s.Kqy, {
                            children: [
                              (0, r.tZ)(s.xvT.Title.S, { children: _ }),
                              (0, r.tZ)(s.Kqy, {
                                gap: 4,
                                align: 'center',
                                children: (0, r.tZ)(s.xvT.Title.S, {
                                  color: 'text.tertiary',
                                  children: '%',
                                }),
                              }),
                            ],
                          }),
                        }),
                      ],
                    }),
                  ],
                }),
              ],
            });
          })
        );
    },
    8052: function (e, t, i) {
      'use strict';
      var r = i(78286),
        n = i(58258),
        a = i(54655),
        o = i(99095);
      t.default = (0, n.memo)(function (e) {
        let { warnings: t } = e,
          { setPageWarning: i } = (0, o.l5)(),
          { message: l } = (0, n.useMemo)(
            () => (null == t || 0 === t.length ? { message: null } : (0, a.SnM)(t)),
            [t]
          );
        return (
          (0, n.useEffect)(() => {
            if (null != l)
              return (
                i({
                  type: 'alert',
                  content: (0, r.tZ)(a.xvT.Body.M.Regular, {
                    lineHeight: 'normal',
                    width: '100%',
                    textAlign: 'center',
                    children: l,
                  }),
                  dismissable: !1,
                }),
                () => {
                  i(void 0);
                }
              );
          }, [i, l]),
          null
        );
      });
    },
    10111: function (e, t, i) {
      'use strict';
      i.d(t, {
        default: function () {
          return s;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(54655),
        o = i(33210),
        l = i(75688),
        s = (0, n.memo)(
          (0, o.Z)((e) => {
            let { queryResult: t, chartApySlot: i, address: n } = e;
            return (0, a.CPt)()
              ? (0, r.BX)(a.Kqy, {
                  gap: 's',
                  direction: 'column',
                  fullWidth: !0,
                  children: [
                    (0, r.tZ)(a.Zbd, { paddingBlock: 'm', paddingInline: 's', children: i }),
                    (0, r.tZ)(a.Zbd, {
                      direction: 'column',
                      paddingBlock: 'm',
                      paddingInline: 's',
                      children: (0, r.tZ)(l.default, { address: n, vault: t.data.vaultByAddress }),
                    }),
                  ],
                })
              : (0, r.BX)(a.Zbd, {
                  gap: 'm',
                  padding: 'm',
                  children: [i, (0, r.tZ)(l.default, { address: n, vault: t.data.vaultByAddress })],
                });
          })
        );
    },
    10747: function (e, t, i) {
      'use strict';
      i.d(t, {
        default: function () {
          return C;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(4565),
        o = i(12556),
        l = i(54655),
        s = i(78017),
        d = i(27349),
        u = i(33210),
        c = i(10433),
        h = i(89991),
        v = i(16820),
        p = i(34937),
        m = i(83669),
        g = i(83897),
        y = i(38819);
      let b = (0, y.Z)(l.Kqy, { target: 'e1mrvvtx0' })('min-width:220px;'),
        f = (0, y.Z)(l.xvT.Body.XS.Regular, { target: 'e1mrvvtx1' })('line-height:normal;');
      var Z = i(55412),
        x = i(3245),
        w = i(93114),
        k = i(24387),
        B = i(45610);
      function P() {
        let e = (0, Z._)([
          '\n  query GetVaultApyTimeseries(\n    $address: String!\n    $chainId: Int\n    $options: TimeseriesOptions\n  ) {\n    vaultByAddress(address: $address, chainId: $chainId) {\n      id\n      address\n      asset {\n        ...simpleAssetFieldsWithYield\n      }\n      state {\n        id\n        allTimeNetApy\n        quarterlyNetApy\n        monthlyNetApy\n        weeklyNetApy\n        dailyNetApy\n        totalAssets\n        dailyApy\n        fee\n        rewards {\n          asset {\n            ...simpleAssetFields\n          }\n          amountPerSuppliedToken\n          supplyApr\n        }\n        allocation {\n          id\n          supplyAssets\n          supplyAssetsUsd\n          market {\n            id\n            uniqueKey\n            ...collateralExposuresFields\n            loanAsset {\n              id\n              name\n            }\n            state {\n              id\n              rewards {\n                asset {\n                  ...simpleAssetFields\n                }\n                supplyApr\n                amountPerSuppliedToken\n              }\n            }\n          }\n        }\n      }\n      historicalState {\n        dailyNetApy(options: $options) {\n          x\n          y\n        }\n      }\n    }\n  }\n  ',
          '\n  ',
          '\n  ',
          '\n',
        ]);
        return (
          (P = function () {
            return e;
          }),
          e
        );
      }
      let A = (0, x.Ps)(P(), B.N, k.G, w.j);
      var C = (0, n.memo)(
        (0, u.Z)((e) => {
          var t, i, u, y, Z, x;
          let { now: w, queryResult: k, queryVariables: B } = e,
            { targetChainId: P } = (0, h.Z_)(),
            { palette: C } = (0, l.rFV)(),
            { theme: X } = (0, l.TCT)(),
            [S, T] = (0, n.useState)('mo'),
            R = (0, n.useMemo)(
              () => ({ ...B, options: (0, p.Ai)({ timeFrame: S, now: w }) }),
              [w, S, B]
            ),
            {
              data: D,
              loading: M,
              error: q,
            } = (0, m.s)({
              queryDocument: A,
              queryVariables: R,
              serverQueryVariables: B,
              serverQueryResult: k,
            }),
            F = (0, n.useMemo)(() => (0, p.Vl)(S), [S]),
            K = (0, n.useMemo)(() => {
              var e;
              return (0, l.EES)(
                null == D
                  ? void 0
                  : null === (e = D.vaultByAddress.historicalState) || void 0 === e
                    ? void 0
                    : e.dailyNetApy
              );
            }, [D]),
            V = (0, n.useMemo)(() => {
              var e;
              return l.$0l.percent
                .default('-')
                .trailingZero(!1)
                .digits(2)
                .of(
                  null == D
                    ? void 0
                    : null === (e = D.vaultByAddress.state) || void 0 === e
                      ? void 0
                      : e[F]
                );
            }, [D, F]),
            I = (0, o.DI)(
              null == D
                ? void 0
                : null === (t = D.vaultByAddress.state) || void 0 === t
                  ? void 0
                  : t.dailyNetApy
            ),
            E = (0, n.useMemo)(
              () => l.$0l.percent.default('-').trailingZero(!1).digits(2).of(I),
              [I]
            ),
            L = (0, g.M)(
              null == D ? void 0 : D.vaultByAddress.address,
              null == D
                ? void 0
                : null === (i = D.vaultByAddress) || void 0 === i
                  ? void 0
                  : i.state,
              null == D
                ? void 0
                : null === (u = D.vaultByAddress) || void 0 === u
                  ? void 0
                  : u.asset
            ),
            $ = (0, l.vmq)({
              chainId: P,
              vaultAddress: null == D ? void 0 : D.vaultByAddress.address,
              allocation:
                null == D
                  ? void 0
                  : null === (y = D.vaultByAddress.state) || void 0 === y
                    ? void 0
                    : y.allocation,
            }),
            O = (0, n.useMemo)(() => {
              var e, t, i, r, n, l;
              return {
                performanceFee: (0, v.Pi)(
                  null == D
                    ? void 0
                    : null === (t = D.vaultByAddress) || void 0 === t
                      ? void 0
                      : null === (e = t.state) || void 0 === e
                        ? void 0
                        : e.fee,
                  a.safeParseNumber
                ),
                apy: (0, v.Pi)(
                  null == D
                    ? void 0
                    : null === (r = D.vaultByAddress) || void 0 === r
                      ? void 0
                      : null === (i = r.state) || void 0 === i
                        ? void 0
                        : i.dailyApy,
                  a.safeParseNumber
                ),
                rewards: L,
                points: $,
                variant: 'vault',
                netApy: (0, v.Pi)(
                  null == D
                    ? void 0
                    : null === (n = D.vaultByAddress.state) || void 0 === n
                      ? void 0
                      : n.dailyNetApy,
                  a.safeParseNumber
                ),
                asset: (0, o.wk)(
                  null == D
                    ? void 0
                    : null === (l = D.vaultByAddress) || void 0 === l
                      ? void 0
                      : l.asset
                ),
              };
            }, [D, $, L]);
          return (0, r.BX)(b, {
            direction: 'column',
            gap: 'm',
            grow: 1,
            children: [
              (0, r.BX)(l.Kqy, {
                justify: 'space-between',
                align: 'center',
                children: [
                  (0, r.BX)(l.Kqy, {
                    direction: 'column',
                    gap: 'xs',
                    children: [
                      (0, r.tZ)(s.w, {
                        RewardsHoverCardProps: O,
                        noHover: !0,
                        children: (0, r.tZ)(f, {
                          color: 'text.secondary',
                          lineHeight: 'normal',
                          children: 'APY',
                        }),
                      }),
                      (0, r.BX)(l.zsw.Root, {
                        children: [
                          (0, r.tZ)(l.zsw.Trigger, {
                            children: (0, r.BX)(l.Kqy, {
                              gap: 2,
                              align: 'center',
                              children: [
                                (0, r.tZ)(l.xvT.Title.S, { color: 'text.body', children: E }),
                                (0, r.tZ)(l.xvT.Title.S, { color: 'text.tertiary', children: '%' }),
                              ],
                            }),
                          }),
                          (0, r.tZ)(l.zsw.Content, { children: (0, r.tZ)(d.Z, { ...O }) }),
                        ],
                      }),
                    ],
                  }),
                  (0, r.tZ)(l.PhF, { options: c.S, value: S, onChange: T }),
                ],
              }),
              (0, r.tZ)(l._9J, {
                statuses: { loading: M, error: q },
                unit: '%',
                height: '225px',
                series: [
                  {
                    type: 'areaspline',
                    name: 'Apy',
                    data: K,
                    color: C.colors[0],
                    lineColor: C.colors[0],
                    fillColor: C.areaChartColors[0],
                  },
                ],
                plotlinesY: [
                  {
                    value:
                      null !==
                        (x =
                          null == D
                            ? void 0
                            : null === (Z = D.vaultByAddress.state) || void 0 === Z
                              ? void 0
                              : Z[F]) && void 0 !== x
                        ? x
                        : void 0,
                    color: X.colors.constant.color.brand,
                    dashStyle: 'Dot',
                    width: 1,
                    label: {
                      x: 6,
                      y: -15,
                      text: 'Avg '.concat(V, '%'),
                      align: 'left',
                      useHTML: !0,
                      formatter: (0, l.RFc)(X, X.colors.text.body),
                    },
                  },
                ],
                additionalOptions: { yAxis: { softMin: 0, maxPadding: 0.4 } },
              }),
            ],
          });
        })
      );
    },
    75688: function (e, t, i) {
      'use strict';
      i.d(t, {
        default: function () {
          return f;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(4565),
        o = i(12556),
        l = i(54655),
        s = i(16586),
        d = i(89991),
        u = i(16820),
        c = i(964),
        h = i(73828),
        v = i(83897),
        p = i(38819);
      let m = (0, p.Z)(l.Kqy, { target: 'e13ws6aj0' })('padding:9px 0;min-height:50px;'),
        g = (0, p.Z)('div', { target: 'e13ws6aj1' })(
          'background-color:',
          (e) => {
            let { theme: t } = e;
            return t.colors.background.tertiary;
          },
          ';padding:',
          (e) => {
            let { theme: t } = e;
            return t.padding.s;
          },
          ';border-radius:',
          (e) => {
            let { theme: t } = e;
            return t.borderRadius;
          },
          ';width:275px;overflow-y:auto;max-height:332px;',
          (e) => {
            let { theme: t } = e;
            return t.breakpoints.down('m');
          },
          '{max-height:345px;background-color:unset;padding:0;border:unset;width:100%;border-radius:0;}'
        ),
        y = (0, p.Z)('div', { target: 'e13ws6aj2' })(
          'background-color:',
          (e) => {
            let { theme: t } = e;
            return t.colors.background.primary;
          },
          ';width:24px;height:24px;border-radius:50%;display:flex;align-items:center;justify-content:center;'
        ),
        b = (0, p.Z)(l.JO$, { target: 'e13ws6aj4' })(
          'position:relative;top:-1px;margin-left:-1px;'
        );
      var f = (0, n.memo)((e) => {
        var t, i, p, f, Z, x;
        let { vault: w, address: k } = e,
          { targetChainId: B } = (0, d.Z_)(),
          P = (0, n.useMemo)(
            () => (0, o.wk)(null == w ? void 0 : w.asset),
            [null == w ? void 0 : w.asset]
          ),
          A = (0, v.M)(k, null == w ? void 0 : w.state, null == w ? void 0 : w.asset),
          C = (0, n.useMemo)(() => {
            var e, t, i;
            return (0, c.H2)({
              rewards: A,
              netApy: (0, u.Pi)(
                null == w
                  ? void 0
                  : null === (e = w.state) || void 0 === e
                    ? void 0
                    : e.dailyNetApy,
                a.safeParseNumber
              ),
              nativeApy: (0, u.Pi)(
                null == w ? void 0 : null === (t = w.state) || void 0 === t ? void 0 : t.dailyApy,
                a.safeParseNumber
              ),
              performanceFee: (0, u.Pi)(
                null == w ? void 0 : null === (i = w.state) || void 0 === i ? void 0 : i.fee,
                a.safeParseNumber
              ),
              asset: P,
            });
          }, [
            null == w ? void 0 : null === (t = w.state) || void 0 === t ? void 0 : t.dailyNetApy,
            null == w ? void 0 : null === (i = w.state) || void 0 === i ? void 0 : i.dailyApy,
            A,
            P,
            null == w ? void 0 : null === (p = w.state) || void 0 === p ? void 0 : p.fee,
          ]),
          X = (0, n.useMemo)(
            () => l.$0l.percent.trailingZero(!1).digits(2).unit('%').default('-').of(C, 18),
            [C]
          ),
          S = (0, n.useMemo)(() => {
            var e;
            return l.$0l.percent
              .trailingZero(!1)
              .digits(2)
              .unit('%')
              .default('0')
              .of(null == w ? void 0 : null === (e = w.state) || void 0 === e ? void 0 : e.fee);
          }, [null == w ? void 0 : null === (f = w.state) || void 0 === f ? void 0 : f.fee]),
          T = (0, l.vmq)({
            chainId: B,
            vaultAddress: k,
            allocation:
              null == w ? void 0 : null === (Z = w.state) || void 0 === Z ? void 0 : Z.allocation,
          }),
          R = (0, n.useMemo)(() => {
            var e, t;
            let i = null == w ? void 0 : null === (e = w.state) || void 0 === e ? void 0 : e.fee,
              r = null == w ? void 0 : null === (t = w.state) || void 0 === t ? void 0 : t.dailyApy,
              n = i && r ? i * r : 0;
            return 0 === n
              ? '0.00%'
              : l.$0l.percent.trailingZero(!1).digits(2).sign().unit('%').of(-n);
          }, [null == w ? void 0 : w.state]),
          D = (0, n.useMemo)(() => {
            var e;
            return l.$0l.percent
              .trailingZero(!1)
              .digits(2)
              .unit('%')
              .default('-')
              .of(
                null == w ? void 0 : null === (e = w.state) || void 0 === e ? void 0 : e.dailyNetApy
              );
          }, [
            null == w ? void 0 : null === (x = w.state) || void 0 === x ? void 0 : x.dailyNetApy,
          ]);
        return (0, r.BX)(g, {
          children: [
            (0, r.BX)(m, {
              justify: 'space-between',
              align: 'center',
              children: [
                (0, r.BX)(l.Kqy, {
                  gap: 4,
                  align: 'center',
                  children: [
                    (0, r.tZ)(y, {
                      children: (0, r.tZ)(l.JO$, { icon: 'InterestGeneratedGradient20', size: 14 }),
                    }),
                    (0, r.tZ)(l.xvT.Body.XXS.Regular, {
                      color: 'text.body',
                      children: 'Native APY',
                    }),
                  ],
                }),
                (0, r.tZ)(l.xvT.Body.XXS.Regular, { children: X }),
              ],
            }),
            P instanceof o.YK &&
              (0, r.tZ)(r.HY, {
                children: (0, r.BX)(m, {
                  justify: 'space-between',
                  align: 'center',
                  children: [
                    (0, r.BX)(l.Kqy, {
                      gap: 4,
                      align: 'center',
                      children: [
                        (0, r.tZ)(l.qEK, { src: P.logoURI, size: 'medium' }),
                        (0, r.BX)(l.xvT.Body.XXS.Regular, { children: [P.symbol, ' Yield'] }),
                        (0, r.tZ)(l.mUV, {
                          toCopy: P.address,
                          toastMessage: 'Address copied to clipboard.',
                          tooltipMessage: 'Copy address.',
                        }),
                      ],
                    }),
                    (0, r.tZ)(l.Kqy, {
                      gap: 4,
                      align: 'center',
                      children: (0, r.tZ)(l.xvT.Body.XXS.Regular, {
                        lineHeight: 'normal',
                        children: l.$0l.percent
                          .digits(2)
                          .unit('%')
                          .trailingZero(!1)
                          .sign()
                          .of(P.yield),
                      }),
                    }),
                  ],
                }),
              }),
            A.map((e, t) =>
              (0, r.tZ)(
                'div',
                {
                  children: (0, r.BX)(m, {
                    justify: 'space-between',
                    align: 'center',
                    children: [
                      (0, r.BX)(l.Kqy, {
                        gap: 4,
                        align: 'center',
                        children: [
                          (0, r.tZ)(l.qEK, { src: e.rewardToken.logoURI, size: 'medium' }),
                          (0, r.tZ)(l.xvT.Body.XXS.Regular, {
                            color: 'text.body',
                            children: e.rewardToken.symbol,
                          }),
                          (0, r.tZ)(l.mUV, {
                            toCopy: e.rewardToken.address,
                            toastMessage: 'Address copied to clipboard.',
                            tooltipMessage: 'Copy address.',
                          }),
                        ],
                      }),
                      (0, r.BX)(l.Kqy, {
                        gap: 4,
                        align: 'center',
                        children: [
                          (0, r.tZ)(l.xvT.Body.XXS.Regular, {
                            lineHeight: 'normal',
                            color: 'text.body',
                            children: (0, h.Cn)(e),
                          }),
                          !e.apr &&
                            e.proportional &&
                            !e.rewardToken.price &&
                            (0, r.tZ)(l.ua7, {
                              content: 'Per year per $1000 deposited.',
                              withTouch: !0,
                              children: (0, r.tZ)(l.JO$, {
                                icon: 'QuestionPlain20',
                                color: 'text.secondary',
                                size: 16,
                              }),
                            }),
                        ],
                      }),
                    ],
                  }),
                },
                'reward-'.concat(t)
              )
            ),
            (0, r.BX)(m, {
              justify: 'space-between',
              align: 'center',
              children: [
                (0, r.BX)(l.Kqy, {
                  gap: 4,
                  align: 'center',
                  children: [
                    (0, r.tZ)(b, { size: 25, icon: 'DollarSignPlain24', color: 'text.primary' }),
                    (0, r.tZ)(l.xvT.Body.XS.Regular, {
                      color: 'text.body',
                      children: 'Performance Fee',
                    }),
                    (0, r.tZ)(l.Vp9, { variant: 'main', label: S }),
                  ],
                }),
                (0, r.tZ)(l.xvT.Body.XXS.Regular, { children: R }),
              ],
            }),
            (0, r.BX)(m, {
              justify: 'space-between',
              align: 'center',
              children: [
                (0, r.BX)(l.Kqy, {
                  gap: 4,
                  align: 'center',
                  children: [
                    (0, r.tZ)(l.JO$, { icon: 'RewardsPlain20', color: 'text.interactive.active' }),
                    (0, r.tZ)(l.xvT.Body.XXS.Regular, {
                      color: 'text.interactive.active',
                      children: 'Net APY',
                    }),
                  ],
                }),
                (0, r.BX)(l.xvT.Body.XXS.Regular, {
                  color: 'text.interactive.active',
                  children: ['=', D],
                }),
              ],
            }),
            T.length > 0 && (0, r.tZ)(l.Z0O, {}),
            T.map((e, t) =>
              (0, r.tZ)(
                'div',
                {
                  children: (0, r.BX)(m, {
                    justify: 'space-between',
                    align: 'center',
                    children: [
                      (0, r.BX)(l.Kqy, {
                        gap: 4,
                        align: 'center',
                        children: [
                          (0, r.tZ)(l.JO$, { icon: 'PointsPlain20', color: 'icon.primary' }),
                          e.label && (0, r.tZ)(l.Vp9, { label: e.label }),
                          (0, r.tZ)(s.X, { point: e }),
                        ],
                      }),
                      (0, r.BX)(l.Kqy, {
                        gap: 'xxs',
                        align: 'center',
                        children: [
                          e.value && (0, r.tZ)(l.xvT.Body.XXS.Regular, { children: e.value }),
                          e.title &&
                            (0, r.tZ)(l.xvT.Body.XXS.Regular, {
                              color: 'text.body',
                              children: e.title,
                            }),
                        ],
                      }),
                    ],
                  }),
                },
                'point-'.concat(t)
              )
            ),
          ],
        });
      });
    },
    38071: function (e, t, i) {
      'use strict';
      i.d(t, {
        default: function () {
          return f;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(12556),
        o = i(54655),
        l = i(76992),
        s = i(33210),
        d = i(10433),
        u = i(93319),
        c = i(34937),
        h = i(83669),
        v = i(57892),
        p = i(55412),
        m = i(3245),
        g = i(24387);
      function y() {
        let e = (0, p._)([
          '\n  query GetVaultSupplyLiquidityTimeseries(\n    $address: String!\n    $chainId: Int\n    $options: TimeseriesOptions\n    $fetchTotalAssets: Boolean!\n    $fetchTotalAssetsUsd: Boolean!\n  ) {\n    vaultByAddress(address: $address, chainId: $chainId) {\n      id\n      historicalState {\n        totalAssets(options: $options) @include(if: $fetchTotalAssets) {\n          x\n          y\n        }\n        totalAssetsUsd(options: $options) @include(if: $fetchTotalAssetsUsd) {\n          x\n          y\n        }\n      }\n      state {\n        id\n        totalAssets\n      }\n      asset {\n        ...simpleAssetFields\n      }\n    }\n  }\n  ',
          '\n',
        ]);
        return (
          (y = function () {
            return e;
          }),
          e
        );
      }
      let b = (0, m.Ps)(y(), g.G);
      var f = (0, n.memo)(
        (0, s.Z)((e) => {
          var t, i;
          let { queryVariables: s, queryResult: p, now: m, address: g } = e,
            { palette: y } = (0, o.rFV)(),
            f = (0, o.dD4)(),
            { data: Z } = (0, v.Fj)(g, 0),
            { data: x } = (0, v.Fj)(g),
            w = (0, o.AwN)({
              apiValue:
                null === (i = p.data.vaultByAddress) || void 0 === i
                  ? void 0
                  : null === (t = i.state) || void 0 === t
                    ? void 0
                    : t.totalAssets,
              initialOnchainValue: null == Z ? void 0 : Z.totalAssets,
              latestSimulatedValue: null == x ? void 0 : x.totalAssets,
            }),
            k = (0, n.useMemo)(
              () => (0, a.wk)(p.data.vaultByAddress.asset),
              [p.data.vaultByAddress.asset]
            ),
            B = (0, n.useMemo)(() => {
              if (w.value) return k.toUsd(w.value);
            }, [k, w]),
            [P, A] = (0, n.useState)(d.B),
            [C, X] = (0, n.useState)('USD'),
            S = (0, n.useMemo)(
              () => [
                {
                  value: p.data.vaultByAddress.asset.symbol,
                  label: p.data.vaultByAddress.asset.symbol,
                },
                { value: 'USD', label: 'USD' },
              ],
              [p.data.vaultByAddress.asset]
            ),
            T = (0, n.useMemo)(() => ('USD' === C ? 'totalAssetsUsd' : 'totalAssets'), [C]),
            R = (0, n.useMemo)(
              () => ({
                ...s,
                fetchTotalAssets: 'totalAssets' === T,
                fetchTotalAssetsUsd: 'totalAssetsUsd' === T,
                options: (0, c.Ai)({ timeFrame: P, now: m }),
              }),
              [T, m, P, s]
            ),
            {
              data: D,
              loading: M,
              error: q,
            } = (0, h.s)({
              queryDocument: b,
              queryVariables: R,
              serverQueryVariables: s,
              serverQueryResult: p,
            }),
            F = (0, n.useMemo)(() => {
              var e, t;
              return 'totalAssetsUsd' === T
                ? (0, o.EES)(
                    null == D
                      ? void 0
                      : null === (e = D.vaultByAddress.historicalState) || void 0 === e
                        ? void 0
                        : e.totalAssetsUsd
                  )
                : (0, o.EES)(
                    null == D
                      ? void 0
                      : null === (t = D.vaultByAddress.historicalState) || void 0 === t
                        ? void 0
                        : t.totalAssets,
                    p.data.vaultByAddress.asset.decimals
                  );
            }, [D, T, p.data.vaultByAddress.asset]),
            K = w.isSimulated,
            V = (0, n.useMemo)(() => {
              let e;
              return (
                (e =
                  'totalAssetsUsd' === T
                    ? o.$0l.short.default('-').digits(2).of(B, 18)
                    : o.$0l.short
                        .default('-')
                        .digits(2)
                        .of(w.value, p.data.vaultByAddress.asset.decimals)),
                (0, u.l)(e)
              );
            }, [T, p.data.vaultByAddress.asset, w.value, B]);
          return (0, r.BX)(o.Zbd, {
            fullWidth: !0,
            gap: 'm',
            direction: 'column',
            paddingBlock: 'm',
            paddingInline: { base: 'm', s: 's' },
            children: [
              (0, r.BX)(o.Kqy, {
                justify: 'space-between',
                align: 'center',
                gap: 's',
                wrap: 'wrap',
                children: [
                  (0, r.BX)(o.Kqy, {
                    direction: 'column',
                    gap: 'xs',
                    children: [
                      (0, r.tZ)(o.Kqy, {
                        gap: 2,
                        align: 'center',
                        children: (0, r.BX)(o.xvT.Body.XS.Regular, {
                          color: 'text.secondary',
                          children: ['Total Deposits (', C, ')'],
                        }),
                      }),
                      V.value
                        ? (0, r.BX)(o.Kqy, {
                            gap: 2,
                            align: 'center',
                            children: [
                              (0, r.BX)(o.ZT$, {
                                TextVariant: o.xvT.Title.S,
                                isSimulated: K,
                                children: ['USD' === C ? '$' : '', V.value],
                              }),
                              (0, r.tZ)(o.ZT$, {
                                TextVariant: o.xvT.Title.S,
                                color: 'text.tertiary',
                                isSimulated: K,
                                children: V.unit,
                              }),
                            ],
                          })
                        : (0, r.tZ)(o.OdW, { height: '46px', width: '130px' }),
                    ],
                  }),
                  (0, r.BX)(o.Kqy, {
                    align: 'center',
                    gap: 's',
                    wrap: 'wrap',
                    children: [
                      f
                        ? (0, r.tZ)(r.HY, {
                            children: (0, r.tZ)(o.PhF, { options: S, value: C, onChange: X }),
                          })
                        : (0, r.tZ)(r.HY, {
                            children: (0, r.tZ)(l.E, {
                              variant: 'secondary',
                              id: 'chart-options-currency',
                              options: S,
                              value: C,
                              onChange: X,
                            }),
                          }),
                      (0, r.tZ)(o.PhF, { options: d.S, value: P, onChange: A }),
                    ],
                  }),
                ],
              }),
              (0, r.tZ)(o._9J, {
                statuses: { loading: M, error: q },
                unit: 'USD' === C ? '$' : C,
                height: '224px',
                series: [
                  {
                    type: 'areaspline',
                    name: 'Total Deposits',
                    data: F,
                    color: y.colors[0],
                    lineColor: y.colors[0],
                    fillColor: y.areaChartColors[0],
                  },
                ],
              }),
            ],
          });
        })
      );
    },
    77843: function (e, t, i) {
      'use strict';
      i.d(t, {
        default: function () {
          return S;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(55385),
        o = i(60626),
        l = i(54655),
        s = i(43779),
        d = i(33210),
        u = i(89991),
        c = i(16237),
        h = i(55135),
        v = i(6423),
        p = i(90836),
        m = i(38819);
      let g = (0, m.Z)(l.Kqy, { target: 'e1jy12rw0' })('width:100%;height:100%;'),
        y = (0, m.Z)(l.xrM, { target: 'e1jy12rw1' })(
          'width:100%;height:100%;border-radius:',
          (e) => {
            let { theme: t } = e;
            return t.borderRadius;
          },
          ';display:grid;td{:first-of-type{width:50%;}:nth-of-type(2){width:unset;}}'
        );
      var b = i(4565),
        f = i(27349),
        Z = i(16820),
        x = i(42418);
      let w = [
          {
            accessorKey: 'market',
            header: () =>
              (0, r.tZ)(l.ua7, {
                content: 'The markets this vault has supplied into.',
                children: (0, r.tZ)(l.xvT.Body.XXXS.Regular, {
                  color: 'text.secondary',
                  children: 'Market Exposure',
                }),
              }),
            cell: (e) => {
              let { row: t } = e,
                i = t.original.market;
              return (0, r.tZ)(l.k1R, { ...i, chainId: i.loanAsset.chain.id });
            },
            sortingFn: (e, t) =>
              (0, x.Dt)(
                (0, l.lAJ)({
                  loanAsset: e.original.market.loanAsset,
                  collateralAsset: e.original.market.collateralAsset,
                }),
                (0, l.lAJ)({
                  loanAsset: t.original.market.loanAsset,
                  collateralAsset: t.original.market.collateralAsset,
                })
              ),
          },
          {
            accessorKey: 'percentShare',
            header: () =>
              (0, r.tZ)(l.ua7, {
                content: 'Proportion of the vault supply allocated to this Morpho Market.',
                children: (0, r.tZ)(l.xvT.Body.XXXS.Regular, {
                  color: 'text.secondary',
                  children: 'Vault Allocation %',
                }),
              }),
            cell: (e) => {
              let { row: t } = e;
              return (0, r.tZ)(l.lR8, {
                allocation: t.original.percentShare,
                percentageOffset: t.original.percentageOffset,
                index: t.index,
              });
            },
          },
          {
            accessorKey: 'supplyAssetsUsd',
            header: () =>
              (0, r.tZ)(l.ua7, {
                content: 'The amount supplied to the market.',
                children: (0, r.tZ)(l.xvT.Body.XXXS.Regular, {
                  color: 'text.secondary',
                  children: 'Vault Allocation ($)',
                }),
              }),
            cell: (e) => {
              let { row: t } = e;
              return (0, r.tZ)(l.WN3, {
                children: l.$0l.short
                  .trailingZero(!1)
                  .digits(2)
                  .unit('$')
                  .of(t.original.supplyAssetsUsd),
              });
            },
          },
          {
            accessorKey: 'supplyCapUsd',
            header: () =>
              (0, r.tZ)(l.ua7, {
                content: 'The maximum market allocation allowed by the vault.',
                children: (0, r.tZ)(l.xvT.Body.XXXS.Regular, {
                  color: 'text.secondary',
                  children: 'Supply Cap',
                }),
              }),
            cell: (e) => {
              let { row: t } = e;
              return t.original.market.collateralAsset
                ? (0, r.tZ)(l.WN3, {
                    children: l.$0l.short
                      .trailingZero(!1)
                      .digits(2)
                      .unit('$')
                      .of(t.original.supplyCapUsd),
                  })
                : '-';
            },
          },
          {
            accessorKey: 'market.state.dailyNetSupplyApy',
            header: () =>
              (0, r.tZ)(l.ua7, {
                content: '1D Supply APY + Rewards',
                children: (0, r.tZ)(l.xvT.Body.XXXS.Regular, {
                  color: 'text.secondary',
                  marginLeft: '14px',
                  children: 'APY',
                }),
              }),
            cell: (e) => {
              var t, i, n, a;
              let { row: o } = e;
              return (0, r.tZ)(l.KNv, {
                hoverCardContent: (0, r.tZ)(f.Z, {
                  apy: (0, Z.Pi)(
                    null === (t = o.original.market.state) || void 0 === t
                      ? void 0
                      : t.dailySupplyApy,
                    b.safeParseNumber
                  ),
                  netApy: (0, Z.Pi)(
                    null === (i = o.original.market.state) || void 0 === i
                      ? void 0
                      : i.dailyNetSupplyApy,
                    b.safeParseNumber
                  ),
                  rewards: o.original.rewards,
                  variant: 'supply',
                  asset: o.original.market.collateralAsset,
                }),
                padding: '0 11px 0 14px',
                children: (0, r.BX)(l.Kqy, {
                  gap: 2,
                  align: 'center',
                  children: [
                    (0, r.tZ)(l.WN3, {
                      children: l.$0l.percent
                        .digits(2)
                        .unit('%')
                        .of(
                          null === (n = o.original.market.state) || void 0 === n
                            ? void 0
                            : n.dailyNetSupplyApy
                        ),
                    }),
                    (null === (a = o.original.rewards) || void 0 === a ? void 0 : a.length)
                      ? (0, r.tZ)(l.JO$, { icon: 'RewardsGradient20' })
                      : null,
                  ],
                }),
              });
            },
          },
        ],
        k = {
          market: 'Market',
          percentShare: 'Allocation %',
          supplyAssetsUsd: 'Total Supply',
          supplyCapUsd: 'Cap',
          market_state_dailyNetSupplyApy: 'Daily Supply APY',
        },
        B = {
          columnVisibility: {},
          sorting: [{ id: 'percentShare', desc: !0 }],
          columnFilters: [],
          version: 1,
        };
      var P = i(35047),
        A = i(8937),
        C = i(47528),
        X = (e) =>
          (0, n.useMemo)(() => {
            var t;
            if (
              !(null == e ? void 0 : null === (t = e.state) || void 0 === t ? void 0 : t.allocation)
            )
              return { data: [], totalCount: 0 };
            let i = 0n,
              r = e.state.allocation
                .sort((0, P.bigIntComparator)((e) => e.supplyAssets, 'desc'))
                .map((t) => {
                  var r, n;
                  let a = (0, A.R)(
                      null !==
                        (n =
                          null == e
                            ? void 0
                            : null === (r = e.state) || void 0 === r
                              ? void 0
                              : r.totalAssets) && void 0 !== n
                        ? n
                        : 0n,
                      t.supplyAssets
                    ),
                    o = (0, C.f)(t.market, 'supply'),
                    l = { ...t, percentShare: a, percentageOffset: i, rewards: o };
                  return (i += a), l;
                });
            return { data: r, totalCount: r.length };
          }, [e]),
        S = (0, n.memo)(
          (0, d.Z)((e) => {
            var t;
            let { queryResult: i } = e,
              { targetChain: n } = (0, u.Z_)(),
              { pagination: d, onPaginationChange: m } = (0, p.h)({ defaultPageSize: 10 }),
              { data: b, totalCount: f } = X(
                null === (t = i.data) || void 0 === t ? void 0 : t.vaultByAddress
              ),
              { sorting: Z, setSorting: x } = (0, c.Z)({
                pageKey: h.CT.Vault,
                tableSettingsObjectKey: 'marketAllocationTable',
                defaultTableSettings: B,
              }),
              P = (0, a.b7)({
                data: b,
                getCoreRowModel: (0, o.sC)(),
                getSortedRowModel: (0, o.tj)(),
                getPaginationRowModel: (0, o.G_)(),
                onSortingChange: x,
                state: { sorting: Z, pagination: d },
                columns: w,
                enableSortingRemoval: !1,
                sortDescFirst: !0,
                onPaginationChange: m,
              });
            return (0, r.BX)(g, {
              direction: 'column',
              gap: 'xs',
              children: [
                (0, r.BX)(y, {
                  children: [
                    P.getRowModel().rows.length > 0 &&
                      (0, r.BX)(s.iA.iA, {
                        tableVariant: 'compact',
                        children: [
                          (0, r.tZ)(s.iA.hr, {
                            children: P.getHeaderGroups().map((e) =>
                              (0, r.tZ)(s.uq, { columnLabels: k, headerGroup: e }, e.id)
                            ),
                          }),
                          (0, r.tZ)(s.iA.p3, {
                            children: P.getRowModel().rows.map((e) => {
                              var t, i;
                              return (0, r.tZ)(
                                s.yL,
                                {
                                  row: e,
                                  href: e.original.market.collateralAsset
                                    ? (0, v.E3)({
                                        chainName: n.name,
                                        marketUniqueKey: e.original.market.uniqueKey,
                                        collateralSymbol: e.original.market.collateralAsset.symbol,
                                        loanSymbol:
                                          null !==
                                            (i =
                                              null === (t = e.original.market.loanAsset) ||
                                              void 0 === t
                                                ? void 0
                                                : t.symbol) && void 0 !== i
                                            ? i
                                            : '0x',
                                      })
                                    : void 0,
                                },
                                e.id
                              );
                            }),
                          }),
                        ],
                      }),
                    0 === P.getRowModel().rows.length &&
                      (0, r.tZ)(l.WaR, {
                        text: 'No market allocation found.',
                        height: '640px',
                        cardTextProps: { style: { borderRadius: '0' } },
                      }),
                  ],
                }),
                (0, r.tZ)(l.tlE, {
                  loading: !1,
                  pagination: d,
                  totalItemsCount: f,
                  previousPage: P.previousPage,
                  nextPage: P.nextPage,
                  setPage: P.setPageIndex,
                  canPreviousPage: P.getCanPreviousPage(),
                  canNextPage: P.getCanNextPage(),
                }),
              ],
            });
          })
        );
    },
    96188: function (e, t, i) {
      'use strict';
      var r = i(78286),
        n = i(58258),
        a = i(15176),
        o = i(83747),
        l = i(69653);
      t.default = (0, n.memo)((e) => {
        let {} = e;
        return (0, r.BX)(a.default, { children: [(0, r.tZ)(o.jX, {}), (0, r.tZ)(l.HB, {})] });
      });
    },
    86096: function (e, t, i) {
      'use strict';
      var r = i(78286),
        n = i(58258),
        a = i(15176),
        o = i(83747),
        l = i(69653);
      t.default = (0, n.memo)((e) => {
        let {} = e;
        return (0, r.BX)(a.default, { children: [(0, r.tZ)(o.S5, {}), (0, r.tZ)(l.ih, {})] });
      });
    },
    68987: function (e, t, i) {
      'use strict';
      var r = i(78286),
        n = i(58258),
        a = i(40252),
        o = i(54655),
        l = i(12597),
        s = i(6893);
      t.default = (0, n.memo)((e) => {
        var t;
        let {
            queryResult: { data: i },
          } = e,
          { publicAllocator: n } = (0, a.getChainAddresses)(a.ChainId.EthMainnet);
        return (0, r.BX)(o.Kqy, {
          gap: 's',
          direction: 'column',
          align: 'start',
          children: [
            (0, r.tZ)(s.$, { children: 'Risk Curation' }),
            (null == i
              ? void 0
              : null === (t = i.vaultByAddress) || void 0 === t
                ? void 0
                : t.allocators) &&
              i.vaultByAddress.allocators.length > 0 &&
              (0, r.tZ)(o.Kqy, {
                gap: 's',
                wrap: 'wrap',
                style: { width: '100%' },
                children: i.vaultByAddress.allocators.map((e, t) => {
                  let { address: i } = e;
                  return (0, r.tZ)(
                    l.mD,
                    {
                      title: 'Allocator Address',
                      address: i,
                      minWidth: '275px',
                      labelTag: n === i ? 'Public Allocator' : void 0,
                    },
                    'allocator-' + t
                  );
                }),
              }),
          ],
        });
      });
    },
    9894: function (e, t, i) {
      'use strict';
      i.d(t, {
        default: function () {
          return b;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(54655),
        o = i(76992),
        l = i(33210),
        s = i(10433),
        d = i(34937),
        u = i(83669);
      let c = (0, i(38819).Z)(a.Zbd, { target: 'ew01rsg0' })('width:100%;');
      var h = i(55412),
        v = i(3245),
        p = i(24387);
      function m() {
        let e = (0, h._)([
          '\n  query GetVaultAllocationTimeseries(\n    $address: String!\n    $chainId: Int\n    $options: TimeseriesOptions\n  ) {\n    vaultByAddress(address: $address, chainId: $chainId) {\n      id\n      asset {\n        id\n        symbol\n      }\n      historicalState {\n        allocation {\n          market {\n            id\n            lltv\n            loanAsset {\n              ...simpleAssetFields\n            }\n            collateralAsset {\n              ...simpleAssetFields\n            }\n          }\n          supplyAssets(options: $options) {\n            x\n            y\n          }\n        }\n      }\n    }\n  }\n  ',
          '\n',
        ]);
        return (
          (m = function () {
            return e;
          }),
          e
        );
      }
      let g = (0, v.Ps)(m(), p.G),
        y = (e) => ({
          segmented: [
            { value: 'percent', icon: 'PercentPlain20' },
            { value: 'normal', label: null != e ? e : '' },
          ],
          select: [
            { value: 'percent', label: '%' },
            { value: 'normal', label: null != e ? e : '' },
          ],
        });
      var b = (0, n.memo)(
        (0, l.Z)((e) => {
          var t;
          let { queryVariables: i, queryResult: l, now: h } = e,
            { palette: v } = (0, a.rFV)(),
            p = (0, a.dD4)(),
            [m, b] = (0, n.useState)(s.B),
            [f, Z] = (0, n.useState)('percent'),
            x = (0, n.useMemo)(
              () => ({ ...i, options: (0, d.Ai)({ timeFrame: m, now: h }) }),
              [h, m, i]
            ),
            {
              data: w,
              loading: k,
              error: B,
            } = (0, u.s)({
              queryDocument: g,
              queryVariables: x,
              serverQueryVariables: i,
              serverQueryResult: l,
            }),
            P = (0, n.useMemo)(() => {
              var e;
              return y(
                (null == l
                  ? void 0
                  : null === (e = l.data) || void 0 === e
                    ? void 0
                    : e.vaultByAddress.asset.symbol) ||
                  (null == w ? void 0 : w.vaultByAddress.asset.symbol)
              );
            }, [
              null == l
                ? void 0
                : null === (t = l.data) || void 0 === t
                  ? void 0
                  : t.vaultByAddress.asset.symbol,
              null == w ? void 0 : w.vaultByAddress.asset.symbol,
            ]),
            A = (0, n.useMemo)(() => {
              var e;
              if (!(null == w ? void 0 : w.vaultByAddress.historicalState.allocation)) return [];
              let t = v.colors.length;
              return null === (e = w.vaultByAddress.historicalState.allocation) || void 0 === e
                ? void 0
                : e.map((e, i) => {
                    var r, n;
                    let o = i % t;
                    return {
                      type: 'areaspline',
                      name: (0, a.lAJ)({
                        loanAsset: e.market.loanAsset,
                        collateralAsset: e.market.collateralAsset,
                      }),
                      data: (0, a.EES)(
                        e.supplyAssets,
                        null !==
                          (n =
                            null === (r = e.market.loanAsset) || void 0 === r
                              ? void 0
                              : r.decimals) && void 0 !== n
                          ? n
                          : 18
                      ),
                      color: v.colors[o],
                      lineColor: v.colors[o],
                      fillColor: v.areaChartColors[o],
                      states: { inactive: { enabled: !1 } },
                      lineWidth: 1,
                    };
                  });
            }, [w, v]),
            C = (0, n.useMemo)(() => {
              var e;
              return 'percent' === f
                ? '%'
                : null !== (e = null == w ? void 0 : w.vaultByAddress.asset.symbol) && void 0 !== e
                  ? e
                  : '';
            }, [f, null == w ? void 0 : w.vaultByAddress.asset.symbol]);
          return (0, r.BX)(c, {
            gap: 's',
            direction: 'column',
            padding: 'm',
            children: [
              (0, r.BX)(a.Kqy, {
                align: 'center',
                justify: 'space-between',
                children: [
                  (0, r.tZ)(a.xvT.Body.XS.Regular, {
                    color: 'text.secondary',
                    children: 'Allocation History',
                  }),
                  (0, r.BX)(a.Kqy, {
                    align: 'center',
                    gap: 's',
                    wrap: 'wrap',
                    children: [
                      p
                        ? (0, r.tZ)(a.PhF, { options: P.select, value: f, onChange: Z })
                        : (0, r.tZ)(o.E, {
                            variant: 'secondary',
                            id: 'chart-options-stacking-mode',
                            options: P.segmented,
                            value: f,
                            onChange: Z,
                          }),
                      (0, r.tZ)(a.PhF, { options: s.S, value: m, onChange: b }),
                    ],
                  }),
                ],
              }),
              (0, r.tZ)(a.Qpo, {
                statuses: { loading: k, error: B },
                unit: C,
                stackingMode: f,
                height: '225px',
                series: A,
              }),
            ],
          });
        })
      );
    },
    11901: function (e, t, i) {
      'use strict';
      i.d(t, {
        default: function () {
          return S;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(55385),
        o = i(60626),
        l = i(54655),
        s = i(53863),
        d = i(43779),
        u = i(33210),
        c = i(89991),
        h = i(90836),
        v = i(7518),
        p = i(38819);
      let m = (0, p.Z)(l.Kqy, { target: 'e12urv8e0' })('width:100%;height:100%;'),
        g = (0, p.Z)(l.xrM, { target: 'e12urv8e1' })(
          'width:100%;height:100%;border-radius:',
          (e) => {
            let { theme: t } = e;
            return t.borderRadius;
          },
          ';display:grid;'
        );
      var y = i(4015),
        b = i(83669),
        f = i(68866),
        Z = i(55412),
        x = i(3245),
        w = i(24387);
      function k() {
        let e = (0, Z._)([
          '\n  query GetVaultReallocates(\n    $first: Int\n    $skip: Int\n    $where: VaultReallocateFilters\n    $orderBy: VaultReallocateOrderBy\n    $orderDirection: OrderDirection\n  ) {\n    vaultReallocates(\n      first: $first\n      skip: $skip\n      where: $where\n      orderBy: $orderBy\n      orderDirection: $orderDirection\n    ) {\n      items {\n        id\n        caller\n        timestamp\n        hash\n        assets\n        vault {\n          id\n          asset {\n            ...simpleAssetFields\n          }\n        }\n        market {\n          id\n          lltv\n          uniqueKey\n          loanAsset {\n            ...simpleAssetFields\n          }\n          collateralAsset {\n            ...simpleAssetFields\n          }\n        }\n      }\n      pageInfo {\n        countTotal\n        count\n        limit\n        skip\n      }\n    }\n  }\n  ',
          '\n',
        ]);
        return (
          (k = function () {
            return e;
          }),
          e
        );
      }
      let B = (0, x.Ps)(k(), w.G);
      var P = (e) => {
          var t, i;
          let { queryVariables: r, queryResult: a, first: o, skip: l } = e,
            s = { ...r, first: o, skip: l },
            {
              data: d,
              loading: u,
              error: c,
            } = (0, b.s)({
              queryDocument: B,
              queryVariables: s,
              serverQueryVariables: r,
              serverQueryResult: a,
            }),
            { totalItemsCount: h, pageCount: v } = (0, f.Z)({
              pageInfo:
                null == d
                  ? void 0
                  : null === (t = d.vaultReallocates) || void 0 === t
                    ? void 0
                    : t.pageInfo,
              error: c,
              first: o,
            });
          return (0, n.useMemo)(() => {
            var e;
            return {
              data:
                null == d
                  ? void 0
                  : null === (e = d.vaultReallocates) || void 0 === e
                    ? void 0
                    : e.items,
              loading: u,
              error: c,
              totalCount: h,
              pageCount: v,
            };
          }, [
            null == d
              ? void 0
              : null === (i = d.vaultReallocates) || void 0 === i
                ? void 0
                : i.items,
            u,
            c,
            h,
            v,
          ]);
        },
        A = i(40252),
        C = i(12556),
        X = (e) => {
          let { items: t, chainId: i } = e;
          return (0, n.useMemo)(
            () =>
              t
                ? t.map((e) => {
                    var t;
                    let r = (0, C.wk)(e.vault.asset);
                    return {
                      ...e,
                      urlCaller: A.ChainUtils.getExplorerAddressUrl(i, e.caller),
                      urlHash: A.ChainUtils.getExplorerTransactionUrl(i, e.hash),
                      amountValue: null !== (t = r.toUsd(e.assets)) && void 0 !== t ? t : null,
                    };
                  })
                : [],
            [t, i]
          );
        },
        S = (0, n.memo)(
          (0, u.Z)((e) => {
            let { queryResult: t, queryVariables: i } = e,
              { targetChainId: u } = (0, c.Z_)(),
              {
                first: p,
                skip: b,
                pagination: f,
                onPaginationChange: Z,
              } = (0, h.h)({ defaultPageSize: 5 }),
              {
                data: x,
                loading: w,
                totalCount: k,
                error: B,
              } = P({ queryResult: t, queryVariables: i, first: p, skip: b }),
              A = X({ items: x, chainId: u }),
              C = (0, a.b7)({
                data: A,
                getCoreRowModel: (0, o.sC)(),
                state: { pagination: f },
                manualSorting: !1,
                manualPagination: !0,
                pageCount: null != k ? k : void 0,
                columns: y.vaultAllocationColumnsDefs,
                enableSortingRemoval: !1,
                sortDescFirst: !1,
                onPaginationChange: Z,
              }),
              S = (0, n.useMemo)(() => 0 === C.getRowModel().rows.length, [C]),
              T = (0, v.I)({
                first: p,
                totalCount: k,
                pagination: f,
                columnsDefs: y.vaultAllocationColumnsDefs,
              });
            return (0, r.BX)(m, {
              direction: 'column',
              gap: 'xs',
              children: [
                (0, r.BX)(g, {
                  children: [
                    !S &&
                      (0, r.BX)(d.iA.iA, {
                        tableVariant: 'compact',
                        children: [
                          (0, r.tZ)(d.iA.hr, {
                            children: C.getHeaderGroups().map((e) =>
                              (0, r.tZ)(d.uq, { headerGroup: e }, e.id)
                            ),
                          }),
                          (0, r.BX)(d.iA.p3, {
                            children: [
                              !w &&
                                C.getRowModel().rows.map((e) => (0, r.tZ)(d.yL, { row: e }, e.id)),
                              w &&
                                T.map((e, t) =>
                                  (0, r.tZ)(
                                    d.yL,
                                    { skeletonRow: e },
                                    'skeleton-table-reallocate-'.concat(t)
                                  )
                                ),
                            ],
                          }),
                        ],
                      }),
                    S &&
                      (0, r.tZ)(l.WaR, {
                        text: 'No allocation history found.',
                        height: '600px',
                        cardTextProps: { style: { borderRadius: '0' } },
                      }),
                    !w && B && (0, r.tZ)(s.Z, { minHeight: '340px', style: { borderRadius: '0' } }),
                  ],
                }),
                (0, r.tZ)(l.tlE, {
                  loading: w,
                  error: B,
                  pagination: f,
                  totalItemsCount: k,
                  previousPage: C.previousPage,
                  nextPage: C.nextPage,
                  setPage: C.setPageIndex,
                  canPreviousPage: C.getCanPreviousPage(),
                  canNextPage: C.getCanNextPage(),
                }),
              ],
            });
          })
        );
    },
    4015: function (e, t, i) {
      'use strict';
      i.r(t),
        i.d(t, {
          vaultAllocationColumnsDefs: function () {
            return d;
          },
        });
      var r = i(78286),
        n = i(86842),
        a = i(40252),
        o = i(12556),
        l = i(54655),
        s = i(50825);
      let d = [
        {
          accessorKey: 'timestamp',
          header: () =>
            (0, r.tZ)(l.ua7, {
              content: 'The time the transaction was made.',
              children: (0, r.tZ)(l.xvT.Body.XXXS.Regular, {
                color: 'text.secondary',
                children: 'Date',
              }),
            }),
          cell: (e) => {
            let { row: t } = e,
              i = 1e3 * Number(t.original.timestamp),
              a = (0, n.WU)(new Date(i), 'MM/dd/yyyy HH:mm');
            return (0, r.tZ)(l.WN3, { children: a });
          },
          enableSorting: !1,
          skeletonCell: (0, r.tZ)(l.OdW, { width: '70px', height: '21px' }),
        },
        {
          accessorKey: 'caller',
          header: () =>
            (0, r.tZ)(l.ua7, {
              content: 'User who executed the reallocate.',
              children: (0, r.tZ)(l.xvT.Body.XXXS.Regular, {
                color: 'text.secondary',
                marginLeft: '7px',
                children: 'Allocator',
              }),
            }),
          cell: (e) => {
            let { row: t } = e,
              { publicAllocator: i } = (0, a.getChainAddresses)(a.ChainId.EthMainnet);
            return (0, r.BX)(l.Kqy, {
              gap: 2,
              align: 'center',
              children: [
                (0, r.tZ)(s.Z, {
                  href: t.original.urlCaller,
                  mode: 'external',
                  buttonProps: {
                    variant: 'ghost',
                    size: 'default',
                    label: (0, l.GQT)(t.original.caller),
                    avatarProps: { address: t.original.caller },
                  },
                }),
                t.original.caller === i &&
                  (0, r.tZ)(l.Vp9, { variant: 'main', label: 'Public Allocator' }),
              ],
            });
          },
          enableSorting: !1,
          skeletonCell: (0, r.tZ)(l.OdW, { width: '143px', height: '32px' }),
        },
        {
          accessorKey: 'assets',
          header: () =>
            (0, r.tZ)(l.ua7, {
              content: 'The amount of token involved in the transaction.',
              children: (0, r.tZ)(l.xvT.Body.XXXS.Regular, {
                color: 'text.secondary',
                children: 'Amount',
              }),
            }),
          cell: (e) => {
            let { row: t } = e;
            return (0, r.tZ)(l.kOf, {
              token: (0, o.wk)(t.original.vault.asset),
              amount: t.original.assets,
              value: t.original.amountValue,
              withAvatar: !0,
            });
          },
          enableSorting: !1,
          skeletonCell: (0, r.tZ)(l.OdW, { width: '190px', height: '22px' }),
        },
        {
          accessorKey: 'market',
          header: () =>
            (0, r.tZ)(l.ua7, {
              content: 'The market concerned by the reallocate.',
              children: (0, r.tZ)(l.xvT.Body.XXXS.Regular, {
                color: 'text.secondary',
                children: 'Market',
              }),
            }),
          cell: (e) => {
            let { row: t } = e;
            return (0, r.tZ)(l.k1R, {
              ...t.original.market,
              chainId: t.original.vault.asset.chain.id,
            });
          },
          enableSorting: !1,
          skeletonCell: (0, r.tZ)(l.OdW, { width: '240px', height: '24px' }),
        },
        {
          accessorKey: 'hash',
          header: () =>
            (0, r.tZ)(l.ua7, {
              content: 'The transaction hash.',
              children: (0, r.tZ)(l.xvT.Body.XXXS.Regular, {
                color: 'text.secondary',
                marginLeft: '10px',
                children: 'Hash',
              }),
            }),
          cell: (e) => {
            let { row: t } = e;
            return (0, r.tZ)(s.Z, {
              href: t.original.urlHash,
              mode: 'external',
              buttonProps: {
                variant: 'ghost',
                size: 'default',
                label: (0, l.GQT)(t.original.hash),
              },
            });
          },
          enableSorting: !1,
          skeletonCell: (0, r.tZ)(l.OdW, { width: '122px', height: '32px' }),
        },
      ];
    },
    94098: function (e, t, i) {
      'use strict';
      i.d(t, {
        default: function () {
          return A;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(4899),
        o = i(17965),
        l = i(12556),
        s = i(54655),
        d = i(50825),
        u = i(12597),
        c = i(67355);
      let h = {
          '0xaa0500198B4425DfC4E272FbE42C8E64E21fc03d': {
            name: 'Aragon',
            icon: (0, l.$B)('v2/assets/icons/aragon.svg'),
            tooltipContent: 'Depositor DAO powered by Aragon OSx',
          },
        },
        v = (e) => h[e] || null;
      var p = i(86536);
      let m = (0, i(38819).Z)(s.dLw, { target: 'e26iu020' })(
        'display:inline-block;color:',
        (e) => {
          let { theme: t } = e;
          return t.colors.text.secondary;
        },
        ';&:hover{text-decoration:underline;}'
      );
      var g = (0, n.memo)((e) => {
          let { address: t, timelock: i, title: o, children: l, ...d } = e,
            u = (0, n.useMemo)(() => (0, c.L)(null != i ? i : null), [i]),
            h = (0, n.useMemo)(() => (t ? v(t) || { name: (0, s.GQT)(t) } : null), [t]);
          return (0, r.tZ)(p.x, {
            ...d,
            children: (0, r.BX)(s.Kqy, {
              direction: 'column',
              gap: 's',
              children: [
                (0, r.tZ)(s.xvT.Body.XS.Regular, { color: 'text.secondary', children: o }),
                (0, r.BX)(s.Kqy, {
                  gap: 4,
                  align: 'center',
                  children: [
                    (0, r.tZ)(s.xvT.Body.M.Regular, { children: u }),
                    h &&
                      (0, r.BX)(r.HY, {
                        children: [
                          (0, r.tZ)(s.xvT.Body.M.Regular, { children: ' / ' }),
                          h.icon &&
                            (0, r.tZ)(a.default, {
                              src: h.icon,
                              alt: h.name,
                              width: 18,
                              height: 18,
                            }),
                          (0, r.tZ)(s.xvT.Body.M.Regular, { children: h.name }),
                          h.tooltipContent &&
                            (0, r.tZ)(s.bEE, {
                              disableHoverableContent: !1,
                              tooltipContent: (0, r.BX)('span', {
                                children: [
                                  h.tooltipContent,
                                  (0, r.tZ)(m, {
                                    href: 'https://forum.morpho.org/t/trustless-onchain-guardian-setup-for-metamorpho-vaults/530',
                                    children: 'Learn more →',
                                  }),
                                ],
                              }),
                            }),
                        ],
                      }),
                    t &&
                      (0, r.tZ)(s.mUV, {
                        toCopy: t,
                        toastMessage: 'Guardian address copied to clipboard.',
                        tooltipMessage: 'Copy guardian address.',
                        'aria-label': 'Copy guardian address',
                      }),
                  ],
                }),
              ],
            }),
          });
        }),
        y = i(19686),
        b = i(6893),
        f = i(33210),
        Z = i(52234),
        x = i(89991),
        w = i(72561),
        k = i(17781),
        B = (e) => {
          let { content: t, forumLink: i } = e,
            a = (0, n.useRef)(null),
            o = (0, n.useRef)(null),
            [l, u] = (0, n.useState)(!1),
            [c, h] = (0, n.useState)(!1),
            v = (0, s.dD4)(),
            p = (0, n.useCallback)(() => {
              var e, t;
              let i = null === (e = o.current) || void 0 === e ? void 0 : e.scrollHeight,
                r = null === (t = a.current) || void 0 === t ? void 0 : t.clientHeight;
              i && r && i > r ? u(!0) : u(!1);
            }, []),
            m = (0, n.useCallback)(() => {
              let e = a.current;
              if (!e) return;
              let { scrollTop: t, scrollHeight: i, clientHeight: r } = e;
              h(t + r >= i - 1);
            }, []);
          return (
            (0, n.useEffect)(() => {
              let e = a.current;
              return (
                p(),
                m(),
                e && (e.addEventListener('scroll', m), window.addEventListener('resize', p)),
                () => {
                  e &&
                    (e.removeEventListener('scroll', m), window.removeEventListener('resize', p));
                }
              );
            }, [m, p]),
            (0, r.BX)(w.ac, {
              ref: a,
              children: [
                (0, r.BX)(s.Kqy, {
                  paddingTop: 'm',
                  paddingRight: 's',
                  paddingLeft: 's',
                  paddingBottom: l ? 0 : 'm',
                  ref: o,
                  direction: 'column',
                  gap: 's',
                  children: [
                    (0, r.BX)(s.Kqy, {
                      fullWidth: !0,
                      justify: 'space-between',
                      children: [
                        (0, r.BX)(s.Kqy, {
                          gap: 'xs',
                          align: 'center',
                          children: [
                            (0, r.tZ)(b.$, { children: 'Market Risk Disclosures' }),
                            (0, r.tZ)(s.bEE, {
                              tooltipContent:
                                "Shared by the curator, this section outlines the risks associated with the vault's deployed markets and their configuration.",
                            }),
                          ],
                        }),
                        i &&
                          (0, r.tZ)(n.Fragment, {
                            children: v
                              ? (0, r.tZ)(k.default, {
                                  href: i,
                                  target: '_blank',
                                  children: (0, r.tZ)(s.zxk, {
                                    iconAlone: 'ArrowPlain20',
                                    iconAloneProps: { style: { transform: 'rotate(-45deg)' } },
                                    variant: 'ghost',
                                  }),
                                })
                              : (0, r.tZ)(d.Z, {
                                  href: i,
                                  mode: 'external',
                                  buttonProps: {
                                    variant: 'ghost',
                                    label: 'Learn more at the forum',
                                  },
                                }),
                          }),
                      ],
                    }),
                    (0, r.tZ)(s.xvT.Body.XS.Regular, { whiteSpace: 'pre-wrap', children: t }),
                  ],
                }),
                l && (0, r.tZ)(w.P$, { isScrolledToBottom: c }),
              ],
            })
          );
        };
      function P(e) {
        var t;
        let { curators: i = [] } = e,
          a = i.length > 1,
          o = s.$0l.short.digits(2).unit('$').default('-');
        return (0, r.tZ)(u.xr, {
          minWidth: '220px',
          children: (0, r.BX)(s.Kqy, {
            justify: 'center',
            direction: 'column',
            gap: 's',
            children: [
              a
                ? (0, r.tZ)(r.HY, {
                    children: (0, r.tZ)(s.xvT.Body.XS.Regular, {
                      color: 'text.secondary',
                      children:
                        null == i
                          ? void 0
                          : i.map((e, t) => {
                              var a;
                              return (0, r.BX)(
                                n.Fragment,
                                {
                                  children: [
                                    e.name,
                                    ' AUM',
                                    t <
                                      (null !== (a = null == i ? void 0 : i.length) && void 0 !== a
                                        ? a
                                        : 0) -
                                        1 && ' / ',
                                  ],
                                },
                                'curator-name-'.concat(e.name)
                              );
                            }),
                    }),
                  })
                : (0, r.tZ)(s.xvT.Body.XS.Regular, {
                    color: 'text.secondary',
                    children: 'Curator TVL',
                  }),
              (0, r.tZ)(s.xvT.Body.M.Regular, {
                children: a
                  ? null == i
                    ? void 0
                    : i.map((e, t, i) =>
                        (0, r.BX)(
                          n.Fragment,
                          { children: [o.of(e.aum), t < i.length - 1 && ' / '] },
                          'curator-value-'.concat(e.name)
                        )
                      )
                  : o.of(null == i ? void 0 : null === (t = i[0]) || void 0 === t ? void 0 : t.aum),
              }),
            ],
          }),
        });
      }
      var A = (0, n.memo)(
        (0, f.Z)(function (e) {
          var t, i, h, v, p, m, f, k, A, C, X, S, T, R;
          let { queryResult: D } = e,
            { targetChainId: M } = (0, x.Z_)(),
            q = null == D ? void 0 : D.data.vaultByAddress,
            F = (0, Z.D)(M, q.address),
            K =
              null === (t = q.riskAnalysis) || void 0 === t
                ? void 0
                : t.find((e) => {
                    let { provider: t, isUnderReview: i } = e;
                    return t === o.RiskProvider.Credora && !i;
                  }),
            V = (0, n.useMemo)(() => {
              var e, t;
              return (null === (e = q.state) || void 0 === e ? void 0 : e.curators)
                ? null === (t = q.state) || void 0 === t
                  ? void 0
                  : t.curators.map((e) => {
                      let { __typename: t, state: i, ...r } = e;
                      return { ...r, aum: null == i ? void 0 : i.aum };
                    })
                : [];
            }, [null === (i = q.state) || void 0 === i ? void 0 : i.curators]);
          return (0, r.BX)(s.Kqy, {
            gap: 's',
            direction: 'column',
            align: 'start',
            width: '100%',
            children: [
              (0, r.tZ)(b.$, { children: 'Risk Disclosures' }),
              (0, r.BX)(w.T5, {
                children: [
                  (0, r.tZ)(u.xr, {
                    minWidth: '220px',
                    children: (0, r.BX)(s.Kqy, {
                      direction: 'column',
                      gap: 's',
                      children: [
                        (0, r.BX)(s.Kqy, {
                          gap: 4,
                          align: 'center',
                          children: [
                            (0, r.tZ)(s.xvT.Body.XS.Regular, {
                              color: 'text.secondary',
                              lineHeight: 1,
                              children: 'Risk Score',
                            }),
                            (0, r.tZ)(a.default, {
                              src: (0, l.$B)('/v2/assets/images/credora-network.svg'),
                              alt: 'Credora',
                              height: 17,
                              width: 62,
                            }),
                            (0, r.tZ)(s.ua7, {
                              content: 'Learn more about Credora methodology.',
                              children: (0, r.tZ)(s.Kqy, {
                                children: (0, r.tZ)(d.Z, {
                                  href: 'https://credora.gitbook.io/credora-network-documentation/SZXScuQdZiFKlGcITrLr/morpho-methodologies',
                                  buttonProps: {
                                    variant: 'ghost',
                                    size: 'small',
                                    iconRight: void 0,
                                    iconAlone: 'ArrowDiagonalUpPlain20',
                                    iconAloneProps: { color: 'icon.secondary' },
                                  },
                                }),
                              }),
                            }),
                            (null == K ? void 0 : K.timestamp) &&
                              (0, r.tZ)(s.ua7, {
                                content: 'Last updated: '.concat(
                                  (0, c.J)(null == K ? void 0 : K.timestamp)
                                ),
                                withTouch: !0,
                                children: (0, r.tZ)(s.JO$, {
                                  icon: 'CalendarPlain20',
                                  color: 'icon.secondary',
                                  hoverColor: 'icon.primary',
                                }),
                              }),
                          ],
                        }),
                        (0, r.tZ)(s.xvT.Body.M.Regular, {
                          children:
                            (null == F ? void 0 : F.showCredoraRating) !== !1 &&
                            (null == K ? void 0 : K.rating)
                              ? null == K
                                ? void 0
                                : K.rating
                              : (null == F ? void 0 : F.showCredoraRating) === !1
                                ? 'Not provided by Curator'
                                : 'Has not been rated yet',
                        }),
                      ],
                    }),
                  }),
                  (null !==
                    (S =
                      null === (v = q.state) || void 0 === v
                        ? void 0
                        : null === (h = v.curators) || void 0 === h
                          ? void 0
                          : h.length) && void 0 !== S
                    ? S
                    : 0) > 0 && (0, r.tZ)(P, { curators: V }),
                  (0, r.BX)(u.xr, {
                    minWidth: '220px',
                    children: [
                      (0, r.tZ)(s.xvT.Body.XS.Regular, {
                        color: 'text.secondary',
                        children: 'Vault Deployment Date',
                      }),
                      (0, r.tZ)(s.xvT.Body.M.Regular, {
                        children: (0, c.J)(
                          null !== (T = null == q ? void 0 : q.creationTimestamp) && void 0 !== T
                            ? T
                            : 0
                        ),
                      }),
                    ],
                  }),
                  (null === (p = q.state) || void 0 === p ? void 0 : p.owner) &&
                    (0, r.tZ)(u.mD, {
                      title: 'Owner',
                      toastMessage: 'Owner address copied to clipboard.',
                      tooltipMessage: 'Copy owner address.',
                      address: q.state.owner,
                      minWidth: '220px',
                    }),
                  (null === (m = q.state) || void 0 === m ? void 0 : m.curator) &&
                    (0, r.tZ)(u.mD, {
                      title: 'Curator',
                      toastMessage: 'Curator address copied to clipboard.',
                      tooltipMessage: 'Copy curator address.',
                      address: q.state.curator,
                      minWidth: '220px',
                    }),
                  (null === (f = q.factory) || void 0 === f ? void 0 : f.address) &&
                    (0, r.tZ)(y.E, {
                      chainId: M,
                      factoryAddress: null === (k = q.factory) || void 0 === k ? void 0 : k.address,
                    }),
                  (0, r.tZ)(g, {
                    title: 'Timelock / Guardian',
                    timelock:
                      null == q
                        ? void 0
                        : null === (A = q.state) || void 0 === A
                          ? void 0
                          : A.timelock,
                    address: null === (C = q.state) || void 0 === C ? void 0 : C.guardian,
                  }),
                ],
              }),
              (0, r.tZ)(B, {
                content:
                  null !== (R = null == F ? void 0 : F.disclosure) && void 0 !== R
                    ? R
                    : 'Curator has not submitted a Disclosure.',
                forumLink: null === (X = q.metadata) || void 0 === X ? void 0 : X.forumLink,
              }),
            ],
          });
        })
      );
    },
    46831: function (e, t, i) {
      'use strict';
      i.d(t, {
        default: function () {
          return I;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(12556),
        o = i(54655),
        l = i(35047),
        s = i(27410),
        d = i(33210),
        u = i(22683),
        c = i(82803),
        h = i(89991),
        v = i(4205),
        p = i(55027),
        m = i(53644),
        g = i(59934),
        y = i(34896),
        b = i(89805),
        f = i(53745),
        Z = i(66395),
        x = i(34550),
        w = i(71021),
        k = i(25596),
        B = i(83897),
        P = i(94646),
        A = i(4565),
        C = i(78017),
        X = i(40252);
      let S = (e, t, i) => {
          if (null == e || null == t) return;
          let r = i.toUsd(t);
          if (void 0 !== r)
            return X.MathLib.wMulDown(r, (0, A.safeParseNumber)(Math.pow(1 + e, 1 / 12) - 1, 18));
        },
        T = (e, t, i) => {
          if (null == e || null == t) return;
          let r = (0, A.safeParseNumber)(e, 18),
            n = X.MathLib.wMulDown(r, t);
          return i.toUsd(n);
        };
      var R = i(16820),
        D = i(73057);
      let M = (0, i(38819).Z)(o.Kqy, { target: 'ey3i1bb0' })(
        'animation:',
        o.bx4,
        ' 0.3s ease-in-out;'
      );
      var q = (0, n.memo)((e) => {
          let {
              vaultAddress: t,
              vaultAsset: i,
              localSimulationResult: a,
              userAddress: s,
              netApy: d,
              isLoading: u,
              performanceFee: c,
              dailyApy: h,
              rewards: v,
              points: p,
            } = e,
            { initialData: m, finalData: g } = (0, D.Z)(s, a, t, i),
            y = (0, n.useMemo)(
              () =>
                o.$0l.short
                  .digits((0, o.QQD)(i.price, m.position))
                  .trailingZero(!m.position)
                  .of(m.position, i.decimals),
              [m.position, i.decimals, i.price]
            ),
            b = (0, n.useMemo)(
              () =>
                o.$0l.short
                  .digits((0, o.QQD)(i.price, g.position))
                  .trailingZero(!g.position)
                  .of(g.position, i.decimals),
              [g.position, i.decimals, i.price]
            ),
            f = (0, n.useMemo)(() => o.$0l.percent.default('0.00').unit('%').digits(2).of(d), [d]),
            Z = (0, n.useMemo)(() => {
              let e = T(d, m.position, i);
              return o.$0l.short.digits(2).default('0.00').of(e, 18);
            }, [d, m.position, i]),
            x = (0, n.useMemo)(() => {
              let e = T(d, g.position, i);
              return o.$0l.short.digits(2).of(e, 18);
            }, [d, g.position, i]),
            w = (0, n.useMemo)(() => {
              let e = S(d, m.position, i);
              return o.$0l.short.digits(2).default('0.00').of(e, 18);
            }, [d, i, m.position]),
            k = (0, n.useMemo)(() => {
              let e = S(d, g.position, i);
              return o.$0l.short.digits(2).of(e, 18);
            }, [d, i, g.position]);
          return (0, r.BX)(o.Zbd, {
            direction: 'column',
            gap: 's',
            children: [
              (0, r.BX)(o.Kqy, {
                direction: 'column',
                gap: 'xs',
                children: [
                  (0, r.BX)(o.Kqy, {
                    align: 'center',
                    justify: 'space-between',
                    children: [
                      (0, r.tZ)(o.xvT.Body.XXS.Regular, {
                        color: 'text.secondary',
                        children: 'Your position ('.concat(i.symbol, ')'),
                      }),
                      (0, r.tZ)(o.qEK, { size: 'small', src: i.logoURI }),
                    ],
                  }),
                  (0, r.BX)(o.Kqy, {
                    align: 'center',
                    gap: 2,
                    children: [
                      u
                        ? (0, r.tZ)(o.OdW, {
                            width: '50px',
                            height: '23px',
                            borderRadius: '6px',
                            margin: '3px 0',
                          })
                        : (0, r.tZ)(o.xvT.Body.L.Regular, {
                            color: (0, l.isDefined)(g.position) ? 'text.tertiary' : 'text.primary',
                            children: y,
                          }),
                      (0, l.isDefined)(g.position) &&
                        (0, r.BX)(M, {
                          align: 'center',
                          gap: 2,
                          children: [
                            (0, r.tZ)(o.JO$, { icon: 'ArrowRightPlain20', color: 'icon.tertiary' }),
                            (0, r.tZ)(o.xvT.Body.L.Regular, { children: b }),
                          ],
                        }),
                    ],
                  }),
                ],
              }),
              (0, r.BX)(o.Kqy, {
                direction: 'column',
                gap: 'xs',
                children: [
                  (0, r.tZ)(o.xvT.Body.XXS.Regular, { color: 'text.secondary', children: 'APY' }),
                  (0, r.tZ)(C.w, {
                    RewardsHoverCardProps: {
                      performanceFee: (0, R.Pi)(c, A.safeParseNumber),
                      apy: (0, R.Pi)(h, A.safeParseNumber),
                      rewards: v,
                      points: p,
                      variant: 'vault',
                      netApy: (0, R.Pi)(d, A.safeParseNumber),
                      asset: i,
                    },
                    children: (0, r.tZ)(o.xvT.Body.L.Regular, { children: f }),
                  }),
                ],
              }),
              (0, r.BX)(o.Kqy, {
                direction: 'column',
                gap: 'xs',
                children: [
                  (0, r.tZ)(o.xvT.Body.XXS.Regular, {
                    color: 'text.secondary',
                    children: 'Projected Earnings / Month (USD)',
                  }),
                  (0, r.BX)(o.Kqy, {
                    align: 'center',
                    gap: 2,
                    children: [
                      u
                        ? (0, r.tZ)(o.OdW, {
                            width: '50px',
                            height: '23px',
                            borderRadius: '6px',
                            margin: '3px 0',
                          })
                        : (0, r.tZ)(o.xvT.Body.L.Regular, {
                            color: k ? 'text.tertiary' : 'text.primary',
                            children: w,
                          }),
                      k &&
                        (0, r.BX)(M, {
                          align: 'center',
                          gap: 2,
                          children: [
                            (0, r.tZ)(o.JO$, { icon: 'ArrowRightPlain20', color: 'icon.tertiary' }),
                            (0, r.tZ)(o.xvT.Body.L.Regular, { children: k }),
                          ],
                        }),
                    ],
                  }),
                ],
              }),
              (0, r.BX)(o.Kqy, {
                direction: 'column',
                gap: 'xs',
                children: [
                  (0, r.tZ)(o.xvT.Body.XXS.Regular, {
                    color: 'text.secondary',
                    children: 'Projected Earnings / Year (USD)',
                  }),
                  (0, r.BX)(o.Kqy, {
                    align: 'center',
                    gap: 2,
                    children: [
                      u
                        ? (0, r.tZ)(o.OdW, {
                            width: '50px',
                            height: '23px',
                            borderRadius: '6px',
                            margin: '3px 0',
                          })
                        : (0, r.tZ)(o.xvT.Body.L.Regular, {
                            color: x ? 'text.tertiary' : 'text.primary',
                            children: Z,
                          }),
                      x &&
                        (0, r.BX)(M, {
                          align: 'center',
                          gap: 2,
                          children: [
                            (0, r.tZ)(o.JO$, { icon: 'ArrowRightPlain20', color: 'icon.tertiary' }),
                            (0, r.tZ)(o.xvT.Body.L.Regular, { children: x }),
                          ],
                        }),
                    ],
                  }),
                ],
              }),
            ],
          });
        }),
        F = (0, n.memo)((e) => {
          var t, i, l, s;
          let { vaultAddress: d, vaultAsset: c, vault: v, apiState: p } = e,
            { account: A, targetChainId: C } = (0, h.Z_)(),
            { toggleRightPanel: X, isRightPanelOpen: S } = (0, o.s8G)(),
            { toggleDialog: T } = (0, o.DAv)(),
            {
              simulationError: R,
              operations: D,
              isPending: M,
              blockError: F,
              updateOperation: K,
              bundlerConfiguration: V,
            } = (0, u.N)(),
            {
              isNew: I,
              inputAmount: E,
              setInputAmount: L,
              maxAmount: $,
              isLoading: O,
              isMax: U,
              setIsMax: z,
              initialState: N,
              localOperation: W,
              confirm: _,
              cancel: G,
              peripheralTokenOptions: j,
              setIsEditing: H,
              isEditing: Q,
              onPeripheralTokenOptionChange: Y,
            } = (0, w.o)(d, { origin: 'simple-action-panel' }),
            { isReadOnly: J } = (0, a.WW)({ chainId: v.chain.id, address: d }),
            ee = A.isConnected ? N.data : p,
            [et, ei, er, en] = (0, b._)(ee, W, V, I),
            ea = (0, f.Z)(er, N.data, c.address),
            eo = (0, Z.Z)(en, null == ei ? void 0 : ei.message),
            el = (0, n.useMemo)(
              () => !!ei || !!en || (!!Q && !I) || !!J || !ea || !(0, y.H)(W),
              [Q, W, ei, I, en, ea, J]
            ),
            es = (0, k.ZP)({
              address: d,
              error: eo,
              isWrongChain: A.isWrongChain,
              chainId: v.chain.id,
            }),
            ed = (0, n.useCallback)(() => {
              I && _(), X(!0);
            }, [_, I, X]);
          (0, n.useEffect)(() => {
            S && G();
          }, [G, S]);
          let eu = (0, n.useMemo)(
              () =>
                (Q && !I) || (F && M) || !!eo || !!R || !(0, y.H)(W) || J || !ea || A.isWrongChain,
              [J, Q, I, F, M, eo, R, W, ea, A.isWrongChain]
            ),
            ec = (0, x.Z)('deposit', 0n === E, I, Q, eo, D, R, F, M, A.isWrongChain, J),
            eh = (0, n.useCallback)(() => {
              T((0, r.tZ)(P.Z, { operations: [W] }));
            }, [W, T]),
            ev = (0, B.M)(d, v.state, v.asset),
            ep = (0, o.vmq)({
              chainId: C,
              vaultAddress: v.address,
              allocation: null === (t = v.state) || void 0 === t ? void 0 : t.allocation,
            });
          return (0, r.BX)(r.HY, {
            children: [
              (0, r.BX)(o.Kqy, {
                direction: 'column',
                gap: 2,
                children: [
                  (0, r.tZ)(o.ISm, {
                    header: 'Deposit '.concat(c.symbol),
                    token: c,
                    amount: E,
                    onChange: L,
                    maxValue: $,
                    isMaxLoading: O,
                    isMax: U,
                    onMaxClick: z,
                    peripheralTokenOptions: j,
                    onPeripheralTokenChange: Y,
                    autoFocus: !0,
                    ...(!I && {
                      localErrorMessage: eo,
                      isBundlerInput: !0,
                      isEditing: Q,
                      onIsEditingChange: H,
                      onEditConfirm: _,
                      onEditCancel: G,
                      onReset: () => {
                        K(W.id);
                      },
                    }),
                  }),
                  !ea && (0, r.tZ)(m.r, { tokenAddress: c.address }),
                ],
              }),
              (0, r.tZ)(q, {
                vaultAsset: c,
                vaultAddress: d,
                localSimulationResult: et,
                userAddress: er,
                netApy: null === (i = v.state) || void 0 === i ? void 0 : i.dailyNetApy,
                performanceFee: null === (l = v.state) || void 0 === l ? void 0 : l.fee,
                dailyApy: null === (s = v.state) || void 0 === s ? void 0 : s.dailyApy,
                rewards: ev,
                isLoading: O,
                points: ep,
              }),
              (0, r.tZ)(g.N, {
                handleFinalize: eh,
                handleConfirm: ed,
                isLoading: O,
                isNew: I,
                finalizeLabel: ec,
                tooltipContent: es,
                isFinalizeDisabled: eu,
                isConfirmDisabled: el,
              }),
            ],
          });
        }),
        K = i(48972),
        V = (0, n.memo)((e) => {
          var t, i, l, s;
          let { vaultAddress: d, vaultAsset: c, vault: v, apiState: p } = e,
            { account: w, targetChainId: A } = (0, h.Z_)(),
            { toggleRightPanel: C, isRightPanelOpen: X } = (0, o.s8G)(),
            { toggleDialog: S } = (0, o.DAv)(),
            {
              simulationError: T,
              operations: R,
              blockError: D,
              isPending: M,
              updateOperation: F,
              bundlerConfiguration: V,
            } = (0, u.N)(),
            {
              isNew: I,
              inputAmount: E,
              setInputAmount: L,
              maxAmount: $,
              isLoading: O,
              isMax: U,
              setIsMax: z,
              initialState: N,
              localOperation: W,
              confirm: _,
              cancel: G,
              setIsEditing: j,
              isEditing: H,
            } = (0, K.L)(d, { origin: 'simple-action-panel' }),
            { isReadOnly: Q } = (0, a.WW)({ chainId: v.chain.id, address: d }),
            Y = w.isConnected ? N.data : p,
            [J, ee, et, ei] = (0, b._)(Y, W, V, !1),
            er = (0, Z.Z)(ei, null == ee ? void 0 : ee.message),
            en = (0, f.Z)(et, N.data, c.address),
            ea = (0, n.useMemo)(
              () => !!ee || !!ei || (!!H && !I) || !en || !(0, y.H)(W),
              [H, W, ee, I, ei, en]
            ),
            eo = (0, n.useCallback)(() => {
              I && _(), C(!0);
            }, [_, I, C]);
          (0, n.useEffect)(() => {
            X && G();
          }, [G, X]);
          let el = (0, n.useMemo)(
              () =>
                (H && !I) || (D && M) || !!er || !!T || !(0, y.H)(W) || Q || w.isWrongChain || !en,
              [H, I, D, M, er, T, W, Q, w.isWrongChain, en]
            ),
            es = (0, x.Z)('withdrawal', 0n === E, I, H, er, R, T, D, M, w.isWrongChain, Q),
            ed = (0, k.ZP)({
              address: d,
              error: er,
              isWrongChain: w.isWrongChain,
              chainId: v.chain.id,
            }),
            eu = (0, n.useCallback)(() => {
              S((0, r.tZ)(P.Z, { operations: [W] }));
            }, [W, S]),
            ec = (0, B.M)(d, v.state, v.asset),
            eh = (0, o.vmq)({
              chainId: A,
              vaultAddress: v.address,
              allocation: null === (t = v.state) || void 0 === t ? void 0 : t.allocation,
            });
          return (0, r.BX)(r.HY, {
            children: [
              (0, r.BX)(o.Kqy, {
                direction: 'column',
                gap: 2,
                children: [
                  (0, r.tZ)(o.ISm, {
                    header: 'Withdraw '.concat(c.symbol),
                    token: c,
                    amount: E,
                    onChange: L,
                    maxValue: $,
                    isMaxLoading: O,
                    isMax: U,
                    onMaxClick: z,
                    autoFocus: !0,
                    ...(!I && {
                      localErrorMessage: er,
                      isBundlerInput: !0,
                      isEditing: H,
                      onIsEditingChange: j,
                      onEditConfirm: _,
                      onEditCancel: G,
                      onReset: () => {
                        F(W.id);
                      },
                    }),
                  }),
                  !en && (0, r.tZ)(m.r, { tokenAddress: c.address }),
                ],
              }),
              (0, r.tZ)(q, {
                vaultAsset: c,
                vaultAddress: d,
                localSimulationResult: J,
                userAddress: et,
                netApy: null === (i = v.state) || void 0 === i ? void 0 : i.dailyNetApy,
                performanceFee: null === (l = v.state) || void 0 === l ? void 0 : l.fee,
                dailyApy: null === (s = v.state) || void 0 === s ? void 0 : s.dailyApy,
                rewards: ec,
                isLoading: O,
                points: eh,
              }),
              (0, r.tZ)(g.N, {
                handleFinalize: eu,
                handleConfirm: eo,
                isLoading: O,
                isNew: I,
                finalizeLabel: es,
                tooltipContent: ed,
                isFinalizeDisabled: el,
                isConfirmDisabled: ea,
              }),
            ],
          });
        }),
        I = (0, n.memo)(
          (0, d.Z)((e) => {
            let { vaultAddress: t, queryResult: i } = e,
              {
                operations: d,
                config: { addVaults: m, addMarketIds: g, addTokens: y },
              } = (0, u.N)(),
              { account: b } = (0, h.Z_)(),
              f = (0, v.f)(0),
              Z = (0, n.useMemo)(() => (0, p.o)(i.data), [i.data]),
              [x, w] = (0, n.useState)(c.H.InterfaceOperationType.metaMorphoDeposit);
            (0, n.useEffect)(() => {
              b.isConnected &&
                (m(...(0, l.keys)(Z.vaults)),
                y(...(0, l.keys)(Z.tokens)),
                g(...(0, l.keys)(Z.markets)));
            }, [b.isConnected, Z.vaults, Z.tokens, Z.markets, m, y, g]);
            let k = i.data.vaultByAddress,
              B = (0, n.useMemo)(() => (0, a.wk)(k.asset), [k.asset]),
              P = (0, n.useMemo)(() => {
                var e;
                let i = b.address;
                if (!i) return !1;
                let r = d.some(
                    (e) =>
                      (e.type === c.H.InterfaceOperationType.metaMorphoDeposit ||
                        e.type === c.H.InterfaceOperationType.metaMorphoWithdraw) &&
                      e.vaultAddress === t
                  ),
                  n = !!(null === (e = f.data) || void 0 === e
                    ? void 0
                    : e.getBundleBalance(i, t, !0));
                return r || n;
              }, [b.address, f.data, d, t]);
            return (
              (0, n.useEffect)(() => {
                P || w(c.H.InterfaceOperationType.metaMorphoDeposit);
              }, [P]),
              (0, r.BX)(o.Kqy, {
                direction: 'column',
                gap: 's',
                basis: '100%',
                'data-testid': 'vault-action-panel',
                children: [
                  P &&
                    (0, r.BX)(o.Kqy, {
                      gap: 4,
                      justify: 'stretch',
                      align: 'center',
                      children: [
                        (0, r.tZ)(s.Z, {
                          type: c.H.InterfaceOperationType.metaMorphoDeposit,
                          onClick: () => w(c.H.InterfaceOperationType.metaMorphoDeposit),
                          label: 'Deposit',
                          currentType: x,
                        }),
                        (0, r.tZ)(s.Z, {
                          type: c.H.InterfaceOperationType.metaMorphoWithdraw,
                          onClick: () => {
                            w(c.H.InterfaceOperationType.metaMorphoWithdraw);
                          },
                          label: 'Withdraw',
                          currentType: x,
                        }),
                      ],
                    }),
                  x === c.H.InterfaceOperationType.metaMorphoDeposit &&
                    (0, r.tZ)(F, { vaultAddress: t, vault: k, vaultAsset: B, apiState: Z }),
                  x === c.H.InterfaceOperationType.metaMorphoWithdraw &&
                    (0, r.tZ)(V, { vaultAddress: t, vault: k, vaultAsset: B, apiState: Z }),
                ],
              })
            );
          })
        );
    },
    55027: function (e, t, i) {
      'use strict';
      i.d(t, {
        o: function () {
          return d;
        },
      });
      var r,
        n = i(68612),
        a = i(40252),
        o = i(35047),
        l = i(51196),
        s = i(27987);
      let d = function (e) {
        var t,
          i,
          d,
          u,
          c,
          h,
          v,
          p,
          m,
          g,
          y,
          b,
          f,
          Z,
          x,
          w,
          k,
          B,
          P,
          A,
          C,
          X,
          S,
          T,
          R,
          D,
          M,
          q,
          F,
          K,
          V,
          I,
          E,
          L,
          $,
          O;
        let U =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : new l.SimulationState({
                  chainId: e.vaultByAddress.chain.id,
                  block: {
                    number: 0n,
                    timestamp:
                      null !==
                        (r =
                          null === (O = e.vaultByAddress.state) || void 0 === O
                            ? void 0
                            : O.timestamp) && void 0 !== r
                        ? r
                        : 0n,
                  },
                  tokens: {},
                  markets: {},
                  vaultMarketConfigs: {},
                  vaults: {},
                  users: {},
                  positions: {},
                  holdings: {},
                }),
          z = e.vaultByAddress,
          N = z.chain.id;
        (null !== (k = (d = U.vaults)[(u = z.address)]) && void 0 !== k) ||
          (d[u] = s.Z.getVault(z)),
          (null !== (B = (c = U.users)[(h = z.address)]) && void 0 !== B) ||
            (c[h] = new a.User({ address: z.address, isBundlerAuthorized: !1, morphoNonce: 0n })),
          (null !== (P = (v = U.tokens)[(p = z.asset.address)]) && void 0 !== P) ||
            (v[p] = s.Z.getToken(z.asset)),
          (null !== (A = (m = U.tokens)[(g = z.address)]) && void 0 !== A) ||
            (m[g] = s.Z.getToken({ ...z, decimals: 18 })),
          (null !==
            (X = (f =
              null !== (C = (y = U.holdings)[(b = z.address)]) && void 0 !== C ? C : (y[b] = {}))[
              (Z = z.asset.address)
            ]) &&
            void 0 !== X) ||
            (f[Z] = new a.Holding({
              user: z.address,
              token: z.asset.address,
              balance: 0n,
              erc20Allowances: { morpho: n.zL, permit2: 0n, 'bundler3.generalAdapter1': 0n },
              permit2BundlerAllowance: { amount: 0n, expiration: 0n, nonce: 0n },
            })),
          null === (i = z.state) ||
            void 0 === i ||
            null === (t = i.allocation) ||
            void 0 === t ||
            t.forEach((e) => {
              var t, i, r, n, o, l, d, u, c, h, v, p, m, g, y, b, f, Z, x, w, k;
              let {
                market: { collateralAsset: B, loanAsset: P },
              } = e;
              B &&
                ((null !== (y = (t = U.tokens)[(i = B.address)]) && void 0 !== y) ||
                  (t[i] = s.Z.getToken(B))),
                (null !== (b = (r = U.tokens)[(n = P.address)]) && void 0 !== b) ||
                  (r[n] = s.Z.getToken(P));
              let A = s.Z.getVaultMarketAllocation(z.address, e, z.publicAllocatorConfig);
              (A.position.market.lastUpdate = a.MathLib.min(
                A.position.market.lastUpdate,
                U.block.timestamp
              )),
                (null !== (f = (o = U.markets)[(l = A.marketId)]) && void 0 !== f) ||
                  (o[l] = A.position.market),
                (null !==
                  (x = (c =
                    null !== (Z = (d = U.positions)[(u = z.address)]) && void 0 !== Z
                      ? Z
                      : (d[u] = {}))[(h = A.marketId)]) &&
                  void 0 !== x) ||
                  (c[h] = A.position),
                (null !==
                  (k = (m =
                    null !== (w = (v = U.vaultMarketConfigs)[(p = z.address)]) && void 0 !== w
                      ? w
                      : (v[p] = {}))[(g = A.marketId)]) &&
                  void 0 !== k) ||
                  (m[g] = A.config);
            });
        let { bundler3: W } = (0, a.getChainAddresses)(N);
        for (let e of ((null !== (S = (x = U.users)[(w = W.generalAdapter1)]) && void 0 !== S) ||
          (x[w] = new a.User({
            address: W.generalAdapter1,
            isBundlerAuthorized: !1,
            morphoNonce: 0n,
          })),
        (0, o.values)(U.tokens)))
          e &&
            ((null !==
              (F = (D =
                null !== (q = (T = U.holdings)[(R = W.generalAdapter1)]) && void 0 !== q
                  ? q
                  : (T[R] = {}))[(M = e.address)]) &&
              void 0 !== F) ||
              (D[M] = new a.Holding({
                user: W.generalAdapter1,
                token: e.address,
                balance: 0n,
                erc20Allowances: { morpho: n.zL, permit2: 0n, 'bundler3.generalAdapter1': 0n },
                permit2BundlerAllowance: { amount: 0n, expiration: 0n, nonce: 0n },
              })));
        for (let e of (0, o.values)(U.markets))
          e &&
            ((null !==
              ($ = (I =
                null !== (L = (K = U.positions)[(V = W.generalAdapter1)]) && void 0 !== L
                  ? L
                  : (K[V] = {}))[(E = e.id)]) &&
              void 0 !== $) ||
              (I[E] = new a.Position({
                user: W.generalAdapter1,
                marketId: e.id,
                supplyShares: 0n,
                borrowShares: 0n,
                collateral: 0n,
              })));
        return U;
      };
    },
    84478: function (e, t, i) {
      'use strict';
      i.d(t, {
        default: function () {
          return C;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(12556),
        o = i(54655),
        l = i(35047),
        s = i(77345),
        d = i(81919),
        u = i(76992),
        c = i(33210),
        h = i(18313),
        v = i(26726),
        p = i(89991),
        m = i(93319),
        g = i(34937),
        y = i(57935),
        b = i(83669),
        f = i(243),
        Z = i(55412),
        x = i(3245),
        w = i(41512),
        k = i(24387);
      function B() {
        let e = (0, Z._)([
          '\n  query GetUserVaultPositionHistoryTimeseries(\n    $userAddress: String!\n    $vaultAddress: String!\n    $chainId: Int!\n    $options: TimeseriesOptions\n    $fetchAssets: Boolean!\n    $fetchAssetsUsd: Boolean!\n  ) {\n    vaultPosition(\n      userAddress: $userAddress\n      vaultAddress: $vaultAddress\n      chainId: $chainId\n    ) {\n      id\n      assets\n      assetsUsd\n      vault {\n        id\n        address\n        asset {\n          ...assetFields\n        }\n      }\n      historicalState {\n        assets(options: $options) @include(if: $fetchAssets) {\n          x\n          y\n        }\n        assetsUsd(options: $options) @include(if: $fetchAssetsUsd) {\n          x\n          y\n        }\n      }\n    }\n  }\n  ',
          '\n  ',
          '\n',
        ]);
        return (
          (B = function () {
            return e;
          }),
          e
        );
      }
      let P = (0, x.Ps)(B(), w.n, k.G),
        A = o.$0l.short.trailingZero(!1).default('0.00');
      var C = (0, n.memo)(
        (0, c.Z)((e) => {
          var t, i, c, Z, x, w;
          let { queryVariables: k, queryResult: B, now: C, positionManagerSlot: X } = e,
            { palette: S } = (0, o.rFV)(),
            T = (0, o.dD4)(),
            { account: R } = (0, p.Z_)(),
            D = (0, v.nh)(v.TP.POSITION_HISTORY),
            [M, q] = (0, n.useState)(h.B),
            [F, K] = (0, n.useState)('assets'),
            V = (0, n.useMemo)(() => {
              var e;
              return {
                ...k,
                userAddress: null !== (e = R.address) && void 0 !== e ? e : '',
                fetchAssets: 'assets' === F,
                fetchAssetsUsd: 'assetsUsd' === F,
                options: (0, g.Ai)({ timeFrame: M, now: C }),
              };
            }, [F, C, M, k, R.address]),
            I = (0, b.s)({
              queryDocument: P,
              queryVariables: V,
              serverQueryResult: B,
              serverQueryVariables: k,
            }),
            { targetChainId: E } = (0, p.Z_)(),
            {
              data: L,
              loading: $,
              isNotFound: O,
              error: U,
            } = (0, n.useMemo)(() => (0, f.I)(I), [I]),
            { data: z } = (0, s.sW)({
              variables: { where: { address_in: [k.vaultAddress], chainId_in: [E] } },
              skip: !R.address,
            }),
            { positions: N } = (0, y.w)({
              existingPositions: (0, l.isDefined)(null == L ? void 0 : L.vaultPosition)
                ? [L.vaultPosition]
                : [],
              missingVaults:
                null !== (w = null == z ? void 0 : z.vaults.items) && void 0 !== w ? w : [],
            }),
            W = (0, n.useMemo)(
              () => (null == N ? void 0 : N.find((e) => e.vault.address === k.vaultAddress)),
              [N, k.vaultAddress]
            ),
            _ = (0, n.useMemo)(
              () => (0, a.wk)(null == W ? void 0 : W.vault.asset),
              [null == W ? void 0 : W.vault.asset]
            ),
            G = (0, n.useMemo)(() => {
              let e = [];
              return (
                (null == _ ? void 0 : _.symbol) && e.push({ value: 'assets', label: _.symbol }),
                e.push({ value: 'assetsUsd', label: 'USD' }),
                e
              );
            }, [null == _ ? void 0 : _.symbol]),
            j = (0, n.useMemo)(() => (O ? void 0 : U), [O, U]),
            H = (0, n.useMemo)(() => {
              var e, t, i, r;
              let n = [];
              switch (F) {
                case 'assets':
                  n = (0, o.EES)(
                    null == L
                      ? void 0
                      : null === (e = L.vaultPosition.historicalState) || void 0 === e
                        ? void 0
                        : e.assets,
                    null !==
                      (i =
                        null == L
                          ? void 0
                          : null === (t = L.vaultPosition.vault.asset) || void 0 === t
                            ? void 0
                            : t.decimals) && void 0 !== i
                      ? i
                      : 18
                  );
                  break;
                case 'assetsUsd':
                  n = (0, o.EES)(
                    null == L
                      ? void 0
                      : null === (r = L.vaultPosition.historicalState) || void 0 === r
                        ? void 0
                        : r.assetsUsd
                  );
              }
              return (0, o.q6y)(n);
            }, [
              null == L
                ? void 0
                : null === (t = L.vaultPosition.historicalState) || void 0 === t
                  ? void 0
                  : t.assets,
              null == L
                ? void 0
                : null === (i = L.vaultPosition.historicalState) || void 0 === i
                  ? void 0
                  : i.assetsUsd,
              null == L
                ? void 0
                : null === (c = L.vaultPosition.vault.asset) || void 0 === c
                  ? void 0
                  : c.decimals,
              F,
            ]),
            Q = (0, n.useMemo)(() => !(0, o.ckA)(H), [H]),
            Y = (0, n.useMemo)(() => (0, l.isDefined)(W), [W]),
            J = (0, a.DI)(null == W ? void 0 : W.simulatedValues.assets.value),
            ee = (0, a.DI)(null == W ? void 0 : W.simulatedValues.assetsUsd.value),
            et = (0, n.useMemo)(() => {
              switch (F) {
                case 'assets':
                  var e, t, i;
                  return {
                    value: J,
                    decimals:
                      null !==
                        (i =
                          null == W
                            ? void 0
                            : null === (t = W.vault) || void 0 === t
                              ? void 0
                              : null === (e = t.asset) || void 0 === e
                                ? void 0
                                : e.decimals) && void 0 !== i
                        ? i
                        : 18,
                  };
                case 'assetsUsd':
                  return { value: ee, decimals: 18 };
              }
            }, [
              F,
              J,
              null == W
                ? void 0
                : null === (x = W.vault) || void 0 === x
                  ? void 0
                  : null === (Z = x.asset) || void 0 === Z
                    ? void 0
                    : Z.decimals,
              ee,
            ]),
            ei = (0, n.useMemo)(
              () =>
                (0, m.l)(
                  A.digits((0, o.QQD)(null == _ ? void 0 : _.price, et.value))
                    .trailingZero(!et.value)
                    .of(et.value, et.decimals)
                ),
              [et, null == _ ? void 0 : _.price]
            ),
            er = (0, n.useMemo)(
              () =>
                (null == W ? void 0 : W.simulatedValues.assets.isSimulated) ||
                (null == W ? void 0 : W.isNew),
              [
                null == W ? void 0 : W.simulatedValues.assets.isSimulated,
                null == W ? void 0 : W.isNew,
              ]
            ),
            en = (0, n.useMemo)(() => {
              var e;
              let t =
                  null === (e = G.find((e) => e.value === F)) || void 0 === e ? void 0 : e.label,
                i = 'My Deposit';
              return t ? ''.concat(i, ' (').concat(t, ')') : i;
            }, [F, G]),
            ea = (0, n.useMemo)(() => {
              var e;
              return 'assetsUsd' === F
                ? '$'
                : (0, l.formatLongString)(
                    null !== (e = null == _ ? void 0 : _.symbol) && void 0 !== e ? e : ''
                  );
            }, [F, null == _ ? void 0 : _.symbol]);
          return (0, r.BX)(o.Zbd, {
            fullWidth: !0,
            gap: 'm',
            direction: 'column',
            paddingBlock: 'm',
            paddingInline: { base: 'm', s: 's' },
            children: [
              (0, r.BX)(o.Kqy, {
                justify: 'space-between',
                align: 'center',
                gap: 's',
                wrap: 'wrap',
                children: [
                  (0, r.BX)(o.Kqy, {
                    direction: 'column',
                    gap: 'xs',
                    children: [
                      (0, r.BX)(o.Kqy, {
                        gap: 'xs',
                        align: 'center',
                        children: [
                          (0, r.tZ)(o.xvT.Body.XS.Regular, {
                            color: 'text.secondary',
                            children: en,
                          }),
                          X,
                        ],
                      }),
                      $ && null === et.value
                        ? (0, r.BX)(o.Kqy, {
                            gap: 's',
                            align: 'center',
                            children: [
                              (0, r.tZ)(o.OdW, {
                                height: '46px',
                                width: '130px',
                                borderRadius: '20px',
                              }),
                              (0, r.tZ)(o.OdW, {
                                height: '26px',
                                width: '50px',
                                borderRadius: '120px',
                              }),
                            ],
                          })
                        : (0, r.BX)(o.Kqy, {
                            gap: 's',
                            align: 'center',
                            children: [
                              (0, r.BX)(o.Kqy, {
                                gap: 2,
                                align: 'center',
                                children: [
                                  'assetsUsd' === F &&
                                    (0, r.tZ)(o.ZT$, {
                                      TextVariant: o.xvT.Title.S,
                                      isSimulated: er,
                                      color: 'text.tertiary',
                                      children: '$',
                                    }),
                                  (0, r.tZ)(o.ZT$, {
                                    TextVariant: o.xvT.Title.S,
                                    isSimulated: er,
                                    children: ei.value,
                                  }),
                                  (0, r.tZ)(o.ZT$, {
                                    TextVariant: o.xvT.Title.S,
                                    isSimulated: er,
                                    color: 'text.tertiary',
                                    children: ei.unit,
                                  }),
                                ],
                              }),
                              D &&
                                (0, r.tZ)(r.HY, {
                                  children: $
                                    ? (0, r.tZ)(o.OdW, {
                                        height: '18px',
                                        width: '50px',
                                        borderRadius: '120px',
                                      })
                                    : (0, r.tZ)(d.Z, { formattedData: H }),
                                }),
                            ],
                          }),
                    ],
                  }),
                  (0, r.BX)(o.Kqy, {
                    align: 'center',
                    gap: 's',
                    wrap: 'wrap',
                    children: [
                      T
                        ? (0, r.tZ)(o.PhF, { options: G, value: F, onChange: K, disabled: !Y })
                        : (0, r.tZ)(u.E, {
                            variant: 'secondary',
                            id: 'chart-options-mode',
                            options: G,
                            value: F,
                            onChange: K,
                            disabled: !Y,
                          }),
                      (0, r.tZ)(o.PhF, {
                        options: h.SC,
                        value: M,
                        onChange: q,
                        disabled: !Y || !D,
                      }),
                    ],
                  }),
                ],
              }),
              D
                ? (0, r.tZ)(o._9J, {
                    statuses: { loading: $, error: j },
                    unit: ea,
                    height: '224px',
                    series: Q
                      ? [
                          {
                            type: 'areaspline',
                            name: 'Total '.concat(F),
                            data: H,
                            color: S.colors[0],
                            lineColor: S.colors[0],
                            fillColor: S.areaChartColors[0],
                          },
                        ]
                      : [],
                    additionalOptions: { yAxis: { softMin: 0, maxPadding: 0.4 } },
                  })
                : (0, r.tZ)(o.SKT, {
                    text: 'Position history is temporarily unavailable.',
                    height: '224px',
                  }),
            ],
          });
        })
      );
    },
    5500: function (e, t, i) {
      'use strict';
      i.d(t, {
        _: function () {
          return d;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(99079),
        o = i(3808),
        l = i(16102),
        s = i(54655);
      function d(e) {
        let { timestamp: t } = e;
        if (void 0 === t) return (0, r.tZ)(s.OdW, { height: 26 });
        if (null === t) return (0, r.tZ)(r.HY, {});
        let i = (0, a.K)(Number(t));
        return (0, r.tZ)(s.ua7, {
          content: (0, o.s)(i),
          children: (0, r.tZ)(s.xvT.Body.XS.Regular, {
            color: 'text.body',
            children: (0, l.U)(i, new Date()),
          }),
        });
      }
      t.Z = (0, n.memo)(d);
    },
    59934: function (e, t, i) {
      'use strict';
      i.d(t, {
        N: function () {
          return s;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(54655),
        o = i(89991);
      let l = (0, i(38819).Z)(a.Kqy, { target: 'ernm57p0' })(
        'padding-bottom:',
        (e) => {
          let { theme: t } = e;
          return t.spacing.s;
        },
        ';',
        (e) => {
          let { theme: t } = e;
          return t.breakpoints.down('s');
        },
        '{order:-1;padding-bottom:0;}'
      );
      var s = (0, n.memo)((e) => {
        let {
            isLoading: t,
            isNew: i,
            handleFinalize: n,
            handleConfirm: s,
            finalizeLabel: d,
            tooltipContent: u,
            isFinalizeDisabled: c,
            isConfirmDisabled: h,
          } = e,
          { account: v, modal: p } = (0, o.Z_)(),
          m = (0, a.ajf)('s');
        return (0, r.tZ)(r.HY, {
          children: v.isConnected
            ? (0, r.tZ)(a.Kqy, {
                direction: 'column',
                gap: 8,
                align: 'stretch',
                justify: 'start',
                style: { paddingBottom: 12 },
                children: t
                  ? (0, r.tZ)(a.zxk, {
                      variant: 'secondary',
                      size: 'big',
                      disabled: !0,
                      iconLeft: 'AlertPlain20',
                      label: 'Loading onchain state',
                    })
                  : (0, r.BX)(r.HY, {
                      children: [
                        (0, r.tZ)(a.ua7, {
                          content: u,
                          disabled: !u,
                          children: (0, r.tZ)(a.zxk, {
                            size: 'big',
                            autoCapitalize: 'on',
                            variant: c ? 'secondary' : 'primary',
                            label: d,
                            disabled: c,
                            onClick: n,
                            shortenByWidth: 220,
                            'data-testid': 'finalize-button',
                          }),
                        }),
                        !m &&
                          !h &&
                          (0, r.tZ)(a.zxk, {
                            autoCapitalize: 'on',
                            variant: 'secondary',
                            size: 'big',
                            onClick: s,
                            label: i ? 'Add to bundler' : 'View in bundler',
                            'data-testid': 'add-to-bundler-button',
                          }),
                      ],
                    }),
              })
            : (0, r.tZ)(l, {
                direction: 'column',
                gap: 8,
                align: 'stretch',
                justify: 'start',
                children: (0, r.tZ)(a.zxk, {
                  variant: 'primary',
                  size: 'big',
                  onClick: () => p.open(),
                  label: 'Connect Wallet',
                }),
              }),
        });
      });
    },
    52234: function (e, t, i) {
      'use strict';
      i.d(t, {
        D: function () {
          return l;
        },
      });
      var r = i(78286),
        n = i(40252),
        a = i(54655);
      let o = {
          [n.ChainId.EthMainnet]: {
            '0x749794E985Af5a9A384B9cEe6D88DaB4CE1576A1': { showCredoraRating: !1 },
            '0xD50DA5F859811A91fD1876C9461fD39c23C747Ad': { showCredoraRating: !1 },
            '0xc582F04d8a82795aa2Ff9c8bb4c1c889fe7b754e': { showCredoraRating: !1 },
            '0x78Fc2c2eD1A4cDb5402365934aE5648aDAd094d0': { showCredoraRating: !0 },
            '0xA02F5E93f783baF150Aa1F8b341Ae90fe0a772f7': { showCredoraRating: !0 },
            '0x95EeF579155cd2C5510F312c8fA39208c3Be01a8': { showCredoraRating: !0 },
            '0xE0C98605f279e4D7946d25B75869c69802823763': { showCredoraRating: !0 },
            '0x64964E162Aa18d32f91eA5B24a09529f811AEB8e': { showCredoraRating: !0 },
            '0xb0f05E4De970A1aaf77f8C2F823953a367504BA9': {
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      'Participation in the Falcon USDC Core vault involves exposure to assets issued by Falcon Finance—namely USDf and sUSDf. USDf is an overcollateralized synthetic dollar designed to maintain its peg to the U.S. dollar. To support peg stability, Falcon either creates hedged positions for the underlying collateral or directly converts deposits into USD at entry. While engineered for stability, USDf remains subject to risks such as depegging from collateral volatility or broader market stress.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      "sUSDf is a yield-bearing token backed by Falcon's institutional-grade strategies, managed by the trading team at DWF Labs. These include price arbitrage, funding rate strategies (positive and negative), and staking. While these approaches are designed for high risk-adjusted returns, they rely on favorable conditions and precise execution. Deviations in performance or infrastructure risks may affect sUSDf's ability to meet target yields.",
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      "Assets backing both tokens are held with reputable custodians including Fireblocks, Copper, and CEFU. Trading occurs through omnibus accounts—ensuring assets stay within custody and are not deployed to third-party venues. This setup reduces typical counterparty risk, but depends on Falcon's operational integrity and custodian reliability for accurate fund management.",
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      "Falcon provides quarterly Proof of Reserves for transparency. While this strengthens trust in collateral backing, it does not reflect real-time dynamics or eliminate all operational risk. Depositors should weigh the potential for attractive yields against the system's reliance on institutional infrastructure and execution.",
                  }),
                ],
              }),
            },
            '0x0F359FD18BDa75e9c49bC027E7da59a4b01BF32a': {
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      'Relend Network Vaults are curated by B.Protocol and the RiskDAO who curated over $200m tvl in Morpho, and consulted in the past to over 10 different lending markets.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Our vaults aim to achieve superior risk-adjusted returns by capitalizing on distinctive market opportunities — which may subject depositors to increased volatility or periods of limited liquidity. While continuous oversight and adaptive asset allocation help reduce the risk of significant losses, sudden changes in market sentiment can still lead to liquidations or temporary liquidity challenges.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'The vault also plays key role in the Relend Network protocol, and has the ability to relend the supplied assets into other chains. ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://docs.relend.network/relend.docs/rusdc-mechanism-and-risk-disclosure',
                          children: 'See more details here',
                        }),
                      }),
                      '.',
                    ],
                  }),
                ],
              }),
            },
            '0xc080f56504e0278828A403269DB945F6c6D6E014': {
              showCredoraRating: !1,
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      'Gauntlet is the leading model provider in crypto, building optimization strategies for tokens, protocols, and chains. Central to our Morpho Vault curation approach is ensuring vaults meet our robust risk guidelines, are attractive to the DeFi community, and remain resilient enough to handle inherent crypto market volatility.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Our Core Vaults allocate to a blend of large and lower cap collateralized markets while ensuring exposure to any one asset remains within acceptable bounds. Collateral Selection is based on various factors, including the availability of withdrawal liquidity and sufficient liquidity and slippage to perform healthy liquidations in severe market conditions.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'For more info, visit',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://gauntlet.gitbook.io/gauntlet-vaultbook/morpho-vaults',
                          children: 'this link',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children: (0, r.tZ)(a.xvT.Body.XS.Regular, {
                      color: 'text.interactive.active',
                      children: (0, r.tZ)(a.dLw, {
                        href: 'https://storage.googleapis.com/gauntlet-public-web-assets/Gauntlet_New_Partnership_Disclaimer.pdf',
                        children: 'Gauntlet Disclaimer',
                      }),
                    }),
                  }),
                ],
              }),
            },
            '0xF587f2e8AfF7D76618d3B6B4626621860FbD54e3': {
              showCredoraRating: !1,
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      'Gauntlet is the leading model provider in crypto, building optimization strategies for tokens, protocols, and chains. Central to our Morpho Vault curation approach is ensuring vaults meet our robust risk guidelines, are attractive to the DeFi community, and remain resilient enough to handle inherent crypto market volatility.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Our Core Vaults allocate to a blend of large and lower cap collateralized markets while ensuring exposure to any one asset remains within acceptable bounds. Collateral Selection is based on various factors, including the availability of withdrawal liquidity and sufficient liquidity and slippage to perform healthy liquidations in severe market conditions.',
                  }),
                ],
              }),
            },
            '0x443df5eEE3196e9b2Dd77CaBd3eA76C3dee8f9b2': {
              showCredoraRating: !1,
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      'Gauntlet is the leading model provider in crypto, building optimization strategies for tokens, protocols, and chains. Central to our Morpho Vault curation approach is ensuring vaults meet our robust risk guidelines, are attractive to the DeFi community, and remain resilient enough to handle inherent crypto market volatility.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Our Core Vaults allocate to a blend of large and lower cap collateralized markets while ensuring exposure to any one asset remains within acceptable bounds. Collateral Selection is based on various factors, including the availability of withdrawal liquidity and sufficient liquidity and slippage to perform healthy liquidations in severe market conditions.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'For more info, visit',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://gauntlet.gitbook.io/gauntlet-vaultbook/morpho-vaults',
                          children: 'this link',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children: (0, r.tZ)(a.xvT.Body.XS.Regular, {
                      color: 'text.interactive.active',
                      children: (0, r.tZ)(a.dLw, {
                        href: 'https://storage.googleapis.com/gauntlet-public-web-assets/Gauntlet_New_Partnership_Disclaimer.pdf',
                        children: 'Gauntlet Disclaimer',
                      }),
                    }),
                  }),
                ],
              }),
            },
            '0x9a8bC3B04b7f3D87cfC09ba407dCED575f2d61D8': { showCredoraRating: !1 },
            '0xd63070114470f685b75B74D60EEc7c1113d33a3D': { showCredoraRating: !1 },
            '0xBEeFFF209270748ddd194831b3fa287a5386f5bC': {
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.BX)('p', {
                    children: [
                      "BBQ-branded Vaults are curated and operated by Carniceria Tropical using stringent governance protocols aimed at minimizing trust assumptions and maximizing depositor security. All major decisions — such as adjusting fee levels, refining asset allocations, and updating liquidity thresholds — require approval through this vault's Aragon DAO Guardian link:",
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://app.aragon.org/#/daos/ethereum/bbqusdc-guardian.dao.eth/dashboard',
                          children: 'bbqusdc-guardian.dao.eth',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'BBQ-branded Vaults pursue higher risk-adjusted returns by seizing upon unique market opportunities — potentially exposing depositors to greater volatility or liquidity constraints. Although ongoing monitoring and dynamic asset allocations seek to mitigate large drawdowns, rapid shifts in market sentiment could trigger liquidation events or short-lived liquidity disruptions.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'We encourage participants to review the Steakhouse',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://docs.google.com/document/d/18ADHX_O2oQKjAfRLoLVbDUizKxWBA4w7g8KYsphj0N4/edit?usp=sharing',
                          children: '"Risk Framework for Crypto Assets"',
                        }),
                      }),
                      ' ',
                      'to understand how we evaluate asset volatility and handle swift price swings. Additional notes on the Smokehouse approach can be found here:',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://forum.morpho.org/t/key-information-on-steakhouse-branded-vaults/1343',
                          children: 'Key Information on Steakhouse Branded Vaults',
                        }),
                      }),
                      '.',
                    ],
                  }),
                ],
              }),
              showCredoraRating: !0,
            },
            '0xBeEf11eCb698f4B5378685C05A210bdF71093521': {
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      'Steak-branded Vaults are curated and operated by Carniceria Tropical using stringent governance protocols aimed at minimizing trust assumptions and maximizing depositor security. Increasing exposure to a new or existing collateral type requires approval through the Aragon DAO Guardian.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Steak-branded Vaults are designed to minimize volatility by allocating primarily against highly-liquid assets. While Steak vaults are focused on established markets, no strategy eliminates risk entirely: Extraordinary market events or tail risks may still drive sudden price movements and volatility in the underlying Morpho markets.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'To learn more about how we assess these possibilities and maintain robust safeguards, please review our post: Steakhouse',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://docs.google.com/document/d/18ADHX_O2oQKjAfRLoLVbDUizKxWBA4w7g8KYsphj0N4/edit?usp=sharing',
                          children: '"Counterparty Risk Framework for Crypto Assets"',
                        }),
                      }),
                      '. Further details on vault structures and asset choices can be found at',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://forum.morpho.org/t/key-information-on-steakhouse-branded-vaults/1343',
                          children: 'Key Information on Steakhouse Branded Vaults',
                        }),
                      }),
                      '.',
                    ],
                  }),
                ],
              }),
            },
            '0xbEef047a543E45807105E51A8BBEFCc5950fcfBa': {
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.BX)('p', {
                    children: [
                      "Steak-branded Vaults are curated and operated by Carniceria Tropical using stringent governance protocols aimed at minimizing trust assumptions and maximizing depositor security. Increasing exposure to a new or existing collateral type requires approval through this vault's Aragon DAO Guardian link:",
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://app.aragon.org/#/daos/ethereum/steakusdt-guardian.dao.eth/dashboard',
                          children: '"steakusdt-guardian.dao.eth"',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Steak-branded Vaults are designed to minimize volatility by allocating primarily against highly-liquid assets. While Steak vaults are focused on established markets, no strategy eliminates risk entirely: Extraordinary market events or tail risks may still drive sudden price movements and volatility in the underlying Morpho markets.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'To learn more about how we assess these possibilities and maintain robust safeguards, please review our post: Steakhouse',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://docs.google.com/document/d/18ADHX_O2oQKjAfRLoLVbDUizKxWBA4w7g8KYsphj0N4/edit?usp=sharing',
                          children: '"Counterparty Risk Framework for Crypto Assets"',
                        }),
                      }),
                      '. Further details on vault structures and asset choices can be found at',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://forum.morpho.org/t/key-information-on-steakhouse-branded-vaults/1343',
                          children: 'Key Information on Steakhouse Branded Vaults',
                        }),
                      }),
                      '.',
                    ],
                  }),
                ],
              }),
              showCredoraRating: !0,
            },
            '0xBEEf050ecd6a16c4e7bfFbB52Ebba7846C4b8cD4': {
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.BX)('p', {
                    children: [
                      "Steak-branded Vaults are curated and operated by Carniceria Tropical using stringent governance protocols aimed at minimizing trust assumptions and maximizing depositor security. Increasing exposure to a new or existing collateral type requires approval through this vault's Aragon DAO Guardian link:",
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://app.aragon.org/#/daos/ethereum/steaketh-guardian.dao.eth/dashboard',
                          children: '"steaketh-guardian.dao.eth"',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Steak-branded Vaults are designed to minimize volatility by allocating primarily against highly-liquid assets. While Steak vaults are focused on established markets, no strategy eliminates risk entirely: Extraordinary market events or tail risks may still drive sudden price movements and volatility in the underlying Morpho markets.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'To learn more about how we assess these possibilities and maintain robust safeguards, please review our post: Steakhouse',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://docs.google.com/document/d/18ADHX_O2oQKjAfRLoLVbDUizKxWBA4w7g8KYsphj0N4/edit?usp=sharing',
                          children: '"Counterparty Risk Framework for Crypto Assets"',
                        }),
                      }),
                      '. Further details on vault structures and asset choices can be found at',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://forum.morpho.org/t/key-information-on-steakhouse-branded-vaults/1343',
                          children: 'Key Information on Steakhouse Branded Vaults',
                        }),
                      }),
                      '.',
                    ],
                  }),
                ],
              }),
              showCredoraRating: !0,
            },
            '0xbEeFc011e94f43b8B7b455eBaB290C7Ab4E216f1': {
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      "Custom Vaults are co-branded with external partners, allowing Steakhouse Financial to apply its risk-management expertise in a specialized setting. Depending on each partner's strategic direction, the vault's underlying assets may range from conservative to opportunistic, potentially leading to different liquidity profiles or price sensitivities.",
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'Since each Custom Vault is managed in close collaboration with our partners, management parameters may differ slightly from standard Steakhouse or Smokehouse offerings. Nonetheless, all critical updates—including fee changes, asset rebalancing, or membership criteria—remain subject to formal proposals and time-delayed execution through the following Aragon DAO Guardian link:',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://csusdl-2-guardian.dao.eth/',
                          children: 'csusdl-2-guardian.dao.eth',
                        }),
                      }),
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'For an overview of our broader methodology, see the Steakhouse',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://docs.google.com/document/d/18ADHX_O2oQKjAfRLoLVbDUizKxWBA4w7g8KYsphj0N4/edit?usp=sharing',
                          children: '"Risk Framework for Crypto Assets"',
                        }),
                      }),
                      '. Further explanations on co-branded vault structures can be found at',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://forum.morpho.org/t/key-information-on-steakhouse-branded-vaults/1343',
                          children: 'Key Information on Steakhouse Branded Vaults',
                        }),
                      }),
                      '.',
                    ],
                  }),
                ],
              }),
              showCredoraRating: !0,
            },
            '0xbEEF02e5E13584ab96848af90261f0C8Ee04722a': {
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.BX)('p', {
                    children: [
                      "Steak-branded Vaults are curated and operated by Carniceria Tropical using stringent governance protocols aimed at minimizing trust assumptions and maximizing depositor security. Increasing exposure to a new or existing collateral type requires approval through this vault's Aragon DAO Guardian link:",
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://steakpyusd-guardian.dao.eth/',
                          children: 'steakpyusd-guardian.dao.eth',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Steak-branded Vaults are designed to minimize volatility by allocating primarily against highly-liquid assets. While Steak vaults are focused on established markets, no strategy eliminates risk entirely: Extraordinary market events or tail risks may still drive sudden price movements and volatility in the underlying Morpho markets.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'To learn more about how we assess these possibilities and maintain robust safeguards, please review our post: Steakhouse',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://docs.google.com/document/d/18ADHX_O2oQKjAfRLoLVbDUizKxWBA4w7g8KYsphj0N4/edit?usp=sharing',
                          children: '"Counterparty Risk Framework for Crypto Assets"',
                        }),
                      }),
                      '. Further details on vault structures and asset choices can be found at',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://forum.morpho.org/t/key-information-on-steakhouse-branded-vaults/1343',
                          children: 'Key Information on Steakhouse Branded Vaults',
                        }),
                      }),
                      '.',
                    ],
                  }),
                ],
              }),
            },
            '0xBEEF01735c132Ada46AA9aA4c54623cAA92A64CB': {
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.BX)('p', {
                    children: [
                      "Steak-branded Vaults are curated and operated by Carniceria Tropical using stringent governance protocols aimed at minimizing trust assumptions and maximizing depositor security. Increasing exposure to a new or existing collateral type requires approval through this vault's Aragon DAO Guardian link:",
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://app.aragon.org/dao/ethereum-mainnet-0xaa0500198B4425DfC4E272FbE42C8E64E21fc03d/dashboard',
                          children: 'steakusdc-guardian.dao.eth',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Steak-branded Vaults are designed to minimize volatility by allocating primarily against highly-liquid assets. While Steak vaults are focused on established markets, no strategy eliminates risk entirely: Extraordinary market events or tail risks may still drive sudden price movements and volatility in the underlying Morpho markets.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'To learn more about how we assess these possibilities and maintain robust safeguards, please review our post: Steakhouse',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://docs.google.com/document/d/18ADHX_O2oQKjAfRLoLVbDUizKxWBA4w7g8KYsphj0N4/edit?usp=sharing',
                          children: '"Counterparty Risk Framework for Crypto Assets"',
                        }),
                      }),
                      '. Further details on vault structures and asset choices can be found at',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://forum.morpho.org/t/key-information-on-steakhouse-branded-vaults/1343',
                          children: 'Key Information on Steakhouse Branded Vaults',
                        }),
                      }),
                      '.',
                    ],
                  }),
                ],
              }),
              showCredoraRating: !0,
            },
            '0xdC94785959B73F7A168452b3654E44fEc6A750e4': {
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      'Gauntlet is the leading model provider in crypto, building optimization strategies for tokens, protocols, and chains. Central to our Morpho Vault curation approach is ensuring vaults meet our robust risk guidelines, are attractive to the DeFi community, and remain resilient enough to handle inherent crypto market volatility.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Our Core Vaults allocate to a blend of large and lower cap collateralized markets while ensuring exposure to any one asset remains within acceptable bounds. Collateral Selection is based on various factors, including the availability of withdrawal liquidity and sufficient liquidity and slippage to perform healthy liquidations in severe market conditions.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'For more info, visit',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://gauntlet.gitbook.io/gauntlet-vaultbook/morpho-vaults',
                          children: 'this link',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children: (0, r.tZ)(a.xvT.Body.XS.Regular, {
                      color: 'text.interactive.active',
                      children: (0, r.tZ)(a.dLw, {
                        href: 'https://storage.googleapis.com/gauntlet-public-web-assets/Gauntlet_New_Partnership_Disclaimer.pdf',
                        children: 'Gauntlet Disclaimer',
                      }),
                    }),
                  }),
                ],
              }),
              showCredoraRating: !1,
            },
            '0x6770216aC60F634483Ec073cBABC4011c94307Cb': {
              showCredoraRating: !1,
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      'Gauntlet is the leading model provider in crypto, building optimization strategies for tokens, protocols, and chains. Central to our Morpho Vault curation approach is ensuring vaults meet our robust risk guidelines, are attractive to the DeFi community, and remain resilient enough to handle inherent crypto market volatility.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Our Core Vaults allocate to a blend of large and lower cap collateralized markets while ensuring exposure to any one asset remains within acceptable bounds. Collateral Selection is based on various factors, including the availability of withdrawal liquidity and sufficient liquidity and slippage to perform healthy liquidations in severe market conditions.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'For more info, visit',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://gauntlet.gitbook.io/gauntlet-vaultbook/morpho-vaults',
                          children: 'this link',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children: (0, r.tZ)(a.xvT.Body.XS.Regular, {
                      color: 'text.interactive.active',
                      children: (0, r.tZ)(a.dLw, {
                        href: 'https://storage.googleapis.com/gauntlet-public-web-assets/Gauntlet_New_Partnership_Disclaimer.pdf',
                        children: 'Gauntlet Disclaimer',
                      }),
                    }),
                  }),
                ],
              }),
            },
            '0xdd0f28e19C1780eb6396170735D45153D261490d': {
              showCredoraRating: !1,
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      'Gauntlet is the leading model provider in crypto, building optimization strategies for tokens, protocols, and chains. Central to our Morpho Vault curation approach is ensuring vaults meet our robust risk guidelines, are attractive to the DeFi community, and remain resilient enough to handle inherent crypto market volatility.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Our Prime Vaults allocate supply to maximize risk-adjusted yield while targeting minimal risk of insolvent debt even under extreme market conditions. These Vaults will allocate to markets that meet various criteria, including being a blend of super high liquidity blue chip collateral, and moderate volatility between the supply and collateral token relative.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'For more info, visit',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://gauntlet.gitbook.io/gauntlet-vaultbook/morpho-vaults',
                          children: 'this link',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children: (0, r.tZ)(a.xvT.Body.XS.Regular, {
                      color: 'text.interactive.active',
                      children: (0, r.tZ)(a.dLw, {
                        href: 'https://storage.googleapis.com/gauntlet-public-web-assets/Gauntlet_New_Partnership_Disclaimer.pdf',
                        children: 'Gauntlet Disclaimer',
                      }),
                    }),
                  }),
                ],
              }),
            },
            '0x2371e134e3455e0593363cBF89d3b6cf53740618': {
              showCredoraRating: !1,
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      'Gauntlet is the leading model provider in crypto, building optimization strategies for tokens, protocols, and chains. Central to our Morpho Vault curation approach is ensuring vaults meet our robust risk guidelines, are attractive to the DeFi community, and remain resilient enough to handle inherent crypto market volatility.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Our Prime Vaults allocate supply to maximize risk-adjusted yield while targeting minimal risk of insolvent debt even under extreme market conditions. These Vaults will allocate to markets that meet various criteria, including being a blend of super high liquidity blue chip collateral, and moderate volatility between the supply and collateral token relative.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'For more info, visit',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://gauntlet.gitbook.io/gauntlet-vaultbook/morpho-vaults',
                          children: 'this link',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children: (0, r.tZ)(a.xvT.Body.XS.Regular, {
                      color: 'text.interactive.active',
                      children: (0, r.tZ)(a.dLw, {
                        href: 'https://storage.googleapis.com/gauntlet-public-web-assets/Gauntlet_New_Partnership_Disclaimer.pdf',
                        children: 'Gauntlet Disclaimer',
                      }),
                    }),
                  }),
                ],
              }),
            },
            '0x8eB67A509616cd6A7c1B3c8C21D48FF57df3d458': {
              showCredoraRating: !1,
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      'Gauntlet is the leading model provider in crypto, building optimization strategies for tokens, protocols, and chains. Central to our Morpho Vault curation approach is ensuring vaults meet our robust risk guidelines, are attractive to the DeFi community, and remain resilient enough to handle inherent crypto market volatility.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Our Core Vaults allocate to a blend of large and lower cap collateralized markets while ensuring exposure to any one asset remains within acceptable bounds. Collateral Selection is based on various factors, including the availability of withdrawal liquidity and sufficient liquidity and slippage to perform healthy liquidations in severe market conditions.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'For more info, visit',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://gauntlet.gitbook.io/gauntlet-vaultbook/morpho-vaults',
                          children: 'this link',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children: (0, r.tZ)(a.xvT.Body.XS.Regular, {
                      color: 'text.interactive.active',
                      children: (0, r.tZ)(a.dLw, {
                        href: 'https://storage.googleapis.com/gauntlet-public-web-assets/Gauntlet_New_Partnership_Disclaimer.pdf',
                        children: 'Gauntlet Disclaimer',
                      }),
                    }),
                  }),
                ],
              }),
            },
            '0x4881Ef0BF6d2365D3dd6499ccd7532bcdBCE0658': {
              showCredoraRating: !1,
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      'Gauntlet is the leading model provider in crypto, building optimization strategies for tokens, protocols, and chains. Central to our Morpho Vault curation approach is ensuring vaults meet our robust risk guidelines, are attractive to the DeFi community, and remain resilient enough to handle inherent crypto market volatility.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Our Core Vaults allocate to a blend of large and lower cap collateralized markets while ensuring exposure to any one asset remains within acceptable bounds. Collateral Selection is based on various factors, including the availability of withdrawal liquidity and sufficient liquidity and slippage to perform healthy liquidations in severe market conditions.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'For more info, visit',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://gauntlet.gitbook.io/gauntlet-vaultbook/morpho-vaults',
                          children: 'this link',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children: (0, r.tZ)(a.xvT.Body.XS.Regular, {
                      color: 'text.interactive.active',
                      children: (0, r.tZ)(a.dLw, {
                        href: 'https://storage.googleapis.com/gauntlet-public-web-assets/Gauntlet_New_Partnership_Disclaimer.pdf',
                        children: 'Gauntlet Disclaimer',
                      }),
                    }),
                  }),
                ],
              }),
            },
          },
          [n.ChainId.BaseMainnet]: {
            '0xA2Cac0023a4797b4729Db94783405189a4203AFc': { showCredoraRating: !0 },
            '0x12AFDeFb2237a5963e7BAb3e2D46ad0eee70406e': { showCredoraRating: !0 },
            '0x1D3b1Cd0a0f242d598834b3F2d126dC6bd774657': {
              showCredoraRating: !1,
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      'Clearstar is a research-led DeFi curator dedicated to building vaults that blend capital efficiency, robust risk parameters, and sustainable on-chain yield. Our curation process focuses on vaults that can perform in dynamic market conditions while staying aligned with the interests of serious DeFi users.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      "This Ecosystem Vault is centered around OpenEden's tokenized T-Bill yield via USDO, anchoring strategy in stability while layering in high-demand collateral markets to enhance returns. The vault maintains exposure boundaries to ensure diversification, and evaluates assets based on liquidity depth, withdrawal reliability, and liquidation efficiency under stress scenarios—balancing upside with resilience.",
                  }),
                ],
              }),
            },
            '0xf24608E0CCb972b0b0f4A6446a0BBf58c701a026': { showCredoraRating: !0 },
            '0x6b13c060F13Af1fdB319F52315BbbF3fb1D88844': {
              showCredoraRating: !1,
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      'Gauntlet is the leading model provider in crypto, building optimization strategies for tokens, protocols, and chains. Central to our Morpho Vault curation approach is ensuring vaults meet our robust risk guidelines, are attractive to the DeFi community, and remain resilient enough to handle inherent crypto market volatility.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Our Core Vaults allocate to a blend of large and lower cap collateralized markets while ensuring exposure to any one asset remains within acceptable bounds. Collateral Selection is based on various factors, including the availability of withdrawal liquidity and sufficient liquidity and slippage to perform healthy liquidations in severe market conditions.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'For more info, visit',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://gauntlet.gitbook.io/gauntlet-vaultbook/morpho-vaults',
                          children: 'this link',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children: (0, r.tZ)(a.xvT.Body.XS.Regular, {
                      color: 'text.interactive.active',
                      children: (0, r.tZ)(a.dLw, {
                        href: 'https://storage.googleapis.com/gauntlet-public-web-assets/Gauntlet_New_Partnership_Disclaimer.pdf',
                        children: 'Gauntlet Disclaimer',
                      }),
                    }),
                  }),
                ],
              }),
            },
            '0x5a47C803488FE2BB0A0EAaf346b420e4dF22F3C7': {
              showCredoraRating: !1,
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      'Gauntlet is the leading model provider in crypto, building optimization strategies for tokens, protocols, and chains. Central to our Morpho Vault curation approach is ensuring vaults meet our robust risk guidelines, are attractive to the DeFi community, and remain resilient enough to handle inherent crypto market volatility.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'This Ecosystem Vault applies our Core strategy, which allocates to a blend of large and lower-cap collateralized markets while ensuring exposure to any one asset remains within acceptable bounds. Collateral Selection is based on various factors, including the availability of withdrawal liquidity and sufficient liquidity and slippage to perform healthy liquidations in severe market conditions.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'For more info, visit',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://gauntlet.gitbook.io/gauntlet-vaultbook/morpho-vaults',
                          children: 'this link',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children: (0, r.tZ)(a.xvT.Body.XS.Regular, {
                      color: 'text.interactive.active',
                      children: (0, r.tZ)(a.dLw, {
                        href: 'https://storage.googleapis.com/gauntlet-public-web-assets/Gauntlet_New_Partnership_Disclaimer.pdf',
                        children: 'Gauntlet Disclaimer',
                      }),
                    }),
                  }),
                ],
              }),
            },
            '0x543257eF2161176D7C8cD90BA65C2d4CaEF5a796': { showCredoraRating: !0 },
            '0xa0E430870c4604CcfC7B38Ca7845B1FF653D0ff1': { showCredoraRating: !0 },
            '0xc1256Ae5FF1cf2719D4937adb3bbCCab2E00A2Ca': { showCredoraRating: !0 },
            '0x7BfA7C4f149E7415b73bdeDfe609237e29CBF34A': { showCredoraRating: !1 },
            '0x616a4E1db48e22028f6bbf20444Cd3b8e3273738': {
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      'Gauntlet is the leading model provider in crypto, building optimization strategies for tokens, protocols, and chains. Central to our Morpho Vault curation approach is ensuring vaults meet our robust risk guidelines, are attractive to the DeFi community, and remain resilient enough to handle inherent crypto market volatility.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'This Ecosystem Vault applies our Core strategy, which allocates to a blend of large and lower-cap collateralized markets while ensuring exposure to any one asset remains within acceptable bounds. Collateral Selection is based on various factors, including the availability of withdrawal liquidity and sufficient liquidity and slippage to perform healthy liquidations in severe market conditions.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'For more info, visit',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://gauntlet.gitbook.io/gauntlet-vaultbook/morpho-vaults',
                          children: 'this link',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children: (0, r.tZ)(a.xvT.Body.XS.Regular, {
                      color: 'text.interactive.active',
                      children: (0, r.tZ)(a.dLw, {
                        href: 'https://storage.googleapis.com/gauntlet-public-web-assets/Gauntlet_New_Partnership_Disclaimer.pdf',
                        children: 'Gauntlet Disclaimer',
                      }),
                    }),
                  }),
                ],
              }),
              showCredoraRating: !1,
            },
            '0xbeeF010f9cb27031ad51e3333f9aF9C6B1228183': {
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.BX)('p', {
                    children: [
                      "Steak-branded Vaults are curated and operated by Carniceria Tropical using stringent governance protocols aimed at minimizing trust assumptions and maximizing depositor security. Increasing exposure to a new or existing collateral type requires approval through this vault's Aragon DAO Guardian link:",
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://app.aragon.org/#/daos/base/0xfc7a2c1a631a10574637178610bb2040a15e4c26/dashboard',
                          children: 'steakUSDC Base Guardian DAO',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Steak-branded Vaults are designed to minimize volatility by allocating primarily against highly-liquid assets. While Steak vaults are focused on established markets, no strategy eliminates risk entirely: Extraordinary market events or tail risks may still drive sudden price movements and volatility in the underlying Morpho markets.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'To learn more about how we assess these possibilities and maintain robust safeguards, please review our post: Steakhouse',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://docs.google.com/document/d/18ADHX_O2oQKjAfRLoLVbDUizKxWBA4w7g8KYsphj0N4/edit?usp=sharing',
                          children: '"Counterparty Risk Framework for Crypto Assets"',
                        }),
                      }),
                      '. Further details on vault structures and asset choices can be found at',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://forum.morpho.org/t/key-information-on-steakhouse-branded-vaults/1343',
                          children: 'Key Information on Steakhouse Branded Vaults',
                        }),
                      }),
                      '.',
                    ],
                  }),
                ],
              }),
            },
          },
          [n.ChainId.PolygonMainnet]: void 0,
          [n.ChainId.ArbitrumMainnet]: void 0,
          [n.ChainId.OptimismMainnet]: void 0,
          [n.ChainId.WorldChainMainnet]: void 0,
          [n.ChainId.FraxtalMainnet]: void 0,
          [n.ChainId.ScrollMainnet]: void 0,
          [n.ChainId.InkMainnet]: void 0,
          [n.ChainId.Unichain]: void 0,
          [n.ChainId.SonicMainnet]: void 0,
          [n.ChainId.HemiMainnet]: void 0,
          [n.ChainId.ModeMainnet]: void 0,
          [n.ChainId.CornMainnet]: void 0,
          [n.ChainId.PlumeMainnet]: void 0,
          [n.ChainId.CampMainnet]: void 0,
        },
        l = (e, t) => {
          var i;
          return null === (i = o[e]) || void 0 === i ? void 0 : i[t];
        };
    },
    67355: function (e, t, i) {
      'use strict';
      i.d(t, {
        J: function () {
          return a;
        },
        L: function () {
          return o;
        },
      });
      var r = i(86842),
        n = i(86384);
      let a = (e) => (0, r.WU)(new Date(1e3 * Number(e)), 'MM/dd/yyyy'),
        o = (e) => {
          let { months: t = 0, days: i = 0 } = (0, n.y)({
            start: 0,
            end: 1e3 * Number(null != e ? e : 0),
          });
          return t > 0 ? ''.concat(t, 'M') : ''.concat(i, 'D');
        };
    },
    93319: function (e, t, i) {
      'use strict';
      i.d(t, {
        l: function () {
          return r;
        },
      }),
        i(35047);
      let r = (e) => {
        var t;
        let i = /^(\d*(\.\d+)?)([a-zA-Z]*)$/;
        if (null == e || !i.test(e)) return { value: e, unit: null };
        let r = e.match(i);
        return {
          value: null == r ? void 0 : r[1],
          unit: null !== (t = null == r ? void 0 : r[3]) && void 0 !== t ? t : null,
        };
      };
    },
    85718: function (e, t, i) {
      'use strict';
      i.d(t, {
        T: function () {
          return n;
        },
      });
      var r = i(58258);
      let n = (e) => {
        let t = (0, r.useRef)(null != e ? e : 0n),
          i = (0, r.useRef)(new Map()),
          n = (0, r.useCallback)((e) => {
            i.current.has(e)
              ? (t.current = i.current.get(e))
              : 0 === e && ((t.current = 0n), i.current.clear());
          }, []),
          a = (0, r.useCallback)((e, r) => {
            (t.current += e), i.current.set(r + 1, t.current);
          }, []);
        return { paginatedOffset: t, initOffset: n, setNextOffset: a };
      };
    },
    7518: function (e, t, i) {
      'use strict';
      i.d(t, {
        I: function () {
          return o;
        },
      });
      var r = i(58258),
        n = i(35047),
        a = i(91767);
      let o = (e) => {
        let { first: t, totalCount: i, pagination: o, columnsDefs: l, columnVisibility: s } = e;
        return (0, r.useMemo)(
          () =>
            Array.from({ length: (0, a.a)(t, i, o.pageIndex) }, () =>
              l
                .filter(
                  (e) =>
                    !(
                      (0, n.isDefined)(s) &&
                      (0, n.isDefined)(null == e ? void 0 : e.id) &&
                      (0, n.isDefined)(s[e.id])
                    ) || s[e.id]
                )
                .map((e) => e.skeletonCell)
            ),
          [l, t, o.pageIndex, i, s]
        );
      };
    },
    27987: function (e, t, i) {
      'use strict';
      i.d(t, {
        Z: function () {
          return a;
        },
      });
      var r = i(17965),
        n = i(4565);
      let a = new r.BlueSdkConverter({
        parseAddress: n.safeGetAddress,
        parseNumber: n.safeParseNumber,
      });
    },
  },
  function (e) {
    e.O(
      0,
      [
        9913, 1811, 3261, 1087, 115, 7287, 6929, 3391, 3515, 4516, 3613, 6489, 92, 8051, 5042, 2193,
        8894, 4655, 825, 5962, 9255, 9510, 3779, 4997, 1946, 2783, 6269, 8804, 1744,
      ],
      function () {
        return e((e.s = 80681));
      }
    ),
      (_N_E = e.O());
  },
]);
