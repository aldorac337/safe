import { a as pn, g as zn, c as se } from './lodash-aFjP5OGs.js';
function j4(i, e) {
  for (var t = 0; t < e.length; t++) {
    const r = e[t];
    if (typeof r != 'string' && !Array.isArray(r)) {
      for (const s in r)
        if (s !== 'default' && !(s in i)) {
          const n = Object.getOwnPropertyDescriptor(r, s);
          n && Object.defineProperty(i, s, n.get ? n : { enumerable: !0, get: () => r[s] });
        }
    }
  }
  return Object.freeze(Object.defineProperty(i, Symbol.toStringTag, { value: 'Module' }));
}
let Fc;
const H4 = new Uint8Array(16);
function A2() {
  if (
    !Fc &&
    ((Fc = typeof crypto < 'u' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)),
    !Fc)
  )
    throw new Error(
      'crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported'
    );
  return Fc(H4);
}
const V4 =
  /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function dl(i) {
  return typeof i == 'string' && V4.test(i);
}
const Qr = [];
for (let i = 0; i < 256; ++i) Qr.push((i + 256).toString(16).slice(1));
function pl(i, e = 0) {
  return (
    Qr[i[e + 0]] +
    Qr[i[e + 1]] +
    Qr[i[e + 2]] +
    Qr[i[e + 3]] +
    '-' +
    Qr[i[e + 4]] +
    Qr[i[e + 5]] +
    '-' +
    Qr[i[e + 6]] +
    Qr[i[e + 7]] +
    '-' +
    Qr[i[e + 8]] +
    Qr[i[e + 9]] +
    '-' +
    Qr[i[e + 10]] +
    Qr[i[e + 11]] +
    Qr[i[e + 12]] +
    Qr[i[e + 13]] +
    Qr[i[e + 14]] +
    Qr[i[e + 15]]
  );
}
function G4(i, e = 0) {
  const t = pl(i, e);
  if (!dl(t)) throw TypeError('Stringified UUID is invalid');
  return t;
}
let Mg,
  wh,
  _h = 0,
  Sh = 0;
function Y4(i, e, t) {
  let r = (e && t) || 0;
  const s = e || new Array(16);
  i = i || {};
  let n = i.node || Mg,
    c = i.clockseq !== void 0 ? i.clockseq : wh;
  if (n == null || c == null) {
    const _ = i.random || (i.rng || A2)();
    n == null && (n = Mg = [_[0] | 1, _[1], _[2], _[3], _[4], _[5]]),
      c == null && (c = wh = ((_[6] << 8) | _[7]) & 16383);
  }
  let f = i.msecs !== void 0 ? i.msecs : Date.now(),
    h = i.nsecs !== void 0 ? i.nsecs : Sh + 1;
  const y = f - _h + (h - Sh) / 1e4;
  if (
    (y < 0 && i.clockseq === void 0 && (c = (c + 1) & 16383),
    (y < 0 || f > _h) && i.nsecs === void 0 && (h = 0),
    h >= 1e4)
  )
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  (_h = f), (Sh = h), (wh = c), (f += 122192928e5);
  const p = ((f & 268435455) * 1e4 + h) % 4294967296;
  (s[r++] = (p >>> 24) & 255),
    (s[r++] = (p >>> 16) & 255),
    (s[r++] = (p >>> 8) & 255),
    (s[r++] = p & 255);
  const m = ((f / 4294967296) * 1e4) & 268435455;
  (s[r++] = (m >>> 8) & 255),
    (s[r++] = m & 255),
    (s[r++] = ((m >>> 24) & 15) | 16),
    (s[r++] = (m >>> 16) & 255),
    (s[r++] = (c >>> 8) | 128),
    (s[r++] = c & 255);
  for (let _ = 0; _ < 6; ++_) s[r + _] = n[_];
  return e || pl(s);
}
function E2(i) {
  if (!dl(i)) throw TypeError('Invalid UUID');
  let e;
  const t = new Uint8Array(16);
  return (
    (t[0] = (e = parseInt(i.slice(0, 8), 16)) >>> 24),
    (t[1] = (e >>> 16) & 255),
    (t[2] = (e >>> 8) & 255),
    (t[3] = e & 255),
    (t[4] = (e = parseInt(i.slice(9, 13), 16)) >>> 8),
    (t[5] = e & 255),
    (t[6] = (e = parseInt(i.slice(14, 18), 16)) >>> 8),
    (t[7] = e & 255),
    (t[8] = (e = parseInt(i.slice(19, 23), 16)) >>> 8),
    (t[9] = e & 255),
    (t[10] = ((e = parseInt(i.slice(24, 36), 16)) / 1099511627776) & 255),
    (t[11] = (e / 4294967296) & 255),
    (t[12] = (e >>> 24) & 255),
    (t[13] = (e >>> 16) & 255),
    (t[14] = (e >>> 8) & 255),
    (t[15] = e & 255),
    t
  );
}
function Z4(i) {
  i = unescape(encodeURIComponent(i));
  const e = [];
  for (let t = 0; t < i.length; ++t) e.push(i.charCodeAt(t));
  return e;
}
const J4 = '6ba7b810-9dad-11d1-80b4-00c04fd430c8',
  X4 = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
function k2(i, e, t) {
  function r(s, n, c, f) {
    var h;
    if (
      (typeof s == 'string' && (s = Z4(s)),
      typeof n == 'string' && (n = E2(n)),
      ((h = n) === null || h === void 0 ? void 0 : h.length) !== 16)
    )
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    let y = new Uint8Array(16 + s.length);
    if (
      (y.set(n),
      y.set(s, n.length),
      (y = t(y)),
      (y[6] = (y[6] & 15) | e),
      (y[8] = (y[8] & 63) | 128),
      c)
    ) {
      f = f || 0;
      for (let p = 0; p < 16; ++p) c[f + p] = y[p];
      return c;
    }
    return pl(y);
  }
  try {
    r.name = i;
  } catch {}
  return (r.DNS = J4), (r.URL = X4), r;
}
function Q4(i) {
  if (typeof i == 'string') {
    const e = unescape(encodeURIComponent(i));
    i = new Uint8Array(e.length);
    for (let t = 0; t < e.length; ++t) i[t] = e.charCodeAt(t);
  }
  return e5(t5(r5(i), i.length * 8));
}
function e5(i) {
  const e = [],
    t = i.length * 32,
    r = '0123456789abcdef';
  for (let s = 0; s < t; s += 8) {
    const n = (i[s >> 5] >>> s % 32) & 255,
      c = parseInt(r.charAt((n >>> 4) & 15) + r.charAt(n & 15), 16);
    e.push(c);
  }
  return e;
}
function I2(i) {
  return (((i + 64) >>> 9) << 4) + 14 + 1;
}
function t5(i, e) {
  (i[e >> 5] |= 128 << e % 32), (i[I2(e) - 1] = e);
  let t = 1732584193,
    r = -271733879,
    s = -1732584194,
    n = 271733878;
  for (let c = 0; c < i.length; c += 16) {
    const f = t,
      h = r,
      y = s,
      p = n;
    (t = ui(t, r, s, n, i[c], 7, -680876936)),
      (n = ui(n, t, r, s, i[c + 1], 12, -389564586)),
      (s = ui(s, n, t, r, i[c + 2], 17, 606105819)),
      (r = ui(r, s, n, t, i[c + 3], 22, -1044525330)),
      (t = ui(t, r, s, n, i[c + 4], 7, -176418897)),
      (n = ui(n, t, r, s, i[c + 5], 12, 1200080426)),
      (s = ui(s, n, t, r, i[c + 6], 17, -1473231341)),
      (r = ui(r, s, n, t, i[c + 7], 22, -45705983)),
      (t = ui(t, r, s, n, i[c + 8], 7, 1770035416)),
      (n = ui(n, t, r, s, i[c + 9], 12, -1958414417)),
      (s = ui(s, n, t, r, i[c + 10], 17, -42063)),
      (r = ui(r, s, n, t, i[c + 11], 22, -1990404162)),
      (t = ui(t, r, s, n, i[c + 12], 7, 1804603682)),
      (n = ui(n, t, r, s, i[c + 13], 12, -40341101)),
      (s = ui(s, n, t, r, i[c + 14], 17, -1502002290)),
      (r = ui(r, s, n, t, i[c + 15], 22, 1236535329)),
      (t = ci(t, r, s, n, i[c + 1], 5, -165796510)),
      (n = ci(n, t, r, s, i[c + 6], 9, -1069501632)),
      (s = ci(s, n, t, r, i[c + 11], 14, 643717713)),
      (r = ci(r, s, n, t, i[c], 20, -373897302)),
      (t = ci(t, r, s, n, i[c + 5], 5, -701558691)),
      (n = ci(n, t, r, s, i[c + 10], 9, 38016083)),
      (s = ci(s, n, t, r, i[c + 15], 14, -660478335)),
      (r = ci(r, s, n, t, i[c + 4], 20, -405537848)),
      (t = ci(t, r, s, n, i[c + 9], 5, 568446438)),
      (n = ci(n, t, r, s, i[c + 14], 9, -1019803690)),
      (s = ci(s, n, t, r, i[c + 3], 14, -187363961)),
      (r = ci(r, s, n, t, i[c + 8], 20, 1163531501)),
      (t = ci(t, r, s, n, i[c + 13], 5, -1444681467)),
      (n = ci(n, t, r, s, i[c + 2], 9, -51403784)),
      (s = ci(s, n, t, r, i[c + 7], 14, 1735328473)),
      (r = ci(r, s, n, t, i[c + 12], 20, -1926607734)),
      (t = fi(t, r, s, n, i[c + 5], 4, -378558)),
      (n = fi(n, t, r, s, i[c + 8], 11, -2022574463)),
      (s = fi(s, n, t, r, i[c + 11], 16, 1839030562)),
      (r = fi(r, s, n, t, i[c + 14], 23, -35309556)),
      (t = fi(t, r, s, n, i[c + 1], 4, -1530992060)),
      (n = fi(n, t, r, s, i[c + 4], 11, 1272893353)),
      (s = fi(s, n, t, r, i[c + 7], 16, -155497632)),
      (r = fi(r, s, n, t, i[c + 10], 23, -1094730640)),
      (t = fi(t, r, s, n, i[c + 13], 4, 681279174)),
      (n = fi(n, t, r, s, i[c], 11, -358537222)),
      (s = fi(s, n, t, r, i[c + 3], 16, -722521979)),
      (r = fi(r, s, n, t, i[c + 6], 23, 76029189)),
      (t = fi(t, r, s, n, i[c + 9], 4, -640364487)),
      (n = fi(n, t, r, s, i[c + 12], 11, -421815835)),
      (s = fi(s, n, t, r, i[c + 15], 16, 530742520)),
      (r = fi(r, s, n, t, i[c + 2], 23, -995338651)),
      (t = li(t, r, s, n, i[c], 6, -198630844)),
      (n = li(n, t, r, s, i[c + 7], 10, 1126891415)),
      (s = li(s, n, t, r, i[c + 14], 15, -1416354905)),
      (r = li(r, s, n, t, i[c + 5], 21, -57434055)),
      (t = li(t, r, s, n, i[c + 12], 6, 1700485571)),
      (n = li(n, t, r, s, i[c + 3], 10, -1894986606)),
      (s = li(s, n, t, r, i[c + 10], 15, -1051523)),
      (r = li(r, s, n, t, i[c + 1], 21, -2054922799)),
      (t = li(t, r, s, n, i[c + 8], 6, 1873313359)),
      (n = li(n, t, r, s, i[c + 15], 10, -30611744)),
      (s = li(s, n, t, r, i[c + 6], 15, -1560198380)),
      (r = li(r, s, n, t, i[c + 13], 21, 1309151649)),
      (t = li(t, r, s, n, i[c + 4], 6, -145523070)),
      (n = li(n, t, r, s, i[c + 11], 10, -1120210379)),
      (s = li(s, n, t, r, i[c + 2], 15, 718787259)),
      (r = li(r, s, n, t, i[c + 9], 21, -343485551)),
      (t = Io(t, f)),
      (r = Io(r, h)),
      (s = Io(s, y)),
      (n = Io(n, p));
  }
  return [t, r, s, n];
}
function r5(i) {
  if (i.length === 0) return [];
  const e = i.length * 8,
    t = new Uint32Array(I2(e));
  for (let r = 0; r < e; r += 8) t[r >> 5] |= (i[r / 8] & 255) << r % 32;
  return t;
}
function Io(i, e) {
  const t = (i & 65535) + (e & 65535);
  return (((i >> 16) + (e >> 16) + (t >> 16)) << 16) | (t & 65535);
}
function i5(i, e) {
  return (i << e) | (i >>> (32 - e));
}
function yl(i, e, t, r, s, n) {
  return Io(i5(Io(Io(e, i), Io(r, n)), s), t);
}
function ui(i, e, t, r, s, n, c) {
  return yl((e & t) | (~e & r), i, e, s, n, c);
}
function ci(i, e, t, r, s, n, c) {
  return yl((e & r) | (t & ~r), i, e, s, n, c);
}
function fi(i, e, t, r, s, n, c) {
  return yl(e ^ t ^ r, i, e, s, n, c);
}
function li(i, e, t, r, s, n, c) {
  return yl(t ^ (e | ~r), i, e, s, n, c);
}
const n5 = k2('v3', 48, Q4),
  o5 = n5,
  s5 = typeof crypto < 'u' && crypto.randomUUID && crypto.randomUUID.bind(crypto),
  Ag = { randomUUID: s5 };
function a5(i, e, t) {
  if (Ag.randomUUID && !e && !i) return Ag.randomUUID();
  i = i || {};
  const r = i.random || (i.rng || A2)();
  if (((r[6] = (r[6] & 15) | 64), (r[8] = (r[8] & 63) | 128), e)) {
    t = t || 0;
    for (let s = 0; s < 16; ++s) e[t + s] = r[s];
    return e;
  }
  return pl(r);
}
function u5(i, e, t, r) {
  switch (i) {
    case 0:
      return (e & t) ^ (~e & r);
    case 1:
      return e ^ t ^ r;
    case 2:
      return (e & t) ^ (e & r) ^ (t & r);
    case 3:
      return e ^ t ^ r;
  }
}
function Mh(i, e) {
  return (i << e) | (i >>> (32 - e));
}
function c5(i) {
  const e = [1518500249, 1859775393, 2400959708, 3395469782],
    t = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof i == 'string') {
    const c = unescape(encodeURIComponent(i));
    i = [];
    for (let f = 0; f < c.length; ++f) i.push(c.charCodeAt(f));
  } else Array.isArray(i) || (i = Array.prototype.slice.call(i));
  i.push(128);
  const r = i.length / 4 + 2,
    s = Math.ceil(r / 16),
    n = new Array(s);
  for (let c = 0; c < s; ++c) {
    const f = new Uint32Array(16);
    for (let h = 0; h < 16; ++h)
      f[h] =
        (i[c * 64 + h * 4] << 24) |
        (i[c * 64 + h * 4 + 1] << 16) |
        (i[c * 64 + h * 4 + 2] << 8) |
        i[c * 64 + h * 4 + 3];
    n[c] = f;
  }
  (n[s - 1][14] = ((i.length - 1) * 8) / Math.pow(2, 32)),
    (n[s - 1][14] = Math.floor(n[s - 1][14])),
    (n[s - 1][15] = ((i.length - 1) * 8) & 4294967295);
  for (let c = 0; c < s; ++c) {
    const f = new Uint32Array(80);
    for (let A = 0; A < 16; ++A) f[A] = n[c][A];
    for (let A = 16; A < 80; ++A) f[A] = Mh(f[A - 3] ^ f[A - 8] ^ f[A - 14] ^ f[A - 16], 1);
    let h = t[0],
      y = t[1],
      p = t[2],
      m = t[3],
      _ = t[4];
    for (let A = 0; A < 80; ++A) {
      const E = Math.floor(A / 20),
        I = (Mh(h, 5) + u5(E, y, p, m) + _ + e[E] + f[A]) >>> 0;
      (_ = m), (m = p), (p = Mh(y, 30) >>> 0), (y = h), (h = I);
    }
    (t[0] = (t[0] + h) >>> 0),
      (t[1] = (t[1] + y) >>> 0),
      (t[2] = (t[2] + p) >>> 0),
      (t[3] = (t[3] + m) >>> 0),
      (t[4] = (t[4] + _) >>> 0);
  }
  return [
    (t[0] >> 24) & 255,
    (t[0] >> 16) & 255,
    (t[0] >> 8) & 255,
    t[0] & 255,
    (t[1] >> 24) & 255,
    (t[1] >> 16) & 255,
    (t[1] >> 8) & 255,
    t[1] & 255,
    (t[2] >> 24) & 255,
    (t[2] >> 16) & 255,
    (t[2] >> 8) & 255,
    t[2] & 255,
    (t[3] >> 24) & 255,
    (t[3] >> 16) & 255,
    (t[3] >> 8) & 255,
    t[3] & 255,
    (t[4] >> 24) & 255,
    (t[4] >> 16) & 255,
    (t[4] >> 8) & 255,
    t[4] & 255,
  ];
}
const f5 = k2('v5', 80, c5),
  l5 = f5,
  h5 = '00000000-0000-0000-0000-000000000000';
function d5(i) {
  if (!dl(i)) throw TypeError('Invalid UUID');
  return parseInt(i.slice(14, 15), 16);
}
const p5 = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      NIL: h5,
      parse: E2,
      stringify: G4,
      v1: Y4,
      v3: o5,
      v4: a5,
      v5: l5,
      validate: dl,
      version: d5,
    },
    Symbol.toStringTag,
    { value: 'Module' }
  )
);
function y5(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, 'default') ? i.default : i;
}
var x2 = { exports: {} },
  Cr = (x2.exports = {}),
  mn,
  wn;
function Up() {
  throw new Error('setTimeout has not been defined');
}
function zp() {
  throw new Error('clearTimeout has not been defined');
}
(function () {
  try {
    typeof setTimeout == 'function' ? (mn = setTimeout) : (mn = Up);
  } catch {
    mn = Up;
  }
  try {
    typeof clearTimeout == 'function' ? (wn = clearTimeout) : (wn = zp);
  } catch {
    wn = zp;
  }
})();
function B2(i) {
  if (mn === setTimeout) return setTimeout(i, 0);
  if ((mn === Up || !mn) && setTimeout) return (mn = setTimeout), setTimeout(i, 0);
  try {
    return mn(i, 0);
  } catch {
    try {
      return mn.call(null, i, 0);
    } catch {
      return mn.call(this, i, 0);
    }
  }
}
function g5(i) {
  if (wn === clearTimeout) return clearTimeout(i);
  if ((wn === zp || !wn) && clearTimeout) return (wn = clearTimeout), clearTimeout(i);
  try {
    return wn(i);
  } catch {
    try {
      return wn.call(null, i);
    } catch {
      return wn.call(this, i);
    }
  }
}
var to = [],
  sa = !1,
  rs,
  df = -1;
function b5() {
  !sa || !rs || ((sa = !1), rs.length ? (to = rs.concat(to)) : (df = -1), to.length && R2());
}
function R2() {
  if (!sa) {
    var i = B2(b5);
    sa = !0;
    for (var e = to.length; e; ) {
      for (rs = to, to = []; ++df < e; ) rs && rs[df].run();
      (df = -1), (e = to.length);
    }
    (rs = null), (sa = !1), g5(i);
  }
}
Cr.nextTick = function (i) {
  var e = new Array(arguments.length - 1);
  if (arguments.length > 1) for (var t = 1; t < arguments.length; t++) e[t - 1] = arguments[t];
  to.push(new P2(i, e)), to.length === 1 && !sa && B2(R2);
};
function P2(i, e) {
  (this.fun = i), (this.array = e);
}
P2.prototype.run = function () {
  this.fun.apply(null, this.array);
};
Cr.title = 'browser';
Cr.browser = !0;
Cr.env = {};
Cr.argv = [];
Cr.version = '';
Cr.versions = {};
function uo() {}
Cr.on = uo;
Cr.addListener = uo;
Cr.once = uo;
Cr.off = uo;
Cr.removeListener = uo;
Cr.removeAllListeners = uo;
Cr.emit = uo;
Cr.prependListener = uo;
Cr.prependOnceListener = uo;
Cr.listeners = function (i) {
  return [];
};
Cr.binding = function (i) {
  throw new Error('process.binding is not supported');
};
Cr.cwd = function () {
  return '/';
};
Cr.chdir = function (i) {
  throw new Error('process.chdir is not supported');
};
Cr.umask = function () {
  return 0;
};
var v5 = x2.exports;
const Je = y5(v5);
function m5(i, e) {
  if (!(i instanceof e)) throw new TypeError('Cannot call a class as a function');
}
const w5 = Object.freeze(
  Object.defineProperty({ __proto__: null, default: m5 }, Symbol.toStringTag, { value: 'Module' })
);
function ga(i) {
  '@babel/helpers - typeof';
  return (
    (ga =
      typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
        ? function (e) {
            return typeof e;
          }
        : function (e) {
            return e &&
              typeof Symbol == 'function' &&
              e.constructor === Symbol &&
              e !== Symbol.prototype
              ? 'symbol'
              : typeof e;
          }),
    ga(i)
  );
}
function _5(i, e) {
  if (ga(i) !== 'object' || i === null) return i;
  var t = i[Symbol.toPrimitive];
  if (t !== void 0) {
    var r = t.call(i, e || 'default');
    if (ga(r) !== 'object') return r;
    throw new TypeError('@@toPrimitive must return a primitive value.');
  }
  return (e === 'string' ? String : Number)(i);
}
function T2(i) {
  var e = _5(i, 'string');
  return ga(e) === 'symbol' ? e : String(e);
}
function Eg(i, e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t];
    (r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      'value' in r && (r.writable = !0),
      Object.defineProperty(i, T2(r.key), r);
  }
}
function S5(i, e, t) {
  return (
    e && Eg(i.prototype, e),
    t && Eg(i, t),
    Object.defineProperty(i, 'prototype', { writable: !1 }),
    i
  );
}
const M5 = Object.freeze(
  Object.defineProperty({ __proto__: null, default: S5 }, Symbol.toStringTag, { value: 'Module' })
);
function A5(i) {
  if (i === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return i;
}
function E5(i, e) {
  if (e && (ga(e) === 'object' || typeof e == 'function')) return e;
  if (e !== void 0) throw new TypeError('Derived constructors may only return object or undefined');
  return A5(i);
}
const k5 = Object.freeze(
  Object.defineProperty({ __proto__: null, default: E5 }, Symbol.toStringTag, { value: 'Module' })
);
function Fp(i) {
  return (
    (Fp = Object.setPrototypeOf
      ? Object.getPrototypeOf.bind()
      : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        }),
    Fp(i)
  );
}
const I5 = Object.freeze(
  Object.defineProperty({ __proto__: null, default: Fp }, Symbol.toStringTag, { value: 'Module' })
);
function qp(i, e) {
  return (
    (qp = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function (r, s) {
          return (r.__proto__ = s), r;
        }),
    qp(i, e)
  );
}
function x5(i, e) {
  if (typeof e != 'function' && e !== null)
    throw new TypeError('Super expression must either be null or a function');
  (i.prototype = Object.create(e && e.prototype, {
    constructor: { value: i, writable: !0, configurable: !0 },
  })),
    Object.defineProperty(i, 'prototype', { writable: !1 }),
    e && qp(i, e);
}
const B5 = Object.freeze(
  Object.defineProperty({ __proto__: null, default: x5 }, Symbol.toStringTag, { value: 'Module' })
);
function tu(i, e, t) {
  return (
    (e = T2(e)),
    e in i
      ? Object.defineProperty(i, e, { value: t, enumerable: !0, configurable: !0, writable: !0 })
      : (i[e] = t),
    i
  );
}
var O2 = { exports: {} };
(function (i) {
  var e = Object.prototype.hasOwnProperty,
    t = '~';
  function r() {}
  Object.create && ((r.prototype = Object.create(null)), new r().__proto__ || (t = !1));
  function s(h, y, p) {
    (this.fn = h), (this.context = y), (this.once = p || !1);
  }
  function n(h, y, p, m, _) {
    if (typeof p != 'function') throw new TypeError('The listener must be a function');
    var A = new s(p, m || h, _),
      E = t ? t + y : y;
    return (
      h._events[E]
        ? h._events[E].fn
          ? (h._events[E] = [h._events[E], A])
          : h._events[E].push(A)
        : ((h._events[E] = A), h._eventsCount++),
      h
    );
  }
  function c(h, y) {
    --h._eventsCount === 0 ? (h._events = new r()) : delete h._events[y];
  }
  function f() {
    (this._events = new r()), (this._eventsCount = 0);
  }
  (f.prototype.eventNames = function () {
    var y = [],
      p,
      m;
    if (this._eventsCount === 0) return y;
    for (m in (p = this._events)) e.call(p, m) && y.push(t ? m.slice(1) : m);
    return Object.getOwnPropertySymbols ? y.concat(Object.getOwnPropertySymbols(p)) : y;
  }),
    (f.prototype.listeners = function (y) {
      var p = t ? t + y : y,
        m = this._events[p];
      if (!m) return [];
      if (m.fn) return [m.fn];
      for (var _ = 0, A = m.length, E = new Array(A); _ < A; _++) E[_] = m[_].fn;
      return E;
    }),
    (f.prototype.listenerCount = function (y) {
      var p = t ? t + y : y,
        m = this._events[p];
      return m ? (m.fn ? 1 : m.length) : 0;
    }),
    (f.prototype.emit = function (y, p, m, _, A, E) {
      var I = t ? t + y : y;
      if (!this._events[I]) return !1;
      var R = this._events[I],
        L = arguments.length,
        D,
        q;
      if (R.fn) {
        switch ((R.once && this.removeListener(y, R.fn, void 0, !0), L)) {
          case 1:
            return R.fn.call(R.context), !0;
          case 2:
            return R.fn.call(R.context, p), !0;
          case 3:
            return R.fn.call(R.context, p, m), !0;
          case 4:
            return R.fn.call(R.context, p, m, _), !0;
          case 5:
            return R.fn.call(R.context, p, m, _, A), !0;
          case 6:
            return R.fn.call(R.context, p, m, _, A, E), !0;
        }
        for (q = 1, D = new Array(L - 1); q < L; q++) D[q - 1] = arguments[q];
        R.fn.apply(R.context, D);
      } else {
        var H = R.length,
          V;
        for (q = 0; q < H; q++)
          switch ((R[q].once && this.removeListener(y, R[q].fn, void 0, !0), L)) {
            case 1:
              R[q].fn.call(R[q].context);
              break;
            case 2:
              R[q].fn.call(R[q].context, p);
              break;
            case 3:
              R[q].fn.call(R[q].context, p, m);
              break;
            case 4:
              R[q].fn.call(R[q].context, p, m, _);
              break;
            default:
              if (!D) for (V = 1, D = new Array(L - 1); V < L; V++) D[V - 1] = arguments[V];
              R[q].fn.apply(R[q].context, D);
          }
      }
      return !0;
    }),
    (f.prototype.on = function (y, p, m) {
      return n(this, y, p, m, !1);
    }),
    (f.prototype.once = function (y, p, m) {
      return n(this, y, p, m, !0);
    }),
    (f.prototype.removeListener = function (y, p, m, _) {
      var A = t ? t + y : y;
      if (!this._events[A]) return this;
      if (!p) return c(this, A), this;
      var E = this._events[A];
      if (E.fn) E.fn === p && (!_ || E.once) && (!m || E.context === m) && c(this, A);
      else {
        for (var I = 0, R = [], L = E.length; I < L; I++)
          (E[I].fn !== p || (_ && !E[I].once) || (m && E[I].context !== m)) && R.push(E[I]);
        R.length ? (this._events[A] = R.length === 1 ? R[0] : R) : c(this, A);
      }
      return this;
    }),
    (f.prototype.removeAllListeners = function (y) {
      var p;
      return (
        y
          ? ((p = t ? t + y : y), this._events[p] && c(this, p))
          : ((this._events = new r()), (this._eventsCount = 0)),
        this
      );
    }),
    (f.prototype.off = f.prototype.removeListener),
    (f.prototype.addListener = f.prototype.on),
    (f.prefixed = t),
    (f.EventEmitter = f),
    (i.exports = f);
})(O2);
var C2 = O2.exports,
  _t = {},
  qc = { exports: {} },
  Wp = { exports: {} },
  Kr = {},
  gl = {};
gl.byteLength = T5;
gl.toByteArray = C5;
gl.fromByteArray = $5;
var Mn = [],
  Hi = [],
  R5 = typeof Uint8Array < 'u' ? Uint8Array : Array,
  Ah = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var Ds = 0, P5 = Ah.length; Ds < P5; ++Ds) (Mn[Ds] = Ah[Ds]), (Hi[Ah.charCodeAt(Ds)] = Ds);
Hi[45] = 62;
Hi[95] = 63;
function L2(i) {
  var e = i.length;
  if (e % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4');
  var t = i.indexOf('=');
  t === -1 && (t = e);
  var r = t === e ? 0 : 4 - (t % 4);
  return [t, r];
}
function T5(i) {
  var e = L2(i),
    t = e[0],
    r = e[1];
  return ((t + r) * 3) / 4 - r;
}
function O5(i, e, t) {
  return ((e + t) * 3) / 4 - t;
}
function C5(i) {
  var e,
    t = L2(i),
    r = t[0],
    s = t[1],
    n = new R5(O5(i, r, s)),
    c = 0,
    f = s > 0 ? r - 4 : r,
    h;
  for (h = 0; h < f; h += 4)
    (e =
      (Hi[i.charCodeAt(h)] << 18) |
      (Hi[i.charCodeAt(h + 1)] << 12) |
      (Hi[i.charCodeAt(h + 2)] << 6) |
      Hi[i.charCodeAt(h + 3)]),
      (n[c++] = (e >> 16) & 255),
      (n[c++] = (e >> 8) & 255),
      (n[c++] = e & 255);
  return (
    s === 2 &&
      ((e = (Hi[i.charCodeAt(h)] << 2) | (Hi[i.charCodeAt(h + 1)] >> 4)), (n[c++] = e & 255)),
    s === 1 &&
      ((e =
        (Hi[i.charCodeAt(h)] << 10) |
        (Hi[i.charCodeAt(h + 1)] << 4) |
        (Hi[i.charCodeAt(h + 2)] >> 2)),
      (n[c++] = (e >> 8) & 255),
      (n[c++] = e & 255)),
    n
  );
}
function L5(i) {
  return Mn[(i >> 18) & 63] + Mn[(i >> 12) & 63] + Mn[(i >> 6) & 63] + Mn[i & 63];
}
function N5(i, e, t) {
  for (var r, s = [], n = e; n < t; n += 3)
    (r = ((i[n] << 16) & 16711680) + ((i[n + 1] << 8) & 65280) + (i[n + 2] & 255)), s.push(L5(r));
  return s.join('');
}
function $5(i) {
  for (var e, t = i.length, r = t % 3, s = [], n = 16383, c = 0, f = t - r; c < f; c += n)
    s.push(N5(i, c, c + n > f ? f : c + n));
  return (
    r === 1
      ? ((e = i[t - 1]), s.push(Mn[e >> 2] + Mn[(e << 4) & 63] + '=='))
      : r === 2 &&
        ((e = (i[t - 2] << 8) + i[t - 1]),
        s.push(Mn[e >> 10] + Mn[(e >> 4) & 63] + Mn[(e << 2) & 63] + '=')),
    s.join('')
  );
}
var q1 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ q1.read =
  function (i, e, t, r, s) {
    var n,
      c,
      f = s * 8 - r - 1,
      h = (1 << f) - 1,
      y = h >> 1,
      p = -7,
      m = t ? s - 1 : 0,
      _ = t ? -1 : 1,
      A = i[e + m];
    for (
      m += _, n = A & ((1 << -p) - 1), A >>= -p, p += f;
      p > 0;
      n = n * 256 + i[e + m], m += _, p -= 8
    );
    for (c = n & ((1 << -p) - 1), n >>= -p, p += r; p > 0; c = c * 256 + i[e + m], m += _, p -= 8);
    if (n === 0) n = 1 - y;
    else {
      if (n === h) return c ? NaN : (A ? -1 : 1) * (1 / 0);
      (c = c + Math.pow(2, r)), (n = n - y);
    }
    return (A ? -1 : 1) * c * Math.pow(2, n - r);
  };
q1.write = function (i, e, t, r, s, n) {
  var c,
    f,
    h,
    y = n * 8 - s - 1,
    p = (1 << y) - 1,
    m = p >> 1,
    _ = s === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
    A = r ? 0 : n - 1,
    E = r ? 1 : -1,
    I = e < 0 || (e === 0 && 1 / e < 0) ? 1 : 0;
  for (
    e = Math.abs(e),
      isNaN(e) || e === 1 / 0
        ? ((f = isNaN(e) ? 1 : 0), (c = p))
        : ((c = Math.floor(Math.log(e) / Math.LN2)),
          e * (h = Math.pow(2, -c)) < 1 && (c--, (h *= 2)),
          c + m >= 1 ? (e += _ / h) : (e += _ * Math.pow(2, 1 - m)),
          e * h >= 2 && (c++, (h /= 2)),
          c + m >= p
            ? ((f = 0), (c = p))
            : c + m >= 1
              ? ((f = (e * h - 1) * Math.pow(2, s)), (c = c + m))
              : ((f = e * Math.pow(2, m - 1) * Math.pow(2, s)), (c = 0)));
    s >= 8;
    i[t + A] = f & 255, A += E, f /= 256, s -= 8
  );
  for (c = (c << s) | f, y += s; y > 0; i[t + A] = c & 255, A += E, c /= 256, y -= 8);
  i[t + A - E] |= I * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ (function (i) {
  const e = gl,
    t = q1,
    r =
      typeof Symbol == 'function' && typeof Symbol.for == 'function'
        ? Symbol.for('nodejs.util.inspect.custom')
        : null;
  (i.Buffer = p), (i.SlowBuffer = V), (i.INSPECT_MAX_BYTES = 50);
  const s = 2147483647;
  i.kMaxLength = s;
  const { Uint8Array: n, ArrayBuffer: c, SharedArrayBuffer: f } = globalThis;
  (p.TYPED_ARRAY_SUPPORT = h()),
    !p.TYPED_ARRAY_SUPPORT &&
      typeof console < 'u' &&
      typeof console.error == 'function' &&
      console.error(
        'This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
      );
  function h() {
    try {
      const T = new n(1),
        x = {
          foo: function () {
            return 42;
          },
        };
      return Object.setPrototypeOf(x, n.prototype), Object.setPrototypeOf(T, x), T.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(p.prototype, 'parent', {
    enumerable: !0,
    get: function () {
      if (p.isBuffer(this)) return this.buffer;
    },
  }),
    Object.defineProperty(p.prototype, 'offset', {
      enumerable: !0,
      get: function () {
        if (p.isBuffer(this)) return this.byteOffset;
      },
    });
  function y(T) {
    if (T > s) throw new RangeError('The value "' + T + '" is invalid for option "size"');
    const x = new n(T);
    return Object.setPrototypeOf(x, p.prototype), x;
  }
  function p(T, x, N) {
    if (typeof T == 'number') {
      if (typeof x == 'string')
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return E(T);
    }
    return m(T, x, N);
  }
  p.poolSize = 8192;
  function m(T, x, N) {
    if (typeof T == 'string') return I(T, x);
    if (c.isView(T)) return L(T);
    if (T == null)
      throw new TypeError(
        'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
          typeof T
      );
    if (
      he(T, c) ||
      (T && he(T.buffer, c)) ||
      (typeof f < 'u' && (he(T, f) || (T && he(T.buffer, f))))
    )
      return D(T, x, N);
    if (typeof T == 'number')
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    const j = T.valueOf && T.valueOf();
    if (j != null && j !== T) return p.from(j, x, N);
    const J = q(T);
    if (J) return J;
    if (
      typeof Symbol < 'u' &&
      Symbol.toPrimitive != null &&
      typeof T[Symbol.toPrimitive] == 'function'
    )
      return p.from(T[Symbol.toPrimitive]('string'), x, N);
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
        typeof T
    );
  }
  (p.from = function (T, x, N) {
    return m(T, x, N);
  }),
    Object.setPrototypeOf(p.prototype, n.prototype),
    Object.setPrototypeOf(p, n);
  function _(T) {
    if (typeof T != 'number') throw new TypeError('"size" argument must be of type number');
    if (T < 0) throw new RangeError('The value "' + T + '" is invalid for option "size"');
  }
  function A(T, x, N) {
    return (
      _(T),
      T <= 0 ? y(T) : x !== void 0 ? (typeof N == 'string' ? y(T).fill(x, N) : y(T).fill(x)) : y(T)
    );
  }
  p.alloc = function (T, x, N) {
    return A(T, x, N);
  };
  function E(T) {
    return _(T), y(T < 0 ? 0 : H(T) | 0);
  }
  (p.allocUnsafe = function (T) {
    return E(T);
  }),
    (p.allocUnsafeSlow = function (T) {
      return E(T);
    });
  function I(T, x) {
    if (((typeof x != 'string' || x === '') && (x = 'utf8'), !p.isEncoding(x)))
      throw new TypeError('Unknown encoding: ' + x);
    const N = te(T, x) | 0;
    let j = y(N);
    const J = j.write(T, x);
    return J !== N && (j = j.slice(0, J)), j;
  }
  function R(T) {
    const x = T.length < 0 ? 0 : H(T.length) | 0,
      N = y(x);
    for (let j = 0; j < x; j += 1) N[j] = T[j] & 255;
    return N;
  }
  function L(T) {
    if (he(T, n)) {
      const x = new n(T);
      return D(x.buffer, x.byteOffset, x.byteLength);
    }
    return R(T);
  }
  function D(T, x, N) {
    if (x < 0 || T.byteLength < x) throw new RangeError('"offset" is outside of buffer bounds');
    if (T.byteLength < x + (N || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let j;
    return (
      x === void 0 && N === void 0
        ? (j = new n(T))
        : N === void 0
          ? (j = new n(T, x))
          : (j = new n(T, x, N)),
      Object.setPrototypeOf(j, p.prototype),
      j
    );
  }
  function q(T) {
    if (p.isBuffer(T)) {
      const x = H(T.length) | 0,
        N = y(x);
      return N.length === 0 || T.copy(N, 0, 0, x), N;
    }
    if (T.length !== void 0) return typeof T.length != 'number' || Ke(T.length) ? y(0) : R(T);
    if (T.type === 'Buffer' && Array.isArray(T.data)) return R(T.data);
  }
  function H(T) {
    if (T >= s)
      throw new RangeError(
        'Attempt to allocate Buffer larger than maximum size: 0x' + s.toString(16) + ' bytes'
      );
    return T | 0;
  }
  function V(T) {
    return +T != T && (T = 0), p.alloc(+T);
  }
  (p.isBuffer = function (x) {
    return x != null && x._isBuffer === !0 && x !== p.prototype;
  }),
    (p.compare = function (x, N) {
      if (
        (he(x, n) && (x = p.from(x, x.offset, x.byteLength)),
        he(N, n) && (N = p.from(N, N.offset, N.byteLength)),
        !p.isBuffer(x) || !p.isBuffer(N))
      )
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      if (x === N) return 0;
      let j = x.length,
        J = N.length;
      for (let de = 0, ie = Math.min(j, J); de < ie; ++de)
        if (x[de] !== N[de]) {
          (j = x[de]), (J = N[de]);
          break;
        }
      return j < J ? -1 : J < j ? 1 : 0;
    }),
    (p.isEncoding = function (x) {
      switch (String(x).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return !0;
        default:
          return !1;
      }
    }),
    (p.concat = function (x, N) {
      if (!Array.isArray(x)) throw new TypeError('"list" argument must be an Array of Buffers');
      if (x.length === 0) return p.alloc(0);
      let j;
      if (N === void 0) for (N = 0, j = 0; j < x.length; ++j) N += x[j].length;
      const J = p.allocUnsafe(N);
      let de = 0;
      for (j = 0; j < x.length; ++j) {
        let ie = x[j];
        if (he(ie, n))
          de + ie.length > J.length
            ? (p.isBuffer(ie) || (ie = p.from(ie)), ie.copy(J, de))
            : n.prototype.set.call(J, ie, de);
        else if (p.isBuffer(ie)) ie.copy(J, de);
        else throw new TypeError('"list" argument must be an Array of Buffers');
        de += ie.length;
      }
      return J;
    });
  function te(T, x) {
    if (p.isBuffer(T)) return T.length;
    if (c.isView(T) || he(T, c)) return T.byteLength;
    if (typeof T != 'string')
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
          typeof T
      );
    const N = T.length,
      j = arguments.length > 2 && arguments[2] === !0;
    if (!j && N === 0) return 0;
    let J = !1;
    for (;;)
      switch (x) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return N;
        case 'utf8':
        case 'utf-8':
          return rt(T).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return N * 2;
        case 'hex':
          return N >>> 1;
        case 'base64':
          return ge(T).length;
        default:
          if (J) return j ? -1 : rt(T).length;
          (x = ('' + x).toLowerCase()), (J = !0);
      }
  }
  p.byteLength = te;
  function ue(T, x, N) {
    let j = !1;
    if (
      ((x === void 0 || x < 0) && (x = 0),
      x > this.length ||
        ((N === void 0 || N > this.length) && (N = this.length), N <= 0) ||
        ((N >>>= 0), (x >>>= 0), N <= x))
    )
      return '';
    for (T || (T = 'utf8'); ; )
      switch (T) {
        case 'hex':
          return k(this, x, N);
        case 'utf8':
        case 'utf-8':
          return w(this, x, N);
        case 'ascii':
          return a(this, x, N);
        case 'latin1':
        case 'binary':
          return b(this, x, N);
        case 'base64':
          return g(this, x, N);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return B(this, x, N);
        default:
          if (j) throw new TypeError('Unknown encoding: ' + T);
          (T = (T + '').toLowerCase()), (j = !0);
      }
  }
  p.prototype._isBuffer = !0;
  function ne(T, x, N) {
    const j = T[x];
    (T[x] = T[N]), (T[N] = j);
  }
  (p.prototype.swap16 = function () {
    const x = this.length;
    if (x % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits');
    for (let N = 0; N < x; N += 2) ne(this, N, N + 1);
    return this;
  }),
    (p.prototype.swap32 = function () {
      const x = this.length;
      if (x % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits');
      for (let N = 0; N < x; N += 4) ne(this, N, N + 3), ne(this, N + 1, N + 2);
      return this;
    }),
    (p.prototype.swap64 = function () {
      const x = this.length;
      if (x % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits');
      for (let N = 0; N < x; N += 8)
        ne(this, N, N + 7), ne(this, N + 1, N + 6), ne(this, N + 2, N + 5), ne(this, N + 3, N + 4);
      return this;
    }),
    (p.prototype.toString = function () {
      const x = this.length;
      return x === 0 ? '' : arguments.length === 0 ? w(this, 0, x) : ue.apply(this, arguments);
    }),
    (p.prototype.toLocaleString = p.prototype.toString),
    (p.prototype.equals = function (x) {
      if (!p.isBuffer(x)) throw new TypeError('Argument must be a Buffer');
      return this === x ? !0 : p.compare(this, x) === 0;
    }),
    (p.prototype.inspect = function () {
      let x = '';
      const N = i.INSPECT_MAX_BYTES;
      return (
        (x = this.toString('hex', 0, N)
          .replace(/(.{2})/g, '$1 ')
          .trim()),
        this.length > N && (x += ' ... '),
        '<Buffer ' + x + '>'
      );
    }),
    r && (p.prototype[r] = p.prototype.inspect),
    (p.prototype.compare = function (x, N, j, J, de) {
      if ((he(x, n) && (x = p.from(x, x.offset, x.byteLength)), !p.isBuffer(x)))
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
            typeof x
        );
      if (
        (N === void 0 && (N = 0),
        j === void 0 && (j = x ? x.length : 0),
        J === void 0 && (J = 0),
        de === void 0 && (de = this.length),
        N < 0 || j > x.length || J < 0 || de > this.length)
      )
        throw new RangeError('out of range index');
      if (J >= de && N >= j) return 0;
      if (J >= de) return -1;
      if (N >= j) return 1;
      if (((N >>>= 0), (j >>>= 0), (J >>>= 0), (de >>>= 0), this === x)) return 0;
      let ie = de - J,
        ye = j - N;
      const Ye = Math.min(ie, ye),
        ve = this.slice(J, de),
        _e = x.slice(N, j);
      for (let et = 0; et < Ye; ++et)
        if (ve[et] !== _e[et]) {
          (ie = ve[et]), (ye = _e[et]);
          break;
        }
      return ie < ye ? -1 : ye < ie ? 1 : 0;
    });
  function X(T, x, N, j, J) {
    if (T.length === 0) return -1;
    if (
      (typeof N == 'string'
        ? ((j = N), (N = 0))
        : N > 2147483647
          ? (N = 2147483647)
          : N < -2147483648 && (N = -2147483648),
      (N = +N),
      Ke(N) && (N = J ? 0 : T.length - 1),
      N < 0 && (N = T.length + N),
      N >= T.length)
    ) {
      if (J) return -1;
      N = T.length - 1;
    } else if (N < 0)
      if (J) N = 0;
      else return -1;
    if ((typeof x == 'string' && (x = p.from(x, j)), p.isBuffer(x)))
      return x.length === 0 ? -1 : Oe(T, x, N, j, J);
    if (typeof x == 'number')
      return (
        (x = x & 255),
        typeof n.prototype.indexOf == 'function'
          ? J
            ? n.prototype.indexOf.call(T, x, N)
            : n.prototype.lastIndexOf.call(T, x, N)
          : Oe(T, [x], N, j, J)
      );
    throw new TypeError('val must be string, number or Buffer');
  }
  function Oe(T, x, N, j, J) {
    let de = 1,
      ie = T.length,
      ye = x.length;
    if (
      j !== void 0 &&
      ((j = String(j).toLowerCase()),
      j === 'ucs2' || j === 'ucs-2' || j === 'utf16le' || j === 'utf-16le')
    ) {
      if (T.length < 2 || x.length < 2) return -1;
      (de = 2), (ie /= 2), (ye /= 2), (N /= 2);
    }
    function Ye(_e, et) {
      return de === 1 ? _e[et] : _e.readUInt16BE(et * de);
    }
    let ve;
    if (J) {
      let _e = -1;
      for (ve = N; ve < ie; ve++)
        if (Ye(T, ve) === Ye(x, _e === -1 ? 0 : ve - _e)) {
          if ((_e === -1 && (_e = ve), ve - _e + 1 === ye)) return _e * de;
        } else _e !== -1 && (ve -= ve - _e), (_e = -1);
    } else
      for (N + ye > ie && (N = ie - ye), ve = N; ve >= 0; ve--) {
        let _e = !0;
        for (let et = 0; et < ye; et++)
          if (Ye(T, ve + et) !== Ye(x, et)) {
            _e = !1;
            break;
          }
        if (_e) return ve;
      }
    return -1;
  }
  (p.prototype.includes = function (x, N, j) {
    return this.indexOf(x, N, j) !== -1;
  }),
    (p.prototype.indexOf = function (x, N, j) {
      return X(this, x, N, j, !0);
    }),
    (p.prototype.lastIndexOf = function (x, N, j) {
      return X(this, x, N, j, !1);
    });
  function S(T, x, N, j) {
    N = Number(N) || 0;
    const J = T.length - N;
    j ? ((j = Number(j)), j > J && (j = J)) : (j = J);
    const de = x.length;
    j > de / 2 && (j = de / 2);
    let ie;
    for (ie = 0; ie < j; ++ie) {
      const ye = parseInt(x.substr(ie * 2, 2), 16);
      if (Ke(ye)) return ie;
      T[N + ie] = ye;
    }
    return ie;
  }
  function o(T, x, N, j) {
    return ce(rt(x, T.length - N), T, N, j);
  }
  function u(T, x, N, j) {
    return ce(me(x), T, N, j);
  }
  function l(T, x, N, j) {
    return ce(ge(x), T, N, j);
  }
  function d(T, x, N, j) {
    return ce(re(x, T.length - N), T, N, j);
  }
  (p.prototype.write = function (x, N, j, J) {
    if (N === void 0) (J = 'utf8'), (j = this.length), (N = 0);
    else if (j === void 0 && typeof N == 'string') (J = N), (j = this.length), (N = 0);
    else if (isFinite(N))
      (N = N >>> 0),
        isFinite(j) ? ((j = j >>> 0), J === void 0 && (J = 'utf8')) : ((J = j), (j = void 0));
    else throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    const de = this.length - N;
    if (
      ((j === void 0 || j > de) && (j = de), (x.length > 0 && (j < 0 || N < 0)) || N > this.length)
    )
      throw new RangeError('Attempt to write outside buffer bounds');
    J || (J = 'utf8');
    let ie = !1;
    for (;;)
      switch (J) {
        case 'hex':
          return S(this, x, N, j);
        case 'utf8':
        case 'utf-8':
          return o(this, x, N, j);
        case 'ascii':
        case 'latin1':
        case 'binary':
          return u(this, x, N, j);
        case 'base64':
          return l(this, x, N, j);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return d(this, x, N, j);
        default:
          if (ie) throw new TypeError('Unknown encoding: ' + J);
          (J = ('' + J).toLowerCase()), (ie = !0);
      }
  }),
    (p.prototype.toJSON = function () {
      return { type: 'Buffer', data: Array.prototype.slice.call(this._arr || this, 0) };
    });
  function g(T, x, N) {
    return x === 0 && N === T.length ? e.fromByteArray(T) : e.fromByteArray(T.slice(x, N));
  }
  function w(T, x, N) {
    N = Math.min(T.length, N);
    const j = [];
    let J = x;
    for (; J < N; ) {
      const de = T[J];
      let ie = null,
        ye = de > 239 ? 4 : de > 223 ? 3 : de > 191 ? 2 : 1;
      if (J + ye <= N) {
        let Ye, ve, _e, et;
        switch (ye) {
          case 1:
            de < 128 && (ie = de);
            break;
          case 2:
            (Ye = T[J + 1]),
              (Ye & 192) === 128 && ((et = ((de & 31) << 6) | (Ye & 63)), et > 127 && (ie = et));
            break;
          case 3:
            (Ye = T[J + 1]),
              (ve = T[J + 2]),
              (Ye & 192) === 128 &&
                (ve & 192) === 128 &&
                ((et = ((de & 15) << 12) | ((Ye & 63) << 6) | (ve & 63)),
                et > 2047 && (et < 55296 || et > 57343) && (ie = et));
            break;
          case 4:
            (Ye = T[J + 1]),
              (ve = T[J + 2]),
              (_e = T[J + 3]),
              (Ye & 192) === 128 &&
                (ve & 192) === 128 &&
                (_e & 192) === 128 &&
                ((et = ((de & 15) << 18) | ((Ye & 63) << 12) | ((ve & 63) << 6) | (_e & 63)),
                et > 65535 && et < 1114112 && (ie = et));
        }
      }
      ie === null
        ? ((ie = 65533), (ye = 1))
        : ie > 65535 &&
          ((ie -= 65536), j.push(((ie >>> 10) & 1023) | 55296), (ie = 56320 | (ie & 1023))),
        j.push(ie),
        (J += ye);
    }
    return v(j);
  }
  const M = 4096;
  function v(T) {
    const x = T.length;
    if (x <= M) return String.fromCharCode.apply(String, T);
    let N = '',
      j = 0;
    for (; j < x; ) N += String.fromCharCode.apply(String, T.slice(j, (j += M)));
    return N;
  }
  function a(T, x, N) {
    let j = '';
    N = Math.min(T.length, N);
    for (let J = x; J < N; ++J) j += String.fromCharCode(T[J] & 127);
    return j;
  }
  function b(T, x, N) {
    let j = '';
    N = Math.min(T.length, N);
    for (let J = x; J < N; ++J) j += String.fromCharCode(T[J]);
    return j;
  }
  function k(T, x, N) {
    const j = T.length;
    (!x || x < 0) && (x = 0), (!N || N < 0 || N > j) && (N = j);
    let J = '';
    for (let de = x; de < N; ++de) J += K[T[de]];
    return J;
  }
  function B(T, x, N) {
    const j = T.slice(x, N);
    let J = '';
    for (let de = 0; de < j.length - 1; de += 2) J += String.fromCharCode(j[de] + j[de + 1] * 256);
    return J;
  }
  p.prototype.slice = function (x, N) {
    const j = this.length;
    (x = ~~x),
      (N = N === void 0 ? j : ~~N),
      x < 0 ? ((x += j), x < 0 && (x = 0)) : x > j && (x = j),
      N < 0 ? ((N += j), N < 0 && (N = 0)) : N > j && (N = j),
      N < x && (N = x);
    const J = this.subarray(x, N);
    return Object.setPrototypeOf(J, p.prototype), J;
  };
  function F(T, x, N) {
    if (T % 1 !== 0 || T < 0) throw new RangeError('offset is not uint');
    if (T + x > N) throw new RangeError('Trying to access beyond buffer length');
  }
  (p.prototype.readUintLE = p.prototype.readUIntLE =
    function (x, N, j) {
      (x = x >>> 0), (N = N >>> 0), j || F(x, N, this.length);
      let J = this[x],
        de = 1,
        ie = 0;
      for (; ++ie < N && (de *= 256); ) J += this[x + ie] * de;
      return J;
    }),
    (p.prototype.readUintBE = p.prototype.readUIntBE =
      function (x, N, j) {
        (x = x >>> 0), (N = N >>> 0), j || F(x, N, this.length);
        let J = this[x + --N],
          de = 1;
        for (; N > 0 && (de *= 256); ) J += this[x + --N] * de;
        return J;
      }),
    (p.prototype.readUint8 = p.prototype.readUInt8 =
      function (x, N) {
        return (x = x >>> 0), N || F(x, 1, this.length), this[x];
      }),
    (p.prototype.readUint16LE = p.prototype.readUInt16LE =
      function (x, N) {
        return (x = x >>> 0), N || F(x, 2, this.length), this[x] | (this[x + 1] << 8);
      }),
    (p.prototype.readUint16BE = p.prototype.readUInt16BE =
      function (x, N) {
        return (x = x >>> 0), N || F(x, 2, this.length), (this[x] << 8) | this[x + 1];
      }),
    (p.prototype.readUint32LE = p.prototype.readUInt32LE =
      function (x, N) {
        return (
          (x = x >>> 0),
          N || F(x, 4, this.length),
          (this[x] | (this[x + 1] << 8) | (this[x + 2] << 16)) + this[x + 3] * 16777216
        );
      }),
    (p.prototype.readUint32BE = p.prototype.readUInt32BE =
      function (x, N) {
        return (
          (x = x >>> 0),
          N || F(x, 4, this.length),
          this[x] * 16777216 + ((this[x + 1] << 16) | (this[x + 2] << 8) | this[x + 3])
        );
      }),
    (p.prototype.readBigUInt64LE = O(function (x) {
      (x = x >>> 0), le(x, 'offset');
      const N = this[x],
        j = this[x + 7];
      (N === void 0 || j === void 0) && Fe(x, this.length - 8);
      const J = N + this[++x] * 2 ** 8 + this[++x] * 2 ** 16 + this[++x] * 2 ** 24,
        de = this[++x] + this[++x] * 2 ** 8 + this[++x] * 2 ** 16 + j * 2 ** 24;
      return BigInt(J) + (BigInt(de) << BigInt(32));
    })),
    (p.prototype.readBigUInt64BE = O(function (x) {
      (x = x >>> 0), le(x, 'offset');
      const N = this[x],
        j = this[x + 7];
      (N === void 0 || j === void 0) && Fe(x, this.length - 8);
      const J = N * 2 ** 24 + this[++x] * 2 ** 16 + this[++x] * 2 ** 8 + this[++x],
        de = this[++x] * 2 ** 24 + this[++x] * 2 ** 16 + this[++x] * 2 ** 8 + j;
      return (BigInt(J) << BigInt(32)) + BigInt(de);
    })),
    (p.prototype.readIntLE = function (x, N, j) {
      (x = x >>> 0), (N = N >>> 0), j || F(x, N, this.length);
      let J = this[x],
        de = 1,
        ie = 0;
      for (; ++ie < N && (de *= 256); ) J += this[x + ie] * de;
      return (de *= 128), J >= de && (J -= Math.pow(2, 8 * N)), J;
    }),
    (p.prototype.readIntBE = function (x, N, j) {
      (x = x >>> 0), (N = N >>> 0), j || F(x, N, this.length);
      let J = N,
        de = 1,
        ie = this[x + --J];
      for (; J > 0 && (de *= 256); ) ie += this[x + --J] * de;
      return (de *= 128), ie >= de && (ie -= Math.pow(2, 8 * N)), ie;
    }),
    (p.prototype.readInt8 = function (x, N) {
      return (
        (x = x >>> 0), N || F(x, 1, this.length), this[x] & 128 ? (255 - this[x] + 1) * -1 : this[x]
      );
    }),
    (p.prototype.readInt16LE = function (x, N) {
      (x = x >>> 0), N || F(x, 2, this.length);
      const j = this[x] | (this[x + 1] << 8);
      return j & 32768 ? j | 4294901760 : j;
    }),
    (p.prototype.readInt16BE = function (x, N) {
      (x = x >>> 0), N || F(x, 2, this.length);
      const j = this[x + 1] | (this[x] << 8);
      return j & 32768 ? j | 4294901760 : j;
    }),
    (p.prototype.readInt32LE = function (x, N) {
      return (
        (x = x >>> 0),
        N || F(x, 4, this.length),
        this[x] | (this[x + 1] << 8) | (this[x + 2] << 16) | (this[x + 3] << 24)
      );
    }),
    (p.prototype.readInt32BE = function (x, N) {
      return (
        (x = x >>> 0),
        N || F(x, 4, this.length),
        (this[x] << 24) | (this[x + 1] << 16) | (this[x + 2] << 8) | this[x + 3]
      );
    }),
    (p.prototype.readBigInt64LE = O(function (x) {
      (x = x >>> 0), le(x, 'offset');
      const N = this[x],
        j = this[x + 7];
      (N === void 0 || j === void 0) && Fe(x, this.length - 8);
      const J = this[x + 4] + this[x + 5] * 2 ** 8 + this[x + 6] * 2 ** 16 + (j << 24);
      return (
        (BigInt(J) << BigInt(32)) +
        BigInt(N + this[++x] * 2 ** 8 + this[++x] * 2 ** 16 + this[++x] * 2 ** 24)
      );
    })),
    (p.prototype.readBigInt64BE = O(function (x) {
      (x = x >>> 0), le(x, 'offset');
      const N = this[x],
        j = this[x + 7];
      (N === void 0 || j === void 0) && Fe(x, this.length - 8);
      const J = (N << 24) + this[++x] * 2 ** 16 + this[++x] * 2 ** 8 + this[++x];
      return (
        (BigInt(J) << BigInt(32)) +
        BigInt(this[++x] * 2 ** 24 + this[++x] * 2 ** 16 + this[++x] * 2 ** 8 + j)
      );
    })),
    (p.prototype.readFloatLE = function (x, N) {
      return (x = x >>> 0), N || F(x, 4, this.length), t.read(this, x, !0, 23, 4);
    }),
    (p.prototype.readFloatBE = function (x, N) {
      return (x = x >>> 0), N || F(x, 4, this.length), t.read(this, x, !1, 23, 4);
    }),
    (p.prototype.readDoubleLE = function (x, N) {
      return (x = x >>> 0), N || F(x, 8, this.length), t.read(this, x, !0, 52, 8);
    }),
    (p.prototype.readDoubleBE = function (x, N) {
      return (x = x >>> 0), N || F(x, 8, this.length), t.read(this, x, !1, 52, 8);
    });
  function P(T, x, N, j, J, de) {
    if (!p.isBuffer(T)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (x > J || x < de) throw new RangeError('"value" argument is out of bounds');
    if (N + j > T.length) throw new RangeError('Index out of range');
  }
  (p.prototype.writeUintLE = p.prototype.writeUIntLE =
    function (x, N, j, J) {
      if (((x = +x), (N = N >>> 0), (j = j >>> 0), !J)) {
        const ye = Math.pow(2, 8 * j) - 1;
        P(this, x, N, j, ye, 0);
      }
      let de = 1,
        ie = 0;
      for (this[N] = x & 255; ++ie < j && (de *= 256); ) this[N + ie] = (x / de) & 255;
      return N + j;
    }),
    (p.prototype.writeUintBE = p.prototype.writeUIntBE =
      function (x, N, j, J) {
        if (((x = +x), (N = N >>> 0), (j = j >>> 0), !J)) {
          const ye = Math.pow(2, 8 * j) - 1;
          P(this, x, N, j, ye, 0);
        }
        let de = j - 1,
          ie = 1;
        for (this[N + de] = x & 255; --de >= 0 && (ie *= 256); ) this[N + de] = (x / ie) & 255;
        return N + j;
      }),
    (p.prototype.writeUint8 = p.prototype.writeUInt8 =
      function (x, N, j) {
        return (x = +x), (N = N >>> 0), j || P(this, x, N, 1, 255, 0), (this[N] = x & 255), N + 1;
      }),
    (p.prototype.writeUint16LE = p.prototype.writeUInt16LE =
      function (x, N, j) {
        return (
          (x = +x),
          (N = N >>> 0),
          j || P(this, x, N, 2, 65535, 0),
          (this[N] = x & 255),
          (this[N + 1] = x >>> 8),
          N + 2
        );
      }),
    (p.prototype.writeUint16BE = p.prototype.writeUInt16BE =
      function (x, N, j) {
        return (
          (x = +x),
          (N = N >>> 0),
          j || P(this, x, N, 2, 65535, 0),
          (this[N] = x >>> 8),
          (this[N + 1] = x & 255),
          N + 2
        );
      }),
    (p.prototype.writeUint32LE = p.prototype.writeUInt32LE =
      function (x, N, j) {
        return (
          (x = +x),
          (N = N >>> 0),
          j || P(this, x, N, 4, 4294967295, 0),
          (this[N + 3] = x >>> 24),
          (this[N + 2] = x >>> 16),
          (this[N + 1] = x >>> 8),
          (this[N] = x & 255),
          N + 4
        );
      }),
    (p.prototype.writeUint32BE = p.prototype.writeUInt32BE =
      function (x, N, j) {
        return (
          (x = +x),
          (N = N >>> 0),
          j || P(this, x, N, 4, 4294967295, 0),
          (this[N] = x >>> 24),
          (this[N + 1] = x >>> 16),
          (this[N + 2] = x >>> 8),
          (this[N + 3] = x & 255),
          N + 4
        );
      });
  function C(T, x, N, j, J) {
    fe(x, j, J, T, N, 7);
    let de = Number(x & BigInt(4294967295));
    (T[N++] = de),
      (de = de >> 8),
      (T[N++] = de),
      (de = de >> 8),
      (T[N++] = de),
      (de = de >> 8),
      (T[N++] = de);
    let ie = Number((x >> BigInt(32)) & BigInt(4294967295));
    return (
      (T[N++] = ie),
      (ie = ie >> 8),
      (T[N++] = ie),
      (ie = ie >> 8),
      (T[N++] = ie),
      (ie = ie >> 8),
      (T[N++] = ie),
      N
    );
  }
  function z(T, x, N, j, J) {
    fe(x, j, J, T, N, 7);
    let de = Number(x & BigInt(4294967295));
    (T[N + 7] = de),
      (de = de >> 8),
      (T[N + 6] = de),
      (de = de >> 8),
      (T[N + 5] = de),
      (de = de >> 8),
      (T[N + 4] = de);
    let ie = Number((x >> BigInt(32)) & BigInt(4294967295));
    return (
      (T[N + 3] = ie),
      (ie = ie >> 8),
      (T[N + 2] = ie),
      (ie = ie >> 8),
      (T[N + 1] = ie),
      (ie = ie >> 8),
      (T[N] = ie),
      N + 8
    );
  }
  (p.prototype.writeBigUInt64LE = O(function (x, N = 0) {
    return C(this, x, N, BigInt(0), BigInt('0xffffffffffffffff'));
  })),
    (p.prototype.writeBigUInt64BE = O(function (x, N = 0) {
      return z(this, x, N, BigInt(0), BigInt('0xffffffffffffffff'));
    })),
    (p.prototype.writeIntLE = function (x, N, j, J) {
      if (((x = +x), (N = N >>> 0), !J)) {
        const Ye = Math.pow(2, 8 * j - 1);
        P(this, x, N, j, Ye - 1, -Ye);
      }
      let de = 0,
        ie = 1,
        ye = 0;
      for (this[N] = x & 255; ++de < j && (ie *= 256); )
        x < 0 && ye === 0 && this[N + de - 1] !== 0 && (ye = 1),
          (this[N + de] = (((x / ie) >> 0) - ye) & 255);
      return N + j;
    }),
    (p.prototype.writeIntBE = function (x, N, j, J) {
      if (((x = +x), (N = N >>> 0), !J)) {
        const Ye = Math.pow(2, 8 * j - 1);
        P(this, x, N, j, Ye - 1, -Ye);
      }
      let de = j - 1,
        ie = 1,
        ye = 0;
      for (this[N + de] = x & 255; --de >= 0 && (ie *= 256); )
        x < 0 && ye === 0 && this[N + de + 1] !== 0 && (ye = 1),
          (this[N + de] = (((x / ie) >> 0) - ye) & 255);
      return N + j;
    }),
    (p.prototype.writeInt8 = function (x, N, j) {
      return (
        (x = +x),
        (N = N >>> 0),
        j || P(this, x, N, 1, 127, -128),
        x < 0 && (x = 255 + x + 1),
        (this[N] = x & 255),
        N + 1
      );
    }),
    (p.prototype.writeInt16LE = function (x, N, j) {
      return (
        (x = +x),
        (N = N >>> 0),
        j || P(this, x, N, 2, 32767, -32768),
        (this[N] = x & 255),
        (this[N + 1] = x >>> 8),
        N + 2
      );
    }),
    (p.prototype.writeInt16BE = function (x, N, j) {
      return (
        (x = +x),
        (N = N >>> 0),
        j || P(this, x, N, 2, 32767, -32768),
        (this[N] = x >>> 8),
        (this[N + 1] = x & 255),
        N + 2
      );
    }),
    (p.prototype.writeInt32LE = function (x, N, j) {
      return (
        (x = +x),
        (N = N >>> 0),
        j || P(this, x, N, 4, 2147483647, -2147483648),
        (this[N] = x & 255),
        (this[N + 1] = x >>> 8),
        (this[N + 2] = x >>> 16),
        (this[N + 3] = x >>> 24),
        N + 4
      );
    }),
    (p.prototype.writeInt32BE = function (x, N, j) {
      return (
        (x = +x),
        (N = N >>> 0),
        j || P(this, x, N, 4, 2147483647, -2147483648),
        x < 0 && (x = 4294967295 + x + 1),
        (this[N] = x >>> 24),
        (this[N + 1] = x >>> 16),
        (this[N + 2] = x >>> 8),
        (this[N + 3] = x & 255),
        N + 4
      );
    }),
    (p.prototype.writeBigInt64LE = O(function (x, N = 0) {
      return C(this, x, N, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
    })),
    (p.prototype.writeBigInt64BE = O(function (x, N = 0) {
      return z(this, x, N, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
    }));
  function Y(T, x, N, j, J, de) {
    if (N + j > T.length) throw new RangeError('Index out of range');
    if (N < 0) throw new RangeError('Index out of range');
  }
  function G(T, x, N, j, J) {
    return (x = +x), (N = N >>> 0), J || Y(T, x, N, 4), t.write(T, x, N, j, 23, 4), N + 4;
  }
  (p.prototype.writeFloatLE = function (x, N, j) {
    return G(this, x, N, !0, j);
  }),
    (p.prototype.writeFloatBE = function (x, N, j) {
      return G(this, x, N, !1, j);
    });
  function Q(T, x, N, j, J) {
    return (x = +x), (N = N >>> 0), J || Y(T, x, N, 8), t.write(T, x, N, j, 52, 8), N + 8;
  }
  (p.prototype.writeDoubleLE = function (x, N, j) {
    return Q(this, x, N, !0, j);
  }),
    (p.prototype.writeDoubleBE = function (x, N, j) {
      return Q(this, x, N, !1, j);
    }),
    (p.prototype.copy = function (x, N, j, J) {
      if (!p.isBuffer(x)) throw new TypeError('argument should be a Buffer');
      if (
        (j || (j = 0),
        !J && J !== 0 && (J = this.length),
        N >= x.length && (N = x.length),
        N || (N = 0),
        J > 0 && J < j && (J = j),
        J === j || x.length === 0 || this.length === 0)
      )
        return 0;
      if (N < 0) throw new RangeError('targetStart out of bounds');
      if (j < 0 || j >= this.length) throw new RangeError('Index out of range');
      if (J < 0) throw new RangeError('sourceEnd out of bounds');
      J > this.length && (J = this.length), x.length - N < J - j && (J = x.length - N + j);
      const de = J - j;
      return (
        this === x && typeof n.prototype.copyWithin == 'function'
          ? this.copyWithin(N, j, J)
          : n.prototype.set.call(x, this.subarray(j, J), N),
        de
      );
    }),
    (p.prototype.fill = function (x, N, j, J) {
      if (typeof x == 'string') {
        if (
          (typeof N == 'string'
            ? ((J = N), (N = 0), (j = this.length))
            : typeof j == 'string' && ((J = j), (j = this.length)),
          J !== void 0 && typeof J != 'string')
        )
          throw new TypeError('encoding must be a string');
        if (typeof J == 'string' && !p.isEncoding(J)) throw new TypeError('Unknown encoding: ' + J);
        if (x.length === 1) {
          const ie = x.charCodeAt(0);
          ((J === 'utf8' && ie < 128) || J === 'latin1') && (x = ie);
        }
      } else typeof x == 'number' ? (x = x & 255) : typeof x == 'boolean' && (x = Number(x));
      if (N < 0 || this.length < N || this.length < j) throw new RangeError('Out of range index');
      if (j <= N) return this;
      (N = N >>> 0), (j = j === void 0 ? this.length : j >>> 0), x || (x = 0);
      let de;
      if (typeof x == 'number') for (de = N; de < j; ++de) this[de] = x;
      else {
        const ie = p.isBuffer(x) ? x : p.from(x, J),
          ye = ie.length;
        if (ye === 0) throw new TypeError('The value "' + x + '" is invalid for argument "value"');
        for (de = 0; de < j - N; ++de) this[de + N] = ie[de % ye];
      }
      return this;
    });
  const U = {};
  function $(T, x, N) {
    U[T] = class extends N {
      constructor() {
        super(),
          Object.defineProperty(this, 'message', {
            value: x.apply(this, arguments),
            writable: !0,
            configurable: !0,
          }),
          (this.name = `${this.name} [${T}]`),
          this.stack,
          delete this.name;
      }
      get code() {
        return T;
      }
      set code(J) {
        Object.defineProperty(this, 'code', {
          configurable: !0,
          enumerable: !0,
          value: J,
          writable: !0,
        });
      }
      toString() {
        return `${this.name} [${T}]: ${this.message}`;
      }
    };
  }
  $(
    'ERR_BUFFER_OUT_OF_BOUNDS',
    function (T) {
      return T
        ? `${T} is outside of buffer bounds`
        : 'Attempt to access memory outside buffer bounds';
    },
    RangeError
  ),
    $(
      'ERR_INVALID_ARG_TYPE',
      function (T, x) {
        return `The "${T}" argument must be of type number. Received type ${typeof x}`;
      },
      TypeError
    ),
    $(
      'ERR_OUT_OF_RANGE',
      function (T, x, N) {
        let j = `The value of "${T}" is out of range.`,
          J = N;
        return (
          Number.isInteger(N) && Math.abs(N) > 2 ** 32
            ? (J = Z(String(N)))
            : typeof N == 'bigint' &&
              ((J = String(N)),
              (N > BigInt(2) ** BigInt(32) || N < -(BigInt(2) ** BigInt(32))) && (J = Z(J)),
              (J += 'n')),
          (j += ` It must be ${x}. Received ${J}`),
          j
        );
      },
      RangeError
    );
  function Z(T) {
    let x = '',
      N = T.length;
    const j = T[0] === '-' ? 1 : 0;
    for (; N >= j + 4; N -= 3) x = `_${T.slice(N - 3, N)}${x}`;
    return `${T.slice(0, N)}${x}`;
  }
  function ae(T, x, N) {
    le(x, 'offset'), (T[x] === void 0 || T[x + N] === void 0) && Fe(x, T.length - (N + 1));
  }
  function fe(T, x, N, j, J, de) {
    if (T > N || T < x) {
      const ie = typeof x == 'bigint' ? 'n' : '';
      let ye;
      throw (
        (de > 3
          ? x === 0 || x === BigInt(0)
            ? (ye = `>= 0${ie} and < 2${ie} ** ${(de + 1) * 8}${ie}`)
            : (ye = `>= -(2${ie} ** ${(de + 1) * 8 - 1}${ie}) and < 2 ** ${(de + 1) * 8 - 1}${ie}`)
          : (ye = `>= ${x}${ie} and <= ${N}${ie}`),
        new U.ERR_OUT_OF_RANGE('value', ye, T))
      );
    }
    ae(j, J, de);
  }
  function le(T, x) {
    if (typeof T != 'number') throw new U.ERR_INVALID_ARG_TYPE(x, 'number', T);
  }
  function Fe(T, x, N) {
    throw Math.floor(T) !== T
      ? (le(T, N), new U.ERR_OUT_OF_RANGE(N || 'offset', 'an integer', T))
      : x < 0
        ? new U.ERR_BUFFER_OUT_OF_BOUNDS()
        : new U.ERR_OUT_OF_RANGE(N || 'offset', `>= ${N ? 1 : 0} and <= ${x}`, T);
  }
  const be = /[^+/0-9A-Za-z-_]/g;
  function oe(T) {
    if (((T = T.split('=')[0]), (T = T.trim().replace(be, '')), T.length < 2)) return '';
    for (; T.length % 4 !== 0; ) T = T + '=';
    return T;
  }
  function rt(T, x) {
    x = x || 1 / 0;
    let N;
    const j = T.length;
    let J = null;
    const de = [];
    for (let ie = 0; ie < j; ++ie) {
      if (((N = T.charCodeAt(ie)), N > 55295 && N < 57344)) {
        if (!J) {
          if (N > 56319) {
            (x -= 3) > -1 && de.push(239, 191, 189);
            continue;
          } else if (ie + 1 === j) {
            (x -= 3) > -1 && de.push(239, 191, 189);
            continue;
          }
          J = N;
          continue;
        }
        if (N < 56320) {
          (x -= 3) > -1 && de.push(239, 191, 189), (J = N);
          continue;
        }
        N = (((J - 55296) << 10) | (N - 56320)) + 65536;
      } else J && (x -= 3) > -1 && de.push(239, 191, 189);
      if (((J = null), N < 128)) {
        if ((x -= 1) < 0) break;
        de.push(N);
      } else if (N < 2048) {
        if ((x -= 2) < 0) break;
        de.push((N >> 6) | 192, (N & 63) | 128);
      } else if (N < 65536) {
        if ((x -= 3) < 0) break;
        de.push((N >> 12) | 224, ((N >> 6) & 63) | 128, (N & 63) | 128);
      } else if (N < 1114112) {
        if ((x -= 4) < 0) break;
        de.push((N >> 18) | 240, ((N >> 12) & 63) | 128, ((N >> 6) & 63) | 128, (N & 63) | 128);
      } else throw new Error('Invalid code point');
    }
    return de;
  }
  function me(T) {
    const x = [];
    for (let N = 0; N < T.length; ++N) x.push(T.charCodeAt(N) & 255);
    return x;
  }
  function re(T, x) {
    let N, j, J;
    const de = [];
    for (let ie = 0; ie < T.length && !((x -= 2) < 0); ++ie)
      (N = T.charCodeAt(ie)), (j = N >> 8), (J = N % 256), de.push(J), de.push(j);
    return de;
  }
  function ge(T) {
    return e.toByteArray(oe(T));
  }
  function ce(T, x, N, j) {
    let J;
    for (J = 0; J < j && !(J + N >= x.length || J >= T.length); ++J) x[J + N] = T[J];
    return J;
  }
  function he(T, x) {
    return (
      T instanceof x ||
      (T != null &&
        T.constructor != null &&
        T.constructor.name != null &&
        T.constructor.name === x.name)
    );
  }
  function Ke(T) {
    return T !== T;
  }
  const K = (function () {
    const T = '0123456789abcdef',
      x = new Array(256);
    for (let N = 0; N < 16; ++N) {
      const j = N * 16;
      for (let J = 0; J < 16; ++J) x[j + J] = T[N] + T[J];
    }
    return x;
  })();
  function O(T) {
    return typeof BigInt > 'u' ? W : T;
  }
  function W() {
    throw new Error('BigInt not supported');
  }
})(Kr);
const Ze = Kr.Buffer,
  D5 = Kr.Blob,
  U5 = Kr.BlobOptions,
  He = Kr.Buffer,
  z5 = Kr.File,
  F5 = Kr.FileOptions,
  q5 = Kr.INSPECT_MAX_BYTES,
  W5 = Kr.SlowBuffer,
  K5 = Kr.TranscodeEncoding,
  j5 = Kr.atob,
  H5 = Kr.btoa,
  V5 = Kr.constants,
  G5 = Kr.isAscii,
  Y5 = Kr.isUtf8,
  Z5 = Kr.kMaxLength,
  J5 = Kr.kStringMaxLength,
  X5 = Kr.resolveObjectURL,
  Q5 = Kr.transcode,
  eM = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Blob: D5,
        BlobOptions: U5,
        Buffer: He,
        File: z5,
        FileOptions: F5,
        INSPECT_MAX_BYTES: q5,
        SlowBuffer: W5,
        TranscodeEncoding: K5,
        atob: j5,
        btoa: H5,
        constants: V5,
        default: Ze,
        isAscii: G5,
        isUtf8: Y5,
        kMaxLength: Z5,
        kStringMaxLength: J5,
        resolveObjectURL: X5,
        transcode: Q5,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  ai = pn(eM);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ (function (
  i,
  e
) {
  var t = ai,
    r = t.Buffer;
  function s(c, f) {
    for (var h in c) f[h] = c[h];
  }
  r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow
    ? (i.exports = t)
    : (s(t, e), (e.Buffer = n));
  function n(c, f, h) {
    return r(c, f, h);
  }
  (n.prototype = Object.create(r.prototype)),
    s(r, n),
    (n.from = function (c, f, h) {
      if (typeof c == 'number') throw new TypeError('Argument must not be a number');
      return r(c, f, h);
    }),
    (n.alloc = function (c, f, h) {
      if (typeof c != 'number') throw new TypeError('Argument must be a number');
      var y = r(c);
      return f !== void 0 ? (typeof h == 'string' ? y.fill(f, h) : y.fill(f)) : y.fill(0), y;
    }),
    (n.allocUnsafe = function (c) {
      if (typeof c != 'number') throw new TypeError('Argument must be a number');
      return r(c);
    }),
    (n.allocUnsafeSlow = function (c) {
      if (typeof c != 'number') throw new TypeError('Argument must be a number');
      return t.SlowBuffer(c);
    });
})(Wp, Wp.exports);
var At = Wp.exports,
  kg;
function Ua() {
  if (kg) return qc.exports;
  kg = 1;
  var i = 65536,
    e = 4294967295;
  function t() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var r = At.Buffer,
    s = globalThis.crypto || globalThis.msCrypto;
  s && s.getRandomValues ? (qc.exports = n) : (qc.exports = t);
  function n(c, f) {
    if (c > e) throw new RangeError('requested too many random bytes');
    var h = r.allocUnsafe(c);
    if (c > 0)
      if (c > i) for (var y = 0; y < c; y += i) s.getRandomValues(h.slice(y, y + i));
      else s.getRandomValues(h);
    return typeof f == 'function'
      ? Je.nextTick(function () {
          f(null, h);
        })
      : h;
  }
  return qc.exports;
}
var Kp = { exports: {} };
typeof Object.create == 'function'
  ? (Kp.exports = function (e, t) {
      t &&
        ((e.super_ = t),
        (e.prototype = Object.create(t.prototype, {
          constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 },
        })));
    })
  : (Kp.exports = function (e, t) {
      if (t) {
        e.super_ = t;
        var r = function () {};
        (r.prototype = t.prototype), (e.prototype = new r()), (e.prototype.constructor = e);
      }
    });
var dt = Kp.exports,
  jp = { exports: {} },
  W1 = { exports: {} },
  aa = typeof Reflect == 'object' ? Reflect : null,
  Ig =
    aa && typeof aa.apply == 'function'
      ? aa.apply
      : function (e, t, r) {
          return Function.prototype.apply.call(e, t, r);
        },
  pf;
aa && typeof aa.ownKeys == 'function'
  ? (pf = aa.ownKeys)
  : Object.getOwnPropertySymbols
    ? (pf = function (e) {
        return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
      })
    : (pf = function (e) {
        return Object.getOwnPropertyNames(e);
      });
function tM(i) {
  console && console.warn && console.warn(i);
}
var N2 =
  Number.isNaN ||
  function (e) {
    return e !== e;
  };
function sr() {
  sr.init.call(this);
}
W1.exports = sr;
W1.exports.once = oM;
sr.EventEmitter = sr;
sr.prototype._events = void 0;
sr.prototype._eventsCount = 0;
sr.prototype._maxListeners = void 0;
var xg = 10;
function bl(i) {
  if (typeof i != 'function')
    throw new TypeError(
      'The "listener" argument must be of type Function. Received type ' + typeof i
    );
}
Object.defineProperty(sr, 'defaultMaxListeners', {
  enumerable: !0,
  get: function () {
    return xg;
  },
  set: function (i) {
    if (typeof i != 'number' || i < 0 || N2(i))
      throw new RangeError(
        'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
          i +
          '.'
      );
    xg = i;
  },
});
sr.init = function () {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) &&
    ((this._events = Object.create(null)), (this._eventsCount = 0)),
    (this._maxListeners = this._maxListeners || void 0);
};
sr.prototype.setMaxListeners = function (e) {
  if (typeof e != 'number' || e < 0 || N2(e))
    throw new RangeError(
      'The value of "n" is out of range. It must be a non-negative number. Received ' + e + '.'
    );
  return (this._maxListeners = e), this;
};
function $2(i) {
  return i._maxListeners === void 0 ? sr.defaultMaxListeners : i._maxListeners;
}
sr.prototype.getMaxListeners = function () {
  return $2(this);
};
sr.prototype.emit = function (e) {
  for (var t = [], r = 1; r < arguments.length; r++) t.push(arguments[r]);
  var s = e === 'error',
    n = this._events;
  if (n !== void 0) s = s && n.error === void 0;
  else if (!s) return !1;
  if (s) {
    var c;
    if ((t.length > 0 && (c = t[0]), c instanceof Error)) throw c;
    var f = new Error('Unhandled error.' + (c ? ' (' + c.message + ')' : ''));
    throw ((f.context = c), f);
  }
  var h = n[e];
  if (h === void 0) return !1;
  if (typeof h == 'function') Ig(h, this, t);
  else for (var y = h.length, p = q2(h, y), r = 0; r < y; ++r) Ig(p[r], this, t);
  return !0;
};
function D2(i, e, t, r) {
  var s, n, c;
  if (
    (bl(t),
    (n = i._events),
    n === void 0
      ? ((n = i._events = Object.create(null)), (i._eventsCount = 0))
      : (n.newListener !== void 0 &&
          (i.emit('newListener', e, t.listener ? t.listener : t), (n = i._events)),
        (c = n[e])),
    c === void 0)
  )
    (c = n[e] = t), ++i._eventsCount;
  else if (
    (typeof c == 'function' ? (c = n[e] = r ? [t, c] : [c, t]) : r ? c.unshift(t) : c.push(t),
    (s = $2(i)),
    s > 0 && c.length > s && !c.warned)
  ) {
    c.warned = !0;
    var f = new Error(
      'Possible EventEmitter memory leak detected. ' +
        c.length +
        ' ' +
        String(e) +
        ' listeners added. Use emitter.setMaxListeners() to increase limit'
    );
    (f.name = 'MaxListenersExceededWarning'),
      (f.emitter = i),
      (f.type = e),
      (f.count = c.length),
      tM(f);
  }
  return i;
}
sr.prototype.addListener = function (e, t) {
  return D2(this, e, t, !1);
};
sr.prototype.on = sr.prototype.addListener;
sr.prototype.prependListener = function (e, t) {
  return D2(this, e, t, !0);
};
function rM() {
  if (!this.fired)
    return (
      this.target.removeListener(this.type, this.wrapFn),
      (this.fired = !0),
      arguments.length === 0
        ? this.listener.call(this.target)
        : this.listener.apply(this.target, arguments)
    );
}
function U2(i, e, t) {
  var r = { fired: !1, wrapFn: void 0, target: i, type: e, listener: t },
    s = rM.bind(r);
  return (s.listener = t), (r.wrapFn = s), s;
}
sr.prototype.once = function (e, t) {
  return bl(t), this.on(e, U2(this, e, t)), this;
};
sr.prototype.prependOnceListener = function (e, t) {
  return bl(t), this.prependListener(e, U2(this, e, t)), this;
};
sr.prototype.removeListener = function (e, t) {
  var r, s, n, c, f;
  if ((bl(t), (s = this._events), s === void 0)) return this;
  if (((r = s[e]), r === void 0)) return this;
  if (r === t || r.listener === t)
    --this._eventsCount === 0
      ? (this._events = Object.create(null))
      : (delete s[e], s.removeListener && this.emit('removeListener', e, r.listener || t));
  else if (typeof r != 'function') {
    for (n = -1, c = r.length - 1; c >= 0; c--)
      if (r[c] === t || r[c].listener === t) {
        (f = r[c].listener), (n = c);
        break;
      }
    if (n < 0) return this;
    n === 0 ? r.shift() : iM(r, n),
      r.length === 1 && (s[e] = r[0]),
      s.removeListener !== void 0 && this.emit('removeListener', e, f || t);
  }
  return this;
};
sr.prototype.off = sr.prototype.removeListener;
sr.prototype.removeAllListeners = function (e) {
  var t, r, s;
  if (((r = this._events), r === void 0)) return this;
  if (r.removeListener === void 0)
    return (
      arguments.length === 0
        ? ((this._events = Object.create(null)), (this._eventsCount = 0))
        : r[e] !== void 0 &&
          (--this._eventsCount === 0 ? (this._events = Object.create(null)) : delete r[e]),
      this
    );
  if (arguments.length === 0) {
    var n = Object.keys(r),
      c;
    for (s = 0; s < n.length; ++s) (c = n[s]), c !== 'removeListener' && this.removeAllListeners(c);
    return (
      this.removeAllListeners('removeListener'),
      (this._events = Object.create(null)),
      (this._eventsCount = 0),
      this
    );
  }
  if (((t = r[e]), typeof t == 'function')) this.removeListener(e, t);
  else if (t !== void 0) for (s = t.length - 1; s >= 0; s--) this.removeListener(e, t[s]);
  return this;
};
function z2(i, e, t) {
  var r = i._events;
  if (r === void 0) return [];
  var s = r[e];
  return s === void 0
    ? []
    : typeof s == 'function'
      ? t
        ? [s.listener || s]
        : [s]
      : t
        ? nM(s)
        : q2(s, s.length);
}
sr.prototype.listeners = function (e) {
  return z2(this, e, !0);
};
sr.prototype.rawListeners = function (e) {
  return z2(this, e, !1);
};
sr.listenerCount = function (i, e) {
  return typeof i.listenerCount == 'function' ? i.listenerCount(e) : F2.call(i, e);
};
sr.prototype.listenerCount = F2;
function F2(i) {
  var e = this._events;
  if (e !== void 0) {
    var t = e[i];
    if (typeof t == 'function') return 1;
    if (t !== void 0) return t.length;
  }
  return 0;
}
sr.prototype.eventNames = function () {
  return this._eventsCount > 0 ? pf(this._events) : [];
};
function q2(i, e) {
  for (var t = new Array(e), r = 0; r < e; ++r) t[r] = i[r];
  return t;
}
function iM(i, e) {
  for (; e + 1 < i.length; e++) i[e] = i[e + 1];
  i.pop();
}
function nM(i) {
  for (var e = new Array(i.length), t = 0; t < e.length; ++t) e[t] = i[t].listener || i[t];
  return e;
}
function oM(i, e) {
  return new Promise(function (t, r) {
    function s(c) {
      i.removeListener(e, n), r(c);
    }
    function n() {
      typeof i.removeListener == 'function' && i.removeListener('error', s),
        t([].slice.call(arguments));
    }
    W2(i, e, n, { once: !0 }), e !== 'error' && sM(i, s, { once: !0 });
  });
}
function sM(i, e, t) {
  typeof i.on == 'function' && W2(i, 'error', e, t);
}
function W2(i, e, t, r) {
  if (typeof i.on == 'function') r.once ? i.once(e, t) : i.on(e, t);
  else if (typeof i.addEventListener == 'function')
    i.addEventListener(e, function s(n) {
      r.once && i.removeEventListener(e, s), t(n);
    });
  else
    throw new TypeError(
      'The "emitter" argument must be of type EventEmitter. Received type ' + typeof i
    );
}
var za = W1.exports;
const RU = zn(za);
var K2 = za.EventEmitter,
  Cn = {},
  j2 = {},
  H2 = function () {
    if (typeof Symbol != 'function' || typeof Object.getOwnPropertySymbols != 'function') return !1;
    if (typeof Symbol.iterator == 'symbol') return !0;
    var e = {},
      t = Symbol('test'),
      r = Object(t);
    if (
      typeof t == 'string' ||
      Object.prototype.toString.call(t) !== '[object Symbol]' ||
      Object.prototype.toString.call(r) !== '[object Symbol]'
    )
      return !1;
    var s = 42;
    e[t] = s;
    for (t in e) return !1;
    if (
      (typeof Object.keys == 'function' && Object.keys(e).length !== 0) ||
      (typeof Object.getOwnPropertyNames == 'function' &&
        Object.getOwnPropertyNames(e).length !== 0)
    )
      return !1;
    var n = Object.getOwnPropertySymbols(e);
    if (n.length !== 1 || n[0] !== t || !Object.prototype.propertyIsEnumerable.call(e, t))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == 'function') {
      var c = Object.getOwnPropertyDescriptor(e, t);
      if (c.value !== s || c.enumerable !== !0) return !1;
    }
    return !0;
  },
  Eh,
  Bg;
function vl() {
  if (Bg) return Eh;
  Bg = 1;
  var i = H2;
  return (
    (Eh = function () {
      return i() && !!Symbol.toStringTag;
    }),
    Eh
  );
}
var Rg = typeof Symbol < 'u' && Symbol,
  aM = H2,
  ml = function () {
    return typeof Rg != 'function' ||
      typeof Symbol != 'function' ||
      typeof Rg('foo') != 'symbol' ||
      typeof Symbol('bar') != 'symbol'
      ? !1
      : aM();
  },
  uM = 'Function.prototype.bind called on incompatible ',
  kh = Array.prototype.slice,
  cM = Object.prototype.toString,
  fM = '[object Function]',
  lM = function (e) {
    var t = this;
    if (typeof t != 'function' || cM.call(t) !== fM) throw new TypeError(uM + t);
    for (
      var r = kh.call(arguments, 1),
        s,
        n = function () {
          if (this instanceof s) {
            var p = t.apply(this, r.concat(kh.call(arguments)));
            return Object(p) === p ? p : this;
          } else return t.apply(e, r.concat(kh.call(arguments)));
        },
        c = Math.max(0, t.length - r.length),
        f = [],
        h = 0;
      h < c;
      h++
    )
      f.push('$' + h);
    if (
      ((s = Function(
        'binder',
        'return function (' + f.join(',') + '){ return binder.apply(this,arguments); }'
      )(n)),
      t.prototype)
    ) {
      var y = function () {};
      (y.prototype = t.prototype), (s.prototype = new y()), (y.prototype = null);
    }
    return s;
  },
  hM = lM,
  dM = Function.prototype.bind || hM,
  pM = 'Function.prototype.bind called on incompatible ',
  Ih = Array.prototype.slice,
  yM = Object.prototype.toString,
  gM = '[object Function]',
  bM = function (e) {
    var t = this;
    if (typeof t != 'function' || yM.call(t) !== gM) throw new TypeError(pM + t);
    for (
      var r = Ih.call(arguments, 1),
        s,
        n = function () {
          if (this instanceof s) {
            var p = t.apply(this, r.concat(Ih.call(arguments)));
            return Object(p) === p ? p : this;
          } else return t.apply(e, r.concat(Ih.call(arguments)));
        },
        c = Math.max(0, t.length - r.length),
        f = [],
        h = 0;
      h < c;
      h++
    )
      f.push('$' + h);
    if (
      ((s = Function(
        'binder',
        'return function (' + f.join(',') + '){ return binder.apply(this,arguments); }'
      )(n)),
      t.prototype)
    ) {
      var y = function () {};
      (y.prototype = t.prototype), (s.prototype = new y()), (y.prototype = null);
    }
    return s;
  },
  vM = bM,
  mM = Function.prototype.bind || vM,
  wM = mM,
  wl = wM.call(Function.call, Object.prototype.hasOwnProperty),
  Ct,
  ba = SyntaxError,
  V2 = Function,
  ua = TypeError,
  xh = function (i) {
    try {
      return V2('"use strict"; return (' + i + ').constructor;')();
    } catch {}
  },
  os = Object.getOwnPropertyDescriptor;
if (os)
  try {
    os({}, '');
  } catch {
    os = null;
  }
var Bh = function () {
    throw new ua();
  },
  _M = os
    ? (function () {
        try {
          return arguments.callee, Bh;
        } catch {
          try {
            return os(arguments, 'callee').get;
          } catch {
            return Bh;
          }
        }
      })()
    : Bh,
  Us = ml(),
  So =
    Object.getPrototypeOf ||
    function (i) {
      return i.__proto__;
    },
  Gs = {},
  SM = typeof Uint8Array > 'u' ? Ct : So(Uint8Array),
  ca = {
    '%AggregateError%': typeof AggregateError > 'u' ? Ct : AggregateError,
    '%Array%': Array,
    '%ArrayBuffer%': typeof ArrayBuffer > 'u' ? Ct : ArrayBuffer,
    '%ArrayIteratorPrototype%': Us ? So([][Symbol.iterator]()) : Ct,
    '%AsyncFromSyncIteratorPrototype%': Ct,
    '%AsyncFunction%': Gs,
    '%AsyncGenerator%': Gs,
    '%AsyncGeneratorFunction%': Gs,
    '%AsyncIteratorPrototype%': Gs,
    '%Atomics%': typeof Atomics > 'u' ? Ct : Atomics,
    '%BigInt%': typeof BigInt > 'u' ? Ct : BigInt,
    '%Boolean%': Boolean,
    '%DataView%': typeof DataView > 'u' ? Ct : DataView,
    '%Date%': Date,
    '%decodeURI%': decodeURI,
    '%decodeURIComponent%': decodeURIComponent,
    '%encodeURI%': encodeURI,
    '%encodeURIComponent%': encodeURIComponent,
    '%Error%': Error,
    '%eval%': eval,
    '%EvalError%': EvalError,
    '%Float32Array%': typeof Float32Array > 'u' ? Ct : Float32Array,
    '%Float64Array%': typeof Float64Array > 'u' ? Ct : Float64Array,
    '%FinalizationRegistry%': typeof FinalizationRegistry > 'u' ? Ct : FinalizationRegistry,
    '%Function%': V2,
    '%GeneratorFunction%': Gs,
    '%Int8Array%': typeof Int8Array > 'u' ? Ct : Int8Array,
    '%Int16Array%': typeof Int16Array > 'u' ? Ct : Int16Array,
    '%Int32Array%': typeof Int32Array > 'u' ? Ct : Int32Array,
    '%isFinite%': isFinite,
    '%isNaN%': isNaN,
    '%IteratorPrototype%': Us ? So(So([][Symbol.iterator]())) : Ct,
    '%JSON%': typeof JSON == 'object' ? JSON : Ct,
    '%Map%': typeof Map > 'u' ? Ct : Map,
    '%MapIteratorPrototype%': typeof Map > 'u' || !Us ? Ct : So(new Map()[Symbol.iterator]()),
    '%Math%': Math,
    '%Number%': Number,
    '%Object%': Object,
    '%parseFloat%': parseFloat,
    '%parseInt%': parseInt,
    '%Promise%': typeof Promise > 'u' ? Ct : Promise,
    '%Proxy%': typeof Proxy > 'u' ? Ct : Proxy,
    '%RangeError%': RangeError,
    '%ReferenceError%': ReferenceError,
    '%Reflect%': typeof Reflect > 'u' ? Ct : Reflect,
    '%RegExp%': RegExp,
    '%Set%': typeof Set > 'u' ? Ct : Set,
    '%SetIteratorPrototype%': typeof Set > 'u' || !Us ? Ct : So(new Set()[Symbol.iterator]()),
    '%SharedArrayBuffer%': typeof SharedArrayBuffer > 'u' ? Ct : SharedArrayBuffer,
    '%String%': String,
    '%StringIteratorPrototype%': Us ? So(''[Symbol.iterator]()) : Ct,
    '%Symbol%': Us ? Symbol : Ct,
    '%SyntaxError%': ba,
    '%ThrowTypeError%': _M,
    '%TypedArray%': SM,
    '%TypeError%': ua,
    '%Uint8Array%': typeof Uint8Array > 'u' ? Ct : Uint8Array,
    '%Uint8ClampedArray%': typeof Uint8ClampedArray > 'u' ? Ct : Uint8ClampedArray,
    '%Uint16Array%': typeof Uint16Array > 'u' ? Ct : Uint16Array,
    '%Uint32Array%': typeof Uint32Array > 'u' ? Ct : Uint32Array,
    '%URIError%': URIError,
    '%WeakMap%': typeof WeakMap > 'u' ? Ct : WeakMap,
    '%WeakRef%': typeof WeakRef > 'u' ? Ct : WeakRef,
    '%WeakSet%': typeof WeakSet > 'u' ? Ct : WeakSet,
  },
  MM = function i(e) {
    var t;
    if (e === '%AsyncFunction%') t = xh('async function () {}');
    else if (e === '%GeneratorFunction%') t = xh('function* () {}');
    else if (e === '%AsyncGeneratorFunction%') t = xh('async function* () {}');
    else if (e === '%AsyncGenerator%') {
      var r = i('%AsyncGeneratorFunction%');
      r && (t = r.prototype);
    } else if (e === '%AsyncIteratorPrototype%') {
      var s = i('%AsyncGenerator%');
      s && (t = So(s.prototype));
    }
    return (ca[e] = t), t;
  },
  Pg = {
    '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
    '%ArrayPrototype%': ['Array', 'prototype'],
    '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
    '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
    '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
    '%ArrayProto_values%': ['Array', 'prototype', 'values'],
    '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
    '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
    '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
    '%BooleanPrototype%': ['Boolean', 'prototype'],
    '%DataViewPrototype%': ['DataView', 'prototype'],
    '%DatePrototype%': ['Date', 'prototype'],
    '%ErrorPrototype%': ['Error', 'prototype'],
    '%EvalErrorPrototype%': ['EvalError', 'prototype'],
    '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
    '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
    '%FunctionPrototype%': ['Function', 'prototype'],
    '%Generator%': ['GeneratorFunction', 'prototype'],
    '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
    '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
    '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
    '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
    '%JSONParse%': ['JSON', 'parse'],
    '%JSONStringify%': ['JSON', 'stringify'],
    '%MapPrototype%': ['Map', 'prototype'],
    '%NumberPrototype%': ['Number', 'prototype'],
    '%ObjectPrototype%': ['Object', 'prototype'],
    '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
    '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
    '%PromisePrototype%': ['Promise', 'prototype'],
    '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
    '%Promise_all%': ['Promise', 'all'],
    '%Promise_reject%': ['Promise', 'reject'],
    '%Promise_resolve%': ['Promise', 'resolve'],
    '%RangeErrorPrototype%': ['RangeError', 'prototype'],
    '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
    '%RegExpPrototype%': ['RegExp', 'prototype'],
    '%SetPrototype%': ['Set', 'prototype'],
    '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
    '%StringPrototype%': ['String', 'prototype'],
    '%SymbolPrototype%': ['Symbol', 'prototype'],
    '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
    '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
    '%TypeErrorPrototype%': ['TypeError', 'prototype'],
    '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
    '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
    '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
    '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
    '%URIErrorPrototype%': ['URIError', 'prototype'],
    '%WeakMapPrototype%': ['WeakMap', 'prototype'],
    '%WeakSetPrototype%': ['WeakSet', 'prototype'],
  },
  Hu = dM,
  Lf = wl,
  AM = Hu.call(Function.call, Array.prototype.concat),
  EM = Hu.call(Function.apply, Array.prototype.splice),
  Tg = Hu.call(Function.call, String.prototype.replace),
  Nf = Hu.call(Function.call, String.prototype.slice),
  kM = Hu.call(Function.call, RegExp.prototype.exec),
  IM =
    /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
  xM = /\\(\\)?/g,
  BM = function (e) {
    var t = Nf(e, 0, 1),
      r = Nf(e, -1);
    if (t === '%' && r !== '%') throw new ba('invalid intrinsic syntax, expected closing `%`');
    if (r === '%' && t !== '%') throw new ba('invalid intrinsic syntax, expected opening `%`');
    var s = [];
    return (
      Tg(e, IM, function (n, c, f, h) {
        s[s.length] = f ? Tg(h, xM, '$1') : c || n;
      }),
      s
    );
  },
  RM = function (e, t) {
    var r = e,
      s;
    if ((Lf(Pg, r) && ((s = Pg[r]), (r = '%' + s[0] + '%')), Lf(ca, r))) {
      var n = ca[r];
      if ((n === Gs && (n = MM(r)), typeof n > 'u' && !t))
        throw new ua('intrinsic ' + e + ' exists, but is not available. Please file an issue!');
      return { alias: s, name: r, value: n };
    }
    throw new ba('intrinsic ' + e + ' does not exist!');
  },
  _l = function (e, t) {
    if (typeof e != 'string' || e.length === 0)
      throw new ua('intrinsic name must be a non-empty string');
    if (arguments.length > 1 && typeof t != 'boolean')
      throw new ua('"allowMissing" argument must be a boolean');
    if (kM(/^%?[^%]*%?$/, e) === null)
      throw new ba(
        '`%` may not be present anywhere but at the beginning and end of the intrinsic name'
      );
    var r = BM(e),
      s = r.length > 0 ? r[0] : '',
      n = RM('%' + s + '%', t),
      c = n.name,
      f = n.value,
      h = !1,
      y = n.alias;
    y && ((s = y[0]), EM(r, AM([0, 1], y)));
    for (var p = 1, m = !0; p < r.length; p += 1) {
      var _ = r[p],
        A = Nf(_, 0, 1),
        E = Nf(_, -1);
      if ((A === '"' || A === "'" || A === '`' || E === '"' || E === "'" || E === '`') && A !== E)
        throw new ba('property names with quotes must have matching quotes');
      if (((_ === 'constructor' || !m) && (h = !0), (s += '.' + _), (c = '%' + s + '%'), Lf(ca, c)))
        f = ca[c];
      else if (f != null) {
        if (!(_ in f)) {
          if (!t)
            throw new ua('base intrinsic for ' + e + ' exists, but the property is not available.');
          return;
        }
        if (os && p + 1 >= r.length) {
          var I = os(f, _);
          (m = !!I), m && 'get' in I && !('originalValue' in I.get) ? (f = I.get) : (f = f[_]);
        } else (m = Lf(f, _)), (f = f[_]);
        m && !h && (ca[c] = f);
      }
    }
    return f;
  },
  G2 = { exports: {} },
  PM = 'Function.prototype.bind called on incompatible ',
  Rh = Array.prototype.slice,
  TM = Object.prototype.toString,
  OM = '[object Function]',
  CM = function (e) {
    var t = this;
    if (typeof t != 'function' || TM.call(t) !== OM) throw new TypeError(PM + t);
    for (
      var r = Rh.call(arguments, 1),
        s,
        n = function () {
          if (this instanceof s) {
            var p = t.apply(this, r.concat(Rh.call(arguments)));
            return Object(p) === p ? p : this;
          } else return t.apply(e, r.concat(Rh.call(arguments)));
        },
        c = Math.max(0, t.length - r.length),
        f = [],
        h = 0;
      h < c;
      h++
    )
      f.push('$' + h);
    if (
      ((s = Function(
        'binder',
        'return function (' + f.join(',') + '){ return binder.apply(this,arguments); }'
      )(n)),
      t.prototype)
    ) {
      var y = function () {};
      (y.prototype = t.prototype), (s.prototype = new y()), (y.prototype = null);
    }
    return s;
  },
  LM = CM,
  NM = Function.prototype.bind || LM;
(function (i) {
  var e = NM,
    t = _l,
    r = t('%Function.prototype.apply%'),
    s = t('%Function.prototype.call%'),
    n = t('%Reflect.apply%', !0) || e.call(s, r),
    c = t('%Object.getOwnPropertyDescriptor%', !0),
    f = t('%Object.defineProperty%', !0),
    h = t('%Math.max%');
  if (f)
    try {
      f({}, 'a', { value: 1 });
    } catch {
      f = null;
    }
  i.exports = function (m) {
    var _ = n(e, s, arguments);
    if (c && f) {
      var A = c(_, 'length');
      A.configurable && f(_, 'length', { value: 1 + h(0, m.length - (arguments.length - 1)) });
    }
    return _;
  };
  var y = function () {
    return n(e, r, arguments);
  };
  f ? f(i.exports, 'apply', { value: y }) : (i.exports.apply = y);
})(G2);
var K1 = G2.exports,
  Ph,
  Og;
function Y2() {
  if (Og) return Ph;
  Og = 1;
  var i = _l,
    e = K1,
    t = e(i('String.prototype.indexOf'));
  return (
    (Ph = function (s, n) {
      var c = i(s, !!n);
      return typeof c == 'function' && t(s, '.prototype.') > -1 ? e(c) : c;
    }),
    Ph
  );
}
var Th, Cg;
function $M() {
  if (Cg) return Th;
  Cg = 1;
  var i = vl()(),
    e = Y2(),
    t = e('Object.prototype.toString'),
    r = function (f) {
      return i && f && typeof f == 'object' && Symbol.toStringTag in f
        ? !1
        : t(f) === '[object Arguments]';
    },
    s = function (f) {
      return r(f)
        ? !0
        : f !== null &&
            typeof f == 'object' &&
            typeof f.length == 'number' &&
            f.length >= 0 &&
            t(f) !== '[object Array]' &&
            t(f.callee) === '[object Function]';
    },
    n = (function () {
      return r(arguments);
    })();
  return (r.isLegacyArguments = s), (Th = n ? r : s), Th;
}
var DM = Object.prototype.toString,
  UM = Function.prototype.toString,
  zM = /^\s*(?:function)?\*/,
  Z2 = vl()(),
  Oh = Object.getPrototypeOf,
  FM = function () {
    if (!Z2) return !1;
    try {
      return Function('return function*() {}')();
    } catch {}
  },
  Ch,
  qM = function (e) {
    if (typeof e != 'function') return !1;
    if (zM.test(UM.call(e))) return !0;
    if (!Z2) {
      var t = DM.call(e);
      return t === '[object GeneratorFunction]';
    }
    if (!Oh) return !1;
    if (typeof Ch > 'u') {
      var r = FM();
      Ch = r ? Oh(r) : !1;
    }
    return Oh(e) === Ch;
  },
  Lh,
  Lg;
function WM() {
  if (Lg) return Lh;
  Lg = 1;
  var i = Function.prototype.toString,
    e = typeof Reflect == 'object' && Reflect !== null && Reflect.apply,
    t,
    r;
  if (typeof e == 'function' && typeof Object.defineProperty == 'function')
    try {
      (t = Object.defineProperty({}, 'length', {
        get: function () {
          throw r;
        },
      })),
        (r = {}),
        e(
          function () {
            throw 42;
          },
          null,
          t
        );
    } catch (D) {
      D !== r && (e = null);
    }
  else e = null;
  var s = /^\s*class\b/,
    n = function (q) {
      try {
        var H = i.call(q);
        return s.test(H);
      } catch {
        return !1;
      }
    },
    c = function (q) {
      try {
        return n(q) ? !1 : (i.call(q), !0);
      } catch {
        return !1;
      }
    },
    f = Object.prototype.toString,
    h = '[object Object]',
    y = '[object Function]',
    p = '[object GeneratorFunction]',
    m = '[object HTMLAllCollection]',
    _ = '[object HTML document.all class]',
    A = '[object HTMLCollection]',
    E = typeof Symbol == 'function' && !!Symbol.toStringTag,
    I = !(0 in [,]),
    R = function () {
      return !1;
    };
  if (typeof document == 'object') {
    var L = document.all;
    f.call(L) === f.call(document.all) &&
      (R = function (q) {
        if ((I || !q) && (typeof q > 'u' || typeof q == 'object'))
          try {
            var H = f.call(q);
            return (H === m || H === _ || H === A || H === h) && q('') == null;
          } catch {}
        return !1;
      });
  }
  return (
    (Lh = e
      ? function (q) {
          if (R(q)) return !0;
          if (!q || (typeof q != 'function' && typeof q != 'object')) return !1;
          try {
            e(q, null, t);
          } catch (H) {
            if (H !== r) return !1;
          }
          return !n(q) && c(q);
        }
      : function (q) {
          if (R(q)) return !0;
          if (!q || (typeof q != 'function' && typeof q != 'object')) return !1;
          if (E) return c(q);
          if (n(q)) return !1;
          var H = f.call(q);
          return H !== y && H !== p && !/^\[object HTML/.test(H) ? !1 : c(q);
        }),
    Lh
  );
}
var KM = WM(),
  jM = Object.prototype.toString,
  J2 = Object.prototype.hasOwnProperty,
  HM = function (e, t, r) {
    for (var s = 0, n = e.length; s < n; s++)
      J2.call(e, s) && (r == null ? t(e[s], s, e) : t.call(r, e[s], s, e));
  },
  VM = function (e, t, r) {
    for (var s = 0, n = e.length; s < n; s++)
      r == null ? t(e.charAt(s), s, e) : t.call(r, e.charAt(s), s, e);
  },
  GM = function (e, t, r) {
    for (var s in e) J2.call(e, s) && (r == null ? t(e[s], s, e) : t.call(r, e[s], s, e));
  },
  YM = function (e, t, r) {
    if (!KM(t)) throw new TypeError('iterator must be a function');
    var s;
    arguments.length >= 3 && (s = r),
      jM.call(e) === '[object Array]'
        ? HM(e, t, s)
        : typeof e == 'string'
          ? VM(e, t, s)
          : GM(e, t, s);
  },
  ZM = YM,
  Nh = [
    'BigInt64Array',
    'BigUint64Array',
    'Float32Array',
    'Float64Array',
    'Int16Array',
    'Int32Array',
    'Int8Array',
    'Uint16Array',
    'Uint32Array',
    'Uint8Array',
    'Uint8ClampedArray',
  ],
  JM = globalThis,
  X2 = function () {
    for (var e = [], t = 0; t < Nh.length; t++)
      typeof JM[Nh[t]] == 'function' && (e[e.length] = Nh[t]);
    return e;
  },
  Q2 = { exports: {} },
  XM = 'Function.prototype.bind called on incompatible ',
  QM = Object.prototype.toString,
  e7 = Math.max,
  t7 = '[object Function]',
  Ng = function (e, t) {
    for (var r = [], s = 0; s < e.length; s += 1) r[s] = e[s];
    for (var n = 0; n < t.length; n += 1) r[n + e.length] = t[n];
    return r;
  },
  r7 = function (e, t) {
    for (var r = [], s = t || 0, n = 0; s < e.length; s += 1, n += 1) r[n] = e[s];
    return r;
  },
  i7 = function (i, e) {
    for (var t = '', r = 0; r < i.length; r += 1) (t += i[r]), r + 1 < i.length && (t += e);
    return t;
  },
  n7 = function (e) {
    var t = this;
    if (typeof t != 'function' || QM.apply(t) !== t7) throw new TypeError(XM + t);
    for (
      var r = r7(arguments, 1),
        s,
        n = function () {
          if (this instanceof s) {
            var p = t.apply(this, Ng(r, arguments));
            return Object(p) === p ? p : this;
          }
          return t.apply(e, Ng(r, arguments));
        },
        c = e7(0, t.length - r.length),
        f = [],
        h = 0;
      h < c;
      h++
    )
      f[h] = '$' + h;
    if (
      ((s = Function(
        'binder',
        'return function (' + i7(f, ',') + '){ return binder.apply(this,arguments); }'
      )(n)),
      t.prototype)
    ) {
      var y = function () {};
      (y.prototype = t.prototype), (s.prototype = new y()), (y.prototype = null);
    }
    return s;
  },
  o7 = n7,
  s7 = Function.prototype.bind || o7,
  $g = { foo: {} },
  a7 = Object,
  j1 = function () {
    return { __proto__: $g }.foo === $g.foo && !({ __proto__: null } instanceof a7);
  },
  u7 = 'Function.prototype.bind called on incompatible ',
  $h = Array.prototype.slice,
  c7 = Object.prototype.toString,
  f7 = '[object Function]',
  l7 = function (e) {
    var t = this;
    if (typeof t != 'function' || c7.call(t) !== f7) throw new TypeError(u7 + t);
    for (
      var r = $h.call(arguments, 1),
        s,
        n = function () {
          if (this instanceof s) {
            var p = t.apply(this, r.concat($h.call(arguments)));
            return Object(p) === p ? p : this;
          } else return t.apply(e, r.concat($h.call(arguments)));
        },
        c = Math.max(0, t.length - r.length),
        f = [],
        h = 0;
      h < c;
      h++
    )
      f.push('$' + h);
    if (
      ((s = Function(
        'binder',
        'return function (' + f.join(',') + '){ return binder.apply(this,arguments); }'
      )(n)),
      t.prototype)
    ) {
      var y = function () {};
      (y.prototype = t.prototype), (s.prototype = new y()), (y.prototype = null);
    }
    return s;
  },
  h7 = l7,
  d7 = Function.prototype.bind || h7,
  Rt,
  va = SyntaxError,
  e6 = Function,
  fa = TypeError,
  Dh = function (i) {
    try {
      return e6('"use strict"; return (' + i + ').constructor;')();
    } catch {}
  },
  ss = Object.getOwnPropertyDescriptor;
if (ss)
  try {
    ss({}, '');
  } catch {
    ss = null;
  }
var Uh = function () {
    throw new fa();
  },
  p7 = ss
    ? (function () {
        try {
          return arguments.callee, Uh;
        } catch {
          try {
            return ss(arguments, 'callee').get;
          } catch {
            return Uh;
          }
        }
      })()
    : Uh,
  zs = ml(),
  y7 = j1(),
  Hr =
    Object.getPrototypeOf ||
    (y7
      ? function (i) {
          return i.__proto__;
        }
      : null),
  Ys = {},
  g7 = typeof Uint8Array > 'u' || !Hr ? Rt : Hr(Uint8Array),
  as = {
    '%AggregateError%': typeof AggregateError > 'u' ? Rt : AggregateError,
    '%Array%': Array,
    '%ArrayBuffer%': typeof ArrayBuffer > 'u' ? Rt : ArrayBuffer,
    '%ArrayIteratorPrototype%': zs && Hr ? Hr([][Symbol.iterator]()) : Rt,
    '%AsyncFromSyncIteratorPrototype%': Rt,
    '%AsyncFunction%': Ys,
    '%AsyncGenerator%': Ys,
    '%AsyncGeneratorFunction%': Ys,
    '%AsyncIteratorPrototype%': Ys,
    '%Atomics%': typeof Atomics > 'u' ? Rt : Atomics,
    '%BigInt%': typeof BigInt > 'u' ? Rt : BigInt,
    '%BigInt64Array%': typeof BigInt64Array > 'u' ? Rt : BigInt64Array,
    '%BigUint64Array%': typeof BigUint64Array > 'u' ? Rt : BigUint64Array,
    '%Boolean%': Boolean,
    '%DataView%': typeof DataView > 'u' ? Rt : DataView,
    '%Date%': Date,
    '%decodeURI%': decodeURI,
    '%decodeURIComponent%': decodeURIComponent,
    '%encodeURI%': encodeURI,
    '%encodeURIComponent%': encodeURIComponent,
    '%Error%': Error,
    '%eval%': eval,
    '%EvalError%': EvalError,
    '%Float32Array%': typeof Float32Array > 'u' ? Rt : Float32Array,
    '%Float64Array%': typeof Float64Array > 'u' ? Rt : Float64Array,
    '%FinalizationRegistry%': typeof FinalizationRegistry > 'u' ? Rt : FinalizationRegistry,
    '%Function%': e6,
    '%GeneratorFunction%': Ys,
    '%Int8Array%': typeof Int8Array > 'u' ? Rt : Int8Array,
    '%Int16Array%': typeof Int16Array > 'u' ? Rt : Int16Array,
    '%Int32Array%': typeof Int32Array > 'u' ? Rt : Int32Array,
    '%isFinite%': isFinite,
    '%isNaN%': isNaN,
    '%IteratorPrototype%': zs && Hr ? Hr(Hr([][Symbol.iterator]())) : Rt,
    '%JSON%': typeof JSON == 'object' ? JSON : Rt,
    '%Map%': typeof Map > 'u' ? Rt : Map,
    '%MapIteratorPrototype%':
      typeof Map > 'u' || !zs || !Hr ? Rt : Hr(new Map()[Symbol.iterator]()),
    '%Math%': Math,
    '%Number%': Number,
    '%Object%': Object,
    '%parseFloat%': parseFloat,
    '%parseInt%': parseInt,
    '%Promise%': typeof Promise > 'u' ? Rt : Promise,
    '%Proxy%': typeof Proxy > 'u' ? Rt : Proxy,
    '%RangeError%': RangeError,
    '%ReferenceError%': ReferenceError,
    '%Reflect%': typeof Reflect > 'u' ? Rt : Reflect,
    '%RegExp%': RegExp,
    '%Set%': typeof Set > 'u' ? Rt : Set,
    '%SetIteratorPrototype%':
      typeof Set > 'u' || !zs || !Hr ? Rt : Hr(new Set()[Symbol.iterator]()),
    '%SharedArrayBuffer%': typeof SharedArrayBuffer > 'u' ? Rt : SharedArrayBuffer,
    '%String%': String,
    '%StringIteratorPrototype%': zs && Hr ? Hr(''[Symbol.iterator]()) : Rt,
    '%Symbol%': zs ? Symbol : Rt,
    '%SyntaxError%': va,
    '%ThrowTypeError%': p7,
    '%TypedArray%': g7,
    '%TypeError%': fa,
    '%Uint8Array%': typeof Uint8Array > 'u' ? Rt : Uint8Array,
    '%Uint8ClampedArray%': typeof Uint8ClampedArray > 'u' ? Rt : Uint8ClampedArray,
    '%Uint16Array%': typeof Uint16Array > 'u' ? Rt : Uint16Array,
    '%Uint32Array%': typeof Uint32Array > 'u' ? Rt : Uint32Array,
    '%URIError%': URIError,
    '%WeakMap%': typeof WeakMap > 'u' ? Rt : WeakMap,
    '%WeakRef%': typeof WeakRef > 'u' ? Rt : WeakRef,
    '%WeakSet%': typeof WeakSet > 'u' ? Rt : WeakSet,
  };
if (Hr)
  try {
    null.error;
  } catch (i) {
    var b7 = Hr(Hr(i));
    as['%Error.prototype%'] = b7;
  }
var v7 = function i(e) {
    var t;
    if (e === '%AsyncFunction%') t = Dh('async function () {}');
    else if (e === '%GeneratorFunction%') t = Dh('function* () {}');
    else if (e === '%AsyncGeneratorFunction%') t = Dh('async function* () {}');
    else if (e === '%AsyncGenerator%') {
      var r = i('%AsyncGeneratorFunction%');
      r && (t = r.prototype);
    } else if (e === '%AsyncIteratorPrototype%') {
      var s = i('%AsyncGenerator%');
      s && Hr && (t = Hr(s.prototype));
    }
    return (as[e] = t), t;
  },
  Dg = {
    '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
    '%ArrayPrototype%': ['Array', 'prototype'],
    '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
    '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
    '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
    '%ArrayProto_values%': ['Array', 'prototype', 'values'],
    '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
    '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
    '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
    '%BooleanPrototype%': ['Boolean', 'prototype'],
    '%DataViewPrototype%': ['DataView', 'prototype'],
    '%DatePrototype%': ['Date', 'prototype'],
    '%ErrorPrototype%': ['Error', 'prototype'],
    '%EvalErrorPrototype%': ['EvalError', 'prototype'],
    '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
    '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
    '%FunctionPrototype%': ['Function', 'prototype'],
    '%Generator%': ['GeneratorFunction', 'prototype'],
    '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
    '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
    '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
    '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
    '%JSONParse%': ['JSON', 'parse'],
    '%JSONStringify%': ['JSON', 'stringify'],
    '%MapPrototype%': ['Map', 'prototype'],
    '%NumberPrototype%': ['Number', 'prototype'],
    '%ObjectPrototype%': ['Object', 'prototype'],
    '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
    '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
    '%PromisePrototype%': ['Promise', 'prototype'],
    '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
    '%Promise_all%': ['Promise', 'all'],
    '%Promise_reject%': ['Promise', 'reject'],
    '%Promise_resolve%': ['Promise', 'resolve'],
    '%RangeErrorPrototype%': ['RangeError', 'prototype'],
    '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
    '%RegExpPrototype%': ['RegExp', 'prototype'],
    '%SetPrototype%': ['Set', 'prototype'],
    '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
    '%StringPrototype%': ['String', 'prototype'],
    '%SymbolPrototype%': ['Symbol', 'prototype'],
    '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
    '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
    '%TypeErrorPrototype%': ['TypeError', 'prototype'],
    '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
    '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
    '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
    '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
    '%URIErrorPrototype%': ['URIError', 'prototype'],
    '%WeakMapPrototype%': ['WeakMap', 'prototype'],
    '%WeakSetPrototype%': ['WeakSet', 'prototype'],
  },
  Vu = d7,
  $f = wl,
  m7 = Vu.call(Function.call, Array.prototype.concat),
  w7 = Vu.call(Function.apply, Array.prototype.splice),
  Ug = Vu.call(Function.call, String.prototype.replace),
  Df = Vu.call(Function.call, String.prototype.slice),
  _7 = Vu.call(Function.call, RegExp.prototype.exec),
  S7 =
    /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
  M7 = /\\(\\)?/g,
  A7 = function (e) {
    var t = Df(e, 0, 1),
      r = Df(e, -1);
    if (t === '%' && r !== '%') throw new va('invalid intrinsic syntax, expected closing `%`');
    if (r === '%' && t !== '%') throw new va('invalid intrinsic syntax, expected opening `%`');
    var s = [];
    return (
      Ug(e, S7, function (n, c, f, h) {
        s[s.length] = f ? Ug(h, M7, '$1') : c || n;
      }),
      s
    );
  },
  E7 = function (e, t) {
    var r = e,
      s;
    if (($f(Dg, r) && ((s = Dg[r]), (r = '%' + s[0] + '%')), $f(as, r))) {
      var n = as[r];
      if ((n === Ys && (n = v7(r)), typeof n > 'u' && !t))
        throw new fa('intrinsic ' + e + ' exists, but is not available. Please file an issue!');
      return { alias: s, name: r, value: n };
    }
    throw new va('intrinsic ' + e + ' does not exist!');
  },
  t6 = function (e, t) {
    if (typeof e != 'string' || e.length === 0)
      throw new fa('intrinsic name must be a non-empty string');
    if (arguments.length > 1 && typeof t != 'boolean')
      throw new fa('"allowMissing" argument must be a boolean');
    if (_7(/^%?[^%]*%?$/, e) === null)
      throw new va(
        '`%` may not be present anywhere but at the beginning and end of the intrinsic name'
      );
    var r = A7(e),
      s = r.length > 0 ? r[0] : '',
      n = E7('%' + s + '%', t),
      c = n.name,
      f = n.value,
      h = !1,
      y = n.alias;
    y && ((s = y[0]), w7(r, m7([0, 1], y)));
    for (var p = 1, m = !0; p < r.length; p += 1) {
      var _ = r[p],
        A = Df(_, 0, 1),
        E = Df(_, -1);
      if ((A === '"' || A === "'" || A === '`' || E === '"' || E === "'" || E === '`') && A !== E)
        throw new va('property names with quotes must have matching quotes');
      if (((_ === 'constructor' || !m) && (h = !0), (s += '.' + _), (c = '%' + s + '%'), $f(as, c)))
        f = as[c];
      else if (f != null) {
        if (!(_ in f)) {
          if (!t)
            throw new fa('base intrinsic for ' + e + ' exists, but the property is not available.');
          return;
        }
        if (ss && p + 1 >= r.length) {
          var I = ss(f, _);
          (m = !!I), m && 'get' in I && !('originalValue' in I.get) ? (f = I.get) : (f = f[_]);
        } else (m = $f(f, _)), (f = f[_]);
        m && !h && (as[c] = f);
      }
    }
    return f;
  },
  k7 = 'Function.prototype.bind called on incompatible ',
  zh = Array.prototype.slice,
  I7 = Object.prototype.toString,
  x7 = '[object Function]',
  B7 = function (e) {
    var t = this;
    if (typeof t != 'function' || I7.call(t) !== x7) throw new TypeError(k7 + t);
    for (
      var r = zh.call(arguments, 1),
        s,
        n = function () {
          if (this instanceof s) {
            var p = t.apply(this, r.concat(zh.call(arguments)));
            return Object(p) === p ? p : this;
          } else return t.apply(e, r.concat(zh.call(arguments)));
        },
        c = Math.max(0, t.length - r.length),
        f = [],
        h = 0;
      h < c;
      h++
    )
      f.push('$' + h);
    if (
      ((s = Function(
        'binder',
        'return function (' + f.join(',') + '){ return binder.apply(this,arguments); }'
      )(n)),
      t.prototype)
    ) {
      var y = function () {};
      (y.prototype = t.prototype), (s.prototype = new y()), (y.prototype = null);
    }
    return s;
  },
  R7 = B7,
  P7 = Function.prototype.bind || R7,
  Pt,
  ma = SyntaxError,
  r6 = Function,
  la = TypeError,
  Fh = function (i) {
    try {
      return r6('"use strict"; return (' + i + ').constructor;')();
    } catch {}
  },
  us = Object.getOwnPropertyDescriptor;
if (us)
  try {
    us({}, '');
  } catch {
    us = null;
  }
var qh = function () {
    throw new la();
  },
  T7 = us
    ? (function () {
        try {
          return arguments.callee, qh;
        } catch {
          try {
            return us(arguments, 'callee').get;
          } catch {
            return qh;
          }
        }
      })()
    : qh,
  Fs = ml(),
  O7 = j1(),
  Vr =
    Object.getPrototypeOf ||
    (O7
      ? function (i) {
          return i.__proto__;
        }
      : null),
  Zs = {},
  C7 = typeof Uint8Array > 'u' || !Vr ? Pt : Vr(Uint8Array),
  cs = {
    '%AggregateError%': typeof AggregateError > 'u' ? Pt : AggregateError,
    '%Array%': Array,
    '%ArrayBuffer%': typeof ArrayBuffer > 'u' ? Pt : ArrayBuffer,
    '%ArrayIteratorPrototype%': Fs && Vr ? Vr([][Symbol.iterator]()) : Pt,
    '%AsyncFromSyncIteratorPrototype%': Pt,
    '%AsyncFunction%': Zs,
    '%AsyncGenerator%': Zs,
    '%AsyncGeneratorFunction%': Zs,
    '%AsyncIteratorPrototype%': Zs,
    '%Atomics%': typeof Atomics > 'u' ? Pt : Atomics,
    '%BigInt%': typeof BigInt > 'u' ? Pt : BigInt,
    '%BigInt64Array%': typeof BigInt64Array > 'u' ? Pt : BigInt64Array,
    '%BigUint64Array%': typeof BigUint64Array > 'u' ? Pt : BigUint64Array,
    '%Boolean%': Boolean,
    '%DataView%': typeof DataView > 'u' ? Pt : DataView,
    '%Date%': Date,
    '%decodeURI%': decodeURI,
    '%decodeURIComponent%': decodeURIComponent,
    '%encodeURI%': encodeURI,
    '%encodeURIComponent%': encodeURIComponent,
    '%Error%': Error,
    '%eval%': eval,
    '%EvalError%': EvalError,
    '%Float32Array%': typeof Float32Array > 'u' ? Pt : Float32Array,
    '%Float64Array%': typeof Float64Array > 'u' ? Pt : Float64Array,
    '%FinalizationRegistry%': typeof FinalizationRegistry > 'u' ? Pt : FinalizationRegistry,
    '%Function%': r6,
    '%GeneratorFunction%': Zs,
    '%Int8Array%': typeof Int8Array > 'u' ? Pt : Int8Array,
    '%Int16Array%': typeof Int16Array > 'u' ? Pt : Int16Array,
    '%Int32Array%': typeof Int32Array > 'u' ? Pt : Int32Array,
    '%isFinite%': isFinite,
    '%isNaN%': isNaN,
    '%IteratorPrototype%': Fs && Vr ? Vr(Vr([][Symbol.iterator]())) : Pt,
    '%JSON%': typeof JSON == 'object' ? JSON : Pt,
    '%Map%': typeof Map > 'u' ? Pt : Map,
    '%MapIteratorPrototype%':
      typeof Map > 'u' || !Fs || !Vr ? Pt : Vr(new Map()[Symbol.iterator]()),
    '%Math%': Math,
    '%Number%': Number,
    '%Object%': Object,
    '%parseFloat%': parseFloat,
    '%parseInt%': parseInt,
    '%Promise%': typeof Promise > 'u' ? Pt : Promise,
    '%Proxy%': typeof Proxy > 'u' ? Pt : Proxy,
    '%RangeError%': RangeError,
    '%ReferenceError%': ReferenceError,
    '%Reflect%': typeof Reflect > 'u' ? Pt : Reflect,
    '%RegExp%': RegExp,
    '%Set%': typeof Set > 'u' ? Pt : Set,
    '%SetIteratorPrototype%':
      typeof Set > 'u' || !Fs || !Vr ? Pt : Vr(new Set()[Symbol.iterator]()),
    '%SharedArrayBuffer%': typeof SharedArrayBuffer > 'u' ? Pt : SharedArrayBuffer,
    '%String%': String,
    '%StringIteratorPrototype%': Fs && Vr ? Vr(''[Symbol.iterator]()) : Pt,
    '%Symbol%': Fs ? Symbol : Pt,
    '%SyntaxError%': ma,
    '%ThrowTypeError%': T7,
    '%TypedArray%': C7,
    '%TypeError%': la,
    '%Uint8Array%': typeof Uint8Array > 'u' ? Pt : Uint8Array,
    '%Uint8ClampedArray%': typeof Uint8ClampedArray > 'u' ? Pt : Uint8ClampedArray,
    '%Uint16Array%': typeof Uint16Array > 'u' ? Pt : Uint16Array,
    '%Uint32Array%': typeof Uint32Array > 'u' ? Pt : Uint32Array,
    '%URIError%': URIError,
    '%WeakMap%': typeof WeakMap > 'u' ? Pt : WeakMap,
    '%WeakRef%': typeof WeakRef > 'u' ? Pt : WeakRef,
    '%WeakSet%': typeof WeakSet > 'u' ? Pt : WeakSet,
  };
if (Vr)
  try {
    null.error;
  } catch (i) {
    var L7 = Vr(Vr(i));
    cs['%Error.prototype%'] = L7;
  }
var N7 = function i(e) {
    var t;
    if (e === '%AsyncFunction%') t = Fh('async function () {}');
    else if (e === '%GeneratorFunction%') t = Fh('function* () {}');
    else if (e === '%AsyncGeneratorFunction%') t = Fh('async function* () {}');
    else if (e === '%AsyncGenerator%') {
      var r = i('%AsyncGeneratorFunction%');
      r && (t = r.prototype);
    } else if (e === '%AsyncIteratorPrototype%') {
      var s = i('%AsyncGenerator%');
      s && Vr && (t = Vr(s.prototype));
    }
    return (cs[e] = t), t;
  },
  zg = {
    '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
    '%ArrayPrototype%': ['Array', 'prototype'],
    '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
    '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
    '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
    '%ArrayProto_values%': ['Array', 'prototype', 'values'],
    '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
    '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
    '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
    '%BooleanPrototype%': ['Boolean', 'prototype'],
    '%DataViewPrototype%': ['DataView', 'prototype'],
    '%DatePrototype%': ['Date', 'prototype'],
    '%ErrorPrototype%': ['Error', 'prototype'],
    '%EvalErrorPrototype%': ['EvalError', 'prototype'],
    '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
    '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
    '%FunctionPrototype%': ['Function', 'prototype'],
    '%Generator%': ['GeneratorFunction', 'prototype'],
    '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
    '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
    '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
    '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
    '%JSONParse%': ['JSON', 'parse'],
    '%JSONStringify%': ['JSON', 'stringify'],
    '%MapPrototype%': ['Map', 'prototype'],
    '%NumberPrototype%': ['Number', 'prototype'],
    '%ObjectPrototype%': ['Object', 'prototype'],
    '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
    '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
    '%PromisePrototype%': ['Promise', 'prototype'],
    '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
    '%Promise_all%': ['Promise', 'all'],
    '%Promise_reject%': ['Promise', 'reject'],
    '%Promise_resolve%': ['Promise', 'resolve'],
    '%RangeErrorPrototype%': ['RangeError', 'prototype'],
    '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
    '%RegExpPrototype%': ['RegExp', 'prototype'],
    '%SetPrototype%': ['Set', 'prototype'],
    '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
    '%StringPrototype%': ['String', 'prototype'],
    '%SymbolPrototype%': ['Symbol', 'prototype'],
    '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
    '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
    '%TypeErrorPrototype%': ['TypeError', 'prototype'],
    '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
    '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
    '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
    '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
    '%URIErrorPrototype%': ['URIError', 'prototype'],
    '%WeakMapPrototype%': ['WeakMap', 'prototype'],
    '%WeakSetPrototype%': ['WeakSet', 'prototype'],
  },
  Gu = P7,
  Uf = wl,
  $7 = Gu.call(Function.call, Array.prototype.concat),
  D7 = Gu.call(Function.apply, Array.prototype.splice),
  Fg = Gu.call(Function.call, String.prototype.replace),
  zf = Gu.call(Function.call, String.prototype.slice),
  U7 = Gu.call(Function.call, RegExp.prototype.exec),
  z7 =
    /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
  F7 = /\\(\\)?/g,
  q7 = function (e) {
    var t = zf(e, 0, 1),
      r = zf(e, -1);
    if (t === '%' && r !== '%') throw new ma('invalid intrinsic syntax, expected closing `%`');
    if (r === '%' && t !== '%') throw new ma('invalid intrinsic syntax, expected opening `%`');
    var s = [];
    return (
      Fg(e, z7, function (n, c, f, h) {
        s[s.length] = f ? Fg(h, F7, '$1') : c || n;
      }),
      s
    );
  },
  W7 = function (e, t) {
    var r = e,
      s;
    if ((Uf(zg, r) && ((s = zg[r]), (r = '%' + s[0] + '%')), Uf(cs, r))) {
      var n = cs[r];
      if ((n === Zs && (n = N7(r)), typeof n > 'u' && !t))
        throw new la('intrinsic ' + e + ' exists, but is not available. Please file an issue!');
      return { alias: s, name: r, value: n };
    }
    throw new ma('intrinsic ' + e + ' does not exist!');
  },
  K7 = function (e, t) {
    if (typeof e != 'string' || e.length === 0)
      throw new la('intrinsic name must be a non-empty string');
    if (arguments.length > 1 && typeof t != 'boolean')
      throw new la('"allowMissing" argument must be a boolean');
    if (U7(/^%?[^%]*%?$/, e) === null)
      throw new ma(
        '`%` may not be present anywhere but at the beginning and end of the intrinsic name'
      );
    var r = q7(e),
      s = r.length > 0 ? r[0] : '',
      n = W7('%' + s + '%', t),
      c = n.name,
      f = n.value,
      h = !1,
      y = n.alias;
    y && ((s = y[0]), D7(r, $7([0, 1], y)));
    for (var p = 1, m = !0; p < r.length; p += 1) {
      var _ = r[p],
        A = zf(_, 0, 1),
        E = zf(_, -1);
      if ((A === '"' || A === "'" || A === '`' || E === '"' || E === "'" || E === '`') && A !== E)
        throw new ma('property names with quotes must have matching quotes');
      if (((_ === 'constructor' || !m) && (h = !0), (s += '.' + _), (c = '%' + s + '%'), Uf(cs, c)))
        f = cs[c];
      else if (f != null) {
        if (!(_ in f)) {
          if (!t)
            throw new la('base intrinsic for ' + e + ' exists, but the property is not available.');
          return;
        }
        if (us && p + 1 >= r.length) {
          var I = us(f, _);
          (m = !!I), m && 'get' in I && !('originalValue' in I.get) ? (f = I.get) : (f = f[_]);
        } else (m = Uf(f, _)), (f = f[_]);
        m && !h && (cs[c] = f);
      }
    }
    return f;
  },
  j7 = _l,
  Hp = j7('%Object.defineProperty%', !0),
  Vp = function () {
    if (Hp)
      try {
        return Hp({}, 'a', { value: 1 }), !0;
      } catch {
        return !1;
      }
    return !1;
  };
Vp.hasArrayLengthDefineBug = function () {
  if (!Vp()) return null;
  try {
    return Hp([], 'length', { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var H1 = Vp,
  H7 = 'Function.prototype.bind called on incompatible ',
  Wh = Array.prototype.slice,
  V7 = Object.prototype.toString,
  G7 = '[object Function]',
  Y7 = function (e) {
    var t = this;
    if (typeof t != 'function' || V7.call(t) !== G7) throw new TypeError(H7 + t);
    for (
      var r = Wh.call(arguments, 1),
        s,
        n = function () {
          if (this instanceof s) {
            var p = t.apply(this, r.concat(Wh.call(arguments)));
            return Object(p) === p ? p : this;
          } else return t.apply(e, r.concat(Wh.call(arguments)));
        },
        c = Math.max(0, t.length - r.length),
        f = [],
        h = 0;
      h < c;
      h++
    )
      f.push('$' + h);
    if (
      ((s = Function(
        'binder',
        'return function (' + f.join(',') + '){ return binder.apply(this,arguments); }'
      )(n)),
      t.prototype)
    ) {
      var y = function () {};
      (y.prototype = t.prototype), (s.prototype = new y()), (y.prototype = null);
    }
    return s;
  },
  Z7 = Y7,
  J7 = Function.prototype.bind || Z7,
  Tt,
  wa = SyntaxError,
  i6 = Function,
  ha = TypeError,
  Kh = function (i) {
    try {
      return i6('"use strict"; return (' + i + ').constructor;')();
    } catch {}
  },
  fs = Object.getOwnPropertyDescriptor;
if (fs)
  try {
    fs({}, '');
  } catch {
    fs = null;
  }
var jh = function () {
    throw new ha();
  },
  X7 = fs
    ? (function () {
        try {
          return arguments.callee, jh;
        } catch {
          try {
            return fs(arguments, 'callee').get;
          } catch {
            return jh;
          }
        }
      })()
    : jh,
  qs = ml(),
  Q7 = j1(),
  Gr =
    Object.getPrototypeOf ||
    (Q7
      ? function (i) {
          return i.__proto__;
        }
      : null),
  Js = {},
  eA = typeof Uint8Array > 'u' || !Gr ? Tt : Gr(Uint8Array),
  ls = {
    '%AggregateError%': typeof AggregateError > 'u' ? Tt : AggregateError,
    '%Array%': Array,
    '%ArrayBuffer%': typeof ArrayBuffer > 'u' ? Tt : ArrayBuffer,
    '%ArrayIteratorPrototype%': qs && Gr ? Gr([][Symbol.iterator]()) : Tt,
    '%AsyncFromSyncIteratorPrototype%': Tt,
    '%AsyncFunction%': Js,
    '%AsyncGenerator%': Js,
    '%AsyncGeneratorFunction%': Js,
    '%AsyncIteratorPrototype%': Js,
    '%Atomics%': typeof Atomics > 'u' ? Tt : Atomics,
    '%BigInt%': typeof BigInt > 'u' ? Tt : BigInt,
    '%BigInt64Array%': typeof BigInt64Array > 'u' ? Tt : BigInt64Array,
    '%BigUint64Array%': typeof BigUint64Array > 'u' ? Tt : BigUint64Array,
    '%Boolean%': Boolean,
    '%DataView%': typeof DataView > 'u' ? Tt : DataView,
    '%Date%': Date,
    '%decodeURI%': decodeURI,
    '%decodeURIComponent%': decodeURIComponent,
    '%encodeURI%': encodeURI,
    '%encodeURIComponent%': encodeURIComponent,
    '%Error%': Error,
    '%eval%': eval,
    '%EvalError%': EvalError,
    '%Float32Array%': typeof Float32Array > 'u' ? Tt : Float32Array,
    '%Float64Array%': typeof Float64Array > 'u' ? Tt : Float64Array,
    '%FinalizationRegistry%': typeof FinalizationRegistry > 'u' ? Tt : FinalizationRegistry,
    '%Function%': i6,
    '%GeneratorFunction%': Js,
    '%Int8Array%': typeof Int8Array > 'u' ? Tt : Int8Array,
    '%Int16Array%': typeof Int16Array > 'u' ? Tt : Int16Array,
    '%Int32Array%': typeof Int32Array > 'u' ? Tt : Int32Array,
    '%isFinite%': isFinite,
    '%isNaN%': isNaN,
    '%IteratorPrototype%': qs && Gr ? Gr(Gr([][Symbol.iterator]())) : Tt,
    '%JSON%': typeof JSON == 'object' ? JSON : Tt,
    '%Map%': typeof Map > 'u' ? Tt : Map,
    '%MapIteratorPrototype%':
      typeof Map > 'u' || !qs || !Gr ? Tt : Gr(new Map()[Symbol.iterator]()),
    '%Math%': Math,
    '%Number%': Number,
    '%Object%': Object,
    '%parseFloat%': parseFloat,
    '%parseInt%': parseInt,
    '%Promise%': typeof Promise > 'u' ? Tt : Promise,
    '%Proxy%': typeof Proxy > 'u' ? Tt : Proxy,
    '%RangeError%': RangeError,
    '%ReferenceError%': ReferenceError,
    '%Reflect%': typeof Reflect > 'u' ? Tt : Reflect,
    '%RegExp%': RegExp,
    '%Set%': typeof Set > 'u' ? Tt : Set,
    '%SetIteratorPrototype%':
      typeof Set > 'u' || !qs || !Gr ? Tt : Gr(new Set()[Symbol.iterator]()),
    '%SharedArrayBuffer%': typeof SharedArrayBuffer > 'u' ? Tt : SharedArrayBuffer,
    '%String%': String,
    '%StringIteratorPrototype%': qs && Gr ? Gr(''[Symbol.iterator]()) : Tt,
    '%Symbol%': qs ? Symbol : Tt,
    '%SyntaxError%': wa,
    '%ThrowTypeError%': X7,
    '%TypedArray%': eA,
    '%TypeError%': ha,
    '%Uint8Array%': typeof Uint8Array > 'u' ? Tt : Uint8Array,
    '%Uint8ClampedArray%': typeof Uint8ClampedArray > 'u' ? Tt : Uint8ClampedArray,
    '%Uint16Array%': typeof Uint16Array > 'u' ? Tt : Uint16Array,
    '%Uint32Array%': typeof Uint32Array > 'u' ? Tt : Uint32Array,
    '%URIError%': URIError,
    '%WeakMap%': typeof WeakMap > 'u' ? Tt : WeakMap,
    '%WeakRef%': typeof WeakRef > 'u' ? Tt : WeakRef,
    '%WeakSet%': typeof WeakSet > 'u' ? Tt : WeakSet,
  };
if (Gr)
  try {
    null.error;
  } catch (i) {
    var tA = Gr(Gr(i));
    ls['%Error.prototype%'] = tA;
  }
var rA = function i(e) {
    var t;
    if (e === '%AsyncFunction%') t = Kh('async function () {}');
    else if (e === '%GeneratorFunction%') t = Kh('function* () {}');
    else if (e === '%AsyncGeneratorFunction%') t = Kh('async function* () {}');
    else if (e === '%AsyncGenerator%') {
      var r = i('%AsyncGeneratorFunction%');
      r && (t = r.prototype);
    } else if (e === '%AsyncIteratorPrototype%') {
      var s = i('%AsyncGenerator%');
      s && Gr && (t = Gr(s.prototype));
    }
    return (ls[e] = t), t;
  },
  qg = {
    '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
    '%ArrayPrototype%': ['Array', 'prototype'],
    '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
    '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
    '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
    '%ArrayProto_values%': ['Array', 'prototype', 'values'],
    '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
    '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
    '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
    '%BooleanPrototype%': ['Boolean', 'prototype'],
    '%DataViewPrototype%': ['DataView', 'prototype'],
    '%DatePrototype%': ['Date', 'prototype'],
    '%ErrorPrototype%': ['Error', 'prototype'],
    '%EvalErrorPrototype%': ['EvalError', 'prototype'],
    '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
    '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
    '%FunctionPrototype%': ['Function', 'prototype'],
    '%Generator%': ['GeneratorFunction', 'prototype'],
    '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
    '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
    '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
    '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
    '%JSONParse%': ['JSON', 'parse'],
    '%JSONStringify%': ['JSON', 'stringify'],
    '%MapPrototype%': ['Map', 'prototype'],
    '%NumberPrototype%': ['Number', 'prototype'],
    '%ObjectPrototype%': ['Object', 'prototype'],
    '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
    '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
    '%PromisePrototype%': ['Promise', 'prototype'],
    '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
    '%Promise_all%': ['Promise', 'all'],
    '%Promise_reject%': ['Promise', 'reject'],
    '%Promise_resolve%': ['Promise', 'resolve'],
    '%RangeErrorPrototype%': ['RangeError', 'prototype'],
    '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
    '%RegExpPrototype%': ['RegExp', 'prototype'],
    '%SetPrototype%': ['Set', 'prototype'],
    '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
    '%StringPrototype%': ['String', 'prototype'],
    '%SymbolPrototype%': ['Symbol', 'prototype'],
    '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
    '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
    '%TypeErrorPrototype%': ['TypeError', 'prototype'],
    '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
    '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
    '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
    '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
    '%URIErrorPrototype%': ['URIError', 'prototype'],
    '%WeakMapPrototype%': ['WeakMap', 'prototype'],
    '%WeakSetPrototype%': ['WeakSet', 'prototype'],
  },
  Yu = J7,
  Ff = wl,
  iA = Yu.call(Function.call, Array.prototype.concat),
  nA = Yu.call(Function.apply, Array.prototype.splice),
  Wg = Yu.call(Function.call, String.prototype.replace),
  qf = Yu.call(Function.call, String.prototype.slice),
  oA = Yu.call(Function.call, RegExp.prototype.exec),
  sA =
    /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
  aA = /\\(\\)?/g,
  uA = function (e) {
    var t = qf(e, 0, 1),
      r = qf(e, -1);
    if (t === '%' && r !== '%') throw new wa('invalid intrinsic syntax, expected closing `%`');
    if (r === '%' && t !== '%') throw new wa('invalid intrinsic syntax, expected opening `%`');
    var s = [];
    return (
      Wg(e, sA, function (n, c, f, h) {
        s[s.length] = f ? Wg(h, aA, '$1') : c || n;
      }),
      s
    );
  },
  cA = function (e, t) {
    var r = e,
      s;
    if ((Ff(qg, r) && ((s = qg[r]), (r = '%' + s[0] + '%')), Ff(ls, r))) {
      var n = ls[r];
      if ((n === Js && (n = rA(r)), typeof n > 'u' && !t))
        throw new ha('intrinsic ' + e + ' exists, but is not available. Please file an issue!');
      return { alias: s, name: r, value: n };
    }
    throw new wa('intrinsic ' + e + ' does not exist!');
  },
  fA = function (e, t) {
    if (typeof e != 'string' || e.length === 0)
      throw new ha('intrinsic name must be a non-empty string');
    if (arguments.length > 1 && typeof t != 'boolean')
      throw new ha('"allowMissing" argument must be a boolean');
    if (oA(/^%?[^%]*%?$/, e) === null)
      throw new wa(
        '`%` may not be present anywhere but at the beginning and end of the intrinsic name'
      );
    var r = uA(e),
      s = r.length > 0 ? r[0] : '',
      n = cA('%' + s + '%', t),
      c = n.name,
      f = n.value,
      h = !1,
      y = n.alias;
    y && ((s = y[0]), nA(r, iA([0, 1], y)));
    for (var p = 1, m = !0; p < r.length; p += 1) {
      var _ = r[p],
        A = qf(_, 0, 1),
        E = qf(_, -1);
      if ((A === '"' || A === "'" || A === '`' || E === '"' || E === "'" || E === '`') && A !== E)
        throw new wa('property names with quotes must have matching quotes');
      if (((_ === 'constructor' || !m) && (h = !0), (s += '.' + _), (c = '%' + s + '%'), Ff(ls, c)))
        f = ls[c];
      else if (f != null) {
        if (!(_ in f)) {
          if (!t)
            throw new ha('base intrinsic for ' + e + ' exists, but the property is not available.');
          return;
        }
        if (fs && p + 1 >= r.length) {
          var I = fs(f, _);
          (m = !!I), m && 'get' in I && !('originalValue' in I.get) ? (f = I.get) : (f = f[_]);
        } else (m = Ff(f, _)), (f = f[_]);
        m && !h && (ls[c] = f);
      }
    }
    return f;
  },
  Hh,
  Kg;
function Sl() {
  if (Kg) return Hh;
  Kg = 1;
  var i = _l,
    e = i('%Object.getOwnPropertyDescriptor%', !0);
  if (e)
    try {
      e([], 'length');
    } catch {
      e = null;
    }
  return (Hh = e), Hh;
}
var lA = H1(),
  V1 = fA,
  wu = lA && V1('%Object.defineProperty%', !0);
if (wu)
  try {
    wu({}, 'a', { value: 1 });
  } catch {
    wu = !1;
  }
var hA = V1('%SyntaxError%'),
  Ws = V1('%TypeError%'),
  jg = Sl(),
  dA = function (e, t, r) {
    if (!e || (typeof e != 'object' && typeof e != 'function'))
      throw new Ws('`obj` must be an object or a function`');
    if (typeof t != 'string' && typeof t != 'symbol')
      throw new Ws('`property` must be a string or a symbol`');
    if (arguments.length > 3 && typeof arguments[3] != 'boolean' && arguments[3] !== null)
      throw new Ws('`nonEnumerable`, if provided, must be a boolean or null');
    if (arguments.length > 4 && typeof arguments[4] != 'boolean' && arguments[4] !== null)
      throw new Ws('`nonWritable`, if provided, must be a boolean or null');
    if (arguments.length > 5 && typeof arguments[5] != 'boolean' && arguments[5] !== null)
      throw new Ws('`nonConfigurable`, if provided, must be a boolean or null');
    if (arguments.length > 6 && typeof arguments[6] != 'boolean')
      throw new Ws('`loose`, if provided, must be a boolean');
    var s = arguments.length > 3 ? arguments[3] : null,
      n = arguments.length > 4 ? arguments[4] : null,
      c = arguments.length > 5 ? arguments[5] : null,
      f = arguments.length > 6 ? arguments[6] : !1,
      h = !!jg && jg(e, t);
    if (wu)
      wu(e, t, {
        configurable: c === null && h ? h.configurable : !c,
        enumerable: s === null && h ? h.enumerable : !s,
        value: r,
        writable: n === null && h ? h.writable : !n,
      });
    else if (f || (!s && !n && !c)) e[t] = r;
    else
      throw new hA(
        'This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.'
      );
  },
  n6 = K7,
  Hg = dA,
  pA = H1(),
  Vg = Sl(),
  Gg = n6('%TypeError%'),
  yA = n6('%Math.floor%'),
  gA = function (e, t) {
    if (typeof e != 'function') throw new Gg('`fn` is not a function');
    if (typeof t != 'number' || t < 0 || t > 4294967295 || yA(t) !== t)
      throw new Gg('`length` must be a positive 32-bit integer');
    var r = arguments.length > 2 && !!arguments[2],
      s = !0,
      n = !0;
    if ('length' in e && Vg) {
      var c = Vg(e, 'length');
      c && !c.configurable && (s = !1), c && !c.writable && (n = !1);
    }
    return (s || n || !r) && (pA ? Hg(e, 'length', t, !0, !0) : Hg(e, 'length', t)), e;
  };
(function (i) {
  var e = s7,
    t = t6,
    r = gA,
    s = t('%TypeError%'),
    n = t('%Function.prototype.apply%'),
    c = t('%Function.prototype.call%'),
    f = t('%Reflect.apply%', !0) || e.call(c, n),
    h = t('%Object.defineProperty%', !0),
    y = t('%Math.max%');
  if (h)
    try {
      h({}, 'a', { value: 1 });
    } catch {
      h = null;
    }
  i.exports = function (_) {
    if (typeof _ != 'function') throw new s('a function is required');
    var A = f(e, c, arguments);
    return r(A, 1 + y(0, _.length - (arguments.length - 1)), !0);
  };
  var p = function () {
    return f(e, n, arguments);
  };
  h ? h(i.exports, 'apply', { value: p }) : (i.exports.apply = p);
})(Q2);
var o6 = Q2.exports,
  s6 = t6,
  a6 = o6,
  bA = a6(s6('String.prototype.indexOf')),
  vA = function (e, t) {
    var r = s6(e, !!t);
    return typeof r == 'function' && bA(e, '.prototype.') > -1 ? a6(r) : r;
  },
  Wf = ZM,
  mA = X2,
  Yg = o6,
  G1 = vA,
  yf = Sl(),
  wA = G1('Object.prototype.toString'),
  u6 = vl()(),
  Zg = globalThis,
  Gp = mA(),
  Y1 = G1('String.prototype.slice'),
  Vh = Object.getPrototypeOf,
  _A =
    G1('Array.prototype.indexOf', !0) ||
    function (e, t) {
      for (var r = 0; r < e.length; r += 1) if (e[r] === t) return r;
      return -1;
    },
  Kf = { __proto__: null };
u6 && yf && Vh
  ? Wf(Gp, function (i) {
      var e = new Zg[i]();
      if (Symbol.toStringTag in e) {
        var t = Vh(e),
          r = yf(t, Symbol.toStringTag);
        if (!r) {
          var s = Vh(t);
          r = yf(s, Symbol.toStringTag);
        }
        Kf['$' + i] = Yg(r.get);
      }
    })
  : Wf(Gp, function (i) {
      var e = new Zg[i](),
        t = e.slice || e.set;
      t && (Kf['$' + i] = Yg(t));
    });
var SA = function (e) {
    var t = !1;
    return (
      Wf(Kf, function (r, s) {
        if (!t)
          try {
            '$' + r(e) === s && (t = Y1(s, 1));
          } catch {}
      }),
      t
    );
  },
  MA = function (e) {
    var t = !1;
    return (
      Wf(Kf, function (r, s) {
        if (!t)
          try {
            r(e), (t = Y1(s, 1));
          } catch {}
      }),
      t
    );
  },
  AA = function (e) {
    if (!e || typeof e != 'object') return !1;
    if (!u6) {
      var t = Y1(wA(e), 8, -1);
      return _A(Gp, t) > -1 ? t : t !== 'Object' ? !1 : MA(e);
    }
    return yf ? SA(e) : null;
  },
  EA = Object.prototype.hasOwnProperty,
  kA = Object.prototype.toString,
  IA = function (e, t, r) {
    if (kA.call(t) !== '[object Function]') throw new TypeError('iterator must be a function');
    var s = e.length;
    if (s === +s) for (var n = 0; n < s; n++) t.call(r, e[n], n, e);
    else for (var c in e) EA.call(e, c) && t.call(r, e[c], c, e);
  },
  Gh,
  Jg;
function xA() {
  return Jg || ((Jg = 1), (Gh = Sl())), Gh;
}
var c6 = IA,
  BA = X2,
  Z1 = Y2(),
  RA = Z1('Object.prototype.toString'),
  f6 = vl()(),
  PA = globalThis,
  l6 = BA(),
  TA =
    Z1('Array.prototype.indexOf', !0) ||
    function (e, t) {
      for (var r = 0; r < e.length; r += 1) if (e[r] === t) return r;
      return -1;
    },
  OA = Z1('String.prototype.slice'),
  h6 = {},
  gf = xA(),
  Yh = Object.getPrototypeOf;
f6 &&
  gf &&
  Yh &&
  c6(l6, function (i) {
    var e = new PA[i]();
    if (Symbol.toStringTag in e) {
      var t = Yh(e),
        r = gf(t, Symbol.toStringTag);
      if (!r) {
        var s = Yh(t);
        r = gf(s, Symbol.toStringTag);
      }
      h6[i] = r.get;
    }
  });
var CA = function (e) {
    var t = !1;
    return (
      c6(h6, function (r, s) {
        if (!t)
          try {
            t = r.call(e) === s;
          } catch {}
      }),
      t
    );
  },
  LA = function (e) {
    if (!e || typeof e != 'object') return !1;
    if (!f6 || !(Symbol.toStringTag in e)) {
      var t = OA(RA(e), 8, -1);
      return TA(l6, t) > -1;
    }
    return gf ? CA(e) : !1;
  };
(function (i) {
  var e = $M(),
    t = qM,
    r = AA,
    s = LA;
  function n(oe) {
    return oe.call.bind(oe);
  }
  var c = typeof BigInt < 'u',
    f = typeof Symbol < 'u',
    h = n(Object.prototype.toString),
    y = n(Number.prototype.valueOf),
    p = n(String.prototype.valueOf),
    m = n(Boolean.prototype.valueOf);
  if (c) var _ = n(BigInt.prototype.valueOf);
  if (f) var A = n(Symbol.prototype.valueOf);
  function E(oe, rt) {
    if (typeof oe != 'object') return !1;
    try {
      return rt(oe), !0;
    } catch {
      return !1;
    }
  }
  (i.isArgumentsObject = e), (i.isGeneratorFunction = t), (i.isTypedArray = s);
  function I(oe) {
    return (
      (typeof Promise < 'u' && oe instanceof Promise) ||
      (oe !== null &&
        typeof oe == 'object' &&
        typeof oe.then == 'function' &&
        typeof oe.catch == 'function')
    );
  }
  i.isPromise = I;
  function R(oe) {
    return typeof ArrayBuffer < 'u' && ArrayBuffer.isView ? ArrayBuffer.isView(oe) : s(oe) || B(oe);
  }
  i.isArrayBufferView = R;
  function L(oe) {
    return r(oe) === 'Uint8Array';
  }
  i.isUint8Array = L;
  function D(oe) {
    return r(oe) === 'Uint8ClampedArray';
  }
  i.isUint8ClampedArray = D;
  function q(oe) {
    return r(oe) === 'Uint16Array';
  }
  i.isUint16Array = q;
  function H(oe) {
    return r(oe) === 'Uint32Array';
  }
  i.isUint32Array = H;
  function V(oe) {
    return r(oe) === 'Int8Array';
  }
  i.isInt8Array = V;
  function te(oe) {
    return r(oe) === 'Int16Array';
  }
  i.isInt16Array = te;
  function ue(oe) {
    return r(oe) === 'Int32Array';
  }
  i.isInt32Array = ue;
  function ne(oe) {
    return r(oe) === 'Float32Array';
  }
  i.isFloat32Array = ne;
  function X(oe) {
    return r(oe) === 'Float64Array';
  }
  i.isFloat64Array = X;
  function Oe(oe) {
    return r(oe) === 'BigInt64Array';
  }
  i.isBigInt64Array = Oe;
  function S(oe) {
    return r(oe) === 'BigUint64Array';
  }
  i.isBigUint64Array = S;
  function o(oe) {
    return h(oe) === '[object Map]';
  }
  o.working = typeof Map < 'u' && o(new Map());
  function u(oe) {
    return typeof Map > 'u' ? !1 : o.working ? o(oe) : oe instanceof Map;
  }
  i.isMap = u;
  function l(oe) {
    return h(oe) === '[object Set]';
  }
  l.working = typeof Set < 'u' && l(new Set());
  function d(oe) {
    return typeof Set > 'u' ? !1 : l.working ? l(oe) : oe instanceof Set;
  }
  i.isSet = d;
  function g(oe) {
    return h(oe) === '[object WeakMap]';
  }
  g.working = typeof WeakMap < 'u' && g(new WeakMap());
  function w(oe) {
    return typeof WeakMap > 'u' ? !1 : g.working ? g(oe) : oe instanceof WeakMap;
  }
  i.isWeakMap = w;
  function M(oe) {
    return h(oe) === '[object WeakSet]';
  }
  M.working = typeof WeakSet < 'u' && M(new WeakSet());
  function v(oe) {
    return M(oe);
  }
  i.isWeakSet = v;
  function a(oe) {
    return h(oe) === '[object ArrayBuffer]';
  }
  a.working = typeof ArrayBuffer < 'u' && a(new ArrayBuffer());
  function b(oe) {
    return typeof ArrayBuffer > 'u' ? !1 : a.working ? a(oe) : oe instanceof ArrayBuffer;
  }
  i.isArrayBuffer = b;
  function k(oe) {
    return h(oe) === '[object DataView]';
  }
  k.working =
    typeof ArrayBuffer < 'u' && typeof DataView < 'u' && k(new DataView(new ArrayBuffer(1), 0, 1));
  function B(oe) {
    return typeof DataView > 'u' ? !1 : k.working ? k(oe) : oe instanceof DataView;
  }
  i.isDataView = B;
  var F = typeof SharedArrayBuffer < 'u' ? SharedArrayBuffer : void 0;
  function P(oe) {
    return h(oe) === '[object SharedArrayBuffer]';
  }
  function C(oe) {
    return typeof F > 'u'
      ? !1
      : (typeof P.working > 'u' && (P.working = P(new F())), P.working ? P(oe) : oe instanceof F);
  }
  i.isSharedArrayBuffer = C;
  function z(oe) {
    return h(oe) === '[object AsyncFunction]';
  }
  i.isAsyncFunction = z;
  function Y(oe) {
    return h(oe) === '[object Map Iterator]';
  }
  i.isMapIterator = Y;
  function G(oe) {
    return h(oe) === '[object Set Iterator]';
  }
  i.isSetIterator = G;
  function Q(oe) {
    return h(oe) === '[object Generator]';
  }
  i.isGeneratorObject = Q;
  function U(oe) {
    return h(oe) === '[object WebAssembly.Module]';
  }
  i.isWebAssemblyCompiledModule = U;
  function $(oe) {
    return E(oe, y);
  }
  i.isNumberObject = $;
  function Z(oe) {
    return E(oe, p);
  }
  i.isStringObject = Z;
  function ae(oe) {
    return E(oe, m);
  }
  i.isBooleanObject = ae;
  function fe(oe) {
    return c && E(oe, _);
  }
  i.isBigIntObject = fe;
  function le(oe) {
    return f && E(oe, A);
  }
  i.isSymbolObject = le;
  function Fe(oe) {
    return $(oe) || Z(oe) || ae(oe) || fe(oe) || le(oe);
  }
  i.isBoxedPrimitive = Fe;
  function be(oe) {
    return typeof Uint8Array < 'u' && (b(oe) || C(oe));
  }
  (i.isAnyArrayBuffer = be),
    ['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function (oe) {
      Object.defineProperty(i, oe, {
        enumerable: !1,
        value: function () {
          throw new Error(oe + ' is not supported in userland');
        },
      });
    });
})(j2);
var NA = function (e) {
  return (
    e &&
    typeof e == 'object' &&
    typeof e.copy == 'function' &&
    typeof e.fill == 'function' &&
    typeof e.readUInt8 == 'function'
  );
};
(function (i) {
  var e = {},
    t =
      Object.getOwnPropertyDescriptors ||
      function (F) {
        for (var P = Object.keys(F), C = {}, z = 0; z < P.length; z++)
          C[P[z]] = Object.getOwnPropertyDescriptor(F, P[z]);
        return C;
      },
    r = /%[sdj%]/g;
  (i.format = function (B) {
    if (!te(B)) {
      for (var F = [], P = 0; P < arguments.length; P++) F.push(f(arguments[P]));
      return F.join(' ');
    }
    for (
      var P = 1,
        C = arguments,
        z = C.length,
        Y = String(B).replace(r, function (Q) {
          if (Q === '%%') return '%';
          if (P >= z) return Q;
          switch (Q) {
            case '%s':
              return String(C[P++]);
            case '%d':
              return Number(C[P++]);
            case '%j':
              try {
                return JSON.stringify(C[P++]);
              } catch {
                return '[Circular]';
              }
            default:
              return Q;
          }
        }),
        G = C[P];
      P < z;
      G = C[++P]
    )
      q(G) || !Oe(G) ? (Y += ' ' + G) : (Y += ' ' + f(G));
    return Y;
  }),
    (i.deprecate = function (B, F) {
      if (typeof Je < 'u' && Je.noDeprecation === !0) return B;
      if (typeof Je > 'u')
        return function () {
          return i.deprecate(B, F).apply(this, arguments);
        };
      var P = !1;
      function C() {
        if (!P) {
          if (Je.throwDeprecation) throw new Error(F);
          Je.traceDeprecation ? console.trace(F) : console.error(F), (P = !0);
        }
        return B.apply(this, arguments);
      }
      return C;
    });
  var s = {},
    n = /^$/;
  if (e.NODE_DEBUG) {
    var c = e.NODE_DEBUG;
    (c = c
      .replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
      .replace(/\*/g, '.*')
      .replace(/,/g, '$|^')
      .toUpperCase()),
      (n = new RegExp('^' + c + '$', 'i'));
  }
  i.debuglog = function (B) {
    if (((B = B.toUpperCase()), !s[B]))
      if (n.test(B)) {
        var F = Je.pid;
        s[B] = function () {
          var P = i.format.apply(i, arguments);
          console.error('%s %d: %s', B, F, P);
        };
      } else s[B] = function () {};
    return s[B];
  };
  function f(B, F) {
    var P = { seen: [], stylize: y };
    return (
      arguments.length >= 3 && (P.depth = arguments[2]),
      arguments.length >= 4 && (P.colors = arguments[3]),
      D(F) ? (P.showHidden = F) : F && i._extend(P, F),
      ne(P.showHidden) && (P.showHidden = !1),
      ne(P.depth) && (P.depth = 2),
      ne(P.colors) && (P.colors = !1),
      ne(P.customInspect) && (P.customInspect = !0),
      P.colors && (P.stylize = h),
      m(P, B, P.depth)
    );
  }
  (i.inspect = f),
    (f.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39],
    }),
    (f.styles = {
      special: 'cyan',
      number: 'yellow',
      boolean: 'yellow',
      undefined: 'grey',
      null: 'bold',
      string: 'green',
      date: 'magenta',
      regexp: 'red',
    });
  function h(B, F) {
    var P = f.styles[F];
    return P ? '\x1B[' + f.colors[P][0] + 'm' + B + '\x1B[' + f.colors[P][1] + 'm' : B;
  }
  function y(B, F) {
    return B;
  }
  function p(B) {
    var F = {};
    return (
      B.forEach(function (P, C) {
        F[P] = !0;
      }),
      F
    );
  }
  function m(B, F, P) {
    if (
      B.customInspect &&
      F &&
      u(F.inspect) &&
      F.inspect !== i.inspect &&
      !(F.constructor && F.constructor.prototype === F)
    ) {
      var C = F.inspect(P, B);
      return te(C) || (C = m(B, C, P)), C;
    }
    var z = _(B, F);
    if (z) return z;
    var Y = Object.keys(F),
      G = p(Y);
    if (
      (B.showHidden && (Y = Object.getOwnPropertyNames(F)),
      o(F) && (Y.indexOf('message') >= 0 || Y.indexOf('description') >= 0))
    )
      return A(F);
    if (Y.length === 0) {
      if (u(F)) {
        var Q = F.name ? ': ' + F.name : '';
        return B.stylize('[Function' + Q + ']', 'special');
      }
      if (X(F)) return B.stylize(RegExp.prototype.toString.call(F), 'regexp');
      if (S(F)) return B.stylize(Date.prototype.toString.call(F), 'date');
      if (o(F)) return A(F);
    }
    var U = '',
      $ = !1,
      Z = ['{', '}'];
    if ((L(F) && (($ = !0), (Z = ['[', ']'])), u(F))) {
      var ae = F.name ? ': ' + F.name : '';
      U = ' [Function' + ae + ']';
    }
    if (
      (X(F) && (U = ' ' + RegExp.prototype.toString.call(F)),
      S(F) && (U = ' ' + Date.prototype.toUTCString.call(F)),
      o(F) && (U = ' ' + A(F)),
      Y.length === 0 && (!$ || F.length == 0))
    )
      return Z[0] + U + Z[1];
    if (P < 0)
      return X(F)
        ? B.stylize(RegExp.prototype.toString.call(F), 'regexp')
        : B.stylize('[Object]', 'special');
    B.seen.push(F);
    var fe;
    return (
      $
        ? (fe = E(B, F, P, G, Y))
        : (fe = Y.map(function (le) {
            return I(B, F, P, G, le, $);
          })),
      B.seen.pop(),
      R(fe, U, Z)
    );
  }
  function _(B, F) {
    if (ne(F)) return B.stylize('undefined', 'undefined');
    if (te(F)) {
      var P =
        "'" +
        JSON.stringify(F).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') +
        "'";
      return B.stylize(P, 'string');
    }
    if (V(F)) return B.stylize('' + F, 'number');
    if (D(F)) return B.stylize('' + F, 'boolean');
    if (q(F)) return B.stylize('null', 'null');
  }
  function A(B) {
    return '[' + Error.prototype.toString.call(B) + ']';
  }
  function E(B, F, P, C, z) {
    for (var Y = [], G = 0, Q = F.length; G < Q; ++G)
      v(F, String(G)) ? Y.push(I(B, F, P, C, String(G), !0)) : Y.push('');
    return (
      z.forEach(function (U) {
        U.match(/^\d+$/) || Y.push(I(B, F, P, C, U, !0));
      }),
      Y
    );
  }
  function I(B, F, P, C, z, Y) {
    var G, Q, U;
    if (
      ((U = Object.getOwnPropertyDescriptor(F, z) || { value: F[z] }),
      U.get
        ? U.set
          ? (Q = B.stylize('[Getter/Setter]', 'special'))
          : (Q = B.stylize('[Getter]', 'special'))
        : U.set && (Q = B.stylize('[Setter]', 'special')),
      v(C, z) || (G = '[' + z + ']'),
      Q ||
        (B.seen.indexOf(U.value) < 0
          ? (q(P) ? (Q = m(B, U.value, null)) : (Q = m(B, U.value, P - 1)),
            Q.indexOf(`
`) > -1 &&
              (Y
                ? (Q = Q.split(
                    `
`
                  )
                    .map(function ($) {
                      return '  ' + $;
                    })
                    .join(
                      `
`
                    )
                    .slice(2))
                : (Q =
                    `
` +
                    Q.split(
                      `
`
                    ).map(function ($) {
                      return '   ' + $;
                    }).join(`
`))))
          : (Q = B.stylize('[Circular]', 'special'))),
      ne(G))
    ) {
      if (Y && z.match(/^\d+$/)) return Q;
      (G = JSON.stringify('' + z)),
        G.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)
          ? ((G = G.slice(1, -1)), (G = B.stylize(G, 'name')))
          : ((G = G.replace(/'/g, "\\'")
              .replace(/\\"/g, '"')
              .replace(/(^"|"$)/g, "'")),
            (G = B.stylize(G, 'string')));
    }
    return G + ': ' + Q;
  }
  function R(B, F, P) {
    var C = B.reduce(function (z, Y) {
      return (
        Y.indexOf(`
`) >= 0,
        z + Y.replace(/\u001b\[\d\d?m/g, '').length + 1
      );
    }, 0);
    return C > 60
      ? P[0] +
          (F === ''
            ? ''
            : F +
              `
 `) +
          ' ' +
          B.join(`,
  `) +
          ' ' +
          P[1]
      : P[0] + F + ' ' + B.join(', ') + ' ' + P[1];
  }
  i.types = j2;
  function L(B) {
    return Array.isArray(B);
  }
  i.isArray = L;
  function D(B) {
    return typeof B == 'boolean';
  }
  i.isBoolean = D;
  function q(B) {
    return B === null;
  }
  i.isNull = q;
  function H(B) {
    return B == null;
  }
  i.isNullOrUndefined = H;
  function V(B) {
    return typeof B == 'number';
  }
  i.isNumber = V;
  function te(B) {
    return typeof B == 'string';
  }
  i.isString = te;
  function ue(B) {
    return typeof B == 'symbol';
  }
  i.isSymbol = ue;
  function ne(B) {
    return B === void 0;
  }
  i.isUndefined = ne;
  function X(B) {
    return Oe(B) && d(B) === '[object RegExp]';
  }
  (i.isRegExp = X), (i.types.isRegExp = X);
  function Oe(B) {
    return typeof B == 'object' && B !== null;
  }
  i.isObject = Oe;
  function S(B) {
    return Oe(B) && d(B) === '[object Date]';
  }
  (i.isDate = S), (i.types.isDate = S);
  function o(B) {
    return Oe(B) && (d(B) === '[object Error]' || B instanceof Error);
  }
  (i.isError = o), (i.types.isNativeError = o);
  function u(B) {
    return typeof B == 'function';
  }
  i.isFunction = u;
  function l(B) {
    return (
      B === null ||
      typeof B == 'boolean' ||
      typeof B == 'number' ||
      typeof B == 'string' ||
      typeof B == 'symbol' ||
      typeof B > 'u'
    );
  }
  (i.isPrimitive = l), (i.isBuffer = NA);
  function d(B) {
    return Object.prototype.toString.call(B);
  }
  function g(B) {
    return B < 10 ? '0' + B.toString(10) : B.toString(10);
  }
  var w = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  function M() {
    var B = new Date(),
      F = [g(B.getHours()), g(B.getMinutes()), g(B.getSeconds())].join(':');
    return [B.getDate(), w[B.getMonth()], F].join(' ');
  }
  (i.log = function () {
    console.log('%s - %s', M(), i.format.apply(i, arguments));
  }),
    (i.inherits = dt),
    (i._extend = function (B, F) {
      if (!F || !Oe(F)) return B;
      for (var P = Object.keys(F), C = P.length; C--; ) B[P[C]] = F[P[C]];
      return B;
    });
  function v(B, F) {
    return Object.prototype.hasOwnProperty.call(B, F);
  }
  var a = typeof Symbol < 'u' ? Symbol('util.promisify.custom') : void 0;
  (i.promisify = function (F) {
    if (typeof F != 'function')
      throw new TypeError('The "original" argument must be of type Function');
    if (a && F[a]) {
      var P = F[a];
      if (typeof P != 'function')
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return (
        Object.defineProperty(P, a, { value: P, enumerable: !1, writable: !1, configurable: !0 }), P
      );
    }
    function P() {
      for (
        var C,
          z,
          Y = new Promise(function (U, $) {
            (C = U), (z = $);
          }),
          G = [],
          Q = 0;
        Q < arguments.length;
        Q++
      )
        G.push(arguments[Q]);
      G.push(function (U, $) {
        U ? z(U) : C($);
      });
      try {
        F.apply(this, G);
      } catch (U) {
        z(U);
      }
      return Y;
    }
    return (
      Object.setPrototypeOf(P, Object.getPrototypeOf(F)),
      a &&
        Object.defineProperty(P, a, { value: P, enumerable: !1, writable: !1, configurable: !0 }),
      Object.defineProperties(P, t(F))
    );
  }),
    (i.promisify.custom = a);
  function b(B, F) {
    if (!B) {
      var P = new Error('Promise was rejected with a falsy value');
      (P.reason = B), (B = P);
    }
    return F(B);
  }
  function k(B) {
    if (typeof B != 'function')
      throw new TypeError('The "original" argument must be of type Function');
    function F() {
      for (var P = [], C = 0; C < arguments.length; C++) P.push(arguments[C]);
      var z = P.pop();
      if (typeof z != 'function') throw new TypeError('The last argument must be of type Function');
      var Y = this,
        G = function () {
          return z.apply(Y, arguments);
        };
      B.apply(this, P).then(
        function (Q) {
          Je.nextTick(G.bind(null, null, Q));
        },
        function (Q) {
          Je.nextTick(b.bind(null, Q, G));
        }
      );
    }
    return Object.setPrototypeOf(F, Object.getPrototypeOf(B)), Object.defineProperties(F, t(B)), F;
  }
  i.callbackify = k;
})(Cn);
var Zh, Xg;
function $A() {
  if (Xg) return Zh;
  Xg = 1;
  function i(_, A) {
    var E = Object.keys(_);
    if (Object.getOwnPropertySymbols) {
      var I = Object.getOwnPropertySymbols(_);
      A &&
        (I = I.filter(function (R) {
          return Object.getOwnPropertyDescriptor(_, R).enumerable;
        })),
        E.push.apply(E, I);
    }
    return E;
  }
  function e(_) {
    for (var A = 1; A < arguments.length; A++) {
      var E = arguments[A] != null ? arguments[A] : {};
      A % 2
        ? i(Object(E), !0).forEach(function (I) {
            t(_, I, E[I]);
          })
        : Object.getOwnPropertyDescriptors
          ? Object.defineProperties(_, Object.getOwnPropertyDescriptors(E))
          : i(Object(E)).forEach(function (I) {
              Object.defineProperty(_, I, Object.getOwnPropertyDescriptor(E, I));
            });
    }
    return _;
  }
  function t(_, A, E) {
    return (
      A in _
        ? Object.defineProperty(_, A, { value: E, enumerable: !0, configurable: !0, writable: !0 })
        : (_[A] = E),
      _
    );
  }
  function r(_, A) {
    if (!(_ instanceof A)) throw new TypeError('Cannot call a class as a function');
  }
  function s(_, A) {
    for (var E = 0; E < A.length; E++) {
      var I = A[E];
      (I.enumerable = I.enumerable || !1),
        (I.configurable = !0),
        'value' in I && (I.writable = !0),
        Object.defineProperty(_, I.key, I);
    }
  }
  function n(_, A, E) {
    return A && s(_.prototype, A), E && s(_, E), _;
  }
  var c = ai,
    f = c.Buffer,
    h = Cn,
    y = h.inspect,
    p = (y && y.custom) || 'inspect';
  function m(_, A, E) {
    f.prototype.copy.call(_, A, E);
  }
  return (
    (Zh = (function () {
      function _() {
        r(this, _), (this.head = null), (this.tail = null), (this.length = 0);
      }
      return (
        n(_, [
          {
            key: 'push',
            value: function (E) {
              var I = { data: E, next: null };
              this.length > 0 ? (this.tail.next = I) : (this.head = I),
                (this.tail = I),
                ++this.length;
            },
          },
          {
            key: 'unshift',
            value: function (E) {
              var I = { data: E, next: this.head };
              this.length === 0 && (this.tail = I), (this.head = I), ++this.length;
            },
          },
          {
            key: 'shift',
            value: function () {
              if (this.length !== 0) {
                var E = this.head.data;
                return (
                  this.length === 1 ? (this.head = this.tail = null) : (this.head = this.head.next),
                  --this.length,
                  E
                );
              }
            },
          },
          {
            key: 'clear',
            value: function () {
              (this.head = this.tail = null), (this.length = 0);
            },
          },
          {
            key: 'join',
            value: function (E) {
              if (this.length === 0) return '';
              for (var I = this.head, R = '' + I.data; (I = I.next); ) R += E + I.data;
              return R;
            },
          },
          {
            key: 'concat',
            value: function (E) {
              if (this.length === 0) return f.alloc(0);
              for (var I = f.allocUnsafe(E >>> 0), R = this.head, L = 0; R; )
                m(R.data, I, L), (L += R.data.length), (R = R.next);
              return I;
            },
          },
          {
            key: 'consume',
            value: function (E, I) {
              var R;
              return (
                E < this.head.data.length
                  ? ((R = this.head.data.slice(0, E)), (this.head.data = this.head.data.slice(E)))
                  : E === this.head.data.length
                    ? (R = this.shift())
                    : (R = I ? this._getString(E) : this._getBuffer(E)),
                R
              );
            },
          },
          {
            key: 'first',
            value: function () {
              return this.head.data;
            },
          },
          {
            key: '_getString',
            value: function (E) {
              var I = this.head,
                R = 1,
                L = I.data;
              for (E -= L.length; (I = I.next); ) {
                var D = I.data,
                  q = E > D.length ? D.length : E;
                if ((q === D.length ? (L += D) : (L += D.slice(0, E)), (E -= q), E === 0)) {
                  q === D.length
                    ? (++R, I.next ? (this.head = I.next) : (this.head = this.tail = null))
                    : ((this.head = I), (I.data = D.slice(q)));
                  break;
                }
                ++R;
              }
              return (this.length -= R), L;
            },
          },
          {
            key: '_getBuffer',
            value: function (E) {
              var I = f.allocUnsafe(E),
                R = this.head,
                L = 1;
              for (R.data.copy(I), E -= R.data.length; (R = R.next); ) {
                var D = R.data,
                  q = E > D.length ? D.length : E;
                if ((D.copy(I, I.length - E, 0, q), (E -= q), E === 0)) {
                  q === D.length
                    ? (++L, R.next ? (this.head = R.next) : (this.head = this.tail = null))
                    : ((this.head = R), (R.data = D.slice(q)));
                  break;
                }
                ++L;
              }
              return (this.length -= L), I;
            },
          },
          {
            key: p,
            value: function (E, I) {
              return y(this, e({}, I, { depth: 0, customInspect: !1 }));
            },
          },
        ]),
        _
      );
    })()),
    Zh
  );
}
function DA(i, e) {
  var t = this,
    r = this._readableState && this._readableState.destroyed,
    s = this._writableState && this._writableState.destroyed;
  return r || s
    ? (e
        ? e(i)
        : i &&
          (this._writableState
            ? this._writableState.errorEmitted ||
              ((this._writableState.errorEmitted = !0), Je.nextTick(Yp, this, i))
            : Je.nextTick(Yp, this, i)),
      this)
    : (this._readableState && (this._readableState.destroyed = !0),
      this._writableState && (this._writableState.destroyed = !0),
      this._destroy(i || null, function (n) {
        !e && n
          ? t._writableState
            ? t._writableState.errorEmitted
              ? Je.nextTick(bf, t)
              : ((t._writableState.errorEmitted = !0), Je.nextTick(Qg, t, n))
            : Je.nextTick(Qg, t, n)
          : e
            ? (Je.nextTick(bf, t), e(n))
            : Je.nextTick(bf, t);
      }),
      this);
}
function Qg(i, e) {
  Yp(i, e), bf(i);
}
function bf(i) {
  (i._writableState && !i._writableState.emitClose) ||
    (i._readableState && !i._readableState.emitClose) ||
    i.emit('close');
}
function UA() {
  this._readableState &&
    ((this._readableState.destroyed = !1),
    (this._readableState.reading = !1),
    (this._readableState.ended = !1),
    (this._readableState.endEmitted = !1)),
    this._writableState &&
      ((this._writableState.destroyed = !1),
      (this._writableState.ended = !1),
      (this._writableState.ending = !1),
      (this._writableState.finalCalled = !1),
      (this._writableState.prefinished = !1),
      (this._writableState.finished = !1),
      (this._writableState.errorEmitted = !1));
}
function Yp(i, e) {
  i.emit('error', e);
}
function zA(i, e) {
  var t = i._readableState,
    r = i._writableState;
  (t && t.autoDestroy) || (r && r.autoDestroy) ? i.destroy(e) : i.emit('error', e);
}
var d6 = { destroy: DA, undestroy: UA, errorOrDestroy: zA },
  Is = {};
function FA(i, e) {
  (i.prototype = Object.create(e.prototype)), (i.prototype.constructor = i), (i.__proto__ = e);
}
var p6 = {};
function Xi(i, e, t) {
  t || (t = Error);
  function r(n, c, f) {
    return typeof e == 'string' ? e : e(n, c, f);
  }
  var s = (function (n) {
    FA(c, n);
    function c(f, h, y) {
      return n.call(this, r(f, h, y)) || this;
    }
    return c;
  })(t);
  (s.prototype.name = t.name), (s.prototype.code = i), (p6[i] = s);
}
function eb(i, e) {
  if (Array.isArray(i)) {
    var t = i.length;
    return (
      (i = i.map(function (r) {
        return String(r);
      })),
      t > 2
        ? 'one of '.concat(e, ' ').concat(i.slice(0, t - 1).join(', '), ', or ') + i[t - 1]
        : t === 2
          ? 'one of '.concat(e, ' ').concat(i[0], ' or ').concat(i[1])
          : 'of '.concat(e, ' ').concat(i[0])
    );
  } else return 'of '.concat(e, ' ').concat(String(i));
}
function qA(i, e, t) {
  return i.substr(!t || t < 0 ? 0 : +t, e.length) === e;
}
function WA(i, e, t) {
  return (t === void 0 || t > i.length) && (t = i.length), i.substring(t - e.length, t) === e;
}
function KA(i, e, t) {
  return typeof t != 'number' && (t = 0), t + e.length > i.length ? !1 : i.indexOf(e, t) !== -1;
}
Xi(
  'ERR_INVALID_OPT_VALUE',
  function (i, e) {
    return 'The value "' + e + '" is invalid for option "' + i + '"';
  },
  TypeError
);
Xi(
  'ERR_INVALID_ARG_TYPE',
  function (i, e, t) {
    var r;
    typeof e == 'string' && qA(e, 'not ')
      ? ((r = 'must not be'), (e = e.replace(/^not /, '')))
      : (r = 'must be');
    var s;
    if (WA(i, ' argument')) s = 'The '.concat(i, ' ').concat(r, ' ').concat(eb(e, 'type'));
    else {
      var n = KA(i, '.') ? 'property' : 'argument';
      s = 'The "'.concat(i, '" ').concat(n, ' ').concat(r, ' ').concat(eb(e, 'type'));
    }
    return (s += '. Received type '.concat(typeof t)), s;
  },
  TypeError
);
Xi('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
Xi('ERR_METHOD_NOT_IMPLEMENTED', function (i) {
  return 'The ' + i + ' method is not implemented';
});
Xi('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
Xi('ERR_STREAM_DESTROYED', function (i) {
  return 'Cannot call ' + i + ' after a stream was destroyed';
});
Xi('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
Xi('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
Xi('ERR_STREAM_WRITE_AFTER_END', 'write after end');
Xi('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
Xi(
  'ERR_UNKNOWN_ENCODING',
  function (i) {
    return 'Unknown encoding: ' + i;
  },
  TypeError
);
Xi('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
Is.codes = p6;
var jA = Is.codes.ERR_INVALID_OPT_VALUE;
function HA(i, e, t) {
  return i.highWaterMark != null ? i.highWaterMark : e ? i[t] : null;
}
function VA(i, e, t, r) {
  var s = HA(e, r, t);
  if (s != null) {
    if (!(isFinite(s) && Math.floor(s) === s) || s < 0) {
      var n = r ? t : 'highWaterMark';
      throw new jA(n, s);
    }
    return Math.floor(s);
  }
  return i.objectMode ? 16 : 16 * 1024;
}
var y6 = { getHighWaterMark: VA },
  g6 = GA;
function GA(i, e) {
  if (Jh('noDeprecation')) return i;
  var t = !1;
  function r() {
    if (!t) {
      if (Jh('throwDeprecation')) throw new Error(e);
      Jh('traceDeprecation') ? console.trace(e) : console.warn(e), (t = !0);
    }
    return i.apply(this, arguments);
  }
  return r;
}
function Jh(i) {
  try {
    if (!globalThis.localStorage) return !1;
  } catch {
    return !1;
  }
  var e = globalThis.localStorage[i];
  return e == null ? !1 : String(e).toLowerCase() === 'true';
}
var Xh, tb;
function J1() {
  if (tb) return Xh;
  (tb = 1), (Xh = ne);
  function i(C) {
    var z = this;
    (this.next = null),
      (this.entry = null),
      (this.finish = function () {
        P(z, C);
      });
  }
  var e;
  ne.WritableState = te;
  var t = { deprecate: g6 },
    r = K2,
    s = ai.Buffer,
    n = globalThis.Uint8Array || function () {};
  function c(C) {
    return s.from(C);
  }
  function f(C) {
    return s.isBuffer(C) || C instanceof n;
  }
  var h = d6,
    y = y6,
    p = y.getHighWaterMark,
    m = Is.codes,
    _ = m.ERR_INVALID_ARG_TYPE,
    A = m.ERR_METHOD_NOT_IMPLEMENTED,
    E = m.ERR_MULTIPLE_CALLBACK,
    I = m.ERR_STREAM_CANNOT_PIPE,
    R = m.ERR_STREAM_DESTROYED,
    L = m.ERR_STREAM_NULL_VALUES,
    D = m.ERR_STREAM_WRITE_AFTER_END,
    q = m.ERR_UNKNOWN_ENCODING,
    H = h.errorOrDestroy;
  dt(ne, r);
  function V() {}
  function te(C, z, Y) {
    (e = e || ds()),
      (C = C || {}),
      typeof Y != 'boolean' && (Y = z instanceof e),
      (this.objectMode = !!C.objectMode),
      Y && (this.objectMode = this.objectMode || !!C.writableObjectMode),
      (this.highWaterMark = p(this, C, 'writableHighWaterMark', Y)),
      (this.finalCalled = !1),
      (this.needDrain = !1),
      (this.ending = !1),
      (this.ended = !1),
      (this.finished = !1),
      (this.destroyed = !1);
    var G = C.decodeStrings === !1;
    (this.decodeStrings = !G),
      (this.defaultEncoding = C.defaultEncoding || 'utf8'),
      (this.length = 0),
      (this.writing = !1),
      (this.corked = 0),
      (this.sync = !0),
      (this.bufferProcessing = !1),
      (this.onwrite = function (Q) {
        g(z, Q);
      }),
      (this.writecb = null),
      (this.writelen = 0),
      (this.bufferedRequest = null),
      (this.lastBufferedRequest = null),
      (this.pendingcb = 0),
      (this.prefinished = !1),
      (this.errorEmitted = !1),
      (this.emitClose = C.emitClose !== !1),
      (this.autoDestroy = !!C.autoDestroy),
      (this.bufferedRequestCount = 0),
      (this.corkedRequestsFree = new i(this));
  }
  (te.prototype.getBuffer = function () {
    for (var z = this.bufferedRequest, Y = []; z; ) Y.push(z), (z = z.next);
    return Y;
  }),
    (function () {
      try {
        Object.defineProperty(te.prototype, 'buffer', {
          get: t.deprecate(
            function () {
              return this.getBuffer();
            },
            '_writableState.buffer is deprecated. Use _writableState.getBuffer instead.',
            'DEP0003'
          ),
        });
      } catch {}
    })();
  var ue;
  typeof Symbol == 'function' &&
  Symbol.hasInstance &&
  typeof Function.prototype[Symbol.hasInstance] == 'function'
    ? ((ue = Function.prototype[Symbol.hasInstance]),
      Object.defineProperty(ne, Symbol.hasInstance, {
        value: function (z) {
          return ue.call(this, z) ? !0 : this !== ne ? !1 : z && z._writableState instanceof te;
        },
      }))
    : (ue = function (z) {
        return z instanceof this;
      });
  function ne(C) {
    e = e || ds();
    var z = this instanceof e;
    if (!z && !ue.call(ne, this)) return new ne(C);
    (this._writableState = new te(C, this, z)),
      (this.writable = !0),
      C &&
        (typeof C.write == 'function' && (this._write = C.write),
        typeof C.writev == 'function' && (this._writev = C.writev),
        typeof C.destroy == 'function' && (this._destroy = C.destroy),
        typeof C.final == 'function' && (this._final = C.final)),
      r.call(this);
  }
  ne.prototype.pipe = function () {
    H(this, new I());
  };
  function X(C, z) {
    var Y = new D();
    H(C, Y), Je.nextTick(z, Y);
  }
  function Oe(C, z, Y, G) {
    var Q;
    return (
      Y === null
        ? (Q = new L())
        : typeof Y != 'string' && !z.objectMode && (Q = new _('chunk', ['string', 'Buffer'], Y)),
      Q ? (H(C, Q), Je.nextTick(G, Q), !1) : !0
    );
  }
  (ne.prototype.write = function (C, z, Y) {
    var G = this._writableState,
      Q = !1,
      U = !G.objectMode && f(C);
    return (
      U && !s.isBuffer(C) && (C = c(C)),
      typeof z == 'function' && ((Y = z), (z = null)),
      U ? (z = 'buffer') : z || (z = G.defaultEncoding),
      typeof Y != 'function' && (Y = V),
      G.ending
        ? X(this, Y)
        : (U || Oe(this, G, C, Y)) && (G.pendingcb++, (Q = o(this, G, U, C, z, Y))),
      Q
    );
  }),
    (ne.prototype.cork = function () {
      this._writableState.corked++;
    }),
    (ne.prototype.uncork = function () {
      var C = this._writableState;
      C.corked &&
        (C.corked--,
        !C.writing && !C.corked && !C.bufferProcessing && C.bufferedRequest && v(this, C));
    }),
    (ne.prototype.setDefaultEncoding = function (z) {
      if (
        (typeof z == 'string' && (z = z.toLowerCase()),
        !(
          [
            'hex',
            'utf8',
            'utf-8',
            'ascii',
            'binary',
            'base64',
            'ucs2',
            'ucs-2',
            'utf16le',
            'utf-16le',
            'raw',
          ].indexOf((z + '').toLowerCase()) > -1
        ))
      )
        throw new q(z);
      return (this._writableState.defaultEncoding = z), this;
    }),
    Object.defineProperty(ne.prototype, 'writableBuffer', {
      enumerable: !1,
      get: function () {
        return this._writableState && this._writableState.getBuffer();
      },
    });
  function S(C, z, Y) {
    return !C.objectMode && C.decodeStrings !== !1 && typeof z == 'string' && (z = s.from(z, Y)), z;
  }
  Object.defineProperty(ne.prototype, 'writableHighWaterMark', {
    enumerable: !1,
    get: function () {
      return this._writableState.highWaterMark;
    },
  });
  function o(C, z, Y, G, Q, U) {
    if (!Y) {
      var $ = S(z, G, Q);
      G !== $ && ((Y = !0), (Q = 'buffer'), (G = $));
    }
    var Z = z.objectMode ? 1 : G.length;
    z.length += Z;
    var ae = z.length < z.highWaterMark;
    if ((ae || (z.needDrain = !0), z.writing || z.corked)) {
      var fe = z.lastBufferedRequest;
      (z.lastBufferedRequest = { chunk: G, encoding: Q, isBuf: Y, callback: U, next: null }),
        fe ? (fe.next = z.lastBufferedRequest) : (z.bufferedRequest = z.lastBufferedRequest),
        (z.bufferedRequestCount += 1);
    } else u(C, z, !1, Z, G, Q, U);
    return ae;
  }
  function u(C, z, Y, G, Q, U, $) {
    (z.writelen = G),
      (z.writecb = $),
      (z.writing = !0),
      (z.sync = !0),
      z.destroyed
        ? z.onwrite(new R('write'))
        : Y
          ? C._writev(Q, z.onwrite)
          : C._write(Q, U, z.onwrite),
      (z.sync = !1);
  }
  function l(C, z, Y, G, Q) {
    --z.pendingcb,
      Y
        ? (Je.nextTick(Q, G), Je.nextTick(B, C, z), (C._writableState.errorEmitted = !0), H(C, G))
        : (Q(G), (C._writableState.errorEmitted = !0), H(C, G), B(C, z));
  }
  function d(C) {
    (C.writing = !1), (C.writecb = null), (C.length -= C.writelen), (C.writelen = 0);
  }
  function g(C, z) {
    var Y = C._writableState,
      G = Y.sync,
      Q = Y.writecb;
    if (typeof Q != 'function') throw new E();
    if ((d(Y), z)) l(C, Y, G, z, Q);
    else {
      var U = a(Y) || C.destroyed;
      !U && !Y.corked && !Y.bufferProcessing && Y.bufferedRequest && v(C, Y),
        G ? Je.nextTick(w, C, Y, U, Q) : w(C, Y, U, Q);
    }
  }
  function w(C, z, Y, G) {
    Y || M(C, z), z.pendingcb--, G(), B(C, z);
  }
  function M(C, z) {
    z.length === 0 && z.needDrain && ((z.needDrain = !1), C.emit('drain'));
  }
  function v(C, z) {
    z.bufferProcessing = !0;
    var Y = z.bufferedRequest;
    if (C._writev && Y && Y.next) {
      var G = z.bufferedRequestCount,
        Q = new Array(G),
        U = z.corkedRequestsFree;
      U.entry = Y;
      for (var $ = 0, Z = !0; Y; ) (Q[$] = Y), Y.isBuf || (Z = !1), (Y = Y.next), ($ += 1);
      (Q.allBuffers = Z),
        u(C, z, !0, z.length, Q, '', U.finish),
        z.pendingcb++,
        (z.lastBufferedRequest = null),
        U.next
          ? ((z.corkedRequestsFree = U.next), (U.next = null))
          : (z.corkedRequestsFree = new i(z)),
        (z.bufferedRequestCount = 0);
    } else {
      for (; Y; ) {
        var ae = Y.chunk,
          fe = Y.encoding,
          le = Y.callback,
          Fe = z.objectMode ? 1 : ae.length;
        if ((u(C, z, !1, Fe, ae, fe, le), (Y = Y.next), z.bufferedRequestCount--, z.writing)) break;
      }
      Y === null && (z.lastBufferedRequest = null);
    }
    (z.bufferedRequest = Y), (z.bufferProcessing = !1);
  }
  (ne.prototype._write = function (C, z, Y) {
    Y(new A('_write()'));
  }),
    (ne.prototype._writev = null),
    (ne.prototype.end = function (C, z, Y) {
      var G = this._writableState;
      return (
        typeof C == 'function'
          ? ((Y = C), (C = null), (z = null))
          : typeof z == 'function' && ((Y = z), (z = null)),
        C != null && this.write(C, z),
        G.corked && ((G.corked = 1), this.uncork()),
        G.ending || F(this, G, Y),
        this
      );
    }),
    Object.defineProperty(ne.prototype, 'writableLength', {
      enumerable: !1,
      get: function () {
        return this._writableState.length;
      },
    });
  function a(C) {
    return C.ending && C.length === 0 && C.bufferedRequest === null && !C.finished && !C.writing;
  }
  function b(C, z) {
    C._final(function (Y) {
      z.pendingcb--, Y && H(C, Y), (z.prefinished = !0), C.emit('prefinish'), B(C, z);
    });
  }
  function k(C, z) {
    !z.prefinished &&
      !z.finalCalled &&
      (typeof C._final == 'function' && !z.destroyed
        ? (z.pendingcb++, (z.finalCalled = !0), Je.nextTick(b, C, z))
        : ((z.prefinished = !0), C.emit('prefinish')));
  }
  function B(C, z) {
    var Y = a(z);
    if (Y && (k(C, z), z.pendingcb === 0 && ((z.finished = !0), C.emit('finish'), z.autoDestroy))) {
      var G = C._readableState;
      (!G || (G.autoDestroy && G.endEmitted)) && C.destroy();
    }
    return Y;
  }
  function F(C, z, Y) {
    (z.ending = !0),
      B(C, z),
      Y && (z.finished ? Je.nextTick(Y) : C.once('finish', Y)),
      (z.ended = !0),
      (C.writable = !1);
  }
  function P(C, z, Y) {
    var G = C.entry;
    for (C.entry = null; G; ) {
      var Q = G.callback;
      z.pendingcb--, Q(Y), (G = G.next);
    }
    z.corkedRequestsFree.next = C;
  }
  return (
    Object.defineProperty(ne.prototype, 'destroyed', {
      enumerable: !1,
      get: function () {
        return this._writableState === void 0 ? !1 : this._writableState.destroyed;
      },
      set: function (z) {
        this._writableState && (this._writableState.destroyed = z);
      },
    }),
    (ne.prototype.destroy = h.destroy),
    (ne.prototype._undestroy = h.undestroy),
    (ne.prototype._destroy = function (C, z) {
      z(C);
    }),
    Xh
  );
}
var Qh, rb;
function ds() {
  if (rb) return Qh;
  rb = 1;
  var i =
    Object.keys ||
    function (y) {
      var p = [];
      for (var m in y) p.push(m);
      return p;
    };
  Qh = c;
  var e = Q1(),
    t = J1();
  dt(c, e);
  for (var r = i(t.prototype), s = 0; s < r.length; s++) {
    var n = r[s];
    c.prototype[n] || (c.prototype[n] = t.prototype[n]);
  }
  function c(y) {
    if (!(this instanceof c)) return new c(y);
    e.call(this, y),
      t.call(this, y),
      (this.allowHalfOpen = !0),
      y &&
        (y.readable === !1 && (this.readable = !1),
        y.writable === !1 && (this.writable = !1),
        y.allowHalfOpen === !1 && ((this.allowHalfOpen = !1), this.once('end', f)));
  }
  Object.defineProperty(c.prototype, 'writableHighWaterMark', {
    enumerable: !1,
    get: function () {
      return this._writableState.highWaterMark;
    },
  }),
    Object.defineProperty(c.prototype, 'writableBuffer', {
      enumerable: !1,
      get: function () {
        return this._writableState && this._writableState.getBuffer();
      },
    }),
    Object.defineProperty(c.prototype, 'writableLength', {
      enumerable: !1,
      get: function () {
        return this._writableState.length;
      },
    });
  function f() {
    this._writableState.ended || Je.nextTick(h, this);
  }
  function h(y) {
    y.end();
  }
  return (
    Object.defineProperty(c.prototype, 'destroyed', {
      enumerable: !1,
      get: function () {
        return this._readableState === void 0 || this._writableState === void 0
          ? !1
          : this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function (p) {
        this._readableState === void 0 ||
          this._writableState === void 0 ||
          ((this._readableState.destroyed = p), (this._writableState.destroyed = p));
      },
    }),
    Qh
  );
}
var _a = {},
  X1 = At.Buffer,
  ib =
    X1.isEncoding ||
    function (i) {
      switch (((i = '' + i), i && i.toLowerCase())) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
        case 'raw':
          return !0;
        default:
          return !1;
      }
    };
function YA(i) {
  if (!i) return 'utf8';
  for (var e; ; )
    switch (i) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return i;
      default:
        if (e) return;
        (i = ('' + i).toLowerCase()), (e = !0);
    }
}
function ZA(i) {
  var e = YA(i);
  if (typeof e != 'string' && (X1.isEncoding === ib || !ib(i)))
    throw new Error('Unknown encoding: ' + i);
  return e || i;
}
_a.StringDecoder = Zu;
function Zu(i) {
  this.encoding = ZA(i);
  var e;
  switch (this.encoding) {
    case 'utf16le':
      (this.text = rE), (this.end = iE), (e = 4);
      break;
    case 'utf8':
      (this.fillLast = QA), (e = 4);
      break;
    case 'base64':
      (this.text = nE), (this.end = oE), (e = 3);
      break;
    default:
      (this.write = sE), (this.end = aE);
      return;
  }
  (this.lastNeed = 0), (this.lastTotal = 0), (this.lastChar = X1.allocUnsafe(e));
}
Zu.prototype.write = function (i) {
  if (i.length === 0) return '';
  var e, t;
  if (this.lastNeed) {
    if (((e = this.fillLast(i)), e === void 0)) return '';
    (t = this.lastNeed), (this.lastNeed = 0);
  } else t = 0;
  return t < i.length ? (e ? e + this.text(i, t) : this.text(i, t)) : e || '';
};
Zu.prototype.end = tE;
Zu.prototype.text = eE;
Zu.prototype.fillLast = function (i) {
  if (this.lastNeed <= i.length)
    return (
      i.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed),
      this.lastChar.toString(this.encoding, 0, this.lastTotal)
    );
  i.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, i.length), (this.lastNeed -= i.length);
};
function ed(i) {
  return i <= 127
    ? 0
    : i >> 5 === 6
      ? 2
      : i >> 4 === 14
        ? 3
        : i >> 3 === 30
          ? 4
          : i >> 6 === 2
            ? -1
            : -2;
}
function JA(i, e, t) {
  var r = e.length - 1;
  if (r < t) return 0;
  var s = ed(e[r]);
  return s >= 0
    ? (s > 0 && (i.lastNeed = s - 1), s)
    : --r < t || s === -2
      ? 0
      : ((s = ed(e[r])),
        s >= 0
          ? (s > 0 && (i.lastNeed = s - 2), s)
          : --r < t || s === -2
            ? 0
            : ((s = ed(e[r])),
              s >= 0 ? (s > 0 && (s === 2 ? (s = 0) : (i.lastNeed = s - 3)), s) : 0));
}
function XA(i, e, t) {
  if ((e[0] & 192) !== 128) return (i.lastNeed = 0), '�';
  if (i.lastNeed > 1 && e.length > 1) {
    if ((e[1] & 192) !== 128) return (i.lastNeed = 1), '�';
    if (i.lastNeed > 2 && e.length > 2 && (e[2] & 192) !== 128) return (i.lastNeed = 2), '�';
  }
}
function QA(i) {
  var e = this.lastTotal - this.lastNeed,
    t = XA(this, i);
  if (t !== void 0) return t;
  if (this.lastNeed <= i.length)
    return (
      i.copy(this.lastChar, e, 0, this.lastNeed),
      this.lastChar.toString(this.encoding, 0, this.lastTotal)
    );
  i.copy(this.lastChar, e, 0, i.length), (this.lastNeed -= i.length);
}
function eE(i, e) {
  var t = JA(this, i, e);
  if (!this.lastNeed) return i.toString('utf8', e);
  this.lastTotal = t;
  var r = i.length - (t - this.lastNeed);
  return i.copy(this.lastChar, 0, r), i.toString('utf8', e, r);
}
function tE(i) {
  var e = i && i.length ? this.write(i) : '';
  return this.lastNeed ? e + '�' : e;
}
function rE(i, e) {
  if ((i.length - e) % 2 === 0) {
    var t = i.toString('utf16le', e);
    if (t) {
      var r = t.charCodeAt(t.length - 1);
      if (r >= 55296 && r <= 56319)
        return (
          (this.lastNeed = 2),
          (this.lastTotal = 4),
          (this.lastChar[0] = i[i.length - 2]),
          (this.lastChar[1] = i[i.length - 1]),
          t.slice(0, -1)
        );
    }
    return t;
  }
  return (
    (this.lastNeed = 1),
    (this.lastTotal = 2),
    (this.lastChar[0] = i[i.length - 1]),
    i.toString('utf16le', e, i.length - 1)
  );
}
function iE(i) {
  var e = i && i.length ? this.write(i) : '';
  if (this.lastNeed) {
    var t = this.lastTotal - this.lastNeed;
    return e + this.lastChar.toString('utf16le', 0, t);
  }
  return e;
}
function nE(i, e) {
  var t = (i.length - e) % 3;
  return t === 0
    ? i.toString('base64', e)
    : ((this.lastNeed = 3 - t),
      (this.lastTotal = 3),
      t === 1
        ? (this.lastChar[0] = i[i.length - 1])
        : ((this.lastChar[0] = i[i.length - 2]), (this.lastChar[1] = i[i.length - 1])),
      i.toString('base64', e, i.length - t));
}
function oE(i) {
  var e = i && i.length ? this.write(i) : '';
  return this.lastNeed ? e + this.lastChar.toString('base64', 0, 3 - this.lastNeed) : e;
}
function sE(i) {
  return i.toString(this.encoding);
}
function aE(i) {
  return i && i.length ? this.write(i) : '';
}
var nb = Is.codes.ERR_STREAM_PREMATURE_CLOSE;
function uE(i) {
  var e = !1;
  return function () {
    if (!e) {
      e = !0;
      for (var t = arguments.length, r = new Array(t), s = 0; s < t; s++) r[s] = arguments[s];
      i.apply(this, r);
    }
  };
}
function cE() {}
function fE(i) {
  return i.setHeader && typeof i.abort == 'function';
}
function b6(i, e, t) {
  if (typeof e == 'function') return b6(i, null, e);
  e || (e = {}), (t = uE(t || cE));
  var r = e.readable || (e.readable !== !1 && i.readable),
    s = e.writable || (e.writable !== !1 && i.writable),
    n = function () {
      i.writable || f();
    },
    c = i._writableState && i._writableState.finished,
    f = function () {
      (s = !1), (c = !0), r || t.call(i);
    },
    h = i._readableState && i._readableState.endEmitted,
    y = function () {
      (r = !1), (h = !0), s || t.call(i);
    },
    p = function (E) {
      t.call(i, E);
    },
    m = function () {
      var E;
      if (r && !h)
        return (!i._readableState || !i._readableState.ended) && (E = new nb()), t.call(i, E);
      if (s && !c)
        return (!i._writableState || !i._writableState.ended) && (E = new nb()), t.call(i, E);
    },
    _ = function () {
      i.req.on('finish', f);
    };
  return (
    fE(i)
      ? (i.on('complete', f), i.on('abort', m), i.req ? _() : i.on('request', _))
      : s && !i._writableState && (i.on('end', n), i.on('close', n)),
    i.on('end', y),
    i.on('finish', f),
    e.error !== !1 && i.on('error', p),
    i.on('close', m),
    function () {
      i.removeListener('complete', f),
        i.removeListener('abort', m),
        i.removeListener('request', _),
        i.req && i.req.removeListener('finish', f),
        i.removeListener('end', n),
        i.removeListener('close', n),
        i.removeListener('finish', f),
        i.removeListener('end', y),
        i.removeListener('error', p),
        i.removeListener('close', m);
    }
  );
}
var Ml = b6,
  td,
  ob;
function lE() {
  if (ob) return td;
  ob = 1;
  var i;
  function e(L, D, q) {
    return (
      D in L
        ? Object.defineProperty(L, D, { value: q, enumerable: !0, configurable: !0, writable: !0 })
        : (L[D] = q),
      L
    );
  }
  var t = Ml,
    r = Symbol('lastResolve'),
    s = Symbol('lastReject'),
    n = Symbol('error'),
    c = Symbol('ended'),
    f = Symbol('lastPromise'),
    h = Symbol('handlePromise'),
    y = Symbol('stream');
  function p(L, D) {
    return { value: L, done: D };
  }
  function m(L) {
    var D = L[r];
    if (D !== null) {
      var q = L[y].read();
      q !== null && ((L[f] = null), (L[r] = null), (L[s] = null), D(p(q, !1)));
    }
  }
  function _(L) {
    Je.nextTick(m, L);
  }
  function A(L, D) {
    return function (q, H) {
      L.then(function () {
        if (D[c]) {
          q(p(void 0, !0));
          return;
        }
        D[h](q, H);
      }, H);
    };
  }
  var E = Object.getPrototypeOf(function () {}),
    I = Object.setPrototypeOf(
      ((i = {
        get stream() {
          return this[y];
        },
        next: function () {
          var D = this,
            q = this[n];
          if (q !== null) return Promise.reject(q);
          if (this[c]) return Promise.resolve(p(void 0, !0));
          if (this[y].destroyed)
            return new Promise(function (ue, ne) {
              Je.nextTick(function () {
                D[n] ? ne(D[n]) : ue(p(void 0, !0));
              });
            });
          var H = this[f],
            V;
          if (H) V = new Promise(A(H, this));
          else {
            var te = this[y].read();
            if (te !== null) return Promise.resolve(p(te, !1));
            V = new Promise(this[h]);
          }
          return (this[f] = V), V;
        },
      }),
      e(i, Symbol.asyncIterator, function () {
        return this;
      }),
      e(i, 'return', function () {
        var D = this;
        return new Promise(function (q, H) {
          D[y].destroy(null, function (V) {
            if (V) {
              H(V);
              return;
            }
            q(p(void 0, !0));
          });
        });
      }),
      i),
      E
    ),
    R = function (D) {
      var q,
        H = Object.create(
          I,
          ((q = {}),
          e(q, y, { value: D, writable: !0 }),
          e(q, r, { value: null, writable: !0 }),
          e(q, s, { value: null, writable: !0 }),
          e(q, n, { value: null, writable: !0 }),
          e(q, c, { value: D._readableState.endEmitted, writable: !0 }),
          e(q, h, {
            value: function (te, ue) {
              var ne = H[y].read();
              ne
                ? ((H[f] = null), (H[r] = null), (H[s] = null), te(p(ne, !1)))
                : ((H[r] = te), (H[s] = ue));
            },
            writable: !0,
          }),
          q)
        );
      return (
        (H[f] = null),
        t(D, function (V) {
          if (V && V.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
            var te = H[s];
            te !== null && ((H[f] = null), (H[r] = null), (H[s] = null), te(V)), (H[n] = V);
            return;
          }
          var ue = H[r];
          ue !== null && ((H[f] = null), (H[r] = null), (H[s] = null), ue(p(void 0, !0))),
            (H[c] = !0);
        }),
        D.on('readable', _.bind(null, H)),
        H
      );
    };
  return (td = R), td;
}
var rd, sb;
function hE() {
  return (
    sb ||
      ((sb = 1),
      (rd = function () {
        throw new Error('Readable.from is not available in the browser');
      })),
    rd
  );
}
var id, ab;
function Q1() {
  if (ab) return id;
  (ab = 1), (id = X);
  var i;
  (X.ReadableState = ne), za.EventEmitter;
  var e = function ($, Z) {
      return $.listeners(Z).length;
    },
    t = K2,
    r = ai.Buffer,
    s = globalThis.Uint8Array || function () {};
  function n(U) {
    return r.from(U);
  }
  function c(U) {
    return r.isBuffer(U) || U instanceof s;
  }
  var f = Cn,
    h;
  f && f.debuglog ? (h = f.debuglog('stream')) : (h = function () {});
  var y = $A(),
    p = d6,
    m = y6,
    _ = m.getHighWaterMark,
    A = Is.codes,
    E = A.ERR_INVALID_ARG_TYPE,
    I = A.ERR_STREAM_PUSH_AFTER_EOF,
    R = A.ERR_METHOD_NOT_IMPLEMENTED,
    L = A.ERR_STREAM_UNSHIFT_AFTER_END_EVENT,
    D,
    q,
    H;
  dt(X, t);
  var V = p.errorOrDestroy,
    te = ['error', 'close', 'destroy', 'pause', 'resume'];
  function ue(U, $, Z) {
    if (typeof U.prependListener == 'function') return U.prependListener($, Z);
    !U._events || !U._events[$]
      ? U.on($, Z)
      : Array.isArray(U._events[$])
        ? U._events[$].unshift(Z)
        : (U._events[$] = [Z, U._events[$]]);
  }
  function ne(U, $, Z) {
    (i = i || ds()),
      (U = U || {}),
      typeof Z != 'boolean' && (Z = $ instanceof i),
      (this.objectMode = !!U.objectMode),
      Z && (this.objectMode = this.objectMode || !!U.readableObjectMode),
      (this.highWaterMark = _(this, U, 'readableHighWaterMark', Z)),
      (this.buffer = new y()),
      (this.length = 0),
      (this.pipes = null),
      (this.pipesCount = 0),
      (this.flowing = null),
      (this.ended = !1),
      (this.endEmitted = !1),
      (this.reading = !1),
      (this.sync = !0),
      (this.needReadable = !1),
      (this.emittedReadable = !1),
      (this.readableListening = !1),
      (this.resumeScheduled = !1),
      (this.paused = !0),
      (this.emitClose = U.emitClose !== !1),
      (this.autoDestroy = !!U.autoDestroy),
      (this.destroyed = !1),
      (this.defaultEncoding = U.defaultEncoding || 'utf8'),
      (this.awaitDrain = 0),
      (this.readingMore = !1),
      (this.decoder = null),
      (this.encoding = null),
      U.encoding &&
        (D || (D = _a.StringDecoder),
        (this.decoder = new D(U.encoding)),
        (this.encoding = U.encoding));
  }
  function X(U) {
    if (((i = i || ds()), !(this instanceof X))) return new X(U);
    var $ = this instanceof i;
    (this._readableState = new ne(U, this, $)),
      (this.readable = !0),
      U &&
        (typeof U.read == 'function' && (this._read = U.read),
        typeof U.destroy == 'function' && (this._destroy = U.destroy)),
      t.call(this);
  }
  Object.defineProperty(X.prototype, 'destroyed', {
    enumerable: !1,
    get: function () {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function ($) {
      this._readableState && (this._readableState.destroyed = $);
    },
  }),
    (X.prototype.destroy = p.destroy),
    (X.prototype._undestroy = p.undestroy),
    (X.prototype._destroy = function (U, $) {
      $(U);
    }),
    (X.prototype.push = function (U, $) {
      var Z = this._readableState,
        ae;
      return (
        Z.objectMode
          ? (ae = !0)
          : typeof U == 'string' &&
            (($ = $ || Z.defaultEncoding),
            $ !== Z.encoding && ((U = r.from(U, $)), ($ = '')),
            (ae = !0)),
        Oe(this, U, $, !1, ae)
      );
    }),
    (X.prototype.unshift = function (U) {
      return Oe(this, U, null, !0, !1);
    });
  function Oe(U, $, Z, ae, fe) {
    h('readableAddChunk', $);
    var le = U._readableState;
    if ($ === null) (le.reading = !1), g(U, le);
    else {
      var Fe;
      if ((fe || (Fe = o(le, $)), Fe)) V(U, Fe);
      else if (le.objectMode || ($ && $.length > 0))
        if (
          (typeof $ != 'string' &&
            !le.objectMode &&
            Object.getPrototypeOf($) !== r.prototype &&
            ($ = n($)),
          ae)
        )
          le.endEmitted ? V(U, new L()) : S(U, le, $, !0);
        else if (le.ended) V(U, new I());
        else {
          if (le.destroyed) return !1;
          (le.reading = !1),
            le.decoder && !Z
              ? (($ = le.decoder.write($)),
                le.objectMode || $.length !== 0 ? S(U, le, $, !1) : v(U, le))
              : S(U, le, $, !1);
        }
      else ae || ((le.reading = !1), v(U, le));
    }
    return !le.ended && (le.length < le.highWaterMark || le.length === 0);
  }
  function S(U, $, Z, ae) {
    $.flowing && $.length === 0 && !$.sync
      ? (($.awaitDrain = 0), U.emit('data', Z))
      : (($.length += $.objectMode ? 1 : Z.length),
        ae ? $.buffer.unshift(Z) : $.buffer.push(Z),
        $.needReadable && w(U)),
      v(U, $);
  }
  function o(U, $) {
    var Z;
    return (
      !c($) &&
        typeof $ != 'string' &&
        $ !== void 0 &&
        !U.objectMode &&
        (Z = new E('chunk', ['string', 'Buffer', 'Uint8Array'], $)),
      Z
    );
  }
  (X.prototype.isPaused = function () {
    return this._readableState.flowing === !1;
  }),
    (X.prototype.setEncoding = function (U) {
      D || (D = _a.StringDecoder);
      var $ = new D(U);
      (this._readableState.decoder = $),
        (this._readableState.encoding = this._readableState.decoder.encoding);
      for (var Z = this._readableState.buffer.head, ae = ''; Z !== null; )
        (ae += $.write(Z.data)), (Z = Z.next);
      return (
        this._readableState.buffer.clear(),
        ae !== '' && this._readableState.buffer.push(ae),
        (this._readableState.length = ae.length),
        this
      );
    });
  var u = 1073741824;
  function l(U) {
    return (
      U >= u
        ? (U = u)
        : (U--,
          (U |= U >>> 1),
          (U |= U >>> 2),
          (U |= U >>> 4),
          (U |= U >>> 8),
          (U |= U >>> 16),
          U++),
      U
    );
  }
  function d(U, $) {
    return U <= 0 || ($.length === 0 && $.ended)
      ? 0
      : $.objectMode
        ? 1
        : U !== U
          ? $.flowing && $.length
            ? $.buffer.head.data.length
            : $.length
          : (U > $.highWaterMark && ($.highWaterMark = l(U)),
            U <= $.length ? U : $.ended ? $.length : (($.needReadable = !0), 0));
  }
  X.prototype.read = function (U) {
    h('read', U), (U = parseInt(U, 10));
    var $ = this._readableState,
      Z = U;
    if (
      (U !== 0 && ($.emittedReadable = !1),
      U === 0 &&
        $.needReadable &&
        (($.highWaterMark !== 0 ? $.length >= $.highWaterMark : $.length > 0) || $.ended))
    )
      return (
        h('read: emitReadable', $.length, $.ended),
        $.length === 0 && $.ended ? Y(this) : w(this),
        null
      );
    if (((U = d(U, $)), U === 0 && $.ended)) return $.length === 0 && Y(this), null;
    var ae = $.needReadable;
    h('need readable', ae),
      ($.length === 0 || $.length - U < $.highWaterMark) &&
        ((ae = !0), h('length less than watermark', ae)),
      $.ended || $.reading
        ? ((ae = !1), h('reading or ended', ae))
        : ae &&
          (h('do read'),
          ($.reading = !0),
          ($.sync = !0),
          $.length === 0 && ($.needReadable = !0),
          this._read($.highWaterMark),
          ($.sync = !1),
          $.reading || (U = d(Z, $)));
    var fe;
    return (
      U > 0 ? (fe = z(U, $)) : (fe = null),
      fe === null
        ? (($.needReadable = $.length <= $.highWaterMark), (U = 0))
        : (($.length -= U), ($.awaitDrain = 0)),
      $.length === 0 && ($.ended || ($.needReadable = !0), Z !== U && $.ended && Y(this)),
      fe !== null && this.emit('data', fe),
      fe
    );
  };
  function g(U, $) {
    if ((h('onEofChunk'), !$.ended)) {
      if ($.decoder) {
        var Z = $.decoder.end();
        Z && Z.length && ($.buffer.push(Z), ($.length += $.objectMode ? 1 : Z.length));
      }
      ($.ended = !0),
        $.sync
          ? w(U)
          : (($.needReadable = !1), $.emittedReadable || (($.emittedReadable = !0), M(U)));
    }
  }
  function w(U) {
    var $ = U._readableState;
    h('emitReadable', $.needReadable, $.emittedReadable),
      ($.needReadable = !1),
      $.emittedReadable ||
        (h('emitReadable', $.flowing), ($.emittedReadable = !0), Je.nextTick(M, U));
  }
  function M(U) {
    var $ = U._readableState;
    h('emitReadable_', $.destroyed, $.length, $.ended),
      !$.destroyed && ($.length || $.ended) && (U.emit('readable'), ($.emittedReadable = !1)),
      ($.needReadable = !$.flowing && !$.ended && $.length <= $.highWaterMark),
      C(U);
  }
  function v(U, $) {
    $.readingMore || (($.readingMore = !0), Je.nextTick(a, U, $));
  }
  function a(U, $) {
    for (
      ;
      !$.reading && !$.ended && ($.length < $.highWaterMark || ($.flowing && $.length === 0));

    ) {
      var Z = $.length;
      if ((h('maybeReadMore read 0'), U.read(0), Z === $.length)) break;
    }
    $.readingMore = !1;
  }
  (X.prototype._read = function (U) {
    V(this, new R('_read()'));
  }),
    (X.prototype.pipe = function (U, $) {
      var Z = this,
        ae = this._readableState;
      switch (ae.pipesCount) {
        case 0:
          ae.pipes = U;
          break;
        case 1:
          ae.pipes = [ae.pipes, U];
          break;
        default:
          ae.pipes.push(U);
          break;
      }
      (ae.pipesCount += 1), h('pipe count=%d opts=%j', ae.pipesCount, $);
      var fe = (!$ || $.end !== !1) && U !== Je.stdout && U !== Je.stderr,
        le = fe ? be : Ke;
      ae.endEmitted ? Je.nextTick(le) : Z.once('end', le), U.on('unpipe', Fe);
      function Fe(K, O) {
        h('onunpipe'), K === Z && O && O.hasUnpiped === !1 && ((O.hasUnpiped = !0), me());
      }
      function be() {
        h('onend'), U.end();
      }
      var oe = b(Z);
      U.on('drain', oe);
      var rt = !1;
      function me() {
        h('cleanup'),
          U.removeListener('close', ce),
          U.removeListener('finish', he),
          U.removeListener('drain', oe),
          U.removeListener('error', ge),
          U.removeListener('unpipe', Fe),
          Z.removeListener('end', be),
          Z.removeListener('end', Ke),
          Z.removeListener('data', re),
          (rt = !0),
          ae.awaitDrain && (!U._writableState || U._writableState.needDrain) && oe();
      }
      Z.on('data', re);
      function re(K) {
        h('ondata');
        var O = U.write(K);
        h('dest.write', O),
          O === !1 &&
            (((ae.pipesCount === 1 && ae.pipes === U) ||
              (ae.pipesCount > 1 && Q(ae.pipes, U) !== -1)) &&
              !rt &&
              (h('false write response, pause', ae.awaitDrain), ae.awaitDrain++),
            Z.pause());
      }
      function ge(K) {
        h('onerror', K), Ke(), U.removeListener('error', ge), e(U, 'error') === 0 && V(U, K);
      }
      ue(U, 'error', ge);
      function ce() {
        U.removeListener('finish', he), Ke();
      }
      U.once('close', ce);
      function he() {
        h('onfinish'), U.removeListener('close', ce), Ke();
      }
      U.once('finish', he);
      function Ke() {
        h('unpipe'), Z.unpipe(U);
      }
      return U.emit('pipe', Z), ae.flowing || (h('pipe resume'), Z.resume()), U;
    });
  function b(U) {
    return function () {
      var Z = U._readableState;
      h('pipeOnDrain', Z.awaitDrain),
        Z.awaitDrain && Z.awaitDrain--,
        Z.awaitDrain === 0 && e(U, 'data') && ((Z.flowing = !0), C(U));
    };
  }
  (X.prototype.unpipe = function (U) {
    var $ = this._readableState,
      Z = { hasUnpiped: !1 };
    if ($.pipesCount === 0) return this;
    if ($.pipesCount === 1)
      return U && U !== $.pipes
        ? this
        : (U || (U = $.pipes),
          ($.pipes = null),
          ($.pipesCount = 0),
          ($.flowing = !1),
          U && U.emit('unpipe', this, Z),
          this);
    if (!U) {
      var ae = $.pipes,
        fe = $.pipesCount;
      ($.pipes = null), ($.pipesCount = 0), ($.flowing = !1);
      for (var le = 0; le < fe; le++) ae[le].emit('unpipe', this, { hasUnpiped: !1 });
      return this;
    }
    var Fe = Q($.pipes, U);
    return Fe === -1
      ? this
      : ($.pipes.splice(Fe, 1),
        ($.pipesCount -= 1),
        $.pipesCount === 1 && ($.pipes = $.pipes[0]),
        U.emit('unpipe', this, Z),
        this);
  }),
    (X.prototype.on = function (U, $) {
      var Z = t.prototype.on.call(this, U, $),
        ae = this._readableState;
      return (
        U === 'data'
          ? ((ae.readableListening = this.listenerCount('readable') > 0),
            ae.flowing !== !1 && this.resume())
          : U === 'readable' &&
            !ae.endEmitted &&
            !ae.readableListening &&
            ((ae.readableListening = ae.needReadable = !0),
            (ae.flowing = !1),
            (ae.emittedReadable = !1),
            h('on readable', ae.length, ae.reading),
            ae.length ? w(this) : ae.reading || Je.nextTick(B, this)),
        Z
      );
    }),
    (X.prototype.addListener = X.prototype.on),
    (X.prototype.removeListener = function (U, $) {
      var Z = t.prototype.removeListener.call(this, U, $);
      return U === 'readable' && Je.nextTick(k, this), Z;
    }),
    (X.prototype.removeAllListeners = function (U) {
      var $ = t.prototype.removeAllListeners.apply(this, arguments);
      return (U === 'readable' || U === void 0) && Je.nextTick(k, this), $;
    });
  function k(U) {
    var $ = U._readableState;
    ($.readableListening = U.listenerCount('readable') > 0),
      $.resumeScheduled && !$.paused ? ($.flowing = !0) : U.listenerCount('data') > 0 && U.resume();
  }
  function B(U) {
    h('readable nexttick read 0'), U.read(0);
  }
  X.prototype.resume = function () {
    var U = this._readableState;
    return (
      U.flowing || (h('resume'), (U.flowing = !U.readableListening), F(this, U)),
      (U.paused = !1),
      this
    );
  };
  function F(U, $) {
    $.resumeScheduled || (($.resumeScheduled = !0), Je.nextTick(P, U, $));
  }
  function P(U, $) {
    h('resume', $.reading),
      $.reading || U.read(0),
      ($.resumeScheduled = !1),
      U.emit('resume'),
      C(U),
      $.flowing && !$.reading && U.read(0);
  }
  X.prototype.pause = function () {
    return (
      h('call pause flowing=%j', this._readableState.flowing),
      this._readableState.flowing !== !1 &&
        (h('pause'), (this._readableState.flowing = !1), this.emit('pause')),
      (this._readableState.paused = !0),
      this
    );
  };
  function C(U) {
    var $ = U._readableState;
    for (h('flow', $.flowing); $.flowing && U.read() !== null; );
  }
  (X.prototype.wrap = function (U) {
    var $ = this,
      Z = this._readableState,
      ae = !1;
    U.on('end', function () {
      if ((h('wrapped end'), Z.decoder && !Z.ended)) {
        var Fe = Z.decoder.end();
        Fe && Fe.length && $.push(Fe);
      }
      $.push(null);
    }),
      U.on('data', function (Fe) {
        if (
          (h('wrapped data'),
          Z.decoder && (Fe = Z.decoder.write(Fe)),
          !(Z.objectMode && Fe == null) && !(!Z.objectMode && (!Fe || !Fe.length)))
        ) {
          var be = $.push(Fe);
          be || ((ae = !0), U.pause());
        }
      });
    for (var fe in U)
      this[fe] === void 0 &&
        typeof U[fe] == 'function' &&
        (this[fe] = (function (be) {
          return function () {
            return U[be].apply(U, arguments);
          };
        })(fe));
    for (var le = 0; le < te.length; le++) U.on(te[le], this.emit.bind(this, te[le]));
    return (
      (this._read = function (Fe) {
        h('wrapped _read', Fe), ae && ((ae = !1), U.resume());
      }),
      this
    );
  }),
    typeof Symbol == 'function' &&
      (X.prototype[Symbol.asyncIterator] = function () {
        return q === void 0 && (q = lE()), q(this);
      }),
    Object.defineProperty(X.prototype, 'readableHighWaterMark', {
      enumerable: !1,
      get: function () {
        return this._readableState.highWaterMark;
      },
    }),
    Object.defineProperty(X.prototype, 'readableBuffer', {
      enumerable: !1,
      get: function () {
        return this._readableState && this._readableState.buffer;
      },
    }),
    Object.defineProperty(X.prototype, 'readableFlowing', {
      enumerable: !1,
      get: function () {
        return this._readableState.flowing;
      },
      set: function ($) {
        this._readableState && (this._readableState.flowing = $);
      },
    }),
    (X._fromList = z),
    Object.defineProperty(X.prototype, 'readableLength', {
      enumerable: !1,
      get: function () {
        return this._readableState.length;
      },
    });
  function z(U, $) {
    if ($.length === 0) return null;
    var Z;
    return (
      $.objectMode
        ? (Z = $.buffer.shift())
        : !U || U >= $.length
          ? ($.decoder
              ? (Z = $.buffer.join(''))
              : $.buffer.length === 1
                ? (Z = $.buffer.first())
                : (Z = $.buffer.concat($.length)),
            $.buffer.clear())
          : (Z = $.buffer.consume(U, $.decoder)),
      Z
    );
  }
  function Y(U) {
    var $ = U._readableState;
    h('endReadable', $.endEmitted), $.endEmitted || (($.ended = !0), Je.nextTick(G, $, U));
  }
  function G(U, $) {
    if (
      (h('endReadableNT', U.endEmitted, U.length),
      !U.endEmitted &&
        U.length === 0 &&
        ((U.endEmitted = !0), ($.readable = !1), $.emit('end'), U.autoDestroy))
    ) {
      var Z = $._writableState;
      (!Z || (Z.autoDestroy && Z.finished)) && $.destroy();
    }
  }
  typeof Symbol == 'function' &&
    (X.from = function (U, $) {
      return H === void 0 && (H = hE()), H(X, U, $);
    });
  function Q(U, $) {
    for (var Z = 0, ae = U.length; Z < ae; Z++) if (U[Z] === $) return Z;
    return -1;
  }
  return id;
}
var ey = oo,
  Al = Is.codes,
  dE = Al.ERR_METHOD_NOT_IMPLEMENTED,
  pE = Al.ERR_MULTIPLE_CALLBACK,
  yE = Al.ERR_TRANSFORM_ALREADY_TRANSFORMING,
  gE = Al.ERR_TRANSFORM_WITH_LENGTH_0,
  El = ds();
dt(oo, El);
function bE(i, e) {
  var t = this._transformState;
  t.transforming = !1;
  var r = t.writecb;
  if (r === null) return this.emit('error', new pE());
  (t.writechunk = null), (t.writecb = null), e != null && this.push(e), r(i);
  var s = this._readableState;
  (s.reading = !1), (s.needReadable || s.length < s.highWaterMark) && this._read(s.highWaterMark);
}
function oo(i) {
  if (!(this instanceof oo)) return new oo(i);
  El.call(this, i),
    (this._transformState = {
      afterTransform: bE.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null,
    }),
    (this._readableState.needReadable = !0),
    (this._readableState.sync = !1),
    i &&
      (typeof i.transform == 'function' && (this._transform = i.transform),
      typeof i.flush == 'function' && (this._flush = i.flush)),
    this.on('prefinish', vE);
}
function vE() {
  var i = this;
  typeof this._flush == 'function' && !this._readableState.destroyed
    ? this._flush(function (e, t) {
        ub(i, e, t);
      })
    : ub(this, null, null);
}
oo.prototype.push = function (i, e) {
  return (this._transformState.needTransform = !1), El.prototype.push.call(this, i, e);
};
oo.prototype._transform = function (i, e, t) {
  t(new dE('_transform()'));
};
oo.prototype._write = function (i, e, t) {
  var r = this._transformState;
  if (((r.writecb = t), (r.writechunk = i), (r.writeencoding = e), !r.transforming)) {
    var s = this._readableState;
    (r.needTransform || s.needReadable || s.length < s.highWaterMark) &&
      this._read(s.highWaterMark);
  }
};
oo.prototype._read = function (i) {
  var e = this._transformState;
  e.writechunk !== null && !e.transforming
    ? ((e.transforming = !0), this._transform(e.writechunk, e.writeencoding, e.afterTransform))
    : (e.needTransform = !0);
};
oo.prototype._destroy = function (i, e) {
  El.prototype._destroy.call(this, i, function (t) {
    e(t);
  });
};
function ub(i, e, t) {
  if (e) return i.emit('error', e);
  if ((t != null && i.push(t), i._writableState.length)) throw new gE();
  if (i._transformState.transforming) throw new yE();
  return i.push(null);
}
var v6 = Pu,
  m6 = ey;
dt(Pu, m6);
function Pu(i) {
  if (!(this instanceof Pu)) return new Pu(i);
  m6.call(this, i);
}
Pu.prototype._transform = function (i, e, t) {
  t(null, i);
};
var nd;
function mE(i) {
  var e = !1;
  return function () {
    e || ((e = !0), i.apply(void 0, arguments));
  };
}
var w6 = Is.codes,
  wE = w6.ERR_MISSING_ARGS,
  _E = w6.ERR_STREAM_DESTROYED;
function cb(i) {
  if (i) throw i;
}
function SE(i) {
  return i.setHeader && typeof i.abort == 'function';
}
function ME(i, e, t, r) {
  r = mE(r);
  var s = !1;
  i.on('close', function () {
    s = !0;
  }),
    nd === void 0 && (nd = Ml),
    nd(i, { readable: e, writable: t }, function (c) {
      if (c) return r(c);
      (s = !0), r();
    });
  var n = !1;
  return function (c) {
    if (!s && !n) {
      if (((n = !0), SE(i))) return i.abort();
      if (typeof i.destroy == 'function') return i.destroy();
      r(c || new _E('pipe'));
    }
  };
}
function fb(i) {
  i();
}
function AE(i, e) {
  return i.pipe(e);
}
function EE(i) {
  return !i.length || typeof i[i.length - 1] != 'function' ? cb : i.pop();
}
function kE() {
  for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++) e[t] = arguments[t];
  var r = EE(e);
  if ((Array.isArray(e[0]) && (e = e[0]), e.length < 2)) throw new wE('streams');
  var s,
    n = e.map(function (c, f) {
      var h = f < e.length - 1,
        y = f > 0;
      return ME(c, h, y, function (p) {
        s || (s = p), p && n.forEach(fb), !h && (n.forEach(fb), r(s));
      });
    });
  return e.reduce(AE);
}
var _6 = kE;
(function (i, e) {
  (e = i.exports = Q1()),
    (e.Stream = e),
    (e.Readable = e),
    (e.Writable = J1()),
    (e.Duplex = ds()),
    (e.Transform = ey),
    (e.PassThrough = v6),
    (e.finished = Ml),
    (e.pipeline = _6);
})(jp, jp.exports);
var IE = jp.exports,
  jf = At.Buffer,
  S6 = IE.Transform,
  xE = dt;
function BE(i, e) {
  if (!jf.isBuffer(i) && typeof i != 'string')
    throw new TypeError(e + ' must be a string or a buffer');
}
function qo(i) {
  S6.call(this),
    (this._block = jf.allocUnsafe(i)),
    (this._blockSize = i),
    (this._blockOffset = 0),
    (this._length = [0, 0, 0, 0]),
    (this._finalized = !1);
}
xE(qo, S6);
qo.prototype._transform = function (i, e, t) {
  var r = null;
  try {
    this.update(i, e);
  } catch (s) {
    r = s;
  }
  t(r);
};
qo.prototype._flush = function (i) {
  var e = null;
  try {
    this.push(this.digest());
  } catch (t) {
    e = t;
  }
  i(e);
};
qo.prototype.update = function (i, e) {
  if ((BE(i, 'Data'), this._finalized)) throw new Error('Digest already called');
  jf.isBuffer(i) || (i = jf.from(i, e));
  for (var t = this._block, r = 0; this._blockOffset + i.length - r >= this._blockSize; ) {
    for (var s = this._blockOffset; s < this._blockSize; ) t[s++] = i[r++];
    this._update(), (this._blockOffset = 0);
  }
  for (; r < i.length; ) t[this._blockOffset++] = i[r++];
  for (var n = 0, c = i.length * 8; c > 0; ++n)
    (this._length[n] += c),
      (c = (this._length[n] / 4294967296) | 0),
      c > 0 && (this._length[n] -= 4294967296 * c);
  return this;
};
qo.prototype._update = function () {
  throw new Error('_update is not implemented');
};
qo.prototype.digest = function (i) {
  if (this._finalized) throw new Error('Digest already called');
  this._finalized = !0;
  var e = this._digest();
  i !== void 0 && (e = e.toString(i)), this._block.fill(0), (this._blockOffset = 0);
  for (var t = 0; t < 4; ++t) this._length[t] = 0;
  return e;
};
qo.prototype._digest = function () {
  throw new Error('_digest is not implemented');
};
var M6 = qo,
  RE = dt,
  A6 = M6,
  PE = At.Buffer,
  TE = new Array(16);
function kl() {
  A6.call(this, 64),
    (this._a = 1732584193),
    (this._b = 4023233417),
    (this._c = 2562383102),
    (this._d = 271733878);
}
RE(kl, A6);
kl.prototype._update = function () {
  for (var i = TE, e = 0; e < 16; ++e) i[e] = this._block.readInt32LE(e * 4);
  var t = this._a,
    r = this._b,
    s = this._c,
    n = this._d;
  (t = hi(t, r, s, n, i[0], 3614090360, 7)),
    (n = hi(n, t, r, s, i[1], 3905402710, 12)),
    (s = hi(s, n, t, r, i[2], 606105819, 17)),
    (r = hi(r, s, n, t, i[3], 3250441966, 22)),
    (t = hi(t, r, s, n, i[4], 4118548399, 7)),
    (n = hi(n, t, r, s, i[5], 1200080426, 12)),
    (s = hi(s, n, t, r, i[6], 2821735955, 17)),
    (r = hi(r, s, n, t, i[7], 4249261313, 22)),
    (t = hi(t, r, s, n, i[8], 1770035416, 7)),
    (n = hi(n, t, r, s, i[9], 2336552879, 12)),
    (s = hi(s, n, t, r, i[10], 4294925233, 17)),
    (r = hi(r, s, n, t, i[11], 2304563134, 22)),
    (t = hi(t, r, s, n, i[12], 1804603682, 7)),
    (n = hi(n, t, r, s, i[13], 4254626195, 12)),
    (s = hi(s, n, t, r, i[14], 2792965006, 17)),
    (r = hi(r, s, n, t, i[15], 1236535329, 22)),
    (t = di(t, r, s, n, i[1], 4129170786, 5)),
    (n = di(n, t, r, s, i[6], 3225465664, 9)),
    (s = di(s, n, t, r, i[11], 643717713, 14)),
    (r = di(r, s, n, t, i[0], 3921069994, 20)),
    (t = di(t, r, s, n, i[5], 3593408605, 5)),
    (n = di(n, t, r, s, i[10], 38016083, 9)),
    (s = di(s, n, t, r, i[15], 3634488961, 14)),
    (r = di(r, s, n, t, i[4], 3889429448, 20)),
    (t = di(t, r, s, n, i[9], 568446438, 5)),
    (n = di(n, t, r, s, i[14], 3275163606, 9)),
    (s = di(s, n, t, r, i[3], 4107603335, 14)),
    (r = di(r, s, n, t, i[8], 1163531501, 20)),
    (t = di(t, r, s, n, i[13], 2850285829, 5)),
    (n = di(n, t, r, s, i[2], 4243563512, 9)),
    (s = di(s, n, t, r, i[7], 1735328473, 14)),
    (r = di(r, s, n, t, i[12], 2368359562, 20)),
    (t = pi(t, r, s, n, i[5], 4294588738, 4)),
    (n = pi(n, t, r, s, i[8], 2272392833, 11)),
    (s = pi(s, n, t, r, i[11], 1839030562, 16)),
    (r = pi(r, s, n, t, i[14], 4259657740, 23)),
    (t = pi(t, r, s, n, i[1], 2763975236, 4)),
    (n = pi(n, t, r, s, i[4], 1272893353, 11)),
    (s = pi(s, n, t, r, i[7], 4139469664, 16)),
    (r = pi(r, s, n, t, i[10], 3200236656, 23)),
    (t = pi(t, r, s, n, i[13], 681279174, 4)),
    (n = pi(n, t, r, s, i[0], 3936430074, 11)),
    (s = pi(s, n, t, r, i[3], 3572445317, 16)),
    (r = pi(r, s, n, t, i[6], 76029189, 23)),
    (t = pi(t, r, s, n, i[9], 3654602809, 4)),
    (n = pi(n, t, r, s, i[12], 3873151461, 11)),
    (s = pi(s, n, t, r, i[15], 530742520, 16)),
    (r = pi(r, s, n, t, i[2], 3299628645, 23)),
    (t = yi(t, r, s, n, i[0], 4096336452, 6)),
    (n = yi(n, t, r, s, i[7], 1126891415, 10)),
    (s = yi(s, n, t, r, i[14], 2878612391, 15)),
    (r = yi(r, s, n, t, i[5], 4237533241, 21)),
    (t = yi(t, r, s, n, i[12], 1700485571, 6)),
    (n = yi(n, t, r, s, i[3], 2399980690, 10)),
    (s = yi(s, n, t, r, i[10], 4293915773, 15)),
    (r = yi(r, s, n, t, i[1], 2240044497, 21)),
    (t = yi(t, r, s, n, i[8], 1873313359, 6)),
    (n = yi(n, t, r, s, i[15], 4264355552, 10)),
    (s = yi(s, n, t, r, i[6], 2734768916, 15)),
    (r = yi(r, s, n, t, i[13], 1309151649, 21)),
    (t = yi(t, r, s, n, i[4], 4149444226, 6)),
    (n = yi(n, t, r, s, i[11], 3174756917, 10)),
    (s = yi(s, n, t, r, i[2], 718787259, 15)),
    (r = yi(r, s, n, t, i[9], 3951481745, 21)),
    (this._a = (this._a + t) | 0),
    (this._b = (this._b + r) | 0),
    (this._c = (this._c + s) | 0),
    (this._d = (this._d + n) | 0);
};
kl.prototype._digest = function () {
  (this._block[this._blockOffset++] = 128),
    this._blockOffset > 56 &&
      (this._block.fill(0, this._blockOffset, 64), this._update(), (this._blockOffset = 0)),
    this._block.fill(0, this._blockOffset, 56),
    this._block.writeUInt32LE(this._length[0], 56),
    this._block.writeUInt32LE(this._length[1], 60),
    this._update();
  var i = PE.allocUnsafe(16);
  return (
    i.writeInt32LE(this._a, 0),
    i.writeInt32LE(this._b, 4),
    i.writeInt32LE(this._c, 8),
    i.writeInt32LE(this._d, 12),
    i
  );
};
function Il(i, e) {
  return (i << e) | (i >>> (32 - e));
}
function hi(i, e, t, r, s, n, c) {
  return (Il((i + ((e & t) | (~e & r)) + s + n) | 0, c) + e) | 0;
}
function di(i, e, t, r, s, n, c) {
  return (Il((i + ((e & r) | (t & ~r)) + s + n) | 0, c) + e) | 0;
}
function pi(i, e, t, r, s, n, c) {
  return (Il((i + (e ^ t ^ r) + s + n) | 0, c) + e) | 0;
}
function yi(i, e, t, r, s, n, c) {
  return (Il((i + (t ^ (e | ~r)) + s + n) | 0, c) + e) | 0;
}
var ty = kl,
  od = ai.Buffer,
  OE = dt,
  E6 = M6,
  CE = new Array(16),
  ru = [
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2,
    14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13,
    3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13,
  ],
  iu = [
    5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12,
    4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5,
    12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11,
  ],
  nu = [
    11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9,
    11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15,
    9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6,
  ],
  ou = [
    8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7,
    6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6,
    14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11,
  ],
  su = [0, 1518500249, 1859775393, 2400959708, 2840853838],
  au = [1352829926, 1548603684, 1836072691, 2053994217, 0];
function xl() {
  E6.call(this, 64),
    (this._a = 1732584193),
    (this._b = 4023233417),
    (this._c = 2562383102),
    (this._d = 271733878),
    (this._e = 3285377520);
}
OE(xl, E6);
xl.prototype._update = function () {
  for (var i = CE, e = 0; e < 16; ++e) i[e] = this._block.readInt32LE(e * 4);
  for (
    var t = this._a | 0,
      r = this._b | 0,
      s = this._c | 0,
      n = this._d | 0,
      c = this._e | 0,
      f = this._a | 0,
      h = this._b | 0,
      y = this._c | 0,
      p = this._d | 0,
      m = this._e | 0,
      _ = 0;
    _ < 80;
    _ += 1
  ) {
    var A, E;
    _ < 16
      ? ((A = lb(t, r, s, n, c, i[ru[_]], su[0], nu[_])),
        (E = yb(f, h, y, p, m, i[iu[_]], au[0], ou[_])))
      : _ < 32
        ? ((A = hb(t, r, s, n, c, i[ru[_]], su[1], nu[_])),
          (E = pb(f, h, y, p, m, i[iu[_]], au[1], ou[_])))
        : _ < 48
          ? ((A = db(t, r, s, n, c, i[ru[_]], su[2], nu[_])),
            (E = db(f, h, y, p, m, i[iu[_]], au[2], ou[_])))
          : _ < 64
            ? ((A = pb(t, r, s, n, c, i[ru[_]], su[3], nu[_])),
              (E = hb(f, h, y, p, m, i[iu[_]], au[3], ou[_])))
            : ((A = yb(t, r, s, n, c, i[ru[_]], su[4], nu[_])),
              (E = lb(f, h, y, p, m, i[iu[_]], au[4], ou[_]))),
      (t = c),
      (c = n),
      (n = ps(s, 10)),
      (s = r),
      (r = A),
      (f = m),
      (m = p),
      (p = ps(y, 10)),
      (y = h),
      (h = E);
  }
  var I = (this._b + s + p) | 0;
  (this._b = (this._c + n + m) | 0),
    (this._c = (this._d + c + f) | 0),
    (this._d = (this._e + t + h) | 0),
    (this._e = (this._a + r + y) | 0),
    (this._a = I);
};
xl.prototype._digest = function () {
  (this._block[this._blockOffset++] = 128),
    this._blockOffset > 56 &&
      (this._block.fill(0, this._blockOffset, 64), this._update(), (this._blockOffset = 0)),
    this._block.fill(0, this._blockOffset, 56),
    this._block.writeUInt32LE(this._length[0], 56),
    this._block.writeUInt32LE(this._length[1], 60),
    this._update();
  var i = od.alloc ? od.alloc(20) : new od(20);
  return (
    i.writeInt32LE(this._a, 0),
    i.writeInt32LE(this._b, 4),
    i.writeInt32LE(this._c, 8),
    i.writeInt32LE(this._d, 12),
    i.writeInt32LE(this._e, 16),
    i
  );
};
function ps(i, e) {
  return (i << e) | (i >>> (32 - e));
}
function lb(i, e, t, r, s, n, c, f) {
  return (ps((i + (e ^ t ^ r) + n + c) | 0, f) + s) | 0;
}
function hb(i, e, t, r, s, n, c, f) {
  return (ps((i + ((e & t) | (~e & r)) + n + c) | 0, f) + s) | 0;
}
function db(i, e, t, r, s, n, c, f) {
  return (ps((i + ((e | ~t) ^ r) + n + c) | 0, f) + s) | 0;
}
function pb(i, e, t, r, s, n, c, f) {
  return (ps((i + ((e & r) | (t & ~r)) + n + c) | 0, f) + s) | 0;
}
function yb(i, e, t, r, s, n, c, f) {
  return (ps((i + (e ^ (t | ~r)) + n + c) | 0, f) + s) | 0;
}
var ry = xl,
  k6 = { exports: {} },
  I6 = At.Buffer;
function Bl(i, e) {
  (this._block = I6.alloc(i)), (this._finalSize = e), (this._blockSize = i), (this._len = 0);
}
Bl.prototype.update = function (i, e) {
  typeof i == 'string' && ((e = e || 'utf8'), (i = I6.from(i, e)));
  for (var t = this._block, r = this._blockSize, s = i.length, n = this._len, c = 0; c < s; ) {
    for (var f = n % r, h = Math.min(s - c, r - f), y = 0; y < h; y++) t[f + y] = i[c + y];
    (n += h), (c += h), n % r === 0 && this._update(t);
  }
  return (this._len += s), this;
};
Bl.prototype.digest = function (i) {
  var e = this._len % this._blockSize;
  (this._block[e] = 128),
    this._block.fill(0, e + 1),
    e >= this._finalSize && (this._update(this._block), this._block.fill(0));
  var t = this._len * 8;
  if (t <= 4294967295) this._block.writeUInt32BE(t, this._blockSize - 4);
  else {
    var r = (t & 4294967295) >>> 0,
      s = (t - r) / 4294967296;
    this._block.writeUInt32BE(s, this._blockSize - 8),
      this._block.writeUInt32BE(r, this._blockSize - 4);
  }
  this._update(this._block);
  var n = this._hash();
  return i ? n.toString(i) : n;
};
Bl.prototype._update = function () {
  throw new Error('_update must be implemented by subclass');
};
var Fa = Bl,
  LE = dt,
  x6 = Fa,
  NE = At.Buffer,
  $E = [1518500249, 1859775393, -1894007588, -899497514],
  DE = new Array(80);
function Ju() {
  this.init(), (this._w = DE), x6.call(this, 64, 56);
}
LE(Ju, x6);
Ju.prototype.init = function () {
  return (
    (this._a = 1732584193),
    (this._b = 4023233417),
    (this._c = 2562383102),
    (this._d = 271733878),
    (this._e = 3285377520),
    this
  );
};
function UE(i) {
  return (i << 5) | (i >>> 27);
}
function zE(i) {
  return (i << 30) | (i >>> 2);
}
function FE(i, e, t, r) {
  return i === 0 ? (e & t) | (~e & r) : i === 2 ? (e & t) | (e & r) | (t & r) : e ^ t ^ r;
}
Ju.prototype._update = function (i) {
  for (
    var e = this._w,
      t = this._a | 0,
      r = this._b | 0,
      s = this._c | 0,
      n = this._d | 0,
      c = this._e | 0,
      f = 0;
    f < 16;
    ++f
  )
    e[f] = i.readInt32BE(f * 4);
  for (; f < 80; ++f) e[f] = e[f - 3] ^ e[f - 8] ^ e[f - 14] ^ e[f - 16];
  for (var h = 0; h < 80; ++h) {
    var y = ~~(h / 20),
      p = (UE(t) + FE(y, r, s, n) + c + e[h] + $E[y]) | 0;
    (c = n), (n = s), (s = zE(r)), (r = t), (t = p);
  }
  (this._a = (t + this._a) | 0),
    (this._b = (r + this._b) | 0),
    (this._c = (s + this._c) | 0),
    (this._d = (n + this._d) | 0),
    (this._e = (c + this._e) | 0);
};
Ju.prototype._hash = function () {
  var i = NE.allocUnsafe(20);
  return (
    i.writeInt32BE(this._a | 0, 0),
    i.writeInt32BE(this._b | 0, 4),
    i.writeInt32BE(this._c | 0, 8),
    i.writeInt32BE(this._d | 0, 12),
    i.writeInt32BE(this._e | 0, 16),
    i
  );
};
var qE = Ju,
  WE = dt,
  B6 = Fa,
  KE = At.Buffer,
  jE = [1518500249, 1859775393, -1894007588, -899497514],
  HE = new Array(80);
function Xu() {
  this.init(), (this._w = HE), B6.call(this, 64, 56);
}
WE(Xu, B6);
Xu.prototype.init = function () {
  return (
    (this._a = 1732584193),
    (this._b = 4023233417),
    (this._c = 2562383102),
    (this._d = 271733878),
    (this._e = 3285377520),
    this
  );
};
function VE(i) {
  return (i << 1) | (i >>> 31);
}
function GE(i) {
  return (i << 5) | (i >>> 27);
}
function YE(i) {
  return (i << 30) | (i >>> 2);
}
function ZE(i, e, t, r) {
  return i === 0 ? (e & t) | (~e & r) : i === 2 ? (e & t) | (e & r) | (t & r) : e ^ t ^ r;
}
Xu.prototype._update = function (i) {
  for (
    var e = this._w,
      t = this._a | 0,
      r = this._b | 0,
      s = this._c | 0,
      n = this._d | 0,
      c = this._e | 0,
      f = 0;
    f < 16;
    ++f
  )
    e[f] = i.readInt32BE(f * 4);
  for (; f < 80; ++f) e[f] = VE(e[f - 3] ^ e[f - 8] ^ e[f - 14] ^ e[f - 16]);
  for (var h = 0; h < 80; ++h) {
    var y = ~~(h / 20),
      p = (GE(t) + ZE(y, r, s, n) + c + e[h] + jE[y]) | 0;
    (c = n), (n = s), (s = YE(r)), (r = t), (t = p);
  }
  (this._a = (t + this._a) | 0),
    (this._b = (r + this._b) | 0),
    (this._c = (s + this._c) | 0),
    (this._d = (n + this._d) | 0),
    (this._e = (c + this._e) | 0);
};
Xu.prototype._hash = function () {
  var i = KE.allocUnsafe(20);
  return (
    i.writeInt32BE(this._a | 0, 0),
    i.writeInt32BE(this._b | 0, 4),
    i.writeInt32BE(this._c | 0, 8),
    i.writeInt32BE(this._d | 0, 12),
    i.writeInt32BE(this._e | 0, 16),
    i
  );
};
var JE = Xu,
  XE = dt,
  R6 = Fa,
  QE = At.Buffer,
  e9 = [
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221,
    3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580,
    3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895,
    666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037,
    2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
    1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298,
  ],
  t9 = new Array(64);
function Qu() {
  this.init(), (this._w = t9), R6.call(this, 64, 56);
}
XE(Qu, R6);
Qu.prototype.init = function () {
  return (
    (this._a = 1779033703),
    (this._b = 3144134277),
    (this._c = 1013904242),
    (this._d = 2773480762),
    (this._e = 1359893119),
    (this._f = 2600822924),
    (this._g = 528734635),
    (this._h = 1541459225),
    this
  );
};
function r9(i, e, t) {
  return t ^ (i & (e ^ t));
}
function i9(i, e, t) {
  return (i & e) | (t & (i | e));
}
function n9(i) {
  return ((i >>> 2) | (i << 30)) ^ ((i >>> 13) | (i << 19)) ^ ((i >>> 22) | (i << 10));
}
function o9(i) {
  return ((i >>> 6) | (i << 26)) ^ ((i >>> 11) | (i << 21)) ^ ((i >>> 25) | (i << 7));
}
function s9(i) {
  return ((i >>> 7) | (i << 25)) ^ ((i >>> 18) | (i << 14)) ^ (i >>> 3);
}
function a9(i) {
  return ((i >>> 17) | (i << 15)) ^ ((i >>> 19) | (i << 13)) ^ (i >>> 10);
}
Qu.prototype._update = function (i) {
  for (
    var e = this._w,
      t = this._a | 0,
      r = this._b | 0,
      s = this._c | 0,
      n = this._d | 0,
      c = this._e | 0,
      f = this._f | 0,
      h = this._g | 0,
      y = this._h | 0,
      p = 0;
    p < 16;
    ++p
  )
    e[p] = i.readInt32BE(p * 4);
  for (; p < 64; ++p) e[p] = (a9(e[p - 2]) + e[p - 7] + s9(e[p - 15]) + e[p - 16]) | 0;
  for (var m = 0; m < 64; ++m) {
    var _ = (y + o9(c) + r9(c, f, h) + e9[m] + e[m]) | 0,
      A = (n9(t) + i9(t, r, s)) | 0;
    (y = h), (h = f), (f = c), (c = (n + _) | 0), (n = s), (s = r), (r = t), (t = (_ + A) | 0);
  }
  (this._a = (t + this._a) | 0),
    (this._b = (r + this._b) | 0),
    (this._c = (s + this._c) | 0),
    (this._d = (n + this._d) | 0),
    (this._e = (c + this._e) | 0),
    (this._f = (f + this._f) | 0),
    (this._g = (h + this._g) | 0),
    (this._h = (y + this._h) | 0);
};
Qu.prototype._hash = function () {
  var i = QE.allocUnsafe(32);
  return (
    i.writeInt32BE(this._a, 0),
    i.writeInt32BE(this._b, 4),
    i.writeInt32BE(this._c, 8),
    i.writeInt32BE(this._d, 12),
    i.writeInt32BE(this._e, 16),
    i.writeInt32BE(this._f, 20),
    i.writeInt32BE(this._g, 24),
    i.writeInt32BE(this._h, 28),
    i
  );
};
var P6 = Qu,
  u9 = dt,
  c9 = P6,
  f9 = Fa,
  l9 = At.Buffer,
  h9 = new Array(64);
function Rl() {
  this.init(), (this._w = h9), f9.call(this, 64, 56);
}
u9(Rl, c9);
Rl.prototype.init = function () {
  return (
    (this._a = 3238371032),
    (this._b = 914150663),
    (this._c = 812702999),
    (this._d = 4144912697),
    (this._e = 4290775857),
    (this._f = 1750603025),
    (this._g = 1694076839),
    (this._h = 3204075428),
    this
  );
};
Rl.prototype._hash = function () {
  var i = l9.allocUnsafe(28);
  return (
    i.writeInt32BE(this._a, 0),
    i.writeInt32BE(this._b, 4),
    i.writeInt32BE(this._c, 8),
    i.writeInt32BE(this._d, 12),
    i.writeInt32BE(this._e, 16),
    i.writeInt32BE(this._f, 20),
    i.writeInt32BE(this._g, 24),
    i
  );
};
var d9 = Rl,
  p9 = dt,
  T6 = Fa,
  y9 = At.Buffer,
  gb = [
    1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548,
    961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560,
    3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994,
    1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868,
    3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933,
    770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837,
    2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956,
    3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936,
    666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823,
    1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627,
    2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008,
    3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720,
    430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280,
    958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899,
    1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044,
    2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427,
    3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992,
    116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315,
    685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676,
    1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591,
  ],
  g9 = new Array(160);
function ec() {
  this.init(), (this._w = g9), T6.call(this, 128, 112);
}
p9(ec, T6);
ec.prototype.init = function () {
  return (
    (this._ah = 1779033703),
    (this._bh = 3144134277),
    (this._ch = 1013904242),
    (this._dh = 2773480762),
    (this._eh = 1359893119),
    (this._fh = 2600822924),
    (this._gh = 528734635),
    (this._hh = 1541459225),
    (this._al = 4089235720),
    (this._bl = 2227873595),
    (this._cl = 4271175723),
    (this._dl = 1595750129),
    (this._el = 2917565137),
    (this._fl = 725511199),
    (this._gl = 4215389547),
    (this._hl = 327033209),
    this
  );
};
function bb(i, e, t) {
  return t ^ (i & (e ^ t));
}
function vb(i, e, t) {
  return (i & e) | (t & (i | e));
}
function mb(i, e) {
  return ((i >>> 28) | (e << 4)) ^ ((e >>> 2) | (i << 30)) ^ ((e >>> 7) | (i << 25));
}
function wb(i, e) {
  return ((i >>> 14) | (e << 18)) ^ ((i >>> 18) | (e << 14)) ^ ((e >>> 9) | (i << 23));
}
function b9(i, e) {
  return ((i >>> 1) | (e << 31)) ^ ((i >>> 8) | (e << 24)) ^ (i >>> 7);
}
function v9(i, e) {
  return ((i >>> 1) | (e << 31)) ^ ((i >>> 8) | (e << 24)) ^ ((i >>> 7) | (e << 25));
}
function m9(i, e) {
  return ((i >>> 19) | (e << 13)) ^ ((e >>> 29) | (i << 3)) ^ (i >>> 6);
}
function w9(i, e) {
  return ((i >>> 19) | (e << 13)) ^ ((e >>> 29) | (i << 3)) ^ ((i >>> 6) | (e << 26));
}
function jr(i, e) {
  return i >>> 0 < e >>> 0 ? 1 : 0;
}
ec.prototype._update = function (i) {
  for (
    var e = this._w,
      t = this._ah | 0,
      r = this._bh | 0,
      s = this._ch | 0,
      n = this._dh | 0,
      c = this._eh | 0,
      f = this._fh | 0,
      h = this._gh | 0,
      y = this._hh | 0,
      p = this._al | 0,
      m = this._bl | 0,
      _ = this._cl | 0,
      A = this._dl | 0,
      E = this._el | 0,
      I = this._fl | 0,
      R = this._gl | 0,
      L = this._hl | 0,
      D = 0;
    D < 32;
    D += 2
  )
    (e[D] = i.readInt32BE(D * 4)), (e[D + 1] = i.readInt32BE(D * 4 + 4));
  for (; D < 160; D += 2) {
    var q = e[D - 30],
      H = e[D - 15 * 2 + 1],
      V = b9(q, H),
      te = v9(H, q);
    (q = e[D - 2 * 2]), (H = e[D - 2 * 2 + 1]);
    var ue = m9(q, H),
      ne = w9(H, q),
      X = e[D - 7 * 2],
      Oe = e[D - 7 * 2 + 1],
      S = e[D - 16 * 2],
      o = e[D - 16 * 2 + 1],
      u = (te + Oe) | 0,
      l = (V + X + jr(u, te)) | 0;
    (u = (u + ne) | 0),
      (l = (l + ue + jr(u, ne)) | 0),
      (u = (u + o) | 0),
      (l = (l + S + jr(u, o)) | 0),
      (e[D] = l),
      (e[D + 1] = u);
  }
  for (var d = 0; d < 160; d += 2) {
    (l = e[d]), (u = e[d + 1]);
    var g = vb(t, r, s),
      w = vb(p, m, _),
      M = mb(t, p),
      v = mb(p, t),
      a = wb(c, E),
      b = wb(E, c),
      k = gb[d],
      B = gb[d + 1],
      F = bb(c, f, h),
      P = bb(E, I, R),
      C = (L + b) | 0,
      z = (y + a + jr(C, L)) | 0;
    (C = (C + P) | 0),
      (z = (z + F + jr(C, P)) | 0),
      (C = (C + B) | 0),
      (z = (z + k + jr(C, B)) | 0),
      (C = (C + u) | 0),
      (z = (z + l + jr(C, u)) | 0);
    var Y = (v + w) | 0,
      G = (M + g + jr(Y, v)) | 0;
    (y = h),
      (L = R),
      (h = f),
      (R = I),
      (f = c),
      (I = E),
      (E = (A + C) | 0),
      (c = (n + z + jr(E, A)) | 0),
      (n = s),
      (A = _),
      (s = r),
      (_ = m),
      (r = t),
      (m = p),
      (p = (C + Y) | 0),
      (t = (z + G + jr(p, C)) | 0);
  }
  (this._al = (this._al + p) | 0),
    (this._bl = (this._bl + m) | 0),
    (this._cl = (this._cl + _) | 0),
    (this._dl = (this._dl + A) | 0),
    (this._el = (this._el + E) | 0),
    (this._fl = (this._fl + I) | 0),
    (this._gl = (this._gl + R) | 0),
    (this._hl = (this._hl + L) | 0),
    (this._ah = (this._ah + t + jr(this._al, p)) | 0),
    (this._bh = (this._bh + r + jr(this._bl, m)) | 0),
    (this._ch = (this._ch + s + jr(this._cl, _)) | 0),
    (this._dh = (this._dh + n + jr(this._dl, A)) | 0),
    (this._eh = (this._eh + c + jr(this._el, E)) | 0),
    (this._fh = (this._fh + f + jr(this._fl, I)) | 0),
    (this._gh = (this._gh + h + jr(this._gl, R)) | 0),
    (this._hh = (this._hh + y + jr(this._hl, L)) | 0);
};
ec.prototype._hash = function () {
  var i = y9.allocUnsafe(64);
  function e(t, r, s) {
    i.writeInt32BE(t, s), i.writeInt32BE(r, s + 4);
  }
  return (
    e(this._ah, this._al, 0),
    e(this._bh, this._bl, 8),
    e(this._ch, this._cl, 16),
    e(this._dh, this._dl, 24),
    e(this._eh, this._el, 32),
    e(this._fh, this._fl, 40),
    e(this._gh, this._gl, 48),
    e(this._hh, this._hl, 56),
    i
  );
};
var O6 = ec,
  _9 = dt,
  S9 = O6,
  M9 = Fa,
  A9 = At.Buffer,
  E9 = new Array(160);
function Pl() {
  this.init(), (this._w = E9), M9.call(this, 128, 112);
}
_9(Pl, S9);
Pl.prototype.init = function () {
  return (
    (this._ah = 3418070365),
    (this._bh = 1654270250),
    (this._ch = 2438529370),
    (this._dh = 355462360),
    (this._eh = 1731405415),
    (this._fh = 2394180231),
    (this._gh = 3675008525),
    (this._hh = 1203062813),
    (this._al = 3238371032),
    (this._bl = 914150663),
    (this._cl = 812702999),
    (this._dl = 4144912697),
    (this._el = 4290775857),
    (this._fl = 1750603025),
    (this._gl = 1694076839),
    (this._hl = 3204075428),
    this
  );
};
Pl.prototype._hash = function () {
  var i = A9.allocUnsafe(48);
  function e(t, r, s) {
    i.writeInt32BE(t, s), i.writeInt32BE(r, s + 4);
  }
  return (
    e(this._ah, this._al, 0),
    e(this._bh, this._bl, 8),
    e(this._ch, this._cl, 16),
    e(this._dh, this._dl, 24),
    e(this._eh, this._el, 32),
    e(this._fh, this._fl, 40),
    i
  );
};
var k9 = Pl,
  xs = (k6.exports = function (e) {
    e = e.toLowerCase();
    var t = xs[e];
    if (!t) throw new Error(e + ' is not supported (we accept pull requests)');
    return new t();
  });
xs.sha = qE;
xs.sha1 = JE;
xs.sha224 = d9;
xs.sha256 = P6;
xs.sha384 = k9;
xs.sha512 = O6;
var iy = k6.exports,
  I9 = Ji,
  ny = za.EventEmitter,
  x9 = dt;
x9(Ji, ny);
Ji.Readable = Q1();
Ji.Writable = J1();
Ji.Duplex = ds();
Ji.Transform = ey;
Ji.PassThrough = v6;
Ji.finished = Ml;
Ji.pipeline = _6;
Ji.Stream = Ji;
function Ji() {
  ny.call(this);
}
Ji.prototype.pipe = function (i, e) {
  var t = this;
  function r(p) {
    i.writable && i.write(p) === !1 && t.pause && t.pause();
  }
  t.on('data', r);
  function s() {
    t.readable && t.resume && t.resume();
  }
  i.on('drain', s), !i._isStdio && (!e || e.end !== !1) && (t.on('end', c), t.on('close', f));
  var n = !1;
  function c() {
    n || ((n = !0), i.end());
  }
  function f() {
    n || ((n = !0), typeof i.destroy == 'function' && i.destroy());
  }
  function h(p) {
    if ((y(), ny.listenerCount(this, 'error') === 0)) throw p;
  }
  t.on('error', h), i.on('error', h);
  function y() {
    t.removeListener('data', r),
      i.removeListener('drain', s),
      t.removeListener('end', c),
      t.removeListener('close', f),
      t.removeListener('error', h),
      i.removeListener('error', h),
      t.removeListener('end', y),
      t.removeListener('close', y),
      i.removeListener('close', y);
  }
  return t.on('end', y), t.on('close', y), i.on('close', y), i.emit('pipe', t), i;
};
var C6 = At.Buffer,
  L6 = I9.Transform,
  B9 = _a.StringDecoder,
  R9 = dt;
function yn(i) {
  L6.call(this),
    (this.hashMode = typeof i == 'string'),
    this.hashMode ? (this[i] = this._finalOrDigest) : (this.final = this._finalOrDigest),
    this._final && ((this.__final = this._final), (this._final = null)),
    (this._decoder = null),
    (this._encoding = null);
}
R9(yn, L6);
yn.prototype.update = function (i, e, t) {
  typeof i == 'string' && (i = C6.from(i, e));
  var r = this._update(i);
  return this.hashMode ? this : (t && (r = this._toString(r, t)), r);
};
yn.prototype.setAutoPadding = function () {};
yn.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state');
};
yn.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state');
};
yn.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state');
};
yn.prototype._transform = function (i, e, t) {
  var r;
  try {
    this.hashMode ? this._update(i) : this.push(this._update(i));
  } catch (s) {
    r = s;
  } finally {
    t(r);
  }
};
yn.prototype._flush = function (i) {
  var e;
  try {
    this.push(this.__final());
  } catch (t) {
    e = t;
  }
  i(e);
};
yn.prototype._finalOrDigest = function (i) {
  var e = this.__final() || C6.alloc(0);
  return i && (e = this._toString(e, i, !0)), e;
};
yn.prototype._toString = function (i, e, t) {
  if ((this._decoder || ((this._decoder = new B9(e)), (this._encoding = e)), this._encoding !== e))
    throw new Error("can't switch encodings");
  var r = this._decoder.write(i);
  return t && (r += this._decoder.end()), r;
};
var Wo = yn,
  P9 = dt,
  T9 = ty,
  O9 = ry,
  C9 = iy,
  N6 = Wo;
function Tl(i) {
  N6.call(this, 'digest'), (this._hash = i);
}
P9(Tl, N6);
Tl.prototype._update = function (i) {
  this._hash.update(i);
};
Tl.prototype._final = function () {
  return this._hash.digest();
};
var tc = function (e) {
    return (
      (e = e.toLowerCase()),
      e === 'md5' ? new T9() : e === 'rmd160' || e === 'ripemd160' ? new O9() : new Tl(C9(e))
    );
  },
  sd,
  _b;
function L9() {
  if (_b) return sd;
  _b = 1;
  var i = dt,
    e = At.Buffer,
    t = Wo,
    r = e.alloc(128),
    s = 64;
  function n(c, f) {
    t.call(this, 'digest'),
      typeof f == 'string' && (f = e.from(f)),
      (this._alg = c),
      (this._key = f),
      f.length > s ? (f = c(f)) : f.length < s && (f = e.concat([f, r], s));
    for (
      var h = (this._ipad = e.allocUnsafe(s)), y = (this._opad = e.allocUnsafe(s)), p = 0;
      p < s;
      p++
    )
      (h[p] = f[p] ^ 54), (y[p] = f[p] ^ 92);
    this._hash = [h];
  }
  return (
    i(n, t),
    (n.prototype._update = function (c) {
      this._hash.push(c);
    }),
    (n.prototype._final = function () {
      var c = this._alg(e.concat(this._hash));
      return this._alg(e.concat([this._opad, c]));
    }),
    (sd = n),
    sd
  );
}
var ad, Sb;
function $6() {
  if (Sb) return ad;
  Sb = 1;
  var i = ty;
  return (
    (ad = function (e) {
      return new i().update(e).digest();
    }),
    ad
  );
}
var ud, Mb;
function D6() {
  if (Mb) return ud;
  Mb = 1;
  var i = dt,
    e = L9(),
    t = Wo,
    r = At.Buffer,
    s = $6(),
    n = ry,
    c = iy,
    f = r.alloc(128);
  function h(y, p) {
    t.call(this, 'digest'), typeof p == 'string' && (p = r.from(p));
    var m = y === 'sha512' || y === 'sha384' ? 128 : 64;
    if (((this._alg = y), (this._key = p), p.length > m)) {
      var _ = y === 'rmd160' ? new n() : c(y);
      p = _.update(p).digest();
    } else p.length < m && (p = r.concat([p, f], m));
    for (
      var A = (this._ipad = r.allocUnsafe(m)), E = (this._opad = r.allocUnsafe(m)), I = 0;
      I < m;
      I++
    )
      (A[I] = p[I] ^ 54), (E[I] = p[I] ^ 92);
    (this._hash = y === 'rmd160' ? new n() : c(y)), this._hash.update(A);
  }
  return (
    i(h, t),
    (h.prototype._update = function (y) {
      this._hash.update(y);
    }),
    (h.prototype._final = function () {
      var y = this._hash.digest(),
        p = this._alg === 'rmd160' ? new n() : c(this._alg);
      return p.update(this._opad).update(y).digest();
    }),
    (ud = function (p, m) {
      return (
        (p = p.toLowerCase()),
        p === 'rmd160' || p === 'ripemd160'
          ? new h('rmd160', m)
          : p === 'md5'
            ? new e(s, m)
            : new h(p, m)
      );
    }),
    ud
  );
}
const N9 = { sign: 'rsa', hash: 'sha224', id: '302d300d06096086480165030402040500041c' },
  $9 = { sign: 'rsa', hash: 'sha256', id: '3031300d060960864801650304020105000420' },
  D9 = { sign: 'rsa', hash: 'sha384', id: '3041300d060960864801650304020205000430' },
  U9 = { sign: 'rsa', hash: 'sha512', id: '3051300d060960864801650304020305000440' },
  z9 = { sign: 'ecdsa', hash: 'sha256', id: '' },
  F9 = { sign: 'ecdsa', hash: 'sha224', id: '' },
  q9 = { sign: 'ecdsa', hash: 'sha384', id: '' },
  W9 = { sign: 'ecdsa', hash: 'sha512', id: '' },
  K9 = { sign: 'dsa', hash: 'sha1', id: '' },
  j9 = { sign: 'rsa', hash: 'rmd160', id: '3021300906052b2403020105000414' },
  H9 = { sign: 'rsa', hash: 'md5', id: '3020300c06082a864886f70d020505000410' },
  U6 = {
    sha224WithRSAEncryption: N9,
    'RSA-SHA224': {
      sign: 'ecdsa/rsa',
      hash: 'sha224',
      id: '302d300d06096086480165030402040500041c',
    },
    sha256WithRSAEncryption: $9,
    'RSA-SHA256': {
      sign: 'ecdsa/rsa',
      hash: 'sha256',
      id: '3031300d060960864801650304020105000420',
    },
    sha384WithRSAEncryption: D9,
    'RSA-SHA384': {
      sign: 'ecdsa/rsa',
      hash: 'sha384',
      id: '3041300d060960864801650304020205000430',
    },
    sha512WithRSAEncryption: U9,
    'RSA-SHA512': {
      sign: 'ecdsa/rsa',
      hash: 'sha512',
      id: '3051300d060960864801650304020305000440',
    },
    'RSA-SHA1': { sign: 'rsa', hash: 'sha1', id: '3021300906052b0e03021a05000414' },
    'ecdsa-with-SHA1': { sign: 'ecdsa', hash: 'sha1', id: '' },
    sha256: z9,
    sha224: F9,
    sha384: q9,
    sha512: W9,
    'DSA-SHA': { sign: 'dsa', hash: 'sha1', id: '' },
    'DSA-SHA1': { sign: 'dsa', hash: 'sha1', id: '' },
    DSA: K9,
    'DSA-WITH-SHA224': { sign: 'dsa', hash: 'sha224', id: '' },
    'DSA-SHA224': { sign: 'dsa', hash: 'sha224', id: '' },
    'DSA-WITH-SHA256': { sign: 'dsa', hash: 'sha256', id: '' },
    'DSA-SHA256': { sign: 'dsa', hash: 'sha256', id: '' },
    'DSA-WITH-SHA384': { sign: 'dsa', hash: 'sha384', id: '' },
    'DSA-SHA384': { sign: 'dsa', hash: 'sha384', id: '' },
    'DSA-WITH-SHA512': { sign: 'dsa', hash: 'sha512', id: '' },
    'DSA-SHA512': { sign: 'dsa', hash: 'sha512', id: '' },
    'DSA-RIPEMD160': { sign: 'dsa', hash: 'rmd160', id: '' },
    ripemd160WithRSA: j9,
    'RSA-RIPEMD160': { sign: 'rsa', hash: 'rmd160', id: '3021300906052b2403020105000414' },
    md5WithRSAEncryption: H9,
    'RSA-MD5': { sign: 'rsa', hash: 'md5', id: '3020300c06082a864886f70d020505000410' },
  };
var cd, Ab;
function V9() {
  return Ab || ((Ab = 1), (cd = U6)), cd;
}
var Wc = {},
  fd,
  Eb;
function z6() {
  if (Eb) return fd;
  Eb = 1;
  var i = Math.pow(2, 30) - 1;
  return (
    (fd = function (e, t) {
      if (typeof e != 'number') throw new TypeError('Iterations not a number');
      if (e < 0) throw new TypeError('Bad iterations');
      if (typeof t != 'number') throw new TypeError('Key length not a number');
      if (t < 0 || t > i || t !== t) throw new TypeError('Bad key length');
    }),
    fd
  );
}
var ld, kb;
function F6() {
  if (kb) return ld;
  kb = 1;
  var i;
  if (globalThis.process && globalThis.process.browser) i = 'utf-8';
  else if (globalThis.process && globalThis.process.version) {
    var e = parseInt(Je.version.split('.')[0].slice(1), 10);
    i = e >= 6 ? 'utf-8' : 'binary';
  } else i = 'utf-8';
  return (ld = i), ld;
}
var hd, Ib;
function q6() {
  if (Ib) return hd;
  Ib = 1;
  var i = At.Buffer;
  return (
    (hd = function (e, t, r) {
      if (i.isBuffer(e)) return e;
      if (typeof e == 'string') return i.from(e, t);
      if (ArrayBuffer.isView(e)) return i.from(e.buffer);
      throw new TypeError(r + ' must be a string, a Buffer, a typed array or a DataView');
    }),
    hd
  );
}
var dd, xb;
function W6() {
  if (xb) return dd;
  xb = 1;
  var i = $6(),
    e = ry,
    t = iy,
    r = At.Buffer,
    s = z6(),
    n = F6(),
    c = q6(),
    f = r.alloc(128),
    h = {
      md5: 16,
      sha1: 20,
      sha224: 28,
      sha256: 32,
      sha384: 48,
      sha512: 64,
      rmd160: 20,
      ripemd160: 20,
    };
  function y(_, A, E) {
    var I = p(_),
      R = _ === 'sha512' || _ === 'sha384' ? 128 : 64;
    A.length > R ? (A = I(A)) : A.length < R && (A = r.concat([A, f], R));
    for (var L = r.allocUnsafe(R + h[_]), D = r.allocUnsafe(R + h[_]), q = 0; q < R; q++)
      (L[q] = A[q] ^ 54), (D[q] = A[q] ^ 92);
    var H = r.allocUnsafe(R + E + 4);
    L.copy(H, 0, 0, R),
      (this.ipad1 = H),
      (this.ipad2 = L),
      (this.opad = D),
      (this.alg = _),
      (this.blocksize = R),
      (this.hash = I),
      (this.size = h[_]);
  }
  y.prototype.run = function (_, A) {
    _.copy(A, this.blocksize);
    var E = this.hash(A);
    return E.copy(this.opad, this.blocksize), this.hash(this.opad);
  };
  function p(_) {
    function A(I) {
      return t(_).update(I).digest();
    }
    function E(I) {
      return new e().update(I).digest();
    }
    return _ === 'rmd160' || _ === 'ripemd160' ? E : _ === 'md5' ? i : A;
  }
  function m(_, A, E, I, R) {
    s(E, I), (_ = c(_, n, 'Password')), (A = c(A, n, 'Salt')), (R = R || 'sha1');
    var L = new y(R, _, A.length),
      D = r.allocUnsafe(I),
      q = r.allocUnsafe(A.length + 4);
    A.copy(q, 0, 0, A.length);
    for (var H = 0, V = h[R], te = Math.ceil(I / V), ue = 1; ue <= te; ue++) {
      q.writeUInt32BE(ue, A.length);
      for (var ne = L.run(q, L.ipad1), X = ne, Oe = 1; Oe < E; Oe++) {
        X = L.run(X, L.ipad2);
        for (var S = 0; S < V; S++) ne[S] ^= X[S];
      }
      ne.copy(D, H), (H += V);
    }
    return D;
  }
  return (dd = m), dd;
}
var pd, Bb;
function G9() {
  if (Bb) return pd;
  Bb = 1;
  var i = At.Buffer,
    e = z6(),
    t = F6(),
    r = W6(),
    s = q6(),
    n,
    c = globalThis.crypto && globalThis.crypto.subtle,
    f = {
      sha: 'SHA-1',
      'sha-1': 'SHA-1',
      sha1: 'SHA-1',
      sha256: 'SHA-256',
      'sha-256': 'SHA-256',
      sha384: 'SHA-384',
      'sha-384': 'SHA-384',
      'sha-512': 'SHA-512',
      sha512: 'SHA-512',
    },
    h = [];
  function y(E) {
    if ((globalThis.process && !globalThis.process.browser) || !c || !c.importKey || !c.deriveBits)
      return Promise.resolve(!1);
    if (h[E] !== void 0) return h[E];
    n = n || i.alloc(8);
    var I = _(n, n, 10, 128, E)
      .then(function () {
        return !0;
      })
      .catch(function () {
        return !1;
      });
    return (h[E] = I), I;
  }
  var p;
  function m() {
    return (
      p ||
      (globalThis.process && globalThis.process.nextTick
        ? (p = globalThis.process.nextTick)
        : globalThis.queueMicrotask
          ? (p = globalThis.queueMicrotask)
          : globalThis.setImmediate
            ? (p = globalThis.setImmediate)
            : (p = globalThis.setTimeout),
      p)
    );
  }
  function _(E, I, R, L, D) {
    return c
      .importKey('raw', E, { name: 'PBKDF2' }, !1, ['deriveBits'])
      .then(function (q) {
        return c.deriveBits(
          { name: 'PBKDF2', salt: I, iterations: R, hash: { name: D } },
          q,
          L << 3
        );
      })
      .then(function (q) {
        return i.from(q);
      });
  }
  function A(E, I) {
    E.then(
      function (R) {
        m()(function () {
          I(null, R);
        });
      },
      function (R) {
        m()(function () {
          I(R);
        });
      }
    );
  }
  return (
    (pd = function (E, I, R, L, D, q) {
      typeof D == 'function' && ((q = D), (D = void 0)), (D = D || 'sha1');
      var H = f[D.toLowerCase()];
      if (!H || typeof globalThis.Promise != 'function') {
        m()(function () {
          var V;
          try {
            V = r(E, I, R, L, D);
          } catch (te) {
            return q(te);
          }
          q(null, V);
        });
        return;
      }
      if ((e(R, L), (E = s(E, t, 'Password')), (I = s(I, t, 'Salt')), typeof q != 'function'))
        throw new Error('No callback provided to pbkdf2');
      A(
        y(H).then(function (V) {
          return V ? _(E, I, R, L, H) : r(E, I, R, L, D);
        }),
        q
      );
    }),
    pd
  );
}
var Rb;
function K6() {
  return Rb || ((Rb = 1), (Wc.pbkdf2 = G9()), (Wc.pbkdf2Sync = W6())), Wc;
}
var qi = {},
  Vo = {},
  xi = {},
  Pb;
function j6() {
  if (Pb) return xi;
  (Pb = 1),
    (xi.readUInt32BE = function (s, n) {
      var c = (s[0 + n] << 24) | (s[1 + n] << 16) | (s[2 + n] << 8) | s[3 + n];
      return c >>> 0;
    }),
    (xi.writeUInt32BE = function (s, n, c) {
      (s[0 + c] = n >>> 24),
        (s[1 + c] = (n >>> 16) & 255),
        (s[2 + c] = (n >>> 8) & 255),
        (s[3 + c] = n & 255);
    }),
    (xi.ip = function (s, n, c, f) {
      for (var h = 0, y = 0, p = 6; p >= 0; p -= 2) {
        for (var m = 0; m <= 24; m += 8) (h <<= 1), (h |= (n >>> (m + p)) & 1);
        for (var m = 0; m <= 24; m += 8) (h <<= 1), (h |= (s >>> (m + p)) & 1);
      }
      for (var p = 6; p >= 0; p -= 2) {
        for (var m = 1; m <= 25; m += 8) (y <<= 1), (y |= (n >>> (m + p)) & 1);
        for (var m = 1; m <= 25; m += 8) (y <<= 1), (y |= (s >>> (m + p)) & 1);
      }
      (c[f + 0] = h >>> 0), (c[f + 1] = y >>> 0);
    }),
    (xi.rip = function (s, n, c, f) {
      for (var h = 0, y = 0, p = 0; p < 4; p++)
        for (var m = 24; m >= 0; m -= 8)
          (h <<= 1), (h |= (n >>> (m + p)) & 1), (h <<= 1), (h |= (s >>> (m + p)) & 1);
      for (var p = 4; p < 8; p++)
        for (var m = 24; m >= 0; m -= 8)
          (y <<= 1), (y |= (n >>> (m + p)) & 1), (y <<= 1), (y |= (s >>> (m + p)) & 1);
      (c[f + 0] = h >>> 0), (c[f + 1] = y >>> 0);
    }),
    (xi.pc1 = function (s, n, c, f) {
      for (var h = 0, y = 0, p = 7; p >= 5; p--) {
        for (var m = 0; m <= 24; m += 8) (h <<= 1), (h |= (n >> (m + p)) & 1);
        for (var m = 0; m <= 24; m += 8) (h <<= 1), (h |= (s >> (m + p)) & 1);
      }
      for (var m = 0; m <= 24; m += 8) (h <<= 1), (h |= (n >> (m + p)) & 1);
      for (var p = 1; p <= 3; p++) {
        for (var m = 0; m <= 24; m += 8) (y <<= 1), (y |= (n >> (m + p)) & 1);
        for (var m = 0; m <= 24; m += 8) (y <<= 1), (y |= (s >> (m + p)) & 1);
      }
      for (var m = 0; m <= 24; m += 8) (y <<= 1), (y |= (s >> (m + p)) & 1);
      (c[f + 0] = h >>> 0), (c[f + 1] = y >>> 0);
    }),
    (xi.r28shl = function (s, n) {
      return ((s << n) & 268435455) | (s >>> (28 - n));
    });
  var i = [
    14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4,
    25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24,
  ];
  (xi.pc2 = function (s, n, c, f) {
    for (var h = 0, y = 0, p = i.length >>> 1, m = 0; m < p; m++)
      (h <<= 1), (h |= (s >>> i[m]) & 1);
    for (var m = p; m < i.length; m++) (y <<= 1), (y |= (n >>> i[m]) & 1);
    (c[f + 0] = h >>> 0), (c[f + 1] = y >>> 0);
  }),
    (xi.expand = function (s, n, c) {
      var f = 0,
        h = 0;
      f = ((s & 1) << 5) | (s >>> 27);
      for (var y = 23; y >= 15; y -= 4) (f <<= 6), (f |= (s >>> y) & 63);
      for (var y = 11; y >= 3; y -= 4) (h |= (s >>> y) & 63), (h <<= 6);
      (h |= ((s & 31) << 1) | (s >>> 31)), (n[c + 0] = f >>> 0), (n[c + 1] = h >>> 0);
    });
  var e = [
    14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5,
    0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3,
    10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1,
    13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11,
    8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5,
    10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15,
    9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3,
    5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15,
    9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2,
    14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14,
    8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6,
    10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13,
    4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11,
    0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1,
    13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1,
    3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4,
    8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1,
    4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11,
  ];
  xi.substitute = function (s, n) {
    for (var c = 0, f = 0; f < 4; f++) {
      var h = (s >>> (18 - f * 6)) & 63,
        y = e[f * 64 + h];
      (c <<= 4), (c |= y);
    }
    for (var f = 0; f < 4; f++) {
      var h = (n >>> (18 - f * 6)) & 63,
        y = e[4 * 64 + f * 64 + h];
      (c <<= 4), (c |= y);
    }
    return c >>> 0;
  };
  var t = [
    16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19,
    2, 26, 10, 21, 28, 7,
  ];
  return (
    (xi.permute = function (s) {
      for (var n = 0, c = 0; c < t.length; c++) (n <<= 1), (n |= (s >>> t[c]) & 1);
      return n >>> 0;
    }),
    (xi.padSplit = function (s, n, c) {
      for (var f = s.toString(2); f.length < n; ) f = '0' + f;
      for (var h = [], y = 0; y < n; y += c) h.push(f.slice(y, y + c));
      return h.join(' ');
    }),
    xi
  );
}
var Qi = H6;
function H6(i, e) {
  if (!i) throw new Error(e || 'Assertion failed');
}
H6.equal = function (e, t, r) {
  if (e != t) throw new Error(r || 'Assertion failed: ' + e + ' != ' + t);
};
var yd, Tb;
function oy() {
  if (Tb) return yd;
  Tb = 1;
  var i = Qi;
  function e(t) {
    (this.options = t),
      (this.type = this.options.type),
      (this.blockSize = 8),
      this._init(),
      (this.buffer = new Array(this.blockSize)),
      (this.bufferOff = 0);
  }
  return (
    (yd = e),
    (e.prototype._init = function () {}),
    (e.prototype.update = function (r) {
      return r.length === 0
        ? []
        : this.type === 'decrypt'
          ? this._updateDecrypt(r)
          : this._updateEncrypt(r);
    }),
    (e.prototype._buffer = function (r, s) {
      for (var n = Math.min(this.buffer.length - this.bufferOff, r.length - s), c = 0; c < n; c++)
        this.buffer[this.bufferOff + c] = r[s + c];
      return (this.bufferOff += n), n;
    }),
    (e.prototype._flushBuffer = function (r, s) {
      return this._update(this.buffer, 0, r, s), (this.bufferOff = 0), this.blockSize;
    }),
    (e.prototype._updateEncrypt = function (r) {
      var s = 0,
        n = 0,
        c = ((this.bufferOff + r.length) / this.blockSize) | 0,
        f = new Array(c * this.blockSize);
      this.bufferOff !== 0 &&
        ((s += this._buffer(r, s)),
        this.bufferOff === this.buffer.length && (n += this._flushBuffer(f, n)));
      for (var h = r.length - ((r.length - s) % this.blockSize); s < h; s += this.blockSize)
        this._update(r, s, f, n), (n += this.blockSize);
      for (; s < r.length; s++, this.bufferOff++) this.buffer[this.bufferOff] = r[s];
      return f;
    }),
    (e.prototype._updateDecrypt = function (r) {
      for (
        var s = 0,
          n = 0,
          c = Math.ceil((this.bufferOff + r.length) / this.blockSize) - 1,
          f = new Array(c * this.blockSize);
        c > 0;
        c--
      )
        (s += this._buffer(r, s)), (n += this._flushBuffer(f, n));
      return (s += this._buffer(r, s)), f;
    }),
    (e.prototype.final = function (r) {
      var s;
      r && (s = this.update(r));
      var n;
      return (
        this.type === 'encrypt' ? (n = this._finalEncrypt()) : (n = this._finalDecrypt()),
        s ? s.concat(n) : n
      );
    }),
    (e.prototype._pad = function (r, s) {
      if (s === 0) return !1;
      for (; s < r.length; ) r[s++] = 0;
      return !0;
    }),
    (e.prototype._finalEncrypt = function () {
      if (!this._pad(this.buffer, this.bufferOff)) return [];
      var r = new Array(this.blockSize);
      return this._update(this.buffer, 0, r, 0), r;
    }),
    (e.prototype._unpad = function (r) {
      return r;
    }),
    (e.prototype._finalDecrypt = function () {
      i.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');
      var r = new Array(this.blockSize);
      return this._flushBuffer(r, 0), this._unpad(r);
    }),
    yd
  );
}
var gd, Ob;
function V6() {
  if (Ob) return gd;
  Ob = 1;
  var i = Qi,
    e = dt,
    t = j6(),
    r = oy();
  function s() {
    (this.tmp = new Array(2)), (this.keys = null);
  }
  function n(f) {
    r.call(this, f);
    var h = new s();
    (this._desState = h), this.deriveKeys(h, f.key);
  }
  e(n, r),
    (gd = n),
    (n.create = function (h) {
      return new n(h);
    });
  var c = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
  return (
    (n.prototype.deriveKeys = function (h, y) {
      (h.keys = new Array(16 * 2)), i.equal(y.length, this.blockSize, 'Invalid key length');
      var p = t.readUInt32BE(y, 0),
        m = t.readUInt32BE(y, 4);
      t.pc1(p, m, h.tmp, 0), (p = h.tmp[0]), (m = h.tmp[1]);
      for (var _ = 0; _ < h.keys.length; _ += 2) {
        var A = c[_ >>> 1];
        (p = t.r28shl(p, A)), (m = t.r28shl(m, A)), t.pc2(p, m, h.keys, _);
      }
    }),
    (n.prototype._update = function (h, y, p, m) {
      var _ = this._desState,
        A = t.readUInt32BE(h, y),
        E = t.readUInt32BE(h, y + 4);
      t.ip(A, E, _.tmp, 0),
        (A = _.tmp[0]),
        (E = _.tmp[1]),
        this.type === 'encrypt'
          ? this._encrypt(_, A, E, _.tmp, 0)
          : this._decrypt(_, A, E, _.tmp, 0),
        (A = _.tmp[0]),
        (E = _.tmp[1]),
        t.writeUInt32BE(p, A, m),
        t.writeUInt32BE(p, E, m + 4);
    }),
    (n.prototype._pad = function (h, y) {
      for (var p = h.length - y, m = y; m < h.length; m++) h[m] = p;
      return !0;
    }),
    (n.prototype._unpad = function (h) {
      for (var y = h[h.length - 1], p = h.length - y; p < h.length; p++) i.equal(h[p], y);
      return h.slice(0, h.length - y);
    }),
    (n.prototype._encrypt = function (h, y, p, m, _) {
      for (var A = y, E = p, I = 0; I < h.keys.length; I += 2) {
        var R = h.keys[I],
          L = h.keys[I + 1];
        t.expand(E, h.tmp, 0), (R ^= h.tmp[0]), (L ^= h.tmp[1]);
        var D = t.substitute(R, L),
          q = t.permute(D),
          H = E;
        (E = (A ^ q) >>> 0), (A = H);
      }
      t.rip(E, A, m, _);
    }),
    (n.prototype._decrypt = function (h, y, p, m, _) {
      for (var A = p, E = y, I = h.keys.length - 2; I >= 0; I -= 2) {
        var R = h.keys[I],
          L = h.keys[I + 1];
        t.expand(A, h.tmp, 0), (R ^= h.tmp[0]), (L ^= h.tmp[1]);
        var D = t.substitute(R, L),
          q = t.permute(D),
          H = A;
        (A = (E ^ q) >>> 0), (E = H);
      }
      t.rip(A, E, m, _);
    }),
    gd
  );
}
var bd = {},
  Cb;
function Y9() {
  if (Cb) return bd;
  Cb = 1;
  var i = Qi,
    e = dt,
    t = {};
  function r(n) {
    i.equal(n.length, 8, 'Invalid IV length'), (this.iv = new Array(8));
    for (var c = 0; c < this.iv.length; c++) this.iv[c] = n[c];
  }
  function s(n) {
    function c(p) {
      n.call(this, p), this._cbcInit();
    }
    e(c, n);
    for (var f = Object.keys(t), h = 0; h < f.length; h++) {
      var y = f[h];
      c.prototype[y] = t[y];
    }
    return (
      (c.create = function (m) {
        return new c(m);
      }),
      c
    );
  }
  return (
    (bd.instantiate = s),
    (t._cbcInit = function () {
      var c = new r(this.options.iv);
      this._cbcState = c;
    }),
    (t._update = function (c, f, h, y) {
      var p = this._cbcState,
        m = this.constructor.super_.prototype,
        _ = p.iv;
      if (this.type === 'encrypt') {
        for (var A = 0; A < this.blockSize; A++) _[A] ^= c[f + A];
        m._update.call(this, _, 0, h, y);
        for (var A = 0; A < this.blockSize; A++) _[A] = h[y + A];
      } else {
        m._update.call(this, c, f, h, y);
        for (var A = 0; A < this.blockSize; A++) h[y + A] ^= _[A];
        for (var A = 0; A < this.blockSize; A++) _[A] = c[f + A];
      }
    }),
    bd
  );
}
var vd, Lb;
function Z9() {
  if (Lb) return vd;
  Lb = 1;
  var i = Qi,
    e = dt,
    t = oy(),
    r = V6();
  function s(c, f) {
    i.equal(f.length, 24, 'Invalid key length');
    var h = f.slice(0, 8),
      y = f.slice(8, 16),
      p = f.slice(16, 24);
    c === 'encrypt'
      ? (this.ciphers = [
          r.create({ type: 'encrypt', key: h }),
          r.create({ type: 'decrypt', key: y }),
          r.create({ type: 'encrypt', key: p }),
        ])
      : (this.ciphers = [
          r.create({ type: 'decrypt', key: p }),
          r.create({ type: 'encrypt', key: y }),
          r.create({ type: 'decrypt', key: h }),
        ]);
  }
  function n(c) {
    t.call(this, c);
    var f = new s(this.type, this.options.key);
    this._edeState = f;
  }
  return (
    e(n, t),
    (vd = n),
    (n.create = function (f) {
      return new n(f);
    }),
    (n.prototype._update = function (f, h, y, p) {
      var m = this._edeState;
      m.ciphers[0]._update(f, h, y, p),
        m.ciphers[1]._update(y, p, y, p),
        m.ciphers[2]._update(y, p, y, p);
    }),
    (n.prototype._pad = r.prototype._pad),
    (n.prototype._unpad = r.prototype._unpad),
    vd
  );
}
var Nb;
function J9() {
  return (
    Nb ||
      ((Nb = 1),
      (Vo.utils = j6()),
      (Vo.Cipher = oy()),
      (Vo.DES = V6()),
      (Vo.CBC = Y9()),
      (Vo.EDE = Z9())),
    Vo
  );
}
var md, $b;
function X9() {
  if ($b) return md;
  $b = 1;
  var i = Wo,
    e = J9(),
    t = dt,
    r = At.Buffer,
    s = {
      'des-ede3-cbc': e.CBC.instantiate(e.EDE),
      'des-ede3': e.EDE,
      'des-ede-cbc': e.CBC.instantiate(e.EDE),
      'des-ede': e.EDE,
      'des-cbc': e.CBC.instantiate(e.DES),
      'des-ecb': e.DES,
    };
  (s.des = s['des-cbc']), (s.des3 = s['des-ede3-cbc']), (md = n), t(n, i);
  function n(c) {
    i.call(this);
    var f = c.mode.toLowerCase(),
      h = s[f],
      y;
    c.decrypt ? (y = 'decrypt') : (y = 'encrypt');
    var p = c.key;
    r.isBuffer(p) || (p = r.from(p)),
      (f === 'des-ede' || f === 'des-ede-cbc') && (p = r.concat([p, p.slice(0, 8)]));
    var m = c.iv;
    r.isBuffer(m) || (m = r.from(m)), (this._des = h.create({ key: p, iv: m, type: y }));
  }
  return (
    (n.prototype._update = function (c) {
      return r.from(this._des.update(c));
    }),
    (n.prototype._final = function () {
      return r.from(this._des.final());
    }),
    md
  );
}
var Wi = {},
  Kc = {},
  jc = {},
  Db;
function Q9() {
  return (
    Db ||
      ((Db = 1),
      (jc.encrypt = function (i, e) {
        return i._cipher.encryptBlock(e);
      }),
      (jc.decrypt = function (i, e) {
        return i._cipher.decryptBlock(e);
      })),
    jc
  );
}
var Hc = {},
  wd,
  Ub;
function rc() {
  return (
    Ub ||
      ((Ub = 1),
      (wd = function (e, t) {
        for (var r = Math.min(e.length, t.length), s = new Ze(r), n = 0; n < r; ++n)
          s[n] = e[n] ^ t[n];
        return s;
      })),
    wd
  );
}
var zb;
function ek() {
  if (zb) return Hc;
  zb = 1;
  var i = rc();
  return (
    (Hc.encrypt = function (e, t) {
      var r = i(t, e._prev);
      return (e._prev = e._cipher.encryptBlock(r)), e._prev;
    }),
    (Hc.decrypt = function (e, t) {
      var r = e._prev;
      e._prev = t;
      var s = e._cipher.decryptBlock(t);
      return i(s, r);
    }),
    Hc
  );
}
var _d = {},
  Fb;
function tk() {
  if (Fb) return _d;
  Fb = 1;
  var i = At.Buffer,
    e = rc();
  function t(r, s, n) {
    var c = s.length,
      f = e(s, r._cache);
    return (r._cache = r._cache.slice(c)), (r._prev = i.concat([r._prev, n ? s : f])), f;
  }
  return (
    (_d.encrypt = function (r, s, n) {
      for (var c = i.allocUnsafe(0), f; s.length; )
        if (
          (r._cache.length === 0 &&
            ((r._cache = r._cipher.encryptBlock(r._prev)), (r._prev = i.allocUnsafe(0))),
          r._cache.length <= s.length)
        )
          (f = r._cache.length), (c = i.concat([c, t(r, s.slice(0, f), n)])), (s = s.slice(f));
        else {
          c = i.concat([c, t(r, s, n)]);
          break;
        }
      return c;
    }),
    _d
  );
}
var Sd = {},
  qb;
function rk() {
  if (qb) return Sd;
  qb = 1;
  var i = At.Buffer;
  function e(t, r, s) {
    var n = t._cipher.encryptBlock(t._prev),
      c = n[0] ^ r;
    return (t._prev = i.concat([t._prev.slice(1), i.from([s ? r : c])])), c;
  }
  return (
    (Sd.encrypt = function (t, r, s) {
      for (var n = r.length, c = i.allocUnsafe(n), f = -1; ++f < n; ) c[f] = e(t, r[f], s);
      return c;
    }),
    Sd
  );
}
var Md = {},
  Wb;
function ik() {
  if (Wb) return Md;
  Wb = 1;
  var i = At.Buffer;
  function e(r, s, n) {
    for (var c, f = -1, h = 8, y = 0, p, m; ++f < h; )
      (c = r._cipher.encryptBlock(r._prev)),
        (p = s & (1 << (7 - f)) ? 128 : 0),
        (m = c[0] ^ p),
        (y += (m & 128) >> f % 8),
        (r._prev = t(r._prev, n ? p : m));
    return y;
  }
  function t(r, s) {
    var n = r.length,
      c = -1,
      f = i.allocUnsafe(r.length);
    for (r = i.concat([r, i.from([s])]); ++c < n; ) f[c] = (r[c] << 1) | (r[c + 1] >> 7);
    return f;
  }
  return (
    (Md.encrypt = function (r, s, n) {
      for (var c = s.length, f = i.allocUnsafe(c), h = -1; ++h < c; ) f[h] = e(r, s[h], n);
      return f;
    }),
    Md
  );
}
var Ad = {},
  Kb;
function nk() {
  if (Kb) return Ad;
  Kb = 1;
  var i = rc();
  function e(t) {
    return (t._prev = t._cipher.encryptBlock(t._prev)), t._prev;
  }
  return (
    (Ad.encrypt = function (t, r) {
      for (; t._cache.length < r.length; ) t._cache = Ze.concat([t._cache, e(t)]);
      var s = t._cache.slice(0, r.length);
      return (t._cache = t._cache.slice(r.length)), i(r, s);
    }),
    Ad
  );
}
var Ed = {},
  kd,
  jb;
function G6() {
  if (jb) return kd;
  jb = 1;
  function i(e) {
    for (var t = e.length, r; t--; )
      if (((r = e.readUInt8(t)), r === 255)) e.writeUInt8(0, t);
      else {
        r++, e.writeUInt8(r, t);
        break;
      }
  }
  return (kd = i), kd;
}
var Hb;
function Vb() {
  if (Hb) return Ed;
  Hb = 1;
  var i = rc(),
    e = At.Buffer,
    t = G6();
  function r(n) {
    var c = n._cipher.encryptBlockRaw(n._prev);
    return t(n._prev), c;
  }
  var s = 16;
  return (
    (Ed.encrypt = function (n, c) {
      var f = Math.ceil(c.length / s),
        h = n._cache.length;
      n._cache = e.concat([n._cache, e.allocUnsafe(f * s)]);
      for (var y = 0; y < f; y++) {
        var p = r(n),
          m = h + y * s;
        n._cache.writeUInt32BE(p[0], m + 0),
          n._cache.writeUInt32BE(p[1], m + 4),
          n._cache.writeUInt32BE(p[2], m + 8),
          n._cache.writeUInt32BE(p[3], m + 12);
      }
      var _ = n._cache.slice(0, c.length);
      return (n._cache = n._cache.slice(c.length)), i(c, _);
    }),
    Ed
  );
}
const ok = { cipher: 'AES', key: 128, iv: 16, mode: 'CBC', type: 'block' },
  sk = { cipher: 'AES', key: 192, iv: 16, mode: 'CBC', type: 'block' },
  ak = { cipher: 'AES', key: 256, iv: 16, mode: 'CBC', type: 'block' },
  Y6 = {
    'aes-128-ecb': { cipher: 'AES', key: 128, iv: 0, mode: 'ECB', type: 'block' },
    'aes-192-ecb': { cipher: 'AES', key: 192, iv: 0, mode: 'ECB', type: 'block' },
    'aes-256-ecb': { cipher: 'AES', key: 256, iv: 0, mode: 'ECB', type: 'block' },
    'aes-128-cbc': { cipher: 'AES', key: 128, iv: 16, mode: 'CBC', type: 'block' },
    'aes-192-cbc': { cipher: 'AES', key: 192, iv: 16, mode: 'CBC', type: 'block' },
    'aes-256-cbc': { cipher: 'AES', key: 256, iv: 16, mode: 'CBC', type: 'block' },
    aes128: ok,
    aes192: sk,
    aes256: ak,
    'aes-128-cfb': { cipher: 'AES', key: 128, iv: 16, mode: 'CFB', type: 'stream' },
    'aes-192-cfb': { cipher: 'AES', key: 192, iv: 16, mode: 'CFB', type: 'stream' },
    'aes-256-cfb': { cipher: 'AES', key: 256, iv: 16, mode: 'CFB', type: 'stream' },
    'aes-128-cfb8': { cipher: 'AES', key: 128, iv: 16, mode: 'CFB8', type: 'stream' },
    'aes-192-cfb8': { cipher: 'AES', key: 192, iv: 16, mode: 'CFB8', type: 'stream' },
    'aes-256-cfb8': { cipher: 'AES', key: 256, iv: 16, mode: 'CFB8', type: 'stream' },
    'aes-128-cfb1': { cipher: 'AES', key: 128, iv: 16, mode: 'CFB1', type: 'stream' },
    'aes-192-cfb1': { cipher: 'AES', key: 192, iv: 16, mode: 'CFB1', type: 'stream' },
    'aes-256-cfb1': { cipher: 'AES', key: 256, iv: 16, mode: 'CFB1', type: 'stream' },
    'aes-128-ofb': { cipher: 'AES', key: 128, iv: 16, mode: 'OFB', type: 'stream' },
    'aes-192-ofb': { cipher: 'AES', key: 192, iv: 16, mode: 'OFB', type: 'stream' },
    'aes-256-ofb': { cipher: 'AES', key: 256, iv: 16, mode: 'OFB', type: 'stream' },
    'aes-128-ctr': { cipher: 'AES', key: 128, iv: 16, mode: 'CTR', type: 'stream' },
    'aes-192-ctr': { cipher: 'AES', key: 192, iv: 16, mode: 'CTR', type: 'stream' },
    'aes-256-ctr': { cipher: 'AES', key: 256, iv: 16, mode: 'CTR', type: 'stream' },
    'aes-128-gcm': { cipher: 'AES', key: 128, iv: 12, mode: 'GCM', type: 'auth' },
    'aes-192-gcm': { cipher: 'AES', key: 192, iv: 12, mode: 'GCM', type: 'auth' },
    'aes-256-gcm': { cipher: 'AES', key: 256, iv: 12, mode: 'GCM', type: 'auth' },
  };
var Id, Gb;
function sy() {
  if (Gb) return Id;
  Gb = 1;
  var i = {
      ECB: Q9(),
      CBC: ek(),
      CFB: tk(),
      CFB8: rk(),
      CFB1: ik(),
      OFB: nk(),
      CTR: Vb(),
      GCM: Vb(),
    },
    e = Y6;
  for (var t in e) e[t].module = i[e[t].mode];
  return (Id = e), Id;
}
var xd = {},
  Yb;
function Ol() {
  if (Yb) return xd;
  Yb = 1;
  var i = At.Buffer;
  function e(f) {
    i.isBuffer(f) || (f = i.from(f));
    for (var h = (f.length / 4) | 0, y = new Array(h), p = 0; p < h; p++)
      y[p] = f.readUInt32BE(p * 4);
    return y;
  }
  function t(f) {
    for (var h = 0; h < f.length; f++) f[h] = 0;
  }
  function r(f, h, y, p, m) {
    for (
      var _ = y[0],
        A = y[1],
        E = y[2],
        I = y[3],
        R = f[0] ^ h[0],
        L = f[1] ^ h[1],
        D = f[2] ^ h[2],
        q = f[3] ^ h[3],
        H,
        V,
        te,
        ue,
        ne = 4,
        X = 1;
      X < m;
      X++
    )
      (H = _[R >>> 24] ^ A[(L >>> 16) & 255] ^ E[(D >>> 8) & 255] ^ I[q & 255] ^ h[ne++]),
        (V = _[L >>> 24] ^ A[(D >>> 16) & 255] ^ E[(q >>> 8) & 255] ^ I[R & 255] ^ h[ne++]),
        (te = _[D >>> 24] ^ A[(q >>> 16) & 255] ^ E[(R >>> 8) & 255] ^ I[L & 255] ^ h[ne++]),
        (ue = _[q >>> 24] ^ A[(R >>> 16) & 255] ^ E[(L >>> 8) & 255] ^ I[D & 255] ^ h[ne++]),
        (R = H),
        (L = V),
        (D = te),
        (q = ue);
    return (
      (H =
        ((p[R >>> 24] << 24) |
          (p[(L >>> 16) & 255] << 16) |
          (p[(D >>> 8) & 255] << 8) |
          p[q & 255]) ^
        h[ne++]),
      (V =
        ((p[L >>> 24] << 24) |
          (p[(D >>> 16) & 255] << 16) |
          (p[(q >>> 8) & 255] << 8) |
          p[R & 255]) ^
        h[ne++]),
      (te =
        ((p[D >>> 24] << 24) |
          (p[(q >>> 16) & 255] << 16) |
          (p[(R >>> 8) & 255] << 8) |
          p[L & 255]) ^
        h[ne++]),
      (ue =
        ((p[q >>> 24] << 24) |
          (p[(R >>> 16) & 255] << 16) |
          (p[(L >>> 8) & 255] << 8) |
          p[D & 255]) ^
        h[ne++]),
      (H = H >>> 0),
      (V = V >>> 0),
      (te = te >>> 0),
      (ue = ue >>> 0),
      [H, V, te, ue]
    );
  }
  var s = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54],
    n = (function () {
      for (var f = new Array(256), h = 0; h < 256; h++)
        h < 128 ? (f[h] = h << 1) : (f[h] = (h << 1) ^ 283);
      for (
        var y = [], p = [], m = [[], [], [], []], _ = [[], [], [], []], A = 0, E = 0, I = 0;
        I < 256;
        ++I
      ) {
        var R = E ^ (E << 1) ^ (E << 2) ^ (E << 3) ^ (E << 4);
        (R = (R >>> 8) ^ (R & 255) ^ 99), (y[A] = R), (p[R] = A);
        var L = f[A],
          D = f[L],
          q = f[D],
          H = (f[R] * 257) ^ (R * 16843008);
        (m[0][A] = (H << 24) | (H >>> 8)),
          (m[1][A] = (H << 16) | (H >>> 16)),
          (m[2][A] = (H << 8) | (H >>> 24)),
          (m[3][A] = H),
          (H = (q * 16843009) ^ (D * 65537) ^ (L * 257) ^ (A * 16843008)),
          (_[0][R] = (H << 24) | (H >>> 8)),
          (_[1][R] = (H << 16) | (H >>> 16)),
          (_[2][R] = (H << 8) | (H >>> 24)),
          (_[3][R] = H),
          A === 0 ? (A = E = 1) : ((A = L ^ f[f[f[q ^ L]]]), (E ^= f[f[E]]));
      }
      return { SBOX: y, INV_SBOX: p, SUB_MIX: m, INV_SUB_MIX: _ };
    })();
  function c(f) {
    (this._key = e(f)), this._reset();
  }
  return (
    (c.blockSize = 4 * 4),
    (c.keySize = 256 / 8),
    (c.prototype.blockSize = c.blockSize),
    (c.prototype.keySize = c.keySize),
    (c.prototype._reset = function () {
      for (var f = this._key, h = f.length, y = h + 6, p = (y + 1) * 4, m = [], _ = 0; _ < h; _++)
        m[_] = f[_];
      for (_ = h; _ < p; _++) {
        var A = m[_ - 1];
        _ % h === 0
          ? ((A = (A << 8) | (A >>> 24)),
            (A =
              (n.SBOX[A >>> 24] << 24) |
              (n.SBOX[(A >>> 16) & 255] << 16) |
              (n.SBOX[(A >>> 8) & 255] << 8) |
              n.SBOX[A & 255]),
            (A ^= s[(_ / h) | 0] << 24))
          : h > 6 &&
            _ % h === 4 &&
            (A =
              (n.SBOX[A >>> 24] << 24) |
              (n.SBOX[(A >>> 16) & 255] << 16) |
              (n.SBOX[(A >>> 8) & 255] << 8) |
              n.SBOX[A & 255]),
          (m[_] = m[_ - h] ^ A);
      }
      for (var E = [], I = 0; I < p; I++) {
        var R = p - I,
          L = m[R - (I % 4 ? 0 : 4)];
        I < 4 || R <= 4
          ? (E[I] = L)
          : (E[I] =
              n.INV_SUB_MIX[0][n.SBOX[L >>> 24]] ^
              n.INV_SUB_MIX[1][n.SBOX[(L >>> 16) & 255]] ^
              n.INV_SUB_MIX[2][n.SBOX[(L >>> 8) & 255]] ^
              n.INV_SUB_MIX[3][n.SBOX[L & 255]]);
      }
      (this._nRounds = y), (this._keySchedule = m), (this._invKeySchedule = E);
    }),
    (c.prototype.encryptBlockRaw = function (f) {
      return (f = e(f)), r(f, this._keySchedule, n.SUB_MIX, n.SBOX, this._nRounds);
    }),
    (c.prototype.encryptBlock = function (f) {
      var h = this.encryptBlockRaw(f),
        y = i.allocUnsafe(16);
      return (
        y.writeUInt32BE(h[0], 0),
        y.writeUInt32BE(h[1], 4),
        y.writeUInt32BE(h[2], 8),
        y.writeUInt32BE(h[3], 12),
        y
      );
    }),
    (c.prototype.decryptBlock = function (f) {
      f = e(f);
      var h = f[1];
      (f[1] = f[3]), (f[3] = h);
      var y = r(f, this._invKeySchedule, n.INV_SUB_MIX, n.INV_SBOX, this._nRounds),
        p = i.allocUnsafe(16);
      return (
        p.writeUInt32BE(y[0], 0),
        p.writeUInt32BE(y[3], 4),
        p.writeUInt32BE(y[2], 8),
        p.writeUInt32BE(y[1], 12),
        p
      );
    }),
    (c.prototype.scrub = function () {
      t(this._keySchedule), t(this._invKeySchedule), t(this._key);
    }),
    (xd.AES = c),
    xd
  );
}
var Bd, Zb;
function uk() {
  if (Zb) return Bd;
  Zb = 1;
  var i = At.Buffer,
    e = i.alloc(16, 0);
  function t(n) {
    return [n.readUInt32BE(0), n.readUInt32BE(4), n.readUInt32BE(8), n.readUInt32BE(12)];
  }
  function r(n) {
    var c = i.allocUnsafe(16);
    return (
      c.writeUInt32BE(n[0] >>> 0, 0),
      c.writeUInt32BE(n[1] >>> 0, 4),
      c.writeUInt32BE(n[2] >>> 0, 8),
      c.writeUInt32BE(n[3] >>> 0, 12),
      c
    );
  }
  function s(n) {
    (this.h = n), (this.state = i.alloc(16, 0)), (this.cache = i.allocUnsafe(0));
  }
  return (
    (s.prototype.ghash = function (n) {
      for (var c = -1; ++c < n.length; ) this.state[c] ^= n[c];
      this._multiply();
    }),
    (s.prototype._multiply = function () {
      for (var n = t(this.h), c = [0, 0, 0, 0], f, h, y, p = -1; ++p < 128; ) {
        for (
          h = (this.state[~~(p / 8)] & (1 << (7 - (p % 8)))) !== 0,
            h && ((c[0] ^= n[0]), (c[1] ^= n[1]), (c[2] ^= n[2]), (c[3] ^= n[3])),
            y = (n[3] & 1) !== 0,
            f = 3;
          f > 0;
          f--
        )
          n[f] = (n[f] >>> 1) | ((n[f - 1] & 1) << 31);
        (n[0] = n[0] >>> 1), y && (n[0] = n[0] ^ (225 << 24));
      }
      this.state = r(c);
    }),
    (s.prototype.update = function (n) {
      this.cache = i.concat([this.cache, n]);
      for (var c; this.cache.length >= 16; )
        (c = this.cache.slice(0, 16)), (this.cache = this.cache.slice(16)), this.ghash(c);
    }),
    (s.prototype.final = function (n, c) {
      return (
        this.cache.length && this.ghash(i.concat([this.cache, e], 16)),
        this.ghash(r([0, n, 0, c])),
        this.state
      );
    }),
    (Bd = s),
    Bd
  );
}
var Rd, Jb;
function Z6() {
  if (Jb) return Rd;
  Jb = 1;
  var i = Ol(),
    e = At.Buffer,
    t = Wo,
    r = dt,
    s = uk(),
    n = rc(),
    c = G6();
  function f(p, m) {
    var _ = 0;
    p.length !== m.length && _++;
    for (var A = Math.min(p.length, m.length), E = 0; E < A; ++E) _ += p[E] ^ m[E];
    return _;
  }
  function h(p, m, _) {
    if (m.length === 12)
      return (p._finID = e.concat([m, e.from([0, 0, 0, 1])])), e.concat([m, e.from([0, 0, 0, 2])]);
    var A = new s(_),
      E = m.length,
      I = E % 16;
    A.update(m), I && ((I = 16 - I), A.update(e.alloc(I, 0))), A.update(e.alloc(8, 0));
    var R = E * 8,
      L = e.alloc(8);
    L.writeUIntBE(R, 0, 8), A.update(L), (p._finID = A.state);
    var D = e.from(p._finID);
    return c(D), D;
  }
  function y(p, m, _, A) {
    t.call(this);
    var E = e.alloc(4, 0);
    this._cipher = new i.AES(m);
    var I = this._cipher.encryptBlock(E);
    (this._ghash = new s(I)),
      (_ = h(this, _, I)),
      (this._prev = e.from(_)),
      (this._cache = e.allocUnsafe(0)),
      (this._secCache = e.allocUnsafe(0)),
      (this._decrypt = A),
      (this._alen = 0),
      (this._len = 0),
      (this._mode = p),
      (this._authTag = null),
      (this._called = !1);
  }
  return (
    r(y, t),
    (y.prototype._update = function (p) {
      if (!this._called && this._alen) {
        var m = 16 - (this._alen % 16);
        m < 16 && ((m = e.alloc(m, 0)), this._ghash.update(m));
      }
      this._called = !0;
      var _ = this._mode.encrypt(this, p);
      return (
        this._decrypt ? this._ghash.update(p) : this._ghash.update(_), (this._len += p.length), _
      );
    }),
    (y.prototype._final = function () {
      if (this._decrypt && !this._authTag)
        throw new Error('Unsupported state or unable to authenticate data');
      var p = n(
        this._ghash.final(this._alen * 8, this._len * 8),
        this._cipher.encryptBlock(this._finID)
      );
      if (this._decrypt && f(p, this._authTag))
        throw new Error('Unsupported state or unable to authenticate data');
      (this._authTag = p), this._cipher.scrub();
    }),
    (y.prototype.getAuthTag = function () {
      if (this._decrypt || !e.isBuffer(this._authTag))
        throw new Error('Attempting to get auth tag in unsupported state');
      return this._authTag;
    }),
    (y.prototype.setAuthTag = function (m) {
      if (!this._decrypt) throw new Error('Attempting to set auth tag in unsupported state');
      this._authTag = m;
    }),
    (y.prototype.setAAD = function (m) {
      if (this._called) throw new Error('Attempting to set AAD in unsupported state');
      this._ghash.update(m), (this._alen += m.length);
    }),
    (Rd = y),
    Rd
  );
}
var Pd, Xb;
function J6() {
  if (Xb) return Pd;
  Xb = 1;
  var i = Ol(),
    e = At.Buffer,
    t = Wo,
    r = dt;
  function s(n, c, f, h) {
    t.call(this),
      (this._cipher = new i.AES(c)),
      (this._prev = e.from(f)),
      (this._cache = e.allocUnsafe(0)),
      (this._secCache = e.allocUnsafe(0)),
      (this._decrypt = h),
      (this._mode = n);
  }
  return (
    r(s, t),
    (s.prototype._update = function (n) {
      return this._mode.encrypt(this, n, this._decrypt);
    }),
    (s.prototype._final = function () {
      this._cipher.scrub();
    }),
    (Pd = s),
    Pd
  );
}
var Td, Qb;
function Cl() {
  if (Qb) return Td;
  Qb = 1;
  var i = At.Buffer,
    e = ty;
  function t(r, s, n, c) {
    if (
      (i.isBuffer(r) || (r = i.from(r, 'binary')),
      s && (i.isBuffer(s) || (s = i.from(s, 'binary')), s.length !== 8))
    )
      throw new RangeError('salt should be Buffer with 8 byte length');
    for (var f = n / 8, h = i.alloc(f), y = i.alloc(c || 0), p = i.alloc(0); f > 0 || c > 0; ) {
      var m = new e();
      m.update(p), m.update(r), s && m.update(s), (p = m.digest());
      var _ = 0;
      if (f > 0) {
        var A = h.length - f;
        (_ = Math.min(f, p.length)), p.copy(h, A, 0, _), (f -= _);
      }
      if (_ < p.length && c > 0) {
        var E = y.length - c,
          I = Math.min(c, p.length - _);
        p.copy(y, E, _, _ + I), (c -= I);
      }
    }
    return p.fill(0), { key: h, iv: y };
  }
  return (Td = t), Td;
}
var ev;
function ck() {
  if (ev) return Kc;
  ev = 1;
  var i = sy(),
    e = Z6(),
    t = At.Buffer,
    r = J6(),
    s = Wo,
    n = Ol(),
    c = Cl(),
    f = dt;
  function h(A, E, I) {
    s.call(this),
      (this._cache = new p()),
      (this._cipher = new n.AES(E)),
      (this._prev = t.from(I)),
      (this._mode = A),
      (this._autopadding = !0);
  }
  f(h, s),
    (h.prototype._update = function (A) {
      this._cache.add(A);
      for (var E, I, R = []; (E = this._cache.get()); )
        (I = this._mode.encrypt(this, E)), R.push(I);
      return t.concat(R);
    });
  var y = t.alloc(16, 16);
  (h.prototype._final = function () {
    var A = this._cache.flush();
    if (this._autopadding) return (A = this._mode.encrypt(this, A)), this._cipher.scrub(), A;
    if (!A.equals(y)) throw (this._cipher.scrub(), new Error('data not multiple of block length'));
  }),
    (h.prototype.setAutoPadding = function (A) {
      return (this._autopadding = !!A), this;
    });
  function p() {
    this.cache = t.allocUnsafe(0);
  }
  (p.prototype.add = function (A) {
    this.cache = t.concat([this.cache, A]);
  }),
    (p.prototype.get = function () {
      if (this.cache.length > 15) {
        var A = this.cache.slice(0, 16);
        return (this.cache = this.cache.slice(16)), A;
      }
      return null;
    }),
    (p.prototype.flush = function () {
      for (var A = 16 - this.cache.length, E = t.allocUnsafe(A), I = -1; ++I < A; )
        E.writeUInt8(A, I);
      return t.concat([this.cache, E]);
    });
  function m(A, E, I) {
    var R = i[A.toLowerCase()];
    if (!R) throw new TypeError('invalid suite type');
    if ((typeof E == 'string' && (E = t.from(E)), E.length !== R.key / 8))
      throw new TypeError('invalid key length ' + E.length);
    if ((typeof I == 'string' && (I = t.from(I)), R.mode !== 'GCM' && I.length !== R.iv))
      throw new TypeError('invalid iv length ' + I.length);
    return R.type === 'stream'
      ? new r(R.module, E, I)
      : R.type === 'auth'
        ? new e(R.module, E, I)
        : new h(R.module, E, I);
  }
  function _(A, E) {
    var I = i[A.toLowerCase()];
    if (!I) throw new TypeError('invalid suite type');
    var R = c(E, !1, I.key, I.iv);
    return m(A, R.key, R.iv);
  }
  return (Kc.createCipheriv = m), (Kc.createCipher = _), Kc;
}
var Vc = {},
  tv;
function fk() {
  if (tv) return Vc;
  tv = 1;
  var i = Z6(),
    e = At.Buffer,
    t = sy(),
    r = J6(),
    s = Wo,
    n = Ol(),
    c = Cl(),
    f = dt;
  function h(A, E, I) {
    s.call(this),
      (this._cache = new y()),
      (this._last = void 0),
      (this._cipher = new n.AES(E)),
      (this._prev = e.from(I)),
      (this._mode = A),
      (this._autopadding = !0);
  }
  f(h, s),
    (h.prototype._update = function (A) {
      this._cache.add(A);
      for (var E, I, R = []; (E = this._cache.get(this._autopadding)); )
        (I = this._mode.decrypt(this, E)), R.push(I);
      return e.concat(R);
    }),
    (h.prototype._final = function () {
      var A = this._cache.flush();
      if (this._autopadding) return p(this._mode.decrypt(this, A));
      if (A) throw new Error('data not multiple of block length');
    }),
    (h.prototype.setAutoPadding = function (A) {
      return (this._autopadding = !!A), this;
    });
  function y() {
    this.cache = e.allocUnsafe(0);
  }
  (y.prototype.add = function (A) {
    this.cache = e.concat([this.cache, A]);
  }),
    (y.prototype.get = function (A) {
      var E;
      if (A) {
        if (this.cache.length > 16)
          return (E = this.cache.slice(0, 16)), (this.cache = this.cache.slice(16)), E;
      } else if (this.cache.length >= 16)
        return (E = this.cache.slice(0, 16)), (this.cache = this.cache.slice(16)), E;
      return null;
    }),
    (y.prototype.flush = function () {
      if (this.cache.length) return this.cache;
    });
  function p(A) {
    var E = A[15];
    if (E < 1 || E > 16) throw new Error('unable to decrypt data');
    for (var I = -1; ++I < E; )
      if (A[I + (16 - E)] !== E) throw new Error('unable to decrypt data');
    if (E !== 16) return A.slice(0, 16 - E);
  }
  function m(A, E, I) {
    var R = t[A.toLowerCase()];
    if (!R) throw new TypeError('invalid suite type');
    if ((typeof I == 'string' && (I = e.from(I)), R.mode !== 'GCM' && I.length !== R.iv))
      throw new TypeError('invalid iv length ' + I.length);
    if ((typeof E == 'string' && (E = e.from(E)), E.length !== R.key / 8))
      throw new TypeError('invalid key length ' + E.length);
    return R.type === 'stream'
      ? new r(R.module, E, I, !0)
      : R.type === 'auth'
        ? new i(R.module, E, I, !0)
        : new h(R.module, E, I);
  }
  function _(A, E) {
    var I = t[A.toLowerCase()];
    if (!I) throw new TypeError('invalid suite type');
    var R = c(E, !1, I.key, I.iv);
    return m(A, R.key, R.iv);
  }
  return (Vc.createDecipher = _), (Vc.createDecipheriv = m), Vc;
}
var rv;
function ay() {
  if (rv) return Wi;
  rv = 1;
  var i = ck(),
    e = fk(),
    t = Y6;
  function r() {
    return Object.keys(t);
  }
  return (
    (Wi.createCipher = Wi.Cipher = i.createCipher),
    (Wi.createCipheriv = Wi.Cipheriv = i.createCipheriv),
    (Wi.createDecipher = Wi.Decipher = e.createDecipher),
    (Wi.createDecipheriv = Wi.Decipheriv = e.createDecipheriv),
    (Wi.listCiphers = Wi.getCiphers = r),
    Wi
  );
}
var Od = {},
  iv;
function lk() {
  return (
    iv ||
      ((iv = 1),
      (function (i) {
        (i['des-ecb'] = { key: 8, iv: 0 }),
          (i['des-cbc'] = i.des = { key: 8, iv: 8 }),
          (i['des-ede3-cbc'] = i.des3 = { key: 24, iv: 8 }),
          (i['des-ede3'] = { key: 24, iv: 0 }),
          (i['des-ede-cbc'] = { key: 16, iv: 8 }),
          (i['des-ede'] = { key: 16, iv: 0 });
      })(Od)),
    Od
  );
}
var nv;
function hk() {
  if (nv) return qi;
  nv = 1;
  var i = X9(),
    e = ay(),
    t = sy(),
    r = lk(),
    s = Cl();
  function n(p, m) {
    p = p.toLowerCase();
    var _, A;
    if (t[p]) (_ = t[p].key), (A = t[p].iv);
    else if (r[p]) (_ = r[p].key * 8), (A = r[p].iv);
    else throw new TypeError('invalid suite type');
    var E = s(m, !1, _, A);
    return f(p, E.key, E.iv);
  }
  function c(p, m) {
    p = p.toLowerCase();
    var _, A;
    if (t[p]) (_ = t[p].key), (A = t[p].iv);
    else if (r[p]) (_ = r[p].key * 8), (A = r[p].iv);
    else throw new TypeError('invalid suite type');
    var E = s(m, !1, _, A);
    return h(p, E.key, E.iv);
  }
  function f(p, m, _) {
    if (((p = p.toLowerCase()), t[p])) return e.createCipheriv(p, m, _);
    if (r[p]) return new i({ key: m, iv: _, mode: p });
    throw new TypeError('invalid suite type');
  }
  function h(p, m, _) {
    if (((p = p.toLowerCase()), t[p])) return e.createDecipheriv(p, m, _);
    if (r[p]) return new i({ key: m, iv: _, mode: p, decrypt: !0 });
    throw new TypeError('invalid suite type');
  }
  function y() {
    return Object.keys(r).concat(e.getCiphers());
  }
  return (
    (qi.createCipher = qi.Cipher = n),
    (qi.createCipheriv = qi.Cipheriv = f),
    (qi.createDecipher = qi.Decipher = c),
    (qi.createDecipheriv = qi.Decipheriv = h),
    (qi.listCiphers = qi.getCiphers = y),
    qi
  );
}
var Go = {},
  vf = { exports: {} };
vf.exports;
var ov;
function X6() {
  return (
    ov ||
      ((ov = 1),
      (function (i) {
        (function (e, t) {
          function r(S, o) {
            if (!S) throw new Error(o || 'Assertion failed');
          }
          function s(S, o) {
            S.super_ = o;
            var u = function () {};
            (u.prototype = o.prototype), (S.prototype = new u()), (S.prototype.constructor = S);
          }
          function n(S, o, u) {
            if (n.isBN(S)) return S;
            (this.negative = 0),
              (this.words = null),
              (this.length = 0),
              (this.red = null),
              S !== null &&
                ((o === 'le' || o === 'be') && ((u = o), (o = 10)),
                this._init(S || 0, o || 10, u || 'be'));
          }
          typeof e == 'object' ? (e.exports = n) : (t.BN = n), (n.BN = n), (n.wordSize = 26);
          var c;
          try {
            typeof window < 'u' && typeof window.Buffer < 'u'
              ? (c = window.Buffer)
              : (c = ai.Buffer);
          } catch {}
          (n.isBN = function (o) {
            return o instanceof n
              ? !0
              : o !== null &&
                  typeof o == 'object' &&
                  o.constructor.wordSize === n.wordSize &&
                  Array.isArray(o.words);
          }),
            (n.max = function (o, u) {
              return o.cmp(u) > 0 ? o : u;
            }),
            (n.min = function (o, u) {
              return o.cmp(u) < 0 ? o : u;
            }),
            (n.prototype._init = function (o, u, l) {
              if (typeof o == 'number') return this._initNumber(o, u, l);
              if (typeof o == 'object') return this._initArray(o, u, l);
              u === 'hex' && (u = 16),
                r(u === (u | 0) && u >= 2 && u <= 36),
                (o = o.toString().replace(/\s+/g, ''));
              var d = 0;
              o[0] === '-' && (d++, (this.negative = 1)),
                d < o.length &&
                  (u === 16
                    ? this._parseHex(o, d, l)
                    : (this._parseBase(o, u, d),
                      l === 'le' && this._initArray(this.toArray(), u, l)));
            }),
            (n.prototype._initNumber = function (o, u, l) {
              o < 0 && ((this.negative = 1), (o = -o)),
                o < 67108864
                  ? ((this.words = [o & 67108863]), (this.length = 1))
                  : o < 4503599627370496
                    ? ((this.words = [o & 67108863, (o / 67108864) & 67108863]), (this.length = 2))
                    : (r(o < 9007199254740992),
                      (this.words = [o & 67108863, (o / 67108864) & 67108863, 1]),
                      (this.length = 3)),
                l === 'le' && this._initArray(this.toArray(), u, l);
            }),
            (n.prototype._initArray = function (o, u, l) {
              if ((r(typeof o.length == 'number'), o.length <= 0))
                return (this.words = [0]), (this.length = 1), this;
              (this.length = Math.ceil(o.length / 3)), (this.words = new Array(this.length));
              for (var d = 0; d < this.length; d++) this.words[d] = 0;
              var g,
                w,
                M = 0;
              if (l === 'be')
                for (d = o.length - 1, g = 0; d >= 0; d -= 3)
                  (w = o[d] | (o[d - 1] << 8) | (o[d - 2] << 16)),
                    (this.words[g] |= (w << M) & 67108863),
                    (this.words[g + 1] = (w >>> (26 - M)) & 67108863),
                    (M += 24),
                    M >= 26 && ((M -= 26), g++);
              else if (l === 'le')
                for (d = 0, g = 0; d < o.length; d += 3)
                  (w = o[d] | (o[d + 1] << 8) | (o[d + 2] << 16)),
                    (this.words[g] |= (w << M) & 67108863),
                    (this.words[g + 1] = (w >>> (26 - M)) & 67108863),
                    (M += 24),
                    M >= 26 && ((M -= 26), g++);
              return this.strip();
            });
          function f(S, o) {
            var u = S.charCodeAt(o);
            return u >= 65 && u <= 70 ? u - 55 : u >= 97 && u <= 102 ? u - 87 : (u - 48) & 15;
          }
          function h(S, o, u) {
            var l = f(S, u);
            return u - 1 >= o && (l |= f(S, u - 1) << 4), l;
          }
          n.prototype._parseHex = function (o, u, l) {
            (this.length = Math.ceil((o.length - u) / 6)), (this.words = new Array(this.length));
            for (var d = 0; d < this.length; d++) this.words[d] = 0;
            var g = 0,
              w = 0,
              M;
            if (l === 'be')
              for (d = o.length - 1; d >= u; d -= 2)
                (M = h(o, u, d) << g),
                  (this.words[w] |= M & 67108863),
                  g >= 18 ? ((g -= 18), (w += 1), (this.words[w] |= M >>> 26)) : (g += 8);
            else {
              var v = o.length - u;
              for (d = v % 2 === 0 ? u + 1 : u; d < o.length; d += 2)
                (M = h(o, u, d) << g),
                  (this.words[w] |= M & 67108863),
                  g >= 18 ? ((g -= 18), (w += 1), (this.words[w] |= M >>> 26)) : (g += 8);
            }
            this.strip();
          };
          function y(S, o, u, l) {
            for (var d = 0, g = Math.min(S.length, u), w = o; w < g; w++) {
              var M = S.charCodeAt(w) - 48;
              (d *= l), M >= 49 ? (d += M - 49 + 10) : M >= 17 ? (d += M - 17 + 10) : (d += M);
            }
            return d;
          }
          (n.prototype._parseBase = function (o, u, l) {
            (this.words = [0]), (this.length = 1);
            for (var d = 0, g = 1; g <= 67108863; g *= u) d++;
            d--, (g = (g / u) | 0);
            for (
              var w = o.length - l, M = w % d, v = Math.min(w, w - M) + l, a = 0, b = l;
              b < v;
              b += d
            )
              (a = y(o, b, b + d, u)),
                this.imuln(g),
                this.words[0] + a < 67108864 ? (this.words[0] += a) : this._iaddn(a);
            if (M !== 0) {
              var k = 1;
              for (a = y(o, b, o.length, u), b = 0; b < M; b++) k *= u;
              this.imuln(k), this.words[0] + a < 67108864 ? (this.words[0] += a) : this._iaddn(a);
            }
            this.strip();
          }),
            (n.prototype.copy = function (o) {
              o.words = new Array(this.length);
              for (var u = 0; u < this.length; u++) o.words[u] = this.words[u];
              (o.length = this.length), (o.negative = this.negative), (o.red = this.red);
            }),
            (n.prototype.clone = function () {
              var o = new n(null);
              return this.copy(o), o;
            }),
            (n.prototype._expand = function (o) {
              for (; this.length < o; ) this.words[this.length++] = 0;
              return this;
            }),
            (n.prototype.strip = function () {
              for (; this.length > 1 && this.words[this.length - 1] === 0; ) this.length--;
              return this._normSign();
            }),
            (n.prototype._normSign = function () {
              return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
            }),
            (n.prototype.inspect = function () {
              return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
            });
          var p = [
              '',
              '0',
              '00',
              '000',
              '0000',
              '00000',
              '000000',
              '0000000',
              '00000000',
              '000000000',
              '0000000000',
              '00000000000',
              '000000000000',
              '0000000000000',
              '00000000000000',
              '000000000000000',
              '0000000000000000',
              '00000000000000000',
              '000000000000000000',
              '0000000000000000000',
              '00000000000000000000',
              '000000000000000000000',
              '0000000000000000000000',
              '00000000000000000000000',
              '000000000000000000000000',
              '0000000000000000000000000',
            ],
            m = [
              0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5,
              5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            ],
            _ = [
              0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721,
              1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224,
              47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907,
              17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176,
            ];
          (n.prototype.toString = function (o, u) {
            (o = o || 10), (u = u | 0 || 1);
            var l;
            if (o === 16 || o === 'hex') {
              l = '';
              for (var d = 0, g = 0, w = 0; w < this.length; w++) {
                var M = this.words[w],
                  v = (((M << d) | g) & 16777215).toString(16);
                (g = (M >>> (24 - d)) & 16777215),
                  g !== 0 || w !== this.length - 1 ? (l = p[6 - v.length] + v + l) : (l = v + l),
                  (d += 2),
                  d >= 26 && ((d -= 26), w--);
              }
              for (g !== 0 && (l = g.toString(16) + l); l.length % u !== 0; ) l = '0' + l;
              return this.negative !== 0 && (l = '-' + l), l;
            }
            if (o === (o | 0) && o >= 2 && o <= 36) {
              var a = m[o],
                b = _[o];
              l = '';
              var k = this.clone();
              for (k.negative = 0; !k.isZero(); ) {
                var B = k.modn(b).toString(o);
                (k = k.idivn(b)), k.isZero() ? (l = B + l) : (l = p[a - B.length] + B + l);
              }
              for (this.isZero() && (l = '0' + l); l.length % u !== 0; ) l = '0' + l;
              return this.negative !== 0 && (l = '-' + l), l;
            }
            r(!1, 'Base should be between 2 and 36');
          }),
            (n.prototype.toNumber = function () {
              var o = this.words[0];
              return (
                this.length === 2
                  ? (o += this.words[1] * 67108864)
                  : this.length === 3 && this.words[2] === 1
                    ? (o += 4503599627370496 + this.words[1] * 67108864)
                    : this.length > 2 && r(!1, 'Number can only safely store up to 53 bits'),
                this.negative !== 0 ? -o : o
              );
            }),
            (n.prototype.toJSON = function () {
              return this.toString(16);
            }),
            (n.prototype.toBuffer = function (o, u) {
              return r(typeof c < 'u'), this.toArrayLike(c, o, u);
            }),
            (n.prototype.toArray = function (o, u) {
              return this.toArrayLike(Array, o, u);
            }),
            (n.prototype.toArrayLike = function (o, u, l) {
              var d = this.byteLength(),
                g = l || Math.max(1, d);
              r(d <= g, 'byte array longer than desired length'),
                r(g > 0, 'Requested array length <= 0'),
                this.strip();
              var w = u === 'le',
                M = new o(g),
                v,
                a,
                b = this.clone();
              if (w) {
                for (a = 0; !b.isZero(); a++) (v = b.andln(255)), b.iushrn(8), (M[a] = v);
                for (; a < g; a++) M[a] = 0;
              } else {
                for (a = 0; a < g - d; a++) M[a] = 0;
                for (a = 0; !b.isZero(); a++) (v = b.andln(255)), b.iushrn(8), (M[g - a - 1] = v);
              }
              return M;
            }),
            Math.clz32
              ? (n.prototype._countBits = function (o) {
                  return 32 - Math.clz32(o);
                })
              : (n.prototype._countBits = function (o) {
                  var u = o,
                    l = 0;
                  return (
                    u >= 4096 && ((l += 13), (u >>>= 13)),
                    u >= 64 && ((l += 7), (u >>>= 7)),
                    u >= 8 && ((l += 4), (u >>>= 4)),
                    u >= 2 && ((l += 2), (u >>>= 2)),
                    l + u
                  );
                }),
            (n.prototype._zeroBits = function (o) {
              if (o === 0) return 26;
              var u = o,
                l = 0;
              return (
                u & 8191 || ((l += 13), (u >>>= 13)),
                u & 127 || ((l += 7), (u >>>= 7)),
                u & 15 || ((l += 4), (u >>>= 4)),
                u & 3 || ((l += 2), (u >>>= 2)),
                u & 1 || l++,
                l
              );
            }),
            (n.prototype.bitLength = function () {
              var o = this.words[this.length - 1],
                u = this._countBits(o);
              return (this.length - 1) * 26 + u;
            });
          function A(S) {
            for (var o = new Array(S.bitLength()), u = 0; u < o.length; u++) {
              var l = (u / 26) | 0,
                d = u % 26;
              o[u] = (S.words[l] & (1 << d)) >>> d;
            }
            return o;
          }
          (n.prototype.zeroBits = function () {
            if (this.isZero()) return 0;
            for (var o = 0, u = 0; u < this.length; u++) {
              var l = this._zeroBits(this.words[u]);
              if (((o += l), l !== 26)) break;
            }
            return o;
          }),
            (n.prototype.byteLength = function () {
              return Math.ceil(this.bitLength() / 8);
            }),
            (n.prototype.toTwos = function (o) {
              return this.negative !== 0 ? this.abs().inotn(o).iaddn(1) : this.clone();
            }),
            (n.prototype.fromTwos = function (o) {
              return this.testn(o - 1) ? this.notn(o).iaddn(1).ineg() : this.clone();
            }),
            (n.prototype.isNeg = function () {
              return this.negative !== 0;
            }),
            (n.prototype.neg = function () {
              return this.clone().ineg();
            }),
            (n.prototype.ineg = function () {
              return this.isZero() || (this.negative ^= 1), this;
            }),
            (n.prototype.iuor = function (o) {
              for (; this.length < o.length; ) this.words[this.length++] = 0;
              for (var u = 0; u < o.length; u++) this.words[u] = this.words[u] | o.words[u];
              return this.strip();
            }),
            (n.prototype.ior = function (o) {
              return r((this.negative | o.negative) === 0), this.iuor(o);
            }),
            (n.prototype.or = function (o) {
              return this.length > o.length ? this.clone().ior(o) : o.clone().ior(this);
            }),
            (n.prototype.uor = function (o) {
              return this.length > o.length ? this.clone().iuor(o) : o.clone().iuor(this);
            }),
            (n.prototype.iuand = function (o) {
              var u;
              this.length > o.length ? (u = o) : (u = this);
              for (var l = 0; l < u.length; l++) this.words[l] = this.words[l] & o.words[l];
              return (this.length = u.length), this.strip();
            }),
            (n.prototype.iand = function (o) {
              return r((this.negative | o.negative) === 0), this.iuand(o);
            }),
            (n.prototype.and = function (o) {
              return this.length > o.length ? this.clone().iand(o) : o.clone().iand(this);
            }),
            (n.prototype.uand = function (o) {
              return this.length > o.length ? this.clone().iuand(o) : o.clone().iuand(this);
            }),
            (n.prototype.iuxor = function (o) {
              var u, l;
              this.length > o.length ? ((u = this), (l = o)) : ((u = o), (l = this));
              for (var d = 0; d < l.length; d++) this.words[d] = u.words[d] ^ l.words[d];
              if (this !== u) for (; d < u.length; d++) this.words[d] = u.words[d];
              return (this.length = u.length), this.strip();
            }),
            (n.prototype.ixor = function (o) {
              return r((this.negative | o.negative) === 0), this.iuxor(o);
            }),
            (n.prototype.xor = function (o) {
              return this.length > o.length ? this.clone().ixor(o) : o.clone().ixor(this);
            }),
            (n.prototype.uxor = function (o) {
              return this.length > o.length ? this.clone().iuxor(o) : o.clone().iuxor(this);
            }),
            (n.prototype.inotn = function (o) {
              r(typeof o == 'number' && o >= 0);
              var u = Math.ceil(o / 26) | 0,
                l = o % 26;
              this._expand(u), l > 0 && u--;
              for (var d = 0; d < u; d++) this.words[d] = ~this.words[d] & 67108863;
              return (
                l > 0 && (this.words[d] = ~this.words[d] & (67108863 >> (26 - l))), this.strip()
              );
            }),
            (n.prototype.notn = function (o) {
              return this.clone().inotn(o);
            }),
            (n.prototype.setn = function (o, u) {
              r(typeof o == 'number' && o >= 0);
              var l = (o / 26) | 0,
                d = o % 26;
              return (
                this._expand(l + 1),
                u
                  ? (this.words[l] = this.words[l] | (1 << d))
                  : (this.words[l] = this.words[l] & ~(1 << d)),
                this.strip()
              );
            }),
            (n.prototype.iadd = function (o) {
              var u;
              if (this.negative !== 0 && o.negative === 0)
                return (
                  (this.negative = 0), (u = this.isub(o)), (this.negative ^= 1), this._normSign()
                );
              if (this.negative === 0 && o.negative !== 0)
                return (o.negative = 0), (u = this.isub(o)), (o.negative = 1), u._normSign();
              var l, d;
              this.length > o.length ? ((l = this), (d = o)) : ((l = o), (d = this));
              for (var g = 0, w = 0; w < d.length; w++)
                (u = (l.words[w] | 0) + (d.words[w] | 0) + g),
                  (this.words[w] = u & 67108863),
                  (g = u >>> 26);
              for (; g !== 0 && w < l.length; w++)
                (u = (l.words[w] | 0) + g), (this.words[w] = u & 67108863), (g = u >>> 26);
              if (((this.length = l.length), g !== 0)) (this.words[this.length] = g), this.length++;
              else if (l !== this) for (; w < l.length; w++) this.words[w] = l.words[w];
              return this;
            }),
            (n.prototype.add = function (o) {
              var u;
              return o.negative !== 0 && this.negative === 0
                ? ((o.negative = 0), (u = this.sub(o)), (o.negative ^= 1), u)
                : o.negative === 0 && this.negative !== 0
                  ? ((this.negative = 0), (u = o.sub(this)), (this.negative = 1), u)
                  : this.length > o.length
                    ? this.clone().iadd(o)
                    : o.clone().iadd(this);
            }),
            (n.prototype.isub = function (o) {
              if (o.negative !== 0) {
                o.negative = 0;
                var u = this.iadd(o);
                return (o.negative = 1), u._normSign();
              } else if (this.negative !== 0)
                return (this.negative = 0), this.iadd(o), (this.negative = 1), this._normSign();
              var l = this.cmp(o);
              if (l === 0) return (this.negative = 0), (this.length = 1), (this.words[0] = 0), this;
              var d, g;
              l > 0 ? ((d = this), (g = o)) : ((d = o), (g = this));
              for (var w = 0, M = 0; M < g.length; M++)
                (u = (d.words[M] | 0) - (g.words[M] | 0) + w),
                  (w = u >> 26),
                  (this.words[M] = u & 67108863);
              for (; w !== 0 && M < d.length; M++)
                (u = (d.words[M] | 0) + w), (w = u >> 26), (this.words[M] = u & 67108863);
              if (w === 0 && M < d.length && d !== this)
                for (; M < d.length; M++) this.words[M] = d.words[M];
              return (
                (this.length = Math.max(this.length, M)),
                d !== this && (this.negative = 1),
                this.strip()
              );
            }),
            (n.prototype.sub = function (o) {
              return this.clone().isub(o);
            });
          function E(S, o, u) {
            u.negative = o.negative ^ S.negative;
            var l = (S.length + o.length) | 0;
            (u.length = l), (l = (l - 1) | 0);
            var d = S.words[0] | 0,
              g = o.words[0] | 0,
              w = d * g,
              M = w & 67108863,
              v = (w / 67108864) | 0;
            u.words[0] = M;
            for (var a = 1; a < l; a++) {
              for (
                var b = v >>> 26,
                  k = v & 67108863,
                  B = Math.min(a, o.length - 1),
                  F = Math.max(0, a - S.length + 1);
                F <= B;
                F++
              ) {
                var P = (a - F) | 0;
                (d = S.words[P] | 0),
                  (g = o.words[F] | 0),
                  (w = d * g + k),
                  (b += (w / 67108864) | 0),
                  (k = w & 67108863);
              }
              (u.words[a] = k | 0), (v = b | 0);
            }
            return v !== 0 ? (u.words[a] = v | 0) : u.length--, u.strip();
          }
          var I = function (o, u, l) {
            var d = o.words,
              g = u.words,
              w = l.words,
              M = 0,
              v,
              a,
              b,
              k = d[0] | 0,
              B = k & 8191,
              F = k >>> 13,
              P = d[1] | 0,
              C = P & 8191,
              z = P >>> 13,
              Y = d[2] | 0,
              G = Y & 8191,
              Q = Y >>> 13,
              U = d[3] | 0,
              $ = U & 8191,
              Z = U >>> 13,
              ae = d[4] | 0,
              fe = ae & 8191,
              le = ae >>> 13,
              Fe = d[5] | 0,
              be = Fe & 8191,
              oe = Fe >>> 13,
              rt = d[6] | 0,
              me = rt & 8191,
              re = rt >>> 13,
              ge = d[7] | 0,
              ce = ge & 8191,
              he = ge >>> 13,
              Ke = d[8] | 0,
              K = Ke & 8191,
              O = Ke >>> 13,
              W = d[9] | 0,
              T = W & 8191,
              x = W >>> 13,
              N = g[0] | 0,
              j = N & 8191,
              J = N >>> 13,
              de = g[1] | 0,
              ie = de & 8191,
              ye = de >>> 13,
              Ye = g[2] | 0,
              ve = Ye & 8191,
              _e = Ye >>> 13,
              et = g[3] | 0,
              Me = et & 8191,
              Ce = et >>> 13,
              yt = g[4] | 0,
              Ae = yt & 8191,
              Le = yt >>> 13,
              gt = g[5] | 0,
              Ee = gt & 8191,
              Ne = gt >>> 13,
              bt = g[6] | 0,
              ke = bt & 8191,
              $e = bt >>> 13,
              vt = g[7] | 0,
              Ie = vt & 8191,
              De = vt >>> 13,
              mt = g[8] | 0,
              xe = mt & 8191,
              Ue = mt >>> 13,
              wt = g[9] | 0,
              Be = wt & 8191,
              ze = wt >>> 13;
            (l.negative = o.negative ^ u.negative),
              (l.length = 19),
              (v = Math.imul(B, j)),
              (a = Math.imul(B, J)),
              (a = (a + Math.imul(F, j)) | 0),
              (b = Math.imul(F, J));
            var st = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (st >>> 26)) | 0),
              (st &= 67108863),
              (v = Math.imul(C, j)),
              (a = Math.imul(C, J)),
              (a = (a + Math.imul(z, j)) | 0),
              (b = Math.imul(z, J)),
              (v = (v + Math.imul(B, ie)) | 0),
              (a = (a + Math.imul(B, ye)) | 0),
              (a = (a + Math.imul(F, ie)) | 0),
              (b = (b + Math.imul(F, ye)) | 0);
            var at = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (at >>> 26)) | 0),
              (at &= 67108863),
              (v = Math.imul(G, j)),
              (a = Math.imul(G, J)),
              (a = (a + Math.imul(Q, j)) | 0),
              (b = Math.imul(Q, J)),
              (v = (v + Math.imul(C, ie)) | 0),
              (a = (a + Math.imul(C, ye)) | 0),
              (a = (a + Math.imul(z, ie)) | 0),
              (b = (b + Math.imul(z, ye)) | 0),
              (v = (v + Math.imul(B, ve)) | 0),
              (a = (a + Math.imul(B, _e)) | 0),
              (a = (a + Math.imul(F, ve)) | 0),
              (b = (b + Math.imul(F, _e)) | 0);
            var Ft = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (Ft >>> 26)) | 0),
              (Ft &= 67108863),
              (v = Math.imul($, j)),
              (a = Math.imul($, J)),
              (a = (a + Math.imul(Z, j)) | 0),
              (b = Math.imul(Z, J)),
              (v = (v + Math.imul(G, ie)) | 0),
              (a = (a + Math.imul(G, ye)) | 0),
              (a = (a + Math.imul(Q, ie)) | 0),
              (b = (b + Math.imul(Q, ye)) | 0),
              (v = (v + Math.imul(C, ve)) | 0),
              (a = (a + Math.imul(C, _e)) | 0),
              (a = (a + Math.imul(z, ve)) | 0),
              (b = (b + Math.imul(z, _e)) | 0),
              (v = (v + Math.imul(B, Me)) | 0),
              (a = (a + Math.imul(B, Ce)) | 0),
              (a = (a + Math.imul(F, Me)) | 0),
              (b = (b + Math.imul(F, Ce)) | 0);
            var qt = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (qt >>> 26)) | 0),
              (qt &= 67108863),
              (v = Math.imul(fe, j)),
              (a = Math.imul(fe, J)),
              (a = (a + Math.imul(le, j)) | 0),
              (b = Math.imul(le, J)),
              (v = (v + Math.imul($, ie)) | 0),
              (a = (a + Math.imul($, ye)) | 0),
              (a = (a + Math.imul(Z, ie)) | 0),
              (b = (b + Math.imul(Z, ye)) | 0),
              (v = (v + Math.imul(G, ve)) | 0),
              (a = (a + Math.imul(G, _e)) | 0),
              (a = (a + Math.imul(Q, ve)) | 0),
              (b = (b + Math.imul(Q, _e)) | 0),
              (v = (v + Math.imul(C, Me)) | 0),
              (a = (a + Math.imul(C, Ce)) | 0),
              (a = (a + Math.imul(z, Me)) | 0),
              (b = (b + Math.imul(z, Ce)) | 0),
              (v = (v + Math.imul(B, Ae)) | 0),
              (a = (a + Math.imul(B, Le)) | 0),
              (a = (a + Math.imul(F, Ae)) | 0),
              (b = (b + Math.imul(F, Le)) | 0);
            var Wt = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (Wt >>> 26)) | 0),
              (Wt &= 67108863),
              (v = Math.imul(be, j)),
              (a = Math.imul(be, J)),
              (a = (a + Math.imul(oe, j)) | 0),
              (b = Math.imul(oe, J)),
              (v = (v + Math.imul(fe, ie)) | 0),
              (a = (a + Math.imul(fe, ye)) | 0),
              (a = (a + Math.imul(le, ie)) | 0),
              (b = (b + Math.imul(le, ye)) | 0),
              (v = (v + Math.imul($, ve)) | 0),
              (a = (a + Math.imul($, _e)) | 0),
              (a = (a + Math.imul(Z, ve)) | 0),
              (b = (b + Math.imul(Z, _e)) | 0),
              (v = (v + Math.imul(G, Me)) | 0),
              (a = (a + Math.imul(G, Ce)) | 0),
              (a = (a + Math.imul(Q, Me)) | 0),
              (b = (b + Math.imul(Q, Ce)) | 0),
              (v = (v + Math.imul(C, Ae)) | 0),
              (a = (a + Math.imul(C, Le)) | 0),
              (a = (a + Math.imul(z, Ae)) | 0),
              (b = (b + Math.imul(z, Le)) | 0),
              (v = (v + Math.imul(B, Ee)) | 0),
              (a = (a + Math.imul(B, Ne)) | 0),
              (a = (a + Math.imul(F, Ee)) | 0),
              (b = (b + Math.imul(F, Ne)) | 0);
            var Kt = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (Kt >>> 26)) | 0),
              (Kt &= 67108863),
              (v = Math.imul(me, j)),
              (a = Math.imul(me, J)),
              (a = (a + Math.imul(re, j)) | 0),
              (b = Math.imul(re, J)),
              (v = (v + Math.imul(be, ie)) | 0),
              (a = (a + Math.imul(be, ye)) | 0),
              (a = (a + Math.imul(oe, ie)) | 0),
              (b = (b + Math.imul(oe, ye)) | 0),
              (v = (v + Math.imul(fe, ve)) | 0),
              (a = (a + Math.imul(fe, _e)) | 0),
              (a = (a + Math.imul(le, ve)) | 0),
              (b = (b + Math.imul(le, _e)) | 0),
              (v = (v + Math.imul($, Me)) | 0),
              (a = (a + Math.imul($, Ce)) | 0),
              (a = (a + Math.imul(Z, Me)) | 0),
              (b = (b + Math.imul(Z, Ce)) | 0),
              (v = (v + Math.imul(G, Ae)) | 0),
              (a = (a + Math.imul(G, Le)) | 0),
              (a = (a + Math.imul(Q, Ae)) | 0),
              (b = (b + Math.imul(Q, Le)) | 0),
              (v = (v + Math.imul(C, Ee)) | 0),
              (a = (a + Math.imul(C, Ne)) | 0),
              (a = (a + Math.imul(z, Ee)) | 0),
              (b = (b + Math.imul(z, Ne)) | 0),
              (v = (v + Math.imul(B, ke)) | 0),
              (a = (a + Math.imul(B, $e)) | 0),
              (a = (a + Math.imul(F, ke)) | 0),
              (b = (b + Math.imul(F, $e)) | 0);
            var jt = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (jt >>> 26)) | 0),
              (jt &= 67108863),
              (v = Math.imul(ce, j)),
              (a = Math.imul(ce, J)),
              (a = (a + Math.imul(he, j)) | 0),
              (b = Math.imul(he, J)),
              (v = (v + Math.imul(me, ie)) | 0),
              (a = (a + Math.imul(me, ye)) | 0),
              (a = (a + Math.imul(re, ie)) | 0),
              (b = (b + Math.imul(re, ye)) | 0),
              (v = (v + Math.imul(be, ve)) | 0),
              (a = (a + Math.imul(be, _e)) | 0),
              (a = (a + Math.imul(oe, ve)) | 0),
              (b = (b + Math.imul(oe, _e)) | 0),
              (v = (v + Math.imul(fe, Me)) | 0),
              (a = (a + Math.imul(fe, Ce)) | 0),
              (a = (a + Math.imul(le, Me)) | 0),
              (b = (b + Math.imul(le, Ce)) | 0),
              (v = (v + Math.imul($, Ae)) | 0),
              (a = (a + Math.imul($, Le)) | 0),
              (a = (a + Math.imul(Z, Ae)) | 0),
              (b = (b + Math.imul(Z, Le)) | 0),
              (v = (v + Math.imul(G, Ee)) | 0),
              (a = (a + Math.imul(G, Ne)) | 0),
              (a = (a + Math.imul(Q, Ee)) | 0),
              (b = (b + Math.imul(Q, Ne)) | 0),
              (v = (v + Math.imul(C, ke)) | 0),
              (a = (a + Math.imul(C, $e)) | 0),
              (a = (a + Math.imul(z, ke)) | 0),
              (b = (b + Math.imul(z, $e)) | 0),
              (v = (v + Math.imul(B, Ie)) | 0),
              (a = (a + Math.imul(B, De)) | 0),
              (a = (a + Math.imul(F, Ie)) | 0),
              (b = (b + Math.imul(F, De)) | 0);
            var fr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (fr >>> 26)) | 0),
              (fr &= 67108863),
              (v = Math.imul(K, j)),
              (a = Math.imul(K, J)),
              (a = (a + Math.imul(O, j)) | 0),
              (b = Math.imul(O, J)),
              (v = (v + Math.imul(ce, ie)) | 0),
              (a = (a + Math.imul(ce, ye)) | 0),
              (a = (a + Math.imul(he, ie)) | 0),
              (b = (b + Math.imul(he, ye)) | 0),
              (v = (v + Math.imul(me, ve)) | 0),
              (a = (a + Math.imul(me, _e)) | 0),
              (a = (a + Math.imul(re, ve)) | 0),
              (b = (b + Math.imul(re, _e)) | 0),
              (v = (v + Math.imul(be, Me)) | 0),
              (a = (a + Math.imul(be, Ce)) | 0),
              (a = (a + Math.imul(oe, Me)) | 0),
              (b = (b + Math.imul(oe, Ce)) | 0),
              (v = (v + Math.imul(fe, Ae)) | 0),
              (a = (a + Math.imul(fe, Le)) | 0),
              (a = (a + Math.imul(le, Ae)) | 0),
              (b = (b + Math.imul(le, Le)) | 0),
              (v = (v + Math.imul($, Ee)) | 0),
              (a = (a + Math.imul($, Ne)) | 0),
              (a = (a + Math.imul(Z, Ee)) | 0),
              (b = (b + Math.imul(Z, Ne)) | 0),
              (v = (v + Math.imul(G, ke)) | 0),
              (a = (a + Math.imul(G, $e)) | 0),
              (a = (a + Math.imul(Q, ke)) | 0),
              (b = (b + Math.imul(Q, $e)) | 0),
              (v = (v + Math.imul(C, Ie)) | 0),
              (a = (a + Math.imul(C, De)) | 0),
              (a = (a + Math.imul(z, Ie)) | 0),
              (b = (b + Math.imul(z, De)) | 0),
              (v = (v + Math.imul(B, xe)) | 0),
              (a = (a + Math.imul(B, Ue)) | 0),
              (a = (a + Math.imul(F, xe)) | 0),
              (b = (b + Math.imul(F, Ue)) | 0);
            var lr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (lr >>> 26)) | 0),
              (lr &= 67108863),
              (v = Math.imul(T, j)),
              (a = Math.imul(T, J)),
              (a = (a + Math.imul(x, j)) | 0),
              (b = Math.imul(x, J)),
              (v = (v + Math.imul(K, ie)) | 0),
              (a = (a + Math.imul(K, ye)) | 0),
              (a = (a + Math.imul(O, ie)) | 0),
              (b = (b + Math.imul(O, ye)) | 0),
              (v = (v + Math.imul(ce, ve)) | 0),
              (a = (a + Math.imul(ce, _e)) | 0),
              (a = (a + Math.imul(he, ve)) | 0),
              (b = (b + Math.imul(he, _e)) | 0),
              (v = (v + Math.imul(me, Me)) | 0),
              (a = (a + Math.imul(me, Ce)) | 0),
              (a = (a + Math.imul(re, Me)) | 0),
              (b = (b + Math.imul(re, Ce)) | 0),
              (v = (v + Math.imul(be, Ae)) | 0),
              (a = (a + Math.imul(be, Le)) | 0),
              (a = (a + Math.imul(oe, Ae)) | 0),
              (b = (b + Math.imul(oe, Le)) | 0),
              (v = (v + Math.imul(fe, Ee)) | 0),
              (a = (a + Math.imul(fe, Ne)) | 0),
              (a = (a + Math.imul(le, Ee)) | 0),
              (b = (b + Math.imul(le, Ne)) | 0),
              (v = (v + Math.imul($, ke)) | 0),
              (a = (a + Math.imul($, $e)) | 0),
              (a = (a + Math.imul(Z, ke)) | 0),
              (b = (b + Math.imul(Z, $e)) | 0),
              (v = (v + Math.imul(G, Ie)) | 0),
              (a = (a + Math.imul(G, De)) | 0),
              (a = (a + Math.imul(Q, Ie)) | 0),
              (b = (b + Math.imul(Q, De)) | 0),
              (v = (v + Math.imul(C, xe)) | 0),
              (a = (a + Math.imul(C, Ue)) | 0),
              (a = (a + Math.imul(z, xe)) | 0),
              (b = (b + Math.imul(z, Ue)) | 0),
              (v = (v + Math.imul(B, Be)) | 0),
              (a = (a + Math.imul(B, ze)) | 0),
              (a = (a + Math.imul(F, Be)) | 0),
              (b = (b + Math.imul(F, ze)) | 0);
            var hr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (hr >>> 26)) | 0),
              (hr &= 67108863),
              (v = Math.imul(T, ie)),
              (a = Math.imul(T, ye)),
              (a = (a + Math.imul(x, ie)) | 0),
              (b = Math.imul(x, ye)),
              (v = (v + Math.imul(K, ve)) | 0),
              (a = (a + Math.imul(K, _e)) | 0),
              (a = (a + Math.imul(O, ve)) | 0),
              (b = (b + Math.imul(O, _e)) | 0),
              (v = (v + Math.imul(ce, Me)) | 0),
              (a = (a + Math.imul(ce, Ce)) | 0),
              (a = (a + Math.imul(he, Me)) | 0),
              (b = (b + Math.imul(he, Ce)) | 0),
              (v = (v + Math.imul(me, Ae)) | 0),
              (a = (a + Math.imul(me, Le)) | 0),
              (a = (a + Math.imul(re, Ae)) | 0),
              (b = (b + Math.imul(re, Le)) | 0),
              (v = (v + Math.imul(be, Ee)) | 0),
              (a = (a + Math.imul(be, Ne)) | 0),
              (a = (a + Math.imul(oe, Ee)) | 0),
              (b = (b + Math.imul(oe, Ne)) | 0),
              (v = (v + Math.imul(fe, ke)) | 0),
              (a = (a + Math.imul(fe, $e)) | 0),
              (a = (a + Math.imul(le, ke)) | 0),
              (b = (b + Math.imul(le, $e)) | 0),
              (v = (v + Math.imul($, Ie)) | 0),
              (a = (a + Math.imul($, De)) | 0),
              (a = (a + Math.imul(Z, Ie)) | 0),
              (b = (b + Math.imul(Z, De)) | 0),
              (v = (v + Math.imul(G, xe)) | 0),
              (a = (a + Math.imul(G, Ue)) | 0),
              (a = (a + Math.imul(Q, xe)) | 0),
              (b = (b + Math.imul(Q, Ue)) | 0),
              (v = (v + Math.imul(C, Be)) | 0),
              (a = (a + Math.imul(C, ze)) | 0),
              (a = (a + Math.imul(z, Be)) | 0),
              (b = (b + Math.imul(z, ze)) | 0);
            var dr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (dr >>> 26)) | 0),
              (dr &= 67108863),
              (v = Math.imul(T, ve)),
              (a = Math.imul(T, _e)),
              (a = (a + Math.imul(x, ve)) | 0),
              (b = Math.imul(x, _e)),
              (v = (v + Math.imul(K, Me)) | 0),
              (a = (a + Math.imul(K, Ce)) | 0),
              (a = (a + Math.imul(O, Me)) | 0),
              (b = (b + Math.imul(O, Ce)) | 0),
              (v = (v + Math.imul(ce, Ae)) | 0),
              (a = (a + Math.imul(ce, Le)) | 0),
              (a = (a + Math.imul(he, Ae)) | 0),
              (b = (b + Math.imul(he, Le)) | 0),
              (v = (v + Math.imul(me, Ee)) | 0),
              (a = (a + Math.imul(me, Ne)) | 0),
              (a = (a + Math.imul(re, Ee)) | 0),
              (b = (b + Math.imul(re, Ne)) | 0),
              (v = (v + Math.imul(be, ke)) | 0),
              (a = (a + Math.imul(be, $e)) | 0),
              (a = (a + Math.imul(oe, ke)) | 0),
              (b = (b + Math.imul(oe, $e)) | 0),
              (v = (v + Math.imul(fe, Ie)) | 0),
              (a = (a + Math.imul(fe, De)) | 0),
              (a = (a + Math.imul(le, Ie)) | 0),
              (b = (b + Math.imul(le, De)) | 0),
              (v = (v + Math.imul($, xe)) | 0),
              (a = (a + Math.imul($, Ue)) | 0),
              (a = (a + Math.imul(Z, xe)) | 0),
              (b = (b + Math.imul(Z, Ue)) | 0),
              (v = (v + Math.imul(G, Be)) | 0),
              (a = (a + Math.imul(G, ze)) | 0),
              (a = (a + Math.imul(Q, Be)) | 0),
              (b = (b + Math.imul(Q, ze)) | 0);
            var pr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (pr >>> 26)) | 0),
              (pr &= 67108863),
              (v = Math.imul(T, Me)),
              (a = Math.imul(T, Ce)),
              (a = (a + Math.imul(x, Me)) | 0),
              (b = Math.imul(x, Ce)),
              (v = (v + Math.imul(K, Ae)) | 0),
              (a = (a + Math.imul(K, Le)) | 0),
              (a = (a + Math.imul(O, Ae)) | 0),
              (b = (b + Math.imul(O, Le)) | 0),
              (v = (v + Math.imul(ce, Ee)) | 0),
              (a = (a + Math.imul(ce, Ne)) | 0),
              (a = (a + Math.imul(he, Ee)) | 0),
              (b = (b + Math.imul(he, Ne)) | 0),
              (v = (v + Math.imul(me, ke)) | 0),
              (a = (a + Math.imul(me, $e)) | 0),
              (a = (a + Math.imul(re, ke)) | 0),
              (b = (b + Math.imul(re, $e)) | 0),
              (v = (v + Math.imul(be, Ie)) | 0),
              (a = (a + Math.imul(be, De)) | 0),
              (a = (a + Math.imul(oe, Ie)) | 0),
              (b = (b + Math.imul(oe, De)) | 0),
              (v = (v + Math.imul(fe, xe)) | 0),
              (a = (a + Math.imul(fe, Ue)) | 0),
              (a = (a + Math.imul(le, xe)) | 0),
              (b = (b + Math.imul(le, Ue)) | 0),
              (v = (v + Math.imul($, Be)) | 0),
              (a = (a + Math.imul($, ze)) | 0),
              (a = (a + Math.imul(Z, Be)) | 0),
              (b = (b + Math.imul(Z, ze)) | 0);
            var yr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (yr >>> 26)) | 0),
              (yr &= 67108863),
              (v = Math.imul(T, Ae)),
              (a = Math.imul(T, Le)),
              (a = (a + Math.imul(x, Ae)) | 0),
              (b = Math.imul(x, Le)),
              (v = (v + Math.imul(K, Ee)) | 0),
              (a = (a + Math.imul(K, Ne)) | 0),
              (a = (a + Math.imul(O, Ee)) | 0),
              (b = (b + Math.imul(O, Ne)) | 0),
              (v = (v + Math.imul(ce, ke)) | 0),
              (a = (a + Math.imul(ce, $e)) | 0),
              (a = (a + Math.imul(he, ke)) | 0),
              (b = (b + Math.imul(he, $e)) | 0),
              (v = (v + Math.imul(me, Ie)) | 0),
              (a = (a + Math.imul(me, De)) | 0),
              (a = (a + Math.imul(re, Ie)) | 0),
              (b = (b + Math.imul(re, De)) | 0),
              (v = (v + Math.imul(be, xe)) | 0),
              (a = (a + Math.imul(be, Ue)) | 0),
              (a = (a + Math.imul(oe, xe)) | 0),
              (b = (b + Math.imul(oe, Ue)) | 0),
              (v = (v + Math.imul(fe, Be)) | 0),
              (a = (a + Math.imul(fe, ze)) | 0),
              (a = (a + Math.imul(le, Be)) | 0),
              (b = (b + Math.imul(le, ze)) | 0);
            var gr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (gr >>> 26)) | 0),
              (gr &= 67108863),
              (v = Math.imul(T, Ee)),
              (a = Math.imul(T, Ne)),
              (a = (a + Math.imul(x, Ee)) | 0),
              (b = Math.imul(x, Ne)),
              (v = (v + Math.imul(K, ke)) | 0),
              (a = (a + Math.imul(K, $e)) | 0),
              (a = (a + Math.imul(O, ke)) | 0),
              (b = (b + Math.imul(O, $e)) | 0),
              (v = (v + Math.imul(ce, Ie)) | 0),
              (a = (a + Math.imul(ce, De)) | 0),
              (a = (a + Math.imul(he, Ie)) | 0),
              (b = (b + Math.imul(he, De)) | 0),
              (v = (v + Math.imul(me, xe)) | 0),
              (a = (a + Math.imul(me, Ue)) | 0),
              (a = (a + Math.imul(re, xe)) | 0),
              (b = (b + Math.imul(re, Ue)) | 0),
              (v = (v + Math.imul(be, Be)) | 0),
              (a = (a + Math.imul(be, ze)) | 0),
              (a = (a + Math.imul(oe, Be)) | 0),
              (b = (b + Math.imul(oe, ze)) | 0);
            var br = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (br >>> 26)) | 0),
              (br &= 67108863),
              (v = Math.imul(T, ke)),
              (a = Math.imul(T, $e)),
              (a = (a + Math.imul(x, ke)) | 0),
              (b = Math.imul(x, $e)),
              (v = (v + Math.imul(K, Ie)) | 0),
              (a = (a + Math.imul(K, De)) | 0),
              (a = (a + Math.imul(O, Ie)) | 0),
              (b = (b + Math.imul(O, De)) | 0),
              (v = (v + Math.imul(ce, xe)) | 0),
              (a = (a + Math.imul(ce, Ue)) | 0),
              (a = (a + Math.imul(he, xe)) | 0),
              (b = (b + Math.imul(he, Ue)) | 0),
              (v = (v + Math.imul(me, Be)) | 0),
              (a = (a + Math.imul(me, ze)) | 0),
              (a = (a + Math.imul(re, Be)) | 0),
              (b = (b + Math.imul(re, ze)) | 0);
            var vr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (vr >>> 26)) | 0),
              (vr &= 67108863),
              (v = Math.imul(T, Ie)),
              (a = Math.imul(T, De)),
              (a = (a + Math.imul(x, Ie)) | 0),
              (b = Math.imul(x, De)),
              (v = (v + Math.imul(K, xe)) | 0),
              (a = (a + Math.imul(K, Ue)) | 0),
              (a = (a + Math.imul(O, xe)) | 0),
              (b = (b + Math.imul(O, Ue)) | 0),
              (v = (v + Math.imul(ce, Be)) | 0),
              (a = (a + Math.imul(ce, ze)) | 0),
              (a = (a + Math.imul(he, Be)) | 0),
              (b = (b + Math.imul(he, ze)) | 0);
            var mr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (mr >>> 26)) | 0),
              (mr &= 67108863),
              (v = Math.imul(T, xe)),
              (a = Math.imul(T, Ue)),
              (a = (a + Math.imul(x, xe)) | 0),
              (b = Math.imul(x, Ue)),
              (v = (v + Math.imul(K, Be)) | 0),
              (a = (a + Math.imul(K, ze)) | 0),
              (a = (a + Math.imul(O, Be)) | 0),
              (b = (b + Math.imul(O, ze)) | 0);
            var wr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (wr >>> 26)) | 0),
              (wr &= 67108863),
              (v = Math.imul(T, Be)),
              (a = Math.imul(T, ze)),
              (a = (a + Math.imul(x, Be)) | 0),
              (b = Math.imul(x, ze));
            var _r = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            return (
              (M = (((b + (a >>> 13)) | 0) + (_r >>> 26)) | 0),
              (_r &= 67108863),
              (w[0] = st),
              (w[1] = at),
              (w[2] = Ft),
              (w[3] = qt),
              (w[4] = Wt),
              (w[5] = Kt),
              (w[6] = jt),
              (w[7] = fr),
              (w[8] = lr),
              (w[9] = hr),
              (w[10] = dr),
              (w[11] = pr),
              (w[12] = yr),
              (w[13] = gr),
              (w[14] = br),
              (w[15] = vr),
              (w[16] = mr),
              (w[17] = wr),
              (w[18] = _r),
              M !== 0 && ((w[19] = M), l.length++),
              l
            );
          };
          Math.imul || (I = E);
          function R(S, o, u) {
            (u.negative = o.negative ^ S.negative), (u.length = S.length + o.length);
            for (var l = 0, d = 0, g = 0; g < u.length - 1; g++) {
              var w = d;
              d = 0;
              for (
                var M = l & 67108863,
                  v = Math.min(g, o.length - 1),
                  a = Math.max(0, g - S.length + 1);
                a <= v;
                a++
              ) {
                var b = g - a,
                  k = S.words[b] | 0,
                  B = o.words[a] | 0,
                  F = k * B,
                  P = F & 67108863;
                (w = (w + ((F / 67108864) | 0)) | 0),
                  (P = (P + M) | 0),
                  (M = P & 67108863),
                  (w = (w + (P >>> 26)) | 0),
                  (d += w >>> 26),
                  (w &= 67108863);
              }
              (u.words[g] = M), (l = w), (w = d);
            }
            return l !== 0 ? (u.words[g] = l) : u.length--, u.strip();
          }
          function L(S, o, u) {
            var l = new D();
            return l.mulp(S, o, u);
          }
          n.prototype.mulTo = function (o, u) {
            var l,
              d = this.length + o.length;
            return (
              this.length === 10 && o.length === 10
                ? (l = I(this, o, u))
                : d < 63
                  ? (l = E(this, o, u))
                  : d < 1024
                    ? (l = R(this, o, u))
                    : (l = L(this, o, u)),
              l
            );
          };
          function D(S, o) {
            (this.x = S), (this.y = o);
          }
          (D.prototype.makeRBT = function (o) {
            for (var u = new Array(o), l = n.prototype._countBits(o) - 1, d = 0; d < o; d++)
              u[d] = this.revBin(d, l, o);
            return u;
          }),
            (D.prototype.revBin = function (o, u, l) {
              if (o === 0 || o === l - 1) return o;
              for (var d = 0, g = 0; g < u; g++) (d |= (o & 1) << (u - g - 1)), (o >>= 1);
              return d;
            }),
            (D.prototype.permute = function (o, u, l, d, g, w) {
              for (var M = 0; M < w; M++) (d[M] = u[o[M]]), (g[M] = l[o[M]]);
            }),
            (D.prototype.transform = function (o, u, l, d, g, w) {
              this.permute(w, o, u, l, d, g);
              for (var M = 1; M < g; M <<= 1)
                for (
                  var v = M << 1,
                    a = Math.cos((2 * Math.PI) / v),
                    b = Math.sin((2 * Math.PI) / v),
                    k = 0;
                  k < g;
                  k += v
                )
                  for (var B = a, F = b, P = 0; P < M; P++) {
                    var C = l[k + P],
                      z = d[k + P],
                      Y = l[k + P + M],
                      G = d[k + P + M],
                      Q = B * Y - F * G;
                    (G = B * G + F * Y),
                      (Y = Q),
                      (l[k + P] = C + Y),
                      (d[k + P] = z + G),
                      (l[k + P + M] = C - Y),
                      (d[k + P + M] = z - G),
                      P !== v && ((Q = a * B - b * F), (F = a * F + b * B), (B = Q));
                  }
            }),
            (D.prototype.guessLen13b = function (o, u) {
              var l = Math.max(u, o) | 1,
                d = l & 1,
                g = 0;
              for (l = (l / 2) | 0; l; l = l >>> 1) g++;
              return 1 << (g + 1 + d);
            }),
            (D.prototype.conjugate = function (o, u, l) {
              if (!(l <= 1))
                for (var d = 0; d < l / 2; d++) {
                  var g = o[d];
                  (o[d] = o[l - d - 1]),
                    (o[l - d - 1] = g),
                    (g = u[d]),
                    (u[d] = -u[l - d - 1]),
                    (u[l - d - 1] = -g);
                }
            }),
            (D.prototype.normalize13b = function (o, u) {
              for (var l = 0, d = 0; d < u / 2; d++) {
                var g = Math.round(o[2 * d + 1] / u) * 8192 + Math.round(o[2 * d] / u) + l;
                (o[d] = g & 67108863), g < 67108864 ? (l = 0) : (l = (g / 67108864) | 0);
              }
              return o;
            }),
            (D.prototype.convert13b = function (o, u, l, d) {
              for (var g = 0, w = 0; w < u; w++)
                (g = g + (o[w] | 0)),
                  (l[2 * w] = g & 8191),
                  (g = g >>> 13),
                  (l[2 * w + 1] = g & 8191),
                  (g = g >>> 13);
              for (w = 2 * u; w < d; ++w) l[w] = 0;
              r(g === 0), r((g & -8192) === 0);
            }),
            (D.prototype.stub = function (o) {
              for (var u = new Array(o), l = 0; l < o; l++) u[l] = 0;
              return u;
            }),
            (D.prototype.mulp = function (o, u, l) {
              var d = 2 * this.guessLen13b(o.length, u.length),
                g = this.makeRBT(d),
                w = this.stub(d),
                M = new Array(d),
                v = new Array(d),
                a = new Array(d),
                b = new Array(d),
                k = new Array(d),
                B = new Array(d),
                F = l.words;
              (F.length = d),
                this.convert13b(o.words, o.length, M, d),
                this.convert13b(u.words, u.length, b, d),
                this.transform(M, w, v, a, d, g),
                this.transform(b, w, k, B, d, g);
              for (var P = 0; P < d; P++) {
                var C = v[P] * k[P] - a[P] * B[P];
                (a[P] = v[P] * B[P] + a[P] * k[P]), (v[P] = C);
              }
              return (
                this.conjugate(v, a, d),
                this.transform(v, a, F, w, d, g),
                this.conjugate(F, w, d),
                this.normalize13b(F, d),
                (l.negative = o.negative ^ u.negative),
                (l.length = o.length + u.length),
                l.strip()
              );
            }),
            (n.prototype.mul = function (o) {
              var u = new n(null);
              return (u.words = new Array(this.length + o.length)), this.mulTo(o, u);
            }),
            (n.prototype.mulf = function (o) {
              var u = new n(null);
              return (u.words = new Array(this.length + o.length)), L(this, o, u);
            }),
            (n.prototype.imul = function (o) {
              return this.clone().mulTo(o, this);
            }),
            (n.prototype.imuln = function (o) {
              r(typeof o == 'number'), r(o < 67108864);
              for (var u = 0, l = 0; l < this.length; l++) {
                var d = (this.words[l] | 0) * o,
                  g = (d & 67108863) + (u & 67108863);
                (u >>= 26),
                  (u += (d / 67108864) | 0),
                  (u += g >>> 26),
                  (this.words[l] = g & 67108863);
              }
              return u !== 0 && ((this.words[l] = u), this.length++), this;
            }),
            (n.prototype.muln = function (o) {
              return this.clone().imuln(o);
            }),
            (n.prototype.sqr = function () {
              return this.mul(this);
            }),
            (n.prototype.isqr = function () {
              return this.imul(this.clone());
            }),
            (n.prototype.pow = function (o) {
              var u = A(o);
              if (u.length === 0) return new n(1);
              for (var l = this, d = 0; d < u.length && u[d] === 0; d++, l = l.sqr());
              if (++d < u.length)
                for (var g = l.sqr(); d < u.length; d++, g = g.sqr()) u[d] !== 0 && (l = l.mul(g));
              return l;
            }),
            (n.prototype.iushln = function (o) {
              r(typeof o == 'number' && o >= 0);
              var u = o % 26,
                l = (o - u) / 26,
                d = (67108863 >>> (26 - u)) << (26 - u),
                g;
              if (u !== 0) {
                var w = 0;
                for (g = 0; g < this.length; g++) {
                  var M = this.words[g] & d,
                    v = ((this.words[g] | 0) - M) << u;
                  (this.words[g] = v | w), (w = M >>> (26 - u));
                }
                w && ((this.words[g] = w), this.length++);
              }
              if (l !== 0) {
                for (g = this.length - 1; g >= 0; g--) this.words[g + l] = this.words[g];
                for (g = 0; g < l; g++) this.words[g] = 0;
                this.length += l;
              }
              return this.strip();
            }),
            (n.prototype.ishln = function (o) {
              return r(this.negative === 0), this.iushln(o);
            }),
            (n.prototype.iushrn = function (o, u, l) {
              r(typeof o == 'number' && o >= 0);
              var d;
              u ? (d = (u - (u % 26)) / 26) : (d = 0);
              var g = o % 26,
                w = Math.min((o - g) / 26, this.length),
                M = 67108863 ^ ((67108863 >>> g) << g),
                v = l;
              if (((d -= w), (d = Math.max(0, d)), v)) {
                for (var a = 0; a < w; a++) v.words[a] = this.words[a];
                v.length = w;
              }
              if (w !== 0)
                if (this.length > w)
                  for (this.length -= w, a = 0; a < this.length; a++)
                    this.words[a] = this.words[a + w];
                else (this.words[0] = 0), (this.length = 1);
              var b = 0;
              for (a = this.length - 1; a >= 0 && (b !== 0 || a >= d); a--) {
                var k = this.words[a] | 0;
                (this.words[a] = (b << (26 - g)) | (k >>> g)), (b = k & M);
              }
              return (
                v && b !== 0 && (v.words[v.length++] = b),
                this.length === 0 && ((this.words[0] = 0), (this.length = 1)),
                this.strip()
              );
            }),
            (n.prototype.ishrn = function (o, u, l) {
              return r(this.negative === 0), this.iushrn(o, u, l);
            }),
            (n.prototype.shln = function (o) {
              return this.clone().ishln(o);
            }),
            (n.prototype.ushln = function (o) {
              return this.clone().iushln(o);
            }),
            (n.prototype.shrn = function (o) {
              return this.clone().ishrn(o);
            }),
            (n.prototype.ushrn = function (o) {
              return this.clone().iushrn(o);
            }),
            (n.prototype.testn = function (o) {
              r(typeof o == 'number' && o >= 0);
              var u = o % 26,
                l = (o - u) / 26,
                d = 1 << u;
              if (this.length <= l) return !1;
              var g = this.words[l];
              return !!(g & d);
            }),
            (n.prototype.imaskn = function (o) {
              r(typeof o == 'number' && o >= 0);
              var u = o % 26,
                l = (o - u) / 26;
              if (
                (r(this.negative === 0, 'imaskn works only with positive numbers'),
                this.length <= l)
              )
                return this;
              if ((u !== 0 && l++, (this.length = Math.min(l, this.length)), u !== 0)) {
                var d = 67108863 ^ ((67108863 >>> u) << u);
                this.words[this.length - 1] &= d;
              }
              return this.strip();
            }),
            (n.prototype.maskn = function (o) {
              return this.clone().imaskn(o);
            }),
            (n.prototype.iaddn = function (o) {
              return (
                r(typeof o == 'number'),
                r(o < 67108864),
                o < 0
                  ? this.isubn(-o)
                  : this.negative !== 0
                    ? this.length === 1 && (this.words[0] | 0) < o
                      ? ((this.words[0] = o - (this.words[0] | 0)), (this.negative = 0), this)
                      : ((this.negative = 0), this.isubn(o), (this.negative = 1), this)
                    : this._iaddn(o)
              );
            }),
            (n.prototype._iaddn = function (o) {
              this.words[0] += o;
              for (var u = 0; u < this.length && this.words[u] >= 67108864; u++)
                (this.words[u] -= 67108864),
                  u === this.length - 1 ? (this.words[u + 1] = 1) : this.words[u + 1]++;
              return (this.length = Math.max(this.length, u + 1)), this;
            }),
            (n.prototype.isubn = function (o) {
              if ((r(typeof o == 'number'), r(o < 67108864), o < 0)) return this.iaddn(-o);
              if (this.negative !== 0)
                return (this.negative = 0), this.iaddn(o), (this.negative = 1), this;
              if (((this.words[0] -= o), this.length === 1 && this.words[0] < 0))
                (this.words[0] = -this.words[0]), (this.negative = 1);
              else
                for (var u = 0; u < this.length && this.words[u] < 0; u++)
                  (this.words[u] += 67108864), (this.words[u + 1] -= 1);
              return this.strip();
            }),
            (n.prototype.addn = function (o) {
              return this.clone().iaddn(o);
            }),
            (n.prototype.subn = function (o) {
              return this.clone().isubn(o);
            }),
            (n.prototype.iabs = function () {
              return (this.negative = 0), this;
            }),
            (n.prototype.abs = function () {
              return this.clone().iabs();
            }),
            (n.prototype._ishlnsubmul = function (o, u, l) {
              var d = o.length + l,
                g;
              this._expand(d);
              var w,
                M = 0;
              for (g = 0; g < o.length; g++) {
                w = (this.words[g + l] | 0) + M;
                var v = (o.words[g] | 0) * u;
                (w -= v & 67108863),
                  (M = (w >> 26) - ((v / 67108864) | 0)),
                  (this.words[g + l] = w & 67108863);
              }
              for (; g < this.length - l; g++)
                (w = (this.words[g + l] | 0) + M),
                  (M = w >> 26),
                  (this.words[g + l] = w & 67108863);
              if (M === 0) return this.strip();
              for (r(M === -1), M = 0, g = 0; g < this.length; g++)
                (w = -(this.words[g] | 0) + M), (M = w >> 26), (this.words[g] = w & 67108863);
              return (this.negative = 1), this.strip();
            }),
            (n.prototype._wordDiv = function (o, u) {
              var l = this.length - o.length,
                d = this.clone(),
                g = o,
                w = g.words[g.length - 1] | 0,
                M = this._countBits(w);
              (l = 26 - M),
                l !== 0 && ((g = g.ushln(l)), d.iushln(l), (w = g.words[g.length - 1] | 0));
              var v = d.length - g.length,
                a;
              if (u !== 'mod') {
                (a = new n(null)), (a.length = v + 1), (a.words = new Array(a.length));
                for (var b = 0; b < a.length; b++) a.words[b] = 0;
              }
              var k = d.clone()._ishlnsubmul(g, 1, v);
              k.negative === 0 && ((d = k), a && (a.words[v] = 1));
              for (var B = v - 1; B >= 0; B--) {
                var F = (d.words[g.length + B] | 0) * 67108864 + (d.words[g.length + B - 1] | 0);
                for (
                  F = Math.min((F / w) | 0, 67108863), d._ishlnsubmul(g, F, B);
                  d.negative !== 0;

                )
                  F--, (d.negative = 0), d._ishlnsubmul(g, 1, B), d.isZero() || (d.negative ^= 1);
                a && (a.words[B] = F);
              }
              return (
                a && a.strip(),
                d.strip(),
                u !== 'div' && l !== 0 && d.iushrn(l),
                { div: a || null, mod: d }
              );
            }),
            (n.prototype.divmod = function (o, u, l) {
              if ((r(!o.isZero()), this.isZero())) return { div: new n(0), mod: new n(0) };
              var d, g, w;
              return this.negative !== 0 && o.negative === 0
                ? ((w = this.neg().divmod(o, u)),
                  u !== 'mod' && (d = w.div.neg()),
                  u !== 'div' && ((g = w.mod.neg()), l && g.negative !== 0 && g.iadd(o)),
                  { div: d, mod: g })
                : this.negative === 0 && o.negative !== 0
                  ? ((w = this.divmod(o.neg(), u)),
                    u !== 'mod' && (d = w.div.neg()),
                    { div: d, mod: w.mod })
                  : this.negative & o.negative
                    ? ((w = this.neg().divmod(o.neg(), u)),
                      u !== 'div' && ((g = w.mod.neg()), l && g.negative !== 0 && g.isub(o)),
                      { div: w.div, mod: g })
                    : o.length > this.length || this.cmp(o) < 0
                      ? { div: new n(0), mod: this }
                      : o.length === 1
                        ? u === 'div'
                          ? { div: this.divn(o.words[0]), mod: null }
                          : u === 'mod'
                            ? { div: null, mod: new n(this.modn(o.words[0])) }
                            : { div: this.divn(o.words[0]), mod: new n(this.modn(o.words[0])) }
                        : this._wordDiv(o, u);
            }),
            (n.prototype.div = function (o) {
              return this.divmod(o, 'div', !1).div;
            }),
            (n.prototype.mod = function (o) {
              return this.divmod(o, 'mod', !1).mod;
            }),
            (n.prototype.umod = function (o) {
              return this.divmod(o, 'mod', !0).mod;
            }),
            (n.prototype.divRound = function (o) {
              var u = this.divmod(o);
              if (u.mod.isZero()) return u.div;
              var l = u.div.negative !== 0 ? u.mod.isub(o) : u.mod,
                d = o.ushrn(1),
                g = o.andln(1),
                w = l.cmp(d);
              return w < 0 || (g === 1 && w === 0)
                ? u.div
                : u.div.negative !== 0
                  ? u.div.isubn(1)
                  : u.div.iaddn(1);
            }),
            (n.prototype.modn = function (o) {
              r(o <= 67108863);
              for (var u = (1 << 26) % o, l = 0, d = this.length - 1; d >= 0; d--)
                l = (u * l + (this.words[d] | 0)) % o;
              return l;
            }),
            (n.prototype.idivn = function (o) {
              r(o <= 67108863);
              for (var u = 0, l = this.length - 1; l >= 0; l--) {
                var d = (this.words[l] | 0) + u * 67108864;
                (this.words[l] = (d / o) | 0), (u = d % o);
              }
              return this.strip();
            }),
            (n.prototype.divn = function (o) {
              return this.clone().idivn(o);
            }),
            (n.prototype.egcd = function (o) {
              r(o.negative === 0), r(!o.isZero());
              var u = this,
                l = o.clone();
              u.negative !== 0 ? (u = u.umod(o)) : (u = u.clone());
              for (
                var d = new n(1), g = new n(0), w = new n(0), M = new n(1), v = 0;
                u.isEven() && l.isEven();

              )
                u.iushrn(1), l.iushrn(1), ++v;
              for (var a = l.clone(), b = u.clone(); !u.isZero(); ) {
                for (var k = 0, B = 1; !(u.words[0] & B) && k < 26; ++k, B <<= 1);
                if (k > 0)
                  for (u.iushrn(k); k-- > 0; )
                    (d.isOdd() || g.isOdd()) && (d.iadd(a), g.isub(b)), d.iushrn(1), g.iushrn(1);
                for (var F = 0, P = 1; !(l.words[0] & P) && F < 26; ++F, P <<= 1);
                if (F > 0)
                  for (l.iushrn(F); F-- > 0; )
                    (w.isOdd() || M.isOdd()) && (w.iadd(a), M.isub(b)), w.iushrn(1), M.iushrn(1);
                u.cmp(l) >= 0
                  ? (u.isub(l), d.isub(w), g.isub(M))
                  : (l.isub(u), w.isub(d), M.isub(g));
              }
              return { a: w, b: M, gcd: l.iushln(v) };
            }),
            (n.prototype._invmp = function (o) {
              r(o.negative === 0), r(!o.isZero());
              var u = this,
                l = o.clone();
              u.negative !== 0 ? (u = u.umod(o)) : (u = u.clone());
              for (
                var d = new n(1), g = new n(0), w = l.clone();
                u.cmpn(1) > 0 && l.cmpn(1) > 0;

              ) {
                for (var M = 0, v = 1; !(u.words[0] & v) && M < 26; ++M, v <<= 1);
                if (M > 0) for (u.iushrn(M); M-- > 0; ) d.isOdd() && d.iadd(w), d.iushrn(1);
                for (var a = 0, b = 1; !(l.words[0] & b) && a < 26; ++a, b <<= 1);
                if (a > 0) for (l.iushrn(a); a-- > 0; ) g.isOdd() && g.iadd(w), g.iushrn(1);
                u.cmp(l) >= 0 ? (u.isub(l), d.isub(g)) : (l.isub(u), g.isub(d));
              }
              var k;
              return u.cmpn(1) === 0 ? (k = d) : (k = g), k.cmpn(0) < 0 && k.iadd(o), k;
            }),
            (n.prototype.gcd = function (o) {
              if (this.isZero()) return o.abs();
              if (o.isZero()) return this.abs();
              var u = this.clone(),
                l = o.clone();
              (u.negative = 0), (l.negative = 0);
              for (var d = 0; u.isEven() && l.isEven(); d++) u.iushrn(1), l.iushrn(1);
              do {
                for (; u.isEven(); ) u.iushrn(1);
                for (; l.isEven(); ) l.iushrn(1);
                var g = u.cmp(l);
                if (g < 0) {
                  var w = u;
                  (u = l), (l = w);
                } else if (g === 0 || l.cmpn(1) === 0) break;
                u.isub(l);
              } while (!0);
              return l.iushln(d);
            }),
            (n.prototype.invm = function (o) {
              return this.egcd(o).a.umod(o);
            }),
            (n.prototype.isEven = function () {
              return (this.words[0] & 1) === 0;
            }),
            (n.prototype.isOdd = function () {
              return (this.words[0] & 1) === 1;
            }),
            (n.prototype.andln = function (o) {
              return this.words[0] & o;
            }),
            (n.prototype.bincn = function (o) {
              r(typeof o == 'number');
              var u = o % 26,
                l = (o - u) / 26,
                d = 1 << u;
              if (this.length <= l) return this._expand(l + 1), (this.words[l] |= d), this;
              for (var g = d, w = l; g !== 0 && w < this.length; w++) {
                var M = this.words[w] | 0;
                (M += g), (g = M >>> 26), (M &= 67108863), (this.words[w] = M);
              }
              return g !== 0 && ((this.words[w] = g), this.length++), this;
            }),
            (n.prototype.isZero = function () {
              return this.length === 1 && this.words[0] === 0;
            }),
            (n.prototype.cmpn = function (o) {
              var u = o < 0;
              if (this.negative !== 0 && !u) return -1;
              if (this.negative === 0 && u) return 1;
              this.strip();
              var l;
              if (this.length > 1) l = 1;
              else {
                u && (o = -o), r(o <= 67108863, 'Number is too big');
                var d = this.words[0] | 0;
                l = d === o ? 0 : d < o ? -1 : 1;
              }
              return this.negative !== 0 ? -l | 0 : l;
            }),
            (n.prototype.cmp = function (o) {
              if (this.negative !== 0 && o.negative === 0) return -1;
              if (this.negative === 0 && o.negative !== 0) return 1;
              var u = this.ucmp(o);
              return this.negative !== 0 ? -u | 0 : u;
            }),
            (n.prototype.ucmp = function (o) {
              if (this.length > o.length) return 1;
              if (this.length < o.length) return -1;
              for (var u = 0, l = this.length - 1; l >= 0; l--) {
                var d = this.words[l] | 0,
                  g = o.words[l] | 0;
                if (d !== g) {
                  d < g ? (u = -1) : d > g && (u = 1);
                  break;
                }
              }
              return u;
            }),
            (n.prototype.gtn = function (o) {
              return this.cmpn(o) === 1;
            }),
            (n.prototype.gt = function (o) {
              return this.cmp(o) === 1;
            }),
            (n.prototype.gten = function (o) {
              return this.cmpn(o) >= 0;
            }),
            (n.prototype.gte = function (o) {
              return this.cmp(o) >= 0;
            }),
            (n.prototype.ltn = function (o) {
              return this.cmpn(o) === -1;
            }),
            (n.prototype.lt = function (o) {
              return this.cmp(o) === -1;
            }),
            (n.prototype.lten = function (o) {
              return this.cmpn(o) <= 0;
            }),
            (n.prototype.lte = function (o) {
              return this.cmp(o) <= 0;
            }),
            (n.prototype.eqn = function (o) {
              return this.cmpn(o) === 0;
            }),
            (n.prototype.eq = function (o) {
              return this.cmp(o) === 0;
            }),
            (n.red = function (o) {
              return new X(o);
            }),
            (n.prototype.toRed = function (o) {
              return (
                r(!this.red, 'Already a number in reduction context'),
                r(this.negative === 0, 'red works only with positives'),
                o.convertTo(this)._forceRed(o)
              );
            }),
            (n.prototype.fromRed = function () {
              return (
                r(this.red, 'fromRed works only with numbers in reduction context'),
                this.red.convertFrom(this)
              );
            }),
            (n.prototype._forceRed = function (o) {
              return (this.red = o), this;
            }),
            (n.prototype.forceRed = function (o) {
              return r(!this.red, 'Already a number in reduction context'), this._forceRed(o);
            }),
            (n.prototype.redAdd = function (o) {
              return r(this.red, 'redAdd works only with red numbers'), this.red.add(this, o);
            }),
            (n.prototype.redIAdd = function (o) {
              return r(this.red, 'redIAdd works only with red numbers'), this.red.iadd(this, o);
            }),
            (n.prototype.redSub = function (o) {
              return r(this.red, 'redSub works only with red numbers'), this.red.sub(this, o);
            }),
            (n.prototype.redISub = function (o) {
              return r(this.red, 'redISub works only with red numbers'), this.red.isub(this, o);
            }),
            (n.prototype.redShl = function (o) {
              return r(this.red, 'redShl works only with red numbers'), this.red.shl(this, o);
            }),
            (n.prototype.redMul = function (o) {
              return (
                r(this.red, 'redMul works only with red numbers'),
                this.red._verify2(this, o),
                this.red.mul(this, o)
              );
            }),
            (n.prototype.redIMul = function (o) {
              return (
                r(this.red, 'redMul works only with red numbers'),
                this.red._verify2(this, o),
                this.red.imul(this, o)
              );
            }),
            (n.prototype.redSqr = function () {
              return (
                r(this.red, 'redSqr works only with red numbers'),
                this.red._verify1(this),
                this.red.sqr(this)
              );
            }),
            (n.prototype.redISqr = function () {
              return (
                r(this.red, 'redISqr works only with red numbers'),
                this.red._verify1(this),
                this.red.isqr(this)
              );
            }),
            (n.prototype.redSqrt = function () {
              return (
                r(this.red, 'redSqrt works only with red numbers'),
                this.red._verify1(this),
                this.red.sqrt(this)
              );
            }),
            (n.prototype.redInvm = function () {
              return (
                r(this.red, 'redInvm works only with red numbers'),
                this.red._verify1(this),
                this.red.invm(this)
              );
            }),
            (n.prototype.redNeg = function () {
              return (
                r(this.red, 'redNeg works only with red numbers'),
                this.red._verify1(this),
                this.red.neg(this)
              );
            }),
            (n.prototype.redPow = function (o) {
              return (
                r(this.red && !o.red, 'redPow(normalNum)'),
                this.red._verify1(this),
                this.red.pow(this, o)
              );
            });
          var q = { k256: null, p224: null, p192: null, p25519: null };
          function H(S, o) {
            (this.name = S),
              (this.p = new n(o, 16)),
              (this.n = this.p.bitLength()),
              (this.k = new n(1).iushln(this.n).isub(this.p)),
              (this.tmp = this._tmp());
          }
          (H.prototype._tmp = function () {
            var o = new n(null);
            return (o.words = new Array(Math.ceil(this.n / 13))), o;
          }),
            (H.prototype.ireduce = function (o) {
              var u = o,
                l;
              do
                this.split(u, this.tmp),
                  (u = this.imulK(u)),
                  (u = u.iadd(this.tmp)),
                  (l = u.bitLength());
              while (l > this.n);
              var d = l < this.n ? -1 : u.ucmp(this.p);
              return (
                d === 0
                  ? ((u.words[0] = 0), (u.length = 1))
                  : d > 0
                    ? u.isub(this.p)
                    : u.strip !== void 0
                      ? u.strip()
                      : u._strip(),
                u
              );
            }),
            (H.prototype.split = function (o, u) {
              o.iushrn(this.n, 0, u);
            }),
            (H.prototype.imulK = function (o) {
              return o.imul(this.k);
            });
          function V() {
            H.call(
              this,
              'k256',
              'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f'
            );
          }
          s(V, H),
            (V.prototype.split = function (o, u) {
              for (var l = 4194303, d = Math.min(o.length, 9), g = 0; g < d; g++)
                u.words[g] = o.words[g];
              if (((u.length = d), o.length <= 9)) {
                (o.words[0] = 0), (o.length = 1);
                return;
              }
              var w = o.words[9];
              for (u.words[u.length++] = w & l, g = 10; g < o.length; g++) {
                var M = o.words[g] | 0;
                (o.words[g - 10] = ((M & l) << 4) | (w >>> 22)), (w = M);
              }
              (w >>>= 22),
                (o.words[g - 10] = w),
                w === 0 && o.length > 10 ? (o.length -= 10) : (o.length -= 9);
            }),
            (V.prototype.imulK = function (o) {
              (o.words[o.length] = 0), (o.words[o.length + 1] = 0), (o.length += 2);
              for (var u = 0, l = 0; l < o.length; l++) {
                var d = o.words[l] | 0;
                (u += d * 977), (o.words[l] = u & 67108863), (u = d * 64 + ((u / 67108864) | 0));
              }
              return (
                o.words[o.length - 1] === 0 &&
                  (o.length--, o.words[o.length - 1] === 0 && o.length--),
                o
              );
            });
          function te() {
            H.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
          }
          s(te, H);
          function ue() {
            H.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
          }
          s(ue, H);
          function ne() {
            H.call(
              this,
              '25519',
              '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed'
            );
          }
          s(ne, H),
            (ne.prototype.imulK = function (o) {
              for (var u = 0, l = 0; l < o.length; l++) {
                var d = (o.words[l] | 0) * 19 + u,
                  g = d & 67108863;
                (d >>>= 26), (o.words[l] = g), (u = d);
              }
              return u !== 0 && (o.words[o.length++] = u), o;
            }),
            (n._prime = function (o) {
              if (q[o]) return q[o];
              var u;
              if (o === 'k256') u = new V();
              else if (o === 'p224') u = new te();
              else if (o === 'p192') u = new ue();
              else if (o === 'p25519') u = new ne();
              else throw new Error('Unknown prime ' + o);
              return (q[o] = u), u;
            });
          function X(S) {
            if (typeof S == 'string') {
              var o = n._prime(S);
              (this.m = o.p), (this.prime = o);
            } else r(S.gtn(1), 'modulus must be greater than 1'), (this.m = S), (this.prime = null);
          }
          (X.prototype._verify1 = function (o) {
            r(o.negative === 0, 'red works only with positives'),
              r(o.red, 'red works only with red numbers');
          }),
            (X.prototype._verify2 = function (o, u) {
              r((o.negative | u.negative) === 0, 'red works only with positives'),
                r(o.red && o.red === u.red, 'red works only with red numbers');
            }),
            (X.prototype.imod = function (o) {
              return this.prime
                ? this.prime.ireduce(o)._forceRed(this)
                : o.umod(this.m)._forceRed(this);
            }),
            (X.prototype.neg = function (o) {
              return o.isZero() ? o.clone() : this.m.sub(o)._forceRed(this);
            }),
            (X.prototype.add = function (o, u) {
              this._verify2(o, u);
              var l = o.add(u);
              return l.cmp(this.m) >= 0 && l.isub(this.m), l._forceRed(this);
            }),
            (X.prototype.iadd = function (o, u) {
              this._verify2(o, u);
              var l = o.iadd(u);
              return l.cmp(this.m) >= 0 && l.isub(this.m), l;
            }),
            (X.prototype.sub = function (o, u) {
              this._verify2(o, u);
              var l = o.sub(u);
              return l.cmpn(0) < 0 && l.iadd(this.m), l._forceRed(this);
            }),
            (X.prototype.isub = function (o, u) {
              this._verify2(o, u);
              var l = o.isub(u);
              return l.cmpn(0) < 0 && l.iadd(this.m), l;
            }),
            (X.prototype.shl = function (o, u) {
              return this._verify1(o), this.imod(o.ushln(u));
            }),
            (X.prototype.imul = function (o, u) {
              return this._verify2(o, u), this.imod(o.imul(u));
            }),
            (X.prototype.mul = function (o, u) {
              return this._verify2(o, u), this.imod(o.mul(u));
            }),
            (X.prototype.isqr = function (o) {
              return this.imul(o, o.clone());
            }),
            (X.prototype.sqr = function (o) {
              return this.mul(o, o);
            }),
            (X.prototype.sqrt = function (o) {
              if (o.isZero()) return o.clone();
              var u = this.m.andln(3);
              if ((r(u % 2 === 1), u === 3)) {
                var l = this.m.add(new n(1)).iushrn(2);
                return this.pow(o, l);
              }
              for (var d = this.m.subn(1), g = 0; !d.isZero() && d.andln(1) === 0; )
                g++, d.iushrn(1);
              r(!d.isZero());
              var w = new n(1).toRed(this),
                M = w.redNeg(),
                v = this.m.subn(1).iushrn(1),
                a = this.m.bitLength();
              for (a = new n(2 * a * a).toRed(this); this.pow(a, v).cmp(M) !== 0; ) a.redIAdd(M);
              for (
                var b = this.pow(a, d),
                  k = this.pow(o, d.addn(1).iushrn(1)),
                  B = this.pow(o, d),
                  F = g;
                B.cmp(w) !== 0;

              ) {
                for (var P = B, C = 0; P.cmp(w) !== 0; C++) P = P.redSqr();
                r(C < F);
                var z = this.pow(b, new n(1).iushln(F - C - 1));
                (k = k.redMul(z)), (b = z.redSqr()), (B = B.redMul(b)), (F = C);
              }
              return k;
            }),
            (X.prototype.invm = function (o) {
              var u = o._invmp(this.m);
              return u.negative !== 0 ? ((u.negative = 0), this.imod(u).redNeg()) : this.imod(u);
            }),
            (X.prototype.pow = function (o, u) {
              if (u.isZero()) return new n(1).toRed(this);
              if (u.cmpn(1) === 0) return o.clone();
              var l = 4,
                d = new Array(1 << l);
              (d[0] = new n(1).toRed(this)), (d[1] = o);
              for (var g = 2; g < d.length; g++) d[g] = this.mul(d[g - 1], o);
              var w = d[0],
                M = 0,
                v = 0,
                a = u.bitLength() % 26;
              for (a === 0 && (a = 26), g = u.length - 1; g >= 0; g--) {
                for (var b = u.words[g], k = a - 1; k >= 0; k--) {
                  var B = (b >> k) & 1;
                  if ((w !== d[0] && (w = this.sqr(w)), B === 0 && M === 0)) {
                    v = 0;
                    continue;
                  }
                  (M <<= 1),
                    (M |= B),
                    v++,
                    !(v !== l && (g !== 0 || k !== 0)) &&
                      ((w = this.mul(w, d[M])), (v = 0), (M = 0));
                }
                a = 26;
              }
              return w;
            }),
            (X.prototype.convertTo = function (o) {
              var u = o.umod(this.m);
              return u === o ? u.clone() : u;
            }),
            (X.prototype.convertFrom = function (o) {
              var u = o.clone();
              return (u.red = null), u;
            }),
            (n.mont = function (o) {
              return new Oe(o);
            });
          function Oe(S) {
            X.call(this, S),
              (this.shift = this.m.bitLength()),
              this.shift % 26 !== 0 && (this.shift += 26 - (this.shift % 26)),
              (this.r = new n(1).iushln(this.shift)),
              (this.r2 = this.imod(this.r.sqr())),
              (this.rinv = this.r._invmp(this.m)),
              (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
              (this.minv = this.minv.umod(this.r)),
              (this.minv = this.r.sub(this.minv));
          }
          s(Oe, X),
            (Oe.prototype.convertTo = function (o) {
              return this.imod(o.ushln(this.shift));
            }),
            (Oe.prototype.convertFrom = function (o) {
              var u = this.imod(o.mul(this.rinv));
              return (u.red = null), u;
            }),
            (Oe.prototype.imul = function (o, u) {
              if (o.isZero() || u.isZero()) return (o.words[0] = 0), (o.length = 1), o;
              var l = o.imul(u),
                d = l.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                g = l.isub(d).iushrn(this.shift),
                w = g;
              return (
                g.cmp(this.m) >= 0 ? (w = g.isub(this.m)) : g.cmpn(0) < 0 && (w = g.iadd(this.m)),
                w._forceRed(this)
              );
            }),
            (Oe.prototype.mul = function (o, u) {
              if (o.isZero() || u.isZero()) return new n(0)._forceRed(this);
              var l = o.mul(u),
                d = l.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                g = l.isub(d).iushrn(this.shift),
                w = g;
              return (
                g.cmp(this.m) >= 0 ? (w = g.isub(this.m)) : g.cmpn(0) < 0 && (w = g.iadd(this.m)),
                w._forceRed(this)
              );
            }),
            (Oe.prototype.invm = function (o) {
              var u = this.imod(o._invmp(this.m).mul(this.r2));
              return u._forceRed(this);
            });
        })(i, se);
      })(vf)),
    vf.exports
  );
}
var mf = { exports: {} };
mf.exports;
var sv;
function dk() {
  return (
    sv ||
      ((sv = 1),
      (function (i) {
        (function (e, t) {
          function r(S, o) {
            if (!S) throw new Error(o || 'Assertion failed');
          }
          function s(S, o) {
            S.super_ = o;
            var u = function () {};
            (u.prototype = o.prototype), (S.prototype = new u()), (S.prototype.constructor = S);
          }
          function n(S, o, u) {
            if (n.isBN(S)) return S;
            (this.negative = 0),
              (this.words = null),
              (this.length = 0),
              (this.red = null),
              S !== null &&
                ((o === 'le' || o === 'be') && ((u = o), (o = 10)),
                this._init(S || 0, o || 10, u || 'be'));
          }
          typeof e == 'object' ? (e.exports = n) : (t.BN = n), (n.BN = n), (n.wordSize = 26);
          var c;
          try {
            typeof window < 'u' && typeof window.Buffer < 'u'
              ? (c = window.Buffer)
              : (c = ai.Buffer);
          } catch {}
          (n.isBN = function (o) {
            return o instanceof n
              ? !0
              : o !== null &&
                  typeof o == 'object' &&
                  o.constructor.wordSize === n.wordSize &&
                  Array.isArray(o.words);
          }),
            (n.max = function (o, u) {
              return o.cmp(u) > 0 ? o : u;
            }),
            (n.min = function (o, u) {
              return o.cmp(u) < 0 ? o : u;
            }),
            (n.prototype._init = function (o, u, l) {
              if (typeof o == 'number') return this._initNumber(o, u, l);
              if (typeof o == 'object') return this._initArray(o, u, l);
              u === 'hex' && (u = 16),
                r(u === (u | 0) && u >= 2 && u <= 36),
                (o = o.toString().replace(/\s+/g, ''));
              var d = 0;
              o[0] === '-' && (d++, (this.negative = 1)),
                d < o.length &&
                  (u === 16
                    ? this._parseHex(o, d, l)
                    : (this._parseBase(o, u, d),
                      l === 'le' && this._initArray(this.toArray(), u, l)));
            }),
            (n.prototype._initNumber = function (o, u, l) {
              o < 0 && ((this.negative = 1), (o = -o)),
                o < 67108864
                  ? ((this.words = [o & 67108863]), (this.length = 1))
                  : o < 4503599627370496
                    ? ((this.words = [o & 67108863, (o / 67108864) & 67108863]), (this.length = 2))
                    : (r(o < 9007199254740992),
                      (this.words = [o & 67108863, (o / 67108864) & 67108863, 1]),
                      (this.length = 3)),
                l === 'le' && this._initArray(this.toArray(), u, l);
            }),
            (n.prototype._initArray = function (o, u, l) {
              if ((r(typeof o.length == 'number'), o.length <= 0))
                return (this.words = [0]), (this.length = 1), this;
              (this.length = Math.ceil(o.length / 3)), (this.words = new Array(this.length));
              for (var d = 0; d < this.length; d++) this.words[d] = 0;
              var g,
                w,
                M = 0;
              if (l === 'be')
                for (d = o.length - 1, g = 0; d >= 0; d -= 3)
                  (w = o[d] | (o[d - 1] << 8) | (o[d - 2] << 16)),
                    (this.words[g] |= (w << M) & 67108863),
                    (this.words[g + 1] = (w >>> (26 - M)) & 67108863),
                    (M += 24),
                    M >= 26 && ((M -= 26), g++);
              else if (l === 'le')
                for (d = 0, g = 0; d < o.length; d += 3)
                  (w = o[d] | (o[d + 1] << 8) | (o[d + 2] << 16)),
                    (this.words[g] |= (w << M) & 67108863),
                    (this.words[g + 1] = (w >>> (26 - M)) & 67108863),
                    (M += 24),
                    M >= 26 && ((M -= 26), g++);
              return this.strip();
            });
          function f(S, o) {
            var u = S.charCodeAt(o);
            return u >= 65 && u <= 70 ? u - 55 : u >= 97 && u <= 102 ? u - 87 : (u - 48) & 15;
          }
          function h(S, o, u) {
            var l = f(S, u);
            return u - 1 >= o && (l |= f(S, u - 1) << 4), l;
          }
          n.prototype._parseHex = function (o, u, l) {
            (this.length = Math.ceil((o.length - u) / 6)), (this.words = new Array(this.length));
            for (var d = 0; d < this.length; d++) this.words[d] = 0;
            var g = 0,
              w = 0,
              M;
            if (l === 'be')
              for (d = o.length - 1; d >= u; d -= 2)
                (M = h(o, u, d) << g),
                  (this.words[w] |= M & 67108863),
                  g >= 18 ? ((g -= 18), (w += 1), (this.words[w] |= M >>> 26)) : (g += 8);
            else {
              var v = o.length - u;
              for (d = v % 2 === 0 ? u + 1 : u; d < o.length; d += 2)
                (M = h(o, u, d) << g),
                  (this.words[w] |= M & 67108863),
                  g >= 18 ? ((g -= 18), (w += 1), (this.words[w] |= M >>> 26)) : (g += 8);
            }
            this.strip();
          };
          function y(S, o, u, l) {
            for (var d = 0, g = Math.min(S.length, u), w = o; w < g; w++) {
              var M = S.charCodeAt(w) - 48;
              (d *= l), M >= 49 ? (d += M - 49 + 10) : M >= 17 ? (d += M - 17 + 10) : (d += M);
            }
            return d;
          }
          (n.prototype._parseBase = function (o, u, l) {
            (this.words = [0]), (this.length = 1);
            for (var d = 0, g = 1; g <= 67108863; g *= u) d++;
            d--, (g = (g / u) | 0);
            for (
              var w = o.length - l, M = w % d, v = Math.min(w, w - M) + l, a = 0, b = l;
              b < v;
              b += d
            )
              (a = y(o, b, b + d, u)),
                this.imuln(g),
                this.words[0] + a < 67108864 ? (this.words[0] += a) : this._iaddn(a);
            if (M !== 0) {
              var k = 1;
              for (a = y(o, b, o.length, u), b = 0; b < M; b++) k *= u;
              this.imuln(k), this.words[0] + a < 67108864 ? (this.words[0] += a) : this._iaddn(a);
            }
            this.strip();
          }),
            (n.prototype.copy = function (o) {
              o.words = new Array(this.length);
              for (var u = 0; u < this.length; u++) o.words[u] = this.words[u];
              (o.length = this.length), (o.negative = this.negative), (o.red = this.red);
            }),
            (n.prototype.clone = function () {
              var o = new n(null);
              return this.copy(o), o;
            }),
            (n.prototype._expand = function (o) {
              for (; this.length < o; ) this.words[this.length++] = 0;
              return this;
            }),
            (n.prototype.strip = function () {
              for (; this.length > 1 && this.words[this.length - 1] === 0; ) this.length--;
              return this._normSign();
            }),
            (n.prototype._normSign = function () {
              return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
            }),
            (n.prototype.inspect = function () {
              return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
            });
          var p = [
              '',
              '0',
              '00',
              '000',
              '0000',
              '00000',
              '000000',
              '0000000',
              '00000000',
              '000000000',
              '0000000000',
              '00000000000',
              '000000000000',
              '0000000000000',
              '00000000000000',
              '000000000000000',
              '0000000000000000',
              '00000000000000000',
              '000000000000000000',
              '0000000000000000000',
              '00000000000000000000',
              '000000000000000000000',
              '0000000000000000000000',
              '00000000000000000000000',
              '000000000000000000000000',
              '0000000000000000000000000',
            ],
            m = [
              0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5,
              5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            ],
            _ = [
              0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721,
              1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224,
              47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907,
              17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176,
            ];
          (n.prototype.toString = function (o, u) {
            (o = o || 10), (u = u | 0 || 1);
            var l;
            if (o === 16 || o === 'hex') {
              l = '';
              for (var d = 0, g = 0, w = 0; w < this.length; w++) {
                var M = this.words[w],
                  v = (((M << d) | g) & 16777215).toString(16);
                (g = (M >>> (24 - d)) & 16777215),
                  g !== 0 || w !== this.length - 1 ? (l = p[6 - v.length] + v + l) : (l = v + l),
                  (d += 2),
                  d >= 26 && ((d -= 26), w--);
              }
              for (g !== 0 && (l = g.toString(16) + l); l.length % u !== 0; ) l = '0' + l;
              return this.negative !== 0 && (l = '-' + l), l;
            }
            if (o === (o | 0) && o >= 2 && o <= 36) {
              var a = m[o],
                b = _[o];
              l = '';
              var k = this.clone();
              for (k.negative = 0; !k.isZero(); ) {
                var B = k.modn(b).toString(o);
                (k = k.idivn(b)), k.isZero() ? (l = B + l) : (l = p[a - B.length] + B + l);
              }
              for (this.isZero() && (l = '0' + l); l.length % u !== 0; ) l = '0' + l;
              return this.negative !== 0 && (l = '-' + l), l;
            }
            r(!1, 'Base should be between 2 and 36');
          }),
            (n.prototype.toNumber = function () {
              var o = this.words[0];
              return (
                this.length === 2
                  ? (o += this.words[1] * 67108864)
                  : this.length === 3 && this.words[2] === 1
                    ? (o += 4503599627370496 + this.words[1] * 67108864)
                    : this.length > 2 && r(!1, 'Number can only safely store up to 53 bits'),
                this.negative !== 0 ? -o : o
              );
            }),
            (n.prototype.toJSON = function () {
              return this.toString(16);
            }),
            (n.prototype.toBuffer = function (o, u) {
              return r(typeof c < 'u'), this.toArrayLike(c, o, u);
            }),
            (n.prototype.toArray = function (o, u) {
              return this.toArrayLike(Array, o, u);
            }),
            (n.prototype.toArrayLike = function (o, u, l) {
              var d = this.byteLength(),
                g = l || Math.max(1, d);
              r(d <= g, 'byte array longer than desired length'),
                r(g > 0, 'Requested array length <= 0'),
                this.strip();
              var w = u === 'le',
                M = new o(g),
                v,
                a,
                b = this.clone();
              if (w) {
                for (a = 0; !b.isZero(); a++) (v = b.andln(255)), b.iushrn(8), (M[a] = v);
                for (; a < g; a++) M[a] = 0;
              } else {
                for (a = 0; a < g - d; a++) M[a] = 0;
                for (a = 0; !b.isZero(); a++) (v = b.andln(255)), b.iushrn(8), (M[g - a - 1] = v);
              }
              return M;
            }),
            Math.clz32
              ? (n.prototype._countBits = function (o) {
                  return 32 - Math.clz32(o);
                })
              : (n.prototype._countBits = function (o) {
                  var u = o,
                    l = 0;
                  return (
                    u >= 4096 && ((l += 13), (u >>>= 13)),
                    u >= 64 && ((l += 7), (u >>>= 7)),
                    u >= 8 && ((l += 4), (u >>>= 4)),
                    u >= 2 && ((l += 2), (u >>>= 2)),
                    l + u
                  );
                }),
            (n.prototype._zeroBits = function (o) {
              if (o === 0) return 26;
              var u = o,
                l = 0;
              return (
                u & 8191 || ((l += 13), (u >>>= 13)),
                u & 127 || ((l += 7), (u >>>= 7)),
                u & 15 || ((l += 4), (u >>>= 4)),
                u & 3 || ((l += 2), (u >>>= 2)),
                u & 1 || l++,
                l
              );
            }),
            (n.prototype.bitLength = function () {
              var o = this.words[this.length - 1],
                u = this._countBits(o);
              return (this.length - 1) * 26 + u;
            });
          function A(S) {
            for (var o = new Array(S.bitLength()), u = 0; u < o.length; u++) {
              var l = (u / 26) | 0,
                d = u % 26;
              o[u] = (S.words[l] & (1 << d)) >>> d;
            }
            return o;
          }
          (n.prototype.zeroBits = function () {
            if (this.isZero()) return 0;
            for (var o = 0, u = 0; u < this.length; u++) {
              var l = this._zeroBits(this.words[u]);
              if (((o += l), l !== 26)) break;
            }
            return o;
          }),
            (n.prototype.byteLength = function () {
              return Math.ceil(this.bitLength() / 8);
            }),
            (n.prototype.toTwos = function (o) {
              return this.negative !== 0 ? this.abs().inotn(o).iaddn(1) : this.clone();
            }),
            (n.prototype.fromTwos = function (o) {
              return this.testn(o - 1) ? this.notn(o).iaddn(1).ineg() : this.clone();
            }),
            (n.prototype.isNeg = function () {
              return this.negative !== 0;
            }),
            (n.prototype.neg = function () {
              return this.clone().ineg();
            }),
            (n.prototype.ineg = function () {
              return this.isZero() || (this.negative ^= 1), this;
            }),
            (n.prototype.iuor = function (o) {
              for (; this.length < o.length; ) this.words[this.length++] = 0;
              for (var u = 0; u < o.length; u++) this.words[u] = this.words[u] | o.words[u];
              return this.strip();
            }),
            (n.prototype.ior = function (o) {
              return r((this.negative | o.negative) === 0), this.iuor(o);
            }),
            (n.prototype.or = function (o) {
              return this.length > o.length ? this.clone().ior(o) : o.clone().ior(this);
            }),
            (n.prototype.uor = function (o) {
              return this.length > o.length ? this.clone().iuor(o) : o.clone().iuor(this);
            }),
            (n.prototype.iuand = function (o) {
              var u;
              this.length > o.length ? (u = o) : (u = this);
              for (var l = 0; l < u.length; l++) this.words[l] = this.words[l] & o.words[l];
              return (this.length = u.length), this.strip();
            }),
            (n.prototype.iand = function (o) {
              return r((this.negative | o.negative) === 0), this.iuand(o);
            }),
            (n.prototype.and = function (o) {
              return this.length > o.length ? this.clone().iand(o) : o.clone().iand(this);
            }),
            (n.prototype.uand = function (o) {
              return this.length > o.length ? this.clone().iuand(o) : o.clone().iuand(this);
            }),
            (n.prototype.iuxor = function (o) {
              var u, l;
              this.length > o.length ? ((u = this), (l = o)) : ((u = o), (l = this));
              for (var d = 0; d < l.length; d++) this.words[d] = u.words[d] ^ l.words[d];
              if (this !== u) for (; d < u.length; d++) this.words[d] = u.words[d];
              return (this.length = u.length), this.strip();
            }),
            (n.prototype.ixor = function (o) {
              return r((this.negative | o.negative) === 0), this.iuxor(o);
            }),
            (n.prototype.xor = function (o) {
              return this.length > o.length ? this.clone().ixor(o) : o.clone().ixor(this);
            }),
            (n.prototype.uxor = function (o) {
              return this.length > o.length ? this.clone().iuxor(o) : o.clone().iuxor(this);
            }),
            (n.prototype.inotn = function (o) {
              r(typeof o == 'number' && o >= 0);
              var u = Math.ceil(o / 26) | 0,
                l = o % 26;
              this._expand(u), l > 0 && u--;
              for (var d = 0; d < u; d++) this.words[d] = ~this.words[d] & 67108863;
              return (
                l > 0 && (this.words[d] = ~this.words[d] & (67108863 >> (26 - l))), this.strip()
              );
            }),
            (n.prototype.notn = function (o) {
              return this.clone().inotn(o);
            }),
            (n.prototype.setn = function (o, u) {
              r(typeof o == 'number' && o >= 0);
              var l = (o / 26) | 0,
                d = o % 26;
              return (
                this._expand(l + 1),
                u
                  ? (this.words[l] = this.words[l] | (1 << d))
                  : (this.words[l] = this.words[l] & ~(1 << d)),
                this.strip()
              );
            }),
            (n.prototype.iadd = function (o) {
              var u;
              if (this.negative !== 0 && o.negative === 0)
                return (
                  (this.negative = 0), (u = this.isub(o)), (this.negative ^= 1), this._normSign()
                );
              if (this.negative === 0 && o.negative !== 0)
                return (o.negative = 0), (u = this.isub(o)), (o.negative = 1), u._normSign();
              var l, d;
              this.length > o.length ? ((l = this), (d = o)) : ((l = o), (d = this));
              for (var g = 0, w = 0; w < d.length; w++)
                (u = (l.words[w] | 0) + (d.words[w] | 0) + g),
                  (this.words[w] = u & 67108863),
                  (g = u >>> 26);
              for (; g !== 0 && w < l.length; w++)
                (u = (l.words[w] | 0) + g), (this.words[w] = u & 67108863), (g = u >>> 26);
              if (((this.length = l.length), g !== 0)) (this.words[this.length] = g), this.length++;
              else if (l !== this) for (; w < l.length; w++) this.words[w] = l.words[w];
              return this;
            }),
            (n.prototype.add = function (o) {
              var u;
              return o.negative !== 0 && this.negative === 0
                ? ((o.negative = 0), (u = this.sub(o)), (o.negative ^= 1), u)
                : o.negative === 0 && this.negative !== 0
                  ? ((this.negative = 0), (u = o.sub(this)), (this.negative = 1), u)
                  : this.length > o.length
                    ? this.clone().iadd(o)
                    : o.clone().iadd(this);
            }),
            (n.prototype.isub = function (o) {
              if (o.negative !== 0) {
                o.negative = 0;
                var u = this.iadd(o);
                return (o.negative = 1), u._normSign();
              } else if (this.negative !== 0)
                return (this.negative = 0), this.iadd(o), (this.negative = 1), this._normSign();
              var l = this.cmp(o);
              if (l === 0) return (this.negative = 0), (this.length = 1), (this.words[0] = 0), this;
              var d, g;
              l > 0 ? ((d = this), (g = o)) : ((d = o), (g = this));
              for (var w = 0, M = 0; M < g.length; M++)
                (u = (d.words[M] | 0) - (g.words[M] | 0) + w),
                  (w = u >> 26),
                  (this.words[M] = u & 67108863);
              for (; w !== 0 && M < d.length; M++)
                (u = (d.words[M] | 0) + w), (w = u >> 26), (this.words[M] = u & 67108863);
              if (w === 0 && M < d.length && d !== this)
                for (; M < d.length; M++) this.words[M] = d.words[M];
              return (
                (this.length = Math.max(this.length, M)),
                d !== this && (this.negative = 1),
                this.strip()
              );
            }),
            (n.prototype.sub = function (o) {
              return this.clone().isub(o);
            });
          function E(S, o, u) {
            u.negative = o.negative ^ S.negative;
            var l = (S.length + o.length) | 0;
            (u.length = l), (l = (l - 1) | 0);
            var d = S.words[0] | 0,
              g = o.words[0] | 0,
              w = d * g,
              M = w & 67108863,
              v = (w / 67108864) | 0;
            u.words[0] = M;
            for (var a = 1; a < l; a++) {
              for (
                var b = v >>> 26,
                  k = v & 67108863,
                  B = Math.min(a, o.length - 1),
                  F = Math.max(0, a - S.length + 1);
                F <= B;
                F++
              ) {
                var P = (a - F) | 0;
                (d = S.words[P] | 0),
                  (g = o.words[F] | 0),
                  (w = d * g + k),
                  (b += (w / 67108864) | 0),
                  (k = w & 67108863);
              }
              (u.words[a] = k | 0), (v = b | 0);
            }
            return v !== 0 ? (u.words[a] = v | 0) : u.length--, u.strip();
          }
          var I = function (o, u, l) {
            var d = o.words,
              g = u.words,
              w = l.words,
              M = 0,
              v,
              a,
              b,
              k = d[0] | 0,
              B = k & 8191,
              F = k >>> 13,
              P = d[1] | 0,
              C = P & 8191,
              z = P >>> 13,
              Y = d[2] | 0,
              G = Y & 8191,
              Q = Y >>> 13,
              U = d[3] | 0,
              $ = U & 8191,
              Z = U >>> 13,
              ae = d[4] | 0,
              fe = ae & 8191,
              le = ae >>> 13,
              Fe = d[5] | 0,
              be = Fe & 8191,
              oe = Fe >>> 13,
              rt = d[6] | 0,
              me = rt & 8191,
              re = rt >>> 13,
              ge = d[7] | 0,
              ce = ge & 8191,
              he = ge >>> 13,
              Ke = d[8] | 0,
              K = Ke & 8191,
              O = Ke >>> 13,
              W = d[9] | 0,
              T = W & 8191,
              x = W >>> 13,
              N = g[0] | 0,
              j = N & 8191,
              J = N >>> 13,
              de = g[1] | 0,
              ie = de & 8191,
              ye = de >>> 13,
              Ye = g[2] | 0,
              ve = Ye & 8191,
              _e = Ye >>> 13,
              et = g[3] | 0,
              Me = et & 8191,
              Ce = et >>> 13,
              yt = g[4] | 0,
              Ae = yt & 8191,
              Le = yt >>> 13,
              gt = g[5] | 0,
              Ee = gt & 8191,
              Ne = gt >>> 13,
              bt = g[6] | 0,
              ke = bt & 8191,
              $e = bt >>> 13,
              vt = g[7] | 0,
              Ie = vt & 8191,
              De = vt >>> 13,
              mt = g[8] | 0,
              xe = mt & 8191,
              Ue = mt >>> 13,
              wt = g[9] | 0,
              Be = wt & 8191,
              ze = wt >>> 13;
            (l.negative = o.negative ^ u.negative),
              (l.length = 19),
              (v = Math.imul(B, j)),
              (a = Math.imul(B, J)),
              (a = (a + Math.imul(F, j)) | 0),
              (b = Math.imul(F, J));
            var st = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (st >>> 26)) | 0),
              (st &= 67108863),
              (v = Math.imul(C, j)),
              (a = Math.imul(C, J)),
              (a = (a + Math.imul(z, j)) | 0),
              (b = Math.imul(z, J)),
              (v = (v + Math.imul(B, ie)) | 0),
              (a = (a + Math.imul(B, ye)) | 0),
              (a = (a + Math.imul(F, ie)) | 0),
              (b = (b + Math.imul(F, ye)) | 0);
            var at = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (at >>> 26)) | 0),
              (at &= 67108863),
              (v = Math.imul(G, j)),
              (a = Math.imul(G, J)),
              (a = (a + Math.imul(Q, j)) | 0),
              (b = Math.imul(Q, J)),
              (v = (v + Math.imul(C, ie)) | 0),
              (a = (a + Math.imul(C, ye)) | 0),
              (a = (a + Math.imul(z, ie)) | 0),
              (b = (b + Math.imul(z, ye)) | 0),
              (v = (v + Math.imul(B, ve)) | 0),
              (a = (a + Math.imul(B, _e)) | 0),
              (a = (a + Math.imul(F, ve)) | 0),
              (b = (b + Math.imul(F, _e)) | 0);
            var Ft = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (Ft >>> 26)) | 0),
              (Ft &= 67108863),
              (v = Math.imul($, j)),
              (a = Math.imul($, J)),
              (a = (a + Math.imul(Z, j)) | 0),
              (b = Math.imul(Z, J)),
              (v = (v + Math.imul(G, ie)) | 0),
              (a = (a + Math.imul(G, ye)) | 0),
              (a = (a + Math.imul(Q, ie)) | 0),
              (b = (b + Math.imul(Q, ye)) | 0),
              (v = (v + Math.imul(C, ve)) | 0),
              (a = (a + Math.imul(C, _e)) | 0),
              (a = (a + Math.imul(z, ve)) | 0),
              (b = (b + Math.imul(z, _e)) | 0),
              (v = (v + Math.imul(B, Me)) | 0),
              (a = (a + Math.imul(B, Ce)) | 0),
              (a = (a + Math.imul(F, Me)) | 0),
              (b = (b + Math.imul(F, Ce)) | 0);
            var qt = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (qt >>> 26)) | 0),
              (qt &= 67108863),
              (v = Math.imul(fe, j)),
              (a = Math.imul(fe, J)),
              (a = (a + Math.imul(le, j)) | 0),
              (b = Math.imul(le, J)),
              (v = (v + Math.imul($, ie)) | 0),
              (a = (a + Math.imul($, ye)) | 0),
              (a = (a + Math.imul(Z, ie)) | 0),
              (b = (b + Math.imul(Z, ye)) | 0),
              (v = (v + Math.imul(G, ve)) | 0),
              (a = (a + Math.imul(G, _e)) | 0),
              (a = (a + Math.imul(Q, ve)) | 0),
              (b = (b + Math.imul(Q, _e)) | 0),
              (v = (v + Math.imul(C, Me)) | 0),
              (a = (a + Math.imul(C, Ce)) | 0),
              (a = (a + Math.imul(z, Me)) | 0),
              (b = (b + Math.imul(z, Ce)) | 0),
              (v = (v + Math.imul(B, Ae)) | 0),
              (a = (a + Math.imul(B, Le)) | 0),
              (a = (a + Math.imul(F, Ae)) | 0),
              (b = (b + Math.imul(F, Le)) | 0);
            var Wt = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (Wt >>> 26)) | 0),
              (Wt &= 67108863),
              (v = Math.imul(be, j)),
              (a = Math.imul(be, J)),
              (a = (a + Math.imul(oe, j)) | 0),
              (b = Math.imul(oe, J)),
              (v = (v + Math.imul(fe, ie)) | 0),
              (a = (a + Math.imul(fe, ye)) | 0),
              (a = (a + Math.imul(le, ie)) | 0),
              (b = (b + Math.imul(le, ye)) | 0),
              (v = (v + Math.imul($, ve)) | 0),
              (a = (a + Math.imul($, _e)) | 0),
              (a = (a + Math.imul(Z, ve)) | 0),
              (b = (b + Math.imul(Z, _e)) | 0),
              (v = (v + Math.imul(G, Me)) | 0),
              (a = (a + Math.imul(G, Ce)) | 0),
              (a = (a + Math.imul(Q, Me)) | 0),
              (b = (b + Math.imul(Q, Ce)) | 0),
              (v = (v + Math.imul(C, Ae)) | 0),
              (a = (a + Math.imul(C, Le)) | 0),
              (a = (a + Math.imul(z, Ae)) | 0),
              (b = (b + Math.imul(z, Le)) | 0),
              (v = (v + Math.imul(B, Ee)) | 0),
              (a = (a + Math.imul(B, Ne)) | 0),
              (a = (a + Math.imul(F, Ee)) | 0),
              (b = (b + Math.imul(F, Ne)) | 0);
            var Kt = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (Kt >>> 26)) | 0),
              (Kt &= 67108863),
              (v = Math.imul(me, j)),
              (a = Math.imul(me, J)),
              (a = (a + Math.imul(re, j)) | 0),
              (b = Math.imul(re, J)),
              (v = (v + Math.imul(be, ie)) | 0),
              (a = (a + Math.imul(be, ye)) | 0),
              (a = (a + Math.imul(oe, ie)) | 0),
              (b = (b + Math.imul(oe, ye)) | 0),
              (v = (v + Math.imul(fe, ve)) | 0),
              (a = (a + Math.imul(fe, _e)) | 0),
              (a = (a + Math.imul(le, ve)) | 0),
              (b = (b + Math.imul(le, _e)) | 0),
              (v = (v + Math.imul($, Me)) | 0),
              (a = (a + Math.imul($, Ce)) | 0),
              (a = (a + Math.imul(Z, Me)) | 0),
              (b = (b + Math.imul(Z, Ce)) | 0),
              (v = (v + Math.imul(G, Ae)) | 0),
              (a = (a + Math.imul(G, Le)) | 0),
              (a = (a + Math.imul(Q, Ae)) | 0),
              (b = (b + Math.imul(Q, Le)) | 0),
              (v = (v + Math.imul(C, Ee)) | 0),
              (a = (a + Math.imul(C, Ne)) | 0),
              (a = (a + Math.imul(z, Ee)) | 0),
              (b = (b + Math.imul(z, Ne)) | 0),
              (v = (v + Math.imul(B, ke)) | 0),
              (a = (a + Math.imul(B, $e)) | 0),
              (a = (a + Math.imul(F, ke)) | 0),
              (b = (b + Math.imul(F, $e)) | 0);
            var jt = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (jt >>> 26)) | 0),
              (jt &= 67108863),
              (v = Math.imul(ce, j)),
              (a = Math.imul(ce, J)),
              (a = (a + Math.imul(he, j)) | 0),
              (b = Math.imul(he, J)),
              (v = (v + Math.imul(me, ie)) | 0),
              (a = (a + Math.imul(me, ye)) | 0),
              (a = (a + Math.imul(re, ie)) | 0),
              (b = (b + Math.imul(re, ye)) | 0),
              (v = (v + Math.imul(be, ve)) | 0),
              (a = (a + Math.imul(be, _e)) | 0),
              (a = (a + Math.imul(oe, ve)) | 0),
              (b = (b + Math.imul(oe, _e)) | 0),
              (v = (v + Math.imul(fe, Me)) | 0),
              (a = (a + Math.imul(fe, Ce)) | 0),
              (a = (a + Math.imul(le, Me)) | 0),
              (b = (b + Math.imul(le, Ce)) | 0),
              (v = (v + Math.imul($, Ae)) | 0),
              (a = (a + Math.imul($, Le)) | 0),
              (a = (a + Math.imul(Z, Ae)) | 0),
              (b = (b + Math.imul(Z, Le)) | 0),
              (v = (v + Math.imul(G, Ee)) | 0),
              (a = (a + Math.imul(G, Ne)) | 0),
              (a = (a + Math.imul(Q, Ee)) | 0),
              (b = (b + Math.imul(Q, Ne)) | 0),
              (v = (v + Math.imul(C, ke)) | 0),
              (a = (a + Math.imul(C, $e)) | 0),
              (a = (a + Math.imul(z, ke)) | 0),
              (b = (b + Math.imul(z, $e)) | 0),
              (v = (v + Math.imul(B, Ie)) | 0),
              (a = (a + Math.imul(B, De)) | 0),
              (a = (a + Math.imul(F, Ie)) | 0),
              (b = (b + Math.imul(F, De)) | 0);
            var fr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (fr >>> 26)) | 0),
              (fr &= 67108863),
              (v = Math.imul(K, j)),
              (a = Math.imul(K, J)),
              (a = (a + Math.imul(O, j)) | 0),
              (b = Math.imul(O, J)),
              (v = (v + Math.imul(ce, ie)) | 0),
              (a = (a + Math.imul(ce, ye)) | 0),
              (a = (a + Math.imul(he, ie)) | 0),
              (b = (b + Math.imul(he, ye)) | 0),
              (v = (v + Math.imul(me, ve)) | 0),
              (a = (a + Math.imul(me, _e)) | 0),
              (a = (a + Math.imul(re, ve)) | 0),
              (b = (b + Math.imul(re, _e)) | 0),
              (v = (v + Math.imul(be, Me)) | 0),
              (a = (a + Math.imul(be, Ce)) | 0),
              (a = (a + Math.imul(oe, Me)) | 0),
              (b = (b + Math.imul(oe, Ce)) | 0),
              (v = (v + Math.imul(fe, Ae)) | 0),
              (a = (a + Math.imul(fe, Le)) | 0),
              (a = (a + Math.imul(le, Ae)) | 0),
              (b = (b + Math.imul(le, Le)) | 0),
              (v = (v + Math.imul($, Ee)) | 0),
              (a = (a + Math.imul($, Ne)) | 0),
              (a = (a + Math.imul(Z, Ee)) | 0),
              (b = (b + Math.imul(Z, Ne)) | 0),
              (v = (v + Math.imul(G, ke)) | 0),
              (a = (a + Math.imul(G, $e)) | 0),
              (a = (a + Math.imul(Q, ke)) | 0),
              (b = (b + Math.imul(Q, $e)) | 0),
              (v = (v + Math.imul(C, Ie)) | 0),
              (a = (a + Math.imul(C, De)) | 0),
              (a = (a + Math.imul(z, Ie)) | 0),
              (b = (b + Math.imul(z, De)) | 0),
              (v = (v + Math.imul(B, xe)) | 0),
              (a = (a + Math.imul(B, Ue)) | 0),
              (a = (a + Math.imul(F, xe)) | 0),
              (b = (b + Math.imul(F, Ue)) | 0);
            var lr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (lr >>> 26)) | 0),
              (lr &= 67108863),
              (v = Math.imul(T, j)),
              (a = Math.imul(T, J)),
              (a = (a + Math.imul(x, j)) | 0),
              (b = Math.imul(x, J)),
              (v = (v + Math.imul(K, ie)) | 0),
              (a = (a + Math.imul(K, ye)) | 0),
              (a = (a + Math.imul(O, ie)) | 0),
              (b = (b + Math.imul(O, ye)) | 0),
              (v = (v + Math.imul(ce, ve)) | 0),
              (a = (a + Math.imul(ce, _e)) | 0),
              (a = (a + Math.imul(he, ve)) | 0),
              (b = (b + Math.imul(he, _e)) | 0),
              (v = (v + Math.imul(me, Me)) | 0),
              (a = (a + Math.imul(me, Ce)) | 0),
              (a = (a + Math.imul(re, Me)) | 0),
              (b = (b + Math.imul(re, Ce)) | 0),
              (v = (v + Math.imul(be, Ae)) | 0),
              (a = (a + Math.imul(be, Le)) | 0),
              (a = (a + Math.imul(oe, Ae)) | 0),
              (b = (b + Math.imul(oe, Le)) | 0),
              (v = (v + Math.imul(fe, Ee)) | 0),
              (a = (a + Math.imul(fe, Ne)) | 0),
              (a = (a + Math.imul(le, Ee)) | 0),
              (b = (b + Math.imul(le, Ne)) | 0),
              (v = (v + Math.imul($, ke)) | 0),
              (a = (a + Math.imul($, $e)) | 0),
              (a = (a + Math.imul(Z, ke)) | 0),
              (b = (b + Math.imul(Z, $e)) | 0),
              (v = (v + Math.imul(G, Ie)) | 0),
              (a = (a + Math.imul(G, De)) | 0),
              (a = (a + Math.imul(Q, Ie)) | 0),
              (b = (b + Math.imul(Q, De)) | 0),
              (v = (v + Math.imul(C, xe)) | 0),
              (a = (a + Math.imul(C, Ue)) | 0),
              (a = (a + Math.imul(z, xe)) | 0),
              (b = (b + Math.imul(z, Ue)) | 0),
              (v = (v + Math.imul(B, Be)) | 0),
              (a = (a + Math.imul(B, ze)) | 0),
              (a = (a + Math.imul(F, Be)) | 0),
              (b = (b + Math.imul(F, ze)) | 0);
            var hr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (hr >>> 26)) | 0),
              (hr &= 67108863),
              (v = Math.imul(T, ie)),
              (a = Math.imul(T, ye)),
              (a = (a + Math.imul(x, ie)) | 0),
              (b = Math.imul(x, ye)),
              (v = (v + Math.imul(K, ve)) | 0),
              (a = (a + Math.imul(K, _e)) | 0),
              (a = (a + Math.imul(O, ve)) | 0),
              (b = (b + Math.imul(O, _e)) | 0),
              (v = (v + Math.imul(ce, Me)) | 0),
              (a = (a + Math.imul(ce, Ce)) | 0),
              (a = (a + Math.imul(he, Me)) | 0),
              (b = (b + Math.imul(he, Ce)) | 0),
              (v = (v + Math.imul(me, Ae)) | 0),
              (a = (a + Math.imul(me, Le)) | 0),
              (a = (a + Math.imul(re, Ae)) | 0),
              (b = (b + Math.imul(re, Le)) | 0),
              (v = (v + Math.imul(be, Ee)) | 0),
              (a = (a + Math.imul(be, Ne)) | 0),
              (a = (a + Math.imul(oe, Ee)) | 0),
              (b = (b + Math.imul(oe, Ne)) | 0),
              (v = (v + Math.imul(fe, ke)) | 0),
              (a = (a + Math.imul(fe, $e)) | 0),
              (a = (a + Math.imul(le, ke)) | 0),
              (b = (b + Math.imul(le, $e)) | 0),
              (v = (v + Math.imul($, Ie)) | 0),
              (a = (a + Math.imul($, De)) | 0),
              (a = (a + Math.imul(Z, Ie)) | 0),
              (b = (b + Math.imul(Z, De)) | 0),
              (v = (v + Math.imul(G, xe)) | 0),
              (a = (a + Math.imul(G, Ue)) | 0),
              (a = (a + Math.imul(Q, xe)) | 0),
              (b = (b + Math.imul(Q, Ue)) | 0),
              (v = (v + Math.imul(C, Be)) | 0),
              (a = (a + Math.imul(C, ze)) | 0),
              (a = (a + Math.imul(z, Be)) | 0),
              (b = (b + Math.imul(z, ze)) | 0);
            var dr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (dr >>> 26)) | 0),
              (dr &= 67108863),
              (v = Math.imul(T, ve)),
              (a = Math.imul(T, _e)),
              (a = (a + Math.imul(x, ve)) | 0),
              (b = Math.imul(x, _e)),
              (v = (v + Math.imul(K, Me)) | 0),
              (a = (a + Math.imul(K, Ce)) | 0),
              (a = (a + Math.imul(O, Me)) | 0),
              (b = (b + Math.imul(O, Ce)) | 0),
              (v = (v + Math.imul(ce, Ae)) | 0),
              (a = (a + Math.imul(ce, Le)) | 0),
              (a = (a + Math.imul(he, Ae)) | 0),
              (b = (b + Math.imul(he, Le)) | 0),
              (v = (v + Math.imul(me, Ee)) | 0),
              (a = (a + Math.imul(me, Ne)) | 0),
              (a = (a + Math.imul(re, Ee)) | 0),
              (b = (b + Math.imul(re, Ne)) | 0),
              (v = (v + Math.imul(be, ke)) | 0),
              (a = (a + Math.imul(be, $e)) | 0),
              (a = (a + Math.imul(oe, ke)) | 0),
              (b = (b + Math.imul(oe, $e)) | 0),
              (v = (v + Math.imul(fe, Ie)) | 0),
              (a = (a + Math.imul(fe, De)) | 0),
              (a = (a + Math.imul(le, Ie)) | 0),
              (b = (b + Math.imul(le, De)) | 0),
              (v = (v + Math.imul($, xe)) | 0),
              (a = (a + Math.imul($, Ue)) | 0),
              (a = (a + Math.imul(Z, xe)) | 0),
              (b = (b + Math.imul(Z, Ue)) | 0),
              (v = (v + Math.imul(G, Be)) | 0),
              (a = (a + Math.imul(G, ze)) | 0),
              (a = (a + Math.imul(Q, Be)) | 0),
              (b = (b + Math.imul(Q, ze)) | 0);
            var pr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (pr >>> 26)) | 0),
              (pr &= 67108863),
              (v = Math.imul(T, Me)),
              (a = Math.imul(T, Ce)),
              (a = (a + Math.imul(x, Me)) | 0),
              (b = Math.imul(x, Ce)),
              (v = (v + Math.imul(K, Ae)) | 0),
              (a = (a + Math.imul(K, Le)) | 0),
              (a = (a + Math.imul(O, Ae)) | 0),
              (b = (b + Math.imul(O, Le)) | 0),
              (v = (v + Math.imul(ce, Ee)) | 0),
              (a = (a + Math.imul(ce, Ne)) | 0),
              (a = (a + Math.imul(he, Ee)) | 0),
              (b = (b + Math.imul(he, Ne)) | 0),
              (v = (v + Math.imul(me, ke)) | 0),
              (a = (a + Math.imul(me, $e)) | 0),
              (a = (a + Math.imul(re, ke)) | 0),
              (b = (b + Math.imul(re, $e)) | 0),
              (v = (v + Math.imul(be, Ie)) | 0),
              (a = (a + Math.imul(be, De)) | 0),
              (a = (a + Math.imul(oe, Ie)) | 0),
              (b = (b + Math.imul(oe, De)) | 0),
              (v = (v + Math.imul(fe, xe)) | 0),
              (a = (a + Math.imul(fe, Ue)) | 0),
              (a = (a + Math.imul(le, xe)) | 0),
              (b = (b + Math.imul(le, Ue)) | 0),
              (v = (v + Math.imul($, Be)) | 0),
              (a = (a + Math.imul($, ze)) | 0),
              (a = (a + Math.imul(Z, Be)) | 0),
              (b = (b + Math.imul(Z, ze)) | 0);
            var yr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (yr >>> 26)) | 0),
              (yr &= 67108863),
              (v = Math.imul(T, Ae)),
              (a = Math.imul(T, Le)),
              (a = (a + Math.imul(x, Ae)) | 0),
              (b = Math.imul(x, Le)),
              (v = (v + Math.imul(K, Ee)) | 0),
              (a = (a + Math.imul(K, Ne)) | 0),
              (a = (a + Math.imul(O, Ee)) | 0),
              (b = (b + Math.imul(O, Ne)) | 0),
              (v = (v + Math.imul(ce, ke)) | 0),
              (a = (a + Math.imul(ce, $e)) | 0),
              (a = (a + Math.imul(he, ke)) | 0),
              (b = (b + Math.imul(he, $e)) | 0),
              (v = (v + Math.imul(me, Ie)) | 0),
              (a = (a + Math.imul(me, De)) | 0),
              (a = (a + Math.imul(re, Ie)) | 0),
              (b = (b + Math.imul(re, De)) | 0),
              (v = (v + Math.imul(be, xe)) | 0),
              (a = (a + Math.imul(be, Ue)) | 0),
              (a = (a + Math.imul(oe, xe)) | 0),
              (b = (b + Math.imul(oe, Ue)) | 0),
              (v = (v + Math.imul(fe, Be)) | 0),
              (a = (a + Math.imul(fe, ze)) | 0),
              (a = (a + Math.imul(le, Be)) | 0),
              (b = (b + Math.imul(le, ze)) | 0);
            var gr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (gr >>> 26)) | 0),
              (gr &= 67108863),
              (v = Math.imul(T, Ee)),
              (a = Math.imul(T, Ne)),
              (a = (a + Math.imul(x, Ee)) | 0),
              (b = Math.imul(x, Ne)),
              (v = (v + Math.imul(K, ke)) | 0),
              (a = (a + Math.imul(K, $e)) | 0),
              (a = (a + Math.imul(O, ke)) | 0),
              (b = (b + Math.imul(O, $e)) | 0),
              (v = (v + Math.imul(ce, Ie)) | 0),
              (a = (a + Math.imul(ce, De)) | 0),
              (a = (a + Math.imul(he, Ie)) | 0),
              (b = (b + Math.imul(he, De)) | 0),
              (v = (v + Math.imul(me, xe)) | 0),
              (a = (a + Math.imul(me, Ue)) | 0),
              (a = (a + Math.imul(re, xe)) | 0),
              (b = (b + Math.imul(re, Ue)) | 0),
              (v = (v + Math.imul(be, Be)) | 0),
              (a = (a + Math.imul(be, ze)) | 0),
              (a = (a + Math.imul(oe, Be)) | 0),
              (b = (b + Math.imul(oe, ze)) | 0);
            var br = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (br >>> 26)) | 0),
              (br &= 67108863),
              (v = Math.imul(T, ke)),
              (a = Math.imul(T, $e)),
              (a = (a + Math.imul(x, ke)) | 0),
              (b = Math.imul(x, $e)),
              (v = (v + Math.imul(K, Ie)) | 0),
              (a = (a + Math.imul(K, De)) | 0),
              (a = (a + Math.imul(O, Ie)) | 0),
              (b = (b + Math.imul(O, De)) | 0),
              (v = (v + Math.imul(ce, xe)) | 0),
              (a = (a + Math.imul(ce, Ue)) | 0),
              (a = (a + Math.imul(he, xe)) | 0),
              (b = (b + Math.imul(he, Ue)) | 0),
              (v = (v + Math.imul(me, Be)) | 0),
              (a = (a + Math.imul(me, ze)) | 0),
              (a = (a + Math.imul(re, Be)) | 0),
              (b = (b + Math.imul(re, ze)) | 0);
            var vr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (vr >>> 26)) | 0),
              (vr &= 67108863),
              (v = Math.imul(T, Ie)),
              (a = Math.imul(T, De)),
              (a = (a + Math.imul(x, Ie)) | 0),
              (b = Math.imul(x, De)),
              (v = (v + Math.imul(K, xe)) | 0),
              (a = (a + Math.imul(K, Ue)) | 0),
              (a = (a + Math.imul(O, xe)) | 0),
              (b = (b + Math.imul(O, Ue)) | 0),
              (v = (v + Math.imul(ce, Be)) | 0),
              (a = (a + Math.imul(ce, ze)) | 0),
              (a = (a + Math.imul(he, Be)) | 0),
              (b = (b + Math.imul(he, ze)) | 0);
            var mr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (mr >>> 26)) | 0),
              (mr &= 67108863),
              (v = Math.imul(T, xe)),
              (a = Math.imul(T, Ue)),
              (a = (a + Math.imul(x, xe)) | 0),
              (b = Math.imul(x, Ue)),
              (v = (v + Math.imul(K, Be)) | 0),
              (a = (a + Math.imul(K, ze)) | 0),
              (a = (a + Math.imul(O, Be)) | 0),
              (b = (b + Math.imul(O, ze)) | 0);
            var wr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (wr >>> 26)) | 0),
              (wr &= 67108863),
              (v = Math.imul(T, Be)),
              (a = Math.imul(T, ze)),
              (a = (a + Math.imul(x, Be)) | 0),
              (b = Math.imul(x, ze));
            var _r = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            return (
              (M = (((b + (a >>> 13)) | 0) + (_r >>> 26)) | 0),
              (_r &= 67108863),
              (w[0] = st),
              (w[1] = at),
              (w[2] = Ft),
              (w[3] = qt),
              (w[4] = Wt),
              (w[5] = Kt),
              (w[6] = jt),
              (w[7] = fr),
              (w[8] = lr),
              (w[9] = hr),
              (w[10] = dr),
              (w[11] = pr),
              (w[12] = yr),
              (w[13] = gr),
              (w[14] = br),
              (w[15] = vr),
              (w[16] = mr),
              (w[17] = wr),
              (w[18] = _r),
              M !== 0 && ((w[19] = M), l.length++),
              l
            );
          };
          Math.imul || (I = E);
          function R(S, o, u) {
            (u.negative = o.negative ^ S.negative), (u.length = S.length + o.length);
            for (var l = 0, d = 0, g = 0; g < u.length - 1; g++) {
              var w = d;
              d = 0;
              for (
                var M = l & 67108863,
                  v = Math.min(g, o.length - 1),
                  a = Math.max(0, g - S.length + 1);
                a <= v;
                a++
              ) {
                var b = g - a,
                  k = S.words[b] | 0,
                  B = o.words[a] | 0,
                  F = k * B,
                  P = F & 67108863;
                (w = (w + ((F / 67108864) | 0)) | 0),
                  (P = (P + M) | 0),
                  (M = P & 67108863),
                  (w = (w + (P >>> 26)) | 0),
                  (d += w >>> 26),
                  (w &= 67108863);
              }
              (u.words[g] = M), (l = w), (w = d);
            }
            return l !== 0 ? (u.words[g] = l) : u.length--, u.strip();
          }
          function L(S, o, u) {
            var l = new D();
            return l.mulp(S, o, u);
          }
          n.prototype.mulTo = function (o, u) {
            var l,
              d = this.length + o.length;
            return (
              this.length === 10 && o.length === 10
                ? (l = I(this, o, u))
                : d < 63
                  ? (l = E(this, o, u))
                  : d < 1024
                    ? (l = R(this, o, u))
                    : (l = L(this, o, u)),
              l
            );
          };
          function D(S, o) {
            (this.x = S), (this.y = o);
          }
          (D.prototype.makeRBT = function (o) {
            for (var u = new Array(o), l = n.prototype._countBits(o) - 1, d = 0; d < o; d++)
              u[d] = this.revBin(d, l, o);
            return u;
          }),
            (D.prototype.revBin = function (o, u, l) {
              if (o === 0 || o === l - 1) return o;
              for (var d = 0, g = 0; g < u; g++) (d |= (o & 1) << (u - g - 1)), (o >>= 1);
              return d;
            }),
            (D.prototype.permute = function (o, u, l, d, g, w) {
              for (var M = 0; M < w; M++) (d[M] = u[o[M]]), (g[M] = l[o[M]]);
            }),
            (D.prototype.transform = function (o, u, l, d, g, w) {
              this.permute(w, o, u, l, d, g);
              for (var M = 1; M < g; M <<= 1)
                for (
                  var v = M << 1,
                    a = Math.cos((2 * Math.PI) / v),
                    b = Math.sin((2 * Math.PI) / v),
                    k = 0;
                  k < g;
                  k += v
                )
                  for (var B = a, F = b, P = 0; P < M; P++) {
                    var C = l[k + P],
                      z = d[k + P],
                      Y = l[k + P + M],
                      G = d[k + P + M],
                      Q = B * Y - F * G;
                    (G = B * G + F * Y),
                      (Y = Q),
                      (l[k + P] = C + Y),
                      (d[k + P] = z + G),
                      (l[k + P + M] = C - Y),
                      (d[k + P + M] = z - G),
                      P !== v && ((Q = a * B - b * F), (F = a * F + b * B), (B = Q));
                  }
            }),
            (D.prototype.guessLen13b = function (o, u) {
              var l = Math.max(u, o) | 1,
                d = l & 1,
                g = 0;
              for (l = (l / 2) | 0; l; l = l >>> 1) g++;
              return 1 << (g + 1 + d);
            }),
            (D.prototype.conjugate = function (o, u, l) {
              if (!(l <= 1))
                for (var d = 0; d < l / 2; d++) {
                  var g = o[d];
                  (o[d] = o[l - d - 1]),
                    (o[l - d - 1] = g),
                    (g = u[d]),
                    (u[d] = -u[l - d - 1]),
                    (u[l - d - 1] = -g);
                }
            }),
            (D.prototype.normalize13b = function (o, u) {
              for (var l = 0, d = 0; d < u / 2; d++) {
                var g = Math.round(o[2 * d + 1] / u) * 8192 + Math.round(o[2 * d] / u) + l;
                (o[d] = g & 67108863), g < 67108864 ? (l = 0) : (l = (g / 67108864) | 0);
              }
              return o;
            }),
            (D.prototype.convert13b = function (o, u, l, d) {
              for (var g = 0, w = 0; w < u; w++)
                (g = g + (o[w] | 0)),
                  (l[2 * w] = g & 8191),
                  (g = g >>> 13),
                  (l[2 * w + 1] = g & 8191),
                  (g = g >>> 13);
              for (w = 2 * u; w < d; ++w) l[w] = 0;
              r(g === 0), r((g & -8192) === 0);
            }),
            (D.prototype.stub = function (o) {
              for (var u = new Array(o), l = 0; l < o; l++) u[l] = 0;
              return u;
            }),
            (D.prototype.mulp = function (o, u, l) {
              var d = 2 * this.guessLen13b(o.length, u.length),
                g = this.makeRBT(d),
                w = this.stub(d),
                M = new Array(d),
                v = new Array(d),
                a = new Array(d),
                b = new Array(d),
                k = new Array(d),
                B = new Array(d),
                F = l.words;
              (F.length = d),
                this.convert13b(o.words, o.length, M, d),
                this.convert13b(u.words, u.length, b, d),
                this.transform(M, w, v, a, d, g),
                this.transform(b, w, k, B, d, g);
              for (var P = 0; P < d; P++) {
                var C = v[P] * k[P] - a[P] * B[P];
                (a[P] = v[P] * B[P] + a[P] * k[P]), (v[P] = C);
              }
              return (
                this.conjugate(v, a, d),
                this.transform(v, a, F, w, d, g),
                this.conjugate(F, w, d),
                this.normalize13b(F, d),
                (l.negative = o.negative ^ u.negative),
                (l.length = o.length + u.length),
                l.strip()
              );
            }),
            (n.prototype.mul = function (o) {
              var u = new n(null);
              return (u.words = new Array(this.length + o.length)), this.mulTo(o, u);
            }),
            (n.prototype.mulf = function (o) {
              var u = new n(null);
              return (u.words = new Array(this.length + o.length)), L(this, o, u);
            }),
            (n.prototype.imul = function (o) {
              return this.clone().mulTo(o, this);
            }),
            (n.prototype.imuln = function (o) {
              r(typeof o == 'number'), r(o < 67108864);
              for (var u = 0, l = 0; l < this.length; l++) {
                var d = (this.words[l] | 0) * o,
                  g = (d & 67108863) + (u & 67108863);
                (u >>= 26),
                  (u += (d / 67108864) | 0),
                  (u += g >>> 26),
                  (this.words[l] = g & 67108863);
              }
              return u !== 0 && ((this.words[l] = u), this.length++), this;
            }),
            (n.prototype.muln = function (o) {
              return this.clone().imuln(o);
            }),
            (n.prototype.sqr = function () {
              return this.mul(this);
            }),
            (n.prototype.isqr = function () {
              return this.imul(this.clone());
            }),
            (n.prototype.pow = function (o) {
              var u = A(o);
              if (u.length === 0) return new n(1);
              for (var l = this, d = 0; d < u.length && u[d] === 0; d++, l = l.sqr());
              if (++d < u.length)
                for (var g = l.sqr(); d < u.length; d++, g = g.sqr()) u[d] !== 0 && (l = l.mul(g));
              return l;
            }),
            (n.prototype.iushln = function (o) {
              r(typeof o == 'number' && o >= 0);
              var u = o % 26,
                l = (o - u) / 26,
                d = (67108863 >>> (26 - u)) << (26 - u),
                g;
              if (u !== 0) {
                var w = 0;
                for (g = 0; g < this.length; g++) {
                  var M = this.words[g] & d,
                    v = ((this.words[g] | 0) - M) << u;
                  (this.words[g] = v | w), (w = M >>> (26 - u));
                }
                w && ((this.words[g] = w), this.length++);
              }
              if (l !== 0) {
                for (g = this.length - 1; g >= 0; g--) this.words[g + l] = this.words[g];
                for (g = 0; g < l; g++) this.words[g] = 0;
                this.length += l;
              }
              return this.strip();
            }),
            (n.prototype.ishln = function (o) {
              return r(this.negative === 0), this.iushln(o);
            }),
            (n.prototype.iushrn = function (o, u, l) {
              r(typeof o == 'number' && o >= 0);
              var d;
              u ? (d = (u - (u % 26)) / 26) : (d = 0);
              var g = o % 26,
                w = Math.min((o - g) / 26, this.length),
                M = 67108863 ^ ((67108863 >>> g) << g),
                v = l;
              if (((d -= w), (d = Math.max(0, d)), v)) {
                for (var a = 0; a < w; a++) v.words[a] = this.words[a];
                v.length = w;
              }
              if (w !== 0)
                if (this.length > w)
                  for (this.length -= w, a = 0; a < this.length; a++)
                    this.words[a] = this.words[a + w];
                else (this.words[0] = 0), (this.length = 1);
              var b = 0;
              for (a = this.length - 1; a >= 0 && (b !== 0 || a >= d); a--) {
                var k = this.words[a] | 0;
                (this.words[a] = (b << (26 - g)) | (k >>> g)), (b = k & M);
              }
              return (
                v && b !== 0 && (v.words[v.length++] = b),
                this.length === 0 && ((this.words[0] = 0), (this.length = 1)),
                this.strip()
              );
            }),
            (n.prototype.ishrn = function (o, u, l) {
              return r(this.negative === 0), this.iushrn(o, u, l);
            }),
            (n.prototype.shln = function (o) {
              return this.clone().ishln(o);
            }),
            (n.prototype.ushln = function (o) {
              return this.clone().iushln(o);
            }),
            (n.prototype.shrn = function (o) {
              return this.clone().ishrn(o);
            }),
            (n.prototype.ushrn = function (o) {
              return this.clone().iushrn(o);
            }),
            (n.prototype.testn = function (o) {
              r(typeof o == 'number' && o >= 0);
              var u = o % 26,
                l = (o - u) / 26,
                d = 1 << u;
              if (this.length <= l) return !1;
              var g = this.words[l];
              return !!(g & d);
            }),
            (n.prototype.imaskn = function (o) {
              r(typeof o == 'number' && o >= 0);
              var u = o % 26,
                l = (o - u) / 26;
              if (
                (r(this.negative === 0, 'imaskn works only with positive numbers'),
                this.length <= l)
              )
                return this;
              if ((u !== 0 && l++, (this.length = Math.min(l, this.length)), u !== 0)) {
                var d = 67108863 ^ ((67108863 >>> u) << u);
                this.words[this.length - 1] &= d;
              }
              return this.strip();
            }),
            (n.prototype.maskn = function (o) {
              return this.clone().imaskn(o);
            }),
            (n.prototype.iaddn = function (o) {
              return (
                r(typeof o == 'number'),
                r(o < 67108864),
                o < 0
                  ? this.isubn(-o)
                  : this.negative !== 0
                    ? this.length === 1 && (this.words[0] | 0) < o
                      ? ((this.words[0] = o - (this.words[0] | 0)), (this.negative = 0), this)
                      : ((this.negative = 0), this.isubn(o), (this.negative = 1), this)
                    : this._iaddn(o)
              );
            }),
            (n.prototype._iaddn = function (o) {
              this.words[0] += o;
              for (var u = 0; u < this.length && this.words[u] >= 67108864; u++)
                (this.words[u] -= 67108864),
                  u === this.length - 1 ? (this.words[u + 1] = 1) : this.words[u + 1]++;
              return (this.length = Math.max(this.length, u + 1)), this;
            }),
            (n.prototype.isubn = function (o) {
              if ((r(typeof o == 'number'), r(o < 67108864), o < 0)) return this.iaddn(-o);
              if (this.negative !== 0)
                return (this.negative = 0), this.iaddn(o), (this.negative = 1), this;
              if (((this.words[0] -= o), this.length === 1 && this.words[0] < 0))
                (this.words[0] = -this.words[0]), (this.negative = 1);
              else
                for (var u = 0; u < this.length && this.words[u] < 0; u++)
                  (this.words[u] += 67108864), (this.words[u + 1] -= 1);
              return this.strip();
            }),
            (n.prototype.addn = function (o) {
              return this.clone().iaddn(o);
            }),
            (n.prototype.subn = function (o) {
              return this.clone().isubn(o);
            }),
            (n.prototype.iabs = function () {
              return (this.negative = 0), this;
            }),
            (n.prototype.abs = function () {
              return this.clone().iabs();
            }),
            (n.prototype._ishlnsubmul = function (o, u, l) {
              var d = o.length + l,
                g;
              this._expand(d);
              var w,
                M = 0;
              for (g = 0; g < o.length; g++) {
                w = (this.words[g + l] | 0) + M;
                var v = (o.words[g] | 0) * u;
                (w -= v & 67108863),
                  (M = (w >> 26) - ((v / 67108864) | 0)),
                  (this.words[g + l] = w & 67108863);
              }
              for (; g < this.length - l; g++)
                (w = (this.words[g + l] | 0) + M),
                  (M = w >> 26),
                  (this.words[g + l] = w & 67108863);
              if (M === 0) return this.strip();
              for (r(M === -1), M = 0, g = 0; g < this.length; g++)
                (w = -(this.words[g] | 0) + M), (M = w >> 26), (this.words[g] = w & 67108863);
              return (this.negative = 1), this.strip();
            }),
            (n.prototype._wordDiv = function (o, u) {
              var l = this.length - o.length,
                d = this.clone(),
                g = o,
                w = g.words[g.length - 1] | 0,
                M = this._countBits(w);
              (l = 26 - M),
                l !== 0 && ((g = g.ushln(l)), d.iushln(l), (w = g.words[g.length - 1] | 0));
              var v = d.length - g.length,
                a;
              if (u !== 'mod') {
                (a = new n(null)), (a.length = v + 1), (a.words = new Array(a.length));
                for (var b = 0; b < a.length; b++) a.words[b] = 0;
              }
              var k = d.clone()._ishlnsubmul(g, 1, v);
              k.negative === 0 && ((d = k), a && (a.words[v] = 1));
              for (var B = v - 1; B >= 0; B--) {
                var F = (d.words[g.length + B] | 0) * 67108864 + (d.words[g.length + B - 1] | 0);
                for (
                  F = Math.min((F / w) | 0, 67108863), d._ishlnsubmul(g, F, B);
                  d.negative !== 0;

                )
                  F--, (d.negative = 0), d._ishlnsubmul(g, 1, B), d.isZero() || (d.negative ^= 1);
                a && (a.words[B] = F);
              }
              return (
                a && a.strip(),
                d.strip(),
                u !== 'div' && l !== 0 && d.iushrn(l),
                { div: a || null, mod: d }
              );
            }),
            (n.prototype.divmod = function (o, u, l) {
              if ((r(!o.isZero()), this.isZero())) return { div: new n(0), mod: new n(0) };
              var d, g, w;
              return this.negative !== 0 && o.negative === 0
                ? ((w = this.neg().divmod(o, u)),
                  u !== 'mod' && (d = w.div.neg()),
                  u !== 'div' && ((g = w.mod.neg()), l && g.negative !== 0 && g.iadd(o)),
                  { div: d, mod: g })
                : this.negative === 0 && o.negative !== 0
                  ? ((w = this.divmod(o.neg(), u)),
                    u !== 'mod' && (d = w.div.neg()),
                    { div: d, mod: w.mod })
                  : this.negative & o.negative
                    ? ((w = this.neg().divmod(o.neg(), u)),
                      u !== 'div' && ((g = w.mod.neg()), l && g.negative !== 0 && g.isub(o)),
                      { div: w.div, mod: g })
                    : o.length > this.length || this.cmp(o) < 0
                      ? { div: new n(0), mod: this }
                      : o.length === 1
                        ? u === 'div'
                          ? { div: this.divn(o.words[0]), mod: null }
                          : u === 'mod'
                            ? { div: null, mod: new n(this.modn(o.words[0])) }
                            : { div: this.divn(o.words[0]), mod: new n(this.modn(o.words[0])) }
                        : this._wordDiv(o, u);
            }),
            (n.prototype.div = function (o) {
              return this.divmod(o, 'div', !1).div;
            }),
            (n.prototype.mod = function (o) {
              return this.divmod(o, 'mod', !1).mod;
            }),
            (n.prototype.umod = function (o) {
              return this.divmod(o, 'mod', !0).mod;
            }),
            (n.prototype.divRound = function (o) {
              var u = this.divmod(o);
              if (u.mod.isZero()) return u.div;
              var l = u.div.negative !== 0 ? u.mod.isub(o) : u.mod,
                d = o.ushrn(1),
                g = o.andln(1),
                w = l.cmp(d);
              return w < 0 || (g === 1 && w === 0)
                ? u.div
                : u.div.negative !== 0
                  ? u.div.isubn(1)
                  : u.div.iaddn(1);
            }),
            (n.prototype.modn = function (o) {
              r(o <= 67108863);
              for (var u = (1 << 26) % o, l = 0, d = this.length - 1; d >= 0; d--)
                l = (u * l + (this.words[d] | 0)) % o;
              return l;
            }),
            (n.prototype.idivn = function (o) {
              r(o <= 67108863);
              for (var u = 0, l = this.length - 1; l >= 0; l--) {
                var d = (this.words[l] | 0) + u * 67108864;
                (this.words[l] = (d / o) | 0), (u = d % o);
              }
              return this.strip();
            }),
            (n.prototype.divn = function (o) {
              return this.clone().idivn(o);
            }),
            (n.prototype.egcd = function (o) {
              r(o.negative === 0), r(!o.isZero());
              var u = this,
                l = o.clone();
              u.negative !== 0 ? (u = u.umod(o)) : (u = u.clone());
              for (
                var d = new n(1), g = new n(0), w = new n(0), M = new n(1), v = 0;
                u.isEven() && l.isEven();

              )
                u.iushrn(1), l.iushrn(1), ++v;
              for (var a = l.clone(), b = u.clone(); !u.isZero(); ) {
                for (var k = 0, B = 1; !(u.words[0] & B) && k < 26; ++k, B <<= 1);
                if (k > 0)
                  for (u.iushrn(k); k-- > 0; )
                    (d.isOdd() || g.isOdd()) && (d.iadd(a), g.isub(b)), d.iushrn(1), g.iushrn(1);
                for (var F = 0, P = 1; !(l.words[0] & P) && F < 26; ++F, P <<= 1);
                if (F > 0)
                  for (l.iushrn(F); F-- > 0; )
                    (w.isOdd() || M.isOdd()) && (w.iadd(a), M.isub(b)), w.iushrn(1), M.iushrn(1);
                u.cmp(l) >= 0
                  ? (u.isub(l), d.isub(w), g.isub(M))
                  : (l.isub(u), w.isub(d), M.isub(g));
              }
              return { a: w, b: M, gcd: l.iushln(v) };
            }),
            (n.prototype._invmp = function (o) {
              r(o.negative === 0), r(!o.isZero());
              var u = this,
                l = o.clone();
              u.negative !== 0 ? (u = u.umod(o)) : (u = u.clone());
              for (
                var d = new n(1), g = new n(0), w = l.clone();
                u.cmpn(1) > 0 && l.cmpn(1) > 0;

              ) {
                for (var M = 0, v = 1; !(u.words[0] & v) && M < 26; ++M, v <<= 1);
                if (M > 0) for (u.iushrn(M); M-- > 0; ) d.isOdd() && d.iadd(w), d.iushrn(1);
                for (var a = 0, b = 1; !(l.words[0] & b) && a < 26; ++a, b <<= 1);
                if (a > 0) for (l.iushrn(a); a-- > 0; ) g.isOdd() && g.iadd(w), g.iushrn(1);
                u.cmp(l) >= 0 ? (u.isub(l), d.isub(g)) : (l.isub(u), g.isub(d));
              }
              var k;
              return u.cmpn(1) === 0 ? (k = d) : (k = g), k.cmpn(0) < 0 && k.iadd(o), k;
            }),
            (n.prototype.gcd = function (o) {
              if (this.isZero()) return o.abs();
              if (o.isZero()) return this.abs();
              var u = this.clone(),
                l = o.clone();
              (u.negative = 0), (l.negative = 0);
              for (var d = 0; u.isEven() && l.isEven(); d++) u.iushrn(1), l.iushrn(1);
              do {
                for (; u.isEven(); ) u.iushrn(1);
                for (; l.isEven(); ) l.iushrn(1);
                var g = u.cmp(l);
                if (g < 0) {
                  var w = u;
                  (u = l), (l = w);
                } else if (g === 0 || l.cmpn(1) === 0) break;
                u.isub(l);
              } while (!0);
              return l.iushln(d);
            }),
            (n.prototype.invm = function (o) {
              return this.egcd(o).a.umod(o);
            }),
            (n.prototype.isEven = function () {
              return (this.words[0] & 1) === 0;
            }),
            (n.prototype.isOdd = function () {
              return (this.words[0] & 1) === 1;
            }),
            (n.prototype.andln = function (o) {
              return this.words[0] & o;
            }),
            (n.prototype.bincn = function (o) {
              r(typeof o == 'number');
              var u = o % 26,
                l = (o - u) / 26,
                d = 1 << u;
              if (this.length <= l) return this._expand(l + 1), (this.words[l] |= d), this;
              for (var g = d, w = l; g !== 0 && w < this.length; w++) {
                var M = this.words[w] | 0;
                (M += g), (g = M >>> 26), (M &= 67108863), (this.words[w] = M);
              }
              return g !== 0 && ((this.words[w] = g), this.length++), this;
            }),
            (n.prototype.isZero = function () {
              return this.length === 1 && this.words[0] === 0;
            }),
            (n.prototype.cmpn = function (o) {
              var u = o < 0;
              if (this.negative !== 0 && !u) return -1;
              if (this.negative === 0 && u) return 1;
              this.strip();
              var l;
              if (this.length > 1) l = 1;
              else {
                u && (o = -o), r(o <= 67108863, 'Number is too big');
                var d = this.words[0] | 0;
                l = d === o ? 0 : d < o ? -1 : 1;
              }
              return this.negative !== 0 ? -l | 0 : l;
            }),
            (n.prototype.cmp = function (o) {
              if (this.negative !== 0 && o.negative === 0) return -1;
              if (this.negative === 0 && o.negative !== 0) return 1;
              var u = this.ucmp(o);
              return this.negative !== 0 ? -u | 0 : u;
            }),
            (n.prototype.ucmp = function (o) {
              if (this.length > o.length) return 1;
              if (this.length < o.length) return -1;
              for (var u = 0, l = this.length - 1; l >= 0; l--) {
                var d = this.words[l] | 0,
                  g = o.words[l] | 0;
                if (d !== g) {
                  d < g ? (u = -1) : d > g && (u = 1);
                  break;
                }
              }
              return u;
            }),
            (n.prototype.gtn = function (o) {
              return this.cmpn(o) === 1;
            }),
            (n.prototype.gt = function (o) {
              return this.cmp(o) === 1;
            }),
            (n.prototype.gten = function (o) {
              return this.cmpn(o) >= 0;
            }),
            (n.prototype.gte = function (o) {
              return this.cmp(o) >= 0;
            }),
            (n.prototype.ltn = function (o) {
              return this.cmpn(o) === -1;
            }),
            (n.prototype.lt = function (o) {
              return this.cmp(o) === -1;
            }),
            (n.prototype.lten = function (o) {
              return this.cmpn(o) <= 0;
            }),
            (n.prototype.lte = function (o) {
              return this.cmp(o) <= 0;
            }),
            (n.prototype.eqn = function (o) {
              return this.cmpn(o) === 0;
            }),
            (n.prototype.eq = function (o) {
              return this.cmp(o) === 0;
            }),
            (n.red = function (o) {
              return new X(o);
            }),
            (n.prototype.toRed = function (o) {
              return (
                r(!this.red, 'Already a number in reduction context'),
                r(this.negative === 0, 'red works only with positives'),
                o.convertTo(this)._forceRed(o)
              );
            }),
            (n.prototype.fromRed = function () {
              return (
                r(this.red, 'fromRed works only with numbers in reduction context'),
                this.red.convertFrom(this)
              );
            }),
            (n.prototype._forceRed = function (o) {
              return (this.red = o), this;
            }),
            (n.prototype.forceRed = function (o) {
              return r(!this.red, 'Already a number in reduction context'), this._forceRed(o);
            }),
            (n.prototype.redAdd = function (o) {
              return r(this.red, 'redAdd works only with red numbers'), this.red.add(this, o);
            }),
            (n.prototype.redIAdd = function (o) {
              return r(this.red, 'redIAdd works only with red numbers'), this.red.iadd(this, o);
            }),
            (n.prototype.redSub = function (o) {
              return r(this.red, 'redSub works only with red numbers'), this.red.sub(this, o);
            }),
            (n.prototype.redISub = function (o) {
              return r(this.red, 'redISub works only with red numbers'), this.red.isub(this, o);
            }),
            (n.prototype.redShl = function (o) {
              return r(this.red, 'redShl works only with red numbers'), this.red.shl(this, o);
            }),
            (n.prototype.redMul = function (o) {
              return (
                r(this.red, 'redMul works only with red numbers'),
                this.red._verify2(this, o),
                this.red.mul(this, o)
              );
            }),
            (n.prototype.redIMul = function (o) {
              return (
                r(this.red, 'redMul works only with red numbers'),
                this.red._verify2(this, o),
                this.red.imul(this, o)
              );
            }),
            (n.prototype.redSqr = function () {
              return (
                r(this.red, 'redSqr works only with red numbers'),
                this.red._verify1(this),
                this.red.sqr(this)
              );
            }),
            (n.prototype.redISqr = function () {
              return (
                r(this.red, 'redISqr works only with red numbers'),
                this.red._verify1(this),
                this.red.isqr(this)
              );
            }),
            (n.prototype.redSqrt = function () {
              return (
                r(this.red, 'redSqrt works only with red numbers'),
                this.red._verify1(this),
                this.red.sqrt(this)
              );
            }),
            (n.prototype.redInvm = function () {
              return (
                r(this.red, 'redInvm works only with red numbers'),
                this.red._verify1(this),
                this.red.invm(this)
              );
            }),
            (n.prototype.redNeg = function () {
              return (
                r(this.red, 'redNeg works only with red numbers'),
                this.red._verify1(this),
                this.red.neg(this)
              );
            }),
            (n.prototype.redPow = function (o) {
              return (
                r(this.red && !o.red, 'redPow(normalNum)'),
                this.red._verify1(this),
                this.red.pow(this, o)
              );
            });
          var q = { k256: null, p224: null, p192: null, p25519: null };
          function H(S, o) {
            (this.name = S),
              (this.p = new n(o, 16)),
              (this.n = this.p.bitLength()),
              (this.k = new n(1).iushln(this.n).isub(this.p)),
              (this.tmp = this._tmp());
          }
          (H.prototype._tmp = function () {
            var o = new n(null);
            return (o.words = new Array(Math.ceil(this.n / 13))), o;
          }),
            (H.prototype.ireduce = function (o) {
              var u = o,
                l;
              do
                this.split(u, this.tmp),
                  (u = this.imulK(u)),
                  (u = u.iadd(this.tmp)),
                  (l = u.bitLength());
              while (l > this.n);
              var d = l < this.n ? -1 : u.ucmp(this.p);
              return (
                d === 0
                  ? ((u.words[0] = 0), (u.length = 1))
                  : d > 0
                    ? u.isub(this.p)
                    : u.strip !== void 0
                      ? u.strip()
                      : u._strip(),
                u
              );
            }),
            (H.prototype.split = function (o, u) {
              o.iushrn(this.n, 0, u);
            }),
            (H.prototype.imulK = function (o) {
              return o.imul(this.k);
            });
          function V() {
            H.call(
              this,
              'k256',
              'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f'
            );
          }
          s(V, H),
            (V.prototype.split = function (o, u) {
              for (var l = 4194303, d = Math.min(o.length, 9), g = 0; g < d; g++)
                u.words[g] = o.words[g];
              if (((u.length = d), o.length <= 9)) {
                (o.words[0] = 0), (o.length = 1);
                return;
              }
              var w = o.words[9];
              for (u.words[u.length++] = w & l, g = 10; g < o.length; g++) {
                var M = o.words[g] | 0;
                (o.words[g - 10] = ((M & l) << 4) | (w >>> 22)), (w = M);
              }
              (w >>>= 22),
                (o.words[g - 10] = w),
                w === 0 && o.length > 10 ? (o.length -= 10) : (o.length -= 9);
            }),
            (V.prototype.imulK = function (o) {
              (o.words[o.length] = 0), (o.words[o.length + 1] = 0), (o.length += 2);
              for (var u = 0, l = 0; l < o.length; l++) {
                var d = o.words[l] | 0;
                (u += d * 977), (o.words[l] = u & 67108863), (u = d * 64 + ((u / 67108864) | 0));
              }
              return (
                o.words[o.length - 1] === 0 &&
                  (o.length--, o.words[o.length - 1] === 0 && o.length--),
                o
              );
            });
          function te() {
            H.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
          }
          s(te, H);
          function ue() {
            H.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
          }
          s(ue, H);
          function ne() {
            H.call(
              this,
              '25519',
              '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed'
            );
          }
          s(ne, H),
            (ne.prototype.imulK = function (o) {
              for (var u = 0, l = 0; l < o.length; l++) {
                var d = (o.words[l] | 0) * 19 + u,
                  g = d & 67108863;
                (d >>>= 26), (o.words[l] = g), (u = d);
              }
              return u !== 0 && (o.words[o.length++] = u), o;
            }),
            (n._prime = function (o) {
              if (q[o]) return q[o];
              var u;
              if (o === 'k256') u = new V();
              else if (o === 'p224') u = new te();
              else if (o === 'p192') u = new ue();
              else if (o === 'p25519') u = new ne();
              else throw new Error('Unknown prime ' + o);
              return (q[o] = u), u;
            });
          function X(S) {
            if (typeof S == 'string') {
              var o = n._prime(S);
              (this.m = o.p), (this.prime = o);
            } else r(S.gtn(1), 'modulus must be greater than 1'), (this.m = S), (this.prime = null);
          }
          (X.prototype._verify1 = function (o) {
            r(o.negative === 0, 'red works only with positives'),
              r(o.red, 'red works only with red numbers');
          }),
            (X.prototype._verify2 = function (o, u) {
              r((o.negative | u.negative) === 0, 'red works only with positives'),
                r(o.red && o.red === u.red, 'red works only with red numbers');
            }),
            (X.prototype.imod = function (o) {
              return this.prime
                ? this.prime.ireduce(o)._forceRed(this)
                : o.umod(this.m)._forceRed(this);
            }),
            (X.prototype.neg = function (o) {
              return o.isZero() ? o.clone() : this.m.sub(o)._forceRed(this);
            }),
            (X.prototype.add = function (o, u) {
              this._verify2(o, u);
              var l = o.add(u);
              return l.cmp(this.m) >= 0 && l.isub(this.m), l._forceRed(this);
            }),
            (X.prototype.iadd = function (o, u) {
              this._verify2(o, u);
              var l = o.iadd(u);
              return l.cmp(this.m) >= 0 && l.isub(this.m), l;
            }),
            (X.prototype.sub = function (o, u) {
              this._verify2(o, u);
              var l = o.sub(u);
              return l.cmpn(0) < 0 && l.iadd(this.m), l._forceRed(this);
            }),
            (X.prototype.isub = function (o, u) {
              this._verify2(o, u);
              var l = o.isub(u);
              return l.cmpn(0) < 0 && l.iadd(this.m), l;
            }),
            (X.prototype.shl = function (o, u) {
              return this._verify1(o), this.imod(o.ushln(u));
            }),
            (X.prototype.imul = function (o, u) {
              return this._verify2(o, u), this.imod(o.imul(u));
            }),
            (X.prototype.mul = function (o, u) {
              return this._verify2(o, u), this.imod(o.mul(u));
            }),
            (X.prototype.isqr = function (o) {
              return this.imul(o, o.clone());
            }),
            (X.prototype.sqr = function (o) {
              return this.mul(o, o);
            }),
            (X.prototype.sqrt = function (o) {
              if (o.isZero()) return o.clone();
              var u = this.m.andln(3);
              if ((r(u % 2 === 1), u === 3)) {
                var l = this.m.add(new n(1)).iushrn(2);
                return this.pow(o, l);
              }
              for (var d = this.m.subn(1), g = 0; !d.isZero() && d.andln(1) === 0; )
                g++, d.iushrn(1);
              r(!d.isZero());
              var w = new n(1).toRed(this),
                M = w.redNeg(),
                v = this.m.subn(1).iushrn(1),
                a = this.m.bitLength();
              for (a = new n(2 * a * a).toRed(this); this.pow(a, v).cmp(M) !== 0; ) a.redIAdd(M);
              for (
                var b = this.pow(a, d),
                  k = this.pow(o, d.addn(1).iushrn(1)),
                  B = this.pow(o, d),
                  F = g;
                B.cmp(w) !== 0;

              ) {
                for (var P = B, C = 0; P.cmp(w) !== 0; C++) P = P.redSqr();
                r(C < F);
                var z = this.pow(b, new n(1).iushln(F - C - 1));
                (k = k.redMul(z)), (b = z.redSqr()), (B = B.redMul(b)), (F = C);
              }
              return k;
            }),
            (X.prototype.invm = function (o) {
              var u = o._invmp(this.m);
              return u.negative !== 0 ? ((u.negative = 0), this.imod(u).redNeg()) : this.imod(u);
            }),
            (X.prototype.pow = function (o, u) {
              if (u.isZero()) return new n(1).toRed(this);
              if (u.cmpn(1) === 0) return o.clone();
              var l = 4,
                d = new Array(1 << l);
              (d[0] = new n(1).toRed(this)), (d[1] = o);
              for (var g = 2; g < d.length; g++) d[g] = this.mul(d[g - 1], o);
              var w = d[0],
                M = 0,
                v = 0,
                a = u.bitLength() % 26;
              for (a === 0 && (a = 26), g = u.length - 1; g >= 0; g--) {
                for (var b = u.words[g], k = a - 1; k >= 0; k--) {
                  var B = (b >> k) & 1;
                  if ((w !== d[0] && (w = this.sqr(w)), B === 0 && M === 0)) {
                    v = 0;
                    continue;
                  }
                  (M <<= 1),
                    (M |= B),
                    v++,
                    !(v !== l && (g !== 0 || k !== 0)) &&
                      ((w = this.mul(w, d[M])), (v = 0), (M = 0));
                }
                a = 26;
              }
              return w;
            }),
            (X.prototype.convertTo = function (o) {
              var u = o.umod(this.m);
              return u === o ? u.clone() : u;
            }),
            (X.prototype.convertFrom = function (o) {
              var u = o.clone();
              return (u.red = null), u;
            }),
            (n.mont = function (o) {
              return new Oe(o);
            });
          function Oe(S) {
            X.call(this, S),
              (this.shift = this.m.bitLength()),
              this.shift % 26 !== 0 && (this.shift += 26 - (this.shift % 26)),
              (this.r = new n(1).iushln(this.shift)),
              (this.r2 = this.imod(this.r.sqr())),
              (this.rinv = this.r._invmp(this.m)),
              (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
              (this.minv = this.minv.umod(this.r)),
              (this.minv = this.r.sub(this.minv));
          }
          s(Oe, X),
            (Oe.prototype.convertTo = function (o) {
              return this.imod(o.ushln(this.shift));
            }),
            (Oe.prototype.convertFrom = function (o) {
              var u = this.imod(o.mul(this.rinv));
              return (u.red = null), u;
            }),
            (Oe.prototype.imul = function (o, u) {
              if (o.isZero() || u.isZero()) return (o.words[0] = 0), (o.length = 1), o;
              var l = o.imul(u),
                d = l.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                g = l.isub(d).iushrn(this.shift),
                w = g;
              return (
                g.cmp(this.m) >= 0 ? (w = g.isub(this.m)) : g.cmpn(0) < 0 && (w = g.iadd(this.m)),
                w._forceRed(this)
              );
            }),
            (Oe.prototype.mul = function (o, u) {
              if (o.isZero() || u.isZero()) return new n(0)._forceRed(this);
              var l = o.mul(u),
                d = l.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                g = l.isub(d).iushrn(this.shift),
                w = g;
              return (
                g.cmp(this.m) >= 0 ? (w = g.isub(this.m)) : g.cmpn(0) < 0 && (w = g.iadd(this.m)),
                w._forceRed(this)
              );
            }),
            (Oe.prototype.invm = function (o) {
              var u = this.imod(o._invmp(this.m).mul(this.r2));
              return u._forceRed(this);
            });
        })(i, se);
      })(mf)),
    mf.exports
  );
}
var Gc = { exports: {} },
  av;
function uy() {
  if (av) return Gc.exports;
  av = 1;
  var i;
  Gc.exports = function (s) {
    return i || (i = new e(null)), i.generate(s);
  };
  function e(r) {
    this.rand = r;
  }
  if (
    ((Gc.exports.Rand = e),
    (e.prototype.generate = function (s) {
      return this._rand(s);
    }),
    (e.prototype._rand = function (s) {
      if (this.rand.getBytes) return this.rand.getBytes(s);
      for (var n = new Uint8Array(s), c = 0; c < n.length; c++) n[c] = this.rand.getByte();
      return n;
    }),
    typeof globalThis == 'object')
  )
    globalThis.crypto && globalThis.crypto.getRandomValues
      ? (e.prototype._rand = function (s) {
          var n = new Uint8Array(s);
          return globalThis.crypto.getRandomValues(n), n;
        })
      : globalThis.msCrypto && globalThis.msCrypto.getRandomValues
        ? (e.prototype._rand = function (s) {
            var n = new Uint8Array(s);
            return globalThis.msCrypto.getRandomValues(n), n;
          })
        : typeof window == 'object' &&
          (e.prototype._rand = function () {
            throw new Error('Not implemented yet');
          });
  else
    try {
      var t = N8();
      if (typeof t.randomBytes != 'function') throw new Error('Not supported');
      e.prototype._rand = function (s) {
        return t.randomBytes(s);
      };
    } catch {}
  return Gc.exports;
}
var Cd, uv;
function Q6() {
  if (uv) return Cd;
  uv = 1;
  var i = dk(),
    e = uy();
  function t(r) {
    this.rand = r || new e.Rand();
  }
  return (
    (Cd = t),
    (t.create = function (s) {
      return new t(s);
    }),
    (t.prototype._randbelow = function (s) {
      var n = s.bitLength(),
        c = Math.ceil(n / 8);
      do var f = new i(this.rand.generate(c));
      while (f.cmp(s) >= 0);
      return f;
    }),
    (t.prototype._randrange = function (s, n) {
      var c = n.sub(s);
      return s.add(this._randbelow(c));
    }),
    (t.prototype.test = function (s, n, c) {
      var f = s.bitLength(),
        h = i.mont(s),
        y = new i(1).toRed(h);
      n || (n = Math.max(1, (f / 48) | 0));
      for (var p = s.subn(1), m = 0; !p.testn(m); m++);
      for (var _ = s.shrn(m), A = p.toRed(h), E = !0; n > 0; n--) {
        var I = this._randrange(new i(2), p);
        c && c(I);
        var R = I.toRed(h).redPow(_);
        if (!(R.cmp(y) === 0 || R.cmp(A) === 0)) {
          for (var L = 1; L < m; L++) {
            if (((R = R.redSqr()), R.cmp(y) === 0)) return !1;
            if (R.cmp(A) === 0) break;
          }
          if (L === m) return !1;
        }
      }
      return E;
    }),
    (t.prototype.getDivisor = function (s, n) {
      var c = s.bitLength(),
        f = i.mont(s),
        h = new i(1).toRed(f);
      n || (n = Math.max(1, (c / 48) | 0));
      for (var y = s.subn(1), p = 0; !y.testn(p); p++);
      for (var m = s.shrn(p), _ = y.toRed(f); n > 0; n--) {
        var A = this._randrange(new i(2), y),
          E = s.gcd(A);
        if (E.cmpn(1) !== 0) return E;
        var I = A.toRed(f).redPow(m);
        if (!(I.cmp(h) === 0 || I.cmp(_) === 0)) {
          for (var R = 1; R < p; R++) {
            if (((I = I.redSqr()), I.cmp(h) === 0)) return I.fromRed().subn(1).gcd(s);
            if (I.cmp(_) === 0) break;
          }
          if (R === p) return (I = I.redSqr()), I.fromRed().subn(1).gcd(s);
        }
      }
      return !1;
    }),
    Cd
  );
}
var Ld, cv;
function e8() {
  if (cv) return Ld;
  cv = 1;
  var i = Ua();
  (Ld = R), (R.simpleSieve = E), (R.fermatTest = I);
  var e = X6(),
    t = new e(24),
    r = Q6(),
    s = new r(),
    n = new e(1),
    c = new e(2),
    f = new e(5);
  new e(16), new e(8);
  var h = new e(10),
    y = new e(3);
  new e(7);
  var p = new e(11),
    m = new e(4);
  new e(12);
  var _ = null;
  function A() {
    if (_ !== null) return _;
    var L = 1048576,
      D = [];
    D[0] = 2;
    for (var q = 1, H = 3; H < L; H += 2) {
      for (var V = Math.ceil(Math.sqrt(H)), te = 0; te < q && D[te] <= V && H % D[te] !== 0; te++);
      (q !== te && D[te] <= V) || (D[q++] = H);
    }
    return (_ = D), D;
  }
  function E(L) {
    for (var D = A(), q = 0; q < D.length; q++) if (L.modn(D[q]) === 0) return L.cmpn(D[q]) === 0;
    return !0;
  }
  function I(L) {
    var D = e.mont(L);
    return c.toRed(D).redPow(L.subn(1)).fromRed().cmpn(1) === 0;
  }
  function R(L, D) {
    if (L < 16) return D === 2 || D === 5 ? new e([140, 123]) : new e([140, 39]);
    D = new e(D);
    for (var q, H; ; ) {
      for (q = new e(i(Math.ceil(L / 8))); q.bitLength() > L; ) q.ishrn(1);
      if ((q.isEven() && q.iadd(n), q.testn(1) || q.iadd(c), D.cmp(c))) {
        if (!D.cmp(f)) for (; q.mod(h).cmp(y); ) q.iadd(m);
      } else for (; q.mod(t).cmp(p); ) q.iadd(m);
      if (((H = q.shrn(1)), E(H) && E(q) && I(H) && I(q) && s.test(H) && s.test(q))) return q;
    }
  }
  return Ld;
}
const pk = {
    gen: '02',
    prime:
      'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff',
  },
  yk = {
    gen: '02',
    prime:
      'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff',
  },
  gk = {
    gen: '02',
    prime:
      'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff',
  },
  bk = {
    gen: '02',
    prime:
      'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff',
  },
  vk = {
    gen: '02',
    prime:
      'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff',
  },
  mk = {
    gen: '02',
    prime:
      'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff',
  },
  wk = {
    gen: '02',
    prime:
      'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff',
  },
  _k = {
    gen: '02',
    prime:
      'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff',
  },
  Sk = {
    modp1: pk,
    modp2: yk,
    modp5: gk,
    modp14: bk,
    modp15: vk,
    modp16: mk,
    modp17: wk,
    modp18: _k,
  };
var Nd, fv;
function Mk() {
  if (fv) return Nd;
  fv = 1;
  var i = X6(),
    e = Q6(),
    t = new e(),
    r = new i(24),
    s = new i(11),
    n = new i(10),
    c = new i(3),
    f = new i(7),
    h = e8(),
    y = Ua();
  Nd = E;
  function p(R, L) {
    return (L = L || 'utf8'), Ze.isBuffer(R) || (R = new Ze(R, L)), (this._pub = new i(R)), this;
  }
  function m(R, L) {
    return (L = L || 'utf8'), Ze.isBuffer(R) || (R = new Ze(R, L)), (this._priv = new i(R)), this;
  }
  var _ = {};
  function A(R, L) {
    var D = L.toString('hex'),
      q = [D, R.toString(16)].join('_');
    if (q in _) return _[q];
    var H = 0;
    if (R.isEven() || !h.simpleSieve || !h.fermatTest(R) || !t.test(R))
      return (H += 1), D === '02' || D === '05' ? (H += 8) : (H += 4), (_[q] = H), H;
    t.test(R.shrn(1)) || (H += 2);
    var V;
    switch (D) {
      case '02':
        R.mod(r).cmp(s) && (H += 8);
        break;
      case '05':
        (V = R.mod(n)), V.cmp(c) && V.cmp(f) && (H += 8);
        break;
      default:
        H += 4;
    }
    return (_[q] = H), H;
  }
  function E(R, L, D) {
    this.setGenerator(L),
      (this.__prime = new i(R)),
      (this._prime = i.mont(this.__prime)),
      (this._primeLen = R.length),
      (this._pub = void 0),
      (this._priv = void 0),
      (this._primeCode = void 0),
      D ? ((this.setPublicKey = p), (this.setPrivateKey = m)) : (this._primeCode = 8);
  }
  Object.defineProperty(E.prototype, 'verifyError', {
    enumerable: !0,
    get: function () {
      return (
        typeof this._primeCode != 'number' && (this._primeCode = A(this.__prime, this.__gen)),
        this._primeCode
      );
    },
  }),
    (E.prototype.generateKeys = function () {
      return (
        this._priv || (this._priv = new i(y(this._primeLen))),
        (this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed()),
        this.getPublicKey()
      );
    }),
    (E.prototype.computeSecret = function (R) {
      (R = new i(R)), (R = R.toRed(this._prime));
      var L = R.redPow(this._priv).fromRed(),
        D = new Ze(L.toArray()),
        q = this.getPrime();
      if (D.length < q.length) {
        var H = new Ze(q.length - D.length);
        H.fill(0), (D = Ze.concat([H, D]));
      }
      return D;
    }),
    (E.prototype.getPublicKey = function (L) {
      return I(this._pub, L);
    }),
    (E.prototype.getPrivateKey = function (L) {
      return I(this._priv, L);
    }),
    (E.prototype.getPrime = function (R) {
      return I(this.__prime, R);
    }),
    (E.prototype.getGenerator = function (R) {
      return I(this._gen, R);
    }),
    (E.prototype.setGenerator = function (R, L) {
      return (
        (L = L || 'utf8'),
        Ze.isBuffer(R) || (R = new Ze(R, L)),
        (this.__gen = R),
        (this._gen = new i(R)),
        this
      );
    });
  function I(R, L) {
    var D = new Ze(R.toArray());
    return L ? D.toString(L) : D;
  }
  return Nd;
}
var lv;
function Ak() {
  if (lv) return Go;
  lv = 1;
  var i = e8(),
    e = Sk,
    t = Mk();
  function r(c) {
    var f = new Ze(e[c].prime, 'hex'),
      h = new Ze(e[c].gen, 'hex');
    return new t(f, h);
  }
  var s = { binary: !0, hex: !0, base64: !0 };
  function n(c, f, h, y) {
    return Ze.isBuffer(f) || s[f] === void 0
      ? n(c, 'binary', f, h)
      : ((f = f || 'binary'),
        (y = y || 'binary'),
        (h = h || new Ze([2])),
        Ze.isBuffer(h) || (h = new Ze(h, y)),
        typeof c == 'number'
          ? new t(i(c, h), h, !0)
          : (Ze.isBuffer(c) || (c = new Ze(c, f)), new t(c, h, !0)));
  }
  return (
    (Go.DiffieHellmanGroup = Go.createDiffieHellmanGroup = Go.getDiffieHellman = r),
    (Go.createDiffieHellman = Go.DiffieHellman = n),
    Go
  );
}
var Yc = { exports: {} },
  $d,
  hv;
function t8() {
  return hv || ((hv = 1), ($d = za.EventEmitter)), $d;
}
var Dd, dv;
function Ek() {
  if (dv) return Dd;
  dv = 1;
  function i(E, I) {
    var R = Object.keys(E);
    if (Object.getOwnPropertySymbols) {
      var L = Object.getOwnPropertySymbols(E);
      I &&
        (L = L.filter(function (D) {
          return Object.getOwnPropertyDescriptor(E, D).enumerable;
        })),
        R.push.apply(R, L);
    }
    return R;
  }
  function e(E) {
    for (var I = 1; I < arguments.length; I++) {
      var R = arguments[I] != null ? arguments[I] : {};
      I % 2
        ? i(Object(R), !0).forEach(function (L) {
            t(E, L, R[L]);
          })
        : Object.getOwnPropertyDescriptors
          ? Object.defineProperties(E, Object.getOwnPropertyDescriptors(R))
          : i(Object(R)).forEach(function (L) {
              Object.defineProperty(E, L, Object.getOwnPropertyDescriptor(R, L));
            });
    }
    return E;
  }
  function t(E, I, R) {
    return (
      (I = c(I)),
      I in E
        ? Object.defineProperty(E, I, { value: R, enumerable: !0, configurable: !0, writable: !0 })
        : (E[I] = R),
      E
    );
  }
  function r(E, I) {
    if (!(E instanceof I)) throw new TypeError('Cannot call a class as a function');
  }
  function s(E, I) {
    for (var R = 0; R < I.length; R++) {
      var L = I[R];
      (L.enumerable = L.enumerable || !1),
        (L.configurable = !0),
        'value' in L && (L.writable = !0),
        Object.defineProperty(E, c(L.key), L);
    }
  }
  function n(E, I, R) {
    return (
      I && s(E.prototype, I),
      R && s(E, R),
      Object.defineProperty(E, 'prototype', { writable: !1 }),
      E
    );
  }
  function c(E) {
    var I = f(E, 'string');
    return typeof I == 'symbol' ? I : String(I);
  }
  function f(E, I) {
    if (typeof E != 'object' || E === null) return E;
    var R = E[Symbol.toPrimitive];
    if (R !== void 0) {
      var L = R.call(E, I || 'default');
      if (typeof L != 'object') return L;
      throw new TypeError('@@toPrimitive must return a primitive value.');
    }
    return (I === 'string' ? String : Number)(E);
  }
  var h = ai,
    y = h.Buffer,
    p = Cn,
    m = p.inspect,
    _ = (m && m.custom) || 'inspect';
  function A(E, I, R) {
    y.prototype.copy.call(E, I, R);
  }
  return (
    (Dd = (function () {
      function E() {
        r(this, E), (this.head = null), (this.tail = null), (this.length = 0);
      }
      return (
        n(E, [
          {
            key: 'push',
            value: function (R) {
              var L = { data: R, next: null };
              this.length > 0 ? (this.tail.next = L) : (this.head = L),
                (this.tail = L),
                ++this.length;
            },
          },
          {
            key: 'unshift',
            value: function (R) {
              var L = { data: R, next: this.head };
              this.length === 0 && (this.tail = L), (this.head = L), ++this.length;
            },
          },
          {
            key: 'shift',
            value: function () {
              if (this.length !== 0) {
                var R = this.head.data;
                return (
                  this.length === 1 ? (this.head = this.tail = null) : (this.head = this.head.next),
                  --this.length,
                  R
                );
              }
            },
          },
          {
            key: 'clear',
            value: function () {
              (this.head = this.tail = null), (this.length = 0);
            },
          },
          {
            key: 'join',
            value: function (R) {
              if (this.length === 0) return '';
              for (var L = this.head, D = '' + L.data; (L = L.next); ) D += R + L.data;
              return D;
            },
          },
          {
            key: 'concat',
            value: function (R) {
              if (this.length === 0) return y.alloc(0);
              for (var L = y.allocUnsafe(R >>> 0), D = this.head, q = 0; D; )
                A(D.data, L, q), (q += D.data.length), (D = D.next);
              return L;
            },
          },
          {
            key: 'consume',
            value: function (R, L) {
              var D;
              return (
                R < this.head.data.length
                  ? ((D = this.head.data.slice(0, R)), (this.head.data = this.head.data.slice(R)))
                  : R === this.head.data.length
                    ? (D = this.shift())
                    : (D = L ? this._getString(R) : this._getBuffer(R)),
                D
              );
            },
          },
          {
            key: 'first',
            value: function () {
              return this.head.data;
            },
          },
          {
            key: '_getString',
            value: function (R) {
              var L = this.head,
                D = 1,
                q = L.data;
              for (R -= q.length; (L = L.next); ) {
                var H = L.data,
                  V = R > H.length ? H.length : R;
                if ((V === H.length ? (q += H) : (q += H.slice(0, R)), (R -= V), R === 0)) {
                  V === H.length
                    ? (++D, L.next ? (this.head = L.next) : (this.head = this.tail = null))
                    : ((this.head = L), (L.data = H.slice(V)));
                  break;
                }
                ++D;
              }
              return (this.length -= D), q;
            },
          },
          {
            key: '_getBuffer',
            value: function (R) {
              var L = y.allocUnsafe(R),
                D = this.head,
                q = 1;
              for (D.data.copy(L), R -= D.data.length; (D = D.next); ) {
                var H = D.data,
                  V = R > H.length ? H.length : R;
                if ((H.copy(L, L.length - R, 0, V), (R -= V), R === 0)) {
                  V === H.length
                    ? (++q, D.next ? (this.head = D.next) : (this.head = this.tail = null))
                    : ((this.head = D), (D.data = H.slice(V)));
                  break;
                }
                ++q;
              }
              return (this.length -= q), L;
            },
          },
          {
            key: _,
            value: function (R, L) {
              return m(this, e(e({}, L), {}, { depth: 0, customInspect: !1 }));
            },
          },
        ]),
        E
      );
    })()),
    Dd
  );
}
var Ud, pv;
function r8() {
  if (pv) return Ud;
  pv = 1;
  function i(c, f) {
    var h = this,
      y = this._readableState && this._readableState.destroyed,
      p = this._writableState && this._writableState.destroyed;
    return y || p
      ? (f
          ? f(c)
          : c &&
            (this._writableState
              ? this._writableState.errorEmitted ||
                ((this._writableState.errorEmitted = !0), Je.nextTick(s, this, c))
              : Je.nextTick(s, this, c)),
        this)
      : (this._readableState && (this._readableState.destroyed = !0),
        this._writableState && (this._writableState.destroyed = !0),
        this._destroy(c || null, function (m) {
          !f && m
            ? h._writableState
              ? h._writableState.errorEmitted
                ? Je.nextTick(t, h)
                : ((h._writableState.errorEmitted = !0), Je.nextTick(e, h, m))
              : Je.nextTick(e, h, m)
            : f
              ? (Je.nextTick(t, h), f(m))
              : Je.nextTick(t, h);
        }),
        this);
  }
  function e(c, f) {
    s(c, f), t(c);
  }
  function t(c) {
    (c._writableState && !c._writableState.emitClose) ||
      (c._readableState && !c._readableState.emitClose) ||
      c.emit('close');
  }
  function r() {
    this._readableState &&
      ((this._readableState.destroyed = !1),
      (this._readableState.reading = !1),
      (this._readableState.ended = !1),
      (this._readableState.endEmitted = !1)),
      this._writableState &&
        ((this._writableState.destroyed = !1),
        (this._writableState.ended = !1),
        (this._writableState.ending = !1),
        (this._writableState.finalCalled = !1),
        (this._writableState.prefinished = !1),
        (this._writableState.finished = !1),
        (this._writableState.errorEmitted = !1));
  }
  function s(c, f) {
    c.emit('error', f);
  }
  function n(c, f) {
    var h = c._readableState,
      y = c._writableState;
    (h && h.autoDestroy) || (y && y.autoDestroy) ? c.destroy(f) : c.emit('error', f);
  }
  return (Ud = { destroy: i, undestroy: r, errorOrDestroy: n }), Ud;
}
var zd = {},
  yv;
function qa() {
  if (yv) return zd;
  yv = 1;
  function i(f, h) {
    (f.prototype = Object.create(h.prototype)), (f.prototype.constructor = f), (f.__proto__ = h);
  }
  var e = {};
  function t(f, h, y) {
    y || (y = Error);
    function p(_, A, E) {
      return typeof h == 'string' ? h : h(_, A, E);
    }
    var m = (function (_) {
      i(A, _);
      function A(E, I, R) {
        return _.call(this, p(E, I, R)) || this;
      }
      return A;
    })(y);
    (m.prototype.name = y.name), (m.prototype.code = f), (e[f] = m);
  }
  function r(f, h) {
    if (Array.isArray(f)) {
      var y = f.length;
      return (
        (f = f.map(function (p) {
          return String(p);
        })),
        y > 2
          ? 'one of '.concat(h, ' ').concat(f.slice(0, y - 1).join(', '), ', or ') + f[y - 1]
          : y === 2
            ? 'one of '.concat(h, ' ').concat(f[0], ' or ').concat(f[1])
            : 'of '.concat(h, ' ').concat(f[0])
      );
    } else return 'of '.concat(h, ' ').concat(String(f));
  }
  function s(f, h, y) {
    return f.substr(!y || y < 0 ? 0 : +y, h.length) === h;
  }
  function n(f, h, y) {
    return (y === void 0 || y > f.length) && (y = f.length), f.substring(y - h.length, y) === h;
  }
  function c(f, h, y) {
    return typeof y != 'number' && (y = 0), y + h.length > f.length ? !1 : f.indexOf(h, y) !== -1;
  }
  return (
    t(
      'ERR_INVALID_OPT_VALUE',
      function (f, h) {
        return 'The value "' + h + '" is invalid for option "' + f + '"';
      },
      TypeError
    ),
    t(
      'ERR_INVALID_ARG_TYPE',
      function (f, h, y) {
        var p;
        typeof h == 'string' && s(h, 'not ')
          ? ((p = 'must not be'), (h = h.replace(/^not /, '')))
          : (p = 'must be');
        var m;
        if (n(f, ' argument')) m = 'The '.concat(f, ' ').concat(p, ' ').concat(r(h, 'type'));
        else {
          var _ = c(f, '.') ? 'property' : 'argument';
          m = 'The "'.concat(f, '" ').concat(_, ' ').concat(p, ' ').concat(r(h, 'type'));
        }
        return (m += '. Received type '.concat(typeof y)), m;
      },
      TypeError
    ),
    t('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF'),
    t('ERR_METHOD_NOT_IMPLEMENTED', function (f) {
      return 'The ' + f + ' method is not implemented';
    }),
    t('ERR_STREAM_PREMATURE_CLOSE', 'Premature close'),
    t('ERR_STREAM_DESTROYED', function (f) {
      return 'Cannot call ' + f + ' after a stream was destroyed';
    }),
    t('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times'),
    t('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable'),
    t('ERR_STREAM_WRITE_AFTER_END', 'write after end'),
    t('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError),
    t(
      'ERR_UNKNOWN_ENCODING',
      function (f) {
        return 'Unknown encoding: ' + f;
      },
      TypeError
    ),
    t('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event'),
    (zd.codes = e),
    zd
  );
}
var Fd, gv;
function i8() {
  if (gv) return Fd;
  gv = 1;
  var i = qa().codes.ERR_INVALID_OPT_VALUE;
  function e(r, s, n) {
    return r.highWaterMark != null ? r.highWaterMark : s ? r[n] : null;
  }
  function t(r, s, n, c) {
    var f = e(s, c, n);
    if (f != null) {
      if (!(isFinite(f) && Math.floor(f) === f) || f < 0) {
        var h = c ? n : 'highWaterMark';
        throw new i(h, f);
      }
      return Math.floor(f);
    }
    return r.objectMode ? 16 : 16 * 1024;
  }
  return (Fd = { getHighWaterMark: t }), Fd;
}
var qd, bv;
function n8() {
  if (bv) return qd;
  (bv = 1), (qd = ne);
  function i(C) {
    var z = this;
    (this.next = null),
      (this.entry = null),
      (this.finish = function () {
        P(z, C);
      });
  }
  var e;
  ne.WritableState = te;
  var t = { deprecate: g6 },
    r = t8(),
    s = ai.Buffer,
    n =
      (typeof globalThis < 'u'
        ? globalThis
        : typeof window < 'u'
          ? window
          : typeof globalThis < 'u'
            ? globalThis
            : {}
      ).Uint8Array || function () {};
  function c(C) {
    return s.from(C);
  }
  function f(C) {
    return s.isBuffer(C) || C instanceof n;
  }
  var h = r8(),
    y = i8(),
    p = y.getHighWaterMark,
    m = qa().codes,
    _ = m.ERR_INVALID_ARG_TYPE,
    A = m.ERR_METHOD_NOT_IMPLEMENTED,
    E = m.ERR_MULTIPLE_CALLBACK,
    I = m.ERR_STREAM_CANNOT_PIPE,
    R = m.ERR_STREAM_DESTROYED,
    L = m.ERR_STREAM_NULL_VALUES,
    D = m.ERR_STREAM_WRITE_AFTER_END,
    q = m.ERR_UNKNOWN_ENCODING,
    H = h.errorOrDestroy;
  dt(ne, r);
  function V() {}
  function te(C, z, Y) {
    (e = e || Sa()),
      (C = C || {}),
      typeof Y != 'boolean' && (Y = z instanceof e),
      (this.objectMode = !!C.objectMode),
      Y && (this.objectMode = this.objectMode || !!C.writableObjectMode),
      (this.highWaterMark = p(this, C, 'writableHighWaterMark', Y)),
      (this.finalCalled = !1),
      (this.needDrain = !1),
      (this.ending = !1),
      (this.ended = !1),
      (this.finished = !1),
      (this.destroyed = !1);
    var G = C.decodeStrings === !1;
    (this.decodeStrings = !G),
      (this.defaultEncoding = C.defaultEncoding || 'utf8'),
      (this.length = 0),
      (this.writing = !1),
      (this.corked = 0),
      (this.sync = !0),
      (this.bufferProcessing = !1),
      (this.onwrite = function (Q) {
        g(z, Q);
      }),
      (this.writecb = null),
      (this.writelen = 0),
      (this.bufferedRequest = null),
      (this.lastBufferedRequest = null),
      (this.pendingcb = 0),
      (this.prefinished = !1),
      (this.errorEmitted = !1),
      (this.emitClose = C.emitClose !== !1),
      (this.autoDestroy = !!C.autoDestroy),
      (this.bufferedRequestCount = 0),
      (this.corkedRequestsFree = new i(this));
  }
  (te.prototype.getBuffer = function () {
    for (var z = this.bufferedRequest, Y = []; z; ) Y.push(z), (z = z.next);
    return Y;
  }),
    (function () {
      try {
        Object.defineProperty(te.prototype, 'buffer', {
          get: t.deprecate(
            function () {
              return this.getBuffer();
            },
            '_writableState.buffer is deprecated. Use _writableState.getBuffer instead.',
            'DEP0003'
          ),
        });
      } catch {}
    })();
  var ue;
  typeof Symbol == 'function' &&
  Symbol.hasInstance &&
  typeof Function.prototype[Symbol.hasInstance] == 'function'
    ? ((ue = Function.prototype[Symbol.hasInstance]),
      Object.defineProperty(ne, Symbol.hasInstance, {
        value: function (z) {
          return ue.call(this, z) ? !0 : this !== ne ? !1 : z && z._writableState instanceof te;
        },
      }))
    : (ue = function (z) {
        return z instanceof this;
      });
  function ne(C) {
    e = e || Sa();
    var z = this instanceof e;
    if (!z && !ue.call(ne, this)) return new ne(C);
    (this._writableState = new te(C, this, z)),
      (this.writable = !0),
      C &&
        (typeof C.write == 'function' && (this._write = C.write),
        typeof C.writev == 'function' && (this._writev = C.writev),
        typeof C.destroy == 'function' && (this._destroy = C.destroy),
        typeof C.final == 'function' && (this._final = C.final)),
      r.call(this);
  }
  ne.prototype.pipe = function () {
    H(this, new I());
  };
  function X(C, z) {
    var Y = new D();
    H(C, Y), Je.nextTick(z, Y);
  }
  function Oe(C, z, Y, G) {
    var Q;
    return (
      Y === null
        ? (Q = new L())
        : typeof Y != 'string' && !z.objectMode && (Q = new _('chunk', ['string', 'Buffer'], Y)),
      Q ? (H(C, Q), Je.nextTick(G, Q), !1) : !0
    );
  }
  (ne.prototype.write = function (C, z, Y) {
    var G = this._writableState,
      Q = !1,
      U = !G.objectMode && f(C);
    return (
      U && !s.isBuffer(C) && (C = c(C)),
      typeof z == 'function' && ((Y = z), (z = null)),
      U ? (z = 'buffer') : z || (z = G.defaultEncoding),
      typeof Y != 'function' && (Y = V),
      G.ending
        ? X(this, Y)
        : (U || Oe(this, G, C, Y)) && (G.pendingcb++, (Q = o(this, G, U, C, z, Y))),
      Q
    );
  }),
    (ne.prototype.cork = function () {
      this._writableState.corked++;
    }),
    (ne.prototype.uncork = function () {
      var C = this._writableState;
      C.corked &&
        (C.corked--,
        !C.writing && !C.corked && !C.bufferProcessing && C.bufferedRequest && v(this, C));
    }),
    (ne.prototype.setDefaultEncoding = function (z) {
      if (
        (typeof z == 'string' && (z = z.toLowerCase()),
        !(
          [
            'hex',
            'utf8',
            'utf-8',
            'ascii',
            'binary',
            'base64',
            'ucs2',
            'ucs-2',
            'utf16le',
            'utf-16le',
            'raw',
          ].indexOf((z + '').toLowerCase()) > -1
        ))
      )
        throw new q(z);
      return (this._writableState.defaultEncoding = z), this;
    }),
    Object.defineProperty(ne.prototype, 'writableBuffer', {
      enumerable: !1,
      get: function () {
        return this._writableState && this._writableState.getBuffer();
      },
    });
  function S(C, z, Y) {
    return !C.objectMode && C.decodeStrings !== !1 && typeof z == 'string' && (z = s.from(z, Y)), z;
  }
  Object.defineProperty(ne.prototype, 'writableHighWaterMark', {
    enumerable: !1,
    get: function () {
      return this._writableState.highWaterMark;
    },
  });
  function o(C, z, Y, G, Q, U) {
    if (!Y) {
      var $ = S(z, G, Q);
      G !== $ && ((Y = !0), (Q = 'buffer'), (G = $));
    }
    var Z = z.objectMode ? 1 : G.length;
    z.length += Z;
    var ae = z.length < z.highWaterMark;
    if ((ae || (z.needDrain = !0), z.writing || z.corked)) {
      var fe = z.lastBufferedRequest;
      (z.lastBufferedRequest = { chunk: G, encoding: Q, isBuf: Y, callback: U, next: null }),
        fe ? (fe.next = z.lastBufferedRequest) : (z.bufferedRequest = z.lastBufferedRequest),
        (z.bufferedRequestCount += 1);
    } else u(C, z, !1, Z, G, Q, U);
    return ae;
  }
  function u(C, z, Y, G, Q, U, $) {
    (z.writelen = G),
      (z.writecb = $),
      (z.writing = !0),
      (z.sync = !0),
      z.destroyed
        ? z.onwrite(new R('write'))
        : Y
          ? C._writev(Q, z.onwrite)
          : C._write(Q, U, z.onwrite),
      (z.sync = !1);
  }
  function l(C, z, Y, G, Q) {
    --z.pendingcb,
      Y
        ? (Je.nextTick(Q, G), Je.nextTick(B, C, z), (C._writableState.errorEmitted = !0), H(C, G))
        : (Q(G), (C._writableState.errorEmitted = !0), H(C, G), B(C, z));
  }
  function d(C) {
    (C.writing = !1), (C.writecb = null), (C.length -= C.writelen), (C.writelen = 0);
  }
  function g(C, z) {
    var Y = C._writableState,
      G = Y.sync,
      Q = Y.writecb;
    if (typeof Q != 'function') throw new E();
    if ((d(Y), z)) l(C, Y, G, z, Q);
    else {
      var U = a(Y) || C.destroyed;
      !U && !Y.corked && !Y.bufferProcessing && Y.bufferedRequest && v(C, Y),
        G ? Je.nextTick(w, C, Y, U, Q) : w(C, Y, U, Q);
    }
  }
  function w(C, z, Y, G) {
    Y || M(C, z), z.pendingcb--, G(), B(C, z);
  }
  function M(C, z) {
    z.length === 0 && z.needDrain && ((z.needDrain = !1), C.emit('drain'));
  }
  function v(C, z) {
    z.bufferProcessing = !0;
    var Y = z.bufferedRequest;
    if (C._writev && Y && Y.next) {
      var G = z.bufferedRequestCount,
        Q = new Array(G),
        U = z.corkedRequestsFree;
      U.entry = Y;
      for (var $ = 0, Z = !0; Y; ) (Q[$] = Y), Y.isBuf || (Z = !1), (Y = Y.next), ($ += 1);
      (Q.allBuffers = Z),
        u(C, z, !0, z.length, Q, '', U.finish),
        z.pendingcb++,
        (z.lastBufferedRequest = null),
        U.next
          ? ((z.corkedRequestsFree = U.next), (U.next = null))
          : (z.corkedRequestsFree = new i(z)),
        (z.bufferedRequestCount = 0);
    } else {
      for (; Y; ) {
        var ae = Y.chunk,
          fe = Y.encoding,
          le = Y.callback,
          Fe = z.objectMode ? 1 : ae.length;
        if ((u(C, z, !1, Fe, ae, fe, le), (Y = Y.next), z.bufferedRequestCount--, z.writing)) break;
      }
      Y === null && (z.lastBufferedRequest = null);
    }
    (z.bufferedRequest = Y), (z.bufferProcessing = !1);
  }
  (ne.prototype._write = function (C, z, Y) {
    Y(new A('_write()'));
  }),
    (ne.prototype._writev = null),
    (ne.prototype.end = function (C, z, Y) {
      var G = this._writableState;
      return (
        typeof C == 'function'
          ? ((Y = C), (C = null), (z = null))
          : typeof z == 'function' && ((Y = z), (z = null)),
        C != null && this.write(C, z),
        G.corked && ((G.corked = 1), this.uncork()),
        G.ending || F(this, G, Y),
        this
      );
    }),
    Object.defineProperty(ne.prototype, 'writableLength', {
      enumerable: !1,
      get: function () {
        return this._writableState.length;
      },
    });
  function a(C) {
    return C.ending && C.length === 0 && C.bufferedRequest === null && !C.finished && !C.writing;
  }
  function b(C, z) {
    C._final(function (Y) {
      z.pendingcb--, Y && H(C, Y), (z.prefinished = !0), C.emit('prefinish'), B(C, z);
    });
  }
  function k(C, z) {
    !z.prefinished &&
      !z.finalCalled &&
      (typeof C._final == 'function' && !z.destroyed
        ? (z.pendingcb++, (z.finalCalled = !0), Je.nextTick(b, C, z))
        : ((z.prefinished = !0), C.emit('prefinish')));
  }
  function B(C, z) {
    var Y = a(z);
    if (Y && (k(C, z), z.pendingcb === 0 && ((z.finished = !0), C.emit('finish'), z.autoDestroy))) {
      var G = C._readableState;
      (!G || (G.autoDestroy && G.endEmitted)) && C.destroy();
    }
    return Y;
  }
  function F(C, z, Y) {
    (z.ending = !0),
      B(C, z),
      Y && (z.finished ? Je.nextTick(Y) : C.once('finish', Y)),
      (z.ended = !0),
      (C.writable = !1);
  }
  function P(C, z, Y) {
    var G = C.entry;
    for (C.entry = null; G; ) {
      var Q = G.callback;
      z.pendingcb--, Q(Y), (G = G.next);
    }
    z.corkedRequestsFree.next = C;
  }
  return (
    Object.defineProperty(ne.prototype, 'destroyed', {
      enumerable: !1,
      get: function () {
        return this._writableState === void 0 ? !1 : this._writableState.destroyed;
      },
      set: function (z) {
        this._writableState && (this._writableState.destroyed = z);
      },
    }),
    (ne.prototype.destroy = h.destroy),
    (ne.prototype._undestroy = h.undestroy),
    (ne.prototype._destroy = function (C, z) {
      z(C);
    }),
    qd
  );
}
var Wd, vv;
function Sa() {
  if (vv) return Wd;
  vv = 1;
  var i =
    Object.keys ||
    function (y) {
      var p = [];
      for (var m in y) p.push(m);
      return p;
    };
  Wd = c;
  var e = o8(),
    t = n8();
  dt(c, e);
  for (var r = i(t.prototype), s = 0; s < r.length; s++) {
    var n = r[s];
    c.prototype[n] || (c.prototype[n] = t.prototype[n]);
  }
  function c(y) {
    if (!(this instanceof c)) return new c(y);
    e.call(this, y),
      t.call(this, y),
      (this.allowHalfOpen = !0),
      y &&
        (y.readable === !1 && (this.readable = !1),
        y.writable === !1 && (this.writable = !1),
        y.allowHalfOpen === !1 && ((this.allowHalfOpen = !1), this.once('end', f)));
  }
  Object.defineProperty(c.prototype, 'writableHighWaterMark', {
    enumerable: !1,
    get: function () {
      return this._writableState.highWaterMark;
    },
  }),
    Object.defineProperty(c.prototype, 'writableBuffer', {
      enumerable: !1,
      get: function () {
        return this._writableState && this._writableState.getBuffer();
      },
    }),
    Object.defineProperty(c.prototype, 'writableLength', {
      enumerable: !1,
      get: function () {
        return this._writableState.length;
      },
    });
  function f() {
    this._writableState.ended || Je.nextTick(h, this);
  }
  function h(y) {
    y.end();
  }
  return (
    Object.defineProperty(c.prototype, 'destroyed', {
      enumerable: !1,
      get: function () {
        return this._readableState === void 0 || this._writableState === void 0
          ? !1
          : this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function (p) {
        this._readableState === void 0 ||
          this._writableState === void 0 ||
          ((this._readableState.destroyed = p), (this._writableState.destroyed = p));
      },
    }),
    Wd
  );
}
var Kd, mv;
function cy() {
  if (mv) return Kd;
  mv = 1;
  var i = qa().codes.ERR_STREAM_PREMATURE_CLOSE;
  function e(n) {
    var c = !1;
    return function () {
      if (!c) {
        c = !0;
        for (var f = arguments.length, h = new Array(f), y = 0; y < f; y++) h[y] = arguments[y];
        n.apply(this, h);
      }
    };
  }
  function t() {}
  function r(n) {
    return n.setHeader && typeof n.abort == 'function';
  }
  function s(n, c, f) {
    if (typeof c == 'function') return s(n, null, c);
    c || (c = {}), (f = e(f || t));
    var h = c.readable || (c.readable !== !1 && n.readable),
      y = c.writable || (c.writable !== !1 && n.writable),
      p = function () {
        n.writable || _();
      },
      m = n._writableState && n._writableState.finished,
      _ = function () {
        (y = !1), (m = !0), h || f.call(n);
      },
      A = n._readableState && n._readableState.endEmitted,
      E = function () {
        (h = !1), (A = !0), y || f.call(n);
      },
      I = function (q) {
        f.call(n, q);
      },
      R = function () {
        var q;
        if (h && !A)
          return (!n._readableState || !n._readableState.ended) && (q = new i()), f.call(n, q);
        if (y && !m)
          return (!n._writableState || !n._writableState.ended) && (q = new i()), f.call(n, q);
      },
      L = function () {
        n.req.on('finish', _);
      };
    return (
      r(n)
        ? (n.on('complete', _), n.on('abort', R), n.req ? L() : n.on('request', L))
        : y && !n._writableState && (n.on('end', p), n.on('close', p)),
      n.on('end', E),
      n.on('finish', _),
      c.error !== !1 && n.on('error', I),
      n.on('close', R),
      function () {
        n.removeListener('complete', _),
          n.removeListener('abort', R),
          n.removeListener('request', L),
          n.req && n.req.removeListener('finish', _),
          n.removeListener('end', p),
          n.removeListener('close', p),
          n.removeListener('finish', _),
          n.removeListener('end', E),
          n.removeListener('error', I),
          n.removeListener('close', R);
      }
    );
  }
  return (Kd = s), Kd;
}
var jd, wv;
function kk() {
  if (wv) return jd;
  wv = 1;
  var i;
  function e(q, H, V) {
    return (
      (H = t(H)),
      H in q
        ? Object.defineProperty(q, H, { value: V, enumerable: !0, configurable: !0, writable: !0 })
        : (q[H] = V),
      q
    );
  }
  function t(q) {
    var H = r(q, 'string');
    return typeof H == 'symbol' ? H : String(H);
  }
  function r(q, H) {
    if (typeof q != 'object' || q === null) return q;
    var V = q[Symbol.toPrimitive];
    if (V !== void 0) {
      var te = V.call(q, H || 'default');
      if (typeof te != 'object') return te;
      throw new TypeError('@@toPrimitive must return a primitive value.');
    }
    return (H === 'string' ? String : Number)(q);
  }
  var s = cy(),
    n = Symbol('lastResolve'),
    c = Symbol('lastReject'),
    f = Symbol('error'),
    h = Symbol('ended'),
    y = Symbol('lastPromise'),
    p = Symbol('handlePromise'),
    m = Symbol('stream');
  function _(q, H) {
    return { value: q, done: H };
  }
  function A(q) {
    var H = q[n];
    if (H !== null) {
      var V = q[m].read();
      V !== null && ((q[y] = null), (q[n] = null), (q[c] = null), H(_(V, !1)));
    }
  }
  function E(q) {
    Je.nextTick(A, q);
  }
  function I(q, H) {
    return function (V, te) {
      q.then(function () {
        if (H[h]) {
          V(_(void 0, !0));
          return;
        }
        H[p](V, te);
      }, te);
    };
  }
  var R = Object.getPrototypeOf(function () {}),
    L = Object.setPrototypeOf(
      ((i = {
        get stream() {
          return this[m];
        },
        next: function () {
          var H = this,
            V = this[f];
          if (V !== null) return Promise.reject(V);
          if (this[h]) return Promise.resolve(_(void 0, !0));
          if (this[m].destroyed)
            return new Promise(function (X, Oe) {
              Je.nextTick(function () {
                H[f] ? Oe(H[f]) : X(_(void 0, !0));
              });
            });
          var te = this[y],
            ue;
          if (te) ue = new Promise(I(te, this));
          else {
            var ne = this[m].read();
            if (ne !== null) return Promise.resolve(_(ne, !1));
            ue = new Promise(this[p]);
          }
          return (this[y] = ue), ue;
        },
      }),
      e(i, Symbol.asyncIterator, function () {
        return this;
      }),
      e(i, 'return', function () {
        var H = this;
        return new Promise(function (V, te) {
          H[m].destroy(null, function (ue) {
            if (ue) {
              te(ue);
              return;
            }
            V(_(void 0, !0));
          });
        });
      }),
      i),
      R
    ),
    D = function (H) {
      var V,
        te = Object.create(
          L,
          ((V = {}),
          e(V, m, { value: H, writable: !0 }),
          e(V, n, { value: null, writable: !0 }),
          e(V, c, { value: null, writable: !0 }),
          e(V, f, { value: null, writable: !0 }),
          e(V, h, { value: H._readableState.endEmitted, writable: !0 }),
          e(V, p, {
            value: function (ne, X) {
              var Oe = te[m].read();
              Oe
                ? ((te[y] = null), (te[n] = null), (te[c] = null), ne(_(Oe, !1)))
                : ((te[n] = ne), (te[c] = X));
            },
            writable: !0,
          }),
          V)
        );
      return (
        (te[y] = null),
        s(H, function (ue) {
          if (ue && ue.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
            var ne = te[c];
            ne !== null && ((te[y] = null), (te[n] = null), (te[c] = null), ne(ue)), (te[f] = ue);
            return;
          }
          var X = te[n];
          X !== null && ((te[y] = null), (te[n] = null), (te[c] = null), X(_(void 0, !0))),
            (te[h] = !0);
        }),
        H.on('readable', E.bind(null, te)),
        te
      );
    };
  return (jd = D), jd;
}
var Hd, _v;
function Ik() {
  return (
    _v ||
      ((_v = 1),
      (Hd = function () {
        throw new Error('Readable.from is not available in the browser');
      })),
    Hd
  );
}
var Vd, Sv;
function o8() {
  if (Sv) return Vd;
  (Sv = 1), (Vd = X);
  var i;
  (X.ReadableState = ne), za.EventEmitter;
  var e = function ($, Z) {
      return $.listeners(Z).length;
    },
    t = t8(),
    r = ai.Buffer,
    s =
      (typeof globalThis < 'u'
        ? globalThis
        : typeof window < 'u'
          ? window
          : typeof globalThis < 'u'
            ? globalThis
            : {}
      ).Uint8Array || function () {};
  function n(U) {
    return r.from(U);
  }
  function c(U) {
    return r.isBuffer(U) || U instanceof s;
  }
  var f = Cn,
    h;
  f && f.debuglog ? (h = f.debuglog('stream')) : (h = function () {});
  var y = Ek(),
    p = r8(),
    m = i8(),
    _ = m.getHighWaterMark,
    A = qa().codes,
    E = A.ERR_INVALID_ARG_TYPE,
    I = A.ERR_STREAM_PUSH_AFTER_EOF,
    R = A.ERR_METHOD_NOT_IMPLEMENTED,
    L = A.ERR_STREAM_UNSHIFT_AFTER_END_EVENT,
    D,
    q,
    H;
  dt(X, t);
  var V = p.errorOrDestroy,
    te = ['error', 'close', 'destroy', 'pause', 'resume'];
  function ue(U, $, Z) {
    if (typeof U.prependListener == 'function') return U.prependListener($, Z);
    !U._events || !U._events[$]
      ? U.on($, Z)
      : Array.isArray(U._events[$])
        ? U._events[$].unshift(Z)
        : (U._events[$] = [Z, U._events[$]]);
  }
  function ne(U, $, Z) {
    (i = i || Sa()),
      (U = U || {}),
      typeof Z != 'boolean' && (Z = $ instanceof i),
      (this.objectMode = !!U.objectMode),
      Z && (this.objectMode = this.objectMode || !!U.readableObjectMode),
      (this.highWaterMark = _(this, U, 'readableHighWaterMark', Z)),
      (this.buffer = new y()),
      (this.length = 0),
      (this.pipes = null),
      (this.pipesCount = 0),
      (this.flowing = null),
      (this.ended = !1),
      (this.endEmitted = !1),
      (this.reading = !1),
      (this.sync = !0),
      (this.needReadable = !1),
      (this.emittedReadable = !1),
      (this.readableListening = !1),
      (this.resumeScheduled = !1),
      (this.paused = !0),
      (this.emitClose = U.emitClose !== !1),
      (this.autoDestroy = !!U.autoDestroy),
      (this.destroyed = !1),
      (this.defaultEncoding = U.defaultEncoding || 'utf8'),
      (this.awaitDrain = 0),
      (this.readingMore = !1),
      (this.decoder = null),
      (this.encoding = null),
      U.encoding &&
        (D || (D = _a.StringDecoder),
        (this.decoder = new D(U.encoding)),
        (this.encoding = U.encoding));
  }
  function X(U) {
    if (((i = i || Sa()), !(this instanceof X))) return new X(U);
    var $ = this instanceof i;
    (this._readableState = new ne(U, this, $)),
      (this.readable = !0),
      U &&
        (typeof U.read == 'function' && (this._read = U.read),
        typeof U.destroy == 'function' && (this._destroy = U.destroy)),
      t.call(this);
  }
  Object.defineProperty(X.prototype, 'destroyed', {
    enumerable: !1,
    get: function () {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function ($) {
      this._readableState && (this._readableState.destroyed = $);
    },
  }),
    (X.prototype.destroy = p.destroy),
    (X.prototype._undestroy = p.undestroy),
    (X.prototype._destroy = function (U, $) {
      $(U);
    }),
    (X.prototype.push = function (U, $) {
      var Z = this._readableState,
        ae;
      return (
        Z.objectMode
          ? (ae = !0)
          : typeof U == 'string' &&
            (($ = $ || Z.defaultEncoding),
            $ !== Z.encoding && ((U = r.from(U, $)), ($ = '')),
            (ae = !0)),
        Oe(this, U, $, !1, ae)
      );
    }),
    (X.prototype.unshift = function (U) {
      return Oe(this, U, null, !0, !1);
    });
  function Oe(U, $, Z, ae, fe) {
    h('readableAddChunk', $);
    var le = U._readableState;
    if ($ === null) (le.reading = !1), g(U, le);
    else {
      var Fe;
      if ((fe || (Fe = o(le, $)), Fe)) V(U, Fe);
      else if (le.objectMode || ($ && $.length > 0))
        if (
          (typeof $ != 'string' &&
            !le.objectMode &&
            Object.getPrototypeOf($) !== r.prototype &&
            ($ = n($)),
          ae)
        )
          le.endEmitted ? V(U, new L()) : S(U, le, $, !0);
        else if (le.ended) V(U, new I());
        else {
          if (le.destroyed) return !1;
          (le.reading = !1),
            le.decoder && !Z
              ? (($ = le.decoder.write($)),
                le.objectMode || $.length !== 0 ? S(U, le, $, !1) : v(U, le))
              : S(U, le, $, !1);
        }
      else ae || ((le.reading = !1), v(U, le));
    }
    return !le.ended && (le.length < le.highWaterMark || le.length === 0);
  }
  function S(U, $, Z, ae) {
    $.flowing && $.length === 0 && !$.sync
      ? (($.awaitDrain = 0), U.emit('data', Z))
      : (($.length += $.objectMode ? 1 : Z.length),
        ae ? $.buffer.unshift(Z) : $.buffer.push(Z),
        $.needReadable && w(U)),
      v(U, $);
  }
  function o(U, $) {
    var Z;
    return (
      !c($) &&
        typeof $ != 'string' &&
        $ !== void 0 &&
        !U.objectMode &&
        (Z = new E('chunk', ['string', 'Buffer', 'Uint8Array'], $)),
      Z
    );
  }
  (X.prototype.isPaused = function () {
    return this._readableState.flowing === !1;
  }),
    (X.prototype.setEncoding = function (U) {
      D || (D = _a.StringDecoder);
      var $ = new D(U);
      (this._readableState.decoder = $),
        (this._readableState.encoding = this._readableState.decoder.encoding);
      for (var Z = this._readableState.buffer.head, ae = ''; Z !== null; )
        (ae += $.write(Z.data)), (Z = Z.next);
      return (
        this._readableState.buffer.clear(),
        ae !== '' && this._readableState.buffer.push(ae),
        (this._readableState.length = ae.length),
        this
      );
    });
  var u = 1073741824;
  function l(U) {
    return (
      U >= u
        ? (U = u)
        : (U--,
          (U |= U >>> 1),
          (U |= U >>> 2),
          (U |= U >>> 4),
          (U |= U >>> 8),
          (U |= U >>> 16),
          U++),
      U
    );
  }
  function d(U, $) {
    return U <= 0 || ($.length === 0 && $.ended)
      ? 0
      : $.objectMode
        ? 1
        : U !== U
          ? $.flowing && $.length
            ? $.buffer.head.data.length
            : $.length
          : (U > $.highWaterMark && ($.highWaterMark = l(U)),
            U <= $.length ? U : $.ended ? $.length : (($.needReadable = !0), 0));
  }
  X.prototype.read = function (U) {
    h('read', U), (U = parseInt(U, 10));
    var $ = this._readableState,
      Z = U;
    if (
      (U !== 0 && ($.emittedReadable = !1),
      U === 0 &&
        $.needReadable &&
        (($.highWaterMark !== 0 ? $.length >= $.highWaterMark : $.length > 0) || $.ended))
    )
      return (
        h('read: emitReadable', $.length, $.ended),
        $.length === 0 && $.ended ? Y(this) : w(this),
        null
      );
    if (((U = d(U, $)), U === 0 && $.ended)) return $.length === 0 && Y(this), null;
    var ae = $.needReadable;
    h('need readable', ae),
      ($.length === 0 || $.length - U < $.highWaterMark) &&
        ((ae = !0), h('length less than watermark', ae)),
      $.ended || $.reading
        ? ((ae = !1), h('reading or ended', ae))
        : ae &&
          (h('do read'),
          ($.reading = !0),
          ($.sync = !0),
          $.length === 0 && ($.needReadable = !0),
          this._read($.highWaterMark),
          ($.sync = !1),
          $.reading || (U = d(Z, $)));
    var fe;
    return (
      U > 0 ? (fe = z(U, $)) : (fe = null),
      fe === null
        ? (($.needReadable = $.length <= $.highWaterMark), (U = 0))
        : (($.length -= U), ($.awaitDrain = 0)),
      $.length === 0 && ($.ended || ($.needReadable = !0), Z !== U && $.ended && Y(this)),
      fe !== null && this.emit('data', fe),
      fe
    );
  };
  function g(U, $) {
    if ((h('onEofChunk'), !$.ended)) {
      if ($.decoder) {
        var Z = $.decoder.end();
        Z && Z.length && ($.buffer.push(Z), ($.length += $.objectMode ? 1 : Z.length));
      }
      ($.ended = !0),
        $.sync
          ? w(U)
          : (($.needReadable = !1), $.emittedReadable || (($.emittedReadable = !0), M(U)));
    }
  }
  function w(U) {
    var $ = U._readableState;
    h('emitReadable', $.needReadable, $.emittedReadable),
      ($.needReadable = !1),
      $.emittedReadable ||
        (h('emitReadable', $.flowing), ($.emittedReadable = !0), Je.nextTick(M, U));
  }
  function M(U) {
    var $ = U._readableState;
    h('emitReadable_', $.destroyed, $.length, $.ended),
      !$.destroyed && ($.length || $.ended) && (U.emit('readable'), ($.emittedReadable = !1)),
      ($.needReadable = !$.flowing && !$.ended && $.length <= $.highWaterMark),
      C(U);
  }
  function v(U, $) {
    $.readingMore || (($.readingMore = !0), Je.nextTick(a, U, $));
  }
  function a(U, $) {
    for (
      ;
      !$.reading && !$.ended && ($.length < $.highWaterMark || ($.flowing && $.length === 0));

    ) {
      var Z = $.length;
      if ((h('maybeReadMore read 0'), U.read(0), Z === $.length)) break;
    }
    $.readingMore = !1;
  }
  (X.prototype._read = function (U) {
    V(this, new R('_read()'));
  }),
    (X.prototype.pipe = function (U, $) {
      var Z = this,
        ae = this._readableState;
      switch (ae.pipesCount) {
        case 0:
          ae.pipes = U;
          break;
        case 1:
          ae.pipes = [ae.pipes, U];
          break;
        default:
          ae.pipes.push(U);
          break;
      }
      (ae.pipesCount += 1), h('pipe count=%d opts=%j', ae.pipesCount, $);
      var fe = (!$ || $.end !== !1) && U !== Je.stdout && U !== Je.stderr,
        le = fe ? be : Ke;
      ae.endEmitted ? Je.nextTick(le) : Z.once('end', le), U.on('unpipe', Fe);
      function Fe(K, O) {
        h('onunpipe'), K === Z && O && O.hasUnpiped === !1 && ((O.hasUnpiped = !0), me());
      }
      function be() {
        h('onend'), U.end();
      }
      var oe = b(Z);
      U.on('drain', oe);
      var rt = !1;
      function me() {
        h('cleanup'),
          U.removeListener('close', ce),
          U.removeListener('finish', he),
          U.removeListener('drain', oe),
          U.removeListener('error', ge),
          U.removeListener('unpipe', Fe),
          Z.removeListener('end', be),
          Z.removeListener('end', Ke),
          Z.removeListener('data', re),
          (rt = !0),
          ae.awaitDrain && (!U._writableState || U._writableState.needDrain) && oe();
      }
      Z.on('data', re);
      function re(K) {
        h('ondata');
        var O = U.write(K);
        h('dest.write', O),
          O === !1 &&
            (((ae.pipesCount === 1 && ae.pipes === U) ||
              (ae.pipesCount > 1 && Q(ae.pipes, U) !== -1)) &&
              !rt &&
              (h('false write response, pause', ae.awaitDrain), ae.awaitDrain++),
            Z.pause());
      }
      function ge(K) {
        h('onerror', K), Ke(), U.removeListener('error', ge), e(U, 'error') === 0 && V(U, K);
      }
      ue(U, 'error', ge);
      function ce() {
        U.removeListener('finish', he), Ke();
      }
      U.once('close', ce);
      function he() {
        h('onfinish'), U.removeListener('close', ce), Ke();
      }
      U.once('finish', he);
      function Ke() {
        h('unpipe'), Z.unpipe(U);
      }
      return U.emit('pipe', Z), ae.flowing || (h('pipe resume'), Z.resume()), U;
    });
  function b(U) {
    return function () {
      var Z = U._readableState;
      h('pipeOnDrain', Z.awaitDrain),
        Z.awaitDrain && Z.awaitDrain--,
        Z.awaitDrain === 0 && e(U, 'data') && ((Z.flowing = !0), C(U));
    };
  }
  (X.prototype.unpipe = function (U) {
    var $ = this._readableState,
      Z = { hasUnpiped: !1 };
    if ($.pipesCount === 0) return this;
    if ($.pipesCount === 1)
      return U && U !== $.pipes
        ? this
        : (U || (U = $.pipes),
          ($.pipes = null),
          ($.pipesCount = 0),
          ($.flowing = !1),
          U && U.emit('unpipe', this, Z),
          this);
    if (!U) {
      var ae = $.pipes,
        fe = $.pipesCount;
      ($.pipes = null), ($.pipesCount = 0), ($.flowing = !1);
      for (var le = 0; le < fe; le++) ae[le].emit('unpipe', this, { hasUnpiped: !1 });
      return this;
    }
    var Fe = Q($.pipes, U);
    return Fe === -1
      ? this
      : ($.pipes.splice(Fe, 1),
        ($.pipesCount -= 1),
        $.pipesCount === 1 && ($.pipes = $.pipes[0]),
        U.emit('unpipe', this, Z),
        this);
  }),
    (X.prototype.on = function (U, $) {
      var Z = t.prototype.on.call(this, U, $),
        ae = this._readableState;
      return (
        U === 'data'
          ? ((ae.readableListening = this.listenerCount('readable') > 0),
            ae.flowing !== !1 && this.resume())
          : U === 'readable' &&
            !ae.endEmitted &&
            !ae.readableListening &&
            ((ae.readableListening = ae.needReadable = !0),
            (ae.flowing = !1),
            (ae.emittedReadable = !1),
            h('on readable', ae.length, ae.reading),
            ae.length ? w(this) : ae.reading || Je.nextTick(B, this)),
        Z
      );
    }),
    (X.prototype.addListener = X.prototype.on),
    (X.prototype.removeListener = function (U, $) {
      var Z = t.prototype.removeListener.call(this, U, $);
      return U === 'readable' && Je.nextTick(k, this), Z;
    }),
    (X.prototype.removeAllListeners = function (U) {
      var $ = t.prototype.removeAllListeners.apply(this, arguments);
      return (U === 'readable' || U === void 0) && Je.nextTick(k, this), $;
    });
  function k(U) {
    var $ = U._readableState;
    ($.readableListening = U.listenerCount('readable') > 0),
      $.resumeScheduled && !$.paused ? ($.flowing = !0) : U.listenerCount('data') > 0 && U.resume();
  }
  function B(U) {
    h('readable nexttick read 0'), U.read(0);
  }
  X.prototype.resume = function () {
    var U = this._readableState;
    return (
      U.flowing || (h('resume'), (U.flowing = !U.readableListening), F(this, U)),
      (U.paused = !1),
      this
    );
  };
  function F(U, $) {
    $.resumeScheduled || (($.resumeScheduled = !0), Je.nextTick(P, U, $));
  }
  function P(U, $) {
    h('resume', $.reading),
      $.reading || U.read(0),
      ($.resumeScheduled = !1),
      U.emit('resume'),
      C(U),
      $.flowing && !$.reading && U.read(0);
  }
  X.prototype.pause = function () {
    return (
      h('call pause flowing=%j', this._readableState.flowing),
      this._readableState.flowing !== !1 &&
        (h('pause'), (this._readableState.flowing = !1), this.emit('pause')),
      (this._readableState.paused = !0),
      this
    );
  };
  function C(U) {
    var $ = U._readableState;
    for (h('flow', $.flowing); $.flowing && U.read() !== null; );
  }
  (X.prototype.wrap = function (U) {
    var $ = this,
      Z = this._readableState,
      ae = !1;
    U.on('end', function () {
      if ((h('wrapped end'), Z.decoder && !Z.ended)) {
        var Fe = Z.decoder.end();
        Fe && Fe.length && $.push(Fe);
      }
      $.push(null);
    }),
      U.on('data', function (Fe) {
        if (
          (h('wrapped data'),
          Z.decoder && (Fe = Z.decoder.write(Fe)),
          !(Z.objectMode && Fe == null) && !(!Z.objectMode && (!Fe || !Fe.length)))
        ) {
          var be = $.push(Fe);
          be || ((ae = !0), U.pause());
        }
      });
    for (var fe in U)
      this[fe] === void 0 &&
        typeof U[fe] == 'function' &&
        (this[fe] = (function (be) {
          return function () {
            return U[be].apply(U, arguments);
          };
        })(fe));
    for (var le = 0; le < te.length; le++) U.on(te[le], this.emit.bind(this, te[le]));
    return (
      (this._read = function (Fe) {
        h('wrapped _read', Fe), ae && ((ae = !1), U.resume());
      }),
      this
    );
  }),
    typeof Symbol == 'function' &&
      (X.prototype[Symbol.asyncIterator] = function () {
        return q === void 0 && (q = kk()), q(this);
      }),
    Object.defineProperty(X.prototype, 'readableHighWaterMark', {
      enumerable: !1,
      get: function () {
        return this._readableState.highWaterMark;
      },
    }),
    Object.defineProperty(X.prototype, 'readableBuffer', {
      enumerable: !1,
      get: function () {
        return this._readableState && this._readableState.buffer;
      },
    }),
    Object.defineProperty(X.prototype, 'readableFlowing', {
      enumerable: !1,
      get: function () {
        return this._readableState.flowing;
      },
      set: function ($) {
        this._readableState && (this._readableState.flowing = $);
      },
    }),
    (X._fromList = z),
    Object.defineProperty(X.prototype, 'readableLength', {
      enumerable: !1,
      get: function () {
        return this._readableState.length;
      },
    });
  function z(U, $) {
    if ($.length === 0) return null;
    var Z;
    return (
      $.objectMode
        ? (Z = $.buffer.shift())
        : !U || U >= $.length
          ? ($.decoder
              ? (Z = $.buffer.join(''))
              : $.buffer.length === 1
                ? (Z = $.buffer.first())
                : (Z = $.buffer.concat($.length)),
            $.buffer.clear())
          : (Z = $.buffer.consume(U, $.decoder)),
      Z
    );
  }
  function Y(U) {
    var $ = U._readableState;
    h('endReadable', $.endEmitted), $.endEmitted || (($.ended = !0), Je.nextTick(G, $, U));
  }
  function G(U, $) {
    if (
      (h('endReadableNT', U.endEmitted, U.length),
      !U.endEmitted &&
        U.length === 0 &&
        ((U.endEmitted = !0), ($.readable = !1), $.emit('end'), U.autoDestroy))
    ) {
      var Z = $._writableState;
      (!Z || (Z.autoDestroy && Z.finished)) && $.destroy();
    }
  }
  typeof Symbol == 'function' &&
    (X.from = function (U, $) {
      return H === void 0 && (H = Ik()), H(X, U, $);
    });
  function Q(U, $) {
    for (var Z = 0, ae = U.length; Z < ae; Z++) if (U[Z] === $) return Z;
    return -1;
  }
  return Vd;
}
var Gd, Mv;
function s8() {
  if (Mv) return Gd;
  (Mv = 1), (Gd = f);
  var i = qa().codes,
    e = i.ERR_METHOD_NOT_IMPLEMENTED,
    t = i.ERR_MULTIPLE_CALLBACK,
    r = i.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    s = i.ERR_TRANSFORM_WITH_LENGTH_0,
    n = Sa();
  dt(f, n);
  function c(p, m) {
    var _ = this._transformState;
    _.transforming = !1;
    var A = _.writecb;
    if (A === null) return this.emit('error', new t());
    (_.writechunk = null), (_.writecb = null), m != null && this.push(m), A(p);
    var E = this._readableState;
    (E.reading = !1), (E.needReadable || E.length < E.highWaterMark) && this._read(E.highWaterMark);
  }
  function f(p) {
    if (!(this instanceof f)) return new f(p);
    n.call(this, p),
      (this._transformState = {
        afterTransform: c.bind(this),
        needTransform: !1,
        transforming: !1,
        writecb: null,
        writechunk: null,
        writeencoding: null,
      }),
      (this._readableState.needReadable = !0),
      (this._readableState.sync = !1),
      p &&
        (typeof p.transform == 'function' && (this._transform = p.transform),
        typeof p.flush == 'function' && (this._flush = p.flush)),
      this.on('prefinish', h);
  }
  function h() {
    var p = this;
    typeof this._flush == 'function' && !this._readableState.destroyed
      ? this._flush(function (m, _) {
          y(p, m, _);
        })
      : y(this, null, null);
  }
  (f.prototype.push = function (p, m) {
    return (this._transformState.needTransform = !1), n.prototype.push.call(this, p, m);
  }),
    (f.prototype._transform = function (p, m, _) {
      _(new e('_transform()'));
    }),
    (f.prototype._write = function (p, m, _) {
      var A = this._transformState;
      if (((A.writecb = _), (A.writechunk = p), (A.writeencoding = m), !A.transforming)) {
        var E = this._readableState;
        (A.needTransform || E.needReadable || E.length < E.highWaterMark) &&
          this._read(E.highWaterMark);
      }
    }),
    (f.prototype._read = function (p) {
      var m = this._transformState;
      m.writechunk !== null && !m.transforming
        ? ((m.transforming = !0), this._transform(m.writechunk, m.writeencoding, m.afterTransform))
        : (m.needTransform = !0);
    }),
    (f.prototype._destroy = function (p, m) {
      n.prototype._destroy.call(this, p, function (_) {
        m(_);
      });
    });
  function y(p, m, _) {
    if (m) return p.emit('error', m);
    if ((_ != null && p.push(_), p._writableState.length)) throw new s();
    if (p._transformState.transforming) throw new r();
    return p.push(null);
  }
  return Gd;
}
var Yd, Av;
function xk() {
  if (Av) return Yd;
  (Av = 1), (Yd = e);
  var i = s8();
  dt(e, i);
  function e(t) {
    if (!(this instanceof e)) return new e(t);
    i.call(this, t);
  }
  return (
    (e.prototype._transform = function (t, r, s) {
      s(null, t);
    }),
    Yd
  );
}
var Zd, Ev;
function Bk() {
  if (Ev) return Zd;
  Ev = 1;
  var i;
  function e(_) {
    var A = !1;
    return function () {
      A || ((A = !0), _.apply(void 0, arguments));
    };
  }
  var t = qa().codes,
    r = t.ERR_MISSING_ARGS,
    s = t.ERR_STREAM_DESTROYED;
  function n(_) {
    if (_) throw _;
  }
  function c(_) {
    return _.setHeader && typeof _.abort == 'function';
  }
  function f(_, A, E, I) {
    I = e(I);
    var R = !1;
    _.on('close', function () {
      R = !0;
    }),
      i === void 0 && (i = cy()),
      i(_, { readable: A, writable: E }, function (D) {
        if (D) return I(D);
        (R = !0), I();
      });
    var L = !1;
    return function (D) {
      if (!R && !L) {
        if (((L = !0), c(_))) return _.abort();
        if (typeof _.destroy == 'function') return _.destroy();
        I(D || new s('pipe'));
      }
    };
  }
  function h(_) {
    _();
  }
  function y(_, A) {
    return _.pipe(A);
  }
  function p(_) {
    return !_.length || typeof _[_.length - 1] != 'function' ? n : _.pop();
  }
  function m() {
    for (var _ = arguments.length, A = new Array(_), E = 0; E < _; E++) A[E] = arguments[E];
    var I = p(A);
    if ((Array.isArray(A[0]) && (A = A[0]), A.length < 2)) throw new r('streams');
    var R,
      L = A.map(function (D, q) {
        var H = q < A.length - 1,
          V = q > 0;
        return f(D, H, V, function (te) {
          R || (R = te), te && L.forEach(h), !H && (L.forEach(h), I(R));
        });
      });
    return A.reduce(y);
  }
  return (Zd = m), Zd;
}
var kv;
function Rk() {
  return (
    kv ||
      ((kv = 1),
      (function (i, e) {
        (e = i.exports = o8()),
          (e.Stream = e),
          (e.Readable = e),
          (e.Writable = n8()),
          (e.Duplex = Sa()),
          (e.Transform = s8()),
          (e.PassThrough = xk()),
          (e.finished = cy()),
          (e.pipeline = Bk());
      })(Yc, Yc.exports)),
    Yc.exports
  );
}
var uu = { exports: {} },
  wf = { exports: {} };
wf.exports;
var Iv;
function Ko() {
  return (
    Iv ||
      ((Iv = 1),
      (function (i) {
        (function (e, t) {
          function r(u, l) {
            if (!u) throw new Error(l || 'Assertion failed');
          }
          function s(u, l) {
            u.super_ = l;
            var d = function () {};
            (d.prototype = l.prototype), (u.prototype = new d()), (u.prototype.constructor = u);
          }
          function n(u, l, d) {
            if (n.isBN(u)) return u;
            (this.negative = 0),
              (this.words = null),
              (this.length = 0),
              (this.red = null),
              u !== null &&
                ((l === 'le' || l === 'be') && ((d = l), (l = 10)),
                this._init(u || 0, l || 10, d || 'be'));
          }
          typeof e == 'object' ? (e.exports = n) : (t.BN = n), (n.BN = n), (n.wordSize = 26);
          var c;
          try {
            typeof window < 'u' && typeof window.Buffer < 'u'
              ? (c = window.Buffer)
              : (c = ai.Buffer);
          } catch {}
          (n.isBN = function (l) {
            return l instanceof n
              ? !0
              : l !== null &&
                  typeof l == 'object' &&
                  l.constructor.wordSize === n.wordSize &&
                  Array.isArray(l.words);
          }),
            (n.max = function (l, d) {
              return l.cmp(d) > 0 ? l : d;
            }),
            (n.min = function (l, d) {
              return l.cmp(d) < 0 ? l : d;
            }),
            (n.prototype._init = function (l, d, g) {
              if (typeof l == 'number') return this._initNumber(l, d, g);
              if (typeof l == 'object') return this._initArray(l, d, g);
              d === 'hex' && (d = 16),
                r(d === (d | 0) && d >= 2 && d <= 36),
                (l = l.toString().replace(/\s+/g, ''));
              var w = 0;
              l[0] === '-' && (w++, (this.negative = 1)),
                w < l.length &&
                  (d === 16
                    ? this._parseHex(l, w, g)
                    : (this._parseBase(l, d, w),
                      g === 'le' && this._initArray(this.toArray(), d, g)));
            }),
            (n.prototype._initNumber = function (l, d, g) {
              l < 0 && ((this.negative = 1), (l = -l)),
                l < 67108864
                  ? ((this.words = [l & 67108863]), (this.length = 1))
                  : l < 4503599627370496
                    ? ((this.words = [l & 67108863, (l / 67108864) & 67108863]), (this.length = 2))
                    : (r(l < 9007199254740992),
                      (this.words = [l & 67108863, (l / 67108864) & 67108863, 1]),
                      (this.length = 3)),
                g === 'le' && this._initArray(this.toArray(), d, g);
            }),
            (n.prototype._initArray = function (l, d, g) {
              if ((r(typeof l.length == 'number'), l.length <= 0))
                return (this.words = [0]), (this.length = 1), this;
              (this.length = Math.ceil(l.length / 3)), (this.words = new Array(this.length));
              for (var w = 0; w < this.length; w++) this.words[w] = 0;
              var M,
                v,
                a = 0;
              if (g === 'be')
                for (w = l.length - 1, M = 0; w >= 0; w -= 3)
                  (v = l[w] | (l[w - 1] << 8) | (l[w - 2] << 16)),
                    (this.words[M] |= (v << a) & 67108863),
                    (this.words[M + 1] = (v >>> (26 - a)) & 67108863),
                    (a += 24),
                    a >= 26 && ((a -= 26), M++);
              else if (g === 'le')
                for (w = 0, M = 0; w < l.length; w += 3)
                  (v = l[w] | (l[w + 1] << 8) | (l[w + 2] << 16)),
                    (this.words[M] |= (v << a) & 67108863),
                    (this.words[M + 1] = (v >>> (26 - a)) & 67108863),
                    (a += 24),
                    a >= 26 && ((a -= 26), M++);
              return this._strip();
            });
          function f(u, l) {
            var d = u.charCodeAt(l);
            if (d >= 48 && d <= 57) return d - 48;
            if (d >= 65 && d <= 70) return d - 55;
            if (d >= 97 && d <= 102) return d - 87;
            r(!1, 'Invalid character in ' + u);
          }
          function h(u, l, d) {
            var g = f(u, d);
            return d - 1 >= l && (g |= f(u, d - 1) << 4), g;
          }
          n.prototype._parseHex = function (l, d, g) {
            (this.length = Math.ceil((l.length - d) / 6)), (this.words = new Array(this.length));
            for (var w = 0; w < this.length; w++) this.words[w] = 0;
            var M = 0,
              v = 0,
              a;
            if (g === 'be')
              for (w = l.length - 1; w >= d; w -= 2)
                (a = h(l, d, w) << M),
                  (this.words[v] |= a & 67108863),
                  M >= 18 ? ((M -= 18), (v += 1), (this.words[v] |= a >>> 26)) : (M += 8);
            else {
              var b = l.length - d;
              for (w = b % 2 === 0 ? d + 1 : d; w < l.length; w += 2)
                (a = h(l, d, w) << M),
                  (this.words[v] |= a & 67108863),
                  M >= 18 ? ((M -= 18), (v += 1), (this.words[v] |= a >>> 26)) : (M += 8);
            }
            this._strip();
          };
          function y(u, l, d, g) {
            for (var w = 0, M = 0, v = Math.min(u.length, d), a = l; a < v; a++) {
              var b = u.charCodeAt(a) - 48;
              (w *= g),
                b >= 49 ? (M = b - 49 + 10) : b >= 17 ? (M = b - 17 + 10) : (M = b),
                r(b >= 0 && M < g, 'Invalid character'),
                (w += M);
            }
            return w;
          }
          (n.prototype._parseBase = function (l, d, g) {
            (this.words = [0]), (this.length = 1);
            for (var w = 0, M = 1; M <= 67108863; M *= d) w++;
            w--, (M = (M / d) | 0);
            for (
              var v = l.length - g, a = v % w, b = Math.min(v, v - a) + g, k = 0, B = g;
              B < b;
              B += w
            )
              (k = y(l, B, B + w, d)),
                this.imuln(M),
                this.words[0] + k < 67108864 ? (this.words[0] += k) : this._iaddn(k);
            if (a !== 0) {
              var F = 1;
              for (k = y(l, B, l.length, d), B = 0; B < a; B++) F *= d;
              this.imuln(F), this.words[0] + k < 67108864 ? (this.words[0] += k) : this._iaddn(k);
            }
            this._strip();
          }),
            (n.prototype.copy = function (l) {
              l.words = new Array(this.length);
              for (var d = 0; d < this.length; d++) l.words[d] = this.words[d];
              (l.length = this.length), (l.negative = this.negative), (l.red = this.red);
            });
          function p(u, l) {
            (u.words = l.words), (u.length = l.length), (u.negative = l.negative), (u.red = l.red);
          }
          if (
            ((n.prototype._move = function (l) {
              p(l, this);
            }),
            (n.prototype.clone = function () {
              var l = new n(null);
              return this.copy(l), l;
            }),
            (n.prototype._expand = function (l) {
              for (; this.length < l; ) this.words[this.length++] = 0;
              return this;
            }),
            (n.prototype._strip = function () {
              for (; this.length > 1 && this.words[this.length - 1] === 0; ) this.length--;
              return this._normSign();
            }),
            (n.prototype._normSign = function () {
              return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
            }),
            typeof Symbol < 'u' && typeof Symbol.for == 'function')
          )
            try {
              n.prototype[Symbol.for('nodejs.util.inspect.custom')] = m;
            } catch {
              n.prototype.inspect = m;
            }
          else n.prototype.inspect = m;
          function m() {
            return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
          }
          var _ = [
              '',
              '0',
              '00',
              '000',
              '0000',
              '00000',
              '000000',
              '0000000',
              '00000000',
              '000000000',
              '0000000000',
              '00000000000',
              '000000000000',
              '0000000000000',
              '00000000000000',
              '000000000000000',
              '0000000000000000',
              '00000000000000000',
              '000000000000000000',
              '0000000000000000000',
              '00000000000000000000',
              '000000000000000000000',
              '0000000000000000000000',
              '00000000000000000000000',
              '000000000000000000000000',
              '0000000000000000000000000',
            ],
            A = [
              0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5,
              5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            ],
            E = [
              0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721,
              1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224,
              47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907,
              17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176,
            ];
          (n.prototype.toString = function (l, d) {
            (l = l || 10), (d = d | 0 || 1);
            var g;
            if (l === 16 || l === 'hex') {
              g = '';
              for (var w = 0, M = 0, v = 0; v < this.length; v++) {
                var a = this.words[v],
                  b = (((a << w) | M) & 16777215).toString(16);
                (M = (a >>> (24 - w)) & 16777215),
                  (w += 2),
                  w >= 26 && ((w -= 26), v--),
                  M !== 0 || v !== this.length - 1 ? (g = _[6 - b.length] + b + g) : (g = b + g);
              }
              for (M !== 0 && (g = M.toString(16) + g); g.length % d !== 0; ) g = '0' + g;
              return this.negative !== 0 && (g = '-' + g), g;
            }
            if (l === (l | 0) && l >= 2 && l <= 36) {
              var k = A[l],
                B = E[l];
              g = '';
              var F = this.clone();
              for (F.negative = 0; !F.isZero(); ) {
                var P = F.modrn(B).toString(l);
                (F = F.idivn(B)), F.isZero() ? (g = P + g) : (g = _[k - P.length] + P + g);
              }
              for (this.isZero() && (g = '0' + g); g.length % d !== 0; ) g = '0' + g;
              return this.negative !== 0 && (g = '-' + g), g;
            }
            r(!1, 'Base should be between 2 and 36');
          }),
            (n.prototype.toNumber = function () {
              var l = this.words[0];
              return (
                this.length === 2
                  ? (l += this.words[1] * 67108864)
                  : this.length === 3 && this.words[2] === 1
                    ? (l += 4503599627370496 + this.words[1] * 67108864)
                    : this.length > 2 && r(!1, 'Number can only safely store up to 53 bits'),
                this.negative !== 0 ? -l : l
              );
            }),
            (n.prototype.toJSON = function () {
              return this.toString(16, 2);
            }),
            c &&
              (n.prototype.toBuffer = function (l, d) {
                return this.toArrayLike(c, l, d);
              }),
            (n.prototype.toArray = function (l, d) {
              return this.toArrayLike(Array, l, d);
            });
          var I = function (l, d) {
            return l.allocUnsafe ? l.allocUnsafe(d) : new l(d);
          };
          (n.prototype.toArrayLike = function (l, d, g) {
            this._strip();
            var w = this.byteLength(),
              M = g || Math.max(1, w);
            r(w <= M, 'byte array longer than desired length'),
              r(M > 0, 'Requested array length <= 0');
            var v = I(l, M),
              a = d === 'le' ? 'LE' : 'BE';
            return this['_toArrayLike' + a](v, w), v;
          }),
            (n.prototype._toArrayLikeLE = function (l, d) {
              for (var g = 0, w = 0, M = 0, v = 0; M < this.length; M++) {
                var a = (this.words[M] << v) | w;
                (l[g++] = a & 255),
                  g < l.length && (l[g++] = (a >> 8) & 255),
                  g < l.length && (l[g++] = (a >> 16) & 255),
                  v === 6
                    ? (g < l.length && (l[g++] = (a >> 24) & 255), (w = 0), (v = 0))
                    : ((w = a >>> 24), (v += 2));
              }
              if (g < l.length) for (l[g++] = w; g < l.length; ) l[g++] = 0;
            }),
            (n.prototype._toArrayLikeBE = function (l, d) {
              for (var g = l.length - 1, w = 0, M = 0, v = 0; M < this.length; M++) {
                var a = (this.words[M] << v) | w;
                (l[g--] = a & 255),
                  g >= 0 && (l[g--] = (a >> 8) & 255),
                  g >= 0 && (l[g--] = (a >> 16) & 255),
                  v === 6
                    ? (g >= 0 && (l[g--] = (a >> 24) & 255), (w = 0), (v = 0))
                    : ((w = a >>> 24), (v += 2));
              }
              if (g >= 0) for (l[g--] = w; g >= 0; ) l[g--] = 0;
            }),
            Math.clz32
              ? (n.prototype._countBits = function (l) {
                  return 32 - Math.clz32(l);
                })
              : (n.prototype._countBits = function (l) {
                  var d = l,
                    g = 0;
                  return (
                    d >= 4096 && ((g += 13), (d >>>= 13)),
                    d >= 64 && ((g += 7), (d >>>= 7)),
                    d >= 8 && ((g += 4), (d >>>= 4)),
                    d >= 2 && ((g += 2), (d >>>= 2)),
                    g + d
                  );
                }),
            (n.prototype._zeroBits = function (l) {
              if (l === 0) return 26;
              var d = l,
                g = 0;
              return (
                d & 8191 || ((g += 13), (d >>>= 13)),
                d & 127 || ((g += 7), (d >>>= 7)),
                d & 15 || ((g += 4), (d >>>= 4)),
                d & 3 || ((g += 2), (d >>>= 2)),
                d & 1 || g++,
                g
              );
            }),
            (n.prototype.bitLength = function () {
              var l = this.words[this.length - 1],
                d = this._countBits(l);
              return (this.length - 1) * 26 + d;
            });
          function R(u) {
            for (var l = new Array(u.bitLength()), d = 0; d < l.length; d++) {
              var g = (d / 26) | 0,
                w = d % 26;
              l[d] = (u.words[g] >>> w) & 1;
            }
            return l;
          }
          (n.prototype.zeroBits = function () {
            if (this.isZero()) return 0;
            for (var l = 0, d = 0; d < this.length; d++) {
              var g = this._zeroBits(this.words[d]);
              if (((l += g), g !== 26)) break;
            }
            return l;
          }),
            (n.prototype.byteLength = function () {
              return Math.ceil(this.bitLength() / 8);
            }),
            (n.prototype.toTwos = function (l) {
              return this.negative !== 0 ? this.abs().inotn(l).iaddn(1) : this.clone();
            }),
            (n.prototype.fromTwos = function (l) {
              return this.testn(l - 1) ? this.notn(l).iaddn(1).ineg() : this.clone();
            }),
            (n.prototype.isNeg = function () {
              return this.negative !== 0;
            }),
            (n.prototype.neg = function () {
              return this.clone().ineg();
            }),
            (n.prototype.ineg = function () {
              return this.isZero() || (this.negative ^= 1), this;
            }),
            (n.prototype.iuor = function (l) {
              for (; this.length < l.length; ) this.words[this.length++] = 0;
              for (var d = 0; d < l.length; d++) this.words[d] = this.words[d] | l.words[d];
              return this._strip();
            }),
            (n.prototype.ior = function (l) {
              return r((this.negative | l.negative) === 0), this.iuor(l);
            }),
            (n.prototype.or = function (l) {
              return this.length > l.length ? this.clone().ior(l) : l.clone().ior(this);
            }),
            (n.prototype.uor = function (l) {
              return this.length > l.length ? this.clone().iuor(l) : l.clone().iuor(this);
            }),
            (n.prototype.iuand = function (l) {
              var d;
              this.length > l.length ? (d = l) : (d = this);
              for (var g = 0; g < d.length; g++) this.words[g] = this.words[g] & l.words[g];
              return (this.length = d.length), this._strip();
            }),
            (n.prototype.iand = function (l) {
              return r((this.negative | l.negative) === 0), this.iuand(l);
            }),
            (n.prototype.and = function (l) {
              return this.length > l.length ? this.clone().iand(l) : l.clone().iand(this);
            }),
            (n.prototype.uand = function (l) {
              return this.length > l.length ? this.clone().iuand(l) : l.clone().iuand(this);
            }),
            (n.prototype.iuxor = function (l) {
              var d, g;
              this.length > l.length ? ((d = this), (g = l)) : ((d = l), (g = this));
              for (var w = 0; w < g.length; w++) this.words[w] = d.words[w] ^ g.words[w];
              if (this !== d) for (; w < d.length; w++) this.words[w] = d.words[w];
              return (this.length = d.length), this._strip();
            }),
            (n.prototype.ixor = function (l) {
              return r((this.negative | l.negative) === 0), this.iuxor(l);
            }),
            (n.prototype.xor = function (l) {
              return this.length > l.length ? this.clone().ixor(l) : l.clone().ixor(this);
            }),
            (n.prototype.uxor = function (l) {
              return this.length > l.length ? this.clone().iuxor(l) : l.clone().iuxor(this);
            }),
            (n.prototype.inotn = function (l) {
              r(typeof l == 'number' && l >= 0);
              var d = Math.ceil(l / 26) | 0,
                g = l % 26;
              this._expand(d), g > 0 && d--;
              for (var w = 0; w < d; w++) this.words[w] = ~this.words[w] & 67108863;
              return (
                g > 0 && (this.words[w] = ~this.words[w] & (67108863 >> (26 - g))), this._strip()
              );
            }),
            (n.prototype.notn = function (l) {
              return this.clone().inotn(l);
            }),
            (n.prototype.setn = function (l, d) {
              r(typeof l == 'number' && l >= 0);
              var g = (l / 26) | 0,
                w = l % 26;
              return (
                this._expand(g + 1),
                d
                  ? (this.words[g] = this.words[g] | (1 << w))
                  : (this.words[g] = this.words[g] & ~(1 << w)),
                this._strip()
              );
            }),
            (n.prototype.iadd = function (l) {
              var d;
              if (this.negative !== 0 && l.negative === 0)
                return (
                  (this.negative = 0), (d = this.isub(l)), (this.negative ^= 1), this._normSign()
                );
              if (this.negative === 0 && l.negative !== 0)
                return (l.negative = 0), (d = this.isub(l)), (l.negative = 1), d._normSign();
              var g, w;
              this.length > l.length ? ((g = this), (w = l)) : ((g = l), (w = this));
              for (var M = 0, v = 0; v < w.length; v++)
                (d = (g.words[v] | 0) + (w.words[v] | 0) + M),
                  (this.words[v] = d & 67108863),
                  (M = d >>> 26);
              for (; M !== 0 && v < g.length; v++)
                (d = (g.words[v] | 0) + M), (this.words[v] = d & 67108863), (M = d >>> 26);
              if (((this.length = g.length), M !== 0)) (this.words[this.length] = M), this.length++;
              else if (g !== this) for (; v < g.length; v++) this.words[v] = g.words[v];
              return this;
            }),
            (n.prototype.add = function (l) {
              var d;
              return l.negative !== 0 && this.negative === 0
                ? ((l.negative = 0), (d = this.sub(l)), (l.negative ^= 1), d)
                : l.negative === 0 && this.negative !== 0
                  ? ((this.negative = 0), (d = l.sub(this)), (this.negative = 1), d)
                  : this.length > l.length
                    ? this.clone().iadd(l)
                    : l.clone().iadd(this);
            }),
            (n.prototype.isub = function (l) {
              if (l.negative !== 0) {
                l.negative = 0;
                var d = this.iadd(l);
                return (l.negative = 1), d._normSign();
              } else if (this.negative !== 0)
                return (this.negative = 0), this.iadd(l), (this.negative = 1), this._normSign();
              var g = this.cmp(l);
              if (g === 0) return (this.negative = 0), (this.length = 1), (this.words[0] = 0), this;
              var w, M;
              g > 0 ? ((w = this), (M = l)) : ((w = l), (M = this));
              for (var v = 0, a = 0; a < M.length; a++)
                (d = (w.words[a] | 0) - (M.words[a] | 0) + v),
                  (v = d >> 26),
                  (this.words[a] = d & 67108863);
              for (; v !== 0 && a < w.length; a++)
                (d = (w.words[a] | 0) + v), (v = d >> 26), (this.words[a] = d & 67108863);
              if (v === 0 && a < w.length && w !== this)
                for (; a < w.length; a++) this.words[a] = w.words[a];
              return (
                (this.length = Math.max(this.length, a)),
                w !== this && (this.negative = 1),
                this._strip()
              );
            }),
            (n.prototype.sub = function (l) {
              return this.clone().isub(l);
            });
          function L(u, l, d) {
            d.negative = l.negative ^ u.negative;
            var g = (u.length + l.length) | 0;
            (d.length = g), (g = (g - 1) | 0);
            var w = u.words[0] | 0,
              M = l.words[0] | 0,
              v = w * M,
              a = v & 67108863,
              b = (v / 67108864) | 0;
            d.words[0] = a;
            for (var k = 1; k < g; k++) {
              for (
                var B = b >>> 26,
                  F = b & 67108863,
                  P = Math.min(k, l.length - 1),
                  C = Math.max(0, k - u.length + 1);
                C <= P;
                C++
              ) {
                var z = (k - C) | 0;
                (w = u.words[z] | 0),
                  (M = l.words[C] | 0),
                  (v = w * M + F),
                  (B += (v / 67108864) | 0),
                  (F = v & 67108863);
              }
              (d.words[k] = F | 0), (b = B | 0);
            }
            return b !== 0 ? (d.words[k] = b | 0) : d.length--, d._strip();
          }
          var D = function (l, d, g) {
            var w = l.words,
              M = d.words,
              v = g.words,
              a = 0,
              b,
              k,
              B,
              F = w[0] | 0,
              P = F & 8191,
              C = F >>> 13,
              z = w[1] | 0,
              Y = z & 8191,
              G = z >>> 13,
              Q = w[2] | 0,
              U = Q & 8191,
              $ = Q >>> 13,
              Z = w[3] | 0,
              ae = Z & 8191,
              fe = Z >>> 13,
              le = w[4] | 0,
              Fe = le & 8191,
              be = le >>> 13,
              oe = w[5] | 0,
              rt = oe & 8191,
              me = oe >>> 13,
              re = w[6] | 0,
              ge = re & 8191,
              ce = re >>> 13,
              he = w[7] | 0,
              Ke = he & 8191,
              K = he >>> 13,
              O = w[8] | 0,
              W = O & 8191,
              T = O >>> 13,
              x = w[9] | 0,
              N = x & 8191,
              j = x >>> 13,
              J = M[0] | 0,
              de = J & 8191,
              ie = J >>> 13,
              ye = M[1] | 0,
              Ye = ye & 8191,
              ve = ye >>> 13,
              _e = M[2] | 0,
              et = _e & 8191,
              Me = _e >>> 13,
              Ce = M[3] | 0,
              yt = Ce & 8191,
              Ae = Ce >>> 13,
              Le = M[4] | 0,
              gt = Le & 8191,
              Ee = Le >>> 13,
              Ne = M[5] | 0,
              bt = Ne & 8191,
              ke = Ne >>> 13,
              $e = M[6] | 0,
              vt = $e & 8191,
              Ie = $e >>> 13,
              De = M[7] | 0,
              mt = De & 8191,
              xe = De >>> 13,
              Ue = M[8] | 0,
              wt = Ue & 8191,
              Be = Ue >>> 13,
              ze = M[9] | 0,
              st = ze & 8191,
              at = ze >>> 13;
            (g.negative = l.negative ^ d.negative),
              (g.length = 19),
              (b = Math.imul(P, de)),
              (k = Math.imul(P, ie)),
              (k = (k + Math.imul(C, de)) | 0),
              (B = Math.imul(C, ie));
            var Ft = (((a + b) | 0) + ((k & 8191) << 13)) | 0;
            (a = (((B + (k >>> 13)) | 0) + (Ft >>> 26)) | 0),
              (Ft &= 67108863),
              (b = Math.imul(Y, de)),
              (k = Math.imul(Y, ie)),
              (k = (k + Math.imul(G, de)) | 0),
              (B = Math.imul(G, ie)),
              (b = (b + Math.imul(P, Ye)) | 0),
              (k = (k + Math.imul(P, ve)) | 0),
              (k = (k + Math.imul(C, Ye)) | 0),
              (B = (B + Math.imul(C, ve)) | 0);
            var qt = (((a + b) | 0) + ((k & 8191) << 13)) | 0;
            (a = (((B + (k >>> 13)) | 0) + (qt >>> 26)) | 0),
              (qt &= 67108863),
              (b = Math.imul(U, de)),
              (k = Math.imul(U, ie)),
              (k = (k + Math.imul($, de)) | 0),
              (B = Math.imul($, ie)),
              (b = (b + Math.imul(Y, Ye)) | 0),
              (k = (k + Math.imul(Y, ve)) | 0),
              (k = (k + Math.imul(G, Ye)) | 0),
              (B = (B + Math.imul(G, ve)) | 0),
              (b = (b + Math.imul(P, et)) | 0),
              (k = (k + Math.imul(P, Me)) | 0),
              (k = (k + Math.imul(C, et)) | 0),
              (B = (B + Math.imul(C, Me)) | 0);
            var Wt = (((a + b) | 0) + ((k & 8191) << 13)) | 0;
            (a = (((B + (k >>> 13)) | 0) + (Wt >>> 26)) | 0),
              (Wt &= 67108863),
              (b = Math.imul(ae, de)),
              (k = Math.imul(ae, ie)),
              (k = (k + Math.imul(fe, de)) | 0),
              (B = Math.imul(fe, ie)),
              (b = (b + Math.imul(U, Ye)) | 0),
              (k = (k + Math.imul(U, ve)) | 0),
              (k = (k + Math.imul($, Ye)) | 0),
              (B = (B + Math.imul($, ve)) | 0),
              (b = (b + Math.imul(Y, et)) | 0),
              (k = (k + Math.imul(Y, Me)) | 0),
              (k = (k + Math.imul(G, et)) | 0),
              (B = (B + Math.imul(G, Me)) | 0),
              (b = (b + Math.imul(P, yt)) | 0),
              (k = (k + Math.imul(P, Ae)) | 0),
              (k = (k + Math.imul(C, yt)) | 0),
              (B = (B + Math.imul(C, Ae)) | 0);
            var Kt = (((a + b) | 0) + ((k & 8191) << 13)) | 0;
            (a = (((B + (k >>> 13)) | 0) + (Kt >>> 26)) | 0),
              (Kt &= 67108863),
              (b = Math.imul(Fe, de)),
              (k = Math.imul(Fe, ie)),
              (k = (k + Math.imul(be, de)) | 0),
              (B = Math.imul(be, ie)),
              (b = (b + Math.imul(ae, Ye)) | 0),
              (k = (k + Math.imul(ae, ve)) | 0),
              (k = (k + Math.imul(fe, Ye)) | 0),
              (B = (B + Math.imul(fe, ve)) | 0),
              (b = (b + Math.imul(U, et)) | 0),
              (k = (k + Math.imul(U, Me)) | 0),
              (k = (k + Math.imul($, et)) | 0),
              (B = (B + Math.imul($, Me)) | 0),
              (b = (b + Math.imul(Y, yt)) | 0),
              (k = (k + Math.imul(Y, Ae)) | 0),
              (k = (k + Math.imul(G, yt)) | 0),
              (B = (B + Math.imul(G, Ae)) | 0),
              (b = (b + Math.imul(P, gt)) | 0),
              (k = (k + Math.imul(P, Ee)) | 0),
              (k = (k + Math.imul(C, gt)) | 0),
              (B = (B + Math.imul(C, Ee)) | 0);
            var jt = (((a + b) | 0) + ((k & 8191) << 13)) | 0;
            (a = (((B + (k >>> 13)) | 0) + (jt >>> 26)) | 0),
              (jt &= 67108863),
              (b = Math.imul(rt, de)),
              (k = Math.imul(rt, ie)),
              (k = (k + Math.imul(me, de)) | 0),
              (B = Math.imul(me, ie)),
              (b = (b + Math.imul(Fe, Ye)) | 0),
              (k = (k + Math.imul(Fe, ve)) | 0),
              (k = (k + Math.imul(be, Ye)) | 0),
              (B = (B + Math.imul(be, ve)) | 0),
              (b = (b + Math.imul(ae, et)) | 0),
              (k = (k + Math.imul(ae, Me)) | 0),
              (k = (k + Math.imul(fe, et)) | 0),
              (B = (B + Math.imul(fe, Me)) | 0),
              (b = (b + Math.imul(U, yt)) | 0),
              (k = (k + Math.imul(U, Ae)) | 0),
              (k = (k + Math.imul($, yt)) | 0),
              (B = (B + Math.imul($, Ae)) | 0),
              (b = (b + Math.imul(Y, gt)) | 0),
              (k = (k + Math.imul(Y, Ee)) | 0),
              (k = (k + Math.imul(G, gt)) | 0),
              (B = (B + Math.imul(G, Ee)) | 0),
              (b = (b + Math.imul(P, bt)) | 0),
              (k = (k + Math.imul(P, ke)) | 0),
              (k = (k + Math.imul(C, bt)) | 0),
              (B = (B + Math.imul(C, ke)) | 0);
            var fr = (((a + b) | 0) + ((k & 8191) << 13)) | 0;
            (a = (((B + (k >>> 13)) | 0) + (fr >>> 26)) | 0),
              (fr &= 67108863),
              (b = Math.imul(ge, de)),
              (k = Math.imul(ge, ie)),
              (k = (k + Math.imul(ce, de)) | 0),
              (B = Math.imul(ce, ie)),
              (b = (b + Math.imul(rt, Ye)) | 0),
              (k = (k + Math.imul(rt, ve)) | 0),
              (k = (k + Math.imul(me, Ye)) | 0),
              (B = (B + Math.imul(me, ve)) | 0),
              (b = (b + Math.imul(Fe, et)) | 0),
              (k = (k + Math.imul(Fe, Me)) | 0),
              (k = (k + Math.imul(be, et)) | 0),
              (B = (B + Math.imul(be, Me)) | 0),
              (b = (b + Math.imul(ae, yt)) | 0),
              (k = (k + Math.imul(ae, Ae)) | 0),
              (k = (k + Math.imul(fe, yt)) | 0),
              (B = (B + Math.imul(fe, Ae)) | 0),
              (b = (b + Math.imul(U, gt)) | 0),
              (k = (k + Math.imul(U, Ee)) | 0),
              (k = (k + Math.imul($, gt)) | 0),
              (B = (B + Math.imul($, Ee)) | 0),
              (b = (b + Math.imul(Y, bt)) | 0),
              (k = (k + Math.imul(Y, ke)) | 0),
              (k = (k + Math.imul(G, bt)) | 0),
              (B = (B + Math.imul(G, ke)) | 0),
              (b = (b + Math.imul(P, vt)) | 0),
              (k = (k + Math.imul(P, Ie)) | 0),
              (k = (k + Math.imul(C, vt)) | 0),
              (B = (B + Math.imul(C, Ie)) | 0);
            var lr = (((a + b) | 0) + ((k & 8191) << 13)) | 0;
            (a = (((B + (k >>> 13)) | 0) + (lr >>> 26)) | 0),
              (lr &= 67108863),
              (b = Math.imul(Ke, de)),
              (k = Math.imul(Ke, ie)),
              (k = (k + Math.imul(K, de)) | 0),
              (B = Math.imul(K, ie)),
              (b = (b + Math.imul(ge, Ye)) | 0),
              (k = (k + Math.imul(ge, ve)) | 0),
              (k = (k + Math.imul(ce, Ye)) | 0),
              (B = (B + Math.imul(ce, ve)) | 0),
              (b = (b + Math.imul(rt, et)) | 0),
              (k = (k + Math.imul(rt, Me)) | 0),
              (k = (k + Math.imul(me, et)) | 0),
              (B = (B + Math.imul(me, Me)) | 0),
              (b = (b + Math.imul(Fe, yt)) | 0),
              (k = (k + Math.imul(Fe, Ae)) | 0),
              (k = (k + Math.imul(be, yt)) | 0),
              (B = (B + Math.imul(be, Ae)) | 0),
              (b = (b + Math.imul(ae, gt)) | 0),
              (k = (k + Math.imul(ae, Ee)) | 0),
              (k = (k + Math.imul(fe, gt)) | 0),
              (B = (B + Math.imul(fe, Ee)) | 0),
              (b = (b + Math.imul(U, bt)) | 0),
              (k = (k + Math.imul(U, ke)) | 0),
              (k = (k + Math.imul($, bt)) | 0),
              (B = (B + Math.imul($, ke)) | 0),
              (b = (b + Math.imul(Y, vt)) | 0),
              (k = (k + Math.imul(Y, Ie)) | 0),
              (k = (k + Math.imul(G, vt)) | 0),
              (B = (B + Math.imul(G, Ie)) | 0),
              (b = (b + Math.imul(P, mt)) | 0),
              (k = (k + Math.imul(P, xe)) | 0),
              (k = (k + Math.imul(C, mt)) | 0),
              (B = (B + Math.imul(C, xe)) | 0);
            var hr = (((a + b) | 0) + ((k & 8191) << 13)) | 0;
            (a = (((B + (k >>> 13)) | 0) + (hr >>> 26)) | 0),
              (hr &= 67108863),
              (b = Math.imul(W, de)),
              (k = Math.imul(W, ie)),
              (k = (k + Math.imul(T, de)) | 0),
              (B = Math.imul(T, ie)),
              (b = (b + Math.imul(Ke, Ye)) | 0),
              (k = (k + Math.imul(Ke, ve)) | 0),
              (k = (k + Math.imul(K, Ye)) | 0),
              (B = (B + Math.imul(K, ve)) | 0),
              (b = (b + Math.imul(ge, et)) | 0),
              (k = (k + Math.imul(ge, Me)) | 0),
              (k = (k + Math.imul(ce, et)) | 0),
              (B = (B + Math.imul(ce, Me)) | 0),
              (b = (b + Math.imul(rt, yt)) | 0),
              (k = (k + Math.imul(rt, Ae)) | 0),
              (k = (k + Math.imul(me, yt)) | 0),
              (B = (B + Math.imul(me, Ae)) | 0),
              (b = (b + Math.imul(Fe, gt)) | 0),
              (k = (k + Math.imul(Fe, Ee)) | 0),
              (k = (k + Math.imul(be, gt)) | 0),
              (B = (B + Math.imul(be, Ee)) | 0),
              (b = (b + Math.imul(ae, bt)) | 0),
              (k = (k + Math.imul(ae, ke)) | 0),
              (k = (k + Math.imul(fe, bt)) | 0),
              (B = (B + Math.imul(fe, ke)) | 0),
              (b = (b + Math.imul(U, vt)) | 0),
              (k = (k + Math.imul(U, Ie)) | 0),
              (k = (k + Math.imul($, vt)) | 0),
              (B = (B + Math.imul($, Ie)) | 0),
              (b = (b + Math.imul(Y, mt)) | 0),
              (k = (k + Math.imul(Y, xe)) | 0),
              (k = (k + Math.imul(G, mt)) | 0),
              (B = (B + Math.imul(G, xe)) | 0),
              (b = (b + Math.imul(P, wt)) | 0),
              (k = (k + Math.imul(P, Be)) | 0),
              (k = (k + Math.imul(C, wt)) | 0),
              (B = (B + Math.imul(C, Be)) | 0);
            var dr = (((a + b) | 0) + ((k & 8191) << 13)) | 0;
            (a = (((B + (k >>> 13)) | 0) + (dr >>> 26)) | 0),
              (dr &= 67108863),
              (b = Math.imul(N, de)),
              (k = Math.imul(N, ie)),
              (k = (k + Math.imul(j, de)) | 0),
              (B = Math.imul(j, ie)),
              (b = (b + Math.imul(W, Ye)) | 0),
              (k = (k + Math.imul(W, ve)) | 0),
              (k = (k + Math.imul(T, Ye)) | 0),
              (B = (B + Math.imul(T, ve)) | 0),
              (b = (b + Math.imul(Ke, et)) | 0),
              (k = (k + Math.imul(Ke, Me)) | 0),
              (k = (k + Math.imul(K, et)) | 0),
              (B = (B + Math.imul(K, Me)) | 0),
              (b = (b + Math.imul(ge, yt)) | 0),
              (k = (k + Math.imul(ge, Ae)) | 0),
              (k = (k + Math.imul(ce, yt)) | 0),
              (B = (B + Math.imul(ce, Ae)) | 0),
              (b = (b + Math.imul(rt, gt)) | 0),
              (k = (k + Math.imul(rt, Ee)) | 0),
              (k = (k + Math.imul(me, gt)) | 0),
              (B = (B + Math.imul(me, Ee)) | 0),
              (b = (b + Math.imul(Fe, bt)) | 0),
              (k = (k + Math.imul(Fe, ke)) | 0),
              (k = (k + Math.imul(be, bt)) | 0),
              (B = (B + Math.imul(be, ke)) | 0),
              (b = (b + Math.imul(ae, vt)) | 0),
              (k = (k + Math.imul(ae, Ie)) | 0),
              (k = (k + Math.imul(fe, vt)) | 0),
              (B = (B + Math.imul(fe, Ie)) | 0),
              (b = (b + Math.imul(U, mt)) | 0),
              (k = (k + Math.imul(U, xe)) | 0),
              (k = (k + Math.imul($, mt)) | 0),
              (B = (B + Math.imul($, xe)) | 0),
              (b = (b + Math.imul(Y, wt)) | 0),
              (k = (k + Math.imul(Y, Be)) | 0),
              (k = (k + Math.imul(G, wt)) | 0),
              (B = (B + Math.imul(G, Be)) | 0),
              (b = (b + Math.imul(P, st)) | 0),
              (k = (k + Math.imul(P, at)) | 0),
              (k = (k + Math.imul(C, st)) | 0),
              (B = (B + Math.imul(C, at)) | 0);
            var pr = (((a + b) | 0) + ((k & 8191) << 13)) | 0;
            (a = (((B + (k >>> 13)) | 0) + (pr >>> 26)) | 0),
              (pr &= 67108863),
              (b = Math.imul(N, Ye)),
              (k = Math.imul(N, ve)),
              (k = (k + Math.imul(j, Ye)) | 0),
              (B = Math.imul(j, ve)),
              (b = (b + Math.imul(W, et)) | 0),
              (k = (k + Math.imul(W, Me)) | 0),
              (k = (k + Math.imul(T, et)) | 0),
              (B = (B + Math.imul(T, Me)) | 0),
              (b = (b + Math.imul(Ke, yt)) | 0),
              (k = (k + Math.imul(Ke, Ae)) | 0),
              (k = (k + Math.imul(K, yt)) | 0),
              (B = (B + Math.imul(K, Ae)) | 0),
              (b = (b + Math.imul(ge, gt)) | 0),
              (k = (k + Math.imul(ge, Ee)) | 0),
              (k = (k + Math.imul(ce, gt)) | 0),
              (B = (B + Math.imul(ce, Ee)) | 0),
              (b = (b + Math.imul(rt, bt)) | 0),
              (k = (k + Math.imul(rt, ke)) | 0),
              (k = (k + Math.imul(me, bt)) | 0),
              (B = (B + Math.imul(me, ke)) | 0),
              (b = (b + Math.imul(Fe, vt)) | 0),
              (k = (k + Math.imul(Fe, Ie)) | 0),
              (k = (k + Math.imul(be, vt)) | 0),
              (B = (B + Math.imul(be, Ie)) | 0),
              (b = (b + Math.imul(ae, mt)) | 0),
              (k = (k + Math.imul(ae, xe)) | 0),
              (k = (k + Math.imul(fe, mt)) | 0),
              (B = (B + Math.imul(fe, xe)) | 0),
              (b = (b + Math.imul(U, wt)) | 0),
              (k = (k + Math.imul(U, Be)) | 0),
              (k = (k + Math.imul($, wt)) | 0),
              (B = (B + Math.imul($, Be)) | 0),
              (b = (b + Math.imul(Y, st)) | 0),
              (k = (k + Math.imul(Y, at)) | 0),
              (k = (k + Math.imul(G, st)) | 0),
              (B = (B + Math.imul(G, at)) | 0);
            var yr = (((a + b) | 0) + ((k & 8191) << 13)) | 0;
            (a = (((B + (k >>> 13)) | 0) + (yr >>> 26)) | 0),
              (yr &= 67108863),
              (b = Math.imul(N, et)),
              (k = Math.imul(N, Me)),
              (k = (k + Math.imul(j, et)) | 0),
              (B = Math.imul(j, Me)),
              (b = (b + Math.imul(W, yt)) | 0),
              (k = (k + Math.imul(W, Ae)) | 0),
              (k = (k + Math.imul(T, yt)) | 0),
              (B = (B + Math.imul(T, Ae)) | 0),
              (b = (b + Math.imul(Ke, gt)) | 0),
              (k = (k + Math.imul(Ke, Ee)) | 0),
              (k = (k + Math.imul(K, gt)) | 0),
              (B = (B + Math.imul(K, Ee)) | 0),
              (b = (b + Math.imul(ge, bt)) | 0),
              (k = (k + Math.imul(ge, ke)) | 0),
              (k = (k + Math.imul(ce, bt)) | 0),
              (B = (B + Math.imul(ce, ke)) | 0),
              (b = (b + Math.imul(rt, vt)) | 0),
              (k = (k + Math.imul(rt, Ie)) | 0),
              (k = (k + Math.imul(me, vt)) | 0),
              (B = (B + Math.imul(me, Ie)) | 0),
              (b = (b + Math.imul(Fe, mt)) | 0),
              (k = (k + Math.imul(Fe, xe)) | 0),
              (k = (k + Math.imul(be, mt)) | 0),
              (B = (B + Math.imul(be, xe)) | 0),
              (b = (b + Math.imul(ae, wt)) | 0),
              (k = (k + Math.imul(ae, Be)) | 0),
              (k = (k + Math.imul(fe, wt)) | 0),
              (B = (B + Math.imul(fe, Be)) | 0),
              (b = (b + Math.imul(U, st)) | 0),
              (k = (k + Math.imul(U, at)) | 0),
              (k = (k + Math.imul($, st)) | 0),
              (B = (B + Math.imul($, at)) | 0);
            var gr = (((a + b) | 0) + ((k & 8191) << 13)) | 0;
            (a = (((B + (k >>> 13)) | 0) + (gr >>> 26)) | 0),
              (gr &= 67108863),
              (b = Math.imul(N, yt)),
              (k = Math.imul(N, Ae)),
              (k = (k + Math.imul(j, yt)) | 0),
              (B = Math.imul(j, Ae)),
              (b = (b + Math.imul(W, gt)) | 0),
              (k = (k + Math.imul(W, Ee)) | 0),
              (k = (k + Math.imul(T, gt)) | 0),
              (B = (B + Math.imul(T, Ee)) | 0),
              (b = (b + Math.imul(Ke, bt)) | 0),
              (k = (k + Math.imul(Ke, ke)) | 0),
              (k = (k + Math.imul(K, bt)) | 0),
              (B = (B + Math.imul(K, ke)) | 0),
              (b = (b + Math.imul(ge, vt)) | 0),
              (k = (k + Math.imul(ge, Ie)) | 0),
              (k = (k + Math.imul(ce, vt)) | 0),
              (B = (B + Math.imul(ce, Ie)) | 0),
              (b = (b + Math.imul(rt, mt)) | 0),
              (k = (k + Math.imul(rt, xe)) | 0),
              (k = (k + Math.imul(me, mt)) | 0),
              (B = (B + Math.imul(me, xe)) | 0),
              (b = (b + Math.imul(Fe, wt)) | 0),
              (k = (k + Math.imul(Fe, Be)) | 0),
              (k = (k + Math.imul(be, wt)) | 0),
              (B = (B + Math.imul(be, Be)) | 0),
              (b = (b + Math.imul(ae, st)) | 0),
              (k = (k + Math.imul(ae, at)) | 0),
              (k = (k + Math.imul(fe, st)) | 0),
              (B = (B + Math.imul(fe, at)) | 0);
            var br = (((a + b) | 0) + ((k & 8191) << 13)) | 0;
            (a = (((B + (k >>> 13)) | 0) + (br >>> 26)) | 0),
              (br &= 67108863),
              (b = Math.imul(N, gt)),
              (k = Math.imul(N, Ee)),
              (k = (k + Math.imul(j, gt)) | 0),
              (B = Math.imul(j, Ee)),
              (b = (b + Math.imul(W, bt)) | 0),
              (k = (k + Math.imul(W, ke)) | 0),
              (k = (k + Math.imul(T, bt)) | 0),
              (B = (B + Math.imul(T, ke)) | 0),
              (b = (b + Math.imul(Ke, vt)) | 0),
              (k = (k + Math.imul(Ke, Ie)) | 0),
              (k = (k + Math.imul(K, vt)) | 0),
              (B = (B + Math.imul(K, Ie)) | 0),
              (b = (b + Math.imul(ge, mt)) | 0),
              (k = (k + Math.imul(ge, xe)) | 0),
              (k = (k + Math.imul(ce, mt)) | 0),
              (B = (B + Math.imul(ce, xe)) | 0),
              (b = (b + Math.imul(rt, wt)) | 0),
              (k = (k + Math.imul(rt, Be)) | 0),
              (k = (k + Math.imul(me, wt)) | 0),
              (B = (B + Math.imul(me, Be)) | 0),
              (b = (b + Math.imul(Fe, st)) | 0),
              (k = (k + Math.imul(Fe, at)) | 0),
              (k = (k + Math.imul(be, st)) | 0),
              (B = (B + Math.imul(be, at)) | 0);
            var vr = (((a + b) | 0) + ((k & 8191) << 13)) | 0;
            (a = (((B + (k >>> 13)) | 0) + (vr >>> 26)) | 0),
              (vr &= 67108863),
              (b = Math.imul(N, bt)),
              (k = Math.imul(N, ke)),
              (k = (k + Math.imul(j, bt)) | 0),
              (B = Math.imul(j, ke)),
              (b = (b + Math.imul(W, vt)) | 0),
              (k = (k + Math.imul(W, Ie)) | 0),
              (k = (k + Math.imul(T, vt)) | 0),
              (B = (B + Math.imul(T, Ie)) | 0),
              (b = (b + Math.imul(Ke, mt)) | 0),
              (k = (k + Math.imul(Ke, xe)) | 0),
              (k = (k + Math.imul(K, mt)) | 0),
              (B = (B + Math.imul(K, xe)) | 0),
              (b = (b + Math.imul(ge, wt)) | 0),
              (k = (k + Math.imul(ge, Be)) | 0),
              (k = (k + Math.imul(ce, wt)) | 0),
              (B = (B + Math.imul(ce, Be)) | 0),
              (b = (b + Math.imul(rt, st)) | 0),
              (k = (k + Math.imul(rt, at)) | 0),
              (k = (k + Math.imul(me, st)) | 0),
              (B = (B + Math.imul(me, at)) | 0);
            var mr = (((a + b) | 0) + ((k & 8191) << 13)) | 0;
            (a = (((B + (k >>> 13)) | 0) + (mr >>> 26)) | 0),
              (mr &= 67108863),
              (b = Math.imul(N, vt)),
              (k = Math.imul(N, Ie)),
              (k = (k + Math.imul(j, vt)) | 0),
              (B = Math.imul(j, Ie)),
              (b = (b + Math.imul(W, mt)) | 0),
              (k = (k + Math.imul(W, xe)) | 0),
              (k = (k + Math.imul(T, mt)) | 0),
              (B = (B + Math.imul(T, xe)) | 0),
              (b = (b + Math.imul(Ke, wt)) | 0),
              (k = (k + Math.imul(Ke, Be)) | 0),
              (k = (k + Math.imul(K, wt)) | 0),
              (B = (B + Math.imul(K, Be)) | 0),
              (b = (b + Math.imul(ge, st)) | 0),
              (k = (k + Math.imul(ge, at)) | 0),
              (k = (k + Math.imul(ce, st)) | 0),
              (B = (B + Math.imul(ce, at)) | 0);
            var wr = (((a + b) | 0) + ((k & 8191) << 13)) | 0;
            (a = (((B + (k >>> 13)) | 0) + (wr >>> 26)) | 0),
              (wr &= 67108863),
              (b = Math.imul(N, mt)),
              (k = Math.imul(N, xe)),
              (k = (k + Math.imul(j, mt)) | 0),
              (B = Math.imul(j, xe)),
              (b = (b + Math.imul(W, wt)) | 0),
              (k = (k + Math.imul(W, Be)) | 0),
              (k = (k + Math.imul(T, wt)) | 0),
              (B = (B + Math.imul(T, Be)) | 0),
              (b = (b + Math.imul(Ke, st)) | 0),
              (k = (k + Math.imul(Ke, at)) | 0),
              (k = (k + Math.imul(K, st)) | 0),
              (B = (B + Math.imul(K, at)) | 0);
            var _r = (((a + b) | 0) + ((k & 8191) << 13)) | 0;
            (a = (((B + (k >>> 13)) | 0) + (_r >>> 26)) | 0),
              (_r &= 67108863),
              (b = Math.imul(N, wt)),
              (k = Math.imul(N, Be)),
              (k = (k + Math.imul(j, wt)) | 0),
              (B = Math.imul(j, Be)),
              (b = (b + Math.imul(W, st)) | 0),
              (k = (k + Math.imul(W, at)) | 0),
              (k = (k + Math.imul(T, st)) | 0),
              (B = (B + Math.imul(T, at)) | 0);
            var vh = (((a + b) | 0) + ((k & 8191) << 13)) | 0;
            (a = (((B + (k >>> 13)) | 0) + (vh >>> 26)) | 0),
              (vh &= 67108863),
              (b = Math.imul(N, st)),
              (k = Math.imul(N, at)),
              (k = (k + Math.imul(j, st)) | 0),
              (B = Math.imul(j, at));
            var mh = (((a + b) | 0) + ((k & 8191) << 13)) | 0;
            return (
              (a = (((B + (k >>> 13)) | 0) + (mh >>> 26)) | 0),
              (mh &= 67108863),
              (v[0] = Ft),
              (v[1] = qt),
              (v[2] = Wt),
              (v[3] = Kt),
              (v[4] = jt),
              (v[5] = fr),
              (v[6] = lr),
              (v[7] = hr),
              (v[8] = dr),
              (v[9] = pr),
              (v[10] = yr),
              (v[11] = gr),
              (v[12] = br),
              (v[13] = vr),
              (v[14] = mr),
              (v[15] = wr),
              (v[16] = _r),
              (v[17] = vh),
              (v[18] = mh),
              a !== 0 && ((v[19] = a), g.length++),
              g
            );
          };
          Math.imul || (D = L);
          function q(u, l, d) {
            (d.negative = l.negative ^ u.negative), (d.length = u.length + l.length);
            for (var g = 0, w = 0, M = 0; M < d.length - 1; M++) {
              var v = w;
              w = 0;
              for (
                var a = g & 67108863,
                  b = Math.min(M, l.length - 1),
                  k = Math.max(0, M - u.length + 1);
                k <= b;
                k++
              ) {
                var B = M - k,
                  F = u.words[B] | 0,
                  P = l.words[k] | 0,
                  C = F * P,
                  z = C & 67108863;
                (v = (v + ((C / 67108864) | 0)) | 0),
                  (z = (z + a) | 0),
                  (a = z & 67108863),
                  (v = (v + (z >>> 26)) | 0),
                  (w += v >>> 26),
                  (v &= 67108863);
              }
              (d.words[M] = a), (g = v), (v = w);
            }
            return g !== 0 ? (d.words[M] = g) : d.length--, d._strip();
          }
          function H(u, l, d) {
            return q(u, l, d);
          }
          (n.prototype.mulTo = function (l, d) {
            var g,
              w = this.length + l.length;
            return (
              this.length === 10 && l.length === 10
                ? (g = D(this, l, d))
                : w < 63
                  ? (g = L(this, l, d))
                  : w < 1024
                    ? (g = q(this, l, d))
                    : (g = H(this, l, d)),
              g
            );
          }),
            (n.prototype.mul = function (l) {
              var d = new n(null);
              return (d.words = new Array(this.length + l.length)), this.mulTo(l, d);
            }),
            (n.prototype.mulf = function (l) {
              var d = new n(null);
              return (d.words = new Array(this.length + l.length)), H(this, l, d);
            }),
            (n.prototype.imul = function (l) {
              return this.clone().mulTo(l, this);
            }),
            (n.prototype.imuln = function (l) {
              var d = l < 0;
              d && (l = -l), r(typeof l == 'number'), r(l < 67108864);
              for (var g = 0, w = 0; w < this.length; w++) {
                var M = (this.words[w] | 0) * l,
                  v = (M & 67108863) + (g & 67108863);
                (g >>= 26),
                  (g += (M / 67108864) | 0),
                  (g += v >>> 26),
                  (this.words[w] = v & 67108863);
              }
              return g !== 0 && ((this.words[w] = g), this.length++), d ? this.ineg() : this;
            }),
            (n.prototype.muln = function (l) {
              return this.clone().imuln(l);
            }),
            (n.prototype.sqr = function () {
              return this.mul(this);
            }),
            (n.prototype.isqr = function () {
              return this.imul(this.clone());
            }),
            (n.prototype.pow = function (l) {
              var d = R(l);
              if (d.length === 0) return new n(1);
              for (var g = this, w = 0; w < d.length && d[w] === 0; w++, g = g.sqr());
              if (++w < d.length)
                for (var M = g.sqr(); w < d.length; w++, M = M.sqr()) d[w] !== 0 && (g = g.mul(M));
              return g;
            }),
            (n.prototype.iushln = function (l) {
              r(typeof l == 'number' && l >= 0);
              var d = l % 26,
                g = (l - d) / 26,
                w = (67108863 >>> (26 - d)) << (26 - d),
                M;
              if (d !== 0) {
                var v = 0;
                for (M = 0; M < this.length; M++) {
                  var a = this.words[M] & w,
                    b = ((this.words[M] | 0) - a) << d;
                  (this.words[M] = b | v), (v = a >>> (26 - d));
                }
                v && ((this.words[M] = v), this.length++);
              }
              if (g !== 0) {
                for (M = this.length - 1; M >= 0; M--) this.words[M + g] = this.words[M];
                for (M = 0; M < g; M++) this.words[M] = 0;
                this.length += g;
              }
              return this._strip();
            }),
            (n.prototype.ishln = function (l) {
              return r(this.negative === 0), this.iushln(l);
            }),
            (n.prototype.iushrn = function (l, d, g) {
              r(typeof l == 'number' && l >= 0);
              var w;
              d ? (w = (d - (d % 26)) / 26) : (w = 0);
              var M = l % 26,
                v = Math.min((l - M) / 26, this.length),
                a = 67108863 ^ ((67108863 >>> M) << M),
                b = g;
              if (((w -= v), (w = Math.max(0, w)), b)) {
                for (var k = 0; k < v; k++) b.words[k] = this.words[k];
                b.length = v;
              }
              if (v !== 0)
                if (this.length > v)
                  for (this.length -= v, k = 0; k < this.length; k++)
                    this.words[k] = this.words[k + v];
                else (this.words[0] = 0), (this.length = 1);
              var B = 0;
              for (k = this.length - 1; k >= 0 && (B !== 0 || k >= w); k--) {
                var F = this.words[k] | 0;
                (this.words[k] = (B << (26 - M)) | (F >>> M)), (B = F & a);
              }
              return (
                b && B !== 0 && (b.words[b.length++] = B),
                this.length === 0 && ((this.words[0] = 0), (this.length = 1)),
                this._strip()
              );
            }),
            (n.prototype.ishrn = function (l, d, g) {
              return r(this.negative === 0), this.iushrn(l, d, g);
            }),
            (n.prototype.shln = function (l) {
              return this.clone().ishln(l);
            }),
            (n.prototype.ushln = function (l) {
              return this.clone().iushln(l);
            }),
            (n.prototype.shrn = function (l) {
              return this.clone().ishrn(l);
            }),
            (n.prototype.ushrn = function (l) {
              return this.clone().iushrn(l);
            }),
            (n.prototype.testn = function (l) {
              r(typeof l == 'number' && l >= 0);
              var d = l % 26,
                g = (l - d) / 26,
                w = 1 << d;
              if (this.length <= g) return !1;
              var M = this.words[g];
              return !!(M & w);
            }),
            (n.prototype.imaskn = function (l) {
              r(typeof l == 'number' && l >= 0);
              var d = l % 26,
                g = (l - d) / 26;
              if (
                (r(this.negative === 0, 'imaskn works only with positive numbers'),
                this.length <= g)
              )
                return this;
              if ((d !== 0 && g++, (this.length = Math.min(g, this.length)), d !== 0)) {
                var w = 67108863 ^ ((67108863 >>> d) << d);
                this.words[this.length - 1] &= w;
              }
              return this._strip();
            }),
            (n.prototype.maskn = function (l) {
              return this.clone().imaskn(l);
            }),
            (n.prototype.iaddn = function (l) {
              return (
                r(typeof l == 'number'),
                r(l < 67108864),
                l < 0
                  ? this.isubn(-l)
                  : this.negative !== 0
                    ? this.length === 1 && (this.words[0] | 0) <= l
                      ? ((this.words[0] = l - (this.words[0] | 0)), (this.negative = 0), this)
                      : ((this.negative = 0), this.isubn(l), (this.negative = 1), this)
                    : this._iaddn(l)
              );
            }),
            (n.prototype._iaddn = function (l) {
              this.words[0] += l;
              for (var d = 0; d < this.length && this.words[d] >= 67108864; d++)
                (this.words[d] -= 67108864),
                  d === this.length - 1 ? (this.words[d + 1] = 1) : this.words[d + 1]++;
              return (this.length = Math.max(this.length, d + 1)), this;
            }),
            (n.prototype.isubn = function (l) {
              if ((r(typeof l == 'number'), r(l < 67108864), l < 0)) return this.iaddn(-l);
              if (this.negative !== 0)
                return (this.negative = 0), this.iaddn(l), (this.negative = 1), this;
              if (((this.words[0] -= l), this.length === 1 && this.words[0] < 0))
                (this.words[0] = -this.words[0]), (this.negative = 1);
              else
                for (var d = 0; d < this.length && this.words[d] < 0; d++)
                  (this.words[d] += 67108864), (this.words[d + 1] -= 1);
              return this._strip();
            }),
            (n.prototype.addn = function (l) {
              return this.clone().iaddn(l);
            }),
            (n.prototype.subn = function (l) {
              return this.clone().isubn(l);
            }),
            (n.prototype.iabs = function () {
              return (this.negative = 0), this;
            }),
            (n.prototype.abs = function () {
              return this.clone().iabs();
            }),
            (n.prototype._ishlnsubmul = function (l, d, g) {
              var w = l.length + g,
                M;
              this._expand(w);
              var v,
                a = 0;
              for (M = 0; M < l.length; M++) {
                v = (this.words[M + g] | 0) + a;
                var b = (l.words[M] | 0) * d;
                (v -= b & 67108863),
                  (a = (v >> 26) - ((b / 67108864) | 0)),
                  (this.words[M + g] = v & 67108863);
              }
              for (; M < this.length - g; M++)
                (v = (this.words[M + g] | 0) + a),
                  (a = v >> 26),
                  (this.words[M + g] = v & 67108863);
              if (a === 0) return this._strip();
              for (r(a === -1), a = 0, M = 0; M < this.length; M++)
                (v = -(this.words[M] | 0) + a), (a = v >> 26), (this.words[M] = v & 67108863);
              return (this.negative = 1), this._strip();
            }),
            (n.prototype._wordDiv = function (l, d) {
              var g = this.length - l.length,
                w = this.clone(),
                M = l,
                v = M.words[M.length - 1] | 0,
                a = this._countBits(v);
              (g = 26 - a),
                g !== 0 && ((M = M.ushln(g)), w.iushln(g), (v = M.words[M.length - 1] | 0));
              var b = w.length - M.length,
                k;
              if (d !== 'mod') {
                (k = new n(null)), (k.length = b + 1), (k.words = new Array(k.length));
                for (var B = 0; B < k.length; B++) k.words[B] = 0;
              }
              var F = w.clone()._ishlnsubmul(M, 1, b);
              F.negative === 0 && ((w = F), k && (k.words[b] = 1));
              for (var P = b - 1; P >= 0; P--) {
                var C = (w.words[M.length + P] | 0) * 67108864 + (w.words[M.length + P - 1] | 0);
                for (
                  C = Math.min((C / v) | 0, 67108863), w._ishlnsubmul(M, C, P);
                  w.negative !== 0;

                )
                  C--, (w.negative = 0), w._ishlnsubmul(M, 1, P), w.isZero() || (w.negative ^= 1);
                k && (k.words[P] = C);
              }
              return (
                k && k._strip(),
                w._strip(),
                d !== 'div' && g !== 0 && w.iushrn(g),
                { div: k || null, mod: w }
              );
            }),
            (n.prototype.divmod = function (l, d, g) {
              if ((r(!l.isZero()), this.isZero())) return { div: new n(0), mod: new n(0) };
              var w, M, v;
              return this.negative !== 0 && l.negative === 0
                ? ((v = this.neg().divmod(l, d)),
                  d !== 'mod' && (w = v.div.neg()),
                  d !== 'div' && ((M = v.mod.neg()), g && M.negative !== 0 && M.iadd(l)),
                  { div: w, mod: M })
                : this.negative === 0 && l.negative !== 0
                  ? ((v = this.divmod(l.neg(), d)),
                    d !== 'mod' && (w = v.div.neg()),
                    { div: w, mod: v.mod })
                  : this.negative & l.negative
                    ? ((v = this.neg().divmod(l.neg(), d)),
                      d !== 'div' && ((M = v.mod.neg()), g && M.negative !== 0 && M.isub(l)),
                      { div: v.div, mod: M })
                    : l.length > this.length || this.cmp(l) < 0
                      ? { div: new n(0), mod: this }
                      : l.length === 1
                        ? d === 'div'
                          ? { div: this.divn(l.words[0]), mod: null }
                          : d === 'mod'
                            ? { div: null, mod: new n(this.modrn(l.words[0])) }
                            : { div: this.divn(l.words[0]), mod: new n(this.modrn(l.words[0])) }
                        : this._wordDiv(l, d);
            }),
            (n.prototype.div = function (l) {
              return this.divmod(l, 'div', !1).div;
            }),
            (n.prototype.mod = function (l) {
              return this.divmod(l, 'mod', !1).mod;
            }),
            (n.prototype.umod = function (l) {
              return this.divmod(l, 'mod', !0).mod;
            }),
            (n.prototype.divRound = function (l) {
              var d = this.divmod(l);
              if (d.mod.isZero()) return d.div;
              var g = d.div.negative !== 0 ? d.mod.isub(l) : d.mod,
                w = l.ushrn(1),
                M = l.andln(1),
                v = g.cmp(w);
              return v < 0 || (M === 1 && v === 0)
                ? d.div
                : d.div.negative !== 0
                  ? d.div.isubn(1)
                  : d.div.iaddn(1);
            }),
            (n.prototype.modrn = function (l) {
              var d = l < 0;
              d && (l = -l), r(l <= 67108863);
              for (var g = (1 << 26) % l, w = 0, M = this.length - 1; M >= 0; M--)
                w = (g * w + (this.words[M] | 0)) % l;
              return d ? -w : w;
            }),
            (n.prototype.modn = function (l) {
              return this.modrn(l);
            }),
            (n.prototype.idivn = function (l) {
              var d = l < 0;
              d && (l = -l), r(l <= 67108863);
              for (var g = 0, w = this.length - 1; w >= 0; w--) {
                var M = (this.words[w] | 0) + g * 67108864;
                (this.words[w] = (M / l) | 0), (g = M % l);
              }
              return this._strip(), d ? this.ineg() : this;
            }),
            (n.prototype.divn = function (l) {
              return this.clone().idivn(l);
            }),
            (n.prototype.egcd = function (l) {
              r(l.negative === 0), r(!l.isZero());
              var d = this,
                g = l.clone();
              d.negative !== 0 ? (d = d.umod(l)) : (d = d.clone());
              for (
                var w = new n(1), M = new n(0), v = new n(0), a = new n(1), b = 0;
                d.isEven() && g.isEven();

              )
                d.iushrn(1), g.iushrn(1), ++b;
              for (var k = g.clone(), B = d.clone(); !d.isZero(); ) {
                for (var F = 0, P = 1; !(d.words[0] & P) && F < 26; ++F, P <<= 1);
                if (F > 0)
                  for (d.iushrn(F); F-- > 0; )
                    (w.isOdd() || M.isOdd()) && (w.iadd(k), M.isub(B)), w.iushrn(1), M.iushrn(1);
                for (var C = 0, z = 1; !(g.words[0] & z) && C < 26; ++C, z <<= 1);
                if (C > 0)
                  for (g.iushrn(C); C-- > 0; )
                    (v.isOdd() || a.isOdd()) && (v.iadd(k), a.isub(B)), v.iushrn(1), a.iushrn(1);
                d.cmp(g) >= 0
                  ? (d.isub(g), w.isub(v), M.isub(a))
                  : (g.isub(d), v.isub(w), a.isub(M));
              }
              return { a: v, b: a, gcd: g.iushln(b) };
            }),
            (n.prototype._invmp = function (l) {
              r(l.negative === 0), r(!l.isZero());
              var d = this,
                g = l.clone();
              d.negative !== 0 ? (d = d.umod(l)) : (d = d.clone());
              for (
                var w = new n(1), M = new n(0), v = g.clone();
                d.cmpn(1) > 0 && g.cmpn(1) > 0;

              ) {
                for (var a = 0, b = 1; !(d.words[0] & b) && a < 26; ++a, b <<= 1);
                if (a > 0) for (d.iushrn(a); a-- > 0; ) w.isOdd() && w.iadd(v), w.iushrn(1);
                for (var k = 0, B = 1; !(g.words[0] & B) && k < 26; ++k, B <<= 1);
                if (k > 0) for (g.iushrn(k); k-- > 0; ) M.isOdd() && M.iadd(v), M.iushrn(1);
                d.cmp(g) >= 0 ? (d.isub(g), w.isub(M)) : (g.isub(d), M.isub(w));
              }
              var F;
              return d.cmpn(1) === 0 ? (F = w) : (F = M), F.cmpn(0) < 0 && F.iadd(l), F;
            }),
            (n.prototype.gcd = function (l) {
              if (this.isZero()) return l.abs();
              if (l.isZero()) return this.abs();
              var d = this.clone(),
                g = l.clone();
              (d.negative = 0), (g.negative = 0);
              for (var w = 0; d.isEven() && g.isEven(); w++) d.iushrn(1), g.iushrn(1);
              do {
                for (; d.isEven(); ) d.iushrn(1);
                for (; g.isEven(); ) g.iushrn(1);
                var M = d.cmp(g);
                if (M < 0) {
                  var v = d;
                  (d = g), (g = v);
                } else if (M === 0 || g.cmpn(1) === 0) break;
                d.isub(g);
              } while (!0);
              return g.iushln(w);
            }),
            (n.prototype.invm = function (l) {
              return this.egcd(l).a.umod(l);
            }),
            (n.prototype.isEven = function () {
              return (this.words[0] & 1) === 0;
            }),
            (n.prototype.isOdd = function () {
              return (this.words[0] & 1) === 1;
            }),
            (n.prototype.andln = function (l) {
              return this.words[0] & l;
            }),
            (n.prototype.bincn = function (l) {
              r(typeof l == 'number');
              var d = l % 26,
                g = (l - d) / 26,
                w = 1 << d;
              if (this.length <= g) return this._expand(g + 1), (this.words[g] |= w), this;
              for (var M = w, v = g; M !== 0 && v < this.length; v++) {
                var a = this.words[v] | 0;
                (a += M), (M = a >>> 26), (a &= 67108863), (this.words[v] = a);
              }
              return M !== 0 && ((this.words[v] = M), this.length++), this;
            }),
            (n.prototype.isZero = function () {
              return this.length === 1 && this.words[0] === 0;
            }),
            (n.prototype.cmpn = function (l) {
              var d = l < 0;
              if (this.negative !== 0 && !d) return -1;
              if (this.negative === 0 && d) return 1;
              this._strip();
              var g;
              if (this.length > 1) g = 1;
              else {
                d && (l = -l), r(l <= 67108863, 'Number is too big');
                var w = this.words[0] | 0;
                g = w === l ? 0 : w < l ? -1 : 1;
              }
              return this.negative !== 0 ? -g | 0 : g;
            }),
            (n.prototype.cmp = function (l) {
              if (this.negative !== 0 && l.negative === 0) return -1;
              if (this.negative === 0 && l.negative !== 0) return 1;
              var d = this.ucmp(l);
              return this.negative !== 0 ? -d | 0 : d;
            }),
            (n.prototype.ucmp = function (l) {
              if (this.length > l.length) return 1;
              if (this.length < l.length) return -1;
              for (var d = 0, g = this.length - 1; g >= 0; g--) {
                var w = this.words[g] | 0,
                  M = l.words[g] | 0;
                if (w !== M) {
                  w < M ? (d = -1) : w > M && (d = 1);
                  break;
                }
              }
              return d;
            }),
            (n.prototype.gtn = function (l) {
              return this.cmpn(l) === 1;
            }),
            (n.prototype.gt = function (l) {
              return this.cmp(l) === 1;
            }),
            (n.prototype.gten = function (l) {
              return this.cmpn(l) >= 0;
            }),
            (n.prototype.gte = function (l) {
              return this.cmp(l) >= 0;
            }),
            (n.prototype.ltn = function (l) {
              return this.cmpn(l) === -1;
            }),
            (n.prototype.lt = function (l) {
              return this.cmp(l) === -1;
            }),
            (n.prototype.lten = function (l) {
              return this.cmpn(l) <= 0;
            }),
            (n.prototype.lte = function (l) {
              return this.cmp(l) <= 0;
            }),
            (n.prototype.eqn = function (l) {
              return this.cmpn(l) === 0;
            }),
            (n.prototype.eq = function (l) {
              return this.cmp(l) === 0;
            }),
            (n.red = function (l) {
              return new S(l);
            }),
            (n.prototype.toRed = function (l) {
              return (
                r(!this.red, 'Already a number in reduction context'),
                r(this.negative === 0, 'red works only with positives'),
                l.convertTo(this)._forceRed(l)
              );
            }),
            (n.prototype.fromRed = function () {
              return (
                r(this.red, 'fromRed works only with numbers in reduction context'),
                this.red.convertFrom(this)
              );
            }),
            (n.prototype._forceRed = function (l) {
              return (this.red = l), this;
            }),
            (n.prototype.forceRed = function (l) {
              return r(!this.red, 'Already a number in reduction context'), this._forceRed(l);
            }),
            (n.prototype.redAdd = function (l) {
              return r(this.red, 'redAdd works only with red numbers'), this.red.add(this, l);
            }),
            (n.prototype.redIAdd = function (l) {
              return r(this.red, 'redIAdd works only with red numbers'), this.red.iadd(this, l);
            }),
            (n.prototype.redSub = function (l) {
              return r(this.red, 'redSub works only with red numbers'), this.red.sub(this, l);
            }),
            (n.prototype.redISub = function (l) {
              return r(this.red, 'redISub works only with red numbers'), this.red.isub(this, l);
            }),
            (n.prototype.redShl = function (l) {
              return r(this.red, 'redShl works only with red numbers'), this.red.shl(this, l);
            }),
            (n.prototype.redMul = function (l) {
              return (
                r(this.red, 'redMul works only with red numbers'),
                this.red._verify2(this, l),
                this.red.mul(this, l)
              );
            }),
            (n.prototype.redIMul = function (l) {
              return (
                r(this.red, 'redMul works only with red numbers'),
                this.red._verify2(this, l),
                this.red.imul(this, l)
              );
            }),
            (n.prototype.redSqr = function () {
              return (
                r(this.red, 'redSqr works only with red numbers'),
                this.red._verify1(this),
                this.red.sqr(this)
              );
            }),
            (n.prototype.redISqr = function () {
              return (
                r(this.red, 'redISqr works only with red numbers'),
                this.red._verify1(this),
                this.red.isqr(this)
              );
            }),
            (n.prototype.redSqrt = function () {
              return (
                r(this.red, 'redSqrt works only with red numbers'),
                this.red._verify1(this),
                this.red.sqrt(this)
              );
            }),
            (n.prototype.redInvm = function () {
              return (
                r(this.red, 'redInvm works only with red numbers'),
                this.red._verify1(this),
                this.red.invm(this)
              );
            }),
            (n.prototype.redNeg = function () {
              return (
                r(this.red, 'redNeg works only with red numbers'),
                this.red._verify1(this),
                this.red.neg(this)
              );
            }),
            (n.prototype.redPow = function (l) {
              return (
                r(this.red && !l.red, 'redPow(normalNum)'),
                this.red._verify1(this),
                this.red.pow(this, l)
              );
            });
          var V = { k256: null, p224: null, p192: null, p25519: null };
          function te(u, l) {
            (this.name = u),
              (this.p = new n(l, 16)),
              (this.n = this.p.bitLength()),
              (this.k = new n(1).iushln(this.n).isub(this.p)),
              (this.tmp = this._tmp());
          }
          (te.prototype._tmp = function () {
            var l = new n(null);
            return (l.words = new Array(Math.ceil(this.n / 13))), l;
          }),
            (te.prototype.ireduce = function (l) {
              var d = l,
                g;
              do
                this.split(d, this.tmp),
                  (d = this.imulK(d)),
                  (d = d.iadd(this.tmp)),
                  (g = d.bitLength());
              while (g > this.n);
              var w = g < this.n ? -1 : d.ucmp(this.p);
              return (
                w === 0
                  ? ((d.words[0] = 0), (d.length = 1))
                  : w > 0
                    ? d.isub(this.p)
                    : d.strip !== void 0
                      ? d.strip()
                      : d._strip(),
                d
              );
            }),
            (te.prototype.split = function (l, d) {
              l.iushrn(this.n, 0, d);
            }),
            (te.prototype.imulK = function (l) {
              return l.imul(this.k);
            });
          function ue() {
            te.call(
              this,
              'k256',
              'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f'
            );
          }
          s(ue, te),
            (ue.prototype.split = function (l, d) {
              for (var g = 4194303, w = Math.min(l.length, 9), M = 0; M < w; M++)
                d.words[M] = l.words[M];
              if (((d.length = w), l.length <= 9)) {
                (l.words[0] = 0), (l.length = 1);
                return;
              }
              var v = l.words[9];
              for (d.words[d.length++] = v & g, M = 10; M < l.length; M++) {
                var a = l.words[M] | 0;
                (l.words[M - 10] = ((a & g) << 4) | (v >>> 22)), (v = a);
              }
              (v >>>= 22),
                (l.words[M - 10] = v),
                v === 0 && l.length > 10 ? (l.length -= 10) : (l.length -= 9);
            }),
            (ue.prototype.imulK = function (l) {
              (l.words[l.length] = 0), (l.words[l.length + 1] = 0), (l.length += 2);
              for (var d = 0, g = 0; g < l.length; g++) {
                var w = l.words[g] | 0;
                (d += w * 977), (l.words[g] = d & 67108863), (d = w * 64 + ((d / 67108864) | 0));
              }
              return (
                l.words[l.length - 1] === 0 &&
                  (l.length--, l.words[l.length - 1] === 0 && l.length--),
                l
              );
            });
          function ne() {
            te.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
          }
          s(ne, te);
          function X() {
            te.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
          }
          s(X, te);
          function Oe() {
            te.call(
              this,
              '25519',
              '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed'
            );
          }
          s(Oe, te),
            (Oe.prototype.imulK = function (l) {
              for (var d = 0, g = 0; g < l.length; g++) {
                var w = (l.words[g] | 0) * 19 + d,
                  M = w & 67108863;
                (w >>>= 26), (l.words[g] = M), (d = w);
              }
              return d !== 0 && (l.words[l.length++] = d), l;
            }),
            (n._prime = function (l) {
              if (V[l]) return V[l];
              var d;
              if (l === 'k256') d = new ue();
              else if (l === 'p224') d = new ne();
              else if (l === 'p192') d = new X();
              else if (l === 'p25519') d = new Oe();
              else throw new Error('Unknown prime ' + l);
              return (V[l] = d), d;
            });
          function S(u) {
            if (typeof u == 'string') {
              var l = n._prime(u);
              (this.m = l.p), (this.prime = l);
            } else r(u.gtn(1), 'modulus must be greater than 1'), (this.m = u), (this.prime = null);
          }
          (S.prototype._verify1 = function (l) {
            r(l.negative === 0, 'red works only with positives'),
              r(l.red, 'red works only with red numbers');
          }),
            (S.prototype._verify2 = function (l, d) {
              r((l.negative | d.negative) === 0, 'red works only with positives'),
                r(l.red && l.red === d.red, 'red works only with red numbers');
            }),
            (S.prototype.imod = function (l) {
              return this.prime
                ? this.prime.ireduce(l)._forceRed(this)
                : (p(l, l.umod(this.m)._forceRed(this)), l);
            }),
            (S.prototype.neg = function (l) {
              return l.isZero() ? l.clone() : this.m.sub(l)._forceRed(this);
            }),
            (S.prototype.add = function (l, d) {
              this._verify2(l, d);
              var g = l.add(d);
              return g.cmp(this.m) >= 0 && g.isub(this.m), g._forceRed(this);
            }),
            (S.prototype.iadd = function (l, d) {
              this._verify2(l, d);
              var g = l.iadd(d);
              return g.cmp(this.m) >= 0 && g.isub(this.m), g;
            }),
            (S.prototype.sub = function (l, d) {
              this._verify2(l, d);
              var g = l.sub(d);
              return g.cmpn(0) < 0 && g.iadd(this.m), g._forceRed(this);
            }),
            (S.prototype.isub = function (l, d) {
              this._verify2(l, d);
              var g = l.isub(d);
              return g.cmpn(0) < 0 && g.iadd(this.m), g;
            }),
            (S.prototype.shl = function (l, d) {
              return this._verify1(l), this.imod(l.ushln(d));
            }),
            (S.prototype.imul = function (l, d) {
              return this._verify2(l, d), this.imod(l.imul(d));
            }),
            (S.prototype.mul = function (l, d) {
              return this._verify2(l, d), this.imod(l.mul(d));
            }),
            (S.prototype.isqr = function (l) {
              return this.imul(l, l.clone());
            }),
            (S.prototype.sqr = function (l) {
              return this.mul(l, l);
            }),
            (S.prototype.sqrt = function (l) {
              if (l.isZero()) return l.clone();
              var d = this.m.andln(3);
              if ((r(d % 2 === 1), d === 3)) {
                var g = this.m.add(new n(1)).iushrn(2);
                return this.pow(l, g);
              }
              for (var w = this.m.subn(1), M = 0; !w.isZero() && w.andln(1) === 0; )
                M++, w.iushrn(1);
              r(!w.isZero());
              var v = new n(1).toRed(this),
                a = v.redNeg(),
                b = this.m.subn(1).iushrn(1),
                k = this.m.bitLength();
              for (k = new n(2 * k * k).toRed(this); this.pow(k, b).cmp(a) !== 0; ) k.redIAdd(a);
              for (
                var B = this.pow(k, w),
                  F = this.pow(l, w.addn(1).iushrn(1)),
                  P = this.pow(l, w),
                  C = M;
                P.cmp(v) !== 0;

              ) {
                for (var z = P, Y = 0; z.cmp(v) !== 0; Y++) z = z.redSqr();
                r(Y < C);
                var G = this.pow(B, new n(1).iushln(C - Y - 1));
                (F = F.redMul(G)), (B = G.redSqr()), (P = P.redMul(B)), (C = Y);
              }
              return F;
            }),
            (S.prototype.invm = function (l) {
              var d = l._invmp(this.m);
              return d.negative !== 0 ? ((d.negative = 0), this.imod(d).redNeg()) : this.imod(d);
            }),
            (S.prototype.pow = function (l, d) {
              if (d.isZero()) return new n(1).toRed(this);
              if (d.cmpn(1) === 0) return l.clone();
              var g = 4,
                w = new Array(1 << g);
              (w[0] = new n(1).toRed(this)), (w[1] = l);
              for (var M = 2; M < w.length; M++) w[M] = this.mul(w[M - 1], l);
              var v = w[0],
                a = 0,
                b = 0,
                k = d.bitLength() % 26;
              for (k === 0 && (k = 26), M = d.length - 1; M >= 0; M--) {
                for (var B = d.words[M], F = k - 1; F >= 0; F--) {
                  var P = (B >> F) & 1;
                  if ((v !== w[0] && (v = this.sqr(v)), P === 0 && a === 0)) {
                    b = 0;
                    continue;
                  }
                  (a <<= 1),
                    (a |= P),
                    b++,
                    !(b !== g && (M !== 0 || F !== 0)) &&
                      ((v = this.mul(v, w[a])), (b = 0), (a = 0));
                }
                k = 26;
              }
              return v;
            }),
            (S.prototype.convertTo = function (l) {
              var d = l.umod(this.m);
              return d === l ? d.clone() : d;
            }),
            (S.prototype.convertFrom = function (l) {
              var d = l.clone();
              return (d.red = null), d;
            }),
            (n.mont = function (l) {
              return new o(l);
            });
          function o(u) {
            S.call(this, u),
              (this.shift = this.m.bitLength()),
              this.shift % 26 !== 0 && (this.shift += 26 - (this.shift % 26)),
              (this.r = new n(1).iushln(this.shift)),
              (this.r2 = this.imod(this.r.sqr())),
              (this.rinv = this.r._invmp(this.m)),
              (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
              (this.minv = this.minv.umod(this.r)),
              (this.minv = this.r.sub(this.minv));
          }
          s(o, S),
            (o.prototype.convertTo = function (l) {
              return this.imod(l.ushln(this.shift));
            }),
            (o.prototype.convertFrom = function (l) {
              var d = this.imod(l.mul(this.rinv));
              return (d.red = null), d;
            }),
            (o.prototype.imul = function (l, d) {
              if (l.isZero() || d.isZero()) return (l.words[0] = 0), (l.length = 1), l;
              var g = l.imul(d),
                w = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                M = g.isub(w).iushrn(this.shift),
                v = M;
              return (
                M.cmp(this.m) >= 0 ? (v = M.isub(this.m)) : M.cmpn(0) < 0 && (v = M.iadd(this.m)),
                v._forceRed(this)
              );
            }),
            (o.prototype.mul = function (l, d) {
              if (l.isZero() || d.isZero()) return new n(0)._forceRed(this);
              var g = l.mul(d),
                w = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                M = g.isub(w).iushrn(this.shift),
                v = M;
              return (
                M.cmp(this.m) >= 0 ? (v = M.isub(this.m)) : M.cmpn(0) < 0 && (v = M.iadd(this.m)),
                v._forceRed(this)
              );
            }),
            (o.prototype.invm = function (l) {
              var d = this.imod(l._invmp(this.m).mul(this.r2));
              return d._forceRed(this);
            });
        })(i, se);
      })(wf)),
    wf.exports
  );
}
var Jd, xv;
function fy() {
  if (xv) return Jd;
  xv = 1;
  var i = Ko(),
    e = Ua();
  function t(n) {
    var c = r(n),
      f = c.toRed(i.mont(n.modulus)).redPow(new i(n.publicExponent)).fromRed();
    return { blinder: f, unblinder: c.invm(n.modulus) };
  }
  function r(n) {
    var c = n.modulus.byteLength(),
      f;
    do f = new i(e(c));
    while (f.cmp(n.modulus) >= 0 || !f.umod(n.prime1) || !f.umod(n.prime2));
    return f;
  }
  function s(n, c) {
    var f = t(c),
      h = c.modulus.byteLength(),
      y = new i(n).mul(f.blinder).umod(c.modulus),
      p = y.toRed(i.mont(c.prime1)),
      m = y.toRed(i.mont(c.prime2)),
      _ = c.coefficient,
      A = c.prime1,
      E = c.prime2,
      I = p.redPow(c.exponent1).fromRed(),
      R = m.redPow(c.exponent2).fromRed(),
      L = I.isub(R).imul(_).umod(A).imul(E);
    return R.iadd(L).imul(f.unblinder).umod(c.modulus).toArrayLike(Ze, 'be', h);
  }
  return (s.getr = r), (Jd = s), Jd;
}
var Xd = {};
const Pk = 'elliptic',
  Tk = '6.6.1',
  Ok = 'EC cryptography',
  Ck = 'lib/elliptic.js',
  Lk = ['lib'],
  Nk = {
    lint: 'eslint lib test',
    'lint:fix': 'npm run lint -- --fix',
    unit: 'istanbul test _mocha --reporter=spec test/index.js',
    test: 'npm run lint && npm run unit',
    version: 'grunt dist && git add dist/',
  },
  $k = { type: 'git', url: 'git@github.com:indutny/elliptic' },
  Dk = ['EC', 'Elliptic', 'curve', 'Cryptography'],
  Uk = 'Fedor Indutny <fedor@indutny.com>',
  zk = 'MIT',
  Fk = { url: 'https://github.com/indutny/elliptic/issues' },
  qk = 'https://github.com/indutny/elliptic',
  Wk = {
    brfs: '^2.0.2',
    coveralls: '^3.1.0',
    eslint: '^7.6.0',
    grunt: '^1.2.1',
    'grunt-browserify': '^5.3.0',
    'grunt-cli': '^1.3.2',
    'grunt-contrib-connect': '^3.0.0',
    'grunt-contrib-copy': '^1.0.0',
    'grunt-contrib-uglify': '^5.0.0',
    'grunt-mocha-istanbul': '^5.0.2',
    'grunt-saucelabs': '^9.0.1',
    istanbul: '^0.4.5',
    mocha: '^8.0.1',
  },
  Kk = {
    'bn.js': '^4.11.9',
    brorand: '^1.1.0',
    'hash.js': '^1.0.0',
    'hmac-drbg': '^1.0.1',
    inherits: '^2.0.4',
    'minimalistic-assert': '^1.0.1',
    'minimalistic-crypto-utils': '^1.0.1',
  },
  jk = {
    name: Pk,
    version: Tk,
    description: Ok,
    main: Ck,
    files: Lk,
    scripts: Nk,
    repository: $k,
    keywords: Dk,
    author: Uk,
    license: zk,
    bugs: Fk,
    homepage: qk,
    devDependencies: Wk,
    dependencies: Kk,
  };
var Qd = {},
  _f = { exports: {} };
_f.exports;
var Bv;
function co() {
  return (
    Bv ||
      ((Bv = 1),
      (function (i) {
        (function (e, t) {
          function r(S, o) {
            if (!S) throw new Error(o || 'Assertion failed');
          }
          function s(S, o) {
            S.super_ = o;
            var u = function () {};
            (u.prototype = o.prototype), (S.prototype = new u()), (S.prototype.constructor = S);
          }
          function n(S, o, u) {
            if (n.isBN(S)) return S;
            (this.negative = 0),
              (this.words = null),
              (this.length = 0),
              (this.red = null),
              S !== null &&
                ((o === 'le' || o === 'be') && ((u = o), (o = 10)),
                this._init(S || 0, o || 10, u || 'be'));
          }
          typeof e == 'object' ? (e.exports = n) : (t.BN = n), (n.BN = n), (n.wordSize = 26);
          var c;
          try {
            typeof window < 'u' && typeof window.Buffer < 'u'
              ? (c = window.Buffer)
              : (c = ai.Buffer);
          } catch {}
          (n.isBN = function (o) {
            return o instanceof n
              ? !0
              : o !== null &&
                  typeof o == 'object' &&
                  o.constructor.wordSize === n.wordSize &&
                  Array.isArray(o.words);
          }),
            (n.max = function (o, u) {
              return o.cmp(u) > 0 ? o : u;
            }),
            (n.min = function (o, u) {
              return o.cmp(u) < 0 ? o : u;
            }),
            (n.prototype._init = function (o, u, l) {
              if (typeof o == 'number') return this._initNumber(o, u, l);
              if (typeof o == 'object') return this._initArray(o, u, l);
              u === 'hex' && (u = 16),
                r(u === (u | 0) && u >= 2 && u <= 36),
                (o = o.toString().replace(/\s+/g, ''));
              var d = 0;
              o[0] === '-' && (d++, (this.negative = 1)),
                d < o.length &&
                  (u === 16
                    ? this._parseHex(o, d, l)
                    : (this._parseBase(o, u, d),
                      l === 'le' && this._initArray(this.toArray(), u, l)));
            }),
            (n.prototype._initNumber = function (o, u, l) {
              o < 0 && ((this.negative = 1), (o = -o)),
                o < 67108864
                  ? ((this.words = [o & 67108863]), (this.length = 1))
                  : o < 4503599627370496
                    ? ((this.words = [o & 67108863, (o / 67108864) & 67108863]), (this.length = 2))
                    : (r(o < 9007199254740992),
                      (this.words = [o & 67108863, (o / 67108864) & 67108863, 1]),
                      (this.length = 3)),
                l === 'le' && this._initArray(this.toArray(), u, l);
            }),
            (n.prototype._initArray = function (o, u, l) {
              if ((r(typeof o.length == 'number'), o.length <= 0))
                return (this.words = [0]), (this.length = 1), this;
              (this.length = Math.ceil(o.length / 3)), (this.words = new Array(this.length));
              for (var d = 0; d < this.length; d++) this.words[d] = 0;
              var g,
                w,
                M = 0;
              if (l === 'be')
                for (d = o.length - 1, g = 0; d >= 0; d -= 3)
                  (w = o[d] | (o[d - 1] << 8) | (o[d - 2] << 16)),
                    (this.words[g] |= (w << M) & 67108863),
                    (this.words[g + 1] = (w >>> (26 - M)) & 67108863),
                    (M += 24),
                    M >= 26 && ((M -= 26), g++);
              else if (l === 'le')
                for (d = 0, g = 0; d < o.length; d += 3)
                  (w = o[d] | (o[d + 1] << 8) | (o[d + 2] << 16)),
                    (this.words[g] |= (w << M) & 67108863),
                    (this.words[g + 1] = (w >>> (26 - M)) & 67108863),
                    (M += 24),
                    M >= 26 && ((M -= 26), g++);
              return this.strip();
            });
          function f(S, o) {
            var u = S.charCodeAt(o);
            return u >= 65 && u <= 70 ? u - 55 : u >= 97 && u <= 102 ? u - 87 : (u - 48) & 15;
          }
          function h(S, o, u) {
            var l = f(S, u);
            return u - 1 >= o && (l |= f(S, u - 1) << 4), l;
          }
          n.prototype._parseHex = function (o, u, l) {
            (this.length = Math.ceil((o.length - u) / 6)), (this.words = new Array(this.length));
            for (var d = 0; d < this.length; d++) this.words[d] = 0;
            var g = 0,
              w = 0,
              M;
            if (l === 'be')
              for (d = o.length - 1; d >= u; d -= 2)
                (M = h(o, u, d) << g),
                  (this.words[w] |= M & 67108863),
                  g >= 18 ? ((g -= 18), (w += 1), (this.words[w] |= M >>> 26)) : (g += 8);
            else {
              var v = o.length - u;
              for (d = v % 2 === 0 ? u + 1 : u; d < o.length; d += 2)
                (M = h(o, u, d) << g),
                  (this.words[w] |= M & 67108863),
                  g >= 18 ? ((g -= 18), (w += 1), (this.words[w] |= M >>> 26)) : (g += 8);
            }
            this.strip();
          };
          function y(S, o, u, l) {
            for (var d = 0, g = Math.min(S.length, u), w = o; w < g; w++) {
              var M = S.charCodeAt(w) - 48;
              (d *= l), M >= 49 ? (d += M - 49 + 10) : M >= 17 ? (d += M - 17 + 10) : (d += M);
            }
            return d;
          }
          (n.prototype._parseBase = function (o, u, l) {
            (this.words = [0]), (this.length = 1);
            for (var d = 0, g = 1; g <= 67108863; g *= u) d++;
            d--, (g = (g / u) | 0);
            for (
              var w = o.length - l, M = w % d, v = Math.min(w, w - M) + l, a = 0, b = l;
              b < v;
              b += d
            )
              (a = y(o, b, b + d, u)),
                this.imuln(g),
                this.words[0] + a < 67108864 ? (this.words[0] += a) : this._iaddn(a);
            if (M !== 0) {
              var k = 1;
              for (a = y(o, b, o.length, u), b = 0; b < M; b++) k *= u;
              this.imuln(k), this.words[0] + a < 67108864 ? (this.words[0] += a) : this._iaddn(a);
            }
            this.strip();
          }),
            (n.prototype.copy = function (o) {
              o.words = new Array(this.length);
              for (var u = 0; u < this.length; u++) o.words[u] = this.words[u];
              (o.length = this.length), (o.negative = this.negative), (o.red = this.red);
            }),
            (n.prototype.clone = function () {
              var o = new n(null);
              return this.copy(o), o;
            }),
            (n.prototype._expand = function (o) {
              for (; this.length < o; ) this.words[this.length++] = 0;
              return this;
            }),
            (n.prototype.strip = function () {
              for (; this.length > 1 && this.words[this.length - 1] === 0; ) this.length--;
              return this._normSign();
            }),
            (n.prototype._normSign = function () {
              return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
            }),
            (n.prototype.inspect = function () {
              return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
            });
          var p = [
              '',
              '0',
              '00',
              '000',
              '0000',
              '00000',
              '000000',
              '0000000',
              '00000000',
              '000000000',
              '0000000000',
              '00000000000',
              '000000000000',
              '0000000000000',
              '00000000000000',
              '000000000000000',
              '0000000000000000',
              '00000000000000000',
              '000000000000000000',
              '0000000000000000000',
              '00000000000000000000',
              '000000000000000000000',
              '0000000000000000000000',
              '00000000000000000000000',
              '000000000000000000000000',
              '0000000000000000000000000',
            ],
            m = [
              0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5,
              5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            ],
            _ = [
              0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721,
              1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224,
              47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907,
              17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176,
            ];
          (n.prototype.toString = function (o, u) {
            (o = o || 10), (u = u | 0 || 1);
            var l;
            if (o === 16 || o === 'hex') {
              l = '';
              for (var d = 0, g = 0, w = 0; w < this.length; w++) {
                var M = this.words[w],
                  v = (((M << d) | g) & 16777215).toString(16);
                (g = (M >>> (24 - d)) & 16777215),
                  g !== 0 || w !== this.length - 1 ? (l = p[6 - v.length] + v + l) : (l = v + l),
                  (d += 2),
                  d >= 26 && ((d -= 26), w--);
              }
              for (g !== 0 && (l = g.toString(16) + l); l.length % u !== 0; ) l = '0' + l;
              return this.negative !== 0 && (l = '-' + l), l;
            }
            if (o === (o | 0) && o >= 2 && o <= 36) {
              var a = m[o],
                b = _[o];
              l = '';
              var k = this.clone();
              for (k.negative = 0; !k.isZero(); ) {
                var B = k.modn(b).toString(o);
                (k = k.idivn(b)), k.isZero() ? (l = B + l) : (l = p[a - B.length] + B + l);
              }
              for (this.isZero() && (l = '0' + l); l.length % u !== 0; ) l = '0' + l;
              return this.negative !== 0 && (l = '-' + l), l;
            }
            r(!1, 'Base should be between 2 and 36');
          }),
            (n.prototype.toNumber = function () {
              var o = this.words[0];
              return (
                this.length === 2
                  ? (o += this.words[1] * 67108864)
                  : this.length === 3 && this.words[2] === 1
                    ? (o += 4503599627370496 + this.words[1] * 67108864)
                    : this.length > 2 && r(!1, 'Number can only safely store up to 53 bits'),
                this.negative !== 0 ? -o : o
              );
            }),
            (n.prototype.toJSON = function () {
              return this.toString(16);
            }),
            (n.prototype.toBuffer = function (o, u) {
              return r(typeof c < 'u'), this.toArrayLike(c, o, u);
            }),
            (n.prototype.toArray = function (o, u) {
              return this.toArrayLike(Array, o, u);
            }),
            (n.prototype.toArrayLike = function (o, u, l) {
              var d = this.byteLength(),
                g = l || Math.max(1, d);
              r(d <= g, 'byte array longer than desired length'),
                r(g > 0, 'Requested array length <= 0'),
                this.strip();
              var w = u === 'le',
                M = new o(g),
                v,
                a,
                b = this.clone();
              if (w) {
                for (a = 0; !b.isZero(); a++) (v = b.andln(255)), b.iushrn(8), (M[a] = v);
                for (; a < g; a++) M[a] = 0;
              } else {
                for (a = 0; a < g - d; a++) M[a] = 0;
                for (a = 0; !b.isZero(); a++) (v = b.andln(255)), b.iushrn(8), (M[g - a - 1] = v);
              }
              return M;
            }),
            Math.clz32
              ? (n.prototype._countBits = function (o) {
                  return 32 - Math.clz32(o);
                })
              : (n.prototype._countBits = function (o) {
                  var u = o,
                    l = 0;
                  return (
                    u >= 4096 && ((l += 13), (u >>>= 13)),
                    u >= 64 && ((l += 7), (u >>>= 7)),
                    u >= 8 && ((l += 4), (u >>>= 4)),
                    u >= 2 && ((l += 2), (u >>>= 2)),
                    l + u
                  );
                }),
            (n.prototype._zeroBits = function (o) {
              if (o === 0) return 26;
              var u = o,
                l = 0;
              return (
                u & 8191 || ((l += 13), (u >>>= 13)),
                u & 127 || ((l += 7), (u >>>= 7)),
                u & 15 || ((l += 4), (u >>>= 4)),
                u & 3 || ((l += 2), (u >>>= 2)),
                u & 1 || l++,
                l
              );
            }),
            (n.prototype.bitLength = function () {
              var o = this.words[this.length - 1],
                u = this._countBits(o);
              return (this.length - 1) * 26 + u;
            });
          function A(S) {
            for (var o = new Array(S.bitLength()), u = 0; u < o.length; u++) {
              var l = (u / 26) | 0,
                d = u % 26;
              o[u] = (S.words[l] & (1 << d)) >>> d;
            }
            return o;
          }
          (n.prototype.zeroBits = function () {
            if (this.isZero()) return 0;
            for (var o = 0, u = 0; u < this.length; u++) {
              var l = this._zeroBits(this.words[u]);
              if (((o += l), l !== 26)) break;
            }
            return o;
          }),
            (n.prototype.byteLength = function () {
              return Math.ceil(this.bitLength() / 8);
            }),
            (n.prototype.toTwos = function (o) {
              return this.negative !== 0 ? this.abs().inotn(o).iaddn(1) : this.clone();
            }),
            (n.prototype.fromTwos = function (o) {
              return this.testn(o - 1) ? this.notn(o).iaddn(1).ineg() : this.clone();
            }),
            (n.prototype.isNeg = function () {
              return this.negative !== 0;
            }),
            (n.prototype.neg = function () {
              return this.clone().ineg();
            }),
            (n.prototype.ineg = function () {
              return this.isZero() || (this.negative ^= 1), this;
            }),
            (n.prototype.iuor = function (o) {
              for (; this.length < o.length; ) this.words[this.length++] = 0;
              for (var u = 0; u < o.length; u++) this.words[u] = this.words[u] | o.words[u];
              return this.strip();
            }),
            (n.prototype.ior = function (o) {
              return r((this.negative | o.negative) === 0), this.iuor(o);
            }),
            (n.prototype.or = function (o) {
              return this.length > o.length ? this.clone().ior(o) : o.clone().ior(this);
            }),
            (n.prototype.uor = function (o) {
              return this.length > o.length ? this.clone().iuor(o) : o.clone().iuor(this);
            }),
            (n.prototype.iuand = function (o) {
              var u;
              this.length > o.length ? (u = o) : (u = this);
              for (var l = 0; l < u.length; l++) this.words[l] = this.words[l] & o.words[l];
              return (this.length = u.length), this.strip();
            }),
            (n.prototype.iand = function (o) {
              return r((this.negative | o.negative) === 0), this.iuand(o);
            }),
            (n.prototype.and = function (o) {
              return this.length > o.length ? this.clone().iand(o) : o.clone().iand(this);
            }),
            (n.prototype.uand = function (o) {
              return this.length > o.length ? this.clone().iuand(o) : o.clone().iuand(this);
            }),
            (n.prototype.iuxor = function (o) {
              var u, l;
              this.length > o.length ? ((u = this), (l = o)) : ((u = o), (l = this));
              for (var d = 0; d < l.length; d++) this.words[d] = u.words[d] ^ l.words[d];
              if (this !== u) for (; d < u.length; d++) this.words[d] = u.words[d];
              return (this.length = u.length), this.strip();
            }),
            (n.prototype.ixor = function (o) {
              return r((this.negative | o.negative) === 0), this.iuxor(o);
            }),
            (n.prototype.xor = function (o) {
              return this.length > o.length ? this.clone().ixor(o) : o.clone().ixor(this);
            }),
            (n.prototype.uxor = function (o) {
              return this.length > o.length ? this.clone().iuxor(o) : o.clone().iuxor(this);
            }),
            (n.prototype.inotn = function (o) {
              r(typeof o == 'number' && o >= 0);
              var u = Math.ceil(o / 26) | 0,
                l = o % 26;
              this._expand(u), l > 0 && u--;
              for (var d = 0; d < u; d++) this.words[d] = ~this.words[d] & 67108863;
              return (
                l > 0 && (this.words[d] = ~this.words[d] & (67108863 >> (26 - l))), this.strip()
              );
            }),
            (n.prototype.notn = function (o) {
              return this.clone().inotn(o);
            }),
            (n.prototype.setn = function (o, u) {
              r(typeof o == 'number' && o >= 0);
              var l = (o / 26) | 0,
                d = o % 26;
              return (
                this._expand(l + 1),
                u
                  ? (this.words[l] = this.words[l] | (1 << d))
                  : (this.words[l] = this.words[l] & ~(1 << d)),
                this.strip()
              );
            }),
            (n.prototype.iadd = function (o) {
              var u;
              if (this.negative !== 0 && o.negative === 0)
                return (
                  (this.negative = 0), (u = this.isub(o)), (this.negative ^= 1), this._normSign()
                );
              if (this.negative === 0 && o.negative !== 0)
                return (o.negative = 0), (u = this.isub(o)), (o.negative = 1), u._normSign();
              var l, d;
              this.length > o.length ? ((l = this), (d = o)) : ((l = o), (d = this));
              for (var g = 0, w = 0; w < d.length; w++)
                (u = (l.words[w] | 0) + (d.words[w] | 0) + g),
                  (this.words[w] = u & 67108863),
                  (g = u >>> 26);
              for (; g !== 0 && w < l.length; w++)
                (u = (l.words[w] | 0) + g), (this.words[w] = u & 67108863), (g = u >>> 26);
              if (((this.length = l.length), g !== 0)) (this.words[this.length] = g), this.length++;
              else if (l !== this) for (; w < l.length; w++) this.words[w] = l.words[w];
              return this;
            }),
            (n.prototype.add = function (o) {
              var u;
              return o.negative !== 0 && this.negative === 0
                ? ((o.negative = 0), (u = this.sub(o)), (o.negative ^= 1), u)
                : o.negative === 0 && this.negative !== 0
                  ? ((this.negative = 0), (u = o.sub(this)), (this.negative = 1), u)
                  : this.length > o.length
                    ? this.clone().iadd(o)
                    : o.clone().iadd(this);
            }),
            (n.prototype.isub = function (o) {
              if (o.negative !== 0) {
                o.negative = 0;
                var u = this.iadd(o);
                return (o.negative = 1), u._normSign();
              } else if (this.negative !== 0)
                return (this.negative = 0), this.iadd(o), (this.negative = 1), this._normSign();
              var l = this.cmp(o);
              if (l === 0) return (this.negative = 0), (this.length = 1), (this.words[0] = 0), this;
              var d, g;
              l > 0 ? ((d = this), (g = o)) : ((d = o), (g = this));
              for (var w = 0, M = 0; M < g.length; M++)
                (u = (d.words[M] | 0) - (g.words[M] | 0) + w),
                  (w = u >> 26),
                  (this.words[M] = u & 67108863);
              for (; w !== 0 && M < d.length; M++)
                (u = (d.words[M] | 0) + w), (w = u >> 26), (this.words[M] = u & 67108863);
              if (w === 0 && M < d.length && d !== this)
                for (; M < d.length; M++) this.words[M] = d.words[M];
              return (
                (this.length = Math.max(this.length, M)),
                d !== this && (this.negative = 1),
                this.strip()
              );
            }),
            (n.prototype.sub = function (o) {
              return this.clone().isub(o);
            });
          function E(S, o, u) {
            u.negative = o.negative ^ S.negative;
            var l = (S.length + o.length) | 0;
            (u.length = l), (l = (l - 1) | 0);
            var d = S.words[0] | 0,
              g = o.words[0] | 0,
              w = d * g,
              M = w & 67108863,
              v = (w / 67108864) | 0;
            u.words[0] = M;
            for (var a = 1; a < l; a++) {
              for (
                var b = v >>> 26,
                  k = v & 67108863,
                  B = Math.min(a, o.length - 1),
                  F = Math.max(0, a - S.length + 1);
                F <= B;
                F++
              ) {
                var P = (a - F) | 0;
                (d = S.words[P] | 0),
                  (g = o.words[F] | 0),
                  (w = d * g + k),
                  (b += (w / 67108864) | 0),
                  (k = w & 67108863);
              }
              (u.words[a] = k | 0), (v = b | 0);
            }
            return v !== 0 ? (u.words[a] = v | 0) : u.length--, u.strip();
          }
          var I = function (o, u, l) {
            var d = o.words,
              g = u.words,
              w = l.words,
              M = 0,
              v,
              a,
              b,
              k = d[0] | 0,
              B = k & 8191,
              F = k >>> 13,
              P = d[1] | 0,
              C = P & 8191,
              z = P >>> 13,
              Y = d[2] | 0,
              G = Y & 8191,
              Q = Y >>> 13,
              U = d[3] | 0,
              $ = U & 8191,
              Z = U >>> 13,
              ae = d[4] | 0,
              fe = ae & 8191,
              le = ae >>> 13,
              Fe = d[5] | 0,
              be = Fe & 8191,
              oe = Fe >>> 13,
              rt = d[6] | 0,
              me = rt & 8191,
              re = rt >>> 13,
              ge = d[7] | 0,
              ce = ge & 8191,
              he = ge >>> 13,
              Ke = d[8] | 0,
              K = Ke & 8191,
              O = Ke >>> 13,
              W = d[9] | 0,
              T = W & 8191,
              x = W >>> 13,
              N = g[0] | 0,
              j = N & 8191,
              J = N >>> 13,
              de = g[1] | 0,
              ie = de & 8191,
              ye = de >>> 13,
              Ye = g[2] | 0,
              ve = Ye & 8191,
              _e = Ye >>> 13,
              et = g[3] | 0,
              Me = et & 8191,
              Ce = et >>> 13,
              yt = g[4] | 0,
              Ae = yt & 8191,
              Le = yt >>> 13,
              gt = g[5] | 0,
              Ee = gt & 8191,
              Ne = gt >>> 13,
              bt = g[6] | 0,
              ke = bt & 8191,
              $e = bt >>> 13,
              vt = g[7] | 0,
              Ie = vt & 8191,
              De = vt >>> 13,
              mt = g[8] | 0,
              xe = mt & 8191,
              Ue = mt >>> 13,
              wt = g[9] | 0,
              Be = wt & 8191,
              ze = wt >>> 13;
            (l.negative = o.negative ^ u.negative),
              (l.length = 19),
              (v = Math.imul(B, j)),
              (a = Math.imul(B, J)),
              (a = (a + Math.imul(F, j)) | 0),
              (b = Math.imul(F, J));
            var st = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (st >>> 26)) | 0),
              (st &= 67108863),
              (v = Math.imul(C, j)),
              (a = Math.imul(C, J)),
              (a = (a + Math.imul(z, j)) | 0),
              (b = Math.imul(z, J)),
              (v = (v + Math.imul(B, ie)) | 0),
              (a = (a + Math.imul(B, ye)) | 0),
              (a = (a + Math.imul(F, ie)) | 0),
              (b = (b + Math.imul(F, ye)) | 0);
            var at = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (at >>> 26)) | 0),
              (at &= 67108863),
              (v = Math.imul(G, j)),
              (a = Math.imul(G, J)),
              (a = (a + Math.imul(Q, j)) | 0),
              (b = Math.imul(Q, J)),
              (v = (v + Math.imul(C, ie)) | 0),
              (a = (a + Math.imul(C, ye)) | 0),
              (a = (a + Math.imul(z, ie)) | 0),
              (b = (b + Math.imul(z, ye)) | 0),
              (v = (v + Math.imul(B, ve)) | 0),
              (a = (a + Math.imul(B, _e)) | 0),
              (a = (a + Math.imul(F, ve)) | 0),
              (b = (b + Math.imul(F, _e)) | 0);
            var Ft = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (Ft >>> 26)) | 0),
              (Ft &= 67108863),
              (v = Math.imul($, j)),
              (a = Math.imul($, J)),
              (a = (a + Math.imul(Z, j)) | 0),
              (b = Math.imul(Z, J)),
              (v = (v + Math.imul(G, ie)) | 0),
              (a = (a + Math.imul(G, ye)) | 0),
              (a = (a + Math.imul(Q, ie)) | 0),
              (b = (b + Math.imul(Q, ye)) | 0),
              (v = (v + Math.imul(C, ve)) | 0),
              (a = (a + Math.imul(C, _e)) | 0),
              (a = (a + Math.imul(z, ve)) | 0),
              (b = (b + Math.imul(z, _e)) | 0),
              (v = (v + Math.imul(B, Me)) | 0),
              (a = (a + Math.imul(B, Ce)) | 0),
              (a = (a + Math.imul(F, Me)) | 0),
              (b = (b + Math.imul(F, Ce)) | 0);
            var qt = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (qt >>> 26)) | 0),
              (qt &= 67108863),
              (v = Math.imul(fe, j)),
              (a = Math.imul(fe, J)),
              (a = (a + Math.imul(le, j)) | 0),
              (b = Math.imul(le, J)),
              (v = (v + Math.imul($, ie)) | 0),
              (a = (a + Math.imul($, ye)) | 0),
              (a = (a + Math.imul(Z, ie)) | 0),
              (b = (b + Math.imul(Z, ye)) | 0),
              (v = (v + Math.imul(G, ve)) | 0),
              (a = (a + Math.imul(G, _e)) | 0),
              (a = (a + Math.imul(Q, ve)) | 0),
              (b = (b + Math.imul(Q, _e)) | 0),
              (v = (v + Math.imul(C, Me)) | 0),
              (a = (a + Math.imul(C, Ce)) | 0),
              (a = (a + Math.imul(z, Me)) | 0),
              (b = (b + Math.imul(z, Ce)) | 0),
              (v = (v + Math.imul(B, Ae)) | 0),
              (a = (a + Math.imul(B, Le)) | 0),
              (a = (a + Math.imul(F, Ae)) | 0),
              (b = (b + Math.imul(F, Le)) | 0);
            var Wt = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (Wt >>> 26)) | 0),
              (Wt &= 67108863),
              (v = Math.imul(be, j)),
              (a = Math.imul(be, J)),
              (a = (a + Math.imul(oe, j)) | 0),
              (b = Math.imul(oe, J)),
              (v = (v + Math.imul(fe, ie)) | 0),
              (a = (a + Math.imul(fe, ye)) | 0),
              (a = (a + Math.imul(le, ie)) | 0),
              (b = (b + Math.imul(le, ye)) | 0),
              (v = (v + Math.imul($, ve)) | 0),
              (a = (a + Math.imul($, _e)) | 0),
              (a = (a + Math.imul(Z, ve)) | 0),
              (b = (b + Math.imul(Z, _e)) | 0),
              (v = (v + Math.imul(G, Me)) | 0),
              (a = (a + Math.imul(G, Ce)) | 0),
              (a = (a + Math.imul(Q, Me)) | 0),
              (b = (b + Math.imul(Q, Ce)) | 0),
              (v = (v + Math.imul(C, Ae)) | 0),
              (a = (a + Math.imul(C, Le)) | 0),
              (a = (a + Math.imul(z, Ae)) | 0),
              (b = (b + Math.imul(z, Le)) | 0),
              (v = (v + Math.imul(B, Ee)) | 0),
              (a = (a + Math.imul(B, Ne)) | 0),
              (a = (a + Math.imul(F, Ee)) | 0),
              (b = (b + Math.imul(F, Ne)) | 0);
            var Kt = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (Kt >>> 26)) | 0),
              (Kt &= 67108863),
              (v = Math.imul(me, j)),
              (a = Math.imul(me, J)),
              (a = (a + Math.imul(re, j)) | 0),
              (b = Math.imul(re, J)),
              (v = (v + Math.imul(be, ie)) | 0),
              (a = (a + Math.imul(be, ye)) | 0),
              (a = (a + Math.imul(oe, ie)) | 0),
              (b = (b + Math.imul(oe, ye)) | 0),
              (v = (v + Math.imul(fe, ve)) | 0),
              (a = (a + Math.imul(fe, _e)) | 0),
              (a = (a + Math.imul(le, ve)) | 0),
              (b = (b + Math.imul(le, _e)) | 0),
              (v = (v + Math.imul($, Me)) | 0),
              (a = (a + Math.imul($, Ce)) | 0),
              (a = (a + Math.imul(Z, Me)) | 0),
              (b = (b + Math.imul(Z, Ce)) | 0),
              (v = (v + Math.imul(G, Ae)) | 0),
              (a = (a + Math.imul(G, Le)) | 0),
              (a = (a + Math.imul(Q, Ae)) | 0),
              (b = (b + Math.imul(Q, Le)) | 0),
              (v = (v + Math.imul(C, Ee)) | 0),
              (a = (a + Math.imul(C, Ne)) | 0),
              (a = (a + Math.imul(z, Ee)) | 0),
              (b = (b + Math.imul(z, Ne)) | 0),
              (v = (v + Math.imul(B, ke)) | 0),
              (a = (a + Math.imul(B, $e)) | 0),
              (a = (a + Math.imul(F, ke)) | 0),
              (b = (b + Math.imul(F, $e)) | 0);
            var jt = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (jt >>> 26)) | 0),
              (jt &= 67108863),
              (v = Math.imul(ce, j)),
              (a = Math.imul(ce, J)),
              (a = (a + Math.imul(he, j)) | 0),
              (b = Math.imul(he, J)),
              (v = (v + Math.imul(me, ie)) | 0),
              (a = (a + Math.imul(me, ye)) | 0),
              (a = (a + Math.imul(re, ie)) | 0),
              (b = (b + Math.imul(re, ye)) | 0),
              (v = (v + Math.imul(be, ve)) | 0),
              (a = (a + Math.imul(be, _e)) | 0),
              (a = (a + Math.imul(oe, ve)) | 0),
              (b = (b + Math.imul(oe, _e)) | 0),
              (v = (v + Math.imul(fe, Me)) | 0),
              (a = (a + Math.imul(fe, Ce)) | 0),
              (a = (a + Math.imul(le, Me)) | 0),
              (b = (b + Math.imul(le, Ce)) | 0),
              (v = (v + Math.imul($, Ae)) | 0),
              (a = (a + Math.imul($, Le)) | 0),
              (a = (a + Math.imul(Z, Ae)) | 0),
              (b = (b + Math.imul(Z, Le)) | 0),
              (v = (v + Math.imul(G, Ee)) | 0),
              (a = (a + Math.imul(G, Ne)) | 0),
              (a = (a + Math.imul(Q, Ee)) | 0),
              (b = (b + Math.imul(Q, Ne)) | 0),
              (v = (v + Math.imul(C, ke)) | 0),
              (a = (a + Math.imul(C, $e)) | 0),
              (a = (a + Math.imul(z, ke)) | 0),
              (b = (b + Math.imul(z, $e)) | 0),
              (v = (v + Math.imul(B, Ie)) | 0),
              (a = (a + Math.imul(B, De)) | 0),
              (a = (a + Math.imul(F, Ie)) | 0),
              (b = (b + Math.imul(F, De)) | 0);
            var fr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (fr >>> 26)) | 0),
              (fr &= 67108863),
              (v = Math.imul(K, j)),
              (a = Math.imul(K, J)),
              (a = (a + Math.imul(O, j)) | 0),
              (b = Math.imul(O, J)),
              (v = (v + Math.imul(ce, ie)) | 0),
              (a = (a + Math.imul(ce, ye)) | 0),
              (a = (a + Math.imul(he, ie)) | 0),
              (b = (b + Math.imul(he, ye)) | 0),
              (v = (v + Math.imul(me, ve)) | 0),
              (a = (a + Math.imul(me, _e)) | 0),
              (a = (a + Math.imul(re, ve)) | 0),
              (b = (b + Math.imul(re, _e)) | 0),
              (v = (v + Math.imul(be, Me)) | 0),
              (a = (a + Math.imul(be, Ce)) | 0),
              (a = (a + Math.imul(oe, Me)) | 0),
              (b = (b + Math.imul(oe, Ce)) | 0),
              (v = (v + Math.imul(fe, Ae)) | 0),
              (a = (a + Math.imul(fe, Le)) | 0),
              (a = (a + Math.imul(le, Ae)) | 0),
              (b = (b + Math.imul(le, Le)) | 0),
              (v = (v + Math.imul($, Ee)) | 0),
              (a = (a + Math.imul($, Ne)) | 0),
              (a = (a + Math.imul(Z, Ee)) | 0),
              (b = (b + Math.imul(Z, Ne)) | 0),
              (v = (v + Math.imul(G, ke)) | 0),
              (a = (a + Math.imul(G, $e)) | 0),
              (a = (a + Math.imul(Q, ke)) | 0),
              (b = (b + Math.imul(Q, $e)) | 0),
              (v = (v + Math.imul(C, Ie)) | 0),
              (a = (a + Math.imul(C, De)) | 0),
              (a = (a + Math.imul(z, Ie)) | 0),
              (b = (b + Math.imul(z, De)) | 0),
              (v = (v + Math.imul(B, xe)) | 0),
              (a = (a + Math.imul(B, Ue)) | 0),
              (a = (a + Math.imul(F, xe)) | 0),
              (b = (b + Math.imul(F, Ue)) | 0);
            var lr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (lr >>> 26)) | 0),
              (lr &= 67108863),
              (v = Math.imul(T, j)),
              (a = Math.imul(T, J)),
              (a = (a + Math.imul(x, j)) | 0),
              (b = Math.imul(x, J)),
              (v = (v + Math.imul(K, ie)) | 0),
              (a = (a + Math.imul(K, ye)) | 0),
              (a = (a + Math.imul(O, ie)) | 0),
              (b = (b + Math.imul(O, ye)) | 0),
              (v = (v + Math.imul(ce, ve)) | 0),
              (a = (a + Math.imul(ce, _e)) | 0),
              (a = (a + Math.imul(he, ve)) | 0),
              (b = (b + Math.imul(he, _e)) | 0),
              (v = (v + Math.imul(me, Me)) | 0),
              (a = (a + Math.imul(me, Ce)) | 0),
              (a = (a + Math.imul(re, Me)) | 0),
              (b = (b + Math.imul(re, Ce)) | 0),
              (v = (v + Math.imul(be, Ae)) | 0),
              (a = (a + Math.imul(be, Le)) | 0),
              (a = (a + Math.imul(oe, Ae)) | 0),
              (b = (b + Math.imul(oe, Le)) | 0),
              (v = (v + Math.imul(fe, Ee)) | 0),
              (a = (a + Math.imul(fe, Ne)) | 0),
              (a = (a + Math.imul(le, Ee)) | 0),
              (b = (b + Math.imul(le, Ne)) | 0),
              (v = (v + Math.imul($, ke)) | 0),
              (a = (a + Math.imul($, $e)) | 0),
              (a = (a + Math.imul(Z, ke)) | 0),
              (b = (b + Math.imul(Z, $e)) | 0),
              (v = (v + Math.imul(G, Ie)) | 0),
              (a = (a + Math.imul(G, De)) | 0),
              (a = (a + Math.imul(Q, Ie)) | 0),
              (b = (b + Math.imul(Q, De)) | 0),
              (v = (v + Math.imul(C, xe)) | 0),
              (a = (a + Math.imul(C, Ue)) | 0),
              (a = (a + Math.imul(z, xe)) | 0),
              (b = (b + Math.imul(z, Ue)) | 0),
              (v = (v + Math.imul(B, Be)) | 0),
              (a = (a + Math.imul(B, ze)) | 0),
              (a = (a + Math.imul(F, Be)) | 0),
              (b = (b + Math.imul(F, ze)) | 0);
            var hr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (hr >>> 26)) | 0),
              (hr &= 67108863),
              (v = Math.imul(T, ie)),
              (a = Math.imul(T, ye)),
              (a = (a + Math.imul(x, ie)) | 0),
              (b = Math.imul(x, ye)),
              (v = (v + Math.imul(K, ve)) | 0),
              (a = (a + Math.imul(K, _e)) | 0),
              (a = (a + Math.imul(O, ve)) | 0),
              (b = (b + Math.imul(O, _e)) | 0),
              (v = (v + Math.imul(ce, Me)) | 0),
              (a = (a + Math.imul(ce, Ce)) | 0),
              (a = (a + Math.imul(he, Me)) | 0),
              (b = (b + Math.imul(he, Ce)) | 0),
              (v = (v + Math.imul(me, Ae)) | 0),
              (a = (a + Math.imul(me, Le)) | 0),
              (a = (a + Math.imul(re, Ae)) | 0),
              (b = (b + Math.imul(re, Le)) | 0),
              (v = (v + Math.imul(be, Ee)) | 0),
              (a = (a + Math.imul(be, Ne)) | 0),
              (a = (a + Math.imul(oe, Ee)) | 0),
              (b = (b + Math.imul(oe, Ne)) | 0),
              (v = (v + Math.imul(fe, ke)) | 0),
              (a = (a + Math.imul(fe, $e)) | 0),
              (a = (a + Math.imul(le, ke)) | 0),
              (b = (b + Math.imul(le, $e)) | 0),
              (v = (v + Math.imul($, Ie)) | 0),
              (a = (a + Math.imul($, De)) | 0),
              (a = (a + Math.imul(Z, Ie)) | 0),
              (b = (b + Math.imul(Z, De)) | 0),
              (v = (v + Math.imul(G, xe)) | 0),
              (a = (a + Math.imul(G, Ue)) | 0),
              (a = (a + Math.imul(Q, xe)) | 0),
              (b = (b + Math.imul(Q, Ue)) | 0),
              (v = (v + Math.imul(C, Be)) | 0),
              (a = (a + Math.imul(C, ze)) | 0),
              (a = (a + Math.imul(z, Be)) | 0),
              (b = (b + Math.imul(z, ze)) | 0);
            var dr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (dr >>> 26)) | 0),
              (dr &= 67108863),
              (v = Math.imul(T, ve)),
              (a = Math.imul(T, _e)),
              (a = (a + Math.imul(x, ve)) | 0),
              (b = Math.imul(x, _e)),
              (v = (v + Math.imul(K, Me)) | 0),
              (a = (a + Math.imul(K, Ce)) | 0),
              (a = (a + Math.imul(O, Me)) | 0),
              (b = (b + Math.imul(O, Ce)) | 0),
              (v = (v + Math.imul(ce, Ae)) | 0),
              (a = (a + Math.imul(ce, Le)) | 0),
              (a = (a + Math.imul(he, Ae)) | 0),
              (b = (b + Math.imul(he, Le)) | 0),
              (v = (v + Math.imul(me, Ee)) | 0),
              (a = (a + Math.imul(me, Ne)) | 0),
              (a = (a + Math.imul(re, Ee)) | 0),
              (b = (b + Math.imul(re, Ne)) | 0),
              (v = (v + Math.imul(be, ke)) | 0),
              (a = (a + Math.imul(be, $e)) | 0),
              (a = (a + Math.imul(oe, ke)) | 0),
              (b = (b + Math.imul(oe, $e)) | 0),
              (v = (v + Math.imul(fe, Ie)) | 0),
              (a = (a + Math.imul(fe, De)) | 0),
              (a = (a + Math.imul(le, Ie)) | 0),
              (b = (b + Math.imul(le, De)) | 0),
              (v = (v + Math.imul($, xe)) | 0),
              (a = (a + Math.imul($, Ue)) | 0),
              (a = (a + Math.imul(Z, xe)) | 0),
              (b = (b + Math.imul(Z, Ue)) | 0),
              (v = (v + Math.imul(G, Be)) | 0),
              (a = (a + Math.imul(G, ze)) | 0),
              (a = (a + Math.imul(Q, Be)) | 0),
              (b = (b + Math.imul(Q, ze)) | 0);
            var pr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (pr >>> 26)) | 0),
              (pr &= 67108863),
              (v = Math.imul(T, Me)),
              (a = Math.imul(T, Ce)),
              (a = (a + Math.imul(x, Me)) | 0),
              (b = Math.imul(x, Ce)),
              (v = (v + Math.imul(K, Ae)) | 0),
              (a = (a + Math.imul(K, Le)) | 0),
              (a = (a + Math.imul(O, Ae)) | 0),
              (b = (b + Math.imul(O, Le)) | 0),
              (v = (v + Math.imul(ce, Ee)) | 0),
              (a = (a + Math.imul(ce, Ne)) | 0),
              (a = (a + Math.imul(he, Ee)) | 0),
              (b = (b + Math.imul(he, Ne)) | 0),
              (v = (v + Math.imul(me, ke)) | 0),
              (a = (a + Math.imul(me, $e)) | 0),
              (a = (a + Math.imul(re, ke)) | 0),
              (b = (b + Math.imul(re, $e)) | 0),
              (v = (v + Math.imul(be, Ie)) | 0),
              (a = (a + Math.imul(be, De)) | 0),
              (a = (a + Math.imul(oe, Ie)) | 0),
              (b = (b + Math.imul(oe, De)) | 0),
              (v = (v + Math.imul(fe, xe)) | 0),
              (a = (a + Math.imul(fe, Ue)) | 0),
              (a = (a + Math.imul(le, xe)) | 0),
              (b = (b + Math.imul(le, Ue)) | 0),
              (v = (v + Math.imul($, Be)) | 0),
              (a = (a + Math.imul($, ze)) | 0),
              (a = (a + Math.imul(Z, Be)) | 0),
              (b = (b + Math.imul(Z, ze)) | 0);
            var yr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (yr >>> 26)) | 0),
              (yr &= 67108863),
              (v = Math.imul(T, Ae)),
              (a = Math.imul(T, Le)),
              (a = (a + Math.imul(x, Ae)) | 0),
              (b = Math.imul(x, Le)),
              (v = (v + Math.imul(K, Ee)) | 0),
              (a = (a + Math.imul(K, Ne)) | 0),
              (a = (a + Math.imul(O, Ee)) | 0),
              (b = (b + Math.imul(O, Ne)) | 0),
              (v = (v + Math.imul(ce, ke)) | 0),
              (a = (a + Math.imul(ce, $e)) | 0),
              (a = (a + Math.imul(he, ke)) | 0),
              (b = (b + Math.imul(he, $e)) | 0),
              (v = (v + Math.imul(me, Ie)) | 0),
              (a = (a + Math.imul(me, De)) | 0),
              (a = (a + Math.imul(re, Ie)) | 0),
              (b = (b + Math.imul(re, De)) | 0),
              (v = (v + Math.imul(be, xe)) | 0),
              (a = (a + Math.imul(be, Ue)) | 0),
              (a = (a + Math.imul(oe, xe)) | 0),
              (b = (b + Math.imul(oe, Ue)) | 0),
              (v = (v + Math.imul(fe, Be)) | 0),
              (a = (a + Math.imul(fe, ze)) | 0),
              (a = (a + Math.imul(le, Be)) | 0),
              (b = (b + Math.imul(le, ze)) | 0);
            var gr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (gr >>> 26)) | 0),
              (gr &= 67108863),
              (v = Math.imul(T, Ee)),
              (a = Math.imul(T, Ne)),
              (a = (a + Math.imul(x, Ee)) | 0),
              (b = Math.imul(x, Ne)),
              (v = (v + Math.imul(K, ke)) | 0),
              (a = (a + Math.imul(K, $e)) | 0),
              (a = (a + Math.imul(O, ke)) | 0),
              (b = (b + Math.imul(O, $e)) | 0),
              (v = (v + Math.imul(ce, Ie)) | 0),
              (a = (a + Math.imul(ce, De)) | 0),
              (a = (a + Math.imul(he, Ie)) | 0),
              (b = (b + Math.imul(he, De)) | 0),
              (v = (v + Math.imul(me, xe)) | 0),
              (a = (a + Math.imul(me, Ue)) | 0),
              (a = (a + Math.imul(re, xe)) | 0),
              (b = (b + Math.imul(re, Ue)) | 0),
              (v = (v + Math.imul(be, Be)) | 0),
              (a = (a + Math.imul(be, ze)) | 0),
              (a = (a + Math.imul(oe, Be)) | 0),
              (b = (b + Math.imul(oe, ze)) | 0);
            var br = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (br >>> 26)) | 0),
              (br &= 67108863),
              (v = Math.imul(T, ke)),
              (a = Math.imul(T, $e)),
              (a = (a + Math.imul(x, ke)) | 0),
              (b = Math.imul(x, $e)),
              (v = (v + Math.imul(K, Ie)) | 0),
              (a = (a + Math.imul(K, De)) | 0),
              (a = (a + Math.imul(O, Ie)) | 0),
              (b = (b + Math.imul(O, De)) | 0),
              (v = (v + Math.imul(ce, xe)) | 0),
              (a = (a + Math.imul(ce, Ue)) | 0),
              (a = (a + Math.imul(he, xe)) | 0),
              (b = (b + Math.imul(he, Ue)) | 0),
              (v = (v + Math.imul(me, Be)) | 0),
              (a = (a + Math.imul(me, ze)) | 0),
              (a = (a + Math.imul(re, Be)) | 0),
              (b = (b + Math.imul(re, ze)) | 0);
            var vr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (vr >>> 26)) | 0),
              (vr &= 67108863),
              (v = Math.imul(T, Ie)),
              (a = Math.imul(T, De)),
              (a = (a + Math.imul(x, Ie)) | 0),
              (b = Math.imul(x, De)),
              (v = (v + Math.imul(K, xe)) | 0),
              (a = (a + Math.imul(K, Ue)) | 0),
              (a = (a + Math.imul(O, xe)) | 0),
              (b = (b + Math.imul(O, Ue)) | 0),
              (v = (v + Math.imul(ce, Be)) | 0),
              (a = (a + Math.imul(ce, ze)) | 0),
              (a = (a + Math.imul(he, Be)) | 0),
              (b = (b + Math.imul(he, ze)) | 0);
            var mr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (mr >>> 26)) | 0),
              (mr &= 67108863),
              (v = Math.imul(T, xe)),
              (a = Math.imul(T, Ue)),
              (a = (a + Math.imul(x, xe)) | 0),
              (b = Math.imul(x, Ue)),
              (v = (v + Math.imul(K, Be)) | 0),
              (a = (a + Math.imul(K, ze)) | 0),
              (a = (a + Math.imul(O, Be)) | 0),
              (b = (b + Math.imul(O, ze)) | 0);
            var wr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (wr >>> 26)) | 0),
              (wr &= 67108863),
              (v = Math.imul(T, Be)),
              (a = Math.imul(T, ze)),
              (a = (a + Math.imul(x, Be)) | 0),
              (b = Math.imul(x, ze));
            var _r = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            return (
              (M = (((b + (a >>> 13)) | 0) + (_r >>> 26)) | 0),
              (_r &= 67108863),
              (w[0] = st),
              (w[1] = at),
              (w[2] = Ft),
              (w[3] = qt),
              (w[4] = Wt),
              (w[5] = Kt),
              (w[6] = jt),
              (w[7] = fr),
              (w[8] = lr),
              (w[9] = hr),
              (w[10] = dr),
              (w[11] = pr),
              (w[12] = yr),
              (w[13] = gr),
              (w[14] = br),
              (w[15] = vr),
              (w[16] = mr),
              (w[17] = wr),
              (w[18] = _r),
              M !== 0 && ((w[19] = M), l.length++),
              l
            );
          };
          Math.imul || (I = E);
          function R(S, o, u) {
            (u.negative = o.negative ^ S.negative), (u.length = S.length + o.length);
            for (var l = 0, d = 0, g = 0; g < u.length - 1; g++) {
              var w = d;
              d = 0;
              for (
                var M = l & 67108863,
                  v = Math.min(g, o.length - 1),
                  a = Math.max(0, g - S.length + 1);
                a <= v;
                a++
              ) {
                var b = g - a,
                  k = S.words[b] | 0,
                  B = o.words[a] | 0,
                  F = k * B,
                  P = F & 67108863;
                (w = (w + ((F / 67108864) | 0)) | 0),
                  (P = (P + M) | 0),
                  (M = P & 67108863),
                  (w = (w + (P >>> 26)) | 0),
                  (d += w >>> 26),
                  (w &= 67108863);
              }
              (u.words[g] = M), (l = w), (w = d);
            }
            return l !== 0 ? (u.words[g] = l) : u.length--, u.strip();
          }
          function L(S, o, u) {
            var l = new D();
            return l.mulp(S, o, u);
          }
          n.prototype.mulTo = function (o, u) {
            var l,
              d = this.length + o.length;
            return (
              this.length === 10 && o.length === 10
                ? (l = I(this, o, u))
                : d < 63
                  ? (l = E(this, o, u))
                  : d < 1024
                    ? (l = R(this, o, u))
                    : (l = L(this, o, u)),
              l
            );
          };
          function D(S, o) {
            (this.x = S), (this.y = o);
          }
          (D.prototype.makeRBT = function (o) {
            for (var u = new Array(o), l = n.prototype._countBits(o) - 1, d = 0; d < o; d++)
              u[d] = this.revBin(d, l, o);
            return u;
          }),
            (D.prototype.revBin = function (o, u, l) {
              if (o === 0 || o === l - 1) return o;
              for (var d = 0, g = 0; g < u; g++) (d |= (o & 1) << (u - g - 1)), (o >>= 1);
              return d;
            }),
            (D.prototype.permute = function (o, u, l, d, g, w) {
              for (var M = 0; M < w; M++) (d[M] = u[o[M]]), (g[M] = l[o[M]]);
            }),
            (D.prototype.transform = function (o, u, l, d, g, w) {
              this.permute(w, o, u, l, d, g);
              for (var M = 1; M < g; M <<= 1)
                for (
                  var v = M << 1,
                    a = Math.cos((2 * Math.PI) / v),
                    b = Math.sin((2 * Math.PI) / v),
                    k = 0;
                  k < g;
                  k += v
                )
                  for (var B = a, F = b, P = 0; P < M; P++) {
                    var C = l[k + P],
                      z = d[k + P],
                      Y = l[k + P + M],
                      G = d[k + P + M],
                      Q = B * Y - F * G;
                    (G = B * G + F * Y),
                      (Y = Q),
                      (l[k + P] = C + Y),
                      (d[k + P] = z + G),
                      (l[k + P + M] = C - Y),
                      (d[k + P + M] = z - G),
                      P !== v && ((Q = a * B - b * F), (F = a * F + b * B), (B = Q));
                  }
            }),
            (D.prototype.guessLen13b = function (o, u) {
              var l = Math.max(u, o) | 1,
                d = l & 1,
                g = 0;
              for (l = (l / 2) | 0; l; l = l >>> 1) g++;
              return 1 << (g + 1 + d);
            }),
            (D.prototype.conjugate = function (o, u, l) {
              if (!(l <= 1))
                for (var d = 0; d < l / 2; d++) {
                  var g = o[d];
                  (o[d] = o[l - d - 1]),
                    (o[l - d - 1] = g),
                    (g = u[d]),
                    (u[d] = -u[l - d - 1]),
                    (u[l - d - 1] = -g);
                }
            }),
            (D.prototype.normalize13b = function (o, u) {
              for (var l = 0, d = 0; d < u / 2; d++) {
                var g = Math.round(o[2 * d + 1] / u) * 8192 + Math.round(o[2 * d] / u) + l;
                (o[d] = g & 67108863), g < 67108864 ? (l = 0) : (l = (g / 67108864) | 0);
              }
              return o;
            }),
            (D.prototype.convert13b = function (o, u, l, d) {
              for (var g = 0, w = 0; w < u; w++)
                (g = g + (o[w] | 0)),
                  (l[2 * w] = g & 8191),
                  (g = g >>> 13),
                  (l[2 * w + 1] = g & 8191),
                  (g = g >>> 13);
              for (w = 2 * u; w < d; ++w) l[w] = 0;
              r(g === 0), r((g & -8192) === 0);
            }),
            (D.prototype.stub = function (o) {
              for (var u = new Array(o), l = 0; l < o; l++) u[l] = 0;
              return u;
            }),
            (D.prototype.mulp = function (o, u, l) {
              var d = 2 * this.guessLen13b(o.length, u.length),
                g = this.makeRBT(d),
                w = this.stub(d),
                M = new Array(d),
                v = new Array(d),
                a = new Array(d),
                b = new Array(d),
                k = new Array(d),
                B = new Array(d),
                F = l.words;
              (F.length = d),
                this.convert13b(o.words, o.length, M, d),
                this.convert13b(u.words, u.length, b, d),
                this.transform(M, w, v, a, d, g),
                this.transform(b, w, k, B, d, g);
              for (var P = 0; P < d; P++) {
                var C = v[P] * k[P] - a[P] * B[P];
                (a[P] = v[P] * B[P] + a[P] * k[P]), (v[P] = C);
              }
              return (
                this.conjugate(v, a, d),
                this.transform(v, a, F, w, d, g),
                this.conjugate(F, w, d),
                this.normalize13b(F, d),
                (l.negative = o.negative ^ u.negative),
                (l.length = o.length + u.length),
                l.strip()
              );
            }),
            (n.prototype.mul = function (o) {
              var u = new n(null);
              return (u.words = new Array(this.length + o.length)), this.mulTo(o, u);
            }),
            (n.prototype.mulf = function (o) {
              var u = new n(null);
              return (u.words = new Array(this.length + o.length)), L(this, o, u);
            }),
            (n.prototype.imul = function (o) {
              return this.clone().mulTo(o, this);
            }),
            (n.prototype.imuln = function (o) {
              r(typeof o == 'number'), r(o < 67108864);
              for (var u = 0, l = 0; l < this.length; l++) {
                var d = (this.words[l] | 0) * o,
                  g = (d & 67108863) + (u & 67108863);
                (u >>= 26),
                  (u += (d / 67108864) | 0),
                  (u += g >>> 26),
                  (this.words[l] = g & 67108863);
              }
              return u !== 0 && ((this.words[l] = u), this.length++), this;
            }),
            (n.prototype.muln = function (o) {
              return this.clone().imuln(o);
            }),
            (n.prototype.sqr = function () {
              return this.mul(this);
            }),
            (n.prototype.isqr = function () {
              return this.imul(this.clone());
            }),
            (n.prototype.pow = function (o) {
              var u = A(o);
              if (u.length === 0) return new n(1);
              for (var l = this, d = 0; d < u.length && u[d] === 0; d++, l = l.sqr());
              if (++d < u.length)
                for (var g = l.sqr(); d < u.length; d++, g = g.sqr()) u[d] !== 0 && (l = l.mul(g));
              return l;
            }),
            (n.prototype.iushln = function (o) {
              r(typeof o == 'number' && o >= 0);
              var u = o % 26,
                l = (o - u) / 26,
                d = (67108863 >>> (26 - u)) << (26 - u),
                g;
              if (u !== 0) {
                var w = 0;
                for (g = 0; g < this.length; g++) {
                  var M = this.words[g] & d,
                    v = ((this.words[g] | 0) - M) << u;
                  (this.words[g] = v | w), (w = M >>> (26 - u));
                }
                w && ((this.words[g] = w), this.length++);
              }
              if (l !== 0) {
                for (g = this.length - 1; g >= 0; g--) this.words[g + l] = this.words[g];
                for (g = 0; g < l; g++) this.words[g] = 0;
                this.length += l;
              }
              return this.strip();
            }),
            (n.prototype.ishln = function (o) {
              return r(this.negative === 0), this.iushln(o);
            }),
            (n.prototype.iushrn = function (o, u, l) {
              r(typeof o == 'number' && o >= 0);
              var d;
              u ? (d = (u - (u % 26)) / 26) : (d = 0);
              var g = o % 26,
                w = Math.min((o - g) / 26, this.length),
                M = 67108863 ^ ((67108863 >>> g) << g),
                v = l;
              if (((d -= w), (d = Math.max(0, d)), v)) {
                for (var a = 0; a < w; a++) v.words[a] = this.words[a];
                v.length = w;
              }
              if (w !== 0)
                if (this.length > w)
                  for (this.length -= w, a = 0; a < this.length; a++)
                    this.words[a] = this.words[a + w];
                else (this.words[0] = 0), (this.length = 1);
              var b = 0;
              for (a = this.length - 1; a >= 0 && (b !== 0 || a >= d); a--) {
                var k = this.words[a] | 0;
                (this.words[a] = (b << (26 - g)) | (k >>> g)), (b = k & M);
              }
              return (
                v && b !== 0 && (v.words[v.length++] = b),
                this.length === 0 && ((this.words[0] = 0), (this.length = 1)),
                this.strip()
              );
            }),
            (n.prototype.ishrn = function (o, u, l) {
              return r(this.negative === 0), this.iushrn(o, u, l);
            }),
            (n.prototype.shln = function (o) {
              return this.clone().ishln(o);
            }),
            (n.prototype.ushln = function (o) {
              return this.clone().iushln(o);
            }),
            (n.prototype.shrn = function (o) {
              return this.clone().ishrn(o);
            }),
            (n.prototype.ushrn = function (o) {
              return this.clone().iushrn(o);
            }),
            (n.prototype.testn = function (o) {
              r(typeof o == 'number' && o >= 0);
              var u = o % 26,
                l = (o - u) / 26,
                d = 1 << u;
              if (this.length <= l) return !1;
              var g = this.words[l];
              return !!(g & d);
            }),
            (n.prototype.imaskn = function (o) {
              r(typeof o == 'number' && o >= 0);
              var u = o % 26,
                l = (o - u) / 26;
              if (
                (r(this.negative === 0, 'imaskn works only with positive numbers'),
                this.length <= l)
              )
                return this;
              if ((u !== 0 && l++, (this.length = Math.min(l, this.length)), u !== 0)) {
                var d = 67108863 ^ ((67108863 >>> u) << u);
                this.words[this.length - 1] &= d;
              }
              return this.strip();
            }),
            (n.prototype.maskn = function (o) {
              return this.clone().imaskn(o);
            }),
            (n.prototype.iaddn = function (o) {
              return (
                r(typeof o == 'number'),
                r(o < 67108864),
                o < 0
                  ? this.isubn(-o)
                  : this.negative !== 0
                    ? this.length === 1 && (this.words[0] | 0) < o
                      ? ((this.words[0] = o - (this.words[0] | 0)), (this.negative = 0), this)
                      : ((this.negative = 0), this.isubn(o), (this.negative = 1), this)
                    : this._iaddn(o)
              );
            }),
            (n.prototype._iaddn = function (o) {
              this.words[0] += o;
              for (var u = 0; u < this.length && this.words[u] >= 67108864; u++)
                (this.words[u] -= 67108864),
                  u === this.length - 1 ? (this.words[u + 1] = 1) : this.words[u + 1]++;
              return (this.length = Math.max(this.length, u + 1)), this;
            }),
            (n.prototype.isubn = function (o) {
              if ((r(typeof o == 'number'), r(o < 67108864), o < 0)) return this.iaddn(-o);
              if (this.negative !== 0)
                return (this.negative = 0), this.iaddn(o), (this.negative = 1), this;
              if (((this.words[0] -= o), this.length === 1 && this.words[0] < 0))
                (this.words[0] = -this.words[0]), (this.negative = 1);
              else
                for (var u = 0; u < this.length && this.words[u] < 0; u++)
                  (this.words[u] += 67108864), (this.words[u + 1] -= 1);
              return this.strip();
            }),
            (n.prototype.addn = function (o) {
              return this.clone().iaddn(o);
            }),
            (n.prototype.subn = function (o) {
              return this.clone().isubn(o);
            }),
            (n.prototype.iabs = function () {
              return (this.negative = 0), this;
            }),
            (n.prototype.abs = function () {
              return this.clone().iabs();
            }),
            (n.prototype._ishlnsubmul = function (o, u, l) {
              var d = o.length + l,
                g;
              this._expand(d);
              var w,
                M = 0;
              for (g = 0; g < o.length; g++) {
                w = (this.words[g + l] | 0) + M;
                var v = (o.words[g] | 0) * u;
                (w -= v & 67108863),
                  (M = (w >> 26) - ((v / 67108864) | 0)),
                  (this.words[g + l] = w & 67108863);
              }
              for (; g < this.length - l; g++)
                (w = (this.words[g + l] | 0) + M),
                  (M = w >> 26),
                  (this.words[g + l] = w & 67108863);
              if (M === 0) return this.strip();
              for (r(M === -1), M = 0, g = 0; g < this.length; g++)
                (w = -(this.words[g] | 0) + M), (M = w >> 26), (this.words[g] = w & 67108863);
              return (this.negative = 1), this.strip();
            }),
            (n.prototype._wordDiv = function (o, u) {
              var l = this.length - o.length,
                d = this.clone(),
                g = o,
                w = g.words[g.length - 1] | 0,
                M = this._countBits(w);
              (l = 26 - M),
                l !== 0 && ((g = g.ushln(l)), d.iushln(l), (w = g.words[g.length - 1] | 0));
              var v = d.length - g.length,
                a;
              if (u !== 'mod') {
                (a = new n(null)), (a.length = v + 1), (a.words = new Array(a.length));
                for (var b = 0; b < a.length; b++) a.words[b] = 0;
              }
              var k = d.clone()._ishlnsubmul(g, 1, v);
              k.negative === 0 && ((d = k), a && (a.words[v] = 1));
              for (var B = v - 1; B >= 0; B--) {
                var F = (d.words[g.length + B] | 0) * 67108864 + (d.words[g.length + B - 1] | 0);
                for (
                  F = Math.min((F / w) | 0, 67108863), d._ishlnsubmul(g, F, B);
                  d.negative !== 0;

                )
                  F--, (d.negative = 0), d._ishlnsubmul(g, 1, B), d.isZero() || (d.negative ^= 1);
                a && (a.words[B] = F);
              }
              return (
                a && a.strip(),
                d.strip(),
                u !== 'div' && l !== 0 && d.iushrn(l),
                { div: a || null, mod: d }
              );
            }),
            (n.prototype.divmod = function (o, u, l) {
              if ((r(!o.isZero()), this.isZero())) return { div: new n(0), mod: new n(0) };
              var d, g, w;
              return this.negative !== 0 && o.negative === 0
                ? ((w = this.neg().divmod(o, u)),
                  u !== 'mod' && (d = w.div.neg()),
                  u !== 'div' && ((g = w.mod.neg()), l && g.negative !== 0 && g.iadd(o)),
                  { div: d, mod: g })
                : this.negative === 0 && o.negative !== 0
                  ? ((w = this.divmod(o.neg(), u)),
                    u !== 'mod' && (d = w.div.neg()),
                    { div: d, mod: w.mod })
                  : this.negative & o.negative
                    ? ((w = this.neg().divmod(o.neg(), u)),
                      u !== 'div' && ((g = w.mod.neg()), l && g.negative !== 0 && g.isub(o)),
                      { div: w.div, mod: g })
                    : o.length > this.length || this.cmp(o) < 0
                      ? { div: new n(0), mod: this }
                      : o.length === 1
                        ? u === 'div'
                          ? { div: this.divn(o.words[0]), mod: null }
                          : u === 'mod'
                            ? { div: null, mod: new n(this.modn(o.words[0])) }
                            : { div: this.divn(o.words[0]), mod: new n(this.modn(o.words[0])) }
                        : this._wordDiv(o, u);
            }),
            (n.prototype.div = function (o) {
              return this.divmod(o, 'div', !1).div;
            }),
            (n.prototype.mod = function (o) {
              return this.divmod(o, 'mod', !1).mod;
            }),
            (n.prototype.umod = function (o) {
              return this.divmod(o, 'mod', !0).mod;
            }),
            (n.prototype.divRound = function (o) {
              var u = this.divmod(o);
              if (u.mod.isZero()) return u.div;
              var l = u.div.negative !== 0 ? u.mod.isub(o) : u.mod,
                d = o.ushrn(1),
                g = o.andln(1),
                w = l.cmp(d);
              return w < 0 || (g === 1 && w === 0)
                ? u.div
                : u.div.negative !== 0
                  ? u.div.isubn(1)
                  : u.div.iaddn(1);
            }),
            (n.prototype.modn = function (o) {
              r(o <= 67108863);
              for (var u = (1 << 26) % o, l = 0, d = this.length - 1; d >= 0; d--)
                l = (u * l + (this.words[d] | 0)) % o;
              return l;
            }),
            (n.prototype.idivn = function (o) {
              r(o <= 67108863);
              for (var u = 0, l = this.length - 1; l >= 0; l--) {
                var d = (this.words[l] | 0) + u * 67108864;
                (this.words[l] = (d / o) | 0), (u = d % o);
              }
              return this.strip();
            }),
            (n.prototype.divn = function (o) {
              return this.clone().idivn(o);
            }),
            (n.prototype.egcd = function (o) {
              r(o.negative === 0), r(!o.isZero());
              var u = this,
                l = o.clone();
              u.negative !== 0 ? (u = u.umod(o)) : (u = u.clone());
              for (
                var d = new n(1), g = new n(0), w = new n(0), M = new n(1), v = 0;
                u.isEven() && l.isEven();

              )
                u.iushrn(1), l.iushrn(1), ++v;
              for (var a = l.clone(), b = u.clone(); !u.isZero(); ) {
                for (var k = 0, B = 1; !(u.words[0] & B) && k < 26; ++k, B <<= 1);
                if (k > 0)
                  for (u.iushrn(k); k-- > 0; )
                    (d.isOdd() || g.isOdd()) && (d.iadd(a), g.isub(b)), d.iushrn(1), g.iushrn(1);
                for (var F = 0, P = 1; !(l.words[0] & P) && F < 26; ++F, P <<= 1);
                if (F > 0)
                  for (l.iushrn(F); F-- > 0; )
                    (w.isOdd() || M.isOdd()) && (w.iadd(a), M.isub(b)), w.iushrn(1), M.iushrn(1);
                u.cmp(l) >= 0
                  ? (u.isub(l), d.isub(w), g.isub(M))
                  : (l.isub(u), w.isub(d), M.isub(g));
              }
              return { a: w, b: M, gcd: l.iushln(v) };
            }),
            (n.prototype._invmp = function (o) {
              r(o.negative === 0), r(!o.isZero());
              var u = this,
                l = o.clone();
              u.negative !== 0 ? (u = u.umod(o)) : (u = u.clone());
              for (
                var d = new n(1), g = new n(0), w = l.clone();
                u.cmpn(1) > 0 && l.cmpn(1) > 0;

              ) {
                for (var M = 0, v = 1; !(u.words[0] & v) && M < 26; ++M, v <<= 1);
                if (M > 0) for (u.iushrn(M); M-- > 0; ) d.isOdd() && d.iadd(w), d.iushrn(1);
                for (var a = 0, b = 1; !(l.words[0] & b) && a < 26; ++a, b <<= 1);
                if (a > 0) for (l.iushrn(a); a-- > 0; ) g.isOdd() && g.iadd(w), g.iushrn(1);
                u.cmp(l) >= 0 ? (u.isub(l), d.isub(g)) : (l.isub(u), g.isub(d));
              }
              var k;
              return u.cmpn(1) === 0 ? (k = d) : (k = g), k.cmpn(0) < 0 && k.iadd(o), k;
            }),
            (n.prototype.gcd = function (o) {
              if (this.isZero()) return o.abs();
              if (o.isZero()) return this.abs();
              var u = this.clone(),
                l = o.clone();
              (u.negative = 0), (l.negative = 0);
              for (var d = 0; u.isEven() && l.isEven(); d++) u.iushrn(1), l.iushrn(1);
              do {
                for (; u.isEven(); ) u.iushrn(1);
                for (; l.isEven(); ) l.iushrn(1);
                var g = u.cmp(l);
                if (g < 0) {
                  var w = u;
                  (u = l), (l = w);
                } else if (g === 0 || l.cmpn(1) === 0) break;
                u.isub(l);
              } while (!0);
              return l.iushln(d);
            }),
            (n.prototype.invm = function (o) {
              return this.egcd(o).a.umod(o);
            }),
            (n.prototype.isEven = function () {
              return (this.words[0] & 1) === 0;
            }),
            (n.prototype.isOdd = function () {
              return (this.words[0] & 1) === 1;
            }),
            (n.prototype.andln = function (o) {
              return this.words[0] & o;
            }),
            (n.prototype.bincn = function (o) {
              r(typeof o == 'number');
              var u = o % 26,
                l = (o - u) / 26,
                d = 1 << u;
              if (this.length <= l) return this._expand(l + 1), (this.words[l] |= d), this;
              for (var g = d, w = l; g !== 0 && w < this.length; w++) {
                var M = this.words[w] | 0;
                (M += g), (g = M >>> 26), (M &= 67108863), (this.words[w] = M);
              }
              return g !== 0 && ((this.words[w] = g), this.length++), this;
            }),
            (n.prototype.isZero = function () {
              return this.length === 1 && this.words[0] === 0;
            }),
            (n.prototype.cmpn = function (o) {
              var u = o < 0;
              if (this.negative !== 0 && !u) return -1;
              if (this.negative === 0 && u) return 1;
              this.strip();
              var l;
              if (this.length > 1) l = 1;
              else {
                u && (o = -o), r(o <= 67108863, 'Number is too big');
                var d = this.words[0] | 0;
                l = d === o ? 0 : d < o ? -1 : 1;
              }
              return this.negative !== 0 ? -l | 0 : l;
            }),
            (n.prototype.cmp = function (o) {
              if (this.negative !== 0 && o.negative === 0) return -1;
              if (this.negative === 0 && o.negative !== 0) return 1;
              var u = this.ucmp(o);
              return this.negative !== 0 ? -u | 0 : u;
            }),
            (n.prototype.ucmp = function (o) {
              if (this.length > o.length) return 1;
              if (this.length < o.length) return -1;
              for (var u = 0, l = this.length - 1; l >= 0; l--) {
                var d = this.words[l] | 0,
                  g = o.words[l] | 0;
                if (d !== g) {
                  d < g ? (u = -1) : d > g && (u = 1);
                  break;
                }
              }
              return u;
            }),
            (n.prototype.gtn = function (o) {
              return this.cmpn(o) === 1;
            }),
            (n.prototype.gt = function (o) {
              return this.cmp(o) === 1;
            }),
            (n.prototype.gten = function (o) {
              return this.cmpn(o) >= 0;
            }),
            (n.prototype.gte = function (o) {
              return this.cmp(o) >= 0;
            }),
            (n.prototype.ltn = function (o) {
              return this.cmpn(o) === -1;
            }),
            (n.prototype.lt = function (o) {
              return this.cmp(o) === -1;
            }),
            (n.prototype.lten = function (o) {
              return this.cmpn(o) <= 0;
            }),
            (n.prototype.lte = function (o) {
              return this.cmp(o) <= 0;
            }),
            (n.prototype.eqn = function (o) {
              return this.cmpn(o) === 0;
            }),
            (n.prototype.eq = function (o) {
              return this.cmp(o) === 0;
            }),
            (n.red = function (o) {
              return new X(o);
            }),
            (n.prototype.toRed = function (o) {
              return (
                r(!this.red, 'Already a number in reduction context'),
                r(this.negative === 0, 'red works only with positives'),
                o.convertTo(this)._forceRed(o)
              );
            }),
            (n.prototype.fromRed = function () {
              return (
                r(this.red, 'fromRed works only with numbers in reduction context'),
                this.red.convertFrom(this)
              );
            }),
            (n.prototype._forceRed = function (o) {
              return (this.red = o), this;
            }),
            (n.prototype.forceRed = function (o) {
              return r(!this.red, 'Already a number in reduction context'), this._forceRed(o);
            }),
            (n.prototype.redAdd = function (o) {
              return r(this.red, 'redAdd works only with red numbers'), this.red.add(this, o);
            }),
            (n.prototype.redIAdd = function (o) {
              return r(this.red, 'redIAdd works only with red numbers'), this.red.iadd(this, o);
            }),
            (n.prototype.redSub = function (o) {
              return r(this.red, 'redSub works only with red numbers'), this.red.sub(this, o);
            }),
            (n.prototype.redISub = function (o) {
              return r(this.red, 'redISub works only with red numbers'), this.red.isub(this, o);
            }),
            (n.prototype.redShl = function (o) {
              return r(this.red, 'redShl works only with red numbers'), this.red.shl(this, o);
            }),
            (n.prototype.redMul = function (o) {
              return (
                r(this.red, 'redMul works only with red numbers'),
                this.red._verify2(this, o),
                this.red.mul(this, o)
              );
            }),
            (n.prototype.redIMul = function (o) {
              return (
                r(this.red, 'redMul works only with red numbers'),
                this.red._verify2(this, o),
                this.red.imul(this, o)
              );
            }),
            (n.prototype.redSqr = function () {
              return (
                r(this.red, 'redSqr works only with red numbers'),
                this.red._verify1(this),
                this.red.sqr(this)
              );
            }),
            (n.prototype.redISqr = function () {
              return (
                r(this.red, 'redISqr works only with red numbers'),
                this.red._verify1(this),
                this.red.isqr(this)
              );
            }),
            (n.prototype.redSqrt = function () {
              return (
                r(this.red, 'redSqrt works only with red numbers'),
                this.red._verify1(this),
                this.red.sqrt(this)
              );
            }),
            (n.prototype.redInvm = function () {
              return (
                r(this.red, 'redInvm works only with red numbers'),
                this.red._verify1(this),
                this.red.invm(this)
              );
            }),
            (n.prototype.redNeg = function () {
              return (
                r(this.red, 'redNeg works only with red numbers'),
                this.red._verify1(this),
                this.red.neg(this)
              );
            }),
            (n.prototype.redPow = function (o) {
              return (
                r(this.red && !o.red, 'redPow(normalNum)'),
                this.red._verify1(this),
                this.red.pow(this, o)
              );
            });
          var q = { k256: null, p224: null, p192: null, p25519: null };
          function H(S, o) {
            (this.name = S),
              (this.p = new n(o, 16)),
              (this.n = this.p.bitLength()),
              (this.k = new n(1).iushln(this.n).isub(this.p)),
              (this.tmp = this._tmp());
          }
          (H.prototype._tmp = function () {
            var o = new n(null);
            return (o.words = new Array(Math.ceil(this.n / 13))), o;
          }),
            (H.prototype.ireduce = function (o) {
              var u = o,
                l;
              do
                this.split(u, this.tmp),
                  (u = this.imulK(u)),
                  (u = u.iadd(this.tmp)),
                  (l = u.bitLength());
              while (l > this.n);
              var d = l < this.n ? -1 : u.ucmp(this.p);
              return (
                d === 0
                  ? ((u.words[0] = 0), (u.length = 1))
                  : d > 0
                    ? u.isub(this.p)
                    : u.strip !== void 0
                      ? u.strip()
                      : u._strip(),
                u
              );
            }),
            (H.prototype.split = function (o, u) {
              o.iushrn(this.n, 0, u);
            }),
            (H.prototype.imulK = function (o) {
              return o.imul(this.k);
            });
          function V() {
            H.call(
              this,
              'k256',
              'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f'
            );
          }
          s(V, H),
            (V.prototype.split = function (o, u) {
              for (var l = 4194303, d = Math.min(o.length, 9), g = 0; g < d; g++)
                u.words[g] = o.words[g];
              if (((u.length = d), o.length <= 9)) {
                (o.words[0] = 0), (o.length = 1);
                return;
              }
              var w = o.words[9];
              for (u.words[u.length++] = w & l, g = 10; g < o.length; g++) {
                var M = o.words[g] | 0;
                (o.words[g - 10] = ((M & l) << 4) | (w >>> 22)), (w = M);
              }
              (w >>>= 22),
                (o.words[g - 10] = w),
                w === 0 && o.length > 10 ? (o.length -= 10) : (o.length -= 9);
            }),
            (V.prototype.imulK = function (o) {
              (o.words[o.length] = 0), (o.words[o.length + 1] = 0), (o.length += 2);
              for (var u = 0, l = 0; l < o.length; l++) {
                var d = o.words[l] | 0;
                (u += d * 977), (o.words[l] = u & 67108863), (u = d * 64 + ((u / 67108864) | 0));
              }
              return (
                o.words[o.length - 1] === 0 &&
                  (o.length--, o.words[o.length - 1] === 0 && o.length--),
                o
              );
            });
          function te() {
            H.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
          }
          s(te, H);
          function ue() {
            H.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
          }
          s(ue, H);
          function ne() {
            H.call(
              this,
              '25519',
              '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed'
            );
          }
          s(ne, H),
            (ne.prototype.imulK = function (o) {
              for (var u = 0, l = 0; l < o.length; l++) {
                var d = (o.words[l] | 0) * 19 + u,
                  g = d & 67108863;
                (d >>>= 26), (o.words[l] = g), (u = d);
              }
              return u !== 0 && (o.words[o.length++] = u), o;
            }),
            (n._prime = function (o) {
              if (q[o]) return q[o];
              var u;
              if (o === 'k256') u = new V();
              else if (o === 'p224') u = new te();
              else if (o === 'p192') u = new ue();
              else if (o === 'p25519') u = new ne();
              else throw new Error('Unknown prime ' + o);
              return (q[o] = u), u;
            });
          function X(S) {
            if (typeof S == 'string') {
              var o = n._prime(S);
              (this.m = o.p), (this.prime = o);
            } else r(S.gtn(1), 'modulus must be greater than 1'), (this.m = S), (this.prime = null);
          }
          (X.prototype._verify1 = function (o) {
            r(o.negative === 0, 'red works only with positives'),
              r(o.red, 'red works only with red numbers');
          }),
            (X.prototype._verify2 = function (o, u) {
              r((o.negative | u.negative) === 0, 'red works only with positives'),
                r(o.red && o.red === u.red, 'red works only with red numbers');
            }),
            (X.prototype.imod = function (o) {
              return this.prime
                ? this.prime.ireduce(o)._forceRed(this)
                : o.umod(this.m)._forceRed(this);
            }),
            (X.prototype.neg = function (o) {
              return o.isZero() ? o.clone() : this.m.sub(o)._forceRed(this);
            }),
            (X.prototype.add = function (o, u) {
              this._verify2(o, u);
              var l = o.add(u);
              return l.cmp(this.m) >= 0 && l.isub(this.m), l._forceRed(this);
            }),
            (X.prototype.iadd = function (o, u) {
              this._verify2(o, u);
              var l = o.iadd(u);
              return l.cmp(this.m) >= 0 && l.isub(this.m), l;
            }),
            (X.prototype.sub = function (o, u) {
              this._verify2(o, u);
              var l = o.sub(u);
              return l.cmpn(0) < 0 && l.iadd(this.m), l._forceRed(this);
            }),
            (X.prototype.isub = function (o, u) {
              this._verify2(o, u);
              var l = o.isub(u);
              return l.cmpn(0) < 0 && l.iadd(this.m), l;
            }),
            (X.prototype.shl = function (o, u) {
              return this._verify1(o), this.imod(o.ushln(u));
            }),
            (X.prototype.imul = function (o, u) {
              return this._verify2(o, u), this.imod(o.imul(u));
            }),
            (X.prototype.mul = function (o, u) {
              return this._verify2(o, u), this.imod(o.mul(u));
            }),
            (X.prototype.isqr = function (o) {
              return this.imul(o, o.clone());
            }),
            (X.prototype.sqr = function (o) {
              return this.mul(o, o);
            }),
            (X.prototype.sqrt = function (o) {
              if (o.isZero()) return o.clone();
              var u = this.m.andln(3);
              if ((r(u % 2 === 1), u === 3)) {
                var l = this.m.add(new n(1)).iushrn(2);
                return this.pow(o, l);
              }
              for (var d = this.m.subn(1), g = 0; !d.isZero() && d.andln(1) === 0; )
                g++, d.iushrn(1);
              r(!d.isZero());
              var w = new n(1).toRed(this),
                M = w.redNeg(),
                v = this.m.subn(1).iushrn(1),
                a = this.m.bitLength();
              for (a = new n(2 * a * a).toRed(this); this.pow(a, v).cmp(M) !== 0; ) a.redIAdd(M);
              for (
                var b = this.pow(a, d),
                  k = this.pow(o, d.addn(1).iushrn(1)),
                  B = this.pow(o, d),
                  F = g;
                B.cmp(w) !== 0;

              ) {
                for (var P = B, C = 0; P.cmp(w) !== 0; C++) P = P.redSqr();
                r(C < F);
                var z = this.pow(b, new n(1).iushln(F - C - 1));
                (k = k.redMul(z)), (b = z.redSqr()), (B = B.redMul(b)), (F = C);
              }
              return k;
            }),
            (X.prototype.invm = function (o) {
              var u = o._invmp(this.m);
              return u.negative !== 0 ? ((u.negative = 0), this.imod(u).redNeg()) : this.imod(u);
            }),
            (X.prototype.pow = function (o, u) {
              if (u.isZero()) return new n(1).toRed(this);
              if (u.cmpn(1) === 0) return o.clone();
              var l = 4,
                d = new Array(1 << l);
              (d[0] = new n(1).toRed(this)), (d[1] = o);
              for (var g = 2; g < d.length; g++) d[g] = this.mul(d[g - 1], o);
              var w = d[0],
                M = 0,
                v = 0,
                a = u.bitLength() % 26;
              for (a === 0 && (a = 26), g = u.length - 1; g >= 0; g--) {
                for (var b = u.words[g], k = a - 1; k >= 0; k--) {
                  var B = (b >> k) & 1;
                  if ((w !== d[0] && (w = this.sqr(w)), B === 0 && M === 0)) {
                    v = 0;
                    continue;
                  }
                  (M <<= 1),
                    (M |= B),
                    v++,
                    !(v !== l && (g !== 0 || k !== 0)) &&
                      ((w = this.mul(w, d[M])), (v = 0), (M = 0));
                }
                a = 26;
              }
              return w;
            }),
            (X.prototype.convertTo = function (o) {
              var u = o.umod(this.m);
              return u === o ? u.clone() : u;
            }),
            (X.prototype.convertFrom = function (o) {
              var u = o.clone();
              return (u.red = null), u;
            }),
            (n.mont = function (o) {
              return new Oe(o);
            });
          function Oe(S) {
            X.call(this, S),
              (this.shift = this.m.bitLength()),
              this.shift % 26 !== 0 && (this.shift += 26 - (this.shift % 26)),
              (this.r = new n(1).iushln(this.shift)),
              (this.r2 = this.imod(this.r.sqr())),
              (this.rinv = this.r._invmp(this.m)),
              (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
              (this.minv = this.minv.umod(this.r)),
              (this.minv = this.r.sub(this.minv));
          }
          s(Oe, X),
            (Oe.prototype.convertTo = function (o) {
              return this.imod(o.ushln(this.shift));
            }),
            (Oe.prototype.convertFrom = function (o) {
              var u = this.imod(o.mul(this.rinv));
              return (u.red = null), u;
            }),
            (Oe.prototype.imul = function (o, u) {
              if (o.isZero() || u.isZero()) return (o.words[0] = 0), (o.length = 1), o;
              var l = o.imul(u),
                d = l.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                g = l.isub(d).iushrn(this.shift),
                w = g;
              return (
                g.cmp(this.m) >= 0 ? (w = g.isub(this.m)) : g.cmpn(0) < 0 && (w = g.iadd(this.m)),
                w._forceRed(this)
              );
            }),
            (Oe.prototype.mul = function (o, u) {
              if (o.isZero() || u.isZero()) return new n(0)._forceRed(this);
              var l = o.mul(u),
                d = l.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                g = l.isub(d).iushrn(this.shift),
                w = g;
              return (
                g.cmp(this.m) >= 0 ? (w = g.isub(this.m)) : g.cmpn(0) < 0 && (w = g.iadd(this.m)),
                w._forceRed(this)
              );
            }),
            (Oe.prototype.invm = function (o) {
              var u = this.imod(o._invmp(this.m).mul(this.r2));
              return u._forceRed(this);
            });
        })(i, se);
      })(_f)),
    _f.exports
  );
}
var e0 = {},
  Rv;
function a8() {
  return (
    Rv ||
      ((Rv = 1),
      (function (i) {
        var e = i;
        function t(n, c) {
          if (Array.isArray(n)) return n.slice();
          if (!n) return [];
          var f = [];
          if (typeof n != 'string') {
            for (var h = 0; h < n.length; h++) f[h] = n[h] | 0;
            return f;
          }
          if (c === 'hex') {
            (n = n.replace(/[^a-z0-9]+/gi, '')), n.length % 2 !== 0 && (n = '0' + n);
            for (var h = 0; h < n.length; h += 2) f.push(parseInt(n[h] + n[h + 1], 16));
          } else
            for (var h = 0; h < n.length; h++) {
              var y = n.charCodeAt(h),
                p = y >> 8,
                m = y & 255;
              p ? f.push(p, m) : f.push(m);
            }
          return f;
        }
        e.toArray = t;
        function r(n) {
          return n.length === 1 ? '0' + n : n;
        }
        e.zero2 = r;
        function s(n) {
          for (var c = '', f = 0; f < n.length; f++) c += r(n[f].toString(16));
          return c;
        }
        (e.toHex = s),
          (e.encode = function (c, f) {
            return f === 'hex' ? s(c) : c;
          });
      })(e0)),
    e0
  );
}
var Pv;
function en() {
  return (
    Pv ||
      ((Pv = 1),
      (function (i) {
        var e = i,
          t = co(),
          r = Qi,
          s = a8();
        (e.assert = r),
          (e.toArray = s.toArray),
          (e.zero2 = s.zero2),
          (e.toHex = s.toHex),
          (e.encode = s.encode);
        function n(p, m, _) {
          var A = new Array(Math.max(p.bitLength(), _) + 1),
            E;
          for (E = 0; E < A.length; E += 1) A[E] = 0;
          var I = 1 << (m + 1),
            R = p.clone();
          for (E = 0; E < A.length; E++) {
            var L,
              D = R.andln(I - 1);
            R.isOdd() ? (D > (I >> 1) - 1 ? (L = (I >> 1) - D) : (L = D), R.isubn(L)) : (L = 0),
              (A[E] = L),
              R.iushrn(1);
          }
          return A;
        }
        e.getNAF = n;
        function c(p, m) {
          var _ = [[], []];
          (p = p.clone()), (m = m.clone());
          for (var A = 0, E = 0, I; p.cmpn(-A) > 0 || m.cmpn(-E) > 0; ) {
            var R = (p.andln(3) + A) & 3,
              L = (m.andln(3) + E) & 3;
            R === 3 && (R = -1), L === 3 && (L = -1);
            var D;
            R & 1
              ? ((I = (p.andln(7) + A) & 7), (I === 3 || I === 5) && L === 2 ? (D = -R) : (D = R))
              : (D = 0),
              _[0].push(D);
            var q;
            L & 1
              ? ((I = (m.andln(7) + E) & 7), (I === 3 || I === 5) && R === 2 ? (q = -L) : (q = L))
              : (q = 0),
              _[1].push(q),
              2 * A === D + 1 && (A = 1 - A),
              2 * E === q + 1 && (E = 1 - E),
              p.iushrn(1),
              m.iushrn(1);
          }
          return _;
        }
        e.getJSF = c;
        function f(p, m, _) {
          var A = '_' + m;
          p.prototype[m] = function () {
            return this[A] !== void 0 ? this[A] : (this[A] = _.call(this));
          };
        }
        e.cachedProperty = f;
        function h(p) {
          return typeof p == 'string' ? e.toArray(p, 'hex') : p;
        }
        e.parseBytes = h;
        function y(p) {
          return new t(p, 'hex', 'le');
        }
        e.intFromLE = y;
      })(Qd)),
    Qd
  );
}
var t0 = {},
  r0,
  Tv;
function Ll() {
  if (Tv) return r0;
  Tv = 1;
  var i = co(),
    e = en(),
    t = e.getNAF,
    r = e.getJSF,
    s = e.assert;
  function n(f, h) {
    (this.type = f),
      (this.p = new i(h.p, 16)),
      (this.red = h.prime ? i.red(h.prime) : i.mont(this.p)),
      (this.zero = new i(0).toRed(this.red)),
      (this.one = new i(1).toRed(this.red)),
      (this.two = new i(2).toRed(this.red)),
      (this.n = h.n && new i(h.n, 16)),
      (this.g = h.g && this.pointFromJSON(h.g, h.gRed)),
      (this._wnafT1 = new Array(4)),
      (this._wnafT2 = new Array(4)),
      (this._wnafT3 = new Array(4)),
      (this._wnafT4 = new Array(4)),
      (this._bitLength = this.n ? this.n.bitLength() : 0);
    var y = this.n && this.p.div(this.n);
    !y || y.cmpn(100) > 0
      ? (this.redN = null)
      : ((this._maxwellTrick = !0), (this.redN = this.n.toRed(this.red)));
  }
  (r0 = n),
    (n.prototype.point = function () {
      throw new Error('Not implemented');
    }),
    (n.prototype.validate = function () {
      throw new Error('Not implemented');
    }),
    (n.prototype._fixedNafMul = function (h, y) {
      s(h.precomputed);
      var p = h._getDoubles(),
        m = t(y, 1, this._bitLength),
        _ = (1 << (p.step + 1)) - (p.step % 2 === 0 ? 2 : 1);
      _ /= 3;
      var A = [],
        E,
        I;
      for (E = 0; E < m.length; E += p.step) {
        I = 0;
        for (var R = E + p.step - 1; R >= E; R--) I = (I << 1) + m[R];
        A.push(I);
      }
      for (
        var L = this.jpoint(null, null, null), D = this.jpoint(null, null, null), q = _;
        q > 0;
        q--
      ) {
        for (E = 0; E < A.length; E++)
          (I = A[E]),
            I === q
              ? (D = D.mixedAdd(p.points[E]))
              : I === -q && (D = D.mixedAdd(p.points[E].neg()));
        L = L.add(D);
      }
      return L.toP();
    }),
    (n.prototype._wnafMul = function (h, y) {
      var p = 4,
        m = h._getNAFPoints(p);
      p = m.wnd;
      for (
        var _ = m.points,
          A = t(y, p, this._bitLength),
          E = this.jpoint(null, null, null),
          I = A.length - 1;
        I >= 0;
        I--
      ) {
        for (var R = 0; I >= 0 && A[I] === 0; I--) R++;
        if ((I >= 0 && R++, (E = E.dblp(R)), I < 0)) break;
        var L = A[I];
        s(L !== 0),
          h.type === 'affine'
            ? L > 0
              ? (E = E.mixedAdd(_[(L - 1) >> 1]))
              : (E = E.mixedAdd(_[(-L - 1) >> 1].neg()))
            : L > 0
              ? (E = E.add(_[(L - 1) >> 1]))
              : (E = E.add(_[(-L - 1) >> 1].neg()));
      }
      return h.type === 'affine' ? E.toP() : E;
    }),
    (n.prototype._wnafMulAdd = function (h, y, p, m, _) {
      var A = this._wnafT1,
        E = this._wnafT2,
        I = this._wnafT3,
        R = 0,
        L,
        D,
        q;
      for (L = 0; L < m; L++) {
        q = y[L];
        var H = q._getNAFPoints(h);
        (A[L] = H.wnd), (E[L] = H.points);
      }
      for (L = m - 1; L >= 1; L -= 2) {
        var V = L - 1,
          te = L;
        if (A[V] !== 1 || A[te] !== 1) {
          (I[V] = t(p[V], A[V], this._bitLength)),
            (I[te] = t(p[te], A[te], this._bitLength)),
            (R = Math.max(I[V].length, R)),
            (R = Math.max(I[te].length, R));
          continue;
        }
        var ue = [y[V], null, null, y[te]];
        y[V].y.cmp(y[te].y) === 0
          ? ((ue[1] = y[V].add(y[te])), (ue[2] = y[V].toJ().mixedAdd(y[te].neg())))
          : y[V].y.cmp(y[te].y.redNeg()) === 0
            ? ((ue[1] = y[V].toJ().mixedAdd(y[te])), (ue[2] = y[V].add(y[te].neg())))
            : ((ue[1] = y[V].toJ().mixedAdd(y[te])), (ue[2] = y[V].toJ().mixedAdd(y[te].neg())));
        var ne = [-3, -1, -5, -7, 0, 7, 5, 1, 3],
          X = r(p[V], p[te]);
        for (
          R = Math.max(X[0].length, R), I[V] = new Array(R), I[te] = new Array(R), D = 0;
          D < R;
          D++
        ) {
          var Oe = X[0][D] | 0,
            S = X[1][D] | 0;
          (I[V][D] = ne[(Oe + 1) * 3 + (S + 1)]), (I[te][D] = 0), (E[V] = ue);
        }
      }
      var o = this.jpoint(null, null, null),
        u = this._wnafT4;
      for (L = R; L >= 0; L--) {
        for (var l = 0; L >= 0; ) {
          var d = !0;
          for (D = 0; D < m; D++) (u[D] = I[D][L] | 0), u[D] !== 0 && (d = !1);
          if (!d) break;
          l++, L--;
        }
        if ((L >= 0 && l++, (o = o.dblp(l)), L < 0)) break;
        for (D = 0; D < m; D++) {
          var g = u[D];
          g !== 0 &&
            (g > 0 ? (q = E[D][(g - 1) >> 1]) : g < 0 && (q = E[D][(-g - 1) >> 1].neg()),
            q.type === 'affine' ? (o = o.mixedAdd(q)) : (o = o.add(q)));
        }
      }
      for (L = 0; L < m; L++) E[L] = null;
      return _ ? o : o.toP();
    });
  function c(f, h) {
    (this.curve = f), (this.type = h), (this.precomputed = null);
  }
  return (
    (n.BasePoint = c),
    (c.prototype.eq = function () {
      throw new Error('Not implemented');
    }),
    (c.prototype.validate = function () {
      return this.curve.validate(this);
    }),
    (n.prototype.decodePoint = function (h, y) {
      h = e.toArray(h, y);
      var p = this.p.byteLength();
      if ((h[0] === 4 || h[0] === 6 || h[0] === 7) && h.length - 1 === 2 * p) {
        h[0] === 6 ? s(h[h.length - 1] % 2 === 0) : h[0] === 7 && s(h[h.length - 1] % 2 === 1);
        var m = this.point(h.slice(1, 1 + p), h.slice(1 + p, 1 + 2 * p));
        return m;
      } else if ((h[0] === 2 || h[0] === 3) && h.length - 1 === p)
        return this.pointFromX(h.slice(1, 1 + p), h[0] === 3);
      throw new Error('Unknown point format');
    }),
    (c.prototype.encodeCompressed = function (h) {
      return this.encode(h, !0);
    }),
    (c.prototype._encode = function (h) {
      var y = this.curve.p.byteLength(),
        p = this.getX().toArray('be', y);
      return h
        ? [this.getY().isEven() ? 2 : 3].concat(p)
        : [4].concat(p, this.getY().toArray('be', y));
    }),
    (c.prototype.encode = function (h, y) {
      return e.encode(this._encode(y), h);
    }),
    (c.prototype.precompute = function (h) {
      if (this.precomputed) return this;
      var y = { doubles: null, naf: null, beta: null };
      return (
        (y.naf = this._getNAFPoints(8)),
        (y.doubles = this._getDoubles(4, h)),
        (y.beta = this._getBeta()),
        (this.precomputed = y),
        this
      );
    }),
    (c.prototype._hasDoubles = function (h) {
      if (!this.precomputed) return !1;
      var y = this.precomputed.doubles;
      return y ? y.points.length >= Math.ceil((h.bitLength() + 1) / y.step) : !1;
    }),
    (c.prototype._getDoubles = function (h, y) {
      if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
      for (var p = [this], m = this, _ = 0; _ < y; _ += h) {
        for (var A = 0; A < h; A++) m = m.dbl();
        p.push(m);
      }
      return { step: h, points: p };
    }),
    (c.prototype._getNAFPoints = function (h) {
      if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
      for (var y = [this], p = (1 << h) - 1, m = p === 1 ? null : this.dbl(), _ = 1; _ < p; _++)
        y[_] = y[_ - 1].add(m);
      return { wnd: h, points: y };
    }),
    (c.prototype._getBeta = function () {
      return null;
    }),
    (c.prototype.dblp = function (h) {
      for (var y = this, p = 0; p < h; p++) y = y.dbl();
      return y;
    }),
    r0
  );
}
var i0, Ov;
function Hk() {
  if (Ov) return i0;
  Ov = 1;
  var i = en(),
    e = co(),
    t = dt,
    r = Ll(),
    s = i.assert;
  function n(h) {
    r.call(this, 'short', h),
      (this.a = new e(h.a, 16).toRed(this.red)),
      (this.b = new e(h.b, 16).toRed(this.red)),
      (this.tinv = this.two.redInvm()),
      (this.zeroA = this.a.fromRed().cmpn(0) === 0),
      (this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0),
      (this.endo = this._getEndomorphism(h)),
      (this._endoWnafT1 = new Array(4)),
      (this._endoWnafT2 = new Array(4));
  }
  t(n, r),
    (i0 = n),
    (n.prototype._getEndomorphism = function (y) {
      if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
        var p, m;
        if (y.beta) p = new e(y.beta, 16).toRed(this.red);
        else {
          var _ = this._getEndoRoots(this.p);
          (p = _[0].cmp(_[1]) < 0 ? _[0] : _[1]), (p = p.toRed(this.red));
        }
        if (y.lambda) m = new e(y.lambda, 16);
        else {
          var A = this._getEndoRoots(this.n);
          this.g.mul(A[0]).x.cmp(this.g.x.redMul(p)) === 0
            ? (m = A[0])
            : ((m = A[1]), s(this.g.mul(m).x.cmp(this.g.x.redMul(p)) === 0));
        }
        var E;
        return (
          y.basis
            ? (E = y.basis.map(function (I) {
                return { a: new e(I.a, 16), b: new e(I.b, 16) };
              }))
            : (E = this._getEndoBasis(m)),
          { beta: p, lambda: m, basis: E }
        );
      }
    }),
    (n.prototype._getEndoRoots = function (y) {
      var p = y === this.p ? this.red : e.mont(y),
        m = new e(2).toRed(p).redInvm(),
        _ = m.redNeg(),
        A = new e(3).toRed(p).redNeg().redSqrt().redMul(m),
        E = _.redAdd(A).fromRed(),
        I = _.redSub(A).fromRed();
      return [E, I];
    }),
    (n.prototype._getEndoBasis = function (y) {
      for (
        var p = this.n.ushrn(Math.floor(this.n.bitLength() / 2)),
          m = y,
          _ = this.n.clone(),
          A = new e(1),
          E = new e(0),
          I = new e(0),
          R = new e(1),
          L,
          D,
          q,
          H,
          V,
          te,
          ue,
          ne = 0,
          X,
          Oe;
        m.cmpn(0) !== 0;

      ) {
        var S = _.div(m);
        (X = _.sub(S.mul(m))), (Oe = I.sub(S.mul(A)));
        var o = R.sub(S.mul(E));
        if (!q && X.cmp(p) < 0) (L = ue.neg()), (D = A), (q = X.neg()), (H = Oe);
        else if (q && ++ne === 2) break;
        (ue = X), (_ = m), (m = X), (I = A), (A = Oe), (R = E), (E = o);
      }
      (V = X.neg()), (te = Oe);
      var u = q.sqr().add(H.sqr()),
        l = V.sqr().add(te.sqr());
      return (
        l.cmp(u) >= 0 && ((V = L), (te = D)),
        q.negative && ((q = q.neg()), (H = H.neg())),
        V.negative && ((V = V.neg()), (te = te.neg())),
        [
          { a: q, b: H },
          { a: V, b: te },
        ]
      );
    }),
    (n.prototype._endoSplit = function (y) {
      var p = this.endo.basis,
        m = p[0],
        _ = p[1],
        A = _.b.mul(y).divRound(this.n),
        E = m.b.neg().mul(y).divRound(this.n),
        I = A.mul(m.a),
        R = E.mul(_.a),
        L = A.mul(m.b),
        D = E.mul(_.b),
        q = y.sub(I).sub(R),
        H = L.add(D).neg();
      return { k1: q, k2: H };
    }),
    (n.prototype.pointFromX = function (y, p) {
      (y = new e(y, 16)), y.red || (y = y.toRed(this.red));
      var m = y.redSqr().redMul(y).redIAdd(y.redMul(this.a)).redIAdd(this.b),
        _ = m.redSqrt();
      if (_.redSqr().redSub(m).cmp(this.zero) !== 0) throw new Error('invalid point');
      var A = _.fromRed().isOdd();
      return ((p && !A) || (!p && A)) && (_ = _.redNeg()), this.point(y, _);
    }),
    (n.prototype.validate = function (y) {
      if (y.inf) return !0;
      var p = y.x,
        m = y.y,
        _ = this.a.redMul(p),
        A = p.redSqr().redMul(p).redIAdd(_).redIAdd(this.b);
      return m.redSqr().redISub(A).cmpn(0) === 0;
    }),
    (n.prototype._endoWnafMulAdd = function (y, p, m) {
      for (var _ = this._endoWnafT1, A = this._endoWnafT2, E = 0; E < y.length; E++) {
        var I = this._endoSplit(p[E]),
          R = y[E],
          L = R._getBeta();
        I.k1.negative && (I.k1.ineg(), (R = R.neg(!0))),
          I.k2.negative && (I.k2.ineg(), (L = L.neg(!0))),
          (_[E * 2] = R),
          (_[E * 2 + 1] = L),
          (A[E * 2] = I.k1),
          (A[E * 2 + 1] = I.k2);
      }
      for (var D = this._wnafMulAdd(1, _, A, E * 2, m), q = 0; q < E * 2; q++)
        (_[q] = null), (A[q] = null);
      return D;
    });
  function c(h, y, p, m) {
    r.BasePoint.call(this, h, 'affine'),
      y === null && p === null
        ? ((this.x = null), (this.y = null), (this.inf = !0))
        : ((this.x = new e(y, 16)),
          (this.y = new e(p, 16)),
          m && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)),
          this.x.red || (this.x = this.x.toRed(this.curve.red)),
          this.y.red || (this.y = this.y.toRed(this.curve.red)),
          (this.inf = !1));
  }
  t(c, r.BasePoint),
    (n.prototype.point = function (y, p, m) {
      return new c(this, y, p, m);
    }),
    (n.prototype.pointFromJSON = function (y, p) {
      return c.fromJSON(this, y, p);
    }),
    (c.prototype._getBeta = function () {
      if (this.curve.endo) {
        var y = this.precomputed;
        if (y && y.beta) return y.beta;
        var p = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (y) {
          var m = this.curve,
            _ = function (A) {
              return m.point(A.x.redMul(m.endo.beta), A.y);
            };
          (y.beta = p),
            (p.precomputed = {
              beta: null,
              naf: y.naf && { wnd: y.naf.wnd, points: y.naf.points.map(_) },
              doubles: y.doubles && { step: y.doubles.step, points: y.doubles.points.map(_) },
            });
        }
        return p;
      }
    }),
    (c.prototype.toJSON = function () {
      return this.precomputed
        ? [
            this.x,
            this.y,
            this.precomputed && {
              doubles: this.precomputed.doubles && {
                step: this.precomputed.doubles.step,
                points: this.precomputed.doubles.points.slice(1),
              },
              naf: this.precomputed.naf && {
                wnd: this.precomputed.naf.wnd,
                points: this.precomputed.naf.points.slice(1),
              },
            },
          ]
        : [this.x, this.y];
    }),
    (c.fromJSON = function (y, p, m) {
      typeof p == 'string' && (p = JSON.parse(p));
      var _ = y.point(p[0], p[1], m);
      if (!p[2]) return _;
      function A(I) {
        return y.point(I[0], I[1], m);
      }
      var E = p[2];
      return (
        (_.precomputed = {
          beta: null,
          doubles: E.doubles && {
            step: E.doubles.step,
            points: [_].concat(E.doubles.points.map(A)),
          },
          naf: E.naf && { wnd: E.naf.wnd, points: [_].concat(E.naf.points.map(A)) },
        }),
        _
      );
    }),
    (c.prototype.inspect = function () {
      return this.isInfinity()
        ? '<EC Point Infinity>'
        : '<EC Point x: ' +
            this.x.fromRed().toString(16, 2) +
            ' y: ' +
            this.y.fromRed().toString(16, 2) +
            '>';
    }),
    (c.prototype.isInfinity = function () {
      return this.inf;
    }),
    (c.prototype.add = function (y) {
      if (this.inf) return y;
      if (y.inf) return this;
      if (this.eq(y)) return this.dbl();
      if (this.neg().eq(y)) return this.curve.point(null, null);
      if (this.x.cmp(y.x) === 0) return this.curve.point(null, null);
      var p = this.y.redSub(y.y);
      p.cmpn(0) !== 0 && (p = p.redMul(this.x.redSub(y.x).redInvm()));
      var m = p.redSqr().redISub(this.x).redISub(y.x),
        _ = p.redMul(this.x.redSub(m)).redISub(this.y);
      return this.curve.point(m, _);
    }),
    (c.prototype.dbl = function () {
      if (this.inf) return this;
      var y = this.y.redAdd(this.y);
      if (y.cmpn(0) === 0) return this.curve.point(null, null);
      var p = this.curve.a,
        m = this.x.redSqr(),
        _ = y.redInvm(),
        A = m.redAdd(m).redIAdd(m).redIAdd(p).redMul(_),
        E = A.redSqr().redISub(this.x.redAdd(this.x)),
        I = A.redMul(this.x.redSub(E)).redISub(this.y);
      return this.curve.point(E, I);
    }),
    (c.prototype.getX = function () {
      return this.x.fromRed();
    }),
    (c.prototype.getY = function () {
      return this.y.fromRed();
    }),
    (c.prototype.mul = function (y) {
      return (
        (y = new e(y, 16)),
        this.isInfinity()
          ? this
          : this._hasDoubles(y)
            ? this.curve._fixedNafMul(this, y)
            : this.curve.endo
              ? this.curve._endoWnafMulAdd([this], [y])
              : this.curve._wnafMul(this, y)
      );
    }),
    (c.prototype.mulAdd = function (y, p, m) {
      var _ = [this, p],
        A = [y, m];
      return this.curve.endo
        ? this.curve._endoWnafMulAdd(_, A)
        : this.curve._wnafMulAdd(1, _, A, 2);
    }),
    (c.prototype.jmulAdd = function (y, p, m) {
      var _ = [this, p],
        A = [y, m];
      return this.curve.endo
        ? this.curve._endoWnafMulAdd(_, A, !0)
        : this.curve._wnafMulAdd(1, _, A, 2, !0);
    }),
    (c.prototype.eq = function (y) {
      return (
        this === y ||
        (this.inf === y.inf && (this.inf || (this.x.cmp(y.x) === 0 && this.y.cmp(y.y) === 0)))
      );
    }),
    (c.prototype.neg = function (y) {
      if (this.inf) return this;
      var p = this.curve.point(this.x, this.y.redNeg());
      if (y && this.precomputed) {
        var m = this.precomputed,
          _ = function (A) {
            return A.neg();
          };
        p.precomputed = {
          naf: m.naf && { wnd: m.naf.wnd, points: m.naf.points.map(_) },
          doubles: m.doubles && { step: m.doubles.step, points: m.doubles.points.map(_) },
        };
      }
      return p;
    }),
    (c.prototype.toJ = function () {
      if (this.inf) return this.curve.jpoint(null, null, null);
      var y = this.curve.jpoint(this.x, this.y, this.curve.one);
      return y;
    });
  function f(h, y, p, m) {
    r.BasePoint.call(this, h, 'jacobian'),
      y === null && p === null && m === null
        ? ((this.x = this.curve.one), (this.y = this.curve.one), (this.z = new e(0)))
        : ((this.x = new e(y, 16)), (this.y = new e(p, 16)), (this.z = new e(m, 16))),
      this.x.red || (this.x = this.x.toRed(this.curve.red)),
      this.y.red || (this.y = this.y.toRed(this.curve.red)),
      this.z.red || (this.z = this.z.toRed(this.curve.red)),
      (this.zOne = this.z === this.curve.one);
  }
  return (
    t(f, r.BasePoint),
    (n.prototype.jpoint = function (y, p, m) {
      return new f(this, y, p, m);
    }),
    (f.prototype.toP = function () {
      if (this.isInfinity()) return this.curve.point(null, null);
      var y = this.z.redInvm(),
        p = y.redSqr(),
        m = this.x.redMul(p),
        _ = this.y.redMul(p).redMul(y);
      return this.curve.point(m, _);
    }),
    (f.prototype.neg = function () {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    }),
    (f.prototype.add = function (y) {
      if (this.isInfinity()) return y;
      if (y.isInfinity()) return this;
      var p = y.z.redSqr(),
        m = this.z.redSqr(),
        _ = this.x.redMul(p),
        A = y.x.redMul(m),
        E = this.y.redMul(p.redMul(y.z)),
        I = y.y.redMul(m.redMul(this.z)),
        R = _.redSub(A),
        L = E.redSub(I);
      if (R.cmpn(0) === 0)
        return L.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
      var D = R.redSqr(),
        q = D.redMul(R),
        H = _.redMul(D),
        V = L.redSqr().redIAdd(q).redISub(H).redISub(H),
        te = L.redMul(H.redISub(V)).redISub(E.redMul(q)),
        ue = this.z.redMul(y.z).redMul(R);
      return this.curve.jpoint(V, te, ue);
    }),
    (f.prototype.mixedAdd = function (y) {
      if (this.isInfinity()) return y.toJ();
      if (y.isInfinity()) return this;
      var p = this.z.redSqr(),
        m = this.x,
        _ = y.x.redMul(p),
        A = this.y,
        E = y.y.redMul(p).redMul(this.z),
        I = m.redSub(_),
        R = A.redSub(E);
      if (I.cmpn(0) === 0)
        return R.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
      var L = I.redSqr(),
        D = L.redMul(I),
        q = m.redMul(L),
        H = R.redSqr().redIAdd(D).redISub(q).redISub(q),
        V = R.redMul(q.redISub(H)).redISub(A.redMul(D)),
        te = this.z.redMul(I);
      return this.curve.jpoint(H, V, te);
    }),
    (f.prototype.dblp = function (y) {
      if (y === 0) return this;
      if (this.isInfinity()) return this;
      if (!y) return this.dbl();
      var p;
      if (this.curve.zeroA || this.curve.threeA) {
        var m = this;
        for (p = 0; p < y; p++) m = m.dbl();
        return m;
      }
      var _ = this.curve.a,
        A = this.curve.tinv,
        E = this.x,
        I = this.y,
        R = this.z,
        L = R.redSqr().redSqr(),
        D = I.redAdd(I);
      for (p = 0; p < y; p++) {
        var q = E.redSqr(),
          H = D.redSqr(),
          V = H.redSqr(),
          te = q.redAdd(q).redIAdd(q).redIAdd(_.redMul(L)),
          ue = E.redMul(H),
          ne = te.redSqr().redISub(ue.redAdd(ue)),
          X = ue.redISub(ne),
          Oe = te.redMul(X);
        Oe = Oe.redIAdd(Oe).redISub(V);
        var S = D.redMul(R);
        p + 1 < y && (L = L.redMul(V)), (E = ne), (R = S), (D = Oe);
      }
      return this.curve.jpoint(E, D.redMul(A), R);
    }),
    (f.prototype.dbl = function () {
      return this.isInfinity()
        ? this
        : this.curve.zeroA
          ? this._zeroDbl()
          : this.curve.threeA
            ? this._threeDbl()
            : this._dbl();
    }),
    (f.prototype._zeroDbl = function () {
      var y, p, m;
      if (this.zOne) {
        var _ = this.x.redSqr(),
          A = this.y.redSqr(),
          E = A.redSqr(),
          I = this.x.redAdd(A).redSqr().redISub(_).redISub(E);
        I = I.redIAdd(I);
        var R = _.redAdd(_).redIAdd(_),
          L = R.redSqr().redISub(I).redISub(I),
          D = E.redIAdd(E);
        (D = D.redIAdd(D)),
          (D = D.redIAdd(D)),
          (y = L),
          (p = R.redMul(I.redISub(L)).redISub(D)),
          (m = this.y.redAdd(this.y));
      } else {
        var q = this.x.redSqr(),
          H = this.y.redSqr(),
          V = H.redSqr(),
          te = this.x.redAdd(H).redSqr().redISub(q).redISub(V);
        te = te.redIAdd(te);
        var ue = q.redAdd(q).redIAdd(q),
          ne = ue.redSqr(),
          X = V.redIAdd(V);
        (X = X.redIAdd(X)),
          (X = X.redIAdd(X)),
          (y = ne.redISub(te).redISub(te)),
          (p = ue.redMul(te.redISub(y)).redISub(X)),
          (m = this.y.redMul(this.z)),
          (m = m.redIAdd(m));
      }
      return this.curve.jpoint(y, p, m);
    }),
    (f.prototype._threeDbl = function () {
      var y, p, m;
      if (this.zOne) {
        var _ = this.x.redSqr(),
          A = this.y.redSqr(),
          E = A.redSqr(),
          I = this.x.redAdd(A).redSqr().redISub(_).redISub(E);
        I = I.redIAdd(I);
        var R = _.redAdd(_).redIAdd(_).redIAdd(this.curve.a),
          L = R.redSqr().redISub(I).redISub(I);
        y = L;
        var D = E.redIAdd(E);
        (D = D.redIAdd(D)),
          (D = D.redIAdd(D)),
          (p = R.redMul(I.redISub(L)).redISub(D)),
          (m = this.y.redAdd(this.y));
      } else {
        var q = this.z.redSqr(),
          H = this.y.redSqr(),
          V = this.x.redMul(H),
          te = this.x.redSub(q).redMul(this.x.redAdd(q));
        te = te.redAdd(te).redIAdd(te);
        var ue = V.redIAdd(V);
        ue = ue.redIAdd(ue);
        var ne = ue.redAdd(ue);
        (y = te.redSqr().redISub(ne)), (m = this.y.redAdd(this.z).redSqr().redISub(H).redISub(q));
        var X = H.redSqr();
        (X = X.redIAdd(X)),
          (X = X.redIAdd(X)),
          (X = X.redIAdd(X)),
          (p = te.redMul(ue.redISub(y)).redISub(X));
      }
      return this.curve.jpoint(y, p, m);
    }),
    (f.prototype._dbl = function () {
      var y = this.curve.a,
        p = this.x,
        m = this.y,
        _ = this.z,
        A = _.redSqr().redSqr(),
        E = p.redSqr(),
        I = m.redSqr(),
        R = E.redAdd(E).redIAdd(E).redIAdd(y.redMul(A)),
        L = p.redAdd(p);
      L = L.redIAdd(L);
      var D = L.redMul(I),
        q = R.redSqr().redISub(D.redAdd(D)),
        H = D.redISub(q),
        V = I.redSqr();
      (V = V.redIAdd(V)), (V = V.redIAdd(V)), (V = V.redIAdd(V));
      var te = R.redMul(H).redISub(V),
        ue = m.redAdd(m).redMul(_);
      return this.curve.jpoint(q, te, ue);
    }),
    (f.prototype.trpl = function () {
      if (!this.curve.zeroA) return this.dbl().add(this);
      var y = this.x.redSqr(),
        p = this.y.redSqr(),
        m = this.z.redSqr(),
        _ = p.redSqr(),
        A = y.redAdd(y).redIAdd(y),
        E = A.redSqr(),
        I = this.x.redAdd(p).redSqr().redISub(y).redISub(_);
      (I = I.redIAdd(I)), (I = I.redAdd(I).redIAdd(I)), (I = I.redISub(E));
      var R = I.redSqr(),
        L = _.redIAdd(_);
      (L = L.redIAdd(L)), (L = L.redIAdd(L)), (L = L.redIAdd(L));
      var D = A.redIAdd(I).redSqr().redISub(E).redISub(R).redISub(L),
        q = p.redMul(D);
      (q = q.redIAdd(q)), (q = q.redIAdd(q));
      var H = this.x.redMul(R).redISub(q);
      (H = H.redIAdd(H)), (H = H.redIAdd(H));
      var V = this.y.redMul(D.redMul(L.redISub(D)).redISub(I.redMul(R)));
      (V = V.redIAdd(V)), (V = V.redIAdd(V)), (V = V.redIAdd(V));
      var te = this.z.redAdd(I).redSqr().redISub(m).redISub(R);
      return this.curve.jpoint(H, V, te);
    }),
    (f.prototype.mul = function (y, p) {
      return (y = new e(y, p)), this.curve._wnafMul(this, y);
    }),
    (f.prototype.eq = function (y) {
      if (y.type === 'affine') return this.eq(y.toJ());
      if (this === y) return !0;
      var p = this.z.redSqr(),
        m = y.z.redSqr();
      if (this.x.redMul(m).redISub(y.x.redMul(p)).cmpn(0) !== 0) return !1;
      var _ = p.redMul(this.z),
        A = m.redMul(y.z);
      return this.y.redMul(A).redISub(y.y.redMul(_)).cmpn(0) === 0;
    }),
    (f.prototype.eqXToP = function (y) {
      var p = this.z.redSqr(),
        m = y.toRed(this.curve.red).redMul(p);
      if (this.x.cmp(m) === 0) return !0;
      for (var _ = y.clone(), A = this.curve.redN.redMul(p); ; ) {
        if ((_.iadd(this.curve.n), _.cmp(this.curve.p) >= 0)) return !1;
        if ((m.redIAdd(A), this.x.cmp(m) === 0)) return !0;
      }
    }),
    (f.prototype.inspect = function () {
      return this.isInfinity()
        ? '<EC JPoint Infinity>'
        : '<EC JPoint x: ' +
            this.x.toString(16, 2) +
            ' y: ' +
            this.y.toString(16, 2) +
            ' z: ' +
            this.z.toString(16, 2) +
            '>';
    }),
    (f.prototype.isInfinity = function () {
      return this.z.cmpn(0) === 0;
    }),
    i0
  );
}
var n0, Cv;
function Vk() {
  if (Cv) return n0;
  Cv = 1;
  var i = co(),
    e = dt,
    t = Ll(),
    r = en();
  function s(c) {
    t.call(this, 'mont', c),
      (this.a = new i(c.a, 16).toRed(this.red)),
      (this.b = new i(c.b, 16).toRed(this.red)),
      (this.i4 = new i(4).toRed(this.red).redInvm()),
      (this.two = new i(2).toRed(this.red)),
      (this.a24 = this.i4.redMul(this.a.redAdd(this.two)));
  }
  e(s, t),
    (n0 = s),
    (s.prototype.validate = function (f) {
      var h = f.normalize().x,
        y = h.redSqr(),
        p = y.redMul(h).redAdd(y.redMul(this.a)).redAdd(h),
        m = p.redSqrt();
      return m.redSqr().cmp(p) === 0;
    });
  function n(c, f, h) {
    t.BasePoint.call(this, c, 'projective'),
      f === null && h === null
        ? ((this.x = this.curve.one), (this.z = this.curve.zero))
        : ((this.x = new i(f, 16)),
          (this.z = new i(h, 16)),
          this.x.red || (this.x = this.x.toRed(this.curve.red)),
          this.z.red || (this.z = this.z.toRed(this.curve.red)));
  }
  return (
    e(n, t.BasePoint),
    (s.prototype.decodePoint = function (f, h) {
      return this.point(r.toArray(f, h), 1);
    }),
    (s.prototype.point = function (f, h) {
      return new n(this, f, h);
    }),
    (s.prototype.pointFromJSON = function (f) {
      return n.fromJSON(this, f);
    }),
    (n.prototype.precompute = function () {}),
    (n.prototype._encode = function () {
      return this.getX().toArray('be', this.curve.p.byteLength());
    }),
    (n.fromJSON = function (f, h) {
      return new n(f, h[0], h[1] || f.one);
    }),
    (n.prototype.inspect = function () {
      return this.isInfinity()
        ? '<EC Point Infinity>'
        : '<EC Point x: ' +
            this.x.fromRed().toString(16, 2) +
            ' z: ' +
            this.z.fromRed().toString(16, 2) +
            '>';
    }),
    (n.prototype.isInfinity = function () {
      return this.z.cmpn(0) === 0;
    }),
    (n.prototype.dbl = function () {
      var f = this.x.redAdd(this.z),
        h = f.redSqr(),
        y = this.x.redSub(this.z),
        p = y.redSqr(),
        m = h.redSub(p),
        _ = h.redMul(p),
        A = m.redMul(p.redAdd(this.curve.a24.redMul(m)));
      return this.curve.point(_, A);
    }),
    (n.prototype.add = function () {
      throw new Error('Not supported on Montgomery curve');
    }),
    (n.prototype.diffAdd = function (f, h) {
      var y = this.x.redAdd(this.z),
        p = this.x.redSub(this.z),
        m = f.x.redAdd(f.z),
        _ = f.x.redSub(f.z),
        A = _.redMul(y),
        E = m.redMul(p),
        I = h.z.redMul(A.redAdd(E).redSqr()),
        R = h.x.redMul(A.redISub(E).redSqr());
      return this.curve.point(I, R);
    }),
    (n.prototype.mul = function (f) {
      for (
        var h = f.clone(), y = this, p = this.curve.point(null, null), m = this, _ = [];
        h.cmpn(0) !== 0;
        h.iushrn(1)
      )
        _.push(h.andln(1));
      for (var A = _.length - 1; A >= 0; A--)
        _[A] === 0
          ? ((y = y.diffAdd(p, m)), (p = p.dbl()))
          : ((p = y.diffAdd(p, m)), (y = y.dbl()));
      return p;
    }),
    (n.prototype.mulAdd = function () {
      throw new Error('Not supported on Montgomery curve');
    }),
    (n.prototype.jumlAdd = function () {
      throw new Error('Not supported on Montgomery curve');
    }),
    (n.prototype.eq = function (f) {
      return this.getX().cmp(f.getX()) === 0;
    }),
    (n.prototype.normalize = function () {
      return (this.x = this.x.redMul(this.z.redInvm())), (this.z = this.curve.one), this;
    }),
    (n.prototype.getX = function () {
      return this.normalize(), this.x.fromRed();
    }),
    n0
  );
}
var o0, Lv;
function Gk() {
  if (Lv) return o0;
  Lv = 1;
  var i = en(),
    e = co(),
    t = dt,
    r = Ll(),
    s = i.assert;
  function n(f) {
    (this.twisted = (f.a | 0) !== 1),
      (this.mOneA = this.twisted && (f.a | 0) === -1),
      (this.extended = this.mOneA),
      r.call(this, 'edwards', f),
      (this.a = new e(f.a, 16).umod(this.red.m)),
      (this.a = this.a.toRed(this.red)),
      (this.c = new e(f.c, 16).toRed(this.red)),
      (this.c2 = this.c.redSqr()),
      (this.d = new e(f.d, 16).toRed(this.red)),
      (this.dd = this.d.redAdd(this.d)),
      s(!this.twisted || this.c.fromRed().cmpn(1) === 0),
      (this.oneC = (f.c | 0) === 1);
  }
  t(n, r),
    (o0 = n),
    (n.prototype._mulA = function (h) {
      return this.mOneA ? h.redNeg() : this.a.redMul(h);
    }),
    (n.prototype._mulC = function (h) {
      return this.oneC ? h : this.c.redMul(h);
    }),
    (n.prototype.jpoint = function (h, y, p, m) {
      return this.point(h, y, p, m);
    }),
    (n.prototype.pointFromX = function (h, y) {
      (h = new e(h, 16)), h.red || (h = h.toRed(this.red));
      var p = h.redSqr(),
        m = this.c2.redSub(this.a.redMul(p)),
        _ = this.one.redSub(this.c2.redMul(this.d).redMul(p)),
        A = m.redMul(_.redInvm()),
        E = A.redSqrt();
      if (E.redSqr().redSub(A).cmp(this.zero) !== 0) throw new Error('invalid point');
      var I = E.fromRed().isOdd();
      return ((y && !I) || (!y && I)) && (E = E.redNeg()), this.point(h, E);
    }),
    (n.prototype.pointFromY = function (h, y) {
      (h = new e(h, 16)), h.red || (h = h.toRed(this.red));
      var p = h.redSqr(),
        m = p.redSub(this.c2),
        _ = p.redMul(this.d).redMul(this.c2).redSub(this.a),
        A = m.redMul(_.redInvm());
      if (A.cmp(this.zero) === 0) {
        if (y) throw new Error('invalid point');
        return this.point(this.zero, h);
      }
      var E = A.redSqrt();
      if (E.redSqr().redSub(A).cmp(this.zero) !== 0) throw new Error('invalid point');
      return E.fromRed().isOdd() !== y && (E = E.redNeg()), this.point(E, h);
    }),
    (n.prototype.validate = function (h) {
      if (h.isInfinity()) return !0;
      h.normalize();
      var y = h.x.redSqr(),
        p = h.y.redSqr(),
        m = y.redMul(this.a).redAdd(p),
        _ = this.c2.redMul(this.one.redAdd(this.d.redMul(y).redMul(p)));
      return m.cmp(_) === 0;
    });
  function c(f, h, y, p, m) {
    r.BasePoint.call(this, f, 'projective'),
      h === null && y === null && p === null
        ? ((this.x = this.curve.zero),
          (this.y = this.curve.one),
          (this.z = this.curve.one),
          (this.t = this.curve.zero),
          (this.zOne = !0))
        : ((this.x = new e(h, 16)),
          (this.y = new e(y, 16)),
          (this.z = p ? new e(p, 16) : this.curve.one),
          (this.t = m && new e(m, 16)),
          this.x.red || (this.x = this.x.toRed(this.curve.red)),
          this.y.red || (this.y = this.y.toRed(this.curve.red)),
          this.z.red || (this.z = this.z.toRed(this.curve.red)),
          this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)),
          (this.zOne = this.z === this.curve.one),
          this.curve.extended &&
            !this.t &&
            ((this.t = this.x.redMul(this.y)),
            this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
  }
  return (
    t(c, r.BasePoint),
    (n.prototype.pointFromJSON = function (h) {
      return c.fromJSON(this, h);
    }),
    (n.prototype.point = function (h, y, p, m) {
      return new c(this, h, y, p, m);
    }),
    (c.fromJSON = function (h, y) {
      return new c(h, y[0], y[1], y[2]);
    }),
    (c.prototype.inspect = function () {
      return this.isInfinity()
        ? '<EC Point Infinity>'
        : '<EC Point x: ' +
            this.x.fromRed().toString(16, 2) +
            ' y: ' +
            this.y.fromRed().toString(16, 2) +
            ' z: ' +
            this.z.fromRed().toString(16, 2) +
            '>';
    }),
    (c.prototype.isInfinity = function () {
      return (
        this.x.cmpn(0) === 0 &&
        (this.y.cmp(this.z) === 0 || (this.zOne && this.y.cmp(this.curve.c) === 0))
      );
    }),
    (c.prototype._extDbl = function () {
      var h = this.x.redSqr(),
        y = this.y.redSqr(),
        p = this.z.redSqr();
      p = p.redIAdd(p);
      var m = this.curve._mulA(h),
        _ = this.x.redAdd(this.y).redSqr().redISub(h).redISub(y),
        A = m.redAdd(y),
        E = A.redSub(p),
        I = m.redSub(y),
        R = _.redMul(E),
        L = A.redMul(I),
        D = _.redMul(I),
        q = E.redMul(A);
      return this.curve.point(R, L, q, D);
    }),
    (c.prototype._projDbl = function () {
      var h = this.x.redAdd(this.y).redSqr(),
        y = this.x.redSqr(),
        p = this.y.redSqr(),
        m,
        _,
        A,
        E,
        I,
        R;
      if (this.curve.twisted) {
        E = this.curve._mulA(y);
        var L = E.redAdd(p);
        this.zOne
          ? ((m = h.redSub(y).redSub(p).redMul(L.redSub(this.curve.two))),
            (_ = L.redMul(E.redSub(p))),
            (A = L.redSqr().redSub(L).redSub(L)))
          : ((I = this.z.redSqr()),
            (R = L.redSub(I).redISub(I)),
            (m = h.redSub(y).redISub(p).redMul(R)),
            (_ = L.redMul(E.redSub(p))),
            (A = L.redMul(R)));
      } else
        (E = y.redAdd(p)),
          (I = this.curve._mulC(this.z).redSqr()),
          (R = E.redSub(I).redSub(I)),
          (m = this.curve._mulC(h.redISub(E)).redMul(R)),
          (_ = this.curve._mulC(E).redMul(y.redISub(p))),
          (A = E.redMul(R));
      return this.curve.point(m, _, A);
    }),
    (c.prototype.dbl = function () {
      return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
    }),
    (c.prototype._extAdd = function (h) {
      var y = this.y.redSub(this.x).redMul(h.y.redSub(h.x)),
        p = this.y.redAdd(this.x).redMul(h.y.redAdd(h.x)),
        m = this.t.redMul(this.curve.dd).redMul(h.t),
        _ = this.z.redMul(h.z.redAdd(h.z)),
        A = p.redSub(y),
        E = _.redSub(m),
        I = _.redAdd(m),
        R = p.redAdd(y),
        L = A.redMul(E),
        D = I.redMul(R),
        q = A.redMul(R),
        H = E.redMul(I);
      return this.curve.point(L, D, H, q);
    }),
    (c.prototype._projAdd = function (h) {
      var y = this.z.redMul(h.z),
        p = y.redSqr(),
        m = this.x.redMul(h.x),
        _ = this.y.redMul(h.y),
        A = this.curve.d.redMul(m).redMul(_),
        E = p.redSub(A),
        I = p.redAdd(A),
        R = this.x.redAdd(this.y).redMul(h.x.redAdd(h.y)).redISub(m).redISub(_),
        L = y.redMul(E).redMul(R),
        D,
        q;
      return (
        this.curve.twisted
          ? ((D = y.redMul(I).redMul(_.redSub(this.curve._mulA(m)))), (q = E.redMul(I)))
          : ((D = y.redMul(I).redMul(_.redSub(m))), (q = this.curve._mulC(E).redMul(I))),
        this.curve.point(L, D, q)
      );
    }),
    (c.prototype.add = function (h) {
      return this.isInfinity()
        ? h
        : h.isInfinity()
          ? this
          : this.curve.extended
            ? this._extAdd(h)
            : this._projAdd(h);
    }),
    (c.prototype.mul = function (h) {
      return this._hasDoubles(h) ? this.curve._fixedNafMul(this, h) : this.curve._wnafMul(this, h);
    }),
    (c.prototype.mulAdd = function (h, y, p) {
      return this.curve._wnafMulAdd(1, [this, y], [h, p], 2, !1);
    }),
    (c.prototype.jmulAdd = function (h, y, p) {
      return this.curve._wnafMulAdd(1, [this, y], [h, p], 2, !0);
    }),
    (c.prototype.normalize = function () {
      if (this.zOne) return this;
      var h = this.z.redInvm();
      return (
        (this.x = this.x.redMul(h)),
        (this.y = this.y.redMul(h)),
        this.t && (this.t = this.t.redMul(h)),
        (this.z = this.curve.one),
        (this.zOne = !0),
        this
      );
    }),
    (c.prototype.neg = function () {
      return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
    }),
    (c.prototype.getX = function () {
      return this.normalize(), this.x.fromRed();
    }),
    (c.prototype.getY = function () {
      return this.normalize(), this.y.fromRed();
    }),
    (c.prototype.eq = function (h) {
      return this === h || (this.getX().cmp(h.getX()) === 0 && this.getY().cmp(h.getY()) === 0);
    }),
    (c.prototype.eqXToP = function (h) {
      var y = h.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(y) === 0) return !0;
      for (var p = h.clone(), m = this.curve.redN.redMul(this.z); ; ) {
        if ((p.iadd(this.curve.n), p.cmp(this.curve.p) >= 0)) return !1;
        if ((y.redIAdd(m), this.x.cmp(y) === 0)) return !0;
      }
    }),
    (c.prototype.toP = c.prototype.normalize),
    (c.prototype.mixedAdd = c.prototype.add),
    o0
  );
}
var Nv;
function u8() {
  return (
    Nv ||
      ((Nv = 1),
      (function (i) {
        var e = i;
        (e.base = Ll()), (e.short = Hk()), (e.mont = Vk()), (e.edwards = Gk());
      })(t0)),
    t0
  );
}
var s0 = {},
  ic = {},
  Bt = {},
  Yk = Qi,
  Zk = dt;
Bt.inherits = Zk;
function Jk(i, e) {
  return (i.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= i.length
    ? !1
    : (i.charCodeAt(e + 1) & 64512) === 56320;
}
function Xk(i, e) {
  if (Array.isArray(i)) return i.slice();
  if (!i) return [];
  var t = [];
  if (typeof i == 'string')
    if (e) {
      if (e === 'hex')
        for (
          i = i.replace(/[^a-z0-9]+/gi, ''), i.length % 2 !== 0 && (i = '0' + i), s = 0;
          s < i.length;
          s += 2
        )
          t.push(parseInt(i[s] + i[s + 1], 16));
    } else
      for (var r = 0, s = 0; s < i.length; s++) {
        var n = i.charCodeAt(s);
        n < 128
          ? (t[r++] = n)
          : n < 2048
            ? ((t[r++] = (n >> 6) | 192), (t[r++] = (n & 63) | 128))
            : Jk(i, s)
              ? ((n = 65536 + ((n & 1023) << 10) + (i.charCodeAt(++s) & 1023)),
                (t[r++] = (n >> 18) | 240),
                (t[r++] = ((n >> 12) & 63) | 128),
                (t[r++] = ((n >> 6) & 63) | 128),
                (t[r++] = (n & 63) | 128))
              : ((t[r++] = (n >> 12) | 224),
                (t[r++] = ((n >> 6) & 63) | 128),
                (t[r++] = (n & 63) | 128));
      }
  else for (s = 0; s < i.length; s++) t[s] = i[s] | 0;
  return t;
}
Bt.toArray = Xk;
function Qk(i) {
  for (var e = '', t = 0; t < i.length; t++) e += f8(i[t].toString(16));
  return e;
}
Bt.toHex = Qk;
function c8(i) {
  var e = (i >>> 24) | ((i >>> 8) & 65280) | ((i << 8) & 16711680) | ((i & 255) << 24);
  return e >>> 0;
}
Bt.htonl = c8;
function eI(i, e) {
  for (var t = '', r = 0; r < i.length; r++) {
    var s = i[r];
    e === 'little' && (s = c8(s)), (t += l8(s.toString(16)));
  }
  return t;
}
Bt.toHex32 = eI;
function f8(i) {
  return i.length === 1 ? '0' + i : i;
}
Bt.zero2 = f8;
function l8(i) {
  return i.length === 7
    ? '0' + i
    : i.length === 6
      ? '00' + i
      : i.length === 5
        ? '000' + i
        : i.length === 4
          ? '0000' + i
          : i.length === 3
            ? '00000' + i
            : i.length === 2
              ? '000000' + i
              : i.length === 1
                ? '0000000' + i
                : i;
}
Bt.zero8 = l8;
function tI(i, e, t, r) {
  var s = t - e;
  Yk(s % 4 === 0);
  for (var n = new Array(s / 4), c = 0, f = e; c < n.length; c++, f += 4) {
    var h;
    r === 'big'
      ? (h = (i[f] << 24) | (i[f + 1] << 16) | (i[f + 2] << 8) | i[f + 3])
      : (h = (i[f + 3] << 24) | (i[f + 2] << 16) | (i[f + 1] << 8) | i[f]),
      (n[c] = h >>> 0);
  }
  return n;
}
Bt.join32 = tI;
function rI(i, e) {
  for (var t = new Array(i.length * 4), r = 0, s = 0; r < i.length; r++, s += 4) {
    var n = i[r];
    e === 'big'
      ? ((t[s] = n >>> 24),
        (t[s + 1] = (n >>> 16) & 255),
        (t[s + 2] = (n >>> 8) & 255),
        (t[s + 3] = n & 255))
      : ((t[s + 3] = n >>> 24),
        (t[s + 2] = (n >>> 16) & 255),
        (t[s + 1] = (n >>> 8) & 255),
        (t[s] = n & 255));
  }
  return t;
}
Bt.split32 = rI;
function iI(i, e) {
  return (i >>> e) | (i << (32 - e));
}
Bt.rotr32 = iI;
function nI(i, e) {
  return (i << e) | (i >>> (32 - e));
}
Bt.rotl32 = nI;
function oI(i, e) {
  return (i + e) >>> 0;
}
Bt.sum32 = oI;
function sI(i, e, t) {
  return (i + e + t) >>> 0;
}
Bt.sum32_3 = sI;
function aI(i, e, t, r) {
  return (i + e + t + r) >>> 0;
}
Bt.sum32_4 = aI;
function uI(i, e, t, r, s) {
  return (i + e + t + r + s) >>> 0;
}
Bt.sum32_5 = uI;
function cI(i, e, t, r) {
  var s = i[e],
    n = i[e + 1],
    c = (r + n) >>> 0,
    f = (c < r ? 1 : 0) + t + s;
  (i[e] = f >>> 0), (i[e + 1] = c);
}
Bt.sum64 = cI;
function fI(i, e, t, r) {
  var s = (e + r) >>> 0,
    n = (s < e ? 1 : 0) + i + t;
  return n >>> 0;
}
Bt.sum64_hi = fI;
function lI(i, e, t, r) {
  var s = e + r;
  return s >>> 0;
}
Bt.sum64_lo = lI;
function hI(i, e, t, r, s, n, c, f) {
  var h = 0,
    y = e;
  (y = (y + r) >>> 0),
    (h += y < e ? 1 : 0),
    (y = (y + n) >>> 0),
    (h += y < n ? 1 : 0),
    (y = (y + f) >>> 0),
    (h += y < f ? 1 : 0);
  var p = i + t + s + c + h;
  return p >>> 0;
}
Bt.sum64_4_hi = hI;
function dI(i, e, t, r, s, n, c, f) {
  var h = e + r + n + f;
  return h >>> 0;
}
Bt.sum64_4_lo = dI;
function pI(i, e, t, r, s, n, c, f, h, y) {
  var p = 0,
    m = e;
  (m = (m + r) >>> 0),
    (p += m < e ? 1 : 0),
    (m = (m + n) >>> 0),
    (p += m < n ? 1 : 0),
    (m = (m + f) >>> 0),
    (p += m < f ? 1 : 0),
    (m = (m + y) >>> 0),
    (p += m < y ? 1 : 0);
  var _ = i + t + s + c + h + p;
  return _ >>> 0;
}
Bt.sum64_5_hi = pI;
function yI(i, e, t, r, s, n, c, f, h, y) {
  var p = e + r + n + f + y;
  return p >>> 0;
}
Bt.sum64_5_lo = yI;
function gI(i, e, t) {
  var r = (e << (32 - t)) | (i >>> t);
  return r >>> 0;
}
Bt.rotr64_hi = gI;
function bI(i, e, t) {
  var r = (i << (32 - t)) | (e >>> t);
  return r >>> 0;
}
Bt.rotr64_lo = bI;
function vI(i, e, t) {
  return i >>> t;
}
Bt.shr64_hi = vI;
function mI(i, e, t) {
  var r = (i << (32 - t)) | (e >>> t);
  return r >>> 0;
}
Bt.shr64_lo = mI;
var Wa = {},
  $v = Bt,
  wI = Qi;
function Nl() {
  (this.pending = null),
    (this.pendingTotal = 0),
    (this.blockSize = this.constructor.blockSize),
    (this.outSize = this.constructor.outSize),
    (this.hmacStrength = this.constructor.hmacStrength),
    (this.padLength = this.constructor.padLength / 8),
    (this.endian = 'big'),
    (this._delta8 = this.blockSize / 8),
    (this._delta32 = this.blockSize / 32);
}
Wa.BlockHash = Nl;
Nl.prototype.update = function (e, t) {
  if (
    ((e = $v.toArray(e, t)),
    this.pending ? (this.pending = this.pending.concat(e)) : (this.pending = e),
    (this.pendingTotal += e.length),
    this.pending.length >= this._delta8)
  ) {
    e = this.pending;
    var r = e.length % this._delta8;
    (this.pending = e.slice(e.length - r, e.length)),
      this.pending.length === 0 && (this.pending = null),
      (e = $v.join32(e, 0, e.length - r, this.endian));
    for (var s = 0; s < e.length; s += this._delta32) this._update(e, s, s + this._delta32);
  }
  return this;
};
Nl.prototype.digest = function (e) {
  return this.update(this._pad()), wI(this.pending === null), this._digest(e);
};
Nl.prototype._pad = function () {
  var e = this.pendingTotal,
    t = this._delta8,
    r = t - ((e + this.padLength) % t),
    s = new Array(r + this.padLength);
  s[0] = 128;
  for (var n = 1; n < r; n++) s[n] = 0;
  if (((e <<= 3), this.endian === 'big')) {
    for (var c = 8; c < this.padLength; c++) s[n++] = 0;
    (s[n++] = 0),
      (s[n++] = 0),
      (s[n++] = 0),
      (s[n++] = 0),
      (s[n++] = (e >>> 24) & 255),
      (s[n++] = (e >>> 16) & 255),
      (s[n++] = (e >>> 8) & 255),
      (s[n++] = e & 255);
  } else
    for (
      s[n++] = e & 255,
        s[n++] = (e >>> 8) & 255,
        s[n++] = (e >>> 16) & 255,
        s[n++] = (e >>> 24) & 255,
        s[n++] = 0,
        s[n++] = 0,
        s[n++] = 0,
        s[n++] = 0,
        c = 8;
      c < this.padLength;
      c++
    )
      s[n++] = 0;
  return s;
};
var Ka = {},
  Fn = {},
  _I = Bt,
  Rn = _I.rotr32;
function SI(i, e, t, r) {
  if (i === 0) return h8(e, t, r);
  if (i === 1 || i === 3) return p8(e, t, r);
  if (i === 2) return d8(e, t, r);
}
Fn.ft_1 = SI;
function h8(i, e, t) {
  return (i & e) ^ (~i & t);
}
Fn.ch32 = h8;
function d8(i, e, t) {
  return (i & e) ^ (i & t) ^ (e & t);
}
Fn.maj32 = d8;
function p8(i, e, t) {
  return i ^ e ^ t;
}
Fn.p32 = p8;
function MI(i) {
  return Rn(i, 2) ^ Rn(i, 13) ^ Rn(i, 22);
}
Fn.s0_256 = MI;
function AI(i) {
  return Rn(i, 6) ^ Rn(i, 11) ^ Rn(i, 25);
}
Fn.s1_256 = AI;
function EI(i) {
  return Rn(i, 7) ^ Rn(i, 18) ^ (i >>> 3);
}
Fn.g0_256 = EI;
function kI(i) {
  return Rn(i, 17) ^ Rn(i, 19) ^ (i >>> 10);
}
Fn.g1_256 = kI;
var Ma = Bt,
  II = Wa,
  xI = Fn,
  a0 = Ma.rotl32,
  cu = Ma.sum32,
  BI = Ma.sum32_5,
  RI = xI.ft_1,
  y8 = II.BlockHash,
  PI = [1518500249, 1859775393, 2400959708, 3395469782];
function Ln() {
  if (!(this instanceof Ln)) return new Ln();
  y8.call(this),
    (this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520]),
    (this.W = new Array(80));
}
Ma.inherits(Ln, y8);
var TI = Ln;
Ln.blockSize = 512;
Ln.outSize = 160;
Ln.hmacStrength = 80;
Ln.padLength = 64;
Ln.prototype._update = function (e, t) {
  for (var r = this.W, s = 0; s < 16; s++) r[s] = e[t + s];
  for (; s < r.length; s++) r[s] = a0(r[s - 3] ^ r[s - 8] ^ r[s - 14] ^ r[s - 16], 1);
  var n = this.h[0],
    c = this.h[1],
    f = this.h[2],
    h = this.h[3],
    y = this.h[4];
  for (s = 0; s < r.length; s++) {
    var p = ~~(s / 20),
      m = BI(a0(n, 5), RI(p, c, f, h), y, r[s], PI[p]);
    (y = h), (h = f), (f = a0(c, 30)), (c = n), (n = m);
  }
  (this.h[0] = cu(this.h[0], n)),
    (this.h[1] = cu(this.h[1], c)),
    (this.h[2] = cu(this.h[2], f)),
    (this.h[3] = cu(this.h[3], h)),
    (this.h[4] = cu(this.h[4], y));
};
Ln.prototype._digest = function (e) {
  return e === 'hex' ? Ma.toHex32(this.h, 'big') : Ma.split32(this.h, 'big');
};
var Aa = Bt,
  OI = Wa,
  ja = Fn,
  CI = Qi,
  rn = Aa.sum32,
  LI = Aa.sum32_4,
  NI = Aa.sum32_5,
  $I = ja.ch32,
  DI = ja.maj32,
  UI = ja.s0_256,
  zI = ja.s1_256,
  FI = ja.g0_256,
  qI = ja.g1_256,
  g8 = OI.BlockHash,
  WI = [
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221,
    3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580,
    3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895,
    666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037,
    2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
    1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298,
  ];
function Nn() {
  if (!(this instanceof Nn)) return new Nn();
  g8.call(this),
    (this.h = [
      1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225,
    ]),
    (this.k = WI),
    (this.W = new Array(64));
}
Aa.inherits(Nn, g8);
var b8 = Nn;
Nn.blockSize = 512;
Nn.outSize = 256;
Nn.hmacStrength = 192;
Nn.padLength = 64;
Nn.prototype._update = function (e, t) {
  for (var r = this.W, s = 0; s < 16; s++) r[s] = e[t + s];
  for (; s < r.length; s++) r[s] = LI(qI(r[s - 2]), r[s - 7], FI(r[s - 15]), r[s - 16]);
  var n = this.h[0],
    c = this.h[1],
    f = this.h[2],
    h = this.h[3],
    y = this.h[4],
    p = this.h[5],
    m = this.h[6],
    _ = this.h[7];
  for (CI(this.k.length === r.length), s = 0; s < r.length; s++) {
    var A = NI(_, zI(y), $I(y, p, m), this.k[s], r[s]),
      E = rn(UI(n), DI(n, c, f));
    (_ = m), (m = p), (p = y), (y = rn(h, A)), (h = f), (f = c), (c = n), (n = rn(A, E));
  }
  (this.h[0] = rn(this.h[0], n)),
    (this.h[1] = rn(this.h[1], c)),
    (this.h[2] = rn(this.h[2], f)),
    (this.h[3] = rn(this.h[3], h)),
    (this.h[4] = rn(this.h[4], y)),
    (this.h[5] = rn(this.h[5], p)),
    (this.h[6] = rn(this.h[6], m)),
    (this.h[7] = rn(this.h[7], _));
};
Nn.prototype._digest = function (e) {
  return e === 'hex' ? Aa.toHex32(this.h, 'big') : Aa.split32(this.h, 'big');
};
var Zp = Bt,
  v8 = b8;
function so() {
  if (!(this instanceof so)) return new so();
  v8.call(this),
    (this.h = [
      3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428,
    ]);
}
Zp.inherits(so, v8);
var KI = so;
so.blockSize = 512;
so.outSize = 224;
so.hmacStrength = 192;
so.padLength = 64;
so.prototype._digest = function (e) {
  return e === 'hex'
    ? Zp.toHex32(this.h.slice(0, 7), 'big')
    : Zp.split32(this.h.slice(0, 7), 'big');
};
var ki = Bt,
  jI = Wa,
  HI = Qi,
  Pn = ki.rotr64_hi,
  Tn = ki.rotr64_lo,
  m8 = ki.shr64_hi,
  w8 = ki.shr64_lo,
  fo = ki.sum64,
  u0 = ki.sum64_hi,
  c0 = ki.sum64_lo,
  VI = ki.sum64_4_hi,
  GI = ki.sum64_4_lo,
  YI = ki.sum64_5_hi,
  ZI = ki.sum64_5_lo,
  _8 = jI.BlockHash,
  JI = [
    1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548,
    961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560,
    3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994,
    1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868,
    3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933,
    770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837,
    2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956,
    3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936,
    666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823,
    1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627,
    2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008,
    3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720,
    430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280,
    958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899,
    1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044,
    2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427,
    3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992,
    116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315,
    685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676,
    1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591,
  ];
function fn() {
  if (!(this instanceof fn)) return new fn();
  _8.call(this),
    (this.h = [
      1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762,
      1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225,
      327033209,
    ]),
    (this.k = JI),
    (this.W = new Array(160));
}
ki.inherits(fn, _8);
var S8 = fn;
fn.blockSize = 1024;
fn.outSize = 512;
fn.hmacStrength = 192;
fn.padLength = 128;
fn.prototype._prepareBlock = function (e, t) {
  for (var r = this.W, s = 0; s < 32; s++) r[s] = e[t + s];
  for (; s < r.length; s += 2) {
    var n = ux(r[s - 4], r[s - 3]),
      c = cx(r[s - 4], r[s - 3]),
      f = r[s - 14],
      h = r[s - 13],
      y = sx(r[s - 30], r[s - 29]),
      p = ax(r[s - 30], r[s - 29]),
      m = r[s - 32],
      _ = r[s - 31];
    (r[s] = VI(n, c, f, h, y, p, m, _)), (r[s + 1] = GI(n, c, f, h, y, p, m, _));
  }
};
fn.prototype._update = function (e, t) {
  this._prepareBlock(e, t);
  var r = this.W,
    s = this.h[0],
    n = this.h[1],
    c = this.h[2],
    f = this.h[3],
    h = this.h[4],
    y = this.h[5],
    p = this.h[6],
    m = this.h[7],
    _ = this.h[8],
    A = this.h[9],
    E = this.h[10],
    I = this.h[11],
    R = this.h[12],
    L = this.h[13],
    D = this.h[14],
    q = this.h[15];
  HI(this.k.length === r.length);
  for (var H = 0; H < r.length; H += 2) {
    var V = D,
      te = q,
      ue = nx(_, A),
      ne = ox(_, A),
      X = XI(_, A, E, I, R),
      Oe = QI(_, A, E, I, R, L),
      S = this.k[H],
      o = this.k[H + 1],
      u = r[H],
      l = r[H + 1],
      d = YI(V, te, ue, ne, X, Oe, S, o, u, l),
      g = ZI(V, te, ue, ne, X, Oe, S, o, u, l);
    (V = rx(s, n)), (te = ix(s, n)), (ue = ex(s, n, c, f, h)), (ne = tx(s, n, c, f, h, y));
    var w = u0(V, te, ue, ne),
      M = c0(V, te, ue, ne);
    (D = R),
      (q = L),
      (R = E),
      (L = I),
      (E = _),
      (I = A),
      (_ = u0(p, m, d, g)),
      (A = c0(m, m, d, g)),
      (p = h),
      (m = y),
      (h = c),
      (y = f),
      (c = s),
      (f = n),
      (s = u0(d, g, w, M)),
      (n = c0(d, g, w, M));
  }
  fo(this.h, 0, s, n),
    fo(this.h, 2, c, f),
    fo(this.h, 4, h, y),
    fo(this.h, 6, p, m),
    fo(this.h, 8, _, A),
    fo(this.h, 10, E, I),
    fo(this.h, 12, R, L),
    fo(this.h, 14, D, q);
};
fn.prototype._digest = function (e) {
  return e === 'hex' ? ki.toHex32(this.h, 'big') : ki.split32(this.h, 'big');
};
function XI(i, e, t, r, s) {
  var n = (i & t) ^ (~i & s);
  return n < 0 && (n += 4294967296), n;
}
function QI(i, e, t, r, s, n) {
  var c = (e & r) ^ (~e & n);
  return c < 0 && (c += 4294967296), c;
}
function ex(i, e, t, r, s) {
  var n = (i & t) ^ (i & s) ^ (t & s);
  return n < 0 && (n += 4294967296), n;
}
function tx(i, e, t, r, s, n) {
  var c = (e & r) ^ (e & n) ^ (r & n);
  return c < 0 && (c += 4294967296), c;
}
function rx(i, e) {
  var t = Pn(i, e, 28),
    r = Pn(e, i, 2),
    s = Pn(e, i, 7),
    n = t ^ r ^ s;
  return n < 0 && (n += 4294967296), n;
}
function ix(i, e) {
  var t = Tn(i, e, 28),
    r = Tn(e, i, 2),
    s = Tn(e, i, 7),
    n = t ^ r ^ s;
  return n < 0 && (n += 4294967296), n;
}
function nx(i, e) {
  var t = Pn(i, e, 14),
    r = Pn(i, e, 18),
    s = Pn(e, i, 9),
    n = t ^ r ^ s;
  return n < 0 && (n += 4294967296), n;
}
function ox(i, e) {
  var t = Tn(i, e, 14),
    r = Tn(i, e, 18),
    s = Tn(e, i, 9),
    n = t ^ r ^ s;
  return n < 0 && (n += 4294967296), n;
}
function sx(i, e) {
  var t = Pn(i, e, 1),
    r = Pn(i, e, 8),
    s = m8(i, e, 7),
    n = t ^ r ^ s;
  return n < 0 && (n += 4294967296), n;
}
function ax(i, e) {
  var t = Tn(i, e, 1),
    r = Tn(i, e, 8),
    s = w8(i, e, 7),
    n = t ^ r ^ s;
  return n < 0 && (n += 4294967296), n;
}
function ux(i, e) {
  var t = Pn(i, e, 19),
    r = Pn(e, i, 29),
    s = m8(i, e, 6),
    n = t ^ r ^ s;
  return n < 0 && (n += 4294967296), n;
}
function cx(i, e) {
  var t = Tn(i, e, 19),
    r = Tn(e, i, 29),
    s = w8(i, e, 6),
    n = t ^ r ^ s;
  return n < 0 && (n += 4294967296), n;
}
var Jp = Bt,
  M8 = S8;
function ao() {
  if (!(this instanceof ao)) return new ao();
  M8.call(this),
    (this.h = [
      3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697,
      1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813,
      3204075428,
    ]);
}
Jp.inherits(ao, M8);
var fx = ao;
ao.blockSize = 1024;
ao.outSize = 384;
ao.hmacStrength = 192;
ao.padLength = 128;
ao.prototype._digest = function (e) {
  return e === 'hex'
    ? Jp.toHex32(this.h.slice(0, 12), 'big')
    : Jp.split32(this.h.slice(0, 12), 'big');
};
Ka.sha1 = TI;
Ka.sha224 = KI;
Ka.sha256 = b8;
Ka.sha384 = fx;
Ka.sha512 = S8;
var A8 = {},
  ys = Bt,
  lx = Wa,
  Zc = ys.rotl32,
  Dv = ys.sum32,
  fu = ys.sum32_3,
  Uv = ys.sum32_4,
  E8 = lx.BlockHash;
function $n() {
  if (!(this instanceof $n)) return new $n();
  E8.call(this),
    (this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520]),
    (this.endian = 'little');
}
ys.inherits($n, E8);
A8.ripemd160 = $n;
$n.blockSize = 512;
$n.outSize = 160;
$n.hmacStrength = 192;
$n.padLength = 64;
$n.prototype._update = function (e, t) {
  for (
    var r = this.h[0],
      s = this.h[1],
      n = this.h[2],
      c = this.h[3],
      f = this.h[4],
      h = r,
      y = s,
      p = n,
      m = c,
      _ = f,
      A = 0;
    A < 80;
    A++
  ) {
    var E = Dv(Zc(Uv(r, zv(A, s, n, c), e[px[A] + t], hx(A)), gx[A]), f);
    (r = f),
      (f = c),
      (c = Zc(n, 10)),
      (n = s),
      (s = E),
      (E = Dv(Zc(Uv(h, zv(79 - A, y, p, m), e[yx[A] + t], dx(A)), bx[A]), _)),
      (h = _),
      (_ = m),
      (m = Zc(p, 10)),
      (p = y),
      (y = E);
  }
  (E = fu(this.h[1], n, m)),
    (this.h[1] = fu(this.h[2], c, _)),
    (this.h[2] = fu(this.h[3], f, h)),
    (this.h[3] = fu(this.h[4], r, y)),
    (this.h[4] = fu(this.h[0], s, p)),
    (this.h[0] = E);
};
$n.prototype._digest = function (e) {
  return e === 'hex' ? ys.toHex32(this.h, 'little') : ys.split32(this.h, 'little');
};
function zv(i, e, t, r) {
  return i <= 15
    ? e ^ t ^ r
    : i <= 31
      ? (e & t) | (~e & r)
      : i <= 47
        ? (e | ~t) ^ r
        : i <= 63
          ? (e & r) | (t & ~r)
          : e ^ (t | ~r);
}
function hx(i) {
  return i <= 15
    ? 0
    : i <= 31
      ? 1518500249
      : i <= 47
        ? 1859775393
        : i <= 63
          ? 2400959708
          : 2840853838;
}
function dx(i) {
  return i <= 15
    ? 1352829926
    : i <= 31
      ? 1548603684
      : i <= 47
        ? 1836072691
        : i <= 63
          ? 2053994217
          : 0;
}
var px = [
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2,
    14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13,
    3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13,
  ],
  yx = [
    5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12,
    4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5,
    12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11,
  ],
  gx = [
    11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9,
    11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15,
    9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6,
  ],
  bx = [
    8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7,
    6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6,
    14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11,
  ],
  vx = Bt,
  mx = Qi;
function Ea(i, e, t) {
  if (!(this instanceof Ea)) return new Ea(i, e, t);
  (this.Hash = i),
    (this.blockSize = i.blockSize / 8),
    (this.outSize = i.outSize / 8),
    (this.inner = null),
    (this.outer = null),
    this._init(vx.toArray(e, t));
}
var wx = Ea;
Ea.prototype._init = function (e) {
  e.length > this.blockSize && (e = new this.Hash().update(e).digest()),
    mx(e.length <= this.blockSize);
  for (var t = e.length; t < this.blockSize; t++) e.push(0);
  for (t = 0; t < e.length; t++) e[t] ^= 54;
  for (this.inner = new this.Hash().update(e), t = 0; t < e.length; t++) e[t] ^= 106;
  this.outer = new this.Hash().update(e);
};
Ea.prototype.update = function (e, t) {
  return this.inner.update(e, t), this;
};
Ea.prototype.digest = function (e) {
  return this.outer.update(this.inner.digest()), this.outer.digest(e);
};
(function (i) {
  var e = i;
  (e.utils = Bt),
    (e.common = Wa),
    (e.sha = Ka),
    (e.ripemd = A8),
    (e.hmac = wx),
    (e.sha1 = e.sha.sha1),
    (e.sha256 = e.sha.sha256),
    (e.sha224 = e.sha.sha224),
    (e.sha384 = e.sha.sha384),
    (e.sha512 = e.sha.sha512),
    (e.ripemd160 = e.ripemd.ripemd160);
})(ic);
const PU = zn(ic);
var f0, Fv;
function _x() {
  return (
    Fv ||
      ((Fv = 1),
      (f0 = {
        doubles: {
          step: 4,
          points: [
            [
              'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
              'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821',
            ],
            [
              '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
              '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf',
            ],
            [
              '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
              'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695',
            ],
            [
              '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
              '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9',
            ],
            [
              '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
              '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36',
            ],
            [
              '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
              '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f',
            ],
            [
              'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
              '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999',
            ],
            [
              '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
              'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09',
            ],
            [
              'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
              '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d',
            ],
            [
              'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
              'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088',
            ],
            [
              'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
              '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d',
            ],
            [
              '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
              '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8',
            ],
            [
              '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
              '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a',
            ],
            [
              '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
              '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453',
            ],
            [
              '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
              '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160',
            ],
            [
              '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
              '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0',
            ],
            [
              '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
              '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6',
            ],
            [
              '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
              '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589',
            ],
            [
              '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
              'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17',
            ],
            [
              'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
              '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda',
            ],
            [
              'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
              '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd',
            ],
            [
              '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
              '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2',
            ],
            [
              '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
              '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6',
            ],
            [
              'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
              '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f',
            ],
            [
              '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
              'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01',
            ],
            [
              'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
              '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3',
            ],
            [
              'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
              'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f',
            ],
            [
              'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
              '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7',
            ],
            [
              'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
              'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78',
            ],
            [
              'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
              '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1',
            ],
            [
              '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
              'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150',
            ],
            [
              '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
              '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82',
            ],
            [
              'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
              '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc',
            ],
            [
              '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
              'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b',
            ],
            [
              'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
              '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51',
            ],
            [
              'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
              '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45',
            ],
            [
              'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
              'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120',
            ],
            [
              '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
              '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84',
            ],
            [
              '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
              '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d',
            ],
            [
              '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
              'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d',
            ],
            [
              '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
              '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8',
            ],
            [
              'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
              '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8',
            ],
            [
              '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
              '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac',
            ],
            [
              '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
              'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f',
            ],
            [
              '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
              '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962',
            ],
            [
              'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
              '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907',
            ],
            [
              '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
              'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec',
            ],
            [
              'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
              'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d',
            ],
            [
              'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
              '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414',
            ],
            [
              '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
              'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd',
            ],
            [
              '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
              'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0',
            ],
            [
              'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
              '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811',
            ],
            [
              'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
              '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1',
            ],
            [
              'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
              '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c',
            ],
            [
              '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
              'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73',
            ],
            [
              '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
              '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd',
            ],
            [
              'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
              'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405',
            ],
            [
              '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
              'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589',
            ],
            [
              '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
              '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e',
            ],
            [
              '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
              '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27',
            ],
            [
              'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
              'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1',
            ],
            [
              '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
              '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482',
            ],
            [
              '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
              '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945',
            ],
            [
              'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
              '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573',
            ],
            [
              'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
              'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82',
            ],
          ],
        },
        naf: {
          wnd: 7,
          points: [
            [
              'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
              '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672',
            ],
            [
              '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
              'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6',
            ],
            [
              '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
              '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da',
            ],
            [
              'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
              'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37',
            ],
            [
              '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
              'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b',
            ],
            [
              'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
              'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81',
            ],
            [
              'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
              '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58',
            ],
            [
              'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
              '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77',
            ],
            [
              '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
              '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a',
            ],
            [
              '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
              '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c',
            ],
            [
              '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
              '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67',
            ],
            [
              '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
              '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402',
            ],
            [
              'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
              'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55',
            ],
            [
              'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
              '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482',
            ],
            [
              '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
              'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82',
            ],
            [
              '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
              'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396',
            ],
            [
              '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
              '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49',
            ],
            [
              '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
              '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf',
            ],
            [
              '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
              '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a',
            ],
            [
              '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
              'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7',
            ],
            [
              'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
              'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933',
            ],
            [
              '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
              '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a',
            ],
            [
              '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
              '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6',
            ],
            [
              'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
              'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37',
            ],
            [
              '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
              '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e',
            ],
            [
              'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
              'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6',
            ],
            [
              'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
              'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476',
            ],
            [
              '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
              '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40',
            ],
            [
              '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
              '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61',
            ],
            [
              '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
              '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683',
            ],
            [
              'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
              '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5',
            ],
            [
              '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
              '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b',
            ],
            [
              'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
              '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417',
            ],
            [
              '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
              'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868',
            ],
            [
              '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
              'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a',
            ],
            [
              'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
              'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6',
            ],
            [
              '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
              '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996',
            ],
            [
              '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
              'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e',
            ],
            [
              'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
              'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d',
            ],
            [
              '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
              '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2',
            ],
            [
              '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
              'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e',
            ],
            [
              '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
              '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437',
            ],
            [
              '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
              'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311',
            ],
            [
              'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
              '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4',
            ],
            [
              '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
              '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575',
            ],
            [
              '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
              'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d',
            ],
            [
              '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
              'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d',
            ],
            [
              'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
              'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629',
            ],
            [
              'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
              'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06',
            ],
            [
              '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
              '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374',
            ],
            [
              '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
              '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee',
            ],
            [
              'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
              '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1',
            ],
            [
              'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
              'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b',
            ],
            [
              '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
              '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661',
            ],
            [
              '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
              '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6',
            ],
            [
              'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
              '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e',
            ],
            [
              '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
              '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d',
            ],
            [
              'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
              'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc',
            ],
            [
              '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
              'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4',
            ],
            [
              '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
              '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c',
            ],
            [
              'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
              '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b',
            ],
            [
              'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
              '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913',
            ],
            [
              '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
              '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154',
            ],
            [
              '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
              '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865',
            ],
            [
              '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
              'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc',
            ],
            [
              '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
              'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224',
            ],
            [
              '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
              '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e',
            ],
            [
              '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
              '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6',
            ],
            [
              '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
              '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511',
            ],
            [
              '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
              'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b',
            ],
            [
              'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
              'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2',
            ],
            [
              '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
              'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c',
            ],
            [
              'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
              '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3',
            ],
            [
              'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
              '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d',
            ],
            [
              'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
              '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700',
            ],
            [
              'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
              '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4',
            ],
            [
              '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
              'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196',
            ],
            [
              '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
              '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4',
            ],
            [
              '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
              'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257',
            ],
            [
              'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
              'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13',
            ],
            [
              'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
              '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096',
            ],
            [
              'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
              'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38',
            ],
            [
              'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
              '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f',
            ],
            [
              '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
              '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448',
            ],
            [
              'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
              '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a',
            ],
            [
              'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
              '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4',
            ],
            [
              '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
              '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437',
            ],
            [
              '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
              'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7',
            ],
            [
              'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
              '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d',
            ],
            [
              'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
              '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a',
            ],
            [
              'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
              '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54',
            ],
            [
              '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
              '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77',
            ],
            [
              'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
              'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517',
            ],
            [
              '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
              'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10',
            ],
            [
              'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
              'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125',
            ],
            [
              'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
              '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e',
            ],
            [
              '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
              'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1',
            ],
            [
              'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
              '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2',
            ],
            [
              'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
              '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423',
            ],
            [
              'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
              '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8',
            ],
            [
              '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
              'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758',
            ],
            [
              '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
              'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375',
            ],
            [
              'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
              '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d',
            ],
            [
              '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
              'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec',
            ],
            [
              '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
              '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0',
            ],
            [
              '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
              'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c',
            ],
            [
              'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
              'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4',
            ],
            [
              '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
              'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f',
            ],
            [
              '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
              '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649',
            ],
            [
              '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
              'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826',
            ],
            [
              '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
              '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5',
            ],
            [
              'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
              'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87',
            ],
            [
              '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
              '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b',
            ],
            [
              'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
              '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc',
            ],
            [
              '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
              '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c',
            ],
            [
              'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
              'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f',
            ],
            [
              'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
              '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a',
            ],
            [
              'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
              'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46',
            ],
            [
              '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
              'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f',
            ],
            [
              '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
              '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03',
            ],
            [
              '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
              'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08',
            ],
            [
              '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
              '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8',
            ],
            [
              '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
              '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373',
            ],
            [
              '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
              'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3',
            ],
            [
              '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
              '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8',
            ],
            [
              '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
              '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1',
            ],
            [
              '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
              '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9',
            ],
          ],
        },
      })),
    f0
  );
}
var qv;
function ly() {
  return (
    qv ||
      ((qv = 1),
      (function (i) {
        var e = i,
          t = ic,
          r = u8(),
          s = en(),
          n = s.assert;
        function c(y) {
          y.type === 'short'
            ? (this.curve = new r.short(y))
            : y.type === 'edwards'
              ? (this.curve = new r.edwards(y))
              : (this.curve = new r.mont(y)),
            (this.g = this.curve.g),
            (this.n = this.curve.n),
            (this.hash = y.hash),
            n(this.g.validate(), 'Invalid curve'),
            n(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
        }
        e.PresetCurve = c;
        function f(y, p) {
          Object.defineProperty(e, y, {
            configurable: !0,
            enumerable: !0,
            get: function () {
              var m = new c(p);
              return Object.defineProperty(e, y, { configurable: !0, enumerable: !0, value: m }), m;
            },
          });
        }
        f('p192', {
          type: 'short',
          prime: 'p192',
          p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
          a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
          b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
          n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
          hash: t.sha256,
          gRed: !1,
          g: [
            '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
            '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',
          ],
        }),
          f('p224', {
            type: 'short',
            prime: 'p224',
            p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
            a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
            b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
            n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
            hash: t.sha256,
            gRed: !1,
            g: [
              'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
              'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',
            ],
          }),
          f('p256', {
            type: 'short',
            prime: null,
            p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
            a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
            b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
            n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
            hash: t.sha256,
            gRed: !1,
            g: [
              '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
              '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',
            ],
          }),
          f('p384', {
            type: 'short',
            prime: null,
            p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff',
            a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc',
            b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
            n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
            hash: t.sha384,
            gRed: !1,
            g: [
              'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7',
              '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',
            ],
          }),
          f('p521', {
            type: 'short',
            prime: null,
            p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff',
            a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc',
            b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
            n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
            hash: t.sha512,
            gRed: !1,
            g: [
              '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
              '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650',
            ],
          }),
          f('curve25519', {
            type: 'mont',
            prime: 'p25519',
            p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
            a: '76d06',
            b: '1',
            n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
            hash: t.sha256,
            gRed: !1,
            g: ['9'],
          }),
          f('ed25519', {
            type: 'edwards',
            prime: 'p25519',
            p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
            a: '-1',
            c: '1',
            d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
            n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
            hash: t.sha256,
            gRed: !1,
            g: [
              '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',
              '6666666666666666666666666666666666666666666666666666666666666658',
            ],
          });
        var h;
        try {
          h = _x();
        } catch {
          h = void 0;
        }
        f('secp256k1', {
          type: 'short',
          prime: 'k256',
          p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
          a: '0',
          b: '7',
          n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
          h: '1',
          hash: t.sha256,
          beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
          lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
          basis: [
            { a: '3086d221a7d46bcde86c90e49284eb15', b: '-e4437ed6010e88286f547fa90abfe4c3' },
            { a: '114ca50f7a8e2f3f657c1108d9d44cfd8', b: '3086d221a7d46bcde86c90e49284eb15' },
          ],
          gRed: !1,
          g: [
            '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
            '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
            h,
          ],
        });
      })(s0)),
    s0
  );
}
var l0, Wv;
function Sx() {
  if (Wv) return l0;
  Wv = 1;
  var i = ic,
    e = a8(),
    t = Qi;
  function r(s) {
    if (!(this instanceof r)) return new r(s);
    (this.hash = s.hash),
      (this.predResist = !!s.predResist),
      (this.outLen = this.hash.outSize),
      (this.minEntropy = s.minEntropy || this.hash.hmacStrength),
      (this._reseed = null),
      (this.reseedInterval = null),
      (this.K = null),
      (this.V = null);
    var n = e.toArray(s.entropy, s.entropyEnc || 'hex'),
      c = e.toArray(s.nonce, s.nonceEnc || 'hex'),
      f = e.toArray(s.pers, s.persEnc || 'hex');
    t(
      n.length >= this.minEntropy / 8,
      'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits'
    ),
      this._init(n, c, f);
  }
  return (
    (l0 = r),
    (r.prototype._init = function (n, c, f) {
      var h = n.concat(c).concat(f);
      (this.K = new Array(this.outLen / 8)), (this.V = new Array(this.outLen / 8));
      for (var y = 0; y < this.V.length; y++) (this.K[y] = 0), (this.V[y] = 1);
      this._update(h), (this._reseed = 1), (this.reseedInterval = 281474976710656);
    }),
    (r.prototype._hmac = function () {
      return new i.hmac(this.hash, this.K);
    }),
    (r.prototype._update = function (n) {
      var c = this._hmac().update(this.V).update([0]);
      n && (c = c.update(n)),
        (this.K = c.digest()),
        (this.V = this._hmac().update(this.V).digest()),
        n &&
          ((this.K = this._hmac().update(this.V).update([1]).update(n).digest()),
          (this.V = this._hmac().update(this.V).digest()));
    }),
    (r.prototype.reseed = function (n, c, f, h) {
      typeof c != 'string' && ((h = f), (f = c), (c = null)),
        (n = e.toArray(n, c)),
        (f = e.toArray(f, h)),
        t(
          n.length >= this.minEntropy / 8,
          'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits'
        ),
        this._update(n.concat(f || [])),
        (this._reseed = 1);
    }),
    (r.prototype.generate = function (n, c, f, h) {
      if (this._reseed > this.reseedInterval) throw new Error('Reseed is required');
      typeof c != 'string' && ((h = f), (f = c), (c = null)),
        f && ((f = e.toArray(f, h || 'hex')), this._update(f));
      for (var y = []; y.length < n; )
        (this.V = this._hmac().update(this.V).digest()), (y = y.concat(this.V));
      var p = y.slice(0, n);
      return this._update(f), this._reseed++, e.encode(p, c);
    }),
    l0
  );
}
var h0, Kv;
function Mx() {
  if (Kv) return h0;
  Kv = 1;
  var i = co(),
    e = en(),
    t = e.assert;
  function r(s, n) {
    (this.ec = s),
      (this.priv = null),
      (this.pub = null),
      n.priv && this._importPrivate(n.priv, n.privEnc),
      n.pub && this._importPublic(n.pub, n.pubEnc);
  }
  return (
    (h0 = r),
    (r.fromPublic = function (n, c, f) {
      return c instanceof r ? c : new r(n, { pub: c, pubEnc: f });
    }),
    (r.fromPrivate = function (n, c, f) {
      return c instanceof r ? c : new r(n, { priv: c, privEnc: f });
    }),
    (r.prototype.validate = function () {
      var n = this.getPublic();
      return n.isInfinity()
        ? { result: !1, reason: 'Invalid public key' }
        : n.validate()
          ? n.mul(this.ec.curve.n).isInfinity()
            ? { result: !0, reason: null }
            : { result: !1, reason: 'Public key * N != O' }
          : { result: !1, reason: 'Public key is not a point' };
    }),
    (r.prototype.getPublic = function (n, c) {
      return (
        typeof n == 'string' && ((c = n), (n = null)),
        this.pub || (this.pub = this.ec.g.mul(this.priv)),
        c ? this.pub.encode(c, n) : this.pub
      );
    }),
    (r.prototype.getPrivate = function (n) {
      return n === 'hex' ? this.priv.toString(16, 2) : this.priv;
    }),
    (r.prototype._importPrivate = function (n, c) {
      (this.priv = new i(n, c || 16)), (this.priv = this.priv.umod(this.ec.curve.n));
    }),
    (r.prototype._importPublic = function (n, c) {
      if (n.x || n.y) {
        this.ec.curve.type === 'mont'
          ? t(n.x, 'Need x coordinate')
          : (this.ec.curve.type === 'short' || this.ec.curve.type === 'edwards') &&
            t(n.x && n.y, 'Need both x and y coordinate'),
          (this.pub = this.ec.curve.point(n.x, n.y));
        return;
      }
      this.pub = this.ec.curve.decodePoint(n, c);
    }),
    (r.prototype.derive = function (n) {
      return n.validate() || t(n.validate(), 'public point not validated'), n.mul(this.priv).getX();
    }),
    (r.prototype.sign = function (n, c, f) {
      return this.ec.sign(n, this, c, f);
    }),
    (r.prototype.verify = function (n, c, f) {
      return this.ec.verify(n, c, this, void 0, f);
    }),
    (r.prototype.inspect = function () {
      return (
        '<Key priv: ' +
        (this.priv && this.priv.toString(16, 2)) +
        ' pub: ' +
        (this.pub && this.pub.inspect()) +
        ' >'
      );
    }),
    h0
  );
}
var d0, jv;
function Ax() {
  if (jv) return d0;
  jv = 1;
  var i = co(),
    e = en(),
    t = e.assert;
  function r(h, y) {
    if (h instanceof r) return h;
    this._importDER(h, y) ||
      (t(h.r && h.s, 'Signature without r or s'),
      (this.r = new i(h.r, 16)),
      (this.s = new i(h.s, 16)),
      h.recoveryParam === void 0
        ? (this.recoveryParam = null)
        : (this.recoveryParam = h.recoveryParam));
  }
  d0 = r;
  function s() {
    this.place = 0;
  }
  function n(h, y) {
    var p = h[y.place++];
    if (!(p & 128)) return p;
    var m = p & 15;
    if (m === 0 || m > 4 || h[y.place] === 0) return !1;
    for (var _ = 0, A = 0, E = y.place; A < m; A++, E++) (_ <<= 8), (_ |= h[E]), (_ >>>= 0);
    return _ <= 127 ? !1 : ((y.place = E), _);
  }
  function c(h) {
    for (var y = 0, p = h.length - 1; !h[y] && !(h[y + 1] & 128) && y < p; ) y++;
    return y === 0 ? h : h.slice(y);
  }
  r.prototype._importDER = function (y, p) {
    y = e.toArray(y, p);
    var m = new s();
    if (y[m.place++] !== 48) return !1;
    var _ = n(y, m);
    if (_ === !1 || _ + m.place !== y.length || y[m.place++] !== 2) return !1;
    var A = n(y, m);
    if (A === !1 || y[m.place] & 128) return !1;
    var E = y.slice(m.place, A + m.place);
    if (((m.place += A), y[m.place++] !== 2)) return !1;
    var I = n(y, m);
    if (I === !1 || y.length !== I + m.place || y[m.place] & 128) return !1;
    var R = y.slice(m.place, I + m.place);
    if (E[0] === 0)
      if (E[1] & 128) E = E.slice(1);
      else return !1;
    if (R[0] === 0)
      if (R[1] & 128) R = R.slice(1);
      else return !1;
    return (this.r = new i(E)), (this.s = new i(R)), (this.recoveryParam = null), !0;
  };
  function f(h, y) {
    if (y < 128) {
      h.push(y);
      return;
    }
    var p = 1 + ((Math.log(y) / Math.LN2) >>> 3);
    for (h.push(p | 128); --p; ) h.push((y >>> (p << 3)) & 255);
    h.push(y);
  }
  return (
    (r.prototype.toDER = function (y) {
      var p = this.r.toArray(),
        m = this.s.toArray();
      for (
        p[0] & 128 && (p = [0].concat(p)), m[0] & 128 && (m = [0].concat(m)), p = c(p), m = c(m);
        !m[0] && !(m[1] & 128);

      )
        m = m.slice(1);
      var _ = [2];
      f(_, p.length), (_ = _.concat(p)), _.push(2), f(_, m.length);
      var A = _.concat(m),
        E = [48];
      return f(E, A.length), (E = E.concat(A)), e.encode(E, y);
    }),
    d0
  );
}
var p0, Hv;
function Ex() {
  if (Hv) return p0;
  Hv = 1;
  var i = co(),
    e = Sx(),
    t = en(),
    r = ly(),
    s = uy(),
    n = t.assert,
    c = Mx(),
    f = Ax();
  function h(y) {
    if (!(this instanceof h)) return new h(y);
    typeof y == 'string' &&
      (n(Object.prototype.hasOwnProperty.call(r, y), 'Unknown curve ' + y), (y = r[y])),
      y instanceof r.PresetCurve && (y = { curve: y }),
      (this.curve = y.curve.curve),
      (this.n = this.curve.n),
      (this.nh = this.n.ushrn(1)),
      (this.g = this.curve.g),
      (this.g = y.curve.g),
      this.g.precompute(y.curve.n.bitLength() + 1),
      (this.hash = y.hash || y.curve.hash);
  }
  return (
    (p0 = h),
    (h.prototype.keyPair = function (p) {
      return new c(this, p);
    }),
    (h.prototype.keyFromPrivate = function (p, m) {
      return c.fromPrivate(this, p, m);
    }),
    (h.prototype.keyFromPublic = function (p, m) {
      return c.fromPublic(this, p, m);
    }),
    (h.prototype.genKeyPair = function (p) {
      p || (p = {});
      for (
        var m = new e({
            hash: this.hash,
            pers: p.pers,
            persEnc: p.persEnc || 'utf8',
            entropy: p.entropy || s(this.hash.hmacStrength),
            entropyEnc: (p.entropy && p.entropyEnc) || 'utf8',
            nonce: this.n.toArray(),
          }),
          _ = this.n.byteLength(),
          A = this.n.sub(new i(2));
        ;

      ) {
        var E = new i(m.generate(_));
        if (!(E.cmp(A) > 0)) return E.iaddn(1), this.keyFromPrivate(E);
      }
    }),
    (h.prototype._truncateToN = function (p, m, _) {
      var A;
      if (i.isBN(p) || typeof p == 'number') (p = new i(p, 16)), (A = p.byteLength());
      else if (typeof p == 'object') (A = p.length), (p = new i(p, 16));
      else {
        var E = p.toString();
        (A = (E.length + 1) >>> 1), (p = new i(E, 16));
      }
      typeof _ != 'number' && (_ = A * 8);
      var I = _ - this.n.bitLength();
      return I > 0 && (p = p.ushrn(I)), !m && p.cmp(this.n) >= 0 ? p.sub(this.n) : p;
    }),
    (h.prototype.sign = function (p, m, _, A) {
      if (
        (typeof _ == 'object' && ((A = _), (_ = null)),
        A || (A = {}),
        typeof p != 'string' && typeof p != 'number' && !i.isBN(p))
      ) {
        n(
          typeof p == 'object' && p && typeof p.length == 'number',
          'Expected message to be an array-like, a hex string, or a BN instance'
        ),
          n(p.length >>> 0 === p.length);
        for (var E = 0; E < p.length; E++) n((p[E] & 255) === p[E]);
      }
      (m = this.keyFromPrivate(m, _)),
        (p = this._truncateToN(p, !1, A.msgBitLength)),
        n(!p.isNeg(), 'Can not sign a negative message');
      var I = this.n.byteLength(),
        R = m.getPrivate().toArray('be', I),
        L = p.toArray('be', I);
      n(new i(L).eq(p), 'Can not sign message');
      for (
        var D = new e({
            hash: this.hash,
            entropy: R,
            nonce: L,
            pers: A.pers,
            persEnc: A.persEnc || 'utf8',
          }),
          q = this.n.sub(new i(1)),
          H = 0;
        ;
        H++
      ) {
        var V = A.k ? A.k(H) : new i(D.generate(this.n.byteLength()));
        if (((V = this._truncateToN(V, !0)), !(V.cmpn(1) <= 0 || V.cmp(q) >= 0))) {
          var te = this.g.mul(V);
          if (!te.isInfinity()) {
            var ue = te.getX(),
              ne = ue.umod(this.n);
            if (ne.cmpn(0) !== 0) {
              var X = V.invm(this.n).mul(ne.mul(m.getPrivate()).iadd(p));
              if (((X = X.umod(this.n)), X.cmpn(0) !== 0)) {
                var Oe = (te.getY().isOdd() ? 1 : 0) | (ue.cmp(ne) !== 0 ? 2 : 0);
                return (
                  A.canonical && X.cmp(this.nh) > 0 && ((X = this.n.sub(X)), (Oe ^= 1)),
                  new f({ r: ne, s: X, recoveryParam: Oe })
                );
              }
            }
          }
        }
      }
    }),
    (h.prototype.verify = function (p, m, _, A, E) {
      E || (E = {}),
        (p = this._truncateToN(p, !1, E.msgBitLength)),
        (_ = this.keyFromPublic(_, A)),
        (m = new f(m, 'hex'));
      var I = m.r,
        R = m.s;
      if (I.cmpn(1) < 0 || I.cmp(this.n) >= 0 || R.cmpn(1) < 0 || R.cmp(this.n) >= 0) return !1;
      var L = R.invm(this.n),
        D = L.mul(p).umod(this.n),
        q = L.mul(I).umod(this.n),
        H;
      return this.curve._maxwellTrick
        ? ((H = this.g.jmulAdd(D, _.getPublic(), q)), H.isInfinity() ? !1 : H.eqXToP(I))
        : ((H = this.g.mulAdd(D, _.getPublic(), q)),
          H.isInfinity() ? !1 : H.getX().umod(this.n).cmp(I) === 0);
    }),
    (h.prototype.recoverPubKey = function (y, p, m, _) {
      n((3 & m) === m, 'The recovery param is more than two bits'), (p = new f(p, _));
      var A = this.n,
        E = new i(y),
        I = p.r,
        R = p.s,
        L = m & 1,
        D = m >> 1;
      if (I.cmp(this.curve.p.umod(this.curve.n)) >= 0 && D)
        throw new Error('Unable to find sencond key candinate');
      D ? (I = this.curve.pointFromX(I.add(this.curve.n), L)) : (I = this.curve.pointFromX(I, L));
      var q = p.r.invm(A),
        H = A.sub(E).mul(q).umod(A),
        V = R.mul(q).umod(A);
      return this.g.mulAdd(H, I, V);
    }),
    (h.prototype.getKeyRecoveryParam = function (y, p, m, _) {
      if (((p = new f(p, _)), p.recoveryParam !== null)) return p.recoveryParam;
      for (var A = 0; A < 4; A++) {
        var E;
        try {
          E = this.recoverPubKey(y, p, A);
        } catch {
          continue;
        }
        if (E.eq(m)) return A;
      }
      throw new Error('Unable to find valid recovery factor');
    }),
    p0
  );
}
var y0, Vv;
function kx() {
  if (Vv) return y0;
  Vv = 1;
  var i = en(),
    e = i.assert,
    t = i.parseBytes,
    r = i.cachedProperty;
  function s(n, c) {
    (this.eddsa = n),
      (this._secret = t(c.secret)),
      n.isPoint(c.pub) ? (this._pub = c.pub) : (this._pubBytes = t(c.pub));
  }
  return (
    (s.fromPublic = function (c, f) {
      return f instanceof s ? f : new s(c, { pub: f });
    }),
    (s.fromSecret = function (c, f) {
      return f instanceof s ? f : new s(c, { secret: f });
    }),
    (s.prototype.secret = function () {
      return this._secret;
    }),
    r(s, 'pubBytes', function () {
      return this.eddsa.encodePoint(this.pub());
    }),
    r(s, 'pub', function () {
      return this._pubBytes
        ? this.eddsa.decodePoint(this._pubBytes)
        : this.eddsa.g.mul(this.priv());
    }),
    r(s, 'privBytes', function () {
      var c = this.eddsa,
        f = this.hash(),
        h = c.encodingLength - 1,
        y = f.slice(0, c.encodingLength);
      return (y[0] &= 248), (y[h] &= 127), (y[h] |= 64), y;
    }),
    r(s, 'priv', function () {
      return this.eddsa.decodeInt(this.privBytes());
    }),
    r(s, 'hash', function () {
      return this.eddsa.hash().update(this.secret()).digest();
    }),
    r(s, 'messagePrefix', function () {
      return this.hash().slice(this.eddsa.encodingLength);
    }),
    (s.prototype.sign = function (c) {
      return e(this._secret, 'KeyPair can only verify'), this.eddsa.sign(c, this);
    }),
    (s.prototype.verify = function (c, f) {
      return this.eddsa.verify(c, f, this);
    }),
    (s.prototype.getSecret = function (c) {
      return e(this._secret, 'KeyPair is public only'), i.encode(this.secret(), c);
    }),
    (s.prototype.getPublic = function (c) {
      return i.encode(this.pubBytes(), c);
    }),
    (y0 = s),
    y0
  );
}
var g0, Gv;
function Ix() {
  if (Gv) return g0;
  Gv = 1;
  var i = co(),
    e = en(),
    t = e.assert,
    r = e.cachedProperty,
    s = e.parseBytes;
  function n(c, f) {
    (this.eddsa = c),
      typeof f != 'object' && (f = s(f)),
      Array.isArray(f) &&
        (t(f.length === c.encodingLength * 2, 'Signature has invalid size'),
        (f = { R: f.slice(0, c.encodingLength), S: f.slice(c.encodingLength) })),
      t(f.R && f.S, 'Signature without R or S'),
      c.isPoint(f.R) && (this._R = f.R),
      f.S instanceof i && (this._S = f.S),
      (this._Rencoded = Array.isArray(f.R) ? f.R : f.Rencoded),
      (this._Sencoded = Array.isArray(f.S) ? f.S : f.Sencoded);
  }
  return (
    r(n, 'S', function () {
      return this.eddsa.decodeInt(this.Sencoded());
    }),
    r(n, 'R', function () {
      return this.eddsa.decodePoint(this.Rencoded());
    }),
    r(n, 'Rencoded', function () {
      return this.eddsa.encodePoint(this.R());
    }),
    r(n, 'Sencoded', function () {
      return this.eddsa.encodeInt(this.S());
    }),
    (n.prototype.toBytes = function () {
      return this.Rencoded().concat(this.Sencoded());
    }),
    (n.prototype.toHex = function () {
      return e.encode(this.toBytes(), 'hex').toUpperCase();
    }),
    (g0 = n),
    g0
  );
}
var b0, Yv;
function xx() {
  if (Yv) return b0;
  Yv = 1;
  var i = ic,
    e = ly(),
    t = en(),
    r = t.assert,
    s = t.parseBytes,
    n = kx(),
    c = Ix();
  function f(h) {
    if ((r(h === 'ed25519', 'only tested with ed25519 so far'), !(this instanceof f)))
      return new f(h);
    (h = e[h].curve),
      (this.curve = h),
      (this.g = h.g),
      this.g.precompute(h.n.bitLength() + 1),
      (this.pointClass = h.point().constructor),
      (this.encodingLength = Math.ceil(h.n.bitLength() / 8)),
      (this.hash = i.sha512);
  }
  return (
    (b0 = f),
    (f.prototype.sign = function (y, p) {
      y = s(y);
      var m = this.keyFromSecret(p),
        _ = this.hashInt(m.messagePrefix(), y),
        A = this.g.mul(_),
        E = this.encodePoint(A),
        I = this.hashInt(E, m.pubBytes(), y).mul(m.priv()),
        R = _.add(I).umod(this.curve.n);
      return this.makeSignature({ R: A, S: R, Rencoded: E });
    }),
    (f.prototype.verify = function (y, p, m) {
      if (((y = s(y)), (p = this.makeSignature(p)), p.S().gte(p.eddsa.curve.n) || p.S().isNeg()))
        return !1;
      var _ = this.keyFromPublic(m),
        A = this.hashInt(p.Rencoded(), _.pubBytes(), y),
        E = this.g.mul(p.S()),
        I = p.R().add(_.pub().mul(A));
      return I.eq(E);
    }),
    (f.prototype.hashInt = function () {
      for (var y = this.hash(), p = 0; p < arguments.length; p++) y.update(arguments[p]);
      return t.intFromLE(y.digest()).umod(this.curve.n);
    }),
    (f.prototype.keyFromPublic = function (y) {
      return n.fromPublic(this, y);
    }),
    (f.prototype.keyFromSecret = function (y) {
      return n.fromSecret(this, y);
    }),
    (f.prototype.makeSignature = function (y) {
      return y instanceof c ? y : new c(this, y);
    }),
    (f.prototype.encodePoint = function (y) {
      var p = y.getY().toArray('le', this.encodingLength);
      return (p[this.encodingLength - 1] |= y.getX().isOdd() ? 128 : 0), p;
    }),
    (f.prototype.decodePoint = function (y) {
      y = t.parseBytes(y);
      var p = y.length - 1,
        m = y.slice(0, p).concat(y[p] & -129),
        _ = (y[p] & 128) !== 0,
        A = t.intFromLE(m);
      return this.curve.pointFromY(A, _);
    }),
    (f.prototype.encodeInt = function (y) {
      return y.toArray('le', this.encodingLength);
    }),
    (f.prototype.decodeInt = function (y) {
      return t.intFromLE(y);
    }),
    (f.prototype.isPoint = function (y) {
      return y instanceof this.pointClass;
    }),
    b0
  );
}
var Zv;
function hy() {
  return (
    Zv ||
      ((Zv = 1),
      (function (i) {
        var e = i;
        (e.version = jk.version),
          (e.utils = en()),
          (e.rand = uy()),
          (e.curve = u8()),
          (e.curves = ly()),
          (e.ec = Ex()),
          (e.eddsa = xx());
      })(Xd)),
    Xd
  );
}
var Ki = {},
  v0 = {},
  Sf = { exports: {} };
Sf.exports;
var Jv;
function k8() {
  return (
    Jv ||
      ((Jv = 1),
      (function (i) {
        (function (e, t) {
          function r(S, o) {
            if (!S) throw new Error(o || 'Assertion failed');
          }
          function s(S, o) {
            S.super_ = o;
            var u = function () {};
            (u.prototype = o.prototype), (S.prototype = new u()), (S.prototype.constructor = S);
          }
          function n(S, o, u) {
            if (n.isBN(S)) return S;
            (this.negative = 0),
              (this.words = null),
              (this.length = 0),
              (this.red = null),
              S !== null &&
                ((o === 'le' || o === 'be') && ((u = o), (o = 10)),
                this._init(S || 0, o || 10, u || 'be'));
          }
          typeof e == 'object' ? (e.exports = n) : (t.BN = n), (n.BN = n), (n.wordSize = 26);
          var c;
          try {
            typeof window < 'u' && typeof window.Buffer < 'u'
              ? (c = window.Buffer)
              : (c = ai.Buffer);
          } catch {}
          (n.isBN = function (o) {
            return o instanceof n
              ? !0
              : o !== null &&
                  typeof o == 'object' &&
                  o.constructor.wordSize === n.wordSize &&
                  Array.isArray(o.words);
          }),
            (n.max = function (o, u) {
              return o.cmp(u) > 0 ? o : u;
            }),
            (n.min = function (o, u) {
              return o.cmp(u) < 0 ? o : u;
            }),
            (n.prototype._init = function (o, u, l) {
              if (typeof o == 'number') return this._initNumber(o, u, l);
              if (typeof o == 'object') return this._initArray(o, u, l);
              u === 'hex' && (u = 16),
                r(u === (u | 0) && u >= 2 && u <= 36),
                (o = o.toString().replace(/\s+/g, ''));
              var d = 0;
              o[0] === '-' && (d++, (this.negative = 1)),
                d < o.length &&
                  (u === 16
                    ? this._parseHex(o, d, l)
                    : (this._parseBase(o, u, d),
                      l === 'le' && this._initArray(this.toArray(), u, l)));
            }),
            (n.prototype._initNumber = function (o, u, l) {
              o < 0 && ((this.negative = 1), (o = -o)),
                o < 67108864
                  ? ((this.words = [o & 67108863]), (this.length = 1))
                  : o < 4503599627370496
                    ? ((this.words = [o & 67108863, (o / 67108864) & 67108863]), (this.length = 2))
                    : (r(o < 9007199254740992),
                      (this.words = [o & 67108863, (o / 67108864) & 67108863, 1]),
                      (this.length = 3)),
                l === 'le' && this._initArray(this.toArray(), u, l);
            }),
            (n.prototype._initArray = function (o, u, l) {
              if ((r(typeof o.length == 'number'), o.length <= 0))
                return (this.words = [0]), (this.length = 1), this;
              (this.length = Math.ceil(o.length / 3)), (this.words = new Array(this.length));
              for (var d = 0; d < this.length; d++) this.words[d] = 0;
              var g,
                w,
                M = 0;
              if (l === 'be')
                for (d = o.length - 1, g = 0; d >= 0; d -= 3)
                  (w = o[d] | (o[d - 1] << 8) | (o[d - 2] << 16)),
                    (this.words[g] |= (w << M) & 67108863),
                    (this.words[g + 1] = (w >>> (26 - M)) & 67108863),
                    (M += 24),
                    M >= 26 && ((M -= 26), g++);
              else if (l === 'le')
                for (d = 0, g = 0; d < o.length; d += 3)
                  (w = o[d] | (o[d + 1] << 8) | (o[d + 2] << 16)),
                    (this.words[g] |= (w << M) & 67108863),
                    (this.words[g + 1] = (w >>> (26 - M)) & 67108863),
                    (M += 24),
                    M >= 26 && ((M -= 26), g++);
              return this.strip();
            });
          function f(S, o) {
            var u = S.charCodeAt(o);
            return u >= 65 && u <= 70 ? u - 55 : u >= 97 && u <= 102 ? u - 87 : (u - 48) & 15;
          }
          function h(S, o, u) {
            var l = f(S, u);
            return u - 1 >= o && (l |= f(S, u - 1) << 4), l;
          }
          n.prototype._parseHex = function (o, u, l) {
            (this.length = Math.ceil((o.length - u) / 6)), (this.words = new Array(this.length));
            for (var d = 0; d < this.length; d++) this.words[d] = 0;
            var g = 0,
              w = 0,
              M;
            if (l === 'be')
              for (d = o.length - 1; d >= u; d -= 2)
                (M = h(o, u, d) << g),
                  (this.words[w] |= M & 67108863),
                  g >= 18 ? ((g -= 18), (w += 1), (this.words[w] |= M >>> 26)) : (g += 8);
            else {
              var v = o.length - u;
              for (d = v % 2 === 0 ? u + 1 : u; d < o.length; d += 2)
                (M = h(o, u, d) << g),
                  (this.words[w] |= M & 67108863),
                  g >= 18 ? ((g -= 18), (w += 1), (this.words[w] |= M >>> 26)) : (g += 8);
            }
            this.strip();
          };
          function y(S, o, u, l) {
            for (var d = 0, g = Math.min(S.length, u), w = o; w < g; w++) {
              var M = S.charCodeAt(w) - 48;
              (d *= l), M >= 49 ? (d += M - 49 + 10) : M >= 17 ? (d += M - 17 + 10) : (d += M);
            }
            return d;
          }
          (n.prototype._parseBase = function (o, u, l) {
            (this.words = [0]), (this.length = 1);
            for (var d = 0, g = 1; g <= 67108863; g *= u) d++;
            d--, (g = (g / u) | 0);
            for (
              var w = o.length - l, M = w % d, v = Math.min(w, w - M) + l, a = 0, b = l;
              b < v;
              b += d
            )
              (a = y(o, b, b + d, u)),
                this.imuln(g),
                this.words[0] + a < 67108864 ? (this.words[0] += a) : this._iaddn(a);
            if (M !== 0) {
              var k = 1;
              for (a = y(o, b, o.length, u), b = 0; b < M; b++) k *= u;
              this.imuln(k), this.words[0] + a < 67108864 ? (this.words[0] += a) : this._iaddn(a);
            }
            this.strip();
          }),
            (n.prototype.copy = function (o) {
              o.words = new Array(this.length);
              for (var u = 0; u < this.length; u++) o.words[u] = this.words[u];
              (o.length = this.length), (o.negative = this.negative), (o.red = this.red);
            }),
            (n.prototype.clone = function () {
              var o = new n(null);
              return this.copy(o), o;
            }),
            (n.prototype._expand = function (o) {
              for (; this.length < o; ) this.words[this.length++] = 0;
              return this;
            }),
            (n.prototype.strip = function () {
              for (; this.length > 1 && this.words[this.length - 1] === 0; ) this.length--;
              return this._normSign();
            }),
            (n.prototype._normSign = function () {
              return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
            }),
            (n.prototype.inspect = function () {
              return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
            });
          var p = [
              '',
              '0',
              '00',
              '000',
              '0000',
              '00000',
              '000000',
              '0000000',
              '00000000',
              '000000000',
              '0000000000',
              '00000000000',
              '000000000000',
              '0000000000000',
              '00000000000000',
              '000000000000000',
              '0000000000000000',
              '00000000000000000',
              '000000000000000000',
              '0000000000000000000',
              '00000000000000000000',
              '000000000000000000000',
              '0000000000000000000000',
              '00000000000000000000000',
              '000000000000000000000000',
              '0000000000000000000000000',
            ],
            m = [
              0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5,
              5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            ],
            _ = [
              0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721,
              1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224,
              47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907,
              17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176,
            ];
          (n.prototype.toString = function (o, u) {
            (o = o || 10), (u = u | 0 || 1);
            var l;
            if (o === 16 || o === 'hex') {
              l = '';
              for (var d = 0, g = 0, w = 0; w < this.length; w++) {
                var M = this.words[w],
                  v = (((M << d) | g) & 16777215).toString(16);
                (g = (M >>> (24 - d)) & 16777215),
                  g !== 0 || w !== this.length - 1 ? (l = p[6 - v.length] + v + l) : (l = v + l),
                  (d += 2),
                  d >= 26 && ((d -= 26), w--);
              }
              for (g !== 0 && (l = g.toString(16) + l); l.length % u !== 0; ) l = '0' + l;
              return this.negative !== 0 && (l = '-' + l), l;
            }
            if (o === (o | 0) && o >= 2 && o <= 36) {
              var a = m[o],
                b = _[o];
              l = '';
              var k = this.clone();
              for (k.negative = 0; !k.isZero(); ) {
                var B = k.modn(b).toString(o);
                (k = k.idivn(b)), k.isZero() ? (l = B + l) : (l = p[a - B.length] + B + l);
              }
              for (this.isZero() && (l = '0' + l); l.length % u !== 0; ) l = '0' + l;
              return this.negative !== 0 && (l = '-' + l), l;
            }
            r(!1, 'Base should be between 2 and 36');
          }),
            (n.prototype.toNumber = function () {
              var o = this.words[0];
              return (
                this.length === 2
                  ? (o += this.words[1] * 67108864)
                  : this.length === 3 && this.words[2] === 1
                    ? (o += 4503599627370496 + this.words[1] * 67108864)
                    : this.length > 2 && r(!1, 'Number can only safely store up to 53 bits'),
                this.negative !== 0 ? -o : o
              );
            }),
            (n.prototype.toJSON = function () {
              return this.toString(16);
            }),
            (n.prototype.toBuffer = function (o, u) {
              return r(typeof c < 'u'), this.toArrayLike(c, o, u);
            }),
            (n.prototype.toArray = function (o, u) {
              return this.toArrayLike(Array, o, u);
            }),
            (n.prototype.toArrayLike = function (o, u, l) {
              var d = this.byteLength(),
                g = l || Math.max(1, d);
              r(d <= g, 'byte array longer than desired length'),
                r(g > 0, 'Requested array length <= 0'),
                this.strip();
              var w = u === 'le',
                M = new o(g),
                v,
                a,
                b = this.clone();
              if (w) {
                for (a = 0; !b.isZero(); a++) (v = b.andln(255)), b.iushrn(8), (M[a] = v);
                for (; a < g; a++) M[a] = 0;
              } else {
                for (a = 0; a < g - d; a++) M[a] = 0;
                for (a = 0; !b.isZero(); a++) (v = b.andln(255)), b.iushrn(8), (M[g - a - 1] = v);
              }
              return M;
            }),
            Math.clz32
              ? (n.prototype._countBits = function (o) {
                  return 32 - Math.clz32(o);
                })
              : (n.prototype._countBits = function (o) {
                  var u = o,
                    l = 0;
                  return (
                    u >= 4096 && ((l += 13), (u >>>= 13)),
                    u >= 64 && ((l += 7), (u >>>= 7)),
                    u >= 8 && ((l += 4), (u >>>= 4)),
                    u >= 2 && ((l += 2), (u >>>= 2)),
                    l + u
                  );
                }),
            (n.prototype._zeroBits = function (o) {
              if (o === 0) return 26;
              var u = o,
                l = 0;
              return (
                u & 8191 || ((l += 13), (u >>>= 13)),
                u & 127 || ((l += 7), (u >>>= 7)),
                u & 15 || ((l += 4), (u >>>= 4)),
                u & 3 || ((l += 2), (u >>>= 2)),
                u & 1 || l++,
                l
              );
            }),
            (n.prototype.bitLength = function () {
              var o = this.words[this.length - 1],
                u = this._countBits(o);
              return (this.length - 1) * 26 + u;
            });
          function A(S) {
            for (var o = new Array(S.bitLength()), u = 0; u < o.length; u++) {
              var l = (u / 26) | 0,
                d = u % 26;
              o[u] = (S.words[l] & (1 << d)) >>> d;
            }
            return o;
          }
          (n.prototype.zeroBits = function () {
            if (this.isZero()) return 0;
            for (var o = 0, u = 0; u < this.length; u++) {
              var l = this._zeroBits(this.words[u]);
              if (((o += l), l !== 26)) break;
            }
            return o;
          }),
            (n.prototype.byteLength = function () {
              return Math.ceil(this.bitLength() / 8);
            }),
            (n.prototype.toTwos = function (o) {
              return this.negative !== 0 ? this.abs().inotn(o).iaddn(1) : this.clone();
            }),
            (n.prototype.fromTwos = function (o) {
              return this.testn(o - 1) ? this.notn(o).iaddn(1).ineg() : this.clone();
            }),
            (n.prototype.isNeg = function () {
              return this.negative !== 0;
            }),
            (n.prototype.neg = function () {
              return this.clone().ineg();
            }),
            (n.prototype.ineg = function () {
              return this.isZero() || (this.negative ^= 1), this;
            }),
            (n.prototype.iuor = function (o) {
              for (; this.length < o.length; ) this.words[this.length++] = 0;
              for (var u = 0; u < o.length; u++) this.words[u] = this.words[u] | o.words[u];
              return this.strip();
            }),
            (n.prototype.ior = function (o) {
              return r((this.negative | o.negative) === 0), this.iuor(o);
            }),
            (n.prototype.or = function (o) {
              return this.length > o.length ? this.clone().ior(o) : o.clone().ior(this);
            }),
            (n.prototype.uor = function (o) {
              return this.length > o.length ? this.clone().iuor(o) : o.clone().iuor(this);
            }),
            (n.prototype.iuand = function (o) {
              var u;
              this.length > o.length ? (u = o) : (u = this);
              for (var l = 0; l < u.length; l++) this.words[l] = this.words[l] & o.words[l];
              return (this.length = u.length), this.strip();
            }),
            (n.prototype.iand = function (o) {
              return r((this.negative | o.negative) === 0), this.iuand(o);
            }),
            (n.prototype.and = function (o) {
              return this.length > o.length ? this.clone().iand(o) : o.clone().iand(this);
            }),
            (n.prototype.uand = function (o) {
              return this.length > o.length ? this.clone().iuand(o) : o.clone().iuand(this);
            }),
            (n.prototype.iuxor = function (o) {
              var u, l;
              this.length > o.length ? ((u = this), (l = o)) : ((u = o), (l = this));
              for (var d = 0; d < l.length; d++) this.words[d] = u.words[d] ^ l.words[d];
              if (this !== u) for (; d < u.length; d++) this.words[d] = u.words[d];
              return (this.length = u.length), this.strip();
            }),
            (n.prototype.ixor = function (o) {
              return r((this.negative | o.negative) === 0), this.iuxor(o);
            }),
            (n.prototype.xor = function (o) {
              return this.length > o.length ? this.clone().ixor(o) : o.clone().ixor(this);
            }),
            (n.prototype.uxor = function (o) {
              return this.length > o.length ? this.clone().iuxor(o) : o.clone().iuxor(this);
            }),
            (n.prototype.inotn = function (o) {
              r(typeof o == 'number' && o >= 0);
              var u = Math.ceil(o / 26) | 0,
                l = o % 26;
              this._expand(u), l > 0 && u--;
              for (var d = 0; d < u; d++) this.words[d] = ~this.words[d] & 67108863;
              return (
                l > 0 && (this.words[d] = ~this.words[d] & (67108863 >> (26 - l))), this.strip()
              );
            }),
            (n.prototype.notn = function (o) {
              return this.clone().inotn(o);
            }),
            (n.prototype.setn = function (o, u) {
              r(typeof o == 'number' && o >= 0);
              var l = (o / 26) | 0,
                d = o % 26;
              return (
                this._expand(l + 1),
                u
                  ? (this.words[l] = this.words[l] | (1 << d))
                  : (this.words[l] = this.words[l] & ~(1 << d)),
                this.strip()
              );
            }),
            (n.prototype.iadd = function (o) {
              var u;
              if (this.negative !== 0 && o.negative === 0)
                return (
                  (this.negative = 0), (u = this.isub(o)), (this.negative ^= 1), this._normSign()
                );
              if (this.negative === 0 && o.negative !== 0)
                return (o.negative = 0), (u = this.isub(o)), (o.negative = 1), u._normSign();
              var l, d;
              this.length > o.length ? ((l = this), (d = o)) : ((l = o), (d = this));
              for (var g = 0, w = 0; w < d.length; w++)
                (u = (l.words[w] | 0) + (d.words[w] | 0) + g),
                  (this.words[w] = u & 67108863),
                  (g = u >>> 26);
              for (; g !== 0 && w < l.length; w++)
                (u = (l.words[w] | 0) + g), (this.words[w] = u & 67108863), (g = u >>> 26);
              if (((this.length = l.length), g !== 0)) (this.words[this.length] = g), this.length++;
              else if (l !== this) for (; w < l.length; w++) this.words[w] = l.words[w];
              return this;
            }),
            (n.prototype.add = function (o) {
              var u;
              return o.negative !== 0 && this.negative === 0
                ? ((o.negative = 0), (u = this.sub(o)), (o.negative ^= 1), u)
                : o.negative === 0 && this.negative !== 0
                  ? ((this.negative = 0), (u = o.sub(this)), (this.negative = 1), u)
                  : this.length > o.length
                    ? this.clone().iadd(o)
                    : o.clone().iadd(this);
            }),
            (n.prototype.isub = function (o) {
              if (o.negative !== 0) {
                o.negative = 0;
                var u = this.iadd(o);
                return (o.negative = 1), u._normSign();
              } else if (this.negative !== 0)
                return (this.negative = 0), this.iadd(o), (this.negative = 1), this._normSign();
              var l = this.cmp(o);
              if (l === 0) return (this.negative = 0), (this.length = 1), (this.words[0] = 0), this;
              var d, g;
              l > 0 ? ((d = this), (g = o)) : ((d = o), (g = this));
              for (var w = 0, M = 0; M < g.length; M++)
                (u = (d.words[M] | 0) - (g.words[M] | 0) + w),
                  (w = u >> 26),
                  (this.words[M] = u & 67108863);
              for (; w !== 0 && M < d.length; M++)
                (u = (d.words[M] | 0) + w), (w = u >> 26), (this.words[M] = u & 67108863);
              if (w === 0 && M < d.length && d !== this)
                for (; M < d.length; M++) this.words[M] = d.words[M];
              return (
                (this.length = Math.max(this.length, M)),
                d !== this && (this.negative = 1),
                this.strip()
              );
            }),
            (n.prototype.sub = function (o) {
              return this.clone().isub(o);
            });
          function E(S, o, u) {
            u.negative = o.negative ^ S.negative;
            var l = (S.length + o.length) | 0;
            (u.length = l), (l = (l - 1) | 0);
            var d = S.words[0] | 0,
              g = o.words[0] | 0,
              w = d * g,
              M = w & 67108863,
              v = (w / 67108864) | 0;
            u.words[0] = M;
            for (var a = 1; a < l; a++) {
              for (
                var b = v >>> 26,
                  k = v & 67108863,
                  B = Math.min(a, o.length - 1),
                  F = Math.max(0, a - S.length + 1);
                F <= B;
                F++
              ) {
                var P = (a - F) | 0;
                (d = S.words[P] | 0),
                  (g = o.words[F] | 0),
                  (w = d * g + k),
                  (b += (w / 67108864) | 0),
                  (k = w & 67108863);
              }
              (u.words[a] = k | 0), (v = b | 0);
            }
            return v !== 0 ? (u.words[a] = v | 0) : u.length--, u.strip();
          }
          var I = function (o, u, l) {
            var d = o.words,
              g = u.words,
              w = l.words,
              M = 0,
              v,
              a,
              b,
              k = d[0] | 0,
              B = k & 8191,
              F = k >>> 13,
              P = d[1] | 0,
              C = P & 8191,
              z = P >>> 13,
              Y = d[2] | 0,
              G = Y & 8191,
              Q = Y >>> 13,
              U = d[3] | 0,
              $ = U & 8191,
              Z = U >>> 13,
              ae = d[4] | 0,
              fe = ae & 8191,
              le = ae >>> 13,
              Fe = d[5] | 0,
              be = Fe & 8191,
              oe = Fe >>> 13,
              rt = d[6] | 0,
              me = rt & 8191,
              re = rt >>> 13,
              ge = d[7] | 0,
              ce = ge & 8191,
              he = ge >>> 13,
              Ke = d[8] | 0,
              K = Ke & 8191,
              O = Ke >>> 13,
              W = d[9] | 0,
              T = W & 8191,
              x = W >>> 13,
              N = g[0] | 0,
              j = N & 8191,
              J = N >>> 13,
              de = g[1] | 0,
              ie = de & 8191,
              ye = de >>> 13,
              Ye = g[2] | 0,
              ve = Ye & 8191,
              _e = Ye >>> 13,
              et = g[3] | 0,
              Me = et & 8191,
              Ce = et >>> 13,
              yt = g[4] | 0,
              Ae = yt & 8191,
              Le = yt >>> 13,
              gt = g[5] | 0,
              Ee = gt & 8191,
              Ne = gt >>> 13,
              bt = g[6] | 0,
              ke = bt & 8191,
              $e = bt >>> 13,
              vt = g[7] | 0,
              Ie = vt & 8191,
              De = vt >>> 13,
              mt = g[8] | 0,
              xe = mt & 8191,
              Ue = mt >>> 13,
              wt = g[9] | 0,
              Be = wt & 8191,
              ze = wt >>> 13;
            (l.negative = o.negative ^ u.negative),
              (l.length = 19),
              (v = Math.imul(B, j)),
              (a = Math.imul(B, J)),
              (a = (a + Math.imul(F, j)) | 0),
              (b = Math.imul(F, J));
            var st = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (st >>> 26)) | 0),
              (st &= 67108863),
              (v = Math.imul(C, j)),
              (a = Math.imul(C, J)),
              (a = (a + Math.imul(z, j)) | 0),
              (b = Math.imul(z, J)),
              (v = (v + Math.imul(B, ie)) | 0),
              (a = (a + Math.imul(B, ye)) | 0),
              (a = (a + Math.imul(F, ie)) | 0),
              (b = (b + Math.imul(F, ye)) | 0);
            var at = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (at >>> 26)) | 0),
              (at &= 67108863),
              (v = Math.imul(G, j)),
              (a = Math.imul(G, J)),
              (a = (a + Math.imul(Q, j)) | 0),
              (b = Math.imul(Q, J)),
              (v = (v + Math.imul(C, ie)) | 0),
              (a = (a + Math.imul(C, ye)) | 0),
              (a = (a + Math.imul(z, ie)) | 0),
              (b = (b + Math.imul(z, ye)) | 0),
              (v = (v + Math.imul(B, ve)) | 0),
              (a = (a + Math.imul(B, _e)) | 0),
              (a = (a + Math.imul(F, ve)) | 0),
              (b = (b + Math.imul(F, _e)) | 0);
            var Ft = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (Ft >>> 26)) | 0),
              (Ft &= 67108863),
              (v = Math.imul($, j)),
              (a = Math.imul($, J)),
              (a = (a + Math.imul(Z, j)) | 0),
              (b = Math.imul(Z, J)),
              (v = (v + Math.imul(G, ie)) | 0),
              (a = (a + Math.imul(G, ye)) | 0),
              (a = (a + Math.imul(Q, ie)) | 0),
              (b = (b + Math.imul(Q, ye)) | 0),
              (v = (v + Math.imul(C, ve)) | 0),
              (a = (a + Math.imul(C, _e)) | 0),
              (a = (a + Math.imul(z, ve)) | 0),
              (b = (b + Math.imul(z, _e)) | 0),
              (v = (v + Math.imul(B, Me)) | 0),
              (a = (a + Math.imul(B, Ce)) | 0),
              (a = (a + Math.imul(F, Me)) | 0),
              (b = (b + Math.imul(F, Ce)) | 0);
            var qt = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (qt >>> 26)) | 0),
              (qt &= 67108863),
              (v = Math.imul(fe, j)),
              (a = Math.imul(fe, J)),
              (a = (a + Math.imul(le, j)) | 0),
              (b = Math.imul(le, J)),
              (v = (v + Math.imul($, ie)) | 0),
              (a = (a + Math.imul($, ye)) | 0),
              (a = (a + Math.imul(Z, ie)) | 0),
              (b = (b + Math.imul(Z, ye)) | 0),
              (v = (v + Math.imul(G, ve)) | 0),
              (a = (a + Math.imul(G, _e)) | 0),
              (a = (a + Math.imul(Q, ve)) | 0),
              (b = (b + Math.imul(Q, _e)) | 0),
              (v = (v + Math.imul(C, Me)) | 0),
              (a = (a + Math.imul(C, Ce)) | 0),
              (a = (a + Math.imul(z, Me)) | 0),
              (b = (b + Math.imul(z, Ce)) | 0),
              (v = (v + Math.imul(B, Ae)) | 0),
              (a = (a + Math.imul(B, Le)) | 0),
              (a = (a + Math.imul(F, Ae)) | 0),
              (b = (b + Math.imul(F, Le)) | 0);
            var Wt = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (Wt >>> 26)) | 0),
              (Wt &= 67108863),
              (v = Math.imul(be, j)),
              (a = Math.imul(be, J)),
              (a = (a + Math.imul(oe, j)) | 0),
              (b = Math.imul(oe, J)),
              (v = (v + Math.imul(fe, ie)) | 0),
              (a = (a + Math.imul(fe, ye)) | 0),
              (a = (a + Math.imul(le, ie)) | 0),
              (b = (b + Math.imul(le, ye)) | 0),
              (v = (v + Math.imul($, ve)) | 0),
              (a = (a + Math.imul($, _e)) | 0),
              (a = (a + Math.imul(Z, ve)) | 0),
              (b = (b + Math.imul(Z, _e)) | 0),
              (v = (v + Math.imul(G, Me)) | 0),
              (a = (a + Math.imul(G, Ce)) | 0),
              (a = (a + Math.imul(Q, Me)) | 0),
              (b = (b + Math.imul(Q, Ce)) | 0),
              (v = (v + Math.imul(C, Ae)) | 0),
              (a = (a + Math.imul(C, Le)) | 0),
              (a = (a + Math.imul(z, Ae)) | 0),
              (b = (b + Math.imul(z, Le)) | 0),
              (v = (v + Math.imul(B, Ee)) | 0),
              (a = (a + Math.imul(B, Ne)) | 0),
              (a = (a + Math.imul(F, Ee)) | 0),
              (b = (b + Math.imul(F, Ne)) | 0);
            var Kt = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (Kt >>> 26)) | 0),
              (Kt &= 67108863),
              (v = Math.imul(me, j)),
              (a = Math.imul(me, J)),
              (a = (a + Math.imul(re, j)) | 0),
              (b = Math.imul(re, J)),
              (v = (v + Math.imul(be, ie)) | 0),
              (a = (a + Math.imul(be, ye)) | 0),
              (a = (a + Math.imul(oe, ie)) | 0),
              (b = (b + Math.imul(oe, ye)) | 0),
              (v = (v + Math.imul(fe, ve)) | 0),
              (a = (a + Math.imul(fe, _e)) | 0),
              (a = (a + Math.imul(le, ve)) | 0),
              (b = (b + Math.imul(le, _e)) | 0),
              (v = (v + Math.imul($, Me)) | 0),
              (a = (a + Math.imul($, Ce)) | 0),
              (a = (a + Math.imul(Z, Me)) | 0),
              (b = (b + Math.imul(Z, Ce)) | 0),
              (v = (v + Math.imul(G, Ae)) | 0),
              (a = (a + Math.imul(G, Le)) | 0),
              (a = (a + Math.imul(Q, Ae)) | 0),
              (b = (b + Math.imul(Q, Le)) | 0),
              (v = (v + Math.imul(C, Ee)) | 0),
              (a = (a + Math.imul(C, Ne)) | 0),
              (a = (a + Math.imul(z, Ee)) | 0),
              (b = (b + Math.imul(z, Ne)) | 0),
              (v = (v + Math.imul(B, ke)) | 0),
              (a = (a + Math.imul(B, $e)) | 0),
              (a = (a + Math.imul(F, ke)) | 0),
              (b = (b + Math.imul(F, $e)) | 0);
            var jt = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (jt >>> 26)) | 0),
              (jt &= 67108863),
              (v = Math.imul(ce, j)),
              (a = Math.imul(ce, J)),
              (a = (a + Math.imul(he, j)) | 0),
              (b = Math.imul(he, J)),
              (v = (v + Math.imul(me, ie)) | 0),
              (a = (a + Math.imul(me, ye)) | 0),
              (a = (a + Math.imul(re, ie)) | 0),
              (b = (b + Math.imul(re, ye)) | 0),
              (v = (v + Math.imul(be, ve)) | 0),
              (a = (a + Math.imul(be, _e)) | 0),
              (a = (a + Math.imul(oe, ve)) | 0),
              (b = (b + Math.imul(oe, _e)) | 0),
              (v = (v + Math.imul(fe, Me)) | 0),
              (a = (a + Math.imul(fe, Ce)) | 0),
              (a = (a + Math.imul(le, Me)) | 0),
              (b = (b + Math.imul(le, Ce)) | 0),
              (v = (v + Math.imul($, Ae)) | 0),
              (a = (a + Math.imul($, Le)) | 0),
              (a = (a + Math.imul(Z, Ae)) | 0),
              (b = (b + Math.imul(Z, Le)) | 0),
              (v = (v + Math.imul(G, Ee)) | 0),
              (a = (a + Math.imul(G, Ne)) | 0),
              (a = (a + Math.imul(Q, Ee)) | 0),
              (b = (b + Math.imul(Q, Ne)) | 0),
              (v = (v + Math.imul(C, ke)) | 0),
              (a = (a + Math.imul(C, $e)) | 0),
              (a = (a + Math.imul(z, ke)) | 0),
              (b = (b + Math.imul(z, $e)) | 0),
              (v = (v + Math.imul(B, Ie)) | 0),
              (a = (a + Math.imul(B, De)) | 0),
              (a = (a + Math.imul(F, Ie)) | 0),
              (b = (b + Math.imul(F, De)) | 0);
            var fr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (fr >>> 26)) | 0),
              (fr &= 67108863),
              (v = Math.imul(K, j)),
              (a = Math.imul(K, J)),
              (a = (a + Math.imul(O, j)) | 0),
              (b = Math.imul(O, J)),
              (v = (v + Math.imul(ce, ie)) | 0),
              (a = (a + Math.imul(ce, ye)) | 0),
              (a = (a + Math.imul(he, ie)) | 0),
              (b = (b + Math.imul(he, ye)) | 0),
              (v = (v + Math.imul(me, ve)) | 0),
              (a = (a + Math.imul(me, _e)) | 0),
              (a = (a + Math.imul(re, ve)) | 0),
              (b = (b + Math.imul(re, _e)) | 0),
              (v = (v + Math.imul(be, Me)) | 0),
              (a = (a + Math.imul(be, Ce)) | 0),
              (a = (a + Math.imul(oe, Me)) | 0),
              (b = (b + Math.imul(oe, Ce)) | 0),
              (v = (v + Math.imul(fe, Ae)) | 0),
              (a = (a + Math.imul(fe, Le)) | 0),
              (a = (a + Math.imul(le, Ae)) | 0),
              (b = (b + Math.imul(le, Le)) | 0),
              (v = (v + Math.imul($, Ee)) | 0),
              (a = (a + Math.imul($, Ne)) | 0),
              (a = (a + Math.imul(Z, Ee)) | 0),
              (b = (b + Math.imul(Z, Ne)) | 0),
              (v = (v + Math.imul(G, ke)) | 0),
              (a = (a + Math.imul(G, $e)) | 0),
              (a = (a + Math.imul(Q, ke)) | 0),
              (b = (b + Math.imul(Q, $e)) | 0),
              (v = (v + Math.imul(C, Ie)) | 0),
              (a = (a + Math.imul(C, De)) | 0),
              (a = (a + Math.imul(z, Ie)) | 0),
              (b = (b + Math.imul(z, De)) | 0),
              (v = (v + Math.imul(B, xe)) | 0),
              (a = (a + Math.imul(B, Ue)) | 0),
              (a = (a + Math.imul(F, xe)) | 0),
              (b = (b + Math.imul(F, Ue)) | 0);
            var lr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (lr >>> 26)) | 0),
              (lr &= 67108863),
              (v = Math.imul(T, j)),
              (a = Math.imul(T, J)),
              (a = (a + Math.imul(x, j)) | 0),
              (b = Math.imul(x, J)),
              (v = (v + Math.imul(K, ie)) | 0),
              (a = (a + Math.imul(K, ye)) | 0),
              (a = (a + Math.imul(O, ie)) | 0),
              (b = (b + Math.imul(O, ye)) | 0),
              (v = (v + Math.imul(ce, ve)) | 0),
              (a = (a + Math.imul(ce, _e)) | 0),
              (a = (a + Math.imul(he, ve)) | 0),
              (b = (b + Math.imul(he, _e)) | 0),
              (v = (v + Math.imul(me, Me)) | 0),
              (a = (a + Math.imul(me, Ce)) | 0),
              (a = (a + Math.imul(re, Me)) | 0),
              (b = (b + Math.imul(re, Ce)) | 0),
              (v = (v + Math.imul(be, Ae)) | 0),
              (a = (a + Math.imul(be, Le)) | 0),
              (a = (a + Math.imul(oe, Ae)) | 0),
              (b = (b + Math.imul(oe, Le)) | 0),
              (v = (v + Math.imul(fe, Ee)) | 0),
              (a = (a + Math.imul(fe, Ne)) | 0),
              (a = (a + Math.imul(le, Ee)) | 0),
              (b = (b + Math.imul(le, Ne)) | 0),
              (v = (v + Math.imul($, ke)) | 0),
              (a = (a + Math.imul($, $e)) | 0),
              (a = (a + Math.imul(Z, ke)) | 0),
              (b = (b + Math.imul(Z, $e)) | 0),
              (v = (v + Math.imul(G, Ie)) | 0),
              (a = (a + Math.imul(G, De)) | 0),
              (a = (a + Math.imul(Q, Ie)) | 0),
              (b = (b + Math.imul(Q, De)) | 0),
              (v = (v + Math.imul(C, xe)) | 0),
              (a = (a + Math.imul(C, Ue)) | 0),
              (a = (a + Math.imul(z, xe)) | 0),
              (b = (b + Math.imul(z, Ue)) | 0),
              (v = (v + Math.imul(B, Be)) | 0),
              (a = (a + Math.imul(B, ze)) | 0),
              (a = (a + Math.imul(F, Be)) | 0),
              (b = (b + Math.imul(F, ze)) | 0);
            var hr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (hr >>> 26)) | 0),
              (hr &= 67108863),
              (v = Math.imul(T, ie)),
              (a = Math.imul(T, ye)),
              (a = (a + Math.imul(x, ie)) | 0),
              (b = Math.imul(x, ye)),
              (v = (v + Math.imul(K, ve)) | 0),
              (a = (a + Math.imul(K, _e)) | 0),
              (a = (a + Math.imul(O, ve)) | 0),
              (b = (b + Math.imul(O, _e)) | 0),
              (v = (v + Math.imul(ce, Me)) | 0),
              (a = (a + Math.imul(ce, Ce)) | 0),
              (a = (a + Math.imul(he, Me)) | 0),
              (b = (b + Math.imul(he, Ce)) | 0),
              (v = (v + Math.imul(me, Ae)) | 0),
              (a = (a + Math.imul(me, Le)) | 0),
              (a = (a + Math.imul(re, Ae)) | 0),
              (b = (b + Math.imul(re, Le)) | 0),
              (v = (v + Math.imul(be, Ee)) | 0),
              (a = (a + Math.imul(be, Ne)) | 0),
              (a = (a + Math.imul(oe, Ee)) | 0),
              (b = (b + Math.imul(oe, Ne)) | 0),
              (v = (v + Math.imul(fe, ke)) | 0),
              (a = (a + Math.imul(fe, $e)) | 0),
              (a = (a + Math.imul(le, ke)) | 0),
              (b = (b + Math.imul(le, $e)) | 0),
              (v = (v + Math.imul($, Ie)) | 0),
              (a = (a + Math.imul($, De)) | 0),
              (a = (a + Math.imul(Z, Ie)) | 0),
              (b = (b + Math.imul(Z, De)) | 0),
              (v = (v + Math.imul(G, xe)) | 0),
              (a = (a + Math.imul(G, Ue)) | 0),
              (a = (a + Math.imul(Q, xe)) | 0),
              (b = (b + Math.imul(Q, Ue)) | 0),
              (v = (v + Math.imul(C, Be)) | 0),
              (a = (a + Math.imul(C, ze)) | 0),
              (a = (a + Math.imul(z, Be)) | 0),
              (b = (b + Math.imul(z, ze)) | 0);
            var dr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (dr >>> 26)) | 0),
              (dr &= 67108863),
              (v = Math.imul(T, ve)),
              (a = Math.imul(T, _e)),
              (a = (a + Math.imul(x, ve)) | 0),
              (b = Math.imul(x, _e)),
              (v = (v + Math.imul(K, Me)) | 0),
              (a = (a + Math.imul(K, Ce)) | 0),
              (a = (a + Math.imul(O, Me)) | 0),
              (b = (b + Math.imul(O, Ce)) | 0),
              (v = (v + Math.imul(ce, Ae)) | 0),
              (a = (a + Math.imul(ce, Le)) | 0),
              (a = (a + Math.imul(he, Ae)) | 0),
              (b = (b + Math.imul(he, Le)) | 0),
              (v = (v + Math.imul(me, Ee)) | 0),
              (a = (a + Math.imul(me, Ne)) | 0),
              (a = (a + Math.imul(re, Ee)) | 0),
              (b = (b + Math.imul(re, Ne)) | 0),
              (v = (v + Math.imul(be, ke)) | 0),
              (a = (a + Math.imul(be, $e)) | 0),
              (a = (a + Math.imul(oe, ke)) | 0),
              (b = (b + Math.imul(oe, $e)) | 0),
              (v = (v + Math.imul(fe, Ie)) | 0),
              (a = (a + Math.imul(fe, De)) | 0),
              (a = (a + Math.imul(le, Ie)) | 0),
              (b = (b + Math.imul(le, De)) | 0),
              (v = (v + Math.imul($, xe)) | 0),
              (a = (a + Math.imul($, Ue)) | 0),
              (a = (a + Math.imul(Z, xe)) | 0),
              (b = (b + Math.imul(Z, Ue)) | 0),
              (v = (v + Math.imul(G, Be)) | 0),
              (a = (a + Math.imul(G, ze)) | 0),
              (a = (a + Math.imul(Q, Be)) | 0),
              (b = (b + Math.imul(Q, ze)) | 0);
            var pr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (pr >>> 26)) | 0),
              (pr &= 67108863),
              (v = Math.imul(T, Me)),
              (a = Math.imul(T, Ce)),
              (a = (a + Math.imul(x, Me)) | 0),
              (b = Math.imul(x, Ce)),
              (v = (v + Math.imul(K, Ae)) | 0),
              (a = (a + Math.imul(K, Le)) | 0),
              (a = (a + Math.imul(O, Ae)) | 0),
              (b = (b + Math.imul(O, Le)) | 0),
              (v = (v + Math.imul(ce, Ee)) | 0),
              (a = (a + Math.imul(ce, Ne)) | 0),
              (a = (a + Math.imul(he, Ee)) | 0),
              (b = (b + Math.imul(he, Ne)) | 0),
              (v = (v + Math.imul(me, ke)) | 0),
              (a = (a + Math.imul(me, $e)) | 0),
              (a = (a + Math.imul(re, ke)) | 0),
              (b = (b + Math.imul(re, $e)) | 0),
              (v = (v + Math.imul(be, Ie)) | 0),
              (a = (a + Math.imul(be, De)) | 0),
              (a = (a + Math.imul(oe, Ie)) | 0),
              (b = (b + Math.imul(oe, De)) | 0),
              (v = (v + Math.imul(fe, xe)) | 0),
              (a = (a + Math.imul(fe, Ue)) | 0),
              (a = (a + Math.imul(le, xe)) | 0),
              (b = (b + Math.imul(le, Ue)) | 0),
              (v = (v + Math.imul($, Be)) | 0),
              (a = (a + Math.imul($, ze)) | 0),
              (a = (a + Math.imul(Z, Be)) | 0),
              (b = (b + Math.imul(Z, ze)) | 0);
            var yr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (yr >>> 26)) | 0),
              (yr &= 67108863),
              (v = Math.imul(T, Ae)),
              (a = Math.imul(T, Le)),
              (a = (a + Math.imul(x, Ae)) | 0),
              (b = Math.imul(x, Le)),
              (v = (v + Math.imul(K, Ee)) | 0),
              (a = (a + Math.imul(K, Ne)) | 0),
              (a = (a + Math.imul(O, Ee)) | 0),
              (b = (b + Math.imul(O, Ne)) | 0),
              (v = (v + Math.imul(ce, ke)) | 0),
              (a = (a + Math.imul(ce, $e)) | 0),
              (a = (a + Math.imul(he, ke)) | 0),
              (b = (b + Math.imul(he, $e)) | 0),
              (v = (v + Math.imul(me, Ie)) | 0),
              (a = (a + Math.imul(me, De)) | 0),
              (a = (a + Math.imul(re, Ie)) | 0),
              (b = (b + Math.imul(re, De)) | 0),
              (v = (v + Math.imul(be, xe)) | 0),
              (a = (a + Math.imul(be, Ue)) | 0),
              (a = (a + Math.imul(oe, xe)) | 0),
              (b = (b + Math.imul(oe, Ue)) | 0),
              (v = (v + Math.imul(fe, Be)) | 0),
              (a = (a + Math.imul(fe, ze)) | 0),
              (a = (a + Math.imul(le, Be)) | 0),
              (b = (b + Math.imul(le, ze)) | 0);
            var gr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (gr >>> 26)) | 0),
              (gr &= 67108863),
              (v = Math.imul(T, Ee)),
              (a = Math.imul(T, Ne)),
              (a = (a + Math.imul(x, Ee)) | 0),
              (b = Math.imul(x, Ne)),
              (v = (v + Math.imul(K, ke)) | 0),
              (a = (a + Math.imul(K, $e)) | 0),
              (a = (a + Math.imul(O, ke)) | 0),
              (b = (b + Math.imul(O, $e)) | 0),
              (v = (v + Math.imul(ce, Ie)) | 0),
              (a = (a + Math.imul(ce, De)) | 0),
              (a = (a + Math.imul(he, Ie)) | 0),
              (b = (b + Math.imul(he, De)) | 0),
              (v = (v + Math.imul(me, xe)) | 0),
              (a = (a + Math.imul(me, Ue)) | 0),
              (a = (a + Math.imul(re, xe)) | 0),
              (b = (b + Math.imul(re, Ue)) | 0),
              (v = (v + Math.imul(be, Be)) | 0),
              (a = (a + Math.imul(be, ze)) | 0),
              (a = (a + Math.imul(oe, Be)) | 0),
              (b = (b + Math.imul(oe, ze)) | 0);
            var br = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (br >>> 26)) | 0),
              (br &= 67108863),
              (v = Math.imul(T, ke)),
              (a = Math.imul(T, $e)),
              (a = (a + Math.imul(x, ke)) | 0),
              (b = Math.imul(x, $e)),
              (v = (v + Math.imul(K, Ie)) | 0),
              (a = (a + Math.imul(K, De)) | 0),
              (a = (a + Math.imul(O, Ie)) | 0),
              (b = (b + Math.imul(O, De)) | 0),
              (v = (v + Math.imul(ce, xe)) | 0),
              (a = (a + Math.imul(ce, Ue)) | 0),
              (a = (a + Math.imul(he, xe)) | 0),
              (b = (b + Math.imul(he, Ue)) | 0),
              (v = (v + Math.imul(me, Be)) | 0),
              (a = (a + Math.imul(me, ze)) | 0),
              (a = (a + Math.imul(re, Be)) | 0),
              (b = (b + Math.imul(re, ze)) | 0);
            var vr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (vr >>> 26)) | 0),
              (vr &= 67108863),
              (v = Math.imul(T, Ie)),
              (a = Math.imul(T, De)),
              (a = (a + Math.imul(x, Ie)) | 0),
              (b = Math.imul(x, De)),
              (v = (v + Math.imul(K, xe)) | 0),
              (a = (a + Math.imul(K, Ue)) | 0),
              (a = (a + Math.imul(O, xe)) | 0),
              (b = (b + Math.imul(O, Ue)) | 0),
              (v = (v + Math.imul(ce, Be)) | 0),
              (a = (a + Math.imul(ce, ze)) | 0),
              (a = (a + Math.imul(he, Be)) | 0),
              (b = (b + Math.imul(he, ze)) | 0);
            var mr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (mr >>> 26)) | 0),
              (mr &= 67108863),
              (v = Math.imul(T, xe)),
              (a = Math.imul(T, Ue)),
              (a = (a + Math.imul(x, xe)) | 0),
              (b = Math.imul(x, Ue)),
              (v = (v + Math.imul(K, Be)) | 0),
              (a = (a + Math.imul(K, ze)) | 0),
              (a = (a + Math.imul(O, Be)) | 0),
              (b = (b + Math.imul(O, ze)) | 0);
            var wr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (wr >>> 26)) | 0),
              (wr &= 67108863),
              (v = Math.imul(T, Be)),
              (a = Math.imul(T, ze)),
              (a = (a + Math.imul(x, Be)) | 0),
              (b = Math.imul(x, ze));
            var _r = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            return (
              (M = (((b + (a >>> 13)) | 0) + (_r >>> 26)) | 0),
              (_r &= 67108863),
              (w[0] = st),
              (w[1] = at),
              (w[2] = Ft),
              (w[3] = qt),
              (w[4] = Wt),
              (w[5] = Kt),
              (w[6] = jt),
              (w[7] = fr),
              (w[8] = lr),
              (w[9] = hr),
              (w[10] = dr),
              (w[11] = pr),
              (w[12] = yr),
              (w[13] = gr),
              (w[14] = br),
              (w[15] = vr),
              (w[16] = mr),
              (w[17] = wr),
              (w[18] = _r),
              M !== 0 && ((w[19] = M), l.length++),
              l
            );
          };
          Math.imul || (I = E);
          function R(S, o, u) {
            (u.negative = o.negative ^ S.negative), (u.length = S.length + o.length);
            for (var l = 0, d = 0, g = 0; g < u.length - 1; g++) {
              var w = d;
              d = 0;
              for (
                var M = l & 67108863,
                  v = Math.min(g, o.length - 1),
                  a = Math.max(0, g - S.length + 1);
                a <= v;
                a++
              ) {
                var b = g - a,
                  k = S.words[b] | 0,
                  B = o.words[a] | 0,
                  F = k * B,
                  P = F & 67108863;
                (w = (w + ((F / 67108864) | 0)) | 0),
                  (P = (P + M) | 0),
                  (M = P & 67108863),
                  (w = (w + (P >>> 26)) | 0),
                  (d += w >>> 26),
                  (w &= 67108863);
              }
              (u.words[g] = M), (l = w), (w = d);
            }
            return l !== 0 ? (u.words[g] = l) : u.length--, u.strip();
          }
          function L(S, o, u) {
            var l = new D();
            return l.mulp(S, o, u);
          }
          n.prototype.mulTo = function (o, u) {
            var l,
              d = this.length + o.length;
            return (
              this.length === 10 && o.length === 10
                ? (l = I(this, o, u))
                : d < 63
                  ? (l = E(this, o, u))
                  : d < 1024
                    ? (l = R(this, o, u))
                    : (l = L(this, o, u)),
              l
            );
          };
          function D(S, o) {
            (this.x = S), (this.y = o);
          }
          (D.prototype.makeRBT = function (o) {
            for (var u = new Array(o), l = n.prototype._countBits(o) - 1, d = 0; d < o; d++)
              u[d] = this.revBin(d, l, o);
            return u;
          }),
            (D.prototype.revBin = function (o, u, l) {
              if (o === 0 || o === l - 1) return o;
              for (var d = 0, g = 0; g < u; g++) (d |= (o & 1) << (u - g - 1)), (o >>= 1);
              return d;
            }),
            (D.prototype.permute = function (o, u, l, d, g, w) {
              for (var M = 0; M < w; M++) (d[M] = u[o[M]]), (g[M] = l[o[M]]);
            }),
            (D.prototype.transform = function (o, u, l, d, g, w) {
              this.permute(w, o, u, l, d, g);
              for (var M = 1; M < g; M <<= 1)
                for (
                  var v = M << 1,
                    a = Math.cos((2 * Math.PI) / v),
                    b = Math.sin((2 * Math.PI) / v),
                    k = 0;
                  k < g;
                  k += v
                )
                  for (var B = a, F = b, P = 0; P < M; P++) {
                    var C = l[k + P],
                      z = d[k + P],
                      Y = l[k + P + M],
                      G = d[k + P + M],
                      Q = B * Y - F * G;
                    (G = B * G + F * Y),
                      (Y = Q),
                      (l[k + P] = C + Y),
                      (d[k + P] = z + G),
                      (l[k + P + M] = C - Y),
                      (d[k + P + M] = z - G),
                      P !== v && ((Q = a * B - b * F), (F = a * F + b * B), (B = Q));
                  }
            }),
            (D.prototype.guessLen13b = function (o, u) {
              var l = Math.max(u, o) | 1,
                d = l & 1,
                g = 0;
              for (l = (l / 2) | 0; l; l = l >>> 1) g++;
              return 1 << (g + 1 + d);
            }),
            (D.prototype.conjugate = function (o, u, l) {
              if (!(l <= 1))
                for (var d = 0; d < l / 2; d++) {
                  var g = o[d];
                  (o[d] = o[l - d - 1]),
                    (o[l - d - 1] = g),
                    (g = u[d]),
                    (u[d] = -u[l - d - 1]),
                    (u[l - d - 1] = -g);
                }
            }),
            (D.prototype.normalize13b = function (o, u) {
              for (var l = 0, d = 0; d < u / 2; d++) {
                var g = Math.round(o[2 * d + 1] / u) * 8192 + Math.round(o[2 * d] / u) + l;
                (o[d] = g & 67108863), g < 67108864 ? (l = 0) : (l = (g / 67108864) | 0);
              }
              return o;
            }),
            (D.prototype.convert13b = function (o, u, l, d) {
              for (var g = 0, w = 0; w < u; w++)
                (g = g + (o[w] | 0)),
                  (l[2 * w] = g & 8191),
                  (g = g >>> 13),
                  (l[2 * w + 1] = g & 8191),
                  (g = g >>> 13);
              for (w = 2 * u; w < d; ++w) l[w] = 0;
              r(g === 0), r((g & -8192) === 0);
            }),
            (D.prototype.stub = function (o) {
              for (var u = new Array(o), l = 0; l < o; l++) u[l] = 0;
              return u;
            }),
            (D.prototype.mulp = function (o, u, l) {
              var d = 2 * this.guessLen13b(o.length, u.length),
                g = this.makeRBT(d),
                w = this.stub(d),
                M = new Array(d),
                v = new Array(d),
                a = new Array(d),
                b = new Array(d),
                k = new Array(d),
                B = new Array(d),
                F = l.words;
              (F.length = d),
                this.convert13b(o.words, o.length, M, d),
                this.convert13b(u.words, u.length, b, d),
                this.transform(M, w, v, a, d, g),
                this.transform(b, w, k, B, d, g);
              for (var P = 0; P < d; P++) {
                var C = v[P] * k[P] - a[P] * B[P];
                (a[P] = v[P] * B[P] + a[P] * k[P]), (v[P] = C);
              }
              return (
                this.conjugate(v, a, d),
                this.transform(v, a, F, w, d, g),
                this.conjugate(F, w, d),
                this.normalize13b(F, d),
                (l.negative = o.negative ^ u.negative),
                (l.length = o.length + u.length),
                l.strip()
              );
            }),
            (n.prototype.mul = function (o) {
              var u = new n(null);
              return (u.words = new Array(this.length + o.length)), this.mulTo(o, u);
            }),
            (n.prototype.mulf = function (o) {
              var u = new n(null);
              return (u.words = new Array(this.length + o.length)), L(this, o, u);
            }),
            (n.prototype.imul = function (o) {
              return this.clone().mulTo(o, this);
            }),
            (n.prototype.imuln = function (o) {
              r(typeof o == 'number'), r(o < 67108864);
              for (var u = 0, l = 0; l < this.length; l++) {
                var d = (this.words[l] | 0) * o,
                  g = (d & 67108863) + (u & 67108863);
                (u >>= 26),
                  (u += (d / 67108864) | 0),
                  (u += g >>> 26),
                  (this.words[l] = g & 67108863);
              }
              return u !== 0 && ((this.words[l] = u), this.length++), this;
            }),
            (n.prototype.muln = function (o) {
              return this.clone().imuln(o);
            }),
            (n.prototype.sqr = function () {
              return this.mul(this);
            }),
            (n.prototype.isqr = function () {
              return this.imul(this.clone());
            }),
            (n.prototype.pow = function (o) {
              var u = A(o);
              if (u.length === 0) return new n(1);
              for (var l = this, d = 0; d < u.length && u[d] === 0; d++, l = l.sqr());
              if (++d < u.length)
                for (var g = l.sqr(); d < u.length; d++, g = g.sqr()) u[d] !== 0 && (l = l.mul(g));
              return l;
            }),
            (n.prototype.iushln = function (o) {
              r(typeof o == 'number' && o >= 0);
              var u = o % 26,
                l = (o - u) / 26,
                d = (67108863 >>> (26 - u)) << (26 - u),
                g;
              if (u !== 0) {
                var w = 0;
                for (g = 0; g < this.length; g++) {
                  var M = this.words[g] & d,
                    v = ((this.words[g] | 0) - M) << u;
                  (this.words[g] = v | w), (w = M >>> (26 - u));
                }
                w && ((this.words[g] = w), this.length++);
              }
              if (l !== 0) {
                for (g = this.length - 1; g >= 0; g--) this.words[g + l] = this.words[g];
                for (g = 0; g < l; g++) this.words[g] = 0;
                this.length += l;
              }
              return this.strip();
            }),
            (n.prototype.ishln = function (o) {
              return r(this.negative === 0), this.iushln(o);
            }),
            (n.prototype.iushrn = function (o, u, l) {
              r(typeof o == 'number' && o >= 0);
              var d;
              u ? (d = (u - (u % 26)) / 26) : (d = 0);
              var g = o % 26,
                w = Math.min((o - g) / 26, this.length),
                M = 67108863 ^ ((67108863 >>> g) << g),
                v = l;
              if (((d -= w), (d = Math.max(0, d)), v)) {
                for (var a = 0; a < w; a++) v.words[a] = this.words[a];
                v.length = w;
              }
              if (w !== 0)
                if (this.length > w)
                  for (this.length -= w, a = 0; a < this.length; a++)
                    this.words[a] = this.words[a + w];
                else (this.words[0] = 0), (this.length = 1);
              var b = 0;
              for (a = this.length - 1; a >= 0 && (b !== 0 || a >= d); a--) {
                var k = this.words[a] | 0;
                (this.words[a] = (b << (26 - g)) | (k >>> g)), (b = k & M);
              }
              return (
                v && b !== 0 && (v.words[v.length++] = b),
                this.length === 0 && ((this.words[0] = 0), (this.length = 1)),
                this.strip()
              );
            }),
            (n.prototype.ishrn = function (o, u, l) {
              return r(this.negative === 0), this.iushrn(o, u, l);
            }),
            (n.prototype.shln = function (o) {
              return this.clone().ishln(o);
            }),
            (n.prototype.ushln = function (o) {
              return this.clone().iushln(o);
            }),
            (n.prototype.shrn = function (o) {
              return this.clone().ishrn(o);
            }),
            (n.prototype.ushrn = function (o) {
              return this.clone().iushrn(o);
            }),
            (n.prototype.testn = function (o) {
              r(typeof o == 'number' && o >= 0);
              var u = o % 26,
                l = (o - u) / 26,
                d = 1 << u;
              if (this.length <= l) return !1;
              var g = this.words[l];
              return !!(g & d);
            }),
            (n.prototype.imaskn = function (o) {
              r(typeof o == 'number' && o >= 0);
              var u = o % 26,
                l = (o - u) / 26;
              if (
                (r(this.negative === 0, 'imaskn works only with positive numbers'),
                this.length <= l)
              )
                return this;
              if ((u !== 0 && l++, (this.length = Math.min(l, this.length)), u !== 0)) {
                var d = 67108863 ^ ((67108863 >>> u) << u);
                this.words[this.length - 1] &= d;
              }
              return this.strip();
            }),
            (n.prototype.maskn = function (o) {
              return this.clone().imaskn(o);
            }),
            (n.prototype.iaddn = function (o) {
              return (
                r(typeof o == 'number'),
                r(o < 67108864),
                o < 0
                  ? this.isubn(-o)
                  : this.negative !== 0
                    ? this.length === 1 && (this.words[0] | 0) < o
                      ? ((this.words[0] = o - (this.words[0] | 0)), (this.negative = 0), this)
                      : ((this.negative = 0), this.isubn(o), (this.negative = 1), this)
                    : this._iaddn(o)
              );
            }),
            (n.prototype._iaddn = function (o) {
              this.words[0] += o;
              for (var u = 0; u < this.length && this.words[u] >= 67108864; u++)
                (this.words[u] -= 67108864),
                  u === this.length - 1 ? (this.words[u + 1] = 1) : this.words[u + 1]++;
              return (this.length = Math.max(this.length, u + 1)), this;
            }),
            (n.prototype.isubn = function (o) {
              if ((r(typeof o == 'number'), r(o < 67108864), o < 0)) return this.iaddn(-o);
              if (this.negative !== 0)
                return (this.negative = 0), this.iaddn(o), (this.negative = 1), this;
              if (((this.words[0] -= o), this.length === 1 && this.words[0] < 0))
                (this.words[0] = -this.words[0]), (this.negative = 1);
              else
                for (var u = 0; u < this.length && this.words[u] < 0; u++)
                  (this.words[u] += 67108864), (this.words[u + 1] -= 1);
              return this.strip();
            }),
            (n.prototype.addn = function (o) {
              return this.clone().iaddn(o);
            }),
            (n.prototype.subn = function (o) {
              return this.clone().isubn(o);
            }),
            (n.prototype.iabs = function () {
              return (this.negative = 0), this;
            }),
            (n.prototype.abs = function () {
              return this.clone().iabs();
            }),
            (n.prototype._ishlnsubmul = function (o, u, l) {
              var d = o.length + l,
                g;
              this._expand(d);
              var w,
                M = 0;
              for (g = 0; g < o.length; g++) {
                w = (this.words[g + l] | 0) + M;
                var v = (o.words[g] | 0) * u;
                (w -= v & 67108863),
                  (M = (w >> 26) - ((v / 67108864) | 0)),
                  (this.words[g + l] = w & 67108863);
              }
              for (; g < this.length - l; g++)
                (w = (this.words[g + l] | 0) + M),
                  (M = w >> 26),
                  (this.words[g + l] = w & 67108863);
              if (M === 0) return this.strip();
              for (r(M === -1), M = 0, g = 0; g < this.length; g++)
                (w = -(this.words[g] | 0) + M), (M = w >> 26), (this.words[g] = w & 67108863);
              return (this.negative = 1), this.strip();
            }),
            (n.prototype._wordDiv = function (o, u) {
              var l = this.length - o.length,
                d = this.clone(),
                g = o,
                w = g.words[g.length - 1] | 0,
                M = this._countBits(w);
              (l = 26 - M),
                l !== 0 && ((g = g.ushln(l)), d.iushln(l), (w = g.words[g.length - 1] | 0));
              var v = d.length - g.length,
                a;
              if (u !== 'mod') {
                (a = new n(null)), (a.length = v + 1), (a.words = new Array(a.length));
                for (var b = 0; b < a.length; b++) a.words[b] = 0;
              }
              var k = d.clone()._ishlnsubmul(g, 1, v);
              k.negative === 0 && ((d = k), a && (a.words[v] = 1));
              for (var B = v - 1; B >= 0; B--) {
                var F = (d.words[g.length + B] | 0) * 67108864 + (d.words[g.length + B - 1] | 0);
                for (
                  F = Math.min((F / w) | 0, 67108863), d._ishlnsubmul(g, F, B);
                  d.negative !== 0;

                )
                  F--, (d.negative = 0), d._ishlnsubmul(g, 1, B), d.isZero() || (d.negative ^= 1);
                a && (a.words[B] = F);
              }
              return (
                a && a.strip(),
                d.strip(),
                u !== 'div' && l !== 0 && d.iushrn(l),
                { div: a || null, mod: d }
              );
            }),
            (n.prototype.divmod = function (o, u, l) {
              if ((r(!o.isZero()), this.isZero())) return { div: new n(0), mod: new n(0) };
              var d, g, w;
              return this.negative !== 0 && o.negative === 0
                ? ((w = this.neg().divmod(o, u)),
                  u !== 'mod' && (d = w.div.neg()),
                  u !== 'div' && ((g = w.mod.neg()), l && g.negative !== 0 && g.iadd(o)),
                  { div: d, mod: g })
                : this.negative === 0 && o.negative !== 0
                  ? ((w = this.divmod(o.neg(), u)),
                    u !== 'mod' && (d = w.div.neg()),
                    { div: d, mod: w.mod })
                  : this.negative & o.negative
                    ? ((w = this.neg().divmod(o.neg(), u)),
                      u !== 'div' && ((g = w.mod.neg()), l && g.negative !== 0 && g.isub(o)),
                      { div: w.div, mod: g })
                    : o.length > this.length || this.cmp(o) < 0
                      ? { div: new n(0), mod: this }
                      : o.length === 1
                        ? u === 'div'
                          ? { div: this.divn(o.words[0]), mod: null }
                          : u === 'mod'
                            ? { div: null, mod: new n(this.modn(o.words[0])) }
                            : { div: this.divn(o.words[0]), mod: new n(this.modn(o.words[0])) }
                        : this._wordDiv(o, u);
            }),
            (n.prototype.div = function (o) {
              return this.divmod(o, 'div', !1).div;
            }),
            (n.prototype.mod = function (o) {
              return this.divmod(o, 'mod', !1).mod;
            }),
            (n.prototype.umod = function (o) {
              return this.divmod(o, 'mod', !0).mod;
            }),
            (n.prototype.divRound = function (o) {
              var u = this.divmod(o);
              if (u.mod.isZero()) return u.div;
              var l = u.div.negative !== 0 ? u.mod.isub(o) : u.mod,
                d = o.ushrn(1),
                g = o.andln(1),
                w = l.cmp(d);
              return w < 0 || (g === 1 && w === 0)
                ? u.div
                : u.div.negative !== 0
                  ? u.div.isubn(1)
                  : u.div.iaddn(1);
            }),
            (n.prototype.modn = function (o) {
              r(o <= 67108863);
              for (var u = (1 << 26) % o, l = 0, d = this.length - 1; d >= 0; d--)
                l = (u * l + (this.words[d] | 0)) % o;
              return l;
            }),
            (n.prototype.idivn = function (o) {
              r(o <= 67108863);
              for (var u = 0, l = this.length - 1; l >= 0; l--) {
                var d = (this.words[l] | 0) + u * 67108864;
                (this.words[l] = (d / o) | 0), (u = d % o);
              }
              return this.strip();
            }),
            (n.prototype.divn = function (o) {
              return this.clone().idivn(o);
            }),
            (n.prototype.egcd = function (o) {
              r(o.negative === 0), r(!o.isZero());
              var u = this,
                l = o.clone();
              u.negative !== 0 ? (u = u.umod(o)) : (u = u.clone());
              for (
                var d = new n(1), g = new n(0), w = new n(0), M = new n(1), v = 0;
                u.isEven() && l.isEven();

              )
                u.iushrn(1), l.iushrn(1), ++v;
              for (var a = l.clone(), b = u.clone(); !u.isZero(); ) {
                for (var k = 0, B = 1; !(u.words[0] & B) && k < 26; ++k, B <<= 1);
                if (k > 0)
                  for (u.iushrn(k); k-- > 0; )
                    (d.isOdd() || g.isOdd()) && (d.iadd(a), g.isub(b)), d.iushrn(1), g.iushrn(1);
                for (var F = 0, P = 1; !(l.words[0] & P) && F < 26; ++F, P <<= 1);
                if (F > 0)
                  for (l.iushrn(F); F-- > 0; )
                    (w.isOdd() || M.isOdd()) && (w.iadd(a), M.isub(b)), w.iushrn(1), M.iushrn(1);
                u.cmp(l) >= 0
                  ? (u.isub(l), d.isub(w), g.isub(M))
                  : (l.isub(u), w.isub(d), M.isub(g));
              }
              return { a: w, b: M, gcd: l.iushln(v) };
            }),
            (n.prototype._invmp = function (o) {
              r(o.negative === 0), r(!o.isZero());
              var u = this,
                l = o.clone();
              u.negative !== 0 ? (u = u.umod(o)) : (u = u.clone());
              for (
                var d = new n(1), g = new n(0), w = l.clone();
                u.cmpn(1) > 0 && l.cmpn(1) > 0;

              ) {
                for (var M = 0, v = 1; !(u.words[0] & v) && M < 26; ++M, v <<= 1);
                if (M > 0) for (u.iushrn(M); M-- > 0; ) d.isOdd() && d.iadd(w), d.iushrn(1);
                for (var a = 0, b = 1; !(l.words[0] & b) && a < 26; ++a, b <<= 1);
                if (a > 0) for (l.iushrn(a); a-- > 0; ) g.isOdd() && g.iadd(w), g.iushrn(1);
                u.cmp(l) >= 0 ? (u.isub(l), d.isub(g)) : (l.isub(u), g.isub(d));
              }
              var k;
              return u.cmpn(1) === 0 ? (k = d) : (k = g), k.cmpn(0) < 0 && k.iadd(o), k;
            }),
            (n.prototype.gcd = function (o) {
              if (this.isZero()) return o.abs();
              if (o.isZero()) return this.abs();
              var u = this.clone(),
                l = o.clone();
              (u.negative = 0), (l.negative = 0);
              for (var d = 0; u.isEven() && l.isEven(); d++) u.iushrn(1), l.iushrn(1);
              do {
                for (; u.isEven(); ) u.iushrn(1);
                for (; l.isEven(); ) l.iushrn(1);
                var g = u.cmp(l);
                if (g < 0) {
                  var w = u;
                  (u = l), (l = w);
                } else if (g === 0 || l.cmpn(1) === 0) break;
                u.isub(l);
              } while (!0);
              return l.iushln(d);
            }),
            (n.prototype.invm = function (o) {
              return this.egcd(o).a.umod(o);
            }),
            (n.prototype.isEven = function () {
              return (this.words[0] & 1) === 0;
            }),
            (n.prototype.isOdd = function () {
              return (this.words[0] & 1) === 1;
            }),
            (n.prototype.andln = function (o) {
              return this.words[0] & o;
            }),
            (n.prototype.bincn = function (o) {
              r(typeof o == 'number');
              var u = o % 26,
                l = (o - u) / 26,
                d = 1 << u;
              if (this.length <= l) return this._expand(l + 1), (this.words[l] |= d), this;
              for (var g = d, w = l; g !== 0 && w < this.length; w++) {
                var M = this.words[w] | 0;
                (M += g), (g = M >>> 26), (M &= 67108863), (this.words[w] = M);
              }
              return g !== 0 && ((this.words[w] = g), this.length++), this;
            }),
            (n.prototype.isZero = function () {
              return this.length === 1 && this.words[0] === 0;
            }),
            (n.prototype.cmpn = function (o) {
              var u = o < 0;
              if (this.negative !== 0 && !u) return -1;
              if (this.negative === 0 && u) return 1;
              this.strip();
              var l;
              if (this.length > 1) l = 1;
              else {
                u && (o = -o), r(o <= 67108863, 'Number is too big');
                var d = this.words[0] | 0;
                l = d === o ? 0 : d < o ? -1 : 1;
              }
              return this.negative !== 0 ? -l | 0 : l;
            }),
            (n.prototype.cmp = function (o) {
              if (this.negative !== 0 && o.negative === 0) return -1;
              if (this.negative === 0 && o.negative !== 0) return 1;
              var u = this.ucmp(o);
              return this.negative !== 0 ? -u | 0 : u;
            }),
            (n.prototype.ucmp = function (o) {
              if (this.length > o.length) return 1;
              if (this.length < o.length) return -1;
              for (var u = 0, l = this.length - 1; l >= 0; l--) {
                var d = this.words[l] | 0,
                  g = o.words[l] | 0;
                if (d !== g) {
                  d < g ? (u = -1) : d > g && (u = 1);
                  break;
                }
              }
              return u;
            }),
            (n.prototype.gtn = function (o) {
              return this.cmpn(o) === 1;
            }),
            (n.prototype.gt = function (o) {
              return this.cmp(o) === 1;
            }),
            (n.prototype.gten = function (o) {
              return this.cmpn(o) >= 0;
            }),
            (n.prototype.gte = function (o) {
              return this.cmp(o) >= 0;
            }),
            (n.prototype.ltn = function (o) {
              return this.cmpn(o) === -1;
            }),
            (n.prototype.lt = function (o) {
              return this.cmp(o) === -1;
            }),
            (n.prototype.lten = function (o) {
              return this.cmpn(o) <= 0;
            }),
            (n.prototype.lte = function (o) {
              return this.cmp(o) <= 0;
            }),
            (n.prototype.eqn = function (o) {
              return this.cmpn(o) === 0;
            }),
            (n.prototype.eq = function (o) {
              return this.cmp(o) === 0;
            }),
            (n.red = function (o) {
              return new X(o);
            }),
            (n.prototype.toRed = function (o) {
              return (
                r(!this.red, 'Already a number in reduction context'),
                r(this.negative === 0, 'red works only with positives'),
                o.convertTo(this)._forceRed(o)
              );
            }),
            (n.prototype.fromRed = function () {
              return (
                r(this.red, 'fromRed works only with numbers in reduction context'),
                this.red.convertFrom(this)
              );
            }),
            (n.prototype._forceRed = function (o) {
              return (this.red = o), this;
            }),
            (n.prototype.forceRed = function (o) {
              return r(!this.red, 'Already a number in reduction context'), this._forceRed(o);
            }),
            (n.prototype.redAdd = function (o) {
              return r(this.red, 'redAdd works only with red numbers'), this.red.add(this, o);
            }),
            (n.prototype.redIAdd = function (o) {
              return r(this.red, 'redIAdd works only with red numbers'), this.red.iadd(this, o);
            }),
            (n.prototype.redSub = function (o) {
              return r(this.red, 'redSub works only with red numbers'), this.red.sub(this, o);
            }),
            (n.prototype.redISub = function (o) {
              return r(this.red, 'redISub works only with red numbers'), this.red.isub(this, o);
            }),
            (n.prototype.redShl = function (o) {
              return r(this.red, 'redShl works only with red numbers'), this.red.shl(this, o);
            }),
            (n.prototype.redMul = function (o) {
              return (
                r(this.red, 'redMul works only with red numbers'),
                this.red._verify2(this, o),
                this.red.mul(this, o)
              );
            }),
            (n.prototype.redIMul = function (o) {
              return (
                r(this.red, 'redMul works only with red numbers'),
                this.red._verify2(this, o),
                this.red.imul(this, o)
              );
            }),
            (n.prototype.redSqr = function () {
              return (
                r(this.red, 'redSqr works only with red numbers'),
                this.red._verify1(this),
                this.red.sqr(this)
              );
            }),
            (n.prototype.redISqr = function () {
              return (
                r(this.red, 'redISqr works only with red numbers'),
                this.red._verify1(this),
                this.red.isqr(this)
              );
            }),
            (n.prototype.redSqrt = function () {
              return (
                r(this.red, 'redSqrt works only with red numbers'),
                this.red._verify1(this),
                this.red.sqrt(this)
              );
            }),
            (n.prototype.redInvm = function () {
              return (
                r(this.red, 'redInvm works only with red numbers'),
                this.red._verify1(this),
                this.red.invm(this)
              );
            }),
            (n.prototype.redNeg = function () {
              return (
                r(this.red, 'redNeg works only with red numbers'),
                this.red._verify1(this),
                this.red.neg(this)
              );
            }),
            (n.prototype.redPow = function (o) {
              return (
                r(this.red && !o.red, 'redPow(normalNum)'),
                this.red._verify1(this),
                this.red.pow(this, o)
              );
            });
          var q = { k256: null, p224: null, p192: null, p25519: null };
          function H(S, o) {
            (this.name = S),
              (this.p = new n(o, 16)),
              (this.n = this.p.bitLength()),
              (this.k = new n(1).iushln(this.n).isub(this.p)),
              (this.tmp = this._tmp());
          }
          (H.prototype._tmp = function () {
            var o = new n(null);
            return (o.words = new Array(Math.ceil(this.n / 13))), o;
          }),
            (H.prototype.ireduce = function (o) {
              var u = o,
                l;
              do
                this.split(u, this.tmp),
                  (u = this.imulK(u)),
                  (u = u.iadd(this.tmp)),
                  (l = u.bitLength());
              while (l > this.n);
              var d = l < this.n ? -1 : u.ucmp(this.p);
              return (
                d === 0
                  ? ((u.words[0] = 0), (u.length = 1))
                  : d > 0
                    ? u.isub(this.p)
                    : u.strip !== void 0
                      ? u.strip()
                      : u._strip(),
                u
              );
            }),
            (H.prototype.split = function (o, u) {
              o.iushrn(this.n, 0, u);
            }),
            (H.prototype.imulK = function (o) {
              return o.imul(this.k);
            });
          function V() {
            H.call(
              this,
              'k256',
              'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f'
            );
          }
          s(V, H),
            (V.prototype.split = function (o, u) {
              for (var l = 4194303, d = Math.min(o.length, 9), g = 0; g < d; g++)
                u.words[g] = o.words[g];
              if (((u.length = d), o.length <= 9)) {
                (o.words[0] = 0), (o.length = 1);
                return;
              }
              var w = o.words[9];
              for (u.words[u.length++] = w & l, g = 10; g < o.length; g++) {
                var M = o.words[g] | 0;
                (o.words[g - 10] = ((M & l) << 4) | (w >>> 22)), (w = M);
              }
              (w >>>= 22),
                (o.words[g - 10] = w),
                w === 0 && o.length > 10 ? (o.length -= 10) : (o.length -= 9);
            }),
            (V.prototype.imulK = function (o) {
              (o.words[o.length] = 0), (o.words[o.length + 1] = 0), (o.length += 2);
              for (var u = 0, l = 0; l < o.length; l++) {
                var d = o.words[l] | 0;
                (u += d * 977), (o.words[l] = u & 67108863), (u = d * 64 + ((u / 67108864) | 0));
              }
              return (
                o.words[o.length - 1] === 0 &&
                  (o.length--, o.words[o.length - 1] === 0 && o.length--),
                o
              );
            });
          function te() {
            H.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
          }
          s(te, H);
          function ue() {
            H.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
          }
          s(ue, H);
          function ne() {
            H.call(
              this,
              '25519',
              '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed'
            );
          }
          s(ne, H),
            (ne.prototype.imulK = function (o) {
              for (var u = 0, l = 0; l < o.length; l++) {
                var d = (o.words[l] | 0) * 19 + u,
                  g = d & 67108863;
                (d >>>= 26), (o.words[l] = g), (u = d);
              }
              return u !== 0 && (o.words[o.length++] = u), o;
            }),
            (n._prime = function (o) {
              if (q[o]) return q[o];
              var u;
              if (o === 'k256') u = new V();
              else if (o === 'p224') u = new te();
              else if (o === 'p192') u = new ue();
              else if (o === 'p25519') u = new ne();
              else throw new Error('Unknown prime ' + o);
              return (q[o] = u), u;
            });
          function X(S) {
            if (typeof S == 'string') {
              var o = n._prime(S);
              (this.m = o.p), (this.prime = o);
            } else r(S.gtn(1), 'modulus must be greater than 1'), (this.m = S), (this.prime = null);
          }
          (X.prototype._verify1 = function (o) {
            r(o.negative === 0, 'red works only with positives'),
              r(o.red, 'red works only with red numbers');
          }),
            (X.prototype._verify2 = function (o, u) {
              r((o.negative | u.negative) === 0, 'red works only with positives'),
                r(o.red && o.red === u.red, 'red works only with red numbers');
            }),
            (X.prototype.imod = function (o) {
              return this.prime
                ? this.prime.ireduce(o)._forceRed(this)
                : o.umod(this.m)._forceRed(this);
            }),
            (X.prototype.neg = function (o) {
              return o.isZero() ? o.clone() : this.m.sub(o)._forceRed(this);
            }),
            (X.prototype.add = function (o, u) {
              this._verify2(o, u);
              var l = o.add(u);
              return l.cmp(this.m) >= 0 && l.isub(this.m), l._forceRed(this);
            }),
            (X.prototype.iadd = function (o, u) {
              this._verify2(o, u);
              var l = o.iadd(u);
              return l.cmp(this.m) >= 0 && l.isub(this.m), l;
            }),
            (X.prototype.sub = function (o, u) {
              this._verify2(o, u);
              var l = o.sub(u);
              return l.cmpn(0) < 0 && l.iadd(this.m), l._forceRed(this);
            }),
            (X.prototype.isub = function (o, u) {
              this._verify2(o, u);
              var l = o.isub(u);
              return l.cmpn(0) < 0 && l.iadd(this.m), l;
            }),
            (X.prototype.shl = function (o, u) {
              return this._verify1(o), this.imod(o.ushln(u));
            }),
            (X.prototype.imul = function (o, u) {
              return this._verify2(o, u), this.imod(o.imul(u));
            }),
            (X.prototype.mul = function (o, u) {
              return this._verify2(o, u), this.imod(o.mul(u));
            }),
            (X.prototype.isqr = function (o) {
              return this.imul(o, o.clone());
            }),
            (X.prototype.sqr = function (o) {
              return this.mul(o, o);
            }),
            (X.prototype.sqrt = function (o) {
              if (o.isZero()) return o.clone();
              var u = this.m.andln(3);
              if ((r(u % 2 === 1), u === 3)) {
                var l = this.m.add(new n(1)).iushrn(2);
                return this.pow(o, l);
              }
              for (var d = this.m.subn(1), g = 0; !d.isZero() && d.andln(1) === 0; )
                g++, d.iushrn(1);
              r(!d.isZero());
              var w = new n(1).toRed(this),
                M = w.redNeg(),
                v = this.m.subn(1).iushrn(1),
                a = this.m.bitLength();
              for (a = new n(2 * a * a).toRed(this); this.pow(a, v).cmp(M) !== 0; ) a.redIAdd(M);
              for (
                var b = this.pow(a, d),
                  k = this.pow(o, d.addn(1).iushrn(1)),
                  B = this.pow(o, d),
                  F = g;
                B.cmp(w) !== 0;

              ) {
                for (var P = B, C = 0; P.cmp(w) !== 0; C++) P = P.redSqr();
                r(C < F);
                var z = this.pow(b, new n(1).iushln(F - C - 1));
                (k = k.redMul(z)), (b = z.redSqr()), (B = B.redMul(b)), (F = C);
              }
              return k;
            }),
            (X.prototype.invm = function (o) {
              var u = o._invmp(this.m);
              return u.negative !== 0 ? ((u.negative = 0), this.imod(u).redNeg()) : this.imod(u);
            }),
            (X.prototype.pow = function (o, u) {
              if (u.isZero()) return new n(1).toRed(this);
              if (u.cmpn(1) === 0) return o.clone();
              var l = 4,
                d = new Array(1 << l);
              (d[0] = new n(1).toRed(this)), (d[1] = o);
              for (var g = 2; g < d.length; g++) d[g] = this.mul(d[g - 1], o);
              var w = d[0],
                M = 0,
                v = 0,
                a = u.bitLength() % 26;
              for (a === 0 && (a = 26), g = u.length - 1; g >= 0; g--) {
                for (var b = u.words[g], k = a - 1; k >= 0; k--) {
                  var B = (b >> k) & 1;
                  if ((w !== d[0] && (w = this.sqr(w)), B === 0 && M === 0)) {
                    v = 0;
                    continue;
                  }
                  (M <<= 1),
                    (M |= B),
                    v++,
                    !(v !== l && (g !== 0 || k !== 0)) &&
                      ((w = this.mul(w, d[M])), (v = 0), (M = 0));
                }
                a = 26;
              }
              return w;
            }),
            (X.prototype.convertTo = function (o) {
              var u = o.umod(this.m);
              return u === o ? u.clone() : u;
            }),
            (X.prototype.convertFrom = function (o) {
              var u = o.clone();
              return (u.red = null), u;
            }),
            (n.mont = function (o) {
              return new Oe(o);
            });
          function Oe(S) {
            X.call(this, S),
              (this.shift = this.m.bitLength()),
              this.shift % 26 !== 0 && (this.shift += 26 - (this.shift % 26)),
              (this.r = new n(1).iushln(this.shift)),
              (this.r2 = this.imod(this.r.sqr())),
              (this.rinv = this.r._invmp(this.m)),
              (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
              (this.minv = this.minv.umod(this.r)),
              (this.minv = this.r.sub(this.minv));
          }
          s(Oe, X),
            (Oe.prototype.convertTo = function (o) {
              return this.imod(o.ushln(this.shift));
            }),
            (Oe.prototype.convertFrom = function (o) {
              var u = this.imod(o.mul(this.rinv));
              return (u.red = null), u;
            }),
            (Oe.prototype.imul = function (o, u) {
              if (o.isZero() || u.isZero()) return (o.words[0] = 0), (o.length = 1), o;
              var l = o.imul(u),
                d = l.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                g = l.isub(d).iushrn(this.shift),
                w = g;
              return (
                g.cmp(this.m) >= 0 ? (w = g.isub(this.m)) : g.cmpn(0) < 0 && (w = g.iadd(this.m)),
                w._forceRed(this)
              );
            }),
            (Oe.prototype.mul = function (o, u) {
              if (o.isZero() || u.isZero()) return new n(0)._forceRed(this);
              var l = o.mul(u),
                d = l.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                g = l.isub(d).iushrn(this.shift),
                w = g;
              return (
                g.cmp(this.m) >= 0 ? (w = g.isub(this.m)) : g.cmpn(0) < 0 && (w = g.iadd(this.m)),
                w._forceRed(this)
              );
            }),
            (Oe.prototype.invm = function (o) {
              var u = this.imod(o._invmp(this.m).mul(this.r2));
              return u._forceRed(this);
            });
        })(i, se);
      })(Sf)),
    Sf.exports
  );
}
var m0 = {},
  w0 = {},
  _0,
  Xv;
function dy() {
  if (Xv) return _0;
  Xv = 1;
  var i = ai,
    e = i.Buffer,
    t = {},
    r;
  for (r in i) i.hasOwnProperty(r) && (r === 'SlowBuffer' || r === 'Buffer' || (t[r] = i[r]));
  var s = (t.Buffer = {});
  for (r in e)
    e.hasOwnProperty(r) && (r === 'allocUnsafe' || r === 'allocUnsafeSlow' || (s[r] = e[r]));
  if (
    ((t.Buffer.prototype = e.prototype),
    (!s.from || s.from === Uint8Array.from) &&
      (s.from = function (n, c, f) {
        if (typeof n == 'number')
          throw new TypeError(
            'The "value" argument must not be of type number. Received type ' + typeof n
          );
        if (n && typeof n.length > 'u')
          throw new TypeError(
            'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
              typeof n
          );
        return e(n, c, f);
      }),
    s.alloc ||
      (s.alloc = function (n, c, f) {
        if (typeof n != 'number')
          throw new TypeError(
            'The "size" argument must be of type number. Received type ' + typeof n
          );
        if (n < 0 || n >= 2 * (1 << 30))
          throw new RangeError('The value "' + n + '" is invalid for option "size"');
        var h = e(n);
        return (
          !c || c.length === 0 ? h.fill(0) : typeof f == 'string' ? h.fill(c, f) : h.fill(c), h
        );
      }),
    !t.kStringMaxLength)
  )
    try {
      t.kStringMaxLength = Je.binding('buffer').kStringMaxLength;
    } catch {}
  return (
    t.constants ||
      ((t.constants = { MAX_LENGTH: t.kMaxLength }),
      t.kStringMaxLength && (t.constants.MAX_STRING_LENGTH = t.kStringMaxLength)),
    (_0 = t),
    _0
  );
}
var S0 = {},
  Qv;
function py() {
  if (Qv) return S0;
  Qv = 1;
  const i = dt;
  function e(r) {
    this._reporterState = { obj: null, path: [], options: r || {}, errors: [] };
  }
  (S0.Reporter = e),
    (e.prototype.isError = function (s) {
      return s instanceof t;
    }),
    (e.prototype.save = function () {
      const s = this._reporterState;
      return { obj: s.obj, pathLen: s.path.length };
    }),
    (e.prototype.restore = function (s) {
      const n = this._reporterState;
      (n.obj = s.obj), (n.path = n.path.slice(0, s.pathLen));
    }),
    (e.prototype.enterKey = function (s) {
      return this._reporterState.path.push(s);
    }),
    (e.prototype.exitKey = function (s) {
      const n = this._reporterState;
      n.path = n.path.slice(0, s - 1);
    }),
    (e.prototype.leaveKey = function (s, n, c) {
      const f = this._reporterState;
      this.exitKey(s), f.obj !== null && (f.obj[n] = c);
    }),
    (e.prototype.path = function () {
      return this._reporterState.path.join('/');
    }),
    (e.prototype.enterObject = function () {
      const s = this._reporterState,
        n = s.obj;
      return (s.obj = {}), n;
    }),
    (e.prototype.leaveObject = function (s) {
      const n = this._reporterState,
        c = n.obj;
      return (n.obj = s), c;
    }),
    (e.prototype.error = function (s) {
      let n;
      const c = this._reporterState,
        f = s instanceof t;
      if (
        (f
          ? (n = s)
          : (n = new t(
              c.path
                .map(function (h) {
                  return '[' + JSON.stringify(h) + ']';
                })
                .join(''),
              s.message || s,
              s.stack
            )),
        !c.options.partial)
      )
        throw n;
      return f || c.errors.push(n), n;
    }),
    (e.prototype.wrapResult = function (s) {
      const n = this._reporterState;
      return n.options.partial ? { result: this.isError(s) ? null : s, errors: n.errors } : s;
    });
  function t(r, s) {
    (this.path = r), this.rethrow(s);
  }
  return (
    i(t, Error),
    (t.prototype.rethrow = function (s) {
      if (
        ((this.message = s + ' at: ' + (this.path || '(shallow)')),
        Error.captureStackTrace && Error.captureStackTrace(this, t),
        !this.stack)
      )
        try {
          throw new Error(this.message);
        } catch (n) {
          this.stack = n.stack;
        }
      return this;
    }),
    S0
  );
}
var Jc = {},
  em;
function Tu() {
  if (em) return Jc;
  em = 1;
  const i = dt,
    e = py().Reporter,
    t = dy().Buffer;
  function r(n, c) {
    if ((e.call(this, c), !t.isBuffer(n))) {
      this.error('Input not Buffer');
      return;
    }
    (this.base = n), (this.offset = 0), (this.length = n.length);
  }
  i(r, e),
    (Jc.DecoderBuffer = r),
    (r.isDecoderBuffer = function (c) {
      return c instanceof r
        ? !0
        : typeof c == 'object' &&
            t.isBuffer(c.base) &&
            c.constructor.name === 'DecoderBuffer' &&
            typeof c.offset == 'number' &&
            typeof c.length == 'number' &&
            typeof c.save == 'function' &&
            typeof c.restore == 'function' &&
            typeof c.isEmpty == 'function' &&
            typeof c.readUInt8 == 'function' &&
            typeof c.skip == 'function' &&
            typeof c.raw == 'function';
    }),
    (r.prototype.save = function () {
      return { offset: this.offset, reporter: e.prototype.save.call(this) };
    }),
    (r.prototype.restore = function (c) {
      const f = new r(this.base);
      return (
        (f.offset = c.offset),
        (f.length = this.offset),
        (this.offset = c.offset),
        e.prototype.restore.call(this, c.reporter),
        f
      );
    }),
    (r.prototype.isEmpty = function () {
      return this.offset === this.length;
    }),
    (r.prototype.readUInt8 = function (c) {
      return this.offset + 1 <= this.length
        ? this.base.readUInt8(this.offset++, !0)
        : this.error(c || 'DecoderBuffer overrun');
    }),
    (r.prototype.skip = function (c, f) {
      if (!(this.offset + c <= this.length)) return this.error(f || 'DecoderBuffer overrun');
      const h = new r(this.base);
      return (
        (h._reporterState = this._reporterState),
        (h.offset = this.offset),
        (h.length = this.offset + c),
        (this.offset += c),
        h
      );
    }),
    (r.prototype.raw = function (c) {
      return this.base.slice(c ? c.offset : this.offset, this.length);
    });
  function s(n, c) {
    if (Array.isArray(n))
      (this.length = 0),
        (this.value = n.map(function (f) {
          return s.isEncoderBuffer(f) || (f = new s(f, c)), (this.length += f.length), f;
        }, this));
    else if (typeof n == 'number') {
      if (!(0 <= n && n <= 255)) return c.error('non-byte EncoderBuffer value');
      (this.value = n), (this.length = 1);
    } else if (typeof n == 'string') (this.value = n), (this.length = t.byteLength(n));
    else if (t.isBuffer(n)) (this.value = n), (this.length = n.length);
    else return c.error('Unsupported type: ' + typeof n);
  }
  return (
    (Jc.EncoderBuffer = s),
    (s.isEncoderBuffer = function (c) {
      return c instanceof s
        ? !0
        : typeof c == 'object' &&
            c.constructor.name === 'EncoderBuffer' &&
            typeof c.length == 'number' &&
            typeof c.join == 'function';
    }),
    (s.prototype.join = function (c, f) {
      return (
        c || (c = t.alloc(this.length)),
        f || (f = 0),
        this.length === 0 ||
          (Array.isArray(this.value)
            ? this.value.forEach(function (h) {
                h.join(c, f), (f += h.length);
              })
            : (typeof this.value == 'number'
                ? (c[f] = this.value)
                : typeof this.value == 'string'
                  ? c.write(this.value, f)
                  : t.isBuffer(this.value) && this.value.copy(c, f),
              (f += this.length))),
        c
      );
    }),
    Jc
  );
}
var M0, tm;
function yy() {
  if (tm) return M0;
  tm = 1;
  const i = py().Reporter,
    e = Tu().EncoderBuffer,
    t = Tu().DecoderBuffer,
    r = Qi,
    s = [
      'seq',
      'seqof',
      'set',
      'setof',
      'objid',
      'bool',
      'gentime',
      'utctime',
      'null_',
      'enum',
      'int',
      'objDesc',
      'bitstr',
      'bmpstr',
      'charstr',
      'genstr',
      'graphstr',
      'ia5str',
      'iso646str',
      'numstr',
      'octstr',
      'printstr',
      't61str',
      'unistr',
      'utf8str',
      'videostr',
    ],
    n = [
      'key',
      'obj',
      'use',
      'optional',
      'explicit',
      'implicit',
      'def',
      'choice',
      'any',
      'contains',
    ].concat(s),
    c = [
      '_peekTag',
      '_decodeTag',
      '_use',
      '_decodeStr',
      '_decodeObjid',
      '_decodeTime',
      '_decodeNull',
      '_decodeInt',
      '_decodeBool',
      '_decodeList',
      '_encodeComposite',
      '_encodeStr',
      '_encodeObjid',
      '_encodeTime',
      '_encodeNull',
      '_encodeInt',
      '_encodeBool',
    ];
  function f(y, p, m) {
    const _ = {};
    (this._baseState = _),
      (_.name = m),
      (_.enc = y),
      (_.parent = p || null),
      (_.children = null),
      (_.tag = null),
      (_.args = null),
      (_.reverseArgs = null),
      (_.choice = null),
      (_.optional = !1),
      (_.any = !1),
      (_.obj = !1),
      (_.use = null),
      (_.useDecoder = null),
      (_.key = null),
      (_.default = null),
      (_.explicit = null),
      (_.implicit = null),
      (_.contains = null),
      _.parent || ((_.children = []), this._wrap());
  }
  M0 = f;
  const h = [
    'enc',
    'parent',
    'children',
    'tag',
    'args',
    'reverseArgs',
    'choice',
    'optional',
    'any',
    'obj',
    'use',
    'alteredUse',
    'key',
    'default',
    'explicit',
    'implicit',
    'contains',
  ];
  return (
    (f.prototype.clone = function () {
      const p = this._baseState,
        m = {};
      h.forEach(function (A) {
        m[A] = p[A];
      });
      const _ = new this.constructor(m.parent);
      return (_._baseState = m), _;
    }),
    (f.prototype._wrap = function () {
      const p = this._baseState;
      n.forEach(function (m) {
        this[m] = function () {
          const A = new this.constructor(this);
          return p.children.push(A), A[m].apply(A, arguments);
        };
      }, this);
    }),
    (f.prototype._init = function (p) {
      const m = this._baseState;
      r(m.parent === null),
        p.call(this),
        (m.children = m.children.filter(function (_) {
          return _._baseState.parent === this;
        }, this)),
        r.equal(m.children.length, 1, 'Root node can have only one child');
    }),
    (f.prototype._useArgs = function (p) {
      const m = this._baseState,
        _ = p.filter(function (A) {
          return A instanceof this.constructor;
        }, this);
      (p = p.filter(function (A) {
        return !(A instanceof this.constructor);
      }, this)),
        _.length !== 0 &&
          (r(m.children === null),
          (m.children = _),
          _.forEach(function (A) {
            A._baseState.parent = this;
          }, this)),
        p.length !== 0 &&
          (r(m.args === null),
          (m.args = p),
          (m.reverseArgs = p.map(function (A) {
            if (typeof A != 'object' || A.constructor !== Object) return A;
            const E = {};
            return (
              Object.keys(A).forEach(function (I) {
                I == (I | 0) && (I |= 0);
                const R = A[I];
                E[R] = I;
              }),
              E
            );
          })));
    }),
    c.forEach(function (y) {
      f.prototype[y] = function () {
        const m = this._baseState;
        throw new Error(y + ' not implemented for encoding: ' + m.enc);
      };
    }),
    s.forEach(function (y) {
      f.prototype[y] = function () {
        const m = this._baseState,
          _ = Array.prototype.slice.call(arguments);
        return r(m.tag === null), (m.tag = y), this._useArgs(_), this;
      };
    }),
    (f.prototype.use = function (p) {
      r(p);
      const m = this._baseState;
      return r(m.use === null), (m.use = p), this;
    }),
    (f.prototype.optional = function () {
      const p = this._baseState;
      return (p.optional = !0), this;
    }),
    (f.prototype.def = function (p) {
      const m = this._baseState;
      return r(m.default === null), (m.default = p), (m.optional = !0), this;
    }),
    (f.prototype.explicit = function (p) {
      const m = this._baseState;
      return r(m.explicit === null && m.implicit === null), (m.explicit = p), this;
    }),
    (f.prototype.implicit = function (p) {
      const m = this._baseState;
      return r(m.explicit === null && m.implicit === null), (m.implicit = p), this;
    }),
    (f.prototype.obj = function () {
      const p = this._baseState,
        m = Array.prototype.slice.call(arguments);
      return (p.obj = !0), m.length !== 0 && this._useArgs(m), this;
    }),
    (f.prototype.key = function (p) {
      const m = this._baseState;
      return r(m.key === null), (m.key = p), this;
    }),
    (f.prototype.any = function () {
      const p = this._baseState;
      return (p.any = !0), this;
    }),
    (f.prototype.choice = function (p) {
      const m = this._baseState;
      return (
        r(m.choice === null),
        (m.choice = p),
        this._useArgs(
          Object.keys(p).map(function (_) {
            return p[_];
          })
        ),
        this
      );
    }),
    (f.prototype.contains = function (p) {
      const m = this._baseState;
      return r(m.use === null), (m.contains = p), this;
    }),
    (f.prototype._decode = function (p, m) {
      const _ = this._baseState;
      if (_.parent === null) return p.wrapResult(_.children[0]._decode(p, m));
      let A = _.default,
        E = !0,
        I = null;
      if ((_.key !== null && (I = p.enterKey(_.key)), _.optional)) {
        let L = null;
        if (
          (_.explicit !== null
            ? (L = _.explicit)
            : _.implicit !== null
              ? (L = _.implicit)
              : _.tag !== null && (L = _.tag),
          L === null && !_.any)
        ) {
          const D = p.save();
          try {
            _.choice === null ? this._decodeGeneric(_.tag, p, m) : this._decodeChoice(p, m),
              (E = !0);
          } catch {
            E = !1;
          }
          p.restore(D);
        } else if (((E = this._peekTag(p, L, _.any)), p.isError(E))) return E;
      }
      let R;
      if ((_.obj && E && (R = p.enterObject()), E)) {
        if (_.explicit !== null) {
          const D = this._decodeTag(p, _.explicit);
          if (p.isError(D)) return D;
          p = D;
        }
        const L = p.offset;
        if (_.use === null && _.choice === null) {
          let D;
          _.any && (D = p.save());
          const q = this._decodeTag(p, _.implicit !== null ? _.implicit : _.tag, _.any);
          if (p.isError(q)) return q;
          _.any ? (A = p.raw(D)) : (p = q);
        }
        if (
          (m && m.track && _.tag !== null && m.track(p.path(), L, p.length, 'tagged'),
          m && m.track && _.tag !== null && m.track(p.path(), p.offset, p.length, 'content'),
          _.any ||
            (_.choice === null
              ? (A = this._decodeGeneric(_.tag, p, m))
              : (A = this._decodeChoice(p, m))),
          p.isError(A))
        )
          return A;
        if (
          (!_.any &&
            _.choice === null &&
            _.children !== null &&
            _.children.forEach(function (q) {
              q._decode(p, m);
            }),
          _.contains && (_.tag === 'octstr' || _.tag === 'bitstr'))
        ) {
          const D = new t(A);
          A = this._getUse(_.contains, p._reporterState.obj)._decode(D, m);
        }
      }
      return (
        _.obj && E && (A = p.leaveObject(R)),
        _.key !== null && (A !== null || E === !0)
          ? p.leaveKey(I, _.key, A)
          : I !== null && p.exitKey(I),
        A
      );
    }),
    (f.prototype._decodeGeneric = function (p, m, _) {
      const A = this._baseState;
      return p === 'seq' || p === 'set'
        ? null
        : p === 'seqof' || p === 'setof'
          ? this._decodeList(m, p, A.args[0], _)
          : /str$/.test(p)
            ? this._decodeStr(m, p, _)
            : p === 'objid' && A.args
              ? this._decodeObjid(m, A.args[0], A.args[1], _)
              : p === 'objid'
                ? this._decodeObjid(m, null, null, _)
                : p === 'gentime' || p === 'utctime'
                  ? this._decodeTime(m, p, _)
                  : p === 'null_'
                    ? this._decodeNull(m, _)
                    : p === 'bool'
                      ? this._decodeBool(m, _)
                      : p === 'objDesc'
                        ? this._decodeStr(m, p, _)
                        : p === 'int' || p === 'enum'
                          ? this._decodeInt(m, A.args && A.args[0], _)
                          : A.use !== null
                            ? this._getUse(A.use, m._reporterState.obj)._decode(m, _)
                            : m.error('unknown tag: ' + p);
    }),
    (f.prototype._getUse = function (p, m) {
      const _ = this._baseState;
      return (
        (_.useDecoder = this._use(p, m)),
        r(_.useDecoder._baseState.parent === null),
        (_.useDecoder = _.useDecoder._baseState.children[0]),
        _.implicit !== _.useDecoder._baseState.implicit &&
          ((_.useDecoder = _.useDecoder.clone()), (_.useDecoder._baseState.implicit = _.implicit)),
        _.useDecoder
      );
    }),
    (f.prototype._decodeChoice = function (p, m) {
      const _ = this._baseState;
      let A = null,
        E = !1;
      return (
        Object.keys(_.choice).some(function (I) {
          const R = p.save(),
            L = _.choice[I];
          try {
            const D = L._decode(p, m);
            if (p.isError(D)) return !1;
            (A = { type: I, value: D }), (E = !0);
          } catch {
            return p.restore(R), !1;
          }
          return !0;
        }, this),
        E ? A : p.error('Choice not matched')
      );
    }),
    (f.prototype._createEncoderBuffer = function (p) {
      return new e(p, this.reporter);
    }),
    (f.prototype._encode = function (p, m, _) {
      const A = this._baseState;
      if (A.default !== null && A.default === p) return;
      const E = this._encodeValue(p, m, _);
      if (E !== void 0 && !this._skipDefault(E, m, _)) return E;
    }),
    (f.prototype._encodeValue = function (p, m, _) {
      const A = this._baseState;
      if (A.parent === null) return A.children[0]._encode(p, m || new i());
      let E = null;
      if (((this.reporter = m), A.optional && p === void 0))
        if (A.default !== null) p = A.default;
        else return;
      let I = null,
        R = !1;
      if (A.any) E = this._createEncoderBuffer(p);
      else if (A.choice) E = this._encodeChoice(p, m);
      else if (A.contains) (I = this._getUse(A.contains, _)._encode(p, m)), (R = !0);
      else if (A.children)
        (I = A.children
          .map(function (L) {
            if (L._baseState.tag === 'null_') return L._encode(null, m, p);
            if (L._baseState.key === null) return m.error('Child should have a key');
            const D = m.enterKey(L._baseState.key);
            if (typeof p != 'object') return m.error('Child expected, but input is not object');
            const q = L._encode(p[L._baseState.key], m, p);
            return m.leaveKey(D), q;
          }, this)
          .filter(function (L) {
            return L;
          })),
          (I = this._createEncoderBuffer(I));
      else if (A.tag === 'seqof' || A.tag === 'setof') {
        if (!(A.args && A.args.length === 1)) return m.error('Too many args for : ' + A.tag);
        if (!Array.isArray(p)) return m.error('seqof/setof, but data is not Array');
        const L = this.clone();
        (L._baseState.implicit = null),
          (I = this._createEncoderBuffer(
            p.map(function (D) {
              const q = this._baseState;
              return this._getUse(q.args[0], p)._encode(D, m);
            }, L)
          ));
      } else
        A.use !== null
          ? (E = this._getUse(A.use, _)._encode(p, m))
          : ((I = this._encodePrimitive(A.tag, p)), (R = !0));
      if (!A.any && A.choice === null) {
        const L = A.implicit !== null ? A.implicit : A.tag,
          D = A.implicit === null ? 'universal' : 'context';
        L === null
          ? A.use === null && m.error('Tag could be omitted only for .use()')
          : A.use === null && (E = this._encodeComposite(L, R, D, I));
      }
      return A.explicit !== null && (E = this._encodeComposite(A.explicit, !1, 'context', E)), E;
    }),
    (f.prototype._encodeChoice = function (p, m) {
      const _ = this._baseState,
        A = _.choice[p.type];
      return (
        A || r(!1, p.type + ' not found in ' + JSON.stringify(Object.keys(_.choice))),
        A._encode(p.value, m)
      );
    }),
    (f.prototype._encodePrimitive = function (p, m) {
      const _ = this._baseState;
      if (/str$/.test(p)) return this._encodeStr(m, p);
      if (p === 'objid' && _.args) return this._encodeObjid(m, _.reverseArgs[0], _.args[1]);
      if (p === 'objid') return this._encodeObjid(m, null, null);
      if (p === 'gentime' || p === 'utctime') return this._encodeTime(m, p);
      if (p === 'null_') return this._encodeNull();
      if (p === 'int' || p === 'enum') return this._encodeInt(m, _.args && _.reverseArgs[0]);
      if (p === 'bool') return this._encodeBool(m);
      if (p === 'objDesc') return this._encodeStr(m, p);
      throw new Error('Unsupported tag: ' + p);
    }),
    (f.prototype._isNumstr = function (p) {
      return /^[0-9 ]*$/.test(p);
    }),
    (f.prototype._isPrintstr = function (p) {
      return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(p);
    }),
    M0
  );
}
var A0 = {},
  rm;
function gy() {
  return (
    rm ||
      ((rm = 1),
      (function (i) {
        function e(t) {
          const r = {};
          return (
            Object.keys(t).forEach(function (s) {
              (s | 0) == s && (s = s | 0);
              const n = t[s];
              r[n] = s;
            }),
            r
          );
        }
        (i.tagClass = { 0: 'universal', 1: 'application', 2: 'context', 3: 'private' }),
          (i.tagClassByName = e(i.tagClass)),
          (i.tag = {
            0: 'end',
            1: 'bool',
            2: 'int',
            3: 'bitstr',
            4: 'octstr',
            5: 'null_',
            6: 'objid',
            7: 'objDesc',
            8: 'external',
            9: 'real',
            10: 'enum',
            11: 'embed',
            12: 'utf8str',
            13: 'relativeOid',
            16: 'seq',
            17: 'set',
            18: 'numstr',
            19: 'printstr',
            20: 't61str',
            21: 'videostr',
            22: 'ia5str',
            23: 'utctime',
            24: 'gentime',
            25: 'graphstr',
            26: 'iso646str',
            27: 'genstr',
            28: 'unistr',
            29: 'charstr',
            30: 'bmpstr',
          }),
          (i.tagByName = e(i.tag));
      })(A0)),
    A0
  );
}
var E0, im;
function I8() {
  if (im) return E0;
  im = 1;
  const i = dt,
    e = dy().Buffer,
    t = yy(),
    r = gy();
  function s(h) {
    (this.enc = 'der'),
      (this.name = h.name),
      (this.entity = h),
      (this.tree = new n()),
      this.tree._init(h.body);
  }
  (E0 = s),
    (s.prototype.encode = function (y, p) {
      return this.tree._encode(y, p).join();
    });
  function n(h) {
    t.call(this, 'der', h);
  }
  i(n, t),
    (n.prototype._encodeComposite = function (y, p, m, _) {
      const A = f(y, p, m, this.reporter);
      if (_.length < 128) {
        const R = e.alloc(2);
        return (R[0] = A), (R[1] = _.length), this._createEncoderBuffer([R, _]);
      }
      let E = 1;
      for (let R = _.length; R >= 256; R >>= 8) E++;
      const I = e.alloc(2 + E);
      (I[0] = A), (I[1] = 128 | E);
      for (let R = 1 + E, L = _.length; L > 0; R--, L >>= 8) I[R] = L & 255;
      return this._createEncoderBuffer([I, _]);
    }),
    (n.prototype._encodeStr = function (y, p) {
      if (p === 'bitstr') return this._createEncoderBuffer([y.unused | 0, y.data]);
      if (p === 'bmpstr') {
        const m = e.alloc(y.length * 2);
        for (let _ = 0; _ < y.length; _++) m.writeUInt16BE(y.charCodeAt(_), _ * 2);
        return this._createEncoderBuffer(m);
      } else
        return p === 'numstr'
          ? this._isNumstr(y)
            ? this._createEncoderBuffer(y)
            : this.reporter.error('Encoding of string type: numstr supports only digits and space')
          : p === 'printstr'
            ? this._isPrintstr(y)
              ? this._createEncoderBuffer(y)
              : this.reporter.error(
                  'Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark'
                )
            : /str$/.test(p)
              ? this._createEncoderBuffer(y)
              : p === 'objDesc'
                ? this._createEncoderBuffer(y)
                : this.reporter.error('Encoding of string type: ' + p + ' unsupported');
    }),
    (n.prototype._encodeObjid = function (y, p, m) {
      if (typeof y == 'string') {
        if (!p) return this.reporter.error('string objid given, but no values map found');
        if (!p.hasOwnProperty(y)) return this.reporter.error('objid not found in values map');
        y = p[y].split(/[\s.]+/g);
        for (let I = 0; I < y.length; I++) y[I] |= 0;
      } else if (Array.isArray(y)) {
        y = y.slice();
        for (let I = 0; I < y.length; I++) y[I] |= 0;
      }
      if (!Array.isArray(y))
        return this.reporter.error(
          'objid() should be either array or string, got: ' + JSON.stringify(y)
        );
      if (!m) {
        if (y[1] >= 40) return this.reporter.error('Second objid identifier OOB');
        y.splice(0, 2, y[0] * 40 + y[1]);
      }
      let _ = 0;
      for (let I = 0; I < y.length; I++) {
        let R = y[I];
        for (_++; R >= 128; R >>= 7) _++;
      }
      const A = e.alloc(_);
      let E = A.length - 1;
      for (let I = y.length - 1; I >= 0; I--) {
        let R = y[I];
        for (A[E--] = R & 127; (R >>= 7) > 0; ) A[E--] = 128 | (R & 127);
      }
      return this._createEncoderBuffer(A);
    });
  function c(h) {
    return h < 10 ? '0' + h : h;
  }
  (n.prototype._encodeTime = function (y, p) {
    let m;
    const _ = new Date(y);
    return (
      p === 'gentime'
        ? (m = [
            c(_.getUTCFullYear()),
            c(_.getUTCMonth() + 1),
            c(_.getUTCDate()),
            c(_.getUTCHours()),
            c(_.getUTCMinutes()),
            c(_.getUTCSeconds()),
            'Z',
          ].join(''))
        : p === 'utctime'
          ? (m = [
              c(_.getUTCFullYear() % 100),
              c(_.getUTCMonth() + 1),
              c(_.getUTCDate()),
              c(_.getUTCHours()),
              c(_.getUTCMinutes()),
              c(_.getUTCSeconds()),
              'Z',
            ].join(''))
          : this.reporter.error('Encoding ' + p + ' time is not supported yet'),
      this._encodeStr(m, 'octstr')
    );
  }),
    (n.prototype._encodeNull = function () {
      return this._createEncoderBuffer('');
    }),
    (n.prototype._encodeInt = function (y, p) {
      if (typeof y == 'string') {
        if (!p) return this.reporter.error('String int or enum given, but no values map');
        if (!p.hasOwnProperty(y))
          return this.reporter.error("Values map doesn't contain: " + JSON.stringify(y));
        y = p[y];
      }
      if (typeof y != 'number' && !e.isBuffer(y)) {
        const A = y.toArray();
        !y.sign && A[0] & 128 && A.unshift(0), (y = e.from(A));
      }
      if (e.isBuffer(y)) {
        let A = y.length;
        y.length === 0 && A++;
        const E = e.alloc(A);
        return y.copy(E), y.length === 0 && (E[0] = 0), this._createEncoderBuffer(E);
      }
      if (y < 128) return this._createEncoderBuffer(y);
      if (y < 256) return this._createEncoderBuffer([0, y]);
      let m = 1;
      for (let A = y; A >= 256; A >>= 8) m++;
      const _ = new Array(m);
      for (let A = _.length - 1; A >= 0; A--) (_[A] = y & 255), (y >>= 8);
      return _[0] & 128 && _.unshift(0), this._createEncoderBuffer(e.from(_));
    }),
    (n.prototype._encodeBool = function (y) {
      return this._createEncoderBuffer(y ? 255 : 0);
    }),
    (n.prototype._use = function (y, p) {
      return typeof y == 'function' && (y = y(p)), y._getEncoder('der').tree;
    }),
    (n.prototype._skipDefault = function (y, p, m) {
      const _ = this._baseState;
      let A;
      if (_.default === null) return !1;
      const E = y.join();
      if (
        (_.defaultBuffer === void 0 &&
          (_.defaultBuffer = this._encodeValue(_.default, p, m).join()),
        E.length !== _.defaultBuffer.length)
      )
        return !1;
      for (A = 0; A < E.length; A++) if (E[A] !== _.defaultBuffer[A]) return !1;
      return !0;
    });
  function f(h, y, p, m) {
    let _;
    if ((h === 'seqof' ? (h = 'seq') : h === 'setof' && (h = 'set'), r.tagByName.hasOwnProperty(h)))
      _ = r.tagByName[h];
    else if (typeof h == 'number' && (h | 0) === h) _ = h;
    else return m.error('Unknown tag: ' + h);
    return _ >= 31
      ? m.error('Multi-octet tag encoding unsupported')
      : (y || (_ |= 32), (_ |= r.tagClassByName[p || 'universal'] << 6), _);
  }
  return E0;
}
var k0, nm;
function Bx() {
  if (nm) return k0;
  nm = 1;
  const i = dt,
    e = I8();
  function t(r) {
    e.call(this, r), (this.enc = 'pem');
  }
  return (
    i(t, e),
    (k0 = t),
    (t.prototype.encode = function (s, n) {
      const f = e.prototype.encode.call(this, s).toString('base64'),
        h = ['-----BEGIN ' + n.label + '-----'];
      for (let y = 0; y < f.length; y += 64) h.push(f.slice(y, y + 64));
      return (
        h.push('-----END ' + n.label + '-----'),
        h.join(`
`)
      );
    }),
    k0
  );
}
var om;
function x8() {
  return (
    om ||
      ((om = 1),
      (function (i) {
        const e = i;
        (e.der = I8()), (e.pem = Bx());
      })(w0)),
    w0
  );
}
var I0 = {},
  x0,
  sm;
function B8() {
  if (sm) return x0;
  sm = 1;
  const i = dt,
    e = k8(),
    t = Tu().DecoderBuffer,
    r = yy(),
    s = gy();
  function n(y) {
    (this.enc = 'der'),
      (this.name = y.name),
      (this.entity = y),
      (this.tree = new c()),
      this.tree._init(y.body);
  }
  (x0 = n),
    (n.prototype.decode = function (p, m) {
      return t.isDecoderBuffer(p) || (p = new t(p, m)), this.tree._decode(p, m);
    });
  function c(y) {
    r.call(this, 'der', y);
  }
  i(c, r),
    (c.prototype._peekTag = function (p, m, _) {
      if (p.isEmpty()) return !1;
      const A = p.save(),
        E = f(p, 'Failed to peek tag: "' + m + '"');
      return p.isError(E)
        ? E
        : (p.restore(A), E.tag === m || E.tagStr === m || E.tagStr + 'of' === m || _);
    }),
    (c.prototype._decodeTag = function (p, m, _) {
      const A = f(p, 'Failed to decode tag of "' + m + '"');
      if (p.isError(A)) return A;
      let E = h(p, A.primitive, 'Failed to get length of "' + m + '"');
      if (p.isError(E)) return E;
      if (!_ && A.tag !== m && A.tagStr !== m && A.tagStr + 'of' !== m)
        return p.error('Failed to match tag: "' + m + '"');
      if (A.primitive || E !== null) return p.skip(E, 'Failed to match body of: "' + m + '"');
      const I = p.save(),
        R = this._skipUntilEnd(p, 'Failed to skip indefinite length body: "' + this.tag + '"');
      return p.isError(R)
        ? R
        : ((E = p.offset - I.offset),
          p.restore(I),
          p.skip(E, 'Failed to match body of: "' + m + '"'));
    }),
    (c.prototype._skipUntilEnd = function (p, m) {
      for (;;) {
        const _ = f(p, m);
        if (p.isError(_)) return _;
        const A = h(p, _.primitive, m);
        if (p.isError(A)) return A;
        let E;
        if (
          (_.primitive || A !== null ? (E = p.skip(A)) : (E = this._skipUntilEnd(p, m)),
          p.isError(E))
        )
          return E;
        if (_.tagStr === 'end') break;
      }
    }),
    (c.prototype._decodeList = function (p, m, _, A) {
      const E = [];
      for (; !p.isEmpty(); ) {
        const I = this._peekTag(p, 'end');
        if (p.isError(I)) return I;
        const R = _.decode(p, 'der', A);
        if (p.isError(R) && I) break;
        E.push(R);
      }
      return E;
    }),
    (c.prototype._decodeStr = function (p, m) {
      if (m === 'bitstr') {
        const _ = p.readUInt8();
        return p.isError(_) ? _ : { unused: _, data: p.raw() };
      } else if (m === 'bmpstr') {
        const _ = p.raw();
        if (_.length % 2 === 1) return p.error('Decoding of string type: bmpstr length mismatch');
        let A = '';
        for (let E = 0; E < _.length / 2; E++) A += String.fromCharCode(_.readUInt16BE(E * 2));
        return A;
      } else if (m === 'numstr') {
        const _ = p.raw().toString('ascii');
        return this._isNumstr(_)
          ? _
          : p.error('Decoding of string type: numstr unsupported characters');
      } else {
        if (m === 'octstr') return p.raw();
        if (m === 'objDesc') return p.raw();
        if (m === 'printstr') {
          const _ = p.raw().toString('ascii');
          return this._isPrintstr(_)
            ? _
            : p.error('Decoding of string type: printstr unsupported characters');
        } else
          return /str$/.test(m)
            ? p.raw().toString()
            : p.error('Decoding of string type: ' + m + ' unsupported');
      }
    }),
    (c.prototype._decodeObjid = function (p, m, _) {
      let A;
      const E = [];
      let I = 0,
        R = 0;
      for (; !p.isEmpty(); )
        (R = p.readUInt8()), (I <<= 7), (I |= R & 127), R & 128 || (E.push(I), (I = 0));
      R & 128 && E.push(I);
      const L = (E[0] / 40) | 0,
        D = E[0] % 40;
      if ((_ ? (A = E) : (A = [L, D].concat(E.slice(1))), m)) {
        let q = m[A.join(' ')];
        q === void 0 && (q = m[A.join('.')]), q !== void 0 && (A = q);
      }
      return A;
    }),
    (c.prototype._decodeTime = function (p, m) {
      const _ = p.raw().toString();
      let A, E, I, R, L, D;
      if (m === 'gentime')
        (A = _.slice(0, 4) | 0),
          (E = _.slice(4, 6) | 0),
          (I = _.slice(6, 8) | 0),
          (R = _.slice(8, 10) | 0),
          (L = _.slice(10, 12) | 0),
          (D = _.slice(12, 14) | 0);
      else if (m === 'utctime')
        (A = _.slice(0, 2) | 0),
          (E = _.slice(2, 4) | 0),
          (I = _.slice(4, 6) | 0),
          (R = _.slice(6, 8) | 0),
          (L = _.slice(8, 10) | 0),
          (D = _.slice(10, 12) | 0),
          A < 70 ? (A = 2e3 + A) : (A = 1900 + A);
      else return p.error('Decoding ' + m + ' time is not supported yet');
      return Date.UTC(A, E - 1, I, R, L, D, 0);
    }),
    (c.prototype._decodeNull = function () {
      return null;
    }),
    (c.prototype._decodeBool = function (p) {
      const m = p.readUInt8();
      return p.isError(m) ? m : m !== 0;
    }),
    (c.prototype._decodeInt = function (p, m) {
      const _ = p.raw();
      let A = new e(_);
      return m && (A = m[A.toString(10)] || A), A;
    }),
    (c.prototype._use = function (p, m) {
      return typeof p == 'function' && (p = p(m)), p._getDecoder('der').tree;
    });
  function f(y, p) {
    let m = y.readUInt8(p);
    if (y.isError(m)) return m;
    const _ = s.tagClass[m >> 6],
      A = (m & 32) === 0;
    if ((m & 31) === 31) {
      let I = m;
      for (m = 0; (I & 128) === 128; ) {
        if (((I = y.readUInt8(p)), y.isError(I))) return I;
        (m <<= 7), (m |= I & 127);
      }
    } else m &= 31;
    const E = s.tag[m];
    return { cls: _, primitive: A, tag: m, tagStr: E };
  }
  function h(y, p, m) {
    let _ = y.readUInt8(m);
    if (y.isError(_)) return _;
    if (!p && _ === 128) return null;
    if (!(_ & 128)) return _;
    const A = _ & 127;
    if (A > 4) return y.error('length octect is too long');
    _ = 0;
    for (let E = 0; E < A; E++) {
      _ <<= 8;
      const I = y.readUInt8(m);
      if (y.isError(I)) return I;
      _ |= I;
    }
    return _;
  }
  return x0;
}
var B0, am;
function Rx() {
  if (am) return B0;
  am = 1;
  const i = dt,
    e = dy().Buffer,
    t = B8();
  function r(s) {
    t.call(this, s), (this.enc = 'pem');
  }
  return (
    i(r, t),
    (B0 = r),
    (r.prototype.decode = function (n, c) {
      const f = n.toString().split(/[\r\n]+/g),
        h = c.label.toUpperCase(),
        y = /^-----(BEGIN|END) ([^-]+)-----$/;
      let p = -1,
        m = -1;
      for (let E = 0; E < f.length; E++) {
        const I = f[E].match(y);
        if (I !== null && I[2] === h)
          if (p === -1) {
            if (I[1] !== 'BEGIN') break;
            p = E;
          } else {
            if (I[1] !== 'END') break;
            m = E;
            break;
          }
      }
      if (p === -1 || m === -1) throw new Error('PEM section not found for: ' + h);
      const _ = f.slice(p + 1, m).join('');
      _.replace(/[^a-z0-9+/=]+/gi, '');
      const A = e.from(_, 'base64');
      return t.prototype.decode.call(this, A, c);
    }),
    B0
  );
}
var um;
function R8() {
  return (
    um ||
      ((um = 1),
      (function (i) {
        const e = i;
        (e.der = B8()), (e.pem = Rx());
      })(I0)),
    I0
  );
}
var cm;
function Px() {
  return (
    cm ||
      ((cm = 1),
      (function (i) {
        const e = x8(),
          t = R8(),
          r = dt,
          s = i;
        s.define = function (f, h) {
          return new n(f, h);
        };
        function n(c, f) {
          (this.name = c), (this.body = f), (this.decoders = {}), (this.encoders = {});
        }
        (n.prototype._createNamed = function (f) {
          const h = this.name;
          function y(p) {
            this._initNamed(p, h);
          }
          return (
            r(y, f),
            (y.prototype._initNamed = function (m, _) {
              f.call(this, m, _);
            }),
            new y(this)
          );
        }),
          (n.prototype._getDecoder = function (f) {
            return (
              (f = f || 'der'),
              this.decoders.hasOwnProperty(f) || (this.decoders[f] = this._createNamed(t[f])),
              this.decoders[f]
            );
          }),
          (n.prototype.decode = function (f, h, y) {
            return this._getDecoder(h).decode(f, y);
          }),
          (n.prototype._getEncoder = function (f) {
            return (
              (f = f || 'der'),
              this.encoders.hasOwnProperty(f) || (this.encoders[f] = this._createNamed(e[f])),
              this.encoders[f]
            );
          }),
          (n.prototype.encode = function (f, h, y) {
            return this._getEncoder(h).encode(f, y);
          });
      })(m0)),
    m0
  );
}
var R0 = {},
  fm;
function Tx() {
  return (
    fm ||
      ((fm = 1),
      (function (i) {
        const e = i;
        (e.Reporter = py().Reporter),
          (e.DecoderBuffer = Tu().DecoderBuffer),
          (e.EncoderBuffer = Tu().EncoderBuffer),
          (e.Node = yy());
      })(R0)),
    R0
  );
}
var P0 = {},
  lm;
function Ox() {
  return (
    lm ||
      ((lm = 1),
      (function (i) {
        const e = i;
        (e._reverse = function (r) {
          const s = {};
          return (
            Object.keys(r).forEach(function (n) {
              (n | 0) == n && (n = n | 0);
              const c = r[n];
              s[c] = n;
            }),
            s
          );
        }),
          (e.der = gy());
      })(P0)),
    P0
  );
}
var hm;
function P8() {
  return (
    hm ||
      ((hm = 1),
      (function (i) {
        const e = i;
        (e.bignum = k8()),
          (e.define = Px().define),
          (e.base = Tx()),
          (e.constants = Ox()),
          (e.decoders = R8()),
          (e.encoders = x8());
      })(v0)),
    v0
  );
}
var T0, dm;
function Cx() {
  if (dm) return T0;
  dm = 1;
  var i = P8(),
    e = i.define('Time', function () {
      this.choice({ utcTime: this.utctime(), generalTime: this.gentime() });
    }),
    t = i.define('AttributeTypeValue', function () {
      this.seq().obj(this.key('type').objid(), this.key('value').any());
    }),
    r = i.define('AlgorithmIdentifier', function () {
      this.seq().obj(
        this.key('algorithm').objid(),
        this.key('parameters').optional(),
        this.key('curve').objid().optional()
      );
    }),
    s = i.define('SubjectPublicKeyInfo', function () {
      this.seq().obj(this.key('algorithm').use(r), this.key('subjectPublicKey').bitstr());
    }),
    n = i.define('RelativeDistinguishedName', function () {
      this.setof(t);
    }),
    c = i.define('RDNSequence', function () {
      this.seqof(n);
    }),
    f = i.define('Name', function () {
      this.choice({ rdnSequence: this.use(c) });
    }),
    h = i.define('Validity', function () {
      this.seq().obj(this.key('notBefore').use(e), this.key('notAfter').use(e));
    }),
    y = i.define('Extension', function () {
      this.seq().obj(
        this.key('extnID').objid(),
        this.key('critical').bool().def(!1),
        this.key('extnValue').octstr()
      );
    }),
    p = i.define('TBSCertificate', function () {
      this.seq().obj(
        this.key('version').explicit(0).int().optional(),
        this.key('serialNumber').int(),
        this.key('signature').use(r),
        this.key('issuer').use(f),
        this.key('validity').use(h),
        this.key('subject').use(f),
        this.key('subjectPublicKeyInfo').use(s),
        this.key('issuerUniqueID').implicit(1).bitstr().optional(),
        this.key('subjectUniqueID').implicit(2).bitstr().optional(),
        this.key('extensions').explicit(3).seqof(y).optional()
      );
    }),
    m = i.define('X509Certificate', function () {
      this.seq().obj(
        this.key('tbsCertificate').use(p),
        this.key('signatureAlgorithm').use(r),
        this.key('signatureValue').bitstr()
      );
    });
  return (T0 = m), T0;
}
var pm;
function Lx() {
  if (pm) return Ki;
  pm = 1;
  var i = P8();
  Ki.certificate = Cx();
  var e = i.define('RSAPrivateKey', function () {
    this.seq().obj(
      this.key('version').int(),
      this.key('modulus').int(),
      this.key('publicExponent').int(),
      this.key('privateExponent').int(),
      this.key('prime1').int(),
      this.key('prime2').int(),
      this.key('exponent1').int(),
      this.key('exponent2').int(),
      this.key('coefficient').int()
    );
  });
  Ki.RSAPrivateKey = e;
  var t = i.define('RSAPublicKey', function () {
    this.seq().obj(this.key('modulus').int(), this.key('publicExponent').int());
  });
  Ki.RSAPublicKey = t;
  var r = i.define('SubjectPublicKeyInfo', function () {
    this.seq().obj(this.key('algorithm').use(s), this.key('subjectPublicKey').bitstr());
  });
  Ki.PublicKey = r;
  var s = i.define('AlgorithmIdentifier', function () {
      this.seq().obj(
        this.key('algorithm').objid(),
        this.key('none').null_().optional(),
        this.key('curve').objid().optional(),
        this.key('params')
          .seq()
          .obj(this.key('p').int(), this.key('q').int(), this.key('g').int())
          .optional()
      );
    }),
    n = i.define('PrivateKeyInfo', function () {
      this.seq().obj(
        this.key('version').int(),
        this.key('algorithm').use(s),
        this.key('subjectPrivateKey').octstr()
      );
    });
  Ki.PrivateKey = n;
  var c = i.define('EncryptedPrivateKeyInfo', function () {
    this.seq().obj(
      this.key('algorithm')
        .seq()
        .obj(
          this.key('id').objid(),
          this.key('decrypt')
            .seq()
            .obj(
              this.key('kde')
                .seq()
                .obj(
                  this.key('id').objid(),
                  this.key('kdeparams')
                    .seq()
                    .obj(this.key('salt').octstr(), this.key('iters').int())
                ),
              this.key('cipher').seq().obj(this.key('algo').objid(), this.key('iv').octstr())
            )
        ),
      this.key('subjectPrivateKey').octstr()
    );
  });
  Ki.EncryptedPrivateKey = c;
  var f = i.define('DSAPrivateKey', function () {
    this.seq().obj(
      this.key('version').int(),
      this.key('p').int(),
      this.key('q').int(),
      this.key('g').int(),
      this.key('pub_key').int(),
      this.key('priv_key').int()
    );
  });
  (Ki.DSAPrivateKey = f),
    (Ki.DSAparam = i.define('DSAparam', function () {
      this.int();
    }));
  var h = i.define('ECPrivateKey', function () {
    this.seq().obj(
      this.key('version').int(),
      this.key('privateKey').octstr(),
      this.key('parameters').optional().explicit(0).use(y),
      this.key('publicKey').optional().explicit(1).bitstr()
    );
  });
  Ki.ECPrivateKey = h;
  var y = i.define('ECParameters', function () {
    this.choice({ namedCurve: this.objid() });
  });
  return (
    (Ki.signature = i.define('signature', function () {
      this.seq().obj(this.key('r').int(), this.key('s').int());
    })),
    Ki
  );
}
const Nx = {
  '2.16.840.1.101.3.4.1.1': 'aes-128-ecb',
  '2.16.840.1.101.3.4.1.2': 'aes-128-cbc',
  '2.16.840.1.101.3.4.1.3': 'aes-128-ofb',
  '2.16.840.1.101.3.4.1.4': 'aes-128-cfb',
  '2.16.840.1.101.3.4.1.21': 'aes-192-ecb',
  '2.16.840.1.101.3.4.1.22': 'aes-192-cbc',
  '2.16.840.1.101.3.4.1.23': 'aes-192-ofb',
  '2.16.840.1.101.3.4.1.24': 'aes-192-cfb',
  '2.16.840.1.101.3.4.1.41': 'aes-256-ecb',
  '2.16.840.1.101.3.4.1.42': 'aes-256-cbc',
  '2.16.840.1.101.3.4.1.43': 'aes-256-ofb',
  '2.16.840.1.101.3.4.1.44': 'aes-256-cfb',
};
var O0, ym;
function $x() {
  if (ym) return O0;
  ym = 1;
  var i =
      /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m,
    e = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m,
    t = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m,
    r = Cl(),
    s = ay(),
    n = At.Buffer;
  return (
    (O0 = function (c, f) {
      var h = c.toString(),
        y = h.match(i),
        p;
      if (y) {
        var _ = 'aes' + y[1],
          A = n.from(y[2], 'hex'),
          E = n.from(y[3].replace(/[\r\n]/g, ''), 'base64'),
          I = r(f, A.slice(0, 8), parseInt(y[1], 10)).key,
          R = [],
          L = s.createDecipheriv(_, I, A);
        R.push(L.update(E)), R.push(L.final()), (p = n.concat(R));
      } else {
        var m = h.match(t);
        p = n.from(m[2].replace(/[\r\n]/g, ''), 'base64');
      }
      var D = h.match(e)[1];
      return { tag: D, data: p };
    }),
    O0
  );
}
var C0, gm;
function $l() {
  if (gm) return C0;
  gm = 1;
  var i = Lx(),
    e = Nx,
    t = $x(),
    r = ay(),
    s = K6(),
    n = At.Buffer;
  C0 = c;
  function c(h) {
    var y;
    typeof h == 'object' && !n.isBuffer(h) && ((y = h.passphrase), (h = h.key)),
      typeof h == 'string' && (h = n.from(h));
    var p = t(h, y),
      m = p.tag,
      _ = p.data,
      A,
      E;
    switch (m) {
      case 'CERTIFICATE':
        E = i.certificate.decode(_, 'der').tbsCertificate.subjectPublicKeyInfo;
      case 'PUBLIC KEY':
        switch (
          (E || (E = i.PublicKey.decode(_, 'der')), (A = E.algorithm.algorithm.join('.')), A)
        ) {
          case '1.2.840.113549.1.1.1':
            return i.RSAPublicKey.decode(E.subjectPublicKey.data, 'der');
          case '1.2.840.10045.2.1':
            return (E.subjectPrivateKey = E.subjectPublicKey), { type: 'ec', data: E };
          case '1.2.840.10040.4.1':
            return (
              (E.algorithm.params.pub_key = i.DSAparam.decode(E.subjectPublicKey.data, 'der')),
              { type: 'dsa', data: E.algorithm.params }
            );
          default:
            throw new Error('unknown key id ' + A);
        }
      case 'ENCRYPTED PRIVATE KEY':
        (_ = i.EncryptedPrivateKey.decode(_, 'der')), (_ = f(_, y));
      case 'PRIVATE KEY':
        switch (((E = i.PrivateKey.decode(_, 'der')), (A = E.algorithm.algorithm.join('.')), A)) {
          case '1.2.840.113549.1.1.1':
            return i.RSAPrivateKey.decode(E.subjectPrivateKey, 'der');
          case '1.2.840.10045.2.1':
            return {
              curve: E.algorithm.curve,
              privateKey: i.ECPrivateKey.decode(E.subjectPrivateKey, 'der').privateKey,
            };
          case '1.2.840.10040.4.1':
            return (
              (E.algorithm.params.priv_key = i.DSAparam.decode(E.subjectPrivateKey, 'der')),
              { type: 'dsa', params: E.algorithm.params }
            );
          default:
            throw new Error('unknown key id ' + A);
        }
      case 'RSA PUBLIC KEY':
        return i.RSAPublicKey.decode(_, 'der');
      case 'RSA PRIVATE KEY':
        return i.RSAPrivateKey.decode(_, 'der');
      case 'DSA PRIVATE KEY':
        return { type: 'dsa', params: i.DSAPrivateKey.decode(_, 'der') };
      case 'EC PRIVATE KEY':
        return (
          (_ = i.ECPrivateKey.decode(_, 'der')),
          { curve: _.parameters.value, privateKey: _.privateKey }
        );
      default:
        throw new Error('unknown key type ' + m);
    }
  }
  c.signature = i.signature;
  function f(h, y) {
    var p = h.algorithm.decrypt.kde.kdeparams.salt,
      m = parseInt(h.algorithm.decrypt.kde.kdeparams.iters.toString(), 10),
      _ = e[h.algorithm.decrypt.cipher.algo.join('.')],
      A = h.algorithm.decrypt.cipher.iv,
      E = h.subjectPrivateKey,
      I = parseInt(_.split('-')[1], 10) / 8,
      R = s.pbkdf2Sync(y, p, m, I, 'sha1'),
      L = r.createDecipheriv(_, R, A),
      D = [];
    return D.push(L.update(E)), D.push(L.final()), n.concat(D);
  }
  return C0;
}
const T8 = {
  '1.3.132.0.10': 'secp256k1',
  '1.3.132.0.33': 'p224',
  '1.2.840.10045.3.1.1': 'p192',
  '1.2.840.10045.3.1.7': 'p256',
  '1.3.132.0.34': 'p384',
  '1.3.132.0.35': 'p521',
};
var bm;
function Dx() {
  if (bm) return uu.exports;
  bm = 1;
  var i = At.Buffer,
    e = D6(),
    t = fy(),
    r = hy().ec,
    s = Ko(),
    n = $l(),
    c = T8,
    f = 1;
  function h(L, D, q, H, V) {
    var te = n(D);
    if (te.curve) {
      if (H !== 'ecdsa' && H !== 'ecdsa/rsa') throw new Error('wrong private key type');
      return y(L, te);
    } else if (te.type === 'dsa') {
      if (H !== 'dsa') throw new Error('wrong private key type');
      return p(L, te, q);
    }
    if (H !== 'rsa' && H !== 'ecdsa/rsa') throw new Error('wrong private key type');
    if (D.padding !== void 0 && D.padding !== f)
      throw new Error('illegal or unsupported padding mode');
    L = i.concat([V, L]);
    for (var ue = te.modulus.byteLength(), ne = [0, 1]; L.length + ne.length + 1 < ue; )
      ne.push(255);
    ne.push(0);
    for (var X = -1; ++X < L.length; ) ne.push(L[X]);
    var Oe = t(ne, te);
    return Oe;
  }
  function y(L, D) {
    var q = c[D.curve.join('.')];
    if (!q) throw new Error('unknown curve ' + D.curve.join('.'));
    var H = new r(q),
      V = H.keyFromPrivate(D.privateKey),
      te = V.sign(L);
    return i.from(te.toDER());
  }
  function p(L, D, q) {
    for (
      var H = D.params.priv_key,
        V = D.params.p,
        te = D.params.q,
        ue = D.params.g,
        ne = new s(0),
        X,
        Oe = A(L, te).mod(te),
        S = !1,
        o = _(H, te, L, q);
      S === !1;

    )
      (X = I(te, o, q)),
        (ne = R(ue, X, V, te)),
        (S = X.invm(te)
          .imul(Oe.add(H.mul(ne)))
          .mod(te)),
        S.cmpn(0) === 0 && ((S = !1), (ne = new s(0)));
    return m(ne, S);
  }
  function m(L, D) {
    (L = L.toArray()),
      (D = D.toArray()),
      L[0] & 128 && (L = [0].concat(L)),
      D[0] & 128 && (D = [0].concat(D));
    var q = L.length + D.length + 4,
      H = [48, q, 2, L.length];
    return (H = H.concat(L, [2, D.length], D)), i.from(H);
  }
  function _(L, D, q, H) {
    if (((L = i.from(L.toArray())), L.length < D.byteLength())) {
      var V = i.alloc(D.byteLength() - L.length);
      L = i.concat([V, L]);
    }
    var te = q.length,
      ue = E(q, D),
      ne = i.alloc(te);
    ne.fill(1);
    var X = i.alloc(te);
    return (
      (X = e(H, X)
        .update(ne)
        .update(i.from([0]))
        .update(L)
        .update(ue)
        .digest()),
      (ne = e(H, X).update(ne).digest()),
      (X = e(H, X)
        .update(ne)
        .update(i.from([1]))
        .update(L)
        .update(ue)
        .digest()),
      (ne = e(H, X).update(ne).digest()),
      { k: X, v: ne }
    );
  }
  function A(L, D) {
    var q = new s(L),
      H = (L.length << 3) - D.bitLength();
    return H > 0 && q.ishrn(H), q;
  }
  function E(L, D) {
    (L = A(L, D)), (L = L.mod(D));
    var q = i.from(L.toArray());
    if (q.length < D.byteLength()) {
      var H = i.alloc(D.byteLength() - q.length);
      q = i.concat([H, q]);
    }
    return q;
  }
  function I(L, D, q) {
    var H, V;
    do {
      for (H = i.alloc(0); H.length * 8 < L.bitLength(); )
        (D.v = e(q, D.k).update(D.v).digest()), (H = i.concat([H, D.v]));
      (V = A(H, L)),
        (D.k = e(q, D.k)
          .update(D.v)
          .update(i.from([0]))
          .digest()),
        (D.v = e(q, D.k).update(D.v).digest());
    } while (V.cmp(L) !== -1);
    return V;
  }
  function R(L, D, q, H) {
    return L.toRed(s.mont(q)).redPow(D).fromRed().mod(H);
  }
  return (uu.exports = h), (uu.exports.getKey = _), (uu.exports.makeKey = I), uu.exports;
}
var L0, vm;
function Ux() {
  if (vm) return L0;
  vm = 1;
  var i = At.Buffer,
    e = Ko(),
    t = hy().ec,
    r = $l(),
    s = T8;
  function n(y, p, m, _, A) {
    var E = r(m);
    if (E.type === 'ec') {
      if (_ !== 'ecdsa' && _ !== 'ecdsa/rsa') throw new Error('wrong public key type');
      return c(y, p, E);
    } else if (E.type === 'dsa') {
      if (_ !== 'dsa') throw new Error('wrong public key type');
      return f(y, p, E);
    }
    if (_ !== 'rsa' && _ !== 'ecdsa/rsa') throw new Error('wrong public key type');
    p = i.concat([A, p]);
    for (var I = E.modulus.byteLength(), R = [1], L = 0; p.length + R.length + 2 < I; )
      R.push(255), (L += 1);
    R.push(0);
    for (var D = -1; ++D < p.length; ) R.push(p[D]);
    R = i.from(R);
    var q = e.mont(E.modulus);
    (y = new e(y).toRed(q)),
      (y = y.redPow(new e(E.publicExponent))),
      (y = i.from(y.fromRed().toArray()));
    var H = L < 8 ? 1 : 0;
    for (I = Math.min(y.length, R.length), y.length !== R.length && (H = 1), D = -1; ++D < I; )
      H |= y[D] ^ R[D];
    return H === 0;
  }
  function c(y, p, m) {
    var _ = s[m.data.algorithm.curve.join('.')];
    if (!_) throw new Error('unknown curve ' + m.data.algorithm.curve.join('.'));
    var A = new t(_),
      E = m.data.subjectPrivateKey.data;
    return A.verify(p, y, E);
  }
  function f(y, p, m) {
    var _ = m.data.p,
      A = m.data.q,
      E = m.data.g,
      I = m.data.pub_key,
      R = r.signature.decode(y, 'der'),
      L = R.s,
      D = R.r;
    h(L, A), h(D, A);
    var q = e.mont(_),
      H = L.invm(A),
      V = E.toRed(q)
        .redPow(new e(p).mul(H).mod(A))
        .fromRed()
        .mul(I.toRed(q).redPow(D.mul(H).mod(A)).fromRed())
        .mod(_)
        .mod(A);
    return V.cmp(D) === 0;
  }
  function h(y, p) {
    if (y.cmpn(0) <= 0) throw new Error('invalid sig');
    if (y.cmp(p) >= 0) throw new Error('invalid sig');
  }
  return (L0 = n), L0;
}
var N0, mm;
function zx() {
  if (mm) return N0;
  mm = 1;
  var i = At.Buffer,
    e = tc,
    t = Rk(),
    r = dt,
    s = Dx(),
    n = Ux(),
    c = U6;
  Object.keys(c).forEach(function (m) {
    (c[m].id = i.from(c[m].id, 'hex')), (c[m.toLowerCase()] = c[m]);
  });
  function f(m) {
    t.Writable.call(this);
    var _ = c[m];
    if (!_) throw new Error('Unknown message digest');
    (this._hashType = _.hash),
      (this._hash = e(_.hash)),
      (this._tag = _.id),
      (this._signType = _.sign);
  }
  r(f, t.Writable),
    (f.prototype._write = function (_, A, E) {
      this._hash.update(_), E();
    }),
    (f.prototype.update = function (_, A) {
      return this._hash.update(typeof _ == 'string' ? i.from(_, A) : _), this;
    }),
    (f.prototype.sign = function (_, A) {
      this.end();
      var E = this._hash.digest(),
        I = s(E, _, this._hashType, this._signType, this._tag);
      return A ? I.toString(A) : I;
    });
  function h(m) {
    t.Writable.call(this);
    var _ = c[m];
    if (!_) throw new Error('Unknown message digest');
    (this._hash = e(_.hash)), (this._tag = _.id), (this._signType = _.sign);
  }
  r(h, t.Writable),
    (h.prototype._write = function (_, A, E) {
      this._hash.update(_), E();
    }),
    (h.prototype.update = function (_, A) {
      return this._hash.update(typeof _ == 'string' ? i.from(_, A) : _), this;
    }),
    (h.prototype.verify = function (_, A, E) {
      var I = typeof A == 'string' ? i.from(A, E) : A;
      this.end();
      var R = this._hash.digest();
      return n(I, R, _, this._signType, this._tag);
    });
  function y(m) {
    return new f(m);
  }
  function p(m) {
    return new h(m);
  }
  return (N0 = { Sign: y, Verify: p, createSign: y, createVerify: p }), N0;
}
var Mf = { exports: {} };
Mf.exports;
var wm;
function Fx() {
  return (
    wm ||
      ((wm = 1),
      (function (i) {
        (function (e, t) {
          function r(S, o) {
            if (!S) throw new Error(o || 'Assertion failed');
          }
          function s(S, o) {
            S.super_ = o;
            var u = function () {};
            (u.prototype = o.prototype), (S.prototype = new u()), (S.prototype.constructor = S);
          }
          function n(S, o, u) {
            if (n.isBN(S)) return S;
            (this.negative = 0),
              (this.words = null),
              (this.length = 0),
              (this.red = null),
              S !== null &&
                ((o === 'le' || o === 'be') && ((u = o), (o = 10)),
                this._init(S || 0, o || 10, u || 'be'));
          }
          typeof e == 'object' ? (e.exports = n) : (t.BN = n), (n.BN = n), (n.wordSize = 26);
          var c;
          try {
            typeof window < 'u' && typeof window.Buffer < 'u'
              ? (c = window.Buffer)
              : (c = ai.Buffer);
          } catch {}
          (n.isBN = function (o) {
            return o instanceof n
              ? !0
              : o !== null &&
                  typeof o == 'object' &&
                  o.constructor.wordSize === n.wordSize &&
                  Array.isArray(o.words);
          }),
            (n.max = function (o, u) {
              return o.cmp(u) > 0 ? o : u;
            }),
            (n.min = function (o, u) {
              return o.cmp(u) < 0 ? o : u;
            }),
            (n.prototype._init = function (o, u, l) {
              if (typeof o == 'number') return this._initNumber(o, u, l);
              if (typeof o == 'object') return this._initArray(o, u, l);
              u === 'hex' && (u = 16),
                r(u === (u | 0) && u >= 2 && u <= 36),
                (o = o.toString().replace(/\s+/g, ''));
              var d = 0;
              o[0] === '-' && (d++, (this.negative = 1)),
                d < o.length &&
                  (u === 16
                    ? this._parseHex(o, d, l)
                    : (this._parseBase(o, u, d),
                      l === 'le' && this._initArray(this.toArray(), u, l)));
            }),
            (n.prototype._initNumber = function (o, u, l) {
              o < 0 && ((this.negative = 1), (o = -o)),
                o < 67108864
                  ? ((this.words = [o & 67108863]), (this.length = 1))
                  : o < 4503599627370496
                    ? ((this.words = [o & 67108863, (o / 67108864) & 67108863]), (this.length = 2))
                    : (r(o < 9007199254740992),
                      (this.words = [o & 67108863, (o / 67108864) & 67108863, 1]),
                      (this.length = 3)),
                l === 'le' && this._initArray(this.toArray(), u, l);
            }),
            (n.prototype._initArray = function (o, u, l) {
              if ((r(typeof o.length == 'number'), o.length <= 0))
                return (this.words = [0]), (this.length = 1), this;
              (this.length = Math.ceil(o.length / 3)), (this.words = new Array(this.length));
              for (var d = 0; d < this.length; d++) this.words[d] = 0;
              var g,
                w,
                M = 0;
              if (l === 'be')
                for (d = o.length - 1, g = 0; d >= 0; d -= 3)
                  (w = o[d] | (o[d - 1] << 8) | (o[d - 2] << 16)),
                    (this.words[g] |= (w << M) & 67108863),
                    (this.words[g + 1] = (w >>> (26 - M)) & 67108863),
                    (M += 24),
                    M >= 26 && ((M -= 26), g++);
              else if (l === 'le')
                for (d = 0, g = 0; d < o.length; d += 3)
                  (w = o[d] | (o[d + 1] << 8) | (o[d + 2] << 16)),
                    (this.words[g] |= (w << M) & 67108863),
                    (this.words[g + 1] = (w >>> (26 - M)) & 67108863),
                    (M += 24),
                    M >= 26 && ((M -= 26), g++);
              return this.strip();
            });
          function f(S, o) {
            var u = S.charCodeAt(o);
            return u >= 65 && u <= 70 ? u - 55 : u >= 97 && u <= 102 ? u - 87 : (u - 48) & 15;
          }
          function h(S, o, u) {
            var l = f(S, u);
            return u - 1 >= o && (l |= f(S, u - 1) << 4), l;
          }
          n.prototype._parseHex = function (o, u, l) {
            (this.length = Math.ceil((o.length - u) / 6)), (this.words = new Array(this.length));
            for (var d = 0; d < this.length; d++) this.words[d] = 0;
            var g = 0,
              w = 0,
              M;
            if (l === 'be')
              for (d = o.length - 1; d >= u; d -= 2)
                (M = h(o, u, d) << g),
                  (this.words[w] |= M & 67108863),
                  g >= 18 ? ((g -= 18), (w += 1), (this.words[w] |= M >>> 26)) : (g += 8);
            else {
              var v = o.length - u;
              for (d = v % 2 === 0 ? u + 1 : u; d < o.length; d += 2)
                (M = h(o, u, d) << g),
                  (this.words[w] |= M & 67108863),
                  g >= 18 ? ((g -= 18), (w += 1), (this.words[w] |= M >>> 26)) : (g += 8);
            }
            this.strip();
          };
          function y(S, o, u, l) {
            for (var d = 0, g = Math.min(S.length, u), w = o; w < g; w++) {
              var M = S.charCodeAt(w) - 48;
              (d *= l), M >= 49 ? (d += M - 49 + 10) : M >= 17 ? (d += M - 17 + 10) : (d += M);
            }
            return d;
          }
          (n.prototype._parseBase = function (o, u, l) {
            (this.words = [0]), (this.length = 1);
            for (var d = 0, g = 1; g <= 67108863; g *= u) d++;
            d--, (g = (g / u) | 0);
            for (
              var w = o.length - l, M = w % d, v = Math.min(w, w - M) + l, a = 0, b = l;
              b < v;
              b += d
            )
              (a = y(o, b, b + d, u)),
                this.imuln(g),
                this.words[0] + a < 67108864 ? (this.words[0] += a) : this._iaddn(a);
            if (M !== 0) {
              var k = 1;
              for (a = y(o, b, o.length, u), b = 0; b < M; b++) k *= u;
              this.imuln(k), this.words[0] + a < 67108864 ? (this.words[0] += a) : this._iaddn(a);
            }
            this.strip();
          }),
            (n.prototype.copy = function (o) {
              o.words = new Array(this.length);
              for (var u = 0; u < this.length; u++) o.words[u] = this.words[u];
              (o.length = this.length), (o.negative = this.negative), (o.red = this.red);
            }),
            (n.prototype.clone = function () {
              var o = new n(null);
              return this.copy(o), o;
            }),
            (n.prototype._expand = function (o) {
              for (; this.length < o; ) this.words[this.length++] = 0;
              return this;
            }),
            (n.prototype.strip = function () {
              for (; this.length > 1 && this.words[this.length - 1] === 0; ) this.length--;
              return this._normSign();
            }),
            (n.prototype._normSign = function () {
              return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
            }),
            (n.prototype.inspect = function () {
              return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
            });
          var p = [
              '',
              '0',
              '00',
              '000',
              '0000',
              '00000',
              '000000',
              '0000000',
              '00000000',
              '000000000',
              '0000000000',
              '00000000000',
              '000000000000',
              '0000000000000',
              '00000000000000',
              '000000000000000',
              '0000000000000000',
              '00000000000000000',
              '000000000000000000',
              '0000000000000000000',
              '00000000000000000000',
              '000000000000000000000',
              '0000000000000000000000',
              '00000000000000000000000',
              '000000000000000000000000',
              '0000000000000000000000000',
            ],
            m = [
              0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5,
              5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            ],
            _ = [
              0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721,
              1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224,
              47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907,
              17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176,
            ];
          (n.prototype.toString = function (o, u) {
            (o = o || 10), (u = u | 0 || 1);
            var l;
            if (o === 16 || o === 'hex') {
              l = '';
              for (var d = 0, g = 0, w = 0; w < this.length; w++) {
                var M = this.words[w],
                  v = (((M << d) | g) & 16777215).toString(16);
                (g = (M >>> (24 - d)) & 16777215),
                  g !== 0 || w !== this.length - 1 ? (l = p[6 - v.length] + v + l) : (l = v + l),
                  (d += 2),
                  d >= 26 && ((d -= 26), w--);
              }
              for (g !== 0 && (l = g.toString(16) + l); l.length % u !== 0; ) l = '0' + l;
              return this.negative !== 0 && (l = '-' + l), l;
            }
            if (o === (o | 0) && o >= 2 && o <= 36) {
              var a = m[o],
                b = _[o];
              l = '';
              var k = this.clone();
              for (k.negative = 0; !k.isZero(); ) {
                var B = k.modn(b).toString(o);
                (k = k.idivn(b)), k.isZero() ? (l = B + l) : (l = p[a - B.length] + B + l);
              }
              for (this.isZero() && (l = '0' + l); l.length % u !== 0; ) l = '0' + l;
              return this.negative !== 0 && (l = '-' + l), l;
            }
            r(!1, 'Base should be between 2 and 36');
          }),
            (n.prototype.toNumber = function () {
              var o = this.words[0];
              return (
                this.length === 2
                  ? (o += this.words[1] * 67108864)
                  : this.length === 3 && this.words[2] === 1
                    ? (o += 4503599627370496 + this.words[1] * 67108864)
                    : this.length > 2 && r(!1, 'Number can only safely store up to 53 bits'),
                this.negative !== 0 ? -o : o
              );
            }),
            (n.prototype.toJSON = function () {
              return this.toString(16);
            }),
            (n.prototype.toBuffer = function (o, u) {
              return r(typeof c < 'u'), this.toArrayLike(c, o, u);
            }),
            (n.prototype.toArray = function (o, u) {
              return this.toArrayLike(Array, o, u);
            }),
            (n.prototype.toArrayLike = function (o, u, l) {
              var d = this.byteLength(),
                g = l || Math.max(1, d);
              r(d <= g, 'byte array longer than desired length'),
                r(g > 0, 'Requested array length <= 0'),
                this.strip();
              var w = u === 'le',
                M = new o(g),
                v,
                a,
                b = this.clone();
              if (w) {
                for (a = 0; !b.isZero(); a++) (v = b.andln(255)), b.iushrn(8), (M[a] = v);
                for (; a < g; a++) M[a] = 0;
              } else {
                for (a = 0; a < g - d; a++) M[a] = 0;
                for (a = 0; !b.isZero(); a++) (v = b.andln(255)), b.iushrn(8), (M[g - a - 1] = v);
              }
              return M;
            }),
            Math.clz32
              ? (n.prototype._countBits = function (o) {
                  return 32 - Math.clz32(o);
                })
              : (n.prototype._countBits = function (o) {
                  var u = o,
                    l = 0;
                  return (
                    u >= 4096 && ((l += 13), (u >>>= 13)),
                    u >= 64 && ((l += 7), (u >>>= 7)),
                    u >= 8 && ((l += 4), (u >>>= 4)),
                    u >= 2 && ((l += 2), (u >>>= 2)),
                    l + u
                  );
                }),
            (n.prototype._zeroBits = function (o) {
              if (o === 0) return 26;
              var u = o,
                l = 0;
              return (
                u & 8191 || ((l += 13), (u >>>= 13)),
                u & 127 || ((l += 7), (u >>>= 7)),
                u & 15 || ((l += 4), (u >>>= 4)),
                u & 3 || ((l += 2), (u >>>= 2)),
                u & 1 || l++,
                l
              );
            }),
            (n.prototype.bitLength = function () {
              var o = this.words[this.length - 1],
                u = this._countBits(o);
              return (this.length - 1) * 26 + u;
            });
          function A(S) {
            for (var o = new Array(S.bitLength()), u = 0; u < o.length; u++) {
              var l = (u / 26) | 0,
                d = u % 26;
              o[u] = (S.words[l] & (1 << d)) >>> d;
            }
            return o;
          }
          (n.prototype.zeroBits = function () {
            if (this.isZero()) return 0;
            for (var o = 0, u = 0; u < this.length; u++) {
              var l = this._zeroBits(this.words[u]);
              if (((o += l), l !== 26)) break;
            }
            return o;
          }),
            (n.prototype.byteLength = function () {
              return Math.ceil(this.bitLength() / 8);
            }),
            (n.prototype.toTwos = function (o) {
              return this.negative !== 0 ? this.abs().inotn(o).iaddn(1) : this.clone();
            }),
            (n.prototype.fromTwos = function (o) {
              return this.testn(o - 1) ? this.notn(o).iaddn(1).ineg() : this.clone();
            }),
            (n.prototype.isNeg = function () {
              return this.negative !== 0;
            }),
            (n.prototype.neg = function () {
              return this.clone().ineg();
            }),
            (n.prototype.ineg = function () {
              return this.isZero() || (this.negative ^= 1), this;
            }),
            (n.prototype.iuor = function (o) {
              for (; this.length < o.length; ) this.words[this.length++] = 0;
              for (var u = 0; u < o.length; u++) this.words[u] = this.words[u] | o.words[u];
              return this.strip();
            }),
            (n.prototype.ior = function (o) {
              return r((this.negative | o.negative) === 0), this.iuor(o);
            }),
            (n.prototype.or = function (o) {
              return this.length > o.length ? this.clone().ior(o) : o.clone().ior(this);
            }),
            (n.prototype.uor = function (o) {
              return this.length > o.length ? this.clone().iuor(o) : o.clone().iuor(this);
            }),
            (n.prototype.iuand = function (o) {
              var u;
              this.length > o.length ? (u = o) : (u = this);
              for (var l = 0; l < u.length; l++) this.words[l] = this.words[l] & o.words[l];
              return (this.length = u.length), this.strip();
            }),
            (n.prototype.iand = function (o) {
              return r((this.negative | o.negative) === 0), this.iuand(o);
            }),
            (n.prototype.and = function (o) {
              return this.length > o.length ? this.clone().iand(o) : o.clone().iand(this);
            }),
            (n.prototype.uand = function (o) {
              return this.length > o.length ? this.clone().iuand(o) : o.clone().iuand(this);
            }),
            (n.prototype.iuxor = function (o) {
              var u, l;
              this.length > o.length ? ((u = this), (l = o)) : ((u = o), (l = this));
              for (var d = 0; d < l.length; d++) this.words[d] = u.words[d] ^ l.words[d];
              if (this !== u) for (; d < u.length; d++) this.words[d] = u.words[d];
              return (this.length = u.length), this.strip();
            }),
            (n.prototype.ixor = function (o) {
              return r((this.negative | o.negative) === 0), this.iuxor(o);
            }),
            (n.prototype.xor = function (o) {
              return this.length > o.length ? this.clone().ixor(o) : o.clone().ixor(this);
            }),
            (n.prototype.uxor = function (o) {
              return this.length > o.length ? this.clone().iuxor(o) : o.clone().iuxor(this);
            }),
            (n.prototype.inotn = function (o) {
              r(typeof o == 'number' && o >= 0);
              var u = Math.ceil(o / 26) | 0,
                l = o % 26;
              this._expand(u), l > 0 && u--;
              for (var d = 0; d < u; d++) this.words[d] = ~this.words[d] & 67108863;
              return (
                l > 0 && (this.words[d] = ~this.words[d] & (67108863 >> (26 - l))), this.strip()
              );
            }),
            (n.prototype.notn = function (o) {
              return this.clone().inotn(o);
            }),
            (n.prototype.setn = function (o, u) {
              r(typeof o == 'number' && o >= 0);
              var l = (o / 26) | 0,
                d = o % 26;
              return (
                this._expand(l + 1),
                u
                  ? (this.words[l] = this.words[l] | (1 << d))
                  : (this.words[l] = this.words[l] & ~(1 << d)),
                this.strip()
              );
            }),
            (n.prototype.iadd = function (o) {
              var u;
              if (this.negative !== 0 && o.negative === 0)
                return (
                  (this.negative = 0), (u = this.isub(o)), (this.negative ^= 1), this._normSign()
                );
              if (this.negative === 0 && o.negative !== 0)
                return (o.negative = 0), (u = this.isub(o)), (o.negative = 1), u._normSign();
              var l, d;
              this.length > o.length ? ((l = this), (d = o)) : ((l = o), (d = this));
              for (var g = 0, w = 0; w < d.length; w++)
                (u = (l.words[w] | 0) + (d.words[w] | 0) + g),
                  (this.words[w] = u & 67108863),
                  (g = u >>> 26);
              for (; g !== 0 && w < l.length; w++)
                (u = (l.words[w] | 0) + g), (this.words[w] = u & 67108863), (g = u >>> 26);
              if (((this.length = l.length), g !== 0)) (this.words[this.length] = g), this.length++;
              else if (l !== this) for (; w < l.length; w++) this.words[w] = l.words[w];
              return this;
            }),
            (n.prototype.add = function (o) {
              var u;
              return o.negative !== 0 && this.negative === 0
                ? ((o.negative = 0), (u = this.sub(o)), (o.negative ^= 1), u)
                : o.negative === 0 && this.negative !== 0
                  ? ((this.negative = 0), (u = o.sub(this)), (this.negative = 1), u)
                  : this.length > o.length
                    ? this.clone().iadd(o)
                    : o.clone().iadd(this);
            }),
            (n.prototype.isub = function (o) {
              if (o.negative !== 0) {
                o.negative = 0;
                var u = this.iadd(o);
                return (o.negative = 1), u._normSign();
              } else if (this.negative !== 0)
                return (this.negative = 0), this.iadd(o), (this.negative = 1), this._normSign();
              var l = this.cmp(o);
              if (l === 0) return (this.negative = 0), (this.length = 1), (this.words[0] = 0), this;
              var d, g;
              l > 0 ? ((d = this), (g = o)) : ((d = o), (g = this));
              for (var w = 0, M = 0; M < g.length; M++)
                (u = (d.words[M] | 0) - (g.words[M] | 0) + w),
                  (w = u >> 26),
                  (this.words[M] = u & 67108863);
              for (; w !== 0 && M < d.length; M++)
                (u = (d.words[M] | 0) + w), (w = u >> 26), (this.words[M] = u & 67108863);
              if (w === 0 && M < d.length && d !== this)
                for (; M < d.length; M++) this.words[M] = d.words[M];
              return (
                (this.length = Math.max(this.length, M)),
                d !== this && (this.negative = 1),
                this.strip()
              );
            }),
            (n.prototype.sub = function (o) {
              return this.clone().isub(o);
            });
          function E(S, o, u) {
            u.negative = o.negative ^ S.negative;
            var l = (S.length + o.length) | 0;
            (u.length = l), (l = (l - 1) | 0);
            var d = S.words[0] | 0,
              g = o.words[0] | 0,
              w = d * g,
              M = w & 67108863,
              v = (w / 67108864) | 0;
            u.words[0] = M;
            for (var a = 1; a < l; a++) {
              for (
                var b = v >>> 26,
                  k = v & 67108863,
                  B = Math.min(a, o.length - 1),
                  F = Math.max(0, a - S.length + 1);
                F <= B;
                F++
              ) {
                var P = (a - F) | 0;
                (d = S.words[P] | 0),
                  (g = o.words[F] | 0),
                  (w = d * g + k),
                  (b += (w / 67108864) | 0),
                  (k = w & 67108863);
              }
              (u.words[a] = k | 0), (v = b | 0);
            }
            return v !== 0 ? (u.words[a] = v | 0) : u.length--, u.strip();
          }
          var I = function (o, u, l) {
            var d = o.words,
              g = u.words,
              w = l.words,
              M = 0,
              v,
              a,
              b,
              k = d[0] | 0,
              B = k & 8191,
              F = k >>> 13,
              P = d[1] | 0,
              C = P & 8191,
              z = P >>> 13,
              Y = d[2] | 0,
              G = Y & 8191,
              Q = Y >>> 13,
              U = d[3] | 0,
              $ = U & 8191,
              Z = U >>> 13,
              ae = d[4] | 0,
              fe = ae & 8191,
              le = ae >>> 13,
              Fe = d[5] | 0,
              be = Fe & 8191,
              oe = Fe >>> 13,
              rt = d[6] | 0,
              me = rt & 8191,
              re = rt >>> 13,
              ge = d[7] | 0,
              ce = ge & 8191,
              he = ge >>> 13,
              Ke = d[8] | 0,
              K = Ke & 8191,
              O = Ke >>> 13,
              W = d[9] | 0,
              T = W & 8191,
              x = W >>> 13,
              N = g[0] | 0,
              j = N & 8191,
              J = N >>> 13,
              de = g[1] | 0,
              ie = de & 8191,
              ye = de >>> 13,
              Ye = g[2] | 0,
              ve = Ye & 8191,
              _e = Ye >>> 13,
              et = g[3] | 0,
              Me = et & 8191,
              Ce = et >>> 13,
              yt = g[4] | 0,
              Ae = yt & 8191,
              Le = yt >>> 13,
              gt = g[5] | 0,
              Ee = gt & 8191,
              Ne = gt >>> 13,
              bt = g[6] | 0,
              ke = bt & 8191,
              $e = bt >>> 13,
              vt = g[7] | 0,
              Ie = vt & 8191,
              De = vt >>> 13,
              mt = g[8] | 0,
              xe = mt & 8191,
              Ue = mt >>> 13,
              wt = g[9] | 0,
              Be = wt & 8191,
              ze = wt >>> 13;
            (l.negative = o.negative ^ u.negative),
              (l.length = 19),
              (v = Math.imul(B, j)),
              (a = Math.imul(B, J)),
              (a = (a + Math.imul(F, j)) | 0),
              (b = Math.imul(F, J));
            var st = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (st >>> 26)) | 0),
              (st &= 67108863),
              (v = Math.imul(C, j)),
              (a = Math.imul(C, J)),
              (a = (a + Math.imul(z, j)) | 0),
              (b = Math.imul(z, J)),
              (v = (v + Math.imul(B, ie)) | 0),
              (a = (a + Math.imul(B, ye)) | 0),
              (a = (a + Math.imul(F, ie)) | 0),
              (b = (b + Math.imul(F, ye)) | 0);
            var at = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (at >>> 26)) | 0),
              (at &= 67108863),
              (v = Math.imul(G, j)),
              (a = Math.imul(G, J)),
              (a = (a + Math.imul(Q, j)) | 0),
              (b = Math.imul(Q, J)),
              (v = (v + Math.imul(C, ie)) | 0),
              (a = (a + Math.imul(C, ye)) | 0),
              (a = (a + Math.imul(z, ie)) | 0),
              (b = (b + Math.imul(z, ye)) | 0),
              (v = (v + Math.imul(B, ve)) | 0),
              (a = (a + Math.imul(B, _e)) | 0),
              (a = (a + Math.imul(F, ve)) | 0),
              (b = (b + Math.imul(F, _e)) | 0);
            var Ft = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (Ft >>> 26)) | 0),
              (Ft &= 67108863),
              (v = Math.imul($, j)),
              (a = Math.imul($, J)),
              (a = (a + Math.imul(Z, j)) | 0),
              (b = Math.imul(Z, J)),
              (v = (v + Math.imul(G, ie)) | 0),
              (a = (a + Math.imul(G, ye)) | 0),
              (a = (a + Math.imul(Q, ie)) | 0),
              (b = (b + Math.imul(Q, ye)) | 0),
              (v = (v + Math.imul(C, ve)) | 0),
              (a = (a + Math.imul(C, _e)) | 0),
              (a = (a + Math.imul(z, ve)) | 0),
              (b = (b + Math.imul(z, _e)) | 0),
              (v = (v + Math.imul(B, Me)) | 0),
              (a = (a + Math.imul(B, Ce)) | 0),
              (a = (a + Math.imul(F, Me)) | 0),
              (b = (b + Math.imul(F, Ce)) | 0);
            var qt = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (qt >>> 26)) | 0),
              (qt &= 67108863),
              (v = Math.imul(fe, j)),
              (a = Math.imul(fe, J)),
              (a = (a + Math.imul(le, j)) | 0),
              (b = Math.imul(le, J)),
              (v = (v + Math.imul($, ie)) | 0),
              (a = (a + Math.imul($, ye)) | 0),
              (a = (a + Math.imul(Z, ie)) | 0),
              (b = (b + Math.imul(Z, ye)) | 0),
              (v = (v + Math.imul(G, ve)) | 0),
              (a = (a + Math.imul(G, _e)) | 0),
              (a = (a + Math.imul(Q, ve)) | 0),
              (b = (b + Math.imul(Q, _e)) | 0),
              (v = (v + Math.imul(C, Me)) | 0),
              (a = (a + Math.imul(C, Ce)) | 0),
              (a = (a + Math.imul(z, Me)) | 0),
              (b = (b + Math.imul(z, Ce)) | 0),
              (v = (v + Math.imul(B, Ae)) | 0),
              (a = (a + Math.imul(B, Le)) | 0),
              (a = (a + Math.imul(F, Ae)) | 0),
              (b = (b + Math.imul(F, Le)) | 0);
            var Wt = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (Wt >>> 26)) | 0),
              (Wt &= 67108863),
              (v = Math.imul(be, j)),
              (a = Math.imul(be, J)),
              (a = (a + Math.imul(oe, j)) | 0),
              (b = Math.imul(oe, J)),
              (v = (v + Math.imul(fe, ie)) | 0),
              (a = (a + Math.imul(fe, ye)) | 0),
              (a = (a + Math.imul(le, ie)) | 0),
              (b = (b + Math.imul(le, ye)) | 0),
              (v = (v + Math.imul($, ve)) | 0),
              (a = (a + Math.imul($, _e)) | 0),
              (a = (a + Math.imul(Z, ve)) | 0),
              (b = (b + Math.imul(Z, _e)) | 0),
              (v = (v + Math.imul(G, Me)) | 0),
              (a = (a + Math.imul(G, Ce)) | 0),
              (a = (a + Math.imul(Q, Me)) | 0),
              (b = (b + Math.imul(Q, Ce)) | 0),
              (v = (v + Math.imul(C, Ae)) | 0),
              (a = (a + Math.imul(C, Le)) | 0),
              (a = (a + Math.imul(z, Ae)) | 0),
              (b = (b + Math.imul(z, Le)) | 0),
              (v = (v + Math.imul(B, Ee)) | 0),
              (a = (a + Math.imul(B, Ne)) | 0),
              (a = (a + Math.imul(F, Ee)) | 0),
              (b = (b + Math.imul(F, Ne)) | 0);
            var Kt = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (Kt >>> 26)) | 0),
              (Kt &= 67108863),
              (v = Math.imul(me, j)),
              (a = Math.imul(me, J)),
              (a = (a + Math.imul(re, j)) | 0),
              (b = Math.imul(re, J)),
              (v = (v + Math.imul(be, ie)) | 0),
              (a = (a + Math.imul(be, ye)) | 0),
              (a = (a + Math.imul(oe, ie)) | 0),
              (b = (b + Math.imul(oe, ye)) | 0),
              (v = (v + Math.imul(fe, ve)) | 0),
              (a = (a + Math.imul(fe, _e)) | 0),
              (a = (a + Math.imul(le, ve)) | 0),
              (b = (b + Math.imul(le, _e)) | 0),
              (v = (v + Math.imul($, Me)) | 0),
              (a = (a + Math.imul($, Ce)) | 0),
              (a = (a + Math.imul(Z, Me)) | 0),
              (b = (b + Math.imul(Z, Ce)) | 0),
              (v = (v + Math.imul(G, Ae)) | 0),
              (a = (a + Math.imul(G, Le)) | 0),
              (a = (a + Math.imul(Q, Ae)) | 0),
              (b = (b + Math.imul(Q, Le)) | 0),
              (v = (v + Math.imul(C, Ee)) | 0),
              (a = (a + Math.imul(C, Ne)) | 0),
              (a = (a + Math.imul(z, Ee)) | 0),
              (b = (b + Math.imul(z, Ne)) | 0),
              (v = (v + Math.imul(B, ke)) | 0),
              (a = (a + Math.imul(B, $e)) | 0),
              (a = (a + Math.imul(F, ke)) | 0),
              (b = (b + Math.imul(F, $e)) | 0);
            var jt = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (jt >>> 26)) | 0),
              (jt &= 67108863),
              (v = Math.imul(ce, j)),
              (a = Math.imul(ce, J)),
              (a = (a + Math.imul(he, j)) | 0),
              (b = Math.imul(he, J)),
              (v = (v + Math.imul(me, ie)) | 0),
              (a = (a + Math.imul(me, ye)) | 0),
              (a = (a + Math.imul(re, ie)) | 0),
              (b = (b + Math.imul(re, ye)) | 0),
              (v = (v + Math.imul(be, ve)) | 0),
              (a = (a + Math.imul(be, _e)) | 0),
              (a = (a + Math.imul(oe, ve)) | 0),
              (b = (b + Math.imul(oe, _e)) | 0),
              (v = (v + Math.imul(fe, Me)) | 0),
              (a = (a + Math.imul(fe, Ce)) | 0),
              (a = (a + Math.imul(le, Me)) | 0),
              (b = (b + Math.imul(le, Ce)) | 0),
              (v = (v + Math.imul($, Ae)) | 0),
              (a = (a + Math.imul($, Le)) | 0),
              (a = (a + Math.imul(Z, Ae)) | 0),
              (b = (b + Math.imul(Z, Le)) | 0),
              (v = (v + Math.imul(G, Ee)) | 0),
              (a = (a + Math.imul(G, Ne)) | 0),
              (a = (a + Math.imul(Q, Ee)) | 0),
              (b = (b + Math.imul(Q, Ne)) | 0),
              (v = (v + Math.imul(C, ke)) | 0),
              (a = (a + Math.imul(C, $e)) | 0),
              (a = (a + Math.imul(z, ke)) | 0),
              (b = (b + Math.imul(z, $e)) | 0),
              (v = (v + Math.imul(B, Ie)) | 0),
              (a = (a + Math.imul(B, De)) | 0),
              (a = (a + Math.imul(F, Ie)) | 0),
              (b = (b + Math.imul(F, De)) | 0);
            var fr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (fr >>> 26)) | 0),
              (fr &= 67108863),
              (v = Math.imul(K, j)),
              (a = Math.imul(K, J)),
              (a = (a + Math.imul(O, j)) | 0),
              (b = Math.imul(O, J)),
              (v = (v + Math.imul(ce, ie)) | 0),
              (a = (a + Math.imul(ce, ye)) | 0),
              (a = (a + Math.imul(he, ie)) | 0),
              (b = (b + Math.imul(he, ye)) | 0),
              (v = (v + Math.imul(me, ve)) | 0),
              (a = (a + Math.imul(me, _e)) | 0),
              (a = (a + Math.imul(re, ve)) | 0),
              (b = (b + Math.imul(re, _e)) | 0),
              (v = (v + Math.imul(be, Me)) | 0),
              (a = (a + Math.imul(be, Ce)) | 0),
              (a = (a + Math.imul(oe, Me)) | 0),
              (b = (b + Math.imul(oe, Ce)) | 0),
              (v = (v + Math.imul(fe, Ae)) | 0),
              (a = (a + Math.imul(fe, Le)) | 0),
              (a = (a + Math.imul(le, Ae)) | 0),
              (b = (b + Math.imul(le, Le)) | 0),
              (v = (v + Math.imul($, Ee)) | 0),
              (a = (a + Math.imul($, Ne)) | 0),
              (a = (a + Math.imul(Z, Ee)) | 0),
              (b = (b + Math.imul(Z, Ne)) | 0),
              (v = (v + Math.imul(G, ke)) | 0),
              (a = (a + Math.imul(G, $e)) | 0),
              (a = (a + Math.imul(Q, ke)) | 0),
              (b = (b + Math.imul(Q, $e)) | 0),
              (v = (v + Math.imul(C, Ie)) | 0),
              (a = (a + Math.imul(C, De)) | 0),
              (a = (a + Math.imul(z, Ie)) | 0),
              (b = (b + Math.imul(z, De)) | 0),
              (v = (v + Math.imul(B, xe)) | 0),
              (a = (a + Math.imul(B, Ue)) | 0),
              (a = (a + Math.imul(F, xe)) | 0),
              (b = (b + Math.imul(F, Ue)) | 0);
            var lr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (lr >>> 26)) | 0),
              (lr &= 67108863),
              (v = Math.imul(T, j)),
              (a = Math.imul(T, J)),
              (a = (a + Math.imul(x, j)) | 0),
              (b = Math.imul(x, J)),
              (v = (v + Math.imul(K, ie)) | 0),
              (a = (a + Math.imul(K, ye)) | 0),
              (a = (a + Math.imul(O, ie)) | 0),
              (b = (b + Math.imul(O, ye)) | 0),
              (v = (v + Math.imul(ce, ve)) | 0),
              (a = (a + Math.imul(ce, _e)) | 0),
              (a = (a + Math.imul(he, ve)) | 0),
              (b = (b + Math.imul(he, _e)) | 0),
              (v = (v + Math.imul(me, Me)) | 0),
              (a = (a + Math.imul(me, Ce)) | 0),
              (a = (a + Math.imul(re, Me)) | 0),
              (b = (b + Math.imul(re, Ce)) | 0),
              (v = (v + Math.imul(be, Ae)) | 0),
              (a = (a + Math.imul(be, Le)) | 0),
              (a = (a + Math.imul(oe, Ae)) | 0),
              (b = (b + Math.imul(oe, Le)) | 0),
              (v = (v + Math.imul(fe, Ee)) | 0),
              (a = (a + Math.imul(fe, Ne)) | 0),
              (a = (a + Math.imul(le, Ee)) | 0),
              (b = (b + Math.imul(le, Ne)) | 0),
              (v = (v + Math.imul($, ke)) | 0),
              (a = (a + Math.imul($, $e)) | 0),
              (a = (a + Math.imul(Z, ke)) | 0),
              (b = (b + Math.imul(Z, $e)) | 0),
              (v = (v + Math.imul(G, Ie)) | 0),
              (a = (a + Math.imul(G, De)) | 0),
              (a = (a + Math.imul(Q, Ie)) | 0),
              (b = (b + Math.imul(Q, De)) | 0),
              (v = (v + Math.imul(C, xe)) | 0),
              (a = (a + Math.imul(C, Ue)) | 0),
              (a = (a + Math.imul(z, xe)) | 0),
              (b = (b + Math.imul(z, Ue)) | 0),
              (v = (v + Math.imul(B, Be)) | 0),
              (a = (a + Math.imul(B, ze)) | 0),
              (a = (a + Math.imul(F, Be)) | 0),
              (b = (b + Math.imul(F, ze)) | 0);
            var hr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (hr >>> 26)) | 0),
              (hr &= 67108863),
              (v = Math.imul(T, ie)),
              (a = Math.imul(T, ye)),
              (a = (a + Math.imul(x, ie)) | 0),
              (b = Math.imul(x, ye)),
              (v = (v + Math.imul(K, ve)) | 0),
              (a = (a + Math.imul(K, _e)) | 0),
              (a = (a + Math.imul(O, ve)) | 0),
              (b = (b + Math.imul(O, _e)) | 0),
              (v = (v + Math.imul(ce, Me)) | 0),
              (a = (a + Math.imul(ce, Ce)) | 0),
              (a = (a + Math.imul(he, Me)) | 0),
              (b = (b + Math.imul(he, Ce)) | 0),
              (v = (v + Math.imul(me, Ae)) | 0),
              (a = (a + Math.imul(me, Le)) | 0),
              (a = (a + Math.imul(re, Ae)) | 0),
              (b = (b + Math.imul(re, Le)) | 0),
              (v = (v + Math.imul(be, Ee)) | 0),
              (a = (a + Math.imul(be, Ne)) | 0),
              (a = (a + Math.imul(oe, Ee)) | 0),
              (b = (b + Math.imul(oe, Ne)) | 0),
              (v = (v + Math.imul(fe, ke)) | 0),
              (a = (a + Math.imul(fe, $e)) | 0),
              (a = (a + Math.imul(le, ke)) | 0),
              (b = (b + Math.imul(le, $e)) | 0),
              (v = (v + Math.imul($, Ie)) | 0),
              (a = (a + Math.imul($, De)) | 0),
              (a = (a + Math.imul(Z, Ie)) | 0),
              (b = (b + Math.imul(Z, De)) | 0),
              (v = (v + Math.imul(G, xe)) | 0),
              (a = (a + Math.imul(G, Ue)) | 0),
              (a = (a + Math.imul(Q, xe)) | 0),
              (b = (b + Math.imul(Q, Ue)) | 0),
              (v = (v + Math.imul(C, Be)) | 0),
              (a = (a + Math.imul(C, ze)) | 0),
              (a = (a + Math.imul(z, Be)) | 0),
              (b = (b + Math.imul(z, ze)) | 0);
            var dr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (dr >>> 26)) | 0),
              (dr &= 67108863),
              (v = Math.imul(T, ve)),
              (a = Math.imul(T, _e)),
              (a = (a + Math.imul(x, ve)) | 0),
              (b = Math.imul(x, _e)),
              (v = (v + Math.imul(K, Me)) | 0),
              (a = (a + Math.imul(K, Ce)) | 0),
              (a = (a + Math.imul(O, Me)) | 0),
              (b = (b + Math.imul(O, Ce)) | 0),
              (v = (v + Math.imul(ce, Ae)) | 0),
              (a = (a + Math.imul(ce, Le)) | 0),
              (a = (a + Math.imul(he, Ae)) | 0),
              (b = (b + Math.imul(he, Le)) | 0),
              (v = (v + Math.imul(me, Ee)) | 0),
              (a = (a + Math.imul(me, Ne)) | 0),
              (a = (a + Math.imul(re, Ee)) | 0),
              (b = (b + Math.imul(re, Ne)) | 0),
              (v = (v + Math.imul(be, ke)) | 0),
              (a = (a + Math.imul(be, $e)) | 0),
              (a = (a + Math.imul(oe, ke)) | 0),
              (b = (b + Math.imul(oe, $e)) | 0),
              (v = (v + Math.imul(fe, Ie)) | 0),
              (a = (a + Math.imul(fe, De)) | 0),
              (a = (a + Math.imul(le, Ie)) | 0),
              (b = (b + Math.imul(le, De)) | 0),
              (v = (v + Math.imul($, xe)) | 0),
              (a = (a + Math.imul($, Ue)) | 0),
              (a = (a + Math.imul(Z, xe)) | 0),
              (b = (b + Math.imul(Z, Ue)) | 0),
              (v = (v + Math.imul(G, Be)) | 0),
              (a = (a + Math.imul(G, ze)) | 0),
              (a = (a + Math.imul(Q, Be)) | 0),
              (b = (b + Math.imul(Q, ze)) | 0);
            var pr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (pr >>> 26)) | 0),
              (pr &= 67108863),
              (v = Math.imul(T, Me)),
              (a = Math.imul(T, Ce)),
              (a = (a + Math.imul(x, Me)) | 0),
              (b = Math.imul(x, Ce)),
              (v = (v + Math.imul(K, Ae)) | 0),
              (a = (a + Math.imul(K, Le)) | 0),
              (a = (a + Math.imul(O, Ae)) | 0),
              (b = (b + Math.imul(O, Le)) | 0),
              (v = (v + Math.imul(ce, Ee)) | 0),
              (a = (a + Math.imul(ce, Ne)) | 0),
              (a = (a + Math.imul(he, Ee)) | 0),
              (b = (b + Math.imul(he, Ne)) | 0),
              (v = (v + Math.imul(me, ke)) | 0),
              (a = (a + Math.imul(me, $e)) | 0),
              (a = (a + Math.imul(re, ke)) | 0),
              (b = (b + Math.imul(re, $e)) | 0),
              (v = (v + Math.imul(be, Ie)) | 0),
              (a = (a + Math.imul(be, De)) | 0),
              (a = (a + Math.imul(oe, Ie)) | 0),
              (b = (b + Math.imul(oe, De)) | 0),
              (v = (v + Math.imul(fe, xe)) | 0),
              (a = (a + Math.imul(fe, Ue)) | 0),
              (a = (a + Math.imul(le, xe)) | 0),
              (b = (b + Math.imul(le, Ue)) | 0),
              (v = (v + Math.imul($, Be)) | 0),
              (a = (a + Math.imul($, ze)) | 0),
              (a = (a + Math.imul(Z, Be)) | 0),
              (b = (b + Math.imul(Z, ze)) | 0);
            var yr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (yr >>> 26)) | 0),
              (yr &= 67108863),
              (v = Math.imul(T, Ae)),
              (a = Math.imul(T, Le)),
              (a = (a + Math.imul(x, Ae)) | 0),
              (b = Math.imul(x, Le)),
              (v = (v + Math.imul(K, Ee)) | 0),
              (a = (a + Math.imul(K, Ne)) | 0),
              (a = (a + Math.imul(O, Ee)) | 0),
              (b = (b + Math.imul(O, Ne)) | 0),
              (v = (v + Math.imul(ce, ke)) | 0),
              (a = (a + Math.imul(ce, $e)) | 0),
              (a = (a + Math.imul(he, ke)) | 0),
              (b = (b + Math.imul(he, $e)) | 0),
              (v = (v + Math.imul(me, Ie)) | 0),
              (a = (a + Math.imul(me, De)) | 0),
              (a = (a + Math.imul(re, Ie)) | 0),
              (b = (b + Math.imul(re, De)) | 0),
              (v = (v + Math.imul(be, xe)) | 0),
              (a = (a + Math.imul(be, Ue)) | 0),
              (a = (a + Math.imul(oe, xe)) | 0),
              (b = (b + Math.imul(oe, Ue)) | 0),
              (v = (v + Math.imul(fe, Be)) | 0),
              (a = (a + Math.imul(fe, ze)) | 0),
              (a = (a + Math.imul(le, Be)) | 0),
              (b = (b + Math.imul(le, ze)) | 0);
            var gr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (gr >>> 26)) | 0),
              (gr &= 67108863),
              (v = Math.imul(T, Ee)),
              (a = Math.imul(T, Ne)),
              (a = (a + Math.imul(x, Ee)) | 0),
              (b = Math.imul(x, Ne)),
              (v = (v + Math.imul(K, ke)) | 0),
              (a = (a + Math.imul(K, $e)) | 0),
              (a = (a + Math.imul(O, ke)) | 0),
              (b = (b + Math.imul(O, $e)) | 0),
              (v = (v + Math.imul(ce, Ie)) | 0),
              (a = (a + Math.imul(ce, De)) | 0),
              (a = (a + Math.imul(he, Ie)) | 0),
              (b = (b + Math.imul(he, De)) | 0),
              (v = (v + Math.imul(me, xe)) | 0),
              (a = (a + Math.imul(me, Ue)) | 0),
              (a = (a + Math.imul(re, xe)) | 0),
              (b = (b + Math.imul(re, Ue)) | 0),
              (v = (v + Math.imul(be, Be)) | 0),
              (a = (a + Math.imul(be, ze)) | 0),
              (a = (a + Math.imul(oe, Be)) | 0),
              (b = (b + Math.imul(oe, ze)) | 0);
            var br = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (br >>> 26)) | 0),
              (br &= 67108863),
              (v = Math.imul(T, ke)),
              (a = Math.imul(T, $e)),
              (a = (a + Math.imul(x, ke)) | 0),
              (b = Math.imul(x, $e)),
              (v = (v + Math.imul(K, Ie)) | 0),
              (a = (a + Math.imul(K, De)) | 0),
              (a = (a + Math.imul(O, Ie)) | 0),
              (b = (b + Math.imul(O, De)) | 0),
              (v = (v + Math.imul(ce, xe)) | 0),
              (a = (a + Math.imul(ce, Ue)) | 0),
              (a = (a + Math.imul(he, xe)) | 0),
              (b = (b + Math.imul(he, Ue)) | 0),
              (v = (v + Math.imul(me, Be)) | 0),
              (a = (a + Math.imul(me, ze)) | 0),
              (a = (a + Math.imul(re, Be)) | 0),
              (b = (b + Math.imul(re, ze)) | 0);
            var vr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (vr >>> 26)) | 0),
              (vr &= 67108863),
              (v = Math.imul(T, Ie)),
              (a = Math.imul(T, De)),
              (a = (a + Math.imul(x, Ie)) | 0),
              (b = Math.imul(x, De)),
              (v = (v + Math.imul(K, xe)) | 0),
              (a = (a + Math.imul(K, Ue)) | 0),
              (a = (a + Math.imul(O, xe)) | 0),
              (b = (b + Math.imul(O, Ue)) | 0),
              (v = (v + Math.imul(ce, Be)) | 0),
              (a = (a + Math.imul(ce, ze)) | 0),
              (a = (a + Math.imul(he, Be)) | 0),
              (b = (b + Math.imul(he, ze)) | 0);
            var mr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (mr >>> 26)) | 0),
              (mr &= 67108863),
              (v = Math.imul(T, xe)),
              (a = Math.imul(T, Ue)),
              (a = (a + Math.imul(x, xe)) | 0),
              (b = Math.imul(x, Ue)),
              (v = (v + Math.imul(K, Be)) | 0),
              (a = (a + Math.imul(K, ze)) | 0),
              (a = (a + Math.imul(O, Be)) | 0),
              (b = (b + Math.imul(O, ze)) | 0);
            var wr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (wr >>> 26)) | 0),
              (wr &= 67108863),
              (v = Math.imul(T, Be)),
              (a = Math.imul(T, ze)),
              (a = (a + Math.imul(x, Be)) | 0),
              (b = Math.imul(x, ze));
            var _r = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            return (
              (M = (((b + (a >>> 13)) | 0) + (_r >>> 26)) | 0),
              (_r &= 67108863),
              (w[0] = st),
              (w[1] = at),
              (w[2] = Ft),
              (w[3] = qt),
              (w[4] = Wt),
              (w[5] = Kt),
              (w[6] = jt),
              (w[7] = fr),
              (w[8] = lr),
              (w[9] = hr),
              (w[10] = dr),
              (w[11] = pr),
              (w[12] = yr),
              (w[13] = gr),
              (w[14] = br),
              (w[15] = vr),
              (w[16] = mr),
              (w[17] = wr),
              (w[18] = _r),
              M !== 0 && ((w[19] = M), l.length++),
              l
            );
          };
          Math.imul || (I = E);
          function R(S, o, u) {
            (u.negative = o.negative ^ S.negative), (u.length = S.length + o.length);
            for (var l = 0, d = 0, g = 0; g < u.length - 1; g++) {
              var w = d;
              d = 0;
              for (
                var M = l & 67108863,
                  v = Math.min(g, o.length - 1),
                  a = Math.max(0, g - S.length + 1);
                a <= v;
                a++
              ) {
                var b = g - a,
                  k = S.words[b] | 0,
                  B = o.words[a] | 0,
                  F = k * B,
                  P = F & 67108863;
                (w = (w + ((F / 67108864) | 0)) | 0),
                  (P = (P + M) | 0),
                  (M = P & 67108863),
                  (w = (w + (P >>> 26)) | 0),
                  (d += w >>> 26),
                  (w &= 67108863);
              }
              (u.words[g] = M), (l = w), (w = d);
            }
            return l !== 0 ? (u.words[g] = l) : u.length--, u.strip();
          }
          function L(S, o, u) {
            var l = new D();
            return l.mulp(S, o, u);
          }
          n.prototype.mulTo = function (o, u) {
            var l,
              d = this.length + o.length;
            return (
              this.length === 10 && o.length === 10
                ? (l = I(this, o, u))
                : d < 63
                  ? (l = E(this, o, u))
                  : d < 1024
                    ? (l = R(this, o, u))
                    : (l = L(this, o, u)),
              l
            );
          };
          function D(S, o) {
            (this.x = S), (this.y = o);
          }
          (D.prototype.makeRBT = function (o) {
            for (var u = new Array(o), l = n.prototype._countBits(o) - 1, d = 0; d < o; d++)
              u[d] = this.revBin(d, l, o);
            return u;
          }),
            (D.prototype.revBin = function (o, u, l) {
              if (o === 0 || o === l - 1) return o;
              for (var d = 0, g = 0; g < u; g++) (d |= (o & 1) << (u - g - 1)), (o >>= 1);
              return d;
            }),
            (D.prototype.permute = function (o, u, l, d, g, w) {
              for (var M = 0; M < w; M++) (d[M] = u[o[M]]), (g[M] = l[o[M]]);
            }),
            (D.prototype.transform = function (o, u, l, d, g, w) {
              this.permute(w, o, u, l, d, g);
              for (var M = 1; M < g; M <<= 1)
                for (
                  var v = M << 1,
                    a = Math.cos((2 * Math.PI) / v),
                    b = Math.sin((2 * Math.PI) / v),
                    k = 0;
                  k < g;
                  k += v
                )
                  for (var B = a, F = b, P = 0; P < M; P++) {
                    var C = l[k + P],
                      z = d[k + P],
                      Y = l[k + P + M],
                      G = d[k + P + M],
                      Q = B * Y - F * G;
                    (G = B * G + F * Y),
                      (Y = Q),
                      (l[k + P] = C + Y),
                      (d[k + P] = z + G),
                      (l[k + P + M] = C - Y),
                      (d[k + P + M] = z - G),
                      P !== v && ((Q = a * B - b * F), (F = a * F + b * B), (B = Q));
                  }
            }),
            (D.prototype.guessLen13b = function (o, u) {
              var l = Math.max(u, o) | 1,
                d = l & 1,
                g = 0;
              for (l = (l / 2) | 0; l; l = l >>> 1) g++;
              return 1 << (g + 1 + d);
            }),
            (D.prototype.conjugate = function (o, u, l) {
              if (!(l <= 1))
                for (var d = 0; d < l / 2; d++) {
                  var g = o[d];
                  (o[d] = o[l - d - 1]),
                    (o[l - d - 1] = g),
                    (g = u[d]),
                    (u[d] = -u[l - d - 1]),
                    (u[l - d - 1] = -g);
                }
            }),
            (D.prototype.normalize13b = function (o, u) {
              for (var l = 0, d = 0; d < u / 2; d++) {
                var g = Math.round(o[2 * d + 1] / u) * 8192 + Math.round(o[2 * d] / u) + l;
                (o[d] = g & 67108863), g < 67108864 ? (l = 0) : (l = (g / 67108864) | 0);
              }
              return o;
            }),
            (D.prototype.convert13b = function (o, u, l, d) {
              for (var g = 0, w = 0; w < u; w++)
                (g = g + (o[w] | 0)),
                  (l[2 * w] = g & 8191),
                  (g = g >>> 13),
                  (l[2 * w + 1] = g & 8191),
                  (g = g >>> 13);
              for (w = 2 * u; w < d; ++w) l[w] = 0;
              r(g === 0), r((g & -8192) === 0);
            }),
            (D.prototype.stub = function (o) {
              for (var u = new Array(o), l = 0; l < o; l++) u[l] = 0;
              return u;
            }),
            (D.prototype.mulp = function (o, u, l) {
              var d = 2 * this.guessLen13b(o.length, u.length),
                g = this.makeRBT(d),
                w = this.stub(d),
                M = new Array(d),
                v = new Array(d),
                a = new Array(d),
                b = new Array(d),
                k = new Array(d),
                B = new Array(d),
                F = l.words;
              (F.length = d),
                this.convert13b(o.words, o.length, M, d),
                this.convert13b(u.words, u.length, b, d),
                this.transform(M, w, v, a, d, g),
                this.transform(b, w, k, B, d, g);
              for (var P = 0; P < d; P++) {
                var C = v[P] * k[P] - a[P] * B[P];
                (a[P] = v[P] * B[P] + a[P] * k[P]), (v[P] = C);
              }
              return (
                this.conjugate(v, a, d),
                this.transform(v, a, F, w, d, g),
                this.conjugate(F, w, d),
                this.normalize13b(F, d),
                (l.negative = o.negative ^ u.negative),
                (l.length = o.length + u.length),
                l.strip()
              );
            }),
            (n.prototype.mul = function (o) {
              var u = new n(null);
              return (u.words = new Array(this.length + o.length)), this.mulTo(o, u);
            }),
            (n.prototype.mulf = function (o) {
              var u = new n(null);
              return (u.words = new Array(this.length + o.length)), L(this, o, u);
            }),
            (n.prototype.imul = function (o) {
              return this.clone().mulTo(o, this);
            }),
            (n.prototype.imuln = function (o) {
              r(typeof o == 'number'), r(o < 67108864);
              for (var u = 0, l = 0; l < this.length; l++) {
                var d = (this.words[l] | 0) * o,
                  g = (d & 67108863) + (u & 67108863);
                (u >>= 26),
                  (u += (d / 67108864) | 0),
                  (u += g >>> 26),
                  (this.words[l] = g & 67108863);
              }
              return u !== 0 && ((this.words[l] = u), this.length++), this;
            }),
            (n.prototype.muln = function (o) {
              return this.clone().imuln(o);
            }),
            (n.prototype.sqr = function () {
              return this.mul(this);
            }),
            (n.prototype.isqr = function () {
              return this.imul(this.clone());
            }),
            (n.prototype.pow = function (o) {
              var u = A(o);
              if (u.length === 0) return new n(1);
              for (var l = this, d = 0; d < u.length && u[d] === 0; d++, l = l.sqr());
              if (++d < u.length)
                for (var g = l.sqr(); d < u.length; d++, g = g.sqr()) u[d] !== 0 && (l = l.mul(g));
              return l;
            }),
            (n.prototype.iushln = function (o) {
              r(typeof o == 'number' && o >= 0);
              var u = o % 26,
                l = (o - u) / 26,
                d = (67108863 >>> (26 - u)) << (26 - u),
                g;
              if (u !== 0) {
                var w = 0;
                for (g = 0; g < this.length; g++) {
                  var M = this.words[g] & d,
                    v = ((this.words[g] | 0) - M) << u;
                  (this.words[g] = v | w), (w = M >>> (26 - u));
                }
                w && ((this.words[g] = w), this.length++);
              }
              if (l !== 0) {
                for (g = this.length - 1; g >= 0; g--) this.words[g + l] = this.words[g];
                for (g = 0; g < l; g++) this.words[g] = 0;
                this.length += l;
              }
              return this.strip();
            }),
            (n.prototype.ishln = function (o) {
              return r(this.negative === 0), this.iushln(o);
            }),
            (n.prototype.iushrn = function (o, u, l) {
              r(typeof o == 'number' && o >= 0);
              var d;
              u ? (d = (u - (u % 26)) / 26) : (d = 0);
              var g = o % 26,
                w = Math.min((o - g) / 26, this.length),
                M = 67108863 ^ ((67108863 >>> g) << g),
                v = l;
              if (((d -= w), (d = Math.max(0, d)), v)) {
                for (var a = 0; a < w; a++) v.words[a] = this.words[a];
                v.length = w;
              }
              if (w !== 0)
                if (this.length > w)
                  for (this.length -= w, a = 0; a < this.length; a++)
                    this.words[a] = this.words[a + w];
                else (this.words[0] = 0), (this.length = 1);
              var b = 0;
              for (a = this.length - 1; a >= 0 && (b !== 0 || a >= d); a--) {
                var k = this.words[a] | 0;
                (this.words[a] = (b << (26 - g)) | (k >>> g)), (b = k & M);
              }
              return (
                v && b !== 0 && (v.words[v.length++] = b),
                this.length === 0 && ((this.words[0] = 0), (this.length = 1)),
                this.strip()
              );
            }),
            (n.prototype.ishrn = function (o, u, l) {
              return r(this.negative === 0), this.iushrn(o, u, l);
            }),
            (n.prototype.shln = function (o) {
              return this.clone().ishln(o);
            }),
            (n.prototype.ushln = function (o) {
              return this.clone().iushln(o);
            }),
            (n.prototype.shrn = function (o) {
              return this.clone().ishrn(o);
            }),
            (n.prototype.ushrn = function (o) {
              return this.clone().iushrn(o);
            }),
            (n.prototype.testn = function (o) {
              r(typeof o == 'number' && o >= 0);
              var u = o % 26,
                l = (o - u) / 26,
                d = 1 << u;
              if (this.length <= l) return !1;
              var g = this.words[l];
              return !!(g & d);
            }),
            (n.prototype.imaskn = function (o) {
              r(typeof o == 'number' && o >= 0);
              var u = o % 26,
                l = (o - u) / 26;
              if (
                (r(this.negative === 0, 'imaskn works only with positive numbers'),
                this.length <= l)
              )
                return this;
              if ((u !== 0 && l++, (this.length = Math.min(l, this.length)), u !== 0)) {
                var d = 67108863 ^ ((67108863 >>> u) << u);
                this.words[this.length - 1] &= d;
              }
              return this.strip();
            }),
            (n.prototype.maskn = function (o) {
              return this.clone().imaskn(o);
            }),
            (n.prototype.iaddn = function (o) {
              return (
                r(typeof o == 'number'),
                r(o < 67108864),
                o < 0
                  ? this.isubn(-o)
                  : this.negative !== 0
                    ? this.length === 1 && (this.words[0] | 0) < o
                      ? ((this.words[0] = o - (this.words[0] | 0)), (this.negative = 0), this)
                      : ((this.negative = 0), this.isubn(o), (this.negative = 1), this)
                    : this._iaddn(o)
              );
            }),
            (n.prototype._iaddn = function (o) {
              this.words[0] += o;
              for (var u = 0; u < this.length && this.words[u] >= 67108864; u++)
                (this.words[u] -= 67108864),
                  u === this.length - 1 ? (this.words[u + 1] = 1) : this.words[u + 1]++;
              return (this.length = Math.max(this.length, u + 1)), this;
            }),
            (n.prototype.isubn = function (o) {
              if ((r(typeof o == 'number'), r(o < 67108864), o < 0)) return this.iaddn(-o);
              if (this.negative !== 0)
                return (this.negative = 0), this.iaddn(o), (this.negative = 1), this;
              if (((this.words[0] -= o), this.length === 1 && this.words[0] < 0))
                (this.words[0] = -this.words[0]), (this.negative = 1);
              else
                for (var u = 0; u < this.length && this.words[u] < 0; u++)
                  (this.words[u] += 67108864), (this.words[u + 1] -= 1);
              return this.strip();
            }),
            (n.prototype.addn = function (o) {
              return this.clone().iaddn(o);
            }),
            (n.prototype.subn = function (o) {
              return this.clone().isubn(o);
            }),
            (n.prototype.iabs = function () {
              return (this.negative = 0), this;
            }),
            (n.prototype.abs = function () {
              return this.clone().iabs();
            }),
            (n.prototype._ishlnsubmul = function (o, u, l) {
              var d = o.length + l,
                g;
              this._expand(d);
              var w,
                M = 0;
              for (g = 0; g < o.length; g++) {
                w = (this.words[g + l] | 0) + M;
                var v = (o.words[g] | 0) * u;
                (w -= v & 67108863),
                  (M = (w >> 26) - ((v / 67108864) | 0)),
                  (this.words[g + l] = w & 67108863);
              }
              for (; g < this.length - l; g++)
                (w = (this.words[g + l] | 0) + M),
                  (M = w >> 26),
                  (this.words[g + l] = w & 67108863);
              if (M === 0) return this.strip();
              for (r(M === -1), M = 0, g = 0; g < this.length; g++)
                (w = -(this.words[g] | 0) + M), (M = w >> 26), (this.words[g] = w & 67108863);
              return (this.negative = 1), this.strip();
            }),
            (n.prototype._wordDiv = function (o, u) {
              var l = this.length - o.length,
                d = this.clone(),
                g = o,
                w = g.words[g.length - 1] | 0,
                M = this._countBits(w);
              (l = 26 - M),
                l !== 0 && ((g = g.ushln(l)), d.iushln(l), (w = g.words[g.length - 1] | 0));
              var v = d.length - g.length,
                a;
              if (u !== 'mod') {
                (a = new n(null)), (a.length = v + 1), (a.words = new Array(a.length));
                for (var b = 0; b < a.length; b++) a.words[b] = 0;
              }
              var k = d.clone()._ishlnsubmul(g, 1, v);
              k.negative === 0 && ((d = k), a && (a.words[v] = 1));
              for (var B = v - 1; B >= 0; B--) {
                var F = (d.words[g.length + B] | 0) * 67108864 + (d.words[g.length + B - 1] | 0);
                for (
                  F = Math.min((F / w) | 0, 67108863), d._ishlnsubmul(g, F, B);
                  d.negative !== 0;

                )
                  F--, (d.negative = 0), d._ishlnsubmul(g, 1, B), d.isZero() || (d.negative ^= 1);
                a && (a.words[B] = F);
              }
              return (
                a && a.strip(),
                d.strip(),
                u !== 'div' && l !== 0 && d.iushrn(l),
                { div: a || null, mod: d }
              );
            }),
            (n.prototype.divmod = function (o, u, l) {
              if ((r(!o.isZero()), this.isZero())) return { div: new n(0), mod: new n(0) };
              var d, g, w;
              return this.negative !== 0 && o.negative === 0
                ? ((w = this.neg().divmod(o, u)),
                  u !== 'mod' && (d = w.div.neg()),
                  u !== 'div' && ((g = w.mod.neg()), l && g.negative !== 0 && g.iadd(o)),
                  { div: d, mod: g })
                : this.negative === 0 && o.negative !== 0
                  ? ((w = this.divmod(o.neg(), u)),
                    u !== 'mod' && (d = w.div.neg()),
                    { div: d, mod: w.mod })
                  : this.negative & o.negative
                    ? ((w = this.neg().divmod(o.neg(), u)),
                      u !== 'div' && ((g = w.mod.neg()), l && g.negative !== 0 && g.isub(o)),
                      { div: w.div, mod: g })
                    : o.length > this.length || this.cmp(o) < 0
                      ? { div: new n(0), mod: this }
                      : o.length === 1
                        ? u === 'div'
                          ? { div: this.divn(o.words[0]), mod: null }
                          : u === 'mod'
                            ? { div: null, mod: new n(this.modn(o.words[0])) }
                            : { div: this.divn(o.words[0]), mod: new n(this.modn(o.words[0])) }
                        : this._wordDiv(o, u);
            }),
            (n.prototype.div = function (o) {
              return this.divmod(o, 'div', !1).div;
            }),
            (n.prototype.mod = function (o) {
              return this.divmod(o, 'mod', !1).mod;
            }),
            (n.prototype.umod = function (o) {
              return this.divmod(o, 'mod', !0).mod;
            }),
            (n.prototype.divRound = function (o) {
              var u = this.divmod(o);
              if (u.mod.isZero()) return u.div;
              var l = u.div.negative !== 0 ? u.mod.isub(o) : u.mod,
                d = o.ushrn(1),
                g = o.andln(1),
                w = l.cmp(d);
              return w < 0 || (g === 1 && w === 0)
                ? u.div
                : u.div.negative !== 0
                  ? u.div.isubn(1)
                  : u.div.iaddn(1);
            }),
            (n.prototype.modn = function (o) {
              r(o <= 67108863);
              for (var u = (1 << 26) % o, l = 0, d = this.length - 1; d >= 0; d--)
                l = (u * l + (this.words[d] | 0)) % o;
              return l;
            }),
            (n.prototype.idivn = function (o) {
              r(o <= 67108863);
              for (var u = 0, l = this.length - 1; l >= 0; l--) {
                var d = (this.words[l] | 0) + u * 67108864;
                (this.words[l] = (d / o) | 0), (u = d % o);
              }
              return this.strip();
            }),
            (n.prototype.divn = function (o) {
              return this.clone().idivn(o);
            }),
            (n.prototype.egcd = function (o) {
              r(o.negative === 0), r(!o.isZero());
              var u = this,
                l = o.clone();
              u.negative !== 0 ? (u = u.umod(o)) : (u = u.clone());
              for (
                var d = new n(1), g = new n(0), w = new n(0), M = new n(1), v = 0;
                u.isEven() && l.isEven();

              )
                u.iushrn(1), l.iushrn(1), ++v;
              for (var a = l.clone(), b = u.clone(); !u.isZero(); ) {
                for (var k = 0, B = 1; !(u.words[0] & B) && k < 26; ++k, B <<= 1);
                if (k > 0)
                  for (u.iushrn(k); k-- > 0; )
                    (d.isOdd() || g.isOdd()) && (d.iadd(a), g.isub(b)), d.iushrn(1), g.iushrn(1);
                for (var F = 0, P = 1; !(l.words[0] & P) && F < 26; ++F, P <<= 1);
                if (F > 0)
                  for (l.iushrn(F); F-- > 0; )
                    (w.isOdd() || M.isOdd()) && (w.iadd(a), M.isub(b)), w.iushrn(1), M.iushrn(1);
                u.cmp(l) >= 0
                  ? (u.isub(l), d.isub(w), g.isub(M))
                  : (l.isub(u), w.isub(d), M.isub(g));
              }
              return { a: w, b: M, gcd: l.iushln(v) };
            }),
            (n.prototype._invmp = function (o) {
              r(o.negative === 0), r(!o.isZero());
              var u = this,
                l = o.clone();
              u.negative !== 0 ? (u = u.umod(o)) : (u = u.clone());
              for (
                var d = new n(1), g = new n(0), w = l.clone();
                u.cmpn(1) > 0 && l.cmpn(1) > 0;

              ) {
                for (var M = 0, v = 1; !(u.words[0] & v) && M < 26; ++M, v <<= 1);
                if (M > 0) for (u.iushrn(M); M-- > 0; ) d.isOdd() && d.iadd(w), d.iushrn(1);
                for (var a = 0, b = 1; !(l.words[0] & b) && a < 26; ++a, b <<= 1);
                if (a > 0) for (l.iushrn(a); a-- > 0; ) g.isOdd() && g.iadd(w), g.iushrn(1);
                u.cmp(l) >= 0 ? (u.isub(l), d.isub(g)) : (l.isub(u), g.isub(d));
              }
              var k;
              return u.cmpn(1) === 0 ? (k = d) : (k = g), k.cmpn(0) < 0 && k.iadd(o), k;
            }),
            (n.prototype.gcd = function (o) {
              if (this.isZero()) return o.abs();
              if (o.isZero()) return this.abs();
              var u = this.clone(),
                l = o.clone();
              (u.negative = 0), (l.negative = 0);
              for (var d = 0; u.isEven() && l.isEven(); d++) u.iushrn(1), l.iushrn(1);
              do {
                for (; u.isEven(); ) u.iushrn(1);
                for (; l.isEven(); ) l.iushrn(1);
                var g = u.cmp(l);
                if (g < 0) {
                  var w = u;
                  (u = l), (l = w);
                } else if (g === 0 || l.cmpn(1) === 0) break;
                u.isub(l);
              } while (!0);
              return l.iushln(d);
            }),
            (n.prototype.invm = function (o) {
              return this.egcd(o).a.umod(o);
            }),
            (n.prototype.isEven = function () {
              return (this.words[0] & 1) === 0;
            }),
            (n.prototype.isOdd = function () {
              return (this.words[0] & 1) === 1;
            }),
            (n.prototype.andln = function (o) {
              return this.words[0] & o;
            }),
            (n.prototype.bincn = function (o) {
              r(typeof o == 'number');
              var u = o % 26,
                l = (o - u) / 26,
                d = 1 << u;
              if (this.length <= l) return this._expand(l + 1), (this.words[l] |= d), this;
              for (var g = d, w = l; g !== 0 && w < this.length; w++) {
                var M = this.words[w] | 0;
                (M += g), (g = M >>> 26), (M &= 67108863), (this.words[w] = M);
              }
              return g !== 0 && ((this.words[w] = g), this.length++), this;
            }),
            (n.prototype.isZero = function () {
              return this.length === 1 && this.words[0] === 0;
            }),
            (n.prototype.cmpn = function (o) {
              var u = o < 0;
              if (this.negative !== 0 && !u) return -1;
              if (this.negative === 0 && u) return 1;
              this.strip();
              var l;
              if (this.length > 1) l = 1;
              else {
                u && (o = -o), r(o <= 67108863, 'Number is too big');
                var d = this.words[0] | 0;
                l = d === o ? 0 : d < o ? -1 : 1;
              }
              return this.negative !== 0 ? -l | 0 : l;
            }),
            (n.prototype.cmp = function (o) {
              if (this.negative !== 0 && o.negative === 0) return -1;
              if (this.negative === 0 && o.negative !== 0) return 1;
              var u = this.ucmp(o);
              return this.negative !== 0 ? -u | 0 : u;
            }),
            (n.prototype.ucmp = function (o) {
              if (this.length > o.length) return 1;
              if (this.length < o.length) return -1;
              for (var u = 0, l = this.length - 1; l >= 0; l--) {
                var d = this.words[l] | 0,
                  g = o.words[l] | 0;
                if (d !== g) {
                  d < g ? (u = -1) : d > g && (u = 1);
                  break;
                }
              }
              return u;
            }),
            (n.prototype.gtn = function (o) {
              return this.cmpn(o) === 1;
            }),
            (n.prototype.gt = function (o) {
              return this.cmp(o) === 1;
            }),
            (n.prototype.gten = function (o) {
              return this.cmpn(o) >= 0;
            }),
            (n.prototype.gte = function (o) {
              return this.cmp(o) >= 0;
            }),
            (n.prototype.ltn = function (o) {
              return this.cmpn(o) === -1;
            }),
            (n.prototype.lt = function (o) {
              return this.cmp(o) === -1;
            }),
            (n.prototype.lten = function (o) {
              return this.cmpn(o) <= 0;
            }),
            (n.prototype.lte = function (o) {
              return this.cmp(o) <= 0;
            }),
            (n.prototype.eqn = function (o) {
              return this.cmpn(o) === 0;
            }),
            (n.prototype.eq = function (o) {
              return this.cmp(o) === 0;
            }),
            (n.red = function (o) {
              return new X(o);
            }),
            (n.prototype.toRed = function (o) {
              return (
                r(!this.red, 'Already a number in reduction context'),
                r(this.negative === 0, 'red works only with positives'),
                o.convertTo(this)._forceRed(o)
              );
            }),
            (n.prototype.fromRed = function () {
              return (
                r(this.red, 'fromRed works only with numbers in reduction context'),
                this.red.convertFrom(this)
              );
            }),
            (n.prototype._forceRed = function (o) {
              return (this.red = o), this;
            }),
            (n.prototype.forceRed = function (o) {
              return r(!this.red, 'Already a number in reduction context'), this._forceRed(o);
            }),
            (n.prototype.redAdd = function (o) {
              return r(this.red, 'redAdd works only with red numbers'), this.red.add(this, o);
            }),
            (n.prototype.redIAdd = function (o) {
              return r(this.red, 'redIAdd works only with red numbers'), this.red.iadd(this, o);
            }),
            (n.prototype.redSub = function (o) {
              return r(this.red, 'redSub works only with red numbers'), this.red.sub(this, o);
            }),
            (n.prototype.redISub = function (o) {
              return r(this.red, 'redISub works only with red numbers'), this.red.isub(this, o);
            }),
            (n.prototype.redShl = function (o) {
              return r(this.red, 'redShl works only with red numbers'), this.red.shl(this, o);
            }),
            (n.prototype.redMul = function (o) {
              return (
                r(this.red, 'redMul works only with red numbers'),
                this.red._verify2(this, o),
                this.red.mul(this, o)
              );
            }),
            (n.prototype.redIMul = function (o) {
              return (
                r(this.red, 'redMul works only with red numbers'),
                this.red._verify2(this, o),
                this.red.imul(this, o)
              );
            }),
            (n.prototype.redSqr = function () {
              return (
                r(this.red, 'redSqr works only with red numbers'),
                this.red._verify1(this),
                this.red.sqr(this)
              );
            }),
            (n.prototype.redISqr = function () {
              return (
                r(this.red, 'redISqr works only with red numbers'),
                this.red._verify1(this),
                this.red.isqr(this)
              );
            }),
            (n.prototype.redSqrt = function () {
              return (
                r(this.red, 'redSqrt works only with red numbers'),
                this.red._verify1(this),
                this.red.sqrt(this)
              );
            }),
            (n.prototype.redInvm = function () {
              return (
                r(this.red, 'redInvm works only with red numbers'),
                this.red._verify1(this),
                this.red.invm(this)
              );
            }),
            (n.prototype.redNeg = function () {
              return (
                r(this.red, 'redNeg works only with red numbers'),
                this.red._verify1(this),
                this.red.neg(this)
              );
            }),
            (n.prototype.redPow = function (o) {
              return (
                r(this.red && !o.red, 'redPow(normalNum)'),
                this.red._verify1(this),
                this.red.pow(this, o)
              );
            });
          var q = { k256: null, p224: null, p192: null, p25519: null };
          function H(S, o) {
            (this.name = S),
              (this.p = new n(o, 16)),
              (this.n = this.p.bitLength()),
              (this.k = new n(1).iushln(this.n).isub(this.p)),
              (this.tmp = this._tmp());
          }
          (H.prototype._tmp = function () {
            var o = new n(null);
            return (o.words = new Array(Math.ceil(this.n / 13))), o;
          }),
            (H.prototype.ireduce = function (o) {
              var u = o,
                l;
              do
                this.split(u, this.tmp),
                  (u = this.imulK(u)),
                  (u = u.iadd(this.tmp)),
                  (l = u.bitLength());
              while (l > this.n);
              var d = l < this.n ? -1 : u.ucmp(this.p);
              return (
                d === 0
                  ? ((u.words[0] = 0), (u.length = 1))
                  : d > 0
                    ? u.isub(this.p)
                    : u.strip !== void 0
                      ? u.strip()
                      : u._strip(),
                u
              );
            }),
            (H.prototype.split = function (o, u) {
              o.iushrn(this.n, 0, u);
            }),
            (H.prototype.imulK = function (o) {
              return o.imul(this.k);
            });
          function V() {
            H.call(
              this,
              'k256',
              'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f'
            );
          }
          s(V, H),
            (V.prototype.split = function (o, u) {
              for (var l = 4194303, d = Math.min(o.length, 9), g = 0; g < d; g++)
                u.words[g] = o.words[g];
              if (((u.length = d), o.length <= 9)) {
                (o.words[0] = 0), (o.length = 1);
                return;
              }
              var w = o.words[9];
              for (u.words[u.length++] = w & l, g = 10; g < o.length; g++) {
                var M = o.words[g] | 0;
                (o.words[g - 10] = ((M & l) << 4) | (w >>> 22)), (w = M);
              }
              (w >>>= 22),
                (o.words[g - 10] = w),
                w === 0 && o.length > 10 ? (o.length -= 10) : (o.length -= 9);
            }),
            (V.prototype.imulK = function (o) {
              (o.words[o.length] = 0), (o.words[o.length + 1] = 0), (o.length += 2);
              for (var u = 0, l = 0; l < o.length; l++) {
                var d = o.words[l] | 0;
                (u += d * 977), (o.words[l] = u & 67108863), (u = d * 64 + ((u / 67108864) | 0));
              }
              return (
                o.words[o.length - 1] === 0 &&
                  (o.length--, o.words[o.length - 1] === 0 && o.length--),
                o
              );
            });
          function te() {
            H.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
          }
          s(te, H);
          function ue() {
            H.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
          }
          s(ue, H);
          function ne() {
            H.call(
              this,
              '25519',
              '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed'
            );
          }
          s(ne, H),
            (ne.prototype.imulK = function (o) {
              for (var u = 0, l = 0; l < o.length; l++) {
                var d = (o.words[l] | 0) * 19 + u,
                  g = d & 67108863;
                (d >>>= 26), (o.words[l] = g), (u = d);
              }
              return u !== 0 && (o.words[o.length++] = u), o;
            }),
            (n._prime = function (o) {
              if (q[o]) return q[o];
              var u;
              if (o === 'k256') u = new V();
              else if (o === 'p224') u = new te();
              else if (o === 'p192') u = new ue();
              else if (o === 'p25519') u = new ne();
              else throw new Error('Unknown prime ' + o);
              return (q[o] = u), u;
            });
          function X(S) {
            if (typeof S == 'string') {
              var o = n._prime(S);
              (this.m = o.p), (this.prime = o);
            } else r(S.gtn(1), 'modulus must be greater than 1'), (this.m = S), (this.prime = null);
          }
          (X.prototype._verify1 = function (o) {
            r(o.negative === 0, 'red works only with positives'),
              r(o.red, 'red works only with red numbers');
          }),
            (X.prototype._verify2 = function (o, u) {
              r((o.negative | u.negative) === 0, 'red works only with positives'),
                r(o.red && o.red === u.red, 'red works only with red numbers');
            }),
            (X.prototype.imod = function (o) {
              return this.prime
                ? this.prime.ireduce(o)._forceRed(this)
                : o.umod(this.m)._forceRed(this);
            }),
            (X.prototype.neg = function (o) {
              return o.isZero() ? o.clone() : this.m.sub(o)._forceRed(this);
            }),
            (X.prototype.add = function (o, u) {
              this._verify2(o, u);
              var l = o.add(u);
              return l.cmp(this.m) >= 0 && l.isub(this.m), l._forceRed(this);
            }),
            (X.prototype.iadd = function (o, u) {
              this._verify2(o, u);
              var l = o.iadd(u);
              return l.cmp(this.m) >= 0 && l.isub(this.m), l;
            }),
            (X.prototype.sub = function (o, u) {
              this._verify2(o, u);
              var l = o.sub(u);
              return l.cmpn(0) < 0 && l.iadd(this.m), l._forceRed(this);
            }),
            (X.prototype.isub = function (o, u) {
              this._verify2(o, u);
              var l = o.isub(u);
              return l.cmpn(0) < 0 && l.iadd(this.m), l;
            }),
            (X.prototype.shl = function (o, u) {
              return this._verify1(o), this.imod(o.ushln(u));
            }),
            (X.prototype.imul = function (o, u) {
              return this._verify2(o, u), this.imod(o.imul(u));
            }),
            (X.prototype.mul = function (o, u) {
              return this._verify2(o, u), this.imod(o.mul(u));
            }),
            (X.prototype.isqr = function (o) {
              return this.imul(o, o.clone());
            }),
            (X.prototype.sqr = function (o) {
              return this.mul(o, o);
            }),
            (X.prototype.sqrt = function (o) {
              if (o.isZero()) return o.clone();
              var u = this.m.andln(3);
              if ((r(u % 2 === 1), u === 3)) {
                var l = this.m.add(new n(1)).iushrn(2);
                return this.pow(o, l);
              }
              for (var d = this.m.subn(1), g = 0; !d.isZero() && d.andln(1) === 0; )
                g++, d.iushrn(1);
              r(!d.isZero());
              var w = new n(1).toRed(this),
                M = w.redNeg(),
                v = this.m.subn(1).iushrn(1),
                a = this.m.bitLength();
              for (a = new n(2 * a * a).toRed(this); this.pow(a, v).cmp(M) !== 0; ) a.redIAdd(M);
              for (
                var b = this.pow(a, d),
                  k = this.pow(o, d.addn(1).iushrn(1)),
                  B = this.pow(o, d),
                  F = g;
                B.cmp(w) !== 0;

              ) {
                for (var P = B, C = 0; P.cmp(w) !== 0; C++) P = P.redSqr();
                r(C < F);
                var z = this.pow(b, new n(1).iushln(F - C - 1));
                (k = k.redMul(z)), (b = z.redSqr()), (B = B.redMul(b)), (F = C);
              }
              return k;
            }),
            (X.prototype.invm = function (o) {
              var u = o._invmp(this.m);
              return u.negative !== 0 ? ((u.negative = 0), this.imod(u).redNeg()) : this.imod(u);
            }),
            (X.prototype.pow = function (o, u) {
              if (u.isZero()) return new n(1).toRed(this);
              if (u.cmpn(1) === 0) return o.clone();
              var l = 4,
                d = new Array(1 << l);
              (d[0] = new n(1).toRed(this)), (d[1] = o);
              for (var g = 2; g < d.length; g++) d[g] = this.mul(d[g - 1], o);
              var w = d[0],
                M = 0,
                v = 0,
                a = u.bitLength() % 26;
              for (a === 0 && (a = 26), g = u.length - 1; g >= 0; g--) {
                for (var b = u.words[g], k = a - 1; k >= 0; k--) {
                  var B = (b >> k) & 1;
                  if ((w !== d[0] && (w = this.sqr(w)), B === 0 && M === 0)) {
                    v = 0;
                    continue;
                  }
                  (M <<= 1),
                    (M |= B),
                    v++,
                    !(v !== l && (g !== 0 || k !== 0)) &&
                      ((w = this.mul(w, d[M])), (v = 0), (M = 0));
                }
                a = 26;
              }
              return w;
            }),
            (X.prototype.convertTo = function (o) {
              var u = o.umod(this.m);
              return u === o ? u.clone() : u;
            }),
            (X.prototype.convertFrom = function (o) {
              var u = o.clone();
              return (u.red = null), u;
            }),
            (n.mont = function (o) {
              return new Oe(o);
            });
          function Oe(S) {
            X.call(this, S),
              (this.shift = this.m.bitLength()),
              this.shift % 26 !== 0 && (this.shift += 26 - (this.shift % 26)),
              (this.r = new n(1).iushln(this.shift)),
              (this.r2 = this.imod(this.r.sqr())),
              (this.rinv = this.r._invmp(this.m)),
              (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
              (this.minv = this.minv.umod(this.r)),
              (this.minv = this.r.sub(this.minv));
          }
          s(Oe, X),
            (Oe.prototype.convertTo = function (o) {
              return this.imod(o.ushln(this.shift));
            }),
            (Oe.prototype.convertFrom = function (o) {
              var u = this.imod(o.mul(this.rinv));
              return (u.red = null), u;
            }),
            (Oe.prototype.imul = function (o, u) {
              if (o.isZero() || u.isZero()) return (o.words[0] = 0), (o.length = 1), o;
              var l = o.imul(u),
                d = l.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                g = l.isub(d).iushrn(this.shift),
                w = g;
              return (
                g.cmp(this.m) >= 0 ? (w = g.isub(this.m)) : g.cmpn(0) < 0 && (w = g.iadd(this.m)),
                w._forceRed(this)
              );
            }),
            (Oe.prototype.mul = function (o, u) {
              if (o.isZero() || u.isZero()) return new n(0)._forceRed(this);
              var l = o.mul(u),
                d = l.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                g = l.isub(d).iushrn(this.shift),
                w = g;
              return (
                g.cmp(this.m) >= 0 ? (w = g.isub(this.m)) : g.cmpn(0) < 0 && (w = g.iadd(this.m)),
                w._forceRed(this)
              );
            }),
            (Oe.prototype.invm = function (o) {
              var u = this.imod(o._invmp(this.m).mul(this.r2));
              return u._forceRed(this);
            });
        })(i, se);
      })(Mf)),
    Mf.exports
  );
}
var $0, _m;
function qx() {
  if (_m) return $0;
  _m = 1;
  var i = hy(),
    e = Fx();
  $0 = function (c) {
    return new r(c);
  };
  var t = {
    secp256k1: { name: 'secp256k1', byteLength: 32 },
    secp224r1: { name: 'p224', byteLength: 28 },
    prime256v1: { name: 'p256', byteLength: 32 },
    prime192v1: { name: 'p192', byteLength: 24 },
    ed25519: { name: 'ed25519', byteLength: 32 },
    secp384r1: { name: 'p384', byteLength: 48 },
    secp521r1: { name: 'p521', byteLength: 66 },
  };
  (t.p224 = t.secp224r1),
    (t.p256 = t.secp256r1 = t.prime256v1),
    (t.p192 = t.secp192r1 = t.prime192v1),
    (t.p384 = t.secp384r1),
    (t.p521 = t.secp521r1);
  function r(n) {
    (this.curveType = t[n]),
      this.curveType || (this.curveType = { name: n }),
      (this.curve = new i.ec(this.curveType.name)),
      (this.keys = void 0);
  }
  (r.prototype.generateKeys = function (n, c) {
    return (this.keys = this.curve.genKeyPair()), this.getPublicKey(n, c);
  }),
    (r.prototype.computeSecret = function (n, c, f) {
      (c = c || 'utf8'), Ze.isBuffer(n) || (n = new Ze(n, c));
      var h = this.curve.keyFromPublic(n).getPublic(),
        y = h.mul(this.keys.getPrivate()).getX();
      return s(y, f, this.curveType.byteLength);
    }),
    (r.prototype.getPublicKey = function (n, c) {
      var f = this.keys.getPublic(c === 'compressed', !0);
      return c === 'hybrid' && (f[f.length - 1] % 2 ? (f[0] = 7) : (f[0] = 6)), s(f, n);
    }),
    (r.prototype.getPrivateKey = function (n) {
      return s(this.keys.getPrivate(), n);
    }),
    (r.prototype.setPublicKey = function (n, c) {
      return (
        (c = c || 'utf8'), Ze.isBuffer(n) || (n = new Ze(n, c)), this.keys._importPublic(n), this
      );
    }),
    (r.prototype.setPrivateKey = function (n, c) {
      (c = c || 'utf8'), Ze.isBuffer(n) || (n = new Ze(n, c));
      var f = new e(n);
      return (
        (f = f.toString(16)),
        (this.keys = this.curve.genKeyPair()),
        this.keys._importPrivate(f),
        this
      );
    });
  function s(n, c, f) {
    Array.isArray(n) || (n = n.toArray());
    var h = new Ze(n);
    if (f && h.length < f) {
      var y = new Ze(f - h.length);
      y.fill(0), (h = Ze.concat([y, h]));
    }
    return c ? h.toString(c) : h;
  }
  return $0;
}
var D0 = {},
  U0,
  Sm;
function O8() {
  if (Sm) return U0;
  Sm = 1;
  var i = tc,
    e = At.Buffer;
  U0 = function (r, s) {
    for (var n = e.alloc(0), c = 0, f; n.length < s; )
      (f = t(c++)), (n = e.concat([n, i('sha1').update(r).update(f).digest()]));
    return n.slice(0, s);
  };
  function t(r) {
    var s = e.allocUnsafe(4);
    return s.writeUInt32BE(r, 0), s;
  }
  return U0;
}
var z0, Mm;
function C8() {
  return (
    Mm ||
      ((Mm = 1),
      (z0 = function (e, t) {
        for (var r = e.length, s = -1; ++s < r; ) e[s] ^= t[s];
        return e;
      })),
    z0
  );
}
var Af = { exports: {} };
Af.exports;
var Am;
function by() {
  return (
    Am ||
      ((Am = 1),
      (function (i) {
        (function (e, t) {
          function r(S, o) {
            if (!S) throw new Error(o || 'Assertion failed');
          }
          function s(S, o) {
            S.super_ = o;
            var u = function () {};
            (u.prototype = o.prototype), (S.prototype = new u()), (S.prototype.constructor = S);
          }
          function n(S, o, u) {
            if (n.isBN(S)) return S;
            (this.negative = 0),
              (this.words = null),
              (this.length = 0),
              (this.red = null),
              S !== null &&
                ((o === 'le' || o === 'be') && ((u = o), (o = 10)),
                this._init(S || 0, o || 10, u || 'be'));
          }
          typeof e == 'object' ? (e.exports = n) : (t.BN = n), (n.BN = n), (n.wordSize = 26);
          var c;
          try {
            typeof window < 'u' && typeof window.Buffer < 'u'
              ? (c = window.Buffer)
              : (c = ai.Buffer);
          } catch {}
          (n.isBN = function (o) {
            return o instanceof n
              ? !0
              : o !== null &&
                  typeof o == 'object' &&
                  o.constructor.wordSize === n.wordSize &&
                  Array.isArray(o.words);
          }),
            (n.max = function (o, u) {
              return o.cmp(u) > 0 ? o : u;
            }),
            (n.min = function (o, u) {
              return o.cmp(u) < 0 ? o : u;
            }),
            (n.prototype._init = function (o, u, l) {
              if (typeof o == 'number') return this._initNumber(o, u, l);
              if (typeof o == 'object') return this._initArray(o, u, l);
              u === 'hex' && (u = 16),
                r(u === (u | 0) && u >= 2 && u <= 36),
                (o = o.toString().replace(/\s+/g, ''));
              var d = 0;
              o[0] === '-' && (d++, (this.negative = 1)),
                d < o.length &&
                  (u === 16
                    ? this._parseHex(o, d, l)
                    : (this._parseBase(o, u, d),
                      l === 'le' && this._initArray(this.toArray(), u, l)));
            }),
            (n.prototype._initNumber = function (o, u, l) {
              o < 0 && ((this.negative = 1), (o = -o)),
                o < 67108864
                  ? ((this.words = [o & 67108863]), (this.length = 1))
                  : o < 4503599627370496
                    ? ((this.words = [o & 67108863, (o / 67108864) & 67108863]), (this.length = 2))
                    : (r(o < 9007199254740992),
                      (this.words = [o & 67108863, (o / 67108864) & 67108863, 1]),
                      (this.length = 3)),
                l === 'le' && this._initArray(this.toArray(), u, l);
            }),
            (n.prototype._initArray = function (o, u, l) {
              if ((r(typeof o.length == 'number'), o.length <= 0))
                return (this.words = [0]), (this.length = 1), this;
              (this.length = Math.ceil(o.length / 3)), (this.words = new Array(this.length));
              for (var d = 0; d < this.length; d++) this.words[d] = 0;
              var g,
                w,
                M = 0;
              if (l === 'be')
                for (d = o.length - 1, g = 0; d >= 0; d -= 3)
                  (w = o[d] | (o[d - 1] << 8) | (o[d - 2] << 16)),
                    (this.words[g] |= (w << M) & 67108863),
                    (this.words[g + 1] = (w >>> (26 - M)) & 67108863),
                    (M += 24),
                    M >= 26 && ((M -= 26), g++);
              else if (l === 'le')
                for (d = 0, g = 0; d < o.length; d += 3)
                  (w = o[d] | (o[d + 1] << 8) | (o[d + 2] << 16)),
                    (this.words[g] |= (w << M) & 67108863),
                    (this.words[g + 1] = (w >>> (26 - M)) & 67108863),
                    (M += 24),
                    M >= 26 && ((M -= 26), g++);
              return this.strip();
            });
          function f(S, o) {
            var u = S.charCodeAt(o);
            return u >= 65 && u <= 70 ? u - 55 : u >= 97 && u <= 102 ? u - 87 : (u - 48) & 15;
          }
          function h(S, o, u) {
            var l = f(S, u);
            return u - 1 >= o && (l |= f(S, u - 1) << 4), l;
          }
          n.prototype._parseHex = function (o, u, l) {
            (this.length = Math.ceil((o.length - u) / 6)), (this.words = new Array(this.length));
            for (var d = 0; d < this.length; d++) this.words[d] = 0;
            var g = 0,
              w = 0,
              M;
            if (l === 'be')
              for (d = o.length - 1; d >= u; d -= 2)
                (M = h(o, u, d) << g),
                  (this.words[w] |= M & 67108863),
                  g >= 18 ? ((g -= 18), (w += 1), (this.words[w] |= M >>> 26)) : (g += 8);
            else {
              var v = o.length - u;
              for (d = v % 2 === 0 ? u + 1 : u; d < o.length; d += 2)
                (M = h(o, u, d) << g),
                  (this.words[w] |= M & 67108863),
                  g >= 18 ? ((g -= 18), (w += 1), (this.words[w] |= M >>> 26)) : (g += 8);
            }
            this.strip();
          };
          function y(S, o, u, l) {
            for (var d = 0, g = Math.min(S.length, u), w = o; w < g; w++) {
              var M = S.charCodeAt(w) - 48;
              (d *= l), M >= 49 ? (d += M - 49 + 10) : M >= 17 ? (d += M - 17 + 10) : (d += M);
            }
            return d;
          }
          (n.prototype._parseBase = function (o, u, l) {
            (this.words = [0]), (this.length = 1);
            for (var d = 0, g = 1; g <= 67108863; g *= u) d++;
            d--, (g = (g / u) | 0);
            for (
              var w = o.length - l, M = w % d, v = Math.min(w, w - M) + l, a = 0, b = l;
              b < v;
              b += d
            )
              (a = y(o, b, b + d, u)),
                this.imuln(g),
                this.words[0] + a < 67108864 ? (this.words[0] += a) : this._iaddn(a);
            if (M !== 0) {
              var k = 1;
              for (a = y(o, b, o.length, u), b = 0; b < M; b++) k *= u;
              this.imuln(k), this.words[0] + a < 67108864 ? (this.words[0] += a) : this._iaddn(a);
            }
            this.strip();
          }),
            (n.prototype.copy = function (o) {
              o.words = new Array(this.length);
              for (var u = 0; u < this.length; u++) o.words[u] = this.words[u];
              (o.length = this.length), (o.negative = this.negative), (o.red = this.red);
            }),
            (n.prototype.clone = function () {
              var o = new n(null);
              return this.copy(o), o;
            }),
            (n.prototype._expand = function (o) {
              for (; this.length < o; ) this.words[this.length++] = 0;
              return this;
            }),
            (n.prototype.strip = function () {
              for (; this.length > 1 && this.words[this.length - 1] === 0; ) this.length--;
              return this._normSign();
            }),
            (n.prototype._normSign = function () {
              return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
            }),
            (n.prototype.inspect = function () {
              return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
            });
          var p = [
              '',
              '0',
              '00',
              '000',
              '0000',
              '00000',
              '000000',
              '0000000',
              '00000000',
              '000000000',
              '0000000000',
              '00000000000',
              '000000000000',
              '0000000000000',
              '00000000000000',
              '000000000000000',
              '0000000000000000',
              '00000000000000000',
              '000000000000000000',
              '0000000000000000000',
              '00000000000000000000',
              '000000000000000000000',
              '0000000000000000000000',
              '00000000000000000000000',
              '000000000000000000000000',
              '0000000000000000000000000',
            ],
            m = [
              0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5,
              5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            ],
            _ = [
              0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721,
              1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224,
              47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907,
              17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176,
            ];
          (n.prototype.toString = function (o, u) {
            (o = o || 10), (u = u | 0 || 1);
            var l;
            if (o === 16 || o === 'hex') {
              l = '';
              for (var d = 0, g = 0, w = 0; w < this.length; w++) {
                var M = this.words[w],
                  v = (((M << d) | g) & 16777215).toString(16);
                (g = (M >>> (24 - d)) & 16777215),
                  g !== 0 || w !== this.length - 1 ? (l = p[6 - v.length] + v + l) : (l = v + l),
                  (d += 2),
                  d >= 26 && ((d -= 26), w--);
              }
              for (g !== 0 && (l = g.toString(16) + l); l.length % u !== 0; ) l = '0' + l;
              return this.negative !== 0 && (l = '-' + l), l;
            }
            if (o === (o | 0) && o >= 2 && o <= 36) {
              var a = m[o],
                b = _[o];
              l = '';
              var k = this.clone();
              for (k.negative = 0; !k.isZero(); ) {
                var B = k.modn(b).toString(o);
                (k = k.idivn(b)), k.isZero() ? (l = B + l) : (l = p[a - B.length] + B + l);
              }
              for (this.isZero() && (l = '0' + l); l.length % u !== 0; ) l = '0' + l;
              return this.negative !== 0 && (l = '-' + l), l;
            }
            r(!1, 'Base should be between 2 and 36');
          }),
            (n.prototype.toNumber = function () {
              var o = this.words[0];
              return (
                this.length === 2
                  ? (o += this.words[1] * 67108864)
                  : this.length === 3 && this.words[2] === 1
                    ? (o += 4503599627370496 + this.words[1] * 67108864)
                    : this.length > 2 && r(!1, 'Number can only safely store up to 53 bits'),
                this.negative !== 0 ? -o : o
              );
            }),
            (n.prototype.toJSON = function () {
              return this.toString(16);
            }),
            (n.prototype.toBuffer = function (o, u) {
              return r(typeof c < 'u'), this.toArrayLike(c, o, u);
            }),
            (n.prototype.toArray = function (o, u) {
              return this.toArrayLike(Array, o, u);
            }),
            (n.prototype.toArrayLike = function (o, u, l) {
              var d = this.byteLength(),
                g = l || Math.max(1, d);
              r(d <= g, 'byte array longer than desired length'),
                r(g > 0, 'Requested array length <= 0'),
                this.strip();
              var w = u === 'le',
                M = new o(g),
                v,
                a,
                b = this.clone();
              if (w) {
                for (a = 0; !b.isZero(); a++) (v = b.andln(255)), b.iushrn(8), (M[a] = v);
                for (; a < g; a++) M[a] = 0;
              } else {
                for (a = 0; a < g - d; a++) M[a] = 0;
                for (a = 0; !b.isZero(); a++) (v = b.andln(255)), b.iushrn(8), (M[g - a - 1] = v);
              }
              return M;
            }),
            Math.clz32
              ? (n.prototype._countBits = function (o) {
                  return 32 - Math.clz32(o);
                })
              : (n.prototype._countBits = function (o) {
                  var u = o,
                    l = 0;
                  return (
                    u >= 4096 && ((l += 13), (u >>>= 13)),
                    u >= 64 && ((l += 7), (u >>>= 7)),
                    u >= 8 && ((l += 4), (u >>>= 4)),
                    u >= 2 && ((l += 2), (u >>>= 2)),
                    l + u
                  );
                }),
            (n.prototype._zeroBits = function (o) {
              if (o === 0) return 26;
              var u = o,
                l = 0;
              return (
                u & 8191 || ((l += 13), (u >>>= 13)),
                u & 127 || ((l += 7), (u >>>= 7)),
                u & 15 || ((l += 4), (u >>>= 4)),
                u & 3 || ((l += 2), (u >>>= 2)),
                u & 1 || l++,
                l
              );
            }),
            (n.prototype.bitLength = function () {
              var o = this.words[this.length - 1],
                u = this._countBits(o);
              return (this.length - 1) * 26 + u;
            });
          function A(S) {
            for (var o = new Array(S.bitLength()), u = 0; u < o.length; u++) {
              var l = (u / 26) | 0,
                d = u % 26;
              o[u] = (S.words[l] & (1 << d)) >>> d;
            }
            return o;
          }
          (n.prototype.zeroBits = function () {
            if (this.isZero()) return 0;
            for (var o = 0, u = 0; u < this.length; u++) {
              var l = this._zeroBits(this.words[u]);
              if (((o += l), l !== 26)) break;
            }
            return o;
          }),
            (n.prototype.byteLength = function () {
              return Math.ceil(this.bitLength() / 8);
            }),
            (n.prototype.toTwos = function (o) {
              return this.negative !== 0 ? this.abs().inotn(o).iaddn(1) : this.clone();
            }),
            (n.prototype.fromTwos = function (o) {
              return this.testn(o - 1) ? this.notn(o).iaddn(1).ineg() : this.clone();
            }),
            (n.prototype.isNeg = function () {
              return this.negative !== 0;
            }),
            (n.prototype.neg = function () {
              return this.clone().ineg();
            }),
            (n.prototype.ineg = function () {
              return this.isZero() || (this.negative ^= 1), this;
            }),
            (n.prototype.iuor = function (o) {
              for (; this.length < o.length; ) this.words[this.length++] = 0;
              for (var u = 0; u < o.length; u++) this.words[u] = this.words[u] | o.words[u];
              return this.strip();
            }),
            (n.prototype.ior = function (o) {
              return r((this.negative | o.negative) === 0), this.iuor(o);
            }),
            (n.prototype.or = function (o) {
              return this.length > o.length ? this.clone().ior(o) : o.clone().ior(this);
            }),
            (n.prototype.uor = function (o) {
              return this.length > o.length ? this.clone().iuor(o) : o.clone().iuor(this);
            }),
            (n.prototype.iuand = function (o) {
              var u;
              this.length > o.length ? (u = o) : (u = this);
              for (var l = 0; l < u.length; l++) this.words[l] = this.words[l] & o.words[l];
              return (this.length = u.length), this.strip();
            }),
            (n.prototype.iand = function (o) {
              return r((this.negative | o.negative) === 0), this.iuand(o);
            }),
            (n.prototype.and = function (o) {
              return this.length > o.length ? this.clone().iand(o) : o.clone().iand(this);
            }),
            (n.prototype.uand = function (o) {
              return this.length > o.length ? this.clone().iuand(o) : o.clone().iuand(this);
            }),
            (n.prototype.iuxor = function (o) {
              var u, l;
              this.length > o.length ? ((u = this), (l = o)) : ((u = o), (l = this));
              for (var d = 0; d < l.length; d++) this.words[d] = u.words[d] ^ l.words[d];
              if (this !== u) for (; d < u.length; d++) this.words[d] = u.words[d];
              return (this.length = u.length), this.strip();
            }),
            (n.prototype.ixor = function (o) {
              return r((this.negative | o.negative) === 0), this.iuxor(o);
            }),
            (n.prototype.xor = function (o) {
              return this.length > o.length ? this.clone().ixor(o) : o.clone().ixor(this);
            }),
            (n.prototype.uxor = function (o) {
              return this.length > o.length ? this.clone().iuxor(o) : o.clone().iuxor(this);
            }),
            (n.prototype.inotn = function (o) {
              r(typeof o == 'number' && o >= 0);
              var u = Math.ceil(o / 26) | 0,
                l = o % 26;
              this._expand(u), l > 0 && u--;
              for (var d = 0; d < u; d++) this.words[d] = ~this.words[d] & 67108863;
              return (
                l > 0 && (this.words[d] = ~this.words[d] & (67108863 >> (26 - l))), this.strip()
              );
            }),
            (n.prototype.notn = function (o) {
              return this.clone().inotn(o);
            }),
            (n.prototype.setn = function (o, u) {
              r(typeof o == 'number' && o >= 0);
              var l = (o / 26) | 0,
                d = o % 26;
              return (
                this._expand(l + 1),
                u
                  ? (this.words[l] = this.words[l] | (1 << d))
                  : (this.words[l] = this.words[l] & ~(1 << d)),
                this.strip()
              );
            }),
            (n.prototype.iadd = function (o) {
              var u;
              if (this.negative !== 0 && o.negative === 0)
                return (
                  (this.negative = 0), (u = this.isub(o)), (this.negative ^= 1), this._normSign()
                );
              if (this.negative === 0 && o.negative !== 0)
                return (o.negative = 0), (u = this.isub(o)), (o.negative = 1), u._normSign();
              var l, d;
              this.length > o.length ? ((l = this), (d = o)) : ((l = o), (d = this));
              for (var g = 0, w = 0; w < d.length; w++)
                (u = (l.words[w] | 0) + (d.words[w] | 0) + g),
                  (this.words[w] = u & 67108863),
                  (g = u >>> 26);
              for (; g !== 0 && w < l.length; w++)
                (u = (l.words[w] | 0) + g), (this.words[w] = u & 67108863), (g = u >>> 26);
              if (((this.length = l.length), g !== 0)) (this.words[this.length] = g), this.length++;
              else if (l !== this) for (; w < l.length; w++) this.words[w] = l.words[w];
              return this;
            }),
            (n.prototype.add = function (o) {
              var u;
              return o.negative !== 0 && this.negative === 0
                ? ((o.negative = 0), (u = this.sub(o)), (o.negative ^= 1), u)
                : o.negative === 0 && this.negative !== 0
                  ? ((this.negative = 0), (u = o.sub(this)), (this.negative = 1), u)
                  : this.length > o.length
                    ? this.clone().iadd(o)
                    : o.clone().iadd(this);
            }),
            (n.prototype.isub = function (o) {
              if (o.negative !== 0) {
                o.negative = 0;
                var u = this.iadd(o);
                return (o.negative = 1), u._normSign();
              } else if (this.negative !== 0)
                return (this.negative = 0), this.iadd(o), (this.negative = 1), this._normSign();
              var l = this.cmp(o);
              if (l === 0) return (this.negative = 0), (this.length = 1), (this.words[0] = 0), this;
              var d, g;
              l > 0 ? ((d = this), (g = o)) : ((d = o), (g = this));
              for (var w = 0, M = 0; M < g.length; M++)
                (u = (d.words[M] | 0) - (g.words[M] | 0) + w),
                  (w = u >> 26),
                  (this.words[M] = u & 67108863);
              for (; w !== 0 && M < d.length; M++)
                (u = (d.words[M] | 0) + w), (w = u >> 26), (this.words[M] = u & 67108863);
              if (w === 0 && M < d.length && d !== this)
                for (; M < d.length; M++) this.words[M] = d.words[M];
              return (
                (this.length = Math.max(this.length, M)),
                d !== this && (this.negative = 1),
                this.strip()
              );
            }),
            (n.prototype.sub = function (o) {
              return this.clone().isub(o);
            });
          function E(S, o, u) {
            u.negative = o.negative ^ S.negative;
            var l = (S.length + o.length) | 0;
            (u.length = l), (l = (l - 1) | 0);
            var d = S.words[0] | 0,
              g = o.words[0] | 0,
              w = d * g,
              M = w & 67108863,
              v = (w / 67108864) | 0;
            u.words[0] = M;
            for (var a = 1; a < l; a++) {
              for (
                var b = v >>> 26,
                  k = v & 67108863,
                  B = Math.min(a, o.length - 1),
                  F = Math.max(0, a - S.length + 1);
                F <= B;
                F++
              ) {
                var P = (a - F) | 0;
                (d = S.words[P] | 0),
                  (g = o.words[F] | 0),
                  (w = d * g + k),
                  (b += (w / 67108864) | 0),
                  (k = w & 67108863);
              }
              (u.words[a] = k | 0), (v = b | 0);
            }
            return v !== 0 ? (u.words[a] = v | 0) : u.length--, u.strip();
          }
          var I = function (o, u, l) {
            var d = o.words,
              g = u.words,
              w = l.words,
              M = 0,
              v,
              a,
              b,
              k = d[0] | 0,
              B = k & 8191,
              F = k >>> 13,
              P = d[1] | 0,
              C = P & 8191,
              z = P >>> 13,
              Y = d[2] | 0,
              G = Y & 8191,
              Q = Y >>> 13,
              U = d[3] | 0,
              $ = U & 8191,
              Z = U >>> 13,
              ae = d[4] | 0,
              fe = ae & 8191,
              le = ae >>> 13,
              Fe = d[5] | 0,
              be = Fe & 8191,
              oe = Fe >>> 13,
              rt = d[6] | 0,
              me = rt & 8191,
              re = rt >>> 13,
              ge = d[7] | 0,
              ce = ge & 8191,
              he = ge >>> 13,
              Ke = d[8] | 0,
              K = Ke & 8191,
              O = Ke >>> 13,
              W = d[9] | 0,
              T = W & 8191,
              x = W >>> 13,
              N = g[0] | 0,
              j = N & 8191,
              J = N >>> 13,
              de = g[1] | 0,
              ie = de & 8191,
              ye = de >>> 13,
              Ye = g[2] | 0,
              ve = Ye & 8191,
              _e = Ye >>> 13,
              et = g[3] | 0,
              Me = et & 8191,
              Ce = et >>> 13,
              yt = g[4] | 0,
              Ae = yt & 8191,
              Le = yt >>> 13,
              gt = g[5] | 0,
              Ee = gt & 8191,
              Ne = gt >>> 13,
              bt = g[6] | 0,
              ke = bt & 8191,
              $e = bt >>> 13,
              vt = g[7] | 0,
              Ie = vt & 8191,
              De = vt >>> 13,
              mt = g[8] | 0,
              xe = mt & 8191,
              Ue = mt >>> 13,
              wt = g[9] | 0,
              Be = wt & 8191,
              ze = wt >>> 13;
            (l.negative = o.negative ^ u.negative),
              (l.length = 19),
              (v = Math.imul(B, j)),
              (a = Math.imul(B, J)),
              (a = (a + Math.imul(F, j)) | 0),
              (b = Math.imul(F, J));
            var st = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (st >>> 26)) | 0),
              (st &= 67108863),
              (v = Math.imul(C, j)),
              (a = Math.imul(C, J)),
              (a = (a + Math.imul(z, j)) | 0),
              (b = Math.imul(z, J)),
              (v = (v + Math.imul(B, ie)) | 0),
              (a = (a + Math.imul(B, ye)) | 0),
              (a = (a + Math.imul(F, ie)) | 0),
              (b = (b + Math.imul(F, ye)) | 0);
            var at = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (at >>> 26)) | 0),
              (at &= 67108863),
              (v = Math.imul(G, j)),
              (a = Math.imul(G, J)),
              (a = (a + Math.imul(Q, j)) | 0),
              (b = Math.imul(Q, J)),
              (v = (v + Math.imul(C, ie)) | 0),
              (a = (a + Math.imul(C, ye)) | 0),
              (a = (a + Math.imul(z, ie)) | 0),
              (b = (b + Math.imul(z, ye)) | 0),
              (v = (v + Math.imul(B, ve)) | 0),
              (a = (a + Math.imul(B, _e)) | 0),
              (a = (a + Math.imul(F, ve)) | 0),
              (b = (b + Math.imul(F, _e)) | 0);
            var Ft = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (Ft >>> 26)) | 0),
              (Ft &= 67108863),
              (v = Math.imul($, j)),
              (a = Math.imul($, J)),
              (a = (a + Math.imul(Z, j)) | 0),
              (b = Math.imul(Z, J)),
              (v = (v + Math.imul(G, ie)) | 0),
              (a = (a + Math.imul(G, ye)) | 0),
              (a = (a + Math.imul(Q, ie)) | 0),
              (b = (b + Math.imul(Q, ye)) | 0),
              (v = (v + Math.imul(C, ve)) | 0),
              (a = (a + Math.imul(C, _e)) | 0),
              (a = (a + Math.imul(z, ve)) | 0),
              (b = (b + Math.imul(z, _e)) | 0),
              (v = (v + Math.imul(B, Me)) | 0),
              (a = (a + Math.imul(B, Ce)) | 0),
              (a = (a + Math.imul(F, Me)) | 0),
              (b = (b + Math.imul(F, Ce)) | 0);
            var qt = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (qt >>> 26)) | 0),
              (qt &= 67108863),
              (v = Math.imul(fe, j)),
              (a = Math.imul(fe, J)),
              (a = (a + Math.imul(le, j)) | 0),
              (b = Math.imul(le, J)),
              (v = (v + Math.imul($, ie)) | 0),
              (a = (a + Math.imul($, ye)) | 0),
              (a = (a + Math.imul(Z, ie)) | 0),
              (b = (b + Math.imul(Z, ye)) | 0),
              (v = (v + Math.imul(G, ve)) | 0),
              (a = (a + Math.imul(G, _e)) | 0),
              (a = (a + Math.imul(Q, ve)) | 0),
              (b = (b + Math.imul(Q, _e)) | 0),
              (v = (v + Math.imul(C, Me)) | 0),
              (a = (a + Math.imul(C, Ce)) | 0),
              (a = (a + Math.imul(z, Me)) | 0),
              (b = (b + Math.imul(z, Ce)) | 0),
              (v = (v + Math.imul(B, Ae)) | 0),
              (a = (a + Math.imul(B, Le)) | 0),
              (a = (a + Math.imul(F, Ae)) | 0),
              (b = (b + Math.imul(F, Le)) | 0);
            var Wt = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (Wt >>> 26)) | 0),
              (Wt &= 67108863),
              (v = Math.imul(be, j)),
              (a = Math.imul(be, J)),
              (a = (a + Math.imul(oe, j)) | 0),
              (b = Math.imul(oe, J)),
              (v = (v + Math.imul(fe, ie)) | 0),
              (a = (a + Math.imul(fe, ye)) | 0),
              (a = (a + Math.imul(le, ie)) | 0),
              (b = (b + Math.imul(le, ye)) | 0),
              (v = (v + Math.imul($, ve)) | 0),
              (a = (a + Math.imul($, _e)) | 0),
              (a = (a + Math.imul(Z, ve)) | 0),
              (b = (b + Math.imul(Z, _e)) | 0),
              (v = (v + Math.imul(G, Me)) | 0),
              (a = (a + Math.imul(G, Ce)) | 0),
              (a = (a + Math.imul(Q, Me)) | 0),
              (b = (b + Math.imul(Q, Ce)) | 0),
              (v = (v + Math.imul(C, Ae)) | 0),
              (a = (a + Math.imul(C, Le)) | 0),
              (a = (a + Math.imul(z, Ae)) | 0),
              (b = (b + Math.imul(z, Le)) | 0),
              (v = (v + Math.imul(B, Ee)) | 0),
              (a = (a + Math.imul(B, Ne)) | 0),
              (a = (a + Math.imul(F, Ee)) | 0),
              (b = (b + Math.imul(F, Ne)) | 0);
            var Kt = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (Kt >>> 26)) | 0),
              (Kt &= 67108863),
              (v = Math.imul(me, j)),
              (a = Math.imul(me, J)),
              (a = (a + Math.imul(re, j)) | 0),
              (b = Math.imul(re, J)),
              (v = (v + Math.imul(be, ie)) | 0),
              (a = (a + Math.imul(be, ye)) | 0),
              (a = (a + Math.imul(oe, ie)) | 0),
              (b = (b + Math.imul(oe, ye)) | 0),
              (v = (v + Math.imul(fe, ve)) | 0),
              (a = (a + Math.imul(fe, _e)) | 0),
              (a = (a + Math.imul(le, ve)) | 0),
              (b = (b + Math.imul(le, _e)) | 0),
              (v = (v + Math.imul($, Me)) | 0),
              (a = (a + Math.imul($, Ce)) | 0),
              (a = (a + Math.imul(Z, Me)) | 0),
              (b = (b + Math.imul(Z, Ce)) | 0),
              (v = (v + Math.imul(G, Ae)) | 0),
              (a = (a + Math.imul(G, Le)) | 0),
              (a = (a + Math.imul(Q, Ae)) | 0),
              (b = (b + Math.imul(Q, Le)) | 0),
              (v = (v + Math.imul(C, Ee)) | 0),
              (a = (a + Math.imul(C, Ne)) | 0),
              (a = (a + Math.imul(z, Ee)) | 0),
              (b = (b + Math.imul(z, Ne)) | 0),
              (v = (v + Math.imul(B, ke)) | 0),
              (a = (a + Math.imul(B, $e)) | 0),
              (a = (a + Math.imul(F, ke)) | 0),
              (b = (b + Math.imul(F, $e)) | 0);
            var jt = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (jt >>> 26)) | 0),
              (jt &= 67108863),
              (v = Math.imul(ce, j)),
              (a = Math.imul(ce, J)),
              (a = (a + Math.imul(he, j)) | 0),
              (b = Math.imul(he, J)),
              (v = (v + Math.imul(me, ie)) | 0),
              (a = (a + Math.imul(me, ye)) | 0),
              (a = (a + Math.imul(re, ie)) | 0),
              (b = (b + Math.imul(re, ye)) | 0),
              (v = (v + Math.imul(be, ve)) | 0),
              (a = (a + Math.imul(be, _e)) | 0),
              (a = (a + Math.imul(oe, ve)) | 0),
              (b = (b + Math.imul(oe, _e)) | 0),
              (v = (v + Math.imul(fe, Me)) | 0),
              (a = (a + Math.imul(fe, Ce)) | 0),
              (a = (a + Math.imul(le, Me)) | 0),
              (b = (b + Math.imul(le, Ce)) | 0),
              (v = (v + Math.imul($, Ae)) | 0),
              (a = (a + Math.imul($, Le)) | 0),
              (a = (a + Math.imul(Z, Ae)) | 0),
              (b = (b + Math.imul(Z, Le)) | 0),
              (v = (v + Math.imul(G, Ee)) | 0),
              (a = (a + Math.imul(G, Ne)) | 0),
              (a = (a + Math.imul(Q, Ee)) | 0),
              (b = (b + Math.imul(Q, Ne)) | 0),
              (v = (v + Math.imul(C, ke)) | 0),
              (a = (a + Math.imul(C, $e)) | 0),
              (a = (a + Math.imul(z, ke)) | 0),
              (b = (b + Math.imul(z, $e)) | 0),
              (v = (v + Math.imul(B, Ie)) | 0),
              (a = (a + Math.imul(B, De)) | 0),
              (a = (a + Math.imul(F, Ie)) | 0),
              (b = (b + Math.imul(F, De)) | 0);
            var fr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (fr >>> 26)) | 0),
              (fr &= 67108863),
              (v = Math.imul(K, j)),
              (a = Math.imul(K, J)),
              (a = (a + Math.imul(O, j)) | 0),
              (b = Math.imul(O, J)),
              (v = (v + Math.imul(ce, ie)) | 0),
              (a = (a + Math.imul(ce, ye)) | 0),
              (a = (a + Math.imul(he, ie)) | 0),
              (b = (b + Math.imul(he, ye)) | 0),
              (v = (v + Math.imul(me, ve)) | 0),
              (a = (a + Math.imul(me, _e)) | 0),
              (a = (a + Math.imul(re, ve)) | 0),
              (b = (b + Math.imul(re, _e)) | 0),
              (v = (v + Math.imul(be, Me)) | 0),
              (a = (a + Math.imul(be, Ce)) | 0),
              (a = (a + Math.imul(oe, Me)) | 0),
              (b = (b + Math.imul(oe, Ce)) | 0),
              (v = (v + Math.imul(fe, Ae)) | 0),
              (a = (a + Math.imul(fe, Le)) | 0),
              (a = (a + Math.imul(le, Ae)) | 0),
              (b = (b + Math.imul(le, Le)) | 0),
              (v = (v + Math.imul($, Ee)) | 0),
              (a = (a + Math.imul($, Ne)) | 0),
              (a = (a + Math.imul(Z, Ee)) | 0),
              (b = (b + Math.imul(Z, Ne)) | 0),
              (v = (v + Math.imul(G, ke)) | 0),
              (a = (a + Math.imul(G, $e)) | 0),
              (a = (a + Math.imul(Q, ke)) | 0),
              (b = (b + Math.imul(Q, $e)) | 0),
              (v = (v + Math.imul(C, Ie)) | 0),
              (a = (a + Math.imul(C, De)) | 0),
              (a = (a + Math.imul(z, Ie)) | 0),
              (b = (b + Math.imul(z, De)) | 0),
              (v = (v + Math.imul(B, xe)) | 0),
              (a = (a + Math.imul(B, Ue)) | 0),
              (a = (a + Math.imul(F, xe)) | 0),
              (b = (b + Math.imul(F, Ue)) | 0);
            var lr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (lr >>> 26)) | 0),
              (lr &= 67108863),
              (v = Math.imul(T, j)),
              (a = Math.imul(T, J)),
              (a = (a + Math.imul(x, j)) | 0),
              (b = Math.imul(x, J)),
              (v = (v + Math.imul(K, ie)) | 0),
              (a = (a + Math.imul(K, ye)) | 0),
              (a = (a + Math.imul(O, ie)) | 0),
              (b = (b + Math.imul(O, ye)) | 0),
              (v = (v + Math.imul(ce, ve)) | 0),
              (a = (a + Math.imul(ce, _e)) | 0),
              (a = (a + Math.imul(he, ve)) | 0),
              (b = (b + Math.imul(he, _e)) | 0),
              (v = (v + Math.imul(me, Me)) | 0),
              (a = (a + Math.imul(me, Ce)) | 0),
              (a = (a + Math.imul(re, Me)) | 0),
              (b = (b + Math.imul(re, Ce)) | 0),
              (v = (v + Math.imul(be, Ae)) | 0),
              (a = (a + Math.imul(be, Le)) | 0),
              (a = (a + Math.imul(oe, Ae)) | 0),
              (b = (b + Math.imul(oe, Le)) | 0),
              (v = (v + Math.imul(fe, Ee)) | 0),
              (a = (a + Math.imul(fe, Ne)) | 0),
              (a = (a + Math.imul(le, Ee)) | 0),
              (b = (b + Math.imul(le, Ne)) | 0),
              (v = (v + Math.imul($, ke)) | 0),
              (a = (a + Math.imul($, $e)) | 0),
              (a = (a + Math.imul(Z, ke)) | 0),
              (b = (b + Math.imul(Z, $e)) | 0),
              (v = (v + Math.imul(G, Ie)) | 0),
              (a = (a + Math.imul(G, De)) | 0),
              (a = (a + Math.imul(Q, Ie)) | 0),
              (b = (b + Math.imul(Q, De)) | 0),
              (v = (v + Math.imul(C, xe)) | 0),
              (a = (a + Math.imul(C, Ue)) | 0),
              (a = (a + Math.imul(z, xe)) | 0),
              (b = (b + Math.imul(z, Ue)) | 0),
              (v = (v + Math.imul(B, Be)) | 0),
              (a = (a + Math.imul(B, ze)) | 0),
              (a = (a + Math.imul(F, Be)) | 0),
              (b = (b + Math.imul(F, ze)) | 0);
            var hr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (hr >>> 26)) | 0),
              (hr &= 67108863),
              (v = Math.imul(T, ie)),
              (a = Math.imul(T, ye)),
              (a = (a + Math.imul(x, ie)) | 0),
              (b = Math.imul(x, ye)),
              (v = (v + Math.imul(K, ve)) | 0),
              (a = (a + Math.imul(K, _e)) | 0),
              (a = (a + Math.imul(O, ve)) | 0),
              (b = (b + Math.imul(O, _e)) | 0),
              (v = (v + Math.imul(ce, Me)) | 0),
              (a = (a + Math.imul(ce, Ce)) | 0),
              (a = (a + Math.imul(he, Me)) | 0),
              (b = (b + Math.imul(he, Ce)) | 0),
              (v = (v + Math.imul(me, Ae)) | 0),
              (a = (a + Math.imul(me, Le)) | 0),
              (a = (a + Math.imul(re, Ae)) | 0),
              (b = (b + Math.imul(re, Le)) | 0),
              (v = (v + Math.imul(be, Ee)) | 0),
              (a = (a + Math.imul(be, Ne)) | 0),
              (a = (a + Math.imul(oe, Ee)) | 0),
              (b = (b + Math.imul(oe, Ne)) | 0),
              (v = (v + Math.imul(fe, ke)) | 0),
              (a = (a + Math.imul(fe, $e)) | 0),
              (a = (a + Math.imul(le, ke)) | 0),
              (b = (b + Math.imul(le, $e)) | 0),
              (v = (v + Math.imul($, Ie)) | 0),
              (a = (a + Math.imul($, De)) | 0),
              (a = (a + Math.imul(Z, Ie)) | 0),
              (b = (b + Math.imul(Z, De)) | 0),
              (v = (v + Math.imul(G, xe)) | 0),
              (a = (a + Math.imul(G, Ue)) | 0),
              (a = (a + Math.imul(Q, xe)) | 0),
              (b = (b + Math.imul(Q, Ue)) | 0),
              (v = (v + Math.imul(C, Be)) | 0),
              (a = (a + Math.imul(C, ze)) | 0),
              (a = (a + Math.imul(z, Be)) | 0),
              (b = (b + Math.imul(z, ze)) | 0);
            var dr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (dr >>> 26)) | 0),
              (dr &= 67108863),
              (v = Math.imul(T, ve)),
              (a = Math.imul(T, _e)),
              (a = (a + Math.imul(x, ve)) | 0),
              (b = Math.imul(x, _e)),
              (v = (v + Math.imul(K, Me)) | 0),
              (a = (a + Math.imul(K, Ce)) | 0),
              (a = (a + Math.imul(O, Me)) | 0),
              (b = (b + Math.imul(O, Ce)) | 0),
              (v = (v + Math.imul(ce, Ae)) | 0),
              (a = (a + Math.imul(ce, Le)) | 0),
              (a = (a + Math.imul(he, Ae)) | 0),
              (b = (b + Math.imul(he, Le)) | 0),
              (v = (v + Math.imul(me, Ee)) | 0),
              (a = (a + Math.imul(me, Ne)) | 0),
              (a = (a + Math.imul(re, Ee)) | 0),
              (b = (b + Math.imul(re, Ne)) | 0),
              (v = (v + Math.imul(be, ke)) | 0),
              (a = (a + Math.imul(be, $e)) | 0),
              (a = (a + Math.imul(oe, ke)) | 0),
              (b = (b + Math.imul(oe, $e)) | 0),
              (v = (v + Math.imul(fe, Ie)) | 0),
              (a = (a + Math.imul(fe, De)) | 0),
              (a = (a + Math.imul(le, Ie)) | 0),
              (b = (b + Math.imul(le, De)) | 0),
              (v = (v + Math.imul($, xe)) | 0),
              (a = (a + Math.imul($, Ue)) | 0),
              (a = (a + Math.imul(Z, xe)) | 0),
              (b = (b + Math.imul(Z, Ue)) | 0),
              (v = (v + Math.imul(G, Be)) | 0),
              (a = (a + Math.imul(G, ze)) | 0),
              (a = (a + Math.imul(Q, Be)) | 0),
              (b = (b + Math.imul(Q, ze)) | 0);
            var pr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (pr >>> 26)) | 0),
              (pr &= 67108863),
              (v = Math.imul(T, Me)),
              (a = Math.imul(T, Ce)),
              (a = (a + Math.imul(x, Me)) | 0),
              (b = Math.imul(x, Ce)),
              (v = (v + Math.imul(K, Ae)) | 0),
              (a = (a + Math.imul(K, Le)) | 0),
              (a = (a + Math.imul(O, Ae)) | 0),
              (b = (b + Math.imul(O, Le)) | 0),
              (v = (v + Math.imul(ce, Ee)) | 0),
              (a = (a + Math.imul(ce, Ne)) | 0),
              (a = (a + Math.imul(he, Ee)) | 0),
              (b = (b + Math.imul(he, Ne)) | 0),
              (v = (v + Math.imul(me, ke)) | 0),
              (a = (a + Math.imul(me, $e)) | 0),
              (a = (a + Math.imul(re, ke)) | 0),
              (b = (b + Math.imul(re, $e)) | 0),
              (v = (v + Math.imul(be, Ie)) | 0),
              (a = (a + Math.imul(be, De)) | 0),
              (a = (a + Math.imul(oe, Ie)) | 0),
              (b = (b + Math.imul(oe, De)) | 0),
              (v = (v + Math.imul(fe, xe)) | 0),
              (a = (a + Math.imul(fe, Ue)) | 0),
              (a = (a + Math.imul(le, xe)) | 0),
              (b = (b + Math.imul(le, Ue)) | 0),
              (v = (v + Math.imul($, Be)) | 0),
              (a = (a + Math.imul($, ze)) | 0),
              (a = (a + Math.imul(Z, Be)) | 0),
              (b = (b + Math.imul(Z, ze)) | 0);
            var yr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (yr >>> 26)) | 0),
              (yr &= 67108863),
              (v = Math.imul(T, Ae)),
              (a = Math.imul(T, Le)),
              (a = (a + Math.imul(x, Ae)) | 0),
              (b = Math.imul(x, Le)),
              (v = (v + Math.imul(K, Ee)) | 0),
              (a = (a + Math.imul(K, Ne)) | 0),
              (a = (a + Math.imul(O, Ee)) | 0),
              (b = (b + Math.imul(O, Ne)) | 0),
              (v = (v + Math.imul(ce, ke)) | 0),
              (a = (a + Math.imul(ce, $e)) | 0),
              (a = (a + Math.imul(he, ke)) | 0),
              (b = (b + Math.imul(he, $e)) | 0),
              (v = (v + Math.imul(me, Ie)) | 0),
              (a = (a + Math.imul(me, De)) | 0),
              (a = (a + Math.imul(re, Ie)) | 0),
              (b = (b + Math.imul(re, De)) | 0),
              (v = (v + Math.imul(be, xe)) | 0),
              (a = (a + Math.imul(be, Ue)) | 0),
              (a = (a + Math.imul(oe, xe)) | 0),
              (b = (b + Math.imul(oe, Ue)) | 0),
              (v = (v + Math.imul(fe, Be)) | 0),
              (a = (a + Math.imul(fe, ze)) | 0),
              (a = (a + Math.imul(le, Be)) | 0),
              (b = (b + Math.imul(le, ze)) | 0);
            var gr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (gr >>> 26)) | 0),
              (gr &= 67108863),
              (v = Math.imul(T, Ee)),
              (a = Math.imul(T, Ne)),
              (a = (a + Math.imul(x, Ee)) | 0),
              (b = Math.imul(x, Ne)),
              (v = (v + Math.imul(K, ke)) | 0),
              (a = (a + Math.imul(K, $e)) | 0),
              (a = (a + Math.imul(O, ke)) | 0),
              (b = (b + Math.imul(O, $e)) | 0),
              (v = (v + Math.imul(ce, Ie)) | 0),
              (a = (a + Math.imul(ce, De)) | 0),
              (a = (a + Math.imul(he, Ie)) | 0),
              (b = (b + Math.imul(he, De)) | 0),
              (v = (v + Math.imul(me, xe)) | 0),
              (a = (a + Math.imul(me, Ue)) | 0),
              (a = (a + Math.imul(re, xe)) | 0),
              (b = (b + Math.imul(re, Ue)) | 0),
              (v = (v + Math.imul(be, Be)) | 0),
              (a = (a + Math.imul(be, ze)) | 0),
              (a = (a + Math.imul(oe, Be)) | 0),
              (b = (b + Math.imul(oe, ze)) | 0);
            var br = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (br >>> 26)) | 0),
              (br &= 67108863),
              (v = Math.imul(T, ke)),
              (a = Math.imul(T, $e)),
              (a = (a + Math.imul(x, ke)) | 0),
              (b = Math.imul(x, $e)),
              (v = (v + Math.imul(K, Ie)) | 0),
              (a = (a + Math.imul(K, De)) | 0),
              (a = (a + Math.imul(O, Ie)) | 0),
              (b = (b + Math.imul(O, De)) | 0),
              (v = (v + Math.imul(ce, xe)) | 0),
              (a = (a + Math.imul(ce, Ue)) | 0),
              (a = (a + Math.imul(he, xe)) | 0),
              (b = (b + Math.imul(he, Ue)) | 0),
              (v = (v + Math.imul(me, Be)) | 0),
              (a = (a + Math.imul(me, ze)) | 0),
              (a = (a + Math.imul(re, Be)) | 0),
              (b = (b + Math.imul(re, ze)) | 0);
            var vr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (vr >>> 26)) | 0),
              (vr &= 67108863),
              (v = Math.imul(T, Ie)),
              (a = Math.imul(T, De)),
              (a = (a + Math.imul(x, Ie)) | 0),
              (b = Math.imul(x, De)),
              (v = (v + Math.imul(K, xe)) | 0),
              (a = (a + Math.imul(K, Ue)) | 0),
              (a = (a + Math.imul(O, xe)) | 0),
              (b = (b + Math.imul(O, Ue)) | 0),
              (v = (v + Math.imul(ce, Be)) | 0),
              (a = (a + Math.imul(ce, ze)) | 0),
              (a = (a + Math.imul(he, Be)) | 0),
              (b = (b + Math.imul(he, ze)) | 0);
            var mr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (mr >>> 26)) | 0),
              (mr &= 67108863),
              (v = Math.imul(T, xe)),
              (a = Math.imul(T, Ue)),
              (a = (a + Math.imul(x, xe)) | 0),
              (b = Math.imul(x, Ue)),
              (v = (v + Math.imul(K, Be)) | 0),
              (a = (a + Math.imul(K, ze)) | 0),
              (a = (a + Math.imul(O, Be)) | 0),
              (b = (b + Math.imul(O, ze)) | 0);
            var wr = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            (M = (((b + (a >>> 13)) | 0) + (wr >>> 26)) | 0),
              (wr &= 67108863),
              (v = Math.imul(T, Be)),
              (a = Math.imul(T, ze)),
              (a = (a + Math.imul(x, Be)) | 0),
              (b = Math.imul(x, ze));
            var _r = (((M + v) | 0) + ((a & 8191) << 13)) | 0;
            return (
              (M = (((b + (a >>> 13)) | 0) + (_r >>> 26)) | 0),
              (_r &= 67108863),
              (w[0] = st),
              (w[1] = at),
              (w[2] = Ft),
              (w[3] = qt),
              (w[4] = Wt),
              (w[5] = Kt),
              (w[6] = jt),
              (w[7] = fr),
              (w[8] = lr),
              (w[9] = hr),
              (w[10] = dr),
              (w[11] = pr),
              (w[12] = yr),
              (w[13] = gr),
              (w[14] = br),
              (w[15] = vr),
              (w[16] = mr),
              (w[17] = wr),
              (w[18] = _r),
              M !== 0 && ((w[19] = M), l.length++),
              l
            );
          };
          Math.imul || (I = E);
          function R(S, o, u) {
            (u.negative = o.negative ^ S.negative), (u.length = S.length + o.length);
            for (var l = 0, d = 0, g = 0; g < u.length - 1; g++) {
              var w = d;
              d = 0;
              for (
                var M = l & 67108863,
                  v = Math.min(g, o.length - 1),
                  a = Math.max(0, g - S.length + 1);
                a <= v;
                a++
              ) {
                var b = g - a,
                  k = S.words[b] | 0,
                  B = o.words[a] | 0,
                  F = k * B,
                  P = F & 67108863;
                (w = (w + ((F / 67108864) | 0)) | 0),
                  (P = (P + M) | 0),
                  (M = P & 67108863),
                  (w = (w + (P >>> 26)) | 0),
                  (d += w >>> 26),
                  (w &= 67108863);
              }
              (u.words[g] = M), (l = w), (w = d);
            }
            return l !== 0 ? (u.words[g] = l) : u.length--, u.strip();
          }
          function L(S, o, u) {
            var l = new D();
            return l.mulp(S, o, u);
          }
          n.prototype.mulTo = function (o, u) {
            var l,
              d = this.length + o.length;
            return (
              this.length === 10 && o.length === 10
                ? (l = I(this, o, u))
                : d < 63
                  ? (l = E(this, o, u))
                  : d < 1024
                    ? (l = R(this, o, u))
                    : (l = L(this, o, u)),
              l
            );
          };
          function D(S, o) {
            (this.x = S), (this.y = o);
          }
          (D.prototype.makeRBT = function (o) {
            for (var u = new Array(o), l = n.prototype._countBits(o) - 1, d = 0; d < o; d++)
              u[d] = this.revBin(d, l, o);
            return u;
          }),
            (D.prototype.revBin = function (o, u, l) {
              if (o === 0 || o === l - 1) return o;
              for (var d = 0, g = 0; g < u; g++) (d |= (o & 1) << (u - g - 1)), (o >>= 1);
              return d;
            }),
            (D.prototype.permute = function (o, u, l, d, g, w) {
              for (var M = 0; M < w; M++) (d[M] = u[o[M]]), (g[M] = l[o[M]]);
            }),
            (D.prototype.transform = function (o, u, l, d, g, w) {
              this.permute(w, o, u, l, d, g);
              for (var M = 1; M < g; M <<= 1)
                for (
                  var v = M << 1,
                    a = Math.cos((2 * Math.PI) / v),
                    b = Math.sin((2 * Math.PI) / v),
                    k = 0;
                  k < g;
                  k += v
                )
                  for (var B = a, F = b, P = 0; P < M; P++) {
                    var C = l[k + P],
                      z = d[k + P],
                      Y = l[k + P + M],
                      G = d[k + P + M],
                      Q = B * Y - F * G;
                    (G = B * G + F * Y),
                      (Y = Q),
                      (l[k + P] = C + Y),
                      (d[k + P] = z + G),
                      (l[k + P + M] = C - Y),
                      (d[k + P + M] = z - G),
                      P !== v && ((Q = a * B - b * F), (F = a * F + b * B), (B = Q));
                  }
            }),
            (D.prototype.guessLen13b = function (o, u) {
              var l = Math.max(u, o) | 1,
                d = l & 1,
                g = 0;
              for (l = (l / 2) | 0; l; l = l >>> 1) g++;
              return 1 << (g + 1 + d);
            }),
            (D.prototype.conjugate = function (o, u, l) {
              if (!(l <= 1))
                for (var d = 0; d < l / 2; d++) {
                  var g = o[d];
                  (o[d] = o[l - d - 1]),
                    (o[l - d - 1] = g),
                    (g = u[d]),
                    (u[d] = -u[l - d - 1]),
                    (u[l - d - 1] = -g);
                }
            }),
            (D.prototype.normalize13b = function (o, u) {
              for (var l = 0, d = 0; d < u / 2; d++) {
                var g = Math.round(o[2 * d + 1] / u) * 8192 + Math.round(o[2 * d] / u) + l;
                (o[d] = g & 67108863), g < 67108864 ? (l = 0) : (l = (g / 67108864) | 0);
              }
              return o;
            }),
            (D.prototype.convert13b = function (o, u, l, d) {
              for (var g = 0, w = 0; w < u; w++)
                (g = g + (o[w] | 0)),
                  (l[2 * w] = g & 8191),
                  (g = g >>> 13),
                  (l[2 * w + 1] = g & 8191),
                  (g = g >>> 13);
              for (w = 2 * u; w < d; ++w) l[w] = 0;
              r(g === 0), r((g & -8192) === 0);
            }),
            (D.prototype.stub = function (o) {
              for (var u = new Array(o), l = 0; l < o; l++) u[l] = 0;
              return u;
            }),
            (D.prototype.mulp = function (o, u, l) {
              var d = 2 * this.guessLen13b(o.length, u.length),
                g = this.makeRBT(d),
                w = this.stub(d),
                M = new Array(d),
                v = new Array(d),
                a = new Array(d),
                b = new Array(d),
                k = new Array(d),
                B = new Array(d),
                F = l.words;
              (F.length = d),
                this.convert13b(o.words, o.length, M, d),
                this.convert13b(u.words, u.length, b, d),
                this.transform(M, w, v, a, d, g),
                this.transform(b, w, k, B, d, g);
              for (var P = 0; P < d; P++) {
                var C = v[P] * k[P] - a[P] * B[P];
                (a[P] = v[P] * B[P] + a[P] * k[P]), (v[P] = C);
              }
              return (
                this.conjugate(v, a, d),
                this.transform(v, a, F, w, d, g),
                this.conjugate(F, w, d),
                this.normalize13b(F, d),
                (l.negative = o.negative ^ u.negative),
                (l.length = o.length + u.length),
                l.strip()
              );
            }),
            (n.prototype.mul = function (o) {
              var u = new n(null);
              return (u.words = new Array(this.length + o.length)), this.mulTo(o, u);
            }),
            (n.prototype.mulf = function (o) {
              var u = new n(null);
              return (u.words = new Array(this.length + o.length)), L(this, o, u);
            }),
            (n.prototype.imul = function (o) {
              return this.clone().mulTo(o, this);
            }),
            (n.prototype.imuln = function (o) {
              r(typeof o == 'number'), r(o < 67108864);
              for (var u = 0, l = 0; l < this.length; l++) {
                var d = (this.words[l] | 0) * o,
                  g = (d & 67108863) + (u & 67108863);
                (u >>= 26),
                  (u += (d / 67108864) | 0),
                  (u += g >>> 26),
                  (this.words[l] = g & 67108863);
              }
              return u !== 0 && ((this.words[l] = u), this.length++), this;
            }),
            (n.prototype.muln = function (o) {
              return this.clone().imuln(o);
            }),
            (n.prototype.sqr = function () {
              return this.mul(this);
            }),
            (n.prototype.isqr = function () {
              return this.imul(this.clone());
            }),
            (n.prototype.pow = function (o) {
              var u = A(o);
              if (u.length === 0) return new n(1);
              for (var l = this, d = 0; d < u.length && u[d] === 0; d++, l = l.sqr());
              if (++d < u.length)
                for (var g = l.sqr(); d < u.length; d++, g = g.sqr()) u[d] !== 0 && (l = l.mul(g));
              return l;
            }),
            (n.prototype.iushln = function (o) {
              r(typeof o == 'number' && o >= 0);
              var u = o % 26,
                l = (o - u) / 26,
                d = (67108863 >>> (26 - u)) << (26 - u),
                g;
              if (u !== 0) {
                var w = 0;
                for (g = 0; g < this.length; g++) {
                  var M = this.words[g] & d,
                    v = ((this.words[g] | 0) - M) << u;
                  (this.words[g] = v | w), (w = M >>> (26 - u));
                }
                w && ((this.words[g] = w), this.length++);
              }
              if (l !== 0) {
                for (g = this.length - 1; g >= 0; g--) this.words[g + l] = this.words[g];
                for (g = 0; g < l; g++) this.words[g] = 0;
                this.length += l;
              }
              return this.strip();
            }),
            (n.prototype.ishln = function (o) {
              return r(this.negative === 0), this.iushln(o);
            }),
            (n.prototype.iushrn = function (o, u, l) {
              r(typeof o == 'number' && o >= 0);
              var d;
              u ? (d = (u - (u % 26)) / 26) : (d = 0);
              var g = o % 26,
                w = Math.min((o - g) / 26, this.length),
                M = 67108863 ^ ((67108863 >>> g) << g),
                v = l;
              if (((d -= w), (d = Math.max(0, d)), v)) {
                for (var a = 0; a < w; a++) v.words[a] = this.words[a];
                v.length = w;
              }
              if (w !== 0)
                if (this.length > w)
                  for (this.length -= w, a = 0; a < this.length; a++)
                    this.words[a] = this.words[a + w];
                else (this.words[0] = 0), (this.length = 1);
              var b = 0;
              for (a = this.length - 1; a >= 0 && (b !== 0 || a >= d); a--) {
                var k = this.words[a] | 0;
                (this.words[a] = (b << (26 - g)) | (k >>> g)), (b = k & M);
              }
              return (
                v && b !== 0 && (v.words[v.length++] = b),
                this.length === 0 && ((this.words[0] = 0), (this.length = 1)),
                this.strip()
              );
            }),
            (n.prototype.ishrn = function (o, u, l) {
              return r(this.negative === 0), this.iushrn(o, u, l);
            }),
            (n.prototype.shln = function (o) {
              return this.clone().ishln(o);
            }),
            (n.prototype.ushln = function (o) {
              return this.clone().iushln(o);
            }),
            (n.prototype.shrn = function (o) {
              return this.clone().ishrn(o);
            }),
            (n.prototype.ushrn = function (o) {
              return this.clone().iushrn(o);
            }),
            (n.prototype.testn = function (o) {
              r(typeof o == 'number' && o >= 0);
              var u = o % 26,
                l = (o - u) / 26,
                d = 1 << u;
              if (this.length <= l) return !1;
              var g = this.words[l];
              return !!(g & d);
            }),
            (n.prototype.imaskn = function (o) {
              r(typeof o == 'number' && o >= 0);
              var u = o % 26,
                l = (o - u) / 26;
              if (
                (r(this.negative === 0, 'imaskn works only with positive numbers'),
                this.length <= l)
              )
                return this;
              if ((u !== 0 && l++, (this.length = Math.min(l, this.length)), u !== 0)) {
                var d = 67108863 ^ ((67108863 >>> u) << u);
                this.words[this.length - 1] &= d;
              }
              return this.strip();
            }),
            (n.prototype.maskn = function (o) {
              return this.clone().imaskn(o);
            }),
            (n.prototype.iaddn = function (o) {
              return (
                r(typeof o == 'number'),
                r(o < 67108864),
                o < 0
                  ? this.isubn(-o)
                  : this.negative !== 0
                    ? this.length === 1 && (this.words[0] | 0) < o
                      ? ((this.words[0] = o - (this.words[0] | 0)), (this.negative = 0), this)
                      : ((this.negative = 0), this.isubn(o), (this.negative = 1), this)
                    : this._iaddn(o)
              );
            }),
            (n.prototype._iaddn = function (o) {
              this.words[0] += o;
              for (var u = 0; u < this.length && this.words[u] >= 67108864; u++)
                (this.words[u] -= 67108864),
                  u === this.length - 1 ? (this.words[u + 1] = 1) : this.words[u + 1]++;
              return (this.length = Math.max(this.length, u + 1)), this;
            }),
            (n.prototype.isubn = function (o) {
              if ((r(typeof o == 'number'), r(o < 67108864), o < 0)) return this.iaddn(-o);
              if (this.negative !== 0)
                return (this.negative = 0), this.iaddn(o), (this.negative = 1), this;
              if (((this.words[0] -= o), this.length === 1 && this.words[0] < 0))
                (this.words[0] = -this.words[0]), (this.negative = 1);
              else
                for (var u = 0; u < this.length && this.words[u] < 0; u++)
                  (this.words[u] += 67108864), (this.words[u + 1] -= 1);
              return this.strip();
            }),
            (n.prototype.addn = function (o) {
              return this.clone().iaddn(o);
            }),
            (n.prototype.subn = function (o) {
              return this.clone().isubn(o);
            }),
            (n.prototype.iabs = function () {
              return (this.negative = 0), this;
            }),
            (n.prototype.abs = function () {
              return this.clone().iabs();
            }),
            (n.prototype._ishlnsubmul = function (o, u, l) {
              var d = o.length + l,
                g;
              this._expand(d);
              var w,
                M = 0;
              for (g = 0; g < o.length; g++) {
                w = (this.words[g + l] | 0) + M;
                var v = (o.words[g] | 0) * u;
                (w -= v & 67108863),
                  (M = (w >> 26) - ((v / 67108864) | 0)),
                  (this.words[g + l] = w & 67108863);
              }
              for (; g < this.length - l; g++)
                (w = (this.words[g + l] | 0) + M),
                  (M = w >> 26),
                  (this.words[g + l] = w & 67108863);
              if (M === 0) return this.strip();
              for (r(M === -1), M = 0, g = 0; g < this.length; g++)
                (w = -(this.words[g] | 0) + M), (M = w >> 26), (this.words[g] = w & 67108863);
              return (this.negative = 1), this.strip();
            }),
            (n.prototype._wordDiv = function (o, u) {
              var l = this.length - o.length,
                d = this.clone(),
                g = o,
                w = g.words[g.length - 1] | 0,
                M = this._countBits(w);
              (l = 26 - M),
                l !== 0 && ((g = g.ushln(l)), d.iushln(l), (w = g.words[g.length - 1] | 0));
              var v = d.length - g.length,
                a;
              if (u !== 'mod') {
                (a = new n(null)), (a.length = v + 1), (a.words = new Array(a.length));
                for (var b = 0; b < a.length; b++) a.words[b] = 0;
              }
              var k = d.clone()._ishlnsubmul(g, 1, v);
              k.negative === 0 && ((d = k), a && (a.words[v] = 1));
              for (var B = v - 1; B >= 0; B--) {
                var F = (d.words[g.length + B] | 0) * 67108864 + (d.words[g.length + B - 1] | 0);
                for (
                  F = Math.min((F / w) | 0, 67108863), d._ishlnsubmul(g, F, B);
                  d.negative !== 0;

                )
                  F--, (d.negative = 0), d._ishlnsubmul(g, 1, B), d.isZero() || (d.negative ^= 1);
                a && (a.words[B] = F);
              }
              return (
                a && a.strip(),
                d.strip(),
                u !== 'div' && l !== 0 && d.iushrn(l),
                { div: a || null, mod: d }
              );
            }),
            (n.prototype.divmod = function (o, u, l) {
              if ((r(!o.isZero()), this.isZero())) return { div: new n(0), mod: new n(0) };
              var d, g, w;
              return this.negative !== 0 && o.negative === 0
                ? ((w = this.neg().divmod(o, u)),
                  u !== 'mod' && (d = w.div.neg()),
                  u !== 'div' && ((g = w.mod.neg()), l && g.negative !== 0 && g.iadd(o)),
                  { div: d, mod: g })
                : this.negative === 0 && o.negative !== 0
                  ? ((w = this.divmod(o.neg(), u)),
                    u !== 'mod' && (d = w.div.neg()),
                    { div: d, mod: w.mod })
                  : this.negative & o.negative
                    ? ((w = this.neg().divmod(o.neg(), u)),
                      u !== 'div' && ((g = w.mod.neg()), l && g.negative !== 0 && g.isub(o)),
                      { div: w.div, mod: g })
                    : o.length > this.length || this.cmp(o) < 0
                      ? { div: new n(0), mod: this }
                      : o.length === 1
                        ? u === 'div'
                          ? { div: this.divn(o.words[0]), mod: null }
                          : u === 'mod'
                            ? { div: null, mod: new n(this.modn(o.words[0])) }
                            : { div: this.divn(o.words[0]), mod: new n(this.modn(o.words[0])) }
                        : this._wordDiv(o, u);
            }),
            (n.prototype.div = function (o) {
              return this.divmod(o, 'div', !1).div;
            }),
            (n.prototype.mod = function (o) {
              return this.divmod(o, 'mod', !1).mod;
            }),
            (n.prototype.umod = function (o) {
              return this.divmod(o, 'mod', !0).mod;
            }),
            (n.prototype.divRound = function (o) {
              var u = this.divmod(o);
              if (u.mod.isZero()) return u.div;
              var l = u.div.negative !== 0 ? u.mod.isub(o) : u.mod,
                d = o.ushrn(1),
                g = o.andln(1),
                w = l.cmp(d);
              return w < 0 || (g === 1 && w === 0)
                ? u.div
                : u.div.negative !== 0
                  ? u.div.isubn(1)
                  : u.div.iaddn(1);
            }),
            (n.prototype.modn = function (o) {
              r(o <= 67108863);
              for (var u = (1 << 26) % o, l = 0, d = this.length - 1; d >= 0; d--)
                l = (u * l + (this.words[d] | 0)) % o;
              return l;
            }),
            (n.prototype.idivn = function (o) {
              r(o <= 67108863);
              for (var u = 0, l = this.length - 1; l >= 0; l--) {
                var d = (this.words[l] | 0) + u * 67108864;
                (this.words[l] = (d / o) | 0), (u = d % o);
              }
              return this.strip();
            }),
            (n.prototype.divn = function (o) {
              return this.clone().idivn(o);
            }),
            (n.prototype.egcd = function (o) {
              r(o.negative === 0), r(!o.isZero());
              var u = this,
                l = o.clone();
              u.negative !== 0 ? (u = u.umod(o)) : (u = u.clone());
              for (
                var d = new n(1), g = new n(0), w = new n(0), M = new n(1), v = 0;
                u.isEven() && l.isEven();

              )
                u.iushrn(1), l.iushrn(1), ++v;
              for (var a = l.clone(), b = u.clone(); !u.isZero(); ) {
                for (var k = 0, B = 1; !(u.words[0] & B) && k < 26; ++k, B <<= 1);
                if (k > 0)
                  for (u.iushrn(k); k-- > 0; )
                    (d.isOdd() || g.isOdd()) && (d.iadd(a), g.isub(b)), d.iushrn(1), g.iushrn(1);
                for (var F = 0, P = 1; !(l.words[0] & P) && F < 26; ++F, P <<= 1);
                if (F > 0)
                  for (l.iushrn(F); F-- > 0; )
                    (w.isOdd() || M.isOdd()) && (w.iadd(a), M.isub(b)), w.iushrn(1), M.iushrn(1);
                u.cmp(l) >= 0
                  ? (u.isub(l), d.isub(w), g.isub(M))
                  : (l.isub(u), w.isub(d), M.isub(g));
              }
              return { a: w, b: M, gcd: l.iushln(v) };
            }),
            (n.prototype._invmp = function (o) {
              r(o.negative === 0), r(!o.isZero());
              var u = this,
                l = o.clone();
              u.negative !== 0 ? (u = u.umod(o)) : (u = u.clone());
              for (
                var d = new n(1), g = new n(0), w = l.clone();
                u.cmpn(1) > 0 && l.cmpn(1) > 0;

              ) {
                for (var M = 0, v = 1; !(u.words[0] & v) && M < 26; ++M, v <<= 1);
                if (M > 0) for (u.iushrn(M); M-- > 0; ) d.isOdd() && d.iadd(w), d.iushrn(1);
                for (var a = 0, b = 1; !(l.words[0] & b) && a < 26; ++a, b <<= 1);
                if (a > 0) for (l.iushrn(a); a-- > 0; ) g.isOdd() && g.iadd(w), g.iushrn(1);
                u.cmp(l) >= 0 ? (u.isub(l), d.isub(g)) : (l.isub(u), g.isub(d));
              }
              var k;
              return u.cmpn(1) === 0 ? (k = d) : (k = g), k.cmpn(0) < 0 && k.iadd(o), k;
            }),
            (n.prototype.gcd = function (o) {
              if (this.isZero()) return o.abs();
              if (o.isZero()) return this.abs();
              var u = this.clone(),
                l = o.clone();
              (u.negative = 0), (l.negative = 0);
              for (var d = 0; u.isEven() && l.isEven(); d++) u.iushrn(1), l.iushrn(1);
              do {
                for (; u.isEven(); ) u.iushrn(1);
                for (; l.isEven(); ) l.iushrn(1);
                var g = u.cmp(l);
                if (g < 0) {
                  var w = u;
                  (u = l), (l = w);
                } else if (g === 0 || l.cmpn(1) === 0) break;
                u.isub(l);
              } while (!0);
              return l.iushln(d);
            }),
            (n.prototype.invm = function (o) {
              return this.egcd(o).a.umod(o);
            }),
            (n.prototype.isEven = function () {
              return (this.words[0] & 1) === 0;
            }),
            (n.prototype.isOdd = function () {
              return (this.words[0] & 1) === 1;
            }),
            (n.prototype.andln = function (o) {
              return this.words[0] & o;
            }),
            (n.prototype.bincn = function (o) {
              r(typeof o == 'number');
              var u = o % 26,
                l = (o - u) / 26,
                d = 1 << u;
              if (this.length <= l) return this._expand(l + 1), (this.words[l] |= d), this;
              for (var g = d, w = l; g !== 0 && w < this.length; w++) {
                var M = this.words[w] | 0;
                (M += g), (g = M >>> 26), (M &= 67108863), (this.words[w] = M);
              }
              return g !== 0 && ((this.words[w] = g), this.length++), this;
            }),
            (n.prototype.isZero = function () {
              return this.length === 1 && this.words[0] === 0;
            }),
            (n.prototype.cmpn = function (o) {
              var u = o < 0;
              if (this.negative !== 0 && !u) return -1;
              if (this.negative === 0 && u) return 1;
              this.strip();
              var l;
              if (this.length > 1) l = 1;
              else {
                u && (o = -o), r(o <= 67108863, 'Number is too big');
                var d = this.words[0] | 0;
                l = d === o ? 0 : d < o ? -1 : 1;
              }
              return this.negative !== 0 ? -l | 0 : l;
            }),
            (n.prototype.cmp = function (o) {
              if (this.negative !== 0 && o.negative === 0) return -1;
              if (this.negative === 0 && o.negative !== 0) return 1;
              var u = this.ucmp(o);
              return this.negative !== 0 ? -u | 0 : u;
            }),
            (n.prototype.ucmp = function (o) {
              if (this.length > o.length) return 1;
              if (this.length < o.length) return -1;
              for (var u = 0, l = this.length - 1; l >= 0; l--) {
                var d = this.words[l] | 0,
                  g = o.words[l] | 0;
                if (d !== g) {
                  d < g ? (u = -1) : d > g && (u = 1);
                  break;
                }
              }
              return u;
            }),
            (n.prototype.gtn = function (o) {
              return this.cmpn(o) === 1;
            }),
            (n.prototype.gt = function (o) {
              return this.cmp(o) === 1;
            }),
            (n.prototype.gten = function (o) {
              return this.cmpn(o) >= 0;
            }),
            (n.prototype.gte = function (o) {
              return this.cmp(o) >= 0;
            }),
            (n.prototype.ltn = function (o) {
              return this.cmpn(o) === -1;
            }),
            (n.prototype.lt = function (o) {
              return this.cmp(o) === -1;
            }),
            (n.prototype.lten = function (o) {
              return this.cmpn(o) <= 0;
            }),
            (n.prototype.lte = function (o) {
              return this.cmp(o) <= 0;
            }),
            (n.prototype.eqn = function (o) {
              return this.cmpn(o) === 0;
            }),
            (n.prototype.eq = function (o) {
              return this.cmp(o) === 0;
            }),
            (n.red = function (o) {
              return new X(o);
            }),
            (n.prototype.toRed = function (o) {
              return (
                r(!this.red, 'Already a number in reduction context'),
                r(this.negative === 0, 'red works only with positives'),
                o.convertTo(this)._forceRed(o)
              );
            }),
            (n.prototype.fromRed = function () {
              return (
                r(this.red, 'fromRed works only with numbers in reduction context'),
                this.red.convertFrom(this)
              );
            }),
            (n.prototype._forceRed = function (o) {
              return (this.red = o), this;
            }),
            (n.prototype.forceRed = function (o) {
              return r(!this.red, 'Already a number in reduction context'), this._forceRed(o);
            }),
            (n.prototype.redAdd = function (o) {
              return r(this.red, 'redAdd works only with red numbers'), this.red.add(this, o);
            }),
            (n.prototype.redIAdd = function (o) {
              return r(this.red, 'redIAdd works only with red numbers'), this.red.iadd(this, o);
            }),
            (n.prototype.redSub = function (o) {
              return r(this.red, 'redSub works only with red numbers'), this.red.sub(this, o);
            }),
            (n.prototype.redISub = function (o) {
              return r(this.red, 'redISub works only with red numbers'), this.red.isub(this, o);
            }),
            (n.prototype.redShl = function (o) {
              return r(this.red, 'redShl works only with red numbers'), this.red.shl(this, o);
            }),
            (n.prototype.redMul = function (o) {
              return (
                r(this.red, 'redMul works only with red numbers'),
                this.red._verify2(this, o),
                this.red.mul(this, o)
              );
            }),
            (n.prototype.redIMul = function (o) {
              return (
                r(this.red, 'redMul works only with red numbers'),
                this.red._verify2(this, o),
                this.red.imul(this, o)
              );
            }),
            (n.prototype.redSqr = function () {
              return (
                r(this.red, 'redSqr works only with red numbers'),
                this.red._verify1(this),
                this.red.sqr(this)
              );
            }),
            (n.prototype.redISqr = function () {
              return (
                r(this.red, 'redISqr works only with red numbers'),
                this.red._verify1(this),
                this.red.isqr(this)
              );
            }),
            (n.prototype.redSqrt = function () {
              return (
                r(this.red, 'redSqrt works only with red numbers'),
                this.red._verify1(this),
                this.red.sqrt(this)
              );
            }),
            (n.prototype.redInvm = function () {
              return (
                r(this.red, 'redInvm works only with red numbers'),
                this.red._verify1(this),
                this.red.invm(this)
              );
            }),
            (n.prototype.redNeg = function () {
              return (
                r(this.red, 'redNeg works only with red numbers'),
                this.red._verify1(this),
                this.red.neg(this)
              );
            }),
            (n.prototype.redPow = function (o) {
              return (
                r(this.red && !o.red, 'redPow(normalNum)'),
                this.red._verify1(this),
                this.red.pow(this, o)
              );
            });
          var q = { k256: null, p224: null, p192: null, p25519: null };
          function H(S, o) {
            (this.name = S),
              (this.p = new n(o, 16)),
              (this.n = this.p.bitLength()),
              (this.k = new n(1).iushln(this.n).isub(this.p)),
              (this.tmp = this._tmp());
          }
          (H.prototype._tmp = function () {
            var o = new n(null);
            return (o.words = new Array(Math.ceil(this.n / 13))), o;
          }),
            (H.prototype.ireduce = function (o) {
              var u = o,
                l;
              do
                this.split(u, this.tmp),
                  (u = this.imulK(u)),
                  (u = u.iadd(this.tmp)),
                  (l = u.bitLength());
              while (l > this.n);
              var d = l < this.n ? -1 : u.ucmp(this.p);
              return (
                d === 0
                  ? ((u.words[0] = 0), (u.length = 1))
                  : d > 0
                    ? u.isub(this.p)
                    : u.strip !== void 0
                      ? u.strip()
                      : u._strip(),
                u
              );
            }),
            (H.prototype.split = function (o, u) {
              o.iushrn(this.n, 0, u);
            }),
            (H.prototype.imulK = function (o) {
              return o.imul(this.k);
            });
          function V() {
            H.call(
              this,
              'k256',
              'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f'
            );
          }
          s(V, H),
            (V.prototype.split = function (o, u) {
              for (var l = 4194303, d = Math.min(o.length, 9), g = 0; g < d; g++)
                u.words[g] = o.words[g];
              if (((u.length = d), o.length <= 9)) {
                (o.words[0] = 0), (o.length = 1);
                return;
              }
              var w = o.words[9];
              for (u.words[u.length++] = w & l, g = 10; g < o.length; g++) {
                var M = o.words[g] | 0;
                (o.words[g - 10] = ((M & l) << 4) | (w >>> 22)), (w = M);
              }
              (w >>>= 22),
                (o.words[g - 10] = w),
                w === 0 && o.length > 10 ? (o.length -= 10) : (o.length -= 9);
            }),
            (V.prototype.imulK = function (o) {
              (o.words[o.length] = 0), (o.words[o.length + 1] = 0), (o.length += 2);
              for (var u = 0, l = 0; l < o.length; l++) {
                var d = o.words[l] | 0;
                (u += d * 977), (o.words[l] = u & 67108863), (u = d * 64 + ((u / 67108864) | 0));
              }
              return (
                o.words[o.length - 1] === 0 &&
                  (o.length--, o.words[o.length - 1] === 0 && o.length--),
                o
              );
            });
          function te() {
            H.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
          }
          s(te, H);
          function ue() {
            H.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
          }
          s(ue, H);
          function ne() {
            H.call(
              this,
              '25519',
              '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed'
            );
          }
          s(ne, H),
            (ne.prototype.imulK = function (o) {
              for (var u = 0, l = 0; l < o.length; l++) {
                var d = (o.words[l] | 0) * 19 + u,
                  g = d & 67108863;
                (d >>>= 26), (o.words[l] = g), (u = d);
              }
              return u !== 0 && (o.words[o.length++] = u), o;
            }),
            (n._prime = function (o) {
              if (q[o]) return q[o];
              var u;
              if (o === 'k256') u = new V();
              else if (o === 'p224') u = new te();
              else if (o === 'p192') u = new ue();
              else if (o === 'p25519') u = new ne();
              else throw new Error('Unknown prime ' + o);
              return (q[o] = u), u;
            });
          function X(S) {
            if (typeof S == 'string') {
              var o = n._prime(S);
              (this.m = o.p), (this.prime = o);
            } else r(S.gtn(1), 'modulus must be greater than 1'), (this.m = S), (this.prime = null);
          }
          (X.prototype._verify1 = function (o) {
            r(o.negative === 0, 'red works only with positives'),
              r(o.red, 'red works only with red numbers');
          }),
            (X.prototype._verify2 = function (o, u) {
              r((o.negative | u.negative) === 0, 'red works only with positives'),
                r(o.red && o.red === u.red, 'red works only with red numbers');
            }),
            (X.prototype.imod = function (o) {
              return this.prime
                ? this.prime.ireduce(o)._forceRed(this)
                : o.umod(this.m)._forceRed(this);
            }),
            (X.prototype.neg = function (o) {
              return o.isZero() ? o.clone() : this.m.sub(o)._forceRed(this);
            }),
            (X.prototype.add = function (o, u) {
              this._verify2(o, u);
              var l = o.add(u);
              return l.cmp(this.m) >= 0 && l.isub(this.m), l._forceRed(this);
            }),
            (X.prototype.iadd = function (o, u) {
              this._verify2(o, u);
              var l = o.iadd(u);
              return l.cmp(this.m) >= 0 && l.isub(this.m), l;
            }),
            (X.prototype.sub = function (o, u) {
              this._verify2(o, u);
              var l = o.sub(u);
              return l.cmpn(0) < 0 && l.iadd(this.m), l._forceRed(this);
            }),
            (X.prototype.isub = function (o, u) {
              this._verify2(o, u);
              var l = o.isub(u);
              return l.cmpn(0) < 0 && l.iadd(this.m), l;
            }),
            (X.prototype.shl = function (o, u) {
              return this._verify1(o), this.imod(o.ushln(u));
            }),
            (X.prototype.imul = function (o, u) {
              return this._verify2(o, u), this.imod(o.imul(u));
            }),
            (X.prototype.mul = function (o, u) {
              return this._verify2(o, u), this.imod(o.mul(u));
            }),
            (X.prototype.isqr = function (o) {
              return this.imul(o, o.clone());
            }),
            (X.prototype.sqr = function (o) {
              return this.mul(o, o);
            }),
            (X.prototype.sqrt = function (o) {
              if (o.isZero()) return o.clone();
              var u = this.m.andln(3);
              if ((r(u % 2 === 1), u === 3)) {
                var l = this.m.add(new n(1)).iushrn(2);
                return this.pow(o, l);
              }
              for (var d = this.m.subn(1), g = 0; !d.isZero() && d.andln(1) === 0; )
                g++, d.iushrn(1);
              r(!d.isZero());
              var w = new n(1).toRed(this),
                M = w.redNeg(),
                v = this.m.subn(1).iushrn(1),
                a = this.m.bitLength();
              for (a = new n(2 * a * a).toRed(this); this.pow(a, v).cmp(M) !== 0; ) a.redIAdd(M);
              for (
                var b = this.pow(a, d),
                  k = this.pow(o, d.addn(1).iushrn(1)),
                  B = this.pow(o, d),
                  F = g;
                B.cmp(w) !== 0;

              ) {
                for (var P = B, C = 0; P.cmp(w) !== 0; C++) P = P.redSqr();
                r(C < F);
                var z = this.pow(b, new n(1).iushln(F - C - 1));
                (k = k.redMul(z)), (b = z.redSqr()), (B = B.redMul(b)), (F = C);
              }
              return k;
            }),
            (X.prototype.invm = function (o) {
              var u = o._invmp(this.m);
              return u.negative !== 0 ? ((u.negative = 0), this.imod(u).redNeg()) : this.imod(u);
            }),
            (X.prototype.pow = function (o, u) {
              if (u.isZero()) return new n(1).toRed(this);
              if (u.cmpn(1) === 0) return o.clone();
              var l = 4,
                d = new Array(1 << l);
              (d[0] = new n(1).toRed(this)), (d[1] = o);
              for (var g = 2; g < d.length; g++) d[g] = this.mul(d[g - 1], o);
              var w = d[0],
                M = 0,
                v = 0,
                a = u.bitLength() % 26;
              for (a === 0 && (a = 26), g = u.length - 1; g >= 0; g--) {
                for (var b = u.words[g], k = a - 1; k >= 0; k--) {
                  var B = (b >> k) & 1;
                  if ((w !== d[0] && (w = this.sqr(w)), B === 0 && M === 0)) {
                    v = 0;
                    continue;
                  }
                  (M <<= 1),
                    (M |= B),
                    v++,
                    !(v !== l && (g !== 0 || k !== 0)) &&
                      ((w = this.mul(w, d[M])), (v = 0), (M = 0));
                }
                a = 26;
              }
              return w;
            }),
            (X.prototype.convertTo = function (o) {
              var u = o.umod(this.m);
              return u === o ? u.clone() : u;
            }),
            (X.prototype.convertFrom = function (o) {
              var u = o.clone();
              return (u.red = null), u;
            }),
            (n.mont = function (o) {
              return new Oe(o);
            });
          function Oe(S) {
            X.call(this, S),
              (this.shift = this.m.bitLength()),
              this.shift % 26 !== 0 && (this.shift += 26 - (this.shift % 26)),
              (this.r = new n(1).iushln(this.shift)),
              (this.r2 = this.imod(this.r.sqr())),
              (this.rinv = this.r._invmp(this.m)),
              (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
              (this.minv = this.minv.umod(this.r)),
              (this.minv = this.r.sub(this.minv));
          }
          s(Oe, X),
            (Oe.prototype.convertTo = function (o) {
              return this.imod(o.ushln(this.shift));
            }),
            (Oe.prototype.convertFrom = function (o) {
              var u = this.imod(o.mul(this.rinv));
              return (u.red = null), u;
            }),
            (Oe.prototype.imul = function (o, u) {
              if (o.isZero() || u.isZero()) return (o.words[0] = 0), (o.length = 1), o;
              var l = o.imul(u),
                d = l.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                g = l.isub(d).iushrn(this.shift),
                w = g;
              return (
                g.cmp(this.m) >= 0 ? (w = g.isub(this.m)) : g.cmpn(0) < 0 && (w = g.iadd(this.m)),
                w._forceRed(this)
              );
            }),
            (Oe.prototype.mul = function (o, u) {
              if (o.isZero() || u.isZero()) return new n(0)._forceRed(this);
              var l = o.mul(u),
                d = l.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                g = l.isub(d).iushrn(this.shift),
                w = g;
              return (
                g.cmp(this.m) >= 0 ? (w = g.isub(this.m)) : g.cmpn(0) < 0 && (w = g.iadd(this.m)),
                w._forceRed(this)
              );
            }),
            (Oe.prototype.invm = function (o) {
              var u = this.imod(o._invmp(this.m).mul(this.r2));
              return u._forceRed(this);
            });
        })(i, se);
      })(Af)),
    Af.exports
  );
}
var F0, Em;
function L8() {
  if (Em) return F0;
  Em = 1;
  var i = by(),
    e = At.Buffer;
  function t(r, s) {
    return e.from(r.toRed(i.mont(s.modulus)).redPow(new i(s.publicExponent)).fromRed().toArray());
  }
  return (F0 = t), F0;
}
var q0, km;
function Wx() {
  if (km) return q0;
  km = 1;
  var i = $l(),
    e = Ua(),
    t = tc,
    r = O8(),
    s = C8(),
    n = by(),
    c = L8(),
    f = fy(),
    h = At.Buffer;
  q0 = function (A, E, I) {
    var R;
    A.padding ? (R = A.padding) : I ? (R = 1) : (R = 4);
    var L = i(A),
      D;
    if (R === 4) D = y(L, E);
    else if (R === 1) D = p(L, E, I);
    else if (R === 3) {
      if (((D = new n(E)), D.cmp(L.modulus) >= 0)) throw new Error('data too long for modulus');
    } else throw new Error('unknown padding');
    return I ? f(D, L) : c(D, L);
  };
  function y(_, A) {
    var E = _.modulus.byteLength(),
      I = A.length,
      R = t('sha1').update(h.alloc(0)).digest(),
      L = R.length,
      D = 2 * L;
    if (I > E - D - 2) throw new Error('message too long');
    var q = h.alloc(E - I - D - 2),
      H = E - L - 1,
      V = e(L),
      te = s(h.concat([R, q, h.alloc(1, 1), A], H), r(V, H)),
      ue = s(V, r(te, L));
    return new n(h.concat([h.alloc(1), ue, te], E));
  }
  function p(_, A, E) {
    var I = A.length,
      R = _.modulus.byteLength();
    if (I > R - 11) throw new Error('message too long');
    var L;
    return (
      E ? (L = h.alloc(R - I - 3, 255)) : (L = m(R - I - 3)),
      new n(h.concat([h.from([0, E ? 1 : 2]), L, h.alloc(1), A], R))
    );
  }
  function m(_) {
    for (var A = h.allocUnsafe(_), E = 0, I = e(_ * 2), R = 0, L; E < _; )
      R === I.length && ((I = e(_ * 2)), (R = 0)), (L = I[R++]), L && (A[E++] = L);
    return A;
  }
  return q0;
}
var W0, Im;
function Kx() {
  if (Im) return W0;
  Im = 1;
  var i = $l(),
    e = O8(),
    t = C8(),
    r = by(),
    s = fy(),
    n = tc,
    c = L8(),
    f = At.Buffer;
  W0 = function (_, A, E) {
    var I;
    _.padding ? (I = _.padding) : E ? (I = 1) : (I = 4);
    var R = i(_),
      L = R.modulus.byteLength();
    if (A.length > L || new r(A).cmp(R.modulus) >= 0) throw new Error('decryption error');
    var D;
    E ? (D = c(new r(A), R)) : (D = s(A, R));
    var q = f.alloc(L - D.length);
    if (((D = f.concat([q, D], L)), I === 4)) return h(R, D);
    if (I === 1) return y(R, D, E);
    if (I === 3) return D;
    throw new Error('unknown padding');
  };
  function h(m, _) {
    var A = m.modulus.byteLength(),
      E = n('sha1').update(f.alloc(0)).digest(),
      I = E.length;
    if (_[0] !== 0) throw new Error('decryption error');
    var R = _.slice(1, I + 1),
      L = _.slice(I + 1),
      D = t(R, e(L, I)),
      q = t(L, e(D, A - I - 1));
    if (p(E, q.slice(0, I))) throw new Error('decryption error');
    for (var H = I; q[H] === 0; ) H++;
    if (q[H++] !== 1) throw new Error('decryption error');
    return q.slice(H);
  }
  function y(m, _, A) {
    for (var E = _.slice(0, 2), I = 2, R = 0; _[I++] !== 0; )
      if (I >= _.length) {
        R++;
        break;
      }
    var L = _.slice(2, I - 1);
    if (
      (((E.toString('hex') !== '0002' && !A) || (E.toString('hex') !== '0001' && A)) && R++,
      L.length < 8 && R++,
      R)
    )
      throw new Error('decryption error');
    return _.slice(I);
  }
  function p(m, _) {
    (m = f.from(m)), (_ = f.from(_));
    var A = 0,
      E = m.length;
    m.length !== _.length && (A++, (E = Math.min(m.length, _.length)));
    for (var I = -1; ++I < E; ) A += m[I] ^ _[I];
    return A;
  }
  return W0;
}
var xm;
function jx() {
  return (
    xm ||
      ((xm = 1),
      (function (i) {
        (i.publicEncrypt = Wx()),
          (i.privateDecrypt = Kx()),
          (i.privateEncrypt = function (t, r) {
            return i.publicEncrypt(t, r, !0);
          }),
          (i.publicDecrypt = function (t, r) {
            return i.privateDecrypt(t, r, !0);
          });
      })(D0)),
    D0
  );
}
var Ks = {},
  Bm;
function Hx() {
  if (Bm) return Ks;
  Bm = 1;
  function i() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
  }
  var e = At,
    t = Ua(),
    r = e.Buffer,
    s = e.kMaxLength,
    n = globalThis.crypto || globalThis.msCrypto,
    c = Math.pow(2, 32) - 1;
  function f(_, A) {
    if (typeof _ != 'number' || _ !== _) throw new TypeError('offset must be a number');
    if (_ > c || _ < 0) throw new TypeError('offset must be a uint32');
    if (_ > s || _ > A) throw new RangeError('offset out of range');
  }
  function h(_, A, E) {
    if (typeof _ != 'number' || _ !== _) throw new TypeError('size must be a number');
    if (_ > c || _ < 0) throw new TypeError('size must be a uint32');
    if (_ + A > E || _ > s) throw new RangeError('buffer too small');
  }
  (n && n.getRandomValues) || !Je.browser
    ? ((Ks.randomFill = y), (Ks.randomFillSync = m))
    : ((Ks.randomFill = i), (Ks.randomFillSync = i));
  function y(_, A, E, I) {
    if (!r.isBuffer(_) && !(_ instanceof globalThis.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof A == 'function') (I = A), (A = 0), (E = _.length);
    else if (typeof E == 'function') (I = E), (E = _.length - A);
    else if (typeof I != 'function') throw new TypeError('"cb" argument must be a function');
    return f(A, _.length), h(E, A, _.length), p(_, A, E, I);
  }
  function p(_, A, E, I) {
    if (Je.browser) {
      var R = _.buffer,
        L = new Uint8Array(R, A, E);
      if ((n.getRandomValues(L), I)) {
        Je.nextTick(function () {
          I(null, _);
        });
        return;
      }
      return _;
    }
    if (I) {
      t(E, function (q, H) {
        if (q) return I(q);
        H.copy(_, A), I(null, _);
      });
      return;
    }
    var D = t(E);
    return D.copy(_, A), _;
  }
  function m(_, A, E) {
    if ((typeof A > 'u' && (A = 0), !r.isBuffer(_) && !(_ instanceof globalThis.Uint8Array)))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return f(A, _.length), E === void 0 && (E = _.length - A), h(E, A, _.length), p(_, A, E);
  }
  return Ks;
}
var Rm;
function N8() {
  if (Rm) return _t;
  (Rm = 1),
    (_t.randomBytes = _t.rng = _t.pseudoRandomBytes = _t.prng = Ua()),
    (_t.createHash = _t.Hash = tc),
    (_t.createHmac = _t.Hmac = D6());
  var i = V9(),
    e = Object.keys(i),
    t = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(e);
  _t.getHashes = function () {
    return t;
  };
  var r = K6();
  (_t.pbkdf2 = r.pbkdf2), (_t.pbkdf2Sync = r.pbkdf2Sync);
  var s = hk();
  (_t.Cipher = s.Cipher),
    (_t.createCipher = s.createCipher),
    (_t.Cipheriv = s.Cipheriv),
    (_t.createCipheriv = s.createCipheriv),
    (_t.Decipher = s.Decipher),
    (_t.createDecipher = s.createDecipher),
    (_t.Decipheriv = s.Decipheriv),
    (_t.createDecipheriv = s.createDecipheriv),
    (_t.getCiphers = s.getCiphers),
    (_t.listCiphers = s.listCiphers);
  var n = Ak();
  (_t.DiffieHellmanGroup = n.DiffieHellmanGroup),
    (_t.createDiffieHellmanGroup = n.createDiffieHellmanGroup),
    (_t.getDiffieHellman = n.getDiffieHellman),
    (_t.createDiffieHellman = n.createDiffieHellman),
    (_t.DiffieHellman = n.DiffieHellman);
  var c = zx();
  (_t.createSign = c.createSign),
    (_t.Sign = c.Sign),
    (_t.createVerify = c.createVerify),
    (_t.Verify = c.Verify),
    (_t.createECDH = qx());
  var f = jx();
  (_t.publicEncrypt = f.publicEncrypt),
    (_t.privateEncrypt = f.privateEncrypt),
    (_t.publicDecrypt = f.publicDecrypt),
    (_t.privateDecrypt = f.privateDecrypt);
  var h = Hx();
  return (
    (_t.randomFill = h.randomFill),
    (_t.randomFillSync = h.randomFillSync),
    (_t.createCredentials = function () {
      throw new Error(
        [
          'sorry, createCredentials is not implemented yet',
          'we accept pull requests',
          'https://github.com/crypto-browserify/crypto-browserify',
        ].join(`
`)
      );
    }),
    (_t.constants = {
      DH_CHECK_P_NOT_SAFE_PRIME: 2,
      DH_CHECK_P_NOT_PRIME: 1,
      DH_UNABLE_TO_CHECK_GENERATOR: 4,
      DH_NOT_SUITABLE_GENERATOR: 8,
      NPN_ENABLED: 1,
      ALPN_ENABLED: 1,
      RSA_PKCS1_PADDING: 1,
      RSA_SSLV23_PADDING: 2,
      RSA_NO_PADDING: 3,
      RSA_PKCS1_OAEP_PADDING: 4,
      RSA_X931_PADDING: 5,
      RSA_PKCS1_PSS_PADDING: 6,
      POINT_CONVERSION_COMPRESSED: 2,
      POINT_CONVERSION_UNCOMPRESSED: 4,
      POINT_CONVERSION_HYBRID: 6,
    }),
    _t
  );
}
var $8 = N8();
const Vx = zn($8),
  D8 = j4({ __proto__: null, default: Vx }, [$8]);
/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */ const ni = BigInt(0),
  Ut = BigInt(1),
  Eo = BigInt(2),
  Gx = BigInt(8),
  Pm = BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989'),
  xr = Object.freeze({
    a: BigInt(-1),
    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),
    P: BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949'),
    l: Pm,
    n: Pm,
    h: BigInt(8),
    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),
    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),
  }),
  U8 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000'),
  _u = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');
BigInt('6853475219497561581579357271197624642482790079785650197046958215289687604742');
const Yx = BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235'),
  Zx = BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578'),
  Jx = BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838'),
  Xx = BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');
class Lt {
  constructor(e, t, r, s) {
    (this.x = e), (this.y = t), (this.z = r), (this.t = s);
  }
  static fromAffine(e) {
    if (!(e instanceof Or)) throw new TypeError('ExtendedPoint#fromAffine: expected Point');
    return e.equals(Or.ZERO) ? Lt.ZERO : new Lt(e.x, e.y, Ut, je(e.x * e.y));
  }
  static toAffineBatch(e) {
    const t = tB(e.map((r) => r.z));
    return e.map((r, s) => r.toAffine(t[s]));
  }
  static normalizeZ(e) {
    return this.toAffineBatch(e).map(this.fromAffine);
  }
  equals(e) {
    Om(e);
    const { x: t, y: r, z: s } = this,
      { x: n, y: c, z: f } = e,
      h = je(t * f),
      y = je(n * s),
      p = je(r * f),
      m = je(c * s);
    return h === y && p === m;
  }
  negate() {
    return new Lt(je(-this.x), this.y, this.z, je(-this.t));
  }
  double() {
    const { x: e, y: t, z: r } = this,
      { a: s } = xr,
      n = je(e * e),
      c = je(t * t),
      f = je(Eo * je(r * r)),
      h = je(s * n),
      y = e + t,
      p = je(je(y * y) - n - c),
      m = h + c,
      _ = m - f,
      A = h - c,
      E = je(p * _),
      I = je(m * A),
      R = je(p * A),
      L = je(_ * m);
    return new Lt(E, I, L, R);
  }
  add(e) {
    Om(e);
    const { x: t, y: r, z: s, t: n } = this,
      { x: c, y: f, z: h, t: y } = e,
      p = je((r - t) * (f + c)),
      m = je((r + t) * (f - c)),
      _ = je(m - p);
    if (_ === ni) return this.double();
    const A = je(s * Eo * y),
      E = je(n * Eo * h),
      I = E + A,
      R = m + p,
      L = E - A,
      D = je(I * _),
      q = je(R * L),
      H = je(I * L),
      V = je(_ * R);
    return new Lt(D, q, V, H);
  }
  subtract(e) {
    return this.add(e.negate());
  }
  precomputeWindow(e) {
    const t = 1 + 256 / e,
      r = [];
    let s = this,
      n = s;
    for (let c = 0; c < t; c++) {
      (n = s), r.push(n);
      for (let f = 1; f < 2 ** (e - 1); f++) (n = n.add(s)), r.push(n);
      s = n.double();
    }
    return r;
  }
  wNAF(e, t) {
    !t && this.equals(Lt.BASE) && (t = Or.BASE);
    const r = (t && t._WINDOW_SIZE) || 1;
    if (256 % r) throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');
    let s = t && Xp.get(t);
    s || ((s = this.precomputeWindow(r)), t && r !== 1 && ((s = Lt.normalizeZ(s)), Xp.set(t, s)));
    let n = Lt.ZERO,
      c = Lt.BASE;
    const f = 1 + 256 / r,
      h = 2 ** (r - 1),
      y = BigInt(2 ** r - 1),
      p = 2 ** r,
      m = BigInt(r);
    for (let _ = 0; _ < f; _++) {
      const A = _ * h;
      let E = Number(e & y);
      (e >>= m), E > h && ((E -= p), (e += Ut));
      const I = A,
        R = A + Math.abs(E) - 1,
        L = _ % 2 !== 0,
        D = E < 0;
      E === 0 ? (c = c.add(Tm(L, s[I]))) : (n = n.add(Tm(D, s[R])));
    }
    return Lt.normalizeZ([n, c])[0];
  }
  multiply(e, t) {
    return this.wNAF(Vf(e, xr.l), t);
  }
  multiplyUnsafe(e) {
    let t = Vf(e, xr.l, !1);
    const r = Lt.BASE,
      s = Lt.ZERO;
    if (t === ni) return s;
    if (this.equals(s) || t === Ut) return this;
    if (this.equals(r)) return this.wNAF(t);
    let n = s,
      c = this;
    for (; t > ni; ) t & Ut && (n = n.add(c)), (c = c.double()), (t >>= Ut);
    return n;
  }
  isSmallOrder() {
    return this.multiplyUnsafe(xr.h).equals(Lt.ZERO);
  }
  isTorsionFree() {
    let e = this.multiplyUnsafe(xr.l / Eo).double();
    return xr.l % Eo && (e = e.add(this)), e.equals(Lt.ZERO);
  }
  toAffine(e) {
    const { x: t, y: r, z: s } = this,
      n = this.equals(Lt.ZERO);
    e == null && (e = n ? Gx : Dl(s));
    const c = je(t * e),
      f = je(r * e),
      h = je(s * e);
    if (n) return Or.ZERO;
    if (h !== Ut) throw new Error('invZ was invalid');
    return new Or(c, f);
  }
  fromRistrettoBytes() {
    j0();
  }
  toRistrettoBytes() {
    j0();
  }
  fromRistrettoHash() {
    j0();
  }
}
Lt.BASE = new Lt(xr.Gx, xr.Gy, Ut, je(xr.Gx * xr.Gy));
Lt.ZERO = new Lt(ni, Ut, Ut, ni);
function Tm(i, e) {
  const t = e.negate();
  return i ? t : e;
}
function Om(i) {
  if (!(i instanceof Lt)) throw new TypeError('ExtendedPoint expected');
}
function K0(i) {
  if (!(i instanceof Yi)) throw new TypeError('RistrettoPoint expected');
}
function j0() {
  throw new Error('Legacy method: switch to RistrettoPoint');
}
class Yi {
  constructor(e) {
    this.ep = e;
  }
  static calcElligatorRistrettoMap(e) {
    const { d: t } = xr,
      r = je(_u * e * e),
      s = je((r + Ut) * Jx);
    let n = BigInt(-1);
    const c = je((n - t * r) * je(r + t));
    let { isValid: f, value: h } = my(s, c),
      y = je(h * e);
    _o(y) || (y = je(-y)), f || (h = y), f || (n = r);
    const p = je(n * (r - Ut) * Xx - c),
      m = h * h,
      _ = je((h + h) * c),
      A = je(p * Yx),
      E = je(Ut - m),
      I = je(Ut + m);
    return new Lt(je(_ * I), je(E * A), je(A * I), je(_ * E));
  }
  static hashToCurve(e) {
    e = No(e, 64);
    const t = H0(e.slice(0, 32)),
      r = this.calcElligatorRistrettoMap(t),
      s = H0(e.slice(32, 64)),
      n = this.calcElligatorRistrettoMap(s);
    return new Yi(r.add(n));
  }
  static fromHex(e) {
    e = No(e, 32);
    const { a: t, d: r } = xr,
      s = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint',
      n = H0(e);
    if (!iB(Ou(n), e) || _o(n)) throw new Error(s);
    const c = je(n * n),
      f = je(Ut + t * c),
      h = je(Ut - t * c),
      y = je(f * f),
      p = je(h * h),
      m = je(t * r * y - p),
      { isValid: _, value: A } = Lm(je(m * p)),
      E = je(A * h),
      I = je(A * E * m);
    let R = je((n + n) * E);
    _o(R) && (R = je(-R));
    const L = je(f * I),
      D = je(R * L);
    if (!_ || _o(D) || L === ni) throw new Error(s);
    return new Yi(new Lt(R, L, Ut, D));
  }
  toRawBytes() {
    let { x: e, y: t, z: r, t: s } = this.ep;
    const n = je(je(r + t) * je(r - t)),
      c = je(e * t),
      f = je(c * c),
      { value: h } = Lm(je(n * f)),
      y = je(h * n),
      p = je(h * c),
      m = je(y * p * s);
    let _;
    if (_o(s * m)) {
      let E = je(t * _u),
        I = je(e * _u);
      (e = E), (t = I), (_ = je(y * Zx));
    } else _ = p;
    _o(e * m) && (t = je(-t));
    let A = je((r - t) * _);
    return _o(A) && (A = je(-A)), Ou(A);
  }
  toHex() {
    return nc(this.toRawBytes());
  }
  toString() {
    return this.toHex();
  }
  equals(e) {
    K0(e);
    const t = this.ep,
      r = e.ep,
      s = je(t.x * r.y) === je(t.y * r.x),
      n = je(t.y * r.y) === je(t.x * r.x);
    return s || n;
  }
  add(e) {
    return K0(e), new Yi(this.ep.add(e.ep));
  }
  subtract(e) {
    return K0(e), new Yi(this.ep.subtract(e.ep));
  }
  multiply(e) {
    return new Yi(this.ep.multiply(e));
  }
  multiplyUnsafe(e) {
    return new Yi(this.ep.multiplyUnsafe(e));
  }
}
Yi.BASE = new Yi(Lt.BASE);
Yi.ZERO = new Yi(Lt.ZERO);
const Xp = new WeakMap();
let Or = class Qp {
  constructor(e, t) {
    (this.x = e), (this.y = t);
  }
  _setWindowSize(e) {
    (this._WINDOW_SIZE = e), Xp.delete(this);
  }
  static fromHex(e, t = !0) {
    const { d: r, P: s } = xr;
    e = No(e, 32);
    const n = e.slice();
    n[31] = e[31] & -129;
    const c = oc(n);
    if (t && c >= s) throw new Error('Expected 0 < hex < P');
    if (!t && c >= U8) throw new Error('Expected 0 < hex < 2**256');
    const f = je(c * c),
      h = je(f - Ut),
      y = je(r * f + Ut);
    let { isValid: p, value: m } = my(h, y);
    if (!p) throw new Error('Point.fromHex: invalid y coordinate');
    const _ = (m & Ut) === Ut;
    return ((e[31] & 128) !== 0) !== _ && (m = je(-m)), new Qp(m, c);
  }
  static async fromPrivateKey(e) {
    return (await K8(e)).point;
  }
  toRawBytes() {
    const e = Ou(this.y);
    return (e[31] |= this.x & Ut ? 128 : 0), e;
  }
  toHex() {
    return nc(this.toRawBytes());
  }
  toX25519() {
    const { y: e } = this,
      t = je((Ut + e) * Dl(Ut - e));
    return Ou(t);
  }
  isTorsionFree() {
    return Lt.fromAffine(this).isTorsionFree();
  }
  equals(e) {
    return this.x === e.x && this.y === e.y;
  }
  negate() {
    return new Qp(je(-this.x), this.y);
  }
  add(e) {
    return Lt.fromAffine(this).add(Lt.fromAffine(e)).toAffine();
  }
  subtract(e) {
    return this.add(e.negate());
  }
  multiply(e) {
    return Lt.fromAffine(this).multiply(e, this).toAffine();
  }
};
Or.BASE = new Or(xr.Gx, xr.Gy);
Or.ZERO = new Or(ni, Ut);
let e1 = class z8 {
  constructor(e, t) {
    (this.r = e), (this.s = t), this.assertValidity();
  }
  static fromHex(e) {
    const t = No(e, 64),
      r = Or.fromHex(t.slice(0, 32), !1),
      s = oc(t.slice(32, 64));
    return new z8(r, s);
  }
  assertValidity() {
    const { r: e, s: t } = this;
    if (!(e instanceof Or)) throw new Error('Expected Point instance');
    return Vf(t, xr.l, !1), this;
  }
  toRawBytes() {
    const e = new Uint8Array(64);
    return e.set(this.r.toRawBytes()), e.set(Ou(this.s), 32), e;
  }
  toHex() {
    return nc(this.toRawBytes());
  }
};
function Cm(...i) {
  if (!i.every((r) => r instanceof Uint8Array)) throw new Error('Expected Uint8Array list');
  if (i.length === 1) return i[0];
  const e = i.reduce((r, s) => r + s.length, 0),
    t = new Uint8Array(e);
  for (let r = 0, s = 0; r < i.length; r++) {
    const n = i[r];
    t.set(n, s), (s += n.length);
  }
  return t;
}
const Qx = Array.from({ length: 256 }, (i, e) => e.toString(16).padStart(2, '0'));
function nc(i) {
  if (!(i instanceof Uint8Array)) throw new Error('Uint8Array expected');
  let e = '';
  for (let t = 0; t < i.length; t++) e += Qx[i[t]];
  return e;
}
function vy(i) {
  if (typeof i != 'string') throw new TypeError('hexToBytes: expected string, got ' + typeof i);
  if (i.length % 2) throw new Error('hexToBytes: received invalid unpadded hex');
  const e = new Uint8Array(i.length / 2);
  for (let t = 0; t < e.length; t++) {
    const r = t * 2,
      s = i.slice(r, r + 2),
      n = Number.parseInt(s, 16);
    if (Number.isNaN(n) || n < 0) throw new Error('Invalid byte sequence');
    e[t] = n;
  }
  return e;
}
function F8(i) {
  const t = i.toString(16).padStart(64, '0');
  return vy(t);
}
function Ou(i) {
  return F8(i).reverse();
}
function _o(i) {
  return (je(i) & Ut) === Ut;
}
function oc(i) {
  if (!(i instanceof Uint8Array)) throw new Error('Expected Uint8Array');
  return BigInt('0x' + nc(Uint8Array.from(i).reverse()));
}
const eB = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
function H0(i) {
  return je(oc(i) & eB);
}
function je(i, e = xr.P) {
  const t = i % e;
  return t >= ni ? t : e + t;
}
function Dl(i, e = xr.P) {
  if (i === ni || e <= ni)
    throw new Error(`invert: expected positive integers, got n=${i} mod=${e}`);
  let t = je(i, e),
    r = e,
    s = ni,
    n = Ut;
  for (; t !== ni; ) {
    const f = r / t,
      h = r % t,
      y = s - n * f;
    (r = t), (t = h), (s = n), (n = y);
  }
  if (r !== Ut) throw new Error('invert: does not exist');
  return je(s, e);
}
function tB(i, e = xr.P) {
  const t = new Array(i.length),
    r = i.reduce((n, c, f) => (c === ni ? n : ((t[f] = n), je(n * c, e))), Ut),
    s = Dl(r, e);
  return (
    i.reduceRight((n, c, f) => (c === ni ? n : ((t[f] = je(n * t[f], e)), je(n * c, e))), s), t
  );
}
function gn(i, e) {
  const { P: t } = xr;
  let r = i;
  for (; e-- > ni; ) (r *= r), (r %= t);
  return r;
}
function rB(i) {
  const { P: e } = xr,
    t = BigInt(5),
    r = BigInt(10),
    s = BigInt(20),
    n = BigInt(40),
    c = BigInt(80),
    h = (((i * i) % e) * i) % e,
    y = (gn(h, Eo) * h) % e,
    p = (gn(y, Ut) * i) % e,
    m = (gn(p, t) * p) % e,
    _ = (gn(m, r) * m) % e,
    A = (gn(_, s) * _) % e,
    E = (gn(A, n) * A) % e,
    I = (gn(E, c) * E) % e,
    R = (gn(I, c) * E) % e,
    L = (gn(R, r) * m) % e;
  return { pow_p_5_8: (gn(L, Eo) * i) % e, b2: h };
}
function my(i, e) {
  const t = je(e * e * e),
    r = je(t * t * e),
    s = rB(i * r).pow_p_5_8;
  let n = je(i * t * s);
  const c = je(e * n * n),
    f = n,
    h = je(n * _u),
    y = c === i,
    p = c === je(-i),
    m = c === je(-i * _u);
  return y && (n = f), (p || m) && (n = h), _o(n) && (n = je(-n)), { isValid: y || p, value: n };
}
function Lm(i) {
  return my(Ut, i);
}
function Hf(i) {
  return je(oc(i), xr.l);
}
function iB(i, e) {
  if (i.length !== e.length) return !1;
  for (let t = 0; t < i.length; t++) if (i[t] !== e[t]) return !1;
  return !0;
}
function No(i, e) {
  const t = i instanceof Uint8Array ? Uint8Array.from(i) : vy(i);
  if (typeof e == 'number' && t.length !== e) throw new Error(`Expected ${e} bytes`);
  return t;
}
function Vf(i, e, t = !0) {
  if (!e) throw new TypeError('Specify max value');
  if (
    (typeof i == 'number' && Number.isSafeInteger(i) && (i = BigInt(i)),
    typeof i == 'bigint' && i < e)
  ) {
    if (t) {
      if (ni < i) return i;
    } else if (ni <= i) return i;
  }
  throw new TypeError('Expected valid scalar: 0 < scalar < max');
}
function nB(i) {
  return (i[0] &= 248), (i[31] &= 127), (i[31] |= 64), i;
}
function q8(i) {
  if (((i = typeof i == 'bigint' || typeof i == 'number' ? F8(Vf(i, U8)) : No(i)), i.length !== 32))
    throw new Error('Expected 32 bytes');
  return i;
}
function W8(i) {
  const e = nB(i.slice(0, 32)),
    t = i.slice(32, 64),
    r = Hf(e),
    s = Or.BASE.multiply(r),
    n = s.toRawBytes();
  return { head: e, prefix: t, scalar: r, point: s, pointBytes: n };
}
let Su;
function Gf(...i) {
  if (typeof Su != 'function') throw new Error('utils.sha512Sync must be set to use sync methods');
  return Su(...i);
}
async function K8(i) {
  return W8(await ln.sha512(q8(i)));
}
function wy(i) {
  return W8(Gf(q8(i)));
}
function oB(i) {
  return wy(i).pointBytes;
}
function sB(i, e) {
  i = No(i);
  const { prefix: t, scalar: r, pointBytes: s } = wy(e),
    n = Hf(Gf(t, i)),
    c = Or.BASE.multiply(n),
    f = Hf(Gf(c.toRawBytes(), s, i)),
    h = je(n + f * r, xr.l);
  return new e1(c, h).toRawBytes();
}
function aB(i, e, t) {
  (e = No(e)), t instanceof Or || (t = Or.fromHex(t, !1));
  const { r, s } = i instanceof e1 ? i.assertValidity() : e1.fromHex(i),
    n = Lt.BASE.multiplyUnsafe(s);
  return { r, s, SB: n, pub: t, msg: e };
}
function uB(i, e, t, r) {
  const s = Hf(r),
    n = Lt.fromAffine(i).multiplyUnsafe(s);
  return Lt.fromAffine(e).add(n).subtract(t).multiplyUnsafe(xr.h).equals(Lt.ZERO);
}
function cB(i, e, t) {
  const { r, SB: s, msg: n, pub: c } = aB(i, e, t),
    f = Gf(r.toRawBytes(), c.toRawBytes(), n);
  return uB(c, r, s, f);
}
const Ha = { getExtendedPublicKey: wy, getPublicKey: oB, sign: sB, verify: cB };
Or.BASE._setWindowSize(8);
const lo = {
    node: D8,
    web: typeof globalThis == 'object' && 'crypto' in globalThis ? globalThis.crypto : void 0,
  },
  ln = {
    bytesToHex: nc,
    hexToBytes: vy,
    concatBytes: Cm,
    getExtendedPublicKey: K8,
    mod: je,
    invert: Dl,
    TORSION_SUBGROUP: [
      '0100000000000000000000000000000000000000000000000000000000000000',
      'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',
      '0000000000000000000000000000000000000000000000000000000000000080',
      '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',
      'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',
      '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',
      '0000000000000000000000000000000000000000000000000000000000000000',
      'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',
    ],
    hashToPrivateScalar: (i) => {
      if (((i = No(i)), i.length < 40 || i.length > 1024))
        throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');
      return je(oc(i), xr.l - Ut) + Ut;
    },
    randomBytes: (i = 32) => {
      if (lo.web) return lo.web.getRandomValues(new Uint8Array(i));
      if (lo.node) {
        const { randomBytes: e } = lo.node;
        return new Uint8Array(e(i).buffer);
      } else throw new Error("The environment doesn't have randomBytes function");
    },
    randomPrivateKey: () => ln.randomBytes(32),
    sha512: async (...i) => {
      const e = Cm(...i);
      if (lo.web) {
        const t = await lo.web.subtle.digest('SHA-512', e.buffer);
        return new Uint8Array(t);
      } else {
        if (lo.node) return Uint8Array.from(lo.node.createHash('sha512').update(e).digest());
        throw new Error("The environment doesn't have sha512 function");
      }
    },
    precompute(i = 8, e = Or.BASE) {
      const t = e.equals(Or.BASE) ? e : new Or(e.x, e.y);
      return t._setWindowSize(i), t.multiply(Eo), t;
    },
    sha512Sync: void 0,
  };
Object.defineProperties(ln, {
  sha512Sync: {
    configurable: !1,
    get() {
      return Su;
    },
    set(i) {
      Su || (Su = i);
    },
  },
});
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */ const Ot = BigInt(0),
  Br = BigInt(1),
  xo = BigInt(2),
  Mu = BigInt(3),
  Nm = BigInt(8),
  or = Object.freeze({
    a: Ot,
    b: BigInt(7),
    P: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),
    n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),
    h: Br,
    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),
    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),
    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
  }),
  $m = (i, e) => (i + e / xo) / e,
  Xc = {
    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
    splitScalar(i) {
      const { n: e } = or,
        t = BigInt('0x3086d221a7d46bcde86c90e49284eb15'),
        r = -Br * BigInt('0xe4437ed6010e88286f547fa90abfe4c3'),
        s = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'),
        n = t,
        c = BigInt('0x100000000000000000000000000000000'),
        f = $m(n * i, e),
        h = $m(-r * i, e);
      let y = Qe(i - f * t - h * s, e),
        p = Qe(-f * r - h * n, e);
      const m = y > c,
        _ = p > c;
      if ((m && (y = e - y), _ && (p = e - p), y > c || p > c))
        throw new Error('splitScalarEndo: Endomorphism failed, k=' + i);
      return { k1neg: m, k1: y, k2neg: _, k2: p };
    },
  },
  sn = 32,
  gs = 32,
  j8 = 32,
  Yf = sn + 1,
  Zf = 2 * sn + 1;
function Dm(i) {
  const { a: e, b: t } = or,
    r = Qe(i * i),
    s = Qe(r * i);
  return Qe(s + e * i + t);
}
const Qc = or.a === Ot;
class _y extends Error {
  constructor(e) {
    super(e);
  }
}
function Um(i) {
  if (!(i instanceof Qt)) throw new TypeError('JacobianPoint expected');
}
class Qt {
  constructor(e, t, r) {
    (this.x = e), (this.y = t), (this.z = r);
  }
  static fromAffine(e) {
    if (!(e instanceof Yt)) throw new TypeError('JacobianPoint#fromAffine: expected Point');
    return e.equals(Yt.ZERO) ? Qt.ZERO : new Qt(e.x, e.y, Br);
  }
  static toAffineBatch(e) {
    const t = pB(e.map((r) => r.z));
    return e.map((r, s) => r.toAffine(t[s]));
  }
  static normalizeZ(e) {
    return Qt.toAffineBatch(e).map(Qt.fromAffine);
  }
  equals(e) {
    Um(e);
    const { x: t, y: r, z: s } = this,
      { x: n, y: c, z: f } = e,
      h = Qe(s * s),
      y = Qe(f * f),
      p = Qe(t * y),
      m = Qe(n * h),
      _ = Qe(Qe(r * f) * y),
      A = Qe(Qe(c * s) * h);
    return p === m && _ === A;
  }
  negate() {
    return new Qt(this.x, Qe(-this.y), this.z);
  }
  double() {
    const { x: e, y: t, z: r } = this,
      s = Qe(e * e),
      n = Qe(t * t),
      c = Qe(n * n),
      f = e + n,
      h = Qe(xo * (Qe(f * f) - s - c)),
      y = Qe(Mu * s),
      p = Qe(y * y),
      m = Qe(p - xo * h),
      _ = Qe(y * (h - m) - Nm * c),
      A = Qe(xo * t * r);
    return new Qt(m, _, A);
  }
  add(e) {
    Um(e);
    const { x: t, y: r, z: s } = this,
      { x: n, y: c, z: f } = e;
    if (n === Ot || c === Ot) return this;
    if (t === Ot || r === Ot) return e;
    const h = Qe(s * s),
      y = Qe(f * f),
      p = Qe(t * y),
      m = Qe(n * h),
      _ = Qe(Qe(r * f) * y),
      A = Qe(Qe(c * s) * h),
      E = Qe(m - p),
      I = Qe(A - _);
    if (E === Ot) return I === Ot ? this.double() : Qt.ZERO;
    const R = Qe(E * E),
      L = Qe(E * R),
      D = Qe(p * R),
      q = Qe(I * I - L - xo * D),
      H = Qe(I * (D - q) - _ * L),
      V = Qe(s * f * E);
    return new Qt(q, H, V);
  }
  subtract(e) {
    return this.add(e.negate());
  }
  multiplyUnsafe(e) {
    const t = Qt.ZERO;
    if (typeof e == 'bigint' && e === Ot) return t;
    let r = qm(e);
    if (r === Br) return this;
    if (!Qc) {
      let m = t,
        _ = this;
      for (; r > Ot; ) r & Br && (m = m.add(_)), (_ = _.double()), (r >>= Br);
      return m;
    }
    let { k1neg: s, k1: n, k2neg: c, k2: f } = Xc.splitScalar(r),
      h = t,
      y = t,
      p = this;
    for (; n > Ot || f > Ot; )
      n & Br && (h = h.add(p)), f & Br && (y = y.add(p)), (p = p.double()), (n >>= Br), (f >>= Br);
    return (
      s && (h = h.negate()),
      c && (y = y.negate()),
      (y = new Qt(Qe(y.x * Xc.beta), y.y, y.z)),
      h.add(y)
    );
  }
  precomputeWindow(e) {
    const t = Qc ? 128 / e + 1 : 256 / e + 1,
      r = [];
    let s = this,
      n = s;
    for (let c = 0; c < t; c++) {
      (n = s), r.push(n);
      for (let f = 1; f < 2 ** (e - 1); f++) (n = n.add(s)), r.push(n);
      s = n.double();
    }
    return r;
  }
  wNAF(e, t) {
    !t && this.equals(Qt.BASE) && (t = Yt.BASE);
    const r = (t && t._WINDOW_SIZE) || 1;
    if (256 % r) throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');
    let s = t && t1.get(t);
    s || ((s = this.precomputeWindow(r)), t && r !== 1 && ((s = Qt.normalizeZ(s)), t1.set(t, s)));
    let n = Qt.ZERO,
      c = Qt.BASE;
    const f = 1 + (Qc ? 128 / r : 256 / r),
      h = 2 ** (r - 1),
      y = BigInt(2 ** r - 1),
      p = 2 ** r,
      m = BigInt(r);
    for (let _ = 0; _ < f; _++) {
      const A = _ * h;
      let E = Number(e & y);
      (e >>= m), E > h && ((E -= p), (e += Br));
      const I = A,
        R = A + Math.abs(E) - 1,
        L = _ % 2 !== 0,
        D = E < 0;
      E === 0 ? (c = c.add(ef(L, s[I]))) : (n = n.add(ef(D, s[R])));
    }
    return { p: n, f: c };
  }
  multiply(e, t) {
    let r = qm(e),
      s,
      n;
    if (Qc) {
      const { k1neg: c, k1: f, k2neg: h, k2: y } = Xc.splitScalar(r);
      let { p, f: m } = this.wNAF(f, t),
        { p: _, f: A } = this.wNAF(y, t);
      (p = ef(c, p)),
        (_ = ef(h, _)),
        (_ = new Qt(Qe(_.x * Xc.beta), _.y, _.z)),
        (s = p.add(_)),
        (n = m.add(A));
    } else {
      const { p: c, f } = this.wNAF(r, t);
      (s = c), (n = f);
    }
    return Qt.normalizeZ([s, n])[0];
  }
  toAffine(e) {
    const { x: t, y: r, z: s } = this,
      n = this.equals(Qt.ZERO);
    e == null && (e = n ? Nm : Va(s));
    const c = e,
      f = Qe(c * c),
      h = Qe(f * c),
      y = Qe(t * f),
      p = Qe(r * h),
      m = Qe(s * c);
    if (n) return Yt.ZERO;
    if (m !== Br) throw new Error('invZ was invalid');
    return new Yt(y, p);
  }
}
Qt.BASE = new Qt(or.Gx, or.Gy, Br);
Qt.ZERO = new Qt(Ot, Br, Ot);
function ef(i, e) {
  const t = e.negate();
  return i ? t : e;
}
const t1 = new WeakMap();
class Yt {
  constructor(e, t) {
    (this.x = e), (this.y = t);
  }
  _setWindowSize(e) {
    (this._WINDOW_SIZE = e), t1.delete(this);
  }
  hasEvenY() {
    return this.y % xo === Ot;
  }
  static fromCompressedHex(e) {
    const t = e.length === 32,
      r = Di(t ? e : e.subarray(1));
    if (!Ef(r)) throw new Error('Point is not on curve');
    const s = Dm(r);
    let n = dB(s);
    const c = (n & Br) === Br;
    t ? c && (n = Qe(-n)) : ((e[0] & 1) === 1) !== c && (n = Qe(-n));
    const f = new Yt(r, n);
    return f.assertValidity(), f;
  }
  static fromUncompressedHex(e) {
    const t = Di(e.subarray(1, sn + 1)),
      r = Di(e.subarray(sn + 1, sn * 2 + 1)),
      s = new Yt(t, r);
    return s.assertValidity(), s;
  }
  static fromHex(e) {
    const t = Dn(e),
      r = t.length,
      s = t[0];
    if (r === sn) return this.fromCompressedHex(t);
    if (r === Yf && (s === 2 || s === 3)) return this.fromCompressedHex(t);
    if (r === Zf && s === 4) return this.fromUncompressedHex(t);
    throw new Error(
      `Point.fromHex: received invalid point. Expected 32-${Yf} compressed bytes or ${Zf} uncompressed bytes, not ${r}`
    );
  }
  static fromPrivateKey(e) {
    return Yt.BASE.multiply(bs(e));
  }
  static fromSignature(e, t, r) {
    const { r: s, s: n } = G8(t);
    if (![0, 1, 2, 3].includes(r)) throw new Error('Cannot recover: invalid recovery bit');
    const c = Sy(Dn(e)),
      { n: f } = or,
      h = r === 2 || r === 3 ? s + f : s,
      y = Va(h, f),
      p = Qe(-c * y, f),
      m = Qe(n * y, f),
      _ = r & 1 ? '03' : '02',
      A = Yt.fromHex(_ + Po(h)),
      E = Yt.BASE.multiplyAndAddUnsafe(A, p, m);
    if (!E) throw new Error('Cannot recover signature: point at infinify');
    return E.assertValidity(), E;
  }
  toRawBytes(e = !1) {
    return To(this.toHex(e));
  }
  toHex(e = !1) {
    const t = Po(this.x);
    return e ? `${this.hasEvenY() ? '02' : '03'}${t}` : `04${t}${Po(this.y)}`;
  }
  toHexX() {
    return this.toHex(!0).slice(2);
  }
  toRawX() {
    return this.toRawBytes(!0).slice(1);
  }
  assertValidity() {
    const e = 'Point is not on elliptic curve',
      { x: t, y: r } = this;
    if (!Ef(t) || !Ef(r)) throw new Error(e);
    const s = Qe(r * r),
      n = Dm(t);
    if (Qe(s - n) !== Ot) throw new Error(e);
  }
  equals(e) {
    return this.x === e.x && this.y === e.y;
  }
  negate() {
    return new Yt(this.x, Qe(-this.y));
  }
  double() {
    return Qt.fromAffine(this).double().toAffine();
  }
  add(e) {
    return Qt.fromAffine(this).add(Qt.fromAffine(e)).toAffine();
  }
  subtract(e) {
    return this.add(e.negate());
  }
  multiply(e) {
    return Qt.fromAffine(this).multiply(e, this).toAffine();
  }
  multiplyAndAddUnsafe(e, t, r) {
    const s = Qt.fromAffine(this),
      n = t === Ot || t === Br || this !== Yt.BASE ? s.multiplyUnsafe(t) : s.multiply(t),
      c = Qt.fromAffine(e).multiplyUnsafe(r),
      f = n.add(c);
    return f.equals(Qt.ZERO) ? void 0 : f.toAffine();
  }
}
Yt.BASE = new Yt(or.Gx, or.Gy);
Yt.ZERO = new Yt(Ot, Ot);
function zm(i) {
  return Number.parseInt(i[0], 16) >= 8 ? '00' + i : i;
}
function Fm(i) {
  if (i.length < 2 || i[0] !== 2) throw new Error(`Invalid signature integer tag: ${ka(i)}`);
  const e = i[1],
    t = i.subarray(2, e + 2);
  if (!e || t.length !== e) throw new Error('Invalid signature integer: wrong length');
  if (t[0] === 0 && t[1] <= 127) throw new Error('Invalid signature integer: trailing length');
  return { data: Di(t), left: i.subarray(e + 2) };
}
function fB(i) {
  if (i.length < 2 || i[0] != 48) throw new Error(`Invalid signature tag: ${ka(i)}`);
  if (i[1] !== i.length - 2) throw new Error('Invalid signature: incorrect length');
  const { data: e, left: t } = Fm(i.subarray(2)),
    { data: r, left: s } = Fm(t);
  if (s.length) throw new Error(`Invalid signature: left bytes after parsing: ${ka(s)}`);
  return { r: e, s: r };
}
class ro {
  constructor(e, t) {
    (this.r = e), (this.s = t), this.assertValidity();
  }
  static fromCompact(e) {
    const t = e instanceof Uint8Array,
      r = 'Signature.fromCompact';
    if (typeof e != 'string' && !t) throw new TypeError(`${r}: Expected string or Uint8Array`);
    const s = t ? ka(e) : e;
    if (s.length !== 128) throw new Error(`${r}: Expected 64-byte hex`);
    return new ro(Jf(s.slice(0, 64)), Jf(s.slice(64, 128)));
  }
  static fromDER(e) {
    const t = e instanceof Uint8Array;
    if (typeof e != 'string' && !t)
      throw new TypeError('Signature.fromDER: Expected string or Uint8Array');
    const { r, s } = fB(t ? e : To(e));
    return new ro(r, s);
  }
  static fromHex(e) {
    return this.fromDER(e);
  }
  assertValidity() {
    const { r: e, s: t } = this;
    if (!xa(e)) throw new Error('Invalid Signature: r must be 0 < r < n');
    if (!xa(t)) throw new Error('Invalid Signature: s must be 0 < s < n');
  }
  hasHighS() {
    const e = or.n >> Br;
    return this.s > e;
  }
  normalizeS() {
    return this.hasHighS() ? new ro(this.r, Qe(-this.s, or.n)) : this;
  }
  toDERRawBytes() {
    return To(this.toDERHex());
  }
  toDERHex() {
    const e = zm(lu(this.s)),
      t = zm(lu(this.r)),
      r = e.length / 2,
      s = t.length / 2,
      n = lu(r),
      c = lu(s);
    return `30${lu(s + r + 4)}02${c}${t}02${n}${e}`;
  }
  toRawBytes() {
    return this.toDERRawBytes();
  }
  toHex() {
    return this.toDERHex();
  }
  toCompactRawBytes() {
    return To(this.toCompactHex());
  }
  toCompactHex() {
    return Po(this.r) + Po(this.s);
  }
}
function ko(...i) {
  if (!i.every((r) => r instanceof Uint8Array)) throw new Error('Uint8Array list expected');
  if (i.length === 1) return i[0];
  const e = i.reduce((r, s) => r + s.length, 0),
    t = new Uint8Array(e);
  for (let r = 0, s = 0; r < i.length; r++) {
    const n = i[r];
    t.set(n, s), (s += n.length);
  }
  return t;
}
const lB = Array.from({ length: 256 }, (i, e) => e.toString(16).padStart(2, '0'));
function ka(i) {
  if (!(i instanceof Uint8Array)) throw new Error('Expected Uint8Array');
  let e = '';
  for (let t = 0; t < i.length; t++) e += lB[i[t]];
  return e;
}
const hB = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');
function Po(i) {
  if (typeof i != 'bigint') throw new Error('Expected bigint');
  if (!(Ot <= i && i < hB)) throw new Error('Expected number 0 <= n < 2^256');
  return i.toString(16).padStart(64, '0');
}
function Ia(i) {
  const e = To(Po(i));
  if (e.length !== 32) throw new Error('Error: expected 32 bytes');
  return e;
}
function lu(i) {
  const e = i.toString(16);
  return e.length & 1 ? `0${e}` : e;
}
function Jf(i) {
  if (typeof i != 'string') throw new TypeError('hexToNumber: expected string, got ' + typeof i);
  return BigInt(`0x${i}`);
}
function To(i) {
  if (typeof i != 'string') throw new TypeError('hexToBytes: expected string, got ' + typeof i);
  if (i.length % 2) throw new Error('hexToBytes: received invalid unpadded hex' + i.length);
  const e = new Uint8Array(i.length / 2);
  for (let t = 0; t < e.length; t++) {
    const r = t * 2,
      s = i.slice(r, r + 2),
      n = Number.parseInt(s, 16);
    if (Number.isNaN(n) || n < 0) throw new Error('Invalid byte sequence');
    e[t] = n;
  }
  return e;
}
function Di(i) {
  return Jf(ka(i));
}
function Dn(i) {
  return i instanceof Uint8Array ? Uint8Array.from(i) : To(i);
}
function qm(i) {
  if (typeof i == 'number' && Number.isSafeInteger(i) && i > 0) return BigInt(i);
  if (typeof i == 'bigint' && xa(i)) return i;
  throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');
}
function Qe(i, e = or.P) {
  const t = i % e;
  return t >= Ot ? t : e + t;
}
function ji(i, e) {
  const { P: t } = or;
  let r = i;
  for (; e-- > Ot; ) (r *= r), (r %= t);
  return r;
}
function dB(i) {
  const { P: e } = or,
    t = BigInt(6),
    r = BigInt(11),
    s = BigInt(22),
    n = BigInt(23),
    c = BigInt(44),
    f = BigInt(88),
    h = (i * i * i) % e,
    y = (h * h * i) % e,
    p = (ji(y, Mu) * y) % e,
    m = (ji(p, Mu) * y) % e,
    _ = (ji(m, xo) * h) % e,
    A = (ji(_, r) * _) % e,
    E = (ji(A, s) * A) % e,
    I = (ji(E, c) * E) % e,
    R = (ji(I, f) * I) % e,
    L = (ji(R, c) * E) % e,
    D = (ji(L, Mu) * y) % e,
    q = (ji(D, n) * A) % e,
    H = (ji(q, t) * h) % e,
    V = ji(H, xo);
  if ((V * V) % e !== i) throw new Error('Cannot find square root');
  return V;
}
function Va(i, e = or.P) {
  if (i === Ot || e <= Ot)
    throw new Error(`invert: expected positive integers, got n=${i} mod=${e}`);
  let t = Qe(i, e),
    r = e,
    s = Ot,
    n = Br;
  for (; t !== Ot; ) {
    const f = r / t,
      h = r % t,
      y = s - n * f;
    (r = t), (t = h), (s = n), (n = y);
  }
  if (r !== Br) throw new Error('invert: does not exist');
  return Qe(s, e);
}
function pB(i, e = or.P) {
  const t = new Array(i.length),
    r = i.reduce((n, c, f) => (c === Ot ? n : ((t[f] = n), Qe(n * c, e))), Br),
    s = Va(r, e);
  return (
    i.reduceRight((n, c, f) => (c === Ot ? n : ((t[f] = Qe(n * t[f], e)), Qe(n * c, e))), s), t
  );
}
function yB(i) {
  const e = i.length * 8 - gs * 8,
    t = Di(i);
  return e > 0 ? t >> BigInt(e) : t;
}
function Sy(i, e = !1) {
  const t = yB(i);
  if (e) return t;
  const { n: r } = or;
  return t >= r ? t - r : t;
}
let da, Au;
class H8 {
  constructor(e, t) {
    if (((this.hashLen = e), (this.qByteLen = t), typeof e != 'number' || e < 2))
      throw new Error('hashLen must be a number');
    if (typeof t != 'number' || t < 2) throw new Error('qByteLen must be a number');
    (this.v = new Uint8Array(e).fill(1)), (this.k = new Uint8Array(e).fill(0)), (this.counter = 0);
  }
  hmac(...e) {
    return oi.hmacSha256(this.k, ...e);
  }
  hmacSync(...e) {
    return Au(this.k, ...e);
  }
  checkSync() {
    if (typeof Au != 'function') throw new _y('hmacSha256Sync needs to be set');
  }
  incr() {
    if (this.counter >= 1e3) throw new Error('Tried 1,000 k values for sign(), all were invalid');
    this.counter += 1;
  }
  async reseed(e = new Uint8Array()) {
    (this.k = await this.hmac(this.v, Uint8Array.from([0]), e)),
      (this.v = await this.hmac(this.v)),
      e.length !== 0 &&
        ((this.k = await this.hmac(this.v, Uint8Array.from([1]), e)),
        (this.v = await this.hmac(this.v)));
  }
  reseedSync(e = new Uint8Array()) {
    this.checkSync(),
      (this.k = this.hmacSync(this.v, Uint8Array.from([0]), e)),
      (this.v = this.hmacSync(this.v)),
      e.length !== 0 &&
        ((this.k = this.hmacSync(this.v, Uint8Array.from([1]), e)),
        (this.v = this.hmacSync(this.v)));
  }
  async generate() {
    this.incr();
    let e = 0;
    const t = [];
    for (; e < this.qByteLen; ) {
      this.v = await this.hmac(this.v);
      const r = this.v.slice();
      t.push(r), (e += this.v.length);
    }
    return ko(...t);
  }
  generateSync() {
    this.checkSync(), this.incr();
    let e = 0;
    const t = [];
    for (; e < this.qByteLen; ) {
      this.v = this.hmacSync(this.v);
      const r = this.v.slice();
      t.push(r), (e += this.v.length);
    }
    return ko(...t);
  }
}
function xa(i) {
  return Ot < i && i < or.n;
}
function Ef(i) {
  return Ot < i && i < or.P;
}
function V8(i, e, t, r = !0) {
  const { n: s } = or,
    n = Sy(i, !0);
  if (!xa(n)) return;
  const c = Va(n, s),
    f = Yt.BASE.multiply(n),
    h = Qe(f.x, s);
  if (h === Ot) return;
  const y = Qe(c * Qe(e + t * h, s), s);
  if (y === Ot) return;
  let p = new ro(h, y),
    m = (f.x === p.r ? 0 : 2) | Number(f.y & Br);
  return r && p.hasHighS() && ((p = p.normalizeS()), (m ^= 1)), { sig: p, recovery: m };
}
function bs(i) {
  let e;
  if (typeof i == 'bigint') e = i;
  else if (typeof i == 'number' && Number.isSafeInteger(i) && i > 0) e = BigInt(i);
  else if (typeof i == 'string') {
    if (i.length !== 2 * gs) throw new Error('Expected 32 bytes of private key');
    e = Jf(i);
  } else if (i instanceof Uint8Array) {
    if (i.length !== gs) throw new Error('Expected 32 bytes of private key');
    e = Di(i);
  } else throw new TypeError('Expected valid private key');
  if (!xa(e)) throw new Error('Expected private key: 0 < key < n');
  return e;
}
function My(i) {
  return i instanceof Yt ? (i.assertValidity(), i) : Yt.fromHex(i);
}
function G8(i) {
  if (i instanceof ro) return i.assertValidity(), i;
  try {
    return ro.fromDER(i);
  } catch {
    return ro.fromCompact(i);
  }
}
function Ay(i, e = !1) {
  return Yt.fromPrivateKey(i).toRawBytes(e);
}
function gB(i, e, t, r = !1) {
  return Yt.fromSignature(i, e, t).toRawBytes(r);
}
function Wm(i) {
  const e = i instanceof Uint8Array,
    t = typeof i == 'string',
    r = (e || t) && i.length;
  return e ? r === Yf || r === Zf : t ? r === Yf * 2 || r === Zf * 2 : i instanceof Yt;
}
function bB(i, e, t = !1) {
  if (Wm(i)) throw new TypeError('getSharedSecret: first arg must be private key');
  if (!Wm(e)) throw new TypeError('getSharedSecret: second arg must be public key');
  const r = My(e);
  return r.assertValidity(), r.multiply(bs(i)).toRawBytes(t);
}
function Y8(i) {
  const e = i.length > sn ? i.slice(0, sn) : i;
  return Di(e);
}
function vB(i) {
  const e = Y8(i),
    t = Qe(e, or.n);
  return Z8(t < Ot ? e : t);
}
function Z8(i) {
  return Ia(i);
}
function J8(i, e, t) {
  if (i == null) throw new Error(`sign: expected valid message hash, not "${i}"`);
  const r = Dn(i),
    s = bs(e),
    n = [Z8(s), vB(r)];
  if (t != null) {
    t === !0 && (t = oi.randomBytes(sn));
    const h = Dn(t);
    if (h.length !== sn) throw new Error(`sign: Expected ${sn} bytes of extra data`);
    n.push(h);
  }
  const c = ko(...n),
    f = Y8(r);
  return { seed: c, m: f, d: s };
}
function X8(i, e) {
  const { sig: t, recovery: r } = i,
    { der: s, recovered: n } = Object.assign({ canonical: !0, der: !0 }, e),
    c = s ? t.toDERRawBytes() : t.toCompactRawBytes();
  return n ? [c, r] : c;
}
async function mB(i, e, t = {}) {
  const { seed: r, m: s, d: n } = J8(i, e, t.extraEntropy),
    c = new H8(j8, gs);
  await c.reseed(r);
  let f;
  for (; !(f = V8(await c.generate(), s, n, t.canonical)); ) await c.reseed();
  return X8(f, t);
}
function Ey(i, e, t = {}) {
  const { seed: r, m: s, d: n } = J8(i, e, t.extraEntropy),
    c = new H8(j8, gs);
  c.reseedSync(r);
  let f;
  for (; !(f = V8(c.generateSync(), s, n, t.canonical)); ) c.reseedSync();
  return X8(f, t);
}
const wB = { strict: !0 };
function _B(i, e, t, r = wB) {
  let s;
  try {
    (s = G8(i)), (e = Dn(e));
  } catch {
    return !1;
  }
  const { r: n, s: c } = s;
  if (r.strict && s.hasHighS()) return !1;
  const f = Sy(e);
  let h;
  try {
    h = My(t);
  } catch {
    return !1;
  }
  const { n: y } = or,
    p = Va(c, y),
    m = Qe(f * p, y),
    _ = Qe(n * p, y),
    A = Yt.BASE.multiplyAndAddUnsafe(h, m, _);
  return A ? Qe(A.x, y) === n : !1;
}
function Xf(i) {
  return Qe(Di(i), or.n);
}
class Ba {
  constructor(e, t) {
    (this.r = e), (this.s = t), this.assertValidity();
  }
  static fromHex(e) {
    const t = Dn(e);
    if (t.length !== 64)
      throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${t.length}`);
    const r = Di(t.subarray(0, 32)),
      s = Di(t.subarray(32, 64));
    return new Ba(r, s);
  }
  assertValidity() {
    const { r: e, s: t } = this;
    if (!Ef(e) || !xa(t)) throw new Error('Invalid signature');
  }
  toHex() {
    return Po(this.r) + Po(this.s);
  }
  toRawBytes() {
    return To(this.toHex());
  }
}
function SB(i) {
  return Yt.fromPrivateKey(i).toRawX();
}
class Q8 {
  constructor(e, t, r = oi.randomBytes()) {
    if (e == null) throw new TypeError(`sign: Expected valid message, not "${e}"`);
    this.m = Dn(e);
    const { x: s, scalar: n } = this.getScalar(bs(t));
    if (((this.px = s), (this.d = n), (this.rand = Dn(r)), this.rand.length !== 32))
      throw new TypeError('sign: Expected 32 bytes of aux randomness');
  }
  getScalar(e) {
    const t = Yt.fromPrivateKey(e),
      r = t.hasEvenY() ? e : or.n - e;
    return { point: t, scalar: r, x: t.toRawX() };
  }
  initNonce(e, t) {
    return Ia(e ^ Di(t));
  }
  finalizeNonce(e) {
    const t = Qe(Di(e), or.n);
    if (t === Ot) throw new Error('sign: Creation of signature failed. k is zero');
    const { point: r, x: s, scalar: n } = this.getScalar(t);
    return { R: r, rx: s, k: n };
  }
  finalizeSig(e, t, r, s) {
    return new Ba(e.x, Qe(t + r * s, or.n)).toRawBytes();
  }
  error() {
    throw new Error('sign: Invalid signature produced');
  }
  async calc() {
    const { m: e, d: t, px: r, rand: s } = this,
      n = oi.taggedHash,
      c = this.initNonce(t, await n(Mo.aux, s)),
      { R: f, rx: h, k: y } = this.finalizeNonce(await n(Mo.nonce, c, r, e)),
      p = Xf(await n(Mo.challenge, h, r, e)),
      m = this.finalizeSig(f, y, p, t);
    return (await r3(m, e, r)) || this.error(), m;
  }
  calcSync() {
    const { m: e, d: t, px: r, rand: s } = this,
      n = oi.taggedHashSync,
      c = this.initNonce(t, n(Mo.aux, s)),
      { R: f, rx: h, k: y } = this.finalizeNonce(n(Mo.nonce, c, r, e)),
      p = Xf(n(Mo.challenge, h, r, e)),
      m = this.finalizeSig(f, y, p, t);
    return i3(m, e, r) || this.error(), m;
  }
}
async function MB(i, e, t) {
  return new Q8(i, e, t).calc();
}
function AB(i, e, t) {
  return new Q8(i, e, t).calcSync();
}
function e3(i, e, t) {
  const r = i instanceof Ba,
    s = r ? i : Ba.fromHex(i);
  return r && s.assertValidity(), { ...s, m: Dn(e), P: My(t) };
}
function t3(i, e, t, r) {
  const s = Yt.BASE.multiplyAndAddUnsafe(e, bs(t), Qe(-r, or.n));
  return !(!s || !s.hasEvenY() || s.x !== i);
}
async function r3(i, e, t) {
  try {
    const { r, s, m: n, P: c } = e3(i, e, t),
      f = Xf(await oi.taggedHash(Mo.challenge, Ia(r), c.toRawX(), n));
    return t3(r, c, s, f);
  } catch {
    return !1;
  }
}
function i3(i, e, t) {
  try {
    const { r, s, m: n, P: c } = e3(i, e, t),
      f = Xf(oi.taggedHashSync(Mo.challenge, Ia(r), c.toRawX(), n));
    return t3(r, c, s, f);
  } catch (r) {
    if (r instanceof _y) throw r;
    return !1;
  }
}
const EB = { Signature: Ba, getPublicKey: SB, sign: MB, verify: r3, signSync: AB, verifySync: i3 };
Yt.BASE._setWindowSize(8);
const Bi = {
    node: D8,
    web: typeof globalThis == 'object' && 'crypto' in globalThis ? globalThis.crypto : void 0,
  },
  Mo = { challenge: 'BIP0340/challenge', aux: 'BIP0340/aux', nonce: 'BIP0340/nonce' },
  tf = {},
  oi = {
    bytesToHex: ka,
    hexToBytes: To,
    concatBytes: ko,
    mod: Qe,
    invert: Va,
    isValidPrivateKey(i) {
      try {
        return bs(i), !0;
      } catch {
        return !1;
      }
    },
    _bigintTo32Bytes: Ia,
    _normalizePrivateKey: bs,
    hashToPrivateKey: (i) => {
      i = Dn(i);
      const e = gs + 8;
      if (i.length < e || i.length > 1024)
        throw new Error('Expected valid bytes of private key as per FIPS 186');
      const t = Qe(Di(i), or.n - Br) + Br;
      return Ia(t);
    },
    randomBytes: (i = 32) => {
      if (Bi.web) return Bi.web.getRandomValues(new Uint8Array(i));
      if (Bi.node) {
        const { randomBytes: e } = Bi.node;
        return Uint8Array.from(e(i));
      } else throw new Error("The environment doesn't have randomBytes function");
    },
    randomPrivateKey: () => oi.hashToPrivateKey(oi.randomBytes(gs + 8)),
    precompute(i = 8, e = Yt.BASE) {
      const t = e === Yt.BASE ? e : new Yt(e.x, e.y);
      return t._setWindowSize(i), t.multiply(Mu), t;
    },
    sha256: async (...i) => {
      if (Bi.web) {
        const e = await Bi.web.subtle.digest('SHA-256', ko(...i));
        return new Uint8Array(e);
      } else if (Bi.node) {
        const { createHash: e } = Bi.node,
          t = e('sha256');
        return i.forEach((r) => t.update(r)), Uint8Array.from(t.digest());
      } else throw new Error("The environment doesn't have sha256 function");
    },
    hmacSha256: async (i, ...e) => {
      if (Bi.web) {
        const t = await Bi.web.subtle.importKey(
            'raw',
            i,
            { name: 'HMAC', hash: { name: 'SHA-256' } },
            !1,
            ['sign']
          ),
          r = ko(...e),
          s = await Bi.web.subtle.sign('HMAC', t, r);
        return new Uint8Array(s);
      } else if (Bi.node) {
        const { createHmac: t } = Bi.node,
          r = t('sha256', i);
        return e.forEach((s) => r.update(s)), Uint8Array.from(r.digest());
      } else throw new Error("The environment doesn't have hmac-sha256 function");
    },
    sha256Sync: void 0,
    hmacSha256Sync: void 0,
    taggedHash: async (i, ...e) => {
      let t = tf[i];
      if (t === void 0) {
        const r = await oi.sha256(Uint8Array.from(i, (s) => s.charCodeAt(0)));
        (t = ko(r, r)), (tf[i] = t);
      }
      return oi.sha256(t, ...e);
    },
    taggedHashSync: (i, ...e) => {
      if (typeof da != 'function') throw new _y('sha256Sync is undefined, you need to set it');
      let t = tf[i];
      if (t === void 0) {
        const r = da(Uint8Array.from(i, (s) => s.charCodeAt(0)));
        (t = ko(r, r)), (tf[i] = t);
      }
      return da(t, ...e);
    },
    _JacobianPoint: Qt,
  };
Object.defineProperties(oi, {
  sha256Sync: {
    configurable: !1,
    get() {
      return da;
    },
    set(i) {
      da || (da = i);
    },
  },
  hmacSha256Sync: {
    configurable: !1,
    get() {
      return Au;
    },
    set(i) {
      Au || (Au = i);
    },
  },
});
const TU = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      CURVE: or,
      Point: Yt,
      Signature: ro,
      getPublicKey: Ay,
      getSharedSecret: bB,
      recoverPublicKey: gB,
      schnorr: EB,
      sign: mB,
      signSync: Ey,
      utils: oi,
      verify: _B,
    },
    Symbol.toStringTag,
    { value: 'Module' }
  )
);
var kB = Ko();
const Cu = zn(kB);
var n3 = { exports: {} };
(function (i) {
  (function () {
    var e = 'input is invalid type',
      t = 'finalize already called',
      r = typeof window == 'object',
      s = r ? window : {};
    s.JS_SHA3_NO_WINDOW && (r = !1);
    var n = !r && typeof globalThis == 'object',
      c = !s.JS_SHA3_NO_NODE_JS && typeof Je == 'object' && Je.versions && Je.versions.node;
    (c || n) && (s = globalThis);
    var f = !s.JS_SHA3_NO_COMMON_JS && !0 && i.exports,
      h = !s.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < 'u',
      y = '0123456789abcdef'.split(''),
      p = [31, 7936, 2031616, 520093696],
      m = [4, 1024, 262144, 67108864],
      _ = [1, 256, 65536, 16777216],
      A = [6, 1536, 393216, 100663296],
      E = [0, 8, 16, 24],
      I = [
        1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0,
        2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0,
        2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648,
        128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896,
        2147483648, 2147483649, 0, 2147516424, 2147483648,
      ],
      R = [224, 256, 384, 512],
      L = [128, 256],
      D = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'],
      q = { 128: 168, 256: 136 };
    (s.JS_SHA3_NO_NODE_JS || !Array.isArray) &&
      (Array.isArray = function (P) {
        return Object.prototype.toString.call(P) === '[object Array]';
      }),
      h &&
        (s.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) &&
        (ArrayBuffer.isView = function (P) {
          return typeof P == 'object' && P.buffer && P.buffer.constructor === ArrayBuffer;
        });
    for (
      var H = function (P, C, z) {
          return function (Y) {
            return new k(P, C, P).update(Y)[z]();
          };
        },
        V = function (P, C, z) {
          return function (Y, G) {
            return new k(P, C, G).update(Y)[z]();
          };
        },
        te = function (P, C, z) {
          return function (Y, G, Q, U) {
            return l['cshake' + P].update(Y, G, Q, U)[z]();
          };
        },
        ue = function (P, C, z) {
          return function (Y, G, Q, U) {
            return l['kmac' + P].update(Y, G, Q, U)[z]();
          };
        },
        ne = function (P, C, z, Y) {
          for (var G = 0; G < D.length; ++G) {
            var Q = D[G];
            P[Q] = C(z, Y, Q);
          }
          return P;
        },
        X = function (P, C) {
          var z = H(P, C, 'hex');
          return (
            (z.create = function () {
              return new k(P, C, P);
            }),
            (z.update = function (Y) {
              return z.create().update(Y);
            }),
            ne(z, H, P, C)
          );
        },
        Oe = function (P, C) {
          var z = V(P, C, 'hex');
          return (
            (z.create = function (Y) {
              return new k(P, C, Y);
            }),
            (z.update = function (Y, G) {
              return z.create(G).update(Y);
            }),
            ne(z, V, P, C)
          );
        },
        S = function (P, C) {
          var z = q[P],
            Y = te(P, C, 'hex');
          return (
            (Y.create = function (G, Q, U) {
              return !Q && !U ? l['shake' + P].create(G) : new k(P, C, G).bytepad([Q, U], z);
            }),
            (Y.update = function (G, Q, U, $) {
              return Y.create(Q, U, $).update(G);
            }),
            ne(Y, te, P, C)
          );
        },
        o = function (P, C) {
          var z = q[P],
            Y = ue(P, C, 'hex');
          return (
            (Y.create = function (G, Q, U) {
              return new B(P, C, Q).bytepad(['KMAC', U], z).bytepad([G], z);
            }),
            (Y.update = function (G, Q, U, $) {
              return Y.create(G, U, $).update(Q);
            }),
            ne(Y, ue, P, C)
          );
        },
        u = [
          { name: 'keccak', padding: _, bits: R, createMethod: X },
          { name: 'sha3', padding: A, bits: R, createMethod: X },
          { name: 'shake', padding: p, bits: L, createMethod: Oe },
          { name: 'cshake', padding: m, bits: L, createMethod: S },
          { name: 'kmac', padding: m, bits: L, createMethod: o },
        ],
        l = {},
        d = [],
        g = 0;
      g < u.length;
      ++g
    )
      for (var w = u[g], M = w.bits, v = 0; v < M.length; ++v) {
        var a = w.name + '_' + M[v];
        if ((d.push(a), (l[a] = w.createMethod(M[v], w.padding)), w.name !== 'sha3')) {
          var b = w.name + M[v];
          d.push(b), (l[b] = l[a]);
        }
      }
    function k(P, C, z) {
      (this.blocks = []),
        (this.s = []),
        (this.padding = C),
        (this.outputBits = z),
        (this.reset = !0),
        (this.finalized = !1),
        (this.block = 0),
        (this.start = 0),
        (this.blockCount = (1600 - (P << 1)) >> 5),
        (this.byteCount = this.blockCount << 2),
        (this.outputBlocks = z >> 5),
        (this.extraBytes = (z & 31) >> 3);
      for (var Y = 0; Y < 50; ++Y) this.s[Y] = 0;
    }
    (k.prototype.update = function (P) {
      if (this.finalized) throw new Error(t);
      var C,
        z = typeof P;
      if (z !== 'string') {
        if (z === 'object') {
          if (P === null) throw new Error(e);
          if (h && P.constructor === ArrayBuffer) P = new Uint8Array(P);
          else if (!Array.isArray(P) && (!h || !ArrayBuffer.isView(P))) throw new Error(e);
        } else throw new Error(e);
        C = !0;
      }
      for (
        var Y = this.blocks,
          G = this.byteCount,
          Q = P.length,
          U = this.blockCount,
          $ = 0,
          Z = this.s,
          ae,
          fe;
        $ < Q;

      ) {
        if (this.reset)
          for (this.reset = !1, Y[0] = this.block, ae = 1; ae < U + 1; ++ae) Y[ae] = 0;
        if (C) for (ae = this.start; $ < Q && ae < G; ++$) Y[ae >> 2] |= P[$] << E[ae++ & 3];
        else
          for (ae = this.start; $ < Q && ae < G; ++$)
            (fe = P.charCodeAt($)),
              fe < 128
                ? (Y[ae >> 2] |= fe << E[ae++ & 3])
                : fe < 2048
                  ? ((Y[ae >> 2] |= (192 | (fe >> 6)) << E[ae++ & 3]),
                    (Y[ae >> 2] |= (128 | (fe & 63)) << E[ae++ & 3]))
                  : fe < 55296 || fe >= 57344
                    ? ((Y[ae >> 2] |= (224 | (fe >> 12)) << E[ae++ & 3]),
                      (Y[ae >> 2] |= (128 | ((fe >> 6) & 63)) << E[ae++ & 3]),
                      (Y[ae >> 2] |= (128 | (fe & 63)) << E[ae++ & 3]))
                    : ((fe = 65536 + (((fe & 1023) << 10) | (P.charCodeAt(++$) & 1023))),
                      (Y[ae >> 2] |= (240 | (fe >> 18)) << E[ae++ & 3]),
                      (Y[ae >> 2] |= (128 | ((fe >> 12) & 63)) << E[ae++ & 3]),
                      (Y[ae >> 2] |= (128 | ((fe >> 6) & 63)) << E[ae++ & 3]),
                      (Y[ae >> 2] |= (128 | (fe & 63)) << E[ae++ & 3]));
        if (((this.lastByteIndex = ae), ae >= G)) {
          for (this.start = ae - G, this.block = Y[U], ae = 0; ae < U; ++ae) Z[ae] ^= Y[ae];
          F(Z), (this.reset = !0);
        } else this.start = ae;
      }
      return this;
    }),
      (k.prototype.encode = function (P, C) {
        var z = P & 255,
          Y = 1,
          G = [z];
        for (P = P >> 8, z = P & 255; z > 0; ) G.unshift(z), (P = P >> 8), (z = P & 255), ++Y;
        return C ? G.push(Y) : G.unshift(Y), this.update(G), G.length;
      }),
      (k.prototype.encodeString = function (P) {
        var C,
          z = typeof P;
        if (z !== 'string') {
          if (z === 'object') {
            if (P === null) throw new Error(e);
            if (h && P.constructor === ArrayBuffer) P = new Uint8Array(P);
            else if (!Array.isArray(P) && (!h || !ArrayBuffer.isView(P))) throw new Error(e);
          } else throw new Error(e);
          C = !0;
        }
        var Y = 0,
          G = P.length;
        if (C) Y = G;
        else
          for (var Q = 0; Q < P.length; ++Q) {
            var U = P.charCodeAt(Q);
            U < 128
              ? (Y += 1)
              : U < 2048
                ? (Y += 2)
                : U < 55296 || U >= 57344
                  ? (Y += 3)
                  : ((U = 65536 + (((U & 1023) << 10) | (P.charCodeAt(++Q) & 1023))), (Y += 4));
          }
        return (Y += this.encode(Y * 8)), this.update(P), Y;
      }),
      (k.prototype.bytepad = function (P, C) {
        for (var z = this.encode(C), Y = 0; Y < P.length; ++Y) z += this.encodeString(P[Y]);
        var G = C - (z % C),
          Q = [];
        return (Q.length = G), this.update(Q), this;
      }),
      (k.prototype.finalize = function () {
        if (!this.finalized) {
          this.finalized = !0;
          var P = this.blocks,
            C = this.lastByteIndex,
            z = this.blockCount,
            Y = this.s;
          if (((P[C >> 2] |= this.padding[C & 3]), this.lastByteIndex === this.byteCount))
            for (P[0] = P[z], C = 1; C < z + 1; ++C) P[C] = 0;
          for (P[z - 1] |= 2147483648, C = 0; C < z; ++C) Y[C] ^= P[C];
          F(Y);
        }
      }),
      (k.prototype.toString = k.prototype.hex =
        function () {
          this.finalize();
          for (
            var P = this.blockCount,
              C = this.s,
              z = this.outputBlocks,
              Y = this.extraBytes,
              G = 0,
              Q = 0,
              U = '',
              $;
            Q < z;

          ) {
            for (G = 0; G < P && Q < z; ++G, ++Q)
              ($ = C[G]),
                (U +=
                  y[($ >> 4) & 15] +
                  y[$ & 15] +
                  y[($ >> 12) & 15] +
                  y[($ >> 8) & 15] +
                  y[($ >> 20) & 15] +
                  y[($ >> 16) & 15] +
                  y[($ >> 28) & 15] +
                  y[($ >> 24) & 15]);
            Q % P === 0 && (F(C), (G = 0));
          }
          return (
            Y &&
              (($ = C[G]),
              (U += y[($ >> 4) & 15] + y[$ & 15]),
              Y > 1 && (U += y[($ >> 12) & 15] + y[($ >> 8) & 15]),
              Y > 2 && (U += y[($ >> 20) & 15] + y[($ >> 16) & 15])),
            U
          );
        }),
      (k.prototype.arrayBuffer = function () {
        this.finalize();
        var P = this.blockCount,
          C = this.s,
          z = this.outputBlocks,
          Y = this.extraBytes,
          G = 0,
          Q = 0,
          U = this.outputBits >> 3,
          $;
        Y ? ($ = new ArrayBuffer((z + 1) << 2)) : ($ = new ArrayBuffer(U));
        for (var Z = new Uint32Array($); Q < z; ) {
          for (G = 0; G < P && Q < z; ++G, ++Q) Z[Q] = C[G];
          Q % P === 0 && F(C);
        }
        return Y && ((Z[G] = C[G]), ($ = $.slice(0, U))), $;
      }),
      (k.prototype.buffer = k.prototype.arrayBuffer),
      (k.prototype.digest = k.prototype.array =
        function () {
          this.finalize();
          for (
            var P = this.blockCount,
              C = this.s,
              z = this.outputBlocks,
              Y = this.extraBytes,
              G = 0,
              Q = 0,
              U = [],
              $,
              Z;
            Q < z;

          ) {
            for (G = 0; G < P && Q < z; ++G, ++Q)
              ($ = Q << 2),
                (Z = C[G]),
                (U[$] = Z & 255),
                (U[$ + 1] = (Z >> 8) & 255),
                (U[$ + 2] = (Z >> 16) & 255),
                (U[$ + 3] = (Z >> 24) & 255);
            Q % P === 0 && F(C);
          }
          return (
            Y &&
              (($ = Q << 2),
              (Z = C[G]),
              (U[$] = Z & 255),
              Y > 1 && (U[$ + 1] = (Z >> 8) & 255),
              Y > 2 && (U[$ + 2] = (Z >> 16) & 255)),
            U
          );
        });
    function B(P, C, z) {
      k.call(this, P, C, z);
    }
    (B.prototype = new k()),
      (B.prototype.finalize = function () {
        return this.encode(this.outputBits, !0), k.prototype.finalize.call(this);
      });
    var F = function (P) {
      var C,
        z,
        Y,
        G,
        Q,
        U,
        $,
        Z,
        ae,
        fe,
        le,
        Fe,
        be,
        oe,
        rt,
        me,
        re,
        ge,
        ce,
        he,
        Ke,
        K,
        O,
        W,
        T,
        x,
        N,
        j,
        J,
        de,
        ie,
        ye,
        Ye,
        ve,
        _e,
        et,
        Me,
        Ce,
        yt,
        Ae,
        Le,
        gt,
        Ee,
        Ne,
        bt,
        ke,
        $e,
        vt,
        Ie,
        De,
        mt,
        xe,
        Ue,
        wt,
        Be,
        ze,
        st,
        at,
        Ft,
        qt,
        Wt,
        Kt,
        jt;
      for (Y = 0; Y < 48; Y += 2)
        (G = P[0] ^ P[10] ^ P[20] ^ P[30] ^ P[40]),
          (Q = P[1] ^ P[11] ^ P[21] ^ P[31] ^ P[41]),
          (U = P[2] ^ P[12] ^ P[22] ^ P[32] ^ P[42]),
          ($ = P[3] ^ P[13] ^ P[23] ^ P[33] ^ P[43]),
          (Z = P[4] ^ P[14] ^ P[24] ^ P[34] ^ P[44]),
          (ae = P[5] ^ P[15] ^ P[25] ^ P[35] ^ P[45]),
          (fe = P[6] ^ P[16] ^ P[26] ^ P[36] ^ P[46]),
          (le = P[7] ^ P[17] ^ P[27] ^ P[37] ^ P[47]),
          (Fe = P[8] ^ P[18] ^ P[28] ^ P[38] ^ P[48]),
          (be = P[9] ^ P[19] ^ P[29] ^ P[39] ^ P[49]),
          (C = Fe ^ ((U << 1) | ($ >>> 31))),
          (z = be ^ (($ << 1) | (U >>> 31))),
          (P[0] ^= C),
          (P[1] ^= z),
          (P[10] ^= C),
          (P[11] ^= z),
          (P[20] ^= C),
          (P[21] ^= z),
          (P[30] ^= C),
          (P[31] ^= z),
          (P[40] ^= C),
          (P[41] ^= z),
          (C = G ^ ((Z << 1) | (ae >>> 31))),
          (z = Q ^ ((ae << 1) | (Z >>> 31))),
          (P[2] ^= C),
          (P[3] ^= z),
          (P[12] ^= C),
          (P[13] ^= z),
          (P[22] ^= C),
          (P[23] ^= z),
          (P[32] ^= C),
          (P[33] ^= z),
          (P[42] ^= C),
          (P[43] ^= z),
          (C = U ^ ((fe << 1) | (le >>> 31))),
          (z = $ ^ ((le << 1) | (fe >>> 31))),
          (P[4] ^= C),
          (P[5] ^= z),
          (P[14] ^= C),
          (P[15] ^= z),
          (P[24] ^= C),
          (P[25] ^= z),
          (P[34] ^= C),
          (P[35] ^= z),
          (P[44] ^= C),
          (P[45] ^= z),
          (C = Z ^ ((Fe << 1) | (be >>> 31))),
          (z = ae ^ ((be << 1) | (Fe >>> 31))),
          (P[6] ^= C),
          (P[7] ^= z),
          (P[16] ^= C),
          (P[17] ^= z),
          (P[26] ^= C),
          (P[27] ^= z),
          (P[36] ^= C),
          (P[37] ^= z),
          (P[46] ^= C),
          (P[47] ^= z),
          (C = fe ^ ((G << 1) | (Q >>> 31))),
          (z = le ^ ((Q << 1) | (G >>> 31))),
          (P[8] ^= C),
          (P[9] ^= z),
          (P[18] ^= C),
          (P[19] ^= z),
          (P[28] ^= C),
          (P[29] ^= z),
          (P[38] ^= C),
          (P[39] ^= z),
          (P[48] ^= C),
          (P[49] ^= z),
          (oe = P[0]),
          (rt = P[1]),
          (ke = (P[11] << 4) | (P[10] >>> 28)),
          ($e = (P[10] << 4) | (P[11] >>> 28)),
          (j = (P[20] << 3) | (P[21] >>> 29)),
          (J = (P[21] << 3) | (P[20] >>> 29)),
          (qt = (P[31] << 9) | (P[30] >>> 23)),
          (Wt = (P[30] << 9) | (P[31] >>> 23)),
          (gt = (P[40] << 18) | (P[41] >>> 14)),
          (Ee = (P[41] << 18) | (P[40] >>> 14)),
          (ve = (P[2] << 1) | (P[3] >>> 31)),
          (_e = (P[3] << 1) | (P[2] >>> 31)),
          (me = (P[13] << 12) | (P[12] >>> 20)),
          (re = (P[12] << 12) | (P[13] >>> 20)),
          (vt = (P[22] << 10) | (P[23] >>> 22)),
          (Ie = (P[23] << 10) | (P[22] >>> 22)),
          (de = (P[33] << 13) | (P[32] >>> 19)),
          (ie = (P[32] << 13) | (P[33] >>> 19)),
          (Kt = (P[42] << 2) | (P[43] >>> 30)),
          (jt = (P[43] << 2) | (P[42] >>> 30)),
          (wt = (P[5] << 30) | (P[4] >>> 2)),
          (Be = (P[4] << 30) | (P[5] >>> 2)),
          (et = (P[14] << 6) | (P[15] >>> 26)),
          (Me = (P[15] << 6) | (P[14] >>> 26)),
          (ge = (P[25] << 11) | (P[24] >>> 21)),
          (ce = (P[24] << 11) | (P[25] >>> 21)),
          (De = (P[34] << 15) | (P[35] >>> 17)),
          (mt = (P[35] << 15) | (P[34] >>> 17)),
          (ye = (P[45] << 29) | (P[44] >>> 3)),
          (Ye = (P[44] << 29) | (P[45] >>> 3)),
          (W = (P[6] << 28) | (P[7] >>> 4)),
          (T = (P[7] << 28) | (P[6] >>> 4)),
          (ze = (P[17] << 23) | (P[16] >>> 9)),
          (st = (P[16] << 23) | (P[17] >>> 9)),
          (Ce = (P[26] << 25) | (P[27] >>> 7)),
          (yt = (P[27] << 25) | (P[26] >>> 7)),
          (he = (P[36] << 21) | (P[37] >>> 11)),
          (Ke = (P[37] << 21) | (P[36] >>> 11)),
          (xe = (P[47] << 24) | (P[46] >>> 8)),
          (Ue = (P[46] << 24) | (P[47] >>> 8)),
          (Ne = (P[8] << 27) | (P[9] >>> 5)),
          (bt = (P[9] << 27) | (P[8] >>> 5)),
          (x = (P[18] << 20) | (P[19] >>> 12)),
          (N = (P[19] << 20) | (P[18] >>> 12)),
          (at = (P[29] << 7) | (P[28] >>> 25)),
          (Ft = (P[28] << 7) | (P[29] >>> 25)),
          (Ae = (P[38] << 8) | (P[39] >>> 24)),
          (Le = (P[39] << 8) | (P[38] >>> 24)),
          (K = (P[48] << 14) | (P[49] >>> 18)),
          (O = (P[49] << 14) | (P[48] >>> 18)),
          (P[0] = oe ^ (~me & ge)),
          (P[1] = rt ^ (~re & ce)),
          (P[10] = W ^ (~x & j)),
          (P[11] = T ^ (~N & J)),
          (P[20] = ve ^ (~et & Ce)),
          (P[21] = _e ^ (~Me & yt)),
          (P[30] = Ne ^ (~ke & vt)),
          (P[31] = bt ^ (~$e & Ie)),
          (P[40] = wt ^ (~ze & at)),
          (P[41] = Be ^ (~st & Ft)),
          (P[2] = me ^ (~ge & he)),
          (P[3] = re ^ (~ce & Ke)),
          (P[12] = x ^ (~j & de)),
          (P[13] = N ^ (~J & ie)),
          (P[22] = et ^ (~Ce & Ae)),
          (P[23] = Me ^ (~yt & Le)),
          (P[32] = ke ^ (~vt & De)),
          (P[33] = $e ^ (~Ie & mt)),
          (P[42] = ze ^ (~at & qt)),
          (P[43] = st ^ (~Ft & Wt)),
          (P[4] = ge ^ (~he & K)),
          (P[5] = ce ^ (~Ke & O)),
          (P[14] = j ^ (~de & ye)),
          (P[15] = J ^ (~ie & Ye)),
          (P[24] = Ce ^ (~Ae & gt)),
          (P[25] = yt ^ (~Le & Ee)),
          (P[34] = vt ^ (~De & xe)),
          (P[35] = Ie ^ (~mt & Ue)),
          (P[44] = at ^ (~qt & Kt)),
          (P[45] = Ft ^ (~Wt & jt)),
          (P[6] = he ^ (~K & oe)),
          (P[7] = Ke ^ (~O & rt)),
          (P[16] = de ^ (~ye & W)),
          (P[17] = ie ^ (~Ye & T)),
          (P[26] = Ae ^ (~gt & ve)),
          (P[27] = Le ^ (~Ee & _e)),
          (P[36] = De ^ (~xe & Ne)),
          (P[37] = mt ^ (~Ue & bt)),
          (P[46] = qt ^ (~Kt & wt)),
          (P[47] = Wt ^ (~jt & Be)),
          (P[8] = K ^ (~oe & me)),
          (P[9] = O ^ (~rt & re)),
          (P[18] = ye ^ (~W & x)),
          (P[19] = Ye ^ (~T & N)),
          (P[28] = gt ^ (~ve & et)),
          (P[29] = Ee ^ (~_e & Me)),
          (P[38] = xe ^ (~Ne & ke)),
          (P[39] = Ue ^ (~bt & $e)),
          (P[48] = Kt ^ (~wt & ze)),
          (P[49] = jt ^ (~Be & st)),
          (P[0] ^= I[Y]),
          (P[1] ^= I[Y + 1]);
    };
    if (f) i.exports = l;
    else for (g = 0; g < d.length; ++g) s[d[g]] = l[d[g]];
  })();
})(n3);
var o3 = n3.exports;
const OU = zn(o3);
var Re = {};
/**
 * Support for translating between Uint8Array instances and JavaScript
 * native types.
 *
 * {@link module:Layout~Layout|Layout} is the basis of a class
 * hierarchy that associates property names with sequences of encoded
 * bytes.
 *
 * Layouts are supported for these scalar (numeric) types:
 * * {@link module:Layout~UInt|Unsigned integers in little-endian
 *   format} with {@link module:Layout.u8|8-bit}, {@link
 *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},
 *   {@link module:Layout.u32|32-bit}, {@link
 *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}
 *   representation ranges;
 * * {@link module:Layout~UIntBE|Unsigned integers in big-endian
 *   format} with {@link module:Layout.u16be|16-bit}, {@link
 *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},
 *   {@link module:Layout.u40be|40-bit}, and {@link
 *   module:Layout.u48be|48-bit} representation ranges;
 * * {@link module:Layout~Int|Signed integers in little-endian
 *   format} with {@link module:Layout.s8|8-bit}, {@link
 *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},
 *   {@link module:Layout.s32|32-bit}, {@link
 *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}
 *   representation ranges;
 * * {@link module:Layout~IntBE|Signed integers in big-endian format}
 *   with {@link module:Layout.s16be|16-bit}, {@link
 *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},
 *   {@link module:Layout.s40be|40-bit}, and {@link
 *   module:Layout.s48be|48-bit} representation ranges;
 * * 64-bit integral values that decode to an exact (if magnitude is
 *   less than 2^53) or nearby integral Number in {@link
 *   module:Layout.nu64|unsigned little-endian}, {@link
 *   module:Layout.nu64be|unsigned big-endian}, {@link
 *   module:Layout.ns64|signed little-endian}, and {@link
 *   module:Layout.ns64be|unsigned big-endian} encodings;
 * * 32-bit floating point values with {@link
 *   module:Layout.f32|little-endian} and {@link
 *   module:Layout.f32be|big-endian} representations;
 * * 64-bit floating point values with {@link
 *   module:Layout.f64|little-endian} and {@link
 *   module:Layout.f64be|big-endian} representations;
 * * {@link module:Layout.const|Constants} that take no space in the
 *   encoded expression.
 *
 * and for these aggregate types:
 * * {@link module:Layout.seq|Sequence}s of instances of a {@link
 *   module:Layout~Layout|Layout}, with JavaScript representation as
 *   an Array and constant or data-dependent {@link
 *   module:Layout~Sequence#count|length};
 * * {@link module:Layout.struct|Structure}s that aggregate a
 *   heterogeneous sequence of {@link module:Layout~Layout|Layout}
 *   instances, with JavaScript representation as an Object;
 * * {@link module:Layout.union|Union}s that support multiple {@link
 *   module:Layout~VariantLayout|variant layouts} over a fixed
 *   (padded) or variable (not padded) span of bytes, using an
 *   unsigned integer at the start of the data or a separate {@link
 *   module:Layout.unionLayoutDiscriminator|layout element} to
 *   determine which layout to use when interpreting the buffer
 *   contents;
 * * {@link module:Layout.bits|BitStructure}s that contain a sequence
 *   of individual {@link
 *   module:Layout~BitStructure#addField|BitField}s packed into an 8,
 *   16, 24, or 32-bit unsigned integer starting at the least- or
 *   most-significant bit;
 * * {@link module:Layout.cstr|C strings} of varying length;
 * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link
 *   module:Layout~Blob#length|length} raw data.
 *
 * All {@link module:Layout~Layout|Layout} instances are immutable
 * after construction, to prevent internal state from becoming
 * inconsistent.
 *
 * @local Layout
 * @local ExternalLayout
 * @local GreedyCount
 * @local OffsetLayout
 * @local UInt
 * @local UIntBE
 * @local Int
 * @local IntBE
 * @local NearUInt64
 * @local NearUInt64BE
 * @local NearInt64
 * @local NearInt64BE
 * @local Float
 * @local FloatBE
 * @local Double
 * @local DoubleBE
 * @local Sequence
 * @local Structure
 * @local UnionDiscriminator
 * @local UnionLayoutDiscriminator
 * @local Union
 * @local VariantLayout
 * @local BitStructure
 * @local BitField
 * @local Boolean
 * @local Blob
 * @local CString
 * @local Constant
 * @local bindConstructorLayout
 * @module Layout
 * @license MIT
 * @author Peter A. Bigot
 * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}
 */ Object.defineProperty(Re, '__esModule', { value: !0 });
Re.s16 =
  Re.s8 =
  Re.nu64be =
  Re.u48be =
  Re.u40be =
  Re.u32be =
  Re.u24be =
  Re.u16be =
  Nt =
  Re.nu64 =
  Re.u48 =
  Re.u40 =
  qe =
  Re.u32 =
  Re.u24 =
  Tr =
  Re.u16 =
  tt =
  Re.u8 =
  _i =
  Re.offset =
  Re.greedy =
  Re.Constant =
  Re.UTF8 =
  Re.CString =
  Re.Blob =
  Re.Boolean =
  Re.BitField =
  Re.BitStructure =
  Re.VariantLayout =
  Re.Union =
  Re.UnionLayoutDiscriminator =
  Re.UnionDiscriminator =
  Re.Structure =
  Re.Sequence =
  Re.DoubleBE =
  Re.Double =
  Re.FloatBE =
  Re.Float =
  Re.NearInt64BE =
  Re.NearInt64 =
  Re.NearUInt64BE =
  Re.NearUInt64 =
  Re.IntBE =
  Re.Int =
  Re.UIntBE =
  Re.UInt =
  Re.OffsetLayout =
  Re.GreedyCount =
  Re.ExternalLayout =
  Re.bindConstructorLayout =
  Re.nameWithProperty =
  Re.Layout =
  Re.uint8ArrayToBuffer =
  Re.checkUint8Array =
    void 0;
Re.constant =
  Re.utf8 =
  Re.cstr =
  ut =
  Re.blob =
  Re.unionLayoutDiscriminator =
  Re.union =
  zt =
  Re.seq =
  Re.bits =
  We =
  Re.struct =
  Re.f64be =
  Re.f64 =
  Re.f32be =
  Re.f32 =
  Re.ns64be =
  Re.s48be =
  Re.s40be =
  Re.s32be =
  Re.s24be =
  Re.s16be =
  Ir =
  Re.ns64 =
  Re.s48 =
  Re.s40 =
  Re.s32 =
  Re.s24 =
    void 0;
const ky = ai;
function Ga(i) {
  if (!(i instanceof Uint8Array)) throw new TypeError('b must be a Uint8Array');
}
Re.checkUint8Array = Ga;
function Zt(i) {
  return Ga(i), ky.Buffer.from(i.buffer, i.byteOffset, i.length);
}
Re.uint8ArrayToBuffer = Zt;
let nr = class {
  constructor(e, t) {
    if (!Number.isInteger(e)) throw new TypeError('span must be an integer');
    (this.span = e), (this.property = t);
  }
  makeDestinationObject() {
    return {};
  }
  getSpan(e, t) {
    if (0 > this.span) throw new RangeError('indeterminate span');
    return this.span;
  }
  replicate(e) {
    const t = Object.create(this.constructor.prototype);
    return Object.assign(t, this), (t.property = e), t;
  }
  fromArray(e) {}
};
Re.Layout = nr;
function Iy(i, e) {
  return e.property ? i + '[' + e.property + ']' : i;
}
Re.nameWithProperty = Iy;
function IB(i, e) {
  if (typeof i != 'function') throw new TypeError('Class must be constructor');
  if (Object.prototype.hasOwnProperty.call(i, 'layout_'))
    throw new Error('Class is already bound to a layout');
  if (!(e && e instanceof nr)) throw new TypeError('layout must be a Layout');
  if (Object.prototype.hasOwnProperty.call(e, 'boundConstructor_'))
    throw new Error('layout is already bound to a constructor');
  (i.layout_ = e),
    (e.boundConstructor_ = i),
    (e.makeDestinationObject = () => new i()),
    Object.defineProperty(i.prototype, 'encode', {
      value(t, r) {
        return e.encode(this, t, r);
      },
      writable: !0,
    }),
    Object.defineProperty(i, 'decode', {
      value(t, r) {
        return e.decode(t, r);
      },
      writable: !0,
    });
}
Re.bindConstructorLayout = IB;
let Ei = class extends nr {
  isCount() {
    throw new Error('ExternalLayout is abstract');
  }
};
Re.ExternalLayout = Ei;
class s3 extends Ei {
  constructor(e = 1, t) {
    if (!Number.isInteger(e) || 0 >= e)
      throw new TypeError('elementSpan must be a (positive) integer');
    super(-1, t), (this.elementSpan = e);
  }
  isCount() {
    return !0;
  }
  decode(e, t = 0) {
    Ga(e);
    const r = e.length - t;
    return Math.floor(r / this.elementSpan);
  }
  encode(e, t, r) {
    return 0;
  }
}
Re.GreedyCount = s3;
class xy extends Ei {
  constructor(e, t = 0, r) {
    if (!(e instanceof nr)) throw new TypeError('layout must be a Layout');
    if (!Number.isInteger(t)) throw new TypeError('offset must be integer or undefined');
    super(e.span, r || e.property), (this.layout = e), (this.offset = t);
  }
  isCount() {
    return this.layout instanceof Zi || this.layout instanceof cn;
  }
  decode(e, t = 0) {
    return this.layout.decode(e, t + this.offset);
  }
  encode(e, t, r = 0) {
    return this.layout.encode(e, t, r + this.offset);
  }
}
Re.OffsetLayout = xy;
let Zi = class extends nr {
  constructor(e, t) {
    if ((super(e, t), 6 < this.span)) throw new RangeError('span must not exceed 6 bytes');
  }
  decode(e, t = 0) {
    return Zt(e).readUIntLE(t, this.span);
  }
  encode(e, t, r = 0) {
    return Zt(t).writeUIntLE(e, r, this.span), this.span;
  }
};
Re.UInt = Zi;
class cn extends nr {
  constructor(e, t) {
    if ((super(e, t), 6 < this.span)) throw new RangeError('span must not exceed 6 bytes');
  }
  decode(e, t = 0) {
    return Zt(e).readUIntBE(t, this.span);
  }
  encode(e, t, r = 0) {
    return Zt(t).writeUIntBE(e, r, this.span), this.span;
  }
}
Re.UIntBE = cn;
class Bs extends nr {
  constructor(e, t) {
    if ((super(e, t), 6 < this.span)) throw new RangeError('span must not exceed 6 bytes');
  }
  decode(e, t = 0) {
    return Zt(e).readIntLE(t, this.span);
  }
  encode(e, t, r = 0) {
    return Zt(t).writeIntLE(e, r, this.span), this.span;
  }
}
Re.Int = Bs;
class Ya extends nr {
  constructor(e, t) {
    if ((super(e, t), 6 < this.span)) throw new RangeError('span must not exceed 6 bytes');
  }
  decode(e, t = 0) {
    return Zt(e).readIntBE(t, this.span);
  }
  encode(e, t, r = 0) {
    return Zt(t).writeIntBE(e, r, this.span), this.span;
  }
}
Re.IntBE = Ya;
const r1 = Math.pow(2, 32);
function Ul(i) {
  const e = Math.floor(i / r1),
    t = i - e * r1;
  return { hi32: e, lo32: t };
}
function zl(i, e) {
  return i * r1 + e;
}
class a3 extends nr {
  constructor(e) {
    super(8, e);
  }
  decode(e, t = 0) {
    const r = Zt(e),
      s = r.readUInt32LE(t),
      n = r.readUInt32LE(t + 4);
    return zl(n, s);
  }
  encode(e, t, r = 0) {
    const s = Ul(e),
      n = Zt(t);
    return n.writeUInt32LE(s.lo32, r), n.writeUInt32LE(s.hi32, r + 4), 8;
  }
}
Re.NearUInt64 = a3;
class u3 extends nr {
  constructor(e) {
    super(8, e);
  }
  decode(e, t = 0) {
    const r = Zt(e),
      s = r.readUInt32BE(t),
      n = r.readUInt32BE(t + 4);
    return zl(s, n);
  }
  encode(e, t, r = 0) {
    const s = Ul(e),
      n = Zt(t);
    return n.writeUInt32BE(s.hi32, r), n.writeUInt32BE(s.lo32, r + 4), 8;
  }
}
Re.NearUInt64BE = u3;
class c3 extends nr {
  constructor(e) {
    super(8, e);
  }
  decode(e, t = 0) {
    const r = Zt(e),
      s = r.readUInt32LE(t),
      n = r.readInt32LE(t + 4);
    return zl(n, s);
  }
  encode(e, t, r = 0) {
    const s = Ul(e),
      n = Zt(t);
    return n.writeUInt32LE(s.lo32, r), n.writeInt32LE(s.hi32, r + 4), 8;
  }
}
Re.NearInt64 = c3;
class f3 extends nr {
  constructor(e) {
    super(8, e);
  }
  decode(e, t = 0) {
    const r = Zt(e),
      s = r.readInt32BE(t),
      n = r.readUInt32BE(t + 4);
    return zl(s, n);
  }
  encode(e, t, r = 0) {
    const s = Ul(e),
      n = Zt(t);
    return n.writeInt32BE(s.hi32, r), n.writeUInt32BE(s.lo32, r + 4), 8;
  }
}
Re.NearInt64BE = f3;
class l3 extends nr {
  constructor(e) {
    super(4, e);
  }
  decode(e, t = 0) {
    return Zt(e).readFloatLE(t);
  }
  encode(e, t, r = 0) {
    return Zt(t).writeFloatLE(e, r), 4;
  }
}
Re.Float = l3;
class h3 extends nr {
  constructor(e) {
    super(4, e);
  }
  decode(e, t = 0) {
    return Zt(e).readFloatBE(t);
  }
  encode(e, t, r = 0) {
    return Zt(t).writeFloatBE(e, r), 4;
  }
}
Re.FloatBE = h3;
class d3 extends nr {
  constructor(e) {
    super(8, e);
  }
  decode(e, t = 0) {
    return Zt(e).readDoubleLE(t);
  }
  encode(e, t, r = 0) {
    return Zt(t).writeDoubleLE(e, r), 8;
  }
}
Re.Double = d3;
class p3 extends nr {
  constructor(e) {
    super(8, e);
  }
  decode(e, t = 0) {
    return Zt(e).readDoubleBE(t);
  }
  encode(e, t, r = 0) {
    return Zt(t).writeDoubleBE(e, r), 8;
  }
}
Re.DoubleBE = p3;
class y3 extends nr {
  constructor(e, t, r) {
    if (!(e instanceof nr)) throw new TypeError('elementLayout must be a Layout');
    if (!((t instanceof Ei && t.isCount()) || (Number.isInteger(t) && 0 <= t)))
      throw new TypeError(
        'count must be non-negative integer or an unsigned integer ExternalLayout'
      );
    let s = -1;
    !(t instanceof Ei) && 0 < e.span && (s = t * e.span),
      super(s, r),
      (this.elementLayout = e),
      (this.count = t);
  }
  getSpan(e, t = 0) {
    if (0 <= this.span) return this.span;
    let r = 0,
      s = this.count;
    if ((s instanceof Ei && (s = s.decode(e, t)), 0 < this.elementLayout.span))
      r = s * this.elementLayout.span;
    else {
      let n = 0;
      for (; n < s; ) (r += this.elementLayout.getSpan(e, t + r)), ++n;
    }
    return r;
  }
  decode(e, t = 0) {
    const r = [];
    let s = 0,
      n = this.count;
    for (n instanceof Ei && (n = n.decode(e, t)); s < n; )
      r.push(this.elementLayout.decode(e, t)), (t += this.elementLayout.getSpan(e, t)), (s += 1);
    return r;
  }
  encode(e, t, r = 0) {
    const s = this.elementLayout,
      n = e.reduce((c, f) => c + s.encode(f, t, r + c), 0);
    return this.count instanceof Ei && this.count.encode(e.length, t, r), n;
  }
}
Re.Sequence = y3;
let g3 = class extends nr {
  constructor(e, t, r) {
    if (!(Array.isArray(e) && e.reduce((n, c) => n && c instanceof nr, !0)))
      throw new TypeError('fields must be array of Layout instances');
    typeof t == 'boolean' && r === void 0 && ((r = t), (t = void 0));
    for (const n of e)
      if (0 > n.span && n.property === void 0)
        throw new Error('fields cannot contain unnamed variable-length layout');
    let s = -1;
    try {
      s = e.reduce((n, c) => n + c.getSpan(), 0);
    } catch {}
    super(s, t), (this.fields = e), (this.decodePrefixes = !!r);
  }
  getSpan(e, t = 0) {
    if (0 <= this.span) return this.span;
    let r = 0;
    try {
      r = this.fields.reduce((s, n) => {
        const c = n.getSpan(e, t);
        return (t += c), s + c;
      }, 0);
    } catch {
      throw new RangeError('indeterminate span');
    }
    return r;
  }
  decode(e, t = 0) {
    Ga(e);
    const r = this.makeDestinationObject();
    for (const s of this.fields)
      if (
        (s.property !== void 0 && (r[s.property] = s.decode(e, t)),
        (t += s.getSpan(e, t)),
        this.decodePrefixes && e.length === t)
      )
        break;
    return r;
  }
  encode(e, t, r = 0) {
    const s = r;
    let n = 0,
      c = 0;
    for (const f of this.fields) {
      let h = f.span;
      if (((c = 0 < h ? h : 0), f.property !== void 0)) {
        const y = e[f.property];
        y !== void 0 && ((c = f.encode(y, t, r)), 0 > h && (h = f.getSpan(t, r)));
      }
      (n = r), (r += h);
    }
    return n + c - s;
  }
  fromArray(e) {
    const t = this.makeDestinationObject();
    for (const r of this.fields)
      r.property !== void 0 && 0 < e.length && (t[r.property] = e.shift());
    return t;
  }
  layoutFor(e) {
    if (typeof e != 'string') throw new TypeError('property must be string');
    for (const t of this.fields) if (t.property === e) return t;
  }
  offsetOf(e) {
    if (typeof e != 'string') throw new TypeError('property must be string');
    let t = 0;
    for (const r of this.fields) {
      if (r.property === e) return t;
      0 > r.span ? (t = -1) : 0 <= t && (t += r.span);
    }
  }
};
Re.Structure = g3;
class By {
  constructor(e) {
    this.property = e;
  }
  decode(e, t) {
    throw new Error('UnionDiscriminator is abstract');
  }
  encode(e, t, r) {
    throw new Error('UnionDiscriminator is abstract');
  }
}
Re.UnionDiscriminator = By;
class Qf extends By {
  constructor(e, t) {
    if (!(e instanceof Ei && e.isCount()))
      throw new TypeError('layout must be an unsigned integer ExternalLayout');
    super(t || e.property || 'variant'), (this.layout = e);
  }
  decode(e, t) {
    return this.layout.decode(e, t);
  }
  encode(e, t, r) {
    return this.layout.encode(e, t, r);
  }
}
Re.UnionLayoutDiscriminator = Qf;
class Ry extends nr {
  constructor(e, t, r) {
    let s;
    if (e instanceof Zi || e instanceof cn) s = new Qf(new xy(e));
    else if (e instanceof Ei && e.isCount()) s = new Qf(e);
    else if (e instanceof By) s = e;
    else throw new TypeError('discr must be a UnionDiscriminator or an unsigned integer layout');
    if ((t === void 0 && (t = null), !(t === null || t instanceof nr)))
      throw new TypeError('defaultLayout must be null or a Layout');
    if (t !== null) {
      if (0 > t.span) throw new Error('defaultLayout must have constant span');
      t.property === void 0 && (t = t.replicate('content'));
    }
    let n = -1;
    t && ((n = t.span), 0 <= n && (e instanceof Zi || e instanceof cn) && (n += s.layout.span)),
      super(n, r),
      (this.discriminator = s),
      (this.usesPrefixDiscriminator = e instanceof Zi || e instanceof cn),
      (this.defaultLayout = t),
      (this.registry = {});
    let c = this.defaultGetSourceVariant.bind(this);
    (this.getSourceVariant = function (f) {
      return c(f);
    }),
      (this.configGetSourceVariant = function (f) {
        c = f.bind(this);
      });
  }
  getSpan(e, t = 0) {
    if (0 <= this.span) return this.span;
    const r = this.getVariant(e, t);
    if (!r) throw new Error('unable to determine span for unrecognized variant');
    return r.getSpan(e, t);
  }
  defaultGetSourceVariant(e) {
    if (Object.prototype.hasOwnProperty.call(e, this.discriminator.property)) {
      if (
        this.defaultLayout &&
        this.defaultLayout.property &&
        Object.prototype.hasOwnProperty.call(e, this.defaultLayout.property)
      )
        return;
      const t = this.registry[e[this.discriminator.property]];
      if (t && (!t.layout || (t.property && Object.prototype.hasOwnProperty.call(e, t.property))))
        return t;
    } else
      for (const t in this.registry) {
        const r = this.registry[t];
        if (r.property && Object.prototype.hasOwnProperty.call(e, r.property)) return r;
      }
    throw new Error('unable to infer src variant');
  }
  decode(e, t = 0) {
    let r;
    const s = this.discriminator,
      n = s.decode(e, t),
      c = this.registry[n];
    if (c === void 0) {
      const f = this.defaultLayout;
      let h = 0;
      this.usesPrefixDiscriminator && (h = s.layout.span),
        (r = this.makeDestinationObject()),
        (r[s.property] = n),
        (r[f.property] = f.decode(e, t + h));
    } else r = c.decode(e, t);
    return r;
  }
  encode(e, t, r = 0) {
    const s = this.getSourceVariant(e);
    if (s === void 0) {
      const n = this.discriminator,
        c = this.defaultLayout;
      let f = 0;
      return (
        this.usesPrefixDiscriminator && (f = n.layout.span),
        n.encode(e[n.property], t, r),
        f + c.encode(e[c.property], t, r + f)
      );
    }
    return s.encode(e, t, r);
  }
  addVariant(e, t, r) {
    const s = new b3(this, e, t, r);
    return (this.registry[e] = s), s;
  }
  getVariant(e, t = 0) {
    let r;
    return (
      e instanceof Uint8Array ? (r = this.discriminator.decode(e, t)) : (r = e), this.registry[r]
    );
  }
}
Re.Union = Ry;
class b3 extends nr {
  constructor(e, t, r, s) {
    if (!(e instanceof Ry)) throw new TypeError('union must be a Union');
    if (!Number.isInteger(t) || 0 > t)
      throw new TypeError('variant must be a (non-negative) integer');
    if ((typeof r == 'string' && s === void 0 && ((s = r), (r = null)), r)) {
      if (!(r instanceof nr)) throw new TypeError('layout must be a Layout');
      if (e.defaultLayout !== null && 0 <= r.span && r.span > e.defaultLayout.span)
        throw new Error('variant span exceeds span of containing union');
      if (typeof s != 'string') throw new TypeError('variant must have a String property');
    }
    let n = e.span;
    0 > e.span &&
      ((n = r ? r.span : 0),
      0 <= n && e.usesPrefixDiscriminator && (n += e.discriminator.layout.span)),
      super(n, s),
      (this.union = e),
      (this.variant = t),
      (this.layout = r || null);
  }
  getSpan(e, t = 0) {
    if (0 <= this.span) return this.span;
    let r = 0;
    this.union.usesPrefixDiscriminator && (r = this.union.discriminator.layout.span);
    let s = 0;
    return this.layout && (s = this.layout.getSpan(e, t + r)), r + s;
  }
  decode(e, t = 0) {
    const r = this.makeDestinationObject();
    if (this !== this.union.getVariant(e, t)) throw new Error('variant mismatch');
    let s = 0;
    return (
      this.union.usesPrefixDiscriminator && (s = this.union.discriminator.layout.span),
      this.layout
        ? (r[this.property] = this.layout.decode(e, t + s))
        : this.property
          ? (r[this.property] = !0)
          : this.union.usesPrefixDiscriminator &&
            (r[this.union.discriminator.property] = this.variant),
      r
    );
  }
  encode(e, t, r = 0) {
    let s = 0;
    if (
      (this.union.usesPrefixDiscriminator && (s = this.union.discriminator.layout.span),
      this.layout && !Object.prototype.hasOwnProperty.call(e, this.property))
    )
      throw new TypeError('variant lacks property ' + this.property);
    this.union.discriminator.encode(this.variant, t, r);
    let n = s;
    if (
      this.layout &&
      (this.layout.encode(e[this.property], t, r + s),
      (n += this.layout.getSpan(t, r + s)),
      0 <= this.union.span && n > this.union.span)
    )
      throw new Error('encoded variant overruns containing union');
    return n;
  }
  fromArray(e) {
    if (this.layout) return this.layout.fromArray(e);
  }
}
Re.VariantLayout = b3;
function Xs(i) {
  return 0 > i && (i += 4294967296), i;
}
class Py extends nr {
  constructor(e, t, r) {
    if (!(e instanceof Zi || e instanceof cn))
      throw new TypeError('word must be a UInt or UIntBE layout');
    if ((typeof t == 'string' && r === void 0 && ((r = t), (t = !1)), 4 < e.span))
      throw new RangeError('word cannot exceed 32 bits');
    super(e.span, r), (this.word = e), (this.msb = !!t), (this.fields = []);
    let s = 0;
    (this._packedSetValue = function (n) {
      return (s = Xs(n)), this;
    }),
      (this._packedGetValue = function () {
        return s;
      });
  }
  decode(e, t = 0) {
    const r = this.makeDestinationObject(),
      s = this.word.decode(e, t);
    this._packedSetValue(s);
    for (const n of this.fields) n.property !== void 0 && (r[n.property] = n.decode(e));
    return r;
  }
  encode(e, t, r = 0) {
    const s = this.word.decode(t, r);
    this._packedSetValue(s);
    for (const n of this.fields)
      if (n.property !== void 0) {
        const c = e[n.property];
        c !== void 0 && n.encode(c);
      }
    return this.word.encode(this._packedGetValue(), t, r);
  }
  addField(e, t) {
    const r = new Ty(this, e, t);
    return this.fields.push(r), r;
  }
  addBoolean(e) {
    const t = new v3(this, e);
    return this.fields.push(t), t;
  }
  fieldFor(e) {
    if (typeof e != 'string') throw new TypeError('property must be string');
    for (const t of this.fields) if (t.property === e) return t;
  }
}
Re.BitStructure = Py;
class Ty {
  constructor(e, t, r) {
    if (!(e instanceof Py)) throw new TypeError('container must be a BitStructure');
    if (!Number.isInteger(t) || 0 >= t) throw new TypeError('bits must be positive integer');
    const s = 8 * e.span,
      n = e.fields.reduce((c, f) => c + f.bits, 0);
    if (t + n > s)
      throw new Error('bits too long for span remainder (' + (s - n) + ' of ' + s + ' remain)');
    (this.container = e),
      (this.bits = t),
      (this.valueMask = (1 << t) - 1),
      t === 32 && (this.valueMask = 4294967295),
      (this.start = n),
      this.container.msb && (this.start = s - n - t),
      (this.wordMask = Xs(this.valueMask << this.start)),
      (this.property = r);
  }
  decode(e, t) {
    const r = this.container._packedGetValue();
    return Xs(r & this.wordMask) >>> this.start;
  }
  encode(e) {
    if (typeof e != 'number' || !Number.isInteger(e) || e !== Xs(e & this.valueMask))
      throw new TypeError(
        Iy('BitField.encode', this) + ' value must be integer not exceeding ' + this.valueMask
      );
    const t = this.container._packedGetValue(),
      r = Xs(e << this.start);
    this.container._packedSetValue(Xs(t & ~this.wordMask) | r);
  }
}
Re.BitField = Ty;
let v3 = class extends Ty {
  constructor(e, t) {
    super(e, 1, t);
  }
  decode(e, t) {
    return !!super.decode(e, t);
  }
  encode(e) {
    typeof e == 'boolean' && (e = +e), super.encode(e);
  }
};
Re.Boolean = v3;
let m3 = class extends nr {
  constructor(e, t) {
    if (!((e instanceof Ei && e.isCount()) || (Number.isInteger(e) && 0 <= e)))
      throw new TypeError('length must be positive integer or an unsigned integer ExternalLayout');
    let r = -1;
    e instanceof Ei || (r = e), super(r, t), (this.length = e);
  }
  getSpan(e, t) {
    let r = this.span;
    return 0 > r && (r = this.length.decode(e, t)), r;
  }
  decode(e, t = 0) {
    let r = this.span;
    return 0 > r && (r = this.length.decode(e, t)), Zt(e).slice(t, t + r);
  }
  encode(e, t, r) {
    let s = this.length;
    if ((this.length instanceof Ei && (s = e.length), !(e instanceof Uint8Array && s === e.length)))
      throw new TypeError(
        Iy('Blob.encode', this) + ' requires (length ' + s + ') Uint8Array as src'
      );
    if (r + s > t.length) throw new RangeError('encoding overruns Uint8Array');
    const n = Zt(e);
    return (
      Zt(t).write(n.toString('hex'), r, s, 'hex'),
      this.length instanceof Ei && this.length.encode(s, t, r),
      s
    );
  }
};
Re.Blob = m3;
class w3 extends nr {
  constructor(e) {
    super(-1, e);
  }
  getSpan(e, t = 0) {
    Ga(e);
    let r = t;
    for (; r < e.length && e[r] !== 0; ) r += 1;
    return 1 + r - t;
  }
  decode(e, t = 0) {
    const r = this.getSpan(e, t);
    return Zt(e)
      .slice(t, t + r - 1)
      .toString('utf-8');
  }
  encode(e, t, r = 0) {
    typeof e != 'string' && (e = String(e));
    const s = ky.Buffer.from(e, 'utf8'),
      n = s.length;
    if (r + n > t.length) throw new RangeError('encoding overruns Buffer');
    const c = Zt(t);
    return s.copy(c, r), (c[r + n] = 0), n + 1;
  }
}
Re.CString = w3;
class _3 extends nr {
  constructor(e, t) {
    if ((typeof e == 'string' && t === void 0 && ((t = e), (e = void 0)), e === void 0)) e = -1;
    else if (!Number.isInteger(e)) throw new TypeError('maxSpan must be an integer');
    super(-1, t), (this.maxSpan = e);
  }
  getSpan(e, t = 0) {
    return Ga(e), e.length - t;
  }
  decode(e, t = 0) {
    const r = this.getSpan(e, t);
    if (0 <= this.maxSpan && this.maxSpan < r) throw new RangeError('text length exceeds maxSpan');
    return Zt(e)
      .slice(t, t + r)
      .toString('utf-8');
  }
  encode(e, t, r = 0) {
    typeof e != 'string' && (e = String(e));
    const s = ky.Buffer.from(e, 'utf8'),
      n = s.length;
    if (0 <= this.maxSpan && this.maxSpan < n) throw new RangeError('text length exceeds maxSpan');
    if (r + n > t.length) throw new RangeError('encoding overruns Buffer');
    return s.copy(Zt(t), r), n;
  }
}
Re.UTF8 = _3;
class S3 extends nr {
  constructor(e, t) {
    super(0, t), (this.value = e);
  }
  decode(e, t) {
    return this.value;
  }
  encode(e, t, r) {
    return 0;
  }
}
Re.Constant = S3;
Re.greedy = (i, e) => new s3(i, e);
var _i = (Re.offset = (i, e, t) => new xy(i, e, t)),
  tt = (Re.u8 = (i) => new Zi(1, i)),
  Tr = (Re.u16 = (i) => new Zi(2, i));
Re.u24 = (i) => new Zi(3, i);
var qe = (Re.u32 = (i) => new Zi(4, i));
Re.u40 = (i) => new Zi(5, i);
Re.u48 = (i) => new Zi(6, i);
var Nt = (Re.nu64 = (i) => new a3(i));
Re.u16be = (i) => new cn(2, i);
Re.u24be = (i) => new cn(3, i);
Re.u32be = (i) => new cn(4, i);
Re.u40be = (i) => new cn(5, i);
Re.u48be = (i) => new cn(6, i);
Re.nu64be = (i) => new u3(i);
Re.s8 = (i) => new Bs(1, i);
Re.s16 = (i) => new Bs(2, i);
Re.s24 = (i) => new Bs(3, i);
Re.s32 = (i) => new Bs(4, i);
Re.s40 = (i) => new Bs(5, i);
Re.s48 = (i) => new Bs(6, i);
var Ir = (Re.ns64 = (i) => new c3(i));
Re.s16be = (i) => new Ya(2, i);
Re.s24be = (i) => new Ya(3, i);
Re.s32be = (i) => new Ya(4, i);
Re.s40be = (i) => new Ya(5, i);
Re.s48be = (i) => new Ya(6, i);
Re.ns64be = (i) => new f3(i);
Re.f32 = (i) => new l3(i);
Re.f32be = (i) => new h3(i);
Re.f64 = (i) => new d3(i);
Re.f64be = (i) => new p3(i);
var We = (Re.struct = (i, e, t) => new g3(i, e, t));
Re.bits = (i, e, t) => new Py(i, e, t);
var zt = (Re.seq = (i, e, t) => new y3(i, e, t));
Re.union = (i, e, t) => new Ry(i, e, t);
Re.unionLayoutDiscriminator = (i, e) => new Qf(i, e);
var ut = (Re.blob = (i, e) => new m3(i, e));
Re.cstr = (i) => new w3(i);
Re.utf8 = (i, e) => new _3(i, e);
Re.constant = (i, e) => new S3(i, e);
var rf = At.Buffer;
function xB(i) {
  if (i.length >= 255) throw new TypeError('Alphabet too long');
  for (var e = new Uint8Array(256), t = 0; t < e.length; t++) e[t] = 255;
  for (var r = 0; r < i.length; r++) {
    var s = i.charAt(r),
      n = s.charCodeAt(0);
    if (e[n] !== 255) throw new TypeError(s + ' is ambiguous');
    e[n] = r;
  }
  var c = i.length,
    f = i.charAt(0),
    h = Math.log(c) / Math.log(256),
    y = Math.log(256) / Math.log(c);
  function p(A) {
    if (((Array.isArray(A) || A instanceof Uint8Array) && (A = rf.from(A)), !rf.isBuffer(A)))
      throw new TypeError('Expected Buffer');
    if (A.length === 0) return '';
    for (var E = 0, I = 0, R = 0, L = A.length; R !== L && A[R] === 0; ) R++, E++;
    for (var D = ((L - R) * y + 1) >>> 0, q = new Uint8Array(D); R !== L; ) {
      for (var H = A[R], V = 0, te = D - 1; (H !== 0 || V < I) && te !== -1; te--, V++)
        (H += (256 * q[te]) >>> 0), (q[te] = H % c >>> 0), (H = (H / c) >>> 0);
      if (H !== 0) throw new Error('Non-zero carry');
      (I = V), R++;
    }
    for (var ue = D - I; ue !== D && q[ue] === 0; ) ue++;
    for (var ne = f.repeat(E); ue < D; ++ue) ne += i.charAt(q[ue]);
    return ne;
  }
  function m(A) {
    if (typeof A != 'string') throw new TypeError('Expected String');
    if (A.length === 0) return rf.alloc(0);
    for (var E = 0, I = 0, R = 0; A[E] === f; ) I++, E++;
    for (var L = ((A.length - E) * h + 1) >>> 0, D = new Uint8Array(L); A[E]; ) {
      var q = e[A.charCodeAt(E)];
      if (q === 255) return;
      for (var H = 0, V = L - 1; (q !== 0 || H < R) && V !== -1; V--, H++)
        (q += (c * D[V]) >>> 0), (D[V] = q % 256 >>> 0), (q = (q / 256) >>> 0);
      if (q !== 0) throw new Error('Non-zero carry');
      (R = H), E++;
    }
    for (var te = L - R; te !== L && D[te] === 0; ) te++;
    var ue = rf.allocUnsafe(I + (L - te));
    ue.fill(0, 0, I);
    for (var ne = I; te !== L; ) ue[ne++] = D[te++];
    return ue;
  }
  function _(A) {
    var E = m(A);
    if (E) return E;
    throw new Error('Non-base' + c + ' character');
  }
  return { encode: p, decodeUnsafe: m, decode: _ };
}
var Oy = xB,
  BB = Oy,
  RB = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz',
  M3 = BB(RB);
const ri = zn(M3);
function Zn(i, e, t) {
  return e <= i && i <= t;
}
function Fl(i) {
  if (i === void 0) return {};
  if (i === Object(i)) return i;
  throw TypeError('Could not convert argument to dictionary');
}
function PB(i) {
  for (var e = String(i), t = e.length, r = 0, s = []; r < t; ) {
    var n = e.charCodeAt(r);
    if (n < 55296 || n > 57343) s.push(n);
    else if (56320 <= n && n <= 57343) s.push(65533);
    else if (55296 <= n && n <= 56319)
      if (r === t - 1) s.push(65533);
      else {
        var c = i.charCodeAt(r + 1);
        if (56320 <= c && c <= 57343) {
          var f = n & 1023,
            h = c & 1023;
          s.push(65536 + (f << 10) + h), (r += 1);
        } else s.push(65533);
      }
    r += 1;
  }
  return s;
}
function TB(i) {
  for (var e = '', t = 0; t < i.length; ++t) {
    var r = i[t];
    r <= 65535
      ? (e += String.fromCharCode(r))
      : ((r -= 65536), (e += String.fromCharCode((r >> 10) + 55296, (r & 1023) + 56320)));
  }
  return e;
}
var el = -1;
function Cy(i) {
  this.tokens = [].slice.call(i);
}
Cy.prototype = {
  endOfStream: function () {
    return !this.tokens.length;
  },
  read: function () {
    return this.tokens.length ? this.tokens.shift() : el;
  },
  prepend: function (i) {
    if (Array.isArray(i)) for (var e = i; e.length; ) this.tokens.unshift(e.pop());
    else this.tokens.unshift(i);
  },
  push: function (i) {
    if (Array.isArray(i)) for (var e = i; e.length; ) this.tokens.push(e.shift());
    else this.tokens.push(i);
  },
};
var Ra = -1;
function V0(i, e) {
  if (i) throw TypeError('Decoder error');
  return e || 65533;
}
var tl = 'utf-8';
function rl(i, e) {
  if (!(this instanceof rl)) return new rl(i, e);
  if (((i = i !== void 0 ? String(i).toLowerCase() : tl), i !== tl))
    throw new Error('Encoding not supported. Only utf-8 is supported');
  (e = Fl(e)),
    (this._streaming = !1),
    (this._BOMseen = !1),
    (this._decoder = null),
    (this._fatal = !!e.fatal),
    (this._ignoreBOM = !!e.ignoreBOM),
    Object.defineProperty(this, 'encoding', { value: 'utf-8' }),
    Object.defineProperty(this, 'fatal', { value: this._fatal }),
    Object.defineProperty(this, 'ignoreBOM', { value: this._ignoreBOM });
}
rl.prototype = {
  decode: function (e, t) {
    var r;
    typeof e == 'object' && e instanceof ArrayBuffer
      ? (r = new Uint8Array(e))
      : typeof e == 'object' && 'buffer' in e && e.buffer instanceof ArrayBuffer
        ? (r = new Uint8Array(e.buffer, e.byteOffset, e.byteLength))
        : (r = new Uint8Array(0)),
      (t = Fl(t)),
      this._streaming || ((this._decoder = new OB({ fatal: this._fatal })), (this._BOMseen = !1)),
      (this._streaming = !!t.stream);
    for (
      var s = new Cy(r), n = [], c;
      !s.endOfStream() && ((c = this._decoder.handler(s, s.read())), c !== Ra);

    )
      c !== null && (Array.isArray(c) ? n.push.apply(n, c) : n.push(c));
    if (!this._streaming) {
      do {
        if (((c = this._decoder.handler(s, s.read())), c === Ra)) break;
        c !== null && (Array.isArray(c) ? n.push.apply(n, c) : n.push(c));
      } while (!s.endOfStream());
      this._decoder = null;
    }
    return (
      n.length &&
        ['utf-8'].indexOf(this.encoding) !== -1 &&
        !this._ignoreBOM &&
        !this._BOMseen &&
        (n[0] === 65279 ? ((this._BOMseen = !0), n.shift()) : (this._BOMseen = !0)),
      TB(n)
    );
  },
};
function il(i, e) {
  if (!(this instanceof il)) return new il(i, e);
  if (((i = i !== void 0 ? String(i).toLowerCase() : tl), i !== tl))
    throw new Error('Encoding not supported. Only utf-8 is supported');
  (e = Fl(e)),
    (this._streaming = !1),
    (this._encoder = null),
    (this._options = { fatal: !!e.fatal }),
    Object.defineProperty(this, 'encoding', { value: 'utf-8' });
}
il.prototype = {
  encode: function (e, t) {
    (e = e ? String(e) : ''),
      (t = Fl(t)),
      this._streaming || (this._encoder = new CB(this._options)),
      (this._streaming = !!t.stream);
    for (
      var r = [], s = new Cy(PB(e)), n;
      !s.endOfStream() && ((n = this._encoder.handler(s, s.read())), n !== Ra);

    )
      Array.isArray(n) ? r.push.apply(r, n) : r.push(n);
    if (!this._streaming) {
      for (; (n = this._encoder.handler(s, s.read())), n !== Ra; )
        Array.isArray(n) ? r.push.apply(r, n) : r.push(n);
      this._encoder = null;
    }
    return new Uint8Array(r);
  },
};
function OB(i) {
  var e = i.fatal,
    t = 0,
    r = 0,
    s = 0,
    n = 128,
    c = 191;
  this.handler = function (f, h) {
    if (h === el && s !== 0) return (s = 0), V0(e);
    if (h === el) return Ra;
    if (s === 0) {
      if (Zn(h, 0, 127)) return h;
      if (Zn(h, 194, 223)) (s = 1), (t = h - 192);
      else if (Zn(h, 224, 239))
        h === 224 && (n = 160), h === 237 && (c = 159), (s = 2), (t = h - 224);
      else if (Zn(h, 240, 244))
        h === 240 && (n = 144), h === 244 && (c = 143), (s = 3), (t = h - 240);
      else return V0(e);
      return (t = t << (6 * s)), null;
    }
    if (!Zn(h, n, c)) return (t = s = r = 0), (n = 128), (c = 191), f.prepend(h), V0(e);
    if (((n = 128), (c = 191), (r += 1), (t += (h - 128) << (6 * (s - r))), r !== s)) return null;
    var y = t;
    return (t = s = r = 0), y;
  };
}
function CB(i) {
  i.fatal,
    (this.handler = function (e, t) {
      if (t === el) return Ra;
      if (Zn(t, 0, 127)) return t;
      var r, s;
      Zn(t, 128, 2047)
        ? ((r = 1), (s = 192))
        : Zn(t, 2048, 65535)
          ? ((r = 2), (s = 224))
          : Zn(t, 65536, 1114111) && ((r = 3), (s = 240));
      for (var n = [(t >> (6 * r)) + s]; r > 0; ) {
        var c = t >> (6 * (r - 1));
        n.push(128 | (c & 63)), (r -= 1);
      }
      return n;
    });
}
const LB = Object.freeze(
    Object.defineProperty(
      { __proto__: null, TextDecoder: rl, TextEncoder: il },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  A3 = pn(LB);
var sc = {};
Object.defineProperty(sc, '__esModule', { value: !0 });
function NB(i) {
  {
    const e = Ze.from(i);
    e.reverse();
    const t = e.toString('hex');
    return t.length === 0 ? BigInt(0) : BigInt(`0x${t}`);
  }
}
var E3 = (sc.toBigIntLE = NB);
function $B(i) {
  {
    const e = i.toString('hex');
    return e.length === 0 ? BigInt(0) : BigInt(`0x${e}`);
  }
}
var zU = (sc.toBigIntBE = $B);
function DB(i, e) {
  {
    const t = i.toString(16),
      r = Ze.from(t.padStart(e * 2, '0').slice(0, e * 2), 'hex');
    return r.reverse(), r;
  }
}
var ql = (sc.toBufferLE = DB);
function UB(i, e) {
  {
    const t = i.toString(16);
    return Ze.from(t.padStart(e * 2, '0').slice(0, e * 2), 'hex');
  }
}
var FU = (sc.toBufferBE = UB);
class zB extends TypeError {
  constructor(e, t) {
    let r;
    const { message: s, ...n } = e,
      { path: c } = e,
      f = c.length === 0 ? s : 'At path: ' + c.join('.') + ' -- ' + s;
    super(f),
      Object.assign(this, n),
      (this.name = this.constructor.name),
      (this.failures = () => {
        var h;
        return (h = r) != null ? h : (r = [e, ...t()]);
      });
  }
}
function FB(i) {
  return Oo(i) && typeof i[Symbol.iterator] == 'function';
}
function Oo(i) {
  return typeof i == 'object' && i != null;
}
function hn(i) {
  return typeof i == 'string' ? JSON.stringify(i) : '' + i;
}
function qB(i) {
  const { done: e, value: t } = i.next();
  return e ? void 0 : t;
}
function WB(i, e, t, r) {
  if (i === !0) return;
  i === !1 ? (i = {}) : typeof i == 'string' && (i = { message: i });
  const { path: s, branch: n } = e,
    { type: c } = t,
    {
      refinement: f,
      message: h = 'Expected a value of type `' +
        c +
        '`' +
        (f ? ' with refinement `' + f + '`' : '') +
        ', but received: `' +
        hn(r) +
        '`',
    } = i;
  return {
    value: r,
    type: c,
    refinement: f,
    key: s[s.length - 1],
    path: s,
    branch: n,
    ...i,
    message: h,
  };
}
function* Km(i, e, t, r) {
  FB(i) || (i = [i]);
  for (const s of i) {
    const n = WB(s, e, t, r);
    n && (yield n);
  }
}
function* Ly(i, e, t = {}) {
  const { path: r = [], branch: s = [i], coerce: n = !1, mask: c = !1 } = t,
    f = { path: r, branch: s };
  if (
    n &&
    ((i = e.coercer(i, f)), c && e.type !== 'type' && Oo(e.schema) && Oo(i) && !Array.isArray(i))
  )
    for (const y in i) e.schema[y] === void 0 && delete i[y];
  let h = !0;
  for (const y of e.validator(i, f)) (h = !1), yield [y, void 0];
  for (let [y, p, m] of e.entries(i, f)) {
    const _ = Ly(p, m, {
      path: y === void 0 ? r : [...r, y],
      branch: y === void 0 ? s : [...s, p],
      coerce: n,
      mask: c,
    });
    for (const A of _)
      A[0]
        ? ((h = !1), yield [A[0], void 0])
        : n &&
          ((p = A[1]),
          y === void 0
            ? (i = p)
            : i instanceof Map
              ? i.set(y, p)
              : i instanceof Set
                ? i.add(p)
                : Oo(i) && (i[y] = p));
  }
  if (h) for (const y of e.refiner(i, f)) (h = !1), yield [y, void 0];
  h && (yield [void 0, i]);
}
let qn = class {
  constructor(e) {
    const {
      type: t,
      schema: r,
      validator: s,
      refiner: n,
      coercer: c = (h) => h,
      entries: f = function* () {},
    } = e;
    (this.type = t),
      (this.schema = r),
      (this.entries = f),
      (this.coercer = c),
      s
        ? (this.validator = (h, y) => {
            const p = s(h, y);
            return Km(p, y, this, h);
          })
        : (this.validator = () => []),
      n
        ? (this.refiner = (h, y) => {
            const p = n(h, y);
            return Km(p, y, this, h);
          })
        : (this.refiner = () => []);
  }
  assert(e) {
    return Ny(e, this);
  }
  create(e) {
    return Se(e, this);
  }
  is(e) {
    return k3(e, this);
  }
  mask(e) {
    return KB(e, this);
  }
  validate(e, t = {}) {
    return ac(e, this, t);
  }
};
function Ny(i, e) {
  const t = ac(i, e);
  if (t[0]) throw t[0];
}
function Se(i, e) {
  const t = ac(i, e, { coerce: !0 });
  if (t[0]) throw t[0];
  return t[1];
}
function KB(i, e) {
  const t = ac(i, e, { coerce: !0, mask: !0 });
  if (t[0]) throw t[0];
  return t[1];
}
function k3(i, e) {
  return !ac(i, e)[0];
}
function ac(i, e, t = {}) {
  const r = Ly(i, e, t),
    s = qB(r);
  return s[0]
    ? [
        new zB(s[0], function* () {
          for (const c of r) c[0] && (yield c[0]);
        }),
        void 0,
      ]
    : [void 0, s[1]];
}
function Rs(i, e) {
  return new qn({ type: i, schema: null, validator: e });
}
function I3() {
  return Rs('any', () => !0);
}
function Te(i) {
  return new qn({
    type: 'array',
    schema: i,
    *entries(e) {
      if (i && Array.isArray(e)) for (const [t, r] of e.entries()) yield [t, r, i];
    },
    coercer(e) {
      return Array.isArray(e) ? e.slice() : e;
    },
    validator(e) {
      return Array.isArray(e) || 'Expected an array value, but received: ' + hn(e);
    },
  });
}
function Xr() {
  return Rs('boolean', (i) => typeof i == 'boolean');
}
function Za(i) {
  return Rs(
    'instance',
    (e) => e instanceof i || 'Expected a `' + i.name + '` instance, but received: ' + hn(e)
  );
}
function ft(i) {
  const e = hn(i),
    t = typeof i;
  return new qn({
    type: 'literal',
    schema: t === 'string' || t === 'number' || t === 'boolean' ? i : null,
    validator(r) {
      return r === i || 'Expected the literal `' + e + '`, but received: ' + hn(r);
    },
  });
}
function jB() {
  return Rs('never', () => !1);
}
function Pe(i) {
  return new qn({
    ...i,
    validator: (e, t) => e === null || i.validator(e, t),
    refiner: (e, t) => e === null || i.refiner(e, t),
  });
}
function ee() {
  return Rs(
    'number',
    (i) => (typeof i == 'number' && !isNaN(i)) || 'Expected a number, but received: ' + hn(i)
  );
}
function Ge(i) {
  return new qn({
    ...i,
    validator: (e, t) => e === void 0 || i.validator(e, t),
    refiner: (e, t) => e === void 0 || i.refiner(e, t),
  });
}
function Wl(i, e) {
  return new qn({
    type: 'record',
    schema: null,
    *entries(t) {
      if (Oo(t))
        for (const r in t) {
          const s = t[r];
          yield [r, r, i], yield [r, s, e];
        }
    },
    validator(t) {
      return Oo(t) || 'Expected an object, but received: ' + hn(t);
    },
  });
}
function we() {
  return Rs('string', (i) => typeof i == 'string' || 'Expected a string, but received: ' + hn(i));
}
function Ja(i) {
  const e = jB();
  return new qn({
    type: 'tuple',
    schema: null,
    *entries(t) {
      if (Array.isArray(t)) {
        const r = Math.max(i.length, t.length);
        for (let s = 0; s < r; s++) yield [s, t[s], i[s] || e];
      }
    },
    validator(t) {
      return Array.isArray(t) || 'Expected an array, but received: ' + hn(t);
    },
  });
}
function pe(i) {
  const e = Object.keys(i);
  return new qn({
    type: 'type',
    schema: i,
    *entries(t) {
      if (Oo(t)) for (const r of e) yield [r, t[r], i[r]];
    },
    validator(t) {
      return Oo(t) || 'Expected an object, but received: ' + hn(t);
    },
  });
}
function ar(i) {
  const e = i.map((t) => t.type).join(' | ');
  return new qn({
    type: 'union',
    schema: null,
    validator(t, r) {
      const s = [];
      for (const n of i) {
        const [...c] = Ly(t, n, r),
          [f] = c;
        if (f[0]) for (const [h] of c) h && s.push(h);
        else return [];
      }
      return ['Expected the value to satisfy a union of `' + e + '`, but received: ' + hn(t), ...s];
    },
  });
}
function Wn() {
  return Rs('unknown', () => !0);
}
function Kn(i, e, t) {
  return new qn({ ...i, coercer: (r, s) => (k3(r, e) ? i.coercer(t(r, s), s) : i.coercer(r, s)) });
}
const x3 = pn(p5),
  HB = x3.v4,
  VB = function (i, e, t, r) {
    if (typeof i != 'string') throw new TypeError(i + ' must be a string');
    r = r || {};
    const s = typeof r.version == 'number' ? r.version : 2;
    if (s !== 1 && s !== 2) throw new TypeError(s + ' must be 1 or 2');
    const n = { method: i };
    if ((s === 2 && (n.jsonrpc = '2.0'), e)) {
      if (typeof e != 'object' && !Array.isArray(e))
        throw new TypeError(e + ' must be an object, array or omitted');
      n.params = e;
    }
    if (typeof t > 'u') {
      const c =
        typeof r.generator == 'function'
          ? r.generator
          : function () {
              return HB();
            };
      n.id = c(n, r);
    } else s === 2 && t === null ? r.notificationIdNull && (n.id = null) : (n.id = t);
    return n;
  };
var GB = VB;
const YB = x3.v4,
  ZB = GB,
  Lu = function (i, e) {
    if (!(this instanceof Lu)) return new Lu(i, e);
    e || (e = {}),
      (this.options = {
        reviver: typeof e.reviver < 'u' ? e.reviver : null,
        replacer: typeof e.replacer < 'u' ? e.replacer : null,
        generator:
          typeof e.generator < 'u'
            ? e.generator
            : function () {
                return YB();
              },
        version: typeof e.version < 'u' ? e.version : 2,
        notificationIdNull: typeof e.notificationIdNull == 'boolean' ? e.notificationIdNull : !1,
      }),
      (this.callServer = i);
  };
var JB = Lu;
Lu.prototype.request = function (i, e, t, r) {
  const s = this;
  let n = null;
  const c = Array.isArray(i) && typeof e == 'function';
  if (this.options.version === 1 && c)
    throw new TypeError('JSON-RPC 1.0 does not support batching');
  if (c || (!c && i && typeof i == 'object' && typeof e == 'function')) (r = e), (n = i);
  else {
    typeof t == 'function' && ((r = t), (t = void 0));
    const y = typeof r == 'function';
    try {
      n = ZB(i, e, t, {
        generator: this.options.generator,
        version: this.options.version,
        notificationIdNull: this.options.notificationIdNull,
      });
    } catch (p) {
      if (y) return r(p);
      throw p;
    }
    if (!y) return n;
  }
  let h;
  try {
    h = JSON.stringify(n, this.options.replacer);
  } catch (y) {
    return r(y);
  }
  return (
    this.callServer(h, function (y, p) {
      s._parseResponse(y, p, r);
    }),
    n
  );
};
Lu.prototype._parseResponse = function (i, e, t) {
  if (i) {
    t(i);
    return;
  }
  if (!e) return t();
  let r;
  try {
    r = JSON.parse(e, this.options.reviver);
  } catch (s) {
    return t(s);
  }
  if (t.length === 3)
    if (Array.isArray(r)) {
      const s = function (c) {
          return typeof c.error < 'u';
        },
        n = function (c) {
          return !s(c);
        };
      return t(null, r.filter(s), r.filter(n));
    } else return t(null, r.error, r.result);
  t(null, r);
};
const B3 = zn(JB);
var R3 = {},
  P3 = { exports: {} };
(function (i) {
  function e(t) {
    return t && t.__esModule ? t : { default: t };
  }
  (i.exports = e), (i.exports.__esModule = !0), (i.exports.default = i.exports);
})(P3);
var T3 = P3.exports,
  G0 = { exports: {} },
  Y0 = { exports: {} },
  jm;
function O3() {
  return (
    jm ||
      ((jm = 1),
      (function (i) {
        function e(t) {
          '@babel/helpers - typeof';
          return (
            (i.exports = e =
              typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (r) {
                    return typeof r;
                  }
                : function (r) {
                    return r &&
                      typeof Symbol == 'function' &&
                      r.constructor === Symbol &&
                      r !== Symbol.prototype
                      ? 'symbol'
                      : typeof r;
                  }),
            (i.exports.__esModule = !0),
            (i.exports.default = i.exports),
            e(t)
          );
        }
        (i.exports = e), (i.exports.__esModule = !0), (i.exports.default = i.exports);
      })(Y0)),
    Y0.exports
  );
}
var Hm;
function XB() {
  return (
    Hm ||
      ((Hm = 1),
      (function (i) {
        var e = O3().default;
        function t() {
          /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ (i.exports =
            t =
              function () {
                return r;
              }),
            (i.exports.__esModule = !0),
            (i.exports.default = i.exports);
          var r = {},
            s = Object.prototype,
            n = s.hasOwnProperty,
            c =
              Object.defineProperty ||
              function (d, g, w) {
                d[g] = w.value;
              },
            f = typeof Symbol == 'function' ? Symbol : {},
            h = f.iterator || '@@iterator',
            y = f.asyncIterator || '@@asyncIterator',
            p = f.toStringTag || '@@toStringTag';
          function m(d, g, w) {
            return (
              Object.defineProperty(d, g, {
                value: w,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              }),
              d[g]
            );
          }
          try {
            m({}, '');
          } catch {
            m = function (w, M, v) {
              return (w[M] = v);
            };
          }
          function _(d, g, w, M) {
            var v = g && g.prototype instanceof I ? g : I,
              a = Object.create(v.prototype),
              b = new o(M || []);
            return c(a, '_invoke', { value: ne(d, w, b) }), a;
          }
          function A(d, g, w) {
            try {
              return { type: 'normal', arg: d.call(g, w) };
            } catch (M) {
              return { type: 'throw', arg: M };
            }
          }
          r.wrap = _;
          var E = {};
          function I() {}
          function R() {}
          function L() {}
          var D = {};
          m(D, h, function () {
            return this;
          });
          var q = Object.getPrototypeOf,
            H = q && q(q(u([])));
          H && H !== s && n.call(H, h) && (D = H);
          var V = (L.prototype = I.prototype = Object.create(D));
          function te(d) {
            ['next', 'throw', 'return'].forEach(function (g) {
              m(d, g, function (w) {
                return this._invoke(g, w);
              });
            });
          }
          function ue(d, g) {
            function w(v, a, b, k) {
              var B = A(d[v], d, a);
              if (B.type !== 'throw') {
                var F = B.arg,
                  P = F.value;
                return P && e(P) == 'object' && n.call(P, '__await')
                  ? g.resolve(P.__await).then(
                      function (C) {
                        w('next', C, b, k);
                      },
                      function (C) {
                        w('throw', C, b, k);
                      }
                    )
                  : g.resolve(P).then(
                      function (C) {
                        (F.value = C), b(F);
                      },
                      function (C) {
                        return w('throw', C, b, k);
                      }
                    );
              }
              k(B.arg);
            }
            var M;
            c(this, '_invoke', {
              value: function (a, b) {
                function k() {
                  return new g(function (B, F) {
                    w(a, b, B, F);
                  });
                }
                return (M = M ? M.then(k, k) : k());
              },
            });
          }
          function ne(d, g, w) {
            var M = 'suspendedStart';
            return function (v, a) {
              if (M === 'executing') throw new Error('Generator is already running');
              if (M === 'completed') {
                if (v === 'throw') throw a;
                return l();
              }
              for (w.method = v, w.arg = a; ; ) {
                var b = w.delegate;
                if (b) {
                  var k = X(b, w);
                  if (k) {
                    if (k === E) continue;
                    return k;
                  }
                }
                if (w.method === 'next') w.sent = w._sent = w.arg;
                else if (w.method === 'throw') {
                  if (M === 'suspendedStart') throw ((M = 'completed'), w.arg);
                  w.dispatchException(w.arg);
                } else w.method === 'return' && w.abrupt('return', w.arg);
                M = 'executing';
                var B = A(d, g, w);
                if (B.type === 'normal') {
                  if (((M = w.done ? 'completed' : 'suspendedYield'), B.arg === E)) continue;
                  return { value: B.arg, done: w.done };
                }
                B.type === 'throw' && ((M = 'completed'), (w.method = 'throw'), (w.arg = B.arg));
              }
            };
          }
          function X(d, g) {
            var w = g.method,
              M = d.iterator[w];
            if (M === void 0)
              return (
                (g.delegate = null),
                (w === 'throw' &&
                  d.iterator.return &&
                  ((g.method = 'return'), (g.arg = void 0), X(d, g), g.method === 'throw')) ||
                  (w !== 'return' &&
                    ((g.method = 'throw'),
                    (g.arg = new TypeError("The iterator does not provide a '" + w + "' method")))),
                E
              );
            var v = A(M, d.iterator, g.arg);
            if (v.type === 'throw')
              return (g.method = 'throw'), (g.arg = v.arg), (g.delegate = null), E;
            var a = v.arg;
            return a
              ? a.done
                ? ((g[d.resultName] = a.value),
                  (g.next = d.nextLoc),
                  g.method !== 'return' && ((g.method = 'next'), (g.arg = void 0)),
                  (g.delegate = null),
                  E)
                : a
              : ((g.method = 'throw'),
                (g.arg = new TypeError('iterator result is not an object')),
                (g.delegate = null),
                E);
          }
          function Oe(d) {
            var g = { tryLoc: d[0] };
            1 in d && (g.catchLoc = d[1]),
              2 in d && ((g.finallyLoc = d[2]), (g.afterLoc = d[3])),
              this.tryEntries.push(g);
          }
          function S(d) {
            var g = d.completion || {};
            (g.type = 'normal'), delete g.arg, (d.completion = g);
          }
          function o(d) {
            (this.tryEntries = [{ tryLoc: 'root' }]), d.forEach(Oe, this), this.reset(!0);
          }
          function u(d) {
            if (d) {
              var g = d[h];
              if (g) return g.call(d);
              if (typeof d.next == 'function') return d;
              if (!isNaN(d.length)) {
                var w = -1,
                  M = function v() {
                    for (; ++w < d.length; )
                      if (n.call(d, w)) return (v.value = d[w]), (v.done = !1), v;
                    return (v.value = void 0), (v.done = !0), v;
                  };
                return (M.next = M);
              }
            }
            return { next: l };
          }
          function l() {
            return { value: void 0, done: !0 };
          }
          return (
            (R.prototype = L),
            c(V, 'constructor', { value: L, configurable: !0 }),
            c(L, 'constructor', { value: R, configurable: !0 }),
            (R.displayName = m(L, p, 'GeneratorFunction')),
            (r.isGeneratorFunction = function (d) {
              var g = typeof d == 'function' && d.constructor;
              return !!g && (g === R || (g.displayName || g.name) === 'GeneratorFunction');
            }),
            (r.mark = function (d) {
              return (
                Object.setPrototypeOf
                  ? Object.setPrototypeOf(d, L)
                  : ((d.__proto__ = L), m(d, p, 'GeneratorFunction')),
                (d.prototype = Object.create(V)),
                d
              );
            }),
            (r.awrap = function (d) {
              return { __await: d };
            }),
            te(ue.prototype),
            m(ue.prototype, y, function () {
              return this;
            }),
            (r.AsyncIterator = ue),
            (r.async = function (d, g, w, M, v) {
              v === void 0 && (v = Promise);
              var a = new ue(_(d, g, w, M), v);
              return r.isGeneratorFunction(g)
                ? a
                : a.next().then(function (b) {
                    return b.done ? b.value : a.next();
                  });
            }),
            te(V),
            m(V, p, 'Generator'),
            m(V, h, function () {
              return this;
            }),
            m(V, 'toString', function () {
              return '[object Generator]';
            }),
            (r.keys = function (d) {
              var g = Object(d),
                w = [];
              for (var M in g) w.push(M);
              return (
                w.reverse(),
                function v() {
                  for (; w.length; ) {
                    var a = w.pop();
                    if (a in g) return (v.value = a), (v.done = !1), v;
                  }
                  return (v.done = !0), v;
                }
              );
            }),
            (r.values = u),
            (o.prototype = {
              constructor: o,
              reset: function (g) {
                if (
                  ((this.prev = 0),
                  (this.next = 0),
                  (this.sent = this._sent = void 0),
                  (this.done = !1),
                  (this.delegate = null),
                  (this.method = 'next'),
                  (this.arg = void 0),
                  this.tryEntries.forEach(S),
                  !g)
                )
                  for (var w in this)
                    w.charAt(0) === 't' &&
                      n.call(this, w) &&
                      !isNaN(+w.slice(1)) &&
                      (this[w] = void 0);
              },
              stop: function () {
                this.done = !0;
                var g = this.tryEntries[0].completion;
                if (g.type === 'throw') throw g.arg;
                return this.rval;
              },
              dispatchException: function (g) {
                if (this.done) throw g;
                var w = this;
                function M(F, P) {
                  return (
                    (b.type = 'throw'),
                    (b.arg = g),
                    (w.next = F),
                    P && ((w.method = 'next'), (w.arg = void 0)),
                    !!P
                  );
                }
                for (var v = this.tryEntries.length - 1; v >= 0; --v) {
                  var a = this.tryEntries[v],
                    b = a.completion;
                  if (a.tryLoc === 'root') return M('end');
                  if (a.tryLoc <= this.prev) {
                    var k = n.call(a, 'catchLoc'),
                      B = n.call(a, 'finallyLoc');
                    if (k && B) {
                      if (this.prev < a.catchLoc) return M(a.catchLoc, !0);
                      if (this.prev < a.finallyLoc) return M(a.finallyLoc);
                    } else if (k) {
                      if (this.prev < a.catchLoc) return M(a.catchLoc, !0);
                    } else {
                      if (!B) throw new Error('try statement without catch or finally');
                      if (this.prev < a.finallyLoc) return M(a.finallyLoc);
                    }
                  }
                }
              },
              abrupt: function (g, w) {
                for (var M = this.tryEntries.length - 1; M >= 0; --M) {
                  var v = this.tryEntries[M];
                  if (
                    v.tryLoc <= this.prev &&
                    n.call(v, 'finallyLoc') &&
                    this.prev < v.finallyLoc
                  ) {
                    var a = v;
                    break;
                  }
                }
                a &&
                  (g === 'break' || g === 'continue') &&
                  a.tryLoc <= w &&
                  w <= a.finallyLoc &&
                  (a = null);
                var b = a ? a.completion : {};
                return (
                  (b.type = g),
                  (b.arg = w),
                  a ? ((this.method = 'next'), (this.next = a.finallyLoc), E) : this.complete(b)
                );
              },
              complete: function (g, w) {
                if (g.type === 'throw') throw g.arg;
                return (
                  g.type === 'break' || g.type === 'continue'
                    ? (this.next = g.arg)
                    : g.type === 'return'
                      ? ((this.rval = this.arg = g.arg),
                        (this.method = 'return'),
                        (this.next = 'end'))
                      : g.type === 'normal' && w && (this.next = w),
                  E
                );
              },
              finish: function (g) {
                for (var w = this.tryEntries.length - 1; w >= 0; --w) {
                  var M = this.tryEntries[w];
                  if (M.finallyLoc === g) return this.complete(M.completion, M.afterLoc), S(M), E;
                }
              },
              catch: function (g) {
                for (var w = this.tryEntries.length - 1; w >= 0; --w) {
                  var M = this.tryEntries[w];
                  if (M.tryLoc === g) {
                    var v = M.completion;
                    if (v.type === 'throw') {
                      var a = v.arg;
                      S(M);
                    }
                    return a;
                  }
                }
                throw new Error('illegal catch attempt');
              },
              delegateYield: function (g, w, M) {
                return (
                  (this.delegate = { iterator: u(g), resultName: w, nextLoc: M }),
                  this.method === 'next' && (this.arg = void 0),
                  E
                );
              },
            }),
            r
          );
        }
        (i.exports = t), (i.exports.__esModule = !0), (i.exports.default = i.exports);
      })(G0)),
    G0.exports
  );
}
var Z0, Vm;
function QB() {
  if (Vm) return Z0;
  Vm = 1;
  var i = XB()();
  Z0 = i;
  try {
    regeneratorRuntime = i;
  } catch {
    typeof globalThis == 'object'
      ? (globalThis.regeneratorRuntime = i)
      : Function('r', 'regeneratorRuntime = r')(i);
  }
  return Z0;
}
var J0 = { exports: {} },
  Gm;
function eR() {
  return (
    Gm ||
      ((Gm = 1),
      (function (i) {
        function e(r, s, n, c, f, h, y) {
          try {
            var p = r[h](y),
              m = p.value;
          } catch (_) {
            n(_);
            return;
          }
          p.done ? s(m) : Promise.resolve(m).then(c, f);
        }
        function t(r) {
          return function () {
            var s = this,
              n = arguments;
            return new Promise(function (c, f) {
              var h = r.apply(s, n);
              function y(m) {
                e(h, c, f, y, p, 'next', m);
              }
              function p(m) {
                e(h, c, f, y, p, 'throw', m);
              }
              y(void 0);
            });
          };
        }
        (i.exports = t), (i.exports.__esModule = !0), (i.exports.default = i.exports);
      })(J0)),
    J0.exports
  );
}
const C3 = pn(w5),
  L3 = pn(M5),
  N3 = pn(B5),
  $3 = pn(k5),
  D3 = pn(I5);
(function (i) {
  var e = T3;
  Object.defineProperty(i, '__esModule', { value: !0 }), (i.default = void 0);
  var t = e(QB()),
    r = e(eR()),
    s = e(O3()),
    n = e(C3),
    c = e(L3),
    f = e(N3),
    h = e($3),
    y = e(D3),
    p = C2;
  function m(I) {
    var R = _();
    return function () {
      var D = (0, y.default)(I),
        q;
      if (R) {
        var H = (0, y.default)(this).constructor;
        q = Reflect.construct(D, arguments, H);
      } else q = D.apply(this, arguments);
      return (0, h.default)(this, q);
    };
  }
  function _() {
    if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == 'function') return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
    } catch {
      return !1;
    }
  }
  var A = function (I, R) {
      var L = {};
      for (var D in I)
        Object.prototype.hasOwnProperty.call(I, D) && R.indexOf(D) < 0 && (L[D] = I[D]);
      if (I != null && typeof Object.getOwnPropertySymbols == 'function')
        for (var q = 0, D = Object.getOwnPropertySymbols(I); q < D.length; q++)
          R.indexOf(D[q]) < 0 &&
            Object.prototype.propertyIsEnumerable.call(I, D[q]) &&
            (L[D[q]] = I[D[q]]);
      return L;
    },
    E = (function (I) {
      (0, f.default)(L, I);
      var R = m(L);
      function L(D) {
        var q,
          H =
            arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'ws://localhost:8080',
          V = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
          te = arguments.length > 3 ? arguments[3] : void 0;
        (0, n.default)(this, L);
        var ue = V.autoconnect,
          ne = ue === void 0 ? !0 : ue,
          X = V.reconnect,
          Oe = X === void 0 ? !0 : X,
          S = V.reconnect_interval,
          o = S === void 0 ? 1e3 : S,
          u = V.max_reconnects,
          l = u === void 0 ? 5 : u,
          d = A(V, ['autoconnect', 'reconnect', 'reconnect_interval', 'max_reconnects']);
        return (
          (q = R.call(this)),
          (q.webSocketFactory = D),
          (q.queue = {}),
          (q.rpc_id = 0),
          (q.address = H),
          (q.autoconnect = ne),
          (q.ready = !1),
          (q.reconnect = Oe),
          (q.reconnect_timer_id = void 0),
          (q.reconnect_interval = o),
          (q.max_reconnects = l),
          (q.rest_options = d),
          (q.current_reconnects = 0),
          (q.generate_request_id =
            te ||
            function () {
              return ++q.rpc_id;
            }),
          q.autoconnect &&
            q._connect(
              q.address,
              Object.assign(
                {
                  autoconnect: q.autoconnect,
                  reconnect: q.reconnect,
                  reconnect_interval: q.reconnect_interval,
                  max_reconnects: q.max_reconnects,
                },
                q.rest_options
              )
            ),
          q
        );
      }
      return (
        (0, c.default)(L, [
          {
            key: 'connect',
            value: function () {
              this.socket ||
                this._connect(
                  this.address,
                  Object.assign(
                    {
                      autoconnect: this.autoconnect,
                      reconnect: this.reconnect,
                      reconnect_interval: this.reconnect_interval,
                      max_reconnects: this.max_reconnects,
                    },
                    this.rest_options
                  )
                );
            },
          },
          {
            key: 'call',
            value: function (q, H, V, te) {
              var ue = this;
              return (
                !te && (0, s.default)(V) === 'object' && ((te = V), (V = null)),
                new Promise(function (ne, X) {
                  if (!ue.ready) return X(new Error('socket not ready'));
                  var Oe = ue.generate_request_id(q, H),
                    S = { jsonrpc: '2.0', method: q, params: H || null, id: Oe };
                  ue.socket.send(JSON.stringify(S), te, function (o) {
                    if (o) return X(o);
                    (ue.queue[Oe] = { promise: [ne, X] }),
                      V &&
                        (ue.queue[Oe].timeout = setTimeout(function () {
                          delete ue.queue[Oe], X(new Error('reply timeout'));
                        }, V));
                  });
                })
              );
            },
          },
          {
            key: 'login',
            value: (function () {
              var D = (0, r.default)(
                t.default.mark(function H(V) {
                  var te;
                  return t.default.wrap(
                    function (ne) {
                      for (;;)
                        switch ((ne.prev = ne.next)) {
                          case 0:
                            return (ne.next = 2), this.call('rpc.login', V);
                          case 2:
                            if (((te = ne.sent), te)) {
                              ne.next = 5;
                              break;
                            }
                            throw new Error('authentication failed');
                          case 5:
                            return ne.abrupt('return', te);
                          case 6:
                          case 'end':
                            return ne.stop();
                        }
                    },
                    H,
                    this
                  );
                })
              );
              function q(H) {
                return D.apply(this, arguments);
              }
              return q;
            })(),
          },
          {
            key: 'listMethods',
            value: (function () {
              var D = (0, r.default)(
                t.default.mark(function H() {
                  return t.default.wrap(
                    function (te) {
                      for (;;)
                        switch ((te.prev = te.next)) {
                          case 0:
                            return (te.next = 2), this.call('__listMethods');
                          case 2:
                            return te.abrupt('return', te.sent);
                          case 3:
                          case 'end':
                            return te.stop();
                        }
                    },
                    H,
                    this
                  );
                })
              );
              function q() {
                return D.apply(this, arguments);
              }
              return q;
            })(),
          },
          {
            key: 'notify',
            value: function (q, H) {
              var V = this;
              return new Promise(function (te, ue) {
                if (!V.ready) return ue(new Error('socket not ready'));
                var ne = { jsonrpc: '2.0', method: q, params: H || null };
                V.socket.send(JSON.stringify(ne), function (X) {
                  if (X) return ue(X);
                  te();
                });
              });
            },
          },
          {
            key: 'subscribe',
            value: (function () {
              var D = (0, r.default)(
                t.default.mark(function H(V) {
                  var te;
                  return t.default.wrap(
                    function (ne) {
                      for (;;)
                        switch ((ne.prev = ne.next)) {
                          case 0:
                            return (
                              typeof V == 'string' && (V = [V]),
                              (ne.next = 3),
                              this.call('rpc.on', V)
                            );
                          case 3:
                            if (((te = ne.sent), !(typeof V == 'string' && te[V] !== 'ok'))) {
                              ne.next = 6;
                              break;
                            }
                            throw new Error(
                              "Failed subscribing to an event '" + V + "' with: " + te[V]
                            );
                          case 6:
                            return ne.abrupt('return', te);
                          case 7:
                          case 'end':
                            return ne.stop();
                        }
                    },
                    H,
                    this
                  );
                })
              );
              function q(H) {
                return D.apply(this, arguments);
              }
              return q;
            })(),
          },
          {
            key: 'unsubscribe',
            value: (function () {
              var D = (0, r.default)(
                t.default.mark(function H(V) {
                  var te;
                  return t.default.wrap(
                    function (ne) {
                      for (;;)
                        switch ((ne.prev = ne.next)) {
                          case 0:
                            return (
                              typeof V == 'string' && (V = [V]),
                              (ne.next = 3),
                              this.call('rpc.off', V)
                            );
                          case 3:
                            if (((te = ne.sent), !(typeof V == 'string' && te[V] !== 'ok'))) {
                              ne.next = 6;
                              break;
                            }
                            throw new Error('Failed unsubscribing from an event with: ' + te);
                          case 6:
                            return ne.abrupt('return', te);
                          case 7:
                          case 'end':
                            return ne.stop();
                        }
                    },
                    H,
                    this
                  );
                })
              );
              function q(H) {
                return D.apply(this, arguments);
              }
              return q;
            })(),
          },
          {
            key: 'close',
            value: function (q, H) {
              this.socket.close(q || 1e3, H);
            },
          },
          {
            key: '_connect',
            value: function (q, H) {
              var V = this;
              clearTimeout(this.reconnect_timer_id),
                (this.socket = this.webSocketFactory(q, H)),
                this.socket.addEventListener('open', function () {
                  (V.ready = !0), V.emit('open'), (V.current_reconnects = 0);
                }),
                this.socket.addEventListener('message', function (te) {
                  var ue = te.data;
                  ue instanceof ArrayBuffer && (ue = Ze.from(ue).toString());
                  try {
                    ue = JSON.parse(ue);
                  } catch {
                    return;
                  }
                  if (ue.notification && V.listeners(ue.notification).length) {
                    if (!Object.keys(ue.params).length) return V.emit(ue.notification);
                    var ne = [ue.notification];
                    if (ue.params.constructor === Object) ne.push(ue.params);
                    else for (var X = 0; X < ue.params.length; X++) ne.push(ue.params[X]);
                    return Promise.resolve().then(function () {
                      V.emit.apply(V, ne);
                    });
                  }
                  if (!V.queue[ue.id])
                    return ue.method && ue.params
                      ? Promise.resolve().then(function () {
                          V.emit(ue.method, ue.params);
                        })
                      : void 0;
                  'error' in ue == 'result' in ue &&
                    V.queue[ue.id].promise[1](
                      new Error(
                        'Server response malformed. Response must include either "result" or "error", but not both.'
                      )
                    ),
                    V.queue[ue.id].timeout && clearTimeout(V.queue[ue.id].timeout),
                    ue.error
                      ? V.queue[ue.id].promise[1](ue.error)
                      : V.queue[ue.id].promise[0](ue.result),
                    delete V.queue[ue.id];
                }),
                this.socket.addEventListener('error', function (te) {
                  return V.emit('error', te);
                }),
                this.socket.addEventListener('close', function (te) {
                  var ue = te.code,
                    ne = te.reason;
                  V.ready &&
                    setTimeout(function () {
                      return V.emit('close', ue, ne);
                    }, 0),
                    (V.ready = !1),
                    (V.socket = void 0),
                    ue !== 1e3 &&
                      (V.current_reconnects++,
                      V.reconnect &&
                        (V.max_reconnects > V.current_reconnects || V.max_reconnects === 0) &&
                        (V.reconnect_timer_id = setTimeout(function () {
                          return V._connect(q, H);
                        }, V.reconnect_interval)));
                });
            },
          },
        ]),
        L
      );
    })(p.EventEmitter);
  i.default = E;
})(R3);
const U3 = zn(R3);
var z3 = {};
(function (i) {
  var e = T3;
  Object.defineProperty(i, '__esModule', { value: !0 }), (i.default = m);
  var t = e(C3),
    r = e(L3),
    s = e(N3),
    n = e($3),
    c = e(D3),
    f = C2;
  function h(_) {
    var A = y();
    return function () {
      var I = (0, c.default)(_),
        R;
      if (A) {
        var L = (0, c.default)(this).constructor;
        R = Reflect.construct(I, arguments, L);
      } else R = I.apply(this, arguments);
      return (0, n.default)(this, R);
    };
  }
  function y() {
    if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == 'function') return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
    } catch {
      return !1;
    }
  }
  var p = (function (_) {
    (0, s.default)(E, _);
    var A = h(E);
    function E(I, R, L) {
      var D;
      return (
        (0, t.default)(this, E),
        (D = A.call(this)),
        (D.socket = new globalThis.WebSocket(I, L)),
        (D.socket.onopen = function () {
          return D.emit('open');
        }),
        (D.socket.onmessage = function (q) {
          return D.emit('message', q.data);
        }),
        (D.socket.onerror = function (q) {
          return D.emit('error', q);
        }),
        (D.socket.onclose = function (q) {
          D.emit('close', q.code, q.reason);
        }),
        D
      );
    }
    return (
      (0, r.default)(E, [
        {
          key: 'send',
          value: function (R, L, D) {
            var q = D || L;
            try {
              this.socket.send(R), q();
            } catch (H) {
              q(H);
            }
          },
        },
        {
          key: 'close',
          value: function (R, L) {
            this.socket.close(R, L);
          },
        },
        {
          key: 'addEventListener',
          value: function (R, L, D) {
            this.socket.addEventListener(R, L, D);
          },
        },
      ]),
      E
    );
  })(f.EventEmitter);
  function m(_, A) {
    return new p(_, A);
  }
})(z3);
const F3 = zn(z3);
var Ym = Object.prototype.toString,
  q3 = function (e) {
    var t = Ym.call(e),
      r = t === '[object Arguments]';
    return (
      r ||
        (r =
          t !== '[object Array]' &&
          e !== null &&
          typeof e == 'object' &&
          typeof e.length == 'number' &&
          e.length >= 0 &&
          Ym.call(e.callee) === '[object Function]'),
      r
    );
  },
  X0,
  Zm;
function tR() {
  if (Zm) return X0;
  Zm = 1;
  var i;
  if (!Object.keys) {
    var e = Object.prototype.hasOwnProperty,
      t = Object.prototype.toString,
      r = q3,
      s = Object.prototype.propertyIsEnumerable,
      n = !s.call({ toString: null }, 'toString'),
      c = s.call(function () {}, 'prototype'),
      f = [
        'toString',
        'toLocaleString',
        'valueOf',
        'hasOwnProperty',
        'isPrototypeOf',
        'propertyIsEnumerable',
        'constructor',
      ],
      h = function (_) {
        var A = _.constructor;
        return A && A.prototype === _;
      },
      y = {
        $applicationCache: !0,
        $console: !0,
        $external: !0,
        $frame: !0,
        $frameElement: !0,
        $frames: !0,
        $innerHeight: !0,
        $innerWidth: !0,
        $onmozfullscreenchange: !0,
        $onmozfullscreenerror: !0,
        $outerHeight: !0,
        $outerWidth: !0,
        $pageXOffset: !0,
        $pageYOffset: !0,
        $parent: !0,
        $scrollLeft: !0,
        $scrollTop: !0,
        $scrollX: !0,
        $scrollY: !0,
        $self: !0,
        $webkitIndexedDB: !0,
        $webkitStorageInfo: !0,
        $window: !0,
      },
      p = (function () {
        if (typeof window > 'u') return !1;
        for (var _ in window)
          try {
            if (
              !y['$' + _] &&
              e.call(window, _) &&
              window[_] !== null &&
              typeof window[_] == 'object'
            )
              try {
                h(window[_]);
              } catch {
                return !0;
              }
          } catch {
            return !0;
          }
        return !1;
      })(),
      m = function (_) {
        if (typeof window > 'u' || !p) return h(_);
        try {
          return h(_);
        } catch {
          return !1;
        }
      };
    i = function (A) {
      var E = A !== null && typeof A == 'object',
        I = t.call(A) === '[object Function]',
        R = r(A),
        L = E && t.call(A) === '[object String]',
        D = [];
      if (!E && !I && !R) throw new TypeError('Object.keys called on a non-object');
      var q = c && I;
      if (L && A.length > 0 && !e.call(A, 0)) for (var H = 0; H < A.length; ++H) D.push(String(H));
      if (R && A.length > 0) for (var V = 0; V < A.length; ++V) D.push(String(V));
      else for (var te in A) !(q && te === 'prototype') && e.call(A, te) && D.push(String(te));
      if (n)
        for (var ue = m(A), ne = 0; ne < f.length; ++ne)
          !(ue && f[ne] === 'constructor') && e.call(A, f[ne]) && D.push(f[ne]);
      return D;
    };
  }
  return (X0 = i), X0;
}
var rR = Array.prototype.slice,
  iR = q3,
  Jm = Object.keys,
  kf = Jm
    ? function (e) {
        return Jm(e);
      }
    : tR(),
  Xm = Object.keys;
kf.shim = function () {
  if (Object.keys) {
    var e = (function () {
      var t = Object.keys(arguments);
      return t && t.length === arguments.length;
    })(1, 2);
    e ||
      (Object.keys = function (r) {
        return iR(r) ? Xm(rR.call(r)) : Xm(r);
      });
  } else Object.keys = kf;
  return Object.keys || kf;
};
var nR = kf,
  oR = nR,
  sR = typeof Symbol == 'function' && typeof Symbol('foo') == 'symbol',
  aR = Object.prototype.toString,
  uR = Array.prototype.concat,
  W3 = Object.defineProperty,
  cR = function (i) {
    return typeof i == 'function' && aR.call(i) === '[object Function]';
  },
  fR = H1(),
  K3 = W3 && fR,
  lR = function (i, e, t, r) {
    if (e in i) {
      if (r === !0) {
        if (i[e] === t) return;
      } else if (!cR(r) || !r()) return;
    }
    K3 ? W3(i, e, { configurable: !0, enumerable: !1, value: t, writable: !0 }) : (i[e] = t);
  },
  j3 = function (i, e) {
    var t = arguments.length > 2 ? arguments[2] : {},
      r = oR(e);
    sR && (r = uR.call(r, Object.getOwnPropertySymbols(e)));
    for (var s = 0; s < r.length; s += 1) lR(i, r[s], e[r[s]], t[r[s]]);
  };
j3.supportsDescriptors = !!K3;
var Kl = j3,
  Q0 = { exports: {} },
  ep = {},
  Qm;
function H3() {
  if (Qm) return ep;
  Qm = 1;
  function i(I) {
    return (
      typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
        ? (i = function (L) {
            return typeof L;
          })
        : (i = function (L) {
            return L &&
              typeof Symbol == 'function' &&
              L.constructor === Symbol &&
              L !== Symbol.prototype
              ? 'symbol'
              : typeof L;
          }),
      i(I)
    );
  }
  function e(I, R) {
    if (!(I instanceof R)) throw new TypeError('Cannot call a class as a function');
  }
  function t(I, R) {
    return R && (i(R) === 'object' || typeof R == 'function') ? R : r(I);
  }
  function r(I) {
    if (I === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return I;
  }
  function s(I) {
    return (
      (s = Object.setPrototypeOf
        ? Object.getPrototypeOf
        : function (L) {
            return L.__proto__ || Object.getPrototypeOf(L);
          }),
      s(I)
    );
  }
  function n(I, R) {
    if (typeof R != 'function' && R !== null)
      throw new TypeError('Super expression must either be null or a function');
    (I.prototype = Object.create(R && R.prototype, {
      constructor: { value: I, writable: !0, configurable: !0 },
    })),
      R && c(I, R);
  }
  function c(I, R) {
    return (
      (c =
        Object.setPrototypeOf ||
        function (D, q) {
          return (D.__proto__ = q), D;
        }),
      c(I, R)
    );
  }
  var f = {},
    h,
    y;
  function p(I, R, L) {
    L || (L = Error);
    function D(H, V, te) {
      return typeof R == 'string' ? R : R(H, V, te);
    }
    var q = (function (H) {
      n(V, H);
      function V(te, ue, ne) {
        var X;
        return e(this, V), (X = t(this, s(V).call(this, D(te, ue, ne)))), (X.code = I), X;
      }
      return V;
    })(L);
    f[I] = q;
  }
  function m(I, R) {
    if (Array.isArray(I)) {
      var L = I.length;
      return (
        (I = I.map(function (D) {
          return String(D);
        })),
        L > 2
          ? 'one of '.concat(R, ' ').concat(I.slice(0, L - 1).join(', '), ', or ') + I[L - 1]
          : L === 2
            ? 'one of '.concat(R, ' ').concat(I[0], ' or ').concat(I[1])
            : 'of '.concat(R, ' ').concat(I[0])
      );
    } else return 'of '.concat(R, ' ').concat(String(I));
  }
  function _(I, R, L) {
    return I.substr(!L || L < 0 ? 0 : +L, R.length) === R;
  }
  function A(I, R, L) {
    return (L === void 0 || L > I.length) && (L = I.length), I.substring(L - R.length, L) === R;
  }
  function E(I, R, L) {
    return typeof L != 'number' && (L = 0), L + R.length > I.length ? !1 : I.indexOf(R, L) !== -1;
  }
  return (
    p('ERR_AMBIGUOUS_ARGUMENT', 'The "%s" argument is ambiguous. %s', TypeError),
    p(
      'ERR_INVALID_ARG_TYPE',
      function (I, R, L) {
        h === void 0 && (h = Ui()), h(typeof I == 'string', "'name' must be a string");
        var D;
        typeof R == 'string' && _(R, 'not ')
          ? ((D = 'must not be'), (R = R.replace(/^not /, '')))
          : (D = 'must be');
        var q;
        if (A(I, ' argument')) q = 'The '.concat(I, ' ').concat(D, ' ').concat(m(R, 'type'));
        else {
          var H = E(I, '.') ? 'property' : 'argument';
          q = 'The "'.concat(I, '" ').concat(H, ' ').concat(D, ' ').concat(m(R, 'type'));
        }
        return (q += '. Received type '.concat(i(L))), q;
      },
      TypeError
    ),
    p(
      'ERR_INVALID_ARG_VALUE',
      function (I, R) {
        var L = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'is invalid';
        y === void 0 && (y = Cn);
        var D = y.inspect(R);
        return (
          D.length > 128 && (D = ''.concat(D.slice(0, 128), '...')),
          "The argument '".concat(I, "' ").concat(L, '. Received ').concat(D)
        );
      },
      TypeError
    ),
    p(
      'ERR_INVALID_RETURN_VALUE',
      function (I, R, L) {
        var D;
        return (
          L && L.constructor && L.constructor.name
            ? (D = 'instance of '.concat(L.constructor.name))
            : (D = 'type '.concat(i(L))),
          'Expected '.concat(I, ' to be returned from the "').concat(R, '"') +
            ' function but got '.concat(D, '.')
        );
      },
      TypeError
    ),
    p(
      'ERR_MISSING_ARGS',
      function () {
        for (var I = arguments.length, R = new Array(I), L = 0; L < I; L++) R[L] = arguments[L];
        h === void 0 && (h = Ui()), h(R.length > 0, 'At least one arg needs to be specified');
        var D = 'The ',
          q = R.length;
        switch (
          ((R = R.map(function (H) {
            return '"'.concat(H, '"');
          })),
          q)
        ) {
          case 1:
            D += ''.concat(R[0], ' argument');
            break;
          case 2:
            D += ''.concat(R[0], ' and ').concat(R[1], ' arguments');
            break;
          default:
            (D += R.slice(0, q - 1).join(', ')), (D += ', and '.concat(R[q - 1], ' arguments'));
            break;
        }
        return ''.concat(D, ' must be specified');
      },
      TypeError
    ),
    (ep.codes = f),
    ep
  );
}
var tp, ew;
function hR() {
  if (ew) return tp;
  ew = 1;
  function i(d) {
    for (var g = 1; g < arguments.length; g++) {
      var w = arguments[g] != null ? arguments[g] : {},
        M = Object.keys(w);
      typeof Object.getOwnPropertySymbols == 'function' &&
        (M = M.concat(
          Object.getOwnPropertySymbols(w).filter(function (v) {
            return Object.getOwnPropertyDescriptor(w, v).enumerable;
          })
        )),
        M.forEach(function (v) {
          e(d, v, w[v]);
        });
    }
    return d;
  }
  function e(d, g, w) {
    return (
      g in d
        ? Object.defineProperty(d, g, { value: w, enumerable: !0, configurable: !0, writable: !0 })
        : (d[g] = w),
      d
    );
  }
  function t(d, g) {
    if (!(d instanceof g)) throw new TypeError('Cannot call a class as a function');
  }
  function r(d, g) {
    for (var w = 0; w < g.length; w++) {
      var M = g[w];
      (M.enumerable = M.enumerable || !1),
        (M.configurable = !0),
        'value' in M && (M.writable = !0),
        Object.defineProperty(d, M.key, M);
    }
  }
  function s(d, g, w) {
    return g && r(d.prototype, g), w && r(d, w), d;
  }
  function n(d, g) {
    return g && (E(g) === 'object' || typeof g == 'function') ? g : c(d);
  }
  function c(d) {
    if (d === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d;
  }
  function f(d, g) {
    if (typeof g != 'function' && g !== null)
      throw new TypeError('Super expression must either be null or a function');
    (d.prototype = Object.create(g && g.prototype, {
      constructor: { value: d, writable: !0, configurable: !0 },
    })),
      g && _(d, g);
  }
  function h(d) {
    var g = typeof Map == 'function' ? new Map() : void 0;
    return (
      (h = function (M) {
        if (M === null || !m(M)) return M;
        if (typeof M != 'function')
          throw new TypeError('Super expression must either be null or a function');
        if (typeof g < 'u') {
          if (g.has(M)) return g.get(M);
          g.set(M, v);
        }
        function v() {
          return p(M, arguments, A(this).constructor);
        }
        return (
          (v.prototype = Object.create(M.prototype, {
            constructor: { value: v, enumerable: !1, writable: !0, configurable: !0 },
          })),
          _(v, M)
        );
      }),
      h(d)
    );
  }
  function y() {
    if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == 'function') return !0;
    try {
      return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;
    } catch {
      return !1;
    }
  }
  function p(d, g, w) {
    return (
      y()
        ? (p = Reflect.construct)
        : (p = function (v, a, b) {
            var k = [null];
            k.push.apply(k, a);
            var B = Function.bind.apply(v, k),
              F = new B();
            return b && _(F, b.prototype), F;
          }),
      p.apply(null, arguments)
    );
  }
  function m(d) {
    return Function.toString.call(d).indexOf('[native code]') !== -1;
  }
  function _(d, g) {
    return (
      (_ =
        Object.setPrototypeOf ||
        function (M, v) {
          return (M.__proto__ = v), M;
        }),
      _(d, g)
    );
  }
  function A(d) {
    return (
      (A = Object.setPrototypeOf
        ? Object.getPrototypeOf
        : function (w) {
            return w.__proto__ || Object.getPrototypeOf(w);
          }),
      A(d)
    );
  }
  function E(d) {
    return (
      typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
        ? (E = function (w) {
            return typeof w;
          })
        : (E = function (w) {
            return w &&
              typeof Symbol == 'function' &&
              w.constructor === Symbol &&
              w !== Symbol.prototype
              ? 'symbol'
              : typeof w;
          }),
      E(d)
    );
  }
  var I = Cn,
    R = I.inspect,
    L = H3(),
    D = L.codes.ERR_INVALID_ARG_TYPE;
  function q(d, g, w) {
    return (w === void 0 || w > d.length) && (w = d.length), d.substring(w - g.length, w) === g;
  }
  function H(d, g) {
    if (((g = Math.floor(g)), d.length == 0 || g == 0)) return '';
    var w = d.length * g;
    for (g = Math.floor(Math.log(g) / Math.log(2)); g; ) (d += d), g--;
    return (d += d.substring(0, w - d.length)), d;
  }
  var V = '',
    te = '',
    ue = '',
    ne = '',
    X = {
      deepStrictEqual: 'Expected values to be strictly deep-equal:',
      strictEqual: 'Expected values to be strictly equal:',
      strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
      deepEqual: 'Expected values to be loosely deep-equal:',
      equal: 'Expected values to be loosely equal:',
      notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
      notStrictEqual: 'Expected "actual" to be strictly unequal to:',
      notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
      notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
      notEqual: 'Expected "actual" to be loosely unequal to:',
      notIdentical: 'Values identical but not reference-equal:',
    },
    Oe = 10;
  function S(d) {
    var g = Object.keys(d),
      w = Object.create(Object.getPrototypeOf(d));
    return (
      g.forEach(function (M) {
        w[M] = d[M];
      }),
      Object.defineProperty(w, 'message', { value: d.message }),
      w
    );
  }
  function o(d) {
    return R(d, {
      compact: !1,
      customInspect: !1,
      depth: 1e3,
      maxArrayLength: 1 / 0,
      showHidden: !1,
      breakLength: 1 / 0,
      showProxy: !1,
      sorted: !0,
      getters: !0,
    });
  }
  function u(d, g, w) {
    var M = '',
      v = '',
      a = 0,
      b = '',
      k = !1,
      B = o(d),
      F = B.split(`
`),
      P = o(g).split(`
`),
      C = 0,
      z = '';
    if (
      (w === 'strictEqual' &&
        E(d) === 'object' &&
        E(g) === 'object' &&
        d !== null &&
        g !== null &&
        (w = 'strictEqualObject'),
      F.length === 1 && P.length === 1 && F[0] !== P[0])
    ) {
      var Y = F[0].length + P[0].length;
      if (Y <= Oe) {
        if (
          (E(d) !== 'object' || d === null) &&
          (E(g) !== 'object' || g === null) &&
          (d !== 0 || g !== 0)
        )
          return (
            ''.concat(
              X[w],
              `

`
            ) +
            ''.concat(F[0], ' !== ').concat(
              P[0],
              `
`
            )
          );
      } else if (w !== 'strictEqualObject') {
        var G = Je.stderr && Je.stderr.isTTY ? Je.stderr.columns : 80;
        if (Y < G) {
          for (; F[0][C] === P[0][C]; ) C++;
          C > 2 &&
            ((z = `
  `.concat(H(' ', C), '^')),
            (C = 0));
        }
      }
    }
    for (
      var Q = F[F.length - 1], U = P[P.length - 1];
      Q === U &&
      (C++ < 2
        ? (b = `
  `
            .concat(Q)
            .concat(b))
        : (M = Q),
      F.pop(),
      P.pop(),
      !(F.length === 0 || P.length === 0));

    )
      (Q = F[F.length - 1]), (U = P[P.length - 1]);
    var $ = Math.max(F.length, P.length);
    if ($ === 0) {
      var Z = B.split(`
`);
      if (Z.length > 30) for (Z[26] = ''.concat(V, '...').concat(ne); Z.length > 27; ) Z.pop();
      return ''
        .concat(
          X.notIdentical,
          `

`
        )
        .concat(
          Z.join(`
`),
          `
`
        );
    }
    C > 3 &&
      ((b = `
`
        .concat(V, '...')
        .concat(ne)
        .concat(b)),
      (k = !0)),
      M !== '' &&
        ((b = `
  `
          .concat(M)
          .concat(b)),
        (M = ''));
    var ae = 0,
      fe =
        X[w] +
        `
`
          .concat(te, '+ actual')
          .concat(ne, ' ')
          .concat(ue, '- expected')
          .concat(ne),
      le = ' '.concat(V, '...').concat(ne, ' Lines skipped');
    for (C = 0; C < $; C++) {
      var Fe = C - a;
      if (F.length < C + 1)
        Fe > 1 &&
          C > 2 &&
          (Fe > 4
            ? ((v += `
`
                .concat(V, '...')
                .concat(ne)),
              (k = !0))
            : Fe > 3 &&
              ((v += `
  `.concat(P[C - 2])),
              ae++),
          (v += `
  `.concat(P[C - 1])),
          ae++),
          (a = C),
          (M += `
`
            .concat(ue, '-')
            .concat(ne, ' ')
            .concat(P[C])),
          ae++;
      else if (P.length < C + 1)
        Fe > 1 &&
          C > 2 &&
          (Fe > 4
            ? ((v += `
`
                .concat(V, '...')
                .concat(ne)),
              (k = !0))
            : Fe > 3 &&
              ((v += `
  `.concat(F[C - 2])),
              ae++),
          (v += `
  `.concat(F[C - 1])),
          ae++),
          (a = C),
          (v += `
`
            .concat(te, '+')
            .concat(ne, ' ')
            .concat(F[C])),
          ae++;
      else {
        var be = P[C],
          oe = F[C],
          rt = oe !== be && (!q(oe, ',') || oe.slice(0, -1) !== be);
        rt && q(be, ',') && be.slice(0, -1) === oe && ((rt = !1), (oe += ',')),
          rt
            ? (Fe > 1 &&
                C > 2 &&
                (Fe > 4
                  ? ((v += `
`
                      .concat(V, '...')
                      .concat(ne)),
                    (k = !0))
                  : Fe > 3 &&
                    ((v += `
  `.concat(F[C - 2])),
                    ae++),
                (v += `
  `.concat(F[C - 1])),
                ae++),
              (a = C),
              (v += `
`
                .concat(te, '+')
                .concat(ne, ' ')
                .concat(oe)),
              (M += `
`
                .concat(ue, '-')
                .concat(ne, ' ')
                .concat(be)),
              (ae += 2))
            : ((v += M),
              (M = ''),
              (Fe === 1 || C === 0) &&
                ((v += `
  `.concat(oe)),
                ae++));
      }
      if (ae > 20 && C < $ - 2)
        return (
          ''
            .concat(fe)
            .concat(
              le,
              `
`
            )
            .concat(
              v,
              `
`
            )
            .concat(V, '...')
            .concat(ne)
            .concat(
              M,
              `
`
            ) + ''.concat(V, '...').concat(ne)
        );
    }
    return ''
      .concat(fe)
      .concat(
        k ? le : '',
        `
`
      )
      .concat(v)
      .concat(M)
      .concat(b)
      .concat(z);
  }
  var l = (function (d) {
    f(g, d);
    function g(w) {
      var M;
      if ((t(this, g), E(w) !== 'object' || w === null)) throw new D('options', 'Object', w);
      var v = w.message,
        a = w.operator,
        b = w.stackStartFn,
        k = w.actual,
        B = w.expected,
        F = Error.stackTraceLimit;
      if (((Error.stackTraceLimit = 0), v != null)) M = n(this, A(g).call(this, String(v)));
      else if (
        (Je.stderr &&
          Je.stderr.isTTY &&
          (Je.stderr && Je.stderr.getColorDepth && Je.stderr.getColorDepth() !== 1
            ? ((V = '\x1B[34m'), (te = '\x1B[32m'), (ne = '\x1B[39m'), (ue = '\x1B[31m'))
            : ((V = ''), (te = ''), (ne = ''), (ue = ''))),
        E(k) === 'object' &&
          k !== null &&
          E(B) === 'object' &&
          B !== null &&
          'stack' in k &&
          k instanceof Error &&
          'stack' in B &&
          B instanceof Error &&
          ((k = S(k)), (B = S(B))),
        a === 'deepStrictEqual' || a === 'strictEqual')
      )
        M = n(this, A(g).call(this, u(k, B, a)));
      else if (a === 'notDeepStrictEqual' || a === 'notStrictEqual') {
        var P = X[a],
          C = o(k).split(`
`);
        if (
          (a === 'notStrictEqual' &&
            E(k) === 'object' &&
            k !== null &&
            (P = X.notStrictEqualObject),
          C.length > 30)
        )
          for (C[26] = ''.concat(V, '...').concat(ne); C.length > 27; ) C.pop();
        C.length === 1
          ? (M = n(this, A(g).call(this, ''.concat(P, ' ').concat(C[0]))))
          : (M = n(
              this,
              A(g).call(
                this,
                ''
                  .concat(
                    P,
                    `

`
                  )
                  .concat(
                    C.join(`
`),
                    `
`
                  )
              )
            ));
      } else {
        var z = o(k),
          Y = '',
          G = X[a];
        a === 'notDeepEqual' || a === 'notEqual'
          ? ((z = ''
              .concat(
                X[a],
                `

`
              )
              .concat(z)),
            z.length > 1024 && (z = ''.concat(z.slice(0, 1021), '...')))
          : ((Y = ''.concat(o(B))),
            z.length > 512 && (z = ''.concat(z.slice(0, 509), '...')),
            Y.length > 512 && (Y = ''.concat(Y.slice(0, 509), '...')),
            a === 'deepEqual' || a === 'equal'
              ? (z = ''
                  .concat(
                    G,
                    `

`
                  )
                  .concat(
                    z,
                    `

should equal

`
                  ))
              : (Y = ' '.concat(a, ' ').concat(Y))),
          (M = n(this, A(g).call(this, ''.concat(z).concat(Y))));
      }
      return (
        (Error.stackTraceLimit = F),
        (M.generatedMessage = !v),
        Object.defineProperty(c(M), 'name', {
          value: 'AssertionError [ERR_ASSERTION]',
          enumerable: !1,
          writable: !0,
          configurable: !0,
        }),
        (M.code = 'ERR_ASSERTION'),
        (M.actual = k),
        (M.expected = B),
        (M.operator = a),
        Error.captureStackTrace && Error.captureStackTrace(c(M), b),
        M.stack,
        (M.name = 'AssertionError'),
        n(M)
      );
    }
    return (
      s(g, [
        {
          key: 'toString',
          value: function () {
            return ''.concat(this.name, ' [').concat(this.code, ']: ').concat(this.message);
          },
        },
        {
          key: R.custom,
          value: function (M, v) {
            return R(this, i({}, v, { customInspect: !1, depth: 0 }));
          },
        },
      ]),
      g
    );
  })(h(Error));
  return (tp = l), tp;
}
var rp, tw;
function dR() {
  if (tw) return rp;
  tw = 1;
  function i(t, r) {
    if (t == null) throw new TypeError('Cannot convert first argument to object');
    for (var s = Object(t), n = 1; n < arguments.length; n++) {
      var c = arguments[n];
      if (c != null)
        for (var f = Object.keys(Object(c)), h = 0, y = f.length; h < y; h++) {
          var p = f[h],
            m = Object.getOwnPropertyDescriptor(c, p);
          m !== void 0 && m.enumerable && (s[p] = c[p]);
        }
    }
    return s;
  }
  function e() {
    Object.assign ||
      Object.defineProperty(Object, 'assign', {
        enumerable: !1,
        configurable: !0,
        writable: !0,
        value: i,
      });
  }
  return (rp = { assign: i, polyfill: e }), rp;
}
var ip, rw;
function V3() {
  if (rw) return ip;
  rw = 1;
  var i = function (e) {
    return e !== e;
  };
  return (
    (ip = function (t, r) {
      return t === 0 && r === 0 ? 1 / t === 1 / r : !!(t === r || (i(t) && i(r)));
    }),
    ip
  );
}
var np, iw;
function G3() {
  if (iw) return np;
  iw = 1;
  var i = V3();
  return (
    (np = function () {
      return typeof Object.is == 'function' ? Object.is : i;
    }),
    np
  );
}
var op, nw;
function pR() {
  if (nw) return op;
  nw = 1;
  var i = G3(),
    e = Kl;
  return (
    (op = function () {
      var r = i();
      return (
        e(
          Object,
          { is: r },
          {
            is: function () {
              return Object.is !== r;
            },
          }
        ),
        r
      );
    }),
    op
  );
}
var sp, ow;
function Y3() {
  if (ow) return sp;
  ow = 1;
  var i = Kl,
    e = K1,
    t = V3(),
    r = G3(),
    s = pR(),
    n = e(r(), Object);
  return i(n, { getPolyfill: r, implementation: t, shim: s }), (sp = n), sp;
}
var ap, sw;
function Z3() {
  return (
    sw ||
      ((sw = 1),
      (ap = function (e) {
        return e !== e;
      })),
    ap
  );
}
var up, aw;
function J3() {
  if (aw) return up;
  aw = 1;
  var i = Z3();
  return (
    (up = function () {
      return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a') ? Number.isNaN : i;
    }),
    up
  );
}
var cp, uw;
function yR() {
  if (uw) return cp;
  uw = 1;
  var i = Kl,
    e = J3();
  return (
    (cp = function () {
      var r = e();
      return (
        i(
          Number,
          { isNaN: r },
          {
            isNaN: function () {
              return Number.isNaN !== r;
            },
          }
        ),
        r
      );
    }),
    cp
  );
}
var fp, cw;
function gR() {
  if (cw) return fp;
  cw = 1;
  var i = K1,
    e = Kl,
    t = Z3(),
    r = J3(),
    s = yR(),
    n = i(r(), Number);
  return e(n, { getPolyfill: r, implementation: t, shim: s }), (fp = n), fp;
}
var lp, fw;
function bR() {
  if (fw) return lp;
  fw = 1;
  function i(re, ge) {
    return r(re) || t(re, ge) || e();
  }
  function e() {
    throw new TypeError('Invalid attempt to destructure non-iterable instance');
  }
  function t(re, ge) {
    var ce = [],
      he = !0,
      Ke = !1,
      K = void 0;
    try {
      for (
        var O = re[Symbol.iterator](), W;
        !(he = (W = O.next()).done) && (ce.push(W.value), !(ge && ce.length === ge));
        he = !0
      );
    } catch (T) {
      (Ke = !0), (K = T);
    } finally {
      try {
        !he && O.return != null && O.return();
      } finally {
        if (Ke) throw K;
      }
    }
    return ce;
  }
  function r(re) {
    if (Array.isArray(re)) return re;
  }
  function s(re) {
    return (
      typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
        ? (s = function (ce) {
            return typeof ce;
          })
        : (s = function (ce) {
            return ce &&
              typeof Symbol == 'function' &&
              ce.constructor === Symbol &&
              ce !== Symbol.prototype
              ? 'symbol'
              : typeof ce;
          }),
      s(re)
    );
  }
  var n = /a/g.flags !== void 0,
    c = function (ge) {
      var ce = [];
      return (
        ge.forEach(function (he) {
          return ce.push(he);
        }),
        ce
      );
    },
    f = function (ge) {
      var ce = [];
      return (
        ge.forEach(function (he, Ke) {
          return ce.push([Ke, he]);
        }),
        ce
      );
    },
    h = Object.is ? Object.is : Y3(),
    y = Object.getOwnPropertySymbols
      ? Object.getOwnPropertySymbols
      : function () {
          return [];
        },
    p = Number.isNaN ? Number.isNaN : gR();
  function m(re) {
    return re.call.bind(re);
  }
  var _ = m(Object.prototype.hasOwnProperty),
    A = m(Object.prototype.propertyIsEnumerable),
    E = m(Object.prototype.toString),
    I = Cn.types,
    R = I.isAnyArrayBuffer,
    L = I.isArrayBufferView,
    D = I.isDate,
    q = I.isMap,
    H = I.isRegExp,
    V = I.isSet,
    te = I.isNativeError,
    ue = I.isBoxedPrimitive,
    ne = I.isNumberObject,
    X = I.isStringObject,
    Oe = I.isBooleanObject,
    S = I.isBigIntObject,
    o = I.isSymbolObject,
    u = I.isFloat32Array,
    l = I.isFloat64Array;
  function d(re) {
    if (re.length === 0 || re.length > 10) return !0;
    for (var ge = 0; ge < re.length; ge++) {
      var ce = re.charCodeAt(ge);
      if (ce < 48 || ce > 57) return !0;
    }
    return re.length === 10 && re >= Math.pow(2, 32);
  }
  function g(re) {
    return Object.keys(re)
      .filter(d)
      .concat(y(re).filter(Object.prototype.propertyIsEnumerable.bind(re)));
  }
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */ function w(re, ge) {
    if (re === ge) return 0;
    for (var ce = re.length, he = ge.length, Ke = 0, K = Math.min(ce, he); Ke < K; ++Ke)
      if (re[Ke] !== ge[Ke]) {
        (ce = re[Ke]), (he = ge[Ke]);
        break;
      }
    return ce < he ? -1 : he < ce ? 1 : 0;
  }
  var M = !0,
    v = !1,
    a = 0,
    b = 1,
    k = 2,
    B = 3;
  function F(re, ge) {
    return n
      ? re.source === ge.source && re.flags === ge.flags
      : RegExp.prototype.toString.call(re) === RegExp.prototype.toString.call(ge);
  }
  function P(re, ge) {
    if (re.byteLength !== ge.byteLength) return !1;
    for (var ce = 0; ce < re.byteLength; ce++) if (re[ce] !== ge[ce]) return !1;
    return !0;
  }
  function C(re, ge) {
    return re.byteLength !== ge.byteLength
      ? !1
      : w(
          new Uint8Array(re.buffer, re.byteOffset, re.byteLength),
          new Uint8Array(ge.buffer, ge.byteOffset, ge.byteLength)
        ) === 0;
  }
  function z(re, ge) {
    return re.byteLength === ge.byteLength && w(new Uint8Array(re), new Uint8Array(ge)) === 0;
  }
  function Y(re, ge) {
    return ne(re)
      ? ne(ge) && h(Number.prototype.valueOf.call(re), Number.prototype.valueOf.call(ge))
      : X(re)
        ? X(ge) && String.prototype.valueOf.call(re) === String.prototype.valueOf.call(ge)
        : Oe(re)
          ? Oe(ge) && Boolean.prototype.valueOf.call(re) === Boolean.prototype.valueOf.call(ge)
          : S(re)
            ? S(ge) && BigInt.prototype.valueOf.call(re) === BigInt.prototype.valueOf.call(ge)
            : o(ge) && Symbol.prototype.valueOf.call(re) === Symbol.prototype.valueOf.call(ge);
  }
  function G(re, ge, ce, he) {
    if (re === ge) return re !== 0 ? !0 : ce ? h(re, ge) : !0;
    if (ce) {
      if (s(re) !== 'object') return typeof re == 'number' && p(re) && p(ge);
      if (
        s(ge) !== 'object' ||
        re === null ||
        ge === null ||
        Object.getPrototypeOf(re) !== Object.getPrototypeOf(ge)
      )
        return !1;
    } else {
      if (re === null || s(re) !== 'object')
        return ge === null || s(ge) !== 'object' ? re == ge : !1;
      if (ge === null || s(ge) !== 'object') return !1;
    }
    var Ke = E(re),
      K = E(ge);
    if (Ke !== K) return !1;
    if (Array.isArray(re)) {
      if (re.length !== ge.length) return !1;
      var O = g(re),
        W = g(ge);
      return O.length !== W.length ? !1 : U(re, ge, ce, he, b, O);
    }
    if (Ke === '[object Object]' && ((!q(re) && q(ge)) || (!V(re) && V(ge)))) return !1;
    if (D(re)) {
      if (!D(ge) || Date.prototype.getTime.call(re) !== Date.prototype.getTime.call(ge)) return !1;
    } else if (H(re)) {
      if (!H(ge) || !F(re, ge)) return !1;
    } else if (te(re) || re instanceof Error) {
      if (re.message !== ge.message || re.name !== ge.name) return !1;
    } else if (L(re)) {
      if (!ce && (u(re) || l(re))) {
        if (!P(re, ge)) return !1;
      } else if (!C(re, ge)) return !1;
      var T = g(re),
        x = g(ge);
      return T.length !== x.length ? !1 : U(re, ge, ce, he, a, T);
    } else {
      if (V(re)) return !V(ge) || re.size !== ge.size ? !1 : U(re, ge, ce, he, k);
      if (q(re)) return !q(ge) || re.size !== ge.size ? !1 : U(re, ge, ce, he, B);
      if (R(re)) {
        if (!z(re, ge)) return !1;
      } else if (ue(re) && !Y(re, ge)) return !1;
    }
    return U(re, ge, ce, he, a);
  }
  function Q(re, ge) {
    return ge.filter(function (ce) {
      return A(re, ce);
    });
  }
  function U(re, ge, ce, he, Ke, K) {
    if (arguments.length === 5) {
      K = Object.keys(re);
      var O = Object.keys(ge);
      if (K.length !== O.length) return !1;
    }
    for (var W = 0; W < K.length; W++) if (!_(ge, K[W])) return !1;
    if (ce && arguments.length === 5) {
      var T = y(re);
      if (T.length !== 0) {
        var x = 0;
        for (W = 0; W < T.length; W++) {
          var N = T[W];
          if (A(re, N)) {
            if (!A(ge, N)) return !1;
            K.push(N), x++;
          } else if (A(ge, N)) return !1;
        }
        var j = y(ge);
        if (T.length !== j.length && Q(ge, j).length !== x) return !1;
      } else {
        var J = y(ge);
        if (J.length !== 0 && Q(ge, J).length !== 0) return !1;
      }
    }
    if (K.length === 0 && (Ke === a || (Ke === b && re.length === 0) || re.size === 0)) return !0;
    if (he === void 0) he = { val1: new Map(), val2: new Map(), position: 0 };
    else {
      var de = he.val1.get(re);
      if (de !== void 0) {
        var ie = he.val2.get(ge);
        if (ie !== void 0) return de === ie;
      }
      he.position++;
    }
    he.val1.set(re, he.position), he.val2.set(ge, he.position);
    var ye = oe(re, ge, ce, K, he, Ke);
    return he.val1.delete(re), he.val2.delete(ge), ye;
  }
  function $(re, ge, ce, he) {
    for (var Ke = c(re), K = 0; K < Ke.length; K++) {
      var O = Ke[K];
      if (G(ge, O, ce, he)) return re.delete(O), !0;
    }
    return !1;
  }
  function Z(re) {
    switch (s(re)) {
      case 'undefined':
        return null;
      case 'object':
        return;
      case 'symbol':
        return !1;
      case 'string':
        re = +re;
      case 'number':
        if (p(re)) return !1;
    }
    return !0;
  }
  function ae(re, ge, ce) {
    var he = Z(ce);
    return he ?? (ge.has(he) && !re.has(he));
  }
  function fe(re, ge, ce, he, Ke) {
    var K = Z(ce);
    if (K != null) return K;
    var O = ge.get(K);
    return (O === void 0 && !ge.has(K)) || !G(he, O, !1, Ke) ? !1 : !re.has(K) && G(he, O, !1, Ke);
  }
  function le(re, ge, ce, he) {
    for (var Ke = null, K = c(re), O = 0; O < K.length; O++) {
      var W = K[O];
      if (s(W) === 'object' && W !== null) Ke === null && (Ke = new Set()), Ke.add(W);
      else if (!ge.has(W)) {
        if (ce || !ae(re, ge, W)) return !1;
        Ke === null && (Ke = new Set()), Ke.add(W);
      }
    }
    if (Ke !== null) {
      for (var T = c(ge), x = 0; x < T.length; x++) {
        var N = T[x];
        if (s(N) === 'object' && N !== null) {
          if (!$(Ke, N, ce, he)) return !1;
        } else if (!ce && !re.has(N) && !$(Ke, N, ce, he)) return !1;
      }
      return Ke.size === 0;
    }
    return !0;
  }
  function Fe(re, ge, ce, he, Ke, K) {
    for (var O = c(re), W = 0; W < O.length; W++) {
      var T = O[W];
      if (G(ce, T, Ke, K) && G(he, ge.get(T), Ke, K)) return re.delete(T), !0;
    }
    return !1;
  }
  function be(re, ge, ce, he) {
    for (var Ke = null, K = f(re), O = 0; O < K.length; O++) {
      var W = i(K[O], 2),
        T = W[0],
        x = W[1];
      if (s(T) === 'object' && T !== null) Ke === null && (Ke = new Set()), Ke.add(T);
      else {
        var N = ge.get(T);
        if ((N === void 0 && !ge.has(T)) || !G(x, N, ce, he)) {
          if (ce || !fe(re, ge, T, x, he)) return !1;
          Ke === null && (Ke = new Set()), Ke.add(T);
        }
      }
    }
    if (Ke !== null) {
      for (var j = f(ge), J = 0; J < j.length; J++) {
        var de = i(j[J], 2),
          T = de[0],
          ie = de[1];
        if (s(T) === 'object' && T !== null) {
          if (!Fe(Ke, re, T, ie, ce, he)) return !1;
        } else if (!ce && (!re.has(T) || !G(re.get(T), ie, !1, he)) && !Fe(Ke, re, T, ie, !1, he))
          return !1;
      }
      return Ke.size === 0;
    }
    return !0;
  }
  function oe(re, ge, ce, he, Ke, K) {
    var O = 0;
    if (K === k) {
      if (!le(re, ge, ce, Ke)) return !1;
    } else if (K === B) {
      if (!be(re, ge, ce, Ke)) return !1;
    } else if (K === b)
      for (; O < re.length; O++)
        if (_(re, O)) {
          if (!_(ge, O) || !G(re[O], ge[O], ce, Ke)) return !1;
        } else {
          if (_(ge, O)) return !1;
          for (var W = Object.keys(re); O < W.length; O++) {
            var T = W[O];
            if (!_(ge, T) || !G(re[T], ge[T], ce, Ke)) return !1;
          }
          return W.length === Object.keys(ge).length;
        }
    for (O = 0; O < he.length; O++) {
      var x = he[O];
      if (!G(re[x], ge[x], ce, Ke)) return !1;
    }
    return !0;
  }
  function rt(re, ge) {
    return G(re, ge, v);
  }
  function me(re, ge) {
    return G(re, ge, M);
  }
  return (lp = { isDeepEqual: rt, isDeepStrictEqual: me }), lp;
}
var lw;
function Ui() {
  if (lw) return Q0.exports;
  lw = 1;
  function i(b) {
    return (
      typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
        ? (i = function (B) {
            return typeof B;
          })
        : (i = function (B) {
            return B &&
              typeof Symbol == 'function' &&
              B.constructor === Symbol &&
              B !== Symbol.prototype
              ? 'symbol'
              : typeof B;
          }),
      i(b)
    );
  }
  function e(b, k) {
    if (!(b instanceof k)) throw new TypeError('Cannot call a class as a function');
  }
  var t = H3(),
    r = t.codes,
    s = r.ERR_AMBIGUOUS_ARGUMENT,
    n = r.ERR_INVALID_ARG_TYPE,
    c = r.ERR_INVALID_ARG_VALUE,
    f = r.ERR_INVALID_RETURN_VALUE,
    h = r.ERR_MISSING_ARGS,
    y = hR(),
    p = Cn,
    m = p.inspect,
    _ = Cn.types,
    A = _.isPromise,
    E = _.isRegExp,
    I = Object.assign ? Object.assign : dR().assign,
    R = Object.is ? Object.is : Y3(),
    L,
    D;
  function q() {
    var b = bR();
    (L = b.isDeepEqual), (D = b.isDeepStrictEqual);
  }
  var H = !1,
    V = (Q0.exports = Oe),
    te = {};
  function ue(b) {
    throw b.message instanceof Error ? b.message : new y(b);
  }
  function ne(b, k, B, F, P) {
    var C = arguments.length,
      z;
    if (C === 0) z = 'Failed';
    else if (C === 1) (B = b), (b = void 0);
    else {
      if (H === !1) {
        H = !0;
        var Y = Je.emitWarning ? Je.emitWarning : console.warn.bind(console);
        Y(
          'assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.',
          'DeprecationWarning',
          'DEP0094'
        );
      }
      C === 2 && (F = '!=');
    }
    if (B instanceof Error) throw B;
    var G = { actual: b, expected: k, operator: F === void 0 ? 'fail' : F, stackStartFn: P || ne };
    B !== void 0 && (G.message = B);
    var Q = new y(G);
    throw (z && ((Q.message = z), (Q.generatedMessage = !0)), Q);
  }
  (V.fail = ne), (V.AssertionError = y);
  function X(b, k, B, F) {
    if (!B) {
      var P = !1;
      if (k === 0) (P = !0), (F = 'No value argument passed to `assert.ok()`');
      else if (F instanceof Error) throw F;
      var C = new y({ actual: B, expected: !0, message: F, operator: '==', stackStartFn: b });
      throw ((C.generatedMessage = P), C);
    }
  }
  function Oe() {
    for (var b = arguments.length, k = new Array(b), B = 0; B < b; B++) k[B] = arguments[B];
    X.apply(void 0, [Oe, k.length].concat(k));
  }
  (V.ok = Oe),
    (V.equal = function b(k, B, F) {
      if (arguments.length < 2) throw new h('actual', 'expected');
      k != B && ue({ actual: k, expected: B, message: F, operator: '==', stackStartFn: b });
    }),
    (V.notEqual = function b(k, B, F) {
      if (arguments.length < 2) throw new h('actual', 'expected');
      k == B && ue({ actual: k, expected: B, message: F, operator: '!=', stackStartFn: b });
    }),
    (V.deepEqual = function b(k, B, F) {
      if (arguments.length < 2) throw new h('actual', 'expected');
      L === void 0 && q(),
        L(k, B) ||
          ue({ actual: k, expected: B, message: F, operator: 'deepEqual', stackStartFn: b });
    }),
    (V.notDeepEqual = function b(k, B, F) {
      if (arguments.length < 2) throw new h('actual', 'expected');
      L === void 0 && q(),
        L(k, B) &&
          ue({ actual: k, expected: B, message: F, operator: 'notDeepEqual', stackStartFn: b });
    }),
    (V.deepStrictEqual = function b(k, B, F) {
      if (arguments.length < 2) throw new h('actual', 'expected');
      L === void 0 && q(),
        D(k, B) ||
          ue({ actual: k, expected: B, message: F, operator: 'deepStrictEqual', stackStartFn: b });
    }),
    (V.notDeepStrictEqual = S);
  function S(b, k, B) {
    if (arguments.length < 2) throw new h('actual', 'expected');
    L === void 0 && q(),
      D(b, k) &&
        ue({ actual: b, expected: k, message: B, operator: 'notDeepStrictEqual', stackStartFn: S });
  }
  (V.strictEqual = function b(k, B, F) {
    if (arguments.length < 2) throw new h('actual', 'expected');
    R(k, B) || ue({ actual: k, expected: B, message: F, operator: 'strictEqual', stackStartFn: b });
  }),
    (V.notStrictEqual = function b(k, B, F) {
      if (arguments.length < 2) throw new h('actual', 'expected');
      R(k, B) &&
        ue({ actual: k, expected: B, message: F, operator: 'notStrictEqual', stackStartFn: b });
    });
  var o = function b(k, B, F) {
    var P = this;
    e(this, b),
      B.forEach(function (C) {
        C in k &&
          (F !== void 0 && typeof F[C] == 'string' && E(k[C]) && k[C].test(F[C])
            ? (P[C] = F[C])
            : (P[C] = k[C]));
      });
  };
  function u(b, k, B, F, P, C) {
    if (!(B in b) || !D(b[B], k[B])) {
      if (!F) {
        var z = new o(b, P),
          Y = new o(k, P, b),
          G = new y({ actual: z, expected: Y, operator: 'deepStrictEqual', stackStartFn: C });
        throw ((G.actual = b), (G.expected = k), (G.operator = C.name), G);
      }
      ue({ actual: b, expected: k, message: F, operator: C.name, stackStartFn: C });
    }
  }
  function l(b, k, B, F) {
    if (typeof k != 'function') {
      if (E(k)) return k.test(b);
      if (arguments.length === 2) throw new n('expected', ['Function', 'RegExp'], k);
      if (i(b) !== 'object' || b === null) {
        var P = new y({
          actual: b,
          expected: k,
          message: B,
          operator: 'deepStrictEqual',
          stackStartFn: F,
        });
        throw ((P.operator = F.name), P);
      }
      var C = Object.keys(k);
      if (k instanceof Error) C.push('name', 'message');
      else if (C.length === 0) throw new c('error', k, 'may not be an empty object');
      return (
        L === void 0 && q(),
        C.forEach(function (z) {
          (typeof b[z] == 'string' && E(k[z]) && k[z].test(b[z])) || u(b, k, z, B, C, F);
        }),
        !0
      );
    }
    return k.prototype !== void 0 && b instanceof k
      ? !0
      : Error.isPrototypeOf(k)
        ? !1
        : k.call({}, b) === !0;
  }
  function d(b) {
    if (typeof b != 'function') throw new n('fn', 'Function', b);
    try {
      b();
    } catch (k) {
      return k;
    }
    return te;
  }
  function g(b) {
    return (
      A(b) ||
      (b !== null &&
        i(b) === 'object' &&
        typeof b.then == 'function' &&
        typeof b.catch == 'function')
    );
  }
  function w(b) {
    return Promise.resolve().then(function () {
      var k;
      if (typeof b == 'function') {
        if (((k = b()), !g(k))) throw new f('instance of Promise', 'promiseFn', k);
      } else if (g(b)) k = b;
      else throw new n('promiseFn', ['Function', 'Promise'], b);
      return Promise.resolve()
        .then(function () {
          return k;
        })
        .then(function () {
          return te;
        })
        .catch(function (B) {
          return B;
        });
    });
  }
  function M(b, k, B, F) {
    if (typeof B == 'string') {
      if (arguments.length === 4)
        throw new n('error', ['Object', 'Error', 'Function', 'RegExp'], B);
      if (i(k) === 'object' && k !== null) {
        if (k.message === B)
          throw new s(
            'error/message',
            'The error message "'.concat(k.message, '" is identical to the message.')
          );
      } else if (k === B)
        throw new s('error/message', 'The error "'.concat(k, '" is identical to the message.'));
      (F = B), (B = void 0);
    } else if (B != null && i(B) !== 'object' && typeof B != 'function')
      throw new n('error', ['Object', 'Error', 'Function', 'RegExp'], B);
    if (k === te) {
      var P = '';
      B && B.name && (P += ' ('.concat(B.name, ')')), (P += F ? ': '.concat(F) : '.');
      var C = b.name === 'rejects' ? 'rejection' : 'exception';
      ue({
        actual: void 0,
        expected: B,
        operator: b.name,
        message: 'Missing expected '.concat(C).concat(P),
        stackStartFn: b,
      });
    }
    if (B && !l(k, B, F, b)) throw k;
  }
  function v(b, k, B, F) {
    if (k !== te) {
      if ((typeof B == 'string' && ((F = B), (B = void 0)), !B || l(k, B))) {
        var P = F ? ': '.concat(F) : '.',
          C = b.name === 'doesNotReject' ? 'rejection' : 'exception';
        ue({
          actual: k,
          expected: B,
          operator: b.name,
          message:
            'Got unwanted '.concat(C).concat(
              P,
              `
`
            ) + 'Actual message: "'.concat(k && k.message, '"'),
          stackStartFn: b,
        });
      }
      throw k;
    }
  }
  (V.throws = function b(k) {
    for (var B = arguments.length, F = new Array(B > 1 ? B - 1 : 0), P = 1; P < B; P++)
      F[P - 1] = arguments[P];
    M.apply(void 0, [b, d(k)].concat(F));
  }),
    (V.rejects = function b(k) {
      for (var B = arguments.length, F = new Array(B > 1 ? B - 1 : 0), P = 1; P < B; P++)
        F[P - 1] = arguments[P];
      return w(k).then(function (C) {
        return M.apply(void 0, [b, C].concat(F));
      });
    }),
    (V.doesNotThrow = function b(k) {
      for (var B = arguments.length, F = new Array(B > 1 ? B - 1 : 0), P = 1; P < B; P++)
        F[P - 1] = arguments[P];
      v.apply(void 0, [b, d(k)].concat(F));
    }),
    (V.doesNotReject = function b(k) {
      for (var B = arguments.length, F = new Array(B > 1 ? B - 1 : 0), P = 1; P < B; P++)
        F[P - 1] = arguments[P];
      return w(k).then(function (C) {
        return v.apply(void 0, [b, C].concat(F));
      });
    }),
    (V.ifError = function b(k) {
      if (k != null) {
        var B = 'ifError got unwanted exception: ';
        i(k) === 'object' && typeof k.message == 'string'
          ? k.message.length === 0 && k.constructor
            ? (B += k.constructor.name)
            : (B += k.message)
          : (B += m(k));
        var F = new y({
            actual: k,
            expected: null,
            operator: 'ifError',
            message: B,
            stackStartFn: b,
          }),
          P = k.stack;
        if (typeof P == 'string') {
          var C = P.split(`
`);
          C.shift();
          for (
            var z = F.stack.split(`
`),
              Y = 0;
            Y < C.length;
            Y++
          ) {
            var G = z.indexOf(C[Y]);
            if (G !== -1) {
              z = z.slice(0, G);
              break;
            }
          }
          F.stack = ''
            .concat(
              z.join(`
`),
              `
`
            )
            .concat(
              C.join(`
`)
            );
        }
        throw F;
      }
    });
  function a() {
    for (var b = arguments.length, k = new Array(b), B = 0; B < b; B++) k[B] = arguments[B];
    X.apply(void 0, [a, k.length].concat(k));
  }
  return (
    (V.strict = I(a, V, {
      equal: V.strictEqual,
      deepEqual: V.deepStrictEqual,
      notEqual: V.notStrictEqual,
      notDeepEqual: V.notDeepStrictEqual,
    })),
    (V.strict.strict = V.strict),
    Q0.exports
  );
}
var vR = {},
  Nu = {};
function i1(i) {
  if (!Number.isSafeInteger(i) || i < 0) throw new Error(`Wrong positive integer: ${i}`);
}
function mR(i) {
  if (typeof i != 'boolean') throw new Error(`Expected boolean, not ${i}`);
}
function X3(i, ...e) {
  if (!(i instanceof Uint8Array)) throw new TypeError('Expected Uint8Array');
  if (e.length > 0 && !e.includes(i.length))
    throw new TypeError(`Expected Uint8Array of length ${e}, not of length=${i.length}`);
}
function wR(i) {
  if (typeof i != 'function' || typeof i.create != 'function')
    throw new Error('Hash should be wrapped by utils.wrapConstructor');
  i1(i.outputLen), i1(i.blockLen);
}
function _R(i, e = !0) {
  if (i.destroyed) throw new Error('Hash instance has been destroyed');
  if (e && i.finished) throw new Error('Hash#digest() has already been called');
}
function SR(i, e) {
  X3(i);
  const t = e.outputLen;
  if (i.length < t) throw new Error(`digestInto() expects output buffer of length at least ${t}`);
}
const Ci = { number: i1, bool: mR, bytes: X3, hash: wR, exists: _R, output: SR };
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const MR = (i) =>
    new Uint32Array(i.buffer, i.byteOffset, Math.floor(i.byteLength / 4)),
  hp = (i) => new DataView(i.buffer, i.byteOffset, i.byteLength),
  bn = (i, e) => (i << (32 - e)) | (i >>> e),
  AR = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!AR) throw new Error('Non little-endian hardware is not supported');
Array.from({ length: 256 }, (i, e) => e.toString(16).padStart(2, '0'));
function ER(i) {
  if (typeof i != 'string') throw new TypeError(`utf8ToBytes expected string, got ${typeof i}`);
  return new TextEncoder().encode(i);
}
function uc(i) {
  if ((typeof i == 'string' && (i = ER(i)), !(i instanceof Uint8Array)))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof i})`);
  return i;
}
let $y = class {
  clone() {
    return this._cloneInto();
  }
};
function Ps(i) {
  const e = (r) => i().update(uc(r)).digest(),
    t = i();
  return (e.outputLen = t.outputLen), (e.blockLen = t.blockLen), (e.create = () => i()), e;
}
function kR(i) {
  const e = (r, s) => i(s).update(uc(r)).digest(),
    t = i({});
  return (e.outputLen = t.outputLen), (e.blockLen = t.blockLen), (e.create = (r) => i(r)), e;
}
function IR(i, e, t, r) {
  if (typeof i.setBigUint64 == 'function') return i.setBigUint64(e, t, r);
  const s = BigInt(32),
    n = BigInt(4294967295),
    c = Number((t >> s) & n),
    f = Number(t & n),
    h = r ? 4 : 0,
    y = r ? 0 : 4;
  i.setUint32(e + h, c, r), i.setUint32(e + y, f, r);
}
let Q3 = class extends $y {
  constructor(e, t, r, s) {
    super(),
      (this.blockLen = e),
      (this.outputLen = t),
      (this.padOffset = r),
      (this.isLE = s),
      (this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.buffer = new Uint8Array(e)),
      (this.view = hp(this.buffer));
  }
  update(e) {
    Ci.exists(this);
    const { view: t, buffer: r, blockLen: s } = this;
    e = uc(e);
    const n = e.length;
    for (let c = 0; c < n; ) {
      const f = Math.min(s - this.pos, n - c);
      if (f === s) {
        const h = hp(e);
        for (; s <= n - c; c += s) this.process(h, c);
        continue;
      }
      r.set(e.subarray(c, c + f), this.pos),
        (this.pos += f),
        (c += f),
        this.pos === s && (this.process(t, 0), (this.pos = 0));
    }
    return (this.length += e.length), this.roundClean(), this;
  }
  digestInto(e) {
    Ci.exists(this), Ci.output(e, this), (this.finished = !0);
    const { buffer: t, view: r, blockLen: s, isLE: n } = this;
    let { pos: c } = this;
    (t[c++] = 128),
      this.buffer.subarray(c).fill(0),
      this.padOffset > s - c && (this.process(r, 0), (c = 0));
    for (let m = c; m < s; m++) t[m] = 0;
    IR(r, s - 8, BigInt(this.length * 8), n), this.process(r, 0);
    const f = hp(e),
      h = this.outputLen;
    if (h % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
    const y = h / 4,
      p = this.get();
    if (y > p.length) throw new Error('_sha2: outputLen bigger than state');
    for (let m = 0; m < y; m++) f.setUint32(4 * m, p[m], n);
  }
  digest() {
    const { buffer: e, outputLen: t } = this;
    this.digestInto(e);
    const r = e.slice(0, t);
    return this.destroy(), r;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: t, buffer: r, length: s, finished: n, destroyed: c, pos: f } = this;
    return (
      (e.length = s), (e.pos = f), (e.finished = n), (e.destroyed = c), s % t && e.buffer.set(r), e
    );
  }
};
const nf = BigInt(2 ** 32 - 1),
  n1 = BigInt(32);
function e_(i, e = !1) {
  return e
    ? { h: Number(i & nf), l: Number((i >> n1) & nf) }
    : { h: Number((i >> n1) & nf) | 0, l: Number(i & nf) | 0 };
}
function xR(i, e = !1) {
  let t = new Uint32Array(i.length),
    r = new Uint32Array(i.length);
  for (let s = 0; s < i.length; s++) {
    const { h: n, l: c } = e_(i[s], e);
    [t[s], r[s]] = [n, c];
  }
  return [t, r];
}
const BR = (i, e) => (BigInt(i >>> 0) << n1) | BigInt(e >>> 0),
  RR = (i, e, t) => i >>> t,
  PR = (i, e, t) => (i << (32 - t)) | (e >>> t),
  TR = (i, e, t) => (i >>> t) | (e << (32 - t)),
  OR = (i, e, t) => (i << (32 - t)) | (e >>> t),
  CR = (i, e, t) => (i << (64 - t)) | (e >>> (t - 32)),
  LR = (i, e, t) => (i >>> (t - 32)) | (e << (64 - t)),
  NR = (i, e) => e,
  $R = (i, e) => i,
  DR = (i, e, t) => (i << t) | (e >>> (32 - t)),
  UR = (i, e, t) => (e << t) | (i >>> (32 - t)),
  zR = (i, e, t) => (e << (t - 32)) | (i >>> (64 - t)),
  FR = (i, e, t) => (i << (t - 32)) | (e >>> (64 - t));
function qR(i, e, t, r) {
  const s = (e >>> 0) + (r >>> 0);
  return { h: (i + t + ((s / 2 ** 32) | 0)) | 0, l: s | 0 };
}
const WR = (i, e, t) => (i >>> 0) + (e >>> 0) + (t >>> 0),
  KR = (i, e, t, r) => (e + t + r + ((i / 2 ** 32) | 0)) | 0,
  jR = (i, e, t, r) => (i >>> 0) + (e >>> 0) + (t >>> 0) + (r >>> 0),
  HR = (i, e, t, r, s) => (e + t + r + s + ((i / 2 ** 32) | 0)) | 0,
  VR = (i, e, t, r, s) => (i >>> 0) + (e >>> 0) + (t >>> 0) + (r >>> 0) + (s >>> 0),
  GR = (i, e, t, r, s, n) => (e + t + r + s + n + ((i / 2 ** 32) | 0)) | 0,
  lt = {
    fromBig: e_,
    split: xR,
    toBig: BR,
    shrSH: RR,
    shrSL: PR,
    rotrSH: TR,
    rotrSL: OR,
    rotrBH: CR,
    rotrBL: LR,
    rotr32H: NR,
    rotr32L: $R,
    rotlSH: DR,
    rotlSL: UR,
    rotlBH: zR,
    rotlBL: FR,
    add: qR,
    add3L: WR,
    add3H: KR,
    add4L: jR,
    add4H: HR,
    add5H: GR,
    add5L: VR,
  },
  [YR, ZR] = lt.split(
    [
      '0x428a2f98d728ae22',
      '0x7137449123ef65cd',
      '0xb5c0fbcfec4d3b2f',
      '0xe9b5dba58189dbbc',
      '0x3956c25bf348b538',
      '0x59f111f1b605d019',
      '0x923f82a4af194f9b',
      '0xab1c5ed5da6d8118',
      '0xd807aa98a3030242',
      '0x12835b0145706fbe',
      '0x243185be4ee4b28c',
      '0x550c7dc3d5ffb4e2',
      '0x72be5d74f27b896f',
      '0x80deb1fe3b1696b1',
      '0x9bdc06a725c71235',
      '0xc19bf174cf692694',
      '0xe49b69c19ef14ad2',
      '0xefbe4786384f25e3',
      '0x0fc19dc68b8cd5b5',
      '0x240ca1cc77ac9c65',
      '0x2de92c6f592b0275',
      '0x4a7484aa6ea6e483',
      '0x5cb0a9dcbd41fbd4',
      '0x76f988da831153b5',
      '0x983e5152ee66dfab',
      '0xa831c66d2db43210',
      '0xb00327c898fb213f',
      '0xbf597fc7beef0ee4',
      '0xc6e00bf33da88fc2',
      '0xd5a79147930aa725',
      '0x06ca6351e003826f',
      '0x142929670a0e6e70',
      '0x27b70a8546d22ffc',
      '0x2e1b21385c26c926',
      '0x4d2c6dfc5ac42aed',
      '0x53380d139d95b3df',
      '0x650a73548baf63de',
      '0x766a0abb3c77b2a8',
      '0x81c2c92e47edaee6',
      '0x92722c851482353b',
      '0xa2bfe8a14cf10364',
      '0xa81a664bbc423001',
      '0xc24b8b70d0f89791',
      '0xc76c51a30654be30',
      '0xd192e819d6ef5218',
      '0xd69906245565a910',
      '0xf40e35855771202a',
      '0x106aa07032bbd1b8',
      '0x19a4c116b8d2d0c8',
      '0x1e376c085141ab53',
      '0x2748774cdf8eeb99',
      '0x34b0bcb5e19b48a8',
      '0x391c0cb3c5c95a63',
      '0x4ed8aa4ae3418acb',
      '0x5b9cca4f7763e373',
      '0x682e6ff3d6b2b8a3',
      '0x748f82ee5defb2fc',
      '0x78a5636f43172f60',
      '0x84c87814a1f0ab72',
      '0x8cc702081a6439ec',
      '0x90befffa23631e28',
      '0xa4506cebde82bde9',
      '0xbef9a3f7b2c67915',
      '0xc67178f2e372532b',
      '0xca273eceea26619c',
      '0xd186b8c721c0c207',
      '0xeada7dd6cde0eb1e',
      '0xf57d4f7fee6ed178',
      '0x06f067aa72176fba',
      '0x0a637dc5a2c898a6',
      '0x113f9804bef90dae',
      '0x1b710b35131c471b',
      '0x28db77f523047d84',
      '0x32caab7b40c72493',
      '0x3c9ebe0a15c9bebc',
      '0x431d67c49c100d4c',
      '0x4cc5d4becb3e42b6',
      '0x597f299cfc657e2a',
      '0x5fcb6fab3ad6faec',
      '0x6c44198c4a475817',
    ].map((i) => BigInt(i))
  ),
  ho = new Uint32Array(80),
  po = new Uint32Array(80);
let jl = class extends Q3 {
    constructor() {
      super(128, 64, 16, !1),
        (this.Ah = 1779033703),
        (this.Al = -205731576),
        (this.Bh = -1150833019),
        (this.Bl = -2067093701),
        (this.Ch = 1013904242),
        (this.Cl = -23791573),
        (this.Dh = -1521486534),
        (this.Dl = 1595750129),
        (this.Eh = 1359893119),
        (this.El = -1377402159),
        (this.Fh = -1694144372),
        (this.Fl = 725511199),
        (this.Gh = 528734635),
        (this.Gl = -79577749),
        (this.Hh = 1541459225),
        (this.Hl = 327033209);
    }
    get() {
      const {
        Ah: e,
        Al: t,
        Bh: r,
        Bl: s,
        Ch: n,
        Cl: c,
        Dh: f,
        Dl: h,
        Eh: y,
        El: p,
        Fh: m,
        Fl: _,
        Gh: A,
        Gl: E,
        Hh: I,
        Hl: R,
      } = this;
      return [e, t, r, s, n, c, f, h, y, p, m, _, A, E, I, R];
    }
    set(e, t, r, s, n, c, f, h, y, p, m, _, A, E, I, R) {
      (this.Ah = e | 0),
        (this.Al = t | 0),
        (this.Bh = r | 0),
        (this.Bl = s | 0),
        (this.Ch = n | 0),
        (this.Cl = c | 0),
        (this.Dh = f | 0),
        (this.Dl = h | 0),
        (this.Eh = y | 0),
        (this.El = p | 0),
        (this.Fh = m | 0),
        (this.Fl = _ | 0),
        (this.Gh = A | 0),
        (this.Gl = E | 0),
        (this.Hh = I | 0),
        (this.Hl = R | 0);
    }
    process(e, t) {
      for (let q = 0; q < 16; q++, t += 4)
        (ho[q] = e.getUint32(t)), (po[q] = e.getUint32((t += 4)));
      for (let q = 16; q < 80; q++) {
        const H = ho[q - 15] | 0,
          V = po[q - 15] | 0,
          te = lt.rotrSH(H, V, 1) ^ lt.rotrSH(H, V, 8) ^ lt.shrSH(H, V, 7),
          ue = lt.rotrSL(H, V, 1) ^ lt.rotrSL(H, V, 8) ^ lt.shrSL(H, V, 7),
          ne = ho[q - 2] | 0,
          X = po[q - 2] | 0,
          Oe = lt.rotrSH(ne, X, 19) ^ lt.rotrBH(ne, X, 61) ^ lt.shrSH(ne, X, 6),
          S = lt.rotrSL(ne, X, 19) ^ lt.rotrBL(ne, X, 61) ^ lt.shrSL(ne, X, 6),
          o = lt.add4L(ue, S, po[q - 7], po[q - 16]),
          u = lt.add4H(o, te, Oe, ho[q - 7], ho[q - 16]);
        (ho[q] = u | 0), (po[q] = o | 0);
      }
      let {
        Ah: r,
        Al: s,
        Bh: n,
        Bl: c,
        Ch: f,
        Cl: h,
        Dh: y,
        Dl: p,
        Eh: m,
        El: _,
        Fh: A,
        Fl: E,
        Gh: I,
        Gl: R,
        Hh: L,
        Hl: D,
      } = this;
      for (let q = 0; q < 80; q++) {
        const H = lt.rotrSH(m, _, 14) ^ lt.rotrSH(m, _, 18) ^ lt.rotrBH(m, _, 41),
          V = lt.rotrSL(m, _, 14) ^ lt.rotrSL(m, _, 18) ^ lt.rotrBL(m, _, 41),
          te = (m & A) ^ (~m & I),
          ue = (_ & E) ^ (~_ & R),
          ne = lt.add5L(D, V, ue, ZR[q], po[q]),
          X = lt.add5H(ne, L, H, te, YR[q], ho[q]),
          Oe = ne | 0,
          S = lt.rotrSH(r, s, 28) ^ lt.rotrBH(r, s, 34) ^ lt.rotrBH(r, s, 39),
          o = lt.rotrSL(r, s, 28) ^ lt.rotrBL(r, s, 34) ^ lt.rotrBL(r, s, 39),
          u = (r & n) ^ (r & f) ^ (n & f),
          l = (s & c) ^ (s & h) ^ (c & h);
        (L = I | 0),
          (D = R | 0),
          (I = A | 0),
          (R = E | 0),
          (A = m | 0),
          (E = _ | 0),
          ({ h: m, l: _ } = lt.add(y | 0, p | 0, X | 0, Oe | 0)),
          (y = f | 0),
          (p = h | 0),
          (f = n | 0),
          (h = c | 0),
          (n = r | 0),
          (c = s | 0);
        const d = lt.add3L(Oe, o, l);
        (r = lt.add3H(d, X, S, u)), (s = d | 0);
      }
      ({ h: r, l: s } = lt.add(this.Ah | 0, this.Al | 0, r | 0, s | 0)),
        ({ h: n, l: c } = lt.add(this.Bh | 0, this.Bl | 0, n | 0, c | 0)),
        ({ h: f, l: h } = lt.add(this.Ch | 0, this.Cl | 0, f | 0, h | 0)),
        ({ h: y, l: p } = lt.add(this.Dh | 0, this.Dl | 0, y | 0, p | 0)),
        ({ h: m, l: _ } = lt.add(this.Eh | 0, this.El | 0, m | 0, _ | 0)),
        ({ h: A, l: E } = lt.add(this.Fh | 0, this.Fl | 0, A | 0, E | 0)),
        ({ h: I, l: R } = lt.add(this.Gh | 0, this.Gl | 0, I | 0, R | 0)),
        ({ h: L, l: D } = lt.add(this.Hh | 0, this.Hl | 0, L | 0, D | 0)),
        this.set(r, s, n, c, f, h, y, p, m, _, A, E, I, R, L, D);
    }
    roundClean() {
      ho.fill(0), po.fill(0);
    }
    destroy() {
      this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  },
  JR = class extends jl {
    constructor() {
      super(),
        (this.Ah = -1942145080),
        (this.Al = 424955298),
        (this.Bh = 1944164710),
        (this.Bl = -1982016298),
        (this.Ch = 502970286),
        (this.Cl = 855612546),
        (this.Dh = 1738396948),
        (this.Dl = 1479516111),
        (this.Eh = 258812777),
        (this.El = 2077511080),
        (this.Fh = 2011393907),
        (this.Fl = 79989058),
        (this.Gh = 1067287976),
        (this.Gl = 1780299464),
        (this.Hh = 286451373),
        (this.Hl = -1848208735),
        (this.outputLen = 28);
    }
  },
  XR = class extends jl {
    constructor() {
      super(),
        (this.Ah = 573645204),
        (this.Al = -64227540),
        (this.Bh = -1621794909),
        (this.Bl = -934517566),
        (this.Ch = 596883563),
        (this.Cl = 1867755857),
        (this.Dh = -1774684391),
        (this.Dl = 1497426621),
        (this.Eh = -1775747358),
        (this.El = -1467023389),
        (this.Fh = -1101128155),
        (this.Fl = 1401305490),
        (this.Gh = 721525244),
        (this.Gl = 746961066),
        (this.Hh = 246885852),
        (this.Hl = -2117784414),
        (this.outputLen = 32);
    }
  },
  QR = class extends jl {
    constructor() {
      super(),
        (this.Ah = -876896931),
        (this.Al = -1056596264),
        (this.Bh = 1654270250),
        (this.Bl = 914150663),
        (this.Ch = -1856437926),
        (this.Cl = 812702999),
        (this.Dh = 355462360),
        (this.Dl = -150054599),
        (this.Eh = 1731405415),
        (this.El = -4191439),
        (this.Fh = -1900787065),
        (this.Fl = 1750603025),
        (this.Gh = -619958771),
        (this.Gl = 1694076839),
        (this.Hh = 1203062813),
        (this.Hl = -1090891868),
        (this.outputLen = 48);
    }
  };
const eP = Ps(() => new jl());
Ps(() => new JR());
Ps(() => new XR());
Ps(() => new QR());
const tP = (i, e, t) => (i & e) ^ (~i & t),
  rP = (i, e, t) => (i & e) ^ (i & t) ^ (e & t),
  iP = new Uint32Array([
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221,
    3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580,
    3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895,
    666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037,
    2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
    1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298,
  ]),
  yo = new Uint32Array([
    1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225,
  ]),
  go = new Uint32Array(64);
let t_ = class extends Q3 {
    constructor() {
      super(64, 32, 8, !1),
        (this.A = yo[0] | 0),
        (this.B = yo[1] | 0),
        (this.C = yo[2] | 0),
        (this.D = yo[3] | 0),
        (this.E = yo[4] | 0),
        (this.F = yo[5] | 0),
        (this.G = yo[6] | 0),
        (this.H = yo[7] | 0);
    }
    get() {
      const { A: e, B: t, C: r, D: s, E: n, F: c, G: f, H: h } = this;
      return [e, t, r, s, n, c, f, h];
    }
    set(e, t, r, s, n, c, f, h) {
      (this.A = e | 0),
        (this.B = t | 0),
        (this.C = r | 0),
        (this.D = s | 0),
        (this.E = n | 0),
        (this.F = c | 0),
        (this.G = f | 0),
        (this.H = h | 0);
    }
    process(e, t) {
      for (let m = 0; m < 16; m++, t += 4) go[m] = e.getUint32(t, !1);
      for (let m = 16; m < 64; m++) {
        const _ = go[m - 15],
          A = go[m - 2],
          E = bn(_, 7) ^ bn(_, 18) ^ (_ >>> 3),
          I = bn(A, 17) ^ bn(A, 19) ^ (A >>> 10);
        go[m] = (I + go[m - 7] + E + go[m - 16]) | 0;
      }
      let { A: r, B: s, C: n, D: c, E: f, F: h, G: y, H: p } = this;
      for (let m = 0; m < 64; m++) {
        const _ = bn(f, 6) ^ bn(f, 11) ^ bn(f, 25),
          A = (p + _ + tP(f, h, y) + iP[m] + go[m]) | 0,
          I = ((bn(r, 2) ^ bn(r, 13) ^ bn(r, 22)) + rP(r, s, n)) | 0;
        (p = y), (y = h), (h = f), (f = (c + A) | 0), (c = n), (n = s), (s = r), (r = (A + I) | 0);
      }
      (r = (r + this.A) | 0),
        (s = (s + this.B) | 0),
        (n = (n + this.C) | 0),
        (c = (c + this.D) | 0),
        (f = (f + this.E) | 0),
        (h = (h + this.F) | 0),
        (y = (y + this.G) | 0),
        (p = (p + this.H) | 0),
        this.set(r, s, n, c, f, h, y, p);
    }
    roundClean() {
      go.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
    }
  },
  nP = class extends t_ {
    constructor() {
      super(),
        (this.A = -1056596264),
        (this.B = 914150663),
        (this.C = 812702999),
        (this.D = -150054599),
        (this.E = -4191439),
        (this.F = 1750603025),
        (this.G = 1694076839),
        (this.H = -1090891868),
        (this.outputLen = 28);
    }
  };
const o1 = Ps(() => new t_());
Ps(() => new nP());
var ei = {},
  oP =
    (se && se.__createBinding) ||
    (Object.create
      ? function (i, e, t, r) {
          r === void 0 && (r = t),
            Object.defineProperty(i, r, {
              enumerable: !0,
              get: function () {
                return e[t];
              },
            });
        }
      : function (i, e, t, r) {
          r === void 0 && (r = t), (i[r] = e[t]);
        }),
  sP =
    (se && se.__setModuleDefault) ||
    (Object.create
      ? function (i, e) {
          Object.defineProperty(i, 'default', { enumerable: !0, value: e });
        }
      : function (i, e) {
          i.default = e;
        }),
  jn =
    (se && se.__decorate) ||
    function (i, e, t, r) {
      var s = arguments.length,
        n = s < 3 ? e : r === null ? (r = Object.getOwnPropertyDescriptor(e, t)) : r,
        c;
      if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function')
        n = Reflect.decorate(i, e, t, r);
      else
        for (var f = i.length - 1; f >= 0; f--)
          (c = i[f]) && (n = (s < 3 ? c(n) : s > 3 ? c(e, t, n) : c(e, t)) || n);
      return s > 3 && n && Object.defineProperty(e, t, n), n;
    },
  aP =
    (se && se.__importStar) ||
    function (i) {
      if (i && i.__esModule) return i;
      var e = {};
      if (i != null)
        for (var t in i) t !== 'default' && Object.hasOwnProperty.call(i, t) && oP(e, i, t);
      return sP(e, i), e;
    },
  r_ =
    (se && se.__importDefault) ||
    function (i) {
      return i && i.__esModule ? i : { default: i };
    };
Object.defineProperty(ei, '__esModule', { value: !0 });
var i_ =
  (ei.deserializeUnchecked =
  c_ =
  ei.deserialize =
  u_ =
  ei.serialize =
  ei.BinaryReader =
  ei.BinaryWriter =
  ei.BorshError =
  ei.baseDecode =
  ei.baseEncode =
    void 0);
const Bo = r_(Ko()),
  n_ = r_(M3),
  uP = aP(A3),
  cP = typeof TextDecoder != 'function' ? uP.TextDecoder : TextDecoder,
  fP = new cP('utf-8', { fatal: !0 });
function lP(i) {
  return typeof i == 'string' && (i = Ze.from(i, 'utf8')), n_.default.encode(Ze.from(i));
}
ei.baseEncode = lP;
function hP(i) {
  return Ze.from(n_.default.decode(i));
}
ei.baseDecode = hP;
const dp = 1024;
let mi = class extends Error {
  constructor(e) {
    super(e), (this.fieldPath = []), (this.originalMessage = e);
  }
  addToFieldPath(e) {
    this.fieldPath.splice(0, 0, e),
      (this.message = this.originalMessage + ': ' + this.fieldPath.join('.'));
  }
};
ei.BorshError = mi;
let o_ = class {
  constructor() {
    (this.buf = Ze.alloc(dp)), (this.length = 0);
  }
  maybeResize() {
    this.buf.length < 16 + this.length && (this.buf = Ze.concat([this.buf, Ze.alloc(dp)]));
  }
  writeU8(e) {
    this.maybeResize(), this.buf.writeUInt8(e, this.length), (this.length += 1);
  }
  writeU16(e) {
    this.maybeResize(), this.buf.writeUInt16LE(e, this.length), (this.length += 2);
  }
  writeU32(e) {
    this.maybeResize(), this.buf.writeUInt32LE(e, this.length), (this.length += 4);
  }
  writeU64(e) {
    this.maybeResize(), this.writeBuffer(Ze.from(new Bo.default(e).toArray('le', 8)));
  }
  writeU128(e) {
    this.maybeResize(), this.writeBuffer(Ze.from(new Bo.default(e).toArray('le', 16)));
  }
  writeU256(e) {
    this.maybeResize(), this.writeBuffer(Ze.from(new Bo.default(e).toArray('le', 32)));
  }
  writeU512(e) {
    this.maybeResize(), this.writeBuffer(Ze.from(new Bo.default(e).toArray('le', 64)));
  }
  writeBuffer(e) {
    (this.buf = Ze.concat([Ze.from(this.buf.subarray(0, this.length)), e, Ze.alloc(dp)])),
      (this.length += e.length);
  }
  writeString(e) {
    this.maybeResize();
    const t = Ze.from(e, 'utf8');
    this.writeU32(t.length), this.writeBuffer(t);
  }
  writeFixedArray(e) {
    this.writeBuffer(Ze.from(e));
  }
  writeArray(e, t) {
    this.maybeResize(), this.writeU32(e.length);
    for (const r of e) this.maybeResize(), t(r);
  }
  toArray() {
    return this.buf.subarray(0, this.length);
  }
};
ei.BinaryWriter = o_;
function Hn(i, e, t) {
  const r = t.value;
  t.value = function (...s) {
    try {
      return r.apply(this, s);
    } catch (n) {
      if (n instanceof RangeError) {
        const c = n.code;
        if (['ERR_BUFFER_OUT_OF_BOUNDS', 'ERR_OUT_OF_RANGE'].indexOf(c) >= 0)
          throw new mi('Reached the end of buffer when deserializing');
      }
      throw n;
    }
  };
}
let zi = class {
  constructor(e) {
    (this.buf = e), (this.offset = 0);
  }
  readU8() {
    const e = this.buf.readUInt8(this.offset);
    return (this.offset += 1), e;
  }
  readU16() {
    const e = this.buf.readUInt16LE(this.offset);
    return (this.offset += 2), e;
  }
  readU32() {
    const e = this.buf.readUInt32LE(this.offset);
    return (this.offset += 4), e;
  }
  readU64() {
    const e = this.readBuffer(8);
    return new Bo.default(e, 'le');
  }
  readU128() {
    const e = this.readBuffer(16);
    return new Bo.default(e, 'le');
  }
  readU256() {
    const e = this.readBuffer(32);
    return new Bo.default(e, 'le');
  }
  readU512() {
    const e = this.readBuffer(64);
    return new Bo.default(e, 'le');
  }
  readBuffer(e) {
    if (this.offset + e > this.buf.length)
      throw new mi(`Expected buffer length ${e} isn't within bounds`);
    const t = this.buf.slice(this.offset, this.offset + e);
    return (this.offset += e), t;
  }
  readString() {
    const e = this.readU32(),
      t = this.readBuffer(e);
    try {
      return fP.decode(t);
    } catch (r) {
      throw new mi(`Error decoding UTF-8 string: ${r}`);
    }
  }
  readFixedArray(e) {
    return new Uint8Array(this.readBuffer(e));
  }
  readArray(e) {
    const t = this.readU32(),
      r = Array();
    for (let s = 0; s < t; ++s) r.push(e());
    return r;
  }
};
jn([Hn], zi.prototype, 'readU8', null);
jn([Hn], zi.prototype, 'readU16', null);
jn([Hn], zi.prototype, 'readU32', null);
jn([Hn], zi.prototype, 'readU64', null);
jn([Hn], zi.prototype, 'readU128', null);
jn([Hn], zi.prototype, 'readU256', null);
jn([Hn], zi.prototype, 'readU512', null);
jn([Hn], zi.prototype, 'readString', null);
jn([Hn], zi.prototype, 'readFixedArray', null);
jn([Hn], zi.prototype, 'readArray', null);
ei.BinaryReader = zi;
function s_(i) {
  return i.charAt(0).toUpperCase() + i.slice(1);
}
function Zo(i, e, t, r, s) {
  try {
    if (typeof r == 'string') s[`write${s_(r)}`](t);
    else if (r instanceof Array)
      if (typeof r[0] == 'number') {
        if (t.length !== r[0])
          throw new mi(`Expecting byte array of length ${r[0]}, but got ${t.length} bytes`);
        s.writeFixedArray(t);
      } else if (r.length === 2 && typeof r[1] == 'number') {
        if (t.length !== r[1])
          throw new mi(`Expecting byte array of length ${r[1]}, but got ${t.length} bytes`);
        for (let n = 0; n < r[1]; n++) Zo(i, null, t[n], r[0], s);
      } else
        s.writeArray(t, (n) => {
          Zo(i, e, n, r[0], s);
        });
    else if (r.kind !== void 0)
      switch (r.kind) {
        case 'option': {
          t == null ? s.writeU8(0) : (s.writeU8(1), Zo(i, e, t, r.type, s));
          break;
        }
        case 'map': {
          s.writeU32(t.size),
            t.forEach((n, c) => {
              Zo(i, e, c, r.key, s), Zo(i, e, n, r.value, s);
            });
          break;
        }
        default:
          throw new mi(`FieldType ${r} unrecognized`);
      }
    else a_(i, t, s);
  } catch (n) {
    throw (n instanceof mi && n.addToFieldPath(e), n);
  }
}
function a_(i, e, t) {
  if (typeof e.borshSerialize == 'function') {
    e.borshSerialize(t);
    return;
  }
  const r = i.get(e.constructor);
  if (!r) throw new mi(`Class ${e.constructor.name} is missing in schema`);
  if (r.kind === 'struct')
    r.fields.map(([s, n]) => {
      Zo(i, s, e[s], n, t);
    });
  else if (r.kind === 'enum') {
    const s = e[r.field];
    for (let n = 0; n < r.values.length; ++n) {
      const [c, f] = r.values[n];
      if (c === s) {
        t.writeU8(n), Zo(i, c, e[c], f, t);
        break;
      }
    }
  } else throw new mi(`Unexpected schema kind: ${r.kind} for ${e.constructor.name}`);
}
function dP(i, e, t = o_) {
  const r = new t();
  return a_(i, e, r), r.toArray();
}
var u_ = (ei.serialize = dP);
function Jo(i, e, t, r) {
  try {
    if (typeof t == 'string') return r[`read${s_(t)}`]();
    if (t instanceof Array) {
      if (typeof t[0] == 'number') return r.readFixedArray(t[0]);
      if (typeof t[1] == 'number') {
        const s = [];
        for (let n = 0; n < t[1]; n++) s.push(Jo(i, null, t[0], r));
        return s;
      } else return r.readArray(() => Jo(i, e, t[0], r));
    }
    if (t.kind === 'option') return r.readU8() ? Jo(i, e, t.type, r) : void 0;
    if (t.kind === 'map') {
      let s = new Map();
      const n = r.readU32();
      for (let c = 0; c < n; c++) {
        const f = Jo(i, e, t.key, r),
          h = Jo(i, e, t.value, r);
        s.set(f, h);
      }
      return s;
    }
    return Dy(i, t, r);
  } catch (s) {
    throw (s instanceof mi && s.addToFieldPath(e), s);
  }
}
function Dy(i, e, t) {
  if (typeof e.borshDeserialize == 'function') return e.borshDeserialize(t);
  const r = i.get(e);
  if (!r) throw new mi(`Class ${e.name} is missing in schema`);
  if (r.kind === 'struct') {
    const s = {};
    for (const [n, c] of i.get(e).fields) s[n] = Jo(i, n, c, t);
    return new e(s);
  }
  if (r.kind === 'enum') {
    const s = t.readU8();
    if (s >= r.values.length) throw new mi(`Enum index: ${s} is out of range`);
    const [n, c] = r.values[s],
      f = Jo(i, n, c, t);
    return new e({ [n]: f });
  }
  throw new mi(`Unexpected schema kind: ${r.kind} for ${e.constructor.name}`);
}
function pP(i, e, t, r = zi) {
  const s = new r(t),
    n = Dy(i, e, s);
  if (s.offset < t.length)
    throw new mi(`Unexpected ${t.length - s.offset} bytes after deserialized data`);
  return n;
}
var c_ = (ei.deserialize = pP);
function yP(i, e, t, r = zi) {
  const s = new r(t);
  return Dy(i, e, s);
}
i_ = ei.deserializeUnchecked = yP;
const [f_, l_, h_] = [[], [], []],
  gP = BigInt(0),
  hu = BigInt(1),
  bP = BigInt(2),
  vP = BigInt(7),
  mP = BigInt(256),
  wP = BigInt(113);
for (let i = 0, e = hu, t = 1, r = 0; i < 24; i++) {
  ([t, r] = [r, (2 * t + 3 * r) % 5]),
    f_.push(2 * (5 * r + t)),
    l_.push((((i + 1) * (i + 2)) / 2) % 64);
  let s = gP;
  for (let n = 0; n < 7; n++)
    (e = ((e << hu) ^ ((e >> vP) * wP)) % mP), e & bP && (s ^= hu << ((hu << BigInt(n)) - hu));
  h_.push(s);
}
const [_P, SP] = lt.split(h_, !0),
  hw = (i, e, t) => (t > 32 ? lt.rotlBH(i, e, t) : lt.rotlSH(i, e, t)),
  dw = (i, e, t) => (t > 32 ? lt.rotlBL(i, e, t) : lt.rotlSL(i, e, t));
function MP(i, e = 24) {
  const t = new Uint32Array(10);
  for (let r = 24 - e; r < 24; r++) {
    for (let c = 0; c < 10; c++) t[c] = i[c] ^ i[c + 10] ^ i[c + 20] ^ i[c + 30] ^ i[c + 40];
    for (let c = 0; c < 10; c += 2) {
      const f = (c + 8) % 10,
        h = (c + 2) % 10,
        y = t[h],
        p = t[h + 1],
        m = hw(y, p, 1) ^ t[f],
        _ = dw(y, p, 1) ^ t[f + 1];
      for (let A = 0; A < 50; A += 10) (i[c + A] ^= m), (i[c + A + 1] ^= _);
    }
    let s = i[2],
      n = i[3];
    for (let c = 0; c < 24; c++) {
      const f = l_[c],
        h = hw(s, n, f),
        y = dw(s, n, f),
        p = f_[c];
      (s = i[p]), (n = i[p + 1]), (i[p] = h), (i[p + 1] = y);
    }
    for (let c = 0; c < 50; c += 10) {
      for (let f = 0; f < 10; f++) t[f] = i[c + f];
      for (let f = 0; f < 10; f++) i[c + f] ^= ~t[(f + 2) % 10] & t[(f + 4) % 10];
    }
    (i[0] ^= _P[r]), (i[1] ^= SP[r]);
  }
  t.fill(0);
}
let d_ = class p_ extends $y {
  constructor(e, t, r, s = !1, n = 24) {
    if (
      (super(),
      (this.blockLen = e),
      (this.suffix = t),
      (this.outputLen = r),
      (this.enableXOF = s),
      (this.rounds = n),
      (this.pos = 0),
      (this.posOut = 0),
      (this.finished = !1),
      (this.destroyed = !1),
      Ci.number(r),
      0 >= this.blockLen || this.blockLen >= 200)
    )
      throw new Error('Sha3 supports only keccak-f1600 function');
    (this.state = new Uint8Array(200)), (this.state32 = MR(this.state));
  }
  keccak() {
    MP(this.state32, this.rounds), (this.posOut = 0), (this.pos = 0);
  }
  update(e) {
    Ci.exists(this);
    const { blockLen: t, state: r } = this;
    e = uc(e);
    const s = e.length;
    for (let n = 0; n < s; ) {
      const c = Math.min(t - this.pos, s - n);
      for (let f = 0; f < c; f++) r[this.pos++] ^= e[n++];
      this.pos === t && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = !0;
    const { state: e, suffix: t, pos: r, blockLen: s } = this;
    (e[r] ^= t), t & 128 && r === s - 1 && this.keccak(), (e[s - 1] ^= 128), this.keccak();
  }
  writeInto(e) {
    Ci.exists(this, !1), Ci.bytes(e), this.finish();
    const t = this.state,
      { blockLen: r } = this;
    for (let s = 0, n = e.length; s < n; ) {
      this.posOut >= r && this.keccak();
      const c = Math.min(r - this.posOut, n - s);
      e.set(t.subarray(this.posOut, this.posOut + c), s), (this.posOut += c), (s += c);
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF) throw new Error('XOF is not possible for this instance');
    return this.writeInto(e);
  }
  xof(e) {
    return Ci.number(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if ((Ci.output(e, this), this.finished)) throw new Error('digest() was already called');
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    (this.destroyed = !0), this.state.fill(0);
  }
  _cloneInto(e) {
    const { blockLen: t, suffix: r, outputLen: s, rounds: n, enableXOF: c } = this;
    return (
      e || (e = new p_(t, r, s, c, n)),
      e.state32.set(this.state32),
      (e.pos = this.pos),
      (e.posOut = this.posOut),
      (e.finished = this.finished),
      (e.rounds = n),
      (e.suffix = r),
      (e.outputLen = s),
      (e.enableXOF = c),
      (e.destroyed = this.destroyed),
      e
    );
  }
};
const jo = (i, e, t) => Ps(() => new d_(e, i, t));
jo(6, 144, 224 / 8);
jo(6, 136, 256 / 8);
jo(6, 104, 384 / 8);
jo(6, 72, 512 / 8);
jo(1, 144, 224 / 8);
const pw = jo(1, 136, 256 / 8);
jo(1, 104, 384 / 8);
jo(1, 72, 512 / 8);
const y_ = (i, e, t) => kR((r = {}) => new d_(e, i, r.dkLen === void 0 ? t : r.dkLen, !0));
y_(31, 168, 128 / 8);
y_(31, 136, 256 / 8);
let g_ = class extends $y {
  constructor(e, t) {
    super(), (this.finished = !1), (this.destroyed = !1), Ci.hash(e);
    const r = uc(t);
    if (((this.iHash = e.create()), typeof this.iHash.update != 'function'))
      throw new TypeError('Expected instance of class which extends utils.Hash');
    (this.blockLen = this.iHash.blockLen), (this.outputLen = this.iHash.outputLen);
    const s = this.blockLen,
      n = new Uint8Array(s);
    n.set(r.length > s ? e.create().update(r).digest() : r);
    for (let c = 0; c < n.length; c++) n[c] ^= 54;
    this.iHash.update(n), (this.oHash = e.create());
    for (let c = 0; c < n.length; c++) n[c] ^= 106;
    this.oHash.update(n), n.fill(0);
  }
  update(e) {
    return Ci.exists(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    Ci.exists(this),
      Ci.bytes(e, this.outputLen),
      (this.finished = !0),
      this.iHash.digestInto(e),
      this.oHash.update(e),
      this.oHash.digestInto(e),
      this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: t, iHash: r, finished: s, destroyed: n, blockLen: c, outputLen: f } = this;
    return (
      (e = e),
      (e.finished = s),
      (e.destroyed = n),
      (e.blockLen = c),
      (e.outputLen = f),
      (e.oHash = t._cloneInto(e.oHash)),
      (e.iHash = r._cloneInto(e.iHash)),
      e
    );
  }
  destroy() {
    (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
  }
};
const b_ = (i, e, t) => new g_(i, e).update(t).digest();
b_.create = (i, e) => new g_(i, e);
ln.sha512Sync = (...i) => eP(ln.concatBytes(...i));
const AP = ln.randomPrivateKey,
  yw = () => {
    const i = ln.randomPrivateKey(),
      e = nl(i),
      t = new Uint8Array(64);
    return t.set(i), t.set(e, 32), { publicKey: e, secretKey: t };
  },
  nl = Ha.getPublicKey;
function gw(i) {
  try {
    return Or.fromHex(i, !0), !0;
  } catch {
    return !1;
  }
}
const Uy = (i, e) => Ha.sign(i, e.slice(0, 32)),
  EP = Ha.verify,
  St = (i) =>
    He.isBuffer(i)
      ? i
      : i instanceof Uint8Array
        ? He.from(i.buffer, i.byteOffset, i.byteLength)
        : He.from(i);
let zy = class {
    constructor(e) {
      Object.assign(this, e);
    }
    encode() {
      return He.from(u_(Eu, this));
    }
    static decode(e) {
      return c_(Eu, this, e);
    }
    static decodeUnchecked(e) {
      return i_(Eu, this, e);
    }
  },
  kP = class extends zy {
    constructor(e) {
      if ((super(e), (this.enum = ''), Object.keys(e).length !== 1))
        throw new Error('Enum can only take single value');
      Object.keys(e).map((t) => {
        this.enum = t;
      });
    }
  };
const Eu = new Map();
let v_;
const m_ = 32,
  Ni = 32;
function IP(i) {
  return i._bn !== void 0;
}
let bw = 1;
v_ = Symbol.toStringTag;
let Ve = class Qs extends zy {
  constructor(e) {
    if ((super({}), (this._bn = void 0), IP(e))) this._bn = e._bn;
    else {
      if (typeof e == 'string') {
        const t = ri.decode(e);
        if (t.length != Ni) throw new Error('Invalid public key input');
        this._bn = new Cu(t);
      } else this._bn = new Cu(e);
      if (this._bn.byteLength() > Ni) throw new Error('Invalid public key input');
    }
  }
  static unique() {
    const e = new Qs(bw);
    return (bw += 1), new Qs(e.toBuffer());
  }
  equals(e) {
    return this._bn.eq(e._bn);
  }
  toBase58() {
    return ri.encode(this.toBytes());
  }
  toJSON() {
    return this.toBase58();
  }
  toBytes() {
    const e = this.toBuffer();
    return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
  }
  toBuffer() {
    const e = this._bn.toArrayLike(He);
    if (e.length === Ni) return e;
    const t = He.alloc(32);
    return e.copy(t, 32 - e.length), t;
  }
  get [v_]() {
    return `PublicKey(${this.toString()})`;
  }
  toString() {
    return this.toBase58();
  }
  static async createWithSeed(e, t, r) {
    const s = He.concat([e.toBuffer(), He.from(t), r.toBuffer()]),
      n = o1(s);
    return new Qs(n);
  }
  static createProgramAddressSync(e, t) {
    let r = He.alloc(0);
    e.forEach(function (n) {
      if (n.length > m_) throw new TypeError('Max seed length exceeded');
      r = He.concat([r, St(n)]);
    }),
      (r = He.concat([r, t.toBuffer(), He.from('ProgramDerivedAddress')]));
    const s = o1(r);
    if (gw(s)) throw new Error('Invalid seeds, address must fall off the curve');
    return new Qs(s);
  }
  static async createProgramAddress(e, t) {
    return this.createProgramAddressSync(e, t);
  }
  static findProgramAddressSync(e, t) {
    let r = 255,
      s;
    for (; r != 0; ) {
      try {
        const n = e.concat(He.from([r]));
        s = this.createProgramAddressSync(n, t);
      } catch (n) {
        if (n instanceof TypeError) throw n;
        r--;
        continue;
      }
      return [s, r];
    }
    throw new Error('Unable to find a viable program address nonce');
  }
  static async findProgramAddress(e, t) {
    return this.findProgramAddressSync(e, t);
  }
  static isOnCurve(e) {
    const t = new Qs(e);
    return gw(t.toBytes());
  }
};
Ve.default = new Ve('11111111111111111111111111111111');
Eu.set(Ve, { kind: 'struct', fields: [['_bn', 'u256']] });
let xP = class {
  constructor(e) {
    if (((this._publicKey = void 0), (this._secretKey = void 0), e)) {
      const t = St(e);
      if (e.length !== 64) throw new Error('bad secret key size');
      (this._publicKey = t.slice(32, 64)), (this._secretKey = t.slice(0, 32));
    } else (this._secretKey = St(AP())), (this._publicKey = St(nl(this._secretKey)));
  }
  get publicKey() {
    return new Ve(this._publicKey);
  }
  get secretKey() {
    return He.concat([this._secretKey, this._publicKey], 64);
  }
};
const BP = new Ve('BPFLoader1111111111111111111111111111111111'),
  Co = 1232,
  Hl = 127,
  Pa = 64;
let Fy = class extends Error {
  constructor(e) {
    super(`Signature ${e} has expired: block height exceeded.`),
      (this.signature = void 0),
      (this.signature = e);
  }
};
Object.defineProperty(Fy.prototype, 'name', {
  value: 'TransactionExpiredBlockheightExceededError',
});
let qy = class extends Error {
  constructor(e, t) {
    super(
      `Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`
    ),
      (this.signature = void 0),
      (this.signature = e);
  }
};
Object.defineProperty(qy.prototype, 'name', { value: 'TransactionExpiredTimeoutError' });
let ta = class extends Error {
  constructor(e) {
    super(`Signature ${e} has expired: the nonce is no longer valid.`),
      (this.signature = void 0),
      (this.signature = e);
  }
};
Object.defineProperty(ta.prototype, 'name', { value: 'TransactionExpiredNonceInvalidError' });
let $u = class {
  constructor(e, t) {
    (this.staticAccountKeys = void 0),
      (this.accountKeysFromLookups = void 0),
      (this.staticAccountKeys = e),
      (this.accountKeysFromLookups = t);
  }
  keySegments() {
    const e = [this.staticAccountKeys];
    return (
      this.accountKeysFromLookups &&
        (e.push(this.accountKeysFromLookups.writable),
        e.push(this.accountKeysFromLookups.readonly)),
      e
    );
  }
  get(e) {
    for (const t of this.keySegments()) {
      if (e < t.length) return t[e];
      e -= t.length;
    }
  }
  get length() {
    return this.keySegments().flat().length;
  }
  compileInstructions(e) {
    if (this.length > 256) throw new Error('Account index overflow encountered during compilation');
    const r = new Map();
    this.keySegments()
      .flat()
      .forEach((n, c) => {
        r.set(n.toBase58(), c);
      });
    const s = (n) => {
      const c = r.get(n.toBase58());
      if (c === void 0)
        throw new Error('Encountered an unknown instruction account key during compilation');
      return c;
    };
    return e.map((n) => ({
      programIdIndex: s(n.programId),
      accountKeyIndexes: n.keys.map((c) => s(c.pubkey)),
      data: n.data,
    }));
  }
};
const It = (i = 'publicKey') => ut(32, i),
  RP = (i = 'signature') => ut(64, i),
  is = (i = 'string') => {
    const e = We([qe('length'), qe('lengthPadding'), ut(_i(qe(), -8), 'chars')], i),
      t = e.decode.bind(e),
      r = e.encode.bind(e),
      s = e;
    return (
      (s.decode = (n, c) => t(n, c).chars.toString()),
      (s.encode = (n, c, f) => {
        const h = { chars: He.from(n, 'utf8') };
        return r(h, c, f);
      }),
      (s.alloc = (n) => qe().span + qe().span + He.from(n, 'utf8').length),
      s
    );
  },
  PP = (i = 'authorized') => We([It('staker'), It('withdrawer')], i),
  TP = (i = 'lockup') => We([Ir('unixTimestamp'), Ir('epoch'), It('custodian')], i),
  OP = (i = 'voteInit') =>
    We([It('nodePubkey'), It('authorizedVoter'), It('authorizedWithdrawer'), tt('commission')], i),
  CP = (i = 'voteAuthorizeWithSeedArgs') =>
    We(
      [
        qe('voteAuthorizationType'),
        It('currentAuthorityDerivedKeyOwnerPubkey'),
        is('currentAuthorityDerivedKeySeed'),
        It('newAuthorized'),
      ],
      i
    );
function w_(i, e) {
  const t = (s) => {
    if (s.span >= 0) return s.span;
    if (typeof s.alloc == 'function') return s.alloc(e[s.property]);
    if ('count' in s && 'elementLayout' in s) {
      const n = e[s.property];
      if (Array.isArray(n)) return n.length * t(s.elementLayout);
    } else if ('fields' in s) return w_({ layout: s }, e[s.property]);
    return 0;
  };
  let r = 0;
  return (
    i.layout.fields.forEach((s) => {
      r += t(s);
    }),
    r
  );
}
function Si(i) {
  let e = 0,
    t = 0;
  for (;;) {
    let r = i.shift();
    if (((e |= (r & 127) << (t * 7)), (t += 1), !(r & 128))) break;
  }
  return e;
}
function Ti(i, e) {
  let t = e;
  for (;;) {
    let r = t & 127;
    if (((t >>= 7), t == 0)) {
      i.push(r);
      break;
    } else (r |= 128), i.push(r);
  }
}
function Vt(i, e) {
  if (!i) throw new Error(e || 'Assertion failed');
}
let __ = class S_ {
    constructor(e, t) {
      (this.payer = void 0), (this.keyMetaMap = void 0), (this.payer = e), (this.keyMetaMap = t);
    }
    static compile(e, t) {
      const r = new Map(),
        s = (c) => {
          const f = c.toBase58();
          let h = r.get(f);
          return (
            h === void 0 && ((h = { isSigner: !1, isWritable: !1, isInvoked: !1 }), r.set(f, h)), h
          );
        },
        n = s(t);
      (n.isSigner = !0), (n.isWritable = !0);
      for (const c of e) {
        s(c.programId).isInvoked = !0;
        for (const f of c.keys) {
          const h = s(f.pubkey);
          h.isSigner || (h.isSigner = f.isSigner), h.isWritable || (h.isWritable = f.isWritable);
        }
      }
      return new S_(t, r);
    }
    getMessageComponents() {
      const e = [...this.keyMetaMap.entries()];
      Vt(e.length <= 256, 'Max static account keys length exceeded');
      const t = e.filter(([, h]) => h.isSigner && h.isWritable),
        r = e.filter(([, h]) => h.isSigner && !h.isWritable),
        s = e.filter(([, h]) => !h.isSigner && h.isWritable),
        n = e.filter(([, h]) => !h.isSigner && !h.isWritable),
        c = {
          numRequiredSignatures: t.length + r.length,
          numReadonlySignedAccounts: r.length,
          numReadonlyUnsignedAccounts: n.length,
        };
      {
        Vt(t.length > 0, 'Expected at least one writable signer key');
        const [h] = t[0];
        Vt(h === this.payer.toBase58(), 'Expected first writable signer key to be the fee payer');
      }
      const f = [
        ...t.map(([h]) => new Ve(h)),
        ...r.map(([h]) => new Ve(h)),
        ...s.map(([h]) => new Ve(h)),
        ...n.map(([h]) => new Ve(h)),
      ];
      return [c, f];
    }
    extractTableLookup(e) {
      const [t, r] = this.drainKeysFoundInLookupTable(
          e.state.addresses,
          (c) => !c.isSigner && !c.isInvoked && c.isWritable
        ),
        [s, n] = this.drainKeysFoundInLookupTable(
          e.state.addresses,
          (c) => !c.isSigner && !c.isInvoked && !c.isWritable
        );
      if (!(t.length === 0 && s.length === 0))
        return [
          { accountKey: e.key, writableIndexes: t, readonlyIndexes: s },
          { writable: r, readonly: n },
        ];
    }
    drainKeysFoundInLookupTable(e, t) {
      const r = new Array(),
        s = new Array();
      for (const [n, c] of this.keyMetaMap.entries())
        if (t(c)) {
          const f = new Ve(n),
            h = e.findIndex((y) => y.equals(f));
          h >= 0 &&
            (Vt(h < 256, 'Max lookup table index exceeded'),
            r.push(h),
            s.push(f),
            this.keyMetaMap.delete(n));
        }
      return [r, s];
    }
  },
  $o = class s1 {
    constructor(e) {
      (this.header = void 0),
        (this.accountKeys = void 0),
        (this.recentBlockhash = void 0),
        (this.instructions = void 0),
        (this.indexToProgramIds = new Map()),
        (this.header = e.header),
        (this.accountKeys = e.accountKeys.map((t) => new Ve(t))),
        (this.recentBlockhash = e.recentBlockhash),
        (this.instructions = e.instructions),
        this.instructions.forEach((t) =>
          this.indexToProgramIds.set(t.programIdIndex, this.accountKeys[t.programIdIndex])
        );
    }
    get version() {
      return 'legacy';
    }
    get staticAccountKeys() {
      return this.accountKeys;
    }
    get compiledInstructions() {
      return this.instructions.map((e) => ({
        programIdIndex: e.programIdIndex,
        accountKeyIndexes: e.accounts,
        data: ri.decode(e.data),
      }));
    }
    get addressTableLookups() {
      return [];
    }
    getAccountKeys() {
      return new $u(this.staticAccountKeys);
    }
    static compile(e) {
      const t = __.compile(e.instructions, e.payerKey),
        [r, s] = t.getMessageComponents(),
        c = new $u(s)
          .compileInstructions(e.instructions)
          .map((f) => ({
            programIdIndex: f.programIdIndex,
            accounts: f.accountKeyIndexes,
            data: ri.encode(f.data),
          }));
      return new s1({
        header: r,
        accountKeys: s,
        recentBlockhash: e.recentBlockhash,
        instructions: c,
      });
    }
    isAccountSigner(e) {
      return e < this.header.numRequiredSignatures;
    }
    isAccountWritable(e) {
      const t = this.header.numRequiredSignatures;
      if (e >= this.header.numRequiredSignatures) {
        const r = e - t,
          n = this.accountKeys.length - t - this.header.numReadonlyUnsignedAccounts;
        return r < n;
      } else {
        const r = t - this.header.numReadonlySignedAccounts;
        return e < r;
      }
    }
    isProgramId(e) {
      return this.indexToProgramIds.has(e);
    }
    programIds() {
      return [...this.indexToProgramIds.values()];
    }
    nonProgramIds() {
      return this.accountKeys.filter((e, t) => !this.isProgramId(t));
    }
    serialize() {
      const e = this.accountKeys.length;
      let t = [];
      Ti(t, e);
      const r = this.instructions.map((m) => {
        const { accounts: _, programIdIndex: A } = m,
          E = Array.from(ri.decode(m.data));
        let I = [];
        Ti(I, _.length);
        let R = [];
        return (
          Ti(R, E.length),
          {
            programIdIndex: A,
            keyIndicesCount: He.from(I),
            keyIndices: _,
            dataLength: He.from(R),
            data: E,
          }
        );
      });
      let s = [];
      Ti(s, r.length);
      let n = He.alloc(Co);
      He.from(s).copy(n);
      let c = s.length;
      r.forEach((m) => {
        const A = We([
          tt('programIdIndex'),
          ut(m.keyIndicesCount.length, 'keyIndicesCount'),
          zt(tt('keyIndex'), m.keyIndices.length, 'keyIndices'),
          ut(m.dataLength.length, 'dataLength'),
          zt(tt('userdatum'), m.data.length, 'data'),
        ]).encode(m, n, c);
        c += A;
      }),
        (n = n.slice(0, c));
      const f = We([
          ut(1, 'numRequiredSignatures'),
          ut(1, 'numReadonlySignedAccounts'),
          ut(1, 'numReadonlyUnsignedAccounts'),
          ut(t.length, 'keyCount'),
          zt(It('key'), e, 'keys'),
          It('recentBlockhash'),
        ]),
        h = {
          numRequiredSignatures: He.from([this.header.numRequiredSignatures]),
          numReadonlySignedAccounts: He.from([this.header.numReadonlySignedAccounts]),
          numReadonlyUnsignedAccounts: He.from([this.header.numReadonlyUnsignedAccounts]),
          keyCount: He.from(t),
          keys: this.accountKeys.map((m) => St(m.toBytes())),
          recentBlockhash: ri.decode(this.recentBlockhash),
        };
      let y = He.alloc(2048);
      const p = f.encode(h, y);
      return n.copy(y, p), y.slice(0, p + n.length);
    }
    static from(e) {
      let t = [...e];
      const r = t.shift();
      if (r !== (r & Hl))
        throw new Error(
          'Versioned messages must be deserialized with VersionedMessage.deserialize()'
        );
      const s = t.shift(),
        n = t.shift(),
        c = Si(t);
      let f = [];
      for (let _ = 0; _ < c; _++) {
        const A = t.slice(0, Ni);
        (t = t.slice(Ni)), f.push(new Ve(He.from(A)));
      }
      const h = t.slice(0, Ni);
      t = t.slice(Ni);
      const y = Si(t);
      let p = [];
      for (let _ = 0; _ < y; _++) {
        const A = t.shift(),
          E = Si(t),
          I = t.slice(0, E);
        t = t.slice(E);
        const R = Si(t),
          L = t.slice(0, R),
          D = ri.encode(He.from(L));
        (t = t.slice(R)), p.push({ programIdIndex: A, accounts: I, data: D });
      }
      const m = {
        header: {
          numRequiredSignatures: r,
          numReadonlySignedAccounts: s,
          numReadonlyUnsignedAccounts: n,
        },
        recentBlockhash: ri.encode(He.from(h)),
        accountKeys: f,
        instructions: p,
      };
      return new s1(m);
    }
  },
  Vl = class a1 {
    constructor(e) {
      (this.header = void 0),
        (this.staticAccountKeys = void 0),
        (this.recentBlockhash = void 0),
        (this.compiledInstructions = void 0),
        (this.addressTableLookups = void 0),
        (this.header = e.header),
        (this.staticAccountKeys = e.staticAccountKeys),
        (this.recentBlockhash = e.recentBlockhash),
        (this.compiledInstructions = e.compiledInstructions),
        (this.addressTableLookups = e.addressTableLookups);
    }
    get version() {
      return 0;
    }
    get numAccountKeysFromLookups() {
      let e = 0;
      for (const t of this.addressTableLookups)
        e += t.readonlyIndexes.length + t.writableIndexes.length;
      return e;
    }
    getAccountKeys(e) {
      let t;
      if (e && 'accountKeysFromLookups' in e && e.accountKeysFromLookups) {
        if (
          this.numAccountKeysFromLookups !=
          e.accountKeysFromLookups.writable.length + e.accountKeysFromLookups.readonly.length
        )
          throw new Error(
            'Failed to get account keys because of a mismatch in the number of account keys from lookups'
          );
        t = e.accountKeysFromLookups;
      } else if (e && 'addressLookupTableAccounts' in e && e.addressLookupTableAccounts)
        t = this.resolveAddressTableLookups(e.addressLookupTableAccounts);
      else if (this.addressTableLookups.length > 0)
        throw new Error(
          'Failed to get account keys because address table lookups were not resolved'
        );
      return new $u(this.staticAccountKeys, t);
    }
    isAccountSigner(e) {
      return e < this.header.numRequiredSignatures;
    }
    isAccountWritable(e) {
      const t = this.header.numRequiredSignatures,
        r = this.staticAccountKeys.length;
      if (e >= r) {
        const s = e - r,
          n = this.addressTableLookups.reduce((c, f) => c + f.writableIndexes.length, 0);
        return s < n;
      } else if (e >= this.header.numRequiredSignatures) {
        const s = e - t,
          c = r - t - this.header.numReadonlyUnsignedAccounts;
        return s < c;
      } else {
        const s = t - this.header.numReadonlySignedAccounts;
        return e < s;
      }
    }
    resolveAddressTableLookups(e) {
      const t = { writable: [], readonly: [] };
      for (const r of this.addressTableLookups) {
        const s = e.find((n) => n.key.equals(r.accountKey));
        if (!s)
          throw new Error(
            `Failed to find address lookup table account for table key ${r.accountKey.toBase58()}`
          );
        for (const n of r.writableIndexes)
          if (n < s.state.addresses.length) t.writable.push(s.state.addresses[n]);
          else
            throw new Error(
              `Failed to find address for index ${n} in address lookup table ${r.accountKey.toBase58()}`
            );
        for (const n of r.readonlyIndexes)
          if (n < s.state.addresses.length) t.readonly.push(s.state.addresses[n]);
          else
            throw new Error(
              `Failed to find address for index ${n} in address lookup table ${r.accountKey.toBase58()}`
            );
      }
      return t;
    }
    static compile(e) {
      const t = __.compile(e.instructions, e.payerKey),
        r = new Array(),
        s = { writable: new Array(), readonly: new Array() },
        n = e.addressLookupTableAccounts || [];
      for (const p of n) {
        const m = t.extractTableLookup(p);
        if (m !== void 0) {
          const [_, { writable: A, readonly: E }] = m;
          r.push(_), s.writable.push(...A), s.readonly.push(...E);
        }
      }
      const [c, f] = t.getMessageComponents(),
        y = new $u(f, s).compileInstructions(e.instructions);
      return new a1({
        header: c,
        staticAccountKeys: f,
        recentBlockhash: e.recentBlockhash,
        compiledInstructions: y,
        addressTableLookups: r,
      });
    }
    serialize() {
      const e = Array();
      Ti(e, this.staticAccountKeys.length);
      const t = this.serializeInstructions(),
        r = Array();
      Ti(r, this.compiledInstructions.length);
      const s = this.serializeAddressTableLookups(),
        n = Array();
      Ti(n, this.addressTableLookups.length);
      const c = We([
          tt('prefix'),
          We(
            [
              tt('numRequiredSignatures'),
              tt('numReadonlySignedAccounts'),
              tt('numReadonlyUnsignedAccounts'),
            ],
            'header'
          ),
          ut(e.length, 'staticAccountKeysLength'),
          zt(It(), this.staticAccountKeys.length, 'staticAccountKeys'),
          It('recentBlockhash'),
          ut(r.length, 'instructionsLength'),
          ut(t.length, 'serializedInstructions'),
          ut(n.length, 'addressTableLookupsLength'),
          ut(s.length, 'serializedAddressTableLookups'),
        ]),
        f = new Uint8Array(Co),
        y = c.encode(
          {
            prefix: 128,
            header: this.header,
            staticAccountKeysLength: new Uint8Array(e),
            staticAccountKeys: this.staticAccountKeys.map((p) => p.toBytes()),
            recentBlockhash: ri.decode(this.recentBlockhash),
            instructionsLength: new Uint8Array(r),
            serializedInstructions: t,
            addressTableLookupsLength: new Uint8Array(n),
            serializedAddressTableLookups: s,
          },
          f
        );
      return f.slice(0, y);
    }
    serializeInstructions() {
      let e = 0;
      const t = new Uint8Array(Co);
      for (const r of this.compiledInstructions) {
        const s = Array();
        Ti(s, r.accountKeyIndexes.length);
        const n = Array();
        Ti(n, r.data.length);
        const c = We([
          tt('programIdIndex'),
          ut(s.length, 'encodedAccountKeyIndexesLength'),
          zt(tt(), r.accountKeyIndexes.length, 'accountKeyIndexes'),
          ut(n.length, 'encodedDataLength'),
          ut(r.data.length, 'data'),
        ]);
        e += c.encode(
          {
            programIdIndex: r.programIdIndex,
            encodedAccountKeyIndexesLength: new Uint8Array(s),
            accountKeyIndexes: r.accountKeyIndexes,
            encodedDataLength: new Uint8Array(n),
            data: r.data,
          },
          t,
          e
        );
      }
      return t.slice(0, e);
    }
    serializeAddressTableLookups() {
      let e = 0;
      const t = new Uint8Array(Co);
      for (const r of this.addressTableLookups) {
        const s = Array();
        Ti(s, r.writableIndexes.length);
        const n = Array();
        Ti(n, r.readonlyIndexes.length);
        const c = We([
          It('accountKey'),
          ut(s.length, 'encodedWritableIndexesLength'),
          zt(tt(), r.writableIndexes.length, 'writableIndexes'),
          ut(n.length, 'encodedReadonlyIndexesLength'),
          zt(tt(), r.readonlyIndexes.length, 'readonlyIndexes'),
        ]);
        e += c.encode(
          {
            accountKey: r.accountKey.toBytes(),
            encodedWritableIndexesLength: new Uint8Array(s),
            writableIndexes: r.writableIndexes,
            encodedReadonlyIndexesLength: new Uint8Array(n),
            readonlyIndexes: r.readonlyIndexes,
          },
          t,
          e
        );
      }
      return t.slice(0, e);
    }
    static deserialize(e) {
      let t = [...e];
      const r = t.shift(),
        s = r & Hl;
      Vt(r !== s, 'Expected versioned message but received legacy message');
      const n = s;
      Vt(n === 0, `Expected versioned message with version 0 but found version ${n}`);
      const c = {
          numRequiredSignatures: t.shift(),
          numReadonlySignedAccounts: t.shift(),
          numReadonlyUnsignedAccounts: t.shift(),
        },
        f = [],
        h = Si(t);
      for (let E = 0; E < h; E++) f.push(new Ve(t.splice(0, Ni)));
      const y = ri.encode(t.splice(0, Ni)),
        p = Si(t),
        m = [];
      for (let E = 0; E < p; E++) {
        const I = t.shift(),
          R = Si(t),
          L = t.splice(0, R),
          D = Si(t),
          q = new Uint8Array(t.splice(0, D));
        m.push({ programIdIndex: I, accountKeyIndexes: L, data: q });
      }
      const _ = Si(t),
        A = [];
      for (let E = 0; E < _; E++) {
        const I = new Ve(t.splice(0, Ni)),
          R = Si(t),
          L = t.splice(0, R),
          D = Si(t),
          q = t.splice(0, D);
        A.push({ accountKey: I, writableIndexes: L, readonlyIndexes: q });
      }
      return new a1({
        header: c,
        staticAccountKeys: f,
        recentBlockhash: y,
        compiledInstructions: m,
        addressTableLookups: A,
      });
    }
  };
const Wy = {
  deserializeMessageVersion(i) {
    const e = i[0],
      t = e & Hl;
    return t === e ? 'legacy' : t;
  },
  deserialize: (i) => {
    const e = Wy.deserializeMessageVersion(i);
    if (e === 'legacy') return $o.from(i);
    if (e === 0) return Vl.deserialize(i);
    throw new Error(`Transaction message version ${e} deserialization is not supported`);
  },
};
let nn;
(function (i) {
  (i[(i.BLOCKHEIGHT_EXCEEDED = 0)] = 'BLOCKHEIGHT_EXCEEDED'),
    (i[(i.PROCESSED = 1)] = 'PROCESSED'),
    (i[(i.TIMED_OUT = 2)] = 'TIMED_OUT'),
    (i[(i.NONCE_INVALID = 3)] = 'NONCE_INVALID');
})(nn || (nn = {}));
const LP = He.alloc(Pa).fill(0);
let pt = class {
    constructor(e) {
      (this.keys = void 0),
        (this.programId = void 0),
        (this.data = He.alloc(0)),
        (this.programId = e.programId),
        (this.keys = e.keys),
        e.data && (this.data = e.data);
    }
    toJSON() {
      return {
        keys: this.keys.map(({ pubkey: e, isSigner: t, isWritable: r }) => ({
          pubkey: e.toJSON(),
          isSigner: t,
          isWritable: r,
        })),
        programId: this.programId.toJSON(),
        data: [...this.data],
      };
    }
  },
  ct = class u1 {
    get signature() {
      return this.signatures.length > 0 ? this.signatures[0].signature : null;
    }
    constructor(e) {
      if (
        ((this.signatures = []),
        (this.feePayer = void 0),
        (this.instructions = []),
        (this.recentBlockhash = void 0),
        (this.lastValidBlockHeight = void 0),
        (this.nonceInfo = void 0),
        (this.minNonceContextSlot = void 0),
        (this._message = void 0),
        (this._json = void 0),
        !!e)
      )
        if (
          (e.feePayer && (this.feePayer = e.feePayer),
          e.signatures && (this.signatures = e.signatures),
          Object.prototype.hasOwnProperty.call(e, 'nonceInfo'))
        ) {
          const { minContextSlot: t, nonceInfo: r } = e;
          (this.minNonceContextSlot = t), (this.nonceInfo = r);
        } else if (Object.prototype.hasOwnProperty.call(e, 'lastValidBlockHeight')) {
          const { blockhash: t, lastValidBlockHeight: r } = e;
          (this.recentBlockhash = t), (this.lastValidBlockHeight = r);
        } else {
          const { recentBlockhash: t, nonceInfo: r } = e;
          r && (this.nonceInfo = r), (this.recentBlockhash = t);
        }
    }
    toJSON() {
      return {
        recentBlockhash: this.recentBlockhash || null,
        feePayer: this.feePayer ? this.feePayer.toJSON() : null,
        nonceInfo: this.nonceInfo
          ? {
              nonce: this.nonceInfo.nonce,
              nonceInstruction: this.nonceInfo.nonceInstruction.toJSON(),
            }
          : null,
        instructions: this.instructions.map((e) => e.toJSON()),
        signers: this.signatures.map(({ publicKey: e }) => e.toJSON()),
      };
    }
    add(...e) {
      if (e.length === 0) throw new Error('No instructions');
      return (
        e.forEach((t) => {
          'instructions' in t
            ? (this.instructions = this.instructions.concat(t.instructions))
            : 'data' in t && 'programId' in t && 'keys' in t
              ? this.instructions.push(t)
              : this.instructions.push(new pt(t));
        }),
        this
      );
    }
    compileMessage() {
      if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json))
        return this._message;
      let e, t;
      if (
        (this.nonceInfo
          ? ((e = this.nonceInfo.nonce),
            this.instructions[0] != this.nonceInfo.nonceInstruction
              ? (t = [this.nonceInfo.nonceInstruction, ...this.instructions])
              : (t = this.instructions))
          : ((e = this.recentBlockhash), (t = this.instructions)),
        !e)
      )
        throw new Error('Transaction recentBlockhash required');
      t.length < 1 && console.warn('No instructions provided');
      let r;
      if (this.feePayer) r = this.feePayer;
      else if (this.signatures.length > 0 && this.signatures[0].publicKey)
        r = this.signatures[0].publicKey;
      else throw new Error('Transaction fee payer required');
      for (let I = 0; I < t.length; I++)
        if (t[I].programId === void 0)
          throw new Error(`Transaction instruction index ${I} has undefined program id`);
      const s = [],
        n = [];
      t.forEach((I) => {
        I.keys.forEach((L) => {
          n.push({ ...L });
        });
        const R = I.programId.toString();
        s.includes(R) || s.push(R);
      }),
        s.forEach((I) => {
          n.push({ pubkey: new Ve(I), isSigner: !1, isWritable: !1 });
        });
      const c = [];
      n.forEach((I) => {
        const R = I.pubkey.toString(),
          L = c.findIndex((D) => D.pubkey.toString() === R);
        L > -1
          ? ((c[L].isWritable = c[L].isWritable || I.isWritable),
            (c[L].isSigner = c[L].isSigner || I.isSigner))
          : c.push(I);
      }),
        c.sort(function (I, R) {
          return I.isSigner !== R.isSigner
            ? I.isSigner
              ? -1
              : 1
            : I.isWritable !== R.isWritable
              ? I.isWritable
                ? -1
                : 1
              : I.pubkey.toBase58().localeCompare(R.pubkey.toBase58());
        });
      const f = c.findIndex((I) => I.pubkey.equals(r));
      if (f > -1) {
        const [I] = c.splice(f, 1);
        (I.isSigner = !0), (I.isWritable = !0), c.unshift(I);
      } else c.unshift({ pubkey: r, isSigner: !0, isWritable: !0 });
      for (const I of this.signatures) {
        const R = c.findIndex((L) => L.pubkey.equals(I.publicKey));
        if (R > -1)
          c[R].isSigner ||
            ((c[R].isSigner = !0),
            console.warn(
              'Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release.'
            ));
        else throw new Error(`unknown signer: ${I.publicKey.toString()}`);
      }
      let h = 0,
        y = 0,
        p = 0;
      const m = [],
        _ = [];
      c.forEach(({ pubkey: I, isSigner: R, isWritable: L }) => {
        R ? (m.push(I.toString()), (h += 1), L || (y += 1)) : (_.push(I.toString()), L || (p += 1));
      });
      const A = m.concat(_),
        E = t.map((I) => {
          const { data: R, programId: L } = I;
          return {
            programIdIndex: A.indexOf(L.toString()),
            accounts: I.keys.map((D) => A.indexOf(D.pubkey.toString())),
            data: ri.encode(R),
          };
        });
      return (
        E.forEach((I) => {
          Vt(I.programIdIndex >= 0), I.accounts.forEach((R) => Vt(R >= 0));
        }),
        new $o({
          header: {
            numRequiredSignatures: h,
            numReadonlySignedAccounts: y,
            numReadonlyUnsignedAccounts: p,
          },
          accountKeys: A,
          recentBlockhash: e,
          instructions: E,
        })
      );
    }
    _compile() {
      const e = this.compileMessage(),
        t = e.accountKeys.slice(0, e.header.numRequiredSignatures);
      return (
        (this.signatures.length === t.length &&
          this.signatures.every((s, n) => t[n].equals(s.publicKey))) ||
          (this.signatures = t.map((r) => ({ signature: null, publicKey: r }))),
        e
      );
    }
    serializeMessage() {
      return this._compile().serialize();
    }
    async getEstimatedFee(e) {
      return (await e.getFeeForMessage(this.compileMessage())).value;
    }
    setSigners(...e) {
      if (e.length === 0) throw new Error('No signers');
      const t = new Set();
      this.signatures = e
        .filter((r) => {
          const s = r.toString();
          return t.has(s) ? !1 : (t.add(s), !0);
        })
        .map((r) => ({ signature: null, publicKey: r }));
    }
    sign(...e) {
      if (e.length === 0) throw new Error('No signers');
      const t = new Set(),
        r = [];
      for (const n of e) {
        const c = n.publicKey.toString();
        t.has(c) || (t.add(c), r.push(n));
      }
      this.signatures = r.map((n) => ({ signature: null, publicKey: n.publicKey }));
      const s = this._compile();
      this._partialSign(s, ...r);
    }
    partialSign(...e) {
      if (e.length === 0) throw new Error('No signers');
      const t = new Set(),
        r = [];
      for (const n of e) {
        const c = n.publicKey.toString();
        t.has(c) || (t.add(c), r.push(n));
      }
      const s = this._compile();
      this._partialSign(s, ...r);
    }
    _partialSign(e, ...t) {
      const r = e.serialize();
      t.forEach((s) => {
        const n = Uy(r, s.secretKey);
        this._addSignature(s.publicKey, St(n));
      });
    }
    addSignature(e, t) {
      this._compile(), this._addSignature(e, t);
    }
    _addSignature(e, t) {
      Vt(t.length === 64);
      const r = this.signatures.findIndex((s) => e.equals(s.publicKey));
      if (r < 0) throw new Error(`unknown signer: ${e.toString()}`);
      this.signatures[r].signature = He.from(t);
    }
    verifySignatures(e) {
      return this._verifySignatures(this.serializeMessage(), e === void 0 ? !0 : e);
    }
    _verifySignatures(e, t) {
      for (const { signature: r, publicKey: s } of this.signatures)
        if (r === null) {
          if (t) return !1;
        } else if (!EP(r, e, s.toBytes())) return !1;
      return !0;
    }
    serialize(e) {
      const { requireAllSignatures: t, verifySignatures: r } = Object.assign(
          { requireAllSignatures: !0, verifySignatures: !0 },
          e
        ),
        s = this.serializeMessage();
      if (r && !this._verifySignatures(s, t)) throw new Error('Signature verification failed');
      return this._serialize(s);
    }
    _serialize(e) {
      const { signatures: t } = this,
        r = [];
      Ti(r, t.length);
      const s = r.length + t.length * 64 + e.length,
        n = He.alloc(s);
      return (
        Vt(t.length < 256),
        He.from(r).copy(n, 0),
        t.forEach(({ signature: c }, f) => {
          c !== null &&
            (Vt(c.length === 64, 'signature has invalid length'),
            He.from(c).copy(n, r.length + f * 64));
        }),
        e.copy(n, r.length + t.length * 64),
        Vt(n.length <= Co, `Transaction too large: ${n.length} > ${Co}`),
        n
      );
    }
    get keys() {
      return Vt(this.instructions.length === 1), this.instructions[0].keys.map((e) => e.pubkey);
    }
    get programId() {
      return Vt(this.instructions.length === 1), this.instructions[0].programId;
    }
    get data() {
      return Vt(this.instructions.length === 1), this.instructions[0].data;
    }
    static from(e) {
      let t = [...e];
      const r = Si(t);
      let s = [];
      for (let n = 0; n < r; n++) {
        const c = t.slice(0, Pa);
        (t = t.slice(Pa)), s.push(ri.encode(He.from(c)));
      }
      return u1.populate($o.from(t), s);
    }
    static populate(e, t = []) {
      const r = new u1();
      return (
        (r.recentBlockhash = e.recentBlockhash),
        e.header.numRequiredSignatures > 0 && (r.feePayer = e.accountKeys[0]),
        t.forEach((s, n) => {
          const c = {
            signature: s == ri.encode(LP) ? null : ri.decode(s),
            publicKey: e.accountKeys[n],
          };
          r.signatures.push(c);
        }),
        e.instructions.forEach((s) => {
          const n = s.accounts.map((c) => {
            const f = e.accountKeys[c];
            return {
              pubkey: f,
              isSigner:
                r.signatures.some((h) => h.publicKey.toString() === f.toString()) ||
                e.isAccountSigner(c),
              isWritable: e.isAccountWritable(c),
            };
          });
          r.instructions.push(
            new pt({ keys: n, programId: e.accountKeys[s.programIdIndex], data: ri.decode(s.data) })
          );
        }),
        (r._message = e),
        (r._json = r.toJSON()),
        r
      );
    }
  },
  NP = class M_ {
    constructor(e) {
      (this.payerKey = void 0),
        (this.instructions = void 0),
        (this.recentBlockhash = void 0),
        (this.payerKey = e.payerKey),
        (this.instructions = e.instructions),
        (this.recentBlockhash = e.recentBlockhash);
    }
    static decompile(e, t) {
      const { header: r, compiledInstructions: s, recentBlockhash: n } = e,
        {
          numRequiredSignatures: c,
          numReadonlySignedAccounts: f,
          numReadonlyUnsignedAccounts: h,
        } = r,
        y = c - f;
      Vt(y > 0, 'Message header is invalid');
      const p = e.staticAccountKeys.length - c - h;
      Vt(p >= 0, 'Message header is invalid');
      const m = e.getAccountKeys(t),
        _ = m.get(0);
      if (_ === void 0)
        throw new Error('Failed to decompile message because no account keys were found');
      const A = [];
      for (const E of s) {
        const I = [];
        for (const L of E.accountKeyIndexes) {
          const D = m.get(L);
          if (D === void 0) throw new Error(`Failed to find key for account key index ${L}`);
          const q = L < c;
          let H;
          q
            ? (H = L < y)
            : L < m.staticAccountKeys.length
              ? (H = L - c < p)
              : (H = L - m.staticAccountKeys.length < m.accountKeysFromLookups.writable.length),
            I.push({ pubkey: D, isSigner: L < r.numRequiredSignatures, isWritable: H });
        }
        const R = m.get(E.programIdIndex);
        if (R === void 0)
          throw new Error(`Failed to find program id for program id index ${E.programIdIndex}`);
        A.push(new pt({ programId: R, data: St(E.data), keys: I }));
      }
      return new M_({ payerKey: _, instructions: A, recentBlockhash: n });
    }
    compileToLegacyMessage() {
      return $o.compile({
        payerKey: this.payerKey,
        recentBlockhash: this.recentBlockhash,
        instructions: this.instructions,
      });
    }
    compileToV0Message(e) {
      return Vl.compile({
        payerKey: this.payerKey,
        recentBlockhash: this.recentBlockhash,
        instructions: this.instructions,
        addressLookupTableAccounts: e,
      });
    }
  },
  $P = class A_ {
    get version() {
      return this.message.version;
    }
    constructor(e, t) {
      if (((this.signatures = void 0), (this.message = void 0), t !== void 0))
        Vt(
          t.length === e.header.numRequiredSignatures,
          'Expected signatures length to be equal to the number of required signatures'
        ),
          (this.signatures = t);
      else {
        const r = [];
        for (let s = 0; s < e.header.numRequiredSignatures; s++) r.push(new Uint8Array(Pa));
        this.signatures = r;
      }
      this.message = e;
    }
    serialize() {
      const e = this.message.serialize(),
        t = Array();
      Ti(t, this.signatures.length);
      const r = We([
          ut(t.length, 'encodedSignaturesLength'),
          zt(RP(), this.signatures.length, 'signatures'),
          ut(e.length, 'serializedMessage'),
        ]),
        s = new Uint8Array(2048),
        n = r.encode(
          {
            encodedSignaturesLength: new Uint8Array(t),
            signatures: this.signatures,
            serializedMessage: e,
          },
          s
        );
      return s.slice(0, n);
    }
    static deserialize(e) {
      let t = [...e];
      const r = [],
        s = Si(t);
      for (let c = 0; c < s; c++) r.push(new Uint8Array(t.splice(0, Pa)));
      const n = Wy.deserialize(new Uint8Array(t));
      return new A_(n, r);
    }
    sign(e) {
      const t = this.message.serialize(),
        r = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
      for (const s of e) {
        const n = r.findIndex((c) => c.equals(s.publicKey));
        Vt(n >= 0, `Cannot sign with non signer key ${s.publicKey.toBase58()}`),
          (this.signatures[n] = Uy(t, s.secretKey));
      }
    }
    addSignature(e, t) {
      Vt(t.byteLength === 64, 'Signature must be 64 bytes long');
      const s = this.message.staticAccountKeys
        .slice(0, this.message.header.numRequiredSignatures)
        .findIndex((n) => n.equals(e));
      Vt(
        s >= 0,
        `Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`
      ),
        (this.signatures[s] = t);
    }
  };
const _n = new Ve('SysvarC1ock11111111111111111111111111111111'),
  DP = new Ve('SysvarEpochSchedu1e111111111111111111111111'),
  UP = new Ve('Sysvar1nstructions1111111111111111111111111'),
  If = new Ve('SysvarRecentB1ockHashes11111111111111111111'),
  In = new Ve('SysvarRent111111111111111111111111111111111'),
  zP = new Ve('SysvarRewards111111111111111111111111111111'),
  FP = new Ve('SysvarS1otHashes111111111111111111111111111'),
  qP = new Ve('SysvarS1otHistory11111111111111111111111111'),
  xf = new Ve('SysvarStakeHistory1111111111111111111111111');
async function ku(i, e, t, r) {
  const s = r && {
      skipPreflight: r.skipPreflight,
      preflightCommitment: r.preflightCommitment || r.commitment,
      maxRetries: r.maxRetries,
      minContextSlot: r.minContextSlot,
    },
    n = await i.sendTransaction(e, t, s);
  let c;
  if (e.recentBlockhash != null && e.lastValidBlockHeight != null)
    c = (
      await i.confirmTransaction(
        {
          abortSignal: r == null ? void 0 : r.abortSignal,
          signature: n,
          blockhash: e.recentBlockhash,
          lastValidBlockHeight: e.lastValidBlockHeight,
        },
        r && r.commitment
      )
    ).value;
  else if (e.minNonceContextSlot != null && e.nonceInfo != null) {
    const { nonceInstruction: f } = e.nonceInfo,
      h = f.keys[0].pubkey;
    c = (
      await i.confirmTransaction(
        {
          abortSignal: r == null ? void 0 : r.abortSignal,
          minContextSlot: e.minNonceContextSlot,
          nonceAccountPubkey: h,
          nonceValue: e.nonceInfo.nonce,
          signature: n,
        },
        r && r.commitment
      )
    ).value;
  } else
    (r == null ? void 0 : r.abortSignal) != null &&
      console.warn(
        'sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.'
      ),
      (c = (await i.confirmTransaction(n, r && r.commitment)).value);
  if (c.err) throw new Error(`Transaction ${n} failed (${JSON.stringify(c)})`);
  return n;
}
function Xo(i) {
  return new Promise((e) => setTimeout(e, i));
}
function $t(i, e) {
  const t = i.layout.span >= 0 ? i.layout.span : w_(i, e),
    r = He.alloc(t),
    s = Object.assign({ instruction: i.index }, e);
  return i.layout.encode(s, r), r;
}
function er(i, e) {
  let t;
  try {
    t = i.layout.decode(e);
  } catch (r) {
    throw new Error('invalid instruction; ' + r);
  }
  if (t.instruction !== i.index)
    throw new Error(
      `invalid instruction; instruction index mismatch ${t.instruction} != ${i.index}`
    );
  return t;
}
const E_ = Nt('lamportsPerSignature'),
  k_ = We([
    qe('version'),
    qe('state'),
    It('authorizedPubkey'),
    It('nonce'),
    We([E_], 'feeCalculator'),
  ]),
  c1 = k_.span;
let I_ = class x_ {
  constructor(e) {
    (this.authorizedPubkey = void 0),
      (this.nonce = void 0),
      (this.feeCalculator = void 0),
      (this.authorizedPubkey = e.authorizedPubkey),
      (this.nonce = e.nonce),
      (this.feeCalculator = e.feeCalculator);
  }
  static fromAccountData(e) {
    const t = k_.decode(St(e), 0);
    return new x_({
      authorizedPubkey: new Ve(t.authorizedPubkey),
      nonce: new Ve(t.nonce).toString(),
      feeCalculator: t.feeCalculator,
    });
  }
};
const WP = (i) => {
    const e = i.decode.bind(i),
      t = i.encode.bind(i);
    return { decode: e, encode: t };
  },
  KP = (i) => (e) => {
    const t = ut(i, e),
      { encode: r, decode: s } = WP(t),
      n = t;
    return (
      (n.decode = (c, f) => {
        const h = s(c, f);
        return E3(He.from(h));
      }),
      (n.encode = (c, f, h) => {
        const y = ql(c, i);
        return r(y, f, h);
      }),
      n
    );
  },
  Ta = KP(8);
let jP = class {
  constructor() {}
  static decodeInstructionType(e) {
    this.checkProgramId(e.programId);
    const r = qe('instruction').decode(e.data);
    let s;
    for (const [n, c] of Object.entries(Ar))
      if (c.index == r) {
        s = n;
        break;
      }
    if (!s) throw new Error('Instruction type incorrect; not a SystemInstruction');
    return s;
  }
  static decodeCreateAccount(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
    const { lamports: t, space: r, programId: s } = er(Ar.Create, e.data);
    return {
      fromPubkey: e.keys[0].pubkey,
      newAccountPubkey: e.keys[1].pubkey,
      lamports: t,
      space: r,
      programId: new Ve(s),
    };
  }
  static decodeTransfer(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
    const { lamports: t } = er(Ar.Transfer, e.data);
    return { fromPubkey: e.keys[0].pubkey, toPubkey: e.keys[1].pubkey, lamports: t };
  }
  static decodeTransferWithSeed(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
    const { lamports: t, seed: r, programId: s } = er(Ar.TransferWithSeed, e.data);
    return {
      fromPubkey: e.keys[0].pubkey,
      basePubkey: e.keys[1].pubkey,
      toPubkey: e.keys[2].pubkey,
      lamports: t,
      seed: r,
      programId: new Ve(s),
    };
  }
  static decodeAllocate(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 1);
    const { space: t } = er(Ar.Allocate, e.data);
    return { accountPubkey: e.keys[0].pubkey, space: t };
  }
  static decodeAllocateWithSeed(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 1);
    const { base: t, seed: r, space: s, programId: n } = er(Ar.AllocateWithSeed, e.data);
    return {
      accountPubkey: e.keys[0].pubkey,
      basePubkey: new Ve(t),
      seed: r,
      space: s,
      programId: new Ve(n),
    };
  }
  static decodeAssign(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 1);
    const { programId: t } = er(Ar.Assign, e.data);
    return { accountPubkey: e.keys[0].pubkey, programId: new Ve(t) };
  }
  static decodeAssignWithSeed(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 1);
    const { base: t, seed: r, programId: s } = er(Ar.AssignWithSeed, e.data);
    return {
      accountPubkey: e.keys[0].pubkey,
      basePubkey: new Ve(t),
      seed: r,
      programId: new Ve(s),
    };
  }
  static decodeCreateWithSeed(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
    const { base: t, seed: r, lamports: s, space: n, programId: c } = er(Ar.CreateWithSeed, e.data);
    return {
      fromPubkey: e.keys[0].pubkey,
      newAccountPubkey: e.keys[1].pubkey,
      basePubkey: new Ve(t),
      seed: r,
      lamports: s,
      space: n,
      programId: new Ve(c),
    };
  }
  static decodeNonceInitialize(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
    const { authorized: t } = er(Ar.InitializeNonceAccount, e.data);
    return { noncePubkey: e.keys[0].pubkey, authorizedPubkey: new Ve(t) };
  }
  static decodeNonceAdvance(e) {
    return (
      this.checkProgramId(e.programId),
      this.checkKeyLength(e.keys, 3),
      er(Ar.AdvanceNonceAccount, e.data),
      { noncePubkey: e.keys[0].pubkey, authorizedPubkey: e.keys[2].pubkey }
    );
  }
  static decodeNonceWithdraw(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 5);
    const { lamports: t } = er(Ar.WithdrawNonceAccount, e.data);
    return {
      noncePubkey: e.keys[0].pubkey,
      toPubkey: e.keys[1].pubkey,
      authorizedPubkey: e.keys[4].pubkey,
      lamports: t,
    };
  }
  static decodeNonceAuthorize(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
    const { authorized: t } = er(Ar.AuthorizeNonceAccount, e.data);
    return {
      noncePubkey: e.keys[0].pubkey,
      authorizedPubkey: e.keys[1].pubkey,
      newAuthorizedPubkey: new Ve(t),
    };
  }
  static checkProgramId(e) {
    if (!e.equals(Ur.programId))
      throw new Error('invalid instruction; programId is not SystemProgram');
  }
  static checkKeyLength(e, t) {
    if (e.length < t)
      throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`);
  }
};
const Ar = Object.freeze({
  Create: {
    index: 0,
    layout: We([qe('instruction'), Ir('lamports'), Ir('space'), It('programId')]),
  },
  Assign: { index: 1, layout: We([qe('instruction'), It('programId')]) },
  Transfer: { index: 2, layout: We([qe('instruction'), Ta('lamports')]) },
  CreateWithSeed: {
    index: 3,
    layout: We([
      qe('instruction'),
      It('base'),
      is('seed'),
      Ir('lamports'),
      Ir('space'),
      It('programId'),
    ]),
  },
  AdvanceNonceAccount: { index: 4, layout: We([qe('instruction')]) },
  WithdrawNonceAccount: { index: 5, layout: We([qe('instruction'), Ir('lamports')]) },
  InitializeNonceAccount: { index: 6, layout: We([qe('instruction'), It('authorized')]) },
  AuthorizeNonceAccount: { index: 7, layout: We([qe('instruction'), It('authorized')]) },
  Allocate: { index: 8, layout: We([qe('instruction'), Ir('space')]) },
  AllocateWithSeed: {
    index: 9,
    layout: We([qe('instruction'), It('base'), is('seed'), Ir('space'), It('programId')]),
  },
  AssignWithSeed: {
    index: 10,
    layout: We([qe('instruction'), It('base'), is('seed'), It('programId')]),
  },
  TransferWithSeed: {
    index: 11,
    layout: We([qe('instruction'), Ta('lamports'), is('seed'), It('programId')]),
  },
  UpgradeNonceAccount: { index: 12, layout: We([qe('instruction')]) },
});
let Ur = class f1 {
  constructor() {}
  static createAccount(e) {
    const t = Ar.Create,
      r = $t(t, { lamports: e.lamports, space: e.space, programId: St(e.programId.toBuffer()) });
    return new pt({
      keys: [
        { pubkey: e.fromPubkey, isSigner: !0, isWritable: !0 },
        { pubkey: e.newAccountPubkey, isSigner: !0, isWritable: !0 },
      ],
      programId: this.programId,
      data: r,
    });
  }
  static transfer(e) {
    let t, r;
    if ('basePubkey' in e) {
      const s = Ar.TransferWithSeed;
      (t = $t(s, {
        lamports: BigInt(e.lamports),
        seed: e.seed,
        programId: St(e.programId.toBuffer()),
      })),
        (r = [
          { pubkey: e.fromPubkey, isSigner: !1, isWritable: !0 },
          { pubkey: e.basePubkey, isSigner: !0, isWritable: !1 },
          { pubkey: e.toPubkey, isSigner: !1, isWritable: !0 },
        ]);
    } else {
      const s = Ar.Transfer;
      (t = $t(s, { lamports: BigInt(e.lamports) })),
        (r = [
          { pubkey: e.fromPubkey, isSigner: !0, isWritable: !0 },
          { pubkey: e.toPubkey, isSigner: !1, isWritable: !0 },
        ]);
    }
    return new pt({ keys: r, programId: this.programId, data: t });
  }
  static assign(e) {
    let t, r;
    if ('basePubkey' in e) {
      const s = Ar.AssignWithSeed;
      (t = $t(s, {
        base: St(e.basePubkey.toBuffer()),
        seed: e.seed,
        programId: St(e.programId.toBuffer()),
      })),
        (r = [
          { pubkey: e.accountPubkey, isSigner: !1, isWritable: !0 },
          { pubkey: e.basePubkey, isSigner: !0, isWritable: !1 },
        ]);
    } else {
      const s = Ar.Assign;
      (t = $t(s, { programId: St(e.programId.toBuffer()) })),
        (r = [{ pubkey: e.accountPubkey, isSigner: !0, isWritable: !0 }]);
    }
    return new pt({ keys: r, programId: this.programId, data: t });
  }
  static createAccountWithSeed(e) {
    const t = Ar.CreateWithSeed,
      r = $t(t, {
        base: St(e.basePubkey.toBuffer()),
        seed: e.seed,
        lamports: e.lamports,
        space: e.space,
        programId: St(e.programId.toBuffer()),
      });
    let s = [
      { pubkey: e.fromPubkey, isSigner: !0, isWritable: !0 },
      { pubkey: e.newAccountPubkey, isSigner: !1, isWritable: !0 },
    ];
    return (
      e.basePubkey != e.fromPubkey &&
        s.push({ pubkey: e.basePubkey, isSigner: !0, isWritable: !1 }),
      new pt({ keys: s, programId: this.programId, data: r })
    );
  }
  static createNonceAccount(e) {
    const t = new ct();
    'basePubkey' in e && 'seed' in e
      ? t.add(
          f1.createAccountWithSeed({
            fromPubkey: e.fromPubkey,
            newAccountPubkey: e.noncePubkey,
            basePubkey: e.basePubkey,
            seed: e.seed,
            lamports: e.lamports,
            space: c1,
            programId: this.programId,
          })
        )
      : t.add(
          f1.createAccount({
            fromPubkey: e.fromPubkey,
            newAccountPubkey: e.noncePubkey,
            lamports: e.lamports,
            space: c1,
            programId: this.programId,
          })
        );
    const r = { noncePubkey: e.noncePubkey, authorizedPubkey: e.authorizedPubkey };
    return t.add(this.nonceInitialize(r)), t;
  }
  static nonceInitialize(e) {
    const t = Ar.InitializeNonceAccount,
      r = $t(t, { authorized: St(e.authorizedPubkey.toBuffer()) }),
      s = {
        keys: [
          { pubkey: e.noncePubkey, isSigner: !1, isWritable: !0 },
          { pubkey: If, isSigner: !1, isWritable: !1 },
          { pubkey: In, isSigner: !1, isWritable: !1 },
        ],
        programId: this.programId,
        data: r,
      };
    return new pt(s);
  }
  static nonceAdvance(e) {
    const t = Ar.AdvanceNonceAccount,
      r = $t(t),
      s = {
        keys: [
          { pubkey: e.noncePubkey, isSigner: !1, isWritable: !0 },
          { pubkey: If, isSigner: !1, isWritable: !1 },
          { pubkey: e.authorizedPubkey, isSigner: !0, isWritable: !1 },
        ],
        programId: this.programId,
        data: r,
      };
    return new pt(s);
  }
  static nonceWithdraw(e) {
    const t = Ar.WithdrawNonceAccount,
      r = $t(t, { lamports: e.lamports });
    return new pt({
      keys: [
        { pubkey: e.noncePubkey, isSigner: !1, isWritable: !0 },
        { pubkey: e.toPubkey, isSigner: !1, isWritable: !0 },
        { pubkey: If, isSigner: !1, isWritable: !1 },
        { pubkey: In, isSigner: !1, isWritable: !1 },
        { pubkey: e.authorizedPubkey, isSigner: !0, isWritable: !1 },
      ],
      programId: this.programId,
      data: r,
    });
  }
  static nonceAuthorize(e) {
    const t = Ar.AuthorizeNonceAccount,
      r = $t(t, { authorized: St(e.newAuthorizedPubkey.toBuffer()) });
    return new pt({
      keys: [
        { pubkey: e.noncePubkey, isSigner: !1, isWritable: !0 },
        { pubkey: e.authorizedPubkey, isSigner: !0, isWritable: !1 },
      ],
      programId: this.programId,
      data: r,
    });
  }
  static allocate(e) {
    let t, r;
    if ('basePubkey' in e) {
      const s = Ar.AllocateWithSeed;
      (t = $t(s, {
        base: St(e.basePubkey.toBuffer()),
        seed: e.seed,
        space: e.space,
        programId: St(e.programId.toBuffer()),
      })),
        (r = [
          { pubkey: e.accountPubkey, isSigner: !1, isWritable: !0 },
          { pubkey: e.basePubkey, isSigner: !0, isWritable: !1 },
        ]);
    } else {
      const s = Ar.Allocate;
      (t = $t(s, { space: e.space })),
        (r = [{ pubkey: e.accountPubkey, isSigner: !0, isWritable: !0 }]);
    }
    return new pt({ keys: r, programId: this.programId, data: t });
  }
};
Ur.programId = new Ve('11111111111111111111111111111111');
const HP = Co - 300;
let ol = class l1 {
  constructor() {}
  static getMinNumSignatures(e) {
    return 2 * (Math.ceil(e / l1.chunkSize) + 1 + 1);
  }
  static async load(e, t, r, s, n) {
    {
      const m = await e.getMinimumBalanceForRentExemption(n.length),
        _ = await e.getAccountInfo(r.publicKey, 'confirmed');
      let A = null;
      if (_ !== null) {
        if (_.executable)
          return console.error('Program load failed, account is already executable'), !1;
        _.data.length !== n.length &&
          ((A = A || new ct()),
          A.add(Ur.allocate({ accountPubkey: r.publicKey, space: n.length }))),
          _.owner.equals(s) ||
            ((A = A || new ct()), A.add(Ur.assign({ accountPubkey: r.publicKey, programId: s }))),
          _.lamports < m &&
            ((A = A || new ct()),
            A.add(
              Ur.transfer({
                fromPubkey: t.publicKey,
                toPubkey: r.publicKey,
                lamports: m - _.lamports,
              })
            ));
      } else
        A = new ct().add(
          Ur.createAccount({
            fromPubkey: t.publicKey,
            newAccountPubkey: r.publicKey,
            lamports: m > 0 ? m : 1,
            space: n.length,
            programId: s,
          })
        );
      A !== null && (await ku(e, A, [t, r], { commitment: 'confirmed' }));
    }
    const c = We([
        qe('instruction'),
        qe('offset'),
        qe('bytesLength'),
        qe('bytesLengthPadding'),
        zt(tt('byte'), _i(qe(), -8), 'bytes'),
      ]),
      f = l1.chunkSize;
    let h = 0,
      y = n,
      p = [];
    for (; y.length > 0; ) {
      const m = y.slice(0, f),
        _ = He.alloc(f + 16);
      c.encode({ instruction: 0, offset: h, bytes: m, bytesLength: 0, bytesLengthPadding: 0 }, _);
      const A = new ct().add({
        keys: [{ pubkey: r.publicKey, isSigner: !0, isWritable: !0 }],
        programId: s,
        data: _,
      });
      p.push(ku(e, A, [t, r], { commitment: 'confirmed' })),
        e._rpcEndpoint.includes('solana.com') && (await Xo(1e3 / 4)),
        (h += f),
        (y = y.slice(f));
    }
    await Promise.all(p);
    {
      const m = We([qe('instruction')]),
        _ = He.alloc(m.span);
      m.encode({ instruction: 1 }, _);
      const A = new ct().add({
        keys: [
          { pubkey: r.publicKey, isSigner: !0, isWritable: !0 },
          { pubkey: In, isSigner: !1, isWritable: !1 },
        ],
        programId: s,
        data: _,
      });
      await ku(e, A, [t, r], { commitment: 'confirmed' });
    }
    return !0;
  }
};
ol.chunkSize = HP;
const VP = new Ve('BPFLoader2111111111111111111111111111111111');
let GP = class {
  static getMinNumSignatures(e) {
    return ol.getMinNumSignatures(e);
  }
  static load(e, t, r, s, n) {
    return ol.load(e, t, r, n, s);
  }
};
var YP = Object.prototype.toString,
  ZP =
    Object.keys ||
    function (i) {
      var e = [];
      for (var t in i) e.push(t);
      return e;
    };
function bu(i, e) {
  var t, r, s, n, c, f, h;
  if (i === !0) return 'true';
  if (i === !1) return 'false';
  switch (typeof i) {
    case 'object':
      if (i === null) return null;
      if (i.toJSON && typeof i.toJSON == 'function') return bu(i.toJSON(), e);
      if (((h = YP.call(i)), h === '[object Array]')) {
        for (s = '[', r = i.length - 1, t = 0; t < r; t++) s += bu(i[t], !0) + ',';
        return r > -1 && (s += bu(i[t], !0)), s + ']';
      } else if (h === '[object Object]') {
        for (n = ZP(i).sort(), r = n.length, s = '', t = 0; t < r; )
          (c = n[t]),
            (f = bu(i[c], !1)),
            f !== void 0 && (s && (s += ','), (s += JSON.stringify(c) + ':' + f)),
            t++;
        return '{' + s + '}';
      } else return JSON.stringify(i);
    case 'function':
    case 'undefined':
      return e ? null : void 0;
    case 'string':
      return JSON.stringify(i);
    default:
      return isFinite(i) ? i : null;
  }
}
var JP = function (i) {
    var e = bu(i, !1);
    if (e !== void 0) return '' + e;
  },
  vw = JP;
const du = 32;
function pp(i) {
  let e = 0;
  for (; i > 1; ) (i /= 2), e++;
  return e;
}
function XP(i) {
  return i === 0
    ? 1
    : (i--,
      (i |= i >> 1),
      (i |= i >> 2),
      (i |= i >> 4),
      (i |= i >> 8),
      (i |= i >> 16),
      (i |= i >> 32),
      i + 1);
}
let B_ = class {
    constructor(e, t, r, s, n) {
      (this.slotsPerEpoch = void 0),
        (this.leaderScheduleSlotOffset = void 0),
        (this.warmup = void 0),
        (this.firstNormalEpoch = void 0),
        (this.firstNormalSlot = void 0),
        (this.slotsPerEpoch = e),
        (this.leaderScheduleSlotOffset = t),
        (this.warmup = r),
        (this.firstNormalEpoch = s),
        (this.firstNormalSlot = n);
    }
    getEpoch(e) {
      return this.getEpochAndSlotIndex(e)[0];
    }
    getEpochAndSlotIndex(e) {
      if (e < this.firstNormalSlot) {
        const t = pp(XP(e + du + 1)) - pp(du) - 1,
          r = this.getSlotsInEpoch(t),
          s = e - (r - du);
        return [t, s];
      } else {
        const t = e - this.firstNormalSlot,
          r = Math.floor(t / this.slotsPerEpoch),
          s = this.firstNormalEpoch + r,
          n = t % this.slotsPerEpoch;
        return [s, n];
      }
    }
    getFirstSlotInEpoch(e) {
      return e <= this.firstNormalEpoch
        ? (Math.pow(2, e) - 1) * du
        : (e - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;
    }
    getLastSlotInEpoch(e) {
      return this.getFirstSlotInEpoch(e) + this.getSlotsInEpoch(e) - 1;
    }
    getSlotsInEpoch(e) {
      return e < this.firstNormalEpoch ? Math.pow(2, e + pp(du)) : this.slotsPerEpoch;
    }
  },
  h1 = class extends Error {
    constructor(e, t) {
      super(e), (this.logs = void 0), (this.logs = t);
    }
  };
const QP = {
  JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
  JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,
  JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
  JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
  JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,
  JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
  JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
  JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
  JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
  JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
  JSON_RPC_SCAN_ERROR: -32012,
  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
  JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
  JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
  JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016,
};
let nt = class extends Error {
  constructor({ code: e, message: t, data: r }, s) {
    super(s != null ? `${s}: ${t}` : t),
      (this.code = void 0),
      (this.data = void 0),
      (this.code = e),
      (this.data = r),
      (this.name = 'SolanaJSONRPCError');
  }
};
var eT = globalThis.fetch;
let tT = class extends U3 {
  constructor(e, t, r) {
    const s = (n) => {
      const c = F3(n, {
        autoconnect: !0,
        max_reconnects: 5,
        reconnect: !0,
        reconnect_interval: 1e3,
        ...t,
      });
      return 'socket' in c ? (this.underlyingSocket = c.socket) : (this.underlyingSocket = c), c;
    };
    super(s, e, t, r), (this.underlyingSocket = void 0);
  }
  call(...e) {
    var r;
    const t = (r = this.underlyingSocket) == null ? void 0 : r.readyState;
    return t === 1
      ? super.call(...e)
      : Promise.reject(
          new Error(
            'Tried to call a JSON-RPC method `' +
              e[0] +
              '` but the socket was not `CONNECTING` or `OPEN` (`readyState` was ' +
              t +
              ')'
          )
        );
  }
  notify(...e) {
    var r;
    const t = (r = this.underlyingSocket) == null ? void 0 : r.readyState;
    return t === 1
      ? super.notify(...e)
      : Promise.reject(
          new Error(
            'Tried to send a JSON-RPC notification `' +
              e[0] +
              '` but the socket was not `CONNECTING` or `OPEN` (`readyState` was ' +
              t +
              ')'
          )
        );
  }
};
const rT = 160,
  iT = 64,
  nT = rT / iT,
  oT = 1e3 / nT;
function sT(i, e) {
  let t;
  try {
    t = i.layout.decode(e);
  } catch (r) {
    throw new Error('invalid instruction; ' + r);
  }
  if (t.typeIndex !== i.index)
    throw new Error(`invalid account data; account type mismatch ${t.typeIndex} != ${i.index}`);
  return t;
}
const mw = 56;
let d1 = class {
  constructor(e) {
    (this.key = void 0), (this.state = void 0), (this.key = e.key), (this.state = e.state);
  }
  isActive() {
    const e = BigInt('0xffffffffffffffff');
    return this.state.deactivationSlot === e;
  }
  static deserialize(e) {
    const t = sT(aT, e),
      r = e.length - mw;
    Vt(r >= 0, 'lookup table is invalid'), Vt(r % 32 === 0, 'lookup table is invalid');
    const s = r / 32,
      { addresses: n } = We([zt(It(), s, 'addresses')]).decode(e.slice(mw));
    return {
      deactivationSlot: t.deactivationSlot,
      lastExtendedSlot: t.lastExtendedSlot,
      lastExtendedSlotStartIndex: t.lastExtendedStartIndex,
      authority: t.authority.length !== 0 ? new Ve(t.authority[0]) : void 0,
      addresses: n.map((c) => new Ve(c)),
    };
  }
};
const aT = {
    index: 1,
    layout: We([
      qe('typeIndex'),
      Ta('deactivationSlot'),
      Nt('lastExtendedSlot'),
      tt('lastExtendedStartIndex'),
      tt(),
      zt(It(), _i(tt(), -1), 'authority'),
    ]),
  },
  uT = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
function cT(i) {
  const e = i.match(uT);
  if (e == null) throw TypeError(`Failed to validate endpoint URL \`${i}\``);
  const [t, r, s, n] = e,
    c = i.startsWith('https:') ? 'wss:' : 'ws:',
    f = s == null ? null : parseInt(s.slice(1), 10),
    h = f == null ? '' : `:${f + 1}`;
  return `${c}//${r}${h}${n}`;
}
const zr = Kn(Za(Ve), we(), (i) => new Ve(i)),
  R_ = Ja([we(), ft('base64')]),
  Ky = Kn(Za(He), R_, (i) => He.from(i[0], 'base64')),
  P_ = 30 * 1e3;
function fT(i) {
  if (/^https?:/.test(i) === !1)
    throw new TypeError('Endpoint URL must start with `http:` or `https:`.');
  return i;
}
function Rr(i) {
  let e, t;
  if (typeof i == 'string') e = i;
  else if (i) {
    const { commitment: r, ...s } = i;
    (e = r), (t = s);
  }
  return { commitment: e, config: t };
}
function T_(i) {
  return ar([
    pe({ jsonrpc: ft('2.0'), id: we(), result: i }),
    pe({ jsonrpc: ft('2.0'), id: we(), error: pe({ code: Wn(), message: we(), data: Ge(I3()) }) }),
  ]);
}
const lT = T_(Wn());
function Et(i) {
  return Kn(T_(i), lT, (e) => ('error' in e ? e : { ...e, result: Se(e.result, i) }));
}
function $r(i) {
  return Et(pe({ context: pe({ slot: ee() }), value: i }));
}
function Gl(i) {
  return pe({ context: pe({ slot: ee() }), value: i });
}
function yp(i, e) {
  return i === 0
    ? new Vl({
        header: e.header,
        staticAccountKeys: e.accountKeys.map((t) => new Ve(t)),
        recentBlockhash: e.recentBlockhash,
        compiledInstructions: e.instructions.map((t) => ({
          programIdIndex: t.programIdIndex,
          accountKeyIndexes: t.accounts,
          data: ri.decode(t.data),
        })),
        addressTableLookups: e.addressTableLookups,
      })
    : new $o(e);
}
const hT = pe({
    foundation: ee(),
    foundationTerm: ee(),
    initial: ee(),
    taper: ee(),
    terminal: ee(),
  }),
  dT = Et(
    Te(
      Pe(
        pe({
          epoch: ee(),
          effectiveSlot: ee(),
          amount: ee(),
          postBalance: ee(),
          commission: Ge(Pe(ee())),
        })
      )
    )
  ),
  pT = pe({ total: ee(), validator: ee(), foundation: ee(), epoch: ee() }),
  yT = pe({
    epoch: ee(),
    slotIndex: ee(),
    slotsInEpoch: ee(),
    absoluteSlot: ee(),
    blockHeight: Ge(ee()),
    transactionCount: Ge(ee()),
  }),
  gT = pe({
    slotsPerEpoch: ee(),
    leaderScheduleSlotOffset: ee(),
    warmup: Xr(),
    firstNormalEpoch: ee(),
    firstNormalSlot: ee(),
  }),
  bT = Wl(we(), Te(ee())),
  Ts = Pe(ar([pe({}), we()])),
  vT = pe({ err: Ts }),
  mT = ft('receivedSignature'),
  wT = pe({ 'solana-core': we(), 'feature-set': Ge(ee()) }),
  ww = $r(
    pe({
      err: Pe(ar([pe({}), we()])),
      logs: Pe(Te(we())),
      accounts: Ge(
        Pe(
          Te(
            Pe(
              pe({
                executable: Xr(),
                owner: we(),
                lamports: ee(),
                data: Te(we()),
                rentEpoch: Ge(ee()),
              })
            )
          )
        )
      ),
      unitsConsumed: Ge(ee()),
      returnData: Ge(Pe(pe({ programId: we(), data: Ja([we(), ft('base64')]) }))),
    })
  ),
  _T = $r(pe({ byIdentity: Wl(we(), Te(ee())), range: pe({ firstSlot: ee(), lastSlot: ee() }) }));
function ST(i, e, t, r, s, n) {
  const c = t || eT;
  let f;
  n != null &&
    console.warn(
      'You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.'
    );
  let h;
  return (
    r &&
      (h = async (p, m) => {
        const _ = await new Promise((A, E) => {
          try {
            r(p, m, (I, R) => A([I, R]));
          } catch (I) {
            E(I);
          }
        });
        return await c(..._);
      }),
    new B3(async (p, m) => {
      const _ = {
        method: 'POST',
        body: p,
        agent: f,
        headers: Object.assign({ 'Content-Type': 'application/json' }, e || {}, _O),
      };
      try {
        let A = 5,
          E,
          I = 500;
        for (
          ;
          h ? (E = await h(i, _)) : (E = await c(i, _)),
            !(E.status !== 429 || s === !0 || ((A -= 1), A === 0));

        )
          console.log(
            `Server responded with ${E.status} ${E.statusText}.  Retrying after ${I}ms delay...`
          ),
            await Xo(I),
            (I *= 2);
        const R = await E.text();
        E.ok ? m(null, R) : m(new Error(`${E.status} ${E.statusText}: ${R}`));
      } catch (A) {
        A instanceof Error && m(A);
      }
    }, {})
  );
}
function MT(i) {
  return (e, t) =>
    new Promise((r, s) => {
      i.request(e, t, (n, c) => {
        if (n) {
          s(n);
          return;
        }
        r(c);
      });
    });
}
function AT(i) {
  return (e) =>
    new Promise((t, r) => {
      e.length === 0 && t([]);
      const s = e.map((n) => i.request(n.methodName, n.args));
      i.request(s, (n, c) => {
        if (n) {
          r(n);
          return;
        }
        t(c);
      });
    });
}
const ET = Et(hT),
  kT = Et(pT),
  IT = Et(yT),
  xT = Et(gT),
  BT = Et(bT),
  RT = Et(ee()),
  PT = $r(
    pe({ total: ee(), circulating: ee(), nonCirculating: ee(), nonCirculatingAccounts: Te(zr) })
  ),
  p1 = pe({ amount: we(), uiAmount: Pe(ee()), decimals: ee(), uiAmountString: Ge(we()) }),
  TT = $r(
    Te(
      pe({
        address: zr,
        amount: we(),
        uiAmount: Pe(ee()),
        decimals: ee(),
        uiAmountString: Ge(we()),
      })
    )
  ),
  OT = $r(
    Te(
      pe({
        pubkey: zr,
        account: pe({ executable: Xr(), owner: zr, lamports: ee(), data: Ky, rentEpoch: ee() }),
      })
    )
  ),
  y1 = pe({ program: we(), parsed: Wn(), space: ee() }),
  CT = $r(
    Te(
      pe({
        pubkey: zr,
        account: pe({ executable: Xr(), owner: zr, lamports: ee(), data: y1, rentEpoch: ee() }),
      })
    )
  ),
  LT = $r(Te(pe({ lamports: ee(), address: zr }))),
  Du = pe({ executable: Xr(), owner: zr, lamports: ee(), data: Ky, rentEpoch: ee() }),
  NT = pe({ pubkey: zr, account: Du }),
  $T = Kn(ar([Za(He), y1]), ar([R_, y1]), (i) => (Array.isArray(i) ? Se(i, Ky) : i)),
  g1 = pe({ executable: Xr(), owner: zr, lamports: ee(), data: $T, rentEpoch: ee() }),
  DT = pe({ pubkey: zr, account: g1 }),
  UT = pe({
    state: ar([ft('active'), ft('inactive'), ft('activating'), ft('deactivating')]),
    active: ee(),
    inactive: ee(),
  }),
  zT = Et(
    Te(pe({ signature: we(), slot: ee(), err: Ts, memo: Pe(we()), blockTime: Ge(Pe(ee())) }))
  ),
  FT = Et(
    Te(pe({ signature: we(), slot: ee(), err: Ts, memo: Pe(we()), blockTime: Ge(Pe(ee())) }))
  ),
  qT = pe({ subscription: ee(), result: Gl(Du) }),
  WT = pe({ pubkey: zr, account: Du }),
  KT = pe({ subscription: ee(), result: Gl(WT) }),
  jT = pe({ parent: ee(), slot: ee(), root: ee() }),
  HT = pe({ subscription: ee(), result: jT }),
  VT = ar([
    pe({
      type: ar([
        ft('firstShredReceived'),
        ft('completed'),
        ft('optimisticConfirmation'),
        ft('root'),
      ]),
      slot: ee(),
      timestamp: ee(),
    }),
    pe({ type: ft('createdBank'), parent: ee(), slot: ee(), timestamp: ee() }),
    pe({
      type: ft('frozen'),
      slot: ee(),
      timestamp: ee(),
      stats: pe({
        numTransactionEntries: ee(),
        numSuccessfulTransactions: ee(),
        numFailedTransactions: ee(),
        maxTransactionsPerEntry: ee(),
      }),
    }),
    pe({ type: ft('dead'), slot: ee(), timestamp: ee(), err: we() }),
  ]),
  GT = pe({ subscription: ee(), result: VT }),
  YT = pe({ subscription: ee(), result: Gl(ar([vT, mT])) }),
  ZT = pe({ subscription: ee(), result: ee() }),
  JT = pe({ pubkey: we(), gossip: Pe(we()), tpu: Pe(we()), rpc: Pe(we()), version: Pe(we()) }),
  _w = pe({
    votePubkey: we(),
    nodePubkey: we(),
    activatedStake: ee(),
    epochVoteAccount: Xr(),
    epochCredits: Te(Ja([ee(), ee(), ee()])),
    commission: ee(),
    lastVote: ee(),
    rootSlot: Pe(ee()),
  }),
  XT = Et(pe({ current: Te(_w), delinquent: Te(_w) })),
  QT = ar([ft('processed'), ft('confirmed'), ft('finalized')]),
  eO = pe({ slot: ee(), confirmations: Pe(ee()), err: Ts, confirmationStatus: Ge(QT) }),
  tO = $r(Te(Pe(eO))),
  rO = Et(ee()),
  O_ = pe({ accountKey: zr, writableIndexes: Te(ee()), readonlyIndexes: Te(ee()) }),
  jy = pe({
    signatures: Te(we()),
    message: pe({
      accountKeys: Te(we()),
      header: pe({
        numRequiredSignatures: ee(),
        numReadonlySignedAccounts: ee(),
        numReadonlyUnsignedAccounts: ee(),
      }),
      instructions: Te(pe({ accounts: Te(ee()), data: we(), programIdIndex: ee() })),
      recentBlockhash: we(),
      addressTableLookups: Ge(Te(O_)),
    }),
  }),
  C_ = pe({
    pubkey: zr,
    signer: Xr(),
    writable: Xr(),
    source: Ge(ar([ft('transaction'), ft('lookupTable')])),
  }),
  L_ = pe({ accountKeys: Te(C_), signatures: Te(we()) }),
  N_ = pe({ parsed: Wn(), program: we(), programId: zr }),
  $_ = pe({ accounts: Te(zr), data: we(), programId: zr }),
  iO = ar([$_, N_]),
  nO = ar([
    pe({ parsed: Wn(), program: we(), programId: we() }),
    pe({ accounts: Te(we()), data: we(), programId: we() }),
  ]),
  D_ = Kn(iO, nO, (i) => ('accounts' in i ? Se(i, $_) : Se(i, N_))),
  U_ = pe({
    signatures: Te(we()),
    message: pe({
      accountKeys: Te(C_),
      instructions: Te(D_),
      recentBlockhash: we(),
      addressTableLookups: Ge(Pe(Te(O_))),
    }),
  }),
  sl = pe({ accountIndex: ee(), mint: we(), owner: Ge(we()), uiTokenAmount: p1 }),
  z_ = pe({ writable: Te(zr), readonly: Te(zr) }),
  Yl = pe({
    err: Ts,
    fee: ee(),
    innerInstructions: Ge(
      Pe(
        Te(
          pe({
            index: ee(),
            instructions: Te(pe({ accounts: Te(ee()), data: we(), programIdIndex: ee() })),
          })
        )
      )
    ),
    preBalances: Te(ee()),
    postBalances: Te(ee()),
    logMessages: Ge(Pe(Te(we()))),
    preTokenBalances: Ge(Pe(Te(sl))),
    postTokenBalances: Ge(Pe(Te(sl))),
    loadedAddresses: Ge(z_),
    computeUnitsConsumed: Ge(ee()),
  }),
  Hy = pe({
    err: Ts,
    fee: ee(),
    innerInstructions: Ge(Pe(Te(pe({ index: ee(), instructions: Te(D_) })))),
    preBalances: Te(ee()),
    postBalances: Te(ee()),
    logMessages: Ge(Pe(Te(we()))),
    preTokenBalances: Ge(Pe(Te(sl))),
    postTokenBalances: Ge(Pe(Te(sl))),
    loadedAddresses: Ge(z_),
    computeUnitsConsumed: Ge(ee()),
  }),
  Xa = ar([ft(0), ft('legacy')]),
  Os = pe({
    pubkey: we(),
    lamports: ee(),
    postBalance: Pe(ee()),
    rewardType: Pe(we()),
    commission: Ge(Pe(ee())),
  }),
  oO = Et(
    Pe(
      pe({
        blockhash: we(),
        previousBlockhash: we(),
        parentSlot: ee(),
        transactions: Te(pe({ transaction: jy, meta: Pe(Yl), version: Ge(Xa) })),
        rewards: Ge(Te(Os)),
        blockTime: Pe(ee()),
        blockHeight: Pe(ee()),
      })
    )
  ),
  sO = Et(
    Pe(
      pe({
        blockhash: we(),
        previousBlockhash: we(),
        parentSlot: ee(),
        rewards: Ge(Te(Os)),
        blockTime: Pe(ee()),
        blockHeight: Pe(ee()),
      })
    )
  ),
  aO = Et(
    Pe(
      pe({
        blockhash: we(),
        previousBlockhash: we(),
        parentSlot: ee(),
        transactions: Te(pe({ transaction: L_, meta: Pe(Yl), version: Ge(Xa) })),
        rewards: Ge(Te(Os)),
        blockTime: Pe(ee()),
        blockHeight: Pe(ee()),
      })
    )
  ),
  uO = Et(
    Pe(
      pe({
        blockhash: we(),
        previousBlockhash: we(),
        parentSlot: ee(),
        transactions: Te(pe({ transaction: U_, meta: Pe(Hy), version: Ge(Xa) })),
        rewards: Ge(Te(Os)),
        blockTime: Pe(ee()),
        blockHeight: Pe(ee()),
      })
    )
  ),
  cO = Et(
    Pe(
      pe({
        blockhash: we(),
        previousBlockhash: we(),
        parentSlot: ee(),
        transactions: Te(pe({ transaction: L_, meta: Pe(Hy), version: Ge(Xa) })),
        rewards: Ge(Te(Os)),
        blockTime: Pe(ee()),
        blockHeight: Pe(ee()),
      })
    )
  ),
  fO = Et(
    Pe(
      pe({
        blockhash: we(),
        previousBlockhash: we(),
        parentSlot: ee(),
        rewards: Ge(Te(Os)),
        blockTime: Pe(ee()),
        blockHeight: Pe(ee()),
      })
    )
  ),
  lO = Et(
    Pe(
      pe({
        blockhash: we(),
        previousBlockhash: we(),
        parentSlot: ee(),
        transactions: Te(pe({ transaction: jy, meta: Pe(Yl) })),
        rewards: Ge(Te(Os)),
        blockTime: Pe(ee()),
      })
    )
  ),
  Sw = Et(
    Pe(
      pe({
        blockhash: we(),
        previousBlockhash: we(),
        parentSlot: ee(),
        signatures: Te(we()),
        blockTime: Pe(ee()),
      })
    )
  ),
  gp = Et(
    Pe(pe({ slot: ee(), meta: Yl, blockTime: Ge(Pe(ee())), transaction: jy, version: Ge(Xa) }))
  ),
  of = Et(
    Pe(pe({ slot: ee(), transaction: U_, meta: Pe(Hy), blockTime: Ge(Pe(ee())), version: Ge(Xa) }))
  ),
  hO = $r(pe({ blockhash: we(), feeCalculator: pe({ lamportsPerSignature: ee() }) })),
  dO = $r(pe({ blockhash: we(), lastValidBlockHeight: ee() })),
  pO = pe({ slot: ee(), numTransactions: ee(), numSlots: ee(), samplePeriodSecs: ee() }),
  yO = Et(Te(pO)),
  gO = $r(Pe(pe({ feeCalculator: pe({ lamportsPerSignature: ee() }) }))),
  bO = Et(we()),
  vO = Et(we()),
  mO = pe({ err: Ts, logs: Te(we()), signature: we() }),
  wO = pe({ result: Gl(mO), subscription: ee() }),
  _O = { 'solana-client': 'js/0.0.0-development' };
let SO = class {
    constructor(e, t) {
      (this._commitment = void 0),
        (this._confirmTransactionInitialTimeout = void 0),
        (this._rpcEndpoint = void 0),
        (this._rpcWsEndpoint = void 0),
        (this._rpcClient = void 0),
        (this._rpcRequest = void 0),
        (this._rpcBatchRequest = void 0),
        (this._rpcWebSocket = void 0),
        (this._rpcWebSocketConnected = !1),
        (this._rpcWebSocketHeartbeat = null),
        (this._rpcWebSocketIdleTimeout = null),
        (this._rpcWebSocketGeneration = 0),
        (this._disableBlockhashCaching = !1),
        (this._pollingBlockhash = !1),
        (this._blockhashInfo = {
          latestBlockhash: null,
          lastFetch: 0,
          transactionSignatures: [],
          simulatedSignatures: [],
        }),
        (this._nextClientSubscriptionId = 0),
        (this._subscriptionDisposeFunctionsByClientSubscriptionId = {}),
        (this._subscriptionHashByClientSubscriptionId = {}),
        (this._subscriptionStateChangeCallbacksByHash = {}),
        (this._subscriptionCallbacksByServerSubscriptionId = {}),
        (this._subscriptionsByHash = {}),
        (this._subscriptionsAutoDisposedByRpc = new Set()),
        (this.getBlockHeight = (() => {
          const y = {};
          return async (p) => {
            const { commitment: m, config: _ } = Rr(p),
              A = this._buildArgs([], m, void 0, _),
              E = vw(A);
            return (
              (y[E] =
                y[E] ??
                (async () => {
                  try {
                    const I = await this._rpcRequest('getBlockHeight', A),
                      R = Se(I, Et(ee()));
                    if ('error' in R)
                      throw new nt(R.error, 'failed to get block height information');
                    return R.result;
                  } finally {
                    delete y[E];
                  }
                })()),
              await y[E]
            );
          };
        })());
      let r, s, n, c, f, h;
      t && typeof t == 'string'
        ? (this._commitment = t)
        : t &&
          ((this._commitment = t.commitment),
          (this._confirmTransactionInitialTimeout = t.confirmTransactionInitialTimeout),
          (r = t.wsEndpoint),
          (s = t.httpHeaders),
          (n = t.fetch),
          (c = t.fetchMiddleware),
          (f = t.disableRetryOnRateLimit),
          (h = t.httpAgent)),
        (this._rpcEndpoint = fT(e)),
        (this._rpcWsEndpoint = r || cT(e)),
        (this._rpcClient = ST(e, s, n, c, f, h)),
        (this._rpcRequest = MT(this._rpcClient)),
        (this._rpcBatchRequest = AT(this._rpcClient)),
        (this._rpcWebSocket = new tT(this._rpcWsEndpoint, {
          autoconnect: !1,
          max_reconnects: 1 / 0,
        })),
        this._rpcWebSocket.on('open', this._wsOnOpen.bind(this)),
        this._rpcWebSocket.on('error', this._wsOnError.bind(this)),
        this._rpcWebSocket.on('close', this._wsOnClose.bind(this)),
        this._rpcWebSocket.on('accountNotification', this._wsOnAccountNotification.bind(this)),
        this._rpcWebSocket.on(
          'programNotification',
          this._wsOnProgramAccountNotification.bind(this)
        ),
        this._rpcWebSocket.on('slotNotification', this._wsOnSlotNotification.bind(this)),
        this._rpcWebSocket.on(
          'slotsUpdatesNotification',
          this._wsOnSlotUpdatesNotification.bind(this)
        ),
        this._rpcWebSocket.on('signatureNotification', this._wsOnSignatureNotification.bind(this)),
        this._rpcWebSocket.on('rootNotification', this._wsOnRootNotification.bind(this)),
        this._rpcWebSocket.on('logsNotification', this._wsOnLogsNotification.bind(this));
    }
    get commitment() {
      return this._commitment;
    }
    get rpcEndpoint() {
      return this._rpcEndpoint;
    }
    async getBalanceAndContext(e, t) {
      const { commitment: r, config: s } = Rr(t),
        n = this._buildArgs([e.toBase58()], r, void 0, s),
        c = await this._rpcRequest('getBalance', n),
        f = Se(c, $r(ee()));
      if ('error' in f) throw new nt(f.error, `failed to get balance for ${e.toBase58()}`);
      return f.result;
    }
    async getBalance(e, t) {
      return await this.getBalanceAndContext(e, t)
        .then((r) => r.value)
        .catch((r) => {
          throw new Error('failed to get balance of account ' + e.toBase58() + ': ' + r);
        });
    }
    async getBlockTime(e) {
      const t = await this._rpcRequest('getBlockTime', [e]),
        r = Se(t, Et(Pe(ee())));
      if ('error' in r) throw new nt(r.error, `failed to get block time for slot ${e}`);
      return r.result;
    }
    async getMinimumLedgerSlot() {
      const e = await this._rpcRequest('minimumLedgerSlot', []),
        t = Se(e, Et(ee()));
      if ('error' in t) throw new nt(t.error, 'failed to get minimum ledger slot');
      return t.result;
    }
    async getFirstAvailableBlock() {
      const e = await this._rpcRequest('getFirstAvailableBlock', []),
        t = Se(e, RT);
      if ('error' in t) throw new nt(t.error, 'failed to get first available block');
      return t.result;
    }
    async getSupply(e) {
      let t = {};
      typeof e == 'string'
        ? (t = { commitment: e })
        : e
          ? (t = { ...e, commitment: (e && e.commitment) || this.commitment })
          : (t = { commitment: this.commitment });
      const r = await this._rpcRequest('getSupply', [t]),
        s = Se(r, PT);
      if ('error' in s) throw new nt(s.error, 'failed to get supply');
      return s.result;
    }
    async getTokenSupply(e, t) {
      const r = this._buildArgs([e.toBase58()], t),
        s = await this._rpcRequest('getTokenSupply', r),
        n = Se(s, $r(p1));
      if ('error' in n) throw new nt(n.error, 'failed to get token supply');
      return n.result;
    }
    async getTokenAccountBalance(e, t) {
      const r = this._buildArgs([e.toBase58()], t),
        s = await this._rpcRequest('getTokenAccountBalance', r),
        n = Se(s, $r(p1));
      if ('error' in n) throw new nt(n.error, 'failed to get token account balance');
      return n.result;
    }
    async getTokenAccountsByOwner(e, t, r) {
      const { commitment: s, config: n } = Rr(r);
      let c = [e.toBase58()];
      'mint' in t
        ? c.push({ mint: t.mint.toBase58() })
        : c.push({ programId: t.programId.toBase58() });
      const f = this._buildArgs(c, s, 'base64', n),
        h = await this._rpcRequest('getTokenAccountsByOwner', f),
        y = Se(h, OT);
      if ('error' in y)
        throw new nt(y.error, `failed to get token accounts owned by account ${e.toBase58()}`);
      return y.result;
    }
    async getParsedTokenAccountsByOwner(e, t, r) {
      let s = [e.toBase58()];
      'mint' in t
        ? s.push({ mint: t.mint.toBase58() })
        : s.push({ programId: t.programId.toBase58() });
      const n = this._buildArgs(s, r, 'jsonParsed'),
        c = await this._rpcRequest('getTokenAccountsByOwner', n),
        f = Se(c, CT);
      if ('error' in f)
        throw new nt(f.error, `failed to get token accounts owned by account ${e.toBase58()}`);
      return f.result;
    }
    async getLargestAccounts(e) {
      const t = { ...e, commitment: (e && e.commitment) || this.commitment },
        r = t.filter || t.commitment ? [t] : [],
        s = await this._rpcRequest('getLargestAccounts', r),
        n = Se(s, LT);
      if ('error' in n) throw new nt(n.error, 'failed to get largest accounts');
      return n.result;
    }
    async getTokenLargestAccounts(e, t) {
      const r = this._buildArgs([e.toBase58()], t),
        s = await this._rpcRequest('getTokenLargestAccounts', r),
        n = Se(s, TT);
      if ('error' in n) throw new nt(n.error, 'failed to get token largest accounts');
      return n.result;
    }
    async getAccountInfoAndContext(e, t) {
      const { commitment: r, config: s } = Rr(t),
        n = this._buildArgs([e.toBase58()], r, 'base64', s),
        c = await this._rpcRequest('getAccountInfo', n),
        f = Se(c, $r(Pe(Du)));
      if ('error' in f) throw new nt(f.error, `failed to get info about account ${e.toBase58()}`);
      return f.result;
    }
    async getParsedAccountInfo(e, t) {
      const { commitment: r, config: s } = Rr(t),
        n = this._buildArgs([e.toBase58()], r, 'jsonParsed', s),
        c = await this._rpcRequest('getAccountInfo', n),
        f = Se(c, $r(Pe(g1)));
      if ('error' in f) throw new nt(f.error, `failed to get info about account ${e.toBase58()}`);
      return f.result;
    }
    async getAccountInfo(e, t) {
      try {
        return (await this.getAccountInfoAndContext(e, t)).value;
      } catch (r) {
        throw new Error('failed to get info about account ' + e.toBase58() + ': ' + r);
      }
    }
    async getMultipleParsedAccounts(e, t) {
      const { commitment: r, config: s } = Rr(t),
        n = e.map((y) => y.toBase58()),
        c = this._buildArgs([n], r, 'jsonParsed', s),
        f = await this._rpcRequest('getMultipleAccounts', c),
        h = Se(f, $r(Te(Pe(g1))));
      if ('error' in h) throw new nt(h.error, `failed to get info for accounts ${n}`);
      return h.result;
    }
    async getMultipleAccountsInfoAndContext(e, t) {
      const { commitment: r, config: s } = Rr(t),
        n = e.map((y) => y.toBase58()),
        c = this._buildArgs([n], r, 'base64', s),
        f = await this._rpcRequest('getMultipleAccounts', c),
        h = Se(f, $r(Te(Pe(Du))));
      if ('error' in h) throw new nt(h.error, `failed to get info for accounts ${n}`);
      return h.result;
    }
    async getMultipleAccountsInfo(e, t) {
      return (await this.getMultipleAccountsInfoAndContext(e, t)).value;
    }
    async getStakeActivation(e, t, r) {
      const { commitment: s, config: n } = Rr(t),
        c = this._buildArgs([e.toBase58()], s, void 0, {
          ...n,
          epoch: r ?? (n == null ? void 0 : n.epoch),
        }),
        f = await this._rpcRequest('getStakeActivation', c),
        h = Se(f, Et(UT));
      if ('error' in h) throw new nt(h.error, `failed to get Stake Activation ${e.toBase58()}`);
      return h.result;
    }
    async getProgramAccounts(e, t) {
      const { commitment: r, config: s } = Rr(t),
        { encoding: n, ...c } = s || {},
        f = this._buildArgs([e.toBase58()], r, n || 'base64', c),
        h = await this._rpcRequest('getProgramAccounts', f),
        y = Se(h, Et(Te(NT)));
      if ('error' in y)
        throw new nt(y.error, `failed to get accounts owned by program ${e.toBase58()}`);
      return y.result;
    }
    async getParsedProgramAccounts(e, t) {
      const { commitment: r, config: s } = Rr(t),
        n = this._buildArgs([e.toBase58()], r, 'jsonParsed', s),
        c = await this._rpcRequest('getProgramAccounts', n),
        f = Se(c, Et(Te(DT)));
      if ('error' in f)
        throw new nt(f.error, `failed to get accounts owned by program ${e.toBase58()}`);
      return f.result;
    }
    async confirmTransaction(e, t) {
      var n;
      let r;
      if (typeof e == 'string') r = e;
      else {
        const c = e;
        if ((n = c.abortSignal) != null && n.aborted) return Promise.reject(c.abortSignal.reason);
        r = c.signature;
      }
      let s;
      try {
        s = ri.decode(r);
      } catch {
        throw new Error('signature must be base58 encoded: ' + r);
      }
      return (
        Vt(s.length === 64, 'signature has invalid length'),
        typeof e == 'string'
          ? await this.confirmTransactionUsingLegacyTimeoutStrategy({
              commitment: t || this.commitment,
              signature: r,
            })
          : 'lastValidBlockHeight' in e
            ? await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
                commitment: t || this.commitment,
                strategy: e,
              })
            : await this.confirmTransactionUsingDurableNonceStrategy({
                commitment: t || this.commitment,
                strategy: e,
              })
      );
    }
    getCancellationPromise(e) {
      return new Promise((t, r) => {
        e != null &&
          (e.aborted
            ? r(e.reason)
            : e.addEventListener('abort', () => {
                r(e.reason);
              }));
      });
    }
    getTransactionConfirmationPromise({ commitment: e, signature: t }) {
      let r,
        s,
        n = !1;
      const c = new Promise((h, y) => {
        try {
          r = this.onSignature(
            t,
            (m, _) => {
              r = void 0;
              const A = { context: _, value: m };
              h({ __type: nn.PROCESSED, response: A });
            },
            e
          );
          const p = new Promise((m) => {
            r == null
              ? m()
              : (s = this._onSubscriptionStateChange(r, (_) => {
                  _ === 'subscribed' && m();
                }));
          });
          (async () => {
            if ((await p, n)) return;
            const m = await this.getSignatureStatus(t);
            if (n || m == null) return;
            const { context: _, value: A } = m;
            if (A != null)
              if (A != null && A.err) y(A.err);
              else {
                switch (e) {
                  case 'confirmed':
                  case 'single':
                  case 'singleGossip': {
                    if (A.confirmationStatus === 'processed') return;
                    break;
                  }
                  case 'finalized':
                  case 'max':
                  case 'root': {
                    if (
                      A.confirmationStatus === 'processed' ||
                      A.confirmationStatus === 'confirmed'
                    )
                      return;
                    break;
                  }
                  case 'processed':
                  case 'recent':
                }
                (n = !0), h({ __type: nn.PROCESSED, response: { context: _, value: A } });
              }
          })();
        } catch (p) {
          y(p);
        }
      });
      return {
        abortConfirmation: () => {
          s && (s(), (s = void 0)), r != null && (this.removeSignatureListener(r), (r = void 0));
        },
        confirmationPromise: c,
      };
    }
    async confirmTransactionUsingBlockHeightExceedanceStrategy({
      commitment: e,
      strategy: { abortSignal: t, lastValidBlockHeight: r, signature: s },
    }) {
      let n = !1;
      const c = new Promise((m) => {
          const _ = async () => {
            try {
              return await this.getBlockHeight(e);
            } catch {
              return -1;
            }
          };
          (async () => {
            let A = await _();
            if (!n) {
              for (; A <= r; ) if ((await Xo(1e3), n || ((A = await _()), n))) return;
              m({ __type: nn.BLOCKHEIGHT_EXCEEDED });
            }
          })();
        }),
        { abortConfirmation: f, confirmationPromise: h } = this.getTransactionConfirmationPromise({
          commitment: e,
          signature: s,
        }),
        y = this.getCancellationPromise(t);
      let p;
      try {
        const m = await Promise.race([y, h, c]);
        if (m.__type === nn.PROCESSED) p = m.response;
        else throw new Fy(s);
      } finally {
        (n = !0), f();
      }
      return p;
    }
    async confirmTransactionUsingDurableNonceStrategy({
      commitment: e,
      strategy: {
        abortSignal: t,
        minContextSlot: r,
        nonceAccountPubkey: s,
        nonceValue: n,
        signature: c,
      },
    }) {
      let f = !1;
      const h = new Promise((A) => {
          let E = n,
            I = null;
          const R = async () => {
            try {
              const { context: L, value: D } = await this.getNonceAndContext(s, {
                commitment: e,
                minContextSlot: r,
              });
              return (I = L.slot), D == null ? void 0 : D.nonce;
            } catch {
              return E;
            }
          };
          (async () => {
            if (((E = await R()), !f))
              for (;;) {
                if (n !== E) {
                  A({ __type: nn.NONCE_INVALID, slotInWhichNonceDidAdvance: I });
                  return;
                }
                if ((await Xo(2e3), f || ((E = await R()), f))) return;
              }
          })();
        }),
        { abortConfirmation: y, confirmationPromise: p } = this.getTransactionConfirmationPromise({
          commitment: e,
          signature: c,
        }),
        m = this.getCancellationPromise(t);
      let _;
      try {
        const A = await Promise.race([m, p, h]);
        if (A.__type === nn.PROCESSED) _ = A.response;
        else {
          let E;
          for (;;) {
            const I = await this.getSignatureStatus(c);
            if (I == null) break;
            if (I.context.slot < (A.slotInWhichNonceDidAdvance ?? r)) {
              await Xo(400);
              continue;
            }
            E = I;
            break;
          }
          if (E != null && E.value) {
            const I = e || 'finalized',
              { confirmationStatus: R } = E.value;
            switch (I) {
              case 'processed':
              case 'recent':
                if (R !== 'processed' && R !== 'confirmed' && R !== 'finalized') throw new ta(c);
                break;
              case 'confirmed':
              case 'single':
              case 'singleGossip':
                if (R !== 'confirmed' && R !== 'finalized') throw new ta(c);
                break;
              case 'finalized':
              case 'max':
              case 'root':
                if (R !== 'finalized') throw new ta(c);
                break;
              default:
            }
            _ = { context: E.context, value: { err: E.value.err } };
          } else throw new ta(c);
        }
      } finally {
        (f = !0), y();
      }
      return _;
    }
    async confirmTransactionUsingLegacyTimeoutStrategy({ commitment: e, signature: t }) {
      let r;
      const s = new Promise((h) => {
          let y = this._confirmTransactionInitialTimeout || 6e4;
          switch (e) {
            case 'processed':
            case 'recent':
            case 'single':
            case 'confirmed':
            case 'singleGossip': {
              y = this._confirmTransactionInitialTimeout || 3e4;
              break;
            }
          }
          r = setTimeout(() => h({ __type: nn.TIMED_OUT, timeoutMs: y }), y);
        }),
        { abortConfirmation: n, confirmationPromise: c } = this.getTransactionConfirmationPromise({
          commitment: e,
          signature: t,
        });
      let f;
      try {
        const h = await Promise.race([c, s]);
        if (h.__type === nn.PROCESSED) f = h.response;
        else throw new qy(t, h.timeoutMs / 1e3);
      } finally {
        clearTimeout(r), n();
      }
      return f;
    }
    async getClusterNodes() {
      const e = await this._rpcRequest('getClusterNodes', []),
        t = Se(e, Et(Te(JT)));
      if ('error' in t) throw new nt(t.error, 'failed to get cluster nodes');
      return t.result;
    }
    async getVoteAccounts(e) {
      const t = this._buildArgs([], e),
        r = await this._rpcRequest('getVoteAccounts', t),
        s = Se(r, XT);
      if ('error' in s) throw new nt(s.error, 'failed to get vote accounts');
      return s.result;
    }
    async getSlot(e) {
      const { commitment: t, config: r } = Rr(e),
        s = this._buildArgs([], t, void 0, r),
        n = await this._rpcRequest('getSlot', s),
        c = Se(n, Et(ee()));
      if ('error' in c) throw new nt(c.error, 'failed to get slot');
      return c.result;
    }
    async getSlotLeader(e) {
      const { commitment: t, config: r } = Rr(e),
        s = this._buildArgs([], t, void 0, r),
        n = await this._rpcRequest('getSlotLeader', s),
        c = Se(n, Et(we()));
      if ('error' in c) throw new nt(c.error, 'failed to get slot leader');
      return c.result;
    }
    async getSlotLeaders(e, t) {
      const r = [e, t],
        s = await this._rpcRequest('getSlotLeaders', r),
        n = Se(s, Et(Te(zr)));
      if ('error' in n) throw new nt(n.error, 'failed to get slot leaders');
      return n.result;
    }
    async getSignatureStatus(e, t) {
      const { context: r, value: s } = await this.getSignatureStatuses([e], t);
      Vt(s.length === 1);
      const n = s[0];
      return { context: r, value: n };
    }
    async getSignatureStatuses(e, t) {
      const r = [e];
      t && r.push(t);
      const s = await this._rpcRequest('getSignatureStatuses', r),
        n = Se(s, tO);
      if ('error' in n) throw new nt(n.error, 'failed to get signature status');
      return n.result;
    }
    async getTransactionCount(e) {
      const { commitment: t, config: r } = Rr(e),
        s = this._buildArgs([], t, void 0, r),
        n = await this._rpcRequest('getTransactionCount', s),
        c = Se(n, Et(ee()));
      if ('error' in c) throw new nt(c.error, 'failed to get transaction count');
      return c.result;
    }
    async getTotalSupply(e) {
      return (await this.getSupply({ commitment: e, excludeNonCirculatingAccountsList: !0 })).value
        .total;
    }
    async getInflationGovernor(e) {
      const t = this._buildArgs([], e),
        r = await this._rpcRequest('getInflationGovernor', t),
        s = Se(r, ET);
      if ('error' in s) throw new nt(s.error, 'failed to get inflation');
      return s.result;
    }
    async getInflationReward(e, t, r) {
      const { commitment: s, config: n } = Rr(r),
        c = this._buildArgs([e.map((y) => y.toBase58())], s, void 0, {
          ...n,
          epoch: t ?? (n == null ? void 0 : n.epoch),
        }),
        f = await this._rpcRequest('getInflationReward', c),
        h = Se(f, dT);
      if ('error' in h) throw new nt(h.error, 'failed to get inflation reward');
      return h.result;
    }
    async getInflationRate() {
      const e = await this._rpcRequest('getInflationRate', []),
        t = Se(e, kT);
      if ('error' in t) throw new nt(t.error, 'failed to get inflation rate');
      return t.result;
    }
    async getEpochInfo(e) {
      const { commitment: t, config: r } = Rr(e),
        s = this._buildArgs([], t, void 0, r),
        n = await this._rpcRequest('getEpochInfo', s),
        c = Se(n, IT);
      if ('error' in c) throw new nt(c.error, 'failed to get epoch info');
      return c.result;
    }
    async getEpochSchedule() {
      const e = await this._rpcRequest('getEpochSchedule', []),
        t = Se(e, xT);
      if ('error' in t) throw new nt(t.error, 'failed to get epoch schedule');
      const r = t.result;
      return new B_(
        r.slotsPerEpoch,
        r.leaderScheduleSlotOffset,
        r.warmup,
        r.firstNormalEpoch,
        r.firstNormalSlot
      );
    }
    async getLeaderSchedule() {
      const e = await this._rpcRequest('getLeaderSchedule', []),
        t = Se(e, BT);
      if ('error' in t) throw new nt(t.error, 'failed to get leader schedule');
      return t.result;
    }
    async getMinimumBalanceForRentExemption(e, t) {
      const r = this._buildArgs([e], t),
        s = await this._rpcRequest('getMinimumBalanceForRentExemption', r),
        n = Se(s, rO);
      return 'error' in n
        ? (console.warn('Unable to fetch minimum balance for rent exemption'), 0)
        : n.result;
    }
    async getRecentBlockhashAndContext(e) {
      const t = this._buildArgs([], e),
        r = await this._rpcRequest('getRecentBlockhash', t),
        s = Se(r, hO);
      if ('error' in s) throw new nt(s.error, 'failed to get recent blockhash');
      return s.result;
    }
    async getRecentPerformanceSamples(e) {
      const t = await this._rpcRequest('getRecentPerformanceSamples', e ? [e] : []),
        r = Se(t, yO);
      if ('error' in r) throw new nt(r.error, 'failed to get recent performance samples');
      return r.result;
    }
    async getFeeCalculatorForBlockhash(e, t) {
      const r = this._buildArgs([e], t),
        s = await this._rpcRequest('getFeeCalculatorForBlockhash', r),
        n = Se(s, gO);
      if ('error' in n) throw new nt(n.error, 'failed to get fee calculator');
      const { context: c, value: f } = n.result;
      return { context: c, value: f !== null ? f.feeCalculator : null };
    }
    async getFeeForMessage(e, t) {
      const r = St(e.serialize()).toString('base64'),
        s = this._buildArgs([r], t),
        n = await this._rpcRequest('getFeeForMessage', s),
        c = Se(n, $r(Pe(ee())));
      if ('error' in c) throw new nt(c.error, 'failed to get fee for message');
      if (c.result === null) throw new Error('invalid blockhash');
      return c.result;
    }
    async getRecentBlockhash(e) {
      try {
        return (await this.getRecentBlockhashAndContext(e)).value;
      } catch (t) {
        throw new Error('failed to get recent blockhash: ' + t);
      }
    }
    async getLatestBlockhash(e) {
      try {
        return (await this.getLatestBlockhashAndContext(e)).value;
      } catch (t) {
        throw new Error('failed to get recent blockhash: ' + t);
      }
    }
    async getLatestBlockhashAndContext(e) {
      const { commitment: t, config: r } = Rr(e),
        s = this._buildArgs([], t, void 0, r),
        n = await this._rpcRequest('getLatestBlockhash', s),
        c = Se(n, dO);
      if ('error' in c) throw new nt(c.error, 'failed to get latest blockhash');
      return c.result;
    }
    async getVersion() {
      const e = await this._rpcRequest('getVersion', []),
        t = Se(e, Et(wT));
      if ('error' in t) throw new nt(t.error, 'failed to get version');
      return t.result;
    }
    async getGenesisHash() {
      const e = await this._rpcRequest('getGenesisHash', []),
        t = Se(e, Et(we()));
      if ('error' in t) throw new nt(t.error, 'failed to get genesis hash');
      return t.result;
    }
    async getBlock(e, t) {
      const { commitment: r, config: s } = Rr(t),
        n = this._buildArgsAtLeastConfirmed([e], r, void 0, s),
        c = await this._rpcRequest('getBlock', n);
      try {
        switch (s == null ? void 0 : s.transactionDetails) {
          case 'accounts': {
            const f = Se(c, aO);
            if ('error' in f) throw f.error;
            return f.result;
          }
          case 'none': {
            const f = Se(c, sO);
            if ('error' in f) throw f.error;
            return f.result;
          }
          default: {
            const f = Se(c, oO);
            if ('error' in f) throw f.error;
            const { result: h } = f;
            return h
              ? {
                  ...h,
                  transactions: h.transactions.map(({ transaction: y, meta: p, version: m }) => ({
                    meta: p,
                    transaction: { ...y, message: yp(m, y.message) },
                    version: m,
                  })),
                }
              : null;
          }
        }
      } catch (f) {
        throw new nt(f, 'failed to get confirmed block');
      }
    }
    async getParsedBlock(e, t) {
      const { commitment: r, config: s } = Rr(t),
        n = this._buildArgsAtLeastConfirmed([e], r, 'jsonParsed', s),
        c = await this._rpcRequest('getBlock', n);
      try {
        switch (s == null ? void 0 : s.transactionDetails) {
          case 'accounts': {
            const f = Se(c, cO);
            if ('error' in f) throw f.error;
            return f.result;
          }
          case 'none': {
            const f = Se(c, fO);
            if ('error' in f) throw f.error;
            return f.result;
          }
          default: {
            const f = Se(c, uO);
            if ('error' in f) throw f.error;
            return f.result;
          }
        }
      } catch (f) {
        throw new nt(f, 'failed to get block');
      }
    }
    async getBlockProduction(e) {
      let t, r;
      if (typeof e == 'string') r = e;
      else if (e) {
        const { commitment: f, ...h } = e;
        (r = f), (t = h);
      }
      const s = this._buildArgs([], r, 'base64', t),
        n = await this._rpcRequest('getBlockProduction', s),
        c = Se(n, _T);
      if ('error' in c) throw new nt(c.error, 'failed to get block production information');
      return c.result;
    }
    async getTransaction(e, t) {
      const { commitment: r, config: s } = Rr(t),
        n = this._buildArgsAtLeastConfirmed([e], r, void 0, s),
        c = await this._rpcRequest('getTransaction', n),
        f = Se(c, gp);
      if ('error' in f) throw new nt(f.error, 'failed to get transaction');
      const h = f.result;
      return (
        h && {
          ...h,
          transaction: { ...h.transaction, message: yp(h.version, h.transaction.message) },
        }
      );
    }
    async getParsedTransaction(e, t) {
      const { commitment: r, config: s } = Rr(t),
        n = this._buildArgsAtLeastConfirmed([e], r, 'jsonParsed', s),
        c = await this._rpcRequest('getTransaction', n),
        f = Se(c, of);
      if ('error' in f) throw new nt(f.error, 'failed to get transaction');
      return f.result;
    }
    async getParsedTransactions(e, t) {
      const { commitment: r, config: s } = Rr(t),
        n = e.map((h) => ({
          methodName: 'getTransaction',
          args: this._buildArgsAtLeastConfirmed([h], r, 'jsonParsed', s),
        }));
      return (await this._rpcBatchRequest(n)).map((h) => {
        const y = Se(h, of);
        if ('error' in y) throw new nt(y.error, 'failed to get transactions');
        return y.result;
      });
    }
    async getTransactions(e, t) {
      const { commitment: r, config: s } = Rr(t),
        n = e.map((h) => ({
          methodName: 'getTransaction',
          args: this._buildArgsAtLeastConfirmed([h], r, void 0, s),
        }));
      return (await this._rpcBatchRequest(n)).map((h) => {
        const y = Se(h, gp);
        if ('error' in y) throw new nt(y.error, 'failed to get transactions');
        const p = y.result;
        return (
          p && {
            ...p,
            transaction: { ...p.transaction, message: yp(p.version, p.transaction.message) },
          }
        );
      });
    }
    async getConfirmedBlock(e, t) {
      const r = this._buildArgsAtLeastConfirmed([e], t),
        s = await this._rpcRequest('getConfirmedBlock', r),
        n = Se(s, lO);
      if ('error' in n) throw new nt(n.error, 'failed to get confirmed block');
      const c = n.result;
      if (!c) throw new Error('Confirmed block ' + e + ' not found');
      const f = {
        ...c,
        transactions: c.transactions.map(({ transaction: h, meta: y }) => {
          const p = new $o(h.message);
          return { meta: y, transaction: { ...h, message: p } };
        }),
      };
      return {
        ...f,
        transactions: f.transactions.map(({ transaction: h, meta: y }) => ({
          meta: y,
          transaction: ct.populate(h.message, h.signatures),
        })),
      };
    }
    async getBlocks(e, t, r) {
      const s = this._buildArgsAtLeastConfirmed(t !== void 0 ? [e, t] : [e], r),
        n = await this._rpcRequest('getBlocks', s),
        c = Se(n, Et(Te(ee())));
      if ('error' in c) throw new nt(c.error, 'failed to get blocks');
      return c.result;
    }
    async getBlockSignatures(e, t) {
      const r = this._buildArgsAtLeastConfirmed([e], t, void 0, {
          transactionDetails: 'signatures',
          rewards: !1,
        }),
        s = await this._rpcRequest('getBlock', r),
        n = Se(s, Sw);
      if ('error' in n) throw new nt(n.error, 'failed to get block');
      const c = n.result;
      if (!c) throw new Error('Block ' + e + ' not found');
      return c;
    }
    async getConfirmedBlockSignatures(e, t) {
      const r = this._buildArgsAtLeastConfirmed([e], t, void 0, {
          transactionDetails: 'signatures',
          rewards: !1,
        }),
        s = await this._rpcRequest('getConfirmedBlock', r),
        n = Se(s, Sw);
      if ('error' in n) throw new nt(n.error, 'failed to get confirmed block');
      const c = n.result;
      if (!c) throw new Error('Confirmed block ' + e + ' not found');
      return c;
    }
    async getConfirmedTransaction(e, t) {
      const r = this._buildArgsAtLeastConfirmed([e], t),
        s = await this._rpcRequest('getConfirmedTransaction', r),
        n = Se(s, gp);
      if ('error' in n) throw new nt(n.error, 'failed to get transaction');
      const c = n.result;
      if (!c) return c;
      const f = new $o(c.transaction.message),
        h = c.transaction.signatures;
      return { ...c, transaction: ct.populate(f, h) };
    }
    async getParsedConfirmedTransaction(e, t) {
      const r = this._buildArgsAtLeastConfirmed([e], t, 'jsonParsed'),
        s = await this._rpcRequest('getConfirmedTransaction', r),
        n = Se(s, of);
      if ('error' in n) throw new nt(n.error, 'failed to get confirmed transaction');
      return n.result;
    }
    async getParsedConfirmedTransactions(e, t) {
      const r = e.map((c) => ({
        methodName: 'getConfirmedTransaction',
        args: this._buildArgsAtLeastConfirmed([c], t, 'jsonParsed'),
      }));
      return (await this._rpcBatchRequest(r)).map((c) => {
        const f = Se(c, of);
        if ('error' in f) throw new nt(f.error, 'failed to get confirmed transactions');
        return f.result;
      });
    }
    async getConfirmedSignaturesForAddress(e, t, r) {
      let s = {},
        n = await this.getFirstAvailableBlock();
      for (; !('until' in s) && (t--, !(t <= 0 || t < n)); )
        try {
          const h = await this.getConfirmedBlockSignatures(t, 'finalized');
          h.signatures.length > 0 && (s.until = h.signatures[h.signatures.length - 1].toString());
        } catch (h) {
          if (h instanceof Error && h.message.includes('skipped')) continue;
          throw h;
        }
      let c = await this.getSlot('finalized');
      for (; !('before' in s) && (r++, !(r > c)); )
        try {
          const h = await this.getConfirmedBlockSignatures(r);
          h.signatures.length > 0 && (s.before = h.signatures[h.signatures.length - 1].toString());
        } catch (h) {
          if (h instanceof Error && h.message.includes('skipped')) continue;
          throw h;
        }
      return (await this.getConfirmedSignaturesForAddress2(e, s)).map((h) => h.signature);
    }
    async getConfirmedSignaturesForAddress2(e, t, r) {
      const s = this._buildArgsAtLeastConfirmed([e.toBase58()], r, void 0, t),
        n = await this._rpcRequest('getConfirmedSignaturesForAddress2', s),
        c = Se(n, zT);
      if ('error' in c) throw new nt(c.error, 'failed to get confirmed signatures for address');
      return c.result;
    }
    async getSignaturesForAddress(e, t, r) {
      const s = this._buildArgsAtLeastConfirmed([e.toBase58()], r, void 0, t),
        n = await this._rpcRequest('getSignaturesForAddress', s),
        c = Se(n, FT);
      if ('error' in c) throw new nt(c.error, 'failed to get signatures for address');
      return c.result;
    }
    async getAddressLookupTable(e, t) {
      const { context: r, value: s } = await this.getAccountInfoAndContext(e, t);
      let n = null;
      return (
        s !== null && (n = new d1({ key: e, state: d1.deserialize(s.data) })),
        { context: r, value: n }
      );
    }
    async getNonceAndContext(e, t) {
      const { context: r, value: s } = await this.getAccountInfoAndContext(e, t);
      let n = null;
      return s !== null && (n = I_.fromAccountData(s.data)), { context: r, value: n };
    }
    async getNonce(e, t) {
      return await this.getNonceAndContext(e, t)
        .then((r) => r.value)
        .catch((r) => {
          throw new Error('failed to get nonce for account ' + e.toBase58() + ': ' + r);
        });
    }
    async requestAirdrop(e, t) {
      const r = await this._rpcRequest('requestAirdrop', [e.toBase58(), t]),
        s = Se(r, bO);
      if ('error' in s) throw new nt(s.error, `airdrop to ${e.toBase58()} failed`);
      return s.result;
    }
    async _blockhashWithExpiryBlockHeight(e) {
      if (!e) {
        for (; this._pollingBlockhash; ) await Xo(100);
        const r = Date.now() - this._blockhashInfo.lastFetch >= P_;
        if (this._blockhashInfo.latestBlockhash !== null && !r)
          return this._blockhashInfo.latestBlockhash;
      }
      return await this._pollNewBlockhash();
    }
    async _pollNewBlockhash() {
      this._pollingBlockhash = !0;
      try {
        const e = Date.now(),
          t = this._blockhashInfo.latestBlockhash,
          r = t ? t.blockhash : null;
        for (let s = 0; s < 50; s++) {
          const n = await this.getLatestBlockhash('finalized');
          if (r !== n.blockhash)
            return (
              (this._blockhashInfo = {
                latestBlockhash: n,
                lastFetch: Date.now(),
                transactionSignatures: [],
                simulatedSignatures: [],
              }),
              n
            );
          await Xo(oT / 2);
        }
        throw new Error(`Unable to obtain a new blockhash after ${Date.now() - e}ms`);
      } finally {
        this._pollingBlockhash = !1;
      }
    }
    async getStakeMinimumDelegation(e) {
      const { commitment: t, config: r } = Rr(e),
        s = this._buildArgs([], t, 'base64', r),
        n = await this._rpcRequest('getStakeMinimumDelegation', s),
        c = Se(n, $r(ee()));
      if ('error' in c) throw new nt(c.error, 'failed to get stake minimum delegation');
      return c.result;
    }
    async simulateTransaction(e, t, r) {
      if ('message' in e) {
        const I = e.serialize(),
          R = He.from(I).toString('base64');
        if (Array.isArray(t) || r !== void 0) throw new Error('Invalid arguments');
        const L = t || {};
        (L.encoding = 'base64'), 'commitment' in L || (L.commitment = this.commitment);
        const D = [R, L],
          q = await this._rpcRequest('simulateTransaction', D),
          H = Se(q, ww);
        if ('error' in H) throw new Error('failed to simulate transaction: ' + H.error.message);
        return H.result;
      }
      let s;
      if (e instanceof ct) {
        let E = e;
        (s = new ct()),
          (s.feePayer = E.feePayer),
          (s.instructions = e.instructions),
          (s.nonceInfo = E.nonceInfo),
          (s.signatures = E.signatures);
      } else (s = ct.populate(e)), (s._message = s._json = void 0);
      if (t !== void 0 && !Array.isArray(t)) throw new Error('Invalid arguments');
      const n = t;
      if (s.nonceInfo && n) s.sign(...n);
      else {
        let E = this._disableBlockhashCaching;
        for (;;) {
          const I = await this._blockhashWithExpiryBlockHeight(E);
          if (
            ((s.lastValidBlockHeight = I.lastValidBlockHeight),
            (s.recentBlockhash = I.blockhash),
            !n)
          )
            break;
          if ((s.sign(...n), !s.signature)) throw new Error('!signature');
          const R = s.signature.toString('base64');
          if (
            !this._blockhashInfo.simulatedSignatures.includes(R) &&
            !this._blockhashInfo.transactionSignatures.includes(R)
          ) {
            this._blockhashInfo.simulatedSignatures.push(R);
            break;
          } else E = !0;
        }
      }
      const c = s._compile(),
        f = c.serialize(),
        y = s._serialize(f).toString('base64'),
        p = { encoding: 'base64', commitment: this.commitment };
      if (r) {
        const E = (Array.isArray(r) ? r : c.nonProgramIds()).map((I) => I.toBase58());
        p.accounts = { encoding: 'base64', addresses: E };
      }
      n && (p.sigVerify = !0);
      const m = [y, p],
        _ = await this._rpcRequest('simulateTransaction', m),
        A = Se(_, ww);
      if ('error' in A) {
        let E;
        if ('data' in A.error && ((E = A.error.data.logs), E && Array.isArray(E))) {
          const I = `
    `,
            R = I + E.join(I);
          console.error(A.error.message, R);
        }
        throw new h1('failed to simulate transaction: ' + A.error.message, E);
      }
      return A.result;
    }
    async sendTransaction(e, t, r) {
      if ('version' in e) {
        if (t && Array.isArray(t)) throw new Error('Invalid arguments');
        const c = e.serialize();
        return await this.sendRawTransaction(c, t);
      }
      if (t === void 0 || !Array.isArray(t)) throw new Error('Invalid arguments');
      const s = t;
      if (e.nonceInfo) e.sign(...s);
      else {
        let c = this._disableBlockhashCaching;
        for (;;) {
          const f = await this._blockhashWithExpiryBlockHeight(c);
          if (
            ((e.lastValidBlockHeight = f.lastValidBlockHeight),
            (e.recentBlockhash = f.blockhash),
            e.sign(...s),
            !e.signature)
          )
            throw new Error('!signature');
          const h = e.signature.toString('base64');
          if (this._blockhashInfo.transactionSignatures.includes(h)) c = !0;
          else {
            this._blockhashInfo.transactionSignatures.push(h);
            break;
          }
        }
      }
      const n = e.serialize();
      return await this.sendRawTransaction(n, r);
    }
    async sendRawTransaction(e, t) {
      const r = St(e).toString('base64');
      return await this.sendEncodedTransaction(r, t);
    }
    async sendEncodedTransaction(e, t) {
      const r = { encoding: 'base64' },
        s = t && t.skipPreflight,
        n = (t && t.preflightCommitment) || this.commitment;
      t && t.maxRetries != null && (r.maxRetries = t.maxRetries),
        t && t.minContextSlot != null && (r.minContextSlot = t.minContextSlot),
        s && (r.skipPreflight = s),
        n && (r.preflightCommitment = n);
      const c = [e, r],
        f = await this._rpcRequest('sendTransaction', c),
        h = Se(f, vO);
      if ('error' in h) {
        let y;
        throw (
          ('data' in h.error && (y = h.error.data.logs),
          new h1('failed to send transaction: ' + h.error.message, y))
        );
      }
      return h.result;
    }
    _wsOnOpen() {
      (this._rpcWebSocketConnected = !0),
        (this._rpcWebSocketHeartbeat = setInterval(() => {
          (async () => {
            try {
              await this._rpcWebSocket.notify('ping');
            } catch {}
          })();
        }, 5e3)),
        this._updateSubscriptions();
    }
    _wsOnError(e) {
      (this._rpcWebSocketConnected = !1), console.error('ws error:', e.message);
    }
    _wsOnClose(e) {
      if (
        ((this._rpcWebSocketConnected = !1),
        (this._rpcWebSocketGeneration =
          (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER),
        this._rpcWebSocketIdleTimeout &&
          (clearTimeout(this._rpcWebSocketIdleTimeout), (this._rpcWebSocketIdleTimeout = null)),
        this._rpcWebSocketHeartbeat &&
          (clearInterval(this._rpcWebSocketHeartbeat), (this._rpcWebSocketHeartbeat = null)),
        e === 1e3)
      ) {
        this._updateSubscriptions();
        return;
      }
      (this._subscriptionCallbacksByServerSubscriptionId = {}),
        Object.entries(this._subscriptionsByHash).forEach(([t, r]) => {
          this._setSubscription(t, { ...r, state: 'pending' });
        });
    }
    _setSubscription(e, t) {
      var s;
      const r = (s = this._subscriptionsByHash[e]) == null ? void 0 : s.state;
      if (((this._subscriptionsByHash[e] = t), r !== t.state)) {
        const n = this._subscriptionStateChangeCallbacksByHash[e];
        n &&
          n.forEach((c) => {
            try {
              c(t.state);
            } catch {}
          });
      }
    }
    _onSubscriptionStateChange(e, t) {
      var r;
      const s = this._subscriptionHashByClientSubscriptionId[e];
      if (s == null) return () => {};
      const n = (r = this._subscriptionStateChangeCallbacksByHash)[s] || (r[s] = new Set());
      return (
        n.add(t),
        () => {
          n.delete(t), n.size === 0 && delete this._subscriptionStateChangeCallbacksByHash[s];
        }
      );
    }
    async _updateSubscriptions() {
      if (Object.keys(this._subscriptionsByHash).length === 0) {
        this._rpcWebSocketConnected &&
          ((this._rpcWebSocketConnected = !1),
          (this._rpcWebSocketIdleTimeout = setTimeout(() => {
            this._rpcWebSocketIdleTimeout = null;
            try {
              this._rpcWebSocket.close();
            } catch (r) {
              r instanceof Error &&
                console.log(`Error when closing socket connection: ${r.message}`);
            }
          }, 500)));
        return;
      }
      if (
        (this._rpcWebSocketIdleTimeout !== null &&
          (clearTimeout(this._rpcWebSocketIdleTimeout),
          (this._rpcWebSocketIdleTimeout = null),
          (this._rpcWebSocketConnected = !0)),
        !this._rpcWebSocketConnected)
      ) {
        this._rpcWebSocket.connect();
        return;
      }
      const e = this._rpcWebSocketGeneration,
        t = () => e === this._rpcWebSocketGeneration;
      await Promise.all(
        Object.keys(this._subscriptionsByHash).map(async (r) => {
          const s = this._subscriptionsByHash[r];
          if (s !== void 0)
            switch (s.state) {
              case 'pending':
              case 'unsubscribed':
                if (s.callbacks.size === 0) {
                  delete this._subscriptionsByHash[r],
                    s.state === 'unsubscribed' &&
                      delete this._subscriptionCallbacksByServerSubscriptionId[
                        s.serverSubscriptionId
                      ],
                    await this._updateSubscriptions();
                  return;
                }
                await (async () => {
                  const { args: n, method: c } = s;
                  try {
                    this._setSubscription(r, { ...s, state: 'subscribing' });
                    const f = await this._rpcWebSocket.call(c, n);
                    this._setSubscription(r, {
                      ...s,
                      serverSubscriptionId: f,
                      state: 'subscribed',
                    }),
                      (this._subscriptionCallbacksByServerSubscriptionId[f] = s.callbacks),
                      await this._updateSubscriptions();
                  } catch (f) {
                    if (
                      (f instanceof Error && console.error(`${c} error for argument`, n, f.message),
                      !t())
                    )
                      return;
                    this._setSubscription(r, { ...s, state: 'pending' }),
                      await this._updateSubscriptions();
                  }
                })();
                break;
              case 'subscribed':
                s.callbacks.size === 0 &&
                  (await (async () => {
                    const { serverSubscriptionId: n, unsubscribeMethod: c } = s;
                    if (this._subscriptionsAutoDisposedByRpc.has(n))
                      this._subscriptionsAutoDisposedByRpc.delete(n);
                    else {
                      this._setSubscription(r, { ...s, state: 'unsubscribing' }),
                        this._setSubscription(r, { ...s, state: 'unsubscribing' });
                      try {
                        await this._rpcWebSocket.call(c, [n]);
                      } catch (f) {
                        if ((f instanceof Error && console.error(`${c} error:`, f.message), !t()))
                          return;
                        this._setSubscription(r, { ...s, state: 'subscribed' }),
                          await this._updateSubscriptions();
                        return;
                      }
                    }
                    this._setSubscription(r, { ...s, state: 'unsubscribed' }),
                      await this._updateSubscriptions();
                  })());
                break;
            }
        })
      );
    }
    _handleServerNotification(e, t) {
      const r = this._subscriptionCallbacksByServerSubscriptionId[e];
      r !== void 0 &&
        r.forEach((s) => {
          try {
            s(...t);
          } catch (n) {
            console.error(n);
          }
        });
    }
    _wsOnAccountNotification(e) {
      const { result: t, subscription: r } = Se(e, qT);
      this._handleServerNotification(r, [t.value, t.context]);
    }
    _makeSubscription(e, t) {
      const r = this._nextClientSubscriptionId++,
        s = vw([e.method, t]),
        n = this._subscriptionsByHash[s];
      return (
        n === void 0
          ? (this._subscriptionsByHash[s] = {
              ...e,
              args: t,
              callbacks: new Set([e.callback]),
              state: 'pending',
            })
          : n.callbacks.add(e.callback),
        (this._subscriptionHashByClientSubscriptionId[r] = s),
        (this._subscriptionDisposeFunctionsByClientSubscriptionId[r] = async () => {
          delete this._subscriptionDisposeFunctionsByClientSubscriptionId[r],
            delete this._subscriptionHashByClientSubscriptionId[r];
          const c = this._subscriptionsByHash[s];
          Vt(
            c !== void 0,
            `Could not find a \`Subscription\` when tearing down client subscription #${r}`
          ),
            c.callbacks.delete(e.callback),
            await this._updateSubscriptions();
        }),
        this._updateSubscriptions(),
        r
      );
    }
    onAccountChange(e, t, r) {
      const s = this._buildArgs([e.toBase58()], r || this._commitment || 'finalized', 'base64');
      return this._makeSubscription(
        { callback: t, method: 'accountSubscribe', unsubscribeMethod: 'accountUnsubscribe' },
        s
      );
    }
    async removeAccountChangeListener(e) {
      await this._unsubscribeClientSubscription(e, 'account change');
    }
    _wsOnProgramAccountNotification(e) {
      const { result: t, subscription: r } = Se(e, KT);
      this._handleServerNotification(r, [
        { accountId: t.value.pubkey, accountInfo: t.value.account },
        t.context,
      ]);
    }
    onProgramAccountChange(e, t, r, s) {
      const n = this._buildArgs(
        [e.toBase58()],
        r || this._commitment || 'finalized',
        'base64',
        s ? { filters: s } : void 0
      );
      return this._makeSubscription(
        { callback: t, method: 'programSubscribe', unsubscribeMethod: 'programUnsubscribe' },
        n
      );
    }
    async removeProgramAccountChangeListener(e) {
      await this._unsubscribeClientSubscription(e, 'program account change');
    }
    onLogs(e, t, r) {
      const s = this._buildArgs(
        [typeof e == 'object' ? { mentions: [e.toString()] } : e],
        r || this._commitment || 'finalized'
      );
      return this._makeSubscription(
        { callback: t, method: 'logsSubscribe', unsubscribeMethod: 'logsUnsubscribe' },
        s
      );
    }
    async removeOnLogsListener(e) {
      await this._unsubscribeClientSubscription(e, 'logs');
    }
    _wsOnLogsNotification(e) {
      const { result: t, subscription: r } = Se(e, wO);
      this._handleServerNotification(r, [t.value, t.context]);
    }
    _wsOnSlotNotification(e) {
      const { result: t, subscription: r } = Se(e, HT);
      this._handleServerNotification(r, [t]);
    }
    onSlotChange(e) {
      return this._makeSubscription(
        { callback: e, method: 'slotSubscribe', unsubscribeMethod: 'slotUnsubscribe' },
        []
      );
    }
    async removeSlotChangeListener(e) {
      await this._unsubscribeClientSubscription(e, 'slot change');
    }
    _wsOnSlotUpdatesNotification(e) {
      const { result: t, subscription: r } = Se(e, GT);
      this._handleServerNotification(r, [t]);
    }
    onSlotUpdate(e) {
      return this._makeSubscription(
        {
          callback: e,
          method: 'slotsUpdatesSubscribe',
          unsubscribeMethod: 'slotsUpdatesUnsubscribe',
        },
        []
      );
    }
    async removeSlotUpdateListener(e) {
      await this._unsubscribeClientSubscription(e, 'slot update');
    }
    async _unsubscribeClientSubscription(e, t) {
      const r = this._subscriptionDisposeFunctionsByClientSubscriptionId[e];
      r
        ? await r()
        : console.warn(
            `Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`
          );
    }
    _buildArgs(e, t, r, s) {
      const n = t || this._commitment;
      if (n || r || s) {
        let c = {};
        r && (c.encoding = r), n && (c.commitment = n), s && (c = Object.assign(c, s)), e.push(c);
      }
      return e;
    }
    _buildArgsAtLeastConfirmed(e, t, r, s) {
      const n = t || this._commitment;
      if (n && !['confirmed', 'finalized'].includes(n))
        throw new Error(
          'Using Connection with default commitment: `' +
            this._commitment +
            '`, but method requires at least `confirmed`'
        );
      return this._buildArgs(e, t, r, s);
    }
    _wsOnSignatureNotification(e) {
      const { result: t, subscription: r } = Se(e, YT);
      t.value !== 'receivedSignature' && this._subscriptionsAutoDisposedByRpc.add(r),
        this._handleServerNotification(
          r,
          t.value === 'receivedSignature'
            ? [{ type: 'received' }, t.context]
            : [{ type: 'status', result: t.value }, t.context]
        );
    }
    onSignature(e, t, r) {
      const s = this._buildArgs([e], r || this._commitment || 'finalized'),
        n = this._makeSubscription(
          {
            callback: (c, f) => {
              if (c.type === 'status') {
                t(c.result, f);
                try {
                  this.removeSignatureListener(n);
                } catch {}
              }
            },
            method: 'signatureSubscribe',
            unsubscribeMethod: 'signatureUnsubscribe',
          },
          s
        );
      return n;
    }
    onSignatureWithOptions(e, t, r) {
      const { commitment: s, ...n } = {
          ...r,
          commitment: (r && r.commitment) || this._commitment || 'finalized',
        },
        c = this._buildArgs([e], s, void 0, n),
        f = this._makeSubscription(
          {
            callback: (h, y) => {
              t(h, y);
              try {
                this.removeSignatureListener(f);
              } catch {}
            },
            method: 'signatureSubscribe',
            unsubscribeMethod: 'signatureUnsubscribe',
          },
          c
        );
      return f;
    }
    async removeSignatureListener(e) {
      await this._unsubscribeClientSubscription(e, 'signature result');
    }
    _wsOnRootNotification(e) {
      const { result: t, subscription: r } = Se(e, ZT);
      this._handleServerNotification(r, [t]);
    }
    onRootChange(e) {
      return this._makeSubscription(
        { callback: e, method: 'rootSubscribe', unsubscribeMethod: 'rootUnsubscribe' },
        []
      );
    }
    async removeRootChangeListener(e) {
      await this._unsubscribeClientSubscription(e, 'root change');
    }
  },
  ra = class Bf {
    constructor(e) {
      (this._keypair = void 0), (this._keypair = e ?? yw());
    }
    static generate() {
      return new Bf(yw());
    }
    static fromSecretKey(e, t) {
      if (e.byteLength !== 64) throw new Error('bad secret key size');
      const r = e.slice(32, 64);
      if (!t || !t.skipValidation) {
        const s = e.slice(0, 32),
          n = nl(s);
        for (let c = 0; c < 32; c++)
          if (r[c] !== n[c]) throw new Error('provided secretKey is invalid');
      }
      return new Bf({ publicKey: r, secretKey: e });
    }
    static fromSeed(e) {
      const t = nl(e),
        r = new Uint8Array(64);
      return r.set(e), r.set(t, 32), new Bf({ publicKey: t, secretKey: r });
    }
    get publicKey() {
      return new Ve(this._keypair.publicKey);
    }
    get secretKey() {
      return new Uint8Array(this._keypair.secretKey);
    }
  };
const Jn = Object.freeze({
  CreateLookupTable: {
    index: 0,
    layout: We([qe('instruction'), Ta('recentSlot'), tt('bumpSeed')]),
  },
  FreezeLookupTable: { index: 1, layout: We([qe('instruction')]) },
  ExtendLookupTable: {
    index: 2,
    layout: We([qe('instruction'), Ta(), zt(It(), _i(qe(), -8), 'addresses')]),
  },
  DeactivateLookupTable: { index: 3, layout: We([qe('instruction')]) },
  CloseLookupTable: { index: 4, layout: We([qe('instruction')]) },
});
let MO = class {
    constructor() {}
    static decodeInstructionType(e) {
      this.checkProgramId(e.programId);
      const r = qe('instruction').decode(e.data);
      let s;
      for (const [n, c] of Object.entries(Jn))
        if (c.index == r) {
          s = n;
          break;
        }
      if (!s) throw new Error('Invalid Instruction. Should be a LookupTable Instruction');
      return s;
    }
    static decodeCreateLookupTable(e) {
      this.checkProgramId(e.programId), this.checkKeysLength(e.keys, 4);
      const { recentSlot: t } = er(Jn.CreateLookupTable, e.data);
      return { authority: e.keys[1].pubkey, payer: e.keys[2].pubkey, recentSlot: Number(t) };
    }
    static decodeExtendLookupTable(e) {
      if ((this.checkProgramId(e.programId), e.keys.length < 2))
        throw new Error(`invalid instruction; found ${e.keys.length} keys, expected at least 2`);
      const { addresses: t } = er(Jn.ExtendLookupTable, e.data);
      return {
        lookupTable: e.keys[0].pubkey,
        authority: e.keys[1].pubkey,
        payer: e.keys.length > 2 ? e.keys[2].pubkey : void 0,
        addresses: t.map((r) => new Ve(r)),
      };
    }
    static decodeCloseLookupTable(e) {
      return (
        this.checkProgramId(e.programId),
        this.checkKeysLength(e.keys, 3),
        { lookupTable: e.keys[0].pubkey, authority: e.keys[1].pubkey, recipient: e.keys[2].pubkey }
      );
    }
    static decodeFreezeLookupTable(e) {
      return (
        this.checkProgramId(e.programId),
        this.checkKeysLength(e.keys, 2),
        { lookupTable: e.keys[0].pubkey, authority: e.keys[1].pubkey }
      );
    }
    static decodeDeactivateLookupTable(e) {
      return (
        this.checkProgramId(e.programId),
        this.checkKeysLength(e.keys, 2),
        { lookupTable: e.keys[0].pubkey, authority: e.keys[1].pubkey }
      );
    }
    static checkProgramId(e) {
      if (!e.equals(Vy.programId))
        throw new Error('invalid instruction; programId is not AddressLookupTable Program');
    }
    static checkKeysLength(e, t) {
      if (e.length < t)
        throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`);
    }
  },
  Vy = class {
    constructor() {}
    static createLookupTable(e) {
      const [t, r] = Ve.findProgramAddressSync(
          [e.authority.toBuffer(), ql(BigInt(e.recentSlot), 8)],
          this.programId
        ),
        s = Jn.CreateLookupTable,
        n = $t(s, { recentSlot: BigInt(e.recentSlot), bumpSeed: r }),
        c = [
          { pubkey: t, isSigner: !1, isWritable: !0 },
          { pubkey: e.authority, isSigner: !0, isWritable: !1 },
          { pubkey: e.payer, isSigner: !0, isWritable: !0 },
          { pubkey: Ur.programId, isSigner: !1, isWritable: !1 },
        ];
      return [new pt({ programId: this.programId, keys: c, data: n }), t];
    }
    static freezeLookupTable(e) {
      const t = Jn.FreezeLookupTable,
        r = $t(t),
        s = [
          { pubkey: e.lookupTable, isSigner: !1, isWritable: !0 },
          { pubkey: e.authority, isSigner: !0, isWritable: !1 },
        ];
      return new pt({ programId: this.programId, keys: s, data: r });
    }
    static extendLookupTable(e) {
      const t = Jn.ExtendLookupTable,
        r = $t(t, { addresses: e.addresses.map((n) => n.toBytes()) }),
        s = [
          { pubkey: e.lookupTable, isSigner: !1, isWritable: !0 },
          { pubkey: e.authority, isSigner: !0, isWritable: !1 },
        ];
      return (
        e.payer &&
          s.push(
            { pubkey: e.payer, isSigner: !0, isWritable: !0 },
            { pubkey: Ur.programId, isSigner: !1, isWritable: !1 }
          ),
        new pt({ programId: this.programId, keys: s, data: r })
      );
    }
    static deactivateLookupTable(e) {
      const t = Jn.DeactivateLookupTable,
        r = $t(t),
        s = [
          { pubkey: e.lookupTable, isSigner: !1, isWritable: !0 },
          { pubkey: e.authority, isSigner: !0, isWritable: !1 },
        ];
      return new pt({ programId: this.programId, keys: s, data: r });
    }
    static closeLookupTable(e) {
      const t = Jn.CloseLookupTable,
        r = $t(t),
        s = [
          { pubkey: e.lookupTable, isSigner: !1, isWritable: !0 },
          { pubkey: e.authority, isSigner: !0, isWritable: !1 },
          { pubkey: e.recipient, isSigner: !1, isWritable: !0 },
        ];
      return new pt({ programId: this.programId, keys: s, data: r });
    }
  };
Vy.programId = new Ve('AddressLookupTab1e1111111111111111111111111');
let AO = class {
  constructor() {}
  static decodeInstructionType(e) {
    this.checkProgramId(e.programId);
    const r = tt('instruction').decode(e.data);
    let s;
    for (const [n, c] of Object.entries(An))
      if (c.index == r) {
        s = n;
        break;
      }
    if (!s) throw new Error('Instruction type incorrect; not a ComputeBudgetInstruction');
    return s;
  }
  static decodeRequestUnits(e) {
    this.checkProgramId(e.programId);
    const { units: t, additionalFee: r } = er(An.RequestUnits, e.data);
    return { units: t, additionalFee: r };
  }
  static decodeRequestHeapFrame(e) {
    this.checkProgramId(e.programId);
    const { bytes: t } = er(An.RequestHeapFrame, e.data);
    return { bytes: t };
  }
  static decodeSetComputeUnitLimit(e) {
    this.checkProgramId(e.programId);
    const { units: t } = er(An.SetComputeUnitLimit, e.data);
    return { units: t };
  }
  static decodeSetComputeUnitPrice(e) {
    this.checkProgramId(e.programId);
    const { microLamports: t } = er(An.SetComputeUnitPrice, e.data);
    return { microLamports: t };
  }
  static checkProgramId(e) {
    if (!e.equals(Gy.programId))
      throw new Error('invalid instruction; programId is not ComputeBudgetProgram');
  }
};
const An = Object.freeze({
  RequestUnits: { index: 0, layout: We([tt('instruction'), qe('units'), qe('additionalFee')]) },
  RequestHeapFrame: { index: 1, layout: We([tt('instruction'), qe('bytes')]) },
  SetComputeUnitLimit: { index: 2, layout: We([tt('instruction'), qe('units')]) },
  SetComputeUnitPrice: { index: 3, layout: We([tt('instruction'), Ta('microLamports')]) },
});
let Gy = class {
  constructor() {}
  static requestUnits(e) {
    const t = An.RequestUnits,
      r = $t(t, e);
    return new pt({ keys: [], programId: this.programId, data: r });
  }
  static requestHeapFrame(e) {
    const t = An.RequestHeapFrame,
      r = $t(t, e);
    return new pt({ keys: [], programId: this.programId, data: r });
  }
  static setComputeUnitLimit(e) {
    const t = An.SetComputeUnitLimit,
      r = $t(t, e);
    return new pt({ keys: [], programId: this.programId, data: r });
  }
  static setComputeUnitPrice(e) {
    const t = An.SetComputeUnitPrice,
      r = $t(t, { microLamports: BigInt(e.microLamports) });
    return new pt({ keys: [], programId: this.programId, data: r });
  }
};
Gy.programId = new Ve('ComputeBudget111111111111111111111111111111');
const Mw = 64,
  Aw = 32,
  Ew = 64,
  kw = We([
    tt('numSignatures'),
    tt('padding'),
    Tr('signatureOffset'),
    Tr('signatureInstructionIndex'),
    Tr('publicKeyOffset'),
    Tr('publicKeyInstructionIndex'),
    Tr('messageDataOffset'),
    Tr('messageDataSize'),
    Tr('messageInstructionIndex'),
  ]);
let F_ = class q_ {
  constructor() {}
  static createInstructionWithPublicKey(e) {
    const { publicKey: t, message: r, signature: s, instructionIndex: n } = e;
    Vt(t.length === Aw, `Public Key must be ${Aw} bytes but received ${t.length} bytes`),
      Vt(s.length === Ew, `Signature must be ${Ew} bytes but received ${s.length} bytes`);
    const c = kw.span,
      f = c + t.length,
      h = f + s.length,
      y = 1,
      p = He.alloc(h + r.length),
      m = n ?? 65535;
    return (
      kw.encode(
        {
          numSignatures: y,
          padding: 0,
          signatureOffset: f,
          signatureInstructionIndex: m,
          publicKeyOffset: c,
          publicKeyInstructionIndex: m,
          messageDataOffset: h,
          messageDataSize: r.length,
          messageInstructionIndex: m,
        },
        p
      ),
      p.fill(t, c),
      p.fill(s, f),
      p.fill(r, h),
      new pt({ keys: [], programId: q_.programId, data: p })
    );
  }
  static createInstructionWithPrivateKey(e) {
    const { privateKey: t, message: r, instructionIndex: s } = e;
    Vt(t.length === Mw, `Private key must be ${Mw} bytes but received ${t.length} bytes`);
    try {
      const n = ra.fromSecretKey(t),
        c = n.publicKey.toBytes(),
        f = Uy(r, n.secretKey);
      return this.createInstructionWithPublicKey({
        publicKey: c,
        message: r,
        signature: f,
        instructionIndex: s,
      });
    } catch (n) {
      throw new Error(`Error creating instruction; ${n}`);
    }
  }
};
F_.programId = new Ve('Ed25519SigVerify111111111111111111111111111');
oi.hmacSha256Sync = (i, ...e) => {
  const t = b_.create(o1, i);
  return e.forEach((r) => t.update(r)), t.digest();
};
const EO = (i, e) => Ey(i, e, { der: !1, recovered: !0 });
oi.isValidPrivateKey;
const kO = Ay,
  Iw = 32,
  bp = 20,
  xw = 64,
  IO = 11,
  vp = We([
    tt('numSignatures'),
    Tr('signatureOffset'),
    tt('signatureInstructionIndex'),
    Tr('ethAddressOffset'),
    tt('ethAddressInstructionIndex'),
    Tr('messageDataOffset'),
    Tr('messageDataSize'),
    tt('messageInstructionIndex'),
    ut(20, 'ethAddress'),
    ut(64, 'signature'),
    tt('recoveryId'),
  ]);
let W_ = class Rf {
  constructor() {}
  static publicKeyToEthAddress(e) {
    Vt(e.length === xw, `Public key must be ${xw} bytes but received ${e.length} bytes`);
    try {
      return He.from(pw(St(e))).slice(-bp);
    } catch (t) {
      throw new Error(`Error constructing Ethereum address: ${t}`);
    }
  }
  static createInstructionWithPublicKey(e) {
    const { publicKey: t, message: r, signature: s, recoveryId: n, instructionIndex: c } = e;
    return Rf.createInstructionWithEthAddress({
      ethAddress: Rf.publicKeyToEthAddress(t),
      message: r,
      signature: s,
      recoveryId: n,
      instructionIndex: c,
    });
  }
  static createInstructionWithEthAddress(e) {
    const { ethAddress: t, message: r, signature: s, recoveryId: n, instructionIndex: c = 0 } = e;
    let f;
    typeof t == 'string'
      ? t.startsWith('0x')
        ? (f = He.from(t.substr(2), 'hex'))
        : (f = He.from(t, 'hex'))
      : (f = t),
      Vt(f.length === bp, `Address must be ${bp} bytes but received ${f.length} bytes`);
    const h = 1 + IO,
      y = h,
      p = h + f.length,
      m = p + s.length + 1,
      _ = 1,
      A = He.alloc(vp.span + r.length);
    return (
      vp.encode(
        {
          numSignatures: _,
          signatureOffset: p,
          signatureInstructionIndex: c,
          ethAddressOffset: y,
          ethAddressInstructionIndex: c,
          messageDataOffset: m,
          messageDataSize: r.length,
          messageInstructionIndex: c,
          signature: St(s),
          ethAddress: St(f),
          recoveryId: n,
        },
        A
      ),
      A.fill(St(r), vp.span),
      new pt({ keys: [], programId: Rf.programId, data: A })
    );
  }
  static createInstructionWithPrivateKey(e) {
    const { privateKey: t, message: r, instructionIndex: s } = e;
    Vt(t.length === Iw, `Private key must be ${Iw} bytes but received ${t.length} bytes`);
    try {
      const n = St(t),
        c = kO(n, !1).slice(1),
        f = He.from(pw(St(r))),
        [h, y] = EO(f, n);
      return this.createInstructionWithPublicKey({
        publicKey: c,
        message: r,
        signature: h,
        recoveryId: y,
        instructionIndex: s,
      });
    } catch (n) {
      throw new Error(`Error creating instruction; ${n}`);
    }
  }
};
W_.programId = new Ve('KeccakSecp256k11111111111111111111111111111');
const K_ = new Ve('StakeConfig11111111111111111111111111111111');
let j_ = class {
    constructor(e, t) {
      (this.staker = void 0), (this.withdrawer = void 0), (this.staker = e), (this.withdrawer = t);
    }
  },
  Uu = class {
    constructor(e, t, r) {
      (this.unixTimestamp = void 0),
        (this.epoch = void 0),
        (this.custodian = void 0),
        (this.unixTimestamp = e),
        (this.epoch = t),
        (this.custodian = r);
    }
  };
Uu.default = new Uu(0, 0, Ve.default);
let xO = class {
  constructor() {}
  static decodeInstructionType(e) {
    this.checkProgramId(e.programId);
    const r = qe('instruction').decode(e.data);
    let s;
    for (const [n, c] of Object.entries(Yr))
      if (c.index == r) {
        s = n;
        break;
      }
    if (!s) throw new Error('Instruction type incorrect; not a StakeInstruction');
    return s;
  }
  static decodeInitialize(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
    const { authorized: t, lockup: r } = er(Yr.Initialize, e.data);
    return {
      stakePubkey: e.keys[0].pubkey,
      authorized: new j_(new Ve(t.staker), new Ve(t.withdrawer)),
      lockup: new Uu(r.unixTimestamp, r.epoch, new Ve(r.custodian)),
    };
  }
  static decodeDelegate(e) {
    return (
      this.checkProgramId(e.programId),
      this.checkKeyLength(e.keys, 6),
      er(Yr.Delegate, e.data),
      {
        stakePubkey: e.keys[0].pubkey,
        votePubkey: e.keys[1].pubkey,
        authorizedPubkey: e.keys[5].pubkey,
      }
    );
  }
  static decodeAuthorize(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
    const { newAuthorized: t, stakeAuthorizationType: r } = er(Yr.Authorize, e.data),
      s = {
        stakePubkey: e.keys[0].pubkey,
        authorizedPubkey: e.keys[2].pubkey,
        newAuthorizedPubkey: new Ve(t),
        stakeAuthorizationType: { index: r },
      };
    return e.keys.length > 3 && (s.custodianPubkey = e.keys[3].pubkey), s;
  }
  static decodeAuthorizeWithSeed(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
    const {
        newAuthorized: t,
        stakeAuthorizationType: r,
        authoritySeed: s,
        authorityOwner: n,
      } = er(Yr.AuthorizeWithSeed, e.data),
      c = {
        stakePubkey: e.keys[0].pubkey,
        authorityBase: e.keys[1].pubkey,
        authoritySeed: s,
        authorityOwner: new Ve(n),
        newAuthorizedPubkey: new Ve(t),
        stakeAuthorizationType: { index: r },
      };
    return e.keys.length > 3 && (c.custodianPubkey = e.keys[3].pubkey), c;
  }
  static decodeSplit(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
    const { lamports: t } = er(Yr.Split, e.data);
    return {
      stakePubkey: e.keys[0].pubkey,
      splitStakePubkey: e.keys[1].pubkey,
      authorizedPubkey: e.keys[2].pubkey,
      lamports: t,
    };
  }
  static decodeMerge(e) {
    return (
      this.checkProgramId(e.programId),
      this.checkKeyLength(e.keys, 3),
      er(Yr.Merge, e.data),
      {
        stakePubkey: e.keys[0].pubkey,
        sourceStakePubKey: e.keys[1].pubkey,
        authorizedPubkey: e.keys[4].pubkey,
      }
    );
  }
  static decodeWithdraw(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 5);
    const { lamports: t } = er(Yr.Withdraw, e.data),
      r = {
        stakePubkey: e.keys[0].pubkey,
        toPubkey: e.keys[1].pubkey,
        authorizedPubkey: e.keys[4].pubkey,
        lamports: t,
      };
    return e.keys.length > 5 && (r.custodianPubkey = e.keys[5].pubkey), r;
  }
  static decodeDeactivate(e) {
    return (
      this.checkProgramId(e.programId),
      this.checkKeyLength(e.keys, 3),
      er(Yr.Deactivate, e.data),
      { stakePubkey: e.keys[0].pubkey, authorizedPubkey: e.keys[2].pubkey }
    );
  }
  static checkProgramId(e) {
    if (!e.equals(Zl.programId))
      throw new Error('invalid instruction; programId is not StakeProgram');
  }
  static checkKeyLength(e, t) {
    if (e.length < t)
      throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`);
  }
};
const Yr = Object.freeze({
    Initialize: { index: 0, layout: We([qe('instruction'), PP(), TP()]) },
    Authorize: {
      index: 1,
      layout: We([qe('instruction'), It('newAuthorized'), qe('stakeAuthorizationType')]),
    },
    Delegate: { index: 2, layout: We([qe('instruction')]) },
    Split: { index: 3, layout: We([qe('instruction'), Ir('lamports')]) },
    Withdraw: { index: 4, layout: We([qe('instruction'), Ir('lamports')]) },
    Deactivate: { index: 5, layout: We([qe('instruction')]) },
    Merge: { index: 7, layout: We([qe('instruction')]) },
    AuthorizeWithSeed: {
      index: 8,
      layout: We([
        qe('instruction'),
        It('newAuthorized'),
        qe('stakeAuthorizationType'),
        is('authoritySeed'),
        It('authorityOwner'),
      ]),
    },
  }),
  BO = Object.freeze({ Staker: { index: 0 }, Withdrawer: { index: 1 } });
let Zl = class {
  constructor() {}
  static initialize(e) {
    const { stakePubkey: t, authorized: r, lockup: s } = e,
      n = s || Uu.default,
      c = Yr.Initialize,
      f = $t(c, {
        authorized: { staker: St(r.staker.toBuffer()), withdrawer: St(r.withdrawer.toBuffer()) },
        lockup: {
          unixTimestamp: n.unixTimestamp,
          epoch: n.epoch,
          custodian: St(n.custodian.toBuffer()),
        },
      }),
      h = {
        keys: [
          { pubkey: t, isSigner: !1, isWritable: !0 },
          { pubkey: In, isSigner: !1, isWritable: !1 },
        ],
        programId: this.programId,
        data: f,
      };
    return new pt(h);
  }
  static createAccountWithSeed(e) {
    const t = new ct();
    t.add(
      Ur.createAccountWithSeed({
        fromPubkey: e.fromPubkey,
        newAccountPubkey: e.stakePubkey,
        basePubkey: e.basePubkey,
        seed: e.seed,
        lamports: e.lamports,
        space: this.space,
        programId: this.programId,
      })
    );
    const { stakePubkey: r, authorized: s, lockup: n } = e;
    return t.add(this.initialize({ stakePubkey: r, authorized: s, lockup: n }));
  }
  static createAccount(e) {
    const t = new ct();
    t.add(
      Ur.createAccount({
        fromPubkey: e.fromPubkey,
        newAccountPubkey: e.stakePubkey,
        lamports: e.lamports,
        space: this.space,
        programId: this.programId,
      })
    );
    const { stakePubkey: r, authorized: s, lockup: n } = e;
    return t.add(this.initialize({ stakePubkey: r, authorized: s, lockup: n }));
  }
  static delegate(e) {
    const { stakePubkey: t, authorizedPubkey: r, votePubkey: s } = e,
      n = Yr.Delegate,
      c = $t(n);
    return new ct().add({
      keys: [
        { pubkey: t, isSigner: !1, isWritable: !0 },
        { pubkey: s, isSigner: !1, isWritable: !1 },
        { pubkey: _n, isSigner: !1, isWritable: !1 },
        { pubkey: xf, isSigner: !1, isWritable: !1 },
        { pubkey: K_, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ],
      programId: this.programId,
      data: c,
    });
  }
  static authorize(e) {
    const {
        stakePubkey: t,
        authorizedPubkey: r,
        newAuthorizedPubkey: s,
        stakeAuthorizationType: n,
        custodianPubkey: c,
      } = e,
      f = Yr.Authorize,
      h = $t(f, { newAuthorized: St(s.toBuffer()), stakeAuthorizationType: n.index }),
      y = [
        { pubkey: t, isSigner: !1, isWritable: !0 },
        { pubkey: _n, isSigner: !1, isWritable: !0 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ];
    return (
      c && y.push({ pubkey: c, isSigner: !1, isWritable: !1 }),
      new ct().add({ keys: y, programId: this.programId, data: h })
    );
  }
  static authorizeWithSeed(e) {
    const {
        stakePubkey: t,
        authorityBase: r,
        authoritySeed: s,
        authorityOwner: n,
        newAuthorizedPubkey: c,
        stakeAuthorizationType: f,
        custodianPubkey: h,
      } = e,
      y = Yr.AuthorizeWithSeed,
      p = $t(y, {
        newAuthorized: St(c.toBuffer()),
        stakeAuthorizationType: f.index,
        authoritySeed: s,
        authorityOwner: St(n.toBuffer()),
      }),
      m = [
        { pubkey: t, isSigner: !1, isWritable: !0 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
        { pubkey: _n, isSigner: !1, isWritable: !1 },
      ];
    return (
      h && m.push({ pubkey: h, isSigner: !1, isWritable: !1 }),
      new ct().add({ keys: m, programId: this.programId, data: p })
    );
  }
  static splitInstruction(e) {
    const { stakePubkey: t, authorizedPubkey: r, splitStakePubkey: s, lamports: n } = e,
      c = Yr.Split,
      f = $t(c, { lamports: n });
    return new pt({
      keys: [
        { pubkey: t, isSigner: !1, isWritable: !0 },
        { pubkey: s, isSigner: !1, isWritable: !0 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ],
      programId: this.programId,
      data: f,
    });
  }
  static split(e) {
    const t = new ct();
    return (
      t.add(
        Ur.createAccount({
          fromPubkey: e.authorizedPubkey,
          newAccountPubkey: e.splitStakePubkey,
          lamports: 0,
          space: this.space,
          programId: this.programId,
        })
      ),
      t.add(this.splitInstruction(e))
    );
  }
  static splitWithSeed(e) {
    const {
        stakePubkey: t,
        authorizedPubkey: r,
        splitStakePubkey: s,
        basePubkey: n,
        seed: c,
        lamports: f,
      } = e,
      h = new ct();
    return (
      h.add(
        Ur.allocate({
          accountPubkey: s,
          basePubkey: n,
          seed: c,
          space: this.space,
          programId: this.programId,
        })
      ),
      h.add(
        this.splitInstruction({
          stakePubkey: t,
          authorizedPubkey: r,
          splitStakePubkey: s,
          lamports: f,
        })
      )
    );
  }
  static merge(e) {
    const { stakePubkey: t, sourceStakePubKey: r, authorizedPubkey: s } = e,
      n = Yr.Merge,
      c = $t(n);
    return new ct().add({
      keys: [
        { pubkey: t, isSigner: !1, isWritable: !0 },
        { pubkey: r, isSigner: !1, isWritable: !0 },
        { pubkey: _n, isSigner: !1, isWritable: !1 },
        { pubkey: xf, isSigner: !1, isWritable: !1 },
        { pubkey: s, isSigner: !0, isWritable: !1 },
      ],
      programId: this.programId,
      data: c,
    });
  }
  static withdraw(e) {
    const { stakePubkey: t, authorizedPubkey: r, toPubkey: s, lamports: n, custodianPubkey: c } = e,
      f = Yr.Withdraw,
      h = $t(f, { lamports: n }),
      y = [
        { pubkey: t, isSigner: !1, isWritable: !0 },
        { pubkey: s, isSigner: !1, isWritable: !0 },
        { pubkey: _n, isSigner: !1, isWritable: !1 },
        { pubkey: xf, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ];
    return (
      c && y.push({ pubkey: c, isSigner: !1, isWritable: !1 }),
      new ct().add({ keys: y, programId: this.programId, data: h })
    );
  }
  static deactivate(e) {
    const { stakePubkey: t, authorizedPubkey: r } = e,
      s = Yr.Deactivate,
      n = $t(s);
    return new ct().add({
      keys: [
        { pubkey: t, isSigner: !1, isWritable: !0 },
        { pubkey: _n, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ],
      programId: this.programId,
      data: n,
    });
  }
};
Zl.programId = new Ve('Stake11111111111111111111111111111111111111');
Zl.space = 200;
let H_ = class {
    constructor(e, t, r, s) {
      (this.nodePubkey = void 0),
        (this.authorizedVoter = void 0),
        (this.authorizedWithdrawer = void 0),
        (this.commission = void 0),
        (this.nodePubkey = e),
        (this.authorizedVoter = t),
        (this.authorizedWithdrawer = r),
        (this.commission = s);
    }
  },
  RO = class {
    constructor() {}
    static decodeInstructionType(e) {
      this.checkProgramId(e.programId);
      const r = qe('instruction').decode(e.data);
      let s;
      for (const [n, c] of Object.entries(Xn))
        if (c.index == r) {
          s = n;
          break;
        }
      if (!s) throw new Error('Instruction type incorrect; not a VoteInstruction');
      return s;
    }
    static decodeInitializeAccount(e) {
      this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 4);
      const { voteInit: t } = er(Xn.InitializeAccount, e.data);
      return {
        votePubkey: e.keys[0].pubkey,
        nodePubkey: e.keys[3].pubkey,
        voteInit: new H_(
          new Ve(t.nodePubkey),
          new Ve(t.authorizedVoter),
          new Ve(t.authorizedWithdrawer),
          t.commission
        ),
      };
    }
    static decodeAuthorize(e) {
      this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
      const { newAuthorized: t, voteAuthorizationType: r } = er(Xn.Authorize, e.data);
      return {
        votePubkey: e.keys[0].pubkey,
        authorizedPubkey: e.keys[2].pubkey,
        newAuthorizedPubkey: new Ve(t),
        voteAuthorizationType: { index: r },
      };
    }
    static decodeAuthorizeWithSeed(e) {
      this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
      const {
        voteAuthorizeWithSeedArgs: {
          currentAuthorityDerivedKeyOwnerPubkey: t,
          currentAuthorityDerivedKeySeed: r,
          newAuthorized: s,
          voteAuthorizationType: n,
        },
      } = er(Xn.AuthorizeWithSeed, e.data);
      return {
        currentAuthorityDerivedKeyBasePubkey: e.keys[2].pubkey,
        currentAuthorityDerivedKeyOwnerPubkey: new Ve(t),
        currentAuthorityDerivedKeySeed: r,
        newAuthorizedPubkey: new Ve(s),
        voteAuthorizationType: { index: n },
        votePubkey: e.keys[0].pubkey,
      };
    }
    static decodeWithdraw(e) {
      this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
      const { lamports: t } = er(Xn.Withdraw, e.data);
      return {
        votePubkey: e.keys[0].pubkey,
        authorizedWithdrawerPubkey: e.keys[2].pubkey,
        lamports: t,
        toPubkey: e.keys[1].pubkey,
      };
    }
    static checkProgramId(e) {
      if (!e.equals(Jl.programId))
        throw new Error('invalid instruction; programId is not VoteProgram');
    }
    static checkKeyLength(e, t) {
      if (e.length < t)
        throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`);
    }
  };
const Xn = Object.freeze({
    InitializeAccount: { index: 0, layout: We([qe('instruction'), OP()]) },
    Authorize: {
      index: 1,
      layout: We([qe('instruction'), It('newAuthorized'), qe('voteAuthorizationType')]),
    },
    Withdraw: { index: 3, layout: We([qe('instruction'), Ir('lamports')]) },
    AuthorizeWithSeed: { index: 10, layout: We([qe('instruction'), CP()]) },
  }),
  PO = Object.freeze({ Voter: { index: 0 }, Withdrawer: { index: 1 } });
let Jl = class V_ {
  constructor() {}
  static initializeAccount(e) {
    const { votePubkey: t, nodePubkey: r, voteInit: s } = e,
      n = Xn.InitializeAccount,
      c = $t(n, {
        voteInit: {
          nodePubkey: St(s.nodePubkey.toBuffer()),
          authorizedVoter: St(s.authorizedVoter.toBuffer()),
          authorizedWithdrawer: St(s.authorizedWithdrawer.toBuffer()),
          commission: s.commission,
        },
      }),
      f = {
        keys: [
          { pubkey: t, isSigner: !1, isWritable: !0 },
          { pubkey: In, isSigner: !1, isWritable: !1 },
          { pubkey: _n, isSigner: !1, isWritable: !1 },
          { pubkey: r, isSigner: !0, isWritable: !1 },
        ],
        programId: this.programId,
        data: c,
      };
    return new pt(f);
  }
  static createAccount(e) {
    const t = new ct();
    return (
      t.add(
        Ur.createAccount({
          fromPubkey: e.fromPubkey,
          newAccountPubkey: e.votePubkey,
          lamports: e.lamports,
          space: this.space,
          programId: this.programId,
        })
      ),
      t.add(
        this.initializeAccount({
          votePubkey: e.votePubkey,
          nodePubkey: e.voteInit.nodePubkey,
          voteInit: e.voteInit,
        })
      )
    );
  }
  static authorize(e) {
    const {
        votePubkey: t,
        authorizedPubkey: r,
        newAuthorizedPubkey: s,
        voteAuthorizationType: n,
      } = e,
      c = Xn.Authorize,
      f = $t(c, { newAuthorized: St(s.toBuffer()), voteAuthorizationType: n.index }),
      h = [
        { pubkey: t, isSigner: !1, isWritable: !0 },
        { pubkey: _n, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ];
    return new ct().add({ keys: h, programId: this.programId, data: f });
  }
  static authorizeWithSeed(e) {
    const {
        currentAuthorityDerivedKeyBasePubkey: t,
        currentAuthorityDerivedKeyOwnerPubkey: r,
        currentAuthorityDerivedKeySeed: s,
        newAuthorizedPubkey: n,
        voteAuthorizationType: c,
        votePubkey: f,
      } = e,
      h = Xn.AuthorizeWithSeed,
      y = $t(h, {
        voteAuthorizeWithSeedArgs: {
          currentAuthorityDerivedKeyOwnerPubkey: St(r.toBuffer()),
          currentAuthorityDerivedKeySeed: s,
          newAuthorized: St(n.toBuffer()),
          voteAuthorizationType: c.index,
        },
      }),
      p = [
        { pubkey: f, isSigner: !1, isWritable: !0 },
        { pubkey: _n, isSigner: !1, isWritable: !1 },
        { pubkey: t, isSigner: !0, isWritable: !1 },
      ];
    return new ct().add({ keys: p, programId: this.programId, data: y });
  }
  static withdraw(e) {
    const { votePubkey: t, authorizedWithdrawerPubkey: r, lamports: s, toPubkey: n } = e,
      c = Xn.Withdraw,
      f = $t(c, { lamports: s }),
      h = [
        { pubkey: t, isSigner: !1, isWritable: !0 },
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ];
    return new ct().add({ keys: h, programId: this.programId, data: f });
  }
  static safeWithdraw(e, t, r) {
    if (e.lamports > t - r)
      throw new Error('Withdraw will leave vote account with insuffcient funds.');
    return V_.withdraw(e);
  }
};
Jl.programId = new Ve('Vote111111111111111111111111111111111111111');
Jl.space = 3731;
const G_ = new Ve('Va1idator1nfo111111111111111111111111111111'),
  TO = pe({ name: we(), website: Ge(we()), details: Ge(we()), keybaseUsername: Ge(we()) });
let OO = class Y_ {
  constructor(e, t) {
    (this.key = void 0), (this.info = void 0), (this.key = e), (this.info = t);
  }
  static fromConfigData(e) {
    let t = [...e];
    if (Si(t) !== 2) return null;
    const s = [];
    for (let n = 0; n < 2; n++) {
      const c = new Ve(t.slice(0, Ni));
      t = t.slice(Ni);
      const f = t.slice(0, 1)[0] === 1;
      (t = t.slice(1)), s.push({ publicKey: c, isSigner: f });
    }
    if (s[0].publicKey.equals(G_) && s[1].isSigner) {
      const n = is().decode(He.from(t)),
        c = JSON.parse(n);
      return Ny(c, TO), new Y_(s[1].publicKey, c);
    }
    return null;
  }
};
const CO = new Ve('Vote111111111111111111111111111111111111111'),
  LO = We([
    It('nodePubkey'),
    It('authorizedWithdrawer'),
    tt('commission'),
    Nt(),
    zt(We([Nt('slot'), qe('confirmationCount')]), _i(qe(), -8), 'votes'),
    tt('rootSlotValid'),
    Nt('rootSlot'),
    Nt(),
    zt(We([Nt('epoch'), It('authorizedVoter')]), _i(qe(), -8), 'authorizedVoters'),
    We(
      [
        zt(
          We([It('authorizedPubkey'), Nt('epochOfLastAuthorizedSwitch'), Nt('targetEpoch')]),
          32,
          'buf'
        ),
        Nt('idx'),
        tt('isEmpty'),
      ],
      'priorVoters'
    ),
    Nt(),
    zt(We([Nt('epoch'), Nt('credits'), Nt('prevCredits')]), _i(qe(), -8), 'epochCredits'),
    We([Nt('slot'), Nt('timestamp')], 'lastTimestamp'),
  ]);
let NO = class Z_ {
  constructor(e) {
    (this.nodePubkey = void 0),
      (this.authorizedWithdrawer = void 0),
      (this.commission = void 0),
      (this.rootSlot = void 0),
      (this.votes = void 0),
      (this.authorizedVoters = void 0),
      (this.priorVoters = void 0),
      (this.epochCredits = void 0),
      (this.lastTimestamp = void 0),
      (this.nodePubkey = e.nodePubkey),
      (this.authorizedWithdrawer = e.authorizedWithdrawer),
      (this.commission = e.commission),
      (this.rootSlot = e.rootSlot),
      (this.votes = e.votes),
      (this.authorizedVoters = e.authorizedVoters),
      (this.priorVoters = e.priorVoters),
      (this.epochCredits = e.epochCredits),
      (this.lastTimestamp = e.lastTimestamp);
  }
  static fromAccountData(e) {
    const r = LO.decode(St(e), 4);
    let s = r.rootSlot;
    return (
      r.rootSlotValid || (s = null),
      new Z_({
        nodePubkey: new Ve(r.nodePubkey),
        authorizedWithdrawer: new Ve(r.authorizedWithdrawer),
        commission: r.commission,
        votes: r.votes,
        rootSlot: s,
        authorizedVoters: r.authorizedVoters.map($O),
        priorVoters: DO(r.priorVoters),
        epochCredits: r.epochCredits,
        lastTimestamp: r.lastTimestamp,
      })
    );
  }
};
function $O({ authorizedVoter: i, epoch: e }) {
  return { epoch: e, authorizedVoter: new Ve(i) };
}
function Bw({ authorizedPubkey: i, epochOfLastAuthorizedSwitch: e, targetEpoch: t }) {
  return { authorizedPubkey: new Ve(i), epochOfLastAuthorizedSwitch: e, targetEpoch: t };
}
function DO({ buf: i, idx: e, isEmpty: t }) {
  return t ? [] : [...i.slice(e + 1).map(Bw), ...i.slice(0, e).map(Bw)];
}
const Rw = {
  http: {
    devnet: 'http://api.devnet.solana.com',
    testnet: 'http://api.testnet.solana.com',
    'mainnet-beta': 'http://api.mainnet-beta.solana.com/',
  },
  https: {
    devnet: 'https://api.devnet.solana.com',
    testnet: 'https://api.testnet.solana.com',
    'mainnet-beta': 'https://api.mainnet-beta.solana.com/',
  },
};
function UO(i, e) {
  const t = e === !1 ? 'http' : 'https';
  if (!i) return Rw[t].devnet;
  const r = Rw[t][i];
  if (!r) throw new Error(`Unknown ${t} cluster: ${i}`);
  return r;
}
async function zO(i, e, t, r) {
  let s, n;
  (t && Object.prototype.hasOwnProperty.call(t, 'lastValidBlockHeight')) ||
  (t && Object.prototype.hasOwnProperty.call(t, 'nonceValue'))
    ? ((s = t), (n = r))
    : (n = t);
  const c = n && {
      skipPreflight: n.skipPreflight,
      preflightCommitment: n.preflightCommitment || n.commitment,
      minContextSlot: n.minContextSlot,
    },
    f = await i.sendRawTransaction(e, c),
    h = n && n.commitment,
    p = (await (s ? i.confirmTransaction(s, h) : i.confirmTransaction(f, h))).value;
  if (p.err) throw new Error(`Raw transaction ${f} failed (${JSON.stringify(p)})`);
  return f;
}
const FO = 1e9,
  qO = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Account: xP,
        AddressLookupTableAccount: d1,
        AddressLookupTableInstruction: MO,
        AddressLookupTableProgram: Vy,
        Authorized: j_,
        BLOCKHASH_CACHE_TIMEOUT_MS: P_,
        BPF_LOADER_DEPRECATED_PROGRAM_ID: BP,
        BPF_LOADER_PROGRAM_ID: VP,
        BpfLoader: GP,
        COMPUTE_BUDGET_INSTRUCTION_LAYOUTS: An,
        ComputeBudgetInstruction: AO,
        ComputeBudgetProgram: Gy,
        Connection: SO,
        Ed25519Program: F_,
        Enum: kP,
        EpochSchedule: B_,
        FeeCalculatorLayout: E_,
        Keypair: ra,
        LAMPORTS_PER_SOL: FO,
        LOOKUP_TABLE_INSTRUCTION_LAYOUTS: Jn,
        Loader: ol,
        Lockup: Uu,
        MAX_SEED_LENGTH: m_,
        Message: $o,
        MessageAccountKeys: $u,
        MessageV0: Vl,
        NONCE_ACCOUNT_LENGTH: c1,
        NonceAccount: I_,
        PACKET_DATA_SIZE: Co,
        PUBLIC_KEY_LENGTH: Ni,
        PublicKey: Ve,
        SIGNATURE_LENGTH_IN_BYTES: Pa,
        SOLANA_SCHEMA: Eu,
        STAKE_CONFIG_ID: K_,
        STAKE_INSTRUCTION_LAYOUTS: Yr,
        SYSTEM_INSTRUCTION_LAYOUTS: Ar,
        SYSVAR_CLOCK_PUBKEY: _n,
        SYSVAR_EPOCH_SCHEDULE_PUBKEY: DP,
        SYSVAR_INSTRUCTIONS_PUBKEY: UP,
        SYSVAR_RECENT_BLOCKHASHES_PUBKEY: If,
        SYSVAR_RENT_PUBKEY: In,
        SYSVAR_REWARDS_PUBKEY: zP,
        SYSVAR_SLOT_HASHES_PUBKEY: FP,
        SYSVAR_SLOT_HISTORY_PUBKEY: qP,
        SYSVAR_STAKE_HISTORY_PUBKEY: xf,
        Secp256k1Program: W_,
        SendTransactionError: h1,
        SolanaJSONRPCError: nt,
        SolanaJSONRPCErrorCode: QP,
        StakeAuthorizationLayout: BO,
        StakeInstruction: xO,
        StakeProgram: Zl,
        Struct: zy,
        SystemInstruction: jP,
        SystemProgram: Ur,
        Transaction: ct,
        TransactionExpiredBlockheightExceededError: Fy,
        TransactionExpiredNonceInvalidError: ta,
        TransactionExpiredTimeoutError: qy,
        TransactionInstruction: pt,
        TransactionMessage: NP,
        get TransactionStatus() {
          return nn;
        },
        VALIDATOR_INFO_KEY: G_,
        VERSION_PREFIX_MASK: Hl,
        VOTE_PROGRAM_ID: CO,
        ValidatorInfo: OO,
        VersionedMessage: Wy,
        VersionedTransaction: $P,
        VoteAccount: NO,
        VoteAuthorizationLayout: PO,
        VoteInit: H_,
        VoteInstruction: RO,
        VoteProgram: Jl,
        clusterApiUrl: UO,
        sendAndConfirmRawTransaction: zO,
        sendAndConfirmTransaction: ku,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  qr = pn(qO);
var J_ = {},
  b1 = {},
  Jt = {},
  Jr = {},
  ir = {};
Object.defineProperty(ir, '__esModule', { value: !0 });
ir.isElementCollectionFixedSizeBeet =
  ir.isFixableBeet =
  ir.assertFixedSizeBeet =
  ir.isFixedSizeBeet =
  ir.BEET_TYPE_ARG_INNER =
  ir.BEET_TYPE_ARG_LEN =
  ir.BEET_PACKAGE =
    void 0;
const WO = Ui();
ir.BEET_PACKAGE = '@metaplex-foundation/beet';
ir.BEET_TYPE_ARG_LEN = 'len';
ir.BEET_TYPE_ARG_INNER = 'Beet<{innner}>';
function X_(i) {
  return Object.keys(i).includes('byteSize');
}
ir.isFixedSizeBeet = X_;
function KO(i, e = `${i} should have been a fixed beet`) {
  (0, WO.strict)(X_(i), e);
}
ir.assertFixedSizeBeet = KO;
function jO(i) {
  return typeof i.toFixedFromData == 'function' && typeof i.toFixedFromValue == 'function';
}
ir.isFixableBeet = jO;
function HO(i) {
  const e = Object.keys(i);
  return e.includes('length') && e.includes('elementByteSize') && e.includes('lenPrefixByteSize');
}
ir.isElementCollectionFixedSizeBeet = HO;
var Do = {};
(function (i) {
  var e =
    (se && se.__importDefault) ||
    function (c) {
      return c && c.__esModule ? c : { default: c };
    };
  Object.defineProperty(i, '__esModule', { value: !0 }),
    (i.numbersTypeMap =
      i.bool =
      i.i512 =
      i.i256 =
      i.i128 =
      i.i64 =
      i.i32 =
      i.i16 =
      i.i8 =
      i.u512 =
      i.u256 =
      i.u128 =
      i.u64 =
      i.u32 =
      i.u16 =
      i.u8 =
        void 0);
  const t = e(Ko()),
    r = ir;
  (i.u8 = {
    write: function (c, f, h) {
      c.writeUInt8(h, f);
    },
    read: function (c, f) {
      return c.readUInt8(f);
    },
    byteSize: 1,
    description: 'u8',
  }),
    (i.u16 = {
      write: function (c, f, h) {
        c.writeUInt16LE(h, f);
      },
      read: function (c, f) {
        return c.readUInt16LE(f);
      },
      byteSize: 2,
      description: 'u16',
    }),
    (i.u32 = {
      write: function (c, f, h) {
        c.writeUInt32LE(h, f);
      },
      read: function (c, f) {
        return c.readUInt32LE(f);
      },
      byteSize: 4,
      description: 'u32',
    });
  function s(c, f) {
    return {
      write: function (h, y, p) {
        const _ = (t.default.isBN(p) ? p : new t.default(p)).toArray('le', this.byteSize);
        Ze.from(_).copy(h, y, 0, this.byteSize);
      },
      read: function (h, y) {
        const p = h.slice(y, y + this.byteSize);
        return new t.default(p, 'le');
      },
      byteSize: c,
      description: f,
    };
  }
  (i.u64 = s(8, 'u64')),
    (i.u128 = s(16, 'u128')),
    (i.u256 = s(32, 'u256')),
    (i.u512 = s(64, 'u512')),
    (i.i8 = {
      write: function (c, f, h) {
        c.writeInt8(h, f);
      },
      read: function (c, f) {
        return c.readInt8(f);
      },
      byteSize: 1,
      description: 'i8',
    }),
    (i.i16 = {
      write: function (c, f, h) {
        c.writeInt16LE(h, f);
      },
      read: function (c, f) {
        return c.readInt16LE(f);
      },
      byteSize: 2,
      description: 'i16',
    }),
    (i.i32 = {
      write: function (c, f, h) {
        c.writeInt32LE(h, f);
      },
      read: function (c, f) {
        return c.readInt32LE(f);
      },
      byteSize: 4,
      description: 'i32',
    });
  function n(c, f) {
    const h = c * 8;
    return {
      write: function (y, p, m) {
        const A = (t.default.isBN(m) ? m : new t.default(m)).toTwos(h).toArray('le', this.byteSize);
        Ze.from(A).copy(y, p, 0, this.byteSize);
      },
      read: function (y, p) {
        const m = y.slice(p, p + this.byteSize);
        return new t.default(m, 'le').fromTwos(h);
      },
      byteSize: c,
      description: f,
    };
  }
  (i.i64 = n(8, 'i64')),
    (i.i128 = n(16, 'i128')),
    (i.i256 = n(32, 'i256')),
    (i.i512 = n(64, 'i512')),
    (i.bool = {
      write: function (c, f, h) {
        const y = h ? 1 : 0;
        i.u8.write(c, f, y);
      },
      read: function (c, f) {
        return i.u8.read(c, f) === 1;
      },
      byteSize: 1,
      description: 'bool',
    }),
    (i.numbersTypeMap = {
      u8: { beet: 'u8', isFixable: !1, sourcePack: r.BEET_PACKAGE, ts: 'number' },
      u16: { beet: 'u16', isFixable: !1, sourcePack: r.BEET_PACKAGE, ts: 'number' },
      u32: { beet: 'u32', isFixable: !1, sourcePack: r.BEET_PACKAGE, ts: 'number' },
      i8: { beet: 'i8', isFixable: !1, sourcePack: r.BEET_PACKAGE, ts: 'number' },
      i16: { beet: 'i16', isFixable: !1, sourcePack: r.BEET_PACKAGE, ts: 'number' },
      i32: { beet: 'i32', isFixable: !1, sourcePack: r.BEET_PACKAGE, ts: 'number' },
      bool: { beet: 'bool', isFixable: !1, sourcePack: r.BEET_PACKAGE, ts: 'boolean' },
      u64: {
        beet: 'u64',
        isFixable: !1,
        sourcePack: r.BEET_PACKAGE,
        ts: 'bignum',
        pack: r.BEET_PACKAGE,
      },
      u128: {
        beet: 'u128',
        isFixable: !1,
        sourcePack: r.BEET_PACKAGE,
        ts: 'bignum',
        pack: r.BEET_PACKAGE,
      },
      u256: {
        beet: 'u256',
        isFixable: !1,
        sourcePack: r.BEET_PACKAGE,
        ts: 'bignum',
        pack: r.BEET_PACKAGE,
      },
      u512: {
        beet: 'u512',
        isFixable: !1,
        sourcePack: r.BEET_PACKAGE,
        ts: 'bignum',
        pack: r.BEET_PACKAGE,
      },
      i64: {
        beet: 'i64',
        isFixable: !1,
        sourcePack: r.BEET_PACKAGE,
        ts: 'bignum',
        pack: r.BEET_PACKAGE,
      },
      i128: {
        beet: 'i128',
        isFixable: !1,
        sourcePack: r.BEET_PACKAGE,
        ts: 'bignum',
        pack: r.BEET_PACKAGE,
      },
      i256: {
        beet: 'i256',
        isFixable: !1,
        sourcePack: r.BEET_PACKAGE,
        ts: 'bignum',
        pack: r.BEET_PACKAGE,
      },
      i512: {
        beet: 'i512',
        isFixable: !1,
        sourcePack: r.BEET_PACKAGE,
        ts: 'bignum',
        pack: r.BEET_PACKAGE,
      },
    });
})(Do);
var kr = {},
  v1 = { exports: {} },
  mp,
  Pw;
function VO() {
  if (Pw) return mp;
  Pw = 1;
  var i = 1e3,
    e = i * 60,
    t = e * 60,
    r = t * 24,
    s = r * 7,
    n = r * 365.25;
  mp = function (p, m) {
    m = m || {};
    var _ = typeof p;
    if (_ === 'string' && p.length > 0) return c(p);
    if (_ === 'number' && isFinite(p)) return m.long ? h(p) : f(p);
    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(p));
  };
  function c(p) {
    if (((p = String(p)), !(p.length > 100))) {
      var m =
        /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          p
        );
      if (m) {
        var _ = parseFloat(m[1]),
          A = (m[2] || 'ms').toLowerCase();
        switch (A) {
          case 'years':
          case 'year':
          case 'yrs':
          case 'yr':
          case 'y':
            return _ * n;
          case 'weeks':
          case 'week':
          case 'w':
            return _ * s;
          case 'days':
          case 'day':
          case 'd':
            return _ * r;
          case 'hours':
          case 'hour':
          case 'hrs':
          case 'hr':
          case 'h':
            return _ * t;
          case 'minutes':
          case 'minute':
          case 'mins':
          case 'min':
          case 'm':
            return _ * e;
          case 'seconds':
          case 'second':
          case 'secs':
          case 'sec':
          case 's':
            return _ * i;
          case 'milliseconds':
          case 'millisecond':
          case 'msecs':
          case 'msec':
          case 'ms':
            return _;
          default:
            return;
        }
      }
    }
  }
  function f(p) {
    var m = Math.abs(p);
    return m >= r
      ? Math.round(p / r) + 'd'
      : m >= t
        ? Math.round(p / t) + 'h'
        : m >= e
          ? Math.round(p / e) + 'm'
          : m >= i
            ? Math.round(p / i) + 's'
            : p + 'ms';
  }
  function h(p) {
    var m = Math.abs(p);
    return m >= r
      ? y(p, m, r, 'day')
      : m >= t
        ? y(p, m, t, 'hour')
        : m >= e
          ? y(p, m, e, 'minute')
          : m >= i
            ? y(p, m, i, 'second')
            : p + ' ms';
  }
  function y(p, m, _, A) {
    var E = m >= _ * 1.5;
    return Math.round(p / _) + ' ' + A + (E ? 's' : '');
  }
  return mp;
}
function GO(i) {
  (t.debug = t),
    (t.default = t),
    (t.coerce = h),
    (t.disable = n),
    (t.enable = s),
    (t.enabled = c),
    (t.humanize = VO()),
    (t.destroy = y),
    Object.keys(i).forEach((p) => {
      t[p] = i[p];
    }),
    (t.names = []),
    (t.skips = []),
    (t.formatters = {});
  function e(p) {
    let m = 0;
    for (let _ = 0; _ < p.length; _++) (m = (m << 5) - m + p.charCodeAt(_)), (m |= 0);
    return t.colors[Math.abs(m) % t.colors.length];
  }
  t.selectColor = e;
  function t(p) {
    let m,
      _ = null,
      A,
      E;
    function I(...R) {
      if (!I.enabled) return;
      const L = I,
        D = Number(new Date()),
        q = D - (m || D);
      (L.diff = q),
        (L.prev = m),
        (L.curr = D),
        (m = D),
        (R[0] = t.coerce(R[0])),
        typeof R[0] != 'string' && R.unshift('%O');
      let H = 0;
      (R[0] = R[0].replace(/%([a-zA-Z%])/g, (te, ue) => {
        if (te === '%%') return '%';
        H++;
        const ne = t.formatters[ue];
        if (typeof ne == 'function') {
          const X = R[H];
          (te = ne.call(L, X)), R.splice(H, 1), H--;
        }
        return te;
      })),
        t.formatArgs.call(L, R),
        (L.log || t.log).apply(L, R);
    }
    return (
      (I.namespace = p),
      (I.useColors = t.useColors()),
      (I.color = t.selectColor(p)),
      (I.extend = r),
      (I.destroy = t.destroy),
      Object.defineProperty(I, 'enabled', {
        enumerable: !0,
        configurable: !1,
        get: () =>
          _ !== null ? _ : (A !== t.namespaces && ((A = t.namespaces), (E = t.enabled(p))), E),
        set: (R) => {
          _ = R;
        },
      }),
      typeof t.init == 'function' && t.init(I),
      I
    );
  }
  function r(p, m) {
    const _ = t(this.namespace + (typeof m > 'u' ? ':' : m) + p);
    return (_.log = this.log), _;
  }
  function s(p) {
    t.save(p), (t.namespaces = p), (t.names = []), (t.skips = []);
    let m;
    const _ = (typeof p == 'string' ? p : '').split(/[\s,]+/),
      A = _.length;
    for (m = 0; m < A; m++)
      _[m] &&
        ((p = _[m].replace(/\*/g, '.*?')),
        p[0] === '-'
          ? t.skips.push(new RegExp('^' + p.slice(1) + '$'))
          : t.names.push(new RegExp('^' + p + '$')));
  }
  function n() {
    const p = [...t.names.map(f), ...t.skips.map(f).map((m) => '-' + m)].join(',');
    return t.enable(''), p;
  }
  function c(p) {
    if (p[p.length - 1] === '*') return !0;
    let m, _;
    for (m = 0, _ = t.skips.length; m < _; m++) if (t.skips[m].test(p)) return !1;
    for (m = 0, _ = t.names.length; m < _; m++) if (t.names[m].test(p)) return !0;
    return !1;
  }
  function f(p) {
    return p
      .toString()
      .substring(2, p.toString().length - 2)
      .replace(/\.\*\?$/, '*');
  }
  function h(p) {
    return p instanceof Error ? p.stack || p.message : p;
  }
  function y() {
    console.warn(
      'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
    );
  }
  return t.enable(t.load()), t;
}
var YO = GO;
(function (i, e) {
  var t = {};
  (e.formatArgs = s),
    (e.save = n),
    (e.load = c),
    (e.useColors = r),
    (e.storage = f()),
    (e.destroy = (() => {
      let y = !1;
      return () => {
        y ||
          ((y = !0),
          console.warn(
            'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
          ));
      };
    })()),
    (e.colors = [
      '#0000CC',
      '#0000FF',
      '#0033CC',
      '#0033FF',
      '#0066CC',
      '#0066FF',
      '#0099CC',
      '#0099FF',
      '#00CC00',
      '#00CC33',
      '#00CC66',
      '#00CC99',
      '#00CCCC',
      '#00CCFF',
      '#3300CC',
      '#3300FF',
      '#3333CC',
      '#3333FF',
      '#3366CC',
      '#3366FF',
      '#3399CC',
      '#3399FF',
      '#33CC00',
      '#33CC33',
      '#33CC66',
      '#33CC99',
      '#33CCCC',
      '#33CCFF',
      '#6600CC',
      '#6600FF',
      '#6633CC',
      '#6633FF',
      '#66CC00',
      '#66CC33',
      '#9900CC',
      '#9900FF',
      '#9933CC',
      '#9933FF',
      '#99CC00',
      '#99CC33',
      '#CC0000',
      '#CC0033',
      '#CC0066',
      '#CC0099',
      '#CC00CC',
      '#CC00FF',
      '#CC3300',
      '#CC3333',
      '#CC3366',
      '#CC3399',
      '#CC33CC',
      '#CC33FF',
      '#CC6600',
      '#CC6633',
      '#CC9900',
      '#CC9933',
      '#CCCC00',
      '#CCCC33',
      '#FF0000',
      '#FF0033',
      '#FF0066',
      '#FF0099',
      '#FF00CC',
      '#FF00FF',
      '#FF3300',
      '#FF3333',
      '#FF3366',
      '#FF3399',
      '#FF33CC',
      '#FF33FF',
      '#FF6600',
      '#FF6633',
      '#FF9900',
      '#FF9933',
      '#FFCC00',
      '#FFCC33',
    ]);
  function r() {
    return typeof window < 'u' &&
      window.process &&
      (window.process.type === 'renderer' || window.process.__nwjs)
      ? !0
      : typeof navigator < 'u' &&
          navigator.userAgent &&
          navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
        ? !1
        : (typeof document < 'u' &&
            document.documentElement &&
            document.documentElement.style &&
            document.documentElement.style.WebkitAppearance) ||
          (typeof window < 'u' &&
            window.console &&
            (window.console.firebug || (window.console.exception && window.console.table))) ||
          (typeof navigator < 'u' &&
            navigator.userAgent &&
            navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
            parseInt(RegExp.$1, 10) >= 31) ||
          (typeof navigator < 'u' &&
            navigator.userAgent &&
            navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
  }
  function s(y) {
    if (
      ((y[0] =
        (this.useColors ? '%c' : '') +
        this.namespace +
        (this.useColors ? ' %c' : ' ') +
        y[0] +
        (this.useColors ? '%c ' : ' ') +
        '+' +
        i.exports.humanize(this.diff)),
      !this.useColors)
    )
      return;
    const p = 'color: ' + this.color;
    y.splice(1, 0, p, 'color: inherit');
    let m = 0,
      _ = 0;
    y[0].replace(/%[a-zA-Z%]/g, (A) => {
      A !== '%%' && (m++, A === '%c' && (_ = m));
    }),
      y.splice(_, 0, p);
  }
  e.log = console.debug || console.log || (() => {});
  function n(y) {
    try {
      y ? e.storage.setItem('debug', y) : e.storage.removeItem('debug');
    } catch {}
  }
  function c() {
    let y;
    try {
      y = e.storage.getItem('debug');
    } catch {}
    return !y && typeof Je < 'u' && 'env' in Je && (y = t.DEBUG), y;
  }
  function f() {
    try {
      return localStorage;
    } catch {}
  }
  i.exports = YO(e);
  const { formatters: h } = i.exports;
  h.j = function (y) {
    try {
      return JSON.stringify(y);
    } catch (p) {
      return '[UnexpectedJSONParseError]: ' + p.message;
    }
  };
})(v1, v1.exports);
var Q_ = v1.exports,
  Tw = {
    white: 37,
    black: 30,
    blue: 34,
    cyan: 36,
    green: 32,
    magenta: 35,
    red: 31,
    yellow: 33,
    brightBlack: 90,
    brightRed: 91,
    brightGreen: 92,
    brightYellow: 93,
    brightBlue: 94,
    brightMagenta: 95,
    brightCyan: 96,
    brightWhite: 97,
  },
  Ow = {
    bgBlack: 40,
    bgRed: 41,
    bgGreen: 42,
    bgYellow: 43,
    bgBlue: 44,
    bgMagenta: 45,
    bgCyan: 46,
    bgWhite: 47,
    bgBrightBlack: 100,
    bgBrightRed: 101,
    bgBrightGreen: 102,
    bgBrightYellow: 103,
    bgBrightBlue: 104,
    bgBrightMagenta: 105,
    bgBrightCyan: 106,
    bgBrightWhite: 107,
  },
  Yy = {},
  Zy = {},
  cc = {};
Object.keys(Tw).forEach(function (i) {
  var e = (Yy[i] = '\x1B[' + Tw[i] + 'm'),
    t = (Zy[i] = '\x1B[39m');
  cc[i] = function (r) {
    return e + r + t;
  };
});
Object.keys(Ow).forEach(function (i) {
  var e = (Yy[i] = '\x1B[' + Ow[i] + 'm'),
    t = (Zy[i] = '\x1B[49m');
  cc[i] = function (r) {
    return e + r + t;
  };
});
var eS = cc;
cc.open = Yy;
cc.close = Zy;
var tS =
  (se && se.__importDefault) ||
  function (i) {
    return i && i.__esModule ? i : { default: i };
  };
Object.defineProperty(kr, '__esModule', { value: !0 });
kr.UnreachableCaseError =
  kr.stringify =
  kr.bytes =
  kr.beetBytes =
  kr.logTrace =
  kr.logDebug =
  kr.logInfo =
  kr.logError =
    void 0;
const Xl = tS(Q_),
  ZO = tS(eS),
  Cw = ir,
  { brightBlack: rS } = ZO.default;
kr.logError = (0, Xl.default)('beet:error');
kr.logInfo = (0, Xl.default)('beet:info');
kr.logDebug = (0, Xl.default)('beet:debug');
kr.logTrace = (0, Xl.default)('beet:trace');
function JO(i, e = !1) {
  let t;
  if ((0, Cw.isFixableBeet)(i)) t = '? B';
  else if ((0, Cw.isElementCollectionFixedSizeBeet)(i)) {
    const r = e ? 'length' : i.length,
      s = i.lenPrefixByteSize;
    t =
      s > 0
        ? `${s} + (${i.elementByteSize} * ${r}) B  (${i.byteSize} B)`
        : `(${i.elementByteSize} * ${r}) B (${i.byteSize} B)`;
  } else t = `${i.byteSize} B`;
  return rS(t);
}
kr.beetBytes = JO;
function XO(i) {
  return rS(`${i} B`);
}
kr.bytes = XO;
function QO(i) {
  return i.toString === 'function' ? i.toString() : i;
}
kr.stringify = QO;
class eC extends Error {
  constructor(e) {
    super(`Unreachable case: ${e}`);
  }
}
kr.UnreachableCaseError = eC;
var Un = {};
Object.defineProperty(Un, '__esModule', { value: !0 });
Un.fixBeetFromValue = Un.fixBeetFromData = void 0;
const al = ir,
  iS = kr;
function tC(i, e, t) {
  if ((0, al.isFixedSizeBeet)(i)) return i;
  if ((0, al.isFixableBeet)(i)) return i.toFixedFromData(e, t);
  throw new iS.UnreachableCaseError(i);
}
Un.fixBeetFromData = tC;
function rC(i, e) {
  if ((0, al.isFixedSizeBeet)(i)) return i;
  if ((0, al.isFixableBeet)(i)) return i.toFixedFromValue(e);
  throw new iS.UnreachableCaseError(i);
}
Un.fixBeetFromValue = rC;
Object.defineProperty(Jr, '__esModule', { value: !0 });
Jr.collectionsTypeMap =
  Jr.uint8Array =
  Jr.fixedSizeUint8Array =
  Jr.fixedSizeBuffer =
  Jr.array =
  Jr.fixedSizeArray =
  Jr.uniformFixedSizeArray =
    void 0;
const js = ir,
  vs = Ui(),
  Uo = Do,
  Hs = ir,
  nS = kr,
  Lw = Un;
function iC(i, e, t = !1) {
  const r = i.byteSize * e,
    s = t ? 4 + r : r;
  return {
    write: function (n, c, f) {
      vs.strict.equal(f.length, e, `array length ${f.length} should match len ${e}`),
        t && (Uo.u32.write(n, c, e), (c += 4));
      for (let h = 0; h < e; h++) i.write(n, c + h * i.byteSize, f[h]);
    },
    read: function (n, c) {
      if (t) {
        const h = Uo.u32.read(n, c);
        vs.strict.equal(h, e, 'invalid byte size'), (c += 4);
      }
      const f = new Array(e);
      for (let h = 0; h < e; h++) f[h] = i.read(n, c + h * i.byteSize);
      return f;
    },
    byteSize: s,
    length: e,
    elementByteSize: i.byteSize,
    lenPrefixByteSize: 4,
    description: `Array<${i.description}>(${e})`,
  };
}
Jr.uniformFixedSizeArray = iC;
function m1(i, e) {
  const t = i.length,
    r = t === 0 ? '<EMPTY>' : i[0].description;
  return {
    write: function (s, n, c) {
      vs.strict.equal(c.length, t, `array length ${c.length} should match len ${t}`),
        Uo.u32.write(s, n, t);
      let f = n + 4;
      for (let h = 0; h < t; h++) {
        const y = i[h];
        y.write(s, f, c[h]), (f += y.byteSize);
      }
    },
    read: function (s, n) {
      const c = Uo.u32.read(s, n);
      vs.strict.equal(c, t, 'invalid byte size');
      let f = n + 4;
      const h = new Array(t);
      for (let y = 0; y < t; y++) {
        const p = i[y];
        (h[y] = p.read(s, f)), (f += p.byteSize);
      }
      return h;
    },
    byteSize: 4 + e,
    length: t,
    description: `Array<${r}>(${t})[ 4 + ${e} ]`,
  };
}
Jr.fixedSizeArray = m1;
function nC(i) {
  return {
    toFixedFromData(e, t) {
      const r = Uo.u32.read(e, t);
      (0, nS.logTrace)(`${this.description}[${r}]`);
      const s = t + 4;
      let n = s;
      const c = new Array(r);
      for (let f = 0; f < r; f++) {
        const h = (0, Lw.fixBeetFromData)(i, e, n);
        (c[f] = h), (n += h.byteSize);
      }
      return m1(c, n - s);
    },
    toFixedFromValue(e) {
      (0, vs.strict)(Array.isArray(e), `${e} should be an array`);
      let t = 0;
      const r = new Array(e.length);
      for (let s = 0; s < e.length; s++) {
        const n = (0, Lw.fixBeetFromValue)(i, e[s]);
        (r[s] = n), (t += n.byteSize);
      }
      return m1(r, t);
    },
    description: 'array',
  };
}
Jr.array = nC;
function oS(i) {
  return {
    write: function (e, t, r) {
      r.copy(e, t, 0, i);
    },
    read: function (e, t) {
      return e.slice(t, t + i);
    },
    byteSize: i,
    description: `Buffer(${i})`,
  };
}
Jr.fixedSizeBuffer = oS;
function w1(i, e = !1) {
  const t = oS(i),
    r = e ? i + 4 : i;
  return {
    write: function (s, n, c) {
      vs.strict.equal(c.byteLength, i, `Uint8Array length ${c.byteLength} should match len ${i}`),
        e && (Uo.u32.write(s, n, i), (n += 4));
      const f = Ze.from(c);
      t.write(s, n, f);
    },
    read: function (s, n) {
      if (e) {
        const f = Uo.u32.read(s, n);
        vs.strict.equal(f, i, 'invalid byte size'), (n += 4);
      }
      const c = t.read(s, n);
      return Uint8Array.from(c);
    },
    byteSize: r,
    description: `Uint8Array(${i})`,
  };
}
Jr.fixedSizeUint8Array = w1;
Jr.uint8Array = {
  toFixedFromData(i, e) {
    const t = Uo.u32.read(i, e);
    return (0, nS.logTrace)(`${this.description}[${t}]`), w1(t, !0);
  },
  toFixedFromValue(i) {
    const e = i.byteLength;
    return w1(e, !0);
  },
  description: 'Uint8Array',
};
Jr.collectionsTypeMap = {
  Array: {
    beet: 'array',
    isFixable: !0,
    sourcePack: Hs.BEET_PACKAGE,
    ts: 'Array',
    arg: js.BEET_TYPE_ARG_LEN,
  },
  FixedSizeArray: {
    beet: 'fixedSizeArray',
    isFixable: !1,
    sourcePack: Hs.BEET_PACKAGE,
    ts: 'Array',
    arg: js.BEET_TYPE_ARG_LEN,
  },
  UniformFixedSizeArray: {
    beet: 'uniformFixedSizeArray',
    isFixable: !1,
    sourcePack: Hs.BEET_PACKAGE,
    ts: 'Array',
    arg: js.BEET_TYPE_ARG_LEN,
  },
  Buffer: {
    beet: 'fixedSizeBuffer',
    isFixable: !1,
    sourcePack: Hs.BEET_PACKAGE,
    ts: 'Buffer',
    arg: js.BEET_TYPE_ARG_LEN,
  },
  FixedSizeUint8Array: {
    beet: 'fixedSizeUint8Array',
    isFixable: !1,
    sourcePack: Hs.BEET_PACKAGE,
    ts: 'Uint8Array',
    arg: js.BEET_TYPE_ARG_LEN,
  },
  Uint8Array: {
    beet: 'uint8Array',
    isFixable: !0,
    sourcePack: Hs.BEET_PACKAGE,
    ts: 'Uint8Array',
    arg: js.BEET_TYPE_ARG_LEN,
  },
};
var vi = {};
Object.defineProperty(vi, '__esModule', { value: !0 });
vi.compositesTypeMap =
  vi.coption =
  vi.coptionSome =
  vi.coptionNone =
  vi.isNoneBuffer =
  vi.isSomeBuffer =
    void 0;
const zu = Ui(),
  _1 = ir,
  Nw = ir,
  sS = kr,
  $w = Un,
  aS = 0,
  uS = 1;
function Jy(i, e) {
  return i[e] === uS;
}
vi.isSomeBuffer = Jy;
function Xy(i, e) {
  return i[e] === aS;
}
vi.isNoneBuffer = Xy;
function S1(i) {
  return (
    (0, sS.logTrace)(`coptionNone(${i})`),
    {
      write: function (e, t, r) {
        (0, zu.strict)(r == null, 'coptionNone can only handle `null` values'), (e[t] = aS);
      },
      read: function (e, t) {
        return (0, zu.strict)(Xy(e, t), 'coptionNone can only handle `NONE` data'), null;
      },
      byteSize: 1,
      description: `COption<None(${i})>`,
    }
  );
}
vi.coptionNone = S1;
function M1(i) {
  const e = 1 + i.byteSize,
    t = {
      write: function (r, s, n) {
        (0, _1.assertFixedSizeBeet)(
          i,
          `coption inner type ${i.description} needs to be fixed before calling write`
        ),
          (0, zu.strict)(n != null, 'coptionSome cannot handle `null` values'),
          (r[s] = uS),
          i.write(r, s + 1, n);
      },
      read: function (r, s) {
        return (
          (0, _1.assertFixedSizeBeet)(
            i,
            `coption inner type ${i.description} needs to be fixed before calling read`
          ),
          (0, zu.strict)(Jy(r, s), 'coptionSome can only handle `SOME` data'),
          i.read(r, s + 1)
        );
      },
      description: `COption<${i.description}>[1 + ${i.byteSize}]`,
      byteSize: e,
      inner: i,
    };
  return (0, sS.logTrace)(t.description), t;
}
vi.coptionSome = M1;
function oC(i) {
  return {
    toFixedFromData(e, t) {
      if (Jy(e, t)) {
        const r = (0, $w.fixBeetFromData)(i, e, t + 1);
        return M1(r);
      } else return (0, zu.strict)(Xy(e, t), `Expected ${e} to hold a COption`), S1(i.description);
    },
    toFixedFromValue(e) {
      return e == null ? S1(i.description) : M1((0, $w.fixBeetFromValue)(i, e));
    },
    description: `COption<${i.description}>`,
  };
}
vi.coption = oC;
vi.compositesTypeMap = {
  option: {
    beet: 'coption',
    isFixable: !0,
    sourcePack: Nw.BEET_PACKAGE,
    ts: 'COption<Inner>',
    arg: _1.BEET_TYPE_ARG_INNER,
    pack: Nw.BEET_PACKAGE,
  },
};
var A1 = {};
(function (i) {
  Object.defineProperty(i, '__esModule', { value: !0 }),
    (i.stringTypeMap = i.utf8String = i.fixedSizeUtf8String = void 0);
  const e = ir,
    t = Ui(),
    r = Do,
    s = kr,
    n = (c) => ({
      write: function (f, h, y) {
        const p = Ze.from(y, 'utf8');
        t.strict.equal(p.byteLength, c, `${y} has invalid byte size`),
          r.u32.write(f, h, c),
          p.copy(f, h + 4, 0, c);
      },
      read: function (f, h) {
        const y = r.u32.read(f, h);
        return (
          t.strict.equal(y, c, 'invalid byte size'), f.slice(h + 4, h + 4 + c).toString('utf8')
        );
      },
      elementByteSize: 1,
      length: c,
      lenPrefixByteSize: 4,
      byteSize: 4 + c,
      description: `Utf8String(4 + ${c})`,
    });
  (i.fixedSizeUtf8String = n),
    (i.utf8String = {
      toFixedFromData(c, f) {
        const h = r.u32.read(c, f);
        return (0, s.logTrace)(`${this.description}[${h}]`), (0, i.fixedSizeUtf8String)(h);
      },
      toFixedFromValue(c) {
        const f = Ze.from(c).byteLength;
        return (0, i.fixedSizeUtf8String)(f);
      },
      description: 'Utf8String',
    }),
    (i.stringTypeMap = {
      fixedSizeString: {
        beet: 'fixedSizeUtf8String',
        isFixable: !1,
        sourcePack: e.BEET_PACKAGE,
        ts: 'string',
        arg: e.BEET_TYPE_ARG_LEN,
      },
      string: { beet: 'utf8String', isFixable: !0, sourcePack: e.BEET_PACKAGE, ts: 'string' },
    });
})(A1);
var an = {},
  On = {},
  ms = {};
Object.defineProperty(ms, '__esModule', { value: !0 });
ms.BeetReader = ms.BeetWriter = void 0;
const sC = Ui();
class aC {
  constructor(e) {
    (this.buf = Ze.alloc(e)), (this._offset = 0);
  }
  get buffer() {
    return this.buf;
  }
  get offset() {
    return this._offset;
  }
  maybeResize(e) {
    this._offset + e > this.buf.length &&
      sC.strict.fail(
        `We shouldn't ever need to resize, but ${this._offset + e} > ${this.buf.length}`
      );
  }
  write(e, t) {
    this.maybeResize(e.byteSize), e.write(this.buf, this._offset, t), (this._offset += e.byteSize);
  }
  writeStruct(e, t) {
    for (const [r, s] of t) {
      const n = e[r];
      this.write(s, n);
    }
  }
}
ms.BeetWriter = aC;
class uC {
  constructor(e, t = 0) {
    (this.buffer = e), (this._offset = t);
  }
  get offset() {
    return this._offset;
  }
  read(e) {
    const t = e.read(this.buffer, this._offset);
    return (this._offset += e.byteSize), t;
  }
  readStruct(e) {
    const t = {};
    for (const [r, s] of e) t[r] = this.read(s);
    return t;
  }
}
ms.BeetReader = uC;
Object.defineProperty(On, '__esModule', { value: !0 });
On.BeetArgsStruct = On.isBeetStruct = On.BeetStruct = void 0;
const Dw = ms,
  Yn = kr;
class zo {
  constructor(e, t, r = zo.description) {
    if (
      ((this.fields = e),
      (this.construct = t),
      (this.description = r),
      (this.byteSize = this.getByteSize()),
      Yn.logDebug.enabled)
    ) {
      const s = e.map(([n, c]) => `${String(n)}: ${c.description} ${(0, Yn.beetBytes)(c)}`).join(`
  `);
      (0, Yn.logDebug)(`struct ${r} {
  ${s}
} ${(0, Yn.beetBytes)(this)}`);
    }
  }
  read(e, t) {
    const [r] = this.deserialize(e, t);
    return r;
  }
  write(e, t, r) {
    const [s, n] = this.serialize(r);
    s.copy(e, t, 0, n);
  }
  deserialize(e, t = 0) {
    Yn.logTrace.enabled &&
      ((0, Yn.logTrace)('deserializing [%s] from %d bytes buffer', this.description, e.byteLength),
      (0, Yn.logTrace)(e),
      (0, Yn.logTrace)(e.toJSON().data));
    const r = new Dw.BeetReader(e, t),
      s = r.readStruct(this.fields);
    return [this.construct(s), r.offset];
  }
  serialize(e, t = this.byteSize) {
    (0, Yn.logTrace)('serializing [%s] %o to %d bytes buffer', this.description, e, t);
    const r = new Dw.BeetWriter(t);
    return r.writeStruct(e, this.fields), [r.buffer, r.offset];
  }
  getByteSize() {
    return this.fields.reduce((e, [t, r]) => e + r.byteSize, 0);
  }
  get type() {
    return zo.TYPE;
  }
}
On.BeetStruct = zo;
zo.description = 'BeetStruct';
zo.TYPE = 'BeetStruct';
function cC(i) {
  return i.type === zo.TYPE;
}
On.isBeetStruct = cC;
class Ql extends zo {
  constructor(e, t = Ql.description) {
    super(e, (r) => r, t);
  }
}
On.BeetArgsStruct = Ql;
Ql.description = 'BeetArgsStruct';
var io = {},
  fC =
    (se && se.__importDefault) ||
    function (i) {
      return i && i.__esModule ? i : { default: i };
    };
Object.defineProperty(io, '__esModule', { value: !0 });
io.FixableBeetArgsStruct = io.isFixableBeetStruct = io.FixableBeetStruct = void 0;
const Uw = Un,
  sf = On,
  lC = ir,
  hC = Ui(),
  wp = kr,
  dC = fC(eS),
  { brightBlack: pC } = dC.default;
class xn {
  constructor(e, t, r = xn.description) {
    (this.fields = e), (this.construct = t), (this.description = r);
    let s = 0;
    if (wp.logDebug.enabled) {
      const n = e.map(
          ([f, h]) => (
            (0, lC.isFixedSizeBeet)(h) && (s += h.byteSize),
            `${f}: ${h.description} ${(0, wp.beetBytes)(h)}`
          )
        ).join(`
  `),
        c = `> ${s} B`;
      (0, wp.logDebug)(`struct ${r} {
  ${n}
} ${pC(c)}`);
    }
  }
  deserialize(e, t = 0) {
    return this.toFixedFromData(e, t).deserialize(e, t);
  }
  serialize(e, t) {
    return this.toFixedFromValue(e).serialize(e, t);
  }
  toFixedFromData(e, t) {
    let r = t;
    const s = new Array(this.fields.length);
    for (let n = 0; n < this.fields.length; n++) {
      const [c, f] = this.fields[n],
        h = (0, Uw.fixBeetFromData)(f, e, r);
      (s[n] = [c, h]), (r += h.byteSize);
    }
    return this.description !== xn.description
      ? new sf.BeetStruct(s, this.construct, this.description)
      : new sf.BeetStruct(s, this.construct);
  }
  toFixedFromValue(e) {
    const t = Object.keys(e),
      r = new Array(this.fields.length);
    for (let s = 0; s < this.fields.length; s++) {
      const [n, c] = this.fields[s];
      (0, hC.strict)(
        t.includes(n),
        `Value with keys [ ${t} ] should include struct key '${n}' but doesn't.`
      );
      const f = e[n],
        h = (0, Uw.fixBeetFromValue)(c, f);
      r[s] = [n, h];
    }
    return this.description !== xn.description
      ? new sf.BeetStruct(r, this.construct, this.description)
      : new sf.BeetStruct(r, this.construct);
  }
  get type() {
    return xn.TYPE;
  }
}
io.FixableBeetStruct = xn;
xn.description = 'FixableBeetStruct';
xn.TYPE = 'FixableBeetStruct';
function yC(i) {
  return i.type === xn.TYPE;
}
io.isFixableBeetStruct = yC;
class eh extends xn {
  constructor(e, t = eh.description) {
    super(e, (r) => r, t);
  }
}
io.FixableBeetArgsStruct = eh;
eh.description = 'FixableBeetArgsStruct';
var Fo = {};
Object.defineProperty(Fo, '__esModule', { value: !0 });
Fo.unitTypeMap = Fo.unit = void 0;
const gC = ir;
Fo.unit = {
  write: function (i, e, t) {},
  read: function (i, e) {},
  byteSize: 0,
  description: 'unit',
};
Fo.unitTypeMap = { unit: { beet: 'unit', isFixable: !1, sourcePack: gC.BEET_PACKAGE, ts: 'void' } };
Object.defineProperty(an, '__esModule', { value: !0 });
an.enumsTypeMap = an.dataEnum = an.uniformDataEnum = an.fixedScalarEnum = void 0;
const Ao = ir,
  un = Do,
  ia = Ui(),
  bC = On,
  vC = io,
  mC = Fo;
function zw(i, e) {
  return e ? `${i}` : i;
}
function wC(i) {
  const e = Object.keys(i);
  return {
    write(t, r, s) {
      const n = typeof s == 'number',
        c = zw(s, n);
      if (
        (e.includes(c) ||
          ia.strict.fail(
            `${s} should be a variant of the provided enum type, i.e. [ ${Object.values(i).join(', ')} ], but isn't`
          ),
        n)
      )
        un.u8.write(t, r, s);
      else {
        const f = i[c];
        un.u8.write(t, r, f);
      }
    },
    read(t, r) {
      const s = un.u8.read(t, r),
        n = typeof s == 'number',
        c = zw(s, n);
      return (
        e.includes(c) ||
          ia.strict.fail(
            `${s} should be a of a variant of the provided enum type, i.e. [ ${Object.values(i).join(', ')} ], but isn't`
          ),
        n ? s : i[c]
      );
    },
    byteSize: un.u8.byteSize,
    description: 'Enum',
  };
}
an.fixedScalarEnum = wC;
function _C(i) {
  return {
    write: function (e, t, r) {
      un.u8.write(e, t, r.kind), i.write(e, t + 1, r.data);
    },
    read: function (e, t) {
      const r = un.u8.read(e, t),
        s = i.read(e, t + 1);
      return { kind: r, data: s };
    },
    byteSize: 1 + i.byteSize,
    description: `UniformDataEnum<${i.description}>`,
  };
}
an.uniformDataEnum = _C;
function Fw(i, e, t) {
  return {
    write(r, s, n) {
      un.u8.write(r, s, e), i.write(r, s + un.u8.byteSize, n);
    },
    read(r, s) {
      const n = i.read(r, s + un.u8.byteSize);
      return { __kind: t, ...n };
    },
    byteSize: i.byteSize + un.u8.byteSize,
    description: `EnumData<${i.description}>`,
  };
}
function SC(i) {
  for (const [e, t] of i)
    (0, ia.strict)(
      (0, bC.isBeetStruct)(t) || (0, vC.isFixableBeetStruct)(t) || t === mC.unit,
      'dataEnum: variants must be a data beet struct or a scalar unit'
    );
  return {
    toFixedFromData(e, t) {
      const r = un.u8.read(e, t),
        s = i[r];
      (0, ia.strict)(s != null, `Discriminant ${r} out of range for ${i.length} variants`);
      const [n, c] = s,
        f = (0, Ao.isFixedSizeBeet)(c) ? c : c.toFixedFromData(e, t + 1);
      return Fw(f, r, n);
    },
    toFixedFromValue(e) {
      if (e.__kind == null) {
        const y = Object.keys(e).join(', '),
          p = i.map(([m]) => m).join(', ');
        ia.strict.fail(
          `Value with fields [ ${y} ] is missing __kind, which needs to be set to one of [ ${p} ]`
        );
      }
      const t = i.findIndex(([y]) => y === e.__kind);
      if (t < 0) {
        const y = i.map(([p]) => p).join(', ');
        ia.strict.fail(`${e.__kind} is not a valid kind, needs to be one of [ ${y} ]`);
      }
      const r = i[t],
        { __kind: s, ...n } = e,
        [c, f] = r,
        h = (0, Ao.isFixedSizeBeet)(f) ? f : f.toFixedFromValue(n);
      return Fw(h, t, c);
    },
    description: `DataEnum<${i.length} variants>`,
  };
}
an.dataEnum = SC;
an.enumsTypeMap = {
  fixedScalarEnum: {
    beet: 'fixedScalarEnum',
    isFixable: !1,
    sourcePack: Ao.BEET_PACKAGE,
    ts: '<TypeName>',
    arg: Ao.BEET_TYPE_ARG_INNER,
    pack: Ao.BEET_PACKAGE,
  },
  dataEnum: {
    beet: 'dataEnum',
    isFixable: !1,
    sourcePack: Ao.BEET_PACKAGE,
    ts: 'DataEnum<Kind, Inner>',
    arg: Ao.BEET_TYPE_ARG_INNER,
    pack: Ao.BEET_PACKAGE,
  },
};
var ws = {};
Object.defineProperty(ws, '__esModule', { value: !0 });
ws.aliasesTypeMap = ws.bytes = void 0;
const cS = Jr;
ws.bytes = cS.uint8Array;
ws.aliasesTypeMap = { bytes: cS.collectionsTypeMap.Uint8Array };
var no = {};
Object.defineProperty(no, '__esModule', { value: !0 });
no.tuplesTypeMap = no.tuple = no.fixedSizeTuple = void 0;
const qw = ir,
  E1 = Ui(),
  Ww = Un;
function k1(i) {
  const e = i.length,
    t = i.map((n) => n.description),
    r = i.map((n) => n.byteSize),
    s = r.reduce((n, c) => n + c, 0);
  return {
    write: function (n, c, f) {
      E1.strict.equal(f.length, e, `tuple value element size ${f.length} should match len ${e}`);
      let h = c;
      for (let y = 0; y < e; y++) {
        const p = f[y],
          m = i[y];
        m.write(n, h, p), (h += m.byteSize);
      }
    },
    read: function (n, c) {
      const f = [];
      let h = c;
      for (let y = 0; y < e; y++) {
        const p = i[y];
        (f[y] = p.read(n, h)), (h += p.byteSize);
      }
      return f;
    },
    byteSize: s,
    length: e,
    description: `FixedSizeTuple<${t.join(',')}>[ ${r.join(', ')} ]`,
  };
}
no.fixedSizeTuple = k1;
function MC(i) {
  const e = i.length,
    t = i.map((r) => r.description);
  return {
    toFixedFromData(r, s) {
      let n = s;
      const c = new Array(e);
      for (let f = 0; f < e; f++) {
        const h = (0, Ww.fixBeetFromData)(i[f], r, n);
        (c[f] = h), (n += h.byteSize);
      }
      return k1(c);
    },
    toFixedFromValue(r) {
      (0, E1.strict)(Array.isArray(r), `${r} should be an array of tuple values`),
        E1.strict.equal(
          r.length,
          e,
          `There should be ${e} tuple values, but there are ${r.length}`
        );
      const s = new Array(e);
      for (let n = 0; n < r.length; n++) {
        const c = (0, Ww.fixBeetFromValue)(i[n], r[n]);
        s[n] = c;
      }
      return k1(s);
    },
    description: `Tuple<${t.join(',')}>`,
  };
}
no.tuple = MC;
no.tuplesTypeMap = {
  Tuple: { beet: 'tuple', isFixable: !0, sourcePack: qw.BEET_PACKAGE, ts: '[__tuple_elements__]' },
  FixedSizeTuple: {
    beet: 'fixedSizeTuple',
    isFixable: !1,
    sourcePack: qw.BEET_PACKAGE,
    ts: '[__tuple_elements__]',
  },
};
var _s = {};
Object.defineProperty(_s, '__esModule', { value: !0 });
_s.mapsTypeMap = _s.map = void 0;
const Fu = ir,
  I1 = Do,
  AC = kr,
  _p = Ui();
function af(i, e, t, r) {
  const s = (0, Fu.isFixedSizeBeet)(i),
    n = (0, Fu.isFixedSizeBeet)(e);
  function c() {
    if (s && n) {
      const y = i.byteSize + e.byteSize;
      return { elementByteSize: y, byteSize: 4 + r * y };
    } else if (s) {
      let y = 0;
      for (const [m, _] of t.values()) y += _.byteSize;
      return { elementByteSize: i.byteSize + Math.ceil(y / r), byteSize: 4 + i.byteSize * r + y };
    } else if (n) {
      let y = 0;
      for (const [m, _] of t.values()) y += m.byteSize;
      return { elementByteSize: Math.ceil(y / r) + e.byteSize, byteSize: 4 + y + e.byteSize * r };
    } else {
      let y = 0,
        p = 0;
      for (const [_, A] of t.values()) (y += _.byteSize), (p += A.byteSize);
      return { elementByteSize: Math.ceil(y / r + p / r), byteSize: 4 + y + p };
    }
  }
  const { elementByteSize: f, byteSize: h } = c();
  return {
    write: function (y, p, m) {
      let _ = p + 4,
        A = 0;
      for (const [E, I] of m.entries()) {
        let R = s ? i : null,
          L = n ? e : null;
        if (R == null || L == null) {
          const D = t.get(E);
          (0, _p.strict)(
            D != null,
            `Should be able to find beet els for ${(0, AC.stringify)(E)}, but could not`
          ),
            R ?? (R = D[0]),
            L ?? (L = D[1]);
        }
        R.write(y, _, E), (_ += R.byteSize), L.write(y, _, I), (_ += L.byteSize), A++;
      }
      I1.u32.write(y, p, A), _p.strict.equal(A, r, `Expected map to have size ${r}, but has ${A}.`);
    },
    read: function (y, p) {
      const m = I1.u32.read(y, p);
      _p.strict.equal(m, r, `Expected map to have size ${r}, but has ${m}.`);
      let _ = p + 4;
      const A = new Map();
      for (let E = 0; E < m; E++) {
        const I = s ? i : i.toFixedFromData(y, _),
          R = I.read(y, _);
        _ += I.byteSize;
        const L = n ? e : e.toFixedFromData(y, _),
          D = L.read(y, _);
        (_ += L.byteSize), A.set(R, D);
      }
      return A;
    },
    elementByteSize: f,
    byteSize: h,
    length: r,
    lenPrefixByteSize: 4,
    description: `Map<${i.description}, ${e.description}>`,
  };
}
function EC(i, e) {
  const t = (0, Fu.isFixedSizeBeet)(i),
    r = (0, Fu.isFixedSizeBeet)(e);
  return {
    toFixedFromData(s, n) {
      const c = I1.u32.read(s, n);
      let f = n + 4;
      if (t && r) return af(i, e, new Map(), c);
      const h = new Map();
      for (let y = 0; y < c; y++) {
        const p = t ? i : i.toFixedFromData(s, f),
          m = p.read(s, f);
        f += p.byteSize;
        const _ = r ? e : e.toFixedFromData(s, f);
        (f += _.byteSize), h.set(m, [p, _]);
      }
      return af(i, e, h, c);
    },
    toFixedFromValue(s) {
      const n = s.size;
      if (t && r) return af(i, e, new Map(), n);
      const c = new Map();
      for (const [f, h] of s) {
        const y = t ? i : i.toFixedFromValue(f),
          p = r ? e : e.toFixedFromValue(h);
        c.set(f, [y, p]);
      }
      return af(i, e, c, n);
    },
    description: `FixableMap<${i.description}, ${e.description}>`,
  };
}
_s.map = EC;
_s.mapsTypeMap = { Map: { beet: 'map', isFixable: !0, sourcePack: Fu.BEET_PACKAGE, ts: 'Map' } };
var Ss = {};
Object.defineProperty(Ss, '__esModule', { value: !0 });
Ss.setsTypeMap = Ss.set = void 0;
const Qy = ir,
  x1 = Do,
  kC = kr,
  Sp = Ui();
function uf(i, e, t) {
  const r = (0, Qy.isFixedSizeBeet)(i);
  function s() {
    if (r) {
      const f = i.byteSize;
      return { elementByteSize: f, byteSize: 4 + t * f };
    } else {
      let f = 0;
      for (const y of e.values()) f += y.byteSize;
      return { elementByteSize: Math.ceil(f / t), byteSize: 4 + f };
    }
  }
  const { elementByteSize: n, byteSize: c } = s();
  return {
    write: function (f, h, y) {
      let p = h + 4,
        m = 0;
      for (const _ of y.keys()) {
        let A = r ? i : null;
        if (A == null) {
          const E = e.get(_);
          (0, Sp.strict)(
            E != null,
            `Should be able to find beet el for ${(0, kC.stringify)(_)}, but could not`
          ),
            A ?? (A = E);
        }
        A.write(f, p, _), (p += A.byteSize), m++;
      }
      x1.u32.write(f, h, m), Sp.strict.equal(m, t, `Expected set to have size ${t}, but has ${m}.`);
    },
    read: function (f, h) {
      const y = x1.u32.read(f, h);
      Sp.strict.equal(y, t, `Expected set to have size ${t}, but has ${y}.`);
      let p = h + 4;
      const m = new Set();
      for (let _ = 0; _ < y; _++) {
        const A = r ? i : i.toFixedFromData(f, p),
          E = A.read(f, p);
        (p += A.byteSize), m.add(E);
      }
      return m;
    },
    elementByteSize: n,
    byteSize: c,
    length: t,
    lenPrefixByteSize: 4,
    description: `Set<${i.description}>`,
  };
}
function IC(i) {
  const e = (0, Qy.isFixedSizeBeet)(i);
  return {
    toFixedFromData(t, r) {
      const s = x1.u32.read(t, r);
      let n = r + 4;
      if (e) return uf(i, new Map(), s);
      const c = new Map();
      for (let f = 0; f < s; f++) {
        const h = e ? i : i.toFixedFromData(t, n),
          y = h.read(t, n);
        (n += h.byteSize), c.set(y, h);
      }
      return uf(i, c, s);
    },
    toFixedFromValue(t) {
      const r = t.size;
      if (e) return uf(i, new Map(), r);
      const s = new Map();
      for (const n of t) {
        const c = e ? i : i.toFixedFromValue(n);
        s.set(n, c);
      }
      return uf(i, s, r);
    },
    description: `FixableSet<${i.description}>`,
  };
}
Ss.set = IC;
Ss.setsTypeMap = { Set: { beet: 'set', isFixable: !0, sourcePack: Qy.BEET_PACKAGE, ts: 'Set' } };
(function (i) {
  var e =
      (se && se.__createBinding) ||
      (Object.create
        ? function (A, E, I, R) {
            R === void 0 && (R = I);
            var L = Object.getOwnPropertyDescriptor(E, I);
            (!L || ('get' in L ? !E.__esModule : L.writable || L.configurable)) &&
              (L = {
                enumerable: !0,
                get: function () {
                  return E[I];
                },
              }),
              Object.defineProperty(A, R, L);
          }
        : function (A, E, I, R) {
            R === void 0 && (R = I), (A[R] = E[I]);
          }),
    t =
      (se && se.__exportStar) ||
      function (A, E) {
        for (var I in A)
          I !== 'default' && !Object.prototype.hasOwnProperty.call(E, I) && e(E, A, I);
      };
  Object.defineProperty(i, '__esModule', { value: !0 }), (i.supportedTypeMap = void 0);
  const r = Jr,
    s = vi,
    n = Do,
    c = A1,
    f = an,
    h = ws,
    y = no,
    p = _s,
    m = Fo,
    _ = Ss;
  t(ws, i),
    t(Jr, i),
    t(vi, i),
    t(an, i),
    t(_s, i),
    t(Do, i),
    t(Ss, i),
    t(A1, i),
    t(no, i),
    t(Fo, i),
    t(Un, i),
    t(ms, i),
    t(On, i),
    t(io, i),
    t(ir, i),
    (i.supportedTypeMap = {
      ...r.collectionsTypeMap,
      ...c.stringTypeMap,
      ...s.compositesTypeMap,
      ...f.enumsTypeMap,
      ...n.numbersTypeMap,
      ...h.aliasesTypeMap,
      ...y.tuplesTypeMap,
      ...p.mapsTypeMap,
      ..._.setsTypeMap,
      ...m.unitTypeMap,
    });
})(Jt);
var Cs = {},
  Ms = {};
function B1(i) {
  if (!Number.isSafeInteger(i) || i < 0) throw new Error(`Wrong positive integer: ${i}`);
}
function xC(i) {
  if (typeof i != 'boolean') throw new Error(`Expected boolean, not ${i}`);
}
function fS(i, ...e) {
  if (!(i instanceof Uint8Array)) throw new TypeError('Expected Uint8Array');
  if (e.length > 0 && !e.includes(i.length))
    throw new TypeError(`Expected Uint8Array of length ${e}, not of length=${i.length}`);
}
function BC(i) {
  if (typeof i != 'function' || typeof i.create != 'function')
    throw new Error('Hash should be wrapped by utils.wrapConstructor');
  B1(i.outputLen), B1(i.blockLen);
}
function RC(i, e = !0) {
  if (i.destroyed) throw new Error('Hash instance has been destroyed');
  if (e && i.finished) throw new Error('Hash#digest() has already been called');
}
function PC(i, e) {
  fS(i);
  const t = e.outputLen;
  if (i.length < t) throw new Error(`digestInto() expects output buffer of length at least ${t}`);
}
const Li = { number: B1, bool: xC, bytes: fS, hash: BC, exists: RC, output: PC };
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const TC = (i) =>
    new Uint32Array(i.buffer, i.byteOffset, Math.floor(i.byteLength / 4)),
  Mp = (i) => new DataView(i.buffer, i.byteOffset, i.byteLength),
  vn = (i, e) => (i << (32 - e)) | (i >>> e),
  OC = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!OC) throw new Error('Non little-endian hardware is not supported');
Array.from({ length: 256 }, (i, e) => e.toString(16).padStart(2, '0'));
function CC(i) {
  if (typeof i != 'string') throw new TypeError(`utf8ToBytes expected string, got ${typeof i}`);
  return new TextEncoder().encode(i);
}
function fc(i) {
  if ((typeof i == 'string' && (i = CC(i)), !(i instanceof Uint8Array)))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof i})`);
  return i;
}
class eg {
  clone() {
    return this._cloneInto();
  }
}
function Ls(i) {
  const e = (r) => i().update(fc(r)).digest(),
    t = i();
  return (e.outputLen = t.outputLen), (e.blockLen = t.blockLen), (e.create = () => i()), e;
}
function LC(i) {
  const e = (r, s) => i(s).update(fc(r)).digest(),
    t = i({});
  return (e.outputLen = t.outputLen), (e.blockLen = t.blockLen), (e.create = (r) => i(r)), e;
}
function NC(i, e, t, r) {
  if (typeof i.setBigUint64 == 'function') return i.setBigUint64(e, t, r);
  const s = BigInt(32),
    n = BigInt(4294967295),
    c = Number((t >> s) & n),
    f = Number(t & n),
    h = r ? 4 : 0,
    y = r ? 0 : 4;
  i.setUint32(e + h, c, r), i.setUint32(e + y, f, r);
}
class lS extends eg {
  constructor(e, t, r, s) {
    super(),
      (this.blockLen = e),
      (this.outputLen = t),
      (this.padOffset = r),
      (this.isLE = s),
      (this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.buffer = new Uint8Array(e)),
      (this.view = Mp(this.buffer));
  }
  update(e) {
    Li.exists(this);
    const { view: t, buffer: r, blockLen: s } = this;
    e = fc(e);
    const n = e.length;
    for (let c = 0; c < n; ) {
      const f = Math.min(s - this.pos, n - c);
      if (f === s) {
        const h = Mp(e);
        for (; s <= n - c; c += s) this.process(h, c);
        continue;
      }
      r.set(e.subarray(c, c + f), this.pos),
        (this.pos += f),
        (c += f),
        this.pos === s && (this.process(t, 0), (this.pos = 0));
    }
    return (this.length += e.length), this.roundClean(), this;
  }
  digestInto(e) {
    Li.exists(this), Li.output(e, this), (this.finished = !0);
    const { buffer: t, view: r, blockLen: s, isLE: n } = this;
    let { pos: c } = this;
    (t[c++] = 128),
      this.buffer.subarray(c).fill(0),
      this.padOffset > s - c && (this.process(r, 0), (c = 0));
    for (let m = c; m < s; m++) t[m] = 0;
    NC(r, s - 8, BigInt(this.length * 8), n), this.process(r, 0);
    const f = Mp(e),
      h = this.outputLen;
    if (h % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
    const y = h / 4,
      p = this.get();
    if (y > p.length) throw new Error('_sha2: outputLen bigger than state');
    for (let m = 0; m < y; m++) f.setUint32(4 * m, p[m], n);
  }
  digest() {
    const { buffer: e, outputLen: t } = this;
    this.digestInto(e);
    const r = e.slice(0, t);
    return this.destroy(), r;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: t, buffer: r, length: s, finished: n, destroyed: c, pos: f } = this;
    return (
      (e.length = s), (e.pos = f), (e.finished = n), (e.destroyed = c), s % t && e.buffer.set(r), e
    );
  }
}
const cf = BigInt(2 ** 32 - 1),
  R1 = BigInt(32);
function hS(i, e = !1) {
  return e
    ? { h: Number(i & cf), l: Number((i >> R1) & cf) }
    : { h: Number((i >> R1) & cf) | 0, l: Number(i & cf) | 0 };
}
function $C(i, e = !1) {
  let t = new Uint32Array(i.length),
    r = new Uint32Array(i.length);
  for (let s = 0; s < i.length; s++) {
    const { h: n, l: c } = hS(i[s], e);
    [t[s], r[s]] = [n, c];
  }
  return [t, r];
}
const DC = (i, e) => (BigInt(i >>> 0) << R1) | BigInt(e >>> 0),
  UC = (i, e, t) => i >>> t,
  zC = (i, e, t) => (i << (32 - t)) | (e >>> t),
  FC = (i, e, t) => (i >>> t) | (e << (32 - t)),
  qC = (i, e, t) => (i << (32 - t)) | (e >>> t),
  WC = (i, e, t) => (i << (64 - t)) | (e >>> (t - 32)),
  KC = (i, e, t) => (i >>> (t - 32)) | (e << (64 - t)),
  jC = (i, e) => e,
  HC = (i, e) => i,
  VC = (i, e, t) => (i << t) | (e >>> (32 - t)),
  GC = (i, e, t) => (e << t) | (i >>> (32 - t)),
  YC = (i, e, t) => (e << (t - 32)) | (i >>> (64 - t)),
  ZC = (i, e, t) => (i << (t - 32)) | (e >>> (64 - t));
function JC(i, e, t, r) {
  const s = (e >>> 0) + (r >>> 0);
  return { h: (i + t + ((s / 2 ** 32) | 0)) | 0, l: s | 0 };
}
const XC = (i, e, t) => (i >>> 0) + (e >>> 0) + (t >>> 0),
  QC = (i, e, t, r) => (e + t + r + ((i / 2 ** 32) | 0)) | 0,
  eL = (i, e, t, r) => (i >>> 0) + (e >>> 0) + (t >>> 0) + (r >>> 0),
  tL = (i, e, t, r, s) => (e + t + r + s + ((i / 2 ** 32) | 0)) | 0,
  rL = (i, e, t, r, s) => (i >>> 0) + (e >>> 0) + (t >>> 0) + (r >>> 0) + (s >>> 0),
  iL = (i, e, t, r, s, n) => (e + t + r + s + n + ((i / 2 ** 32) | 0)) | 0,
  ht = {
    fromBig: hS,
    split: $C,
    toBig: DC,
    shrSH: UC,
    shrSL: zC,
    rotrSH: FC,
    rotrSL: qC,
    rotrBH: WC,
    rotrBL: KC,
    rotr32H: jC,
    rotr32L: HC,
    rotlSH: VC,
    rotlSL: GC,
    rotlBH: YC,
    rotlBL: ZC,
    add: JC,
    add3L: XC,
    add3H: QC,
    add4L: eL,
    add4H: tL,
    add5H: iL,
    add5L: rL,
  },
  [nL, oL] = ht.split(
    [
      '0x428a2f98d728ae22',
      '0x7137449123ef65cd',
      '0xb5c0fbcfec4d3b2f',
      '0xe9b5dba58189dbbc',
      '0x3956c25bf348b538',
      '0x59f111f1b605d019',
      '0x923f82a4af194f9b',
      '0xab1c5ed5da6d8118',
      '0xd807aa98a3030242',
      '0x12835b0145706fbe',
      '0x243185be4ee4b28c',
      '0x550c7dc3d5ffb4e2',
      '0x72be5d74f27b896f',
      '0x80deb1fe3b1696b1',
      '0x9bdc06a725c71235',
      '0xc19bf174cf692694',
      '0xe49b69c19ef14ad2',
      '0xefbe4786384f25e3',
      '0x0fc19dc68b8cd5b5',
      '0x240ca1cc77ac9c65',
      '0x2de92c6f592b0275',
      '0x4a7484aa6ea6e483',
      '0x5cb0a9dcbd41fbd4',
      '0x76f988da831153b5',
      '0x983e5152ee66dfab',
      '0xa831c66d2db43210',
      '0xb00327c898fb213f',
      '0xbf597fc7beef0ee4',
      '0xc6e00bf33da88fc2',
      '0xd5a79147930aa725',
      '0x06ca6351e003826f',
      '0x142929670a0e6e70',
      '0x27b70a8546d22ffc',
      '0x2e1b21385c26c926',
      '0x4d2c6dfc5ac42aed',
      '0x53380d139d95b3df',
      '0x650a73548baf63de',
      '0x766a0abb3c77b2a8',
      '0x81c2c92e47edaee6',
      '0x92722c851482353b',
      '0xa2bfe8a14cf10364',
      '0xa81a664bbc423001',
      '0xc24b8b70d0f89791',
      '0xc76c51a30654be30',
      '0xd192e819d6ef5218',
      '0xd69906245565a910',
      '0xf40e35855771202a',
      '0x106aa07032bbd1b8',
      '0x19a4c116b8d2d0c8',
      '0x1e376c085141ab53',
      '0x2748774cdf8eeb99',
      '0x34b0bcb5e19b48a8',
      '0x391c0cb3c5c95a63',
      '0x4ed8aa4ae3418acb',
      '0x5b9cca4f7763e373',
      '0x682e6ff3d6b2b8a3',
      '0x748f82ee5defb2fc',
      '0x78a5636f43172f60',
      '0x84c87814a1f0ab72',
      '0x8cc702081a6439ec',
      '0x90befffa23631e28',
      '0xa4506cebde82bde9',
      '0xbef9a3f7b2c67915',
      '0xc67178f2e372532b',
      '0xca273eceea26619c',
      '0xd186b8c721c0c207',
      '0xeada7dd6cde0eb1e',
      '0xf57d4f7fee6ed178',
      '0x06f067aa72176fba',
      '0x0a637dc5a2c898a6',
      '0x113f9804bef90dae',
      '0x1b710b35131c471b',
      '0x28db77f523047d84',
      '0x32caab7b40c72493',
      '0x3c9ebe0a15c9bebc',
      '0x431d67c49c100d4c',
      '0x4cc5d4becb3e42b6',
      '0x597f299cfc657e2a',
      '0x5fcb6fab3ad6faec',
      '0x6c44198c4a475817',
    ].map((i) => BigInt(i))
  ),
  bo = new Uint32Array(80),
  vo = new Uint32Array(80);
class th extends lS {
  constructor() {
    super(128, 64, 16, !1),
      (this.Ah = 1779033703),
      (this.Al = -205731576),
      (this.Bh = -1150833019),
      (this.Bl = -2067093701),
      (this.Ch = 1013904242),
      (this.Cl = -23791573),
      (this.Dh = -1521486534),
      (this.Dl = 1595750129),
      (this.Eh = 1359893119),
      (this.El = -1377402159),
      (this.Fh = -1694144372),
      (this.Fl = 725511199),
      (this.Gh = 528734635),
      (this.Gl = -79577749),
      (this.Hh = 1541459225),
      (this.Hl = 327033209);
  }
  get() {
    const {
      Ah: e,
      Al: t,
      Bh: r,
      Bl: s,
      Ch: n,
      Cl: c,
      Dh: f,
      Dl: h,
      Eh: y,
      El: p,
      Fh: m,
      Fl: _,
      Gh: A,
      Gl: E,
      Hh: I,
      Hl: R,
    } = this;
    return [e, t, r, s, n, c, f, h, y, p, m, _, A, E, I, R];
  }
  set(e, t, r, s, n, c, f, h, y, p, m, _, A, E, I, R) {
    (this.Ah = e | 0),
      (this.Al = t | 0),
      (this.Bh = r | 0),
      (this.Bl = s | 0),
      (this.Ch = n | 0),
      (this.Cl = c | 0),
      (this.Dh = f | 0),
      (this.Dl = h | 0),
      (this.Eh = y | 0),
      (this.El = p | 0),
      (this.Fh = m | 0),
      (this.Fl = _ | 0),
      (this.Gh = A | 0),
      (this.Gl = E | 0),
      (this.Hh = I | 0),
      (this.Hl = R | 0);
  }
  process(e, t) {
    for (let q = 0; q < 16; q++, t += 4) (bo[q] = e.getUint32(t)), (vo[q] = e.getUint32((t += 4)));
    for (let q = 16; q < 80; q++) {
      const H = bo[q - 15] | 0,
        V = vo[q - 15] | 0,
        te = ht.rotrSH(H, V, 1) ^ ht.rotrSH(H, V, 8) ^ ht.shrSH(H, V, 7),
        ue = ht.rotrSL(H, V, 1) ^ ht.rotrSL(H, V, 8) ^ ht.shrSL(H, V, 7),
        ne = bo[q - 2] | 0,
        X = vo[q - 2] | 0,
        Oe = ht.rotrSH(ne, X, 19) ^ ht.rotrBH(ne, X, 61) ^ ht.shrSH(ne, X, 6),
        S = ht.rotrSL(ne, X, 19) ^ ht.rotrBL(ne, X, 61) ^ ht.shrSL(ne, X, 6),
        o = ht.add4L(ue, S, vo[q - 7], vo[q - 16]),
        u = ht.add4H(o, te, Oe, bo[q - 7], bo[q - 16]);
      (bo[q] = u | 0), (vo[q] = o | 0);
    }
    let {
      Ah: r,
      Al: s,
      Bh: n,
      Bl: c,
      Ch: f,
      Cl: h,
      Dh: y,
      Dl: p,
      Eh: m,
      El: _,
      Fh: A,
      Fl: E,
      Gh: I,
      Gl: R,
      Hh: L,
      Hl: D,
    } = this;
    for (let q = 0; q < 80; q++) {
      const H = ht.rotrSH(m, _, 14) ^ ht.rotrSH(m, _, 18) ^ ht.rotrBH(m, _, 41),
        V = ht.rotrSL(m, _, 14) ^ ht.rotrSL(m, _, 18) ^ ht.rotrBL(m, _, 41),
        te = (m & A) ^ (~m & I),
        ue = (_ & E) ^ (~_ & R),
        ne = ht.add5L(D, V, ue, oL[q], vo[q]),
        X = ht.add5H(ne, L, H, te, nL[q], bo[q]),
        Oe = ne | 0,
        S = ht.rotrSH(r, s, 28) ^ ht.rotrBH(r, s, 34) ^ ht.rotrBH(r, s, 39),
        o = ht.rotrSL(r, s, 28) ^ ht.rotrBL(r, s, 34) ^ ht.rotrBL(r, s, 39),
        u = (r & n) ^ (r & f) ^ (n & f),
        l = (s & c) ^ (s & h) ^ (c & h);
      (L = I | 0),
        (D = R | 0),
        (I = A | 0),
        (R = E | 0),
        (A = m | 0),
        (E = _ | 0),
        ({ h: m, l: _ } = ht.add(y | 0, p | 0, X | 0, Oe | 0)),
        (y = f | 0),
        (p = h | 0),
        (f = n | 0),
        (h = c | 0),
        (n = r | 0),
        (c = s | 0);
      const d = ht.add3L(Oe, o, l);
      (r = ht.add3H(d, X, S, u)), (s = d | 0);
    }
    ({ h: r, l: s } = ht.add(this.Ah | 0, this.Al | 0, r | 0, s | 0)),
      ({ h: n, l: c } = ht.add(this.Bh | 0, this.Bl | 0, n | 0, c | 0)),
      ({ h: f, l: h } = ht.add(this.Ch | 0, this.Cl | 0, f | 0, h | 0)),
      ({ h: y, l: p } = ht.add(this.Dh | 0, this.Dl | 0, y | 0, p | 0)),
      ({ h: m, l: _ } = ht.add(this.Eh | 0, this.El | 0, m | 0, _ | 0)),
      ({ h: A, l: E } = ht.add(this.Fh | 0, this.Fl | 0, A | 0, E | 0)),
      ({ h: I, l: R } = ht.add(this.Gh | 0, this.Gl | 0, I | 0, R | 0)),
      ({ h: L, l: D } = ht.add(this.Hh | 0, this.Hl | 0, L | 0, D | 0)),
      this.set(r, s, n, c, f, h, y, p, m, _, A, E, I, R, L, D);
  }
  roundClean() {
    bo.fill(0), vo.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
class sL extends th {
  constructor() {
    super(),
      (this.Ah = -1942145080),
      (this.Al = 424955298),
      (this.Bh = 1944164710),
      (this.Bl = -1982016298),
      (this.Ch = 502970286),
      (this.Cl = 855612546),
      (this.Dh = 1738396948),
      (this.Dl = 1479516111),
      (this.Eh = 258812777),
      (this.El = 2077511080),
      (this.Fh = 2011393907),
      (this.Fl = 79989058),
      (this.Gh = 1067287976),
      (this.Gl = 1780299464),
      (this.Hh = 286451373),
      (this.Hl = -1848208735),
      (this.outputLen = 28);
  }
}
class aL extends th {
  constructor() {
    super(),
      (this.Ah = 573645204),
      (this.Al = -64227540),
      (this.Bh = -1621794909),
      (this.Bl = -934517566),
      (this.Ch = 596883563),
      (this.Cl = 1867755857),
      (this.Dh = -1774684391),
      (this.Dl = 1497426621),
      (this.Eh = -1775747358),
      (this.El = -1467023389),
      (this.Fh = -1101128155),
      (this.Fl = 1401305490),
      (this.Gh = 721525244),
      (this.Gl = 746961066),
      (this.Hh = 246885852),
      (this.Hl = -2117784414),
      (this.outputLen = 32);
  }
}
class uL extends th {
  constructor() {
    super(),
      (this.Ah = -876896931),
      (this.Al = -1056596264),
      (this.Bh = 1654270250),
      (this.Bl = 914150663),
      (this.Ch = -1856437926),
      (this.Cl = 812702999),
      (this.Dh = 355462360),
      (this.Dl = -150054599),
      (this.Eh = 1731405415),
      (this.El = -4191439),
      (this.Fh = -1900787065),
      (this.Fl = 1750603025),
      (this.Gh = -619958771),
      (this.Gl = 1694076839),
      (this.Hh = 1203062813),
      (this.Hl = -1090891868),
      (this.outputLen = 48);
  }
}
const cL = Ls(() => new th());
Ls(() => new sL());
Ls(() => new aL());
Ls(() => new uL());
var fL = Oy,
  lL = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz',
  hL = fL(lL);
const ii = zn(hL),
  dL = (i, e, t) => (i & e) ^ (~i & t),
  pL = (i, e, t) => (i & e) ^ (i & t) ^ (e & t),
  yL = new Uint32Array([
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221,
    3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580,
    3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895,
    666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037,
    2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
    1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298,
  ]),
  mo = new Uint32Array([
    1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225,
  ]),
  wo = new Uint32Array(64);
class dS extends lS {
  constructor() {
    super(64, 32, 8, !1),
      (this.A = mo[0] | 0),
      (this.B = mo[1] | 0),
      (this.C = mo[2] | 0),
      (this.D = mo[3] | 0),
      (this.E = mo[4] | 0),
      (this.F = mo[5] | 0),
      (this.G = mo[6] | 0),
      (this.H = mo[7] | 0);
  }
  get() {
    const { A: e, B: t, C: r, D: s, E: n, F: c, G: f, H: h } = this;
    return [e, t, r, s, n, c, f, h];
  }
  set(e, t, r, s, n, c, f, h) {
    (this.A = e | 0),
      (this.B = t | 0),
      (this.C = r | 0),
      (this.D = s | 0),
      (this.E = n | 0),
      (this.F = c | 0),
      (this.G = f | 0),
      (this.H = h | 0);
  }
  process(e, t) {
    for (let m = 0; m < 16; m++, t += 4) wo[m] = e.getUint32(t, !1);
    for (let m = 16; m < 64; m++) {
      const _ = wo[m - 15],
        A = wo[m - 2],
        E = vn(_, 7) ^ vn(_, 18) ^ (_ >>> 3),
        I = vn(A, 17) ^ vn(A, 19) ^ (A >>> 10);
      wo[m] = (I + wo[m - 7] + E + wo[m - 16]) | 0;
    }
    let { A: r, B: s, C: n, D: c, E: f, F: h, G: y, H: p } = this;
    for (let m = 0; m < 64; m++) {
      const _ = vn(f, 6) ^ vn(f, 11) ^ vn(f, 25),
        A = (p + _ + dL(f, h, y) + yL[m] + wo[m]) | 0,
        I = ((vn(r, 2) ^ vn(r, 13) ^ vn(r, 22)) + pL(r, s, n)) | 0;
      (p = y), (y = h), (h = f), (f = (c + A) | 0), (c = n), (n = s), (s = r), (r = (A + I) | 0);
    }
    (r = (r + this.A) | 0),
      (s = (s + this.B) | 0),
      (n = (n + this.C) | 0),
      (c = (c + this.D) | 0),
      (f = (f + this.E) | 0),
      (h = (h + this.F) | 0),
      (y = (y + this.G) | 0),
      (p = (p + this.H) | 0),
      this.set(r, s, n, c, f, h, y, p);
  }
  roundClean() {
    wo.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
class gL extends dS {
  constructor() {
    super(),
      (this.A = -1056596264),
      (this.B = 914150663),
      (this.C = 812702999),
      (this.D = -150054599),
      (this.E = -4191439),
      (this.F = 1750603025),
      (this.G = 1694076839),
      (this.H = -1090891868),
      (this.outputLen = 28);
  }
}
const P1 = Ls(() => new dS());
Ls(() => new gL());
var ti = {},
  bL = Oy,
  vL = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz',
  mL = bL(vL),
  wL =
    (se && se.__createBinding) ||
    (Object.create
      ? function (i, e, t, r) {
          r === void 0 && (r = t),
            Object.defineProperty(i, r, {
              enumerable: !0,
              get: function () {
                return e[t];
              },
            });
        }
      : function (i, e, t, r) {
          r === void 0 && (r = t), (i[r] = e[t]);
        }),
  _L =
    (se && se.__setModuleDefault) ||
    (Object.create
      ? function (i, e) {
          Object.defineProperty(i, 'default', { enumerable: !0, value: e });
        }
      : function (i, e) {
          i.default = e;
        }),
  Vn =
    (se && se.__decorate) ||
    function (i, e, t, r) {
      var s = arguments.length,
        n = s < 3 ? e : r === null ? (r = Object.getOwnPropertyDescriptor(e, t)) : r,
        c;
      if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function')
        n = Reflect.decorate(i, e, t, r);
      else
        for (var f = i.length - 1; f >= 0; f--)
          (c = i[f]) && (n = (s < 3 ? c(n) : s > 3 ? c(e, t, n) : c(e, t)) || n);
      return s > 3 && n && Object.defineProperty(e, t, n), n;
    },
  SL =
    (se && se.__importStar) ||
    function (i) {
      if (i && i.__esModule) return i;
      var e = {};
      if (i != null)
        for (var t in i) t !== 'default' && Object.hasOwnProperty.call(i, t) && wL(e, i, t);
      return _L(e, i), e;
    },
  pS =
    (se && se.__importDefault) ||
    function (i) {
      return i && i.__esModule ? i : { default: i };
    };
Object.defineProperty(ti, '__esModule', { value: !0 });
var yS =
  (ti.deserializeUnchecked =
  _S =
  ti.deserialize =
  wS =
  ti.serialize =
  ti.BinaryReader =
  ti.BinaryWriter =
  ti.BorshError =
  ti.baseDecode =
  ti.baseEncode =
    void 0);
const Ro = pS(Ko()),
  gS = pS(mL),
  ML = SL(A3),
  AL = typeof TextDecoder != 'function' ? ML.TextDecoder : TextDecoder,
  EL = new AL('utf-8', { fatal: !0 });
function kL(i) {
  return typeof i == 'string' && (i = Ze.from(i, 'utf8')), gS.default.encode(Ze.from(i));
}
ti.baseEncode = kL;
function IL(i) {
  return Ze.from(gS.default.decode(i));
}
ti.baseDecode = IL;
const Ap = 1024;
class wi extends Error {
  constructor(e) {
    super(e), (this.fieldPath = []), (this.originalMessage = e);
  }
  addToFieldPath(e) {
    this.fieldPath.splice(0, 0, e),
      (this.message = this.originalMessage + ': ' + this.fieldPath.join('.'));
  }
}
ti.BorshError = wi;
class bS {
  constructor() {
    (this.buf = Ze.alloc(Ap)), (this.length = 0);
  }
  maybeResize() {
    this.buf.length < 16 + this.length && (this.buf = Ze.concat([this.buf, Ze.alloc(Ap)]));
  }
  writeU8(e) {
    this.maybeResize(), this.buf.writeUInt8(e, this.length), (this.length += 1);
  }
  writeU16(e) {
    this.maybeResize(), this.buf.writeUInt16LE(e, this.length), (this.length += 2);
  }
  writeU32(e) {
    this.maybeResize(), this.buf.writeUInt32LE(e, this.length), (this.length += 4);
  }
  writeU64(e) {
    this.maybeResize(), this.writeBuffer(Ze.from(new Ro.default(e).toArray('le', 8)));
  }
  writeU128(e) {
    this.maybeResize(), this.writeBuffer(Ze.from(new Ro.default(e).toArray('le', 16)));
  }
  writeU256(e) {
    this.maybeResize(), this.writeBuffer(Ze.from(new Ro.default(e).toArray('le', 32)));
  }
  writeU512(e) {
    this.maybeResize(), this.writeBuffer(Ze.from(new Ro.default(e).toArray('le', 64)));
  }
  writeBuffer(e) {
    (this.buf = Ze.concat([Ze.from(this.buf.subarray(0, this.length)), e, Ze.alloc(Ap)])),
      (this.length += e.length);
  }
  writeString(e) {
    this.maybeResize();
    const t = Ze.from(e, 'utf8');
    this.writeU32(t.length), this.writeBuffer(t);
  }
  writeFixedArray(e) {
    this.writeBuffer(Ze.from(e));
  }
  writeArray(e, t) {
    this.maybeResize(), this.writeU32(e.length);
    for (const r of e) this.maybeResize(), t(r);
  }
  toArray() {
    return this.buf.subarray(0, this.length);
  }
}
ti.BinaryWriter = bS;
function Gn(i, e, t) {
  const r = t.value;
  t.value = function (...s) {
    try {
      return r.apply(this, s);
    } catch (n) {
      if (n instanceof RangeError) {
        const c = n.code;
        if (['ERR_BUFFER_OUT_OF_BOUNDS', 'ERR_OUT_OF_RANGE'].indexOf(c) >= 0)
          throw new wi('Reached the end of buffer when deserializing');
      }
      throw n;
    }
  };
}
class Fi {
  constructor(e) {
    (this.buf = e), (this.offset = 0);
  }
  readU8() {
    const e = this.buf.readUInt8(this.offset);
    return (this.offset += 1), e;
  }
  readU16() {
    const e = this.buf.readUInt16LE(this.offset);
    return (this.offset += 2), e;
  }
  readU32() {
    const e = this.buf.readUInt32LE(this.offset);
    return (this.offset += 4), e;
  }
  readU64() {
    const e = this.readBuffer(8);
    return new Ro.default(e, 'le');
  }
  readU128() {
    const e = this.readBuffer(16);
    return new Ro.default(e, 'le');
  }
  readU256() {
    const e = this.readBuffer(32);
    return new Ro.default(e, 'le');
  }
  readU512() {
    const e = this.readBuffer(64);
    return new Ro.default(e, 'le');
  }
  readBuffer(e) {
    if (this.offset + e > this.buf.length)
      throw new wi(`Expected buffer length ${e} isn't within bounds`);
    const t = this.buf.slice(this.offset, this.offset + e);
    return (this.offset += e), t;
  }
  readString() {
    const e = this.readU32(),
      t = this.readBuffer(e);
    try {
      return EL.decode(t);
    } catch (r) {
      throw new wi(`Error decoding UTF-8 string: ${r}`);
    }
  }
  readFixedArray(e) {
    return new Uint8Array(this.readBuffer(e));
  }
  readArray(e) {
    const t = this.readU32(),
      r = Array();
    for (let s = 0; s < t; ++s) r.push(e());
    return r;
  }
}
Vn([Gn], Fi.prototype, 'readU8', null);
Vn([Gn], Fi.prototype, 'readU16', null);
Vn([Gn], Fi.prototype, 'readU32', null);
Vn([Gn], Fi.prototype, 'readU64', null);
Vn([Gn], Fi.prototype, 'readU128', null);
Vn([Gn], Fi.prototype, 'readU256', null);
Vn([Gn], Fi.prototype, 'readU512', null);
Vn([Gn], Fi.prototype, 'readString', null);
Vn([Gn], Fi.prototype, 'readFixedArray', null);
Vn([Gn], Fi.prototype, 'readArray', null);
ti.BinaryReader = Fi;
function vS(i) {
  return i.charAt(0).toUpperCase() + i.slice(1);
}
function Qo(i, e, t, r, s) {
  try {
    if (typeof r == 'string') s[`write${vS(r)}`](t);
    else if (r instanceof Array)
      if (typeof r[0] == 'number') {
        if (t.length !== r[0])
          throw new wi(`Expecting byte array of length ${r[0]}, but got ${t.length} bytes`);
        s.writeFixedArray(t);
      } else if (r.length === 2 && typeof r[1] == 'number') {
        if (t.length !== r[1])
          throw new wi(`Expecting byte array of length ${r[1]}, but got ${t.length} bytes`);
        for (let n = 0; n < r[1]; n++) Qo(i, null, t[n], r[0], s);
      } else
        s.writeArray(t, (n) => {
          Qo(i, e, n, r[0], s);
        });
    else if (r.kind !== void 0)
      switch (r.kind) {
        case 'option': {
          t == null ? s.writeU8(0) : (s.writeU8(1), Qo(i, e, t, r.type, s));
          break;
        }
        case 'map': {
          s.writeU32(t.size),
            t.forEach((n, c) => {
              Qo(i, e, c, r.key, s), Qo(i, e, n, r.value, s);
            });
          break;
        }
        default:
          throw new wi(`FieldType ${r} unrecognized`);
      }
    else mS(i, t, s);
  } catch (n) {
    throw (n instanceof wi && n.addToFieldPath(e), n);
  }
}
function mS(i, e, t) {
  if (typeof e.borshSerialize == 'function') {
    e.borshSerialize(t);
    return;
  }
  const r = i.get(e.constructor);
  if (!r) throw new wi(`Class ${e.constructor.name} is missing in schema`);
  if (r.kind === 'struct')
    r.fields.map(([s, n]) => {
      Qo(i, s, e[s], n, t);
    });
  else if (r.kind === 'enum') {
    const s = e[r.field];
    for (let n = 0; n < r.values.length; ++n) {
      const [c, f] = r.values[n];
      if (c === s) {
        t.writeU8(n), Qo(i, c, e[c], f, t);
        break;
      }
    }
  } else throw new wi(`Unexpected schema kind: ${r.kind} for ${e.constructor.name}`);
}
function xL(i, e, t = bS) {
  const r = new t();
  return mS(i, e, r), r.toArray();
}
var wS = (ti.serialize = xL);
function es(i, e, t, r) {
  try {
    if (typeof t == 'string') return r[`read${vS(t)}`]();
    if (t instanceof Array) {
      if (typeof t[0] == 'number') return r.readFixedArray(t[0]);
      if (typeof t[1] == 'number') {
        const s = [];
        for (let n = 0; n < t[1]; n++) s.push(es(i, null, t[0], r));
        return s;
      } else return r.readArray(() => es(i, e, t[0], r));
    }
    if (t.kind === 'option') return r.readU8() ? es(i, e, t.type, r) : void 0;
    if (t.kind === 'map') {
      let s = new Map();
      const n = r.readU32();
      for (let c = 0; c < n; c++) {
        const f = es(i, e, t.key, r),
          h = es(i, e, t.value, r);
        s.set(f, h);
      }
      return s;
    }
    return tg(i, t, r);
  } catch (s) {
    throw (s instanceof wi && s.addToFieldPath(e), s);
  }
}
function tg(i, e, t) {
  if (typeof e.borshDeserialize == 'function') return e.borshDeserialize(t);
  const r = i.get(e);
  if (!r) throw new wi(`Class ${e.name} is missing in schema`);
  if (r.kind === 'struct') {
    const s = {};
    for (const [n, c] of i.get(e).fields) s[n] = es(i, n, c, t);
    return new e(s);
  }
  if (r.kind === 'enum') {
    const s = t.readU8();
    if (s >= r.values.length) throw new wi(`Enum index: ${s} is out of range`);
    const [n, c] = r.values[s],
      f = es(i, n, c, t);
    return new e({ [n]: f });
  }
  throw new wi(`Unexpected schema kind: ${r.kind} for ${e.constructor.name}`);
}
function BL(i, e, t, r = Fi) {
  const s = new r(t),
    n = tg(i, e, s);
  if (s.offset < t.length)
    throw new wi(`Unexpected ${t.length - s.offset} bytes after deserialized data`);
  return n;
}
var _S = (ti.deserialize = BL);
function RL(i, e, t, r = Fi) {
  const s = new r(t);
  return tg(i, e, s);
}
yS = ti.deserializeUnchecked = RL;
const [SS, MS, AS] = [[], [], []],
  PL = BigInt(0),
  pu = BigInt(1),
  TL = BigInt(2),
  OL = BigInt(7),
  CL = BigInt(256),
  LL = BigInt(113);
for (let i = 0, e = pu, t = 1, r = 0; i < 24; i++) {
  ([t, r] = [r, (2 * t + 3 * r) % 5]),
    SS.push(2 * (5 * r + t)),
    MS.push((((i + 1) * (i + 2)) / 2) % 64);
  let s = PL;
  for (let n = 0; n < 7; n++)
    (e = ((e << pu) ^ ((e >> OL) * LL)) % CL), e & TL && (s ^= pu << ((pu << BigInt(n)) - pu));
  AS.push(s);
}
const [NL, $L] = ht.split(AS, !0),
  Kw = (i, e, t) => (t > 32 ? ht.rotlBH(i, e, t) : ht.rotlSH(i, e, t)),
  jw = (i, e, t) => (t > 32 ? ht.rotlBL(i, e, t) : ht.rotlSL(i, e, t));
function DL(i, e = 24) {
  const t = new Uint32Array(10);
  for (let r = 24 - e; r < 24; r++) {
    for (let c = 0; c < 10; c++) t[c] = i[c] ^ i[c + 10] ^ i[c + 20] ^ i[c + 30] ^ i[c + 40];
    for (let c = 0; c < 10; c += 2) {
      const f = (c + 8) % 10,
        h = (c + 2) % 10,
        y = t[h],
        p = t[h + 1],
        m = Kw(y, p, 1) ^ t[f],
        _ = jw(y, p, 1) ^ t[f + 1];
      for (let A = 0; A < 50; A += 10) (i[c + A] ^= m), (i[c + A + 1] ^= _);
    }
    let s = i[2],
      n = i[3];
    for (let c = 0; c < 24; c++) {
      const f = MS[c],
        h = Kw(s, n, f),
        y = jw(s, n, f),
        p = SS[c];
      (s = i[p]), (n = i[p + 1]), (i[p] = h), (i[p + 1] = y);
    }
    for (let c = 0; c < 50; c += 10) {
      for (let f = 0; f < 10; f++) t[f] = i[c + f];
      for (let f = 0; f < 10; f++) i[c + f] ^= ~t[(f + 2) % 10] & t[(f + 4) % 10];
    }
    (i[0] ^= NL[r]), (i[1] ^= $L[r]);
  }
  t.fill(0);
}
class rh extends eg {
  constructor(e, t, r, s = !1, n = 24) {
    if (
      (super(),
      (this.blockLen = e),
      (this.suffix = t),
      (this.outputLen = r),
      (this.enableXOF = s),
      (this.rounds = n),
      (this.pos = 0),
      (this.posOut = 0),
      (this.finished = !1),
      (this.destroyed = !1),
      Li.number(r),
      0 >= this.blockLen || this.blockLen >= 200)
    )
      throw new Error('Sha3 supports only keccak-f1600 function');
    (this.state = new Uint8Array(200)), (this.state32 = TC(this.state));
  }
  keccak() {
    DL(this.state32, this.rounds), (this.posOut = 0), (this.pos = 0);
  }
  update(e) {
    Li.exists(this);
    const { blockLen: t, state: r } = this;
    e = fc(e);
    const s = e.length;
    for (let n = 0; n < s; ) {
      const c = Math.min(t - this.pos, s - n);
      for (let f = 0; f < c; f++) r[this.pos++] ^= e[n++];
      this.pos === t && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = !0;
    const { state: e, suffix: t, pos: r, blockLen: s } = this;
    (e[r] ^= t), t & 128 && r === s - 1 && this.keccak(), (e[s - 1] ^= 128), this.keccak();
  }
  writeInto(e) {
    Li.exists(this, !1), Li.bytes(e), this.finish();
    const t = this.state,
      { blockLen: r } = this;
    for (let s = 0, n = e.length; s < n; ) {
      this.posOut >= r && this.keccak();
      const c = Math.min(r - this.posOut, n - s);
      e.set(t.subarray(this.posOut, this.posOut + c), s), (this.posOut += c), (s += c);
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF) throw new Error('XOF is not possible for this instance');
    return this.writeInto(e);
  }
  xof(e) {
    return Li.number(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if ((Li.output(e, this), this.finished)) throw new Error('digest() was already called');
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    (this.destroyed = !0), this.state.fill(0);
  }
  _cloneInto(e) {
    const { blockLen: t, suffix: r, outputLen: s, rounds: n, enableXOF: c } = this;
    return (
      e || (e = new rh(t, r, s, c, n)),
      e.state32.set(this.state32),
      (e.pos = this.pos),
      (e.posOut = this.posOut),
      (e.finished = this.finished),
      (e.rounds = n),
      (e.suffix = r),
      (e.outputLen = s),
      (e.enableXOF = c),
      (e.destroyed = this.destroyed),
      e
    );
  }
}
const Ho = (i, e, t) => Ls(() => new rh(e, i, t));
Ho(6, 144, 224 / 8);
Ho(6, 136, 256 / 8);
Ho(6, 104, 384 / 8);
Ho(6, 72, 512 / 8);
Ho(1, 144, 224 / 8);
const Hw = Ho(1, 136, 256 / 8);
Ho(1, 104, 384 / 8);
Ho(1, 72, 512 / 8);
const ES = (i, e, t) => LC((r = {}) => new rh(e, i, r.dkLen === void 0 ? t : r.dkLen, !0));
ES(31, 168, 128 / 8);
ES(31, 136, 256 / 8);
class kS extends eg {
  constructor(e, t) {
    super(), (this.finished = !1), (this.destroyed = !1), Li.hash(e);
    const r = fc(t);
    if (((this.iHash = e.create()), typeof this.iHash.update != 'function'))
      throw new TypeError('Expected instance of class which extends utils.Hash');
    (this.blockLen = this.iHash.blockLen), (this.outputLen = this.iHash.outputLen);
    const s = this.blockLen,
      n = new Uint8Array(s);
    n.set(r.length > s ? e.create().update(r).digest() : r);
    for (let c = 0; c < n.length; c++) n[c] ^= 54;
    this.iHash.update(n), (this.oHash = e.create());
    for (let c = 0; c < n.length; c++) n[c] ^= 106;
    this.oHash.update(n), n.fill(0);
  }
  update(e) {
    return Li.exists(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    Li.exists(this),
      Li.bytes(e, this.outputLen),
      (this.finished = !0),
      this.iHash.digestInto(e),
      this.oHash.update(e),
      this.oHash.digestInto(e),
      this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: t, iHash: r, finished: s, destroyed: n, blockLen: c, outputLen: f } = this;
    return (
      (e = e),
      (e.finished = s),
      (e.destroyed = n),
      (e.blockLen = c),
      (e.outputLen = f),
      (e.oHash = t._cloneInto(e.oHash)),
      (e.iHash = r._cloneInto(e.iHash)),
      e
    );
  }
  destroy() {
    (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
  }
}
const IS = (i, e, t) => new kS(i, e).update(t).digest();
IS.create = (i, e) => new kS(i, e);
ln.sha512Sync = (...i) => cL(ln.concatBytes(...i));
const UL = ln.randomPrivateKey,
  Vw = () => {
    const i = ln.randomPrivateKey(),
      e = ul(i),
      t = new Uint8Array(64);
    return t.set(i), t.set(e, 32), { publicKey: e, secretKey: t };
  },
  ul = Ha.getPublicKey;
function Gw(i) {
  try {
    return Or.fromHex(i, !0), !0;
  } catch {
    return !1;
  }
}
const rg = (i, e) => Ha.sign(i, e.slice(0, 32)),
  zL = Ha.verify,
  Mt = (i) =>
    He.isBuffer(i)
      ? i
      : i instanceof Uint8Array
        ? He.from(i.buffer, i.byteOffset, i.byteLength)
        : He.from(i);
class ig {
  constructor(e) {
    Object.assign(this, e);
  }
  encode() {
    return He.from(wS(Iu, this));
  }
  static decode(e) {
    return _S(Iu, this, e);
  }
  static decodeUnchecked(e) {
    return yS(Iu, this, e);
  }
}
class FL extends ig {
  constructor(e) {
    if ((super(e), (this.enum = ''), Object.keys(e).length !== 1))
      throw new Error('Enum can only take single value');
    Object.keys(e).map((t) => {
      this.enum = t;
    });
  }
}
const Iu = new Map();
let xS;
const BS = 32,
  $i = 32;
function qL(i) {
  return i._bn !== void 0;
}
let Yw = 1;
xS = Symbol.toStringTag;
class Xe extends ig {
  constructor(e) {
    if ((super({}), (this._bn = void 0), qL(e))) this._bn = e._bn;
    else {
      if (typeof e == 'string') {
        const t = ii.decode(e);
        if (t.length != $i) throw new Error('Invalid public key input');
        this._bn = new Cu(t);
      } else this._bn = new Cu(e);
      if (this._bn.byteLength() > $i) throw new Error('Invalid public key input');
    }
  }
  static unique() {
    const e = new Xe(Yw);
    return (Yw += 1), new Xe(e.toBuffer());
  }
  equals(e) {
    return this._bn.eq(e._bn);
  }
  toBase58() {
    return ii.encode(this.toBytes());
  }
  toJSON() {
    return this.toBase58();
  }
  toBytes() {
    const e = this.toBuffer();
    return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
  }
  toBuffer() {
    const e = this._bn.toArrayLike(He);
    if (e.length === $i) return e;
    const t = He.alloc(32);
    return e.copy(t, 32 - e.length), t;
  }
  get [xS]() {
    return `PublicKey(${this.toString()})`;
  }
  toString() {
    return this.toBase58();
  }
  static async createWithSeed(e, t, r) {
    const s = He.concat([e.toBuffer(), He.from(t), r.toBuffer()]),
      n = P1(s);
    return new Xe(n);
  }
  static createProgramAddressSync(e, t) {
    let r = He.alloc(0);
    e.forEach(function (n) {
      if (n.length > BS) throw new TypeError('Max seed length exceeded');
      r = He.concat([r, Mt(n)]);
    }),
      (r = He.concat([r, t.toBuffer(), He.from('ProgramDerivedAddress')]));
    const s = P1(r);
    if (Gw(s)) throw new Error('Invalid seeds, address must fall off the curve');
    return new Xe(s);
  }
  static async createProgramAddress(e, t) {
    return this.createProgramAddressSync(e, t);
  }
  static findProgramAddressSync(e, t) {
    let r = 255,
      s;
    for (; r != 0; ) {
      try {
        const n = e.concat(He.from([r]));
        s = this.createProgramAddressSync(n, t);
      } catch (n) {
        if (n instanceof TypeError) throw n;
        r--;
        continue;
      }
      return [s, r];
    }
    throw new Error('Unable to find a viable program address nonce');
  }
  static async findProgramAddress(e, t) {
    return this.findProgramAddressSync(e, t);
  }
  static isOnCurve(e) {
    const t = new Xe(e);
    return Gw(t.toBytes());
  }
}
Xe.default = new Xe('11111111111111111111111111111111');
Iu.set(Xe, { kind: 'struct', fields: [['_bn', 'u256']] });
class WL {
  constructor(e) {
    if (((this._publicKey = void 0), (this._secretKey = void 0), e)) {
      const t = Mt(e);
      if (e.length !== 64) throw new Error('bad secret key size');
      (this._publicKey = t.slice(32, 64)), (this._secretKey = t.slice(0, 32));
    } else (this._secretKey = Mt(UL())), (this._publicKey = Mt(ul(this._secretKey)));
  }
  get publicKey() {
    return new Xe(this._publicKey);
  }
  get secretKey() {
    return He.concat([this._secretKey, this._publicKey], 64);
  }
}
const KL = new Xe('BPFLoader1111111111111111111111111111111111'),
  Lo = 1232,
  ih = 127,
  Oa = 64;
class ng extends Error {
  constructor(e) {
    super(`Signature ${e} has expired: block height exceeded.`),
      (this.signature = void 0),
      (this.signature = e);
  }
}
Object.defineProperty(ng.prototype, 'name', {
  value: 'TransactionExpiredBlockheightExceededError',
});
class og extends Error {
  constructor(e, t) {
    super(
      `Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`
    ),
      (this.signature = void 0),
      (this.signature = e);
  }
}
Object.defineProperty(og.prototype, 'name', { value: 'TransactionExpiredTimeoutError' });
class na extends Error {
  constructor(e) {
    super(`Signature ${e} has expired: the nonce is no longer valid.`),
      (this.signature = void 0),
      (this.signature = e);
  }
}
Object.defineProperty(na.prototype, 'name', { value: 'TransactionExpiredNonceInvalidError' });
class qu {
  constructor(e, t) {
    (this.staticAccountKeys = void 0),
      (this.accountKeysFromLookups = void 0),
      (this.staticAccountKeys = e),
      (this.accountKeysFromLookups = t);
  }
  keySegments() {
    const e = [this.staticAccountKeys];
    return (
      this.accountKeysFromLookups &&
        (e.push(this.accountKeysFromLookups.writable),
        e.push(this.accountKeysFromLookups.readonly)),
      e
    );
  }
  get(e) {
    for (const t of this.keySegments()) {
      if (e < t.length) return t[e];
      e -= t.length;
    }
  }
  get length() {
    return this.keySegments().flat().length;
  }
  compileInstructions(e) {
    if (this.length > 256) throw new Error('Account index overflow encountered during compilation');
    const r = new Map();
    this.keySegments()
      .flat()
      .forEach((n, c) => {
        r.set(n.toBase58(), c);
      });
    const s = (n) => {
      const c = r.get(n.toBase58());
      if (c === void 0)
        throw new Error('Encountered an unknown instruction account key during compilation');
      return c;
    };
    return e.map((n) => ({
      programIdIndex: s(n.programId),
      accountKeyIndexes: n.keys.map((c) => s(c.pubkey)),
      data: n.data,
    }));
  }
}
const xt = (i = 'publicKey') => ut(32, i),
  jL = (i = 'signature') => ut(64, i),
  ns = (i = 'string') => {
    const e = We([qe('length'), qe('lengthPadding'), ut(_i(qe(), -8), 'chars')], i),
      t = e.decode.bind(e),
      r = e.encode.bind(e),
      s = e;
    return (
      (s.decode = (n, c) => t(n, c).chars.toString()),
      (s.encode = (n, c, f) => {
        const h = { chars: He.from(n, 'utf8') };
        return r(h, c, f);
      }),
      (s.alloc = (n) => qe().span + qe().span + He.from(n, 'utf8').length),
      s
    );
  },
  HL = (i = 'authorized') => We([xt('staker'), xt('withdrawer')], i),
  VL = (i = 'lockup') => We([Ir('unixTimestamp'), Ir('epoch'), xt('custodian')], i),
  GL = (i = 'voteInit') =>
    We([xt('nodePubkey'), xt('authorizedVoter'), xt('authorizedWithdrawer'), tt('commission')], i),
  YL = (i = 'voteAuthorizeWithSeedArgs') =>
    We(
      [
        qe('voteAuthorizationType'),
        xt('currentAuthorityDerivedKeyOwnerPubkey'),
        ns('currentAuthorityDerivedKeySeed'),
        xt('newAuthorized'),
      ],
      i
    );
function RS(i, e) {
  const t = (s) => {
    if (s.span >= 0) return s.span;
    if (typeof s.alloc == 'function') return s.alloc(e[s.property]);
    if ('count' in s && 'elementLayout' in s) {
      const n = e[s.property];
      if (Array.isArray(n)) return n.length * t(s.elementLayout);
    } else if ('fields' in s) return RS({ layout: s }, e[s.property]);
    return 0;
  };
  let r = 0;
  return (
    i.layout.fields.forEach((s) => {
      r += t(s);
    }),
    r
  );
}
function Mi(i) {
  let e = 0,
    t = 0;
  for (;;) {
    let r = i.shift();
    if (((e |= (r & 127) << (t * 7)), (t += 1), !(r & 128))) break;
  }
  return e;
}
function Oi(i, e) {
  let t = e;
  for (;;) {
    let r = t & 127;
    if (((t >>= 7), t == 0)) {
      i.push(r);
      break;
    } else (r |= 128), i.push(r);
  }
}
function Gt(i, e) {
  if (!i) throw new Error(e || 'Assertion failed');
}
class nh {
  constructor(e, t) {
    (this.payer = void 0), (this.keyMetaMap = void 0), (this.payer = e), (this.keyMetaMap = t);
  }
  static compile(e, t) {
    const r = new Map(),
      s = (c) => {
        const f = c.toBase58();
        let h = r.get(f);
        return (
          h === void 0 && ((h = { isSigner: !1, isWritable: !1, isInvoked: !1 }), r.set(f, h)), h
        );
      },
      n = s(t);
    (n.isSigner = !0), (n.isWritable = !0);
    for (const c of e) {
      s(c.programId).isInvoked = !0;
      for (const f of c.keys) {
        const h = s(f.pubkey);
        h.isSigner || (h.isSigner = f.isSigner), h.isWritable || (h.isWritable = f.isWritable);
      }
    }
    return new nh(t, r);
  }
  getMessageComponents() {
    const e = [...this.keyMetaMap.entries()];
    Gt(e.length <= 256, 'Max static account keys length exceeded');
    const t = e.filter(([, h]) => h.isSigner && h.isWritable),
      r = e.filter(([, h]) => h.isSigner && !h.isWritable),
      s = e.filter(([, h]) => !h.isSigner && h.isWritable),
      n = e.filter(([, h]) => !h.isSigner && !h.isWritable),
      c = {
        numRequiredSignatures: t.length + r.length,
        numReadonlySignedAccounts: r.length,
        numReadonlyUnsignedAccounts: n.length,
      };
    {
      Gt(t.length > 0, 'Expected at least one writable signer key');
      const [h] = t[0];
      Gt(h === this.payer.toBase58(), 'Expected first writable signer key to be the fee payer');
    }
    const f = [
      ...t.map(([h]) => new Xe(h)),
      ...r.map(([h]) => new Xe(h)),
      ...s.map(([h]) => new Xe(h)),
      ...n.map(([h]) => new Xe(h)),
    ];
    return [c, f];
  }
  extractTableLookup(e) {
    const [t, r] = this.drainKeysFoundInLookupTable(
        e.state.addresses,
        (c) => !c.isSigner && !c.isInvoked && c.isWritable
      ),
      [s, n] = this.drainKeysFoundInLookupTable(
        e.state.addresses,
        (c) => !c.isSigner && !c.isInvoked && !c.isWritable
      );
    if (!(t.length === 0 && s.length === 0))
      return [
        { accountKey: e.key, writableIndexes: t, readonlyIndexes: s },
        { writable: r, readonly: n },
      ];
  }
  drainKeysFoundInLookupTable(e, t) {
    const r = new Array(),
      s = new Array();
    for (const [n, c] of this.keyMetaMap.entries())
      if (t(c)) {
        const f = new Xe(n),
          h = e.findIndex((y) => y.equals(f));
        h >= 0 &&
          (Gt(h < 256, 'Max lookup table index exceeded'),
          r.push(h),
          s.push(f),
          this.keyMetaMap.delete(n));
      }
    return [r, s];
  }
}
class dn {
  constructor(e) {
    (this.header = void 0),
      (this.accountKeys = void 0),
      (this.recentBlockhash = void 0),
      (this.instructions = void 0),
      (this.indexToProgramIds = new Map()),
      (this.header = e.header),
      (this.accountKeys = e.accountKeys.map((t) => new Xe(t))),
      (this.recentBlockhash = e.recentBlockhash),
      (this.instructions = e.instructions),
      this.instructions.forEach((t) =>
        this.indexToProgramIds.set(t.programIdIndex, this.accountKeys[t.programIdIndex])
      );
  }
  get version() {
    return 'legacy';
  }
  get staticAccountKeys() {
    return this.accountKeys;
  }
  get compiledInstructions() {
    return this.instructions.map((e) => ({
      programIdIndex: e.programIdIndex,
      accountKeyIndexes: e.accounts,
      data: ii.decode(e.data),
    }));
  }
  get addressTableLookups() {
    return [];
  }
  getAccountKeys() {
    return new qu(this.staticAccountKeys);
  }
  static compile(e) {
    const t = nh.compile(e.instructions, e.payerKey),
      [r, s] = t.getMessageComponents(),
      c = new qu(s)
        .compileInstructions(e.instructions)
        .map((f) => ({
          programIdIndex: f.programIdIndex,
          accounts: f.accountKeyIndexes,
          data: ii.encode(f.data),
        }));
    return new dn({
      header: r,
      accountKeys: s,
      recentBlockhash: e.recentBlockhash,
      instructions: c,
    });
  }
  isAccountSigner(e) {
    return e < this.header.numRequiredSignatures;
  }
  isAccountWritable(e) {
    const t = this.header.numRequiredSignatures;
    if (e >= this.header.numRequiredSignatures) {
      const r = e - t,
        n = this.accountKeys.length - t - this.header.numReadonlyUnsignedAccounts;
      return r < n;
    } else {
      const r = t - this.header.numReadonlySignedAccounts;
      return e < r;
    }
  }
  isProgramId(e) {
    return this.indexToProgramIds.has(e);
  }
  programIds() {
    return [...this.indexToProgramIds.values()];
  }
  nonProgramIds() {
    return this.accountKeys.filter((e, t) => !this.isProgramId(t));
  }
  serialize() {
    const e = this.accountKeys.length;
    let t = [];
    Oi(t, e);
    const r = this.instructions.map((m) => {
      const { accounts: _, programIdIndex: A } = m,
        E = Array.from(ii.decode(m.data));
      let I = [];
      Oi(I, _.length);
      let R = [];
      return (
        Oi(R, E.length),
        {
          programIdIndex: A,
          keyIndicesCount: He.from(I),
          keyIndices: _,
          dataLength: He.from(R),
          data: E,
        }
      );
    });
    let s = [];
    Oi(s, r.length);
    let n = He.alloc(Lo);
    He.from(s).copy(n);
    let c = s.length;
    r.forEach((m) => {
      const A = We([
        tt('programIdIndex'),
        ut(m.keyIndicesCount.length, 'keyIndicesCount'),
        zt(tt('keyIndex'), m.keyIndices.length, 'keyIndices'),
        ut(m.dataLength.length, 'dataLength'),
        zt(tt('userdatum'), m.data.length, 'data'),
      ]).encode(m, n, c);
      c += A;
    }),
      (n = n.slice(0, c));
    const f = We([
        ut(1, 'numRequiredSignatures'),
        ut(1, 'numReadonlySignedAccounts'),
        ut(1, 'numReadonlyUnsignedAccounts'),
        ut(t.length, 'keyCount'),
        zt(xt('key'), e, 'keys'),
        xt('recentBlockhash'),
      ]),
      h = {
        numRequiredSignatures: He.from([this.header.numRequiredSignatures]),
        numReadonlySignedAccounts: He.from([this.header.numReadonlySignedAccounts]),
        numReadonlyUnsignedAccounts: He.from([this.header.numReadonlyUnsignedAccounts]),
        keyCount: He.from(t),
        keys: this.accountKeys.map((m) => Mt(m.toBytes())),
        recentBlockhash: ii.decode(this.recentBlockhash),
      };
    let y = He.alloc(2048);
    const p = f.encode(h, y);
    return n.copy(y, p), y.slice(0, p + n.length);
  }
  static from(e) {
    let t = [...e];
    const r = t.shift();
    if (r !== (r & ih))
      throw new Error(
        'Versioned messages must be deserialized with VersionedMessage.deserialize()'
      );
    const s = t.shift(),
      n = t.shift(),
      c = Mi(t);
    let f = [];
    for (let _ = 0; _ < c; _++) {
      const A = t.slice(0, $i);
      (t = t.slice($i)), f.push(new Xe(He.from(A)));
    }
    const h = t.slice(0, $i);
    t = t.slice($i);
    const y = Mi(t);
    let p = [];
    for (let _ = 0; _ < y; _++) {
      const A = t.shift(),
        E = Mi(t),
        I = t.slice(0, E);
      t = t.slice(E);
      const R = Mi(t),
        L = t.slice(0, R),
        D = ii.encode(He.from(L));
      (t = t.slice(R)), p.push({ programIdIndex: A, accounts: I, data: D });
    }
    const m = {
      header: {
        numRequiredSignatures: r,
        numReadonlySignedAccounts: s,
        numReadonlyUnsignedAccounts: n,
      },
      recentBlockhash: ii.encode(He.from(h)),
      accountKeys: f,
      instructions: p,
    };
    return new dn(m);
  }
}
class As {
  constructor(e) {
    (this.header = void 0),
      (this.staticAccountKeys = void 0),
      (this.recentBlockhash = void 0),
      (this.compiledInstructions = void 0),
      (this.addressTableLookups = void 0),
      (this.header = e.header),
      (this.staticAccountKeys = e.staticAccountKeys),
      (this.recentBlockhash = e.recentBlockhash),
      (this.compiledInstructions = e.compiledInstructions),
      (this.addressTableLookups = e.addressTableLookups);
  }
  get version() {
    return 0;
  }
  get numAccountKeysFromLookups() {
    let e = 0;
    for (const t of this.addressTableLookups)
      e += t.readonlyIndexes.length + t.writableIndexes.length;
    return e;
  }
  getAccountKeys(e) {
    let t;
    if (e && 'accountKeysFromLookups' in e && e.accountKeysFromLookups) {
      if (
        this.numAccountKeysFromLookups !=
        e.accountKeysFromLookups.writable.length + e.accountKeysFromLookups.readonly.length
      )
        throw new Error(
          'Failed to get account keys because of a mismatch in the number of account keys from lookups'
        );
      t = e.accountKeysFromLookups;
    } else if (e && 'addressLookupTableAccounts' in e && e.addressLookupTableAccounts)
      t = this.resolveAddressTableLookups(e.addressLookupTableAccounts);
    else if (this.addressTableLookups.length > 0)
      throw new Error('Failed to get account keys because address table lookups were not resolved');
    return new qu(this.staticAccountKeys, t);
  }
  isAccountSigner(e) {
    return e < this.header.numRequiredSignatures;
  }
  isAccountWritable(e) {
    const t = this.header.numRequiredSignatures,
      r = this.staticAccountKeys.length;
    if (e >= r) {
      const s = e - r,
        n = this.addressTableLookups.reduce((c, f) => c + f.writableIndexes.length, 0);
      return s < n;
    } else if (e >= this.header.numRequiredSignatures) {
      const s = e - t,
        c = r - t - this.header.numReadonlyUnsignedAccounts;
      return s < c;
    } else {
      const s = t - this.header.numReadonlySignedAccounts;
      return e < s;
    }
  }
  resolveAddressTableLookups(e) {
    const t = { writable: [], readonly: [] };
    for (const r of this.addressTableLookups) {
      const s = e.find((n) => n.key.equals(r.accountKey));
      if (!s)
        throw new Error(
          `Failed to find address lookup table account for table key ${r.accountKey.toBase58()}`
        );
      for (const n of r.writableIndexes)
        if (n < s.state.addresses.length) t.writable.push(s.state.addresses[n]);
        else
          throw new Error(
            `Failed to find address for index ${n} in address lookup table ${r.accountKey.toBase58()}`
          );
      for (const n of r.readonlyIndexes)
        if (n < s.state.addresses.length) t.readonly.push(s.state.addresses[n]);
        else
          throw new Error(
            `Failed to find address for index ${n} in address lookup table ${r.accountKey.toBase58()}`
          );
    }
    return t;
  }
  static compile(e) {
    const t = nh.compile(e.instructions, e.payerKey),
      r = new Array(),
      s = { writable: new Array(), readonly: new Array() },
      n = e.addressLookupTableAccounts || [];
    for (const p of n) {
      const m = t.extractTableLookup(p);
      if (m !== void 0) {
        const [_, { writable: A, readonly: E }] = m;
        r.push(_), s.writable.push(...A), s.readonly.push(...E);
      }
    }
    const [c, f] = t.getMessageComponents(),
      y = new qu(f, s).compileInstructions(e.instructions);
    return new As({
      header: c,
      staticAccountKeys: f,
      recentBlockhash: e.recentBlockhash,
      compiledInstructions: y,
      addressTableLookups: r,
    });
  }
  serialize() {
    const e = Array();
    Oi(e, this.staticAccountKeys.length);
    const t = this.serializeInstructions(),
      r = Array();
    Oi(r, this.compiledInstructions.length);
    const s = this.serializeAddressTableLookups(),
      n = Array();
    Oi(n, this.addressTableLookups.length);
    const c = We([
        tt('prefix'),
        We(
          [
            tt('numRequiredSignatures'),
            tt('numReadonlySignedAccounts'),
            tt('numReadonlyUnsignedAccounts'),
          ],
          'header'
        ),
        ut(e.length, 'staticAccountKeysLength'),
        zt(xt(), this.staticAccountKeys.length, 'staticAccountKeys'),
        xt('recentBlockhash'),
        ut(r.length, 'instructionsLength'),
        ut(t.length, 'serializedInstructions'),
        ut(n.length, 'addressTableLookupsLength'),
        ut(s.length, 'serializedAddressTableLookups'),
      ]),
      f = new Uint8Array(Lo),
      y = c.encode(
        {
          prefix: 128,
          header: this.header,
          staticAccountKeysLength: new Uint8Array(e),
          staticAccountKeys: this.staticAccountKeys.map((p) => p.toBytes()),
          recentBlockhash: ii.decode(this.recentBlockhash),
          instructionsLength: new Uint8Array(r),
          serializedInstructions: t,
          addressTableLookupsLength: new Uint8Array(n),
          serializedAddressTableLookups: s,
        },
        f
      );
    return f.slice(0, y);
  }
  serializeInstructions() {
    let e = 0;
    const t = new Uint8Array(Lo);
    for (const r of this.compiledInstructions) {
      const s = Array();
      Oi(s, r.accountKeyIndexes.length);
      const n = Array();
      Oi(n, r.data.length);
      const c = We([
        tt('programIdIndex'),
        ut(s.length, 'encodedAccountKeyIndexesLength'),
        zt(tt(), r.accountKeyIndexes.length, 'accountKeyIndexes'),
        ut(n.length, 'encodedDataLength'),
        ut(r.data.length, 'data'),
      ]);
      e += c.encode(
        {
          programIdIndex: r.programIdIndex,
          encodedAccountKeyIndexesLength: new Uint8Array(s),
          accountKeyIndexes: r.accountKeyIndexes,
          encodedDataLength: new Uint8Array(n),
          data: r.data,
        },
        t,
        e
      );
    }
    return t.slice(0, e);
  }
  serializeAddressTableLookups() {
    let e = 0;
    const t = new Uint8Array(Lo);
    for (const r of this.addressTableLookups) {
      const s = Array();
      Oi(s, r.writableIndexes.length);
      const n = Array();
      Oi(n, r.readonlyIndexes.length);
      const c = We([
        xt('accountKey'),
        ut(s.length, 'encodedWritableIndexesLength'),
        zt(tt(), r.writableIndexes.length, 'writableIndexes'),
        ut(n.length, 'encodedReadonlyIndexesLength'),
        zt(tt(), r.readonlyIndexes.length, 'readonlyIndexes'),
      ]);
      e += c.encode(
        {
          accountKey: r.accountKey.toBytes(),
          encodedWritableIndexesLength: new Uint8Array(s),
          writableIndexes: r.writableIndexes,
          encodedReadonlyIndexesLength: new Uint8Array(n),
          readonlyIndexes: r.readonlyIndexes,
        },
        t,
        e
      );
    }
    return t.slice(0, e);
  }
  static deserialize(e) {
    let t = [...e];
    const r = t.shift(),
      s = r & ih;
    Gt(r !== s, 'Expected versioned message but received legacy message');
    const n = s;
    Gt(n === 0, `Expected versioned message with version 0 but found version ${n}`);
    const c = {
        numRequiredSignatures: t.shift(),
        numReadonlySignedAccounts: t.shift(),
        numReadonlyUnsignedAccounts: t.shift(),
      },
      f = [],
      h = Mi(t);
    for (let E = 0; E < h; E++) f.push(new Xe(t.splice(0, $i)));
    const y = ii.encode(t.splice(0, $i)),
      p = Mi(t),
      m = [];
    for (let E = 0; E < p; E++) {
      const I = t.shift(),
        R = Mi(t),
        L = t.splice(0, R),
        D = Mi(t),
        q = new Uint8Array(t.splice(0, D));
      m.push({ programIdIndex: I, accountKeyIndexes: L, data: q });
    }
    const _ = Mi(t),
      A = [];
    for (let E = 0; E < _; E++) {
      const I = new Xe(t.splice(0, $i)),
        R = Mi(t),
        L = t.splice(0, R),
        D = Mi(t),
        q = t.splice(0, D);
      A.push({ accountKey: I, writableIndexes: L, readonlyIndexes: q });
    }
    return new As({
      header: c,
      staticAccountKeys: f,
      recentBlockhash: y,
      compiledInstructions: m,
      addressTableLookups: A,
    });
  }
}
const sg = {
  deserializeMessageVersion(i) {
    const e = i[0],
      t = e & ih;
    return t === e ? 'legacy' : t;
  },
  deserialize: (i) => {
    const e = sg.deserializeMessageVersion(i);
    if (e === 'legacy') return dn.from(i);
    if (e === 0) return As.deserialize(i);
    throw new Error(`Transaction message version ${e} deserialization is not supported`);
  },
};
let on;
(function (i) {
  (i[(i.BLOCKHEIGHT_EXCEEDED = 0)] = 'BLOCKHEIGHT_EXCEEDED'),
    (i[(i.PROCESSED = 1)] = 'PROCESSED'),
    (i[(i.TIMED_OUT = 2)] = 'TIMED_OUT'),
    (i[(i.NONCE_INVALID = 3)] = 'NONCE_INVALID');
})(on || (on = {}));
const ZL = He.alloc(Oa).fill(0);
class Mr {
  constructor(e) {
    (this.keys = void 0),
      (this.programId = void 0),
      (this.data = He.alloc(0)),
      (this.programId = e.programId),
      (this.keys = e.keys),
      e.data && (this.data = e.data);
  }
  toJSON() {
    return {
      keys: this.keys.map(({ pubkey: e, isSigner: t, isWritable: r }) => ({
        pubkey: e.toJSON(),
        isSigner: t,
        isWritable: r,
      })),
      programId: this.programId.toJSON(),
      data: [...this.data],
    };
  }
}
class rr {
  get signature() {
    return this.signatures.length > 0 ? this.signatures[0].signature : null;
  }
  constructor(e) {
    if (
      ((this.signatures = []),
      (this.feePayer = void 0),
      (this.instructions = []),
      (this.recentBlockhash = void 0),
      (this.lastValidBlockHeight = void 0),
      (this.nonceInfo = void 0),
      (this.minNonceContextSlot = void 0),
      (this._message = void 0),
      (this._json = void 0),
      !!e)
    )
      if (
        (e.feePayer && (this.feePayer = e.feePayer),
        e.signatures && (this.signatures = e.signatures),
        Object.prototype.hasOwnProperty.call(e, 'nonceInfo'))
      ) {
        const { minContextSlot: t, nonceInfo: r } = e;
        (this.minNonceContextSlot = t), (this.nonceInfo = r);
      } else if (Object.prototype.hasOwnProperty.call(e, 'lastValidBlockHeight')) {
        const { blockhash: t, lastValidBlockHeight: r } = e;
        (this.recentBlockhash = t), (this.lastValidBlockHeight = r);
      } else {
        const { recentBlockhash: t, nonceInfo: r } = e;
        r && (this.nonceInfo = r), (this.recentBlockhash = t);
      }
  }
  toJSON() {
    return {
      recentBlockhash: this.recentBlockhash || null,
      feePayer: this.feePayer ? this.feePayer.toJSON() : null,
      nonceInfo: this.nonceInfo
        ? {
            nonce: this.nonceInfo.nonce,
            nonceInstruction: this.nonceInfo.nonceInstruction.toJSON(),
          }
        : null,
      instructions: this.instructions.map((e) => e.toJSON()),
      signers: this.signatures.map(({ publicKey: e }) => e.toJSON()),
    };
  }
  add(...e) {
    if (e.length === 0) throw new Error('No instructions');
    return (
      e.forEach((t) => {
        'instructions' in t
          ? (this.instructions = this.instructions.concat(t.instructions))
          : 'data' in t && 'programId' in t && 'keys' in t
            ? this.instructions.push(t)
            : this.instructions.push(new Mr(t));
      }),
      this
    );
  }
  compileMessage() {
    if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json))
      return this._message;
    let e, t;
    if (
      (this.nonceInfo
        ? ((e = this.nonceInfo.nonce),
          this.instructions[0] != this.nonceInfo.nonceInstruction
            ? (t = [this.nonceInfo.nonceInstruction, ...this.instructions])
            : (t = this.instructions))
        : ((e = this.recentBlockhash), (t = this.instructions)),
      !e)
    )
      throw new Error('Transaction recentBlockhash required');
    t.length < 1 && console.warn('No instructions provided');
    let r;
    if (this.feePayer) r = this.feePayer;
    else if (this.signatures.length > 0 && this.signatures[0].publicKey)
      r = this.signatures[0].publicKey;
    else throw new Error('Transaction fee payer required');
    for (let I = 0; I < t.length; I++)
      if (t[I].programId === void 0)
        throw new Error(`Transaction instruction index ${I} has undefined program id`);
    const s = [],
      n = [];
    t.forEach((I) => {
      I.keys.forEach((L) => {
        n.push({ ...L });
      });
      const R = I.programId.toString();
      s.includes(R) || s.push(R);
    }),
      s.forEach((I) => {
        n.push({ pubkey: new Xe(I), isSigner: !1, isWritable: !1 });
      });
    const c = [];
    n.forEach((I) => {
      const R = I.pubkey.toString(),
        L = c.findIndex((D) => D.pubkey.toString() === R);
      L > -1
        ? ((c[L].isWritable = c[L].isWritable || I.isWritable),
          (c[L].isSigner = c[L].isSigner || I.isSigner))
        : c.push(I);
    }),
      c.sort(function (I, R) {
        return I.isSigner !== R.isSigner
          ? I.isSigner
            ? -1
            : 1
          : I.isWritable !== R.isWritable
            ? I.isWritable
              ? -1
              : 1
            : I.pubkey.toBase58().localeCompare(R.pubkey.toBase58());
      });
    const f = c.findIndex((I) => I.pubkey.equals(r));
    if (f > -1) {
      const [I] = c.splice(f, 1);
      (I.isSigner = !0), (I.isWritable = !0), c.unshift(I);
    } else c.unshift({ pubkey: r, isSigner: !0, isWritable: !0 });
    for (const I of this.signatures) {
      const R = c.findIndex((L) => L.pubkey.equals(I.publicKey));
      if (R > -1)
        c[R].isSigner ||
          ((c[R].isSigner = !0),
          console.warn(
            'Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release.'
          ));
      else throw new Error(`unknown signer: ${I.publicKey.toString()}`);
    }
    let h = 0,
      y = 0,
      p = 0;
    const m = [],
      _ = [];
    c.forEach(({ pubkey: I, isSigner: R, isWritable: L }) => {
      R ? (m.push(I.toString()), (h += 1), L || (y += 1)) : (_.push(I.toString()), L || (p += 1));
    });
    const A = m.concat(_),
      E = t.map((I) => {
        const { data: R, programId: L } = I;
        return {
          programIdIndex: A.indexOf(L.toString()),
          accounts: I.keys.map((D) => A.indexOf(D.pubkey.toString())),
          data: ii.encode(R),
        };
      });
    return (
      E.forEach((I) => {
        Gt(I.programIdIndex >= 0), I.accounts.forEach((R) => Gt(R >= 0));
      }),
      new dn({
        header: {
          numRequiredSignatures: h,
          numReadonlySignedAccounts: y,
          numReadonlyUnsignedAccounts: p,
        },
        accountKeys: A,
        recentBlockhash: e,
        instructions: E,
      })
    );
  }
  _compile() {
    const e = this.compileMessage(),
      t = e.accountKeys.slice(0, e.header.numRequiredSignatures);
    return (
      (this.signatures.length === t.length &&
        this.signatures.every((s, n) => t[n].equals(s.publicKey))) ||
        (this.signatures = t.map((r) => ({ signature: null, publicKey: r }))),
      e
    );
  }
  serializeMessage() {
    return this._compile().serialize();
  }
  async getEstimatedFee(e) {
    return (await e.getFeeForMessage(this.compileMessage())).value;
  }
  setSigners(...e) {
    if (e.length === 0) throw new Error('No signers');
    const t = new Set();
    this.signatures = e
      .filter((r) => {
        const s = r.toString();
        return t.has(s) ? !1 : (t.add(s), !0);
      })
      .map((r) => ({ signature: null, publicKey: r }));
  }
  sign(...e) {
    if (e.length === 0) throw new Error('No signers');
    const t = new Set(),
      r = [];
    for (const n of e) {
      const c = n.publicKey.toString();
      t.has(c) || (t.add(c), r.push(n));
    }
    this.signatures = r.map((n) => ({ signature: null, publicKey: n.publicKey }));
    const s = this._compile();
    this._partialSign(s, ...r);
  }
  partialSign(...e) {
    if (e.length === 0) throw new Error('No signers');
    const t = new Set(),
      r = [];
    for (const n of e) {
      const c = n.publicKey.toString();
      t.has(c) || (t.add(c), r.push(n));
    }
    const s = this._compile();
    this._partialSign(s, ...r);
  }
  _partialSign(e, ...t) {
    const r = e.serialize();
    t.forEach((s) => {
      const n = rg(r, s.secretKey);
      this._addSignature(s.publicKey, Mt(n));
    });
  }
  addSignature(e, t) {
    this._compile(), this._addSignature(e, t);
  }
  _addSignature(e, t) {
    Gt(t.length === 64);
    const r = this.signatures.findIndex((s) => e.equals(s.publicKey));
    if (r < 0) throw new Error(`unknown signer: ${e.toString()}`);
    this.signatures[r].signature = He.from(t);
  }
  verifySignatures(e) {
    return this._verifySignatures(this.serializeMessage(), e === void 0 ? !0 : e);
  }
  _verifySignatures(e, t) {
    for (const { signature: r, publicKey: s } of this.signatures)
      if (r === null) {
        if (t) return !1;
      } else if (!zL(r, e, s.toBytes())) return !1;
    return !0;
  }
  serialize(e) {
    const { requireAllSignatures: t, verifySignatures: r } = Object.assign(
        { requireAllSignatures: !0, verifySignatures: !0 },
        e
      ),
      s = this.serializeMessage();
    if (r && !this._verifySignatures(s, t)) throw new Error('Signature verification failed');
    return this._serialize(s);
  }
  _serialize(e) {
    const { signatures: t } = this,
      r = [];
    Oi(r, t.length);
    const s = r.length + t.length * 64 + e.length,
      n = He.alloc(s);
    return (
      Gt(t.length < 256),
      He.from(r).copy(n, 0),
      t.forEach(({ signature: c }, f) => {
        c !== null &&
          (Gt(c.length === 64, 'signature has invalid length'),
          He.from(c).copy(n, r.length + f * 64));
      }),
      e.copy(n, r.length + t.length * 64),
      Gt(n.length <= Lo, `Transaction too large: ${n.length} > ${Lo}`),
      n
    );
  }
  get keys() {
    return Gt(this.instructions.length === 1), this.instructions[0].keys.map((e) => e.pubkey);
  }
  get programId() {
    return Gt(this.instructions.length === 1), this.instructions[0].programId;
  }
  get data() {
    return Gt(this.instructions.length === 1), this.instructions[0].data;
  }
  static from(e) {
    let t = [...e];
    const r = Mi(t);
    let s = [];
    for (let n = 0; n < r; n++) {
      const c = t.slice(0, Oa);
      (t = t.slice(Oa)), s.push(ii.encode(He.from(c)));
    }
    return rr.populate(dn.from(t), s);
  }
  static populate(e, t = []) {
    const r = new rr();
    return (
      (r.recentBlockhash = e.recentBlockhash),
      e.header.numRequiredSignatures > 0 && (r.feePayer = e.accountKeys[0]),
      t.forEach((s, n) => {
        const c = {
          signature: s == ii.encode(ZL) ? null : ii.decode(s),
          publicKey: e.accountKeys[n],
        };
        r.signatures.push(c);
      }),
      e.instructions.forEach((s) => {
        const n = s.accounts.map((c) => {
          const f = e.accountKeys[c];
          return {
            pubkey: f,
            isSigner:
              r.signatures.some((h) => h.publicKey.toString() === f.toString()) ||
              e.isAccountSigner(c),
            isWritable: e.isAccountWritable(c),
          };
        });
        r.instructions.push(
          new Mr({ keys: n, programId: e.accountKeys[s.programIdIndex], data: ii.decode(s.data) })
        );
      }),
      (r._message = e),
      (r._json = r.toJSON()),
      r
    );
  }
}
class ag {
  constructor(e) {
    (this.payerKey = void 0),
      (this.instructions = void 0),
      (this.recentBlockhash = void 0),
      (this.payerKey = e.payerKey),
      (this.instructions = e.instructions),
      (this.recentBlockhash = e.recentBlockhash);
  }
  static decompile(e, t) {
    const { header: r, compiledInstructions: s, recentBlockhash: n } = e,
      {
        numRequiredSignatures: c,
        numReadonlySignedAccounts: f,
        numReadonlyUnsignedAccounts: h,
      } = r,
      y = c - f;
    Gt(y > 0, 'Message header is invalid');
    const p = e.staticAccountKeys.length - c - h;
    Gt(p >= 0, 'Message header is invalid');
    const m = e.getAccountKeys(t),
      _ = m.get(0);
    if (_ === void 0)
      throw new Error('Failed to decompile message because no account keys were found');
    const A = [];
    for (const E of s) {
      const I = [];
      for (const L of E.accountKeyIndexes) {
        const D = m.get(L);
        if (D === void 0) throw new Error(`Failed to find key for account key index ${L}`);
        const q = L < c;
        let H;
        q
          ? (H = L < y)
          : L < m.staticAccountKeys.length
            ? (H = L - c < p)
            : (H = L - m.staticAccountKeys.length < m.accountKeysFromLookups.writable.length),
          I.push({ pubkey: D, isSigner: L < r.numRequiredSignatures, isWritable: H });
      }
      const R = m.get(E.programIdIndex);
      if (R === void 0)
        throw new Error(`Failed to find program id for program id index ${E.programIdIndex}`);
      A.push(new Mr({ programId: R, data: Mt(E.data), keys: I }));
    }
    return new ag({ payerKey: _, instructions: A, recentBlockhash: n });
  }
  compileToLegacyMessage() {
    return dn.compile({
      payerKey: this.payerKey,
      recentBlockhash: this.recentBlockhash,
      instructions: this.instructions,
    });
  }
  compileToV0Message(e) {
    return As.compile({
      payerKey: this.payerKey,
      recentBlockhash: this.recentBlockhash,
      instructions: this.instructions,
      addressLookupTableAccounts: e,
    });
  }
}
class ug {
  get version() {
    return this.message.version;
  }
  constructor(e, t) {
    if (((this.signatures = void 0), (this.message = void 0), t !== void 0))
      Gt(
        t.length === e.header.numRequiredSignatures,
        'Expected signatures length to be equal to the number of required signatures'
      ),
        (this.signatures = t);
    else {
      const r = [];
      for (let s = 0; s < e.header.numRequiredSignatures; s++) r.push(new Uint8Array(Oa));
      this.signatures = r;
    }
    this.message = e;
  }
  serialize() {
    const e = this.message.serialize(),
      t = Array();
    Oi(t, this.signatures.length);
    const r = We([
        ut(t.length, 'encodedSignaturesLength'),
        zt(jL(), this.signatures.length, 'signatures'),
        ut(e.length, 'serializedMessage'),
      ]),
      s = new Uint8Array(2048),
      n = r.encode(
        {
          encodedSignaturesLength: new Uint8Array(t),
          signatures: this.signatures,
          serializedMessage: e,
        },
        s
      );
    return s.slice(0, n);
  }
  static deserialize(e) {
    let t = [...e];
    const r = [],
      s = Mi(t);
    for (let c = 0; c < s; c++) r.push(new Uint8Array(t.splice(0, Oa)));
    const n = sg.deserialize(new Uint8Array(t));
    return new ug(n, r);
  }
  sign(e) {
    const t = this.message.serialize(),
      r = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
    for (const s of e) {
      const n = r.findIndex((c) => c.equals(s.publicKey));
      Gt(n >= 0, `Cannot sign with non signer key ${s.publicKey.toBase58()}`),
        (this.signatures[n] = rg(t, s.secretKey));
    }
  }
  addSignature(e, t) {
    Gt(t.byteLength === 64, 'Signature must be 64 bytes long');
    const s = this.message.staticAccountKeys
      .slice(0, this.message.header.numRequiredSignatures)
      .findIndex((n) => n.equals(e));
    Gt(
      s >= 0,
      `Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`
    ),
      (this.signatures[s] = t);
  }
}
const Sn = new Xe('SysvarC1ock11111111111111111111111111111111'),
  JL = new Xe('SysvarEpochSchedu1e111111111111111111111111'),
  XL = new Xe('Sysvar1nstructions1111111111111111111111111'),
  Pf = new Xe('SysvarRecentB1ockHashes11111111111111111111'),
  Ca = new Xe('SysvarRent111111111111111111111111111111111'),
  QL = new Xe('SysvarRewards111111111111111111111111111111'),
  eN = new Xe('SysvarS1otHashes111111111111111111111111111'),
  tN = new Xe('SysvarS1otHistory11111111111111111111111111'),
  Tf = new Xe('SysvarStakeHistory1111111111111111111111111');
async function Of(i, e, t, r) {
  const s = r && {
      skipPreflight: r.skipPreflight,
      preflightCommitment: r.preflightCommitment || r.commitment,
      maxRetries: r.maxRetries,
      minContextSlot: r.minContextSlot,
    },
    n = await i.sendTransaction(e, t, s);
  let c;
  if (e.recentBlockhash != null && e.lastValidBlockHeight != null)
    c = (
      await i.confirmTransaction(
        {
          abortSignal: r == null ? void 0 : r.abortSignal,
          signature: n,
          blockhash: e.recentBlockhash,
          lastValidBlockHeight: e.lastValidBlockHeight,
        },
        r && r.commitment
      )
    ).value;
  else if (e.minNonceContextSlot != null && e.nonceInfo != null) {
    const { nonceInstruction: f } = e.nonceInfo,
      h = f.keys[0].pubkey;
    c = (
      await i.confirmTransaction(
        {
          abortSignal: r == null ? void 0 : r.abortSignal,
          minContextSlot: e.minNonceContextSlot,
          nonceAccountPubkey: h,
          nonceValue: e.nonceInfo.nonce,
          signature: n,
        },
        r && r.commitment
      )
    ).value;
  } else
    (r == null ? void 0 : r.abortSignal) != null &&
      console.warn(
        'sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.'
      ),
      (c = (await i.confirmTransaction(n, r && r.commitment)).value);
  if (c.err) throw new Error(`Transaction ${n} failed (${JSON.stringify(c)})`);
  return n;
}
function ts(i) {
  return new Promise((e) => setTimeout(e, i));
}
function Dt(i, e) {
  const t = i.layout.span >= 0 ? i.layout.span : RS(i, e),
    r = He.alloc(t),
    s = Object.assign({ instruction: i.index }, e);
  return i.layout.encode(s, r), r;
}
function tr(i, e) {
  let t;
  try {
    t = i.layout.decode(e);
  } catch (r) {
    throw new Error('invalid instruction; ' + r);
  }
  if (t.instruction !== i.index)
    throw new Error(
      `invalid instruction; instruction index mismatch ${t.instruction} != ${i.index}`
    );
  return t;
}
const PS = Nt('lamportsPerSignature'),
  TS = We([
    qe('version'),
    qe('state'),
    xt('authorizedPubkey'),
    xt('nonce'),
    We([PS], 'feeCalculator'),
  ]),
  T1 = TS.span;
class oh {
  constructor(e) {
    (this.authorizedPubkey = void 0),
      (this.nonce = void 0),
      (this.feeCalculator = void 0),
      (this.authorizedPubkey = e.authorizedPubkey),
      (this.nonce = e.nonce),
      (this.feeCalculator = e.feeCalculator);
  }
  static fromAccountData(e) {
    const t = TS.decode(Mt(e), 0);
    return new oh({
      authorizedPubkey: new Xe(t.authorizedPubkey),
      nonce: new Xe(t.nonce).toString(),
      feeCalculator: t.feeCalculator,
    });
  }
}
const rN = (i) => {
    const e = i.decode.bind(i),
      t = i.encode.bind(i);
    return { decode: e, encode: t };
  },
  iN = (i) => (e) => {
    const t = ut(i, e),
      { encode: r, decode: s } = rN(t),
      n = t;
    return (
      (n.decode = (c, f) => {
        const h = s(c, f);
        return E3(He.from(h));
      }),
      (n.encode = (c, f, h) => {
        const y = ql(c, i);
        return r(y, f, h);
      }),
      n
    );
  },
  La = iN(8);
class nN {
  constructor() {}
  static decodeInstructionType(e) {
    this.checkProgramId(e.programId);
    const r = qe('instruction').decode(e.data);
    let s;
    for (const [n, c] of Object.entries(Er))
      if (c.index == r) {
        s = n;
        break;
      }
    if (!s) throw new Error('Instruction type incorrect; not a SystemInstruction');
    return s;
  }
  static decodeCreateAccount(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
    const { lamports: t, space: r, programId: s } = tr(Er.Create, e.data);
    return {
      fromPubkey: e.keys[0].pubkey,
      newAccountPubkey: e.keys[1].pubkey,
      lamports: t,
      space: r,
      programId: new Xe(s),
    };
  }
  static decodeTransfer(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
    const { lamports: t } = tr(Er.Transfer, e.data);
    return { fromPubkey: e.keys[0].pubkey, toPubkey: e.keys[1].pubkey, lamports: t };
  }
  static decodeTransferWithSeed(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
    const { lamports: t, seed: r, programId: s } = tr(Er.TransferWithSeed, e.data);
    return {
      fromPubkey: e.keys[0].pubkey,
      basePubkey: e.keys[1].pubkey,
      toPubkey: e.keys[2].pubkey,
      lamports: t,
      seed: r,
      programId: new Xe(s),
    };
  }
  static decodeAllocate(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 1);
    const { space: t } = tr(Er.Allocate, e.data);
    return { accountPubkey: e.keys[0].pubkey, space: t };
  }
  static decodeAllocateWithSeed(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 1);
    const { base: t, seed: r, space: s, programId: n } = tr(Er.AllocateWithSeed, e.data);
    return {
      accountPubkey: e.keys[0].pubkey,
      basePubkey: new Xe(t),
      seed: r,
      space: s,
      programId: new Xe(n),
    };
  }
  static decodeAssign(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 1);
    const { programId: t } = tr(Er.Assign, e.data);
    return { accountPubkey: e.keys[0].pubkey, programId: new Xe(t) };
  }
  static decodeAssignWithSeed(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 1);
    const { base: t, seed: r, programId: s } = tr(Er.AssignWithSeed, e.data);
    return {
      accountPubkey: e.keys[0].pubkey,
      basePubkey: new Xe(t),
      seed: r,
      programId: new Xe(s),
    };
  }
  static decodeCreateWithSeed(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
    const { base: t, seed: r, lamports: s, space: n, programId: c } = tr(Er.CreateWithSeed, e.data);
    return {
      fromPubkey: e.keys[0].pubkey,
      newAccountPubkey: e.keys[1].pubkey,
      basePubkey: new Xe(t),
      seed: r,
      lamports: s,
      space: n,
      programId: new Xe(c),
    };
  }
  static decodeNonceInitialize(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
    const { authorized: t } = tr(Er.InitializeNonceAccount, e.data);
    return { noncePubkey: e.keys[0].pubkey, authorizedPubkey: new Xe(t) };
  }
  static decodeNonceAdvance(e) {
    return (
      this.checkProgramId(e.programId),
      this.checkKeyLength(e.keys, 3),
      tr(Er.AdvanceNonceAccount, e.data),
      { noncePubkey: e.keys[0].pubkey, authorizedPubkey: e.keys[2].pubkey }
    );
  }
  static decodeNonceWithdraw(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 5);
    const { lamports: t } = tr(Er.WithdrawNonceAccount, e.data);
    return {
      noncePubkey: e.keys[0].pubkey,
      toPubkey: e.keys[1].pubkey,
      authorizedPubkey: e.keys[4].pubkey,
      lamports: t,
    };
  }
  static decodeNonceAuthorize(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
    const { authorized: t } = tr(Er.AuthorizeNonceAccount, e.data);
    return {
      noncePubkey: e.keys[0].pubkey,
      authorizedPubkey: e.keys[1].pubkey,
      newAuthorizedPubkey: new Xe(t),
    };
  }
  static checkProgramId(e) {
    if (!e.equals(si.programId))
      throw new Error('invalid instruction; programId is not SystemProgram');
  }
  static checkKeyLength(e, t) {
    if (e.length < t)
      throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`);
  }
}
const Er = Object.freeze({
  Create: {
    index: 0,
    layout: We([qe('instruction'), Ir('lamports'), Ir('space'), xt('programId')]),
  },
  Assign: { index: 1, layout: We([qe('instruction'), xt('programId')]) },
  Transfer: { index: 2, layout: We([qe('instruction'), La('lamports')]) },
  CreateWithSeed: {
    index: 3,
    layout: We([
      qe('instruction'),
      xt('base'),
      ns('seed'),
      Ir('lamports'),
      Ir('space'),
      xt('programId'),
    ]),
  },
  AdvanceNonceAccount: { index: 4, layout: We([qe('instruction')]) },
  WithdrawNonceAccount: { index: 5, layout: We([qe('instruction'), Ir('lamports')]) },
  InitializeNonceAccount: { index: 6, layout: We([qe('instruction'), xt('authorized')]) },
  AuthorizeNonceAccount: { index: 7, layout: We([qe('instruction'), xt('authorized')]) },
  Allocate: { index: 8, layout: We([qe('instruction'), Ir('space')]) },
  AllocateWithSeed: {
    index: 9,
    layout: We([qe('instruction'), xt('base'), ns('seed'), Ir('space'), xt('programId')]),
  },
  AssignWithSeed: {
    index: 10,
    layout: We([qe('instruction'), xt('base'), ns('seed'), xt('programId')]),
  },
  TransferWithSeed: {
    index: 11,
    layout: We([qe('instruction'), La('lamports'), ns('seed'), xt('programId')]),
  },
  UpgradeNonceAccount: { index: 12, layout: We([qe('instruction')]) },
});
class si {
  constructor() {}
  static createAccount(e) {
    const t = Er.Create,
      r = Dt(t, { lamports: e.lamports, space: e.space, programId: Mt(e.programId.toBuffer()) });
    return new Mr({
      keys: [
        { pubkey: e.fromPubkey, isSigner: !0, isWritable: !0 },
        { pubkey: e.newAccountPubkey, isSigner: !0, isWritable: !0 },
      ],
      programId: this.programId,
      data: r,
    });
  }
  static transfer(e) {
    let t, r;
    if ('basePubkey' in e) {
      const s = Er.TransferWithSeed;
      (t = Dt(s, {
        lamports: BigInt(e.lamports),
        seed: e.seed,
        programId: Mt(e.programId.toBuffer()),
      })),
        (r = [
          { pubkey: e.fromPubkey, isSigner: !1, isWritable: !0 },
          { pubkey: e.basePubkey, isSigner: !0, isWritable: !1 },
          { pubkey: e.toPubkey, isSigner: !1, isWritable: !0 },
        ]);
    } else {
      const s = Er.Transfer;
      (t = Dt(s, { lamports: BigInt(e.lamports) })),
        (r = [
          { pubkey: e.fromPubkey, isSigner: !0, isWritable: !0 },
          { pubkey: e.toPubkey, isSigner: !1, isWritable: !0 },
        ]);
    }
    return new Mr({ keys: r, programId: this.programId, data: t });
  }
  static assign(e) {
    let t, r;
    if ('basePubkey' in e) {
      const s = Er.AssignWithSeed;
      (t = Dt(s, {
        base: Mt(e.basePubkey.toBuffer()),
        seed: e.seed,
        programId: Mt(e.programId.toBuffer()),
      })),
        (r = [
          { pubkey: e.accountPubkey, isSigner: !1, isWritable: !0 },
          { pubkey: e.basePubkey, isSigner: !0, isWritable: !1 },
        ]);
    } else {
      const s = Er.Assign;
      (t = Dt(s, { programId: Mt(e.programId.toBuffer()) })),
        (r = [{ pubkey: e.accountPubkey, isSigner: !0, isWritable: !0 }]);
    }
    return new Mr({ keys: r, programId: this.programId, data: t });
  }
  static createAccountWithSeed(e) {
    const t = Er.CreateWithSeed,
      r = Dt(t, {
        base: Mt(e.basePubkey.toBuffer()),
        seed: e.seed,
        lamports: e.lamports,
        space: e.space,
        programId: Mt(e.programId.toBuffer()),
      });
    let s = [
      { pubkey: e.fromPubkey, isSigner: !0, isWritable: !0 },
      { pubkey: e.newAccountPubkey, isSigner: !1, isWritable: !0 },
    ];
    return (
      e.basePubkey != e.fromPubkey &&
        s.push({ pubkey: e.basePubkey, isSigner: !0, isWritable: !1 }),
      new Mr({ keys: s, programId: this.programId, data: r })
    );
  }
  static createNonceAccount(e) {
    const t = new rr();
    'basePubkey' in e && 'seed' in e
      ? t.add(
          si.createAccountWithSeed({
            fromPubkey: e.fromPubkey,
            newAccountPubkey: e.noncePubkey,
            basePubkey: e.basePubkey,
            seed: e.seed,
            lamports: e.lamports,
            space: T1,
            programId: this.programId,
          })
        )
      : t.add(
          si.createAccount({
            fromPubkey: e.fromPubkey,
            newAccountPubkey: e.noncePubkey,
            lamports: e.lamports,
            space: T1,
            programId: this.programId,
          })
        );
    const r = { noncePubkey: e.noncePubkey, authorizedPubkey: e.authorizedPubkey };
    return t.add(this.nonceInitialize(r)), t;
  }
  static nonceInitialize(e) {
    const t = Er.InitializeNonceAccount,
      r = Dt(t, { authorized: Mt(e.authorizedPubkey.toBuffer()) }),
      s = {
        keys: [
          { pubkey: e.noncePubkey, isSigner: !1, isWritable: !0 },
          { pubkey: Pf, isSigner: !1, isWritable: !1 },
          { pubkey: Ca, isSigner: !1, isWritable: !1 },
        ],
        programId: this.programId,
        data: r,
      };
    return new Mr(s);
  }
  static nonceAdvance(e) {
    const t = Er.AdvanceNonceAccount,
      r = Dt(t),
      s = {
        keys: [
          { pubkey: e.noncePubkey, isSigner: !1, isWritable: !0 },
          { pubkey: Pf, isSigner: !1, isWritable: !1 },
          { pubkey: e.authorizedPubkey, isSigner: !0, isWritable: !1 },
        ],
        programId: this.programId,
        data: r,
      };
    return new Mr(s);
  }
  static nonceWithdraw(e) {
    const t = Er.WithdrawNonceAccount,
      r = Dt(t, { lamports: e.lamports });
    return new Mr({
      keys: [
        { pubkey: e.noncePubkey, isSigner: !1, isWritable: !0 },
        { pubkey: e.toPubkey, isSigner: !1, isWritable: !0 },
        { pubkey: Pf, isSigner: !1, isWritable: !1 },
        { pubkey: Ca, isSigner: !1, isWritable: !1 },
        { pubkey: e.authorizedPubkey, isSigner: !0, isWritable: !1 },
      ],
      programId: this.programId,
      data: r,
    });
  }
  static nonceAuthorize(e) {
    const t = Er.AuthorizeNonceAccount,
      r = Dt(t, { authorized: Mt(e.newAuthorizedPubkey.toBuffer()) });
    return new Mr({
      keys: [
        { pubkey: e.noncePubkey, isSigner: !1, isWritable: !0 },
        { pubkey: e.authorizedPubkey, isSigner: !0, isWritable: !1 },
      ],
      programId: this.programId,
      data: r,
    });
  }
  static allocate(e) {
    let t, r;
    if ('basePubkey' in e) {
      const s = Er.AllocateWithSeed;
      (t = Dt(s, {
        base: Mt(e.basePubkey.toBuffer()),
        seed: e.seed,
        space: e.space,
        programId: Mt(e.programId.toBuffer()),
      })),
        (r = [
          { pubkey: e.accountPubkey, isSigner: !1, isWritable: !0 },
          { pubkey: e.basePubkey, isSigner: !0, isWritable: !1 },
        ]);
    } else {
      const s = Er.Allocate;
      (t = Dt(s, { space: e.space })),
        (r = [{ pubkey: e.accountPubkey, isSigner: !0, isWritable: !0 }]);
    }
    return new Mr({ keys: r, programId: this.programId, data: t });
  }
}
si.programId = new Xe('11111111111111111111111111111111');
const oN = Lo - 300;
class Es {
  constructor() {}
  static getMinNumSignatures(e) {
    return 2 * (Math.ceil(e / Es.chunkSize) + 1 + 1);
  }
  static async load(e, t, r, s, n) {
    {
      const m = await e.getMinimumBalanceForRentExemption(n.length),
        _ = await e.getAccountInfo(r.publicKey, 'confirmed');
      let A = null;
      if (_ !== null) {
        if (_.executable)
          return console.error('Program load failed, account is already executable'), !1;
        _.data.length !== n.length &&
          ((A = A || new rr()),
          A.add(si.allocate({ accountPubkey: r.publicKey, space: n.length }))),
          _.owner.equals(s) ||
            ((A = A || new rr()), A.add(si.assign({ accountPubkey: r.publicKey, programId: s }))),
          _.lamports < m &&
            ((A = A || new rr()),
            A.add(
              si.transfer({
                fromPubkey: t.publicKey,
                toPubkey: r.publicKey,
                lamports: m - _.lamports,
              })
            ));
      } else
        A = new rr().add(
          si.createAccount({
            fromPubkey: t.publicKey,
            newAccountPubkey: r.publicKey,
            lamports: m > 0 ? m : 1,
            space: n.length,
            programId: s,
          })
        );
      A !== null && (await Of(e, A, [t, r], { commitment: 'confirmed' }));
    }
    const c = We([
        qe('instruction'),
        qe('offset'),
        qe('bytesLength'),
        qe('bytesLengthPadding'),
        zt(tt('byte'), _i(qe(), -8), 'bytes'),
      ]),
      f = Es.chunkSize;
    let h = 0,
      y = n,
      p = [];
    for (; y.length > 0; ) {
      const m = y.slice(0, f),
        _ = He.alloc(f + 16);
      c.encode({ instruction: 0, offset: h, bytes: m, bytesLength: 0, bytesLengthPadding: 0 }, _);
      const A = new rr().add({
        keys: [{ pubkey: r.publicKey, isSigner: !0, isWritable: !0 }],
        programId: s,
        data: _,
      });
      p.push(Of(e, A, [t, r], { commitment: 'confirmed' })),
        e._rpcEndpoint.includes('solana.com') && (await ts(1e3 / 4)),
        (h += f),
        (y = y.slice(f));
    }
    await Promise.all(p);
    {
      const m = We([qe('instruction')]),
        _ = He.alloc(m.span);
      m.encode({ instruction: 1 }, _);
      const A = new rr().add({
        keys: [
          { pubkey: r.publicKey, isSigner: !0, isWritable: !0 },
          { pubkey: Ca, isSigner: !1, isWritable: !1 },
        ],
        programId: s,
        data: _,
      });
      await Of(e, A, [t, r], { commitment: 'confirmed' });
    }
    return !0;
  }
}
Es.chunkSize = oN;
const sN = new Xe('BPFLoader2111111111111111111111111111111111');
class aN {
  static getMinNumSignatures(e) {
    return Es.getMinNumSignatures(e);
  }
  static load(e, t, r, s, n) {
    return Es.load(e, t, r, n, s);
  }
}
var uN = Object.prototype.toString,
  cN =
    Object.keys ||
    function (i) {
      var e = [];
      for (var t in i) e.push(t);
      return e;
    };
function vu(i, e) {
  var t, r, s, n, c, f, h;
  if (i === !0) return 'true';
  if (i === !1) return 'false';
  switch (typeof i) {
    case 'object':
      if (i === null) return null;
      if (i.toJSON && typeof i.toJSON == 'function') return vu(i.toJSON(), e);
      if (((h = uN.call(i)), h === '[object Array]')) {
        for (s = '[', r = i.length - 1, t = 0; t < r; t++) s += vu(i[t], !0) + ',';
        return r > -1 && (s += vu(i[t], !0)), s + ']';
      } else if (h === '[object Object]') {
        for (n = cN(i).sort(), r = n.length, s = '', t = 0; t < r; )
          (c = n[t]),
            (f = vu(i[c], !1)),
            f !== void 0 && (s && (s += ','), (s += JSON.stringify(c) + ':' + f)),
            t++;
        return '{' + s + '}';
      } else return JSON.stringify(i);
    case 'function':
    case 'undefined':
      return e ? null : void 0;
    case 'string':
      return JSON.stringify(i);
    default:
      return isFinite(i) ? i : null;
  }
}
var fN = function (i) {
    var e = vu(i, !1);
    if (e !== void 0) return '' + e;
  },
  Zw = fN;
const yu = 32;
function Ep(i) {
  let e = 0;
  for (; i > 1; ) (i /= 2), e++;
  return e;
}
function lN(i) {
  return i === 0
    ? 1
    : (i--,
      (i |= i >> 1),
      (i |= i >> 2),
      (i |= i >> 4),
      (i |= i >> 8),
      (i |= i >> 16),
      (i |= i >> 32),
      i + 1);
}
class OS {
  constructor(e, t, r, s, n) {
    (this.slotsPerEpoch = void 0),
      (this.leaderScheduleSlotOffset = void 0),
      (this.warmup = void 0),
      (this.firstNormalEpoch = void 0),
      (this.firstNormalSlot = void 0),
      (this.slotsPerEpoch = e),
      (this.leaderScheduleSlotOffset = t),
      (this.warmup = r),
      (this.firstNormalEpoch = s),
      (this.firstNormalSlot = n);
  }
  getEpoch(e) {
    return this.getEpochAndSlotIndex(e)[0];
  }
  getEpochAndSlotIndex(e) {
    if (e < this.firstNormalSlot) {
      const t = Ep(lN(e + yu + 1)) - Ep(yu) - 1,
        r = this.getSlotsInEpoch(t),
        s = e - (r - yu);
      return [t, s];
    } else {
      const t = e - this.firstNormalSlot,
        r = Math.floor(t / this.slotsPerEpoch),
        s = this.firstNormalEpoch + r,
        n = t % this.slotsPerEpoch;
      return [s, n];
    }
  }
  getFirstSlotInEpoch(e) {
    return e <= this.firstNormalEpoch
      ? (Math.pow(2, e) - 1) * yu
      : (e - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;
  }
  getLastSlotInEpoch(e) {
    return this.getFirstSlotInEpoch(e) + this.getSlotsInEpoch(e) - 1;
  }
  getSlotsInEpoch(e) {
    return e < this.firstNormalEpoch ? Math.pow(2, e + Ep(yu)) : this.slotsPerEpoch;
  }
}
class O1 extends Error {
  constructor(e, t) {
    super(e), (this.logs = void 0), (this.logs = t);
  }
}
const hN = {
  JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
  JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,
  JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
  JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
  JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,
  JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
  JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
  JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
  JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
  JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
  JSON_RPC_SCAN_ERROR: -32012,
  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
  JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
  JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
  JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016,
};
class ot extends Error {
  constructor({ code: e, message: t, data: r }, s) {
    super(s != null ? `${s}: ${t}` : t),
      (this.code = void 0),
      (this.data = void 0),
      (this.code = e),
      (this.data = r),
      (this.name = 'SolanaJSONRPCError');
  }
}
var dN = globalThis.fetch;
class pN extends U3 {
  constructor(e, t, r) {
    const s = (n) => {
      const c = F3(n, {
        autoconnect: !0,
        max_reconnects: 5,
        reconnect: !0,
        reconnect_interval: 1e3,
        ...t,
      });
      return 'socket' in c ? (this.underlyingSocket = c.socket) : (this.underlyingSocket = c), c;
    };
    super(s, e, t, r), (this.underlyingSocket = void 0);
  }
  call(...e) {
    var r;
    const t = (r = this.underlyingSocket) == null ? void 0 : r.readyState;
    return t === 1
      ? super.call(...e)
      : Promise.reject(
          new Error(
            'Tried to call a JSON-RPC method `' +
              e[0] +
              '` but the socket was not `CONNECTING` or `OPEN` (`readyState` was ' +
              t +
              ')'
          )
        );
  }
  notify(...e) {
    var r;
    const t = (r = this.underlyingSocket) == null ? void 0 : r.readyState;
    return t === 1
      ? super.notify(...e)
      : Promise.reject(
          new Error(
            'Tried to send a JSON-RPC notification `' +
              e[0] +
              '` but the socket was not `CONNECTING` or `OPEN` (`readyState` was ' +
              t +
              ')'
          )
        );
  }
}
const yN = 160,
  gN = 64,
  bN = yN / gN,
  vN = 1e3 / bN;
function mN(i, e) {
  let t;
  try {
    t = i.layout.decode(e);
  } catch (r) {
    throw new Error('invalid instruction; ' + r);
  }
  if (t.typeIndex !== i.index)
    throw new Error(`invalid account data; account type mismatch ${t.typeIndex} != ${i.index}`);
  return t;
}
const Jw = 56;
class C1 {
  constructor(e) {
    (this.key = void 0), (this.state = void 0), (this.key = e.key), (this.state = e.state);
  }
  isActive() {
    const e = BigInt('0xffffffffffffffff');
    return this.state.deactivationSlot === e;
  }
  static deserialize(e) {
    const t = mN(wN, e),
      r = e.length - Jw;
    Gt(r >= 0, 'lookup table is invalid'), Gt(r % 32 === 0, 'lookup table is invalid');
    const s = r / 32,
      { addresses: n } = We([zt(xt(), s, 'addresses')]).decode(e.slice(Jw));
    return {
      deactivationSlot: t.deactivationSlot,
      lastExtendedSlot: t.lastExtendedSlot,
      lastExtendedSlotStartIndex: t.lastExtendedStartIndex,
      authority: t.authority.length !== 0 ? new Xe(t.authority[0]) : void 0,
      addresses: n.map((c) => new Xe(c)),
    };
  }
}
const wN = {
    index: 1,
    layout: We([
      qe('typeIndex'),
      La('deactivationSlot'),
      Nt('lastExtendedSlot'),
      tt('lastExtendedStartIndex'),
      tt(),
      zt(xt(), _i(tt(), -1), 'authority'),
    ]),
  },
  _N = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
function SN(i) {
  const e = i.match(_N);
  if (e == null) throw TypeError(`Failed to validate endpoint URL \`${i}\``);
  const [t, r, s, n] = e,
    c = i.startsWith('https:') ? 'wss:' : 'ws:',
    f = s == null ? null : parseInt(s.slice(1), 10),
    h = f == null ? '' : `:${f + 1}`;
  return `${c}//${r}${h}${n}`;
}
const Fr = Kn(Za(Xe), we(), (i) => new Xe(i)),
  CS = Ja([we(), ft('base64')]),
  cg = Kn(Za(He), CS, (i) => He.from(i[0], 'base64')),
  LS = 30 * 1e3;
function MN(i) {
  if (/^https?:/.test(i) === !1)
    throw new TypeError('Endpoint URL must start with `http:` or `https:`.');
  return i;
}
function Pr(i) {
  let e, t;
  if (typeof i == 'string') e = i;
  else if (i) {
    const { commitment: r, ...s } = i;
    (e = r), (t = s);
  }
  return { commitment: e, config: t };
}
function NS(i) {
  return ar([
    pe({ jsonrpc: ft('2.0'), id: we(), result: i }),
    pe({ jsonrpc: ft('2.0'), id: we(), error: pe({ code: Wn(), message: we(), data: Ge(I3()) }) }),
  ]);
}
const AN = NS(Wn());
function kt(i) {
  return Kn(NS(i), AN, (e) => ('error' in e ? e : { ...e, result: Se(e.result, i) }));
}
function Dr(i) {
  return kt(pe({ context: pe({ slot: ee() }), value: i }));
}
function sh(i) {
  return pe({ context: pe({ slot: ee() }), value: i });
}
function kp(i, e) {
  return i === 0
    ? new As({
        header: e.header,
        staticAccountKeys: e.accountKeys.map((t) => new Xe(t)),
        recentBlockhash: e.recentBlockhash,
        compiledInstructions: e.instructions.map((t) => ({
          programIdIndex: t.programIdIndex,
          accountKeyIndexes: t.accounts,
          data: ii.decode(t.data),
        })),
        addressTableLookups: e.addressTableLookups,
      })
    : new dn(e);
}
const EN = pe({
    foundation: ee(),
    foundationTerm: ee(),
    initial: ee(),
    taper: ee(),
    terminal: ee(),
  }),
  kN = kt(
    Te(
      Pe(
        pe({
          epoch: ee(),
          effectiveSlot: ee(),
          amount: ee(),
          postBalance: ee(),
          commission: Ge(Pe(ee())),
        })
      )
    )
  ),
  IN = pe({ total: ee(), validator: ee(), foundation: ee(), epoch: ee() }),
  xN = pe({
    epoch: ee(),
    slotIndex: ee(),
    slotsInEpoch: ee(),
    absoluteSlot: ee(),
    blockHeight: Ge(ee()),
    transactionCount: Ge(ee()),
  }),
  BN = pe({
    slotsPerEpoch: ee(),
    leaderScheduleSlotOffset: ee(),
    warmup: Xr(),
    firstNormalEpoch: ee(),
    firstNormalSlot: ee(),
  }),
  RN = Wl(we(), Te(ee())),
  Ns = Pe(ar([pe({}), we()])),
  PN = pe({ err: Ns }),
  TN = ft('receivedSignature'),
  ON = pe({ 'solana-core': we(), 'feature-set': Ge(ee()) }),
  Xw = Dr(
    pe({
      err: Pe(ar([pe({}), we()])),
      logs: Pe(Te(we())),
      accounts: Ge(
        Pe(
          Te(
            Pe(
              pe({
                executable: Xr(),
                owner: we(),
                lamports: ee(),
                data: Te(we()),
                rentEpoch: Ge(ee()),
              })
            )
          )
        )
      ),
      unitsConsumed: Ge(ee()),
      returnData: Ge(Pe(pe({ programId: we(), data: Ja([we(), ft('base64')]) }))),
    })
  ),
  CN = Dr(pe({ byIdentity: Wl(we(), Te(ee())), range: pe({ firstSlot: ee(), lastSlot: ee() }) }));
function LN(i, e, t, r, s, n) {
  const c = t || dN;
  let f;
  n != null &&
    console.warn(
      'You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.'
    );
  let h;
  return (
    r &&
      (h = async (p, m) => {
        const _ = await new Promise((A, E) => {
          try {
            r(p, m, (I, R) => A([I, R]));
          } catch (I) {
            E(I);
          }
        });
        return await c(..._);
      }),
    new B3(async (p, m) => {
      const _ = {
        method: 'POST',
        body: p,
        agent: f,
        headers: Object.assign({ 'Content-Type': 'application/json' }, e || {}, C$),
      };
      try {
        let A = 5,
          E,
          I = 500;
        for (
          ;
          h ? (E = await h(i, _)) : (E = await c(i, _)),
            !(E.status !== 429 || s === !0 || ((A -= 1), A === 0));

        )
          console.log(
            `Server responded with ${E.status} ${E.statusText}.  Retrying after ${I}ms delay...`
          ),
            await ts(I),
            (I *= 2);
        const R = await E.text();
        E.ok ? m(null, R) : m(new Error(`${E.status} ${E.statusText}: ${R}`));
      } catch (A) {
        A instanceof Error && m(A);
      }
    }, {})
  );
}
function NN(i) {
  return (e, t) =>
    new Promise((r, s) => {
      i.request(e, t, (n, c) => {
        if (n) {
          s(n);
          return;
        }
        r(c);
      });
    });
}
function $N(i) {
  return (e) =>
    new Promise((t, r) => {
      e.length === 0 && t([]);
      const s = e.map((n) => i.request(n.methodName, n.args));
      i.request(s, (n, c) => {
        if (n) {
          r(n);
          return;
        }
        t(c);
      });
    });
}
const DN = kt(EN),
  UN = kt(IN),
  zN = kt(xN),
  FN = kt(BN),
  qN = kt(RN),
  WN = kt(ee()),
  KN = Dr(
    pe({ total: ee(), circulating: ee(), nonCirculating: ee(), nonCirculatingAccounts: Te(Fr) })
  ),
  L1 = pe({ amount: we(), uiAmount: Pe(ee()), decimals: ee(), uiAmountString: Ge(we()) }),
  jN = Dr(
    Te(
      pe({
        address: Fr,
        amount: we(),
        uiAmount: Pe(ee()),
        decimals: ee(),
        uiAmountString: Ge(we()),
      })
    )
  ),
  HN = Dr(
    Te(
      pe({
        pubkey: Fr,
        account: pe({ executable: Xr(), owner: Fr, lamports: ee(), data: cg, rentEpoch: ee() }),
      })
    )
  ),
  N1 = pe({ program: we(), parsed: Wn(), space: ee() }),
  VN = Dr(
    Te(
      pe({
        pubkey: Fr,
        account: pe({ executable: Xr(), owner: Fr, lamports: ee(), data: N1, rentEpoch: ee() }),
      })
    )
  ),
  GN = Dr(Te(pe({ lamports: ee(), address: Fr }))),
  Wu = pe({ executable: Xr(), owner: Fr, lamports: ee(), data: cg, rentEpoch: ee() }),
  YN = pe({ pubkey: Fr, account: Wu }),
  ZN = Kn(ar([Za(He), N1]), ar([CS, N1]), (i) => (Array.isArray(i) ? Se(i, cg) : i)),
  $1 = pe({ executable: Xr(), owner: Fr, lamports: ee(), data: ZN, rentEpoch: ee() }),
  JN = pe({ pubkey: Fr, account: $1 }),
  XN = pe({
    state: ar([ft('active'), ft('inactive'), ft('activating'), ft('deactivating')]),
    active: ee(),
    inactive: ee(),
  }),
  QN = kt(
    Te(pe({ signature: we(), slot: ee(), err: Ns, memo: Pe(we()), blockTime: Ge(Pe(ee())) }))
  ),
  e$ = kt(
    Te(pe({ signature: we(), slot: ee(), err: Ns, memo: Pe(we()), blockTime: Ge(Pe(ee())) }))
  ),
  t$ = pe({ subscription: ee(), result: sh(Wu) }),
  r$ = pe({ pubkey: Fr, account: Wu }),
  i$ = pe({ subscription: ee(), result: sh(r$) }),
  n$ = pe({ parent: ee(), slot: ee(), root: ee() }),
  o$ = pe({ subscription: ee(), result: n$ }),
  s$ = ar([
    pe({
      type: ar([
        ft('firstShredReceived'),
        ft('completed'),
        ft('optimisticConfirmation'),
        ft('root'),
      ]),
      slot: ee(),
      timestamp: ee(),
    }),
    pe({ type: ft('createdBank'), parent: ee(), slot: ee(), timestamp: ee() }),
    pe({
      type: ft('frozen'),
      slot: ee(),
      timestamp: ee(),
      stats: pe({
        numTransactionEntries: ee(),
        numSuccessfulTransactions: ee(),
        numFailedTransactions: ee(),
        maxTransactionsPerEntry: ee(),
      }),
    }),
    pe({ type: ft('dead'), slot: ee(), timestamp: ee(), err: we() }),
  ]),
  a$ = pe({ subscription: ee(), result: s$ }),
  u$ = pe({ subscription: ee(), result: sh(ar([PN, TN])) }),
  c$ = pe({ subscription: ee(), result: ee() }),
  f$ = pe({ pubkey: we(), gossip: Pe(we()), tpu: Pe(we()), rpc: Pe(we()), version: Pe(we()) }),
  Qw = pe({
    votePubkey: we(),
    nodePubkey: we(),
    activatedStake: ee(),
    epochVoteAccount: Xr(),
    epochCredits: Te(Ja([ee(), ee(), ee()])),
    commission: ee(),
    lastVote: ee(),
    rootSlot: Pe(ee()),
  }),
  l$ = kt(pe({ current: Te(Qw), delinquent: Te(Qw) })),
  h$ = ar([ft('processed'), ft('confirmed'), ft('finalized')]),
  d$ = pe({ slot: ee(), confirmations: Pe(ee()), err: Ns, confirmationStatus: Ge(h$) }),
  p$ = Dr(Te(Pe(d$))),
  y$ = kt(ee()),
  $S = pe({ accountKey: Fr, writableIndexes: Te(ee()), readonlyIndexes: Te(ee()) }),
  fg = pe({
    signatures: Te(we()),
    message: pe({
      accountKeys: Te(we()),
      header: pe({
        numRequiredSignatures: ee(),
        numReadonlySignedAccounts: ee(),
        numReadonlyUnsignedAccounts: ee(),
      }),
      instructions: Te(pe({ accounts: Te(ee()), data: we(), programIdIndex: ee() })),
      recentBlockhash: we(),
      addressTableLookups: Ge(Te($S)),
    }),
  }),
  DS = pe({
    pubkey: Fr,
    signer: Xr(),
    writable: Xr(),
    source: Ge(ar([ft('transaction'), ft('lookupTable')])),
  }),
  US = pe({ accountKeys: Te(DS), signatures: Te(we()) }),
  zS = pe({ parsed: Wn(), program: we(), programId: Fr }),
  FS = pe({ accounts: Te(Fr), data: we(), programId: Fr }),
  g$ = ar([FS, zS]),
  b$ = ar([
    pe({ parsed: Wn(), program: we(), programId: we() }),
    pe({ accounts: Te(we()), data: we(), programId: we() }),
  ]),
  qS = Kn(g$, b$, (i) => ('accounts' in i ? Se(i, FS) : Se(i, zS))),
  WS = pe({
    signatures: Te(we()),
    message: pe({
      accountKeys: Te(DS),
      instructions: Te(qS),
      recentBlockhash: we(),
      addressTableLookups: Ge(Pe(Te($S))),
    }),
  }),
  cl = pe({ accountIndex: ee(), mint: we(), owner: Ge(we()), uiTokenAmount: L1 }),
  KS = pe({ writable: Te(Fr), readonly: Te(Fr) }),
  ah = pe({
    err: Ns,
    fee: ee(),
    innerInstructions: Ge(
      Pe(
        Te(
          pe({
            index: ee(),
            instructions: Te(pe({ accounts: Te(ee()), data: we(), programIdIndex: ee() })),
          })
        )
      )
    ),
    preBalances: Te(ee()),
    postBalances: Te(ee()),
    logMessages: Ge(Pe(Te(we()))),
    preTokenBalances: Ge(Pe(Te(cl))),
    postTokenBalances: Ge(Pe(Te(cl))),
    loadedAddresses: Ge(KS),
    computeUnitsConsumed: Ge(ee()),
  }),
  lg = pe({
    err: Ns,
    fee: ee(),
    innerInstructions: Ge(Pe(Te(pe({ index: ee(), instructions: Te(qS) })))),
    preBalances: Te(ee()),
    postBalances: Te(ee()),
    logMessages: Ge(Pe(Te(we()))),
    preTokenBalances: Ge(Pe(Te(cl))),
    postTokenBalances: Ge(Pe(Te(cl))),
    loadedAddresses: Ge(KS),
    computeUnitsConsumed: Ge(ee()),
  }),
  Qa = ar([ft(0), ft('legacy')]),
  $s = pe({
    pubkey: we(),
    lamports: ee(),
    postBalance: Pe(ee()),
    rewardType: Pe(we()),
    commission: Ge(Pe(ee())),
  }),
  v$ = kt(
    Pe(
      pe({
        blockhash: we(),
        previousBlockhash: we(),
        parentSlot: ee(),
        transactions: Te(pe({ transaction: fg, meta: Pe(ah), version: Ge(Qa) })),
        rewards: Ge(Te($s)),
        blockTime: Pe(ee()),
        blockHeight: Pe(ee()),
      })
    )
  ),
  m$ = kt(
    Pe(
      pe({
        blockhash: we(),
        previousBlockhash: we(),
        parentSlot: ee(),
        rewards: Ge(Te($s)),
        blockTime: Pe(ee()),
        blockHeight: Pe(ee()),
      })
    )
  ),
  w$ = kt(
    Pe(
      pe({
        blockhash: we(),
        previousBlockhash: we(),
        parentSlot: ee(),
        transactions: Te(pe({ transaction: US, meta: Pe(ah), version: Ge(Qa) })),
        rewards: Ge(Te($s)),
        blockTime: Pe(ee()),
        blockHeight: Pe(ee()),
      })
    )
  ),
  _$ = kt(
    Pe(
      pe({
        blockhash: we(),
        previousBlockhash: we(),
        parentSlot: ee(),
        transactions: Te(pe({ transaction: WS, meta: Pe(lg), version: Ge(Qa) })),
        rewards: Ge(Te($s)),
        blockTime: Pe(ee()),
        blockHeight: Pe(ee()),
      })
    )
  ),
  S$ = kt(
    Pe(
      pe({
        blockhash: we(),
        previousBlockhash: we(),
        parentSlot: ee(),
        transactions: Te(pe({ transaction: US, meta: Pe(lg), version: Ge(Qa) })),
        rewards: Ge(Te($s)),
        blockTime: Pe(ee()),
        blockHeight: Pe(ee()),
      })
    )
  ),
  M$ = kt(
    Pe(
      pe({
        blockhash: we(),
        previousBlockhash: we(),
        parentSlot: ee(),
        rewards: Ge(Te($s)),
        blockTime: Pe(ee()),
        blockHeight: Pe(ee()),
      })
    )
  ),
  A$ = kt(
    Pe(
      pe({
        blockhash: we(),
        previousBlockhash: we(),
        parentSlot: ee(),
        transactions: Te(pe({ transaction: fg, meta: Pe(ah) })),
        rewards: Ge(Te($s)),
        blockTime: Pe(ee()),
      })
    )
  ),
  e2 = kt(
    Pe(
      pe({
        blockhash: we(),
        previousBlockhash: we(),
        parentSlot: ee(),
        signatures: Te(we()),
        blockTime: Pe(ee()),
      })
    )
  ),
  Ip = kt(
    Pe(pe({ slot: ee(), meta: ah, blockTime: Ge(Pe(ee())), transaction: fg, version: Ge(Qa) }))
  ),
  ff = kt(
    Pe(pe({ slot: ee(), transaction: WS, meta: Pe(lg), blockTime: Ge(Pe(ee())), version: Ge(Qa) }))
  ),
  E$ = Dr(pe({ blockhash: we(), feeCalculator: pe({ lamportsPerSignature: ee() }) })),
  k$ = Dr(pe({ blockhash: we(), lastValidBlockHeight: ee() })),
  I$ = pe({ slot: ee(), numTransactions: ee(), numSlots: ee(), samplePeriodSecs: ee() }),
  x$ = kt(Te(I$)),
  B$ = Dr(Pe(pe({ feeCalculator: pe({ lamportsPerSignature: ee() }) }))),
  R$ = kt(we()),
  P$ = kt(we()),
  T$ = pe({ err: Ns, logs: Te(we()), signature: we() }),
  O$ = pe({ result: sh(T$), subscription: ee() }),
  C$ = { 'solana-client': 'js/0.0.0-development' };
class L$ {
  constructor(e, t) {
    (this._commitment = void 0),
      (this._confirmTransactionInitialTimeout = void 0),
      (this._rpcEndpoint = void 0),
      (this._rpcWsEndpoint = void 0),
      (this._rpcClient = void 0),
      (this._rpcRequest = void 0),
      (this._rpcBatchRequest = void 0),
      (this._rpcWebSocket = void 0),
      (this._rpcWebSocketConnected = !1),
      (this._rpcWebSocketHeartbeat = null),
      (this._rpcWebSocketIdleTimeout = null),
      (this._rpcWebSocketGeneration = 0),
      (this._disableBlockhashCaching = !1),
      (this._pollingBlockhash = !1),
      (this._blockhashInfo = {
        latestBlockhash: null,
        lastFetch: 0,
        transactionSignatures: [],
        simulatedSignatures: [],
      }),
      (this._nextClientSubscriptionId = 0),
      (this._subscriptionDisposeFunctionsByClientSubscriptionId = {}),
      (this._subscriptionHashByClientSubscriptionId = {}),
      (this._subscriptionStateChangeCallbacksByHash = {}),
      (this._subscriptionCallbacksByServerSubscriptionId = {}),
      (this._subscriptionsByHash = {}),
      (this._subscriptionsAutoDisposedByRpc = new Set()),
      (this.getBlockHeight = (() => {
        const y = {};
        return async (p) => {
          const { commitment: m, config: _ } = Pr(p),
            A = this._buildArgs([], m, void 0, _),
            E = Zw(A);
          return (
            (y[E] =
              y[E] ??
              (async () => {
                try {
                  const I = await this._rpcRequest('getBlockHeight', A),
                    R = Se(I, kt(ee()));
                  if ('error' in R) throw new ot(R.error, 'failed to get block height information');
                  return R.result;
                } finally {
                  delete y[E];
                }
              })()),
            await y[E]
          );
        };
      })());
    let r, s, n, c, f, h;
    t && typeof t == 'string'
      ? (this._commitment = t)
      : t &&
        ((this._commitment = t.commitment),
        (this._confirmTransactionInitialTimeout = t.confirmTransactionInitialTimeout),
        (r = t.wsEndpoint),
        (s = t.httpHeaders),
        (n = t.fetch),
        (c = t.fetchMiddleware),
        (f = t.disableRetryOnRateLimit),
        (h = t.httpAgent)),
      (this._rpcEndpoint = MN(e)),
      (this._rpcWsEndpoint = r || SN(e)),
      (this._rpcClient = LN(e, s, n, c, f, h)),
      (this._rpcRequest = NN(this._rpcClient)),
      (this._rpcBatchRequest = $N(this._rpcClient)),
      (this._rpcWebSocket = new pN(this._rpcWsEndpoint, {
        autoconnect: !1,
        max_reconnects: 1 / 0,
      })),
      this._rpcWebSocket.on('open', this._wsOnOpen.bind(this)),
      this._rpcWebSocket.on('error', this._wsOnError.bind(this)),
      this._rpcWebSocket.on('close', this._wsOnClose.bind(this)),
      this._rpcWebSocket.on('accountNotification', this._wsOnAccountNotification.bind(this)),
      this._rpcWebSocket.on('programNotification', this._wsOnProgramAccountNotification.bind(this)),
      this._rpcWebSocket.on('slotNotification', this._wsOnSlotNotification.bind(this)),
      this._rpcWebSocket.on(
        'slotsUpdatesNotification',
        this._wsOnSlotUpdatesNotification.bind(this)
      ),
      this._rpcWebSocket.on('signatureNotification', this._wsOnSignatureNotification.bind(this)),
      this._rpcWebSocket.on('rootNotification', this._wsOnRootNotification.bind(this)),
      this._rpcWebSocket.on('logsNotification', this._wsOnLogsNotification.bind(this));
  }
  get commitment() {
    return this._commitment;
  }
  get rpcEndpoint() {
    return this._rpcEndpoint;
  }
  async getBalanceAndContext(e, t) {
    const { commitment: r, config: s } = Pr(t),
      n = this._buildArgs([e.toBase58()], r, void 0, s),
      c = await this._rpcRequest('getBalance', n),
      f = Se(c, Dr(ee()));
    if ('error' in f) throw new ot(f.error, `failed to get balance for ${e.toBase58()}`);
    return f.result;
  }
  async getBalance(e, t) {
    return await this.getBalanceAndContext(e, t)
      .then((r) => r.value)
      .catch((r) => {
        throw new Error('failed to get balance of account ' + e.toBase58() + ': ' + r);
      });
  }
  async getBlockTime(e) {
    const t = await this._rpcRequest('getBlockTime', [e]),
      r = Se(t, kt(Pe(ee())));
    if ('error' in r) throw new ot(r.error, `failed to get block time for slot ${e}`);
    return r.result;
  }
  async getMinimumLedgerSlot() {
    const e = await this._rpcRequest('minimumLedgerSlot', []),
      t = Se(e, kt(ee()));
    if ('error' in t) throw new ot(t.error, 'failed to get minimum ledger slot');
    return t.result;
  }
  async getFirstAvailableBlock() {
    const e = await this._rpcRequest('getFirstAvailableBlock', []),
      t = Se(e, WN);
    if ('error' in t) throw new ot(t.error, 'failed to get first available block');
    return t.result;
  }
  async getSupply(e) {
    let t = {};
    typeof e == 'string'
      ? (t = { commitment: e })
      : e
        ? (t = { ...e, commitment: (e && e.commitment) || this.commitment })
        : (t = { commitment: this.commitment });
    const r = await this._rpcRequest('getSupply', [t]),
      s = Se(r, KN);
    if ('error' in s) throw new ot(s.error, 'failed to get supply');
    return s.result;
  }
  async getTokenSupply(e, t) {
    const r = this._buildArgs([e.toBase58()], t),
      s = await this._rpcRequest('getTokenSupply', r),
      n = Se(s, Dr(L1));
    if ('error' in n) throw new ot(n.error, 'failed to get token supply');
    return n.result;
  }
  async getTokenAccountBalance(e, t) {
    const r = this._buildArgs([e.toBase58()], t),
      s = await this._rpcRequest('getTokenAccountBalance', r),
      n = Se(s, Dr(L1));
    if ('error' in n) throw new ot(n.error, 'failed to get token account balance');
    return n.result;
  }
  async getTokenAccountsByOwner(e, t, r) {
    const { commitment: s, config: n } = Pr(r);
    let c = [e.toBase58()];
    'mint' in t
      ? c.push({ mint: t.mint.toBase58() })
      : c.push({ programId: t.programId.toBase58() });
    const f = this._buildArgs(c, s, 'base64', n),
      h = await this._rpcRequest('getTokenAccountsByOwner', f),
      y = Se(h, HN);
    if ('error' in y)
      throw new ot(y.error, `failed to get token accounts owned by account ${e.toBase58()}`);
    return y.result;
  }
  async getParsedTokenAccountsByOwner(e, t, r) {
    let s = [e.toBase58()];
    'mint' in t
      ? s.push({ mint: t.mint.toBase58() })
      : s.push({ programId: t.programId.toBase58() });
    const n = this._buildArgs(s, r, 'jsonParsed'),
      c = await this._rpcRequest('getTokenAccountsByOwner', n),
      f = Se(c, VN);
    if ('error' in f)
      throw new ot(f.error, `failed to get token accounts owned by account ${e.toBase58()}`);
    return f.result;
  }
  async getLargestAccounts(e) {
    const t = { ...e, commitment: (e && e.commitment) || this.commitment },
      r = t.filter || t.commitment ? [t] : [],
      s = await this._rpcRequest('getLargestAccounts', r),
      n = Se(s, GN);
    if ('error' in n) throw new ot(n.error, 'failed to get largest accounts');
    return n.result;
  }
  async getTokenLargestAccounts(e, t) {
    const r = this._buildArgs([e.toBase58()], t),
      s = await this._rpcRequest('getTokenLargestAccounts', r),
      n = Se(s, jN);
    if ('error' in n) throw new ot(n.error, 'failed to get token largest accounts');
    return n.result;
  }
  async getAccountInfoAndContext(e, t) {
    const { commitment: r, config: s } = Pr(t),
      n = this._buildArgs([e.toBase58()], r, 'base64', s),
      c = await this._rpcRequest('getAccountInfo', n),
      f = Se(c, Dr(Pe(Wu)));
    if ('error' in f) throw new ot(f.error, `failed to get info about account ${e.toBase58()}`);
    return f.result;
  }
  async getParsedAccountInfo(e, t) {
    const { commitment: r, config: s } = Pr(t),
      n = this._buildArgs([e.toBase58()], r, 'jsonParsed', s),
      c = await this._rpcRequest('getAccountInfo', n),
      f = Se(c, Dr(Pe($1)));
    if ('error' in f) throw new ot(f.error, `failed to get info about account ${e.toBase58()}`);
    return f.result;
  }
  async getAccountInfo(e, t) {
    try {
      return (await this.getAccountInfoAndContext(e, t)).value;
    } catch (r) {
      throw new Error('failed to get info about account ' + e.toBase58() + ': ' + r);
    }
  }
  async getMultipleParsedAccounts(e, t) {
    const { commitment: r, config: s } = Pr(t),
      n = e.map((y) => y.toBase58()),
      c = this._buildArgs([n], r, 'jsonParsed', s),
      f = await this._rpcRequest('getMultipleAccounts', c),
      h = Se(f, Dr(Te(Pe($1))));
    if ('error' in h) throw new ot(h.error, `failed to get info for accounts ${n}`);
    return h.result;
  }
  async getMultipleAccountsInfoAndContext(e, t) {
    const { commitment: r, config: s } = Pr(t),
      n = e.map((y) => y.toBase58()),
      c = this._buildArgs([n], r, 'base64', s),
      f = await this._rpcRequest('getMultipleAccounts', c),
      h = Se(f, Dr(Te(Pe(Wu))));
    if ('error' in h) throw new ot(h.error, `failed to get info for accounts ${n}`);
    return h.result;
  }
  async getMultipleAccountsInfo(e, t) {
    return (await this.getMultipleAccountsInfoAndContext(e, t)).value;
  }
  async getStakeActivation(e, t, r) {
    const { commitment: s, config: n } = Pr(t),
      c = this._buildArgs([e.toBase58()], s, void 0, {
        ...n,
        epoch: r ?? (n == null ? void 0 : n.epoch),
      }),
      f = await this._rpcRequest('getStakeActivation', c),
      h = Se(f, kt(XN));
    if ('error' in h) throw new ot(h.error, `failed to get Stake Activation ${e.toBase58()}`);
    return h.result;
  }
  async getProgramAccounts(e, t) {
    const { commitment: r, config: s } = Pr(t),
      { encoding: n, ...c } = s || {},
      f = this._buildArgs([e.toBase58()], r, n || 'base64', c),
      h = await this._rpcRequest('getProgramAccounts', f),
      y = Se(h, kt(Te(YN)));
    if ('error' in y)
      throw new ot(y.error, `failed to get accounts owned by program ${e.toBase58()}`);
    return y.result;
  }
  async getParsedProgramAccounts(e, t) {
    const { commitment: r, config: s } = Pr(t),
      n = this._buildArgs([e.toBase58()], r, 'jsonParsed', s),
      c = await this._rpcRequest('getProgramAccounts', n),
      f = Se(c, kt(Te(JN)));
    if ('error' in f)
      throw new ot(f.error, `failed to get accounts owned by program ${e.toBase58()}`);
    return f.result;
  }
  async confirmTransaction(e, t) {
    var n;
    let r;
    if (typeof e == 'string') r = e;
    else {
      const c = e;
      if ((n = c.abortSignal) != null && n.aborted) return Promise.reject(c.abortSignal.reason);
      r = c.signature;
    }
    let s;
    try {
      s = ii.decode(r);
    } catch {
      throw new Error('signature must be base58 encoded: ' + r);
    }
    return (
      Gt(s.length === 64, 'signature has invalid length'),
      typeof e == 'string'
        ? await this.confirmTransactionUsingLegacyTimeoutStrategy({
            commitment: t || this.commitment,
            signature: r,
          })
        : 'lastValidBlockHeight' in e
          ? await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
              commitment: t || this.commitment,
              strategy: e,
            })
          : await this.confirmTransactionUsingDurableNonceStrategy({
              commitment: t || this.commitment,
              strategy: e,
            })
    );
  }
  getCancellationPromise(e) {
    return new Promise((t, r) => {
      e != null &&
        (e.aborted
          ? r(e.reason)
          : e.addEventListener('abort', () => {
              r(e.reason);
            }));
    });
  }
  getTransactionConfirmationPromise({ commitment: e, signature: t }) {
    let r,
      s,
      n = !1;
    const c = new Promise((h, y) => {
      try {
        r = this.onSignature(
          t,
          (m, _) => {
            r = void 0;
            const A = { context: _, value: m };
            h({ __type: on.PROCESSED, response: A });
          },
          e
        );
        const p = new Promise((m) => {
          r == null
            ? m()
            : (s = this._onSubscriptionStateChange(r, (_) => {
                _ === 'subscribed' && m();
              }));
        });
        (async () => {
          if ((await p, n)) return;
          const m = await this.getSignatureStatus(t);
          if (n || m == null) return;
          const { context: _, value: A } = m;
          if (A != null)
            if (A != null && A.err) y(A.err);
            else {
              switch (e) {
                case 'confirmed':
                case 'single':
                case 'singleGossip': {
                  if (A.confirmationStatus === 'processed') return;
                  break;
                }
                case 'finalized':
                case 'max':
                case 'root': {
                  if (A.confirmationStatus === 'processed' || A.confirmationStatus === 'confirmed')
                    return;
                  break;
                }
                case 'processed':
                case 'recent':
              }
              (n = !0), h({ __type: on.PROCESSED, response: { context: _, value: A } });
            }
        })();
      } catch (p) {
        y(p);
      }
    });
    return {
      abortConfirmation: () => {
        s && (s(), (s = void 0)), r != null && (this.removeSignatureListener(r), (r = void 0));
      },
      confirmationPromise: c,
    };
  }
  async confirmTransactionUsingBlockHeightExceedanceStrategy({
    commitment: e,
    strategy: { abortSignal: t, lastValidBlockHeight: r, signature: s },
  }) {
    let n = !1;
    const c = new Promise((m) => {
        const _ = async () => {
          try {
            return await this.getBlockHeight(e);
          } catch {
            return -1;
          }
        };
        (async () => {
          let A = await _();
          if (!n) {
            for (; A <= r; ) if ((await ts(1e3), n || ((A = await _()), n))) return;
            m({ __type: on.BLOCKHEIGHT_EXCEEDED });
          }
        })();
      }),
      { abortConfirmation: f, confirmationPromise: h } = this.getTransactionConfirmationPromise({
        commitment: e,
        signature: s,
      }),
      y = this.getCancellationPromise(t);
    let p;
    try {
      const m = await Promise.race([y, h, c]);
      if (m.__type === on.PROCESSED) p = m.response;
      else throw new ng(s);
    } finally {
      (n = !0), f();
    }
    return p;
  }
  async confirmTransactionUsingDurableNonceStrategy({
    commitment: e,
    strategy: {
      abortSignal: t,
      minContextSlot: r,
      nonceAccountPubkey: s,
      nonceValue: n,
      signature: c,
    },
  }) {
    let f = !1;
    const h = new Promise((A) => {
        let E = n,
          I = null;
        const R = async () => {
          try {
            const { context: L, value: D } = await this.getNonceAndContext(s, {
              commitment: e,
              minContextSlot: r,
            });
            return (I = L.slot), D == null ? void 0 : D.nonce;
          } catch {
            return E;
          }
        };
        (async () => {
          if (((E = await R()), !f))
            for (;;) {
              if (n !== E) {
                A({ __type: on.NONCE_INVALID, slotInWhichNonceDidAdvance: I });
                return;
              }
              if ((await ts(2e3), f || ((E = await R()), f))) return;
            }
        })();
      }),
      { abortConfirmation: y, confirmationPromise: p } = this.getTransactionConfirmationPromise({
        commitment: e,
        signature: c,
      }),
      m = this.getCancellationPromise(t);
    let _;
    try {
      const A = await Promise.race([m, p, h]);
      if (A.__type === on.PROCESSED) _ = A.response;
      else {
        let E;
        for (;;) {
          const I = await this.getSignatureStatus(c);
          if (I == null) break;
          if (I.context.slot < (A.slotInWhichNonceDidAdvance ?? r)) {
            await ts(400);
            continue;
          }
          E = I;
          break;
        }
        if (E != null && E.value) {
          const I = e || 'finalized',
            { confirmationStatus: R } = E.value;
          switch (I) {
            case 'processed':
            case 'recent':
              if (R !== 'processed' && R !== 'confirmed' && R !== 'finalized') throw new na(c);
              break;
            case 'confirmed':
            case 'single':
            case 'singleGossip':
              if (R !== 'confirmed' && R !== 'finalized') throw new na(c);
              break;
            case 'finalized':
            case 'max':
            case 'root':
              if (R !== 'finalized') throw new na(c);
              break;
            default:
          }
          _ = { context: E.context, value: { err: E.value.err } };
        } else throw new na(c);
      }
    } finally {
      (f = !0), y();
    }
    return _;
  }
  async confirmTransactionUsingLegacyTimeoutStrategy({ commitment: e, signature: t }) {
    let r;
    const s = new Promise((h) => {
        let y = this._confirmTransactionInitialTimeout || 6e4;
        switch (e) {
          case 'processed':
          case 'recent':
          case 'single':
          case 'confirmed':
          case 'singleGossip': {
            y = this._confirmTransactionInitialTimeout || 3e4;
            break;
          }
        }
        r = setTimeout(() => h({ __type: on.TIMED_OUT, timeoutMs: y }), y);
      }),
      { abortConfirmation: n, confirmationPromise: c } = this.getTransactionConfirmationPromise({
        commitment: e,
        signature: t,
      });
    let f;
    try {
      const h = await Promise.race([c, s]);
      if (h.__type === on.PROCESSED) f = h.response;
      else throw new og(t, h.timeoutMs / 1e3);
    } finally {
      clearTimeout(r), n();
    }
    return f;
  }
  async getClusterNodes() {
    const e = await this._rpcRequest('getClusterNodes', []),
      t = Se(e, kt(Te(f$)));
    if ('error' in t) throw new ot(t.error, 'failed to get cluster nodes');
    return t.result;
  }
  async getVoteAccounts(e) {
    const t = this._buildArgs([], e),
      r = await this._rpcRequest('getVoteAccounts', t),
      s = Se(r, l$);
    if ('error' in s) throw new ot(s.error, 'failed to get vote accounts');
    return s.result;
  }
  async getSlot(e) {
    const { commitment: t, config: r } = Pr(e),
      s = this._buildArgs([], t, void 0, r),
      n = await this._rpcRequest('getSlot', s),
      c = Se(n, kt(ee()));
    if ('error' in c) throw new ot(c.error, 'failed to get slot');
    return c.result;
  }
  async getSlotLeader(e) {
    const { commitment: t, config: r } = Pr(e),
      s = this._buildArgs([], t, void 0, r),
      n = await this._rpcRequest('getSlotLeader', s),
      c = Se(n, kt(we()));
    if ('error' in c) throw new ot(c.error, 'failed to get slot leader');
    return c.result;
  }
  async getSlotLeaders(e, t) {
    const r = [e, t],
      s = await this._rpcRequest('getSlotLeaders', r),
      n = Se(s, kt(Te(Fr)));
    if ('error' in n) throw new ot(n.error, 'failed to get slot leaders');
    return n.result;
  }
  async getSignatureStatus(e, t) {
    const { context: r, value: s } = await this.getSignatureStatuses([e], t);
    Gt(s.length === 1);
    const n = s[0];
    return { context: r, value: n };
  }
  async getSignatureStatuses(e, t) {
    const r = [e];
    t && r.push(t);
    const s = await this._rpcRequest('getSignatureStatuses', r),
      n = Se(s, p$);
    if ('error' in n) throw new ot(n.error, 'failed to get signature status');
    return n.result;
  }
  async getTransactionCount(e) {
    const { commitment: t, config: r } = Pr(e),
      s = this._buildArgs([], t, void 0, r),
      n = await this._rpcRequest('getTransactionCount', s),
      c = Se(n, kt(ee()));
    if ('error' in c) throw new ot(c.error, 'failed to get transaction count');
    return c.result;
  }
  async getTotalSupply(e) {
    return (await this.getSupply({ commitment: e, excludeNonCirculatingAccountsList: !0 })).value
      .total;
  }
  async getInflationGovernor(e) {
    const t = this._buildArgs([], e),
      r = await this._rpcRequest('getInflationGovernor', t),
      s = Se(r, DN);
    if ('error' in s) throw new ot(s.error, 'failed to get inflation');
    return s.result;
  }
  async getInflationReward(e, t, r) {
    const { commitment: s, config: n } = Pr(r),
      c = this._buildArgs([e.map((y) => y.toBase58())], s, void 0, {
        ...n,
        epoch: t ?? (n == null ? void 0 : n.epoch),
      }),
      f = await this._rpcRequest('getInflationReward', c),
      h = Se(f, kN);
    if ('error' in h) throw new ot(h.error, 'failed to get inflation reward');
    return h.result;
  }
  async getInflationRate() {
    const e = await this._rpcRequest('getInflationRate', []),
      t = Se(e, UN);
    if ('error' in t) throw new ot(t.error, 'failed to get inflation rate');
    return t.result;
  }
  async getEpochInfo(e) {
    const { commitment: t, config: r } = Pr(e),
      s = this._buildArgs([], t, void 0, r),
      n = await this._rpcRequest('getEpochInfo', s),
      c = Se(n, zN);
    if ('error' in c) throw new ot(c.error, 'failed to get epoch info');
    return c.result;
  }
  async getEpochSchedule() {
    const e = await this._rpcRequest('getEpochSchedule', []),
      t = Se(e, FN);
    if ('error' in t) throw new ot(t.error, 'failed to get epoch schedule');
    const r = t.result;
    return new OS(
      r.slotsPerEpoch,
      r.leaderScheduleSlotOffset,
      r.warmup,
      r.firstNormalEpoch,
      r.firstNormalSlot
    );
  }
  async getLeaderSchedule() {
    const e = await this._rpcRequest('getLeaderSchedule', []),
      t = Se(e, qN);
    if ('error' in t) throw new ot(t.error, 'failed to get leader schedule');
    return t.result;
  }
  async getMinimumBalanceForRentExemption(e, t) {
    const r = this._buildArgs([e], t),
      s = await this._rpcRequest('getMinimumBalanceForRentExemption', r),
      n = Se(s, y$);
    return 'error' in n
      ? (console.warn('Unable to fetch minimum balance for rent exemption'), 0)
      : n.result;
  }
  async getRecentBlockhashAndContext(e) {
    const t = this._buildArgs([], e),
      r = await this._rpcRequest('getRecentBlockhash', t),
      s = Se(r, E$);
    if ('error' in s) throw new ot(s.error, 'failed to get recent blockhash');
    return s.result;
  }
  async getRecentPerformanceSamples(e) {
    const t = await this._rpcRequest('getRecentPerformanceSamples', e ? [e] : []),
      r = Se(t, x$);
    if ('error' in r) throw new ot(r.error, 'failed to get recent performance samples');
    return r.result;
  }
  async getFeeCalculatorForBlockhash(e, t) {
    const r = this._buildArgs([e], t),
      s = await this._rpcRequest('getFeeCalculatorForBlockhash', r),
      n = Se(s, B$);
    if ('error' in n) throw new ot(n.error, 'failed to get fee calculator');
    const { context: c, value: f } = n.result;
    return { context: c, value: f !== null ? f.feeCalculator : null };
  }
  async getFeeForMessage(e, t) {
    const r = Mt(e.serialize()).toString('base64'),
      s = this._buildArgs([r], t),
      n = await this._rpcRequest('getFeeForMessage', s),
      c = Se(n, Dr(Pe(ee())));
    if ('error' in c) throw new ot(c.error, 'failed to get fee for message');
    if (c.result === null) throw new Error('invalid blockhash');
    return c.result;
  }
  async getRecentBlockhash(e) {
    try {
      return (await this.getRecentBlockhashAndContext(e)).value;
    } catch (t) {
      throw new Error('failed to get recent blockhash: ' + t);
    }
  }
  async getLatestBlockhash(e) {
    try {
      return (await this.getLatestBlockhashAndContext(e)).value;
    } catch (t) {
      throw new Error('failed to get recent blockhash: ' + t);
    }
  }
  async getLatestBlockhashAndContext(e) {
    const { commitment: t, config: r } = Pr(e),
      s = this._buildArgs([], t, void 0, r),
      n = await this._rpcRequest('getLatestBlockhash', s),
      c = Se(n, k$);
    if ('error' in c) throw new ot(c.error, 'failed to get latest blockhash');
    return c.result;
  }
  async getVersion() {
    const e = await this._rpcRequest('getVersion', []),
      t = Se(e, kt(ON));
    if ('error' in t) throw new ot(t.error, 'failed to get version');
    return t.result;
  }
  async getGenesisHash() {
    const e = await this._rpcRequest('getGenesisHash', []),
      t = Se(e, kt(we()));
    if ('error' in t) throw new ot(t.error, 'failed to get genesis hash');
    return t.result;
  }
  async getBlock(e, t) {
    const { commitment: r, config: s } = Pr(t),
      n = this._buildArgsAtLeastConfirmed([e], r, void 0, s),
      c = await this._rpcRequest('getBlock', n);
    try {
      switch (s == null ? void 0 : s.transactionDetails) {
        case 'accounts': {
          const f = Se(c, w$);
          if ('error' in f) throw f.error;
          return f.result;
        }
        case 'none': {
          const f = Se(c, m$);
          if ('error' in f) throw f.error;
          return f.result;
        }
        default: {
          const f = Se(c, v$);
          if ('error' in f) throw f.error;
          const { result: h } = f;
          return h
            ? {
                ...h,
                transactions: h.transactions.map(({ transaction: y, meta: p, version: m }) => ({
                  meta: p,
                  transaction: { ...y, message: kp(m, y.message) },
                  version: m,
                })),
              }
            : null;
        }
      }
    } catch (f) {
      throw new ot(f, 'failed to get confirmed block');
    }
  }
  async getParsedBlock(e, t) {
    const { commitment: r, config: s } = Pr(t),
      n = this._buildArgsAtLeastConfirmed([e], r, 'jsonParsed', s),
      c = await this._rpcRequest('getBlock', n);
    try {
      switch (s == null ? void 0 : s.transactionDetails) {
        case 'accounts': {
          const f = Se(c, S$);
          if ('error' in f) throw f.error;
          return f.result;
        }
        case 'none': {
          const f = Se(c, M$);
          if ('error' in f) throw f.error;
          return f.result;
        }
        default: {
          const f = Se(c, _$);
          if ('error' in f) throw f.error;
          return f.result;
        }
      }
    } catch (f) {
      throw new ot(f, 'failed to get block');
    }
  }
  async getBlockProduction(e) {
    let t, r;
    if (typeof e == 'string') r = e;
    else if (e) {
      const { commitment: f, ...h } = e;
      (r = f), (t = h);
    }
    const s = this._buildArgs([], r, 'base64', t),
      n = await this._rpcRequest('getBlockProduction', s),
      c = Se(n, CN);
    if ('error' in c) throw new ot(c.error, 'failed to get block production information');
    return c.result;
  }
  async getTransaction(e, t) {
    const { commitment: r, config: s } = Pr(t),
      n = this._buildArgsAtLeastConfirmed([e], r, void 0, s),
      c = await this._rpcRequest('getTransaction', n),
      f = Se(c, Ip);
    if ('error' in f) throw new ot(f.error, 'failed to get transaction');
    const h = f.result;
    return (
      h && {
        ...h,
        transaction: { ...h.transaction, message: kp(h.version, h.transaction.message) },
      }
    );
  }
  async getParsedTransaction(e, t) {
    const { commitment: r, config: s } = Pr(t),
      n = this._buildArgsAtLeastConfirmed([e], r, 'jsonParsed', s),
      c = await this._rpcRequest('getTransaction', n),
      f = Se(c, ff);
    if ('error' in f) throw new ot(f.error, 'failed to get transaction');
    return f.result;
  }
  async getParsedTransactions(e, t) {
    const { commitment: r, config: s } = Pr(t),
      n = e.map((h) => ({
        methodName: 'getTransaction',
        args: this._buildArgsAtLeastConfirmed([h], r, 'jsonParsed', s),
      }));
    return (await this._rpcBatchRequest(n)).map((h) => {
      const y = Se(h, ff);
      if ('error' in y) throw new ot(y.error, 'failed to get transactions');
      return y.result;
    });
  }
  async getTransactions(e, t) {
    const { commitment: r, config: s } = Pr(t),
      n = e.map((h) => ({
        methodName: 'getTransaction',
        args: this._buildArgsAtLeastConfirmed([h], r, void 0, s),
      }));
    return (await this._rpcBatchRequest(n)).map((h) => {
      const y = Se(h, Ip);
      if ('error' in y) throw new ot(y.error, 'failed to get transactions');
      const p = y.result;
      return (
        p && {
          ...p,
          transaction: { ...p.transaction, message: kp(p.version, p.transaction.message) },
        }
      );
    });
  }
  async getConfirmedBlock(e, t) {
    const r = this._buildArgsAtLeastConfirmed([e], t),
      s = await this._rpcRequest('getConfirmedBlock', r),
      n = Se(s, A$);
    if ('error' in n) throw new ot(n.error, 'failed to get confirmed block');
    const c = n.result;
    if (!c) throw new Error('Confirmed block ' + e + ' not found');
    const f = {
      ...c,
      transactions: c.transactions.map(({ transaction: h, meta: y }) => {
        const p = new dn(h.message);
        return { meta: y, transaction: { ...h, message: p } };
      }),
    };
    return {
      ...f,
      transactions: f.transactions.map(({ transaction: h, meta: y }) => ({
        meta: y,
        transaction: rr.populate(h.message, h.signatures),
      })),
    };
  }
  async getBlocks(e, t, r) {
    const s = this._buildArgsAtLeastConfirmed(t !== void 0 ? [e, t] : [e], r),
      n = await this._rpcRequest('getBlocks', s),
      c = Se(n, kt(Te(ee())));
    if ('error' in c) throw new ot(c.error, 'failed to get blocks');
    return c.result;
  }
  async getBlockSignatures(e, t) {
    const r = this._buildArgsAtLeastConfirmed([e], t, void 0, {
        transactionDetails: 'signatures',
        rewards: !1,
      }),
      s = await this._rpcRequest('getBlock', r),
      n = Se(s, e2);
    if ('error' in n) throw new ot(n.error, 'failed to get block');
    const c = n.result;
    if (!c) throw new Error('Block ' + e + ' not found');
    return c;
  }
  async getConfirmedBlockSignatures(e, t) {
    const r = this._buildArgsAtLeastConfirmed([e], t, void 0, {
        transactionDetails: 'signatures',
        rewards: !1,
      }),
      s = await this._rpcRequest('getConfirmedBlock', r),
      n = Se(s, e2);
    if ('error' in n) throw new ot(n.error, 'failed to get confirmed block');
    const c = n.result;
    if (!c) throw new Error('Confirmed block ' + e + ' not found');
    return c;
  }
  async getConfirmedTransaction(e, t) {
    const r = this._buildArgsAtLeastConfirmed([e], t),
      s = await this._rpcRequest('getConfirmedTransaction', r),
      n = Se(s, Ip);
    if ('error' in n) throw new ot(n.error, 'failed to get transaction');
    const c = n.result;
    if (!c) return c;
    const f = new dn(c.transaction.message),
      h = c.transaction.signatures;
    return { ...c, transaction: rr.populate(f, h) };
  }
  async getParsedConfirmedTransaction(e, t) {
    const r = this._buildArgsAtLeastConfirmed([e], t, 'jsonParsed'),
      s = await this._rpcRequest('getConfirmedTransaction', r),
      n = Se(s, ff);
    if ('error' in n) throw new ot(n.error, 'failed to get confirmed transaction');
    return n.result;
  }
  async getParsedConfirmedTransactions(e, t) {
    const r = e.map((c) => ({
      methodName: 'getConfirmedTransaction',
      args: this._buildArgsAtLeastConfirmed([c], t, 'jsonParsed'),
    }));
    return (await this._rpcBatchRequest(r)).map((c) => {
      const f = Se(c, ff);
      if ('error' in f) throw new ot(f.error, 'failed to get confirmed transactions');
      return f.result;
    });
  }
  async getConfirmedSignaturesForAddress(e, t, r) {
    let s = {},
      n = await this.getFirstAvailableBlock();
    for (; !('until' in s) && (t--, !(t <= 0 || t < n)); )
      try {
        const h = await this.getConfirmedBlockSignatures(t, 'finalized');
        h.signatures.length > 0 && (s.until = h.signatures[h.signatures.length - 1].toString());
      } catch (h) {
        if (h instanceof Error && h.message.includes('skipped')) continue;
        throw h;
      }
    let c = await this.getSlot('finalized');
    for (; !('before' in s) && (r++, !(r > c)); )
      try {
        const h = await this.getConfirmedBlockSignatures(r);
        h.signatures.length > 0 && (s.before = h.signatures[h.signatures.length - 1].toString());
      } catch (h) {
        if (h instanceof Error && h.message.includes('skipped')) continue;
        throw h;
      }
    return (await this.getConfirmedSignaturesForAddress2(e, s)).map((h) => h.signature);
  }
  async getConfirmedSignaturesForAddress2(e, t, r) {
    const s = this._buildArgsAtLeastConfirmed([e.toBase58()], r, void 0, t),
      n = await this._rpcRequest('getConfirmedSignaturesForAddress2', s),
      c = Se(n, QN);
    if ('error' in c) throw new ot(c.error, 'failed to get confirmed signatures for address');
    return c.result;
  }
  async getSignaturesForAddress(e, t, r) {
    const s = this._buildArgsAtLeastConfirmed([e.toBase58()], r, void 0, t),
      n = await this._rpcRequest('getSignaturesForAddress', s),
      c = Se(n, e$);
    if ('error' in c) throw new ot(c.error, 'failed to get signatures for address');
    return c.result;
  }
  async getAddressLookupTable(e, t) {
    const { context: r, value: s } = await this.getAccountInfoAndContext(e, t);
    let n = null;
    return (
      s !== null && (n = new C1({ key: e, state: C1.deserialize(s.data) })),
      { context: r, value: n }
    );
  }
  async getNonceAndContext(e, t) {
    const { context: r, value: s } = await this.getAccountInfoAndContext(e, t);
    let n = null;
    return s !== null && (n = oh.fromAccountData(s.data)), { context: r, value: n };
  }
  async getNonce(e, t) {
    return await this.getNonceAndContext(e, t)
      .then((r) => r.value)
      .catch((r) => {
        throw new Error('failed to get nonce for account ' + e.toBase58() + ': ' + r);
      });
  }
  async requestAirdrop(e, t) {
    const r = await this._rpcRequest('requestAirdrop', [e.toBase58(), t]),
      s = Se(r, R$);
    if ('error' in s) throw new ot(s.error, `airdrop to ${e.toBase58()} failed`);
    return s.result;
  }
  async _blockhashWithExpiryBlockHeight(e) {
    if (!e) {
      for (; this._pollingBlockhash; ) await ts(100);
      const r = Date.now() - this._blockhashInfo.lastFetch >= LS;
      if (this._blockhashInfo.latestBlockhash !== null && !r)
        return this._blockhashInfo.latestBlockhash;
    }
    return await this._pollNewBlockhash();
  }
  async _pollNewBlockhash() {
    this._pollingBlockhash = !0;
    try {
      const e = Date.now(),
        t = this._blockhashInfo.latestBlockhash,
        r = t ? t.blockhash : null;
      for (let s = 0; s < 50; s++) {
        const n = await this.getLatestBlockhash('finalized');
        if (r !== n.blockhash)
          return (
            (this._blockhashInfo = {
              latestBlockhash: n,
              lastFetch: Date.now(),
              transactionSignatures: [],
              simulatedSignatures: [],
            }),
            n
          );
        await ts(vN / 2);
      }
      throw new Error(`Unable to obtain a new blockhash after ${Date.now() - e}ms`);
    } finally {
      this._pollingBlockhash = !1;
    }
  }
  async getStakeMinimumDelegation(e) {
    const { commitment: t, config: r } = Pr(e),
      s = this._buildArgs([], t, 'base64', r),
      n = await this._rpcRequest('getStakeMinimumDelegation', s),
      c = Se(n, Dr(ee()));
    if ('error' in c) throw new ot(c.error, 'failed to get stake minimum delegation');
    return c.result;
  }
  async simulateTransaction(e, t, r) {
    if ('message' in e) {
      const I = e.serialize(),
        R = He.from(I).toString('base64');
      if (Array.isArray(t) || r !== void 0) throw new Error('Invalid arguments');
      const L = t || {};
      (L.encoding = 'base64'), 'commitment' in L || (L.commitment = this.commitment);
      const D = [R, L],
        q = await this._rpcRequest('simulateTransaction', D),
        H = Se(q, Xw);
      if ('error' in H) throw new Error('failed to simulate transaction: ' + H.error.message);
      return H.result;
    }
    let s;
    if (e instanceof rr) {
      let E = e;
      (s = new rr()),
        (s.feePayer = E.feePayer),
        (s.instructions = e.instructions),
        (s.nonceInfo = E.nonceInfo),
        (s.signatures = E.signatures);
    } else (s = rr.populate(e)), (s._message = s._json = void 0);
    if (t !== void 0 && !Array.isArray(t)) throw new Error('Invalid arguments');
    const n = t;
    if (s.nonceInfo && n) s.sign(...n);
    else {
      let E = this._disableBlockhashCaching;
      for (;;) {
        const I = await this._blockhashWithExpiryBlockHeight(E);
        if (
          ((s.lastValidBlockHeight = I.lastValidBlockHeight), (s.recentBlockhash = I.blockhash), !n)
        )
          break;
        if ((s.sign(...n), !s.signature)) throw new Error('!signature');
        const R = s.signature.toString('base64');
        if (
          !this._blockhashInfo.simulatedSignatures.includes(R) &&
          !this._blockhashInfo.transactionSignatures.includes(R)
        ) {
          this._blockhashInfo.simulatedSignatures.push(R);
          break;
        } else E = !0;
      }
    }
    const c = s._compile(),
      f = c.serialize(),
      y = s._serialize(f).toString('base64'),
      p = { encoding: 'base64', commitment: this.commitment };
    if (r) {
      const E = (Array.isArray(r) ? r : c.nonProgramIds()).map((I) => I.toBase58());
      p.accounts = { encoding: 'base64', addresses: E };
    }
    n && (p.sigVerify = !0);
    const m = [y, p],
      _ = await this._rpcRequest('simulateTransaction', m),
      A = Se(_, Xw);
    if ('error' in A) {
      let E;
      if ('data' in A.error && ((E = A.error.data.logs), E && Array.isArray(E))) {
        const I = `
    `,
          R = I + E.join(I);
        console.error(A.error.message, R);
      }
      throw new O1('failed to simulate transaction: ' + A.error.message, E);
    }
    return A.result;
  }
  async sendTransaction(e, t, r) {
    if ('version' in e) {
      if (t && Array.isArray(t)) throw new Error('Invalid arguments');
      const c = e.serialize();
      return await this.sendRawTransaction(c, t);
    }
    if (t === void 0 || !Array.isArray(t)) throw new Error('Invalid arguments');
    const s = t;
    if (e.nonceInfo) e.sign(...s);
    else {
      let c = this._disableBlockhashCaching;
      for (;;) {
        const f = await this._blockhashWithExpiryBlockHeight(c);
        if (
          ((e.lastValidBlockHeight = f.lastValidBlockHeight),
          (e.recentBlockhash = f.blockhash),
          e.sign(...s),
          !e.signature)
        )
          throw new Error('!signature');
        const h = e.signature.toString('base64');
        if (this._blockhashInfo.transactionSignatures.includes(h)) c = !0;
        else {
          this._blockhashInfo.transactionSignatures.push(h);
          break;
        }
      }
    }
    const n = e.serialize();
    return await this.sendRawTransaction(n, r);
  }
  async sendRawTransaction(e, t) {
    const r = Mt(e).toString('base64');
    return await this.sendEncodedTransaction(r, t);
  }
  async sendEncodedTransaction(e, t) {
    const r = { encoding: 'base64' },
      s = t && t.skipPreflight,
      n = (t && t.preflightCommitment) || this.commitment;
    t && t.maxRetries != null && (r.maxRetries = t.maxRetries),
      t && t.minContextSlot != null && (r.minContextSlot = t.minContextSlot),
      s && (r.skipPreflight = s),
      n && (r.preflightCommitment = n);
    const c = [e, r],
      f = await this._rpcRequest('sendTransaction', c),
      h = Se(f, P$);
    if ('error' in h) {
      let y;
      throw (
        ('data' in h.error && (y = h.error.data.logs),
        new O1('failed to send transaction: ' + h.error.message, y))
      );
    }
    return h.result;
  }
  _wsOnOpen() {
    (this._rpcWebSocketConnected = !0),
      (this._rpcWebSocketHeartbeat = setInterval(() => {
        (async () => {
          try {
            await this._rpcWebSocket.notify('ping');
          } catch {}
        })();
      }, 5e3)),
      this._updateSubscriptions();
  }
  _wsOnError(e) {
    (this._rpcWebSocketConnected = !1), console.error('ws error:', e.message);
  }
  _wsOnClose(e) {
    if (
      ((this._rpcWebSocketConnected = !1),
      (this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER),
      this._rpcWebSocketIdleTimeout &&
        (clearTimeout(this._rpcWebSocketIdleTimeout), (this._rpcWebSocketIdleTimeout = null)),
      this._rpcWebSocketHeartbeat &&
        (clearInterval(this._rpcWebSocketHeartbeat), (this._rpcWebSocketHeartbeat = null)),
      e === 1e3)
    ) {
      this._updateSubscriptions();
      return;
    }
    (this._subscriptionCallbacksByServerSubscriptionId = {}),
      Object.entries(this._subscriptionsByHash).forEach(([t, r]) => {
        this._setSubscription(t, { ...r, state: 'pending' });
      });
  }
  _setSubscription(e, t) {
    var s;
    const r = (s = this._subscriptionsByHash[e]) == null ? void 0 : s.state;
    if (((this._subscriptionsByHash[e] = t), r !== t.state)) {
      const n = this._subscriptionStateChangeCallbacksByHash[e];
      n &&
        n.forEach((c) => {
          try {
            c(t.state);
          } catch {}
        });
    }
  }
  _onSubscriptionStateChange(e, t) {
    var r;
    const s = this._subscriptionHashByClientSubscriptionId[e];
    if (s == null) return () => {};
    const n = (r = this._subscriptionStateChangeCallbacksByHash)[s] || (r[s] = new Set());
    return (
      n.add(t),
      () => {
        n.delete(t), n.size === 0 && delete this._subscriptionStateChangeCallbacksByHash[s];
      }
    );
  }
  async _updateSubscriptions() {
    if (Object.keys(this._subscriptionsByHash).length === 0) {
      this._rpcWebSocketConnected &&
        ((this._rpcWebSocketConnected = !1),
        (this._rpcWebSocketIdleTimeout = setTimeout(() => {
          this._rpcWebSocketIdleTimeout = null;
          try {
            this._rpcWebSocket.close();
          } catch (r) {
            r instanceof Error && console.log(`Error when closing socket connection: ${r.message}`);
          }
        }, 500)));
      return;
    }
    if (
      (this._rpcWebSocketIdleTimeout !== null &&
        (clearTimeout(this._rpcWebSocketIdleTimeout),
        (this._rpcWebSocketIdleTimeout = null),
        (this._rpcWebSocketConnected = !0)),
      !this._rpcWebSocketConnected)
    ) {
      this._rpcWebSocket.connect();
      return;
    }
    const e = this._rpcWebSocketGeneration,
      t = () => e === this._rpcWebSocketGeneration;
    await Promise.all(
      Object.keys(this._subscriptionsByHash).map(async (r) => {
        const s = this._subscriptionsByHash[r];
        if (s !== void 0)
          switch (s.state) {
            case 'pending':
            case 'unsubscribed':
              if (s.callbacks.size === 0) {
                delete this._subscriptionsByHash[r],
                  s.state === 'unsubscribed' &&
                    delete this._subscriptionCallbacksByServerSubscriptionId[
                      s.serverSubscriptionId
                    ],
                  await this._updateSubscriptions();
                return;
              }
              await (async () => {
                const { args: n, method: c } = s;
                try {
                  this._setSubscription(r, { ...s, state: 'subscribing' });
                  const f = await this._rpcWebSocket.call(c, n);
                  this._setSubscription(r, { ...s, serverSubscriptionId: f, state: 'subscribed' }),
                    (this._subscriptionCallbacksByServerSubscriptionId[f] = s.callbacks),
                    await this._updateSubscriptions();
                } catch (f) {
                  if (
                    (f instanceof Error && console.error(`${c} error for argument`, n, f.message),
                    !t())
                  )
                    return;
                  this._setSubscription(r, { ...s, state: 'pending' }),
                    await this._updateSubscriptions();
                }
              })();
              break;
            case 'subscribed':
              s.callbacks.size === 0 &&
                (await (async () => {
                  const { serverSubscriptionId: n, unsubscribeMethod: c } = s;
                  if (this._subscriptionsAutoDisposedByRpc.has(n))
                    this._subscriptionsAutoDisposedByRpc.delete(n);
                  else {
                    this._setSubscription(r, { ...s, state: 'unsubscribing' }),
                      this._setSubscription(r, { ...s, state: 'unsubscribing' });
                    try {
                      await this._rpcWebSocket.call(c, [n]);
                    } catch (f) {
                      if ((f instanceof Error && console.error(`${c} error:`, f.message), !t()))
                        return;
                      this._setSubscription(r, { ...s, state: 'subscribed' }),
                        await this._updateSubscriptions();
                      return;
                    }
                  }
                  this._setSubscription(r, { ...s, state: 'unsubscribed' }),
                    await this._updateSubscriptions();
                })());
              break;
          }
      })
    );
  }
  _handleServerNotification(e, t) {
    const r = this._subscriptionCallbacksByServerSubscriptionId[e];
    r !== void 0 &&
      r.forEach((s) => {
        try {
          s(...t);
        } catch (n) {
          console.error(n);
        }
      });
  }
  _wsOnAccountNotification(e) {
    const { result: t, subscription: r } = Se(e, t$);
    this._handleServerNotification(r, [t.value, t.context]);
  }
  _makeSubscription(e, t) {
    const r = this._nextClientSubscriptionId++,
      s = Zw([e.method, t]),
      n = this._subscriptionsByHash[s];
    return (
      n === void 0
        ? (this._subscriptionsByHash[s] = {
            ...e,
            args: t,
            callbacks: new Set([e.callback]),
            state: 'pending',
          })
        : n.callbacks.add(e.callback),
      (this._subscriptionHashByClientSubscriptionId[r] = s),
      (this._subscriptionDisposeFunctionsByClientSubscriptionId[r] = async () => {
        delete this._subscriptionDisposeFunctionsByClientSubscriptionId[r],
          delete this._subscriptionHashByClientSubscriptionId[r];
        const c = this._subscriptionsByHash[s];
        Gt(
          c !== void 0,
          `Could not find a \`Subscription\` when tearing down client subscription #${r}`
        ),
          c.callbacks.delete(e.callback),
          await this._updateSubscriptions();
      }),
      this._updateSubscriptions(),
      r
    );
  }
  onAccountChange(e, t, r) {
    const s = this._buildArgs([e.toBase58()], r || this._commitment || 'finalized', 'base64');
    return this._makeSubscription(
      { callback: t, method: 'accountSubscribe', unsubscribeMethod: 'accountUnsubscribe' },
      s
    );
  }
  async removeAccountChangeListener(e) {
    await this._unsubscribeClientSubscription(e, 'account change');
  }
  _wsOnProgramAccountNotification(e) {
    const { result: t, subscription: r } = Se(e, i$);
    this._handleServerNotification(r, [
      { accountId: t.value.pubkey, accountInfo: t.value.account },
      t.context,
    ]);
  }
  onProgramAccountChange(e, t, r, s) {
    const n = this._buildArgs(
      [e.toBase58()],
      r || this._commitment || 'finalized',
      'base64',
      s ? { filters: s } : void 0
    );
    return this._makeSubscription(
      { callback: t, method: 'programSubscribe', unsubscribeMethod: 'programUnsubscribe' },
      n
    );
  }
  async removeProgramAccountChangeListener(e) {
    await this._unsubscribeClientSubscription(e, 'program account change');
  }
  onLogs(e, t, r) {
    const s = this._buildArgs(
      [typeof e == 'object' ? { mentions: [e.toString()] } : e],
      r || this._commitment || 'finalized'
    );
    return this._makeSubscription(
      { callback: t, method: 'logsSubscribe', unsubscribeMethod: 'logsUnsubscribe' },
      s
    );
  }
  async removeOnLogsListener(e) {
    await this._unsubscribeClientSubscription(e, 'logs');
  }
  _wsOnLogsNotification(e) {
    const { result: t, subscription: r } = Se(e, O$);
    this._handleServerNotification(r, [t.value, t.context]);
  }
  _wsOnSlotNotification(e) {
    const { result: t, subscription: r } = Se(e, o$);
    this._handleServerNotification(r, [t]);
  }
  onSlotChange(e) {
    return this._makeSubscription(
      { callback: e, method: 'slotSubscribe', unsubscribeMethod: 'slotUnsubscribe' },
      []
    );
  }
  async removeSlotChangeListener(e) {
    await this._unsubscribeClientSubscription(e, 'slot change');
  }
  _wsOnSlotUpdatesNotification(e) {
    const { result: t, subscription: r } = Se(e, a$);
    this._handleServerNotification(r, [t]);
  }
  onSlotUpdate(e) {
    return this._makeSubscription(
      {
        callback: e,
        method: 'slotsUpdatesSubscribe',
        unsubscribeMethod: 'slotsUpdatesUnsubscribe',
      },
      []
    );
  }
  async removeSlotUpdateListener(e) {
    await this._unsubscribeClientSubscription(e, 'slot update');
  }
  async _unsubscribeClientSubscription(e, t) {
    const r = this._subscriptionDisposeFunctionsByClientSubscriptionId[e];
    r
      ? await r()
      : console.warn(
          `Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`
        );
  }
  _buildArgs(e, t, r, s) {
    const n = t || this._commitment;
    if (n || r || s) {
      let c = {};
      r && (c.encoding = r), n && (c.commitment = n), s && (c = Object.assign(c, s)), e.push(c);
    }
    return e;
  }
  _buildArgsAtLeastConfirmed(e, t, r, s) {
    const n = t || this._commitment;
    if (n && !['confirmed', 'finalized'].includes(n))
      throw new Error(
        'Using Connection with default commitment: `' +
          this._commitment +
          '`, but method requires at least `confirmed`'
      );
    return this._buildArgs(e, t, r, s);
  }
  _wsOnSignatureNotification(e) {
    const { result: t, subscription: r } = Se(e, u$);
    t.value !== 'receivedSignature' && this._subscriptionsAutoDisposedByRpc.add(r),
      this._handleServerNotification(
        r,
        t.value === 'receivedSignature'
          ? [{ type: 'received' }, t.context]
          : [{ type: 'status', result: t.value }, t.context]
      );
  }
  onSignature(e, t, r) {
    const s = this._buildArgs([e], r || this._commitment || 'finalized'),
      n = this._makeSubscription(
        {
          callback: (c, f) => {
            if (c.type === 'status') {
              t(c.result, f);
              try {
                this.removeSignatureListener(n);
              } catch {}
            }
          },
          method: 'signatureSubscribe',
          unsubscribeMethod: 'signatureUnsubscribe',
        },
        s
      );
    return n;
  }
  onSignatureWithOptions(e, t, r) {
    const { commitment: s, ...n } = {
        ...r,
        commitment: (r && r.commitment) || this._commitment || 'finalized',
      },
      c = this._buildArgs([e], s, void 0, n),
      f = this._makeSubscription(
        {
          callback: (h, y) => {
            t(h, y);
            try {
              this.removeSignatureListener(f);
            } catch {}
          },
          method: 'signatureSubscribe',
          unsubscribeMethod: 'signatureUnsubscribe',
        },
        c
      );
    return f;
  }
  async removeSignatureListener(e) {
    await this._unsubscribeClientSubscription(e, 'signature result');
  }
  _wsOnRootNotification(e) {
    const { result: t, subscription: r } = Se(e, c$);
    this._handleServerNotification(r, [t]);
  }
  onRootChange(e) {
    return this._makeSubscription(
      { callback: e, method: 'rootSubscribe', unsubscribeMethod: 'rootUnsubscribe' },
      []
    );
  }
  async removeRootChangeListener(e) {
    await this._unsubscribeClientSubscription(e, 'root change');
  }
}
class pa {
  constructor(e) {
    (this._keypair = void 0), (this._keypair = e ?? Vw());
  }
  static generate() {
    return new pa(Vw());
  }
  static fromSecretKey(e, t) {
    if (e.byteLength !== 64) throw new Error('bad secret key size');
    const r = e.slice(32, 64);
    if (!t || !t.skipValidation) {
      const s = e.slice(0, 32),
        n = ul(s);
      for (let c = 0; c < 32; c++)
        if (r[c] !== n[c]) throw new Error('provided secretKey is invalid');
    }
    return new pa({ publicKey: r, secretKey: e });
  }
  static fromSeed(e) {
    const t = ul(e),
      r = new Uint8Array(64);
    return r.set(e), r.set(t, 32), new pa({ publicKey: t, secretKey: r });
  }
  get publicKey() {
    return new Xe(this._keypair.publicKey);
  }
  get secretKey() {
    return new Uint8Array(this._keypair.secretKey);
  }
}
const Qn = Object.freeze({
  CreateLookupTable: {
    index: 0,
    layout: We([qe('instruction'), La('recentSlot'), tt('bumpSeed')]),
  },
  FreezeLookupTable: { index: 1, layout: We([qe('instruction')]) },
  ExtendLookupTable: {
    index: 2,
    layout: We([qe('instruction'), La(), zt(xt(), _i(qe(), -8), 'addresses')]),
  },
  DeactivateLookupTable: { index: 3, layout: We([qe('instruction')]) },
  CloseLookupTable: { index: 4, layout: We([qe('instruction')]) },
});
class N$ {
  constructor() {}
  static decodeInstructionType(e) {
    this.checkProgramId(e.programId);
    const r = qe('instruction').decode(e.data);
    let s;
    for (const [n, c] of Object.entries(Qn))
      if (c.index == r) {
        s = n;
        break;
      }
    if (!s) throw new Error('Invalid Instruction. Should be a LookupTable Instruction');
    return s;
  }
  static decodeCreateLookupTable(e) {
    this.checkProgramId(e.programId), this.checkKeysLength(e.keys, 4);
    const { recentSlot: t } = tr(Qn.CreateLookupTable, e.data);
    return { authority: e.keys[1].pubkey, payer: e.keys[2].pubkey, recentSlot: Number(t) };
  }
  static decodeExtendLookupTable(e) {
    if ((this.checkProgramId(e.programId), e.keys.length < 2))
      throw new Error(`invalid instruction; found ${e.keys.length} keys, expected at least 2`);
    const { addresses: t } = tr(Qn.ExtendLookupTable, e.data);
    return {
      lookupTable: e.keys[0].pubkey,
      authority: e.keys[1].pubkey,
      payer: e.keys.length > 2 ? e.keys[2].pubkey : void 0,
      addresses: t.map((r) => new Xe(r)),
    };
  }
  static decodeCloseLookupTable(e) {
    return (
      this.checkProgramId(e.programId),
      this.checkKeysLength(e.keys, 3),
      { lookupTable: e.keys[0].pubkey, authority: e.keys[1].pubkey, recipient: e.keys[2].pubkey }
    );
  }
  static decodeFreezeLookupTable(e) {
    return (
      this.checkProgramId(e.programId),
      this.checkKeysLength(e.keys, 2),
      { lookupTable: e.keys[0].pubkey, authority: e.keys[1].pubkey }
    );
  }
  static decodeDeactivateLookupTable(e) {
    return (
      this.checkProgramId(e.programId),
      this.checkKeysLength(e.keys, 2),
      { lookupTable: e.keys[0].pubkey, authority: e.keys[1].pubkey }
    );
  }
  static checkProgramId(e) {
    if (!e.equals(hg.programId))
      throw new Error('invalid instruction; programId is not AddressLookupTable Program');
  }
  static checkKeysLength(e, t) {
    if (e.length < t)
      throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`);
  }
}
class hg {
  constructor() {}
  static createLookupTable(e) {
    const [t, r] = Xe.findProgramAddressSync(
        [e.authority.toBuffer(), ql(BigInt(e.recentSlot), 8)],
        this.programId
      ),
      s = Qn.CreateLookupTable,
      n = Dt(s, { recentSlot: BigInt(e.recentSlot), bumpSeed: r }),
      c = [
        { pubkey: t, isSigner: !1, isWritable: !0 },
        { pubkey: e.authority, isSigner: !0, isWritable: !1 },
        { pubkey: e.payer, isSigner: !0, isWritable: !0 },
        { pubkey: si.programId, isSigner: !1, isWritable: !1 },
      ];
    return [new Mr({ programId: this.programId, keys: c, data: n }), t];
  }
  static freezeLookupTable(e) {
    const t = Qn.FreezeLookupTable,
      r = Dt(t),
      s = [
        { pubkey: e.lookupTable, isSigner: !1, isWritable: !0 },
        { pubkey: e.authority, isSigner: !0, isWritable: !1 },
      ];
    return new Mr({ programId: this.programId, keys: s, data: r });
  }
  static extendLookupTable(e) {
    const t = Qn.ExtendLookupTable,
      r = Dt(t, { addresses: e.addresses.map((n) => n.toBytes()) }),
      s = [
        { pubkey: e.lookupTable, isSigner: !1, isWritable: !0 },
        { pubkey: e.authority, isSigner: !0, isWritable: !1 },
      ];
    return (
      e.payer &&
        s.push(
          { pubkey: e.payer, isSigner: !0, isWritable: !0 },
          { pubkey: si.programId, isSigner: !1, isWritable: !1 }
        ),
      new Mr({ programId: this.programId, keys: s, data: r })
    );
  }
  static deactivateLookupTable(e) {
    const t = Qn.DeactivateLookupTable,
      r = Dt(t),
      s = [
        { pubkey: e.lookupTable, isSigner: !1, isWritable: !0 },
        { pubkey: e.authority, isSigner: !0, isWritable: !1 },
      ];
    return new Mr({ programId: this.programId, keys: s, data: r });
  }
  static closeLookupTable(e) {
    const t = Qn.CloseLookupTable,
      r = Dt(t),
      s = [
        { pubkey: e.lookupTable, isSigner: !1, isWritable: !0 },
        { pubkey: e.authority, isSigner: !0, isWritable: !1 },
        { pubkey: e.recipient, isSigner: !1, isWritable: !0 },
      ];
    return new Mr({ programId: this.programId, keys: s, data: r });
  }
}
hg.programId = new Xe('AddressLookupTab1e1111111111111111111111111');
class $$ {
  constructor() {}
  static decodeInstructionType(e) {
    this.checkProgramId(e.programId);
    const r = tt('instruction').decode(e.data);
    let s;
    for (const [n, c] of Object.entries(En))
      if (c.index == r) {
        s = n;
        break;
      }
    if (!s) throw new Error('Instruction type incorrect; not a ComputeBudgetInstruction');
    return s;
  }
  static decodeRequestUnits(e) {
    this.checkProgramId(e.programId);
    const { units: t, additionalFee: r } = tr(En.RequestUnits, e.data);
    return { units: t, additionalFee: r };
  }
  static decodeRequestHeapFrame(e) {
    this.checkProgramId(e.programId);
    const { bytes: t } = tr(En.RequestHeapFrame, e.data);
    return { bytes: t };
  }
  static decodeSetComputeUnitLimit(e) {
    this.checkProgramId(e.programId);
    const { units: t } = tr(En.SetComputeUnitLimit, e.data);
    return { units: t };
  }
  static decodeSetComputeUnitPrice(e) {
    this.checkProgramId(e.programId);
    const { microLamports: t } = tr(En.SetComputeUnitPrice, e.data);
    return { microLamports: t };
  }
  static checkProgramId(e) {
    if (!e.equals(dg.programId))
      throw new Error('invalid instruction; programId is not ComputeBudgetProgram');
  }
}
const En = Object.freeze({
  RequestUnits: { index: 0, layout: We([tt('instruction'), qe('units'), qe('additionalFee')]) },
  RequestHeapFrame: { index: 1, layout: We([tt('instruction'), qe('bytes')]) },
  SetComputeUnitLimit: { index: 2, layout: We([tt('instruction'), qe('units')]) },
  SetComputeUnitPrice: { index: 3, layout: We([tt('instruction'), La('microLamports')]) },
});
class dg {
  constructor() {}
  static requestUnits(e) {
    const t = En.RequestUnits,
      r = Dt(t, e);
    return new Mr({ keys: [], programId: this.programId, data: r });
  }
  static requestHeapFrame(e) {
    const t = En.RequestHeapFrame,
      r = Dt(t, e);
    return new Mr({ keys: [], programId: this.programId, data: r });
  }
  static setComputeUnitLimit(e) {
    const t = En.SetComputeUnitLimit,
      r = Dt(t, e);
    return new Mr({ keys: [], programId: this.programId, data: r });
  }
  static setComputeUnitPrice(e) {
    const t = En.SetComputeUnitPrice,
      r = Dt(t, { microLamports: BigInt(e.microLamports) });
    return new Mr({ keys: [], programId: this.programId, data: r });
  }
}
dg.programId = new Xe('ComputeBudget111111111111111111111111111111');
const t2 = 64,
  r2 = 32,
  i2 = 64,
  n2 = We([
    tt('numSignatures'),
    tt('padding'),
    Tr('signatureOffset'),
    Tr('signatureInstructionIndex'),
    Tr('publicKeyOffset'),
    Tr('publicKeyInstructionIndex'),
    Tr('messageDataOffset'),
    Tr('messageDataSize'),
    Tr('messageInstructionIndex'),
  ]);
class uh {
  constructor() {}
  static createInstructionWithPublicKey(e) {
    const { publicKey: t, message: r, signature: s, instructionIndex: n } = e;
    Gt(t.length === r2, `Public Key must be ${r2} bytes but received ${t.length} bytes`),
      Gt(s.length === i2, `Signature must be ${i2} bytes but received ${s.length} bytes`);
    const c = n2.span,
      f = c + t.length,
      h = f + s.length,
      y = 1,
      p = He.alloc(h + r.length),
      m = n ?? 65535;
    return (
      n2.encode(
        {
          numSignatures: y,
          padding: 0,
          signatureOffset: f,
          signatureInstructionIndex: m,
          publicKeyOffset: c,
          publicKeyInstructionIndex: m,
          messageDataOffset: h,
          messageDataSize: r.length,
          messageInstructionIndex: m,
        },
        p
      ),
      p.fill(t, c),
      p.fill(s, f),
      p.fill(r, h),
      new Mr({ keys: [], programId: uh.programId, data: p })
    );
  }
  static createInstructionWithPrivateKey(e) {
    const { privateKey: t, message: r, instructionIndex: s } = e;
    Gt(t.length === t2, `Private key must be ${t2} bytes but received ${t.length} bytes`);
    try {
      const n = pa.fromSecretKey(t),
        c = n.publicKey.toBytes(),
        f = rg(r, n.secretKey);
      return this.createInstructionWithPublicKey({
        publicKey: c,
        message: r,
        signature: f,
        instructionIndex: s,
      });
    } catch (n) {
      throw new Error(`Error creating instruction; ${n}`);
    }
  }
}
uh.programId = new Xe('Ed25519SigVerify111111111111111111111111111');
oi.hmacSha256Sync = (i, ...e) => {
  const t = IS.create(P1, i);
  return e.forEach((r) => t.update(r)), t.digest();
};
const D$ = (i, e) => Ey(i, e, { der: !1, recovered: !0 });
oi.isValidPrivateKey;
const U$ = Ay,
  o2 = 32,
  xp = 20,
  s2 = 64,
  z$ = 11,
  Bp = We([
    tt('numSignatures'),
    Tr('signatureOffset'),
    tt('signatureInstructionIndex'),
    Tr('ethAddressOffset'),
    tt('ethAddressInstructionIndex'),
    Tr('messageDataOffset'),
    Tr('messageDataSize'),
    tt('messageInstructionIndex'),
    ut(20, 'ethAddress'),
    ut(64, 'signature'),
    tt('recoveryId'),
  ]);
class ya {
  constructor() {}
  static publicKeyToEthAddress(e) {
    Gt(e.length === s2, `Public key must be ${s2} bytes but received ${e.length} bytes`);
    try {
      return He.from(Hw(Mt(e))).slice(-xp);
    } catch (t) {
      throw new Error(`Error constructing Ethereum address: ${t}`);
    }
  }
  static createInstructionWithPublicKey(e) {
    const { publicKey: t, message: r, signature: s, recoveryId: n, instructionIndex: c } = e;
    return ya.createInstructionWithEthAddress({
      ethAddress: ya.publicKeyToEthAddress(t),
      message: r,
      signature: s,
      recoveryId: n,
      instructionIndex: c,
    });
  }
  static createInstructionWithEthAddress(e) {
    const { ethAddress: t, message: r, signature: s, recoveryId: n, instructionIndex: c = 0 } = e;
    let f;
    typeof t == 'string'
      ? t.startsWith('0x')
        ? (f = He.from(t.substr(2), 'hex'))
        : (f = He.from(t, 'hex'))
      : (f = t),
      Gt(f.length === xp, `Address must be ${xp} bytes but received ${f.length} bytes`);
    const h = 1 + z$,
      y = h,
      p = h + f.length,
      m = p + s.length + 1,
      _ = 1,
      A = He.alloc(Bp.span + r.length);
    return (
      Bp.encode(
        {
          numSignatures: _,
          signatureOffset: p,
          signatureInstructionIndex: c,
          ethAddressOffset: y,
          ethAddressInstructionIndex: c,
          messageDataOffset: m,
          messageDataSize: r.length,
          messageInstructionIndex: c,
          signature: Mt(s),
          ethAddress: Mt(f),
          recoveryId: n,
        },
        A
      ),
      A.fill(Mt(r), Bp.span),
      new Mr({ keys: [], programId: ya.programId, data: A })
    );
  }
  static createInstructionWithPrivateKey(e) {
    const { privateKey: t, message: r, instructionIndex: s } = e;
    Gt(t.length === o2, `Private key must be ${o2} bytes but received ${t.length} bytes`);
    try {
      const n = Mt(t),
        c = U$(n, !1).slice(1),
        f = He.from(Hw(Mt(r))),
        [h, y] = D$(f, n);
      return this.createInstructionWithPublicKey({
        publicKey: c,
        message: r,
        signature: h,
        recoveryId: y,
        instructionIndex: s,
      });
    } catch (n) {
      throw new Error(`Error creating instruction; ${n}`);
    }
  }
}
ya.programId = new Xe('KeccakSecp256k11111111111111111111111111111');
const jS = new Xe('StakeConfig11111111111111111111111111111111');
class HS {
  constructor(e, t) {
    (this.staker = void 0), (this.withdrawer = void 0), (this.staker = e), (this.withdrawer = t);
  }
}
class Ku {
  constructor(e, t, r) {
    (this.unixTimestamp = void 0),
      (this.epoch = void 0),
      (this.custodian = void 0),
      (this.unixTimestamp = e),
      (this.epoch = t),
      (this.custodian = r);
  }
}
Ku.default = new Ku(0, 0, Xe.default);
class F$ {
  constructor() {}
  static decodeInstructionType(e) {
    this.checkProgramId(e.programId);
    const r = qe('instruction').decode(e.data);
    let s;
    for (const [n, c] of Object.entries(Zr))
      if (c.index == r) {
        s = n;
        break;
      }
    if (!s) throw new Error('Instruction type incorrect; not a StakeInstruction');
    return s;
  }
  static decodeInitialize(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
    const { authorized: t, lockup: r } = tr(Zr.Initialize, e.data);
    return {
      stakePubkey: e.keys[0].pubkey,
      authorized: new HS(new Xe(t.staker), new Xe(t.withdrawer)),
      lockup: new Ku(r.unixTimestamp, r.epoch, new Xe(r.custodian)),
    };
  }
  static decodeDelegate(e) {
    return (
      this.checkProgramId(e.programId),
      this.checkKeyLength(e.keys, 6),
      tr(Zr.Delegate, e.data),
      {
        stakePubkey: e.keys[0].pubkey,
        votePubkey: e.keys[1].pubkey,
        authorizedPubkey: e.keys[5].pubkey,
      }
    );
  }
  static decodeAuthorize(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
    const { newAuthorized: t, stakeAuthorizationType: r } = tr(Zr.Authorize, e.data),
      s = {
        stakePubkey: e.keys[0].pubkey,
        authorizedPubkey: e.keys[2].pubkey,
        newAuthorizedPubkey: new Xe(t),
        stakeAuthorizationType: { index: r },
      };
    return e.keys.length > 3 && (s.custodianPubkey = e.keys[3].pubkey), s;
  }
  static decodeAuthorizeWithSeed(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
    const {
        newAuthorized: t,
        stakeAuthorizationType: r,
        authoritySeed: s,
        authorityOwner: n,
      } = tr(Zr.AuthorizeWithSeed, e.data),
      c = {
        stakePubkey: e.keys[0].pubkey,
        authorityBase: e.keys[1].pubkey,
        authoritySeed: s,
        authorityOwner: new Xe(n),
        newAuthorizedPubkey: new Xe(t),
        stakeAuthorizationType: { index: r },
      };
    return e.keys.length > 3 && (c.custodianPubkey = e.keys[3].pubkey), c;
  }
  static decodeSplit(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
    const { lamports: t } = tr(Zr.Split, e.data);
    return {
      stakePubkey: e.keys[0].pubkey,
      splitStakePubkey: e.keys[1].pubkey,
      authorizedPubkey: e.keys[2].pubkey,
      lamports: t,
    };
  }
  static decodeMerge(e) {
    return (
      this.checkProgramId(e.programId),
      this.checkKeyLength(e.keys, 3),
      tr(Zr.Merge, e.data),
      {
        stakePubkey: e.keys[0].pubkey,
        sourceStakePubKey: e.keys[1].pubkey,
        authorizedPubkey: e.keys[4].pubkey,
      }
    );
  }
  static decodeWithdraw(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 5);
    const { lamports: t } = tr(Zr.Withdraw, e.data),
      r = {
        stakePubkey: e.keys[0].pubkey,
        toPubkey: e.keys[1].pubkey,
        authorizedPubkey: e.keys[4].pubkey,
        lamports: t,
      };
    return e.keys.length > 5 && (r.custodianPubkey = e.keys[5].pubkey), r;
  }
  static decodeDeactivate(e) {
    return (
      this.checkProgramId(e.programId),
      this.checkKeyLength(e.keys, 3),
      tr(Zr.Deactivate, e.data),
      { stakePubkey: e.keys[0].pubkey, authorizedPubkey: e.keys[2].pubkey }
    );
  }
  static checkProgramId(e) {
    if (!e.equals(ch.programId))
      throw new Error('invalid instruction; programId is not StakeProgram');
  }
  static checkKeyLength(e, t) {
    if (e.length < t)
      throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`);
  }
}
const Zr = Object.freeze({
    Initialize: { index: 0, layout: We([qe('instruction'), HL(), VL()]) },
    Authorize: {
      index: 1,
      layout: We([qe('instruction'), xt('newAuthorized'), qe('stakeAuthorizationType')]),
    },
    Delegate: { index: 2, layout: We([qe('instruction')]) },
    Split: { index: 3, layout: We([qe('instruction'), Ir('lamports')]) },
    Withdraw: { index: 4, layout: We([qe('instruction'), Ir('lamports')]) },
    Deactivate: { index: 5, layout: We([qe('instruction')]) },
    Merge: { index: 7, layout: We([qe('instruction')]) },
    AuthorizeWithSeed: {
      index: 8,
      layout: We([
        qe('instruction'),
        xt('newAuthorized'),
        qe('stakeAuthorizationType'),
        ns('authoritySeed'),
        xt('authorityOwner'),
      ]),
    },
  }),
  q$ = Object.freeze({ Staker: { index: 0 }, Withdrawer: { index: 1 } });
class ch {
  constructor() {}
  static initialize(e) {
    const { stakePubkey: t, authorized: r, lockup: s } = e,
      n = s || Ku.default,
      c = Zr.Initialize,
      f = Dt(c, {
        authorized: { staker: Mt(r.staker.toBuffer()), withdrawer: Mt(r.withdrawer.toBuffer()) },
        lockup: {
          unixTimestamp: n.unixTimestamp,
          epoch: n.epoch,
          custodian: Mt(n.custodian.toBuffer()),
        },
      }),
      h = {
        keys: [
          { pubkey: t, isSigner: !1, isWritable: !0 },
          { pubkey: Ca, isSigner: !1, isWritable: !1 },
        ],
        programId: this.programId,
        data: f,
      };
    return new Mr(h);
  }
  static createAccountWithSeed(e) {
    const t = new rr();
    t.add(
      si.createAccountWithSeed({
        fromPubkey: e.fromPubkey,
        newAccountPubkey: e.stakePubkey,
        basePubkey: e.basePubkey,
        seed: e.seed,
        lamports: e.lamports,
        space: this.space,
        programId: this.programId,
      })
    );
    const { stakePubkey: r, authorized: s, lockup: n } = e;
    return t.add(this.initialize({ stakePubkey: r, authorized: s, lockup: n }));
  }
  static createAccount(e) {
    const t = new rr();
    t.add(
      si.createAccount({
        fromPubkey: e.fromPubkey,
        newAccountPubkey: e.stakePubkey,
        lamports: e.lamports,
        space: this.space,
        programId: this.programId,
      })
    );
    const { stakePubkey: r, authorized: s, lockup: n } = e;
    return t.add(this.initialize({ stakePubkey: r, authorized: s, lockup: n }));
  }
  static delegate(e) {
    const { stakePubkey: t, authorizedPubkey: r, votePubkey: s } = e,
      n = Zr.Delegate,
      c = Dt(n);
    return new rr().add({
      keys: [
        { pubkey: t, isSigner: !1, isWritable: !0 },
        { pubkey: s, isSigner: !1, isWritable: !1 },
        { pubkey: Sn, isSigner: !1, isWritable: !1 },
        { pubkey: Tf, isSigner: !1, isWritable: !1 },
        { pubkey: jS, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ],
      programId: this.programId,
      data: c,
    });
  }
  static authorize(e) {
    const {
        stakePubkey: t,
        authorizedPubkey: r,
        newAuthorizedPubkey: s,
        stakeAuthorizationType: n,
        custodianPubkey: c,
      } = e,
      f = Zr.Authorize,
      h = Dt(f, { newAuthorized: Mt(s.toBuffer()), stakeAuthorizationType: n.index }),
      y = [
        { pubkey: t, isSigner: !1, isWritable: !0 },
        { pubkey: Sn, isSigner: !1, isWritable: !0 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ];
    return (
      c && y.push({ pubkey: c, isSigner: !1, isWritable: !1 }),
      new rr().add({ keys: y, programId: this.programId, data: h })
    );
  }
  static authorizeWithSeed(e) {
    const {
        stakePubkey: t,
        authorityBase: r,
        authoritySeed: s,
        authorityOwner: n,
        newAuthorizedPubkey: c,
        stakeAuthorizationType: f,
        custodianPubkey: h,
      } = e,
      y = Zr.AuthorizeWithSeed,
      p = Dt(y, {
        newAuthorized: Mt(c.toBuffer()),
        stakeAuthorizationType: f.index,
        authoritySeed: s,
        authorityOwner: Mt(n.toBuffer()),
      }),
      m = [
        { pubkey: t, isSigner: !1, isWritable: !0 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
        { pubkey: Sn, isSigner: !1, isWritable: !1 },
      ];
    return (
      h && m.push({ pubkey: h, isSigner: !1, isWritable: !1 }),
      new rr().add({ keys: m, programId: this.programId, data: p })
    );
  }
  static splitInstruction(e) {
    const { stakePubkey: t, authorizedPubkey: r, splitStakePubkey: s, lamports: n } = e,
      c = Zr.Split,
      f = Dt(c, { lamports: n });
    return new Mr({
      keys: [
        { pubkey: t, isSigner: !1, isWritable: !0 },
        { pubkey: s, isSigner: !1, isWritable: !0 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ],
      programId: this.programId,
      data: f,
    });
  }
  static split(e) {
    const t = new rr();
    return (
      t.add(
        si.createAccount({
          fromPubkey: e.authorizedPubkey,
          newAccountPubkey: e.splitStakePubkey,
          lamports: 0,
          space: this.space,
          programId: this.programId,
        })
      ),
      t.add(this.splitInstruction(e))
    );
  }
  static splitWithSeed(e) {
    const {
        stakePubkey: t,
        authorizedPubkey: r,
        splitStakePubkey: s,
        basePubkey: n,
        seed: c,
        lamports: f,
      } = e,
      h = new rr();
    return (
      h.add(
        si.allocate({
          accountPubkey: s,
          basePubkey: n,
          seed: c,
          space: this.space,
          programId: this.programId,
        })
      ),
      h.add(
        this.splitInstruction({
          stakePubkey: t,
          authorizedPubkey: r,
          splitStakePubkey: s,
          lamports: f,
        })
      )
    );
  }
  static merge(e) {
    const { stakePubkey: t, sourceStakePubKey: r, authorizedPubkey: s } = e,
      n = Zr.Merge,
      c = Dt(n);
    return new rr().add({
      keys: [
        { pubkey: t, isSigner: !1, isWritable: !0 },
        { pubkey: r, isSigner: !1, isWritable: !0 },
        { pubkey: Sn, isSigner: !1, isWritable: !1 },
        { pubkey: Tf, isSigner: !1, isWritable: !1 },
        { pubkey: s, isSigner: !0, isWritable: !1 },
      ],
      programId: this.programId,
      data: c,
    });
  }
  static withdraw(e) {
    const { stakePubkey: t, authorizedPubkey: r, toPubkey: s, lamports: n, custodianPubkey: c } = e,
      f = Zr.Withdraw,
      h = Dt(f, { lamports: n }),
      y = [
        { pubkey: t, isSigner: !1, isWritable: !0 },
        { pubkey: s, isSigner: !1, isWritable: !0 },
        { pubkey: Sn, isSigner: !1, isWritable: !1 },
        { pubkey: Tf, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ];
    return (
      c && y.push({ pubkey: c, isSigner: !1, isWritable: !1 }),
      new rr().add({ keys: y, programId: this.programId, data: h })
    );
  }
  static deactivate(e) {
    const { stakePubkey: t, authorizedPubkey: r } = e,
      s = Zr.Deactivate,
      n = Dt(s);
    return new rr().add({
      keys: [
        { pubkey: t, isSigner: !1, isWritable: !0 },
        { pubkey: Sn, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ],
      programId: this.programId,
      data: n,
    });
  }
}
ch.programId = new Xe('Stake11111111111111111111111111111111111111');
ch.space = 200;
class VS {
  constructor(e, t, r, s) {
    (this.nodePubkey = void 0),
      (this.authorizedVoter = void 0),
      (this.authorizedWithdrawer = void 0),
      (this.commission = void 0),
      (this.nodePubkey = e),
      (this.authorizedVoter = t),
      (this.authorizedWithdrawer = r),
      (this.commission = s);
  }
}
class W$ {
  constructor() {}
  static decodeInstructionType(e) {
    this.checkProgramId(e.programId);
    const r = qe('instruction').decode(e.data);
    let s;
    for (const [n, c] of Object.entries(eo))
      if (c.index == r) {
        s = n;
        break;
      }
    if (!s) throw new Error('Instruction type incorrect; not a VoteInstruction');
    return s;
  }
  static decodeInitializeAccount(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 4);
    const { voteInit: t } = tr(eo.InitializeAccount, e.data);
    return {
      votePubkey: e.keys[0].pubkey,
      nodePubkey: e.keys[3].pubkey,
      voteInit: new VS(
        new Xe(t.nodePubkey),
        new Xe(t.authorizedVoter),
        new Xe(t.authorizedWithdrawer),
        t.commission
      ),
    };
  }
  static decodeAuthorize(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
    const { newAuthorized: t, voteAuthorizationType: r } = tr(eo.Authorize, e.data);
    return {
      votePubkey: e.keys[0].pubkey,
      authorizedPubkey: e.keys[2].pubkey,
      newAuthorizedPubkey: new Xe(t),
      voteAuthorizationType: { index: r },
    };
  }
  static decodeAuthorizeWithSeed(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
    const {
      voteAuthorizeWithSeedArgs: {
        currentAuthorityDerivedKeyOwnerPubkey: t,
        currentAuthorityDerivedKeySeed: r,
        newAuthorized: s,
        voteAuthorizationType: n,
      },
    } = tr(eo.AuthorizeWithSeed, e.data);
    return {
      currentAuthorityDerivedKeyBasePubkey: e.keys[2].pubkey,
      currentAuthorityDerivedKeyOwnerPubkey: new Xe(t),
      currentAuthorityDerivedKeySeed: r,
      newAuthorizedPubkey: new Xe(s),
      voteAuthorizationType: { index: n },
      votePubkey: e.keys[0].pubkey,
    };
  }
  static decodeWithdraw(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
    const { lamports: t } = tr(eo.Withdraw, e.data);
    return {
      votePubkey: e.keys[0].pubkey,
      authorizedWithdrawerPubkey: e.keys[2].pubkey,
      lamports: t,
      toPubkey: e.keys[1].pubkey,
    };
  }
  static checkProgramId(e) {
    if (!e.equals(eu.programId))
      throw new Error('invalid instruction; programId is not VoteProgram');
  }
  static checkKeyLength(e, t) {
    if (e.length < t)
      throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`);
  }
}
const eo = Object.freeze({
    InitializeAccount: { index: 0, layout: We([qe('instruction'), GL()]) },
    Authorize: {
      index: 1,
      layout: We([qe('instruction'), xt('newAuthorized'), qe('voteAuthorizationType')]),
    },
    Withdraw: { index: 3, layout: We([qe('instruction'), Ir('lamports')]) },
    AuthorizeWithSeed: { index: 10, layout: We([qe('instruction'), YL()]) },
  }),
  K$ = Object.freeze({ Voter: { index: 0 }, Withdrawer: { index: 1 } });
class eu {
  constructor() {}
  static initializeAccount(e) {
    const { votePubkey: t, nodePubkey: r, voteInit: s } = e,
      n = eo.InitializeAccount,
      c = Dt(n, {
        voteInit: {
          nodePubkey: Mt(s.nodePubkey.toBuffer()),
          authorizedVoter: Mt(s.authorizedVoter.toBuffer()),
          authorizedWithdrawer: Mt(s.authorizedWithdrawer.toBuffer()),
          commission: s.commission,
        },
      }),
      f = {
        keys: [
          { pubkey: t, isSigner: !1, isWritable: !0 },
          { pubkey: Ca, isSigner: !1, isWritable: !1 },
          { pubkey: Sn, isSigner: !1, isWritable: !1 },
          { pubkey: r, isSigner: !0, isWritable: !1 },
        ],
        programId: this.programId,
        data: c,
      };
    return new Mr(f);
  }
  static createAccount(e) {
    const t = new rr();
    return (
      t.add(
        si.createAccount({
          fromPubkey: e.fromPubkey,
          newAccountPubkey: e.votePubkey,
          lamports: e.lamports,
          space: this.space,
          programId: this.programId,
        })
      ),
      t.add(
        this.initializeAccount({
          votePubkey: e.votePubkey,
          nodePubkey: e.voteInit.nodePubkey,
          voteInit: e.voteInit,
        })
      )
    );
  }
  static authorize(e) {
    const {
        votePubkey: t,
        authorizedPubkey: r,
        newAuthorizedPubkey: s,
        voteAuthorizationType: n,
      } = e,
      c = eo.Authorize,
      f = Dt(c, { newAuthorized: Mt(s.toBuffer()), voteAuthorizationType: n.index }),
      h = [
        { pubkey: t, isSigner: !1, isWritable: !0 },
        { pubkey: Sn, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ];
    return new rr().add({ keys: h, programId: this.programId, data: f });
  }
  static authorizeWithSeed(e) {
    const {
        currentAuthorityDerivedKeyBasePubkey: t,
        currentAuthorityDerivedKeyOwnerPubkey: r,
        currentAuthorityDerivedKeySeed: s,
        newAuthorizedPubkey: n,
        voteAuthorizationType: c,
        votePubkey: f,
      } = e,
      h = eo.AuthorizeWithSeed,
      y = Dt(h, {
        voteAuthorizeWithSeedArgs: {
          currentAuthorityDerivedKeyOwnerPubkey: Mt(r.toBuffer()),
          currentAuthorityDerivedKeySeed: s,
          newAuthorized: Mt(n.toBuffer()),
          voteAuthorizationType: c.index,
        },
      }),
      p = [
        { pubkey: f, isSigner: !1, isWritable: !0 },
        { pubkey: Sn, isSigner: !1, isWritable: !1 },
        { pubkey: t, isSigner: !0, isWritable: !1 },
      ];
    return new rr().add({ keys: p, programId: this.programId, data: y });
  }
  static withdraw(e) {
    const { votePubkey: t, authorizedWithdrawerPubkey: r, lamports: s, toPubkey: n } = e,
      c = eo.Withdraw,
      f = Dt(c, { lamports: s }),
      h = [
        { pubkey: t, isSigner: !1, isWritable: !0 },
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ];
    return new rr().add({ keys: h, programId: this.programId, data: f });
  }
  static safeWithdraw(e, t, r) {
    if (e.lamports > t - r)
      throw new Error('Withdraw will leave vote account with insuffcient funds.');
    return eu.withdraw(e);
  }
}
eu.programId = new Xe('Vote111111111111111111111111111111111111111');
eu.space = 3731;
const GS = new Xe('Va1idator1nfo111111111111111111111111111111'),
  j$ = pe({ name: we(), website: Ge(we()), details: Ge(we()), keybaseUsername: Ge(we()) });
class pg {
  constructor(e, t) {
    (this.key = void 0), (this.info = void 0), (this.key = e), (this.info = t);
  }
  static fromConfigData(e) {
    let t = [...e];
    if (Mi(t) !== 2) return null;
    const s = [];
    for (let n = 0; n < 2; n++) {
      const c = new Xe(t.slice(0, $i));
      t = t.slice($i);
      const f = t.slice(0, 1)[0] === 1;
      (t = t.slice(1)), s.push({ publicKey: c, isSigner: f });
    }
    if (s[0].publicKey.equals(GS) && s[1].isSigner) {
      const n = ns().decode(He.from(t)),
        c = JSON.parse(n);
      return Ny(c, j$), new pg(s[1].publicKey, c);
    }
    return null;
  }
}
const H$ = new Xe('Vote111111111111111111111111111111111111111'),
  V$ = We([
    xt('nodePubkey'),
    xt('authorizedWithdrawer'),
    tt('commission'),
    Nt(),
    zt(We([Nt('slot'), qe('confirmationCount')]), _i(qe(), -8), 'votes'),
    tt('rootSlotValid'),
    Nt('rootSlot'),
    Nt(),
    zt(We([Nt('epoch'), xt('authorizedVoter')]), _i(qe(), -8), 'authorizedVoters'),
    We(
      [
        zt(
          We([xt('authorizedPubkey'), Nt('epochOfLastAuthorizedSwitch'), Nt('targetEpoch')]),
          32,
          'buf'
        ),
        Nt('idx'),
        tt('isEmpty'),
      ],
      'priorVoters'
    ),
    Nt(),
    zt(We([Nt('epoch'), Nt('credits'), Nt('prevCredits')]), _i(qe(), -8), 'epochCredits'),
    We([Nt('slot'), Nt('timestamp')], 'lastTimestamp'),
  ]);
class yg {
  constructor(e) {
    (this.nodePubkey = void 0),
      (this.authorizedWithdrawer = void 0),
      (this.commission = void 0),
      (this.rootSlot = void 0),
      (this.votes = void 0),
      (this.authorizedVoters = void 0),
      (this.priorVoters = void 0),
      (this.epochCredits = void 0),
      (this.lastTimestamp = void 0),
      (this.nodePubkey = e.nodePubkey),
      (this.authorizedWithdrawer = e.authorizedWithdrawer),
      (this.commission = e.commission),
      (this.rootSlot = e.rootSlot),
      (this.votes = e.votes),
      (this.authorizedVoters = e.authorizedVoters),
      (this.priorVoters = e.priorVoters),
      (this.epochCredits = e.epochCredits),
      (this.lastTimestamp = e.lastTimestamp);
  }
  static fromAccountData(e) {
    const r = V$.decode(Mt(e), 4);
    let s = r.rootSlot;
    return (
      r.rootSlotValid || (s = null),
      new yg({
        nodePubkey: new Xe(r.nodePubkey),
        authorizedWithdrawer: new Xe(r.authorizedWithdrawer),
        commission: r.commission,
        votes: r.votes,
        rootSlot: s,
        authorizedVoters: r.authorizedVoters.map(G$),
        priorVoters: Y$(r.priorVoters),
        epochCredits: r.epochCredits,
        lastTimestamp: r.lastTimestamp,
      })
    );
  }
}
function G$({ authorizedVoter: i, epoch: e }) {
  return { epoch: e, authorizedVoter: new Xe(i) };
}
function a2({ authorizedPubkey: i, epochOfLastAuthorizedSwitch: e, targetEpoch: t }) {
  return { authorizedPubkey: new Xe(i), epochOfLastAuthorizedSwitch: e, targetEpoch: t };
}
function Y$({ buf: i, idx: e, isEmpty: t }) {
  return t ? [] : [...i.slice(e + 1).map(a2), ...i.slice(0, e).map(a2)];
}
const u2 = {
  http: {
    devnet: 'http://api.devnet.solana.com',
    testnet: 'http://api.testnet.solana.com',
    'mainnet-beta': 'http://api.mainnet-beta.solana.com/',
  },
  https: {
    devnet: 'https://api.devnet.solana.com',
    testnet: 'https://api.testnet.solana.com',
    'mainnet-beta': 'https://api.mainnet-beta.solana.com/',
  },
};
function Z$(i, e) {
  const t = e === !1 ? 'http' : 'https';
  if (!i) return u2[t].devnet;
  const r = u2[t][i];
  if (!r) throw new Error(`Unknown ${t} cluster: ${i}`);
  return r;
}
async function J$(i, e, t, r) {
  let s, n;
  (t && Object.prototype.hasOwnProperty.call(t, 'lastValidBlockHeight')) ||
  (t && Object.prototype.hasOwnProperty.call(t, 'nonceValue'))
    ? ((s = t), (n = r))
    : (n = t);
  const c = n && {
      skipPreflight: n.skipPreflight,
      preflightCommitment: n.preflightCommitment || n.commitment,
      minContextSlot: n.minContextSlot,
    },
    f = await i.sendRawTransaction(e, c),
    h = n && n.commitment,
    p = (await (s ? i.confirmTransaction(s, h) : i.confirmTransaction(f, h))).value;
  if (p.err) throw new Error(`Raw transaction ${f} failed (${JSON.stringify(p)})`);
  return f;
}
const X$ = 1e9,
  Q$ = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Account: WL,
        AddressLookupTableAccount: C1,
        AddressLookupTableInstruction: N$,
        AddressLookupTableProgram: hg,
        Authorized: HS,
        BLOCKHASH_CACHE_TIMEOUT_MS: LS,
        BPF_LOADER_DEPRECATED_PROGRAM_ID: KL,
        BPF_LOADER_PROGRAM_ID: sN,
        BpfLoader: aN,
        COMPUTE_BUDGET_INSTRUCTION_LAYOUTS: En,
        ComputeBudgetInstruction: $$,
        ComputeBudgetProgram: dg,
        Connection: L$,
        Ed25519Program: uh,
        Enum: FL,
        EpochSchedule: OS,
        FeeCalculatorLayout: PS,
        Keypair: pa,
        LAMPORTS_PER_SOL: X$,
        LOOKUP_TABLE_INSTRUCTION_LAYOUTS: Qn,
        Loader: Es,
        Lockup: Ku,
        MAX_SEED_LENGTH: BS,
        Message: dn,
        MessageAccountKeys: qu,
        MessageV0: As,
        NONCE_ACCOUNT_LENGTH: T1,
        NonceAccount: oh,
        PACKET_DATA_SIZE: Lo,
        PUBLIC_KEY_LENGTH: $i,
        PublicKey: Xe,
        SIGNATURE_LENGTH_IN_BYTES: Oa,
        SOLANA_SCHEMA: Iu,
        STAKE_CONFIG_ID: jS,
        STAKE_INSTRUCTION_LAYOUTS: Zr,
        SYSTEM_INSTRUCTION_LAYOUTS: Er,
        SYSVAR_CLOCK_PUBKEY: Sn,
        SYSVAR_EPOCH_SCHEDULE_PUBKEY: JL,
        SYSVAR_INSTRUCTIONS_PUBKEY: XL,
        SYSVAR_RECENT_BLOCKHASHES_PUBKEY: Pf,
        SYSVAR_RENT_PUBKEY: Ca,
        SYSVAR_REWARDS_PUBKEY: QL,
        SYSVAR_SLOT_HASHES_PUBKEY: eN,
        SYSVAR_SLOT_HISTORY_PUBKEY: tN,
        SYSVAR_STAKE_HISTORY_PUBKEY: Tf,
        Secp256k1Program: ya,
        SendTransactionError: O1,
        SolanaJSONRPCError: ot,
        SolanaJSONRPCErrorCode: hN,
        StakeAuthorizationLayout: q$,
        StakeInstruction: F$,
        StakeProgram: ch,
        Struct: ig,
        SystemInstruction: nN,
        SystemProgram: si,
        Transaction: rr,
        TransactionExpiredBlockheightExceededError: ng,
        TransactionExpiredNonceInvalidError: na,
        TransactionExpiredTimeoutError: og,
        TransactionInstruction: Mr,
        TransactionMessage: ag,
        get TransactionStatus() {
          return on;
        },
        VALIDATOR_INFO_KEY: GS,
        VERSION_PREFIX_MASK: ih,
        VOTE_PROGRAM_ID: H$,
        ValidatorInfo: pg,
        VersionedMessage: sg,
        VersionedTransaction: ug,
        VoteAccount: yg,
        VoteAuthorizationLayout: K$,
        VoteInit: VS,
        VoteInstruction: W$,
        VoteProgram: eu,
        clusterApiUrl: Z$,
        sendAndConfirmRawTransaction: J$,
        sendAndConfirmTransaction: Of,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  eD = pn(Q$);
Object.defineProperty(Ms, '__esModule', { value: !0 });
Ms.keysTypeMap = Ms.publicKey = void 0;
const tD = eD,
  rD = Jt,
  iD = '@metaplex-foundation/beet-solana',
  nD = '@solana/web3.js',
  Rp = (0, rD.fixedSizeUint8Array)(32);
Ms.publicKey = {
  write: function (i, e, t) {
    const r = t.toBytes();
    Rp.write(i, e, r);
  },
  read: function (i, e) {
    const t = Rp.read(i, e);
    return new tD.PublicKey(t);
  },
  byteSize: Rp.byteSize,
  description: 'PublicKey',
};
Ms.keysTypeMap = {
  publicKey: { beet: 'publicKey', isFixable: !1, sourcePack: iD, ts: 'PublicKey', pack: nD },
};
var fh = {},
  Bn = {},
  oD =
    (se && se.__importDefault) ||
    function (i) {
      return i && i.__esModule ? i : { default: i };
    };
Object.defineProperty(Bn, '__esModule', { value: !0 });
Bn.logTrace = Bn.logDebug = Bn.logInfo = Bn.logError = void 0;
const lh = oD(Q_);
Bn.logError = (0, lh.default)('beet:error');
Bn.logInfo = (0, lh.default)('beet:info');
Bn.logDebug = (0, lh.default)('beet:debug');
Bn.logTrace = (0, lh.default)('beet:trace');
var hh = {};
function sD(i) {
  if (i.length >= 255) throw new TypeError('Alphabet too long');
  for (var e = new Uint8Array(256), t = 0; t < e.length; t++) e[t] = 255;
  for (var r = 0; r < i.length; r++) {
    var s = i.charAt(r),
      n = s.charCodeAt(0);
    if (e[n] !== 255) throw new TypeError(s + ' is ambiguous');
    e[n] = r;
  }
  var c = i.length,
    f = i.charAt(0),
    h = Math.log(c) / Math.log(256),
    y = Math.log(256) / Math.log(c);
  function p(A) {
    if (
      (A instanceof Uint8Array ||
        (ArrayBuffer.isView(A)
          ? (A = new Uint8Array(A.buffer, A.byteOffset, A.byteLength))
          : Array.isArray(A) && (A = Uint8Array.from(A))),
      !(A instanceof Uint8Array))
    )
      throw new TypeError('Expected Uint8Array');
    if (A.length === 0) return '';
    for (var E = 0, I = 0, R = 0, L = A.length; R !== L && A[R] === 0; ) R++, E++;
    for (var D = ((L - R) * y + 1) >>> 0, q = new Uint8Array(D); R !== L; ) {
      for (var H = A[R], V = 0, te = D - 1; (H !== 0 || V < I) && te !== -1; te--, V++)
        (H += (256 * q[te]) >>> 0), (q[te] = H % c >>> 0), (H = (H / c) >>> 0);
      if (H !== 0) throw new Error('Non-zero carry');
      (I = V), R++;
    }
    for (var ue = D - I; ue !== D && q[ue] === 0; ) ue++;
    for (var ne = f.repeat(E); ue < D; ++ue) ne += i.charAt(q[ue]);
    return ne;
  }
  function m(A) {
    if (typeof A != 'string') throw new TypeError('Expected String');
    if (A.length === 0) return new Uint8Array();
    for (var E = 0, I = 0, R = 0; A[E] === f; ) I++, E++;
    for (var L = ((A.length - E) * h + 1) >>> 0, D = new Uint8Array(L); A[E]; ) {
      var q = e[A.charCodeAt(E)];
      if (q === 255) return;
      for (var H = 0, V = L - 1; (q !== 0 || H < R) && V !== -1; V--, H++)
        (q += (c * D[V]) >>> 0), (D[V] = q % 256 >>> 0), (q = (q / 256) >>> 0);
      if (q !== 0) throw new Error('Non-zero carry');
      (R = H), E++;
    }
    for (var te = L - R; te !== L && D[te] === 0; ) te++;
    for (var ue = new Uint8Array(I + (L - te)), ne = I; te !== L; ) ue[ne++] = D[te++];
    return ue;
  }
  function _(A) {
    var E = m(A);
    if (E) return E;
    throw new Error('Non-base' + c + ' character');
  }
  return { encode: p, decodeUnsafe: m, decode: _ };
}
var aD = sD;
const uD = aD,
  cD = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
var fD = uD(cD),
  lD =
    (se && se.__importDefault) ||
    function (i) {
      return i && i.__esModule ? i : { default: i };
    };
Object.defineProperty(hh, '__esModule', { value: !0 });
hh.encodeFixedBeet = void 0;
const hD = lD(fD);
function dD(i, e) {
  const t = Ze.alloc(i.byteSize);
  return i.write(t, 0, e), hD.default.encode(t);
}
hh.encodeFixedBeet = dD;
Object.defineProperty(fh, '__esModule', { value: !0 });
fh.GpaBuilder = void 0;
const Pp = Jt,
  gu = Ui(),
  pD = Bn,
  c2 = hh;
class fl {
  constructor(e, t, r) {
    (this.programId = e), (this.beets = t), (this.accountSize = r), (this.config = {});
  }
  _addFilter(e) {
    return (
      this.config.filters == null && (this.config.filters = []), this.config.filters.push(e), this
    );
  }
  _addInnerFilter(e, t, r) {
    (0, pD.logTrace)(`gpa.addInnerFilter: ${e}.${t}`);
    const s = this.beets.get(e);
    (0, gu.strict)(s != null, 'Outer filter key needs to be an existing field name');
    const n = s.beet;
    let c = s.offset;
    const f = (0, Pp.isFixedSizeBeet)(n) ? n : n.toFixedFromValue(r);
    let h;
    for (const [p, m] of f.fields) {
      if (p === t) {
        h = m;
        break;
      }
      c += m.byteSize;
    }
    (0, gu.strict)(h != null, `${t} is not a field of the ${e} struct`);
    const y = (0, c2.encodeFixedBeet)(h, r);
    return this._addFilter({ memcmp: { offset: c, bytes: y } }), this;
  }
  addInnerFilter(e, t) {
    const r = e.split('.');
    gu.strict.equal(
      r.length,
      2,
      "inner filters can go only one level deep, i.e. 'outer.inner' is ok, but 'outer.inner.deep' is not"
    );
    const [s, n] = r;
    return this._addInnerFilter(s, n, t);
  }
  addFilter(e, t) {
    const r = this.beets.get(e);
    (0, gu.strict)(r != null, 'Filter key needs to be an existing field name');
    const s = (0, Pp.isFixedSizeBeet)(r.beet) ? r.beet : r.beet.toFixedFromValue(t),
      n = (0, c2.encodeFixedBeet)(s, t);
    return this._addFilter({ memcmp: { offset: r.offset, bytes: n } }), this;
  }
  dataSize(e) {
    return (
      (e = e ?? this.accountSize),
      (0, gu.strict)(
        e != null,
        'for accounts of dynamic size the dataSize arg needs to be provided'
      ),
      this._addFilter({ dataSize: e })
    );
  }
  run(e) {
    return e.getProgramAccounts(this.programId, this.config);
  }
  static fromBeetFields(e, t) {
    const r = new Map();
    let s = 0,
      n = !1;
    for (const [f, h] of t) {
      if ((r.set(f, { beet: h, offset: s }), !(0, Pp.isFixedSizeBeet)(h))) {
        n = !0;
        break;
      }
      s += h.byteSize;
    }
    const c = n ? void 0 : s;
    return new fl(e, r, c);
  }
  static fromStruct(e, t) {
    return fl.fromBeetFields(e, t.fields);
  }
}
fh.GpaBuilder = fl;
(function (i) {
  var e =
      (se && se.__createBinding) ||
      (Object.create
        ? function (s, n, c, f) {
            f === void 0 && (f = c);
            var h = Object.getOwnPropertyDescriptor(n, c);
            (!h || ('get' in h ? !n.__esModule : h.writable || h.configurable)) &&
              (h = {
                enumerable: !0,
                get: function () {
                  return n[c];
                },
              }),
              Object.defineProperty(s, f, h);
          }
        : function (s, n, c, f) {
            f === void 0 && (f = c), (s[f] = n[c]);
          }),
    t =
      (se && se.__exportStar) ||
      function (s, n) {
        for (var c in s)
          c !== 'default' && !Object.prototype.hasOwnProperty.call(n, c) && e(n, s, c);
      };
  Object.defineProperty(i, '__esModule', { value: !0 }), (i.supportedTypeMap = void 0);
  const r = Ms;
  t(Ms, i), t(fh, i), (i.supportedTypeMap = r.keysTypeMap);
})(Cs);
(function (i) {
  var e =
      (se && se.__createBinding) ||
      (Object.create
        ? function (h, y, p, m) {
            m === void 0 && (m = p);
            var _ = Object.getOwnPropertyDescriptor(y, p);
            (!_ || ('get' in _ ? !y.__esModule : _.writable || _.configurable)) &&
              (_ = {
                enumerable: !0,
                get: function () {
                  return y[p];
                },
              }),
              Object.defineProperty(h, m, _);
          }
        : function (h, y, p, m) {
            m === void 0 && (m = p), (h[m] = y[p]);
          }),
    t =
      (se && se.__setModuleDefault) ||
      (Object.create
        ? function (h, y) {
            Object.defineProperty(h, 'default', { enumerable: !0, value: y });
          }
        : function (h, y) {
            h.default = y;
          }),
    r =
      (se && se.__importStar) ||
      function (h) {
        if (h && h.__esModule) return h;
        var y = {};
        if (h != null)
          for (var p in h)
            p !== 'default' && Object.prototype.hasOwnProperty.call(h, p) && e(y, h, p);
        return t(y, h), y;
      };
  Object.defineProperty(i, '__esModule', { value: !0 }),
    (i.treeConfigBeet = i.TreeConfig = i.treeConfigDiscriminator = void 0);
  const s = r(qr),
    n = r(Jt),
    c = r(Cs);
  i.treeConfigDiscriminator = [122, 245, 175, 248, 171, 34, 0, 207];
  class f {
    constructor(y, p, m, _, A) {
      (this.treeCreator = y),
        (this.treeDelegate = p),
        (this.totalMintCapacity = m),
        (this.numMinted = _),
        (this.isPublic = A);
    }
    static fromArgs(y) {
      return new f(y.treeCreator, y.treeDelegate, y.totalMintCapacity, y.numMinted, y.isPublic);
    }
    static fromAccountInfo(y, p = 0) {
      return f.deserialize(y.data, p);
    }
    static async fromAccountAddress(y, p, m) {
      const _ = await y.getAccountInfo(p, m);
      if (_ == null) throw new Error(`Unable to find TreeConfig account at ${p}`);
      return f.fromAccountInfo(_, 0)[0];
    }
    static gpaBuilder(y = new s.PublicKey('BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY')) {
      return c.GpaBuilder.fromStruct(y, i.treeConfigBeet);
    }
    static deserialize(y, p = 0) {
      return i.treeConfigBeet.deserialize(y, p);
    }
    serialize() {
      return i.treeConfigBeet.serialize({
        accountDiscriminator: i.treeConfigDiscriminator,
        ...this,
      });
    }
    static get byteSize() {
      return i.treeConfigBeet.byteSize;
    }
    static async getMinimumBalanceForRentExemption(y, p) {
      return y.getMinimumBalanceForRentExemption(f.byteSize, p);
    }
    static hasCorrectByteSize(y, p = 0) {
      return y.byteLength - p === f.byteSize;
    }
    pretty() {
      return {
        treeCreator: this.treeCreator.toBase58(),
        treeDelegate: this.treeDelegate.toBase58(),
        totalMintCapacity: (() => {
          const y = this.totalMintCapacity;
          if (typeof y.toNumber == 'function')
            try {
              return y.toNumber();
            } catch {
              return y;
            }
          return y;
        })(),
        numMinted: (() => {
          const y = this.numMinted;
          if (typeof y.toNumber == 'function')
            try {
              return y.toNumber();
            } catch {
              return y;
            }
          return y;
        })(),
        isPublic: this.isPublic,
      };
    }
  }
  (i.TreeConfig = f),
    (i.treeConfigBeet = new n.BeetStruct(
      [
        ['accountDiscriminator', n.uniformFixedSizeArray(n.u8, 8)],
        ['treeCreator', c.publicKey],
        ['treeDelegate', c.publicKey],
        ['totalMintCapacity', n.u64],
        ['numMinted', n.u64],
        ['isPublic', n.bool],
      ],
      f.fromArgs,
      'TreeConfig'
    ));
})(b1);
var D1 = {},
  ks = {},
  yD =
    (se && se.__createBinding) ||
    (Object.create
      ? function (i, e, t, r) {
          r === void 0 && (r = t);
          var s = Object.getOwnPropertyDescriptor(e, t);
          (!s || ('get' in s ? !e.__esModule : s.writable || s.configurable)) &&
            (s = {
              enumerable: !0,
              get: function () {
                return e[t];
              },
            }),
            Object.defineProperty(i, r, s);
        }
      : function (i, e, t, r) {
          r === void 0 && (r = t), (i[r] = e[t]);
        }),
  gD =
    (se && se.__setModuleDefault) ||
    (Object.create
      ? function (i, e) {
          Object.defineProperty(i, 'default', { enumerable: !0, value: e });
        }
      : function (i, e) {
          i.default = e;
        }),
  YS =
    (se && se.__importStar) ||
    function (i) {
      if (i && i.__esModule) return i;
      var e = {};
      if (i != null)
        for (var t in i)
          t !== 'default' && Object.prototype.hasOwnProperty.call(i, t) && yD(e, i, t);
      return gD(e, i), e;
    };
Object.defineProperty(ks, '__esModule', { value: !0 });
ks.leafSchemaBeet = ks.isLeafSchemaV1 = void 0;
const Yo = YS(Jt),
  Tp = YS(Cs),
  bD = (i) => i.__kind === 'V1';
ks.isLeafSchemaV1 = bD;
ks.leafSchemaBeet = Yo.dataEnum([
  [
    'V1',
    new Yo.BeetArgsStruct(
      [
        ['id', Tp.publicKey],
        ['owner', Tp.publicKey],
        ['delegate', Tp.publicKey],
        ['nonce', Yo.u64],
        ['dataHash', Yo.uniformFixedSizeArray(Yo.u8, 32)],
        ['creatorHash', Yo.uniformFixedSizeArray(Yo.u8, 32)],
      ],
      'LeafSchemaRecord["V1"]'
    ),
  ],
]);
(function (i) {
  var e =
      (se && se.__createBinding) ||
      (Object.create
        ? function (y, p, m, _) {
            _ === void 0 && (_ = m);
            var A = Object.getOwnPropertyDescriptor(p, m);
            (!A || ('get' in A ? !p.__esModule : A.writable || A.configurable)) &&
              (A = {
                enumerable: !0,
                get: function () {
                  return p[m];
                },
              }),
              Object.defineProperty(y, _, A);
          }
        : function (y, p, m, _) {
            _ === void 0 && (_ = m), (y[_] = p[m]);
          }),
    t =
      (se && se.__setModuleDefault) ||
      (Object.create
        ? function (y, p) {
            Object.defineProperty(y, 'default', { enumerable: !0, value: p });
          }
        : function (y, p) {
            y.default = p;
          }),
    r =
      (se && se.__importStar) ||
      function (y) {
        if (y && y.__esModule) return y;
        var p = {};
        if (y != null)
          for (var m in y)
            m !== 'default' && Object.prototype.hasOwnProperty.call(y, m) && e(p, y, m);
        return t(p, y), p;
      };
  Object.defineProperty(i, '__esModule', { value: !0 }),
    (i.voucherBeet = i.Voucher = i.voucherDiscriminator = void 0);
  const s = r(qr),
    n = r(Jt),
    c = r(Cs),
    f = ks;
  i.voucherDiscriminator = [191, 204, 149, 234, 213, 165, 13, 65];
  class h {
    constructor(p, m, _) {
      (this.leafSchema = p), (this.index = m), (this.merkleTree = _);
    }
    static fromArgs(p) {
      return new h(p.leafSchema, p.index, p.merkleTree);
    }
    static fromAccountInfo(p, m = 0) {
      return h.deserialize(p.data, m);
    }
    static async fromAccountAddress(p, m, _) {
      const A = await p.getAccountInfo(m, _);
      if (A == null) throw new Error(`Unable to find Voucher account at ${m}`);
      return h.fromAccountInfo(A, 0)[0];
    }
    static gpaBuilder(p = new s.PublicKey('BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY')) {
      return c.GpaBuilder.fromStruct(p, i.voucherBeet);
    }
    static deserialize(p, m = 0) {
      return i.voucherBeet.deserialize(p, m);
    }
    serialize() {
      return i.voucherBeet.serialize({ accountDiscriminator: i.voucherDiscriminator, ...this });
    }
    static byteSize(p) {
      const m = h.fromArgs(p);
      return i.voucherBeet.toFixedFromValue({ accountDiscriminator: i.voucherDiscriminator, ...m })
        .byteSize;
    }
    static async getMinimumBalanceForRentExemption(p, m, _) {
      return m.getMinimumBalanceForRentExemption(h.byteSize(p), _);
    }
    pretty() {
      return {
        leafSchema: this.leafSchema.__kind,
        index: this.index,
        merkleTree: this.merkleTree.toBase58(),
      };
    }
  }
  (i.Voucher = h),
    (i.voucherBeet = new n.FixableBeetStruct(
      [
        ['accountDiscriminator', n.uniformFixedSizeArray(n.u8, 8)],
        ['leafSchema', f.leafSchemaBeet],
        ['index', n.u32],
        ['merkleTree', c.publicKey],
      ],
      h.fromArgs,
      'Voucher'
    ));
})(D1);
(function (i) {
  var e =
      (se && se.__createBinding) ||
      (Object.create
        ? function (n, c, f, h) {
            h === void 0 && (h = f);
            var y = Object.getOwnPropertyDescriptor(c, f);
            (!y || ('get' in y ? !c.__esModule : y.writable || y.configurable)) &&
              (y = {
                enumerable: !0,
                get: function () {
                  return c[f];
                },
              }),
              Object.defineProperty(n, h, y);
          }
        : function (n, c, f, h) {
            h === void 0 && (h = f), (n[h] = c[f]);
          }),
    t =
      (se && se.__exportStar) ||
      function (n, c) {
        for (var f in n)
          f !== 'default' && !Object.prototype.hasOwnProperty.call(c, f) && e(c, n, f);
      };
  Object.defineProperty(i, '__esModule', { value: !0 }),
    (i.accountProviders = void 0),
    t(b1, i),
    t(D1, i);
  const r = b1,
    s = D1;
  i.accountProviders = { TreeConfig: r.TreeConfig, Voucher: s.Voucher };
})(J_);
var it = {};
Object.defineProperty(it, '__esModule', { value: !0 });
it.errorFromName =
  it.errorFromCode =
  it.CollectionMustBeSizedError =
  it.LeafAuthorityMustSignError =
  it.UpdateAuthorityIncorrectError =
  it.AlreadyUnverifiedError =
  it.AlreadyVerifiedError =
  it.CollectionNotFoundError =
  it.CollectionCannotBeVerifiedInThisInstructionError =
  it.IncorrectOwnerError =
  it.NumericalOverflowErrorError =
  it.InsufficientMintCapacityError =
  it.TreeAuthorityIncorrectError =
  it.MetadataBasisPointsTooHighError =
  it.MetadataUriTooLongError =
  it.MetadataSymbolTooLongError =
  it.MetadataNameTooLongError =
  it.CreatorsTooLongError =
  it.DataHashMismatchError =
  it.CreatorHashMismatchError =
  it.NoCreatorsPresentError =
  it.CreatorNotFoundError =
  it.CreatorDidNotVerifyError =
  it.DuplicateCreatorAddressError =
  it.CreatorShareTotalMustBe100Error =
  it.UnsupportedSchemaVersionError =
  it.HashingMismatchError =
  it.PublicKeyMismatchError =
  it.AssetOwnerMismatchError =
    void 0;
const ur = new Map(),
  cr = new Map();
class lc extends Error {
  constructor() {
    super('Asset Owner Does not match'),
      (this.code = 6e3),
      (this.name = 'AssetOwnerMismatch'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, lc);
  }
}
it.AssetOwnerMismatchError = lc;
ur.set(6e3, () => new lc());
cr.set('AssetOwnerMismatch', () => new lc());
class hc extends Error {
  constructor() {
    super('PublicKeyMismatch'),
      (this.code = 6001),
      (this.name = 'PublicKeyMismatch'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, hc);
  }
}
it.PublicKeyMismatchError = hc;
ur.set(6001, () => new hc());
cr.set('PublicKeyMismatch', () => new hc());
class dc extends Error {
  constructor() {
    super('Hashing Mismatch Within Leaf Schema'),
      (this.code = 6002),
      (this.name = 'HashingMismatch'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, dc);
  }
}
it.HashingMismatchError = dc;
ur.set(6002, () => new dc());
cr.set('HashingMismatch', () => new dc());
class pc extends Error {
  constructor() {
    super('Unsupported Schema Version'),
      (this.code = 6003),
      (this.name = 'UnsupportedSchemaVersion'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, pc);
  }
}
it.UnsupportedSchemaVersionError = pc;
ur.set(6003, () => new pc());
cr.set('UnsupportedSchemaVersion', () => new pc());
class yc extends Error {
  constructor() {
    super('Creator shares must sum to 100'),
      (this.code = 6004),
      (this.name = 'CreatorShareTotalMustBe100'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, yc);
  }
}
it.CreatorShareTotalMustBe100Error = yc;
ur.set(6004, () => new yc());
cr.set('CreatorShareTotalMustBe100', () => new yc());
class gc extends Error {
  constructor() {
    super('No duplicate creator addresses in metadata'),
      (this.code = 6005),
      (this.name = 'DuplicateCreatorAddress'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, gc);
  }
}
it.DuplicateCreatorAddressError = gc;
ur.set(6005, () => new gc());
cr.set('DuplicateCreatorAddress', () => new gc());
class bc extends Error {
  constructor() {
    super('Creator did not verify the metadata'),
      (this.code = 6006),
      (this.name = 'CreatorDidNotVerify'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, bc);
  }
}
it.CreatorDidNotVerifyError = bc;
ur.set(6006, () => new bc());
cr.set('CreatorDidNotVerify', () => new bc());
class vc extends Error {
  constructor() {
    super('Creator not found in creator Vec'),
      (this.code = 6007),
      (this.name = 'CreatorNotFound'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, vc);
  }
}
it.CreatorNotFoundError = vc;
ur.set(6007, () => new vc());
cr.set('CreatorNotFound', () => new vc());
class mc extends Error {
  constructor() {
    super('No creators in creator Vec'),
      (this.code = 6008),
      (this.name = 'NoCreatorsPresent'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, mc);
  }
}
it.NoCreatorsPresentError = mc;
ur.set(6008, () => new mc());
cr.set('NoCreatorsPresent', () => new mc());
class wc extends Error {
  constructor() {
    super('User-provided creator Vec must result in same user-provided creator hash'),
      (this.code = 6009),
      (this.name = 'CreatorHashMismatch'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, wc);
  }
}
it.CreatorHashMismatchError = wc;
ur.set(6009, () => new wc());
cr.set('CreatorHashMismatch', () => new wc());
class _c extends Error {
  constructor() {
    super('User-provided metadata must result in same user-provided data hash'),
      (this.code = 6010),
      (this.name = 'DataHashMismatch'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, _c);
  }
}
it.DataHashMismatchError = _c;
ur.set(6010, () => new _c());
cr.set('DataHashMismatch', () => new _c());
class Sc extends Error {
  constructor() {
    super('Creators list too long'),
      (this.code = 6011),
      (this.name = 'CreatorsTooLong'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Sc);
  }
}
it.CreatorsTooLongError = Sc;
ur.set(6011, () => new Sc());
cr.set('CreatorsTooLong', () => new Sc());
class Mc extends Error {
  constructor() {
    super('Name in metadata is too long'),
      (this.code = 6012),
      (this.name = 'MetadataNameTooLong'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Mc);
  }
}
it.MetadataNameTooLongError = Mc;
ur.set(6012, () => new Mc());
cr.set('MetadataNameTooLong', () => new Mc());
class Ac extends Error {
  constructor() {
    super('Symbol in metadata is too long'),
      (this.code = 6013),
      (this.name = 'MetadataSymbolTooLong'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Ac);
  }
}
it.MetadataSymbolTooLongError = Ac;
ur.set(6013, () => new Ac());
cr.set('MetadataSymbolTooLong', () => new Ac());
class Ec extends Error {
  constructor() {
    super('Uri in metadata is too long'),
      (this.code = 6014),
      (this.name = 'MetadataUriTooLong'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Ec);
  }
}
it.MetadataUriTooLongError = Ec;
ur.set(6014, () => new Ec());
cr.set('MetadataUriTooLong', () => new Ec());
class kc extends Error {
  constructor() {
    super('Basis points in metadata cannot exceed 10000'),
      (this.code = 6015),
      (this.name = 'MetadataBasisPointsTooHigh'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, kc);
  }
}
it.MetadataBasisPointsTooHighError = kc;
ur.set(6015, () => new kc());
cr.set('MetadataBasisPointsTooHigh', () => new kc());
class Ic extends Error {
  constructor() {
    super('Tree creator or tree delegate must sign.'),
      (this.code = 6016),
      (this.name = 'TreeAuthorityIncorrect'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Ic);
  }
}
it.TreeAuthorityIncorrectError = Ic;
ur.set(6016, () => new Ic());
cr.set('TreeAuthorityIncorrect', () => new Ic());
class xc extends Error {
  constructor() {
    super('Not enough unapproved mints left'),
      (this.code = 6017),
      (this.name = 'InsufficientMintCapacity'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, xc);
  }
}
it.InsufficientMintCapacityError = xc;
ur.set(6017, () => new xc());
cr.set('InsufficientMintCapacity', () => new xc());
class Bc extends Error {
  constructor() {
    super('NumericalOverflowError'),
      (this.code = 6018),
      (this.name = 'NumericalOverflowError'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Bc);
  }
}
it.NumericalOverflowErrorError = Bc;
ur.set(6018, () => new Bc());
cr.set('NumericalOverflowError', () => new Bc());
class Rc extends Error {
  constructor() {
    super('Incorrect account owner'),
      (this.code = 6019),
      (this.name = 'IncorrectOwner'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Rc);
  }
}
it.IncorrectOwnerError = Rc;
ur.set(6019, () => new Rc());
cr.set('IncorrectOwner', () => new Rc());
class Pc extends Error {
  constructor() {
    super('Cannot Verify Collection in this Instruction'),
      (this.code = 6020),
      (this.name = 'CollectionCannotBeVerifiedInThisInstruction'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Pc);
  }
}
it.CollectionCannotBeVerifiedInThisInstructionError = Pc;
ur.set(6020, () => new Pc());
cr.set('CollectionCannotBeVerifiedInThisInstruction', () => new Pc());
class Tc extends Error {
  constructor() {
    super('Collection Not Found on Metadata'),
      (this.code = 6021),
      (this.name = 'CollectionNotFound'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Tc);
  }
}
it.CollectionNotFoundError = Tc;
ur.set(6021, () => new Tc());
cr.set('CollectionNotFound', () => new Tc());
class Oc extends Error {
  constructor() {
    super('Collection item is already verified.'),
      (this.code = 6022),
      (this.name = 'AlreadyVerified'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Oc);
  }
}
it.AlreadyVerifiedError = Oc;
ur.set(6022, () => new Oc());
cr.set('AlreadyVerified', () => new Oc());
class Cc extends Error {
  constructor() {
    super('Collection item is already unverified.'),
      (this.code = 6023),
      (this.name = 'AlreadyUnverified'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Cc);
  }
}
it.AlreadyUnverifiedError = Cc;
ur.set(6023, () => new Cc());
cr.set('AlreadyUnverified', () => new Cc());
class Lc extends Error {
  constructor() {
    super('Incorrect leaf metadata update authority.'),
      (this.code = 6024),
      (this.name = 'UpdateAuthorityIncorrect'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Lc);
  }
}
it.UpdateAuthorityIncorrectError = Lc;
ur.set(6024, () => new Lc());
cr.set('UpdateAuthorityIncorrect', () => new Lc());
class Nc extends Error {
  constructor() {
    super('This transaction must be signed by either the leaf owner or leaf delegate'),
      (this.code = 6025),
      (this.name = 'LeafAuthorityMustSign'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Nc);
  }
}
it.LeafAuthorityMustSignError = Nc;
ur.set(6025, () => new Nc());
cr.set('LeafAuthorityMustSign', () => new Nc());
class $c extends Error {
  constructor() {
    super('Collection Not Compatable with Compression, Must be Sized'),
      (this.code = 6026),
      (this.name = 'CollectionMustBeSized'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, $c);
  }
}
it.CollectionMustBeSizedError = $c;
ur.set(6026, () => new $c());
cr.set('CollectionMustBeSized', () => new $c());
function vD(i) {
  const e = ur.get(i);
  return e != null ? e() : null;
}
it.errorFromCode = vD;
function mD(i) {
  const e = cr.get(i);
  return e != null ? e() : null;
}
it.errorFromName = mD;
var ZS = {},
  JS = {};
(function (i) {
  var e =
      (se && se.__createBinding) ||
      (Object.create
        ? function (f, h, y, p) {
            p === void 0 && (p = y);
            var m = Object.getOwnPropertyDescriptor(h, y);
            (!m || ('get' in m ? !h.__esModule : m.writable || m.configurable)) &&
              (m = {
                enumerable: !0,
                get: function () {
                  return h[y];
                },
              }),
              Object.defineProperty(f, p, m);
          }
        : function (f, h, y, p) {
            p === void 0 && (p = y), (f[p] = h[y]);
          }),
    t =
      (se && se.__setModuleDefault) ||
      (Object.create
        ? function (f, h) {
            Object.defineProperty(f, 'default', { enumerable: !0, value: h });
          }
        : function (f, h) {
            f.default = h;
          }),
    r =
      (se && se.__importStar) ||
      function (f) {
        if (f && f.__esModule) return f;
        var h = {};
        if (f != null)
          for (var y in f)
            y !== 'default' && Object.prototype.hasOwnProperty.call(f, y) && e(h, f, y);
        return t(h, f), h;
      };
  Object.defineProperty(i, '__esModule', { value: !0 }),
    (i.createBurnInstruction = i.burnInstructionDiscriminator = i.burnStruct = void 0);
  const s = r(Jt),
    n = r(qr);
  (i.burnStruct = new s.BeetArgsStruct(
    [
      ['instructionDiscriminator', s.uniformFixedSizeArray(s.u8, 8)],
      ['root', s.uniformFixedSizeArray(s.u8, 32)],
      ['dataHash', s.uniformFixedSizeArray(s.u8, 32)],
      ['creatorHash', s.uniformFixedSizeArray(s.u8, 32)],
      ['nonce', s.u64],
      ['index', s.u32],
    ],
    'BurnInstructionArgs'
  )),
    (i.burnInstructionDiscriminator = [116, 110, 29, 56, 107, 219, 42, 93]);
  function c(f, h, y = new n.PublicKey('BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY')) {
    var p;
    const [m] = i.burnStruct.serialize({
        instructionDiscriminator: i.burnInstructionDiscriminator,
        ...h,
      }),
      _ = [
        { pubkey: f.treeAuthority, isWritable: !1, isSigner: !1 },
        { pubkey: f.leafOwner, isWritable: !1, isSigner: !1 },
        { pubkey: f.leafDelegate, isWritable: !1, isSigner: !1 },
        { pubkey: f.merkleTree, isWritable: !0, isSigner: !1 },
        { pubkey: f.logWrapper, isWritable: !1, isSigner: !1 },
        { pubkey: f.compressionProgram, isWritable: !1, isSigner: !1 },
        {
          pubkey: (p = f.systemProgram) !== null && p !== void 0 ? p : n.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    if (f.anchorRemainingAccounts != null) for (const E of f.anchorRemainingAccounts) _.push(E);
    return new n.TransactionInstruction({ programId: y, keys: _, data: m });
  }
  i.createBurnInstruction = c;
})(JS);
var XS = {};
(function (i) {
  var e =
      (se && se.__createBinding) ||
      (Object.create
        ? function (f, h, y, p) {
            p === void 0 && (p = y);
            var m = Object.getOwnPropertyDescriptor(h, y);
            (!m || ('get' in m ? !h.__esModule : m.writable || m.configurable)) &&
              (m = {
                enumerable: !0,
                get: function () {
                  return h[y];
                },
              }),
              Object.defineProperty(f, p, m);
          }
        : function (f, h, y, p) {
            p === void 0 && (p = y), (f[p] = h[y]);
          }),
    t =
      (se && se.__setModuleDefault) ||
      (Object.create
        ? function (f, h) {
            Object.defineProperty(f, 'default', { enumerable: !0, value: h });
          }
        : function (f, h) {
            f.default = h;
          }),
    r =
      (se && se.__importStar) ||
      function (f) {
        if (f && f.__esModule) return f;
        var h = {};
        if (f != null)
          for (var y in f)
            y !== 'default' && Object.prototype.hasOwnProperty.call(f, y) && e(h, f, y);
        return t(h, f), h;
      };
  Object.defineProperty(i, '__esModule', { value: !0 }),
    (i.createCancelRedeemInstruction =
      i.cancelRedeemInstructionDiscriminator =
      i.cancelRedeemStruct =
        void 0);
  const s = r(Jt),
    n = r(qr);
  (i.cancelRedeemStruct = new s.BeetArgsStruct(
    [
      ['instructionDiscriminator', s.uniformFixedSizeArray(s.u8, 8)],
      ['root', s.uniformFixedSizeArray(s.u8, 32)],
    ],
    'CancelRedeemInstructionArgs'
  )),
    (i.cancelRedeemInstructionDiscriminator = [111, 76, 232, 50, 39, 175, 48, 242]);
  function c(f, h, y = new n.PublicKey('BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY')) {
    var p;
    const [m] = i.cancelRedeemStruct.serialize({
        instructionDiscriminator: i.cancelRedeemInstructionDiscriminator,
        ...h,
      }),
      _ = [
        { pubkey: f.treeAuthority, isWritable: !1, isSigner: !1 },
        { pubkey: f.leafOwner, isWritable: !0, isSigner: !0 },
        { pubkey: f.merkleTree, isWritable: !0, isSigner: !1 },
        { pubkey: f.voucher, isWritable: !0, isSigner: !1 },
        { pubkey: f.logWrapper, isWritable: !1, isSigner: !1 },
        { pubkey: f.compressionProgram, isWritable: !1, isSigner: !1 },
        {
          pubkey: (p = f.systemProgram) !== null && p !== void 0 ? p : n.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    if (f.anchorRemainingAccounts != null) for (const E of f.anchorRemainingAccounts) _.push(E);
    return new n.TransactionInstruction({ programId: y, keys: _, data: m });
  }
  i.createCancelRedeemInstruction = c;
})(XS);
var QS = {},
  Xt = {},
  dh = {};
dh.byteLength = SD;
dh.toByteArray = AD;
dh.fromByteArray = ID;
var kn = [],
  Vi = [],
  wD = typeof Uint8Array < 'u' ? Uint8Array : Array,
  Op = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var Vs = 0, _D = Op.length; Vs < _D; ++Vs) (kn[Vs] = Op[Vs]), (Vi[Op.charCodeAt(Vs)] = Vs);
Vi[45] = 62;
Vi[95] = 63;
function e4(i) {
  var e = i.length;
  if (e % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4');
  var t = i.indexOf('=');
  t === -1 && (t = e);
  var r = t === e ? 0 : 4 - (t % 4);
  return [t, r];
}
function SD(i) {
  var e = e4(i),
    t = e[0],
    r = e[1];
  return ((t + r) * 3) / 4 - r;
}
function MD(i, e, t) {
  return ((e + t) * 3) / 4 - t;
}
function AD(i) {
  var e,
    t = e4(i),
    r = t[0],
    s = t[1],
    n = new wD(MD(i, r, s)),
    c = 0,
    f = s > 0 ? r - 4 : r,
    h;
  for (h = 0; h < f; h += 4)
    (e =
      (Vi[i.charCodeAt(h)] << 18) |
      (Vi[i.charCodeAt(h + 1)] << 12) |
      (Vi[i.charCodeAt(h + 2)] << 6) |
      Vi[i.charCodeAt(h + 3)]),
      (n[c++] = (e >> 16) & 255),
      (n[c++] = (e >> 8) & 255),
      (n[c++] = e & 255);
  return (
    s === 2 &&
      ((e = (Vi[i.charCodeAt(h)] << 2) | (Vi[i.charCodeAt(h + 1)] >> 4)), (n[c++] = e & 255)),
    s === 1 &&
      ((e =
        (Vi[i.charCodeAt(h)] << 10) |
        (Vi[i.charCodeAt(h + 1)] << 4) |
        (Vi[i.charCodeAt(h + 2)] >> 2)),
      (n[c++] = (e >> 8) & 255),
      (n[c++] = e & 255)),
    n
  );
}
function ED(i) {
  return kn[(i >> 18) & 63] + kn[(i >> 12) & 63] + kn[(i >> 6) & 63] + kn[i & 63];
}
function kD(i, e, t) {
  for (var r, s = [], n = e; n < t; n += 3)
    (r = ((i[n] << 16) & 16711680) + ((i[n + 1] << 8) & 65280) + (i[n + 2] & 255)), s.push(ED(r));
  return s.join('');
}
function ID(i) {
  for (var e, t = i.length, r = t % 3, s = [], n = 16383, c = 0, f = t - r; c < f; c += n)
    s.push(kD(i, c, c + n > f ? f : c + n));
  return (
    r === 1
      ? ((e = i[t - 1]), s.push(kn[e >> 2] + kn[(e << 4) & 63] + '=='))
      : r === 2 &&
        ((e = (i[t - 2] << 8) + i[t - 1]),
        s.push(kn[e >> 10] + kn[(e >> 4) & 63] + kn[(e << 2) & 63] + '=')),
    s.join('')
  );
}
var gg = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ gg.read =
  function (i, e, t, r, s) {
    var n,
      c,
      f = s * 8 - r - 1,
      h = (1 << f) - 1,
      y = h >> 1,
      p = -7,
      m = t ? s - 1 : 0,
      _ = t ? -1 : 1,
      A = i[e + m];
    for (
      m += _, n = A & ((1 << -p) - 1), A >>= -p, p += f;
      p > 0;
      n = n * 256 + i[e + m], m += _, p -= 8
    );
    for (c = n & ((1 << -p) - 1), n >>= -p, p += r; p > 0; c = c * 256 + i[e + m], m += _, p -= 8);
    if (n === 0) n = 1 - y;
    else {
      if (n === h) return c ? NaN : (A ? -1 : 1) * (1 / 0);
      (c = c + Math.pow(2, r)), (n = n - y);
    }
    return (A ? -1 : 1) * c * Math.pow(2, n - r);
  };
gg.write = function (i, e, t, r, s, n) {
  var c,
    f,
    h,
    y = n * 8 - s - 1,
    p = (1 << y) - 1,
    m = p >> 1,
    _ = s === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
    A = r ? 0 : n - 1,
    E = r ? 1 : -1,
    I = e < 0 || (e === 0 && 1 / e < 0) ? 1 : 0;
  for (
    e = Math.abs(e),
      isNaN(e) || e === 1 / 0
        ? ((f = isNaN(e) ? 1 : 0), (c = p))
        : ((c = Math.floor(Math.log(e) / Math.LN2)),
          e * (h = Math.pow(2, -c)) < 1 && (c--, (h *= 2)),
          c + m >= 1 ? (e += _ / h) : (e += _ * Math.pow(2, 1 - m)),
          e * h >= 2 && (c++, (h /= 2)),
          c + m >= p
            ? ((f = 0), (c = p))
            : c + m >= 1
              ? ((f = (e * h - 1) * Math.pow(2, s)), (c = c + m))
              : ((f = e * Math.pow(2, m - 1) * Math.pow(2, s)), (c = 0)));
    s >= 8;
    i[t + A] = f & 255, A += E, f /= 256, s -= 8
  );
  for (c = (c << s) | f, y += s; y > 0; i[t + A] = c & 255, A += E, c /= 256, y -= 8);
  i[t + A - E] |= I * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ (function (i) {
  const e = dh,
    t = gg,
    r =
      typeof Symbol == 'function' && typeof Symbol.for == 'function'
        ? Symbol.for('nodejs.util.inspect.custom')
        : null;
  (i.Buffer = f), (i.SlowBuffer = D), (i.INSPECT_MAX_BYTES = 50);
  const s = 2147483647;
  (i.kMaxLength = s),
    (f.TYPED_ARRAY_SUPPORT = n()),
    !f.TYPED_ARRAY_SUPPORT &&
      typeof console < 'u' &&
      typeof console.error == 'function' &&
      console.error(
        'This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
      );
  function n() {
    try {
      const K = new Uint8Array(1),
        O = {
          foo: function () {
            return 42;
          },
        };
      return (
        Object.setPrototypeOf(O, Uint8Array.prototype), Object.setPrototypeOf(K, O), K.foo() === 42
      );
    } catch {
      return !1;
    }
  }
  Object.defineProperty(f.prototype, 'parent', {
    enumerable: !0,
    get: function () {
      if (f.isBuffer(this)) return this.buffer;
    },
  }),
    Object.defineProperty(f.prototype, 'offset', {
      enumerable: !0,
      get: function () {
        if (f.isBuffer(this)) return this.byteOffset;
      },
    });
  function c(K) {
    if (K > s) throw new RangeError('The value "' + K + '" is invalid for option "size"');
    const O = new Uint8Array(K);
    return Object.setPrototypeOf(O, f.prototype), O;
  }
  function f(K, O, W) {
    if (typeof K == 'number') {
      if (typeof O == 'string')
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return m(K);
    }
    return h(K, O, W);
  }
  f.poolSize = 8192;
  function h(K, O, W) {
    if (typeof K == 'string') return _(K, O);
    if (ArrayBuffer.isView(K)) return E(K);
    if (K == null)
      throw new TypeError(
        'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
          typeof K
      );
    if (
      re(K, ArrayBuffer) ||
      (K && re(K.buffer, ArrayBuffer)) ||
      (typeof SharedArrayBuffer < 'u' &&
        (re(K, SharedArrayBuffer) || (K && re(K.buffer, SharedArrayBuffer))))
    )
      return I(K, O, W);
    if (typeof K == 'number')
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    const T = K.valueOf && K.valueOf();
    if (T != null && T !== K) return f.from(T, O, W);
    const x = R(K);
    if (x) return x;
    if (
      typeof Symbol < 'u' &&
      Symbol.toPrimitive != null &&
      typeof K[Symbol.toPrimitive] == 'function'
    )
      return f.from(K[Symbol.toPrimitive]('string'), O, W);
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
        typeof K
    );
  }
  (f.from = function (K, O, W) {
    return h(K, O, W);
  }),
    Object.setPrototypeOf(f.prototype, Uint8Array.prototype),
    Object.setPrototypeOf(f, Uint8Array);
  function y(K) {
    if (typeof K != 'number') throw new TypeError('"size" argument must be of type number');
    if (K < 0) throw new RangeError('The value "' + K + '" is invalid for option "size"');
  }
  function p(K, O, W) {
    return (
      y(K),
      K <= 0 ? c(K) : O !== void 0 ? (typeof W == 'string' ? c(K).fill(O, W) : c(K).fill(O)) : c(K)
    );
  }
  f.alloc = function (K, O, W) {
    return p(K, O, W);
  };
  function m(K) {
    return y(K), c(K < 0 ? 0 : L(K) | 0);
  }
  (f.allocUnsafe = function (K) {
    return m(K);
  }),
    (f.allocUnsafeSlow = function (K) {
      return m(K);
    });
  function _(K, O) {
    if (((typeof O != 'string' || O === '') && (O = 'utf8'), !f.isEncoding(O)))
      throw new TypeError('Unknown encoding: ' + O);
    const W = q(K, O) | 0;
    let T = c(W);
    const x = T.write(K, O);
    return x !== W && (T = T.slice(0, x)), T;
  }
  function A(K) {
    const O = K.length < 0 ? 0 : L(K.length) | 0,
      W = c(O);
    for (let T = 0; T < O; T += 1) W[T] = K[T] & 255;
    return W;
  }
  function E(K) {
    if (re(K, Uint8Array)) {
      const O = new Uint8Array(K);
      return I(O.buffer, O.byteOffset, O.byteLength);
    }
    return A(K);
  }
  function I(K, O, W) {
    if (O < 0 || K.byteLength < O) throw new RangeError('"offset" is outside of buffer bounds');
    if (K.byteLength < O + (W || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let T;
    return (
      O === void 0 && W === void 0
        ? (T = new Uint8Array(K))
        : W === void 0
          ? (T = new Uint8Array(K, O))
          : (T = new Uint8Array(K, O, W)),
      Object.setPrototypeOf(T, f.prototype),
      T
    );
  }
  function R(K) {
    if (f.isBuffer(K)) {
      const O = L(K.length) | 0,
        W = c(O);
      return W.length === 0 || K.copy(W, 0, 0, O), W;
    }
    if (K.length !== void 0) return typeof K.length != 'number' || ge(K.length) ? c(0) : A(K);
    if (K.type === 'Buffer' && Array.isArray(K.data)) return A(K.data);
  }
  function L(K) {
    if (K >= s)
      throw new RangeError(
        'Attempt to allocate Buffer larger than maximum size: 0x' + s.toString(16) + ' bytes'
      );
    return K | 0;
  }
  function D(K) {
    return +K != K && (K = 0), f.alloc(+K);
  }
  (f.isBuffer = function (O) {
    return O != null && O._isBuffer === !0 && O !== f.prototype;
  }),
    (f.compare = function (O, W) {
      if (
        (re(O, Uint8Array) && (O = f.from(O, O.offset, O.byteLength)),
        re(W, Uint8Array) && (W = f.from(W, W.offset, W.byteLength)),
        !f.isBuffer(O) || !f.isBuffer(W))
      )
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      if (O === W) return 0;
      let T = O.length,
        x = W.length;
      for (let N = 0, j = Math.min(T, x); N < j; ++N)
        if (O[N] !== W[N]) {
          (T = O[N]), (x = W[N]);
          break;
        }
      return T < x ? -1 : x < T ? 1 : 0;
    }),
    (f.isEncoding = function (O) {
      switch (String(O).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return !0;
        default:
          return !1;
      }
    }),
    (f.concat = function (O, W) {
      if (!Array.isArray(O)) throw new TypeError('"list" argument must be an Array of Buffers');
      if (O.length === 0) return f.alloc(0);
      let T;
      if (W === void 0) for (W = 0, T = 0; T < O.length; ++T) W += O[T].length;
      const x = f.allocUnsafe(W);
      let N = 0;
      for (T = 0; T < O.length; ++T) {
        let j = O[T];
        if (re(j, Uint8Array))
          N + j.length > x.length
            ? (f.isBuffer(j) || (j = f.from(j)), j.copy(x, N))
            : Uint8Array.prototype.set.call(x, j, N);
        else if (f.isBuffer(j)) j.copy(x, N);
        else throw new TypeError('"list" argument must be an Array of Buffers');
        N += j.length;
      }
      return x;
    });
  function q(K, O) {
    if (f.isBuffer(K)) return K.length;
    if (ArrayBuffer.isView(K) || re(K, ArrayBuffer)) return K.byteLength;
    if (typeof K != 'string')
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
          typeof K
      );
    const W = K.length,
      T = arguments.length > 2 && arguments[2] === !0;
    if (!T && W === 0) return 0;
    let x = !1;
    for (;;)
      switch (O) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return W;
        case 'utf8':
        case 'utf-8':
          return Fe(K).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return W * 2;
        case 'hex':
          return W >>> 1;
        case 'base64':
          return rt(K).length;
        default:
          if (x) return T ? -1 : Fe(K).length;
          (O = ('' + O).toLowerCase()), (x = !0);
      }
  }
  f.byteLength = q;
  function H(K, O, W) {
    let T = !1;
    if (
      ((O === void 0 || O < 0) && (O = 0),
      O > this.length ||
        ((W === void 0 || W > this.length) && (W = this.length), W <= 0) ||
        ((W >>>= 0), (O >>>= 0), W <= O))
    )
      return '';
    for (K || (K = 'utf8'); ; )
      switch (K) {
        case 'hex':
          return v(this, O, W);
        case 'utf8':
        case 'utf-8':
          return l(this, O, W);
        case 'ascii':
          return w(this, O, W);
        case 'latin1':
        case 'binary':
          return M(this, O, W);
        case 'base64':
          return u(this, O, W);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return a(this, O, W);
        default:
          if (T) throw new TypeError('Unknown encoding: ' + K);
          (K = (K + '').toLowerCase()), (T = !0);
      }
  }
  f.prototype._isBuffer = !0;
  function V(K, O, W) {
    const T = K[O];
    (K[O] = K[W]), (K[W] = T);
  }
  (f.prototype.swap16 = function () {
    const O = this.length;
    if (O % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits');
    for (let W = 0; W < O; W += 2) V(this, W, W + 1);
    return this;
  }),
    (f.prototype.swap32 = function () {
      const O = this.length;
      if (O % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits');
      for (let W = 0; W < O; W += 4) V(this, W, W + 3), V(this, W + 1, W + 2);
      return this;
    }),
    (f.prototype.swap64 = function () {
      const O = this.length;
      if (O % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits');
      for (let W = 0; W < O; W += 8)
        V(this, W, W + 7), V(this, W + 1, W + 6), V(this, W + 2, W + 5), V(this, W + 3, W + 4);
      return this;
    }),
    (f.prototype.toString = function () {
      const O = this.length;
      return O === 0 ? '' : arguments.length === 0 ? l(this, 0, O) : H.apply(this, arguments);
    }),
    (f.prototype.toLocaleString = f.prototype.toString),
    (f.prototype.equals = function (O) {
      if (!f.isBuffer(O)) throw new TypeError('Argument must be a Buffer');
      return this === O ? !0 : f.compare(this, O) === 0;
    }),
    (f.prototype.inspect = function () {
      let O = '';
      const W = i.INSPECT_MAX_BYTES;
      return (
        (O = this.toString('hex', 0, W)
          .replace(/(.{2})/g, '$1 ')
          .trim()),
        this.length > W && (O += ' ... '),
        '<Buffer ' + O + '>'
      );
    }),
    r && (f.prototype[r] = f.prototype.inspect),
    (f.prototype.compare = function (O, W, T, x, N) {
      if ((re(O, Uint8Array) && (O = f.from(O, O.offset, O.byteLength)), !f.isBuffer(O)))
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
            typeof O
        );
      if (
        (W === void 0 && (W = 0),
        T === void 0 && (T = O ? O.length : 0),
        x === void 0 && (x = 0),
        N === void 0 && (N = this.length),
        W < 0 || T > O.length || x < 0 || N > this.length)
      )
        throw new RangeError('out of range index');
      if (x >= N && W >= T) return 0;
      if (x >= N) return -1;
      if (W >= T) return 1;
      if (((W >>>= 0), (T >>>= 0), (x >>>= 0), (N >>>= 0), this === O)) return 0;
      let j = N - x,
        J = T - W;
      const de = Math.min(j, J),
        ie = this.slice(x, N),
        ye = O.slice(W, T);
      for (let Ye = 0; Ye < de; ++Ye)
        if (ie[Ye] !== ye[Ye]) {
          (j = ie[Ye]), (J = ye[Ye]);
          break;
        }
      return j < J ? -1 : J < j ? 1 : 0;
    });
  function te(K, O, W, T, x) {
    if (K.length === 0) return -1;
    if (
      (typeof W == 'string'
        ? ((T = W), (W = 0))
        : W > 2147483647
          ? (W = 2147483647)
          : W < -2147483648 && (W = -2147483648),
      (W = +W),
      ge(W) && (W = x ? 0 : K.length - 1),
      W < 0 && (W = K.length + W),
      W >= K.length)
    ) {
      if (x) return -1;
      W = K.length - 1;
    } else if (W < 0)
      if (x) W = 0;
      else return -1;
    if ((typeof O == 'string' && (O = f.from(O, T)), f.isBuffer(O)))
      return O.length === 0 ? -1 : ue(K, O, W, T, x);
    if (typeof O == 'number')
      return (
        (O = O & 255),
        typeof Uint8Array.prototype.indexOf == 'function'
          ? x
            ? Uint8Array.prototype.indexOf.call(K, O, W)
            : Uint8Array.prototype.lastIndexOf.call(K, O, W)
          : ue(K, [O], W, T, x)
      );
    throw new TypeError('val must be string, number or Buffer');
  }
  function ue(K, O, W, T, x) {
    let N = 1,
      j = K.length,
      J = O.length;
    if (
      T !== void 0 &&
      ((T = String(T).toLowerCase()),
      T === 'ucs2' || T === 'ucs-2' || T === 'utf16le' || T === 'utf-16le')
    ) {
      if (K.length < 2 || O.length < 2) return -1;
      (N = 2), (j /= 2), (J /= 2), (W /= 2);
    }
    function de(ye, Ye) {
      return N === 1 ? ye[Ye] : ye.readUInt16BE(Ye * N);
    }
    let ie;
    if (x) {
      let ye = -1;
      for (ie = W; ie < j; ie++)
        if (de(K, ie) === de(O, ye === -1 ? 0 : ie - ye)) {
          if ((ye === -1 && (ye = ie), ie - ye + 1 === J)) return ye * N;
        } else ye !== -1 && (ie -= ie - ye), (ye = -1);
    } else
      for (W + J > j && (W = j - J), ie = W; ie >= 0; ie--) {
        let ye = !0;
        for (let Ye = 0; Ye < J; Ye++)
          if (de(K, ie + Ye) !== de(O, Ye)) {
            ye = !1;
            break;
          }
        if (ye) return ie;
      }
    return -1;
  }
  (f.prototype.includes = function (O, W, T) {
    return this.indexOf(O, W, T) !== -1;
  }),
    (f.prototype.indexOf = function (O, W, T) {
      return te(this, O, W, T, !0);
    }),
    (f.prototype.lastIndexOf = function (O, W, T) {
      return te(this, O, W, T, !1);
    });
  function ne(K, O, W, T) {
    W = Number(W) || 0;
    const x = K.length - W;
    T ? ((T = Number(T)), T > x && (T = x)) : (T = x);
    const N = O.length;
    T > N / 2 && (T = N / 2);
    let j;
    for (j = 0; j < T; ++j) {
      const J = parseInt(O.substr(j * 2, 2), 16);
      if (ge(J)) return j;
      K[W + j] = J;
    }
    return j;
  }
  function X(K, O, W, T) {
    return me(Fe(O, K.length - W), K, W, T);
  }
  function Oe(K, O, W, T) {
    return me(be(O), K, W, T);
  }
  function S(K, O, W, T) {
    return me(rt(O), K, W, T);
  }
  function o(K, O, W, T) {
    return me(oe(O, K.length - W), K, W, T);
  }
  (f.prototype.write = function (O, W, T, x) {
    if (W === void 0) (x = 'utf8'), (T = this.length), (W = 0);
    else if (T === void 0 && typeof W == 'string') (x = W), (T = this.length), (W = 0);
    else if (isFinite(W))
      (W = W >>> 0),
        isFinite(T) ? ((T = T >>> 0), x === void 0 && (x = 'utf8')) : ((x = T), (T = void 0));
    else throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    const N = this.length - W;
    if (((T === void 0 || T > N) && (T = N), (O.length > 0 && (T < 0 || W < 0)) || W > this.length))
      throw new RangeError('Attempt to write outside buffer bounds');
    x || (x = 'utf8');
    let j = !1;
    for (;;)
      switch (x) {
        case 'hex':
          return ne(this, O, W, T);
        case 'utf8':
        case 'utf-8':
          return X(this, O, W, T);
        case 'ascii':
        case 'latin1':
        case 'binary':
          return Oe(this, O, W, T);
        case 'base64':
          return S(this, O, W, T);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return o(this, O, W, T);
        default:
          if (j) throw new TypeError('Unknown encoding: ' + x);
          (x = ('' + x).toLowerCase()), (j = !0);
      }
  }),
    (f.prototype.toJSON = function () {
      return { type: 'Buffer', data: Array.prototype.slice.call(this._arr || this, 0) };
    });
  function u(K, O, W) {
    return O === 0 && W === K.length ? e.fromByteArray(K) : e.fromByteArray(K.slice(O, W));
  }
  function l(K, O, W) {
    W = Math.min(K.length, W);
    const T = [];
    let x = O;
    for (; x < W; ) {
      const N = K[x];
      let j = null,
        J = N > 239 ? 4 : N > 223 ? 3 : N > 191 ? 2 : 1;
      if (x + J <= W) {
        let de, ie, ye, Ye;
        switch (J) {
          case 1:
            N < 128 && (j = N);
            break;
          case 2:
            (de = K[x + 1]),
              (de & 192) === 128 && ((Ye = ((N & 31) << 6) | (de & 63)), Ye > 127 && (j = Ye));
            break;
          case 3:
            (de = K[x + 1]),
              (ie = K[x + 2]),
              (de & 192) === 128 &&
                (ie & 192) === 128 &&
                ((Ye = ((N & 15) << 12) | ((de & 63) << 6) | (ie & 63)),
                Ye > 2047 && (Ye < 55296 || Ye > 57343) && (j = Ye));
            break;
          case 4:
            (de = K[x + 1]),
              (ie = K[x + 2]),
              (ye = K[x + 3]),
              (de & 192) === 128 &&
                (ie & 192) === 128 &&
                (ye & 192) === 128 &&
                ((Ye = ((N & 15) << 18) | ((de & 63) << 12) | ((ie & 63) << 6) | (ye & 63)),
                Ye > 65535 && Ye < 1114112 && (j = Ye));
        }
      }
      j === null
        ? ((j = 65533), (J = 1))
        : j > 65535 &&
          ((j -= 65536), T.push(((j >>> 10) & 1023) | 55296), (j = 56320 | (j & 1023))),
        T.push(j),
        (x += J);
    }
    return g(T);
  }
  const d = 4096;
  function g(K) {
    const O = K.length;
    if (O <= d) return String.fromCharCode.apply(String, K);
    let W = '',
      T = 0;
    for (; T < O; ) W += String.fromCharCode.apply(String, K.slice(T, (T += d)));
    return W;
  }
  function w(K, O, W) {
    let T = '';
    W = Math.min(K.length, W);
    for (let x = O; x < W; ++x) T += String.fromCharCode(K[x] & 127);
    return T;
  }
  function M(K, O, W) {
    let T = '';
    W = Math.min(K.length, W);
    for (let x = O; x < W; ++x) T += String.fromCharCode(K[x]);
    return T;
  }
  function v(K, O, W) {
    const T = K.length;
    (!O || O < 0) && (O = 0), (!W || W < 0 || W > T) && (W = T);
    let x = '';
    for (let N = O; N < W; ++N) x += ce[K[N]];
    return x;
  }
  function a(K, O, W) {
    const T = K.slice(O, W);
    let x = '';
    for (let N = 0; N < T.length - 1; N += 2) x += String.fromCharCode(T[N] + T[N + 1] * 256);
    return x;
  }
  f.prototype.slice = function (O, W) {
    const T = this.length;
    (O = ~~O),
      (W = W === void 0 ? T : ~~W),
      O < 0 ? ((O += T), O < 0 && (O = 0)) : O > T && (O = T),
      W < 0 ? ((W += T), W < 0 && (W = 0)) : W > T && (W = T),
      W < O && (W = O);
    const x = this.subarray(O, W);
    return Object.setPrototypeOf(x, f.prototype), x;
  };
  function b(K, O, W) {
    if (K % 1 !== 0 || K < 0) throw new RangeError('offset is not uint');
    if (K + O > W) throw new RangeError('Trying to access beyond buffer length');
  }
  (f.prototype.readUintLE = f.prototype.readUIntLE =
    function (O, W, T) {
      (O = O >>> 0), (W = W >>> 0), T || b(O, W, this.length);
      let x = this[O],
        N = 1,
        j = 0;
      for (; ++j < W && (N *= 256); ) x += this[O + j] * N;
      return x;
    }),
    (f.prototype.readUintBE = f.prototype.readUIntBE =
      function (O, W, T) {
        (O = O >>> 0), (W = W >>> 0), T || b(O, W, this.length);
        let x = this[O + --W],
          N = 1;
        for (; W > 0 && (N *= 256); ) x += this[O + --W] * N;
        return x;
      }),
    (f.prototype.readUint8 = f.prototype.readUInt8 =
      function (O, W) {
        return (O = O >>> 0), W || b(O, 1, this.length), this[O];
      }),
    (f.prototype.readUint16LE = f.prototype.readUInt16LE =
      function (O, W) {
        return (O = O >>> 0), W || b(O, 2, this.length), this[O] | (this[O + 1] << 8);
      }),
    (f.prototype.readUint16BE = f.prototype.readUInt16BE =
      function (O, W) {
        return (O = O >>> 0), W || b(O, 2, this.length), (this[O] << 8) | this[O + 1];
      }),
    (f.prototype.readUint32LE = f.prototype.readUInt32LE =
      function (O, W) {
        return (
          (O = O >>> 0),
          W || b(O, 4, this.length),
          (this[O] | (this[O + 1] << 8) | (this[O + 2] << 16)) + this[O + 3] * 16777216
        );
      }),
    (f.prototype.readUint32BE = f.prototype.readUInt32BE =
      function (O, W) {
        return (
          (O = O >>> 0),
          W || b(O, 4, this.length),
          this[O] * 16777216 + ((this[O + 1] << 16) | (this[O + 2] << 8) | this[O + 3])
        );
      }),
    (f.prototype.readBigUInt64LE = he(function (O) {
      (O = O >>> 0), Z(O, 'offset');
      const W = this[O],
        T = this[O + 7];
      (W === void 0 || T === void 0) && ae(O, this.length - 8);
      const x = W + this[++O] * 2 ** 8 + this[++O] * 2 ** 16 + this[++O] * 2 ** 24,
        N = this[++O] + this[++O] * 2 ** 8 + this[++O] * 2 ** 16 + T * 2 ** 24;
      return BigInt(x) + (BigInt(N) << BigInt(32));
    })),
    (f.prototype.readBigUInt64BE = he(function (O) {
      (O = O >>> 0), Z(O, 'offset');
      const W = this[O],
        T = this[O + 7];
      (W === void 0 || T === void 0) && ae(O, this.length - 8);
      const x = W * 2 ** 24 + this[++O] * 2 ** 16 + this[++O] * 2 ** 8 + this[++O],
        N = this[++O] * 2 ** 24 + this[++O] * 2 ** 16 + this[++O] * 2 ** 8 + T;
      return (BigInt(x) << BigInt(32)) + BigInt(N);
    })),
    (f.prototype.readIntLE = function (O, W, T) {
      (O = O >>> 0), (W = W >>> 0), T || b(O, W, this.length);
      let x = this[O],
        N = 1,
        j = 0;
      for (; ++j < W && (N *= 256); ) x += this[O + j] * N;
      return (N *= 128), x >= N && (x -= Math.pow(2, 8 * W)), x;
    }),
    (f.prototype.readIntBE = function (O, W, T) {
      (O = O >>> 0), (W = W >>> 0), T || b(O, W, this.length);
      let x = W,
        N = 1,
        j = this[O + --x];
      for (; x > 0 && (N *= 256); ) j += this[O + --x] * N;
      return (N *= 128), j >= N && (j -= Math.pow(2, 8 * W)), j;
    }),
    (f.prototype.readInt8 = function (O, W) {
      return (
        (O = O >>> 0), W || b(O, 1, this.length), this[O] & 128 ? (255 - this[O] + 1) * -1 : this[O]
      );
    }),
    (f.prototype.readInt16LE = function (O, W) {
      (O = O >>> 0), W || b(O, 2, this.length);
      const T = this[O] | (this[O + 1] << 8);
      return T & 32768 ? T | 4294901760 : T;
    }),
    (f.prototype.readInt16BE = function (O, W) {
      (O = O >>> 0), W || b(O, 2, this.length);
      const T = this[O + 1] | (this[O] << 8);
      return T & 32768 ? T | 4294901760 : T;
    }),
    (f.prototype.readInt32LE = function (O, W) {
      return (
        (O = O >>> 0),
        W || b(O, 4, this.length),
        this[O] | (this[O + 1] << 8) | (this[O + 2] << 16) | (this[O + 3] << 24)
      );
    }),
    (f.prototype.readInt32BE = function (O, W) {
      return (
        (O = O >>> 0),
        W || b(O, 4, this.length),
        (this[O] << 24) | (this[O + 1] << 16) | (this[O + 2] << 8) | this[O + 3]
      );
    }),
    (f.prototype.readBigInt64LE = he(function (O) {
      (O = O >>> 0), Z(O, 'offset');
      const W = this[O],
        T = this[O + 7];
      (W === void 0 || T === void 0) && ae(O, this.length - 8);
      const x = this[O + 4] + this[O + 5] * 2 ** 8 + this[O + 6] * 2 ** 16 + (T << 24);
      return (
        (BigInt(x) << BigInt(32)) +
        BigInt(W + this[++O] * 2 ** 8 + this[++O] * 2 ** 16 + this[++O] * 2 ** 24)
      );
    })),
    (f.prototype.readBigInt64BE = he(function (O) {
      (O = O >>> 0), Z(O, 'offset');
      const W = this[O],
        T = this[O + 7];
      (W === void 0 || T === void 0) && ae(O, this.length - 8);
      const x = (W << 24) + this[++O] * 2 ** 16 + this[++O] * 2 ** 8 + this[++O];
      return (
        (BigInt(x) << BigInt(32)) +
        BigInt(this[++O] * 2 ** 24 + this[++O] * 2 ** 16 + this[++O] * 2 ** 8 + T)
      );
    })),
    (f.prototype.readFloatLE = function (O, W) {
      return (O = O >>> 0), W || b(O, 4, this.length), t.read(this, O, !0, 23, 4);
    }),
    (f.prototype.readFloatBE = function (O, W) {
      return (O = O >>> 0), W || b(O, 4, this.length), t.read(this, O, !1, 23, 4);
    }),
    (f.prototype.readDoubleLE = function (O, W) {
      return (O = O >>> 0), W || b(O, 8, this.length), t.read(this, O, !0, 52, 8);
    }),
    (f.prototype.readDoubleBE = function (O, W) {
      return (O = O >>> 0), W || b(O, 8, this.length), t.read(this, O, !1, 52, 8);
    });
  function k(K, O, W, T, x, N) {
    if (!f.isBuffer(K)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (O > x || O < N) throw new RangeError('"value" argument is out of bounds');
    if (W + T > K.length) throw new RangeError('Index out of range');
  }
  (f.prototype.writeUintLE = f.prototype.writeUIntLE =
    function (O, W, T, x) {
      if (((O = +O), (W = W >>> 0), (T = T >>> 0), !x)) {
        const J = Math.pow(2, 8 * T) - 1;
        k(this, O, W, T, J, 0);
      }
      let N = 1,
        j = 0;
      for (this[W] = O & 255; ++j < T && (N *= 256); ) this[W + j] = (O / N) & 255;
      return W + T;
    }),
    (f.prototype.writeUintBE = f.prototype.writeUIntBE =
      function (O, W, T, x) {
        if (((O = +O), (W = W >>> 0), (T = T >>> 0), !x)) {
          const J = Math.pow(2, 8 * T) - 1;
          k(this, O, W, T, J, 0);
        }
        let N = T - 1,
          j = 1;
        for (this[W + N] = O & 255; --N >= 0 && (j *= 256); ) this[W + N] = (O / j) & 255;
        return W + T;
      }),
    (f.prototype.writeUint8 = f.prototype.writeUInt8 =
      function (O, W, T) {
        return (O = +O), (W = W >>> 0), T || k(this, O, W, 1, 255, 0), (this[W] = O & 255), W + 1;
      }),
    (f.prototype.writeUint16LE = f.prototype.writeUInt16LE =
      function (O, W, T) {
        return (
          (O = +O),
          (W = W >>> 0),
          T || k(this, O, W, 2, 65535, 0),
          (this[W] = O & 255),
          (this[W + 1] = O >>> 8),
          W + 2
        );
      }),
    (f.prototype.writeUint16BE = f.prototype.writeUInt16BE =
      function (O, W, T) {
        return (
          (O = +O),
          (W = W >>> 0),
          T || k(this, O, W, 2, 65535, 0),
          (this[W] = O >>> 8),
          (this[W + 1] = O & 255),
          W + 2
        );
      }),
    (f.prototype.writeUint32LE = f.prototype.writeUInt32LE =
      function (O, W, T) {
        return (
          (O = +O),
          (W = W >>> 0),
          T || k(this, O, W, 4, 4294967295, 0),
          (this[W + 3] = O >>> 24),
          (this[W + 2] = O >>> 16),
          (this[W + 1] = O >>> 8),
          (this[W] = O & 255),
          W + 4
        );
      }),
    (f.prototype.writeUint32BE = f.prototype.writeUInt32BE =
      function (O, W, T) {
        return (
          (O = +O),
          (W = W >>> 0),
          T || k(this, O, W, 4, 4294967295, 0),
          (this[W] = O >>> 24),
          (this[W + 1] = O >>> 16),
          (this[W + 2] = O >>> 8),
          (this[W + 3] = O & 255),
          W + 4
        );
      });
  function B(K, O, W, T, x) {
    $(O, T, x, K, W, 7);
    let N = Number(O & BigInt(4294967295));
    (K[W++] = N),
      (N = N >> 8),
      (K[W++] = N),
      (N = N >> 8),
      (K[W++] = N),
      (N = N >> 8),
      (K[W++] = N);
    let j = Number((O >> BigInt(32)) & BigInt(4294967295));
    return (
      (K[W++] = j),
      (j = j >> 8),
      (K[W++] = j),
      (j = j >> 8),
      (K[W++] = j),
      (j = j >> 8),
      (K[W++] = j),
      W
    );
  }
  function F(K, O, W, T, x) {
    $(O, T, x, K, W, 7);
    let N = Number(O & BigInt(4294967295));
    (K[W + 7] = N),
      (N = N >> 8),
      (K[W + 6] = N),
      (N = N >> 8),
      (K[W + 5] = N),
      (N = N >> 8),
      (K[W + 4] = N);
    let j = Number((O >> BigInt(32)) & BigInt(4294967295));
    return (
      (K[W + 3] = j),
      (j = j >> 8),
      (K[W + 2] = j),
      (j = j >> 8),
      (K[W + 1] = j),
      (j = j >> 8),
      (K[W] = j),
      W + 8
    );
  }
  (f.prototype.writeBigUInt64LE = he(function (O, W = 0) {
    return B(this, O, W, BigInt(0), BigInt('0xffffffffffffffff'));
  })),
    (f.prototype.writeBigUInt64BE = he(function (O, W = 0) {
      return F(this, O, W, BigInt(0), BigInt('0xffffffffffffffff'));
    })),
    (f.prototype.writeIntLE = function (O, W, T, x) {
      if (((O = +O), (W = W >>> 0), !x)) {
        const de = Math.pow(2, 8 * T - 1);
        k(this, O, W, T, de - 1, -de);
      }
      let N = 0,
        j = 1,
        J = 0;
      for (this[W] = O & 255; ++N < T && (j *= 256); )
        O < 0 && J === 0 && this[W + N - 1] !== 0 && (J = 1),
          (this[W + N] = (((O / j) >> 0) - J) & 255);
      return W + T;
    }),
    (f.prototype.writeIntBE = function (O, W, T, x) {
      if (((O = +O), (W = W >>> 0), !x)) {
        const de = Math.pow(2, 8 * T - 1);
        k(this, O, W, T, de - 1, -de);
      }
      let N = T - 1,
        j = 1,
        J = 0;
      for (this[W + N] = O & 255; --N >= 0 && (j *= 256); )
        O < 0 && J === 0 && this[W + N + 1] !== 0 && (J = 1),
          (this[W + N] = (((O / j) >> 0) - J) & 255);
      return W + T;
    }),
    (f.prototype.writeInt8 = function (O, W, T) {
      return (
        (O = +O),
        (W = W >>> 0),
        T || k(this, O, W, 1, 127, -128),
        O < 0 && (O = 255 + O + 1),
        (this[W] = O & 255),
        W + 1
      );
    }),
    (f.prototype.writeInt16LE = function (O, W, T) {
      return (
        (O = +O),
        (W = W >>> 0),
        T || k(this, O, W, 2, 32767, -32768),
        (this[W] = O & 255),
        (this[W + 1] = O >>> 8),
        W + 2
      );
    }),
    (f.prototype.writeInt16BE = function (O, W, T) {
      return (
        (O = +O),
        (W = W >>> 0),
        T || k(this, O, W, 2, 32767, -32768),
        (this[W] = O >>> 8),
        (this[W + 1] = O & 255),
        W + 2
      );
    }),
    (f.prototype.writeInt32LE = function (O, W, T) {
      return (
        (O = +O),
        (W = W >>> 0),
        T || k(this, O, W, 4, 2147483647, -2147483648),
        (this[W] = O & 255),
        (this[W + 1] = O >>> 8),
        (this[W + 2] = O >>> 16),
        (this[W + 3] = O >>> 24),
        W + 4
      );
    }),
    (f.prototype.writeInt32BE = function (O, W, T) {
      return (
        (O = +O),
        (W = W >>> 0),
        T || k(this, O, W, 4, 2147483647, -2147483648),
        O < 0 && (O = 4294967295 + O + 1),
        (this[W] = O >>> 24),
        (this[W + 1] = O >>> 16),
        (this[W + 2] = O >>> 8),
        (this[W + 3] = O & 255),
        W + 4
      );
    }),
    (f.prototype.writeBigInt64LE = he(function (O, W = 0) {
      return B(this, O, W, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
    })),
    (f.prototype.writeBigInt64BE = he(function (O, W = 0) {
      return F(this, O, W, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
    }));
  function P(K, O, W, T, x, N) {
    if (W + T > K.length) throw new RangeError('Index out of range');
    if (W < 0) throw new RangeError('Index out of range');
  }
  function C(K, O, W, T, x) {
    return (O = +O), (W = W >>> 0), x || P(K, O, W, 4), t.write(K, O, W, T, 23, 4), W + 4;
  }
  (f.prototype.writeFloatLE = function (O, W, T) {
    return C(this, O, W, !0, T);
  }),
    (f.prototype.writeFloatBE = function (O, W, T) {
      return C(this, O, W, !1, T);
    });
  function z(K, O, W, T, x) {
    return (O = +O), (W = W >>> 0), x || P(K, O, W, 8), t.write(K, O, W, T, 52, 8), W + 8;
  }
  (f.prototype.writeDoubleLE = function (O, W, T) {
    return z(this, O, W, !0, T);
  }),
    (f.prototype.writeDoubleBE = function (O, W, T) {
      return z(this, O, W, !1, T);
    }),
    (f.prototype.copy = function (O, W, T, x) {
      if (!f.isBuffer(O)) throw new TypeError('argument should be a Buffer');
      if (
        (T || (T = 0),
        !x && x !== 0 && (x = this.length),
        W >= O.length && (W = O.length),
        W || (W = 0),
        x > 0 && x < T && (x = T),
        x === T || O.length === 0 || this.length === 0)
      )
        return 0;
      if (W < 0) throw new RangeError('targetStart out of bounds');
      if (T < 0 || T >= this.length) throw new RangeError('Index out of range');
      if (x < 0) throw new RangeError('sourceEnd out of bounds');
      x > this.length && (x = this.length), O.length - W < x - T && (x = O.length - W + T);
      const N = x - T;
      return (
        this === O && typeof Uint8Array.prototype.copyWithin == 'function'
          ? this.copyWithin(W, T, x)
          : Uint8Array.prototype.set.call(O, this.subarray(T, x), W),
        N
      );
    }),
    (f.prototype.fill = function (O, W, T, x) {
      if (typeof O == 'string') {
        if (
          (typeof W == 'string'
            ? ((x = W), (W = 0), (T = this.length))
            : typeof T == 'string' && ((x = T), (T = this.length)),
          x !== void 0 && typeof x != 'string')
        )
          throw new TypeError('encoding must be a string');
        if (typeof x == 'string' && !f.isEncoding(x)) throw new TypeError('Unknown encoding: ' + x);
        if (O.length === 1) {
          const j = O.charCodeAt(0);
          ((x === 'utf8' && j < 128) || x === 'latin1') && (O = j);
        }
      } else typeof O == 'number' ? (O = O & 255) : typeof O == 'boolean' && (O = Number(O));
      if (W < 0 || this.length < W || this.length < T) throw new RangeError('Out of range index');
      if (T <= W) return this;
      (W = W >>> 0), (T = T === void 0 ? this.length : T >>> 0), O || (O = 0);
      let N;
      if (typeof O == 'number') for (N = W; N < T; ++N) this[N] = O;
      else {
        const j = f.isBuffer(O) ? O : f.from(O, x),
          J = j.length;
        if (J === 0) throw new TypeError('The value "' + O + '" is invalid for argument "value"');
        for (N = 0; N < T - W; ++N) this[N + W] = j[N % J];
      }
      return this;
    });
  const Y = {};
  function G(K, O, W) {
    Y[K] = class extends W {
      constructor() {
        super(),
          Object.defineProperty(this, 'message', {
            value: O.apply(this, arguments),
            writable: !0,
            configurable: !0,
          }),
          (this.name = `${this.name} [${K}]`),
          this.stack,
          delete this.name;
      }
      get code() {
        return K;
      }
      set code(x) {
        Object.defineProperty(this, 'code', {
          configurable: !0,
          enumerable: !0,
          value: x,
          writable: !0,
        });
      }
      toString() {
        return `${this.name} [${K}]: ${this.message}`;
      }
    };
  }
  G(
    'ERR_BUFFER_OUT_OF_BOUNDS',
    function (K) {
      return K
        ? `${K} is outside of buffer bounds`
        : 'Attempt to access memory outside buffer bounds';
    },
    RangeError
  ),
    G(
      'ERR_INVALID_ARG_TYPE',
      function (K, O) {
        return `The "${K}" argument must be of type number. Received type ${typeof O}`;
      },
      TypeError
    ),
    G(
      'ERR_OUT_OF_RANGE',
      function (K, O, W) {
        let T = `The value of "${K}" is out of range.`,
          x = W;
        return (
          Number.isInteger(W) && Math.abs(W) > 2 ** 32
            ? (x = Q(String(W)))
            : typeof W == 'bigint' &&
              ((x = String(W)),
              (W > BigInt(2) ** BigInt(32) || W < -(BigInt(2) ** BigInt(32))) && (x = Q(x)),
              (x += 'n')),
          (T += ` It must be ${O}. Received ${x}`),
          T
        );
      },
      RangeError
    );
  function Q(K) {
    let O = '',
      W = K.length;
    const T = K[0] === '-' ? 1 : 0;
    for (; W >= T + 4; W -= 3) O = `_${K.slice(W - 3, W)}${O}`;
    return `${K.slice(0, W)}${O}`;
  }
  function U(K, O, W) {
    Z(O, 'offset'), (K[O] === void 0 || K[O + W] === void 0) && ae(O, K.length - (W + 1));
  }
  function $(K, O, W, T, x, N) {
    if (K > W || K < O) {
      const j = typeof O == 'bigint' ? 'n' : '';
      let J;
      throw (
        (N > 3
          ? O === 0 || O === BigInt(0)
            ? (J = `>= 0${j} and < 2${j} ** ${(N + 1) * 8}${j}`)
            : (J = `>= -(2${j} ** ${(N + 1) * 8 - 1}${j}) and < 2 ** ${(N + 1) * 8 - 1}${j}`)
          : (J = `>= ${O}${j} and <= ${W}${j}`),
        new Y.ERR_OUT_OF_RANGE('value', J, K))
      );
    }
    U(T, x, N);
  }
  function Z(K, O) {
    if (typeof K != 'number') throw new Y.ERR_INVALID_ARG_TYPE(O, 'number', K);
  }
  function ae(K, O, W) {
    throw Math.floor(K) !== K
      ? (Z(K, W), new Y.ERR_OUT_OF_RANGE(W || 'offset', 'an integer', K))
      : O < 0
        ? new Y.ERR_BUFFER_OUT_OF_BOUNDS()
        : new Y.ERR_OUT_OF_RANGE(W || 'offset', `>= ${W ? 1 : 0} and <= ${O}`, K);
  }
  const fe = /[^+/0-9A-Za-z-_]/g;
  function le(K) {
    if (((K = K.split('=')[0]), (K = K.trim().replace(fe, '')), K.length < 2)) return '';
    for (; K.length % 4 !== 0; ) K = K + '=';
    return K;
  }
  function Fe(K, O) {
    O = O || 1 / 0;
    let W;
    const T = K.length;
    let x = null;
    const N = [];
    for (let j = 0; j < T; ++j) {
      if (((W = K.charCodeAt(j)), W > 55295 && W < 57344)) {
        if (!x) {
          if (W > 56319) {
            (O -= 3) > -1 && N.push(239, 191, 189);
            continue;
          } else if (j + 1 === T) {
            (O -= 3) > -1 && N.push(239, 191, 189);
            continue;
          }
          x = W;
          continue;
        }
        if (W < 56320) {
          (O -= 3) > -1 && N.push(239, 191, 189), (x = W);
          continue;
        }
        W = (((x - 55296) << 10) | (W - 56320)) + 65536;
      } else x && (O -= 3) > -1 && N.push(239, 191, 189);
      if (((x = null), W < 128)) {
        if ((O -= 1) < 0) break;
        N.push(W);
      } else if (W < 2048) {
        if ((O -= 2) < 0) break;
        N.push((W >> 6) | 192, (W & 63) | 128);
      } else if (W < 65536) {
        if ((O -= 3) < 0) break;
        N.push((W >> 12) | 224, ((W >> 6) & 63) | 128, (W & 63) | 128);
      } else if (W < 1114112) {
        if ((O -= 4) < 0) break;
        N.push((W >> 18) | 240, ((W >> 12) & 63) | 128, ((W >> 6) & 63) | 128, (W & 63) | 128);
      } else throw new Error('Invalid code point');
    }
    return N;
  }
  function be(K) {
    const O = [];
    for (let W = 0; W < K.length; ++W) O.push(K.charCodeAt(W) & 255);
    return O;
  }
  function oe(K, O) {
    let W, T, x;
    const N = [];
    for (let j = 0; j < K.length && !((O -= 2) < 0); ++j)
      (W = K.charCodeAt(j)), (T = W >> 8), (x = W % 256), N.push(x), N.push(T);
    return N;
  }
  function rt(K) {
    return e.toByteArray(le(K));
  }
  function me(K, O, W, T) {
    let x;
    for (x = 0; x < T && !(x + W >= O.length || x >= K.length); ++x) O[x + W] = K[x];
    return x;
  }
  function re(K, O) {
    return (
      K instanceof O ||
      (K != null &&
        K.constructor != null &&
        K.constructor.name != null &&
        K.constructor.name === O.name)
    );
  }
  function ge(K) {
    return K !== K;
  }
  const ce = (function () {
    const K = '0123456789abcdef',
      O = new Array(256);
    for (let W = 0; W < 16; ++W) {
      const T = W * 16;
      for (let x = 0; x < 16; ++x) O[T + x] = K[W] + K[x];
    }
    return O;
  })();
  function he(K) {
    return typeof BigInt > 'u' ? Ke : K;
  }
  function Ke() {
    throw new Error('BigInt not supported');
  }
})(Xt);
var xD =
    typeof globalThis < 'u' || typeof globalThis < 'u'
      ? globalThis
      : typeof window < 'u'
        ? window
        : {},
  U1;
typeof Object.create == 'function'
  ? (U1 = function (e, t) {
      (e.super_ = t),
        (e.prototype = Object.create(t.prototype, {
          constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 },
        }));
    })
  : (U1 = function (e, t) {
      e.super_ = t;
      var r = function () {};
      (r.prototype = t.prototype), (e.prototype = new r()), (e.prototype.constructor = e);
    });
var BD = U1;
function hs(i, e) {
  var t = { seen: [], stylize: PD };
  return (
    arguments.length >= 3 && (t.depth = arguments[2]),
    arguments.length >= 4 && (t.colors = arguments[3]),
    t4(e) ? (t.showHidden = e) : e && DD(t, e),
    oa(t.showHidden) && (t.showHidden = !1),
    oa(t.depth) && (t.depth = 2),
    oa(t.colors) && (t.colors = !1),
    oa(t.customInspect) && (t.customInspect = !0),
    t.colors && (t.stylize = RD),
    ll(t, i, t.depth)
  );
}
hs.colors = {
  bold: [1, 22],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  white: [37, 39],
  grey: [90, 39],
  black: [30, 39],
  blue: [34, 39],
  cyan: [36, 39],
  green: [32, 39],
  magenta: [35, 39],
  red: [31, 39],
  yellow: [33, 39],
};
hs.styles = {
  special: 'cyan',
  number: 'yellow',
  boolean: 'yellow',
  undefined: 'grey',
  null: 'bold',
  string: 'green',
  date: 'magenta',
  regexp: 'red',
};
function RD(i, e) {
  var t = hs.styles[e];
  return t ? '\x1B[' + hs.colors[t][0] + 'm' + i + '\x1B[' + hs.colors[t][1] + 'm' : i;
}
function PD(i, e) {
  return i;
}
function TD(i) {
  var e = {};
  return (
    i.forEach(function (t, r) {
      e[t] = !0;
    }),
    e
  );
}
function ll(i, e, t) {
  if (
    i.customInspect &&
    e &&
    Bu(e.inspect) &&
    e.inspect !== hs &&
    !(e.constructor && e.constructor.prototype === e)
  ) {
    var r = e.inspect(t, i);
    return i4(r) || (r = ll(i, r, t)), r;
  }
  var s = OD(i, e);
  if (s) return s;
  var n = Object.keys(e),
    c = TD(n);
  if (
    (i.showHidden && (n = Object.getOwnPropertyNames(e)),
    Cf(e) && (n.indexOf('message') >= 0 || n.indexOf('description') >= 0))
  )
    return Cp(e);
  if (n.length === 0) {
    if (Bu(e)) {
      var f = e.name ? ': ' + e.name : '';
      return i.stylize('[Function' + f + ']', 'special');
    }
    if (xu(e)) return i.stylize(RegExp.prototype.toString.call(e), 'regexp');
    if (hl(e)) return i.stylize(Date.prototype.toString.call(e), 'date');
    if (Cf(e)) return Cp(e);
  }
  var h = '',
    y = !1,
    p = ['{', '}'];
  if ((ND(e) && ((y = !0), (p = ['[', ']'])), Bu(e))) {
    var m = e.name ? ': ' + e.name : '';
    h = ' [Function' + m + ']';
  }
  if (
    (xu(e) && (h = ' ' + RegExp.prototype.toString.call(e)),
    hl(e) && (h = ' ' + Date.prototype.toUTCString.call(e)),
    Cf(e) && (h = ' ' + Cp(e)),
    n.length === 0 && (!y || e.length == 0))
  )
    return p[0] + h + p[1];
  if (t < 0)
    return xu(e)
      ? i.stylize(RegExp.prototype.toString.call(e), 'regexp')
      : i.stylize('[Object]', 'special');
  i.seen.push(e);
  var _;
  return (
    y
      ? (_ = CD(i, e, t, c, n))
      : (_ = n.map(function (A) {
          return z1(i, e, t, c, A, y);
        })),
    i.seen.pop(),
    LD(_, h, p)
  );
}
function OD(i, e) {
  if (oa(e)) return i.stylize('undefined', 'undefined');
  if (i4(e)) {
    var t =
      "'" + JSON.stringify(e).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return i.stylize(t, 'string');
  }
  if ($D(e)) return i.stylize('' + e, 'number');
  if (t4(e)) return i.stylize('' + e, 'boolean');
  if (r4(e)) return i.stylize('null', 'null');
}
function Cp(i) {
  return '[' + Error.prototype.toString.call(i) + ']';
}
function CD(i, e, t, r, s) {
  for (var n = [], c = 0, f = e.length; c < f; ++c)
    n4(e, String(c)) ? n.push(z1(i, e, t, r, String(c), !0)) : n.push('');
  return (
    s.forEach(function (h) {
      h.match(/^\d+$/) || n.push(z1(i, e, t, r, h, !0));
    }),
    n
  );
}
function z1(i, e, t, r, s, n) {
  var c, f, h;
  if (
    ((h = Object.getOwnPropertyDescriptor(e, s) || { value: e[s] }),
    h.get
      ? h.set
        ? (f = i.stylize('[Getter/Setter]', 'special'))
        : (f = i.stylize('[Getter]', 'special'))
      : h.set && (f = i.stylize('[Setter]', 'special')),
    n4(r, s) || (c = '[' + s + ']'),
    f ||
      (i.seen.indexOf(h.value) < 0
        ? (r4(t) ? (f = ll(i, h.value, null)) : (f = ll(i, h.value, t - 1)),
          f.indexOf(`
`) > -1 &&
            (n
              ? (f = f
                  .split(
                    `
`
                  )
                  .map(function (y) {
                    return '  ' + y;
                  })
                  .join(
                    `
`
                  )
                  .substr(2))
              : (f =
                  `
` +
                  f
                    .split(
                      `
`
                    )
                    .map(function (y) {
                      return '   ' + y;
                    }).join(`
`))))
        : (f = i.stylize('[Circular]', 'special'))),
    oa(c))
  ) {
    if (n && s.match(/^\d+$/)) return f;
    (c = JSON.stringify('' + s)),
      c.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)
        ? ((c = c.substr(1, c.length - 2)), (c = i.stylize(c, 'name')))
        : ((c = c
            .replace(/'/g, "\\'")
            .replace(/\\"/g, '"')
            .replace(/(^"|"$)/g, "'")),
          (c = i.stylize(c, 'string')));
  }
  return c + ': ' + f;
}
function LD(i, e, t) {
  var r = i.reduce(function (s, n) {
    return (
      n.indexOf(`
`) >= 0,
      s + n.replace(/\u001b\[\d\d?m/g, '').length + 1
    );
  }, 0);
  return r > 60
    ? t[0] +
        (e === ''
          ? ''
          : e +
            `
 `) +
        ' ' +
        i.join(`,
  `) +
        ' ' +
        t[1]
    : t[0] + e + ' ' + i.join(', ') + ' ' + t[1];
}
function ND(i) {
  return Array.isArray(i);
}
function t4(i) {
  return typeof i == 'boolean';
}
function r4(i) {
  return i === null;
}
function $D(i) {
  return typeof i == 'number';
}
function i4(i) {
  return typeof i == 'string';
}
function oa(i) {
  return i === void 0;
}
function xu(i) {
  return ph(i) && bg(i) === '[object RegExp]';
}
function ph(i) {
  return typeof i == 'object' && i !== null;
}
function hl(i) {
  return ph(i) && bg(i) === '[object Date]';
}
function Cf(i) {
  return ph(i) && (bg(i) === '[object Error]' || i instanceof Error);
}
function Bu(i) {
  return typeof i == 'function';
}
function f2(i) {
  return (
    i === null ||
    typeof i == 'boolean' ||
    typeof i == 'number' ||
    typeof i == 'string' ||
    typeof i == 'symbol' ||
    typeof i > 'u'
  );
}
function bg(i) {
  return Object.prototype.toString.call(i);
}
function DD(i, e) {
  if (!e || !ph(e)) return i;
  for (var t = Object.keys(e), r = t.length; r--; ) i[t[r]] = e[t[r]];
  return i;
}
function n4(i, e) {
  return Object.prototype.hasOwnProperty.call(i, e);
}
function l2(i, e) {
  if (i === e) return 0;
  for (var t = i.length, r = e.length, s = 0, n = Math.min(t, r); s < n; ++s)
    if (i[s] !== e[s]) {
      (t = i[s]), (r = e[s]);
      break;
    }
  return t < r ? -1 : r < t ? 1 : 0;
}
var UD = Object.prototype.hasOwnProperty,
  h2 =
    Object.keys ||
    function (i) {
      var e = [];
      for (var t in i) UD.call(i, t) && e.push(t);
      return e;
    },
  d2 = Array.prototype.slice,
  Lp;
function o4() {
  return typeof Lp < 'u'
    ? Lp
    : (Lp = (function () {
        return function () {}.name === 'foo';
      })());
}
function p2(i) {
  return Object.prototype.toString.call(i);
}
function y2(i) {
  return Xt.isBuffer(i) || typeof xD.ArrayBuffer != 'function'
    ? !1
    : typeof ArrayBuffer.isView == 'function'
      ? ArrayBuffer.isView(i)
      : i
        ? !!(i instanceof DataView || (i.buffer && i.buffer instanceof ArrayBuffer))
        : !1;
}
function bi(i, e) {
  i || Ii(i, !0, e, '==', mg);
}
var zD = /\s*function\s+([^\(\s]*)\s*/;
function s4(i) {
  if (Bu(i)) {
    if (o4()) return i.name;
    var e = i.toString(),
      t = e.match(zD);
    return t && t[1];
  }
}
bi.AssertionError = vg;
function vg(i) {
  (this.name = 'AssertionError'),
    (this.actual = i.actual),
    (this.expected = i.expected),
    (this.operator = i.operator),
    i.message
      ? ((this.message = i.message), (this.generatedMessage = !1))
      : ((this.message = FD(this)), (this.generatedMessage = !0));
  var e = i.stackStartFunction || Ii;
  if (Error.captureStackTrace) Error.captureStackTrace(this, e);
  else {
    var t = new Error();
    if (t.stack) {
      var r = t.stack,
        s = s4(e),
        n = r.indexOf(
          `
` + s
        );
      if (n >= 0) {
        var c = r.indexOf(
          `
`,
          n + 1
        );
        r = r.substring(c + 1);
      }
      this.stack = r;
    }
  }
}
BD(vg, Error);
function g2(i, e) {
  return typeof i == 'string' ? (i.length < e ? i : i.slice(0, e)) : i;
}
function b2(i) {
  if (o4() || !Bu(i)) return hs(i);
  var e = s4(i),
    t = e ? ': ' + e : '';
  return '[Function' + t + ']';
}
function FD(i) {
  return g2(b2(i.actual), 128) + ' ' + i.operator + ' ' + g2(b2(i.expected), 128);
}
function Ii(i, e, t, r, s) {
  throw new vg({ message: t, actual: i, expected: e, operator: r, stackStartFunction: s });
}
bi.fail = Ii;
function mg(i, e) {
  i || Ii(i, !0, e, '==', mg);
}
bi.ok = mg;
bi.equal = a4;
function a4(i, e, t) {
  i != e && Ii(i, e, t, '==', a4);
}
bi.notEqual = u4;
function u4(i, e, t) {
  i == e && Ii(i, e, t, '!=', u4);
}
bi.deepEqual = c4;
function c4(i, e, t) {
  Na(i, e, !1) || Ii(i, e, t, 'deepEqual', c4);
}
bi.deepStrictEqual = f4;
function f4(i, e, t) {
  Na(i, e, !0) || Ii(i, e, t, 'deepStrictEqual', f4);
}
function Na(i, e, t, r) {
  if (i === e) return !0;
  if (Xt.isBuffer(i) && Xt.isBuffer(e)) return l2(i, e) === 0;
  if (hl(i) && hl(e)) return i.getTime() === e.getTime();
  if (xu(i) && xu(e))
    return (
      i.source === e.source &&
      i.global === e.global &&
      i.multiline === e.multiline &&
      i.lastIndex === e.lastIndex &&
      i.ignoreCase === e.ignoreCase
    );
  if ((i === null || typeof i != 'object') && (e === null || typeof e != 'object'))
    return t ? i === e : i == e;
  if (
    y2(i) &&
    y2(e) &&
    p2(i) === p2(e) &&
    !(i instanceof Float32Array || i instanceof Float64Array)
  )
    return l2(new Uint8Array(i.buffer), new Uint8Array(e.buffer)) === 0;
  if (Xt.isBuffer(i) !== Xt.isBuffer(e)) return !1;
  r = r || { actual: [], expected: [] };
  var s = r.actual.indexOf(i);
  return s !== -1 && s === r.expected.indexOf(e)
    ? !0
    : (r.actual.push(i), r.expected.push(e), qD(i, e, t, r));
}
function v2(i) {
  return Object.prototype.toString.call(i) == '[object Arguments]';
}
function qD(i, e, t, r) {
  if (i == null || e === null || e === void 0) return !1;
  if (f2(i) || f2(e)) return i === e;
  if (t && Object.getPrototypeOf(i) !== Object.getPrototypeOf(e)) return !1;
  var s = v2(i),
    n = v2(e);
  if ((s && !n) || (!s && n)) return !1;
  if (s) return (i = d2.call(i)), (e = d2.call(e)), Na(i, e, t);
  var c = h2(i),
    f = h2(e),
    h,
    y;
  if (c.length !== f.length) return !1;
  for (c.sort(), f.sort(), y = c.length - 1; y >= 0; y--) if (c[y] !== f[y]) return !1;
  for (y = c.length - 1; y >= 0; y--) if (((h = c[y]), !Na(i[h], e[h], t, r))) return !1;
  return !0;
}
bi.notDeepEqual = l4;
function l4(i, e, t) {
  Na(i, e, !1) && Ii(i, e, t, 'notDeepEqual', l4);
}
bi.notDeepStrictEqual = h4;
function h4(i, e, t) {
  Na(i, e, !0) && Ii(i, e, t, 'notDeepStrictEqual', h4);
}
bi.strictEqual = d4;
function d4(i, e, t) {
  i !== e && Ii(i, e, t, '===', d4);
}
bi.notStrictEqual = p4;
function p4(i, e, t) {
  i === e && Ii(i, e, t, '!==', p4);
}
function m2(i, e) {
  if (!i || !e) return !1;
  if (Object.prototype.toString.call(e) == '[object RegExp]') return e.test(i);
  try {
    if (i instanceof e) return !0;
  } catch {}
  return Error.isPrototypeOf(e) ? !1 : e.call({}, i) === !0;
}
function WD(i) {
  var e;
  try {
    i();
  } catch (t) {
    e = t;
  }
  return e;
}
function y4(i, e, t, r) {
  var s;
  if (typeof e != 'function') throw new TypeError('"block" argument must be a function');
  typeof t == 'string' && ((r = t), (t = null)),
    (s = WD(e)),
    (r = (t && t.name ? ' (' + t.name + ').' : '.') + (r ? ' ' + r : '.')),
    i && !s && Ii(s, t, 'Missing expected exception' + r);
  var n = typeof r == 'string',
    c = !i && Cf(s),
    f = !i && s && !t;
  if (
    (((c && n && m2(s, t)) || f) && Ii(s, t, 'Got unwanted exception' + r),
    (i && s && t && !m2(s, t)) || (!i && s))
  )
    throw s;
}
bi.throws = KD;
function KD(i, e, t) {
  y4(!0, i, e, t);
}
bi.doesNotThrow = jD;
function jD(i, e, t) {
  y4(!1, i, e, t);
}
bi.ifError = HD;
function HD(i) {
  if (i) throw i;
}
class ju {
  constructor(e, t) {
    if (!Number.isInteger(e)) throw new TypeError('span must be an integer');
    (this.span = e), (this.property = t);
  }
  makeDestinationObject() {
    return {};
  }
  decode(e, t) {
    throw new Error('Layout is abstract');
  }
  encode(e, t, r) {
    throw new Error('Layout is abstract');
  }
  getSpan(e, t) {
    if (0 > this.span) throw new RangeError('indeterminate span');
    return this.span;
  }
  replicate(e) {
    const t = Object.create(this.constructor.prototype);
    return Object.assign(t, this), (t.property = e), t;
  }
  fromArray(e) {}
}
function VD(i, e) {
  return e.property ? i + '[' + e.property + ']' : i;
}
class lf extends ju {
  isCount() {
    throw new Error('ExternalLayout is abstract');
  }
}
class g4 extends ju {
  constructor(e, t) {
    if ((super(e, t), 6 < this.span)) throw new RangeError('span must not exceed 6 bytes');
  }
  decode(e, t) {
    return t === void 0 && (t = 0), e.readUIntLE(t, this.span);
  }
  encode(e, t, r) {
    return r === void 0 && (r = 0), t.writeUIntLE(e, r, this.span), this.span;
  }
}
class GD extends ju {
  constructor(e, t, r) {
    if (!(Array.isArray(e) && e.reduce((n, c) => n && c instanceof ju, !0)))
      throw new TypeError('fields must be array of Layout instances');
    typeof t == 'boolean' && r === void 0 && ((r = t), (t = void 0));
    for (const n of e)
      if (0 > n.span && n.property === void 0)
        throw new Error('fields cannot contain unnamed variable-length layout');
    let s = -1;
    try {
      s = e.reduce((n, c) => n + c.getSpan(), 0);
    } catch {}
    super(s, t), (this.fields = e), (this.decodePrefixes = !!r);
  }
  getSpan(e, t) {
    if (0 <= this.span) return this.span;
    t === void 0 && (t = 0);
    let r = 0;
    try {
      r = this.fields.reduce((s, n) => {
        const c = n.getSpan(e, t);
        return (t += c), s + c;
      }, 0);
    } catch {
      throw new RangeError('indeterminate span');
    }
    return r;
  }
  decode(e, t) {
    t === void 0 && (t = 0);
    const r = this.makeDestinationObject();
    for (const s of this.fields)
      if (
        (s.property !== void 0 && (r[s.property] = s.decode(e, t)),
        (t += s.getSpan(e, t)),
        this.decodePrefixes && e.length === t)
      )
        break;
    return r;
  }
  encode(e, t, r) {
    r === void 0 && (r = 0);
    const s = r;
    let n = 0,
      c = 0;
    for (const f of this.fields) {
      let h = f.span;
      if (((c = 0 < h ? h : 0), f.property !== void 0)) {
        const y = e[f.property];
        y !== void 0 && ((c = f.encode(y, t, r)), 0 > h && (h = f.getSpan(t, r)));
      }
      (n = r), (r += h);
    }
    return n + c - s;
  }
  fromArray(e) {
    const t = this.makeDestinationObject();
    for (const r of this.fields)
      r.property !== void 0 && 0 < e.length && (t[r.property] = e.shift());
    return t;
  }
  layoutFor(e) {
    if (typeof e != 'string') throw new TypeError('property must be string');
    for (const t of this.fields) if (t.property === e) return t;
  }
  offsetOf(e) {
    if (typeof e != 'string') throw new TypeError('property must be string');
    let t = 0;
    for (const r of this.fields) {
      if (r.property === e) return t;
      0 > r.span ? (t = -1) : 0 <= t && (t += r.span);
    }
  }
}
class YD extends ju {
  constructor(e, t) {
    if (!((e instanceof lf && e.isCount()) || (Number.isInteger(e) && 0 <= e)))
      throw new TypeError('length must be positive integer or an unsigned integer ExternalLayout');
    let r = -1;
    e instanceof lf || (r = e), super(r, t), (this.length = e);
  }
  getSpan(e, t) {
    let r = this.span;
    return 0 > r && (r = this.length.decode(e, t)), r;
  }
  decode(e, t) {
    t === void 0 && (t = 0);
    let r = this.span;
    return 0 > r && (r = this.length.decode(e, t)), e.slice(t, t + r);
  }
  encode(e, t, r) {
    let s = this.length;
    if ((this.length instanceof lf && (s = e.length), !(Xt.Buffer.isBuffer(e) && s === e.length)))
      throw new TypeError(VD('Blob.encode', this) + ' requires (length ' + s + ') Buffer as src');
    if (r + s > t.length) throw new RangeError('encoding overruns Buffer');
    return (
      t.write(e.toString('hex'), r, s, 'hex'),
      this.length instanceof lf && this.length.encode(s, t, r),
      s
    );
  }
}
var Ht = (i) => new g4(1, i),
  Ru = (i) => new g4(4, i),
  Lr = (i, e, t) => new GD(i, e, t),
  b4 = (i, e) => new YD(i, e);
const Nr = (i = 'publicKey') => b4(32, i),
  Gi = (i = 'uint64') => b4(8, i);
function Wr(i, e, t, ...r) {
  return ku(e, t, r, { skipPreflight: !1 });
}
const ZD = new Ve('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'),
  v4 = new Ve('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'),
  w2 = 'Failed to find account',
  _2 = 'Invalid account owner';
function Np(i) {
  return Xt.Buffer.from(i.toBuffer());
}
class gi extends Cu {
  toBuffer() {
    const e = super.toArray().reverse(),
      t = Xt.Buffer.from(e);
    if (t.length === 8) return t;
    bi(t.length < 8, 'u64 too large');
    const r = Xt.Buffer.alloc(8);
    return t.copy(r), r;
  }
  static fromBuffer(e) {
    return (
      bi(e.length === 8, `Invalid buffer length: ${e.length}`),
      new gi(
        [...e]
          .reverse()
          .map((t) => `00${t.toString(16)}`.slice(-2))
          .join(''),
        16
      )
    );
  }
}
function Ri(i) {
  return 'publicKey' in i;
}
const JD = { MintTokens: 0, FreezeAccount: 1, AccountOwner: 2, CloseAccount: 3 },
  m4 = new Ve('So11111111111111111111111111111111111111112'),
  mu = Lr([
    Ru('mintAuthorityOption'),
    Nr('mintAuthority'),
    Gi('supply'),
    Ht('decimals'),
    Ht('isInitialized'),
    Ru('freezeAuthorityOption'),
    Nr('freezeAuthority'),
  ]),
  ea = Lr([
    Nr('mint'),
    Nr('owner'),
    Gi('amount'),
    Ru('delegateOption'),
    Nr('delegate'),
    Ht('state'),
    Ru('isNativeOption'),
    Gi('isNative'),
    Gi('delegatedAmount'),
    Ru('closeAuthorityOption'),
    Nr('closeAuthority'),
  ]),
  hf = Lr([
    Ht('m'),
    Ht('n'),
    Ht('is_initialized'),
    Nr('signer1'),
    Nr('signer2'),
    Nr('signer3'),
    Nr('signer4'),
    Nr('signer5'),
    Nr('signer6'),
    Nr('signer7'),
    Nr('signer8'),
    Nr('signer9'),
    Nr('signer10'),
    Nr('signer11'),
  ]);
class Sr {
  constructor(e, t, r, s) {
    tu(this, 'connection', void 0),
      tu(this, 'publicKey', void 0),
      tu(this, 'programId', void 0),
      tu(this, 'associatedProgramId', void 0),
      tu(this, 'payer', void 0),
      Object.assign(this, {
        connection: e,
        publicKey: t,
        programId: r,
        payer: s,
        associatedProgramId: v4,
      });
  }
  static async getMinBalanceRentForExemptMint(e) {
    return await e.getMinimumBalanceForRentExemption(mu.span);
  }
  static async getMinBalanceRentForExemptAccount(e) {
    return await e.getMinimumBalanceForRentExemption(ea.span);
  }
  static async getMinBalanceRentForExemptMultisig(e) {
    return await e.getMinimumBalanceForRentExemption(hf.span);
  }
  static async createMint(e, t, r, s, n, c) {
    const f = ra.generate(),
      h = new Sr(e, f.publicKey, c, t),
      y = await Sr.getMinBalanceRentForExemptMint(e),
      p = new ct();
    return (
      p.add(
        Ur.createAccount({
          fromPubkey: t.publicKey,
          newAccountPubkey: f.publicKey,
          lamports: y,
          space: mu.span,
          programId: c,
        })
      ),
      p.add(Sr.createInitMintInstruction(c, f.publicKey, n, r, s)),
      await Wr('createAccount and InitializeMint', e, p, t, f),
      h
    );
  }
  async createAccount(e) {
    const t = await Sr.getMinBalanceRentForExemptAccount(this.connection),
      r = ra.generate(),
      s = new ct();
    s.add(
      Ur.createAccount({
        fromPubkey: this.payer.publicKey,
        newAccountPubkey: r.publicKey,
        lamports: t,
        space: ea.span,
        programId: this.programId,
      })
    );
    const n = this.publicKey;
    return (
      s.add(Sr.createInitAccountInstruction(this.programId, n, r.publicKey, e)),
      await Wr('createAccount and InitializeAccount', this.connection, s, this.payer, r),
      r.publicKey
    );
  }
  async createAssociatedTokenAccount(e) {
    const t = await Sr.getAssociatedTokenAddress(
      this.associatedProgramId,
      this.programId,
      this.publicKey,
      e
    );
    return this.createAssociatedTokenAccountInternal(e, t);
  }
  async createAssociatedTokenAccountInternal(e, t) {
    return (
      await Wr(
        'CreateAssociatedTokenAccount',
        this.connection,
        new ct().add(
          Sr.createAssociatedTokenAccountInstruction(
            this.associatedProgramId,
            this.programId,
            this.publicKey,
            t,
            e,
            this.payer.publicKey
          )
        ),
        this.payer
      ),
      t
    );
  }
  async getOrCreateAssociatedAccountInfo(e) {
    const t = await Sr.getAssociatedTokenAddress(
      this.associatedProgramId,
      this.programId,
      this.publicKey,
      e
    );
    try {
      return await this.getAccountInfo(t);
    } catch (r) {
      if (r.message === w2 || r.message === _2) {
        try {
          await this.createAssociatedTokenAccountInternal(e, t);
        } catch {}
        return await this.getAccountInfo(t);
      } else throw r;
    }
  }
  static async createWrappedNativeAccount(e, t, r, s, n) {
    const c = await Sr.getMinBalanceRentForExemptAccount(e),
      f = ra.generate(),
      h = new ct();
    return (
      h.add(
        Ur.createAccount({
          fromPubkey: s.publicKey,
          newAccountPubkey: f.publicKey,
          lamports: c,
          space: ea.span,
          programId: t,
        })
      ),
      h.add(Ur.transfer({ fromPubkey: s.publicKey, toPubkey: f.publicKey, lamports: n })),
      h.add(Sr.createInitAccountInstruction(t, m4, f.publicKey, r)),
      await Wr('createAccount, transfer, and initializeAccount', e, h, s, f),
      f.publicKey
    );
  }
  async createMultisig(e, t) {
    const r = ra.generate(),
      s = await Sr.getMinBalanceRentForExemptMultisig(this.connection),
      n = new ct();
    n.add(
      Ur.createAccount({
        fromPubkey: this.payer.publicKey,
        newAccountPubkey: r.publicKey,
        lamports: s,
        space: hf.span,
        programId: this.programId,
      })
    );
    let c = [
      { pubkey: r.publicKey, isSigner: !1, isWritable: !0 },
      { pubkey: In, isSigner: !1, isWritable: !1 },
    ];
    t.forEach((y) => c.push({ pubkey: y, isSigner: !1, isWritable: !1 }));
    const f = Lr([Ht('instruction'), Ht('m')]),
      h = Xt.Buffer.alloc(f.span);
    return (
      f.encode({ instruction: 2, m: e }, h),
      n.add({ keys: c, programId: this.programId, data: h }),
      await Wr('createAccount and InitializeMultisig', this.connection, n, this.payer, r),
      r.publicKey
    );
  }
  async getMintInfo() {
    const e = await this.connection.getAccountInfo(this.publicKey);
    if (e === null) throw new Error('Failed to find mint account');
    if (!e.owner.equals(this.programId))
      throw new Error(`Invalid mint owner: ${JSON.stringify(e.owner)}`);
    if (e.data.length != mu.span) throw new Error('Invalid mint size');
    const t = Xt.Buffer.from(e.data),
      r = mu.decode(t);
    return (
      r.mintAuthorityOption === 0
        ? (r.mintAuthority = null)
        : (r.mintAuthority = new Ve(r.mintAuthority)),
      (r.supply = gi.fromBuffer(r.supply)),
      (r.isInitialized = r.isInitialized != 0),
      r.freezeAuthorityOption === 0
        ? (r.freezeAuthority = null)
        : (r.freezeAuthority = new Ve(r.freezeAuthority)),
      r
    );
  }
  async getAccountInfo(e, t) {
    const r = await this.connection.getAccountInfo(e, t);
    if (r === null) throw new Error(w2);
    if (!r.owner.equals(this.programId)) throw new Error(_2);
    if (r.data.length != ea.span) throw new Error('Invalid account size');
    const s = Xt.Buffer.from(r.data),
      n = ea.decode(s);
    if (
      ((n.address = e),
      (n.mint = new Ve(n.mint)),
      (n.owner = new Ve(n.owner)),
      (n.amount = gi.fromBuffer(n.amount)),
      n.delegateOption === 0
        ? ((n.delegate = null), (n.delegatedAmount = new gi()))
        : ((n.delegate = new Ve(n.delegate)),
          (n.delegatedAmount = gi.fromBuffer(n.delegatedAmount))),
      (n.isInitialized = n.state !== 0),
      (n.isFrozen = n.state === 2),
      n.isNativeOption === 1
        ? ((n.rentExemptReserve = gi.fromBuffer(n.isNative)), (n.isNative = !0))
        : ((n.rentExemptReserve = null), (n.isNative = !1)),
      n.closeAuthorityOption === 0
        ? (n.closeAuthority = null)
        : (n.closeAuthority = new Ve(n.closeAuthority)),
      !n.mint.equals(this.publicKey))
    )
      throw new Error(
        `Invalid account mint: ${JSON.stringify(n.mint)} !== ${JSON.stringify(this.publicKey)}`
      );
    return n;
  }
  async getMultisigInfo(e) {
    const t = await this.connection.getAccountInfo(e);
    if (t === null) throw new Error('Failed to find multisig');
    if (!t.owner.equals(this.programId)) throw new Error('Invalid multisig owner');
    if (t.data.length != hf.span) throw new Error('Invalid multisig size');
    const r = Xt.Buffer.from(t.data),
      s = hf.decode(r);
    return (
      (s.signer1 = new Ve(s.signer1)),
      (s.signer2 = new Ve(s.signer2)),
      (s.signer3 = new Ve(s.signer3)),
      (s.signer4 = new Ve(s.signer4)),
      (s.signer5 = new Ve(s.signer5)),
      (s.signer6 = new Ve(s.signer6)),
      (s.signer7 = new Ve(s.signer7)),
      (s.signer8 = new Ve(s.signer8)),
      (s.signer9 = new Ve(s.signer9)),
      (s.signer10 = new Ve(s.signer10)),
      (s.signer11 = new Ve(s.signer11)),
      s
    );
  }
  async transfer(e, t, r, s, n) {
    let c, f;
    return (
      Ri(r) ? ((c = r.publicKey), (f = [r])) : ((c = r), (f = s)),
      await Wr(
        'Transfer',
        this.connection,
        new ct().add(Sr.createTransferInstruction(this.programId, e, t, c, s, n)),
        this.payer,
        ...f
      )
    );
  }
  async approve(e, t, r, s, n) {
    let c, f;
    Ri(r) ? ((c = r.publicKey), (f = [r])) : ((c = r), (f = s)),
      await Wr(
        'Approve',
        this.connection,
        new ct().add(Sr.createApproveInstruction(this.programId, e, t, c, s, n)),
        this.payer,
        ...f
      );
  }
  async revoke(e, t, r) {
    let s, n;
    Ri(t) ? ((s = t.publicKey), (n = [t])) : ((s = t), (n = r)),
      await Wr(
        'Revoke',
        this.connection,
        new ct().add(Sr.createRevokeInstruction(this.programId, e, s, r)),
        this.payer,
        ...n
      );
  }
  async setAuthority(e, t, r, s, n) {
    let c, f;
    Ri(s) ? ((c = s.publicKey), (f = [s])) : ((c = s), (f = n)),
      await Wr(
        'SetAuthority',
        this.connection,
        new ct().add(Sr.createSetAuthorityInstruction(this.programId, e, t, r, c, n)),
        this.payer,
        ...f
      );
  }
  async mintTo(e, t, r, s) {
    let n, c;
    Ri(t) ? ((n = t.publicKey), (c = [t])) : ((n = t), (c = r)),
      await Wr(
        'MintTo',
        this.connection,
        new ct().add(Sr.createMintToInstruction(this.programId, this.publicKey, e, n, r, s)),
        this.payer,
        ...c
      );
  }
  async burn(e, t, r, s) {
    let n, c;
    Ri(t) ? ((n = t.publicKey), (c = [t])) : ((n = t), (c = r)),
      await Wr(
        'Burn',
        this.connection,
        new ct().add(Sr.createBurnInstruction(this.programId, this.publicKey, e, n, r, s)),
        this.payer,
        ...c
      );
  }
  async closeAccount(e, t, r, s) {
    let n, c;
    Ri(r) ? ((n = r.publicKey), (c = [r])) : ((n = r), (c = s)),
      await Wr(
        'CloseAccount',
        this.connection,
        new ct().add(Sr.createCloseAccountInstruction(this.programId, e, t, n, s)),
        this.payer,
        ...c
      );
  }
  async freezeAccount(e, t, r) {
    let s, n;
    Ri(t) ? ((s = t.publicKey), (n = [t])) : ((s = t), (n = r)),
      await Wr(
        'FreezeAccount',
        this.connection,
        new ct().add(Sr.createFreezeAccountInstruction(this.programId, e, this.publicKey, s, r)),
        this.payer,
        ...n
      );
  }
  async thawAccount(e, t, r) {
    let s, n;
    Ri(t) ? ((s = t.publicKey), (n = [t])) : ((s = t), (n = r)),
      await Wr(
        'ThawAccount',
        this.connection,
        new ct().add(Sr.createThawAccountInstruction(this.programId, e, this.publicKey, s, r)),
        this.payer,
        ...n
      );
  }
  async transferChecked(e, t, r, s, n, c) {
    let f, h;
    return (
      Ri(r) ? ((f = r.publicKey), (h = [r])) : ((f = r), (h = s)),
      await Wr(
        'TransferChecked',
        this.connection,
        new ct().add(
          Sr.createTransferCheckedInstruction(this.programId, e, this.publicKey, t, f, s, n, c)
        ),
        this.payer,
        ...h
      )
    );
  }
  async approveChecked(e, t, r, s, n, c) {
    let f, h;
    Ri(r) ? ((f = r.publicKey), (h = [r])) : ((f = r), (h = s)),
      await Wr(
        'ApproveChecked',
        this.connection,
        new ct().add(
          Sr.createApproveCheckedInstruction(this.programId, e, this.publicKey, t, f, s, n, c)
        ),
        this.payer,
        ...h
      );
  }
  async mintToChecked(e, t, r, s, n) {
    let c, f;
    Ri(t) ? ((c = t.publicKey), (f = [t])) : ((c = t), (f = r)),
      await Wr(
        'MintToChecked',
        this.connection,
        new ct().add(
          Sr.createMintToCheckedInstruction(this.programId, this.publicKey, e, c, r, s, n)
        ),
        this.payer,
        ...f
      );
  }
  async burnChecked(e, t, r, s, n) {
    let c, f;
    Ri(t) ? ((c = t.publicKey), (f = [t])) : ((c = t), (f = r)),
      await Wr(
        'BurnChecked',
        this.connection,
        new ct().add(
          Sr.createBurnCheckedInstruction(this.programId, this.publicKey, e, c, r, s, n)
        ),
        this.payer,
        ...f
      );
  }
  async syncNative(e) {
    await Wr(
      'SyncNative',
      this.connection,
      new ct().add(Sr.createSyncNativeInstruction(this.programId, e)),
      this.payer
    );
  }
  static createInitMintInstruction(e, t, r, s, n) {
    let c = [
      { pubkey: t, isSigner: !1, isWritable: !0 },
      { pubkey: In, isSigner: !1, isWritable: !1 },
    ];
    const f = Lr([
      Ht('instruction'),
      Ht('decimals'),
      Nr('mintAuthority'),
      Ht('option'),
      Nr('freezeAuthority'),
    ]);
    let h = Xt.Buffer.alloc(1024);
    {
      const y = f.encode(
        {
          instruction: 0,
          decimals: r,
          mintAuthority: Np(s),
          option: n === null ? 0 : 1,
          freezeAuthority: Np(n || new Ve(0)),
        },
        h
      );
      h = h.slice(0, y);
    }
    return new pt({ keys: c, programId: e, data: h });
  }
  static createInitAccountInstruction(e, t, r, s) {
    const n = [
        { pubkey: r, isSigner: !1, isWritable: !0 },
        { pubkey: t, isSigner: !1, isWritable: !1 },
        { pubkey: s, isSigner: !1, isWritable: !1 },
        { pubkey: In, isSigner: !1, isWritable: !1 },
      ],
      c = Lr([Ht('instruction')]),
      f = Xt.Buffer.alloc(c.span);
    return c.encode({ instruction: 1 }, f), new pt({ keys: n, programId: e, data: f });
  }
  static createTransferInstruction(e, t, r, s, n, c) {
    const f = Lr([Ht('instruction'), Gi('amount')]),
      h = Xt.Buffer.alloc(f.span);
    f.encode({ instruction: 3, amount: new gi(c).toBuffer() }, h);
    let y = [
      { pubkey: t, isSigner: !1, isWritable: !0 },
      { pubkey: r, isSigner: !1, isWritable: !0 },
    ];
    return (
      n.length === 0
        ? y.push({ pubkey: s, isSigner: !0, isWritable: !1 })
        : (y.push({ pubkey: s, isSigner: !1, isWritable: !1 }),
          n.forEach((p) => y.push({ pubkey: p.publicKey, isSigner: !0, isWritable: !1 }))),
      new pt({ keys: y, programId: e, data: h })
    );
  }
  static createApproveInstruction(e, t, r, s, n, c) {
    const f = Lr([Ht('instruction'), Gi('amount')]),
      h = Xt.Buffer.alloc(f.span);
    f.encode({ instruction: 4, amount: new gi(c).toBuffer() }, h);
    let y = [
      { pubkey: t, isSigner: !1, isWritable: !0 },
      { pubkey: r, isSigner: !1, isWritable: !1 },
    ];
    return (
      n.length === 0
        ? y.push({ pubkey: s, isSigner: !0, isWritable: !1 })
        : (y.push({ pubkey: s, isSigner: !1, isWritable: !1 }),
          n.forEach((p) => y.push({ pubkey: p.publicKey, isSigner: !0, isWritable: !1 }))),
      new pt({ keys: y, programId: e, data: h })
    );
  }
  static createRevokeInstruction(e, t, r, s) {
    const n = Lr([Ht('instruction')]),
      c = Xt.Buffer.alloc(n.span);
    n.encode({ instruction: 5 }, c);
    let f = [{ pubkey: t, isSigner: !1, isWritable: !0 }];
    return (
      s.length === 0
        ? f.push({ pubkey: r, isSigner: !0, isWritable: !1 })
        : (f.push({ pubkey: r, isSigner: !1, isWritable: !1 }),
          s.forEach((h) => f.push({ pubkey: h.publicKey, isSigner: !0, isWritable: !1 }))),
      new pt({ keys: f, programId: e, data: c })
    );
  }
  static createSetAuthorityInstruction(e, t, r, s, n, c) {
    const f = Lr([Ht('instruction'), Ht('authorityType'), Ht('option'), Nr('newAuthority')]);
    let h = Xt.Buffer.alloc(1024);
    {
      const p = f.encode(
        {
          instruction: 6,
          authorityType: JD[s],
          option: r === null ? 0 : 1,
          newAuthority: Np(r || new Ve(0)),
        },
        h
      );
      h = h.slice(0, p);
    }
    let y = [{ pubkey: t, isSigner: !1, isWritable: !0 }];
    return (
      c.length === 0
        ? y.push({ pubkey: n, isSigner: !0, isWritable: !1 })
        : (y.push({ pubkey: n, isSigner: !1, isWritable: !1 }),
          c.forEach((p) => y.push({ pubkey: p.publicKey, isSigner: !0, isWritable: !1 }))),
      new pt({ keys: y, programId: e, data: h })
    );
  }
  static createMintToInstruction(e, t, r, s, n, c) {
    const f = Lr([Ht('instruction'), Gi('amount')]),
      h = Xt.Buffer.alloc(f.span);
    f.encode({ instruction: 7, amount: new gi(c).toBuffer() }, h);
    let y = [
      { pubkey: t, isSigner: !1, isWritable: !0 },
      { pubkey: r, isSigner: !1, isWritable: !0 },
    ];
    return (
      n.length === 0
        ? y.push({ pubkey: s, isSigner: !0, isWritable: !1 })
        : (y.push({ pubkey: s, isSigner: !1, isWritable: !1 }),
          n.forEach((p) => y.push({ pubkey: p.publicKey, isSigner: !0, isWritable: !1 }))),
      new pt({ keys: y, programId: e, data: h })
    );
  }
  static createBurnInstruction(e, t, r, s, n, c) {
    const f = Lr([Ht('instruction'), Gi('amount')]),
      h = Xt.Buffer.alloc(f.span);
    f.encode({ instruction: 8, amount: new gi(c).toBuffer() }, h);
    let y = [
      { pubkey: r, isSigner: !1, isWritable: !0 },
      { pubkey: t, isSigner: !1, isWritable: !0 },
    ];
    return (
      n.length === 0
        ? y.push({ pubkey: s, isSigner: !0, isWritable: !1 })
        : (y.push({ pubkey: s, isSigner: !1, isWritable: !1 }),
          n.forEach((p) => y.push({ pubkey: p.publicKey, isSigner: !0, isWritable: !1 }))),
      new pt({ keys: y, programId: e, data: h })
    );
  }
  static createCloseAccountInstruction(e, t, r, s, n) {
    const c = Lr([Ht('instruction')]),
      f = Xt.Buffer.alloc(c.span);
    c.encode({ instruction: 9 }, f);
    let h = [
      { pubkey: t, isSigner: !1, isWritable: !0 },
      { pubkey: r, isSigner: !1, isWritable: !0 },
    ];
    return (
      n.length === 0
        ? h.push({ pubkey: s, isSigner: !0, isWritable: !1 })
        : (h.push({ pubkey: s, isSigner: !1, isWritable: !1 }),
          n.forEach((y) => h.push({ pubkey: y.publicKey, isSigner: !0, isWritable: !1 }))),
      new pt({ keys: h, programId: e, data: f })
    );
  }
  static createFreezeAccountInstruction(e, t, r, s, n) {
    const c = Lr([Ht('instruction')]),
      f = Xt.Buffer.alloc(c.span);
    c.encode({ instruction: 10 }, f);
    let h = [
      { pubkey: t, isSigner: !1, isWritable: !0 },
      { pubkey: r, isSigner: !1, isWritable: !1 },
    ];
    return (
      n.length === 0
        ? h.push({ pubkey: s, isSigner: !0, isWritable: !1 })
        : (h.push({ pubkey: s, isSigner: !1, isWritable: !1 }),
          n.forEach((y) => h.push({ pubkey: y.publicKey, isSigner: !0, isWritable: !1 }))),
      new pt({ keys: h, programId: e, data: f })
    );
  }
  static createThawAccountInstruction(e, t, r, s, n) {
    const c = Lr([Ht('instruction')]),
      f = Xt.Buffer.alloc(c.span);
    c.encode({ instruction: 11 }, f);
    let h = [
      { pubkey: t, isSigner: !1, isWritable: !0 },
      { pubkey: r, isSigner: !1, isWritable: !1 },
    ];
    return (
      n.length === 0
        ? h.push({ pubkey: s, isSigner: !0, isWritable: !1 })
        : (h.push({ pubkey: s, isSigner: !1, isWritable: !1 }),
          n.forEach((y) => h.push({ pubkey: y.publicKey, isSigner: !0, isWritable: !1 }))),
      new pt({ keys: h, programId: e, data: f })
    );
  }
  static createTransferCheckedInstruction(e, t, r, s, n, c, f, h) {
    const y = Lr([Ht('instruction'), Gi('amount'), Ht('decimals')]),
      p = Xt.Buffer.alloc(y.span);
    y.encode({ instruction: 12, amount: new gi(f).toBuffer(), decimals: h }, p);
    let m = [
      { pubkey: t, isSigner: !1, isWritable: !0 },
      { pubkey: r, isSigner: !1, isWritable: !1 },
      { pubkey: s, isSigner: !1, isWritable: !0 },
    ];
    return (
      c.length === 0
        ? m.push({ pubkey: n, isSigner: !0, isWritable: !1 })
        : (m.push({ pubkey: n, isSigner: !1, isWritable: !1 }),
          c.forEach((_) => m.push({ pubkey: _.publicKey, isSigner: !0, isWritable: !1 }))),
      new pt({ keys: m, programId: e, data: p })
    );
  }
  static createApproveCheckedInstruction(e, t, r, s, n, c, f, h) {
    const y = Lr([Ht('instruction'), Gi('amount'), Ht('decimals')]),
      p = Xt.Buffer.alloc(y.span);
    y.encode({ instruction: 13, amount: new gi(f).toBuffer(), decimals: h }, p);
    let m = [
      { pubkey: t, isSigner: !1, isWritable: !0 },
      { pubkey: r, isSigner: !1, isWritable: !1 },
      { pubkey: s, isSigner: !1, isWritable: !1 },
    ];
    return (
      c.length === 0
        ? m.push({ pubkey: n, isSigner: !0, isWritable: !1 })
        : (m.push({ pubkey: n, isSigner: !1, isWritable: !1 }),
          c.forEach((_) => m.push({ pubkey: _.publicKey, isSigner: !0, isWritable: !1 }))),
      new pt({ keys: m, programId: e, data: p })
    );
  }
  static createMintToCheckedInstruction(e, t, r, s, n, c, f) {
    const h = Lr([Ht('instruction'), Gi('amount'), Ht('decimals')]),
      y = Xt.Buffer.alloc(h.span);
    h.encode({ instruction: 14, amount: new gi(c).toBuffer(), decimals: f }, y);
    let p = [
      { pubkey: t, isSigner: !1, isWritable: !0 },
      { pubkey: r, isSigner: !1, isWritable: !0 },
    ];
    return (
      n.length === 0
        ? p.push({ pubkey: s, isSigner: !0, isWritable: !1 })
        : (p.push({ pubkey: s, isSigner: !1, isWritable: !1 }),
          n.forEach((m) => p.push({ pubkey: m.publicKey, isSigner: !0, isWritable: !1 }))),
      new pt({ keys: p, programId: e, data: y })
    );
  }
  static createBurnCheckedInstruction(e, t, r, s, n, c, f) {
    const h = Lr([Ht('instruction'), Gi('amount'), Ht('decimals')]),
      y = Xt.Buffer.alloc(h.span);
    h.encode({ instruction: 15, amount: new gi(c).toBuffer(), decimals: f }, y);
    let p = [
      { pubkey: r, isSigner: !1, isWritable: !0 },
      { pubkey: t, isSigner: !1, isWritable: !0 },
    ];
    return (
      n.length === 0
        ? p.push({ pubkey: s, isSigner: !0, isWritable: !1 })
        : (p.push({ pubkey: s, isSigner: !1, isWritable: !1 }),
          n.forEach((m) => p.push({ pubkey: m.publicKey, isSigner: !0, isWritable: !1 }))),
      new pt({ keys: p, programId: e, data: y })
    );
  }
  static createSyncNativeInstruction(e, t) {
    const r = Lr([Ht('instruction')]),
      s = Xt.Buffer.alloc(r.span);
    r.encode({ instruction: 17 }, s);
    let n = [{ pubkey: t, isSigner: !1, isWritable: !0 }];
    return new pt({ keys: n, programId: e, data: s });
  }
  static async getAssociatedTokenAddress(e, t, r, s, n = !1) {
    if (!n && !Ve.isOnCurve(s.toBuffer())) throw new Error(`Owner cannot sign: ${s.toString()}`);
    return (await Ve.findProgramAddress([s.toBuffer(), t.toBuffer(), r.toBuffer()], e))[0];
  }
  static createAssociatedTokenAccountInstruction(e, t, r, s, n, c) {
    const f = Xt.Buffer.alloc(0);
    let h = [
      { pubkey: c, isSigner: !0, isWritable: !0 },
      { pubkey: s, isSigner: !1, isWritable: !0 },
      { pubkey: n, isSigner: !1, isWritable: !1 },
      { pubkey: r, isSigner: !1, isWritable: !1 },
      { pubkey: Ur.programId, isSigner: !1, isWritable: !1 },
      { pubkey: t, isSigner: !1, isWritable: !1 },
      { pubkey: In, isSigner: !1, isWritable: !1 },
    ];
    return new pt({ keys: h, programId: e, data: f });
  }
}
const XD = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        ASSOCIATED_TOKEN_PROGRAM_ID: v4,
        AccountLayout: ea,
        MintLayout: mu,
        NATIVE_MINT: m4,
        TOKEN_PROGRAM_ID: ZD,
        Token: Sr,
        u64: gi,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  w4 = pn(XD);
(function (i) {
  var e =
      (se && se.__createBinding) ||
      (Object.create
        ? function (h, y, p, m) {
            m === void 0 && (m = p);
            var _ = Object.getOwnPropertyDescriptor(y, p);
            (!_ || ('get' in _ ? !y.__esModule : _.writable || _.configurable)) &&
              (_ = {
                enumerable: !0,
                get: function () {
                  return y[p];
                },
              }),
              Object.defineProperty(h, m, _);
          }
        : function (h, y, p, m) {
            m === void 0 && (m = p), (h[m] = y[p]);
          }),
    t =
      (se && se.__setModuleDefault) ||
      (Object.create
        ? function (h, y) {
            Object.defineProperty(h, 'default', { enumerable: !0, value: y });
          }
        : function (h, y) {
            h.default = y;
          }),
    r =
      (se && se.__importStar) ||
      function (h) {
        if (h && h.__esModule) return h;
        var y = {};
        if (h != null)
          for (var p in h)
            p !== 'default' && Object.prototype.hasOwnProperty.call(h, p) && e(y, h, p);
        return t(y, h), y;
      };
  Object.defineProperty(i, '__esModule', { value: !0 }),
    (i.createCompressInstruction = i.compressInstructionDiscriminator = i.compressStruct = void 0);
  const s = r(w4),
    n = r(Jt),
    c = r(qr);
  (i.compressStruct = new n.BeetArgsStruct(
    [['instructionDiscriminator', n.uniformFixedSizeArray(n.u8, 8)]],
    'CompressInstructionArgs'
  )),
    (i.compressInstructionDiscriminator = [82, 193, 176, 117, 176, 21, 115, 253]);
  function f(h, y = new c.PublicKey('BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY')) {
    var p, m;
    const [_] = i.compressStruct.serialize({
        instructionDiscriminator: i.compressInstructionDiscriminator,
      }),
      A = [
        { pubkey: h.treeAuthority, isWritable: !1, isSigner: !1 },
        { pubkey: h.leafOwner, isWritable: !1, isSigner: !0 },
        { pubkey: h.leafDelegate, isWritable: !1, isSigner: !1 },
        { pubkey: h.merkleTree, isWritable: !1, isSigner: !1 },
        { pubkey: h.tokenAccount, isWritable: !0, isSigner: !1 },
        { pubkey: h.mint, isWritable: !0, isSigner: !1 },
        { pubkey: h.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: h.masterEdition, isWritable: !0, isSigner: !1 },
        { pubkey: h.payer, isWritable: !0, isSigner: !0 },
        { pubkey: h.logWrapper, isWritable: !1, isSigner: !1 },
        { pubkey: h.compressionProgram, isWritable: !1, isSigner: !1 },
        {
          pubkey: (p = h.tokenProgram) !== null && p !== void 0 ? p : s.TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: h.tokenMetadataProgram, isWritable: !1, isSigner: !1 },
        {
          pubkey: (m = h.systemProgram) !== null && m !== void 0 ? m : c.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    if (h.anchorRemainingAccounts != null) for (const I of h.anchorRemainingAccounts) A.push(I);
    return new c.TransactionInstruction({ programId: y, keys: A, data: _ });
  }
  i.createCompressInstruction = f;
})(QS);
var _4 = {};
(function (i) {
  var e =
      (se && se.__createBinding) ||
      (Object.create
        ? function (f, h, y, p) {
            p === void 0 && (p = y);
            var m = Object.getOwnPropertyDescriptor(h, y);
            (!m || ('get' in m ? !h.__esModule : m.writable || m.configurable)) &&
              (m = {
                enumerable: !0,
                get: function () {
                  return h[y];
                },
              }),
              Object.defineProperty(f, p, m);
          }
        : function (f, h, y, p) {
            p === void 0 && (p = y), (f[p] = h[y]);
          }),
    t =
      (se && se.__setModuleDefault) ||
      (Object.create
        ? function (f, h) {
            Object.defineProperty(f, 'default', { enumerable: !0, value: h });
          }
        : function (f, h) {
            f.default = h;
          }),
    r =
      (se && se.__importStar) ||
      function (f) {
        if (f && f.__esModule) return f;
        var h = {};
        if (f != null)
          for (var y in f)
            y !== 'default' && Object.prototype.hasOwnProperty.call(f, y) && e(h, f, y);
        return t(h, f), h;
      };
  Object.defineProperty(i, '__esModule', { value: !0 }),
    (i.createCreateTreeInstruction =
      i.createTreeInstructionDiscriminator =
      i.createTreeStruct =
        void 0);
  const s = r(Jt),
    n = r(qr);
  (i.createTreeStruct = new s.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', s.uniformFixedSizeArray(s.u8, 8)],
      ['maxDepth', s.u32],
      ['maxBufferSize', s.u32],
      ['public', s.coption(s.bool)],
    ],
    'CreateTreeInstructionArgs'
  )),
    (i.createTreeInstructionDiscriminator = [165, 83, 136, 142, 89, 202, 47, 220]);
  function c(f, h, y = new n.PublicKey('BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY')) {
    var p;
    const [m] = i.createTreeStruct.serialize({
        instructionDiscriminator: i.createTreeInstructionDiscriminator,
        ...h,
      }),
      _ = [
        { pubkey: f.treeAuthority, isWritable: !0, isSigner: !1 },
        { pubkey: f.merkleTree, isWritable: !0, isSigner: !1 },
        { pubkey: f.payer, isWritable: !0, isSigner: !0 },
        { pubkey: f.treeCreator, isWritable: !1, isSigner: !0 },
        { pubkey: f.logWrapper, isWritable: !1, isSigner: !1 },
        { pubkey: f.compressionProgram, isWritable: !1, isSigner: !1 },
        {
          pubkey: (p = f.systemProgram) !== null && p !== void 0 ? p : n.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    if (f.anchorRemainingAccounts != null) for (const E of f.anchorRemainingAccounts) _.push(E);
    return new n.TransactionInstruction({ programId: y, keys: _, data: m });
  }
  i.createCreateTreeInstruction = c;
})(_4);
var S4 = {},
  tn = {},
  wg = {};
(function (i) {
  var e =
      (se && se.__createBinding) ||
      (Object.create
        ? function (c, f, h, y) {
            y === void 0 && (y = h);
            var p = Object.getOwnPropertyDescriptor(f, h);
            (!p || ('get' in p ? !f.__esModule : p.writable || p.configurable)) &&
              (p = {
                enumerable: !0,
                get: function () {
                  return f[h];
                },
              }),
              Object.defineProperty(c, y, p);
          }
        : function (c, f, h, y) {
            y === void 0 && (y = h), (c[y] = f[h]);
          }),
    t =
      (se && se.__setModuleDefault) ||
      (Object.create
        ? function (c, f) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: f });
          }
        : function (c, f) {
            c.default = f;
          }),
    r =
      (se && se.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var f = {};
        if (c != null)
          for (var h in c)
            h !== 'default' && Object.prototype.hasOwnProperty.call(c, h) && e(f, c, h);
        return t(f, c), f;
      };
  Object.defineProperty(i, '__esModule', { value: !0 }),
    (i.tokenStandardBeet = i.TokenStandard = void 0);
  const s = r(Jt);
  var n;
  (function (c) {
    (c[(c.NonFungible = 0)] = 'NonFungible'),
      (c[(c.FungibleAsset = 1)] = 'FungibleAsset'),
      (c[(c.Fungible = 2)] = 'Fungible'),
      (c[(c.NonFungibleEdition = 3)] = 'NonFungibleEdition');
  })((n = i.TokenStandard || (i.TokenStandard = {}))),
    (i.tokenStandardBeet = s.fixedScalarEnum(n));
})(wg);
var Dc = {},
  QD =
    (se && se.__createBinding) ||
    (Object.create
      ? function (i, e, t, r) {
          r === void 0 && (r = t);
          var s = Object.getOwnPropertyDescriptor(e, t);
          (!s || ('get' in s ? !e.__esModule : s.writable || s.configurable)) &&
            (s = {
              enumerable: !0,
              get: function () {
                return e[t];
              },
            }),
            Object.defineProperty(i, r, s);
        }
      : function (i, e, t, r) {
          r === void 0 && (r = t), (i[r] = e[t]);
        }),
  eU =
    (se && se.__setModuleDefault) ||
    (Object.create
      ? function (i, e) {
          Object.defineProperty(i, 'default', { enumerable: !0, value: e });
        }
      : function (i, e) {
          i.default = e;
        }),
  M4 =
    (se && se.__importStar) ||
    function (i) {
      if (i && i.__esModule) return i;
      var e = {};
      if (i != null)
        for (var t in i)
          t !== 'default' && Object.prototype.hasOwnProperty.call(i, t) && QD(e, i, t);
      return eU(e, i), e;
    };
Object.defineProperty(Dc, '__esModule', { value: !0 });
Dc.collectionBeet = void 0;
const S2 = M4(Jt),
  tU = M4(Cs);
Dc.collectionBeet = new S2.BeetArgsStruct(
  [
    ['verified', S2.bool],
    ['key', tU.publicKey],
  ],
  'Collection'
);
var Uc = {},
  _g = {};
(function (i) {
  var e =
      (se && se.__createBinding) ||
      (Object.create
        ? function (c, f, h, y) {
            y === void 0 && (y = h);
            var p = Object.getOwnPropertyDescriptor(f, h);
            (!p || ('get' in p ? !f.__esModule : p.writable || p.configurable)) &&
              (p = {
                enumerable: !0,
                get: function () {
                  return f[h];
                },
              }),
              Object.defineProperty(c, y, p);
          }
        : function (c, f, h, y) {
            y === void 0 && (y = h), (c[y] = f[h]);
          }),
    t =
      (se && se.__setModuleDefault) ||
      (Object.create
        ? function (c, f) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: f });
          }
        : function (c, f) {
            c.default = f;
          }),
    r =
      (se && se.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var f = {};
        if (c != null)
          for (var h in c)
            h !== 'default' && Object.prototype.hasOwnProperty.call(c, h) && e(f, c, h);
        return t(f, c), f;
      };
  Object.defineProperty(i, '__esModule', { value: !0 }), (i.useMethodBeet = i.UseMethod = void 0);
  const s = r(Jt);
  var n;
  (function (c) {
    (c[(c.Burn = 0)] = 'Burn'), (c[(c.Multiple = 1)] = 'Multiple'), (c[(c.Single = 2)] = 'Single');
  })((n = i.UseMethod || (i.UseMethod = {}))),
    (i.useMethodBeet = s.fixedScalarEnum(n));
})(_g);
var rU =
    (se && se.__createBinding) ||
    (Object.create
      ? function (i, e, t, r) {
          r === void 0 && (r = t);
          var s = Object.getOwnPropertyDescriptor(e, t);
          (!s || ('get' in s ? !e.__esModule : s.writable || s.configurable)) &&
            (s = {
              enumerable: !0,
              get: function () {
                return e[t];
              },
            }),
            Object.defineProperty(i, r, s);
        }
      : function (i, e, t, r) {
          r === void 0 && (r = t), (i[r] = e[t]);
        }),
  iU =
    (se && se.__setModuleDefault) ||
    (Object.create
      ? function (i, e) {
          Object.defineProperty(i, 'default', { enumerable: !0, value: e });
        }
      : function (i, e) {
          i.default = e;
        }),
  nU =
    (se && se.__importStar) ||
    function (i) {
      if (i && i.__esModule) return i;
      var e = {};
      if (i != null)
        for (var t in i)
          t !== 'default' && Object.prototype.hasOwnProperty.call(i, t) && rU(e, i, t);
      return iU(e, i), e;
    };
Object.defineProperty(Uc, '__esModule', { value: !0 });
Uc.usesBeet = void 0;
const $p = nU(Jt),
  oU = _g;
Uc.usesBeet = new $p.BeetArgsStruct(
  [
    ['useMethod', oU.useMethodBeet],
    ['remaining', $p.u64],
    ['total', $p.u64],
  ],
  'Uses'
);
var Sg = {};
(function (i) {
  var e =
      (se && se.__createBinding) ||
      (Object.create
        ? function (c, f, h, y) {
            y === void 0 && (y = h);
            var p = Object.getOwnPropertyDescriptor(f, h);
            (!p || ('get' in p ? !f.__esModule : p.writable || p.configurable)) &&
              (p = {
                enumerable: !0,
                get: function () {
                  return f[h];
                },
              }),
              Object.defineProperty(c, y, p);
          }
        : function (c, f, h, y) {
            y === void 0 && (y = h), (c[y] = f[h]);
          }),
    t =
      (se && se.__setModuleDefault) ||
      (Object.create
        ? function (c, f) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: f });
          }
        : function (c, f) {
            c.default = f;
          }),
    r =
      (se && se.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var f = {};
        if (c != null)
          for (var h in c)
            h !== 'default' && Object.prototype.hasOwnProperty.call(c, h) && e(f, c, h);
        return t(f, c), f;
      };
  Object.defineProperty(i, '__esModule', { value: !0 }),
    (i.tokenProgramVersionBeet = i.TokenProgramVersion = void 0);
  const s = r(Jt);
  var n;
  (function (c) {
    (c[(c.Original = 0)] = 'Original'), (c[(c.Token2022 = 1)] = 'Token2022');
  })((n = i.TokenProgramVersion || (i.TokenProgramVersion = {}))),
    (i.tokenProgramVersionBeet = s.fixedScalarEnum(n));
})(Sg);
var zc = {},
  sU =
    (se && se.__createBinding) ||
    (Object.create
      ? function (i, e, t, r) {
          r === void 0 && (r = t);
          var s = Object.getOwnPropertyDescriptor(e, t);
          (!s || ('get' in s ? !e.__esModule : s.writable || s.configurable)) &&
            (s = {
              enumerable: !0,
              get: function () {
                return e[t];
              },
            }),
            Object.defineProperty(i, r, s);
        }
      : function (i, e, t, r) {
          r === void 0 && (r = t), (i[r] = e[t]);
        }),
  aU =
    (se && se.__setModuleDefault) ||
    (Object.create
      ? function (i, e) {
          Object.defineProperty(i, 'default', { enumerable: !0, value: e });
        }
      : function (i, e) {
          i.default = e;
        }),
  A4 =
    (se && se.__importStar) ||
    function (i) {
      if (i && i.__esModule) return i;
      var e = {};
      if (i != null)
        for (var t in i)
          t !== 'default' && Object.prototype.hasOwnProperty.call(i, t) && sU(e, i, t);
      return aU(e, i), e;
    };
Object.defineProperty(zc, '__esModule', { value: !0 });
zc.creatorBeet = void 0;
const uU = A4(Cs),
  Dp = A4(Jt);
zc.creatorBeet = new Dp.BeetArgsStruct(
  [
    ['address', uU.publicKey],
    ['verified', Dp.bool],
    ['share', Dp.u8],
  ],
  'Creator'
);
var cU =
    (se && se.__createBinding) ||
    (Object.create
      ? function (i, e, t, r) {
          r === void 0 && (r = t);
          var s = Object.getOwnPropertyDescriptor(e, t);
          (!s || ('get' in s ? !e.__esModule : s.writable || s.configurable)) &&
            (s = {
              enumerable: !0,
              get: function () {
                return e[t];
              },
            }),
            Object.defineProperty(i, r, s);
        }
      : function (i, e, t, r) {
          r === void 0 && (r = t), (i[r] = e[t]);
        }),
  fU =
    (se && se.__setModuleDefault) ||
    (Object.create
      ? function (i, e) {
          Object.defineProperty(i, 'default', { enumerable: !0, value: e });
        }
      : function (i, e) {
          i.default = e;
        }),
  lU =
    (se && se.__importStar) ||
    function (i) {
      if (i && i.__esModule) return i;
      var e = {};
      if (i != null)
        for (var t in i)
          t !== 'default' && Object.prototype.hasOwnProperty.call(i, t) && cU(e, i, t);
      return fU(e, i), e;
    };
Object.defineProperty(tn, '__esModule', { value: !0 });
tn.metadataArgsBeet = void 0;
const Pi = lU(Jt),
  hU = wg,
  dU = Dc,
  pU = Uc,
  yU = Sg,
  gU = zc;
tn.metadataArgsBeet = new Pi.FixableBeetArgsStruct(
  [
    ['name', Pi.utf8String],
    ['symbol', Pi.utf8String],
    ['uri', Pi.utf8String],
    ['sellerFeeBasisPoints', Pi.u16],
    ['primarySaleHappened', Pi.bool],
    ['isMutable', Pi.bool],
    ['editionNonce', Pi.coption(Pi.u8)],
    ['tokenStandard', Pi.coption(hU.tokenStandardBeet)],
    ['collection', Pi.coption(dU.collectionBeet)],
    ['uses', Pi.coption(pU.usesBeet)],
    ['tokenProgramVersion', yU.tokenProgramVersionBeet],
    ['creators', Pi.array(gU.creatorBeet)],
  ],
  'MetadataArgs'
);
(function (i) {
  var e =
      (se && se.__createBinding) ||
      (Object.create
        ? function (y, p, m, _) {
            _ === void 0 && (_ = m);
            var A = Object.getOwnPropertyDescriptor(p, m);
            (!A || ('get' in A ? !p.__esModule : A.writable || A.configurable)) &&
              (A = {
                enumerable: !0,
                get: function () {
                  return p[m];
                },
              }),
              Object.defineProperty(y, _, A);
          }
        : function (y, p, m, _) {
            _ === void 0 && (_ = m), (y[_] = p[m]);
          }),
    t =
      (se && se.__setModuleDefault) ||
      (Object.create
        ? function (y, p) {
            Object.defineProperty(y, 'default', { enumerable: !0, value: p });
          }
        : function (y, p) {
            y.default = p;
          }),
    r =
      (se && se.__importStar) ||
      function (y) {
        if (y && y.__esModule) return y;
        var p = {};
        if (y != null)
          for (var m in y)
            m !== 'default' && Object.prototype.hasOwnProperty.call(y, m) && e(p, y, m);
        return t(p, y), p;
      };
  Object.defineProperty(i, '__esModule', { value: !0 }),
    (i.createDecompressV1Instruction =
      i.decompressV1InstructionDiscriminator =
      i.decompressV1Struct =
        void 0);
  const s = r(w4),
    n = r(Jt),
    c = r(qr),
    f = tn;
  (i.decompressV1Struct = new n.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', n.uniformFixedSizeArray(n.u8, 8)],
      ['metadata', f.metadataArgsBeet],
    ],
    'DecompressV1InstructionArgs'
  )),
    (i.decompressV1InstructionDiscriminator = [54, 85, 76, 70, 228, 250, 164, 81]);
  function h(y, p, m = new c.PublicKey('BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY')) {
    var _, A;
    const [E] = i.decompressV1Struct.serialize({
        instructionDiscriminator: i.decompressV1InstructionDiscriminator,
        ...p,
      }),
      I = [
        { pubkey: y.voucher, isWritable: !0, isSigner: !1 },
        { pubkey: y.leafOwner, isWritable: !0, isSigner: !0 },
        { pubkey: y.tokenAccount, isWritable: !0, isSigner: !1 },
        { pubkey: y.mint, isWritable: !0, isSigner: !1 },
        { pubkey: y.mintAuthority, isWritable: !0, isSigner: !1 },
        { pubkey: y.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: y.masterEdition, isWritable: !0, isSigner: !1 },
        {
          pubkey: (_ = y.systemProgram) !== null && _ !== void 0 ? _ : c.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: y.sysvarRent, isWritable: !1, isSigner: !1 },
        { pubkey: y.tokenMetadataProgram, isWritable: !1, isSigner: !1 },
        {
          pubkey: (A = y.tokenProgram) !== null && A !== void 0 ? A : s.TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: y.associatedTokenProgram, isWritable: !1, isSigner: !1 },
        { pubkey: y.logWrapper, isWritable: !1, isSigner: !1 },
      ];
    if (y.anchorRemainingAccounts != null) for (const L of y.anchorRemainingAccounts) I.push(L);
    return new c.TransactionInstruction({ programId: m, keys: I, data: E });
  }
  i.createDecompressV1Instruction = h;
})(S4);
var E4 = {};
(function (i) {
  var e =
      (se && se.__createBinding) ||
      (Object.create
        ? function (f, h, y, p) {
            p === void 0 && (p = y);
            var m = Object.getOwnPropertyDescriptor(h, y);
            (!m || ('get' in m ? !h.__esModule : m.writable || m.configurable)) &&
              (m = {
                enumerable: !0,
                get: function () {
                  return h[y];
                },
              }),
              Object.defineProperty(f, p, m);
          }
        : function (f, h, y, p) {
            p === void 0 && (p = y), (f[p] = h[y]);
          }),
    t =
      (se && se.__setModuleDefault) ||
      (Object.create
        ? function (f, h) {
            Object.defineProperty(f, 'default', { enumerable: !0, value: h });
          }
        : function (f, h) {
            f.default = h;
          }),
    r =
      (se && se.__importStar) ||
      function (f) {
        if (f && f.__esModule) return f;
        var h = {};
        if (f != null)
          for (var y in f)
            y !== 'default' && Object.prototype.hasOwnProperty.call(f, y) && e(h, f, y);
        return t(h, f), h;
      };
  Object.defineProperty(i, '__esModule', { value: !0 }),
    (i.createDelegateInstruction = i.delegateInstructionDiscriminator = i.delegateStruct = void 0);
  const s = r(Jt),
    n = r(qr);
  (i.delegateStruct = new s.BeetArgsStruct(
    [
      ['instructionDiscriminator', s.uniformFixedSizeArray(s.u8, 8)],
      ['root', s.uniformFixedSizeArray(s.u8, 32)],
      ['dataHash', s.uniformFixedSizeArray(s.u8, 32)],
      ['creatorHash', s.uniformFixedSizeArray(s.u8, 32)],
      ['nonce', s.u64],
      ['index', s.u32],
    ],
    'DelegateInstructionArgs'
  )),
    (i.delegateInstructionDiscriminator = [90, 147, 75, 178, 85, 88, 4, 137]);
  function c(f, h, y = new n.PublicKey('BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY')) {
    var p;
    const [m] = i.delegateStruct.serialize({
        instructionDiscriminator: i.delegateInstructionDiscriminator,
        ...h,
      }),
      _ = [
        { pubkey: f.treeAuthority, isWritable: !1, isSigner: !1 },
        { pubkey: f.leafOwner, isWritable: !1, isSigner: !0 },
        { pubkey: f.previousLeafDelegate, isWritable: !1, isSigner: !1 },
        { pubkey: f.newLeafDelegate, isWritable: !1, isSigner: !1 },
        { pubkey: f.merkleTree, isWritable: !0, isSigner: !1 },
        { pubkey: f.logWrapper, isWritable: !1, isSigner: !1 },
        { pubkey: f.compressionProgram, isWritable: !1, isSigner: !1 },
        {
          pubkey: (p = f.systemProgram) !== null && p !== void 0 ? p : n.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    if (f.anchorRemainingAccounts != null) for (const E of f.anchorRemainingAccounts) _.push(E);
    return new n.TransactionInstruction({ programId: y, keys: _, data: m });
  }
  i.createDelegateInstruction = c;
})(E4);
var k4 = {};
(function (i) {
  var e =
      (se && se.__createBinding) ||
      (Object.create
        ? function (h, y, p, m) {
            m === void 0 && (m = p);
            var _ = Object.getOwnPropertyDescriptor(y, p);
            (!_ || ('get' in _ ? !y.__esModule : _.writable || _.configurable)) &&
              (_ = {
                enumerable: !0,
                get: function () {
                  return y[p];
                },
              }),
              Object.defineProperty(h, m, _);
          }
        : function (h, y, p, m) {
            m === void 0 && (m = p), (h[m] = y[p]);
          }),
    t =
      (se && se.__setModuleDefault) ||
      (Object.create
        ? function (h, y) {
            Object.defineProperty(h, 'default', { enumerable: !0, value: y });
          }
        : function (h, y) {
            h.default = y;
          }),
    r =
      (se && se.__importStar) ||
      function (h) {
        if (h && h.__esModule) return h;
        var y = {};
        if (h != null)
          for (var p in h)
            p !== 'default' && Object.prototype.hasOwnProperty.call(h, p) && e(y, h, p);
        return t(y, h), y;
      };
  Object.defineProperty(i, '__esModule', { value: !0 }),
    (i.createMintToCollectionV1Instruction =
      i.mintToCollectionV1InstructionDiscriminator =
      i.mintToCollectionV1Struct =
        void 0);
  const s = r(Jt),
    n = r(qr),
    c = tn;
  (i.mintToCollectionV1Struct = new s.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', s.uniformFixedSizeArray(s.u8, 8)],
      ['metadataArgs', c.metadataArgsBeet],
    ],
    'MintToCollectionV1InstructionArgs'
  )),
    (i.mintToCollectionV1InstructionDiscriminator = [153, 18, 178, 47, 197, 158, 86, 15]);
  function f(h, y, p = new n.PublicKey('BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY')) {
    var m;
    const [_] = i.mintToCollectionV1Struct.serialize({
        instructionDiscriminator: i.mintToCollectionV1InstructionDiscriminator,
        ...y,
      }),
      A = [
        { pubkey: h.treeAuthority, isWritable: !0, isSigner: !1 },
        { pubkey: h.leafOwner, isWritable: !1, isSigner: !1 },
        { pubkey: h.leafDelegate, isWritable: !1, isSigner: !1 },
        { pubkey: h.merkleTree, isWritable: !0, isSigner: !1 },
        { pubkey: h.payer, isWritable: !1, isSigner: !0 },
        { pubkey: h.treeDelegate, isWritable: !1, isSigner: !0 },
        { pubkey: h.collectionAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: h.collectionAuthorityRecordPda, isWritable: !1, isSigner: !1 },
        { pubkey: h.collectionMint, isWritable: !1, isSigner: !1 },
        { pubkey: h.collectionMetadata, isWritable: !0, isSigner: !1 },
        { pubkey: h.editionAccount, isWritable: !1, isSigner: !1 },
        { pubkey: h.bubblegumSigner, isWritable: !1, isSigner: !1 },
        { pubkey: h.logWrapper, isWritable: !1, isSigner: !1 },
        { pubkey: h.compressionProgram, isWritable: !1, isSigner: !1 },
        { pubkey: h.tokenMetadataProgram, isWritable: !1, isSigner: !1 },
        {
          pubkey: (m = h.systemProgram) !== null && m !== void 0 ? m : n.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    if (h.anchorRemainingAccounts != null) for (const I of h.anchorRemainingAccounts) A.push(I);
    return new n.TransactionInstruction({ programId: p, keys: A, data: _ });
  }
  i.createMintToCollectionV1Instruction = f;
})(k4);
var I4 = {};
(function (i) {
  var e =
      (se && se.__createBinding) ||
      (Object.create
        ? function (h, y, p, m) {
            m === void 0 && (m = p);
            var _ = Object.getOwnPropertyDescriptor(y, p);
            (!_ || ('get' in _ ? !y.__esModule : _.writable || _.configurable)) &&
              (_ = {
                enumerable: !0,
                get: function () {
                  return y[p];
                },
              }),
              Object.defineProperty(h, m, _);
          }
        : function (h, y, p, m) {
            m === void 0 && (m = p), (h[m] = y[p]);
          }),
    t =
      (se && se.__setModuleDefault) ||
      (Object.create
        ? function (h, y) {
            Object.defineProperty(h, 'default', { enumerable: !0, value: y });
          }
        : function (h, y) {
            h.default = y;
          }),
    r =
      (se && se.__importStar) ||
      function (h) {
        if (h && h.__esModule) return h;
        var y = {};
        if (h != null)
          for (var p in h)
            p !== 'default' && Object.prototype.hasOwnProperty.call(h, p) && e(y, h, p);
        return t(y, h), y;
      };
  Object.defineProperty(i, '__esModule', { value: !0 }),
    (i.createMintV1Instruction = i.mintV1InstructionDiscriminator = i.mintV1Struct = void 0);
  const s = r(Jt),
    n = r(qr),
    c = tn;
  (i.mintV1Struct = new s.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', s.uniformFixedSizeArray(s.u8, 8)],
      ['message', c.metadataArgsBeet],
    ],
    'MintV1InstructionArgs'
  )),
    (i.mintV1InstructionDiscriminator = [145, 98, 192, 118, 184, 147, 118, 104]);
  function f(h, y, p = new n.PublicKey('BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY')) {
    var m;
    const [_] = i.mintV1Struct.serialize({
        instructionDiscriminator: i.mintV1InstructionDiscriminator,
        ...y,
      }),
      A = [
        { pubkey: h.treeAuthority, isWritable: !0, isSigner: !1 },
        { pubkey: h.leafOwner, isWritable: !1, isSigner: !1 },
        { pubkey: h.leafDelegate, isWritable: !1, isSigner: !1 },
        { pubkey: h.merkleTree, isWritable: !0, isSigner: !1 },
        { pubkey: h.payer, isWritable: !1, isSigner: !0 },
        { pubkey: h.treeDelegate, isWritable: !1, isSigner: !0 },
        { pubkey: h.logWrapper, isWritable: !1, isSigner: !1 },
        { pubkey: h.compressionProgram, isWritable: !1, isSigner: !1 },
        {
          pubkey: (m = h.systemProgram) !== null && m !== void 0 ? m : n.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    if (h.anchorRemainingAccounts != null) for (const I of h.anchorRemainingAccounts) A.push(I);
    return new n.TransactionInstruction({ programId: p, keys: A, data: _ });
  }
  i.createMintV1Instruction = f;
})(I4);
var x4 = {};
(function (i) {
  var e =
      (se && se.__createBinding) ||
      (Object.create
        ? function (f, h, y, p) {
            p === void 0 && (p = y);
            var m = Object.getOwnPropertyDescriptor(h, y);
            (!m || ('get' in m ? !h.__esModule : m.writable || m.configurable)) &&
              (m = {
                enumerable: !0,
                get: function () {
                  return h[y];
                },
              }),
              Object.defineProperty(f, p, m);
          }
        : function (f, h, y, p) {
            p === void 0 && (p = y), (f[p] = h[y]);
          }),
    t =
      (se && se.__setModuleDefault) ||
      (Object.create
        ? function (f, h) {
            Object.defineProperty(f, 'default', { enumerable: !0, value: h });
          }
        : function (f, h) {
            f.default = h;
          }),
    r =
      (se && se.__importStar) ||
      function (f) {
        if (f && f.__esModule) return f;
        var h = {};
        if (f != null)
          for (var y in f)
            y !== 'default' && Object.prototype.hasOwnProperty.call(f, y) && e(h, f, y);
        return t(h, f), h;
      };
  Object.defineProperty(i, '__esModule', { value: !0 }),
    (i.createRedeemInstruction = i.redeemInstructionDiscriminator = i.redeemStruct = void 0);
  const s = r(Jt),
    n = r(qr);
  (i.redeemStruct = new s.BeetArgsStruct(
    [
      ['instructionDiscriminator', s.uniformFixedSizeArray(s.u8, 8)],
      ['root', s.uniformFixedSizeArray(s.u8, 32)],
      ['dataHash', s.uniformFixedSizeArray(s.u8, 32)],
      ['creatorHash', s.uniformFixedSizeArray(s.u8, 32)],
      ['nonce', s.u64],
      ['index', s.u32],
    ],
    'RedeemInstructionArgs'
  )),
    (i.redeemInstructionDiscriminator = [184, 12, 86, 149, 70, 196, 97, 225]);
  function c(f, h, y = new n.PublicKey('BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY')) {
    var p;
    const [m] = i.redeemStruct.serialize({
        instructionDiscriminator: i.redeemInstructionDiscriminator,
        ...h,
      }),
      _ = [
        { pubkey: f.treeAuthority, isWritable: !1, isSigner: !1 },
        { pubkey: f.leafOwner, isWritable: !0, isSigner: !0 },
        { pubkey: f.leafDelegate, isWritable: !1, isSigner: !1 },
        { pubkey: f.merkleTree, isWritable: !0, isSigner: !1 },
        { pubkey: f.voucher, isWritable: !0, isSigner: !1 },
        { pubkey: f.logWrapper, isWritable: !1, isSigner: !1 },
        { pubkey: f.compressionProgram, isWritable: !1, isSigner: !1 },
        {
          pubkey: (p = f.systemProgram) !== null && p !== void 0 ? p : n.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    if (f.anchorRemainingAccounts != null) for (const E of f.anchorRemainingAccounts) _.push(E);
    return new n.TransactionInstruction({ programId: y, keys: _, data: m });
  }
  i.createRedeemInstruction = c;
})(x4);
var B4 = {};
(function (i) {
  var e =
      (se && se.__createBinding) ||
      (Object.create
        ? function (y, p, m, _) {
            _ === void 0 && (_ = m);
            var A = Object.getOwnPropertyDescriptor(p, m);
            (!A || ('get' in A ? !p.__esModule : A.writable || A.configurable)) &&
              (A = {
                enumerable: !0,
                get: function () {
                  return p[m];
                },
              }),
              Object.defineProperty(y, _, A);
          }
        : function (y, p, m, _) {
            _ === void 0 && (_ = m), (y[_] = p[m]);
          }),
    t =
      (se && se.__setModuleDefault) ||
      (Object.create
        ? function (y, p) {
            Object.defineProperty(y, 'default', { enumerable: !0, value: p });
          }
        : function (y, p) {
            y.default = p;
          }),
    r =
      (se && se.__importStar) ||
      function (y) {
        if (y && y.__esModule) return y;
        var p = {};
        if (y != null)
          for (var m in y)
            m !== 'default' && Object.prototype.hasOwnProperty.call(y, m) && e(p, y, m);
        return t(p, y), p;
      };
  Object.defineProperty(i, '__esModule', { value: !0 }),
    (i.createSetAndVerifyCollectionInstruction =
      i.setAndVerifyCollectionInstructionDiscriminator =
      i.setAndVerifyCollectionStruct =
        void 0);
  const s = r(Jt),
    n = r(qr),
    c = r(Cs),
    f = tn;
  (i.setAndVerifyCollectionStruct = new s.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', s.uniformFixedSizeArray(s.u8, 8)],
      ['root', s.uniformFixedSizeArray(s.u8, 32)],
      ['dataHash', s.uniformFixedSizeArray(s.u8, 32)],
      ['creatorHash', s.uniformFixedSizeArray(s.u8, 32)],
      ['nonce', s.u64],
      ['index', s.u32],
      ['message', f.metadataArgsBeet],
      ['collection', c.publicKey],
    ],
    'SetAndVerifyCollectionInstructionArgs'
  )),
    (i.setAndVerifyCollectionInstructionDiscriminator = [235, 242, 121, 216, 158, 234, 180, 234]);
  function h(y, p, m = new n.PublicKey('BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY')) {
    var _;
    const [A] = i.setAndVerifyCollectionStruct.serialize({
        instructionDiscriminator: i.setAndVerifyCollectionInstructionDiscriminator,
        ...p,
      }),
      E = [
        { pubkey: y.treeAuthority, isWritable: !1, isSigner: !1 },
        { pubkey: y.leafOwner, isWritable: !1, isSigner: !1 },
        { pubkey: y.leafDelegate, isWritable: !1, isSigner: !1 },
        { pubkey: y.merkleTree, isWritable: !0, isSigner: !1 },
        { pubkey: y.payer, isWritable: !1, isSigner: !0 },
        { pubkey: y.treeDelegate, isWritable: !1, isSigner: !1 },
        { pubkey: y.collectionAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: y.collectionAuthorityRecordPda, isWritable: !1, isSigner: !1 },
        { pubkey: y.collectionMint, isWritable: !1, isSigner: !1 },
        { pubkey: y.collectionMetadata, isWritable: !0, isSigner: !1 },
        { pubkey: y.editionAccount, isWritable: !1, isSigner: !1 },
        { pubkey: y.bubblegumSigner, isWritable: !1, isSigner: !1 },
        { pubkey: y.logWrapper, isWritable: !1, isSigner: !1 },
        { pubkey: y.compressionProgram, isWritable: !1, isSigner: !1 },
        { pubkey: y.tokenMetadataProgram, isWritable: !1, isSigner: !1 },
        {
          pubkey: (_ = y.systemProgram) !== null && _ !== void 0 ? _ : n.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    if (y.anchorRemainingAccounts != null) for (const R of y.anchorRemainingAccounts) E.push(R);
    return new n.TransactionInstruction({ programId: m, keys: E, data: A });
  }
  i.createSetAndVerifyCollectionInstruction = h;
})(B4);
var R4 = {};
(function (i) {
  var e =
      (se && se.__createBinding) ||
      (Object.create
        ? function (f, h, y, p) {
            p === void 0 && (p = y);
            var m = Object.getOwnPropertyDescriptor(h, y);
            (!m || ('get' in m ? !h.__esModule : m.writable || m.configurable)) &&
              (m = {
                enumerable: !0,
                get: function () {
                  return h[y];
                },
              }),
              Object.defineProperty(f, p, m);
          }
        : function (f, h, y, p) {
            p === void 0 && (p = y), (f[p] = h[y]);
          }),
    t =
      (se && se.__setModuleDefault) ||
      (Object.create
        ? function (f, h) {
            Object.defineProperty(f, 'default', { enumerable: !0, value: h });
          }
        : function (f, h) {
            f.default = h;
          }),
    r =
      (se && se.__importStar) ||
      function (f) {
        if (f && f.__esModule) return f;
        var h = {};
        if (f != null)
          for (var y in f)
            y !== 'default' && Object.prototype.hasOwnProperty.call(f, y) && e(h, f, y);
        return t(h, f), h;
      };
  Object.defineProperty(i, '__esModule', { value: !0 }),
    (i.createSetTreeDelegateInstruction =
      i.setTreeDelegateInstructionDiscriminator =
      i.setTreeDelegateStruct =
        void 0);
  const s = r(Jt),
    n = r(qr);
  (i.setTreeDelegateStruct = new s.BeetArgsStruct(
    [['instructionDiscriminator', s.uniformFixedSizeArray(s.u8, 8)]],
    'SetTreeDelegateInstructionArgs'
  )),
    (i.setTreeDelegateInstructionDiscriminator = [253, 118, 66, 37, 190, 49, 154, 102]);
  function c(f, h = new n.PublicKey('BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY')) {
    var y;
    const [p] = i.setTreeDelegateStruct.serialize({
        instructionDiscriminator: i.setTreeDelegateInstructionDiscriminator,
      }),
      m = [
        { pubkey: f.treeAuthority, isWritable: !0, isSigner: !1 },
        { pubkey: f.treeCreator, isWritable: !1, isSigner: !0 },
        { pubkey: f.newTreeDelegate, isWritable: !1, isSigner: !1 },
        { pubkey: f.merkleTree, isWritable: !1, isSigner: !1 },
        {
          pubkey: (y = f.systemProgram) !== null && y !== void 0 ? y : n.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    if (f.anchorRemainingAccounts != null) for (const A of f.anchorRemainingAccounts) m.push(A);
    return new n.TransactionInstruction({ programId: h, keys: m, data: p });
  }
  i.createSetTreeDelegateInstruction = c;
})(R4);
var P4 = {};
(function (i) {
  var e =
      (se && se.__createBinding) ||
      (Object.create
        ? function (f, h, y, p) {
            p === void 0 && (p = y);
            var m = Object.getOwnPropertyDescriptor(h, y);
            (!m || ('get' in m ? !h.__esModule : m.writable || m.configurable)) &&
              (m = {
                enumerable: !0,
                get: function () {
                  return h[y];
                },
              }),
              Object.defineProperty(f, p, m);
          }
        : function (f, h, y, p) {
            p === void 0 && (p = y), (f[p] = h[y]);
          }),
    t =
      (se && se.__setModuleDefault) ||
      (Object.create
        ? function (f, h) {
            Object.defineProperty(f, 'default', { enumerable: !0, value: h });
          }
        : function (f, h) {
            f.default = h;
          }),
    r =
      (se && se.__importStar) ||
      function (f) {
        if (f && f.__esModule) return f;
        var h = {};
        if (f != null)
          for (var y in f)
            y !== 'default' && Object.prototype.hasOwnProperty.call(f, y) && e(h, f, y);
        return t(h, f), h;
      };
  Object.defineProperty(i, '__esModule', { value: !0 }),
    (i.createTransferInstruction = i.transferInstructionDiscriminator = i.transferStruct = void 0);
  const s = r(Jt),
    n = r(qr);
  (i.transferStruct = new s.BeetArgsStruct(
    [
      ['instructionDiscriminator', s.uniformFixedSizeArray(s.u8, 8)],
      ['root', s.uniformFixedSizeArray(s.u8, 32)],
      ['dataHash', s.uniformFixedSizeArray(s.u8, 32)],
      ['creatorHash', s.uniformFixedSizeArray(s.u8, 32)],
      ['nonce', s.u64],
      ['index', s.u32],
    ],
    'TransferInstructionArgs'
  )),
    (i.transferInstructionDiscriminator = [163, 52, 200, 231, 140, 3, 69, 186]);
  function c(f, h, y = new n.PublicKey('BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY')) {
    var p;
    const [m] = i.transferStruct.serialize({
        instructionDiscriminator: i.transferInstructionDiscriminator,
        ...h,
      }),
      _ = [
        { pubkey: f.treeAuthority, isWritable: !1, isSigner: !1 },
        { pubkey: f.leafOwner, isWritable: !1, isSigner: !1 },
        { pubkey: f.leafDelegate, isWritable: !1, isSigner: !1 },
        { pubkey: f.newLeafOwner, isWritable: !1, isSigner: !1 },
        { pubkey: f.merkleTree, isWritable: !0, isSigner: !1 },
        { pubkey: f.logWrapper, isWritable: !1, isSigner: !1 },
        { pubkey: f.compressionProgram, isWritable: !1, isSigner: !1 },
        {
          pubkey: (p = f.systemProgram) !== null && p !== void 0 ? p : n.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    if (f.anchorRemainingAccounts != null) for (const E of f.anchorRemainingAccounts) _.push(E);
    return new n.TransactionInstruction({ programId: y, keys: _, data: m });
  }
  i.createTransferInstruction = c;
})(P4);
var T4 = {};
(function (i) {
  var e =
      (se && se.__createBinding) ||
      (Object.create
        ? function (h, y, p, m) {
            m === void 0 && (m = p);
            var _ = Object.getOwnPropertyDescriptor(y, p);
            (!_ || ('get' in _ ? !y.__esModule : _.writable || _.configurable)) &&
              (_ = {
                enumerable: !0,
                get: function () {
                  return y[p];
                },
              }),
              Object.defineProperty(h, m, _);
          }
        : function (h, y, p, m) {
            m === void 0 && (m = p), (h[m] = y[p]);
          }),
    t =
      (se && se.__setModuleDefault) ||
      (Object.create
        ? function (h, y) {
            Object.defineProperty(h, 'default', { enumerable: !0, value: y });
          }
        : function (h, y) {
            h.default = y;
          }),
    r =
      (se && se.__importStar) ||
      function (h) {
        if (h && h.__esModule) return h;
        var y = {};
        if (h != null)
          for (var p in h)
            p !== 'default' && Object.prototype.hasOwnProperty.call(h, p) && e(y, h, p);
        return t(y, h), y;
      };
  Object.defineProperty(i, '__esModule', { value: !0 }),
    (i.createUnverifyCollectionInstruction =
      i.unverifyCollectionInstructionDiscriminator =
      i.unverifyCollectionStruct =
        void 0);
  const s = r(Jt),
    n = r(qr),
    c = tn;
  (i.unverifyCollectionStruct = new s.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', s.uniformFixedSizeArray(s.u8, 8)],
      ['root', s.uniformFixedSizeArray(s.u8, 32)],
      ['dataHash', s.uniformFixedSizeArray(s.u8, 32)],
      ['creatorHash', s.uniformFixedSizeArray(s.u8, 32)],
      ['nonce', s.u64],
      ['index', s.u32],
      ['message', c.metadataArgsBeet],
    ],
    'UnverifyCollectionInstructionArgs'
  )),
    (i.unverifyCollectionInstructionDiscriminator = [250, 251, 42, 106, 41, 137, 186, 168]);
  function f(h, y, p = new n.PublicKey('BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY')) {
    var m;
    const [_] = i.unverifyCollectionStruct.serialize({
        instructionDiscriminator: i.unverifyCollectionInstructionDiscriminator,
        ...y,
      }),
      A = [
        { pubkey: h.treeAuthority, isWritable: !1, isSigner: !1 },
        { pubkey: h.leafOwner, isWritable: !1, isSigner: !1 },
        { pubkey: h.leafDelegate, isWritable: !1, isSigner: !1 },
        { pubkey: h.merkleTree, isWritable: !0, isSigner: !1 },
        { pubkey: h.payer, isWritable: !1, isSigner: !0 },
        { pubkey: h.treeDelegate, isWritable: !1, isSigner: !1 },
        { pubkey: h.collectionAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: h.collectionAuthorityRecordPda, isWritable: !1, isSigner: !1 },
        { pubkey: h.collectionMint, isWritable: !1, isSigner: !1 },
        { pubkey: h.collectionMetadata, isWritable: !0, isSigner: !1 },
        { pubkey: h.editionAccount, isWritable: !1, isSigner: !1 },
        { pubkey: h.bubblegumSigner, isWritable: !1, isSigner: !1 },
        { pubkey: h.logWrapper, isWritable: !1, isSigner: !1 },
        { pubkey: h.compressionProgram, isWritable: !1, isSigner: !1 },
        { pubkey: h.tokenMetadataProgram, isWritable: !1, isSigner: !1 },
        {
          pubkey: (m = h.systemProgram) !== null && m !== void 0 ? m : n.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    if (h.anchorRemainingAccounts != null) for (const I of h.anchorRemainingAccounts) A.push(I);
    return new n.TransactionInstruction({ programId: p, keys: A, data: _ });
  }
  i.createUnverifyCollectionInstruction = f;
})(T4);
var O4 = {};
(function (i) {
  var e =
      (se && se.__createBinding) ||
      (Object.create
        ? function (h, y, p, m) {
            m === void 0 && (m = p);
            var _ = Object.getOwnPropertyDescriptor(y, p);
            (!_ || ('get' in _ ? !y.__esModule : _.writable || _.configurable)) &&
              (_ = {
                enumerable: !0,
                get: function () {
                  return y[p];
                },
              }),
              Object.defineProperty(h, m, _);
          }
        : function (h, y, p, m) {
            m === void 0 && (m = p), (h[m] = y[p]);
          }),
    t =
      (se && se.__setModuleDefault) ||
      (Object.create
        ? function (h, y) {
            Object.defineProperty(h, 'default', { enumerable: !0, value: y });
          }
        : function (h, y) {
            h.default = y;
          }),
    r =
      (se && se.__importStar) ||
      function (h) {
        if (h && h.__esModule) return h;
        var y = {};
        if (h != null)
          for (var p in h)
            p !== 'default' && Object.prototype.hasOwnProperty.call(h, p) && e(y, h, p);
        return t(y, h), y;
      };
  Object.defineProperty(i, '__esModule', { value: !0 }),
    (i.createUnverifyCreatorInstruction =
      i.unverifyCreatorInstructionDiscriminator =
      i.unverifyCreatorStruct =
        void 0);
  const s = r(Jt),
    n = r(qr),
    c = tn;
  (i.unverifyCreatorStruct = new s.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', s.uniformFixedSizeArray(s.u8, 8)],
      ['root', s.uniformFixedSizeArray(s.u8, 32)],
      ['dataHash', s.uniformFixedSizeArray(s.u8, 32)],
      ['creatorHash', s.uniformFixedSizeArray(s.u8, 32)],
      ['nonce', s.u64],
      ['index', s.u32],
      ['message', c.metadataArgsBeet],
    ],
    'UnverifyCreatorInstructionArgs'
  )),
    (i.unverifyCreatorInstructionDiscriminator = [107, 178, 57, 39, 105, 115, 112, 152]);
  function f(h, y, p = new n.PublicKey('BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY')) {
    var m;
    const [_] = i.unverifyCreatorStruct.serialize({
        instructionDiscriminator: i.unverifyCreatorInstructionDiscriminator,
        ...y,
      }),
      A = [
        { pubkey: h.treeAuthority, isWritable: !1, isSigner: !1 },
        { pubkey: h.leafOwner, isWritable: !1, isSigner: !1 },
        { pubkey: h.leafDelegate, isWritable: !1, isSigner: !1 },
        { pubkey: h.merkleTree, isWritable: !0, isSigner: !1 },
        { pubkey: h.payer, isWritable: !1, isSigner: !0 },
        { pubkey: h.creator, isWritable: !1, isSigner: !0 },
        { pubkey: h.logWrapper, isWritable: !1, isSigner: !1 },
        { pubkey: h.compressionProgram, isWritable: !1, isSigner: !1 },
        {
          pubkey: (m = h.systemProgram) !== null && m !== void 0 ? m : n.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    if (h.anchorRemainingAccounts != null) for (const I of h.anchorRemainingAccounts) A.push(I);
    return new n.TransactionInstruction({ programId: p, keys: A, data: _ });
  }
  i.createUnverifyCreatorInstruction = f;
})(O4);
var C4 = {};
(function (i) {
  var e =
      (se && se.__createBinding) ||
      (Object.create
        ? function (h, y, p, m) {
            m === void 0 && (m = p);
            var _ = Object.getOwnPropertyDescriptor(y, p);
            (!_ || ('get' in _ ? !y.__esModule : _.writable || _.configurable)) &&
              (_ = {
                enumerable: !0,
                get: function () {
                  return y[p];
                },
              }),
              Object.defineProperty(h, m, _);
          }
        : function (h, y, p, m) {
            m === void 0 && (m = p), (h[m] = y[p]);
          }),
    t =
      (se && se.__setModuleDefault) ||
      (Object.create
        ? function (h, y) {
            Object.defineProperty(h, 'default', { enumerable: !0, value: y });
          }
        : function (h, y) {
            h.default = y;
          }),
    r =
      (se && se.__importStar) ||
      function (h) {
        if (h && h.__esModule) return h;
        var y = {};
        if (h != null)
          for (var p in h)
            p !== 'default' && Object.prototype.hasOwnProperty.call(h, p) && e(y, h, p);
        return t(y, h), y;
      };
  Object.defineProperty(i, '__esModule', { value: !0 }),
    (i.createVerifyCollectionInstruction =
      i.verifyCollectionInstructionDiscriminator =
      i.verifyCollectionStruct =
        void 0);
  const s = r(Jt),
    n = r(qr),
    c = tn;
  (i.verifyCollectionStruct = new s.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', s.uniformFixedSizeArray(s.u8, 8)],
      ['root', s.uniformFixedSizeArray(s.u8, 32)],
      ['dataHash', s.uniformFixedSizeArray(s.u8, 32)],
      ['creatorHash', s.uniformFixedSizeArray(s.u8, 32)],
      ['nonce', s.u64],
      ['index', s.u32],
      ['message', c.metadataArgsBeet],
    ],
    'VerifyCollectionInstructionArgs'
  )),
    (i.verifyCollectionInstructionDiscriminator = [56, 113, 101, 253, 79, 55, 122, 169]);
  function f(h, y, p = new n.PublicKey('BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY')) {
    var m;
    const [_] = i.verifyCollectionStruct.serialize({
        instructionDiscriminator: i.verifyCollectionInstructionDiscriminator,
        ...y,
      }),
      A = [
        { pubkey: h.treeAuthority, isWritable: !1, isSigner: !1 },
        { pubkey: h.leafOwner, isWritable: !1, isSigner: !1 },
        { pubkey: h.leafDelegate, isWritable: !1, isSigner: !1 },
        { pubkey: h.merkleTree, isWritable: !0, isSigner: !1 },
        { pubkey: h.payer, isWritable: !1, isSigner: !0 },
        { pubkey: h.treeDelegate, isWritable: !1, isSigner: !1 },
        { pubkey: h.collectionAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: h.collectionAuthorityRecordPda, isWritable: !1, isSigner: !1 },
        { pubkey: h.collectionMint, isWritable: !1, isSigner: !1 },
        { pubkey: h.collectionMetadata, isWritable: !0, isSigner: !1 },
        { pubkey: h.editionAccount, isWritable: !1, isSigner: !1 },
        { pubkey: h.bubblegumSigner, isWritable: !1, isSigner: !1 },
        { pubkey: h.logWrapper, isWritable: !1, isSigner: !1 },
        { pubkey: h.compressionProgram, isWritable: !1, isSigner: !1 },
        { pubkey: h.tokenMetadataProgram, isWritable: !1, isSigner: !1 },
        {
          pubkey: (m = h.systemProgram) !== null && m !== void 0 ? m : n.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    if (h.anchorRemainingAccounts != null) for (const I of h.anchorRemainingAccounts) A.push(I);
    return new n.TransactionInstruction({ programId: p, keys: A, data: _ });
  }
  i.createVerifyCollectionInstruction = f;
})(C4);
var L4 = {};
(function (i) {
  var e =
      (se && se.__createBinding) ||
      (Object.create
        ? function (h, y, p, m) {
            m === void 0 && (m = p);
            var _ = Object.getOwnPropertyDescriptor(y, p);
            (!_ || ('get' in _ ? !y.__esModule : _.writable || _.configurable)) &&
              (_ = {
                enumerable: !0,
                get: function () {
                  return y[p];
                },
              }),
              Object.defineProperty(h, m, _);
          }
        : function (h, y, p, m) {
            m === void 0 && (m = p), (h[m] = y[p]);
          }),
    t =
      (se && se.__setModuleDefault) ||
      (Object.create
        ? function (h, y) {
            Object.defineProperty(h, 'default', { enumerable: !0, value: y });
          }
        : function (h, y) {
            h.default = y;
          }),
    r =
      (se && se.__importStar) ||
      function (h) {
        if (h && h.__esModule) return h;
        var y = {};
        if (h != null)
          for (var p in h)
            p !== 'default' && Object.prototype.hasOwnProperty.call(h, p) && e(y, h, p);
        return t(y, h), y;
      };
  Object.defineProperty(i, '__esModule', { value: !0 }),
    (i.createVerifyCreatorInstruction =
      i.verifyCreatorInstructionDiscriminator =
      i.verifyCreatorStruct =
        void 0);
  const s = r(Jt),
    n = r(qr),
    c = tn;
  (i.verifyCreatorStruct = new s.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', s.uniformFixedSizeArray(s.u8, 8)],
      ['root', s.uniformFixedSizeArray(s.u8, 32)],
      ['dataHash', s.uniformFixedSizeArray(s.u8, 32)],
      ['creatorHash', s.uniformFixedSizeArray(s.u8, 32)],
      ['nonce', s.u64],
      ['index', s.u32],
      ['message', c.metadataArgsBeet],
    ],
    'VerifyCreatorInstructionArgs'
  )),
    (i.verifyCreatorInstructionDiscriminator = [52, 17, 96, 132, 71, 4, 85, 194]);
  function f(h, y, p = new n.PublicKey('BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY')) {
    var m;
    const [_] = i.verifyCreatorStruct.serialize({
        instructionDiscriminator: i.verifyCreatorInstructionDiscriminator,
        ...y,
      }),
      A = [
        { pubkey: h.treeAuthority, isWritable: !1, isSigner: !1 },
        { pubkey: h.leafOwner, isWritable: !1, isSigner: !1 },
        { pubkey: h.leafDelegate, isWritable: !1, isSigner: !1 },
        { pubkey: h.merkleTree, isWritable: !0, isSigner: !1 },
        { pubkey: h.payer, isWritable: !1, isSigner: !0 },
        { pubkey: h.creator, isWritable: !1, isSigner: !0 },
        { pubkey: h.logWrapper, isWritable: !1, isSigner: !1 },
        { pubkey: h.compressionProgram, isWritable: !1, isSigner: !1 },
        {
          pubkey: (m = h.systemProgram) !== null && m !== void 0 ? m : n.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    if (h.anchorRemainingAccounts != null) for (const I of h.anchorRemainingAccounts) A.push(I);
    return new n.TransactionInstruction({ programId: p, keys: A, data: _ });
  }
  i.createVerifyCreatorInstruction = f;
})(L4);
(function (i) {
  var e =
      (se && se.__createBinding) ||
      (Object.create
        ? function (r, s, n, c) {
            c === void 0 && (c = n);
            var f = Object.getOwnPropertyDescriptor(s, n);
            (!f || ('get' in f ? !s.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return s[n];
                },
              }),
              Object.defineProperty(r, c, f);
          }
        : function (r, s, n, c) {
            c === void 0 && (c = n), (r[c] = s[n]);
          }),
    t =
      (se && se.__exportStar) ||
      function (r, s) {
        for (var n in r)
          n !== 'default' && !Object.prototype.hasOwnProperty.call(s, n) && e(s, r, n);
      };
  Object.defineProperty(i, '__esModule', { value: !0 }),
    t(JS, i),
    t(XS, i),
    t(QS, i),
    t(_4, i),
    t(S4, i),
    t(E4, i),
    t(k4, i),
    t(I4, i),
    t(x4, i),
    t(B4, i),
    t(R4, i),
    t(P4, i),
    t(T4, i),
    t(O4, i),
    t(C4, i),
    t(L4, i);
})(ZS);
var N4 = {},
  $4 = {};
(function (i) {
  var e =
      (se && se.__createBinding) ||
      (Object.create
        ? function (c, f, h, y) {
            y === void 0 && (y = h);
            var p = Object.getOwnPropertyDescriptor(f, h);
            (!p || ('get' in p ? !f.__esModule : p.writable || p.configurable)) &&
              (p = {
                enumerable: !0,
                get: function () {
                  return f[h];
                },
              }),
              Object.defineProperty(c, y, p);
          }
        : function (c, f, h, y) {
            y === void 0 && (y = h), (c[y] = f[h]);
          }),
    t =
      (se && se.__setModuleDefault) ||
      (Object.create
        ? function (c, f) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: f });
          }
        : function (c, f) {
            c.default = f;
          }),
    r =
      (se && se.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var f = {};
        if (c != null)
          for (var h in c)
            h !== 'default' && Object.prototype.hasOwnProperty.call(c, h) && e(f, c, h);
        return t(f, c), f;
      };
  Object.defineProperty(i, '__esModule', { value: !0 }),
    (i.bubblegumEventTypeBeet = i.BubblegumEventType = void 0);
  const s = r(Jt);
  var n;
  (function (c) {
    (c[(c.Uninitialized = 0)] = 'Uninitialized'), (c[(c.LeafSchemaEvent = 1)] = 'LeafSchemaEvent');
  })((n = i.BubblegumEventType || (i.BubblegumEventType = {}))),
    (i.bubblegumEventTypeBeet = s.fixedScalarEnum(n));
})($4);
var D4 = {};
(function (i) {
  var e =
      (se && se.__createBinding) ||
      (Object.create
        ? function (c, f, h, y) {
            y === void 0 && (y = h);
            var p = Object.getOwnPropertyDescriptor(f, h);
            (!p || ('get' in p ? !f.__esModule : p.writable || p.configurable)) &&
              (p = {
                enumerable: !0,
                get: function () {
                  return f[h];
                },
              }),
              Object.defineProperty(c, y, p);
          }
        : function (c, f, h, y) {
            y === void 0 && (y = h), (c[y] = f[h]);
          }),
    t =
      (se && se.__setModuleDefault) ||
      (Object.create
        ? function (c, f) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: f });
          }
        : function (c, f) {
            c.default = f;
          }),
    r =
      (se && se.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var f = {};
        if (c != null)
          for (var h in c)
            h !== 'default' && Object.prototype.hasOwnProperty.call(c, h) && e(f, c, h);
        return t(f, c), f;
      };
  Object.defineProperty(i, '__esModule', { value: !0 }),
    (i.instructionNameBeet = i.InstructionName = void 0);
  const s = r(Jt);
  var n;
  (function (c) {
    (c[(c.Unknown = 0)] = 'Unknown'),
      (c[(c.MintV1 = 1)] = 'MintV1'),
      (c[(c.Redeem = 2)] = 'Redeem'),
      (c[(c.CancelRedeem = 3)] = 'CancelRedeem'),
      (c[(c.Transfer = 4)] = 'Transfer'),
      (c[(c.Delegate = 5)] = 'Delegate'),
      (c[(c.DecompressV1 = 6)] = 'DecompressV1'),
      (c[(c.Compress = 7)] = 'Compress'),
      (c[(c.Burn = 8)] = 'Burn'),
      (c[(c.CreateTree = 9)] = 'CreateTree'),
      (c[(c.VerifyCreator = 10)] = 'VerifyCreator'),
      (c[(c.UnverifyCreator = 11)] = 'UnverifyCreator'),
      (c[(c.VerifyCollection = 12)] = 'VerifyCollection'),
      (c[(c.UnverifyCollection = 13)] = 'UnverifyCollection'),
      (c[(c.SetAndVerifyCollection = 14)] = 'SetAndVerifyCollection'),
      (c[(c.MintToCollectionV1 = 15)] = 'MintToCollectionV1');
  })((n = i.InstructionName || (i.InstructionName = {}))),
    (i.instructionNameBeet = s.fixedScalarEnum(n));
})(D4);
var U4 = {};
(function (i) {
  var e =
      (se && se.__createBinding) ||
      (Object.create
        ? function (c, f, h, y) {
            y === void 0 && (y = h);
            var p = Object.getOwnPropertyDescriptor(f, h);
            (!p || ('get' in p ? !f.__esModule : p.writable || p.configurable)) &&
              (p = {
                enumerable: !0,
                get: function () {
                  return f[h];
                },
              }),
              Object.defineProperty(c, y, p);
          }
        : function (c, f, h, y) {
            y === void 0 && (y = h), (c[y] = f[h]);
          }),
    t =
      (se && se.__setModuleDefault) ||
      (Object.create
        ? function (c, f) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: f });
          }
        : function (c, f) {
            c.default = f;
          }),
    r =
      (se && se.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var f = {};
        if (c != null)
          for (var h in c)
            h !== 'default' && Object.prototype.hasOwnProperty.call(c, h) && e(f, c, h);
        return t(f, c), f;
      };
  Object.defineProperty(i, '__esModule', { value: !0 }), (i.versionBeet = i.Version = void 0);
  const s = r(Jt);
  var n;
  (function (c) {
    c[(c.V1 = 0)] = 'V1';
  })((n = i.Version || (i.Version = {}))),
    (i.versionBeet = s.fixedScalarEnum(n));
})(U4);
(function (i) {
  var e =
      (se && se.__createBinding) ||
      (Object.create
        ? function (r, s, n, c) {
            c === void 0 && (c = n);
            var f = Object.getOwnPropertyDescriptor(s, n);
            (!f || ('get' in f ? !s.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return s[n];
                },
              }),
              Object.defineProperty(r, c, f);
          }
        : function (r, s, n, c) {
            c === void 0 && (c = n), (r[c] = s[n]);
          }),
    t =
      (se && se.__exportStar) ||
      function (r, s) {
        for (var n in r)
          n !== 'default' && !Object.prototype.hasOwnProperty.call(s, n) && e(s, r, n);
      };
  Object.defineProperty(i, '__esModule', { value: !0 }),
    t($4, i),
    t(Dc, i),
    t(zc, i),
    t(D4, i),
    t(ks, i),
    t(tn, i),
    t(Sg, i),
    t(wg, i),
    t(_g, i),
    t(Uc, i),
    t(U4, i);
})(N4);
(function (i) {
  var e =
      (se && se.__createBinding) ||
      (Object.create
        ? function (s, n, c, f) {
            f === void 0 && (f = c);
            var h = Object.getOwnPropertyDescriptor(n, c);
            (!h || ('get' in h ? !n.__esModule : h.writable || h.configurable)) &&
              (h = {
                enumerable: !0,
                get: function () {
                  return n[c];
                },
              }),
              Object.defineProperty(s, f, h);
          }
        : function (s, n, c, f) {
            f === void 0 && (f = c), (s[f] = n[c]);
          }),
    t =
      (se && se.__exportStar) ||
      function (s, n) {
        for (var c in s)
          c !== 'default' && !Object.prototype.hasOwnProperty.call(n, c) && e(n, s, c);
      };
  Object.defineProperty(i, '__esModule', { value: !0 }),
    (i.PROGRAM_ID = i.PROGRAM_ADDRESS = void 0);
  const r = qr;
  t(J_, i),
    t(it, i),
    t(ZS, i),
    t(N4, i),
    (i.PROGRAM_ADDRESS = 'BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY'),
    (i.PROGRAM_ID = new r.PublicKey(i.PROGRAM_ADDRESS));
})(Nu);
var yh = {},
  z4 = {},
  Ai = {},
  gh = {};
Object.defineProperty(gh, '__esModule', { value: !0 });
gh.errorCodeFromLogs = void 0;
const bU = /Custom program error: (0x[a-f0-9]+)/i;
function vU(i) {
  for (const e of i) {
    const t = e.match(bU);
    if (t == null) continue;
    const r = t[1];
    try {
      return parseInt(r);
    } catch {}
  }
  return null;
}
gh.errorCodeFromLogs = vU;
var F4 = {};
(function (i) {
  Object.defineProperty(i, '__esModule', { value: !0 }),
    (i.LangErrorMessage = i.LangErrorCode = void 0),
    (i.LangErrorCode = {
      InstructionMissing: 100,
      InstructionFallbackNotFound: 101,
      InstructionDidNotDeserialize: 102,
      InstructionDidNotSerialize: 103,
      IdlInstructionStub: 1e3,
      IdlInstructionInvalidProgram: 1001,
      ConstraintMut: 2e3,
      ConstraintHasOne: 2001,
      ConstraintSigner: 2002,
      ConstraintRaw: 2003,
      ConstraintOwner: 2004,
      ConstraintRentExempt: 2005,
      ConstraintSeeds: 2006,
      ConstraintExecutable: 2007,
      ConstraintState: 2008,
      ConstraintAssociated: 2009,
      ConstraintAssociatedInit: 2010,
      ConstraintClose: 2011,
      ConstraintAddress: 2012,
      ConstraintZero: 2013,
      ConstraintTokenMint: 2014,
      ConstraintTokenOwner: 2015,
      ConstraintMintMintAuthority: 2016,
      ConstraintMintFreezeAuthority: 2017,
      ConstraintMintDecimals: 2018,
      ConstraintSpace: 2019,
      AccountDiscriminatorAlreadySet: 3e3,
      AccountDiscriminatorNotFound: 3001,
      AccountDiscriminatorMismatch: 3002,
      AccountDidNotDeserialize: 3003,
      AccountDidNotSerialize: 3004,
      AccountNotEnoughKeys: 3005,
      AccountNotMutable: 3006,
      AccountOwnedByWrongProgram: 3007,
      InvalidProgramId: 3008,
      InvalidProgramExecutable: 3009,
      AccountNotSigner: 3010,
      AccountNotSystemOwned: 3011,
      AccountNotInitialized: 3012,
      AccountNotProgramData: 3013,
      StateInvalidAddress: 4e3,
      Deprecated: 5e3,
    }),
    (i.LangErrorMessage = new Map([
      [i.LangErrorCode.InstructionMissing, '8 byte instruction identifier not provided'],
      [i.LangErrorCode.InstructionFallbackNotFound, 'Fallback functions are not supported'],
      [
        i.LangErrorCode.InstructionDidNotDeserialize,
        'The program could not deserialize the given instruction',
      ],
      [
        i.LangErrorCode.InstructionDidNotSerialize,
        'The program could not serialize the given instruction',
      ],
      [i.LangErrorCode.IdlInstructionStub, 'The program was compiled without idl instructions'],
      [
        i.LangErrorCode.IdlInstructionInvalidProgram,
        'The transaction was given an invalid program for the IDL instruction',
      ],
      [i.LangErrorCode.ConstraintMut, 'A mut constraint was violated'],
      [i.LangErrorCode.ConstraintHasOne, 'A has_one constraint was violated'],
      [i.LangErrorCode.ConstraintSigner, 'A signer constraint was violated'],
      [i.LangErrorCode.ConstraintRaw, 'A raw constraint was violated'],
      [i.LangErrorCode.ConstraintOwner, 'An owner constraint was violated'],
      [i.LangErrorCode.ConstraintRentExempt, 'A rent exempt constraint was violated'],
      [i.LangErrorCode.ConstraintSeeds, 'A seeds constraint was violated'],
      [i.LangErrorCode.ConstraintExecutable, 'An executable constraint was violated'],
      [i.LangErrorCode.ConstraintState, 'A state constraint was violated'],
      [i.LangErrorCode.ConstraintAssociated, 'An associated constraint was violated'],
      [i.LangErrorCode.ConstraintAssociatedInit, 'An associated init constraint was violated'],
      [i.LangErrorCode.ConstraintClose, 'A close constraint was violated'],
      [i.LangErrorCode.ConstraintAddress, 'An address constraint was violated'],
      [i.LangErrorCode.ConstraintZero, 'Expected zero account discriminant'],
      [i.LangErrorCode.ConstraintTokenMint, 'A token mint constraint was violated'],
      [i.LangErrorCode.ConstraintTokenOwner, 'A token owner constraint was violated'],
      [
        i.LangErrorCode.ConstraintMintMintAuthority,
        'A mint mint authority constraint was violated',
      ],
      [
        i.LangErrorCode.ConstraintMintFreezeAuthority,
        'A mint freeze authority constraint was violated',
      ],
      [i.LangErrorCode.ConstraintMintDecimals, 'A mint decimals constraint was violated'],
      [i.LangErrorCode.ConstraintSpace, 'A space constraint was violated'],
      [
        i.LangErrorCode.AccountDiscriminatorAlreadySet,
        'The account discriminator was already set on this account',
      ],
      [
        i.LangErrorCode.AccountDiscriminatorNotFound,
        'No 8 byte discriminator was found on the account',
      ],
      [
        i.LangErrorCode.AccountDiscriminatorMismatch,
        '8 byte discriminator did not match what was expected',
      ],
      [i.LangErrorCode.AccountDidNotDeserialize, 'Failed to deserialize the account'],
      [i.LangErrorCode.AccountDidNotSerialize, 'Failed to serialize the account'],
      [i.LangErrorCode.AccountNotEnoughKeys, 'Not enough account keys given to the instruction'],
      [i.LangErrorCode.AccountNotMutable, 'The given account is not mutable'],
      [
        i.LangErrorCode.AccountOwnedByWrongProgram,
        'The given account is owned by a different program than expected',
      ],
      [i.LangErrorCode.InvalidProgramId, 'Program ID was not as expected'],
      [i.LangErrorCode.InvalidProgramExecutable, 'Program account is not executable'],
      [i.LangErrorCode.AccountNotSigner, 'The given account did not sign'],
      [
        i.LangErrorCode.AccountNotSystemOwned,
        'The given account is not owned by the system program',
      ],
      [
        i.LangErrorCode.AccountNotInitialized,
        'The program expected this account to be already initialized',
      ],
      [i.LangErrorCode.AccountNotProgramData, 'The given account is not a program data account'],
      [
        i.LangErrorCode.StateInvalidAddress,
        'The given state account does not have the correct address',
      ],
      [i.LangErrorCode.Deprecated, 'The API being used is deprecated and should no longer be used'],
    ]));
})(F4);
var bh = {};
Object.defineProperty(bh, '__esModule', { value: !0 });
bh.tokenLendingErrors = void 0;
bh.tokenLendingErrors = new Map([
  [0, { code: 0, message: 'Failed to unpack instruction data"', name: 'InstructionUnpackError' }],
  [1, { code: 1, message: 'Account is already initialized"', name: 'AlreadyInitialized' }],
  [2, { code: 2, message: 'Lamport balance below rent-exempt threshold"', name: 'NotRentExempt' }],
  [3, { code: 3, message: 'Market authority is invalid"', name: 'InvalidMarketAuthority' }],
  [4, { code: 4, message: 'Market owner is invalid"', name: 'InvalidMarketOwner' }],
  [
    5,
    {
      code: 5,
      message: 'Input account owner is not the program address"',
      name: 'InvalidAccountOwner',
    },
  ],
  [
    6,
    {
      code: 6,
      message: 'Input token account is not owned by the correct token program id"',
      name: 'InvalidTokenOwner',
    },
  ],
  [7, { code: 7, message: 'Input token account is not valid"', name: 'InvalidTokenAccount' }],
  [8, { code: 8, message: 'Input token mint account is not valid"', name: 'InvalidTokenMint' }],
  [
    9,
    { code: 9, message: 'Input token program account is not valid"', name: 'InvalidTokenProgram' },
  ],
  [10, { code: 10, message: 'Input amount is invalid"', name: 'InvalidAmount' }],
  [11, { code: 11, message: 'Input config value is invalid"', name: 'InvalidConfig' }],
  [12, { code: 12, message: 'Input account must be a signer"', name: 'InvalidSigner' }],
  [13, { code: 13, message: 'Invalid account input"', name: 'InvalidAccountInput' }],
  [14, { code: 14, message: 'Math operation overflow"', name: 'MathOverflow' }],
  [15, { code: 15, message: 'Token initialize mint failed"', name: 'TokenInitializeMintFailed' }],
  [
    16,
    { code: 16, message: 'Token initialize account failed"', name: 'TokenInitializeAccountFailed' },
  ],
  [17, { code: 17, message: 'Token transfer failed"', name: 'TokenTransferFailed' }],
  [18, { code: 18, message: 'Token mint to failed"', name: 'TokenMintToFailed' }],
  [19, { code: 19, message: 'Token burn failed"', name: 'TokenBurnFailed' }],
  [20, { code: 20, message: 'Insufficient liquidity available"', name: 'InsufficientLiquidity' }],
  [
    21,
    {
      code: 21,
      message: 'Input reserve has collateral disabled"',
      name: 'ReserveCollateralDisabled',
    },
  ],
  [22, { code: 22, message: 'Reserve state needs to be refreshed"', name: 'ReserveStale' }],
  [23, { code: 23, message: 'Withdraw amount too small"', name: 'WithdrawTooSmall' }],
  [24, { code: 24, message: 'Withdraw amount too large"', name: 'WithdrawTooLarge' }],
  [
    25,
    {
      code: 25,
      message: 'Borrow amount too small to receive liquidity after fees"',
      name: 'BorrowTooSmall',
    },
  ],
  [
    26,
    {
      code: 26,
      message: 'Borrow amount too large for deposited collateral"',
      name: 'BorrowTooLarge',
    },
  ],
  [
    27,
    { code: 27, message: 'Repay amount too small to transfer liquidity"', name: 'RepayTooSmall' },
  ],
  [
    28,
    {
      code: 28,
      message: 'Liquidation amount too small to receive collateral"',
      name: 'LiquidationTooSmall',
    },
  ],
  [29, { code: 29, message: 'Cannot liquidate healthy obligations"', name: 'ObligationHealthy' }],
  [30, { code: 30, message: 'Obligation state needs to be refreshed"', name: 'ObligationStale' }],
  [31, { code: 31, message: 'Obligation reserve limit exceeded"', name: 'ObligationReserveLimit' }],
  [32, { code: 32, message: 'Obligation owner is invalid"', name: 'InvalidObligationOwner' }],
  [33, { code: 33, message: 'Obligation deposits are empty"', name: 'ObligationDepositsEmpty' }],
  [34, { code: 34, message: 'Obligation borrows are empty"', name: 'ObligationBorrowsEmpty' }],
  [
    35,
    { code: 35, message: 'Obligation deposits have zero value"', name: 'ObligationDepositsZero' },
  ],
  [36, { code: 36, message: 'Obligation borrows have zero value"', name: 'ObligationBorrowsZero' }],
  [
    37,
    { code: 37, message: 'Invalid obligation collateral"', name: 'InvalidObligationCollateral' },
  ],
  [38, { code: 38, message: 'Invalid obligation liquidity"', name: 'InvalidObligationLiquidity' }],
  [39, { code: 39, message: 'Obligation collateral is empty"', name: 'ObligationCollateralEmpty' }],
  [40, { code: 40, message: 'Obligation liquidity is empty"', name: 'ObligationLiquidityEmpty' }],
  [41, { code: 41, message: 'Interest rate is negative"', name: 'NegativeInterestRate' }],
  [42, { code: 42, message: 'Input oracle config is invalid"', name: 'InvalidOracleConfig' }],
  [
    43,
    {
      code: 43,
      message: 'Input flash loan receiver program account is not valid"',
      name: 'InvalidFlashLoanReceiverProgram',
    },
  ],
  [
    44,
    {
      code: 44,
      message: 'Not enough liquidity after flash loan"',
      name: 'NotEnoughLiquidityAfterFlashLoan',
    },
  ],
]);
var mU =
    (se && se.__createBinding) ||
    (Object.create
      ? function (i, e, t, r) {
          r === void 0 && (r = t),
            Object.defineProperty(i, r, {
              enumerable: !0,
              get: function () {
                return e[t];
              },
            });
        }
      : function (i, e, t, r) {
          r === void 0 && (r = t), (i[r] = e[t]);
        }),
  wU =
    (se && se.__setModuleDefault) ||
    (Object.create
      ? function (i, e) {
          Object.defineProperty(i, 'default', { enumerable: !0, value: e });
        }
      : function (i, e) {
          i.default = e;
        }),
  _U =
    (se && se.__importStar) ||
    function (i) {
      if (i && i.__esModule) return i;
      var e = {};
      if (i != null)
        for (var t in i)
          t !== 'default' && Object.prototype.hasOwnProperty.call(i, t) && mU(e, i, t);
      return wU(e, i), e;
    };
Object.defineProperty(Ai, '__esModule', { value: !0 });
Ai.TokenLendingError =
  Ai.AnchorError =
  Ai.CustomProgramError =
  Ai.CusperUnknownError =
  Ai.initCusper =
  Ai.ErrorResolver =
    void 0;
const SU = gh,
  M2 = _U(F4),
  MU = bh;
class q4 {
  constructor(e) {
    this.resolveErrorFromCode = e;
  }
  errorFromCode(e, t, r = !0) {
    let s = this.resolveErrorFromCode != null ? this.resolveErrorFromCode(e) : null;
    if (s != null) return this.passPreparedError(s, t ?? this.errorFromCode);
    if (((s = $a.fromCode(e)), s != null))
      return this.passPreparedError(s, t ?? this.errorFromCode);
    if (((s = Da.fromCode(e)), s != null))
      return this.passPreparedError(s, t ?? this.errorFromCode);
    if (r)
      return (
        (s = new F1(e, 'CusperUnknownError', 'cusper does not know this error')),
        this.passPreparedError(s, t ?? this.errorFromCode)
      );
  }
  errorFromProgramLogs(e, t = !0) {
    const r = (0, SU.errorCodeFromLogs)(e);
    return r == null ? null : this.errorFromCode(r, this.errorFromProgramLogs, t);
  }
  throwError(e) {
    const t =
      (e.logs != null && this.errorFromProgramLogs(e.logs, !0)) ||
      new F1(-1, 'Error created without logs and thus without error code');
    throw this.passPreparedError(t, this.throwError);
  }
  passPreparedError(e, t) {
    return e == null
      ? null
      : (typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(e, t), e);
  }
}
Ai.ErrorResolver = q4;
function AU(i) {
  return new q4(i);
}
Ai.initCusper = AU;
class F1 extends Error {
  constructor(e, ...t) {
    super(...t), (this.code = e), (this.name = 'CusperUnknownError');
  }
}
Ai.CusperUnknownError = F1;
class EU extends Error {
  constructor(e, t, ...r) {
    super(...r), (this.code = e), (this.name = `CustomProgramError#${t}`);
  }
}
Ai.CustomProgramError = EU;
class $a extends Error {
  constructor(e, t, ...r) {
    super(...r), (this.code = e), (this.name = `AnchorError#${t}`);
  }
  static fromCode(e) {
    const t = $a.errorMap.get(e);
    return t != null ? new $a(t.code, t.name, t.message) : null;
  }
  toString() {
    return `${this.name}: ${this.message}`;
  }
}
Ai.AnchorError = $a;
$a.errorMap = Object.entries(M2.LangErrorCode).reduce(
  (i, [e, t]) => (i.set(t, { code: t, name: e, message: M2.LangErrorMessage.get(t) }), i),
  new Map()
);
class Da extends Error {
  constructor(e, t, ...r) {
    super(...r), (this.code = e), (this.name = `TokenLendingError#${t}`);
  }
  static fromCode(e) {
    const t = Da.errorMap.get(e);
    return t != null ? new Da(t.code, t.name, t.message) : null;
  }
  toString() {
    return `${this.name}: ${this.message}`;
  }
}
Ai.TokenLendingError = Da;
Da.errorMap = MU.tokenLendingErrors;
var W4 = {};
Object.defineProperty(W4, '__esModule', { value: !0 });
(function (i) {
  var e =
      (se && se.__createBinding) ||
      (Object.create
        ? function (r, s, n, c) {
            c === void 0 && (c = n),
              Object.defineProperty(r, c, {
                enumerable: !0,
                get: function () {
                  return s[n];
                },
              });
          }
        : function (r, s, n, c) {
            c === void 0 && (c = n), (r[c] = s[n]);
          }),
    t =
      (se && se.__exportStar) ||
      function (r, s) {
        for (var n in r)
          n !== 'default' && !Object.prototype.hasOwnProperty.call(s, n) && e(s, r, n);
      };
  Object.defineProperty(i, '__esModule', { value: !0 }), t(Ai, i), t(W4, i);
})(z4);
Object.defineProperty(yh, '__esModule', { value: !0 });
yh.cusper = void 0;
const kU = z4,
  IU = Nu;
yh.cusper = (0, kU.initCusper)(IU.errorFromCode);
var K4 = {};
(function (i) {
  var e =
      (se && se.__createBinding) ||
      (Object.create
        ? function (_, A, E, I) {
            I === void 0 && (I = E);
            var R = Object.getOwnPropertyDescriptor(A, E);
            (!R || ('get' in R ? !A.__esModule : R.writable || R.configurable)) &&
              (R = {
                enumerable: !0,
                get: function () {
                  return A[E];
                },
              }),
              Object.defineProperty(_, I, R);
          }
        : function (_, A, E, I) {
            I === void 0 && (I = E), (_[I] = A[E]);
          }),
    t =
      (se && se.__exportStar) ||
      function (_, A) {
        for (var E in _)
          E !== 'default' && !Object.prototype.hasOwnProperty.call(A, E) && e(A, _, E);
      },
    r =
      (se && se.__importDefault) ||
      function (_) {
        return _ && _.__esModule ? _ : { default: _ };
      };
  Object.defineProperty(i, '__esModule', { value: !0 }),
    (i.computeCompressedNFTHash =
      i.computeCreatorHash =
      i.computeDataHash =
      i.getLeafAssetId =
        void 0);
  const s = Nu,
    n = o3,
    c = qr,
    f = r(Ko());
  t(Nu, i);
  async function h(_, A) {
    const [E] = await c.PublicKey.findProgramAddress(
      [Ze.from('asset', 'utf8'), _.toBuffer(), Uint8Array.from(A.toArray('le', 8))],
      s.PROGRAM_ID
    );
    return E;
  }
  i.getLeafAssetId = h;
  function y(_) {
    const [A] = s.metadataArgsBeet.serialize(_),
      E = Ze.from(n.keccak_256.digest(A)),
      I = new f.default(_.sellerFeeBasisPoints).toBuffer('le', 2);
    return Ze.from(n.keccak_256.digest(Ze.concat([E, I])));
  }
  i.computeDataHash = y;
  function p(_) {
    let A = Ze.from([]);
    for (const E of _)
      A = Ze.concat([E.address.toBuffer(), Ze.from([E.verified ? 1 : 0]), Ze.from([E.share])]);
    return Ze.from(n.keccak_256.digest(A));
  }
  i.computeCreatorHash = p;
  function m(_, A, E, I, R) {
    const L = Ze.concat([
      Ze.from([1]),
      _.toBuffer(),
      A.toBuffer(),
      E.toBuffer(),
      I.toBuffer('le', 8),
      y(R),
      p(R.creators),
    ]);
    return Ze.from(n.keccak_256.digest(L));
  }
  i.computeCompressedNFTHash = m;
})(K4);
(function (i) {
  var e =
      (se && se.__createBinding) ||
      (Object.create
        ? function (r, s, n, c) {
            c === void 0 && (c = n);
            var f = Object.getOwnPropertyDescriptor(s, n);
            (!f || ('get' in f ? !s.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return s[n];
                },
              }),
              Object.defineProperty(r, c, f);
          }
        : function (r, s, n, c) {
            c === void 0 && (c = n), (r[c] = s[n]);
          }),
    t =
      (se && se.__exportStar) ||
      function (r, s) {
        for (var n in r)
          n !== 'default' && !Object.prototype.hasOwnProperty.call(s, n) && e(s, r, n);
      };
  Object.defineProperty(i, '__esModule', { value: !0 }), t(Nu, i), t(yh, i), t(K4, i);
})(vR);
export {
  Ua as $,
  Pe as A,
  Ze as B,
  Ge as C,
  Xr as D,
  Wl as E,
  ar as F,
  Se as G,
  Tr as H,
  oi as I,
  ri as J,
  Cu as K,
  I3 as L,
  PU as M,
  Ha as N,
  B3 as O,
  Or as P,
  Ey as Q,
  U3 as R,
  Ay as S,
  Ny as T,
  F3 as U,
  Jt as V,
  Cs as W,
  OU as X,
  N8 as Y,
  TU as Z,
  hy as _,
  ql as a,
  ai as a0,
  IE as a1,
  tc as a2,
  Ui as a3,
  At as a4,
  a5,
  Je as a6,
  S5 as a7,
  m5 as a8,
  tu as a9,
  x5 as aa,
  E5 as ab,
  Fp as ac,
  A5 as ad,
  _l as ae,
  K1 as af,
  vl as ag,
  $M as ah,
  ml as ai,
  H2 as aj,
  Y2 as ak,
  wl as al,
  H1 as am,
  WM as an,
  Sl as ao,
  Kl as ap,
  K6 as aq,
  EB as ar,
  o3 as as,
  $8 as at,
  C2 as au,
  Oy as av,
  Re as aw,
  z4 as ax,
  RU as ay,
  ut as b,
  zU as c,
  FU as d,
  M3 as e,
  A3 as f,
  ln as g,
  He as h,
  qe as i,
  Ir as j,
  zt as k,
  Kn as l,
  we as m,
  Nt as n,
  _i as o,
  Za as p,
  Ja as q,
  Ko as r,
  We as s,
  E3 as t,
  tt as u,
  ft as v,
  Wn as w,
  pe as x,
  ee as y,
  Te as z,
};
