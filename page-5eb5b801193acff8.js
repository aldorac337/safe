try {
  let e =
      'undefined' != typeof window
        ? window
        : 'undefined' != typeof global
          ? global
          : 'undefined' != typeof globalThis
            ? globalThis
            : 'undefined' != typeof self
              ? self
              : {},
    t = new e.Error().stack;
  t &&
    ((e._sentryDebugIds = e._sentryDebugIds || {}),
    (e._sentryDebugIds[t] = '6b11fb55-cef8-4be6-af16-044009e62186'),
    (e._sentryDebugIdIdentifier = 'sentry-dbid-6b11fb55-cef8-4be6-af16-044009e62186'));
} catch (e) {}
(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
  [1299, 4916],
  {
    24708: function (e, t, i) {
      Promise.resolve().then(i.bind(i, 1208)),
        Promise.resolve().then(i.bind(i, 46997)),
        Promise.resolve().then(i.bind(i, 3849)),
        Promise.resolve().then(i.bind(i, 60647)),
        Promise.resolve().then(i.bind(i, 93665)),
        Promise.resolve().then(i.bind(i, 391)),
        Promise.resolve().then(i.bind(i, 39507)),
        Promise.resolve().then(i.bind(i, 30344)),
        Promise.resolve().then(i.bind(i, 60846)),
        Promise.resolve().then(i.bind(i, 53683)),
        Promise.resolve().then(i.bind(i, 73673)),
        Promise.resolve().then(i.bind(i, 66976)),
        Promise.resolve().then(i.bind(i, 92275)),
        Promise.resolve().then(i.bind(i, 73635)),
        Promise.resolve().then(i.bind(i, 72803)),
        Promise.resolve().then(i.bind(i, 8052)),
        Promise.resolve().then(i.bind(i, 10111)),
        Promise.resolve().then(i.bind(i, 10747)),
        Promise.resolve().then(i.bind(i, 75688)),
        Promise.resolve().then(i.bind(i, 40405)),
        Promise.resolve().then(i.bind(i, 50544)),
        Promise.resolve().then(i.bind(i, 38071)),
        Promise.resolve().then(i.bind(i, 35038)),
        Promise.resolve().then(i.bind(i, 13180)),
        Promise.resolve().then(i.bind(i, 77843)),
        Promise.resolve().then(i.bind(i, 18530)),
        Promise.resolve().then(i.bind(i, 87982)),
        Promise.resolve().then(i.bind(i, 39177)),
        Promise.resolve().then(i.bind(i, 658)),
        Promise.resolve().then(i.bind(i, 96188)),
        Promise.resolve().then(i.bind(i, 86096)),
        Promise.resolve().then(i.bind(i, 15176)),
        Promise.resolve().then(i.bind(i, 68987)),
        Promise.resolve().then(i.bind(i, 89690)),
        Promise.resolve().then(i.bind(i, 77834)),
        Promise.resolve().then(i.bind(i, 9894)),
        Promise.resolve().then(i.bind(i, 45751)),
        Promise.resolve().then(i.bind(i, 39306)),
        Promise.resolve().then(i.bind(i, 4015)),
        Promise.resolve().then(i.bind(i, 3167)),
        Promise.resolve().then(i.bind(i, 89778)),
        Promise.resolve().then(i.bind(i, 11901)),
        Promise.resolve().then(i.bind(i, 52754)),
        Promise.resolve().then(i.bind(i, 94098)),
        Promise.resolve().then(i.bind(i, 84215)),
        Promise.resolve().then(i.bind(i, 91747)),
        Promise.resolve().then(i.bind(i, 77051)),
        Promise.resolve().then(i.bind(i, 94108)),
        Promise.resolve().then(i.bind(i, 57261)),
        Promise.resolve().then(i.bind(i, 71801)),
        Promise.resolve().then(i.bind(i, 61512)),
        Promise.resolve().then(i.bind(i, 20147)),
        Promise.resolve().then(i.bind(i, 70058)),
        Promise.resolve().then(i.bind(i, 92093)),
        Promise.resolve().then(i.bind(i, 75794)),
        Promise.resolve().then(i.bind(i, 39228)),
        Promise.resolve().then(i.bind(i, 84478)),
        Promise.resolve().then(i.bind(i, 43609)),
        Promise.resolve().then(i.bind(i, 49482)),
        Promise.resolve().then(i.t.bind(i, 23293, 23)),
        Promise.resolve().then(i.bind(i, 92529)),
        Promise.resolve().then(i.bind(i, 66911)),
        Promise.resolve().then(i.bind(i, 29015)),
        Promise.resolve().then(i.bind(i, 16164)),
        Promise.resolve().then(i.bind(i, 94282)),
        Promise.resolve().then(i.bind(i, 15642)),
        Promise.resolve().then(i.bind(i, 72355)),
        Promise.resolve().then(i.bind(i, 99e3)),
        Promise.resolve().then(i.bind(i, 16560)),
        Promise.resolve().then(i.bind(i, 18386)),
        Promise.resolve().then(i.bind(i, 13722)),
        Promise.resolve().then(i.bind(i, 65386)),
        Promise.resolve().then(i.bind(i, 7887)),
        Promise.resolve().then(i.bind(i, 58811)),
        Promise.resolve().then(i.bind(i, 81082)),
        Promise.resolve().then(i.bind(i, 38254)),
        Promise.resolve().then(i.bind(i, 16937)),
        Promise.resolve().then(i.bind(i, 84480)),
        Promise.resolve().then(i.bind(i, 1318)),
        Promise.resolve().then(i.bind(i, 18074)),
        Promise.resolve().then(i.bind(i, 3985)),
        Promise.resolve().then(i.bind(i, 63154)),
        Promise.resolve().then(i.bind(i, 70911)),
        Promise.resolve().then(i.bind(i, 24505)),
        Promise.resolve().then(i.bind(i, 95715)),
        Promise.resolve().then(i.bind(i, 55968)),
        Promise.resolve().then(i.bind(i, 82405)),
        Promise.resolve().then(i.bind(i, 67598)),
        Promise.resolve().then(i.bind(i, 32615)),
        Promise.resolve().then(i.bind(i, 92241)),
        Promise.resolve().then(i.bind(i, 95308)),
        Promise.resolve().then(i.bind(i, 33734)),
        Promise.resolve().then(i.bind(i, 54537)),
        Promise.resolve().then(i.bind(i, 40327)),
        Promise.resolve().then(i.bind(i, 23837)),
        Promise.resolve().then(i.bind(i, 50964)),
        Promise.resolve().then(i.bind(i, 14754)),
        Promise.resolve().then(i.bind(i, 45445)),
        Promise.resolve().then(i.bind(i, 76269)),
        Promise.resolve().then(i.bind(i, 89013)),
        Promise.resolve().then(i.bind(i, 12518)),
        Promise.resolve().then(i.bind(i, 74332)),
        Promise.resolve().then(i.bind(i, 39613)),
        Promise.resolve().then(i.bind(i, 68889)),
        Promise.resolve().then(i.bind(i, 84408)),
        Promise.resolve().then(i.bind(i, 62726)),
        Promise.resolve().then(i.bind(i, 22490)),
        Promise.resolve().then(i.bind(i, 7401)),
        Promise.resolve().then(i.bind(i, 17293)),
        Promise.resolve().then(i.bind(i, 79686)),
        Promise.resolve().then(i.bind(i, 9541)),
        Promise.resolve().then(i.bind(i, 42292)),
        Promise.resolve().then(i.bind(i, 36511)),
        Promise.resolve().then(i.bind(i, 31678)),
        Promise.resolve().then(i.bind(i, 53618)),
        Promise.resolve().then(i.bind(i, 10758)),
        Promise.resolve().then(i.bind(i, 47312)),
        Promise.resolve().then(i.bind(i, 59761)),
        Promise.resolve().then(i.bind(i, 98642)),
        Promise.resolve().then(i.bind(i, 16282)),
        Promise.resolve().then(i.bind(i, 86538)),
        Promise.resolve().then(i.bind(i, 36468)),
        Promise.resolve().then(i.bind(i, 68083)),
        Promise.resolve().then(i.bind(i, 59002)),
        Promise.resolve().then(i.bind(i, 9009)),
        Promise.resolve().then(i.bind(i, 30726)),
        Promise.resolve().then(i.bind(i, 95955)),
        Promise.resolve().then(i.bind(i, 59586)),
        Promise.resolve().then(i.bind(i, 68843)),
        Promise.resolve().then(i.bind(i, 1017)),
        Promise.resolve().then(i.bind(i, 87859)),
        Promise.resolve().then(i.bind(i, 61837)),
        Promise.resolve().then(i.bind(i, 71338)),
        Promise.resolve().then(i.bind(i, 38662)),
        Promise.resolve().then(i.bind(i, 87251)),
        Promise.resolve().then(i.bind(i, 84125)),
        Promise.resolve().then(i.bind(i, 16903)),
        Promise.resolve().then(i.bind(i, 40408)),
        Promise.resolve().then(i.bind(i, 10827)),
        Promise.resolve().then(i.bind(i, 48634)),
        Promise.resolve().then(i.bind(i, 95919)),
        Promise.resolve().then(i.bind(i, 15862)),
        Promise.resolve().then(i.bind(i, 14978)),
        Promise.resolve().then(i.bind(i, 62763)),
        Promise.resolve().then(i.bind(i, 71324)),
        Promise.resolve().then(i.bind(i, 66436)),
        Promise.resolve().then(i.bind(i, 53777)),
        Promise.resolve().then(i.bind(i, 17395)),
        Promise.resolve().then(i.bind(i, 67414)),
        Promise.resolve().then(i.bind(i, 17722)),
        Promise.resolve().then(i.bind(i, 19991)),
        Promise.resolve().then(i.bind(i, 80841)),
        Promise.resolve().then(i.bind(i, 31369)),
        Promise.resolve().then(i.bind(i, 45667)),
        Promise.resolve().then(i.bind(i, 60706)),
        Promise.resolve().then(i.bind(i, 71463)),
        Promise.resolve().then(i.bind(i, 24537)),
        Promise.resolve().then(i.bind(i, 40673)),
        Promise.resolve().then(i.bind(i, 40756)),
        Promise.resolve().then(i.bind(i, 36866)),
        Promise.resolve().then(i.bind(i, 2383)),
        Promise.resolve().then(i.bind(i, 63122)),
        Promise.resolve().then(i.bind(i, 47810)),
        Promise.resolve().then(i.bind(i, 14223)),
        Promise.resolve().then(i.bind(i, 43228)),
        Promise.resolve().then(i.bind(i, 35510)),
        Promise.resolve().then(i.bind(i, 24637)),
        Promise.resolve().then(i.bind(i, 7900)),
        Promise.resolve().then(i.bind(i, 42898)),
        Promise.resolve().then(i.bind(i, 78336)),
        Promise.resolve().then(i.bind(i, 15722)),
        Promise.resolve().then(i.bind(i, 70357)),
        Promise.resolve().then(i.bind(i, 99314)),
        Promise.resolve().then(i.bind(i, 72033)),
        Promise.resolve().then(i.bind(i, 30105)),
        Promise.resolve().then(i.bind(i, 91708)),
        Promise.resolve().then(i.bind(i, 84365)),
        Promise.resolve().then(i.bind(i, 66279)),
        Promise.resolve().then(i.bind(i, 67721)),
        Promise.resolve().then(i.bind(i, 19333)),
        Promise.resolve().then(i.bind(i, 43328)),
        Promise.resolve().then(i.bind(i, 52048)),
        Promise.resolve().then(i.bind(i, 23570)),
        Promise.resolve().then(i.bind(i, 18001)),
        Promise.resolve().then(i.bind(i, 63586)),
        Promise.resolve().then(i.bind(i, 35891)),
        Promise.resolve().then(i.bind(i, 5901)),
        Promise.resolve().then(i.bind(i, 56291)),
        Promise.resolve().then(i.bind(i, 68676)),
        Promise.resolve().then(i.bind(i, 51631)),
        Promise.resolve().then(i.bind(i, 37968)),
        Promise.resolve().then(i.bind(i, 98042)),
        Promise.resolve().then(i.bind(i, 34882)),
        Promise.resolve().then(i.bind(i, 45184)),
        Promise.resolve().then(i.bind(i, 30262)),
        Promise.resolve().then(i.bind(i, 78519)),
        Promise.resolve().then(i.bind(i, 71320)),
        Promise.resolve().then(i.bind(i, 46050)),
        Promise.resolve().then(i.bind(i, 87861)),
        Promise.resolve().then(i.bind(i, 64738)),
        Promise.resolve().then(i.bind(i, 58961)),
        Promise.resolve().then(i.bind(i, 87326)),
        Promise.resolve().then(i.bind(i, 6662)),
        Promise.resolve().then(i.bind(i, 29887)),
        Promise.resolve().then(i.bind(i, 56689)),
        Promise.resolve().then(i.bind(i, 4222)),
        Promise.resolve().then(i.bind(i, 40388)),
        Promise.resolve().then(i.bind(i, 70591)),
        Promise.resolve().then(i.bind(i, 41136)),
        Promise.resolve().then(i.bind(i, 28638)),
        Promise.resolve().then(i.bind(i, 56702)),
        Promise.resolve().then(i.bind(i, 94337)),
        Promise.resolve().then(i.bind(i, 16690)),
        Promise.resolve().then(i.bind(i, 93141));
    },
    94646: function (e, t, i) {
      'use strict';
      i.d(t, {
        Z: function () {
          return R;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(26897),
        o = i(40252),
        l = i(25834),
        s = i(12556),
        d = i(54655),
        u = i(69886),
        c = i(51712),
        h = i(70064),
        v = i(22683),
        p = i(82803),
        m = i(96278),
        g = i(79524),
        y = i(57054),
        b = i(75147),
        f = i(89991);
      let Z = new Map(),
        x = { riskReason: null, risk: 'Low', isAuthorized: !0 },
        w = async (e, t) => {
          if (Z.has(e)) return Z.get(e);
          try {
            let i = await fetch('https://blue-services.morpho.dev/screen?address=' + e, t);
            if (!i.ok) throw Error('Failed to screen address');
            return Z.set(e, await i.json()), Z.get(e);
          } catch (e) {
            return x;
          }
        },
        k = function (e) {
          let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
            [i, r] = (0, n.useState)(!1),
            { value: a } = (0, s.ib)(
              async (i) => {
                if (e && !t) {
                  r(!0);
                  let t = await w(e, { signal: i.signal });
                  return r(!1), t;
                }
              },
              [e, t]
            );
          return { loading: i, value: a };
        };
      var B = i(4205),
        A = i(82078);
      let P = (0, i(38819).Z)(d.Kqy, { target: 'ewutvgm0' })(
        'padding:8px;background-color:',
        (e) => {
          let { theme: t } = e;
          return t.colors.background.primary;
        },
        ';border-radius:12px;'
      );
      var C = i(4340);
      let T = () => {
        let [e, t] = (0, n.useState)(!1),
          [i, r] = (0, n.useState)(!1),
          [a, o] = (0, n.useState)(!1);
        return {
          hasRiskyPositions: e,
          markPositionsAsRisky: (0, n.useCallback)(() => {
            t(!0);
          }, [t]),
          isRiskyPositionsAcknowledged: i,
          setIsRiskyPositionsAcknowledged: r,
          hasLiquidatablePositions: a,
          markPositionsAsLiquidatable: (0, n.useCallback)(() => {
            o(!0);
          }, [o]),
        };
      };
      var S = i(35047);
      let X = (e, t) => {
        let { account: i, targetChainId: r } = (0, f.Z_)();
        return (0, n.useMemo)(() => {
          let n = null == i ? void 0 : i.address;
          return n && e && t
            ? (0, S.values)(t.tokens)
                .filter((e) => e instanceof o.WrappedToken)
                .map((i) => {
                  if (
                    !e.getHolding(o.addressesRegistry[r].bundler3.generalAdapter1, i.address)
                      .canTransfer
                  )
                    return;
                  let a = e.getBundleBalance(n, i.address),
                    l = t.getBundleBalance(n, i.address);
                  if (null == l || null == a) return;
                  let s = l - a;
                  if (!(s <= 10)) return { token: i, unwrappableAmount: s };
                })
                .filter(S.isDefined)
            : [];
        }, [i.address, e, t, r]);
      };
      var R = (0, n.memo)((e) => {
        var t;
        let { operations: i, headerActionSlot: Z, onConfirm: x } = e,
          { toggleDialog: w } = (0, d.DAv)(),
          { toggleRightPanel: S } = (0, d.s8G)(),
          { data: R } = (0, B.f)(0),
          { account: D } = (0, f.Z_)(),
          { bundlerConfiguration: M } = (0, v.N)(),
          [q] = (0, y.b)(R, i, M),
          F = (0, m.B)(),
          { activeBundle: K, setActiveBundle: E } = (0, b.H)(),
          [I, V] = (0, n.useState)(),
          [L, , , O] = (0, s.$X)(),
          N = X(R, (0, a.Z)(q)),
          {
            hasRiskyPositions: U,
            isRiskyPositionsAcknowledged: $,
            setIsRiskyPositionsAcknowledged: z,
            markPositionsAsRisky: _,
            hasLiquidatablePositions: W,
            markPositionsAsLiquidatable: H,
          } = T(),
          G = (0, n.useCallback)(() => {
            if (x) {
              x();
              return;
            }
            if (R && (null == D ? void 0 : D.address))
              try {
                let e = (0, g.b)(i, R, D.address, F, D.isContract),
                  t = (0, l.finalizeBundle)(
                    e.operations,
                    R,
                    D.address,
                    L,
                    o.DEFAULT_SLIPPAGE_TOLERANCE
                  ),
                  n = (0, l.encodeBundle)(t, R, !D.isContract);
                E(n, i), S(!1), w((0, r.tZ)(A.Z, {}), { closable: !1 });
              } catch (e) {
                V(e);
              }
          }, [D.address, D.isContract, R, i, F, L, x, E, w, S]),
          { value: j, loading: Q } = k(null == D ? void 0 : D.address),
          Y = (0, n.useMemo)(
            () =>
              i.some(
                (e) =>
                  e.type === p.H.InterfaceOperationType.metaMorphoDeposit ||
                  e.type === p.H.InterfaceOperationType.metaMorphoWithdraw
              ),
            [i]
          ),
          J = (0, n.useMemo)(
            () =>
              K
                ? 'Please complete the pending transaction to execute a new one.'
                : W
                  ? 'You must lower your LTV below the Liquidation LTV to take this action.'
                  : U && !$
                    ? 'Please process liquidation warning.'
                    : D.isWrongChain
                      ? 'Please switch to the correct network.'
                      : (null == j ? void 0 : j.isAuthorized)
                        ? null
                        : 'User is not allowed to perform this action.',
            [W, U, $, D.isWrongChain, null == j ? void 0 : j.isAuthorized, K]
          ),
          ee =
            !!K || W || (U && !$) || D.isWrongChain || !(null == j ? void 0 : j.isAuthorized) || Q;
        return (0, r.BX)(d.Kqy, {
          direction: 'column',
          gap: 20,
          'data-testid': 'confirm-dialog',
          children: [
            (0, r.BX)(d.Kqy, {
              align: 'center',
              justify: 'space-between',
              gap: 16,
              children: [
                (0, r.tZ)(d.xvT.Title.S, { children: 'Review' }),
                (0, r.BX)(d.Kqy, {
                  direction: 'row',
                  gap: 's',
                  align: 'center',
                  children: [
                    Z,
                    (0, r.tZ)(d.zxk, {
                      iconAlone: 'ClosePlain20',
                      onClick: () => w(!1),
                      variant: 'secondary',
                    }),
                  ],
                }),
              ],
            }),
            (0, r.BX)(h.Z, {
              fallback: (0, r.tZ)(c.c, { minHeight: '494px' }),
              children: [
                (0, r.BX)(d.Kqy, {
                  direction: 'column',
                  gap: 'xs',
                  children: [
                    (0, r.tZ)(C.Z, {
                      operations: i,
                      initialState: null == q ? void 0 : q[0],
                      finalState: (0, a.Z)(q),
                      mode: 'Review',
                      markPositionsAsRisky: _,
                      markPositionsAsLiquidatable: H,
                    }),
                    N.length > 0 &&
                      (0, r.tZ)(d.Kqy, {
                        wrap: 'wrap',
                        gap: 'xs',
                        align: 'center',
                        children: N.map((e) => {
                          var t;
                          let { token: i } = e;
                          return (0, r.BX)(
                            P,
                            {
                              gap: 4,
                              align: 'center',
                              children: [
                                (0, r.tZ)(d.rsf, {
                                  active: L.has(i.address),
                                  onClick: O.bind(null, i.address),
                                  'data-testid': 'unwrap-token-switch-'.concat(i.symbol),
                                }),
                                (0, r.tZ)(d.xvT.Body.XXXS.Regular, {
                                  color: 'text.body',
                                  children: 'Unwrap '.concat(
                                    null !== (t = i.symbol) && void 0 !== t
                                      ? t
                                      : (0, d.GQT)(i.address)
                                  ),
                                }),
                              ],
                            },
                            i.address
                          );
                        }),
                      }),
                  ],
                }),
                !W &&
                  U &&
                  (0, r.tZ)(u.Z, {
                    isRiskyPositionsAcknowledged: $,
                    setIsRiskyPositionsAcknowledged: z,
                  }),
                Q
                  ? (0, r.tZ)(d.OdW, { height: 35, borderRadius: '12px' })
                  : (null == j ? void 0 : j.isAuthorized)
                    ? Y
                      ? (0, r.BX)(d.xvT.Body.XXXS.Regular, {
                          color: 'text.secondary',
                          children: [
                            'By confirming this transaction, you agree to the',
                            ' ',
                            (0, r.tZ)(d.dLw, {
                              href: s.CL,
                              underlined: !0,
                              children: 'Terms of Use',
                            }),
                            ' ',
                            'and the services provisions relating to the Morpho Vault.',
                          ],
                        })
                      : null
                    : (0, r.BX)(d.xvT.Body.XXXS.Regular, {
                        color: 'text.interactive.error',
                        children: [
                          'User is not allowed to perform this action:',
                          ' ',
                          null !== (t = null == j ? void 0 : j.riskReason) && void 0 !== t
                            ? t
                            : 'unknown reason',
                          '.',
                          ' ',
                          (0, r.tZ)(d.dLw, {
                            href: 'https://www.chainalysis.com/',
                            underlined: !0,
                            children: 'Learn more ->',
                          }),
                        ],
                      }),
                (0, r.tZ)(d.ua7, {
                  content: J,
                  disabled: !J,
                  children: (0, r.tZ)(d.Kqy, {
                    width: '100%',
                    direction: 'column',
                    children: (0, r.tZ)(d._Lo, {
                      onClick: G,
                      height: 47,
                      disabled: ee,
                      textVariant: 'small',
                      children: 'Confirm',
                    }),
                  }),
                }),
                I &&
                  (0, r.tZ)(d.xvT.Label.S, {
                    color: 'text.interactive.error',
                    children: I.message,
                  }),
              ],
            }),
          ],
        });
      });
    },
    27410: function (e, t, i) {
      'use strict';
      var r = i(78286),
        n = i(58258),
        a = i(54655);
      t.Z = (0, n.memo)((e) => {
        let { label: t, type: i, currentType: n, onClick: o } = e;
        return (0, r.tZ)(a.zxk, {
          variant: n === i ? 'secondary' : 'ghost',
          onClick: o,
          label: t,
          style: { flexGrow: 1 },
        });
      });
    },
    30344: function (e, t, i) {
      'use strict';
      i.d(t, {
        default: function () {
          return X;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(55385),
        o = i(60626),
        l = i(54655),
        s = i(51712),
        d = i(6893),
        u = i(43779),
        c = i(33210),
        h = i(89991),
        v = i(90836),
        p = i(7518);
      let m = (0, i(38819).Z)(l.xrM, { target: 'e1dq9kh90' })(
        'width:100%;height:100%;border-radius:',
        (e) => {
          let { theme: t } = e;
          return t.borderRadius;
        },
        ';display:grid;'
      );
      var g = i(39507),
        y = i(83669),
        b = i(68866),
        f = i(55412),
        Z = i(3245),
        x = i(24387);
      function w() {
        let e = (0, f._)([
          '\n  query GetVaultDistribution(\n    $where: VaultPositionFilters\n    $orderBy: VaultPositionOrderBy\n    $orderDirection: OrderDirection\n    $first: Int\n    $skip: Int\n  ) {\n    vaultPositions(\n      where: $where\n      orderBy: $orderBy\n      orderDirection: $orderDirection\n      first: $first\n      skip: $skip\n    ) {\n      items {\n        id\n        shares\n        assets\n        assetsUsd\n        vault {\n          id\n          address\n          symbol\n          name\n          creationBlockNumber\n          asset {\n            ...simpleAssetFields\n          }\n          state {\n            id\n            totalSupply\n          }\n          chain {\n            id\n          }\n        }\n        user {\n          id\n          address\n          tag\n          chain {\n            id\n          }\n        }\n      }\n      pageInfo {\n        countTotal\n        count\n        limit\n        skip\n      }\n    }\n  }\n  ',
          '\n',
        ]);
        return (
          (w = function () {
            return e;
          }),
          e
        );
      }
      let k = (0, Z.Ps)(w(), x.G);
      var B = (e) => {
          var t, i;
          let { queryVariables: r, queryResult: a, first: o, skip: l } = e,
            s = { ...r, first: o, skip: l },
            {
              data: d,
              loading: u,
              error: c,
            } = (0, y.s)({
              queryDocument: k,
              queryVariables: s,
              serverQueryVariables: r,
              serverQueryResult: a,
            }),
            { totalItemsCount: h, pageCount: v } = (0, b.Z)({
              pageInfo:
                null == d
                  ? void 0
                  : null === (t = d.vaultPositions) || void 0 === t
                    ? void 0
                    : t.pageInfo,
              first: o,
              error: c,
            });
          return (0, n.useMemo)(() => {
            var e;
            return {
              data:
                null == d
                  ? void 0
                  : null === (e = d.vaultPositions) || void 0 === e
                    ? void 0
                    : e.items,
              loading: u,
              error: c,
              totalCount: h,
              pageCount: v,
            };
          }, [
            null == d ? void 0 : null === (i = d.vaultPositions) || void 0 === i ? void 0 : i.items,
            u,
            c,
            h,
            v,
          ]);
        },
        A = i(40252),
        P = i(12556),
        C = i(8937),
        T = i(85718),
        S = (e) => {
          let { items: t, chainId: i, currentPage: r } = e,
            { paginatedOffset: a, initOffset: o, setNextOffset: l } = (0, T.T)(0n);
          return (0, n.useMemo)(
            () =>
              t
                ? (o(r),
                  t.map((e) => {
                    var t, n, o;
                    let s = (0, P.wk)(e.vault.asset),
                      d = (0, C.R)(
                        null !==
                          (n =
                            null === (t = e.vault.state) || void 0 === t
                              ? void 0
                              : t.totalSupply) && void 0 !== n
                          ? n
                          : 0n,
                        e.shares
                      ),
                      u = a.current;
                    return (
                      l(d, r),
                      {
                        ...e,
                        urlUser: A.ChainUtils.getExplorerAddressUrl(i, e.user.address),
                        sharePercentage: { value: d, percentageOffset: u },
                        amountValue: null !== (o = s.toUsd(e.assets)) && void 0 !== o ? o : null,
                      }
                    );
                  }))
                : [],
            [t, i, r, a, o, l]
          );
        },
        X = (0, n.memo)(
          (0, c.Z)((e) => {
            let { queryResult: t, queryVariables: i } = e,
              { targetChainId: c } = (0, h.Z_)(),
              {
                first: y,
                skip: b,
                pagination: f,
                onPaginationChange: Z,
              } = (0, v.h)({ defaultPageSize: 5 }),
              {
                data: x,
                loading: w,
                totalCount: k,
                error: A,
              } = B({ queryResult: t, queryVariables: i, first: y, skip: b }),
              P = S({ items: x, chainId: c, currentPage: f.pageIndex }),
              C = (0, a.b7)({
                data: P,
                getCoreRowModel: (0, o.sC)(),
                state: { pagination: f },
                manualSorting: !1,
                manualPagination: !0,
                pageCount: null != k ? k : void 0,
                columns: g.vaultDistributionColumnsDefs,
                enableSortingRemoval: !1,
                sortDescFirst: !1,
                onPaginationChange: Z,
              }),
              T = (0, n.useMemo)(() => 0 === C.getRowModel().rows.length, [C]),
              X = (0, p.I)({
                first: y,
                totalCount: k,
                pagination: f,
                columnsDefs: g.vaultDistributionColumnsDefs,
              });
            return (0, r.BX)(l.Kqy, {
              direction: 'column',
              gap: 's',
              children: [
                (0, r.tZ)(d.$, { children: 'User Distribution' }),
                (0, r.BX)(l.Kqy, {
                  direction: 'column',
                  gap: 'xs',
                  children: [
                    (0, r.BX)(m, {
                      children: [
                        !T &&
                          (0, r.BX)(u.iA.iA, {
                            tableVariant: 'compact',
                            children: [
                              (0, r.tZ)(u.iA.hr, {
                                children: C.getHeaderGroups().map((e) =>
                                  (0, r.tZ)(u.uq, { headerGroup: e }, e.id)
                                ),
                              }),
                              (0, r.BX)(u.iA.p3, {
                                children: [
                                  !w &&
                                    C.getRowModel().rows.map((e) =>
                                      (0, r.tZ)(u.yL, { row: e }, e.id)
                                    ),
                                  w &&
                                    X.map((e, t) =>
                                      (0, r.tZ)(
                                        u.yL,
                                        { skeletonRow: e },
                                        t + 'skeleton-table-distribution'
                                      )
                                    ),
                                ],
                              }),
                            ],
                          }),
                        T &&
                          (0, r.tZ)(l.WaR, {
                            text: 'No depositor found.',
                            height: '640px',
                            cardTextProps: { style: { borderRadius: '0' } },
                          }),
                        !w &&
                          A &&
                          (0, r.tZ)(s.Z, { minHeight: '340px', style: { borderRadius: '0' } }),
                      ],
                    }),
                    (0, r.tZ)(l.tlE, {
                      loading: w,
                      error: A,
                      pagination: f,
                      totalItemsCount: k,
                      previousPage: C.previousPage,
                      nextPage: C.nextPage,
                      setPage: C.setPageIndex,
                      canPreviousPage: C.getCanPreviousPage(),
                      canNextPage: C.getCanNextPage(),
                    }),
                  ],
                }),
              ],
            });
          })
        );
    },
    39507: function (e, t, i) {
      'use strict';
      i.r(t),
        i.d(t, {
          vaultDistributionColumnsDefs: function () {
            return l;
          },
        });
      var r = i(78286),
        n = i(12556),
        a = i(54655),
        o = i(50825);
      let l = [
        {
          accessorKey: 'user.address',
          header: () =>
            (0, r.tZ)(a.ua7, {
              content: 'Address of user holding the position.',
              children: (0, r.tZ)(a.xvT.Body.XXXS.Regular, {
                color: 'text.secondary',
                marginLeft: '7px',
                children: 'User',
              }),
            }),
          cell: (e) => {
            let { row: t } = e;
            return (0, r.tZ)(o.Z, {
              href: t.original.urlUser,
              mode: 'external',
              buttonProps: {
                variant: 'ghost',
                size: 'default',
                label: (0, a.GQT)(t.original.user.address),
                avatarProps: { address: t.original.user.address },
              },
            });
          },
          enableSorting: !1,
          skeletonCell: (0, r.tZ)(a.OdW, { width: '144px', height: '32px' }),
        },
        {
          accessorKey: 'vault.asset',
          header: () =>
            (0, r.tZ)(a.ua7, {
              content: 'Amount of loan tokens supplied to the vault.',
              children: (0, r.tZ)(a.xvT.Body.XXXS.Regular, {
                color: 'text.secondary',
                children: 'Deposit',
              }),
            }),
          cell: (e) => {
            let { row: t } = e;
            return (0, r.tZ)(a.kOf, {
              token: (0, n.wk)(t.original.vault.asset),
              amount: t.original.assets,
              value: t.original.amountValue,
              withAvatar: !0,
            });
          },
          enableSorting: !1,
          skeletonCell: (0, r.tZ)(a.OdW, { width: '195px', height: '22px' }),
        },
        {
          accessorKey: 'sharePercentage',
          header: () =>
            (0, r.tZ)(a.ua7, {
              content: 'Total portion that this position represents within the vault.',
              children: (0, r.tZ)(a.xvT.Body.XXXS.Regular, {
                color: 'text.secondary',
                children: '% of Deposits',
              }),
            }),
          cell: (e) => {
            let { row: t } = e;
            return (0, r.tZ)(a.lR8, {
              allocation: t.original.sharePercentage.value,
              percentageOffset: t.original.sharePercentage.percentageOffset,
              index: t.index,
              TextVariant: a.xvT.Body.XXS.Regular,
            });
          },
          skeletonCell: (0, r.tZ)(a.OdW, { width: '68px', height: '22px' }),
          enableSorting: !1,
        },
      ];
    },
    66976: function (e, t, i) {
      'use strict';
      i.d(t, {
        default: function () {
          return E;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(90092),
        o = i(55385),
        l = i(60626),
        s = i(13191),
        d = i(54655),
        u = i(35047),
        c = i(51712),
        h = i(43779),
        v = i(33210),
        p = i(89991),
        m = i(56889),
        g = i(55135),
        y = i(90836),
        b = i(7518),
        f = i(37095),
        Z = i(58784),
        x = i(15341),
        w = i(53683),
        k = i(48833);
      let B = (e) => {
        let { selectedTypes: t, onFilterChange: i, disabled: a = !1 } = e,
          o = (0, n.useCallback)(
            (e) => {
              i((0, x.Z)(t, [e]));
            },
            [t, i]
          ),
          l = (0, n.useMemo)(
            () =>
              k.DU.map((e) => ({
                id: e.value,
                label: e.label,
                value: e.value,
                isChecked: t.includes(e.value),
              })),
            [t]
          );
        return (0, r.tZ)(d.h4n, {
          items: l,
          toggleItem: o,
          clear: () => i([]),
          inputPlaceholder: 'Search for transaction type',
          clearTooltipText: 'Remove transaction type filter.',
          disabled: a,
        });
      };
      var A = i(83669),
        P = i(68866),
        C = i(55412),
        T = i(3245),
        S = i(24387);
      function X() {
        let e = (0, C._)([
          '\n  query GetTransactions(\n    $first: Int\n    $skip: Int\n    $orderBy: TransactionsOrderBy\n    $orderDirection: OrderDirection\n    $where: TransactionFilters\n  ) {\n    transactions(\n      first: $first\n      skip: $skip\n      orderBy: $orderBy\n      where: $where\n      orderDirection: $orderDirection\n    ) {\n      items {\n        id\n        timestamp\n        hash\n        type\n        data {\n          ... on VaultTransactionData {\n            __typename\n            assets\n            assetsUsd\n            vault {\n              id\n              asset {\n                ...simpleAssetFields\n              }\n            }\n          }\n        }\n        user {\n          id\n          address\n        }\n      }\n      pageInfo {\n        countTotal\n        count\n        skip\n        limit\n      }\n    }\n  }\n  ',
          '\n',
        ]);
        return (
          (X = function () {
            return e;
          }),
          e
        );
      }
      let R = (0, T.Ps)(X(), S.G);
      var D = (e) => {
          var t, i, r;
          let {
              queryVariables: a,
              queryResult: o,
              first: l,
              skip: d,
              sorting: { orderBy: u, desc: c },
              filteredTransactionTypes: h,
            } = e,
            v = { ...(null == a ? void 0 : a.where) };
          h.length > 0
            ? (v.type_in = h)
            : (null == a ? void 0 : null === (t = a.where) || void 0 === t ? void 0 : t.type_in) &&
              a.where.type_in.length > 0 &&
              (v.type_in = void 0);
          let p = {
              ...a,
              orderDirection: c ? s.OrderDirection.Desc : s.OrderDirection.Asc,
              orderBy: u,
              first: l,
              skip: d,
              where: v,
            },
            {
              data: m,
              loading: g,
              error: y,
            } = (0, A.s)({
              queryDocument: R,
              queryVariables: p,
              serverQueryVariables: a,
              serverQueryResult: o,
            }),
            { totalItemsCount: b, pageCount: f } = (0, P.Z)({
              pageInfo:
                null == m
                  ? void 0
                  : null === (i = m.transactions) || void 0 === i
                    ? void 0
                    : i.pageInfo,
              first: l,
              error: y,
            });
          return (0, n.useMemo)(() => {
            var e;
            return {
              data:
                null == m
                  ? void 0
                  : null === (e = m.transactions) || void 0 === e
                    ? void 0
                    : e.items,
              loading: g,
              totalCount: b,
              pageCount: f,
              error: y,
            };
          }, [
            null == m ? void 0 : null === (r = m.transactions) || void 0 === r ? void 0 : r.items,
            g,
            b,
            f,
            y,
          ]);
        },
        M = i(40252),
        q = i(75571),
        F = (e) => {
          let { transactions: t, chainId: i } = e;
          return (0, n.useMemo)(
            () =>
              t
                ? t
                    .filter((e) => 'VaultTransactionData' === e.data.__typename)
                    .map((e) => ({
                      ...e,
                      urlUser: M.ChainUtils.getExplorerAddressUrl(i, e.user.address),
                      urlHash: M.ChainUtils.getExplorerTransactionUrl(i, e.hash),
                      typeText: (0, q.$L)(e.type),
                      data: e.data,
                    }))
                : [],
            [t, i]
          );
        };
      let K = (e) => {
        let { orderBy: t, desc: i } = (0, n.useMemo)(() => {
          var t;
          let i = e[0];
          return i
            ? {
                orderBy:
                  null !== (t = k.CM[i.id]) && void 0 !== t ? t : s.TransactionsOrderBy.Timestamp,
                desc: i.desc,
              }
            : { orderBy: s.TransactionsOrderBy.Timestamp, desc: !0 };
        }, [e]);
        return { orderBy: t, desc: i };
      };
      var E = (0, n.memo)(
        (0, v.Z)((e) => {
          let { queryResult: t, queryVariables: i } = e,
            [v, x] = (0, a.XI)(k.Rk),
            { targetChainId: A } = (0, p.Z_)(),
            {
              first: P,
              skip: C,
              pagination: T,
              onPaginationChange: S,
              reset: X,
            } = (0, y.h)({ defaultPageSize: k.IV }),
            {
              sorting: R,
              setSorting: M,
              columnVisibility: q,
              setColumnVisibility: E,
            } = (0, m.Z)({
              pageKey: g.CT.Vault,
              tableSettingsObjectKey: k.aL,
              defaultTableSettings: k.wF,
            }),
            { orderBy: I, desc: V } = K(R),
            {
              data: L,
              loading: O,
              totalCount: N,
              error: U,
            } = D({
              queryResult: t,
              queryVariables: i,
              first: P,
              skip: C,
              filteredTransactionTypes: v.transactionTypeFilter
                .map((e) => s.TransactionType[e])
                .filter(u.isDefined),
              sorting: { orderBy: I, desc: V },
            }),
            $ = (0, d.ajf)('m'),
            z = F({ transactions: L, chainId: A }),
            _ = (0, n.useCallback)(
              (e) => {
                (0, n.startTransition)(() => {
                  X(), x({ transactionTypeFilter: e });
                });
              },
              [X, x]
            ),
            W = (0, o.b7)({
              data: z,
              getCoreRowModel: (0, l.sC)(),
              onSortingChange: M,
              getFilteredRowModel: (0, l.vL)(),
              state: { pagination: T, columnVisibility: q, sorting: R },
              manualSorting: !0,
              manualPagination: !0,
              pageCount: null != N ? N : void 0,
              columns: w.columnsDefs,
              enableSortingRemoval: !1,
              sortDescFirst: !1,
              onPaginationChange: S,
              onColumnVisibilityChange: E,
            }),
            H = 0 === W.getRowModel().rows.length,
            G = (0, b.I)({ first: P, totalCount: N, pagination: T, columnsDefs: w.columnsDefs }),
            j = (0, n.useMemo)(
              () =>
                W.getAllLeafColumns()
                  .map((e, t) => {
                    let i = w.COLUMN_LABELS[e.id];
                    return (0, u.isDefined)(i)
                      ? {
                          label: i,
                          value: e.id,
                          isActive: !(0, u.isDefined)(q[e.id]) || q[e.id],
                          isDisabled: 0 === t,
                          action: () => {
                            e.toggleVisibility();
                          },
                        }
                      : null;
                  })
                  .filter(u.isDefined),
              [W, q]
            );
          return (0, r.tZ)(Z.Z, {
            tableSettingsSlot: (0, r.BX)(f.qs, {
              children: [
                $
                  ? (0, r.BX)(d.Kqy, {
                      direction: 'row',
                      gap: 'xs',
                      align: 'center',
                      children: [
                        (0, r.tZ)(d.xvT.Body.XXXS.Regular, {
                          color: 'text.body',
                          children: 'Type:',
                        }),
                        (0, r.tZ)(B, { selectedTypes: v.transactionTypeFilter, onFilterChange: _ }),
                      ],
                    })
                  : (0, r.tZ)(B, { selectedTypes: v.transactionTypeFilter, onFilterChange: _ }),
                (0, r.tZ)(f.FF, { children: (0, r.tZ)(d.RKO, { options: j }) }),
              ],
            }),
            children: (0, r.tZ)(d.Kqy, {
              fullHeight: !0,
              fullWidth: !0,
              direction: 'column',
              gap: 'm',
              children: (0, r.BX)(d.Kqy, {
                direction: 'column',
                gap: 'xs',
                children: [
                  (0, r.BX)(f.A_, {
                    children: [
                      (!H || O) &&
                        (0, r.BX)(h.iA.iA, {
                          tableVariant: 'compact',
                          children: [
                            (0, r.tZ)(h.iA.hr, {
                              children: W.getHeaderGroups().map((e) =>
                                (0, r.tZ)(h.uq, { headerGroup: e }, e.id)
                              ),
                            }),
                            (0, r.BX)(h.iA.p3, {
                              children: [
                                !O &&
                                  W.getRowModel().rows.map((e) =>
                                    (0, r.tZ)(
                                      h.yL,
                                      { row: e },
                                      ''.concat(e.id, '-').concat(e.original.type)
                                    )
                                  ),
                                O &&
                                  G.map((e, t) =>
                                    (0, r.tZ)(h.yL, { skeletonRow: e }, 'skeleton-'.concat(t))
                                  ),
                              ],
                            }),
                          ],
                        }),
                      H &&
                        !U &&
                        !O &&
                        (0, r.tZ)(d.WaR, {
                          text: 'No transactions found.',
                          height: '640px',
                          cardTextProps: { style: { borderRadius: '0' } },
                        }),
                      !O &&
                        U &&
                        (0, r.tZ)(c.Z, { minHeight: '340px', style: { borderRadius: '0' } }),
                    ],
                  }),
                  (0, r.tZ)(d.tlE, {
                    loading: O,
                    error: U,
                    pagination: T,
                    totalItemsCount: N,
                    previousPage: W.previousPage,
                    nextPage: W.nextPage,
                    setPage: W.setPageIndex,
                    canPreviousPage: W.getCanPreviousPage(),
                    canNextPage: W.getCanNextPage(),
                  }),
                ],
              }),
            }),
          });
        })
      );
    },
    53683: function (e, t, i) {
      'use strict';
      i.r(t),
        i.d(t, {
          COLUMN_LABELS: function () {
            return c;
          },
          columnsDefs: function () {
            return h;
          },
        });
      var r = i(78286),
        n = i(4565),
        a = i(12556),
        o = i(54655),
        l = i(35047),
        s = i(50825),
        d = i(5500),
        u = i(48833);
      let c = {
          [u.N6.Timestamp]: 'Date',
          [u.N6.TypeText]: 'Type',
          [u.N6.AssetsUsd]: 'Amount',
          [u.N6.User]: 'User',
          [u.N6.TransactionHash]: 'Transaction',
        },
        h = [
          {
            id: u.N6.Timestamp,
            accessorKey: u.N6.Timestamp,
            header: () =>
              (0, r.tZ)(o.ua7, {
                content: 'Timestamp of when the transaction occurred.',
                children: (0, r.tZ)(o.xvT.Body.XXXS.Regular, {
                  color: 'text.secondary',
                  children: c.Timestamp,
                }),
              }),
            cell: (e) => {
              let { row: t } = e;
              return (0, r.tZ)(d.Z, { timestamp: t.original.timestamp });
            },
            enableSorting: !0,
            skeletonCell: (0, r.tZ)(o.OdW, { width: '88px', height: '21px' }),
          },
          {
            id: u.N6.TypeText,
            accessorKey: u.N6.TypeText,
            header: () =>
              (0, r.tZ)(o.ua7, {
                content:
                  'The nature of the transaction, providing more details about the type of transaction.',
                children: (0, r.tZ)(o.xvT.Body.XXXS.Regular, {
                  color: 'text.secondary',
                  children: c.TypeText,
                }),
              }),
            cell: (e) => {
              let { row: t } = e;
              return (0, r.tZ)(o.WN3, { children: t.original.typeText });
            },
            enableSorting: !1,
            skeletonCell: (0, r.tZ)(o.OdW, { width: '120px', height: '21px' }),
          },
          {
            id: u.N6.AssetsUsd,
            accessorKey: u.N6.AssetsUsd,
            header: () =>
              (0, r.tZ)(o.ua7, {
                content: 'The amount of tokens involved in the transaction.',
                children: (0, r.tZ)(o.xvT.Body.XXXS.Regular, {
                  color: 'text.secondary',
                  children: c.AssetsUsd,
                }),
              }),
            cell: (e) => {
              let { row: t } = e,
                i = (0, l.isDefined)(t.original.data.assetsUsd)
                  ? (0, n.safeParseNumber)(t.original.data.assetsUsd)
                  : void 0;
              return (0, l.isDefined)(t.original.data.vault.asset)
                ? (0, r.tZ)(o.kOf, {
                    token: (0, a.wk)(t.original.data.vault.asset),
                    amount: t.original.data.assets,
                    value: i,
                    withAvatar: !0,
                  })
                : null;
            },
            enableSorting: !1,
            skeletonCell: (0, r.tZ)(o.OdW, { width: '150px', height: '21px' }),
          },
          {
            id: u.N6.User,
            accessorKey: u.N6.User,
            header: () =>
              (0, r.tZ)(o.ua7, {
                content: 'User who executed the transaction.',
                children: (0, r.tZ)(o.xvT.Body.XXXS.Regular, {
                  color: 'text.secondary',
                  marginLeft: '7px',
                  children: c.User,
                }),
              }),
            cell: (e) => {
              let { row: t } = e;
              return (0, r.tZ)(s.Z, {
                href: t.original.urlUser,
                mode: 'external',
                buttonProps: {
                  variant: 'ghost',
                  size: 'default',
                  label: (0, o.GQT)(t.original.user.address),
                  avatarProps: { address: t.original.user.address },
                },
              });
            },
            enableSorting: !1,
            skeletonCell: (0, r.tZ)(o.OdW, { width: '140px', height: '21px' }),
          },
          {
            id: u.N6.TransactionHash,
            accessorKey: u.N6.TransactionHash,
            header: () =>
              (0, r.tZ)(o.ua7, {
                content: 'The transaction hash.',
                children: (0, r.tZ)(o.xvT.Body.XXXS.Regular, {
                  color: 'text.secondary',
                  marginLeft: '12px',
                  children: c.TransactionHash,
                }),
              }),
            cell: (e) => {
              let { row: t } = e;
              return (0, r.tZ)(s.Z, {
                href: t.original.urlHash,
                mode: 'external',
                buttonProps: {
                  variant: 'ghost',
                  size: 'default',
                  label: (0, o.GQT)(t.original.hash),
                },
              });
            },
            enableSorting: !1,
            skeletonCell: (0, r.tZ)(o.OdW, { width: '119px', height: '21px' }),
          },
        ];
    },
    48833: function (e, t, i) {
      'use strict';
      i.d(t, {
        CM: function () {
          return o;
        },
        DU: function () {
          return u;
        },
        IV: function () {
          return a;
        },
        N6: function () {
          return l;
        },
        Rk: function () {
          return c;
        },
        aL: function () {
          return s;
        },
        wF: function () {
          return d;
        },
      });
      var r = i(42324),
        n = i(13191);
      let a = 10,
        o = {
          Timestamp: n.TransactionsOrderBy.Timestamp,
          AssetsUsd: n.TransactionsOrderBy.AssetsUsd,
        },
        l = { ...o, TypeText: 'TypeText', User: 'User', TransactionHash: 'TransactionHash' },
        s = 'vaultTransactionsTable',
        d = {
          columnVisibility: {},
          sorting: [{ id: l.Timestamp, desc: !0 }],
          columnFilters: [],
          version: 1,
        },
        u = [
          { label: 'Vault Deposit', value: n.TransactionType.MetaMorphoDeposit },
          { label: 'Vault Fee', value: n.TransactionType.MetaMorphoFee },
          { label: 'Vault Transfer', value: n.TransactionType.MetaMorphoTransfer },
          { label: 'Vault Withdraw', value: n.TransactionType.MetaMorphoWithdraw },
        ],
        c = { transactionTypeFilter: (0, r.S$)(r.Oi).withDefault([]) };
      (0, r.Cg)(c);
    },
    72803: function (e, t, i) {
      'use strict';
      i.d(t, {
        default: function () {
          return F;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(13191),
        o = i(4565),
        l = i(12556),
        s = i(54655),
        d = i(35047),
        u = i(50825),
        c = i(78017),
        h = i(40252),
        v = i(16820),
        p = i(38819);
      let m = (0, p.Z)(s.zxk, { target: 'e15qzh930' })('padding:3px 10px 3px 5px;');
      var g = (0, n.memo)((e) => {
          let { asset: t } = e,
            i = (0, n.useMemo)(
              () => h.ChainUtils.getExplorerAddressUrl(t.chain.id, t.address),
              [t.address, t.chain.id]
            ),
            a = (0, n.useMemo)(() => (0, v.Tg)(t.address), [t.address]);
          return (0, r.BX)(s.zsw.Root, {
            children: [
              (0, r.tZ)(s.zsw.Trigger, {
                asChild: !0,
                children: (0, r.tZ)(m, {
                  variant: 'ghost',
                  size: 'small',
                  children: (0, r.BX)(s.Kqy, {
                    gap: 2,
                    align: 'center',
                    children: [
                      (0, r.tZ)(s.qEK, { src: t.logoURI, size: 'small' }),
                      (0, r.tZ)(s.xvT.Body.XXXS.Regular, {
                        lineHeight: 'normal',
                        children: t.symbol,
                      }),
                    ],
                  }),
                }),
              }),
              (0, r.tZ)(s.zsw.Content, {
                children: (0, r.BX)(s.Kqy, {
                  direction: 'column',
                  padding: '12px 0px',
                  children: [
                    (0, r.BX)(s.Kqy, {
                      justify: 'space-between',
                      align: 'center',
                      padding: '10px 12px',
                      children: [
                        (0, r.tZ)(s.xvT.Body.XXS.Regular, {
                          lineHeight: 'normal',
                          children: 'Token',
                        }),
                        (0, r.BX)(s.Kqy, {
                          gap: 2,
                          align: 'center',
                          children: [
                            (0, r.tZ)(s.qEK, { src: t.logoURI, size: 'small' }),
                            (0, r.tZ)(s.xvT.Body.XXS.Regular, {
                              lineHeight: 'normal',
                              children: t.symbol,
                            }),
                          ],
                        }),
                      ],
                    }),
                    (0, r.BX)(s.Kqy, {
                      justify: 'space-between',
                      align: 'center',
                      padding: '10px 12px',
                      children: [
                        (0, r.tZ)(s.xvT.Body.XXS.Regular, {
                          lineHeight: 'normal',
                          children: 'Address',
                        }),
                        (0, r.BX)(s.Kqy, {
                          gap: 'xxs',
                          align: 'center',
                          children: [
                            (0, r.tZ)(s.xvT.Body.XXS.Regular, {
                              lineHeight: 'normal',
                              children: a,
                            }),
                            (0, r.tZ)(s.mUV, {
                              toCopy: t.address,
                              toastMessage: 'Token address copied to clipboard.',
                              tooltipMessage: 'Copy Token Address.',
                              size: 'small',
                            }),
                            (0, r.tZ)(u.Z, {
                              href: i,
                              mode: 'external',
                              buttonProps: {
                                variant: 'ghost',
                                size: 'small',
                                iconAlone: 'ArrowDiagonalUpPlain20',
                                iconRight: void 0,
                              },
                            }),
                          ],
                        }),
                      ],
                    }),
                  ],
                }),
              }),
            ],
          });
        }),
        y = i(33210),
        b = i(89991),
        f = i(93319),
        Z = i(6423),
        x = i(83897),
        w = i(57892);
      let k = (0, p.Z)(s.Kqy, { target: 'e1qcx80t0' })('width:100%;'),
        B = (0, p.Z)(s.Kqy, { target: 'e1qcx80t2' })('width:100%;'),
        A = (0, p.Z)(s.Kqy, { target: 'e1qcx80t3' })('flex:1;'),
        P = (0, p.Z)(s.Kqy, { target: 'e1qcx80t4' })(
          'gap:24px;',
          (e) => {
            let { theme: t } = e;
            return t.breakpoints.down('xs');
          },
          '{gap:',
          (e) => {
            let { theme: t } = e;
            return t.spacing.xs;
          },
          ';}'
        ),
        C = (0, p.Z)('span', { target: 'e1qcx80t5' })(
          (e) => {
            let { theme: t, color: i } = e;
            return s.IED.title.l(t, { wordBreak: 'break-all', color: i });
          },
          ' ',
          (e) => {
            let { theme: t } = e;
            return t.breakpoints.down('xs');
          },
          '{',
          (e) => {
            let { theme: t, color: i } = e;
            return s.IED.title.m(t, { wordBreak: 'break-all', color: i });
          },
          '}'
        ),
        T = (0, p.Z)('div', { target: 'e1qcx80t6' })('flex-shrink:0;margin-left:"auto";');
      function S(e) {
        let { address: t } = e;
        return (0, r.tZ)(T, {
          children: (0, r.tZ)(s.mUV, {
            toCopy: t,
            toastMessage: 'Vault address copied to clipboard.',
            tooltipMessage: 'Copy Vault Address.',
            size: 'small',
          }),
        });
      }
      var X = i(52234),
        R = i(20624);
      let D = (0, p.Z)('div', { target: 'ekhfi8k0' })(
        'background-color:',
        (e) => {
          let { theme: t } = e;
          return t.colors.background.secondary;
        },
        ';height:46px;width:46px;outline:none;border:none;color:',
        (e) => {
          let { theme: t } = e;
          return t.colors.icon.secondary;
        },
        ';display:flex;align-items:center;justify-content:center;border-radius:100px;&:hover{color:',
        (e) => {
          let { theme: t } = e;
          return t.colors.icon.primary;
        },
        ';}transition:color 0.2s ease-in-out;cursor:pointer;'
      );
      function M(e) {
        let { tooltipContent: t, icon: i } = e,
          [, n] = (0, R.kq)();
        return (0, r.tZ)(s.ua7, {
          content: t,
          variant: 'main',
          children: (0, r.tZ)(D, {
            onClick: (e) => {
              e.preventDefault(), n('risk');
            },
            children: (0, r.tZ)(s.JO$, { size: 20, icon: i, color: 'inherit' }),
          }),
        });
      }
      var q = (0, n.memo)((e) => {
          let { chainId: t, vaultAddress: i, credoraRating: n } = e,
            a = (0, X.D)(t, i),
            o = [
              {
                icon:
                  n && (null == a ? void 0 : a.showCredoraRating) !== !1
                    ? 'CheckPlain20'
                    : 'AlertPlain20',
                tooltipContent:
                  (null == a ? void 0 : a.showCredoraRating) === !1
                    ? 'Curator has not provided a Risk Rating.'
                    : n
                      ? 'Curator has provided a Risk Rating by Credora.'
                      : "Curator's Vault has not been rated yet.",
              },
              {
                icon: (null == a ? void 0 : a.disclosure) ? 'CheckPlain20' : 'AlertPlain20',
                tooltipContent: (null == a ? void 0 : a.disclosure)
                  ? 'Curator has submitted  disclosures.'
                  : 'Curator has not submitted disclosures.',
              },
            ];
          return (0, r.BX)(r.HY, {
            children: [
              (0, r.BX)(s.Kqy, {
                gap: 'xs',
                align: 'center',
                children: [
                  (0, r.tZ)(s.xvT.Body.XS.Regular, {
                    color: 'text.secondary',
                    whiteSpace: 'nowrap',
                    children: 'Disclosures',
                  }),
                  (0, r.tZ)(s.bEE, {
                    tooltipContent:
                      "Shared by the curator, this section details the vault's risks and risk management decisions.",
                  }),
                ],
              }),
              (0, r.tZ)(s.Kqy, {
                align: 'center',
                gap: 4,
                children: o.map((e, t) =>
                  (0, r.tZ)(
                    M,
                    { icon: e.icon, tooltipContent: e.tooltipContent },
                    ''.concat(t, '-').concat(e.icon)
                  )
                ),
              }),
            ],
          });
        }),
        F = (0, n.memo)(
          (0, y.Z)((e) => {
            var t, i, h, p, m, y, T, X, R, D;
            let { address: M, queryResult: F } = e,
              { targetChainId: K } = (0, b.Z_)(),
              E = (0, s.dD4)(),
              I = null === (t = F.data) || void 0 === t ? void 0 : t.vaultByAddress,
              V =
                null === (i = I.riskAnalysis) || void 0 === i
                  ? void 0
                  : i.find((e) => e.provider === a.RiskProvider.Credora && !e.isUnderReview),
              { data: L } = (0, w.Fj)(M, 0),
              { data: O } = (0, w.Fj)(M),
              N = (0, n.useMemo)(() => (0, l.wk)(null == I ? void 0 : I.asset), [I.asset]),
              U = (0, s.AwN)({
                apiValue:
                  null == I
                    ? void 0
                    : null === (h = I.state) || void 0 === h
                      ? void 0
                      : h.totalAssets,
                initialOnchainValue: null == L ? void 0 : L.totalAssets,
                latestSimulatedValue: null == O ? void 0 : O.totalAssets,
              }),
              $ = (0, n.useMemo)(() => {
                if (!(0, d.isDefined)(U.value)) return null;
                let e = N.toUsd(U.value),
                  t = s.$0l.short.digits(2).trailingZero(!1).default('-').of(e, 18);
                return (0, f.l)(t);
              }, [U.value, N]),
              z = (0, n.useMemo)(
                () =>
                  N
                    ? s.$0l.short
                        .digits(2)
                        .trailingZero(!1)
                        .default('-')
                        .unit(N.symbol)
                        .of(U.value, N.decimals)
                    : '-',
                [N, U.value]
              ),
              _ = (0, s.AwN)({
                apiValue:
                  null == I
                    ? void 0
                    : null === (p = I.liquidity) || void 0 === p
                      ? void 0
                      : p.underlying,
                initialOnchainValue: null == L ? void 0 : L.liquidity,
                latestSimulatedValue: null == O ? void 0 : O.liquidity,
              }),
              W = (0, n.useMemo)(() => {
                if (!(0, d.isDefined)(_.value)) return null;
                let e = N.toUsd(_.value),
                  t = s.$0l.short.digits(2).trailingZero(!1).default('-').of(e, 18);
                return (0, f.l)(t);
              }, [_.value, N]),
              H = (0, n.useMemo)(
                () =>
                  N
                    ? s.$0l.short
                        .digits(2)
                        .trailingZero(!1)
                        .default('-')
                        .unit(N.symbol)
                        .of(_.value, N.decimals)
                    : null,
                [N, _]
              ),
              G = (0, n.useMemo)(() => {
                let e = (0, s.Uaj)(null == I ? void 0 : I.name);
                return (0, s.TaP)(e);
              }, [null == I ? void 0 : I.name]),
              j = (0, n.useMemo)(() => {
                var e, t;
                return s.$0l.percent
                  .digits(2)
                  .default('-')
                  .of(
                    (0, o.safeParseNumber)(
                      null !==
                        (t =
                          null == I
                            ? void 0
                            : null === (e = I.state) || void 0 === e
                              ? void 0
                              : e.dailyNetApy) && void 0 !== t
                        ? t
                        : 0
                    ),
                    18
                  );
              }, [I]),
              Q = (0, x.M)(M, null == I ? void 0 : I.state, null == I ? void 0 : I.asset),
              Y = (0, s.vmq)({
                chainId: K,
                vaultAddress: M,
                allocation:
                  null == I
                    ? void 0
                    : null === (m = I.state) || void 0 === m
                      ? void 0
                      : m.allocation,
              });
            return (0, r.BX)(k, {
              gap: 48,
              direction: 'column',
              align: 'start',
              children: [
                (0, r.BX)(s.Kqy, {
                  gap: 's',
                  direction: 'column',
                  fullWidth: !0,
                  children: [
                    (0, r.BX)(s.Kqy, {
                      gap: 'm',
                      align: 'center',
                      children: [
                        (null == I ? void 0 : I.name)
                          ? (0, r.BX)(P, {
                              wrap: 'wrap',
                              children: [
                                (0, r.tZ)(C, { children: G.first }),
                                (0, r.tZ)(C, { color: 'text.tertiary', children: G.rest }),
                              ],
                            })
                          : (0, r.tZ)(C, { children: (0, d.formatLongString)(M, 16) }),
                        !E && (0, r.tZ)(S, { address: M }),
                      ],
                    }),
                    (0, r.BX)(s.Kqy, {
                      gap: 's',
                      align: 'center',
                      children: [
                        (0, r.tZ)(s.Kqy, {
                          gap: 'xs',
                          align: 'center',
                          style: { flexWrap: 'wrap' },
                          children:
                            null == I
                              ? void 0
                              : null === (T = I.state) || void 0 === T
                                ? void 0
                                : null === (y = T.curators) || void 0 === y
                                  ? void 0
                                  : y.map((e) =>
                                      (0, r.tZ)(
                                        s.Kqy,
                                        {
                                          gap: { base: 8, s: 4 },
                                          align: 'center',
                                          children: (0, r.tZ)(u.Z, {
                                            href: (0, Z.tw)({
                                              chainName: l.FW.getNameById(K),
                                              curatorId: e.id,
                                            }),
                                            mode: 'internal',
                                            buttonProps: {
                                              variant: 'ghost',
                                              label: e.name,
                                              size: 'default',
                                              avatarProps: { src: e.image },
                                            },
                                          }),
                                        },
                                        e.name
                                      )
                                    ),
                        }),
                        (0, r.tZ)(g, { asset: N }),
                        E && (0, r.tZ)(S, { address: M }),
                      ],
                    }),
                  ],
                }),
                (null == I ? void 0 : I.metadata) &&
                  (0, r.tZ)(s.xvT.Body.XS.Regular, {
                    color: 'text.secondary',
                    children: I.metadata.description,
                  }),
                (0, r.BX)(B, {
                  gap: 'm',
                  justify: 'start',
                  wrap: 'wrap',
                  direction: E ? 'column' : 'row',
                  children: [
                    (0, r.BX)(A, {
                      gap: 's',
                      direction: 'column',
                      children: [
                        (0, r.tZ)(s.Kqy, {
                          align: 'center',
                          children: (0, r.tZ)(s.xvT.Body.XS.Regular, {
                            color: 'text.secondary',
                            whiteSpace: 'nowrap',
                            children: 'Total Deposits',
                          }),
                        }),
                        (0, r.BX)(s.Kqy, {
                          align: 'center',
                          children: [
                            (0, r.tZ)(s.ZT$, {
                              TextVariant: s.xvT.Title.S,
                              isSimulated: U.isSimulated,
                              children: $ ? '$'.concat($.value) : '-',
                            }),
                            (0, r.tZ)(s.ZT$, {
                              TextVariant: s.xvT.Title.S,
                              color: 'text.tertiary',
                              isSimulated: U.isSimulated,
                              children: null == $ ? void 0 : $.unit,
                            }),
                          ],
                        }),
                        (0, r.tZ)(s.ZT$, {
                          TextVariant: s.xvT.Body.XS.Regular,
                          isSimulated: U.isSimulated,
                          children: z,
                        }),
                      ],
                    }),
                    (0, r.BX)(A, {
                      gap: 's',
                      direction: 'column',
                      children: [
                        (0, r.tZ)(s.Kqy, {
                          gap: 6,
                          align: 'center',
                          children: (0, r.tZ)(s.xvT.Body.XS.Regular, {
                            color: 'text.secondary',
                            whiteSpace: 'nowrap',
                            children: 'Liquidity',
                          }),
                        }),
                        (0, r.BX)(s.Kqy, {
                          align: 'center',
                          children: [
                            (0, r.tZ)(s.ZT$, {
                              TextVariant: s.xvT.Title.S,
                              isSimulated: _.isSimulated,
                              children: W ? '$'.concat(W.value) : '-',
                            }),
                            (0, r.tZ)(s.ZT$, {
                              TextVariant: s.xvT.Title.S,
                              color: 'text.tertiary',
                              isSimulated: _.isSimulated,
                              children: null == W ? void 0 : W.unit,
                            }),
                          ],
                        }),
                        (0, r.tZ)(s.ZT$, {
                          TextVariant: s.xvT.Body.XS.Regular,
                          isSimulated: _.isSimulated,
                          children: H,
                        }),
                      ],
                    }),
                    (0, r.tZ)(A, {
                      gap: 's',
                      direction: 'column',
                      children: (0, r.tZ)(q, {
                        chainId: K,
                        vaultAddress: M,
                        credoraRating: null == V ? void 0 : V.rating,
                      }),
                    }),
                    (0, r.BX)(A, {
                      gap: 's',
                      direction: 'column',
                      children: [
                        (0, r.BX)(s.Kqy, {
                          gap: 4,
                          align: 'center',
                          children: [
                            (0, r.tZ)(s.xvT.Body.XS.Regular, {
                              color: 'text.secondary',
                              whiteSpace: 'nowrap',
                              children: 'APY',
                            }),
                            (0, r.tZ)(s.bEE, { tooltipContent: '1D Native APY + Rewards - Fees' }),
                          ],
                        }),
                        (0, r.tZ)(c.w, {
                          RewardsHoverCardProps: {
                            performanceFee: (0, v.Pi)(
                              null == I
                                ? void 0
                                : null === (X = I.state) || void 0 === X
                                  ? void 0
                                  : X.fee,
                              o.safeParseNumber
                            ),
                            apy: (0, v.Pi)(
                              null == I
                                ? void 0
                                : null === (R = I.state) || void 0 === R
                                  ? void 0
                                  : R.dailyApy,
                              o.safeParseNumber
                            ),
                            rewards: Q,
                            points: Y,
                            variant: 'vault',
                            netApy: (0, v.Pi)(
                              null == I
                                ? void 0
                                : null === (D = I.state) || void 0 === D
                                  ? void 0
                                  : D.dailyNetApy,
                              o.safeParseNumber
                            ),
                            asset: N,
                          },
                          iconSize: 35,
                          children: (0, r.BX)(s.Kqy, {
                            children: [
                              (0, r.tZ)(s.xvT.Title.S, { children: j }),
                              (0, r.tZ)(s.Kqy, {
                                gap: 4,
                                align: 'center',
                                children: (0, r.tZ)(s.xvT.Title.S, {
                                  color: 'text.tertiary',
                                  children: '%',
                                }),
                              }),
                            ],
                          }),
                        }),
                      ],
                    }),
                  ],
                }),
              ],
            });
          })
        );
    },
    8052: function (e, t, i) {
      'use strict';
      var r = i(78286),
        n = i(58258),
        a = i(54655),
        o = i(99095);
      t.default = (0, n.memo)(function (e) {
        let { warnings: t } = e,
          { setPageWarning: i } = (0, o.l5)(),
          { message: l } = (0, n.useMemo)(
            () => (null == t || 0 === t.length ? { message: null } : (0, a.SnM)(t)),
            [t]
          );
        return (
          (0, n.useEffect)(() => {
            if (null != l)
              return (
                i({
                  type: 'alert',
                  content: (0, r.tZ)(a.xvT.Body.M.Regular, {
                    lineHeight: 'normal',
                    width: '100%',
                    textAlign: 'center',
                    children: l,
                  }),
                  dismissable: !1,
                }),
                () => {
                  i(void 0);
                }
              );
          }, [i, l]),
          null
        );
      });
    },
    10111: function (e, t, i) {
      'use strict';
      i.d(t, {
        default: function () {
          return s;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(54655),
        o = i(33210),
        l = i(75688),
        s = (0, n.memo)(
          (0, o.Z)((e) => {
            let { queryResult: t, chartApySlot: i, address: n } = e;
            return (0, a.CPt)()
              ? (0, r.BX)(a.Kqy, {
                  gap: 's',
                  direction: 'column',
                  fullWidth: !0,
                  children: [
                    (0, r.tZ)(a.Zbd, { paddingBlock: 'm', paddingInline: 's', children: i }),
                    (0, r.tZ)(a.Zbd, {
                      direction: 'column',
                      paddingBlock: 'm',
                      paddingInline: 's',
                      children: (0, r.tZ)(l.default, { address: n, vault: t.data.vaultByAddress }),
                    }),
                  ],
                })
              : (0, r.BX)(a.Zbd, {
                  gap: 'm',
                  padding: 'm',
                  children: [i, (0, r.tZ)(l.default, { address: n, vault: t.data.vaultByAddress })],
                });
          })
        );
    },
    10747: function (e, t, i) {
      'use strict';
      i.d(t, {
        default: function () {
          return C;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(4565),
        o = i(12556),
        l = i(54655),
        s = i(78017),
        d = i(27349),
        u = i(33210),
        c = i(10433),
        h = i(89991),
        v = i(16820),
        p = i(34937),
        m = i(83669),
        g = i(83897),
        y = i(38819);
      let b = (0, y.Z)(l.Kqy, { target: 'e1mrvvtx0' })('min-width:220px;'),
        f = (0, y.Z)(l.xvT.Body.XS.Regular, { target: 'e1mrvvtx1' })('line-height:normal;');
      var Z = i(55412),
        x = i(3245),
        w = i(93114),
        k = i(24387),
        B = i(45610);
      function A() {
        let e = (0, Z._)([
          '\n  query GetVaultApyTimeseries(\n    $address: String!\n    $chainId: Int\n    $options: TimeseriesOptions\n  ) {\n    vaultByAddress(address: $address, chainId: $chainId) {\n      id\n      address\n      asset {\n        ...simpleAssetFieldsWithYield\n      }\n      state {\n        id\n        allTimeNetApy\n        quarterlyNetApy\n        monthlyNetApy\n        weeklyNetApy\n        dailyNetApy\n        totalAssets\n        dailyApy\n        fee\n        rewards {\n          asset {\n            ...simpleAssetFields\n          }\n          amountPerSuppliedToken\n          supplyApr\n        }\n        allocation {\n          id\n          supplyAssets\n          supplyAssetsUsd\n          market {\n            id\n            uniqueKey\n            ...collateralExposuresFields\n            loanAsset {\n              id\n              name\n            }\n            state {\n              id\n              rewards {\n                asset {\n                  ...simpleAssetFields\n                }\n                supplyApr\n                amountPerSuppliedToken\n              }\n            }\n          }\n        }\n      }\n      historicalState {\n        dailyNetApy(options: $options) {\n          x\n          y\n        }\n      }\n    }\n  }\n  ',
          '\n  ',
          '\n  ',
          '\n',
        ]);
        return (
          (A = function () {
            return e;
          }),
          e
        );
      }
      let P = (0, x.Ps)(A(), B.N, k.G, w.j);
      var C = (0, n.memo)(
        (0, u.Z)((e) => {
          var t, i, u, y, Z, x;
          let { now: w, queryResult: k, queryVariables: B } = e,
            { targetChainId: A } = (0, h.Z_)(),
            { palette: C } = (0, l.rFV)(),
            { theme: T } = (0, l.TCT)(),
            [S, X] = (0, n.useState)('mo'),
            R = (0, n.useMemo)(
              () => ({ ...B, options: (0, p.Ai)({ timeFrame: S, now: w }) }),
              [w, S, B]
            ),
            {
              data: D,
              loading: M,
              error: q,
            } = (0, m.s)({
              queryDocument: P,
              queryVariables: R,
              serverQueryVariables: B,
              serverQueryResult: k,
            }),
            F = (0, n.useMemo)(() => (0, p.Vl)(S), [S]),
            K = (0, n.useMemo)(() => {
              var e;
              return (0, l.EES)(
                null == D
                  ? void 0
                  : null === (e = D.vaultByAddress.historicalState) || void 0 === e
                    ? void 0
                    : e.dailyNetApy
              );
            }, [D]),
            E = (0, n.useMemo)(() => {
              var e;
              return l.$0l.percent
                .default('-')
                .trailingZero(!1)
                .digits(2)
                .of(
                  null == D
                    ? void 0
                    : null === (e = D.vaultByAddress.state) || void 0 === e
                      ? void 0
                      : e[F]
                );
            }, [D, F]),
            I = (0, o.DI)(
              null == D
                ? void 0
                : null === (t = D.vaultByAddress.state) || void 0 === t
                  ? void 0
                  : t.dailyNetApy
            ),
            V = (0, n.useMemo)(
              () => l.$0l.percent.default('-').trailingZero(!1).digits(2).of(I),
              [I]
            ),
            L = (0, g.M)(
              null == D ? void 0 : D.vaultByAddress.address,
              null == D
                ? void 0
                : null === (i = D.vaultByAddress) || void 0 === i
                  ? void 0
                  : i.state,
              null == D
                ? void 0
                : null === (u = D.vaultByAddress) || void 0 === u
                  ? void 0
                  : u.asset
            ),
            O = (0, l.vmq)({
              chainId: A,
              vaultAddress: null == D ? void 0 : D.vaultByAddress.address,
              allocation:
                null == D
                  ? void 0
                  : null === (y = D.vaultByAddress.state) || void 0 === y
                    ? void 0
                    : y.allocation,
            }),
            N = (0, n.useMemo)(() => {
              var e, t, i, r, n, l;
              return {
                performanceFee: (0, v.Pi)(
                  null == D
                    ? void 0
                    : null === (t = D.vaultByAddress) || void 0 === t
                      ? void 0
                      : null === (e = t.state) || void 0 === e
                        ? void 0
                        : e.fee,
                  a.safeParseNumber
                ),
                apy: (0, v.Pi)(
                  null == D
                    ? void 0
                    : null === (r = D.vaultByAddress) || void 0 === r
                      ? void 0
                      : null === (i = r.state) || void 0 === i
                        ? void 0
                        : i.dailyApy,
                  a.safeParseNumber
                ),
                rewards: L,
                points: O,
                variant: 'vault',
                netApy: (0, v.Pi)(
                  null == D
                    ? void 0
                    : null === (n = D.vaultByAddress.state) || void 0 === n
                      ? void 0
                      : n.dailyNetApy,
                  a.safeParseNumber
                ),
                asset: (0, o.wk)(
                  null == D
                    ? void 0
                    : null === (l = D.vaultByAddress) || void 0 === l
                      ? void 0
                      : l.asset
                ),
              };
            }, [D, O, L]);
          return (0, r.BX)(b, {
            direction: 'column',
            gap: 'm',
            grow: 1,
            children: [
              (0, r.BX)(l.Kqy, {
                justify: 'space-between',
                align: 'center',
                children: [
                  (0, r.BX)(l.Kqy, {
                    direction: 'column',
                    gap: 'xs',
                    children: [
                      (0, r.tZ)(s.w, {
                        RewardsHoverCardProps: N,
                        noHover: !0,
                        children: (0, r.tZ)(f, {
                          color: 'text.secondary',
                          lineHeight: 'normal',
                          children: 'APY',
                        }),
                      }),
                      (0, r.BX)(l.zsw.Root, {
                        children: [
                          (0, r.tZ)(l.zsw.Trigger, {
                            children: (0, r.BX)(l.Kqy, {
                              gap: 2,
                              align: 'center',
                              children: [
                                (0, r.tZ)(l.xvT.Title.S, { color: 'text.body', children: V }),
                                (0, r.tZ)(l.xvT.Title.S, { color: 'text.tertiary', children: '%' }),
                              ],
                            }),
                          }),
                          (0, r.tZ)(l.zsw.Content, { children: (0, r.tZ)(d.Z, { ...N }) }),
                        ],
                      }),
                    ],
                  }),
                  (0, r.tZ)(l.PhF, { options: c.S, value: S, onChange: X }),
                ],
              }),
              (0, r.tZ)(l._9J, {
                statuses: { loading: M, error: q },
                unit: '%',
                height: '225px',
                series: [
                  {
                    type: 'areaspline',
                    name: 'Apy',
                    data: K,
                    color: C.colors[0],
                    lineColor: C.colors[0],
                    fillColor: C.areaChartColors[0],
                  },
                ],
                plotlinesY: [
                  {
                    value:
                      null !==
                        (x =
                          null == D
                            ? void 0
                            : null === (Z = D.vaultByAddress.state) || void 0 === Z
                              ? void 0
                              : Z[F]) && void 0 !== x
                        ? x
                        : void 0,
                    color: T.colors.constant.color.brand,
                    dashStyle: 'Dot',
                    width: 1,
                    label: {
                      x: 6,
                      y: -15,
                      text: 'Avg '.concat(E, '%'),
                      align: 'left',
                      useHTML: !0,
                      formatter: (0, l.RFc)(T, T.colors.text.body),
                    },
                  },
                ],
                additionalOptions: { yAxis: { softMin: 0, maxPadding: 0.4 } },
              }),
            ],
          });
        })
      );
    },
    75688: function (e, t, i) {
      'use strict';
      i.d(t, {
        default: function () {
          return Z;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(4565),
        o = i(12556),
        l = i(54655),
        s = i(16586),
        d = i(26726),
        u = i(89991),
        c = i(16820),
        h = i(964),
        v = i(73828),
        p = i(83897),
        m = i(38819);
      let g = (0, m.Z)(l.Kqy, { target: 'e13ws6aj0' })('padding:9px 0;min-height:50px;'),
        y = (0, m.Z)('div', { target: 'e13ws6aj1' })(
          'background-color:',
          (e) => {
            let { theme: t } = e;
            return t.colors.background.tertiary;
          },
          ';padding:',
          (e) => {
            let { theme: t } = e;
            return t.padding.s;
          },
          ';border-radius:',
          (e) => {
            let { theme: t } = e;
            return t.borderRadius;
          },
          ';width:275px;overflow-y:auto;max-height:332px;',
          (e) => {
            let { theme: t } = e;
            return t.breakpoints.down('m');
          },
          '{max-height:345px;background-color:unset;padding:0;border:unset;width:100%;border-radius:0;}'
        ),
        b = (0, m.Z)('div', { target: 'e13ws6aj2' })(
          'background-color:',
          (e) => {
            let { theme: t } = e;
            return t.colors.background.primary;
          },
          ';width:24px;height:24px;border-radius:50%;display:flex;align-items:center;justify-content:center;'
        ),
        f = (0, m.Z)(l.JO$, { target: 'e13ws6aj4' })(
          'position:relative;top:-1px;margin-left:-1px;'
        );
      var Z = (0, n.memo)((e) => {
        var t, i, m, Z, x, w;
        let { vault: k, address: B } = e,
          { targetChainId: A } = (0, u.Z_)(),
          P = (0, d.nh)(d.TP.FE_CALCULATION_NATIVE_APY),
          C = (0, n.useMemo)(
            () => (0, o.wk)(null == k ? void 0 : k.asset),
            [null == k ? void 0 : k.asset]
          ),
          T = (0, p.M)(B, null == k ? void 0 : k.state, null == k ? void 0 : k.asset),
          S = (0, n.useMemo)(() => {
            var e, t, i, r;
            return P
              ? (0, h.H2)({
                  rewards: T,
                  netApy: (0, c.Pi)(
                    null == k
                      ? void 0
                      : null === (e = k.state) || void 0 === e
                        ? void 0
                        : e.dailyNetApy,
                    a.safeParseNumber
                  ),
                  nativeApy: (0, c.Pi)(
                    null == k
                      ? void 0
                      : null === (t = k.state) || void 0 === t
                        ? void 0
                        : t.dailyApy,
                    a.safeParseNumber
                  ),
                  performanceFee: (0, c.Pi)(
                    null == k ? void 0 : null === (i = k.state) || void 0 === i ? void 0 : i.fee,
                    a.safeParseNumber
                  ),
                  asset: C,
                })
              : (0, c.Pi)(
                  null == k ? void 0 : null === (r = k.state) || void 0 === r ? void 0 : r.dailyApy,
                  a.safeParseNumber
                );
          }, [
            null == k ? void 0 : null === (t = k.state) || void 0 === t ? void 0 : t.dailyNetApy,
            null == k ? void 0 : null === (i = k.state) || void 0 === i ? void 0 : i.dailyApy,
            T,
            C,
            null == k ? void 0 : null === (m = k.state) || void 0 === m ? void 0 : m.fee,
            P,
          ]),
          X = (0, n.useMemo)(
            () => l.$0l.percent.trailingZero(!1).digits(2).unit('%').default('-').of(S, 18),
            [S]
          ),
          R = (0, n.useMemo)(() => {
            var e;
            return l.$0l.percent
              .trailingZero(!1)
              .digits(2)
              .unit('%')
              .default('0')
              .of(null == k ? void 0 : null === (e = k.state) || void 0 === e ? void 0 : e.fee);
          }, [null == k ? void 0 : null === (Z = k.state) || void 0 === Z ? void 0 : Z.fee]),
          D = (0, l.vmq)({
            chainId: A,
            vaultAddress: B,
            allocation:
              null == k ? void 0 : null === (x = k.state) || void 0 === x ? void 0 : x.allocation,
          }),
          M = (0, n.useMemo)(() => {
            var e, t;
            let i = null == k ? void 0 : null === (e = k.state) || void 0 === e ? void 0 : e.fee,
              r = null == k ? void 0 : null === (t = k.state) || void 0 === t ? void 0 : t.dailyApy,
              n = i && r ? i * r : 0;
            return 0 === n
              ? '0.00%'
              : l.$0l.percent.trailingZero(!1).digits(2).sign().unit('%').of(-n);
          }, [null == k ? void 0 : k.state]),
          q = (0, n.useMemo)(() => {
            var e;
            return l.$0l.percent
              .trailingZero(!1)
              .digits(2)
              .unit('%')
              .default('-')
              .of(
                null == k ? void 0 : null === (e = k.state) || void 0 === e ? void 0 : e.dailyNetApy
              );
          }, [
            null == k ? void 0 : null === (w = k.state) || void 0 === w ? void 0 : w.dailyNetApy,
          ]);
        return (0, r.BX)(y, {
          children: [
            (0, r.BX)(g, {
              justify: 'space-between',
              align: 'center',
              children: [
                (0, r.BX)(l.Kqy, {
                  gap: 4,
                  align: 'center',
                  children: [
                    (0, r.tZ)(b, {
                      children: (0, r.tZ)(l.JO$, { icon: 'InterestGeneratedGradient20', size: 14 }),
                    }),
                    (0, r.tZ)(l.xvT.Body.XXS.Regular, {
                      color: 'text.body',
                      children: 'Native APY',
                    }),
                  ],
                }),
                (0, r.tZ)(l.xvT.Body.XXS.Regular, { children: X }),
              ],
            }),
            C instanceof o.YK &&
              (0, r.tZ)(r.HY, {
                children: (0, r.BX)(g, {
                  justify: 'space-between',
                  align: 'center',
                  children: [
                    (0, r.BX)(l.Kqy, {
                      gap: 4,
                      align: 'center',
                      children: [
                        (0, r.tZ)(l.qEK, { src: C.logoURI, size: 'medium' }),
                        (0, r.BX)(l.xvT.Body.XXS.Regular, { children: [C.symbol, ' Yield'] }),
                        (0, r.tZ)(l.mUV, {
                          toCopy: C.address,
                          toastMessage: 'Address copied to clipboard.',
                          tooltipMessage: 'Copy address.',
                        }),
                      ],
                    }),
                    (0, r.tZ)(l.Kqy, {
                      gap: 4,
                      align: 'center',
                      children: (0, r.tZ)(l.xvT.Body.XXS.Regular, {
                        lineHeight: 'normal',
                        children: l.$0l.percent
                          .digits(2)
                          .unit('%')
                          .trailingZero(!1)
                          .sign()
                          .of(C.yield),
                      }),
                    }),
                  ],
                }),
              }),
            T.map((e, t) =>
              (0, r.tZ)(
                'div',
                {
                  children: (0, r.BX)(g, {
                    justify: 'space-between',
                    align: 'center',
                    children: [
                      (0, r.BX)(l.Kqy, {
                        gap: 4,
                        align: 'center',
                        children: [
                          (0, r.tZ)(l.qEK, { src: e.rewardToken.logoURI, size: 'medium' }),
                          (0, r.tZ)(l.xvT.Body.XXS.Regular, {
                            color: 'text.body',
                            children: e.rewardToken.symbol,
                          }),
                          (0, r.tZ)(l.mUV, {
                            toCopy: e.rewardToken.address,
                            toastMessage: 'Address copied to clipboard.',
                            tooltipMessage: 'Copy address.',
                          }),
                        ],
                      }),
                      (0, r.BX)(l.Kqy, {
                        gap: 4,
                        align: 'center',
                        children: [
                          (0, r.tZ)(l.xvT.Body.XXS.Regular, {
                            lineHeight: 'normal',
                            color: 'text.body',
                            children: (0, v.Cn)(e),
                          }),
                          !e.apr &&
                            e.proportional &&
                            !e.rewardToken.price &&
                            (0, r.tZ)(l.ua7, {
                              content: 'Per year per $1000 deposited.',
                              withTouch: !0,
                              children: (0, r.tZ)(l.JO$, {
                                icon: 'QuestionPlain20',
                                color: 'text.secondary',
                                size: 16,
                              }),
                            }),
                        ],
                      }),
                    ],
                  }),
                },
                'reward-'.concat(t)
              )
            ),
            (0, r.BX)(g, {
              justify: 'space-between',
              align: 'center',
              children: [
                (0, r.BX)(l.Kqy, {
                  gap: 4,
                  align: 'center',
                  children: [
                    (0, r.tZ)(f, { size: 25, icon: 'DollarSignPlain24', color: 'text.primary' }),
                    (0, r.tZ)(l.xvT.Body.XS.Regular, {
                      color: 'text.body',
                      children: 'Performance Fee',
                    }),
                    (0, r.tZ)(l.Vp9, { variant: 'main', label: R }),
                  ],
                }),
                (0, r.tZ)(l.xvT.Body.XXS.Regular, { children: M }),
              ],
            }),
            (0, r.BX)(g, {
              justify: 'space-between',
              align: 'center',
              children: [
                (0, r.BX)(l.Kqy, {
                  gap: 4,
                  align: 'center',
                  children: [
                    (0, r.tZ)(l.JO$, { icon: 'RewardsPlain20', color: 'text.interactive.active' }),
                    (0, r.tZ)(l.xvT.Body.XXS.Regular, {
                      color: 'text.interactive.active',
                      children: 'Net APY',
                    }),
                  ],
                }),
                (0, r.BX)(l.xvT.Body.XXS.Regular, {
                  color: 'text.interactive.active',
                  children: ['=', q],
                }),
              ],
            }),
            D.length > 0 && (0, r.tZ)(l.Z0O, {}),
            D.map((e, t) =>
              (0, r.tZ)(
                'div',
                {
                  children: (0, r.BX)(g, {
                    justify: 'space-between',
                    align: 'center',
                    children: [
                      (0, r.BX)(l.Kqy, {
                        gap: 4,
                        align: 'center',
                        children: [
                          (0, r.tZ)(l.JO$, { icon: 'PointsPlain20', color: 'icon.primary' }),
                          e.label && (0, r.tZ)(l.Vp9, { label: e.label }),
                          (0, r.tZ)(s.X, { point: e }),
                        ],
                      }),
                      (0, r.BX)(l.Kqy, {
                        gap: 'xxs',
                        align: 'center',
                        children: [
                          e.value && (0, r.tZ)(l.xvT.Body.XXS.Regular, { children: e.value }),
                          e.title &&
                            (0, r.tZ)(l.xvT.Body.XXS.Regular, {
                              color: 'text.body',
                              children: e.title,
                            }),
                        ],
                      }),
                    ],
                  }),
                },
                'point-'.concat(t)
              )
            ),
          ],
        });
      });
    },
    38071: function (e, t, i) {
      'use strict';
      i.d(t, {
        default: function () {
          return f;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(12556),
        o = i(54655),
        l = i(76992),
        s = i(33210),
        d = i(10433),
        u = i(93319),
        c = i(34937),
        h = i(83669),
        v = i(57892),
        p = i(55412),
        m = i(3245),
        g = i(24387);
      function y() {
        let e = (0, p._)([
          '\n  query GetVaultSupplyLiquidityTimeseries(\n    $address: String!\n    $chainId: Int\n    $options: TimeseriesOptions\n    $fetchTotalAssets: Boolean!\n    $fetchTotalAssetsUsd: Boolean!\n  ) {\n    vaultByAddress(address: $address, chainId: $chainId) {\n      id\n      historicalState {\n        totalAssets(options: $options) @include(if: $fetchTotalAssets) {\n          x\n          y\n        }\n        totalAssetsUsd(options: $options) @include(if: $fetchTotalAssetsUsd) {\n          x\n          y\n        }\n      }\n      state {\n        id\n        totalAssets\n      }\n      asset {\n        ...simpleAssetFields\n      }\n    }\n  }\n  ',
          '\n',
        ]);
        return (
          (y = function () {
            return e;
          }),
          e
        );
      }
      let b = (0, m.Ps)(y(), g.G);
      var f = (0, n.memo)(
        (0, s.Z)((e) => {
          var t, i;
          let { queryVariables: s, queryResult: p, now: m, address: g } = e,
            { palette: y } = (0, o.rFV)(),
            f = (0, o.dD4)(),
            { data: Z } = (0, v.Fj)(g, 0),
            { data: x } = (0, v.Fj)(g),
            w = (0, o.AwN)({
              apiValue:
                null === (i = p.data.vaultByAddress) || void 0 === i
                  ? void 0
                  : null === (t = i.state) || void 0 === t
                    ? void 0
                    : t.totalAssets,
              initialOnchainValue: null == Z ? void 0 : Z.totalAssets,
              latestSimulatedValue: null == x ? void 0 : x.totalAssets,
            }),
            k = (0, n.useMemo)(
              () => (0, a.wk)(p.data.vaultByAddress.asset),
              [p.data.vaultByAddress.asset]
            ),
            B = (0, n.useMemo)(() => {
              if (w.value) return k.toUsd(w.value);
            }, [k, w]),
            [A, P] = (0, n.useState)(d.B),
            [C, T] = (0, n.useState)('USD'),
            S = (0, n.useMemo)(
              () => [
                {
                  value: p.data.vaultByAddress.asset.symbol,
                  label: p.data.vaultByAddress.asset.symbol,
                },
                { value: 'USD', label: 'USD' },
              ],
              [p.data.vaultByAddress.asset]
            ),
            X = (0, n.useMemo)(() => ('USD' === C ? 'totalAssetsUsd' : 'totalAssets'), [C]),
            R = (0, n.useMemo)(
              () => ({
                ...s,
                fetchTotalAssets: 'totalAssets' === X,
                fetchTotalAssetsUsd: 'totalAssetsUsd' === X,
                options: (0, c.Ai)({ timeFrame: A, now: m }),
              }),
              [X, m, A, s]
            ),
            {
              data: D,
              loading: M,
              error: q,
            } = (0, h.s)({
              queryDocument: b,
              queryVariables: R,
              serverQueryVariables: s,
              serverQueryResult: p,
            }),
            F = (0, n.useMemo)(() => {
              var e, t;
              return 'totalAssetsUsd' === X
                ? (0, o.EES)(
                    null == D
                      ? void 0
                      : null === (e = D.vaultByAddress.historicalState) || void 0 === e
                        ? void 0
                        : e.totalAssetsUsd
                  )
                : (0, o.EES)(
                    null == D
                      ? void 0
                      : null === (t = D.vaultByAddress.historicalState) || void 0 === t
                        ? void 0
                        : t.totalAssets,
                    p.data.vaultByAddress.asset.decimals
                  );
            }, [D, X, p.data.vaultByAddress.asset]),
            K = w.isSimulated,
            E = (0, n.useMemo)(() => {
              let e;
              return (
                (e =
                  'totalAssetsUsd' === X
                    ? o.$0l.short.default('-').digits(2).of(B, 18)
                    : o.$0l.short
                        .default('-')
                        .digits(2)
                        .of(w.value, p.data.vaultByAddress.asset.decimals)),
                (0, u.l)(e)
              );
            }, [X, p.data.vaultByAddress.asset, w.value, B]);
          return (0, r.BX)(o.Zbd, {
            fullWidth: !0,
            gap: 'm',
            direction: 'column',
            paddingBlock: 'm',
            paddingInline: { base: 'm', s: 's' },
            children: [
              (0, r.BX)(o.Kqy, {
                justify: 'space-between',
                align: 'center',
                gap: 's',
                wrap: 'wrap',
                children: [
                  (0, r.BX)(o.Kqy, {
                    direction: 'column',
                    gap: 'xs',
                    children: [
                      (0, r.tZ)(o.Kqy, {
                        gap: 2,
                        align: 'center',
                        children: (0, r.BX)(o.xvT.Body.XS.Regular, {
                          color: 'text.secondary',
                          children: ['Total Deposits (', C, ')'],
                        }),
                      }),
                      E.value
                        ? (0, r.BX)(o.Kqy, {
                            gap: 2,
                            align: 'center',
                            children: [
                              (0, r.BX)(o.ZT$, {
                                TextVariant: o.xvT.Title.S,
                                isSimulated: K,
                                children: ['USD' === C ? '$' : '', E.value],
                              }),
                              (0, r.tZ)(o.ZT$, {
                                TextVariant: o.xvT.Title.S,
                                color: 'text.tertiary',
                                isSimulated: K,
                                children: E.unit,
                              }),
                            ],
                          })
                        : (0, r.tZ)(o.OdW, { height: '46px', width: '130px' }),
                    ],
                  }),
                  (0, r.BX)(o.Kqy, {
                    align: 'center',
                    gap: 's',
                    wrap: 'wrap',
                    children: [
                      f
                        ? (0, r.tZ)(r.HY, {
                            children: (0, r.tZ)(o.PhF, { options: S, value: C, onChange: T }),
                          })
                        : (0, r.tZ)(r.HY, {
                            children: (0, r.tZ)(l.E, {
                              variant: 'secondary',
                              id: 'chart-options-currency',
                              options: S,
                              value: C,
                              onChange: T,
                            }),
                          }),
                      (0, r.tZ)(o.PhF, { options: d.S, value: A, onChange: P }),
                    ],
                  }),
                ],
              }),
              (0, r.tZ)(o._9J, {
                statuses: { loading: M, error: q },
                unit: 'USD' === C ? '$' : C,
                height: '224px',
                series: [
                  {
                    type: 'areaspline',
                    name: 'Total Deposits',
                    data: F,
                    color: y.colors[0],
                    lineColor: y.colors[0],
                    fillColor: y.areaChartColors[0],
                  },
                ],
              }),
            ],
          });
        })
      );
    },
    77843: function (e, t, i) {
      'use strict';
      i.d(t, {
        default: function () {
          return S;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(55385),
        o = i(60626),
        l = i(54655),
        s = i(43779),
        d = i(33210),
        u = i(89991),
        c = i(16237),
        h = i(55135),
        v = i(6423),
        p = i(90836),
        m = i(38819);
      let g = (0, m.Z)(l.Kqy, { target: 'e1jy12rw0' })('width:100%;height:100%;'),
        y = (0, m.Z)(l.xrM, { target: 'e1jy12rw1' })(
          'width:100%;height:100%;border-radius:',
          (e) => {
            let { theme: t } = e;
            return t.borderRadius;
          },
          ';display:grid;td{:first-of-type{width:50%;}:nth-of-type(2){width:unset;}}'
        );
      var b = i(4565),
        f = i(27349),
        Z = i(16820),
        x = i(42418);
      let w = [
          {
            accessorKey: 'market',
            header: () =>
              (0, r.tZ)(l.ua7, {
                content: 'The markets this vault has supplied into.',
                children: (0, r.tZ)(l.xvT.Body.XXXS.Regular, {
                  color: 'text.secondary',
                  children: 'Market Exposure',
                }),
              }),
            cell: (e) => {
              let { row: t } = e,
                i = t.original.market;
              return (0, r.tZ)(l.k1R, { ...i, chainId: i.loanAsset.chain.id });
            },
            sortingFn: (e, t) =>
              (0, x.Dt)(
                (0, l.lAJ)({
                  loanAsset: e.original.market.loanAsset,
                  collateralAsset: e.original.market.collateralAsset,
                }),
                (0, l.lAJ)({
                  loanAsset: t.original.market.loanAsset,
                  collateralAsset: t.original.market.collateralAsset,
                })
              ),
          },
          {
            accessorKey: 'percentShare',
            header: () =>
              (0, r.tZ)(l.ua7, {
                content: 'Proportion of the vault supply allocated to this Morpho Market.',
                children: (0, r.tZ)(l.xvT.Body.XXXS.Regular, {
                  color: 'text.secondary',
                  children: 'Vault Allocation %',
                }),
              }),
            cell: (e) => {
              let { row: t } = e;
              return (0, r.tZ)(l.lR8, {
                allocation: t.original.percentShare,
                percentageOffset: t.original.percentageOffset,
                index: t.index,
              });
            },
          },
          {
            accessorKey: 'supplyAssetsUsd',
            header: () =>
              (0, r.tZ)(l.ua7, {
                content: 'The amount supplied to the market.',
                children: (0, r.tZ)(l.xvT.Body.XXXS.Regular, {
                  color: 'text.secondary',
                  children: 'Vault Allocation ($)',
                }),
              }),
            cell: (e) => {
              let { row: t } = e;
              return (0, r.tZ)(l.WN3, {
                children: l.$0l.short
                  .trailingZero(!1)
                  .digits(2)
                  .unit('$')
                  .of(t.original.supplyAssetsUsd),
              });
            },
          },
          {
            accessorKey: 'supplyCapUsd',
            header: () =>
              (0, r.tZ)(l.ua7, {
                content: 'The maximum market allocation allowed by the vault.',
                children: (0, r.tZ)(l.xvT.Body.XXXS.Regular, {
                  color: 'text.secondary',
                  children: 'Supply Cap',
                }),
              }),
            cell: (e) => {
              let { row: t } = e;
              return t.original.market.collateralAsset
                ? (0, r.tZ)(l.WN3, {
                    children: l.$0l.short
                      .trailingZero(!1)
                      .digits(2)
                      .unit('$')
                      .of(t.original.supplyCapUsd),
                  })
                : '-';
            },
          },
          {
            accessorKey: 'market.state.dailyNetSupplyApy',
            header: () =>
              (0, r.tZ)(l.ua7, {
                content: '1D Supply APY + Rewards',
                children: (0, r.tZ)(l.xvT.Body.XXXS.Regular, {
                  color: 'text.secondary',
                  marginLeft: '14px',
                  children: 'APY',
                }),
              }),
            cell: (e) => {
              var t, i, n, a;
              let { row: o } = e;
              return o.original.market.collateralAsset
                ? (0, r.tZ)(l.KNv, {
                    hoverCardContent: (0, r.tZ)(f.Z, {
                      apy: (0, Z.Pi)(
                        null === (t = o.original.market.state) || void 0 === t
                          ? void 0
                          : t.dailySupplyApy,
                        b.safeParseNumber
                      ),
                      netApy: (0, Z.Pi)(
                        null === (i = o.original.market.state) || void 0 === i
                          ? void 0
                          : i.dailyNetSupplyApy,
                        b.safeParseNumber
                      ),
                      rewards: o.original.rewards,
                      variant: 'supply',
                      asset: o.original.market.collateralAsset,
                    }),
                    padding: '0 11px 0 14px',
                    children: (0, r.BX)(l.Kqy, {
                      gap: 2,
                      align: 'center',
                      children: [
                        (0, r.tZ)(l.WN3, {
                          children: l.$0l.percent
                            .digits(2)
                            .unit('%')
                            .of(
                              null === (n = o.original.market.state) || void 0 === n
                                ? void 0
                                : n.dailyNetSupplyApy
                            ),
                        }),
                        (null === (a = o.original.rewards) || void 0 === a ? void 0 : a.length)
                          ? (0, r.tZ)(l.JO$, { icon: 'RewardsGradient20' })
                          : null,
                      ],
                    }),
                  })
                : (0, r.tZ)(l.WN3, { marginLeft: '14px', children: '-' });
            },
          },
        ],
        k = {
          market: 'Market',
          percentShare: 'Allocation %',
          supplyAssetsUsd: 'Total Supply',
          supplyCapUsd: 'Cap',
          market_state_dailyNetSupplyApy: 'Daily Supply APY',
        },
        B = {
          columnVisibility: {},
          sorting: [{ id: 'percentShare', desc: !0 }],
          columnFilters: [],
          version: 1,
        };
      var A = i(35047),
        P = i(8937),
        C = i(47528),
        T = (e) =>
          (0, n.useMemo)(() => {
            var t;
            if (
              !(null == e ? void 0 : null === (t = e.state) || void 0 === t ? void 0 : t.allocation)
            )
              return { data: [], totalCount: 0 };
            let i = 0n,
              r = e.state.allocation
                .sort((0, A.bigIntComparator)((e) => e.supplyAssets, 'desc'))
                .map((t) => {
                  var r, n;
                  let a = (0, P.R)(
                      null !==
                        (n =
                          null == e
                            ? void 0
                            : null === (r = e.state) || void 0 === r
                              ? void 0
                              : r.totalAssets) && void 0 !== n
                        ? n
                        : 0n,
                      t.supplyAssets
                    ),
                    o = (0, C.f)(t.market, 'supply'),
                    l = { ...t, percentShare: a, percentageOffset: i, rewards: o };
                  return (i += a), l;
                });
            return { data: r, totalCount: r.length };
          }, [e]),
        S = (0, n.memo)(
          (0, d.Z)((e) => {
            var t;
            let { queryResult: i } = e,
              { targetChain: n } = (0, u.Z_)(),
              { pagination: d, onPaginationChange: m } = (0, p.h)({ defaultPageSize: 10 }),
              { data: b, totalCount: f } = T(
                null === (t = i.data) || void 0 === t ? void 0 : t.vaultByAddress
              ),
              { sorting: Z, setSorting: x } = (0, c.Z)({
                pageKey: h.CT.Vault,
                tableSettingsObjectKey: 'marketAllocationTable',
                defaultTableSettings: B,
              }),
              A = (0, a.b7)({
                data: b,
                getCoreRowModel: (0, o.sC)(),
                getSortedRowModel: (0, o.tj)(),
                getPaginationRowModel: (0, o.G_)(),
                onSortingChange: x,
                state: { sorting: Z, pagination: d },
                columns: w,
                enableSortingRemoval: !1,
                sortDescFirst: !0,
                onPaginationChange: m,
              });
            return (0, r.BX)(g, {
              direction: 'column',
              gap: 'xs',
              children: [
                (0, r.BX)(y, {
                  children: [
                    A.getRowModel().rows.length > 0 &&
                      (0, r.BX)(s.iA.iA, {
                        tableVariant: 'compact',
                        children: [
                          (0, r.tZ)(s.iA.hr, {
                            children: A.getHeaderGroups().map((e) =>
                              (0, r.tZ)(s.uq, { columnLabels: k, headerGroup: e }, e.id)
                            ),
                          }),
                          (0, r.tZ)(s.iA.p3, {
                            children: A.getRowModel().rows.map((e) => {
                              var t, i;
                              return (0, r.tZ)(
                                s.yL,
                                {
                                  row: e,
                                  href: e.original.market.collateralAsset
                                    ? (0, v.E3)({
                                        chainName: n.name,
                                        marketUniqueKey: e.original.market.uniqueKey,
                                        collateralSymbol: e.original.market.collateralAsset.symbol,
                                        loanSymbol:
                                          null !==
                                            (i =
                                              null === (t = e.original.market.loanAsset) ||
                                              void 0 === t
                                                ? void 0
                                                : t.symbol) && void 0 !== i
                                            ? i
                                            : '0x',
                                      })
                                    : void 0,
                                },
                                e.id
                              );
                            }),
                          }),
                        ],
                      }),
                    0 === A.getRowModel().rows.length &&
                      (0, r.tZ)(l.WaR, {
                        text: 'No market allocation found.',
                        height: '640px',
                        cardTextProps: { style: { borderRadius: '0' } },
                      }),
                  ],
                }),
                (0, r.tZ)(l.tlE, {
                  loading: !1,
                  pagination: d,
                  totalItemsCount: f,
                  previousPage: A.previousPage,
                  nextPage: A.nextPage,
                  setPage: A.setPageIndex,
                  canPreviousPage: A.getCanPreviousPage(),
                  canNextPage: A.getCanNextPage(),
                }),
              ],
            });
          })
        );
    },
    658: function (e, t, i) {
      'use strict';
      var r = i(78286),
        n = i(58258),
        a = i(12556),
        o = i(54655),
        l = i(89991),
        s = i(83897),
        d = i(1456),
        u = i(84967);
      t.default = (0, n.memo)(function (e) {
        var t, i, c, h, v, p, m, g, y, b;
        let { queryResult: f, chartsPerformanceSlot: Z } = e,
          x = null === (t = f.data) || void 0 === t ? void 0 : t.vaultByAddress,
          { targetChainId: w } = (0, l.Z_)(),
          k = (0, s.M)(x.address, null == x ? void 0 : x.state, null == x ? void 0 : x.asset),
          B = (0, o.vmq)({
            chainId: w,
            vaultAddress: x.address,
            allocation: null === (i = x.state) || void 0 === i ? void 0 : i.allocation,
          }),
          A = (0, n.useMemo)(() => (0, a.wk)(null == x ? void 0 : x.asset), [x.asset]);
        return (0, r.BX)(r.HY, {
          children: [
            (0, r.tZ)(d.ZP, {
              netApy: null === (c = x.state) || void 0 === c ? void 0 : c.netApy,
              apy: null === (h = x.state) || void 0 === h ? void 0 : h.apy,
              apy7d: null === (v = x.state) || void 0 === v ? void 0 : v.weeklyNetApy,
              apy30d: null === (p = x.state) || void 0 === p ? void 0 : p.monthlyNetApy,
              apy90d: null === (m = x.state) || void 0 === m ? void 0 : m.quarterlyNetApy,
              rewards: k,
              points: B,
              asset: A,
              performanceFee:
                null == x ? void 0 : null === (g = x.state) || void 0 === g ? void 0 : g.fee,
            }),
            Z,
            (0, r.tZ)(u.ZP, {
              feeRecipient: null === (y = x.state) || void 0 === y ? void 0 : y.feeRecipient,
              performanceFee: null === (b = x.state) || void 0 === b ? void 0 : b.fee,
            }),
          ],
        });
      });
    },
    96188: function (e, t, i) {
      'use strict';
      var r = i(78286),
        n = i(58258),
        a = i(15176),
        o = i(1456),
        l = i(84967);
      t.default = (0, n.memo)((e) => {
        let {} = e;
        return (0, r.BX)(a.default, { children: [(0, r.tZ)(o.jX, {}), (0, r.tZ)(l.HB, {})] });
      });
    },
    86096: function (e, t, i) {
      'use strict';
      var r = i(78286),
        n = i(58258),
        a = i(15176),
        o = i(1456),
        l = i(84967);
      t.default = (0, n.memo)((e) => {
        let {} = e;
        return (0, r.BX)(a.default, { children: [(0, r.tZ)(o.S5, {}), (0, r.tZ)(l.ih, {})] });
      });
    },
    68987: function (e, t, i) {
      'use strict';
      var r = i(78286),
        n = i(58258),
        a = i(40252),
        o = i(54655),
        l = i(12597),
        s = i(6893);
      t.default = (0, n.memo)((e) => {
        var t;
        let {
            queryResult: { data: i },
          } = e,
          { publicAllocator: n } = (0, a.getChainAddresses)(a.ChainId.EthMainnet);
        return (0, r.BX)(o.Kqy, {
          gap: 's',
          direction: 'column',
          align: 'start',
          children: [
            (0, r.tZ)(s.$, { children: 'Risk Curation' }),
            (null == i
              ? void 0
              : null === (t = i.vaultByAddress) || void 0 === t
                ? void 0
                : t.allocators) &&
              i.vaultByAddress.allocators.length > 0 &&
              (0, r.tZ)(o.Kqy, {
                gap: 's',
                wrap: 'wrap',
                style: { width: '100%' },
                children: i.vaultByAddress.allocators.map((e, t) => {
                  let { address: i } = e;
                  return (0, r.tZ)(
                    l.mD,
                    {
                      title: 'Allocator Address',
                      address: i,
                      minWidth: '275px',
                      labelTag: n === i ? 'Public Allocator' : void 0,
                    },
                    'allocator-' + t
                  );
                }),
              }),
          ],
        });
      });
    },
    9894: function (e, t, i) {
      'use strict';
      i.d(t, {
        default: function () {
          return b;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(54655),
        o = i(76992),
        l = i(33210),
        s = i(10433),
        d = i(34937),
        u = i(83669);
      let c = (0, i(38819).Z)(a.Zbd, { target: 'ew01rsg0' })('width:100%;');
      var h = i(55412),
        v = i(3245),
        p = i(24387);
      function m() {
        let e = (0, h._)([
          '\n  query GetVaultAllocationTimeseries(\n    $address: String!\n    $chainId: Int\n    $options: TimeseriesOptions\n  ) {\n    vaultByAddress(address: $address, chainId: $chainId) {\n      id\n      asset {\n        id\n        symbol\n      }\n      historicalState {\n        allocation {\n          market {\n            id\n            lltv\n            loanAsset {\n              ...simpleAssetFields\n            }\n            collateralAsset {\n              ...simpleAssetFields\n            }\n          }\n          supplyAssets(options: $options) {\n            x\n            y\n          }\n        }\n      }\n    }\n  }\n  ',
          '\n',
        ]);
        return (
          (m = function () {
            return e;
          }),
          e
        );
      }
      let g = (0, v.Ps)(m(), p.G),
        y = (e) => ({
          segmented: [
            { value: 'percent', icon: 'PercentPlain20' },
            { value: 'normal', label: null != e ? e : '' },
          ],
          select: [
            { value: 'percent', label: '%' },
            { value: 'normal', label: null != e ? e : '' },
          ],
        });
      var b = (0, n.memo)(
        (0, l.Z)((e) => {
          var t;
          let { queryVariables: i, queryResult: l, now: h } = e,
            { palette: v } = (0, a.rFV)(),
            p = (0, a.dD4)(),
            [m, b] = (0, n.useState)(s.B),
            [f, Z] = (0, n.useState)('percent'),
            x = (0, n.useMemo)(
              () => ({ ...i, options: (0, d.Ai)({ timeFrame: m, now: h }) }),
              [h, m, i]
            ),
            {
              data: w,
              loading: k,
              error: B,
            } = (0, u.s)({
              queryDocument: g,
              queryVariables: x,
              serverQueryVariables: i,
              serverQueryResult: l,
            }),
            A = (0, n.useMemo)(() => {
              var e;
              return y(
                (null == l
                  ? void 0
                  : null === (e = l.data) || void 0 === e
                    ? void 0
                    : e.vaultByAddress.asset.symbol) ||
                  (null == w ? void 0 : w.vaultByAddress.asset.symbol)
              );
            }, [
              null == l
                ? void 0
                : null === (t = l.data) || void 0 === t
                  ? void 0
                  : t.vaultByAddress.asset.symbol,
              null == w ? void 0 : w.vaultByAddress.asset.symbol,
            ]),
            P = (0, n.useMemo)(() => {
              var e;
              if (!(null == w ? void 0 : w.vaultByAddress.historicalState.allocation)) return [];
              let t = v.colors.length;
              return null === (e = w.vaultByAddress.historicalState.allocation) || void 0 === e
                ? void 0
                : e.map((e, i) => {
                    var r, n;
                    let o = i % t;
                    return {
                      type: 'areaspline',
                      name: (0, a.lAJ)({
                        loanAsset: e.market.loanAsset,
                        collateralAsset: e.market.collateralAsset,
                      }),
                      data: (0, a.EES)(
                        e.supplyAssets,
                        null !==
                          (n =
                            null === (r = e.market.loanAsset) || void 0 === r
                              ? void 0
                              : r.decimals) && void 0 !== n
                          ? n
                          : 18
                      ),
                      color: v.colors[o],
                      lineColor: v.colors[o],
                      fillColor: v.areaChartColors[o],
                      states: { inactive: { enabled: !1 } },
                      lineWidth: 1,
                    };
                  });
            }, [w, v]),
            C = (0, n.useMemo)(() => {
              var e;
              return 'percent' === f
                ? '%'
                : null !== (e = null == w ? void 0 : w.vaultByAddress.asset.symbol) && void 0 !== e
                  ? e
                  : '';
            }, [f, null == w ? void 0 : w.vaultByAddress.asset.symbol]);
          return (0, r.BX)(c, {
            gap: 's',
            direction: 'column',
            padding: 'm',
            children: [
              (0, r.BX)(a.Kqy, {
                align: 'center',
                justify: 'space-between',
                children: [
                  (0, r.tZ)(a.xvT.Body.XS.Regular, {
                    color: 'text.secondary',
                    children: 'Allocation History',
                  }),
                  (0, r.BX)(a.Kqy, {
                    align: 'center',
                    gap: 's',
                    wrap: 'wrap',
                    children: [
                      p
                        ? (0, r.tZ)(a.PhF, { options: A.select, value: f, onChange: Z })
                        : (0, r.tZ)(o.E, {
                            variant: 'secondary',
                            id: 'chart-options-stacking-mode',
                            options: A.segmented,
                            value: f,
                            onChange: Z,
                          }),
                      (0, r.tZ)(a.PhF, { options: s.S, value: m, onChange: b }),
                    ],
                  }),
                ],
              }),
              (0, r.tZ)(a.Qpo, {
                statuses: { loading: k, error: B },
                unit: C,
                stackingMode: f,
                height: '225px',
                series: P,
              }),
            ],
          });
        })
      );
    },
    11901: function (e, t, i) {
      'use strict';
      i.d(t, {
        default: function () {
          return S;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(55385),
        o = i(60626),
        l = i(54655),
        s = i(51712),
        d = i(43779),
        u = i(33210),
        c = i(89991),
        h = i(90836),
        v = i(7518),
        p = i(38819);
      let m = (0, p.Z)(l.Kqy, { target: 'e12urv8e0' })('width:100%;height:100%;'),
        g = (0, p.Z)(l.xrM, { target: 'e12urv8e1' })(
          'width:100%;height:100%;border-radius:',
          (e) => {
            let { theme: t } = e;
            return t.borderRadius;
          },
          ';display:grid;'
        );
      var y = i(4015),
        b = i(83669),
        f = i(68866),
        Z = i(55412),
        x = i(3245),
        w = i(24387);
      function k() {
        let e = (0, Z._)([
          '\n  query GetVaultReallocates(\n    $first: Int\n    $skip: Int\n    $where: VaultReallocateFilters\n    $orderBy: VaultReallocateOrderBy\n    $orderDirection: OrderDirection\n  ) {\n    vaultReallocates(\n      first: $first\n      skip: $skip\n      where: $where\n      orderBy: $orderBy\n      orderDirection: $orderDirection\n    ) {\n      items {\n        id\n        caller\n        timestamp\n        hash\n        assets\n        vault {\n          id\n          asset {\n            ...simpleAssetFields\n          }\n        }\n        market {\n          id\n          lltv\n          uniqueKey\n          loanAsset {\n            ...simpleAssetFields\n          }\n          collateralAsset {\n            ...simpleAssetFields\n          }\n        }\n      }\n      pageInfo {\n        countTotal\n        count\n        limit\n        skip\n      }\n    }\n  }\n  ',
          '\n',
        ]);
        return (
          (k = function () {
            return e;
          }),
          e
        );
      }
      let B = (0, x.Ps)(k(), w.G);
      var A = (e) => {
          var t, i;
          let { queryVariables: r, queryResult: a, first: o, skip: l } = e,
            s = { ...r, first: o, skip: l },
            {
              data: d,
              loading: u,
              error: c,
            } = (0, b.s)({
              queryDocument: B,
              queryVariables: s,
              serverQueryVariables: r,
              serverQueryResult: a,
            }),
            { totalItemsCount: h, pageCount: v } = (0, f.Z)({
              pageInfo:
                null == d
                  ? void 0
                  : null === (t = d.vaultReallocates) || void 0 === t
                    ? void 0
                    : t.pageInfo,
              error: c,
              first: o,
            });
          return (0, n.useMemo)(() => {
            var e;
            return {
              data:
                null == d
                  ? void 0
                  : null === (e = d.vaultReallocates) || void 0 === e
                    ? void 0
                    : e.items,
              loading: u,
              error: c,
              totalCount: h,
              pageCount: v,
            };
          }, [
            null == d
              ? void 0
              : null === (i = d.vaultReallocates) || void 0 === i
                ? void 0
                : i.items,
            u,
            c,
            h,
            v,
          ]);
        },
        P = i(40252),
        C = i(12556),
        T = (e) => {
          let { items: t, chainId: i } = e;
          return (0, n.useMemo)(
            () =>
              t
                ? t.map((e) => {
                    var t;
                    let r = (0, C.wk)(e.vault.asset);
                    return {
                      ...e,
                      urlCaller: P.ChainUtils.getExplorerAddressUrl(i, e.caller),
                      urlHash: P.ChainUtils.getExplorerTransactionUrl(i, e.hash),
                      amountValue: null !== (t = r.toUsd(e.assets)) && void 0 !== t ? t : null,
                    };
                  })
                : [],
            [t, i]
          );
        },
        S = (0, n.memo)(
          (0, u.Z)((e) => {
            let { queryResult: t, queryVariables: i } = e,
              { targetChainId: u } = (0, c.Z_)(),
              {
                first: p,
                skip: b,
                pagination: f,
                onPaginationChange: Z,
              } = (0, h.h)({ defaultPageSize: 5 }),
              {
                data: x,
                loading: w,
                totalCount: k,
                error: B,
              } = A({ queryResult: t, queryVariables: i, first: p, skip: b }),
              P = T({ items: x, chainId: u }),
              C = (0, a.b7)({
                data: P,
                getCoreRowModel: (0, o.sC)(),
                state: { pagination: f },
                manualSorting: !1,
                manualPagination: !0,
                pageCount: null != k ? k : void 0,
                columns: y.vaultAllocationColumnsDefs,
                enableSortingRemoval: !1,
                sortDescFirst: !1,
                onPaginationChange: Z,
              }),
              S = (0, n.useMemo)(() => 0 === C.getRowModel().rows.length, [C]),
              X = (0, v.I)({
                first: p,
                totalCount: k,
                pagination: f,
                columnsDefs: y.vaultAllocationColumnsDefs,
              });
            return (0, r.BX)(m, {
              direction: 'column',
              gap: 'xs',
              children: [
                (0, r.BX)(g, {
                  children: [
                    !S &&
                      (0, r.BX)(d.iA.iA, {
                        tableVariant: 'compact',
                        children: [
                          (0, r.tZ)(d.iA.hr, {
                            children: C.getHeaderGroups().map((e) =>
                              (0, r.tZ)(d.uq, { headerGroup: e }, e.id)
                            ),
                          }),
                          (0, r.BX)(d.iA.p3, {
                            children: [
                              !w &&
                                C.getRowModel().rows.map((e) => (0, r.tZ)(d.yL, { row: e }, e.id)),
                              w &&
                                X.map((e, t) =>
                                  (0, r.tZ)(
                                    d.yL,
                                    { skeletonRow: e },
                                    'skeleton-table-reallocate-'.concat(t)
                                  )
                                ),
                            ],
                          }),
                        ],
                      }),
                    S &&
                      (0, r.tZ)(l.WaR, {
                        text: 'No allocation history found.',
                        height: '600px',
                        cardTextProps: { style: { borderRadius: '0' } },
                      }),
                    !w && B && (0, r.tZ)(s.Z, { minHeight: '340px', style: { borderRadius: '0' } }),
                  ],
                }),
                (0, r.tZ)(l.tlE, {
                  loading: w,
                  error: B,
                  pagination: f,
                  totalItemsCount: k,
                  previousPage: C.previousPage,
                  nextPage: C.nextPage,
                  setPage: C.setPageIndex,
                  canPreviousPage: C.getCanPreviousPage(),
                  canNextPage: C.getCanNextPage(),
                }),
              ],
            });
          })
        );
    },
    4015: function (e, t, i) {
      'use strict';
      i.r(t),
        i.d(t, {
          vaultAllocationColumnsDefs: function () {
            return d;
          },
        });
      var r = i(78286),
        n = i(86842),
        a = i(40252),
        o = i(12556),
        l = i(54655),
        s = i(50825);
      let d = [
        {
          accessorKey: 'timestamp',
          header: () =>
            (0, r.tZ)(l.ua7, {
              content: 'Timestamp of when the transaction occurred.',
              children: (0, r.tZ)(l.xvT.Body.XXXS.Regular, {
                color: 'text.secondary',
                children: 'Date',
              }),
            }),
          cell: (e) => {
            let { row: t } = e,
              i = 1e3 * Number(t.original.timestamp),
              a = (0, n.WU)(new Date(i), 'MM/dd/yyyy HH:mm');
            return (0, r.tZ)(l.WN3, { children: a });
          },
          enableSorting: !1,
          skeletonCell: (0, r.tZ)(l.OdW, { width: '70px', height: '21px' }),
        },
        {
          accessorKey: 'caller',
          header: () =>
            (0, r.tZ)(l.ua7, {
              content: 'User who executed the reallocate.',
              children: (0, r.tZ)(l.xvT.Body.XXXS.Regular, {
                color: 'text.secondary',
                marginLeft: '7px',
                children: 'Allocator',
              }),
            }),
          cell: (e) => {
            let { row: t } = e,
              { publicAllocator: i } = (0, a.getChainAddresses)(a.ChainId.EthMainnet);
            return (0, r.BX)(l.Kqy, {
              gap: 2,
              align: 'center',
              children: [
                (0, r.tZ)(s.Z, {
                  href: t.original.urlCaller,
                  mode: 'external',
                  buttonProps: {
                    variant: 'ghost',
                    size: 'default',
                    label: (0, l.GQT)(t.original.caller),
                    avatarProps: { address: t.original.caller },
                  },
                }),
                t.original.caller === i &&
                  (0, r.tZ)(l.Vp9, { variant: 'main', label: 'Public Allocator' }),
              ],
            });
          },
          enableSorting: !1,
          skeletonCell: (0, r.tZ)(l.OdW, { width: '143px', height: '32px' }),
        },
        {
          accessorKey: 'assets',
          header: () =>
            (0, r.tZ)(l.ua7, {
              content: 'The amount of token involved in the transaction.',
              children: (0, r.tZ)(l.xvT.Body.XXXS.Regular, {
                color: 'text.secondary',
                children: 'Amount',
              }),
            }),
          cell: (e) => {
            let { row: t } = e;
            return (0, r.tZ)(l.kOf, {
              token: (0, o.wk)(t.original.vault.asset),
              amount: t.original.assets,
              value: t.original.amountValue,
              withAvatar: !0,
            });
          },
          enableSorting: !1,
          skeletonCell: (0, r.tZ)(l.OdW, { width: '190px', height: '22px' }),
        },
        {
          accessorKey: 'market',
          header: () =>
            (0, r.tZ)(l.ua7, {
              content: 'The market concerned by the reallocate.',
              children: (0, r.tZ)(l.xvT.Body.XXXS.Regular, {
                color: 'text.secondary',
                children: 'Market',
              }),
            }),
          cell: (e) => {
            let { row: t } = e;
            return (0, r.tZ)(l.k1R, {
              ...t.original.market,
              chainId: t.original.vault.asset.chain.id,
            });
          },
          enableSorting: !1,
          skeletonCell: (0, r.tZ)(l.OdW, { width: '240px', height: '24px' }),
        },
        {
          accessorKey: 'hash',
          header: () =>
            (0, r.tZ)(l.ua7, {
              content: 'The transaction hash.',
              children: (0, r.tZ)(l.xvT.Body.XXXS.Regular, {
                color: 'text.secondary',
                marginLeft: '10px',
                children: 'Hash',
              }),
            }),
          cell: (e) => {
            let { row: t } = e;
            return (0, r.tZ)(s.Z, {
              href: t.original.urlHash,
              mode: 'external',
              buttonProps: {
                variant: 'ghost',
                size: 'default',
                label: (0, l.GQT)(t.original.hash),
              },
            });
          },
          enableSorting: !1,
          skeletonCell: (0, r.tZ)(l.OdW, { width: '122px', height: '32px' }),
        },
      ];
    },
    94098: function (e, t, i) {
      'use strict';
      i.d(t, {
        default: function () {
          return A;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(13191),
        o = i(54655),
        l = i(50825),
        s = i(12597),
        d = i(4899),
        u = i(67355);
      let c = {
          '0xaa0500198B4425DfC4E272FbE42C8E64E21fc03d': {
            name: 'Aragon',
            icon: (0, i(12556).$B)('v2/assets/icons/aragon.svg'),
            tooltipContent: 'Depositor DAO powered by Aragon OSx',
          },
        },
        h = (e) => c[e] || null;
      var v = i(86536);
      let p = (0, i(38819).Z)(o.dLw, { target: 'e26iu020' })(
        'display:inline-block;color:',
        (e) => {
          let { theme: t } = e;
          return t.colors.text.secondary;
        },
        ';&:hover{text-decoration:underline;}'
      );
      var m = (0, n.memo)((e) => {
          let { address: t, timelock: i, title: a, children: l, ...s } = e,
            c = (0, n.useMemo)(() => (0, u.L)(null != i ? i : null), [i]),
            m = (0, n.useMemo)(() => (t ? h(t) || { name: (0, o.GQT)(t) } : null), [t]);
          return (0, r.tZ)(v.x, {
            ...s,
            children: (0, r.BX)(o.Kqy, {
              direction: 'column',
              gap: 's',
              children: [
                (0, r.tZ)(o.xvT.Body.XS.Regular, { color: 'text.secondary', children: a }),
                (0, r.BX)(o.Kqy, {
                  gap: 4,
                  align: 'center',
                  children: [
                    (0, r.tZ)(o.xvT.Body.M.Regular, { children: c }),
                    m &&
                      (0, r.BX)(r.HY, {
                        children: [
                          (0, r.tZ)(o.xvT.Body.M.Regular, { children: ' / ' }),
                          m.icon &&
                            (0, r.tZ)(d.default, {
                              src: m.icon,
                              alt: m.name,
                              width: 18,
                              height: 18,
                            }),
                          (0, r.tZ)(o.xvT.Body.M.Regular, { children: m.name }),
                          m.tooltipContent &&
                            (0, r.tZ)(o.bEE, {
                              disableHoverableContent: !1,
                              tooltipContent: (0, r.BX)('span', {
                                children: [
                                  m.tooltipContent,
                                  (0, r.tZ)(p, {
                                    href: 'https://forum.morpho.org/t/trustless-onchain-guardian-setup-for-metamorpho-vaults/530',
                                    children: 'Learn more ',
                                  }),
                                ],
                              }),
                            }),
                        ],
                      }),
                    t &&
                      (0, r.tZ)(o.mUV, {
                        toCopy: t,
                        toastMessage: 'Guardian address copied to clipboard.',
                        tooltipMessage: 'Copy guardian address.',
                        'aria-label': 'Copy guardian address',
                      }),
                  ],
                }),
              ],
            }),
          });
        }),
        g = i(19686),
        y = i(6893),
        b = i(33210),
        f = i(52234),
        Z = i(89991),
        x = i(72561),
        w = i(17781),
        k = (e) => {
          let { content: t, forumLink: i } = e,
            a = (0, n.useRef)(null),
            s = (0, n.useRef)(null),
            [d, u] = (0, n.useState)(!1),
            [c, h] = (0, n.useState)(!1),
            v = (0, o.dD4)(),
            p = (0, n.useCallback)(() => {
              var e, t;
              let i = null === (e = s.current) || void 0 === e ? void 0 : e.scrollHeight,
                r = null === (t = a.current) || void 0 === t ? void 0 : t.clientHeight;
              i && r && i > r ? u(!0) : u(!1);
            }, []),
            m = (0, n.useCallback)(() => {
              let e = a.current;
              if (!e) return;
              let { scrollTop: t, scrollHeight: i, clientHeight: r } = e;
              h(t + r >= i - 1);
            }, []);
          return (
            (0, n.useEffect)(() => {
              let e = a.current;
              return (
                p(),
                m(),
                e && (e.addEventListener('scroll', m), window.addEventListener('resize', p)),
                () => {
                  e &&
                    (e.removeEventListener('scroll', m), window.removeEventListener('resize', p));
                }
              );
            }, [m, p]),
            (0, r.BX)(x.ac, {
              ref: a,
              children: [
                (0, r.BX)(o.Kqy, {
                  paddingTop: 'm',
                  paddingRight: 's',
                  paddingLeft: 's',
                  paddingBottom: d ? 0 : 'm',
                  ref: s,
                  direction: 'column',
                  gap: 's',
                  children: [
                    (0, r.BX)(o.Kqy, {
                      fullWidth: !0,
                      justify: 'space-between',
                      children: [
                        (0, r.BX)(o.Kqy, {
                          gap: 'xs',
                          align: 'center',
                          children: [
                            (0, r.tZ)(y.$, { children: 'Market Risk Disclosures' }),
                            (0, r.tZ)(o.bEE, {
                              tooltipContent:
                                "Shared by the curator, this section outlines the risks associated with the vault's deployed markets and their configuration.",
                            }),
                          ],
                        }),
                        i &&
                          (0, r.tZ)(n.Fragment, {
                            children: v
                              ? (0, r.tZ)(w.default, {
                                  href: i,
                                  target: '_blank',
                                  children: (0, r.tZ)(o.zxk, {
                                    iconAlone: 'ArrowPlain20',
                                    iconAloneProps: { style: { transform: 'rotate(-45deg)' } },
                                    variant: 'ghost',
                                  }),
                                })
                              : (0, r.tZ)(l.Z, {
                                  href: i,
                                  mode: 'external',
                                  buttonProps: {
                                    variant: 'ghost',
                                    label: 'Learn more at the forum',
                                  },
                                }),
                          }),
                      ],
                    }),
                    (0, r.tZ)(o.xvT.Body.XS.Regular, { whiteSpace: 'pre-wrap', children: t }),
                  ],
                }),
                d && (0, r.tZ)(x.P$, { isScrolledToBottom: c }),
              ],
            })
          );
        };
      function B(e) {
        var t;
        let { curators: i = [] } = e,
          a = i.length > 1,
          l = o.$0l.short.digits(2).unit('$').default('-');
        return (0, r.tZ)(s.xr, {
          minWidth: '220px',
          children: (0, r.BX)(o.Kqy, {
            justify: 'center',
            direction: 'column',
            gap: 's',
            children: [
              a
                ? (0, r.tZ)(r.HY, {
                    children: (0, r.tZ)(o.xvT.Body.XS.Regular, {
                      color: 'text.secondary',
                      children:
                        null == i
                          ? void 0
                          : i.map((e, t) => {
                              var a;
                              return (0, r.BX)(
                                n.Fragment,
                                {
                                  children: [
                                    e.name,
                                    ' AUM',
                                    t <
                                      (null !== (a = null == i ? void 0 : i.length) && void 0 !== a
                                        ? a
                                        : 0) -
                                        1 && ' / ',
                                  ],
                                },
                                'curator-name-'.concat(e.name)
                              );
                            }),
                    }),
                  })
                : (0, r.tZ)(o.xvT.Body.XS.Regular, {
                    color: 'text.secondary',
                    children: 'Curator TVL',
                  }),
              (0, r.tZ)(o.xvT.Body.M.Regular, {
                children: a
                  ? null == i
                    ? void 0
                    : i.map((e, t, i) =>
                        (0, r.BX)(
                          n.Fragment,
                          { children: [l.of(e.aum), t < i.length - 1 && ' / '] },
                          'curator-value-'.concat(e.name)
                        )
                      )
                  : l.of(null == i ? void 0 : null === (t = i[0]) || void 0 === t ? void 0 : t.aum),
              }),
            ],
          }),
        });
      }
      var A = (0, n.memo)(
        (0, b.Z)(function (e) {
          var t, i, d, c, h, v, p, b, w, A, P, C, T, S;
          let { queryResult: X } = e,
            { targetChainId: R } = (0, Z.Z_)(),
            D = null == X ? void 0 : X.data.vaultByAddress,
            M = (0, f.D)(R, D.address),
            q =
              null === (t = D.riskAnalysis) || void 0 === t
                ? void 0
                : t.find((e) => {
                    let { provider: t, isUnderReview: i } = e;
                    return t === a.RiskProvider.Credora && !i;
                  }),
            F = (0, n.useMemo)(() => {
              var e, t;
              return (null === (e = D.state) || void 0 === e ? void 0 : e.curators)
                ? null === (t = D.state) || void 0 === t
                  ? void 0
                  : t.curators.map((e) => {
                      let { __typename: t, state: i, ...r } = e;
                      return { ...r, aum: null == i ? void 0 : i.aum };
                    })
                : [];
            }, [null === (i = D.state) || void 0 === i ? void 0 : i.curators]);
          return (0, r.BX)(o.Kqy, {
            gap: 's',
            direction: 'column',
            align: 'start',
            width: '100%',
            children: [
              (0, r.tZ)(y.$, { children: 'Risk Disclosures' }),
              (0, r.BX)(x.T5, {
                children: [
                  (0, r.tZ)(s.xr, {
                    minWidth: '220px',
                    children: (0, r.BX)(o.Kqy, {
                      direction: 'column',
                      gap: 's',
                      children: [
                        (0, r.BX)(o.Kqy, {
                          gap: 'xxs',
                          align: 'center',
                          children: [
                            (0, r.tZ)(o.xvT.Body.XS.Regular, {
                              color: 'text.secondary',
                              lineHeight: 1,
                              children: 'Risk Score',
                            }),
                            (0, r.tZ)(o.JO$, {
                              icon: 'CredoraIconPlain62',
                              color: 'text.secondary',
                              style: { width: 62, height: 17 },
                            }),
                            (0, r.tZ)(o.ua7, {
                              content: 'Learn more about Credora methodology.',
                              children: (0, r.tZ)(o.Kqy, {
                                children: (0, r.tZ)(l.Z, {
                                  href: 'https://credora.gitbook.io/credora-network-documentation/SZXScuQdZiFKlGcITrLr/morpho-methodologies',
                                  buttonProps: {
                                    variant: 'ghost',
                                    size: 'small',
                                    iconRight: void 0,
                                    iconAlone: 'ArrowDiagonalUpPlain20',
                                    iconAloneProps: { color: 'icon.secondary' },
                                  },
                                }),
                              }),
                            }),
                            (null == q ? void 0 : q.timestamp) &&
                              (0, r.tZ)(o.ua7, {
                                content: 'Last updated: '.concat(
                                  (0, u.J)(null == q ? void 0 : q.timestamp)
                                ),
                                withTouch: !0,
                                children: (0, r.tZ)(o.JO$, {
                                  icon: 'CalendarPlain20',
                                  color: 'icon.secondary',
                                  hoverColor: 'icon.primary',
                                }),
                              }),
                          ],
                        }),
                        (0, r.tZ)(o.xvT.Body.M.Regular, {
                          children:
                            (null == M ? void 0 : M.showCredoraRating) !== !1 &&
                            (null == q ? void 0 : q.rating)
                              ? null == q
                                ? void 0
                                : q.rating
                              : (null == M ? void 0 : M.showCredoraRating) === !1
                                ? 'Not provided by Curator'
                                : 'Has not been rated yet',
                        }),
                      ],
                    }),
                  }),
                  (null !==
                    (C =
                      null === (c = D.state) || void 0 === c
                        ? void 0
                        : null === (d = c.curators) || void 0 === d
                          ? void 0
                          : d.length) && void 0 !== C
                    ? C
                    : 0) > 0 && (0, r.tZ)(B, { curators: F }),
                  (0, r.BX)(s.xr, {
                    minWidth: '220px',
                    children: [
                      (0, r.tZ)(o.xvT.Body.XS.Regular, {
                        color: 'text.secondary',
                        children: 'Vault Deployment Date',
                      }),
                      (0, r.tZ)(o.xvT.Body.M.Regular, {
                        children: (0, u.J)(
                          null !== (T = null == D ? void 0 : D.creationTimestamp) && void 0 !== T
                            ? T
                            : 0
                        ),
                      }),
                    ],
                  }),
                  (null === (h = D.state) || void 0 === h ? void 0 : h.owner) &&
                    (0, r.tZ)(s.mD, {
                      title: 'Owner',
                      toastMessage: 'Owner address copied to clipboard.',
                      tooltipMessage: 'Copy owner address.',
                      address: D.state.owner,
                      minWidth: '220px',
                    }),
                  (null === (v = D.state) || void 0 === v ? void 0 : v.curator) &&
                    (0, r.tZ)(s.mD, {
                      title: 'Curator',
                      toastMessage: 'Curator address copied to clipboard.',
                      tooltipMessage: 'Copy curator address.',
                      address: D.state.curator,
                      minWidth: '220px',
                    }),
                  (null === (p = D.factory) || void 0 === p ? void 0 : p.address) &&
                    (0, r.tZ)(g.E, {
                      chainId: R,
                      factoryAddress: null === (b = D.factory) || void 0 === b ? void 0 : b.address,
                    }),
                  (0, r.tZ)(m, {
                    title: 'Timelock / Guardian',
                    timelock:
                      null == D
                        ? void 0
                        : null === (w = D.state) || void 0 === w
                          ? void 0
                          : w.timelock,
                    address: null === (A = D.state) || void 0 === A ? void 0 : A.guardian,
                  }),
                ],
              }),
              (0, r.tZ)(k, {
                content:
                  null !== (S = null == M ? void 0 : M.disclosure) && void 0 !== S
                    ? S
                    : 'Curator has not submitted a Disclosure.',
                forumLink: null === (P = D.metadata) || void 0 === P ? void 0 : P.forumLink,
              }),
            ],
          });
        })
      );
    },
    71801: function (e, t, i) {
      'use strict';
      i.d(t, {
        default: function () {
          return K;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(12556),
        o = i(54655),
        l = i(35047),
        s = i(27410),
        d = i(33210),
        u = i(22683),
        c = i(82803),
        h = i(89991),
        v = i(4205),
        p = i(55027),
        m = i(53644),
        g = i(59934),
        y = i(34896),
        b = i(89805),
        f = i(53745),
        Z = i(66395),
        x = i(34550),
        w = i(71021),
        k = i(25596),
        B = i(83897),
        A = i(94646),
        P = i(4565),
        C = i(78017),
        T = i(40803),
        S = i(16820),
        X = i(73057);
      let R = (0, i(38819).Z)(o.Kqy, { target: 'ey3i1bb0' })(
        'animation:',
        o.bx4,
        ' 0.3s ease-in-out;'
      );
      var D = (0, n.memo)((e) => {
          let {
              vaultAddress: t,
              vaultAsset: i,
              localSimulationResult: a,
              userAddress: s,
              netApy: d,
              isLoading: u,
              performanceFee: c,
              dailyApy: h,
              rewards: v,
              points: p,
            } = e,
            { initialData: m, finalData: g } = (0, X.Z)(s, a, t, i),
            y = (0, n.useMemo)(
              () =>
                o.$0l.short
                  .digits((0, o.QQD)(i.price, m.position))
                  .trailingZero(!m.position)
                  .of(m.position, i.decimals),
              [m.position, i.decimals, i.price]
            ),
            b = (0, n.useMemo)(
              () =>
                o.$0l.short
                  .digits((0, o.QQD)(i.price, g.position))
                  .trailingZero(!g.position)
                  .of(g.position, i.decimals),
              [g.position, i.decimals, i.price]
            ),
            f = (0, n.useMemo)(() => o.$0l.percent.default('0.00').unit('%').digits(2).of(d), [d]),
            Z = (0, n.useMemo)(() => {
              let e = (0, T.I)(d, m.position, i);
              return o.$0l.short.digits(2).default('0.00').of(e, 18);
            }, [d, m.position, i]),
            x = (0, n.useMemo)(() => {
              let e = (0, T.I)(d, g.position, i);
              return o.$0l.short.digits(2).of(e, 18);
            }, [d, g.position, i]),
            w = (0, n.useMemo)(() => {
              let e = (0, T.s)(d, m.position, i);
              return o.$0l.short.digits(2).default('0.00').of(e, 18);
            }, [d, i, m.position]),
            k = (0, n.useMemo)(() => {
              let e = (0, T.s)(d, g.position, i);
              return o.$0l.short.digits(2).of(e, 18);
            }, [d, i, g.position]);
          return (0, r.BX)(o.Zbd, {
            direction: 'column',
            gap: 's',
            children: [
              (0, r.BX)(o.Kqy, {
                direction: 'column',
                gap: 'xs',
                children: [
                  (0, r.BX)(o.Kqy, {
                    align: 'center',
                    justify: 'space-between',
                    children: [
                      (0, r.tZ)(o.xvT.Body.XXS.Regular, {
                        color: 'text.secondary',
                        children: 'Your position ('.concat(i.symbol, ')'),
                      }),
                      (0, r.tZ)(o.qEK, { size: 'small', src: i.logoURI }),
                    ],
                  }),
                  (0, r.BX)(o.Kqy, {
                    align: 'center',
                    gap: 2,
                    children: [
                      u
                        ? (0, r.tZ)(o.OdW, {
                            width: '50px',
                            height: '23px',
                            borderRadius: '6px',
                            margin: '3px 0',
                          })
                        : (0, r.tZ)(o.xvT.Body.L.Regular, {
                            color: (0, l.isDefined)(g.position) ? 'text.tertiary' : 'text.primary',
                            children: y,
                          }),
                      (0, l.isDefined)(g.position) &&
                        (0, r.BX)(R, {
                          align: 'center',
                          gap: 2,
                          children: [
                            (0, r.tZ)(o.JO$, { icon: 'ArrowRightPlain20', color: 'icon.tertiary' }),
                            (0, r.tZ)(o.xvT.Body.L.Regular, { children: b }),
                          ],
                        }),
                    ],
                  }),
                ],
              }),
              (0, r.BX)(o.Kqy, {
                direction: 'column',
                gap: 'xs',
                children: [
                  (0, r.tZ)(o.xvT.Body.XXS.Regular, { color: 'text.secondary', children: 'APY' }),
                  (0, r.tZ)(C.w, {
                    RewardsHoverCardProps: {
                      performanceFee: (0, S.Pi)(c, P.safeParseNumber),
                      apy: (0, S.Pi)(h, P.safeParseNumber),
                      rewards: v,
                      points: p,
                      variant: 'vault',
                      netApy: (0, S.Pi)(d, P.safeParseNumber),
                      asset: i,
                    },
                    children: (0, r.tZ)(o.xvT.Body.L.Regular, { children: f }),
                  }),
                ],
              }),
              (0, r.BX)(o.Kqy, {
                direction: 'column',
                gap: 'xs',
                children: [
                  (0, r.tZ)(o.xvT.Body.XXS.Regular, {
                    color: 'text.secondary',
                    children: 'Projected Earnings / Month (USD)',
                  }),
                  (0, r.BX)(o.Kqy, {
                    align: 'center',
                    gap: 2,
                    children: [
                      u
                        ? (0, r.tZ)(o.OdW, {
                            width: '50px',
                            height: '23px',
                            borderRadius: '6px',
                            margin: '3px 0',
                          })
                        : (0, r.tZ)(o.xvT.Body.L.Regular, {
                            color: k ? 'text.tertiary' : 'text.primary',
                            children: w,
                          }),
                      k &&
                        (0, r.BX)(R, {
                          align: 'center',
                          gap: 2,
                          children: [
                            (0, r.tZ)(o.JO$, { icon: 'ArrowRightPlain20', color: 'icon.tertiary' }),
                            (0, r.tZ)(o.xvT.Body.L.Regular, { children: k }),
                          ],
                        }),
                    ],
                  }),
                ],
              }),
              (0, r.BX)(o.Kqy, {
                direction: 'column',
                gap: 'xs',
                children: [
                  (0, r.tZ)(o.xvT.Body.XXS.Regular, {
                    color: 'text.secondary',
                    children: 'Projected Earnings / Year (USD)',
                  }),
                  (0, r.BX)(o.Kqy, {
                    align: 'center',
                    gap: 2,
                    children: [
                      u
                        ? (0, r.tZ)(o.OdW, {
                            width: '50px',
                            height: '23px',
                            borderRadius: '6px',
                            margin: '3px 0',
                          })
                        : (0, r.tZ)(o.xvT.Body.L.Regular, {
                            color: x ? 'text.tertiary' : 'text.primary',
                            children: Z,
                          }),
                      x &&
                        (0, r.BX)(R, {
                          align: 'center',
                          gap: 2,
                          children: [
                            (0, r.tZ)(o.JO$, { icon: 'ArrowRightPlain20', color: 'icon.tertiary' }),
                            (0, r.tZ)(o.xvT.Body.L.Regular, { children: x }),
                          ],
                        }),
                    ],
                  }),
                ],
              }),
            ],
          });
        }),
        M = (0, n.memo)((e) => {
          var t, i, l, s;
          let { vaultAddress: d, vaultAsset: c, vault: v, apiState: p } = e,
            { account: P, targetChainId: C } = (0, h.Z_)(),
            { toggleRightPanel: T, isRightPanelOpen: S } = (0, o.s8G)(),
            { toggleDialog: X } = (0, o.DAv)(),
            {
              simulationError: R,
              operations: M,
              isPending: q,
              blockError: F,
              updateOperation: K,
              bundlerConfiguration: E,
            } = (0, u.N)(),
            {
              isNew: I,
              inputAmount: V,
              setInputAmount: L,
              maxAmount: O,
              isLoading: N,
              isMax: U,
              setIsMax: $,
              initialState: z,
              localOperation: _,
              confirm: W,
              cancel: H,
              peripheralTokenOptions: G,
              setIsEditing: j,
              isEditing: Q,
              onPeripheralTokenOptionChange: Y,
            } = (0, w.o)(d, { origin: 'simple-action-panel' }),
            { isReadOnly: J } = (0, a.WW)({ chainId: v.chain.id, address: d }),
            ee = P.isConnected ? z.data : p,
            [et, ei, er, en] = (0, b._)(ee, _, E, I),
            ea = (0, f.Z)(er, z.data, c.address),
            eo = (0, Z.Z)(en, null == ei ? void 0 : ei.message),
            el = (0, n.useMemo)(
              () => !!ei || !!en || (!!Q && !I) || !!J || !ea || !(0, y.H)(_),
              [Q, _, ei, I, en, ea, J]
            ),
            es = (0, k.ZP)({
              address: d,
              error: eo,
              isWrongChain: P.isWrongChain,
              chainId: v.chain.id,
            }),
            ed = (0, n.useCallback)(() => {
              I && W(), T(!0);
            }, [W, I, T]);
          (0, n.useEffect)(() => {
            S && H();
          }, [H, S]);
          let eu = (0, n.useMemo)(
              () =>
                (Q && !I) || (F && q) || !!eo || !!R || !(0, y.H)(_) || J || !ea || P.isWrongChain,
              [J, Q, I, F, q, eo, R, _, ea, P.isWrongChain]
            ),
            ec = (0, x.Z)('deposit', 0n === V, I, Q, eo, M, R, F, q, P.isWrongChain, J),
            eh = (0, n.useCallback)(() => {
              X((0, r.tZ)(A.Z, { operations: [_] }));
            }, [_, X]),
            ev = (0, B.M)(d, v.state, v.asset),
            ep = (0, o.vmq)({
              chainId: C,
              vaultAddress: v.address,
              allocation: null === (t = v.state) || void 0 === t ? void 0 : t.allocation,
            });
          return (0, r.BX)(r.HY, {
            children: [
              (0, r.BX)(o.Kqy, {
                direction: 'column',
                gap: 2,
                children: [
                  (0, r.tZ)(o.ISm, {
                    header: 'Deposit '.concat(c.symbol),
                    token: c,
                    amount: V,
                    onChange: L,
                    maxValue: O,
                    isMaxLoading: N,
                    isMax: U,
                    onMaxClick: $,
                    peripheralTokenOptions: G,
                    onPeripheralTokenChange: Y,
                    autoFocus: !0,
                    ...(!I && {
                      localErrorMessage: eo,
                      isBundlerInput: !0,
                      isEditing: Q,
                      onIsEditingChange: j,
                      onEditConfirm: W,
                      onEditCancel: H,
                      onReset: () => {
                        K(_.id);
                      },
                    }),
                  }),
                  !ea && (0, r.tZ)(m.r, { tokenAddress: c.address }),
                ],
              }),
              (0, r.tZ)(D, {
                vaultAsset: c,
                vaultAddress: d,
                localSimulationResult: et,
                userAddress: er,
                netApy: null === (i = v.state) || void 0 === i ? void 0 : i.dailyNetApy,
                performanceFee: null === (l = v.state) || void 0 === l ? void 0 : l.fee,
                dailyApy: null === (s = v.state) || void 0 === s ? void 0 : s.dailyApy,
                rewards: ev,
                isLoading: N,
                points: ep,
              }),
              (0, r.tZ)(g.N, {
                handleFinalize: eh,
                handleConfirm: ed,
                isLoading: N,
                isNew: I,
                finalizeLabel: ec,
                tooltipContent: es,
                isFinalizeDisabled: eu,
                isConfirmDisabled: el,
              }),
            ],
          });
        }),
        q = i(48972),
        F = (0, n.memo)((e) => {
          var t, i, l, s;
          let { vaultAddress: d, vaultAsset: c, vault: v, apiState: p } = e,
            { account: w, targetChainId: P } = (0, h.Z_)(),
            { toggleRightPanel: C, isRightPanelOpen: T } = (0, o.s8G)(),
            { toggleDialog: S } = (0, o.DAv)(),
            {
              simulationError: X,
              operations: R,
              blockError: M,
              isPending: F,
              updateOperation: K,
              bundlerConfiguration: E,
            } = (0, u.N)(),
            {
              isNew: I,
              inputAmount: V,
              setInputAmount: L,
              maxAmount: O,
              isLoading: N,
              isMax: U,
              setIsMax: $,
              initialState: z,
              localOperation: _,
              confirm: W,
              cancel: H,
              setIsEditing: G,
              isEditing: j,
            } = (0, q.L)(d, { origin: 'simple-action-panel' }),
            { isReadOnly: Q } = (0, a.WW)({ chainId: v.chain.id, address: d }),
            Y = w.isConnected ? z.data : p,
            [J, ee, et, ei] = (0, b._)(Y, _, E, !1),
            er = (0, Z.Z)(ei, null == ee ? void 0 : ee.message),
            en = (0, f.Z)(et, z.data, c.address),
            ea = (0, n.useMemo)(
              () => !!ee || !!ei || (!!j && !I) || !en || !(0, y.H)(_),
              [j, _, ee, I, ei, en]
            ),
            eo = (0, n.useCallback)(() => {
              I && W(), C(!0);
            }, [W, I, C]);
          (0, n.useEffect)(() => {
            T && H();
          }, [H, T]);
          let el = (0, n.useMemo)(
              () =>
                (j && !I) || (M && F) || !!er || !!X || !(0, y.H)(_) || Q || w.isWrongChain || !en,
              [j, I, M, F, er, X, _, Q, w.isWrongChain, en]
            ),
            es = (0, x.Z)('withdrawal', 0n === V, I, j, er, R, X, M, F, w.isWrongChain, Q),
            ed = (0, k.ZP)({
              address: d,
              error: er,
              isWrongChain: w.isWrongChain,
              chainId: v.chain.id,
            }),
            eu = (0, n.useCallback)(() => {
              S((0, r.tZ)(A.Z, { operations: [_] }));
            }, [_, S]),
            ec = (0, B.M)(d, v.state, v.asset),
            eh = (0, o.vmq)({
              chainId: P,
              vaultAddress: v.address,
              allocation: null === (t = v.state) || void 0 === t ? void 0 : t.allocation,
            });
          return (0, r.BX)(r.HY, {
            children: [
              (0, r.BX)(o.Kqy, {
                direction: 'column',
                gap: 2,
                children: [
                  (0, r.tZ)(o.ISm, {
                    header: 'Withdraw '.concat(c.symbol),
                    token: c,
                    amount: V,
                    onChange: L,
                    maxValue: O,
                    isMaxLoading: N,
                    isMax: U,
                    onMaxClick: $,
                    autoFocus: !0,
                    ...(!I && {
                      localErrorMessage: er,
                      isBundlerInput: !0,
                      isEditing: j,
                      onIsEditingChange: G,
                      onEditConfirm: W,
                      onEditCancel: H,
                      onReset: () => {
                        K(_.id);
                      },
                    }),
                  }),
                  !en && (0, r.tZ)(m.r, { tokenAddress: c.address }),
                ],
              }),
              (0, r.tZ)(D, {
                vaultAsset: c,
                vaultAddress: d,
                localSimulationResult: J,
                userAddress: et,
                netApy: null === (i = v.state) || void 0 === i ? void 0 : i.dailyNetApy,
                performanceFee: null === (l = v.state) || void 0 === l ? void 0 : l.fee,
                dailyApy: null === (s = v.state) || void 0 === s ? void 0 : s.dailyApy,
                rewards: ec,
                isLoading: N,
                points: eh,
              }),
              (0, r.tZ)(g.N, {
                handleFinalize: eu,
                handleConfirm: eo,
                isLoading: N,
                isNew: I,
                finalizeLabel: es,
                tooltipContent: ed,
                isFinalizeDisabled: el,
                isConfirmDisabled: ea,
              }),
            ],
          });
        }),
        K = (0, n.memo)(
          (0, d.Z)((e) => {
            let { vaultAddress: t, queryResult: i } = e,
              {
                operations: d,
                config: { addVaults: m, addMarketIds: g, addTokens: y },
              } = (0, u.N)(),
              { account: b } = (0, h.Z_)(),
              f = (0, v.f)(0),
              Z = (0, n.useMemo)(() => (0, p.o)(i.data), [i.data]),
              [x, w] = (0, n.useState)(c.H.InterfaceOperationType.metaMorphoDeposit);
            (0, n.useEffect)(() => {
              b.isConnected &&
                (m(...(0, l.keys)(Z.vaults)),
                y(...(0, l.keys)(Z.tokens)),
                g(...(0, l.keys)(Z.markets)));
            }, [b.isConnected, Z.vaults, Z.tokens, Z.markets, m, y, g]);
            let k = i.data.vaultByAddress,
              B = (0, n.useMemo)(() => (0, a.wk)(k.asset), [k.asset]),
              A = (0, n.useMemo)(() => {
                var e;
                let i = b.address;
                if (!i) return !1;
                let r = d.some(
                    (e) =>
                      (e.type === c.H.InterfaceOperationType.metaMorphoDeposit ||
                        e.type === c.H.InterfaceOperationType.metaMorphoWithdraw) &&
                      e.vaultAddress === t
                  ),
                  n = !!(null === (e = f.data) || void 0 === e
                    ? void 0
                    : e.getBundleBalance(i, t, !0));
                return r || n;
              }, [b.address, f.data, d, t]);
            return (
              (0, n.useEffect)(() => {
                A || w(c.H.InterfaceOperationType.metaMorphoDeposit);
              }, [A]),
              (0, r.BX)(o.Kqy, {
                direction: 'column',
                gap: 's',
                basis: '100%',
                'data-testid': 'vault-action-panel',
                children: [
                  A &&
                    (0, r.BX)(o.Kqy, {
                      gap: 4,
                      justify: 'stretch',
                      align: 'center',
                      children: [
                        (0, r.tZ)(s.Z, {
                          type: c.H.InterfaceOperationType.metaMorphoDeposit,
                          onClick: () => w(c.H.InterfaceOperationType.metaMorphoDeposit),
                          label: 'Deposit',
                          currentType: x,
                        }),
                        (0, r.tZ)(s.Z, {
                          type: c.H.InterfaceOperationType.metaMorphoWithdraw,
                          onClick: () => {
                            w(c.H.InterfaceOperationType.metaMorphoWithdraw);
                          },
                          label: 'Withdraw',
                          currentType: x,
                        }),
                      ],
                    }),
                  x === c.H.InterfaceOperationType.metaMorphoDeposit &&
                    (0, r.tZ)(M, { vaultAddress: t, vault: k, vaultAsset: B, apiState: Z }),
                  x === c.H.InterfaceOperationType.metaMorphoWithdraw &&
                    (0, r.tZ)(F, { vaultAddress: t, vault: k, vaultAsset: B, apiState: Z }),
                ],
              })
            );
          })
        );
    },
    55027: function (e, t, i) {
      'use strict';
      i.d(t, {
        o: function () {
          return d;
        },
      });
      var r,
        n = i(68612),
        a = i(40252),
        o = i(35047),
        l = i(51196),
        s = i(27987);
      let d = function (e) {
        var t,
          i,
          d,
          u,
          c,
          h,
          v,
          p,
          m,
          g,
          y,
          b,
          f,
          Z,
          x,
          w,
          k,
          B,
          A,
          P,
          C,
          T,
          S,
          X,
          R,
          D,
          M,
          q,
          F,
          K,
          E,
          I,
          V,
          L,
          O,
          N;
        let U =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : new l.SimulationState({
                  chainId: e.vaultByAddress.chain.id,
                  block: {
                    number: 0n,
                    timestamp:
                      null !==
                        (r =
                          null === (N = e.vaultByAddress.state) || void 0 === N
                            ? void 0
                            : N.timestamp) && void 0 !== r
                        ? r
                        : 0n,
                  },
                  tokens: {},
                  markets: {},
                  vaultMarketConfigs: {},
                  vaults: {},
                  users: {},
                  positions: {},
                  holdings: {},
                }),
          $ = e.vaultByAddress,
          z = $.chain.id;
        (null !== (k = (d = U.vaults)[(u = $.address)]) && void 0 !== k) ||
          (d[u] = s.Z.getVault($)),
          (null !== (B = (c = U.users)[(h = $.address)]) && void 0 !== B) ||
            (c[h] = new a.User({ address: $.address, isBundlerAuthorized: !1, morphoNonce: 0n })),
          (null !== (A = (v = U.tokens)[(p = $.asset.address)]) && void 0 !== A) ||
            (v[p] = s.Z.getToken($.asset)),
          (null !== (P = (m = U.tokens)[(g = $.address)]) && void 0 !== P) ||
            (m[g] = s.Z.getToken({ ...$, decimals: 18 })),
          (null !==
            (T = (f =
              null !== (C = (y = U.holdings)[(b = $.address)]) && void 0 !== C ? C : (y[b] = {}))[
              (Z = $.asset.address)
            ]) &&
            void 0 !== T) ||
            (f[Z] = new a.Holding({
              user: $.address,
              token: $.asset.address,
              balance: 0n,
              erc20Allowances: { morpho: n.zL, permit2: 0n, 'bundler3.generalAdapter1': 0n },
              permit2BundlerAllowance: { amount: 0n, expiration: 0n, nonce: 0n },
            })),
          null === (i = $.state) ||
            void 0 === i ||
            null === (t = i.allocation) ||
            void 0 === t ||
            t.forEach((e) => {
              var t, i, r, n, o, l, d, u, c, h, v, p, m, g, y, b, f, Z, x, w, k;
              let {
                market: { collateralAsset: B, loanAsset: A },
              } = e;
              B &&
                ((null !== (y = (t = U.tokens)[(i = B.address)]) && void 0 !== y) ||
                  (t[i] = s.Z.getToken(B))),
                (null !== (b = (r = U.tokens)[(n = A.address)]) && void 0 !== b) ||
                  (r[n] = s.Z.getToken(A));
              let P = s.Z.getVaultMarketAllocation($.address, e, $.publicAllocatorConfig);
              (P.position.market.lastUpdate = a.MathLib.min(
                P.position.market.lastUpdate,
                U.block.timestamp
              )),
                (null !== (f = (o = U.markets)[(l = P.marketId)]) && void 0 !== f) ||
                  (o[l] = P.position.market),
                (null !==
                  (x = (c =
                    null !== (Z = (d = U.positions)[(u = $.address)]) && void 0 !== Z
                      ? Z
                      : (d[u] = {}))[(h = P.marketId)]) &&
                  void 0 !== x) ||
                  (c[h] = P.position),
                (null !==
                  (k = (m =
                    null !== (w = (v = U.vaultMarketConfigs)[(p = $.address)]) && void 0 !== w
                      ? w
                      : (v[p] = {}))[(g = P.marketId)]) &&
                  void 0 !== k) ||
                  (m[g] = P.config);
            });
        let { bundler3: _ } = (0, a.getChainAddresses)(z);
        for (let e of ((null !== (S = (x = U.users)[(w = _.generalAdapter1)]) && void 0 !== S) ||
          (x[w] = new a.User({
            address: _.generalAdapter1,
            isBundlerAuthorized: !1,
            morphoNonce: 0n,
          })),
        (0, o.values)(U.tokens)))
          e &&
            ((null !==
              (F = (D =
                null !== (q = (X = U.holdings)[(R = _.generalAdapter1)]) && void 0 !== q
                  ? q
                  : (X[R] = {}))[(M = e.address)]) &&
              void 0 !== F) ||
              (D[M] = new a.Holding({
                user: _.generalAdapter1,
                token: e.address,
                balance: 0n,
                erc20Allowances: { morpho: n.zL, permit2: 0n, 'bundler3.generalAdapter1': 0n },
                permit2BundlerAllowance: { amount: 0n, expiration: 0n, nonce: 0n },
              })));
        for (let e of (0, o.values)(U.markets))
          e &&
            ((null !==
              (O = (I =
                null !== (L = (K = U.positions)[(E = _.generalAdapter1)]) && void 0 !== L
                  ? L
                  : (K[E] = {}))[(V = e.id)]) &&
              void 0 !== O) ||
              (I[V] = new a.Position({
                user: _.generalAdapter1,
                marketId: e.id,
                supplyShares: 0n,
                borrowShares: 0n,
                collateral: 0n,
              })));
        return U;
      };
    },
    84478: function (e, t, i) {
      'use strict';
      i.d(t, {
        default: function () {
          return C;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(12556),
        o = i(54655),
        l = i(35047),
        s = i(77345),
        d = i(81919),
        u = i(76992),
        c = i(33210),
        h = i(18313),
        v = i(26726),
        p = i(89991),
        m = i(93319),
        g = i(34937),
        y = i(57935),
        b = i(83669),
        f = i(243),
        Z = i(55412),
        x = i(3245),
        w = i(41512),
        k = i(24387);
      function B() {
        let e = (0, Z._)([
          '\n  query GetUserVaultPositionHistoryTimeseries(\n    $userAddress: String!\n    $vaultAddress: String!\n    $chainId: Int!\n    $options: TimeseriesOptions\n    $fetchAssets: Boolean!\n    $fetchAssetsUsd: Boolean!\n  ) {\n    vaultPosition(\n      userAddress: $userAddress\n      vaultAddress: $vaultAddress\n      chainId: $chainId\n    ) {\n      id\n      assets\n      assetsUsd\n      vault {\n        id\n        address\n        asset {\n          ...assetFields\n        }\n      }\n      historicalState {\n        assets(options: $options) @include(if: $fetchAssets) {\n          x\n          y\n        }\n        assetsUsd(options: $options) @include(if: $fetchAssetsUsd) {\n          x\n          y\n        }\n      }\n    }\n  }\n  ',
          '\n  ',
          '\n',
        ]);
        return (
          (B = function () {
            return e;
          }),
          e
        );
      }
      let A = (0, x.Ps)(B(), w.n, k.G),
        P = o.$0l.short.trailingZero(!1).default('0.00');
      var C = (0, n.memo)(
        (0, c.Z)((e) => {
          var t, i, c, Z, x, w;
          let { queryVariables: k, queryResult: B, now: C, positionManagerSlot: T } = e,
            { palette: S } = (0, o.rFV)(),
            X = (0, o.dD4)(),
            { account: R } = (0, p.Z_)(),
            D = (0, v.nh)(v.TP.POSITION_HISTORY),
            [M, q] = (0, n.useState)(h.B),
            [F, K] = (0, n.useState)('assets'),
            E = (0, n.useMemo)(() => {
              var e;
              return {
                ...k,
                userAddress: null !== (e = R.address) && void 0 !== e ? e : '',
                fetchAssets: 'assets' === F,
                fetchAssetsUsd: 'assetsUsd' === F,
                options: (0, g.Ai)({ timeFrame: M, now: C }),
              };
            }, [F, C, M, k, R.address]),
            I = (0, b.s)({
              queryDocument: A,
              queryVariables: E,
              serverQueryResult: B,
              serverQueryVariables: k,
            }),
            { targetChainId: V } = (0, p.Z_)(),
            {
              data: L,
              loading: O,
              isNotFound: N,
              error: U,
            } = (0, n.useMemo)(() => (0, f.I)(I), [I]),
            { data: $ } = (0, s.sW)({
              variables: { where: { address_in: [k.vaultAddress], chainId_in: [V] } },
              skip: !R.address,
            }),
            { positions: z } = (0, y.w)({
              existingPositions: (0, l.isDefined)(null == L ? void 0 : L.vaultPosition)
                ? [L.vaultPosition]
                : [],
              missingVaults:
                null !== (w = null == $ ? void 0 : $.vaults.items) && void 0 !== w ? w : [],
            }),
            _ = (0, n.useMemo)(
              () => (null == z ? void 0 : z.find((e) => e.vault.address === k.vaultAddress)),
              [z, k.vaultAddress]
            ),
            W = (0, n.useMemo)(
              () => (0, a.wk)(null == _ ? void 0 : _.vault.asset),
              [null == _ ? void 0 : _.vault.asset]
            ),
            H = (0, n.useMemo)(() => {
              let e = [];
              return (
                (null == W ? void 0 : W.symbol) && e.push({ value: 'assets', label: W.symbol }),
                e.push({ value: 'assetsUsd', label: 'USD' }),
                e
              );
            }, [null == W ? void 0 : W.symbol]),
            G = (0, n.useMemo)(() => (N ? void 0 : U), [N, U]),
            j = (0, n.useMemo)(() => {
              var e, t, i, r;
              let n = [];
              switch (F) {
                case 'assets':
                  n = (0, o.EES)(
                    null == L
                      ? void 0
                      : null === (e = L.vaultPosition.historicalState) || void 0 === e
                        ? void 0
                        : e.assets,
                    null !==
                      (i =
                        null == L
                          ? void 0
                          : null === (t = L.vaultPosition.vault.asset) || void 0 === t
                            ? void 0
                            : t.decimals) && void 0 !== i
                      ? i
                      : 18
                  );
                  break;
                case 'assetsUsd':
                  n = (0, o.EES)(
                    null == L
                      ? void 0
                      : null === (r = L.vaultPosition.historicalState) || void 0 === r
                        ? void 0
                        : r.assetsUsd
                  );
              }
              return (0, o.q6y)(n);
            }, [
              null == L
                ? void 0
                : null === (t = L.vaultPosition.historicalState) || void 0 === t
                  ? void 0
                  : t.assets,
              null == L
                ? void 0
                : null === (i = L.vaultPosition.historicalState) || void 0 === i
                  ? void 0
                  : i.assetsUsd,
              null == L
                ? void 0
                : null === (c = L.vaultPosition.vault.asset) || void 0 === c
                  ? void 0
                  : c.decimals,
              F,
            ]),
            Q = (0, n.useMemo)(() => !(0, o.ckA)(j), [j]),
            Y = (0, n.useMemo)(() => (0, l.isDefined)(_), [_]),
            J = (0, a.DI)(null == _ ? void 0 : _.simulatedValues.assets.value),
            ee = (0, a.DI)(null == _ ? void 0 : _.simulatedValues.assetsUsd.value),
            et = (0, n.useMemo)(() => {
              switch (F) {
                case 'assets':
                  var e, t, i;
                  return {
                    value: J,
                    decimals:
                      null !==
                        (i =
                          null == _
                            ? void 0
                            : null === (t = _.vault) || void 0 === t
                              ? void 0
                              : null === (e = t.asset) || void 0 === e
                                ? void 0
                                : e.decimals) && void 0 !== i
                        ? i
                        : 18,
                  };
                case 'assetsUsd':
                  return { value: ee, decimals: 18 };
              }
            }, [
              F,
              J,
              null == _
                ? void 0
                : null === (x = _.vault) || void 0 === x
                  ? void 0
                  : null === (Z = x.asset) || void 0 === Z
                    ? void 0
                    : Z.decimals,
              ee,
            ]),
            ei = (0, n.useMemo)(
              () =>
                (0, m.l)(
                  P.digits((0, o.QQD)(null == W ? void 0 : W.price, et.value))
                    .trailingZero(!et.value)
                    .of(et.value, et.decimals)
                ),
              [et, null == W ? void 0 : W.price]
            ),
            er = (0, n.useMemo)(
              () =>
                (null == _ ? void 0 : _.simulatedValues.assets.isSimulated) ||
                (null == _ ? void 0 : _.isNew),
              [
                null == _ ? void 0 : _.simulatedValues.assets.isSimulated,
                null == _ ? void 0 : _.isNew,
              ]
            ),
            en = (0, n.useMemo)(() => {
              var e;
              let t =
                  null === (e = H.find((e) => e.value === F)) || void 0 === e ? void 0 : e.label,
                i = 'My Deposit';
              return t ? ''.concat(i, ' (').concat(t, ')') : i;
            }, [F, H]),
            ea = (0, n.useMemo)(() => {
              var e;
              return 'assetsUsd' === F
                ? '$'
                : (0, l.formatLongString)(
                    null !== (e = null == W ? void 0 : W.symbol) && void 0 !== e ? e : ''
                  );
            }, [F, null == W ? void 0 : W.symbol]);
          return (0, r.BX)(o.Zbd, {
            fullWidth: !0,
            gap: 'm',
            direction: 'column',
            paddingBlock: 'm',
            paddingInline: { base: 'm', s: 's' },
            children: [
              (0, r.BX)(o.Kqy, {
                justify: 'space-between',
                align: 'center',
                gap: 's',
                wrap: 'wrap',
                children: [
                  (0, r.BX)(o.Kqy, {
                    direction: 'column',
                    gap: 'xs',
                    children: [
                      (0, r.BX)(o.Kqy, {
                        gap: 'xs',
                        align: 'center',
                        children: [
                          (0, r.tZ)(o.xvT.Body.XS.Regular, {
                            color: 'text.secondary',
                            children: en,
                          }),
                          T,
                        ],
                      }),
                      O && null === et.value
                        ? (0, r.BX)(o.Kqy, {
                            gap: 's',
                            align: 'center',
                            children: [
                              (0, r.tZ)(o.OdW, {
                                height: '46px',
                                width: '130px',
                                borderRadius: '20px',
                              }),
                              (0, r.tZ)(o.OdW, {
                                height: '26px',
                                width: '50px',
                                borderRadius: '120px',
                              }),
                            ],
                          })
                        : (0, r.BX)(o.Kqy, {
                            gap: 's',
                            align: 'center',
                            children: [
                              (0, r.BX)(o.Kqy, {
                                gap: 2,
                                align: 'center',
                                children: [
                                  'assetsUsd' === F &&
                                    (0, r.tZ)(o.ZT$, {
                                      TextVariant: o.xvT.Title.S,
                                      isSimulated: er,
                                      color: 'text.tertiary',
                                      children: '$',
                                    }),
                                  (0, r.tZ)(o.ZT$, {
                                    TextVariant: o.xvT.Title.S,
                                    isSimulated: er,
                                    children: ei.value,
                                  }),
                                  (0, r.tZ)(o.ZT$, {
                                    TextVariant: o.xvT.Title.S,
                                    isSimulated: er,
                                    color: 'text.tertiary',
                                    children: ei.unit,
                                  }),
                                ],
                              }),
                              D &&
                                (0, r.tZ)(r.HY, {
                                  children: O
                                    ? (0, r.tZ)(o.OdW, {
                                        height: '18px',
                                        width: '50px',
                                        borderRadius: '120px',
                                      })
                                    : (0, r.tZ)(d.Z, { formattedData: j }),
                                }),
                            ],
                          }),
                    ],
                  }),
                  (0, r.BX)(o.Kqy, {
                    align: 'center',
                    gap: 's',
                    wrap: 'wrap',
                    children: [
                      X
                        ? (0, r.tZ)(o.PhF, { options: H, value: F, onChange: K, disabled: !Y })
                        : (0, r.tZ)(u.E, {
                            variant: 'secondary',
                            id: 'chart-options-mode',
                            options: H,
                            value: F,
                            onChange: K,
                            disabled: !Y,
                          }),
                      (0, r.tZ)(o.PhF, {
                        options: h.SC,
                        value: M,
                        onChange: q,
                        disabled: !Y || !D,
                      }),
                    ],
                  }),
                ],
              }),
              D
                ? (0, r.tZ)(o._9J, {
                    statuses: { loading: O, error: G },
                    unit: ea,
                    height: '224px',
                    series: Q
                      ? [
                          {
                            type: 'areaspline',
                            name: 'Total '.concat(F),
                            data: j,
                            color: S.colors[0],
                            lineColor: S.colors[0],
                            fillColor: S.areaChartColors[0],
                          },
                        ]
                      : [],
                    additionalOptions: { yAxis: { softMin: 0, maxPadding: 0.4 } },
                  })
                : (0, r.tZ)(o.SKT, {
                    text: 'Position history is temporarily unavailable.',
                    height: '224px',
                  }),
            ],
          });
        })
      );
    },
    81919: function (e, t, i) {
      'use strict';
      var r = i(78286),
        n = i(58258),
        a = i(54655),
        o = i(4366);
      let l = (e) => {
          var t, i, r;
          let n = null === (t = e[0]) || void 0 === t ? void 0 : t[1],
            a = null === (i = e[e.length - 1]) || void 0 === i ? void 0 : i[1];
          if ('number' != typeof n || 'number' != typeof a) return { hasChange: !1 };
          let o =
            n ||
            (null === (r = e.find((e) => null !== e[1] && e[1] > 0)) || void 0 === r
              ? void 0
              : r[1]);
          return o
            ? { percentageChange: (a - o) / o, rawChange: a - o, hasChange: !0 }
            : { hasChange: !1 };
        },
        s = { percentageChange: 'Click to show $ change.', rawChange: 'Click to show % change.' };
      t.Z = (0, n.memo)((e) => {
        let { formattedData: t } = e,
          [i, d] = (0, n.useState)(!0),
          {
            percentageChange: u,
            rawChange: c,
            hasChange: h,
          } = (0, n.useMemo)(() => l(null != t ? t : []), [t]),
          v = (0, n.useMemo)(
            () =>
              i
                ? a.$0l.percent.default('-').digits(2).unit('%').sign().trailingZero(!1).of(u)
                : a.$0l.short.unit('$').sign().digits(2).readable().of(c),
            [i, u, c]
          );
        return h && t
          ? (0, r.tZ)(a.ua7, {
              content: s[i ? 'percentageChange' : 'rawChange'],
              children: (0, r.tZ)(a.Vp9, {
                className: o.DashboardClass.PREVENT_DASHBOARD_CARD_HOVER_CLASS,
                variant: 'pnl',
                label: v,
                onClick: () => d((e) => !e),
              }),
            })
          : null;
      });
    },
    5500: function (e, t, i) {
      'use strict';
      i.d(t, {
        _: function () {
          return d;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(99079),
        o = i(3808),
        l = i(16102),
        s = i(54655);
      function d(e) {
        let { timestamp: t } = e;
        if (void 0 === t) return (0, r.tZ)(s.OdW, { height: 26 });
        if (null === t) return (0, r.tZ)(r.HY, {});
        let i = (0, a.K)(Number(t));
        return (0, r.tZ)(s.ua7, {
          content: (0, o.s)(i),
          children: (0, r.tZ)(s.xvT.Body.XS.Regular, {
            color: 'text.body',
            children: (0, l.U)(i, new Date()),
          }),
        });
      }
      t.Z = (0, n.memo)(d);
    },
    76992: function (e, t, i) {
      'use strict';
      i.d(t, {
        E: function () {
          return p;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(54655),
        o = i(50825),
        l = i(38819),
        s = i(16690);
      let d = (0, l.Z)('div', { target: 'eikqm6p0' })(
          'background-color:',
          (e) => {
            let { theme: t, backgroundVariant: i } = e;
            return 'primary' === i ? t.colors.background.primary : t.colors.constant.dark;
          },
          ';padding:',
          (e) => {
            let { noPadding: t } = e;
            return t ? '0px' : '3px';
          },
          ';display:flex;gap:',
          (e) => {
            let { noGap: t } = e;
            return t ? '0px' : '4px';
          },
          ';border-radius:100px;height:fit-content;'
        ),
        u = (0, l.Z)('div', { target: 'eikqm6p1' })('position:relative;'),
        c = (0, l.Z)(a.Kqy, { target: 'eikqm6p2' })(
          'position:absolute;top:0px;right:0px;background-color:',
          (e) => {
            let { theme: t } = e;
            return t.colors.icon.brand;
          },
          ';width:14px;height:14px;border-radius:50%;display:flex;justify-content:center;align-items:center;text-align:center;',
          (0, s.animationCubicBezier)(s.popUpScale, '300ms'),
          ';& >:first-of-type{transform:translate(0.2px,0.4px);font-size:8px;}',
          (e) => {
            let { theme: t } = e;
            return t.breakpoints.down('s');
          },
          '{top:-5px !important;right:-5px !important;}'
        ),
        h = (0, l.Z)(a.ZT$, { target: 'eikqm6p3' })(
          'transform:translate(0.2px,0.5px);font-size:8px;'
        ),
        v = (0, n.forwardRef)(function (e, t) {
          let {
            options: i,
            id: n,
            value: l,
            noPadding: s = !1,
            noGap: v = !1,
            disabled: p = !1,
            variant: m = 'primary',
            backgroundVariant: g = 'primary',
            size: y = 'small',
            className: b,
            onChange: f,
            ...Z
          } = e;
          return (0, r.tZ)(d, {
            noPadding: s,
            noGap: v,
            backgroundVariant: g,
            ref: t,
            className: b,
            ...Z,
            children: i.map((e) =>
              (0, r.tZ)(
                a.ua7,
                {
                  disabled: !e.tooltip,
                  content: e.tooltip,
                  offset: s ? 4 : 9,
                  children: (0, r.BX)(u, {
                    children: [
                      e.href
                        ? (0, r.tZ)(o.Z, {
                            href: e.href,
                            prefetch: e.prefetch,
                            mode: 'internal',
                            buttonProps: {
                              variant: e.value === l ? m : 'ghost',
                              size: y,
                              disabled: p || e.isDisabled,
                              label: e.label,
                              iconAlone: e.icon,
                              onClick: () => (null == f ? void 0 : f(e.value)),
                            },
                          })
                        : (0, r.tZ)(a.zxk, {
                            variant: e.value === l ? m : 'ghost',
                            size: y,
                            disabled: p || e.isDisabled,
                            label: e.label,
                            iconAlone: e.icon,
                            onClick: () => (null == f ? void 0 : f(e.value)),
                          }),
                      e.counter && e.counter > 0
                        ? (0, r.tZ)(c, {
                            children: (0, r.tZ)(h, {
                              TextVariant: a.xvT.Body.XXXS.Regular,
                              children: e.counter,
                            }),
                          })
                        : null,
                    ],
                  }),
                },
                n + e.value
              )
            ),
          });
        });
      var p = (0, n.memo)(v);
    },
    59934: function (e, t, i) {
      'use strict';
      i.d(t, {
        N: function () {
          return s;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(54655),
        o = i(89991);
      let l = (0, i(38819).Z)(a.Kqy, { target: 'ernm57p0' })(
        'padding-bottom:',
        (e) => {
          let { theme: t } = e;
          return t.spacing.s;
        },
        ';',
        (e) => {
          let { theme: t } = e;
          return t.breakpoints.down('s');
        },
        '{order:-1;padding-bottom:0;}'
      );
      var s = (0, n.memo)((e) => {
        let {
            isLoading: t,
            isNew: i,
            handleFinalize: n,
            handleConfirm: s,
            finalizeLabel: d,
            tooltipContent: u,
            isFinalizeDisabled: c,
            isConfirmDisabled: h,
          } = e,
          { account: v, modal: p } = (0, o.Z_)(),
          m = (0, a.ajf)('s');
        return (0, r.tZ)(r.HY, {
          children: v.isConnected
            ? (0, r.tZ)(a.Kqy, {
                direction: 'column',
                gap: 8,
                align: 'stretch',
                justify: 'start',
                style: { paddingBottom: 12 },
                children: t
                  ? (0, r.tZ)(a.zxk, {
                      variant: 'secondary',
                      size: 'big',
                      disabled: !0,
                      iconLeft: 'AlertPlain20',
                      label: 'Loading onchain state',
                    })
                  : (0, r.BX)(r.HY, {
                      children: [
                        (0, r.tZ)(a.ua7, {
                          content: u,
                          disabled: !u,
                          children: (0, r.tZ)(a.zxk, {
                            size: 'big',
                            autoCapitalize: 'on',
                            variant: c ? 'secondary' : 'primary',
                            label: d,
                            disabled: c,
                            onClick: n,
                            shortenByWidth: 220,
                            'data-testid': 'finalize-button',
                          }),
                        }),
                        !m &&
                          !h &&
                          (0, r.tZ)(a.zxk, {
                            autoCapitalize: 'on',
                            variant: 'secondary',
                            size: 'big',
                            onClick: s,
                            label: i ? 'Add to bundler' : 'View in bundler',
                            'data-testid': 'add-to-bundler-button',
                          }),
                      ],
                    }),
              })
            : (0, r.tZ)(l, {
                direction: 'column',
                gap: 8,
                align: 'stretch',
                justify: 'start',
                children: (0, r.tZ)(a.zxk, {
                  variant: 'primary',
                  size: 'big',
                  onClick: () => p.open(),
                  label: 'Connect Wallet',
                }),
              }),
        });
      });
    },
    66888: function (e, t, i) {
      'use strict';
      i.d(t, {
        u: function () {
          return n;
        },
        Z: function () {
          return F;
        },
      });
      var r,
        n,
        a = i(78286),
        o = i(58258),
        l = i(99095),
        s = i(54655),
        d = i(38819),
        u = i(15328),
        c = i(25834),
        h = i(12556),
        v = i(82078),
        p = i(50825),
        m = i(98949),
        g = i(82803),
        y = i(75147),
        b = i(89991),
        f = i(40816);
      let Z = (0, d.Z)(s.Kqy, { target: 'ef7kvr40' })('width:100%;'),
        x = (0, d.Z)(s.zxk, { target: 'ef7kvr41' })('margin-left:auto;'),
        w = (0, d.Z)(s.Kqy, { target: 'ef7kvr42' })(
          'background-color:',
          (e) => {
            let { theme: t } = e;
            return t.colors.background.tertiary;
          },
          ';border-radius:10px;width:100%;'
        ),
        k = (0, o.memo)(() => {
          var e, t;
          let { toggleDialog: i } = (0, s.DAv)(),
            { targetChainId: r, account: n } = (0, b.Z_)(),
            { setActiveBundle: l } = (0, y.H)(),
            { legacyMorphoHolding: d, morphoHolding: Z } = (0, m.gz)(),
            [k, B] = (0, u._)('morpho.useOnchainApprove', !1),
            A = (0, o.useMemo)(() => {
              var e, t;
              return s.$0l.short
                .digits(2)
                .min(0.01)
                .of(
                  null !== (t = null === (e = d.value) || void 0 === e ? void 0 : e.balance) &&
                    void 0 !== t
                    ? t
                    : 0n,
                  18
                );
            }, [null === (e = d.value) || void 0 === e ? void 0 : e.balance]),
            P = (0, o.useMemo)(() => {
              var e, t;
              return s.$0l.short
                .digits(2)
                .min(0.01)
                .of(
                  null !== (t = null === (e = Z.value) || void 0 === e ? void 0 : e.balance) &&
                    void 0 !== t
                    ? t
                    : 0n,
                  18
                );
            }, [null === (t = Z.value) || void 0 === t ? void 0 : t.balance]),
            C = (0, o.useMemo)(() => {
              var e;
              if (!n.address) return;
              let t = n.address,
                i = new c.ActionBundleRequirements(),
                a = [];
              if (null === (e = d.value) || void 0 === e ? void 0 : e.balance) {
                let e = (0, f.S)({
                  amount: d.value.balance,
                  userAddress: t,
                  supportsSignatures: !k && !n.isContract,
                  bundlerAllowance: d.value.erc20Allowances['bundler3.generalAdapter1'],
                  erc2612Nonce: d.value.erc2612Nonce,
                  chainId: r,
                });
                e &&
                  (a.push(...e.actions),
                  i.signatures.push(...e.requirements.signatures),
                  i.txs.push(...e.requirements.txs));
              }
              return new c.ActionBundle(r, a, i);
            }, [n.address, n.isContract, d.value, r, k]),
            T = (0, o.useCallback)(() => {
              C &&
                (l(C, [
                  {
                    id: 'wrap',
                    type: g.H.InterfaceOperationType.wrap,
                    options: { isMax: [], disabledPeripheralTokens: new Set() },
                  },
                ]),
                i((0, a.tZ)(v.Z, {}), { closable: !1 }));
            }, [C, l, i]);
          return (0, a.BX)(s.Kqy, {
            direction: 'column',
            align: 'center',
            justify: 'center',
            gap: 24,
            children: [
              (0, a.tZ)(x, {
                variant: 'secondary',
                iconAlone: 'ClosePlain20',
                onClick: () => i(!1),
              }),
              (0, a.tZ)(s.qEK, {
                src: 'https://cdn.morpho.org/assets/logos/morpho.svg',
                padding: 0,
                style: { width: '40px', height: '40px' },
              }),
              (0, a.tZ)(s.xvT.Title.S, {
                textAlign: 'center',
                children: 'Wrap your legacy MORPHO',
              }),
              (0, a.tZ)(s.xvT.Body.M.Regular, {
                textAlign: 'center',
                children: 'The Morpho DAO has enabled transferability for the MORPHO token!',
              }),
              (0, a.tZ)(s.xvT.Body.M.Regular, {
                textAlign: 'center',
                children:
                  'Holders of legacy MORPHO tokens on Ethereum will need to wrap their tokens to enable transferability.',
              }),
              (0, a.BX)(s.Kqy, {
                direction: 'column',
                gap: 's',
                align: 'center',
                children: [
                  (0, a.tZ)(s.zxk, {
                    size: 'big',
                    variant: 'primary',
                    label: 'Wrap MORPHO',
                    onClick: T,
                  }),
                  (0, a.tZ)(p.Z, {
                    href: h.IA,
                    buttonProps: { variant: 'secondary', size: 'small', label: 'FAQ' },
                  }),
                ],
              }),
              (0, a.BX)(w, {
                direction: 'column',
                align: 'center',
                padding: 's',
                gap: 6,
                children: [
                  (0, a.tZ)(s.xvT.Body.XS.Regular, { children: 'Wallet Balance' }),
                  (0, a.tZ)(s.xvT.Body.XS.Regular, {
                    children: 'Legacy MORPHO: '.concat(A, ' MORPHO'),
                  }),
                  (0, a.tZ)(s.xvT.Body.XS.Regular, {
                    children: 'Wrapped MORPHO: '.concat(P, ' MORPHO'),
                  }),
                ],
              }),
              !n.isContract &&
                (0, a.BX)(s.Kqy, {
                  gap: 'xs',
                  children: [
                    (0, a.tZ)(s.xvT.Body.XXS.Regular, { children: 'Use approve()' }),
                    (0, a.tZ)(s.rsf, {
                      active: k,
                      onClick: (e) => B(e),
                      'data-testid': 'use-onchain-approve-switch',
                    }),
                  ],
                }),
            ],
          });
        });
      var B = (0, o.memo)((e) => {
          let {} = e,
            { toggleDialog: t } = (0, s.DAv)();
          return (0, a.BX)(Z, {
            align: 'center',
            gap: 8,
            justify: 'space-between',
            'data-testid': 'wrap-banner',
            children: [
              (0, a.tZ)('div', {}),
              (0, a.tZ)(s.xvT.Body.M.Regular, {
                lineHeight: 'normal',
                children:
                  'MORPHO is now transferable! Please wrap your MORPHO to the latest version to enable transferability.',
              }),
              (0, a.BX)(s.Kqy, {
                align: 'center',
                gap: 8,
                children: [
                  (0, a.tZ)(s.zxk, {
                    variant: 'primary',
                    size: 'default',
                    onClick: () => t((0, a.tZ)(k, {}), { closable: !0 }),
                    label: 'Wrap',
                  }),
                  (0, a.tZ)(p.Z, {
                    href: h.IA,
                    buttonProps: { variant: 'secondary', size: 'default', label: 'FAQ' },
                  }),
                ],
              }),
            ],
          });
        }),
        A = i(18313),
        P = (0, o.memo)((e) => {
          let {} = e,
            { account: t, targetChainId: i } = (0, b.Z_)(),
            r = (0, o.useMemo)(() => {
              let e = h.FW.getSafeIdentifier(i),
                r = h.FW.getNameById(i);
              return e
                ? 'https://app.safe.global/apps/open?safe='
                    .concat(e, ':')
                    .concat(null == t ? void 0 : t.address, '&appUrl=')
                    .concat(A.clientEnvs.NEXT_PUBLIC_DEPLOYMENT_URL, '/')
                    .concat(r, '/earn')
                : '#';
            }, [i, null == t ? void 0 : t.address]);
          return (0, a.BX)(s.xvT.Body.M.Regular, {
            lineHeight: 'normal',
            width: '100%',
            justifyContent: 'center',
            textAlign: 'center',
            children: [
              'If you are using a Safe, use the ',
              (0, a.tZ)('a', { href: r, children: 'Morpho Safe App' }),
              ' for an optimal experience',
            ],
          });
        });
      let C =
        'Morpho Association (ADDMO) is not authorized or regulated by the Financial Conduct Authority (FCA), and accordingly, the protections provided by the UK regulatory system will not be available to you when using the products and services provided by Morpho Association. It is your responsibility to ascertain whether you are permitted to use the products and services provided by Morpho Association according to applicable laws or regulations. By accessing this website and the products and services available through it, you acknowledge and confirm that you are a company or partnership with share capital or net assets of at least \xa35m or a trust with total cash and investments of at least \xa310m, or that you have professional experience in matters relating to investments and your ordinary activities involve you in dealing in cryptoassets for the purpose of a business carried on by you. You also acknowledge that cryptoassets are high risk investments and that you deal in them at your own risk.';
      function T() {
        return (0, a.BX)(s.Kqy, {
          direction: 'column',
          align: 'center',
          justify: 'center',
          gap: 'm',
          children: [
            (0, a.tZ)(s.xvT.Body.L.Regular, { children: 'Disclaimer for UK residents' }),
            (0, a.tZ)(s.xvT.Body.S.Regular, { children: C }),
          ],
        });
      }
      var S = (0, o.memo)((e) => {
        let {} = e,
          t = (0, s.dD4)(),
          { toggleDialog: i } = (0, s.DAv)(),
          r = (0, o.useMemo)(() => ''.concat(C.slice(0, 110), '...'), []);
        return (0, a.BX)(s.Kqy, {
          align: 'center',
          justify: 'space-between',
          width: '100%',
          gap: 8,
          children: [
            (0, a.tZ)('div', {}),
            (0, a.tZ)(s.ZT$, {
              TextVariant: t ? s.xvT.Body.XXS.Regular : s.xvT.Body.M.Regular,
              lineHeight: 'normal',
              children: r,
            }),
            (0, a.tZ)(s.zxk, {
              variant: 'ghost',
              size: 'small',
              onClick: () => i((0, a.tZ)(T, {}), { closable: !0 }),
              children: 'See more',
            }),
          ],
        });
      });
      ((r = n || (n = {})).CONFIG = {
        legacyMorpho: { type: 'info', content: (0, a.tZ)(B, {}), dismissable: !0 },
        pageWarning: { type: 'alert', content: null, dismissable: !1 },
        simulate: {
          type: 'info',
          content: (0, a.tZ)(s.xvT.Body.M.Regular, {
            lineHeight: 'normal',
            width: '100%',
            textAlign: 'center',
            children: 'Simulating data based on transactions in Bundler',
          }),
          dismissable: !0,
        },
        ukDisclaimer: { type: 'info', content: (0, a.tZ)(S, {}), dismissable: !1 },
        safeAccount: { type: 'info', content: (0, a.tZ)(P, {}), dismissable: !0 },
      }),
        (r.TypeDef = {
          alert: { background: (e) => e.colors.components.badge },
          info: { background: (e) => e.colors.background.banner },
        });
      let X = (0, d.Z)(s.Kqy, { target: 'e1igxb3q0' })(
        'background:',
        (e) => {
          let { theme: t, variant: i } = e;
          return n.TypeDef[i].background(t);
        },
        ';backdrop-filter:blur(100px);padding:14px 24px;min-height:54px;',
        (0, s.ClW)(s.ieP),
        ';a{text-decoration:underline;}'
      );
      var R = (0, o.memo)((e) => {
          let { className: t, children: i, variant: r = 'alert', onDismiss: n } = e;
          return (0, a.BX)(X, {
            className: t,
            variant: r,
            align: 'center',
            gap: 8,
            children: [
              i,
              n &&
                (0, a.tZ)(s.zxk, {
                  onClick: n,
                  variant: 'ghost',
                  size: 'small',
                  iconAlone: 'ClosePlain20',
                }),
            ],
          });
        }),
        D = i(23567);
      let M = (0, d.Z)(s.Kqy, { target: 'esgdglv0' })(
          'z-index:',
          (e) => {
            let { theme: t } = e;
            return t.zIndex.banner.mid;
          },
          ';margin-top:',
          (0, D.iv)('var(--navbar-height)'),
          ';position:relative;'
        ),
        q = (0, d.Z)('div', { target: 'esgdglv1' })(
          'width:calc(100% - (var(--bundler-width) - var(--bundler-position)));',
          (e) => {
            let { theme: t } = e;
            return t.breakpoints.down('s');
          },
          '{width:100%;}position:fixed;'
        );
      var F = (0, o.memo)((e) => {
        let { className: t } = e,
          { bannersToShow: i, toggleBanner: r } = (0, l.l5)();
        return (0, a.tZ)(M, {
          className: t,
          direction: 'column',
          children: (0, a.tZ)(q, {
            children: i.map((e) => {
              let { id: t, content: i, type: n, dismissable: o } = e;
              return (0, a.tZ)(
                R,
                { variant: n, onDismiss: o ? () => r(t, !1) : void 0, children: i },
                t
              );
            }),
          }),
        });
      });
    },
    52234: function (e, t, i) {
      'use strict';
      i.d(t, {
        D: function () {
          return l;
        },
      });
      var r = i(78286),
        n = i(40252),
        a = i(54655);
      let o = {
          [n.ChainId.EthMainnet]: {
            '0x73e65DBD630f90604062f6E02fAb9138e713edD9': { showCredoraRating: !1 },
            '0x749794E985Af5a9A384B9cEe6D88DaB4CE1576A1': { showCredoraRating: !1 },
            '0xD50DA5F859811A91fD1876C9461fD39c23C747Ad': { showCredoraRating: !1 },
            '0xc582F04d8a82795aa2Ff9c8bb4c1c889fe7b754e': { showCredoraRating: !1 },
            '0x78Fc2c2eD1A4cDb5402365934aE5648aDAd094d0': { showCredoraRating: !0 },
            '0xA02F5E93f783baF150Aa1F8b341Ae90fe0a772f7': { showCredoraRating: !0 },
            '0x95EeF579155cd2C5510F312c8fA39208c3Be01a8': { showCredoraRating: !0 },
            '0xE0C98605f279e4D7946d25B75869c69802823763': { showCredoraRating: !0 },
            '0x64964E162Aa18d32f91eA5B24a09529f811AEB8e': { showCredoraRating: !0 },
            '0xb0f05E4De970A1aaf77f8C2F823953a367504BA9': {
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      'Participation in the Falcon USDC Core vault involves exposure to assets issued by Falcon Financenamely USDf and sUSDf. USDf is an overcollateralized synthetic dollar designed to maintain its peg to the U.S. dollar. To support peg stability, Falcon either creates hedged positions for the underlying collateral or directly converts deposits into USD at entry. While engineered for stability, USDf remains subject to risks such as depegging from collateral volatility or broader market stress.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      "sUSDf is a yield-bearing token backed by Falcon's institutional-grade strategies, managed by the trading team at DWF Labs. These include price arbitrage, funding rate strategies (positive and negative), and staking. While these approaches are designed for high risk-adjusted returns, they rely on favorable conditions and precise execution. Deviations in performance or infrastructure risks may affect sUSDf's ability to meet target yields.",
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      "Assets backing both tokens are held with reputable custodians including Fireblocks, Copper, and CEFU. Trading occurs through omnibus accountsensuring assets stay within custody and are not deployed to third-party venues. This setup reduces typical counterparty risk, but depends on Falcon's operational integrity and custodian reliability for accurate fund management.",
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      "Falcon provides quarterly Proof of Reserves for transparency. While this strengthens trust in collateral backing, it does not reflect real-time dynamics or eliminate all operational risk. Depositors should weigh the potential for attractive yields against the system's reliance on institutional infrastructure and execution.",
                  }),
                ],
              }),
            },
            '0x0F359FD18BDa75e9c49bC027E7da59a4b01BF32a': {
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      'Relend Network Vaults are curated by B.Protocol and the RiskDAO who curated over $200m tvl in Morpho, and consulted in the past to over 10 different lending markets.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Our vaults aim to achieve superior risk-adjusted returns by capitalizing on distinctive market opportunities  which may subject depositors to increased volatility or periods of limited liquidity. While continuous oversight and adaptive asset allocation help reduce the risk of significant losses, sudden changes in market sentiment can still lead to liquidations or temporary liquidity challenges.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'The vault also plays key role in the Relend Network protocol, and has the ability to relend the supplied assets into other chains. ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://docs.relend.network/relend.docs/rusdc-mechanism-and-risk-disclosure',
                          children: 'See more details here',
                        }),
                      }),
                      '.',
                    ],
                  }),
                ],
              }),
            },
            '0xc080f56504e0278828A403269DB945F6c6D6E014': {
              showCredoraRating: !1,
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      'Gauntlet is the leading model provider in crypto, building optimization strategies for tokens, protocols, and chains. Central to our Morpho Vault curation approach is ensuring vaults meet our robust risk guidelines, are attractive to the DeFi community, and remain resilient enough to handle inherent crypto market volatility.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Our Core Vaults allocate to a blend of large and lower cap collateralized markets while ensuring exposure to any one asset remains within acceptable bounds. Collateral Selection is based on various factors, including the availability of withdrawal liquidity and sufficient liquidity and slippage to perform healthy liquidations in severe market conditions.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'For more info, visit',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://gauntlet.gitbook.io/gauntlet-vaultbook/morpho-vaults',
                          children: 'this link',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children: (0, r.tZ)(a.xvT.Body.XS.Regular, {
                      color: 'text.interactive.active',
                      children: (0, r.tZ)(a.dLw, {
                        href: 'https://storage.googleapis.com/gauntlet-public-web-assets/Gauntlet_New_Partnership_Disclaimer.pdf',
                        children: 'Gauntlet Disclaimer',
                      }),
                    }),
                  }),
                ],
              }),
            },
            '0xF587f2e8AfF7D76618d3B6B4626621860FbD54e3': {
              showCredoraRating: !1,
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      'Gauntlet is the leading model provider in crypto, building optimization strategies for tokens, protocols, and chains. Central to our Morpho Vault curation approach is ensuring vaults meet our robust risk guidelines, are attractive to the DeFi community, and remain resilient enough to handle inherent crypto market volatility.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Our Core Vaults allocate to a blend of large and lower cap collateralized markets while ensuring exposure to any one asset remains within acceptable bounds. Collateral Selection is based on various factors, including the availability of withdrawal liquidity and sufficient liquidity and slippage to perform healthy liquidations in severe market conditions.',
                  }),
                ],
              }),
            },
            '0x443df5eEE3196e9b2Dd77CaBd3eA76C3dee8f9b2': {
              showCredoraRating: !1,
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      'Gauntlet is the leading model provider in crypto, building optimization strategies for tokens, protocols, and chains. Central to our Morpho Vault curation approach is ensuring vaults meet our robust risk guidelines, are attractive to the DeFi community, and remain resilient enough to handle inherent crypto market volatility.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Our Core Vaults allocate to a blend of large and lower cap collateralized markets while ensuring exposure to any one asset remains within acceptable bounds. Collateral Selection is based on various factors, including the availability of withdrawal liquidity and sufficient liquidity and slippage to perform healthy liquidations in severe market conditions.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'For more info, visit',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://gauntlet.gitbook.io/gauntlet-vaultbook/morpho-vaults',
                          children: 'this link',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children: (0, r.tZ)(a.xvT.Body.XS.Regular, {
                      color: 'text.interactive.active',
                      children: (0, r.tZ)(a.dLw, {
                        href: 'https://storage.googleapis.com/gauntlet-public-web-assets/Gauntlet_New_Partnership_Disclaimer.pdf',
                        children: 'Gauntlet Disclaimer',
                      }),
                    }),
                  }),
                ],
              }),
            },
            '0x9a8bC3B04b7f3D87cfC09ba407dCED575f2d61D8': { showCredoraRating: !1 },
            '0xd63070114470f685b75B74D60EEc7c1113d33a3D': { showCredoraRating: !1 },
            '0xBEeFFF209270748ddd194831b3fa287a5386f5bC': {
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.BX)('p', {
                    children: [
                      "BBQ-branded Vaults are curated and operated by Carniceria Tropical using stringent governance protocols aimed at minimizing trust assumptions and maximizing depositor security. All major decisions  such as adjusting fee levels, refining asset allocations, and updating liquidity thresholds  require approval through this vault's Aragon DAO Guardian link:",
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://app.aragon.org/#/daos/ethereum/bbqusdc-guardian.dao.eth/dashboard',
                          children: 'bbqusdc-guardian.dao.eth',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'BBQ-branded Vaults pursue higher risk-adjusted returns by seizing upon unique market opportunities  potentially exposing depositors to greater volatility or liquidity constraints. Although ongoing monitoring and dynamic asset allocations seek to mitigate large drawdowns, rapid shifts in market sentiment could trigger liquidation events or short-lived liquidity disruptions.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'We encourage participants to review the Steakhouse',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://docs.google.com/document/d/18ADHX_O2oQKjAfRLoLVbDUizKxWBA4w7g8KYsphj0N4/edit?usp=sharing',
                          children: '"Risk Framework for Crypto Assets"',
                        }),
                      }),
                      ' ',
                      'to understand how we evaluate asset volatility and handle swift price swings. Additional notes on the Smokehouse approach can be found here:',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://forum.morpho.org/t/key-information-on-steakhouse-branded-vaults/1343',
                          children: 'Key Information on Steakhouse Branded Vaults',
                        }),
                      }),
                      '.',
                    ],
                  }),
                ],
              }),
              showCredoraRating: !0,
            },
            '0xBeEf11eCb698f4B5378685C05A210bdF71093521': {
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      'Steak-branded Vaults are curated and operated by Carniceria Tropical using stringent governance protocols aimed at minimizing trust assumptions and maximizing depositor security. Increasing exposure to a new or existing collateral type requires approval through the Aragon DAO Guardian.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Steak-branded Vaults are designed to minimize volatility by allocating primarily against highly-liquid assets. While Steak vaults are focused on established markets, no strategy eliminates risk entirely: Extraordinary market events or tail risks may still drive sudden price movements and volatility in the underlying Morpho markets.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'To learn more about how we assess these possibilities and maintain robust safeguards, please review our post: Steakhouse',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://docs.google.com/document/d/18ADHX_O2oQKjAfRLoLVbDUizKxWBA4w7g8KYsphj0N4/edit?usp=sharing',
                          children: '"Counterparty Risk Framework for Crypto Assets"',
                        }),
                      }),
                      '. Further details on vault structures and asset choices can be found at',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://forum.morpho.org/t/key-information-on-steakhouse-branded-vaults/1343',
                          children: 'Key Information on Steakhouse Branded Vaults',
                        }),
                      }),
                      '.',
                    ],
                  }),
                ],
              }),
            },
            '0xbEef047a543E45807105E51A8BBEFCc5950fcfBa': {
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.BX)('p', {
                    children: [
                      "Steak-branded Vaults are curated and operated by Carniceria Tropical using stringent governance protocols aimed at minimizing trust assumptions and maximizing depositor security. Increasing exposure to a new or existing collateral type requires approval through this vault's Aragon DAO Guardian link:",
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://app.aragon.org/#/daos/ethereum/steakusdt-guardian.dao.eth/dashboard',
                          children: '"steakusdt-guardian.dao.eth"',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Steak-branded Vaults are designed to minimize volatility by allocating primarily against highly-liquid assets. While Steak vaults are focused on established markets, no strategy eliminates risk entirely: Extraordinary market events or tail risks may still drive sudden price movements and volatility in the underlying Morpho markets.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'To learn more about how we assess these possibilities and maintain robust safeguards, please review our post: Steakhouse',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://docs.google.com/document/d/18ADHX_O2oQKjAfRLoLVbDUizKxWBA4w7g8KYsphj0N4/edit?usp=sharing',
                          children: '"Counterparty Risk Framework for Crypto Assets"',
                        }),
                      }),
                      '. Further details on vault structures and asset choices can be found at',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://forum.morpho.org/t/key-information-on-steakhouse-branded-vaults/1343',
                          children: 'Key Information on Steakhouse Branded Vaults',
                        }),
                      }),
                      '.',
                    ],
                  }),
                ],
              }),
              showCredoraRating: !0,
            },
            '0xBEEf050ecd6a16c4e7bfFbB52Ebba7846C4b8cD4': {
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.BX)('p', {
                    children: [
                      "Steak-branded Vaults are curated and operated by Carniceria Tropical using stringent governance protocols aimed at minimizing trust assumptions and maximizing depositor security. Increasing exposure to a new or existing collateral type requires approval through this vault's Aragon DAO Guardian link:",
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://app.aragon.org/#/daos/ethereum/steaketh-guardian.dao.eth/dashboard',
                          children: '"steaketh-guardian.dao.eth"',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Steak-branded Vaults are designed to minimize volatility by allocating primarily against highly-liquid assets. While Steak vaults are focused on established markets, no strategy eliminates risk entirely: Extraordinary market events or tail risks may still drive sudden price movements and volatility in the underlying Morpho markets.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'To learn more about how we assess these possibilities and maintain robust safeguards, please review our post: Steakhouse',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://docs.google.com/document/d/18ADHX_O2oQKjAfRLoLVbDUizKxWBA4w7g8KYsphj0N4/edit?usp=sharing',
                          children: '"Counterparty Risk Framework for Crypto Assets"',
                        }),
                      }),
                      '. Further details on vault structures and asset choices can be found at',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://forum.morpho.org/t/key-information-on-steakhouse-branded-vaults/1343',
                          children: 'Key Information on Steakhouse Branded Vaults',
                        }),
                      }),
                      '.',
                    ],
                  }),
                ],
              }),
              showCredoraRating: !0,
            },
            '0xbEeFc011e94f43b8B7b455eBaB290C7Ab4E216f1': {
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      "Custom Vaults are co-branded with external partners, allowing Steakhouse Financial to apply its risk-management expertise in a specialized setting. Depending on each partner's strategic direction, the vault's underlying assets may range from conservative to opportunistic, potentially leading to different liquidity profiles or price sensitivities.",
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'Since each Custom Vault is managed in close collaboration with our partners, management parameters may differ slightly from standard Steakhouse or Smokehouse offerings. Nonetheless, all critical updatesincluding fee changes, asset rebalancing, or membership criteriaremain subject to formal proposals and time-delayed execution through the following Aragon DAO Guardian link:',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://csusdl-2-guardian.dao.eth/',
                          children: 'csusdl-2-guardian.dao.eth',
                        }),
                      }),
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'For an overview of our broader methodology, see the Steakhouse',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://docs.google.com/document/d/18ADHX_O2oQKjAfRLoLVbDUizKxWBA4w7g8KYsphj0N4/edit?usp=sharing',
                          children: '"Risk Framework for Crypto Assets"',
                        }),
                      }),
                      '. Further explanations on co-branded vault structures can be found at',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://forum.morpho.org/t/key-information-on-steakhouse-branded-vaults/1343',
                          children: 'Key Information on Steakhouse Branded Vaults',
                        }),
                      }),
                      '.',
                    ],
                  }),
                ],
              }),
              showCredoraRating: !0,
            },
            '0xbEEF02e5E13584ab96848af90261f0C8Ee04722a': {
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.BX)('p', {
                    children: [
                      "Steak-branded Vaults are curated and operated by Carniceria Tropical using stringent governance protocols aimed at minimizing trust assumptions and maximizing depositor security. Increasing exposure to a new or existing collateral type requires approval through this vault's Aragon DAO Guardian link:",
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://steakpyusd-guardian.dao.eth/',
                          children: 'steakpyusd-guardian.dao.eth',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Steak-branded Vaults are designed to minimize volatility by allocating primarily against highly-liquid assets. While Steak vaults are focused on established markets, no strategy eliminates risk entirely: Extraordinary market events or tail risks may still drive sudden price movements and volatility in the underlying Morpho markets.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'To learn more about how we assess these possibilities and maintain robust safeguards, please review our post: Steakhouse',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://docs.google.com/document/d/18ADHX_O2oQKjAfRLoLVbDUizKxWBA4w7g8KYsphj0N4/edit?usp=sharing',
                          children: '"Counterparty Risk Framework for Crypto Assets"',
                        }),
                      }),
                      '. Further details on vault structures and asset choices can be found at',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://forum.morpho.org/t/key-information-on-steakhouse-branded-vaults/1343',
                          children: 'Key Information on Steakhouse Branded Vaults',
                        }),
                      }),
                      '.',
                    ],
                  }),
                ],
              }),
            },
            '0xBEEF01735c132Ada46AA9aA4c54623cAA92A64CB': {
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.BX)('p', {
                    children: [
                      "Steak-branded Vaults are curated and operated by Carniceria Tropical using stringent governance protocols aimed at minimizing trust assumptions and maximizing depositor security. Increasing exposure to a new or existing collateral type requires approval through this vault's Aragon DAO Guardian link:",
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://app.aragon.org/dao/ethereum-mainnet-0xaa0500198B4425DfC4E272FbE42C8E64E21fc03d/dashboard',
                          children: 'steakusdc-guardian.dao.eth',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Steak-branded Vaults are designed to minimize volatility by allocating primarily against highly-liquid assets. While Steak vaults are focused on established markets, no strategy eliminates risk entirely: Extraordinary market events or tail risks may still drive sudden price movements and volatility in the underlying Morpho markets.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'To learn more about how we assess these possibilities and maintain robust safeguards, please review our post: Steakhouse',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://docs.google.com/document/d/18ADHX_O2oQKjAfRLoLVbDUizKxWBA4w7g8KYsphj0N4/edit?usp=sharing',
                          children: '"Counterparty Risk Framework for Crypto Assets"',
                        }),
                      }),
                      '. Further details on vault structures and asset choices can be found at',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://forum.morpho.org/t/key-information-on-steakhouse-branded-vaults/1343',
                          children: 'Key Information on Steakhouse Branded Vaults',
                        }),
                      }),
                      '.',
                    ],
                  }),
                ],
              }),
              showCredoraRating: !0,
            },
            '0xdC94785959B73F7A168452b3654E44fEc6A750e4': {
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      'Gauntlet is the leading model provider in crypto, building optimization strategies for tokens, protocols, and chains. Central to our Morpho Vault curation approach is ensuring vaults meet our robust risk guidelines, are attractive to the DeFi community, and remain resilient enough to handle inherent crypto market volatility.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Our Core Vaults allocate to a blend of large and lower cap collateralized markets while ensuring exposure to any one asset remains within acceptable bounds. Collateral Selection is based on various factors, including the availability of withdrawal liquidity and sufficient liquidity and slippage to perform healthy liquidations in severe market conditions.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'For more info, visit',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://gauntlet.gitbook.io/gauntlet-vaultbook/morpho-vaults',
                          children: 'this link',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children: (0, r.tZ)(a.xvT.Body.XS.Regular, {
                      color: 'text.interactive.active',
                      children: (0, r.tZ)(a.dLw, {
                        href: 'https://storage.googleapis.com/gauntlet-public-web-assets/Gauntlet_New_Partnership_Disclaimer.pdf',
                        children: 'Gauntlet Disclaimer',
                      }),
                    }),
                  }),
                ],
              }),
              showCredoraRating: !1,
            },
            '0x6770216aC60F634483Ec073cBABC4011c94307Cb': {
              showCredoraRating: !1,
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      'Gauntlet is the leading model provider in crypto, building optimization strategies for tokens, protocols, and chains. Central to our Morpho Vault curation approach is ensuring vaults meet our robust risk guidelines, are attractive to the DeFi community, and remain resilient enough to handle inherent crypto market volatility.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Our Core Vaults allocate to a blend of large and lower cap collateralized markets while ensuring exposure to any one asset remains within acceptable bounds. Collateral Selection is based on various factors, including the availability of withdrawal liquidity and sufficient liquidity and slippage to perform healthy liquidations in severe market conditions.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'For more info, visit',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://gauntlet.gitbook.io/gauntlet-vaultbook/morpho-vaults',
                          children: 'this link',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children: (0, r.tZ)(a.xvT.Body.XS.Regular, {
                      color: 'text.interactive.active',
                      children: (0, r.tZ)(a.dLw, {
                        href: 'https://storage.googleapis.com/gauntlet-public-web-assets/Gauntlet_New_Partnership_Disclaimer.pdf',
                        children: 'Gauntlet Disclaimer',
                      }),
                    }),
                  }),
                ],
              }),
            },
            '0xdd0f28e19C1780eb6396170735D45153D261490d': {
              showCredoraRating: !1,
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      'Gauntlet is the leading model provider in crypto, building optimization strategies for tokens, protocols, and chains. Central to our Morpho Vault curation approach is ensuring vaults meet our robust risk guidelines, are attractive to the DeFi community, and remain resilient enough to handle inherent crypto market volatility.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Our Prime Vaults allocate supply to maximize risk-adjusted yield while targeting minimal risk of insolvent debt even under extreme market conditions. These Vaults will allocate to markets that meet various criteria, including being a blend of super high liquidity blue chip collateral, and moderate volatility between the supply and collateral token relative.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'For more info, visit',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://gauntlet.gitbook.io/gauntlet-vaultbook/morpho-vaults',
                          children: 'this link',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children: (0, r.tZ)(a.xvT.Body.XS.Regular, {
                      color: 'text.interactive.active',
                      children: (0, r.tZ)(a.dLw, {
                        href: 'https://storage.googleapis.com/gauntlet-public-web-assets/Gauntlet_New_Partnership_Disclaimer.pdf',
                        children: 'Gauntlet Disclaimer',
                      }),
                    }),
                  }),
                ],
              }),
            },
            '0x2371e134e3455e0593363cBF89d3b6cf53740618': {
              showCredoraRating: !1,
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      'Gauntlet is the leading model provider in crypto, building optimization strategies for tokens, protocols, and chains. Central to our Morpho Vault curation approach is ensuring vaults meet our robust risk guidelines, are attractive to the DeFi community, and remain resilient enough to handle inherent crypto market volatility.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Our Prime Vaults allocate supply to maximize risk-adjusted yield while targeting minimal risk of insolvent debt even under extreme market conditions. These Vaults will allocate to markets that meet various criteria, including being a blend of super high liquidity blue chip collateral, and moderate volatility between the supply and collateral token relative.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'For more info, visit',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://gauntlet.gitbook.io/gauntlet-vaultbook/morpho-vaults',
                          children: 'this link',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children: (0, r.tZ)(a.xvT.Body.XS.Regular, {
                      color: 'text.interactive.active',
                      children: (0, r.tZ)(a.dLw, {
                        href: 'https://storage.googleapis.com/gauntlet-public-web-assets/Gauntlet_New_Partnership_Disclaimer.pdf',
                        children: 'Gauntlet Disclaimer',
                      }),
                    }),
                  }),
                ],
              }),
            },
            '0x8eB67A509616cd6A7c1B3c8C21D48FF57df3d458': {
              showCredoraRating: !1,
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      'Gauntlet is the leading model provider in crypto, building optimization strategies for tokens, protocols, and chains. Central to our Morpho Vault curation approach is ensuring vaults meet our robust risk guidelines, are attractive to the DeFi community, and remain resilient enough to handle inherent crypto market volatility.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Our Core Vaults allocate to a blend of large and lower cap collateralized markets while ensuring exposure to any one asset remains within acceptable bounds. Collateral Selection is based on various factors, including the availability of withdrawal liquidity and sufficient liquidity and slippage to perform healthy liquidations in severe market conditions.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'For more info, visit',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://gauntlet.gitbook.io/gauntlet-vaultbook/morpho-vaults',
                          children: 'this link',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children: (0, r.tZ)(a.xvT.Body.XS.Regular, {
                      color: 'text.interactive.active',
                      children: (0, r.tZ)(a.dLw, {
                        href: 'https://storage.googleapis.com/gauntlet-public-web-assets/Gauntlet_New_Partnership_Disclaimer.pdf',
                        children: 'Gauntlet Disclaimer',
                      }),
                    }),
                  }),
                ],
              }),
            },
            '0x4881Ef0BF6d2365D3dd6499ccd7532bcdBCE0658': {
              showCredoraRating: !1,
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      'Gauntlet is the leading model provider in crypto, building optimization strategies for tokens, protocols, and chains. Central to our Morpho Vault curation approach is ensuring vaults meet our robust risk guidelines, are attractive to the DeFi community, and remain resilient enough to handle inherent crypto market volatility.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Our Core Vaults allocate to a blend of large and lower cap collateralized markets while ensuring exposure to any one asset remains within acceptable bounds. Collateral Selection is based on various factors, including the availability of withdrawal liquidity and sufficient liquidity and slippage to perform healthy liquidations in severe market conditions.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'For more info, visit',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://gauntlet.gitbook.io/gauntlet-vaultbook/morpho-vaults',
                          children: 'this link',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children: (0, r.tZ)(a.xvT.Body.XS.Regular, {
                      color: 'text.interactive.active',
                      children: (0, r.tZ)(a.dLw, {
                        href: 'https://storage.googleapis.com/gauntlet-public-web-assets/Gauntlet_New_Partnership_Disclaimer.pdf',
                        children: 'Gauntlet Disclaimer',
                      }),
                    }),
                  }),
                ],
              }),
            },
          },
          [n.ChainId.BaseMainnet]: {
            '0xA2Cac0023a4797b4729Db94783405189a4203AFc': { showCredoraRating: !0 },
            '0x12AFDeFb2237a5963e7BAb3e2D46ad0eee70406e': { showCredoraRating: !0 },
            '0x1D3b1Cd0a0f242d598834b3F2d126dC6bd774657': {
              showCredoraRating: !1,
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      'Clearstar is a research-led DeFi curator dedicated to building vaults that blend capital efficiency, robust risk parameters, and sustainable on-chain yield. Our curation process focuses on vaults that can perform in dynamic market conditions while staying aligned with the interests of serious DeFi users.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      "This Ecosystem Vault is centered around OpenEden's tokenized T-Bill yield via USDO, anchoring strategy in stability while layering in high-demand collateral markets to enhance returns. The vault maintains exposure boundaries to ensure diversification, and evaluates assets based on liquidity depth, withdrawal reliability, and liquidation efficiency under stress scenariosbalancing upside with resilience.",
                  }),
                ],
              }),
            },
            '0xf24608E0CCb972b0b0f4A6446a0BBf58c701a026': { showCredoraRating: !0 },
            '0x6b13c060F13Af1fdB319F52315BbbF3fb1D88844': {
              showCredoraRating: !1,
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      'Gauntlet is the leading model provider in crypto, building optimization strategies for tokens, protocols, and chains. Central to our Morpho Vault curation approach is ensuring vaults meet our robust risk guidelines, are attractive to the DeFi community, and remain resilient enough to handle inherent crypto market volatility.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Our Core Vaults allocate to a blend of large and lower cap collateralized markets while ensuring exposure to any one asset remains within acceptable bounds. Collateral Selection is based on various factors, including the availability of withdrawal liquidity and sufficient liquidity and slippage to perform healthy liquidations in severe market conditions.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'For more info, visit',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://gauntlet.gitbook.io/gauntlet-vaultbook/morpho-vaults',
                          children: 'this link',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children: (0, r.tZ)(a.xvT.Body.XS.Regular, {
                      color: 'text.interactive.active',
                      children: (0, r.tZ)(a.dLw, {
                        href: 'https://storage.googleapis.com/gauntlet-public-web-assets/Gauntlet_New_Partnership_Disclaimer.pdf',
                        children: 'Gauntlet Disclaimer',
                      }),
                    }),
                  }),
                ],
              }),
            },
            '0x5a47C803488FE2BB0A0EAaf346b420e4dF22F3C7': {
              showCredoraRating: !1,
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      'Gauntlet is the leading model provider in crypto, building optimization strategies for tokens, protocols, and chains. Central to our Morpho Vault curation approach is ensuring vaults meet our robust risk guidelines, are attractive to the DeFi community, and remain resilient enough to handle inherent crypto market volatility.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'This Ecosystem Vault applies our Core strategy, which allocates to a blend of large and lower-cap collateralized markets while ensuring exposure to any one asset remains within acceptable bounds. Collateral Selection is based on various factors, including the availability of withdrawal liquidity and sufficient liquidity and slippage to perform healthy liquidations in severe market conditions.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'For more info, visit',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://gauntlet.gitbook.io/gauntlet-vaultbook/morpho-vaults',
                          children: 'this link',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children: (0, r.tZ)(a.xvT.Body.XS.Regular, {
                      color: 'text.interactive.active',
                      children: (0, r.tZ)(a.dLw, {
                        href: 'https://storage.googleapis.com/gauntlet-public-web-assets/Gauntlet_New_Partnership_Disclaimer.pdf',
                        children: 'Gauntlet Disclaimer',
                      }),
                    }),
                  }),
                ],
              }),
            },
            '0x543257eF2161176D7C8cD90BA65C2d4CaEF5a796': { showCredoraRating: !0 },
            '0xa0E430870c4604CcfC7B38Ca7845B1FF653D0ff1': { showCredoraRating: !0 },
            '0xc1256Ae5FF1cf2719D4937adb3bbCCab2E00A2Ca': { showCredoraRating: !0 },
            '0x7BfA7C4f149E7415b73bdeDfe609237e29CBF34A': { showCredoraRating: !1 },
            '0x616a4E1db48e22028f6bbf20444Cd3b8e3273738': {
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.tZ)('p', {
                    children:
                      'Gauntlet is the leading model provider in crypto, building optimization strategies for tokens, protocols, and chains. Central to our Morpho Vault curation approach is ensuring vaults meet our robust risk guidelines, are attractive to the DeFi community, and remain resilient enough to handle inherent crypto market volatility.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'This Ecosystem Vault applies our Core strategy, which allocates to a blend of large and lower-cap collateralized markets while ensuring exposure to any one asset remains within acceptable bounds. Collateral Selection is based on various factors, including the availability of withdrawal liquidity and sufficient liquidity and slippage to perform healthy liquidations in severe market conditions.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'For more info, visit',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://gauntlet.gitbook.io/gauntlet-vaultbook/morpho-vaults',
                          children: 'this link',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children: (0, r.tZ)(a.xvT.Body.XS.Regular, {
                      color: 'text.interactive.active',
                      children: (0, r.tZ)(a.dLw, {
                        href: 'https://storage.googleapis.com/gauntlet-public-web-assets/Gauntlet_New_Partnership_Disclaimer.pdf',
                        children: 'Gauntlet Disclaimer',
                      }),
                    }),
                  }),
                ],
              }),
              showCredoraRating: !1,
            },
            '0xbeeF010f9cb27031ad51e3333f9aF9C6B1228183': {
              disclosure: (0, r.BX)('div', {
                children: [
                  (0, r.BX)('p', {
                    children: [
                      "Steak-branded Vaults are curated and operated by Carniceria Tropical using stringent governance protocols aimed at minimizing trust assumptions and maximizing depositor security. Increasing exposure to a new or existing collateral type requires approval through this vault's Aragon DAO Guardian link:",
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://app.aragon.org/#/daos/base/0xfc7a2c1a631a10574637178610bb2040a15e4c26/dashboard',
                          children: 'steakUSDC Base Guardian DAO',
                        }),
                      }),
                      '.',
                    ],
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.tZ)('p', {
                    children:
                      'Steak-branded Vaults are designed to minimize volatility by allocating primarily against highly-liquid assets. While Steak vaults are focused on established markets, no strategy eliminates risk entirely: Extraordinary market events or tail risks may still drive sudden price movements and volatility in the underlying Morpho markets.',
                  }),
                  (0, r.tZ)('br', {}),
                  (0, r.BX)('p', {
                    children: [
                      'To learn more about how we assess these possibilities and maintain robust safeguards, please review our post: Steakhouse',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://docs.google.com/document/d/18ADHX_O2oQKjAfRLoLVbDUizKxWBA4w7g8KYsphj0N4/edit?usp=sharing',
                          children: '"Counterparty Risk Framework for Crypto Assets"',
                        }),
                      }),
                      '. Further details on vault structures and asset choices can be found at',
                      ' ',
                      (0, r.tZ)(a.xvT.Body.XS.Regular, {
                        color: 'text.interactive.active',
                        children: (0, r.tZ)(a.dLw, {
                          href: 'https://forum.morpho.org/t/key-information-on-steakhouse-branded-vaults/1343',
                          children: 'Key Information on Steakhouse Branded Vaults',
                        }),
                      }),
                      '.',
                    ],
                  }),
                ],
              }),
            },
          },
          [n.ChainId.PolygonMainnet]: void 0,
          [n.ChainId.ArbitrumMainnet]: void 0,
          [n.ChainId.OptimismMainnet]: void 0,
          [n.ChainId.WorldChainMainnet]: void 0,
          [n.ChainId.FraxtalMainnet]: void 0,
          [n.ChainId.ScrollMainnet]: void 0,
          [n.ChainId.InkMainnet]: void 0,
          [n.ChainId.Unichain]: void 0,
          [n.ChainId.SonicMainnet]: void 0,
          [n.ChainId.HemiMainnet]: void 0,
          [n.ChainId.ModeMainnet]: void 0,
          [n.ChainId.CornMainnet]: void 0,
          [n.ChainId.PlumeMainnet]: void 0,
          [n.ChainId.CampMainnet]: void 0,
        },
        l = (e, t) => {
          var i;
          return null === (i = o[e]) || void 0 === i ? void 0 : i[t];
        };
    },
    4366: function (e, t, i) {
      'use strict';
      i.d(t, {
        DashboardClass: function () {
          return n;
        },
        iv: function () {
          return d;
        },
      });
      var r,
        n,
        a = i(78286),
        o = i(58258),
        l = i(54655);
      let s = (0, o.createContext)(null);
      ((r = n || (n = {})).PREVENT_DASHBOARD_CARD_HOVER_CLASS = 'prevent-dashboard-card-hover'),
        (r.DASHBOARD_CARD_BUTTON_EXPAND_CLASS = 'dashboard-card-button-expand');
      let d = () => {
          let e = (0, o.useContext)(s);
          if (!e)
            throw Error('useDashboardContext must be called inside a DashboardContextProvider');
          return e;
        },
        u = (e) => {
          let { isSmallDashboard: t } = e,
            [i, r] = (0, o.useState)(!1),
            [n, a] = (0, o.useState)(!1),
            l = (0, o.useCallback)(() => {
              r((e) => !e);
            }, []),
            s = (0, o.useCallback)(
              (e) => {
                var t;
                (null != e &&
                  null !== (t = e.target) &&
                  void 0 !== t &&
                  t.closest('.prevent-dashboard-card-hover')) ||
                  l();
              },
              [l]
            );
          return (
            (0, o.useEffect)(() => {
              t && r(!1);
            }, [t, r]),
            {
              isDashboardExpanded: i,
              isDashboardHovered: n,
              toggleDashboard: l,
              setIsDashboardHovered: a,
              onClickToggleDashboard: s,
            }
          );
        };
      t.ZP = (0, o.memo)((e) => {
        let { children: t } = e,
          i = (0, l.CPt)(),
          [r, n] = (0, o.useState)('loan'),
          d = u({ isSmallDashboard: i }),
          c = (0, o.useMemo)(
            () => ({
              isSmallDashboard: i,
              borrowDashboardMode: r,
              setBorrowDashboardMode: n,
              ...d,
            }),
            [i, d, r, n]
          );
        return (0, a.tZ)(s.Provider, { value: c, children: t });
      });
    },
    99095: function (e, t, i) {
      'use strict';
      i.d(t, {
        l5: function () {
          return m;
        },
      });
      var r = i(78286),
        n = i(58258),
        a = i(44982),
        o = i(54655),
        l = i(35047),
        s = i(66888),
        d = i(18313),
        u = i(89991),
        c = i(98949),
        h = i(22683),
        v = i(3918);
      let p = (0, n.createContext)(null),
        m = () => {
          let e = (0, n.useContext)(p);
          if (!e) throw Error('useLayoutContext must be called inside a LayoutContextProvider');
          return e;
        };
      t.ZP = (0, n.memo)((e) => {
        var t;
        let { children: i } = e,
          [m, g] = (0, n.useState)(!1),
          [y, b] = (0, n.useState)(!1),
          [f, Z] = (0, n.useState)(!0),
          { operations: x } = (0, h.N)(),
          { toggleAnimation: w } = (0, o.s8G)(),
          k = (0, o.ajf)('s'),
          {
            account: { isConnected: B },
          } = (0, u.Z_)();
        (0, n.useLayoutEffect)(() => {
          B ? w('default') : w('loading');
        }, [B, w]);
        let [A, P] = (0, n.useState)({}),
          [C, T] = (0, n.useState)(),
          S = (0, n.useCallback)(
            (e) => {
              if (k && e) {
                T({ ...e, dismissable: !0 });
                return;
              }
              T(e);
            },
            [k, T]
          ),
          X = (0, n.useMemo)(
            () =>
              (0, l.entries)(A)
                .filter((e) => {
                  let [, t] = e;
                  return t;
                })
                .map((e) => {
                  let [t] = e;
                  return 'pageWarning' === t && (null == C ? void 0 : C.content)
                    ? { ...C, id: t }
                    : { ...s.u.CONFIG[t], id: t };
                })
                .sort((e, t) => (e.type === t.type ? 0 : 'alert' === e.type ? -1 : 1)),
            [A, C]
          ),
          R = (0, n.useCallback)((e, t) => {
            P((i) => ({ ...i, [e]: t }));
          }, []),
          { account: D } = (0, u.Z_)(),
          [M, q] = (0, n.useState)(!1);
        (0, n.useEffect)(() => {
          R('pageWarning', !!C && (0, l.isDefined)(C.content));
        }, [C, null == C ? void 0 : C.content, R]),
          (0, n.useEffect)(() => {
            x.length > 0 ? R('simulate', !0) : R('simulate', !1);
          }, [x, R]),
          (0, n.useEffect)(() => {
            R('safeAccount', !D.isSafe && !!D.isContract);
          }, [R, D.isSafe, D.isContract]);
        let { countryCode: F } = (0, v.RA)();
        (0, n.useEffect)(() => {
          R('ukDisclaimer', 'GB' === F);
        }, [R, F]);
        let { legacyMorphoHolding: K } = (0, c.gz)();
        (0, n.useEffect)(() => {
          var e;
          R(
            'legacyMorpho',
            !!(
              (null === (e = K.value) || void 0 === e ? void 0 : e.balance) && K.value.balance > 0n
            )
          );
        }, [null === (t = K.value) || void 0 === t ? void 0 : t.balance, R]),
          (0, n.useEffect)(() => {
            d.clientEnvs.NEXT_PUBLIC_SPINDL_SDK_KEY &&
              (null == D ? void 0 : D.address) &&
              a.ZP.attribute(D.address);
          }, [null == D ? void 0 : D.address]);
        let E = (0, n.useMemo)(
          () => ({
            isMobileLeftPanelOpen: m,
            setMobileLeftPanelOpen: g,
            isMobileRightPanelOpen: y,
            setMobileRightPanelOpen: b,
            isLeftPanelExpanded: f,
            setIsLeftPanelExpanded: Z,
            setShowRightPanelMask: q,
            bannersToShow: X,
            toggleBanner: R,
            setPageWarning: S,
            showRightPanelMask: M,
          }),
          [m, y, f, X, R, S, M]
        );
        return (0, r.tZ)(p.Provider, { value: E, children: i });
      });
    },
    3918: function (e, t, i) {
      'use strict';
      i.d(t, {
        RA: function () {
          return o;
        },
      });
      var r = i(78286),
        n = i(58258);
      let a = (0, n.createContext)(null),
        o = () => {
          let e = (0, n.useContext)(a);
          if (!e) throw Error('useUtilityContext must be called inside a UtilityContextProvider');
          return e;
        };
      t.ZP = (e) => {
        let { children: t, countryCode: i } = e;
        return (0, r.tZ)(a.Provider, { value: { countryCode: i }, children: t });
      };
    },
    40803: function (e, t, i) {
      'use strict';
      i.d(t, {
        I: function () {
          return o;
        },
        s: function () {
          return a;
        },
      });
      var r = i(40252),
        n = i(4565);
      let a = (e, t, i) => {
          if (null == e || null == t) return;
          let a = i.toUsd(t);
          if (void 0 !== a)
            return r.MathLib.wMulDown(a, (0, n.safeParseNumber)(Math.pow(1 + e, 1 / 12) - 1, 18));
        },
        o = (e, t, i) => {
          if (null == e || null == t) return;
          let a = (0, n.safeParseNumber)(e, 18),
            o = r.MathLib.wMulDown(a, t);
          return i.toUsd(o);
        };
    },
    56889: function (e, t, i) {
      'use strict';
      i.d(t, {
        Z: function () {
          return r.Z;
        },
      });
      var r = i(16237);
    },
    67355: function (e, t, i) {
      'use strict';
      i.d(t, {
        J: function () {
          return a;
        },
        L: function () {
          return o;
        },
      });
      var r = i(86842),
        n = i(86384);
      let a = (e) => (0, r.WU)(new Date(1e3 * Number(e)), 'MM/dd/yyyy'),
        o = (e) => {
          let { months: t = 0, days: i = 0 } = (0, n.y)({
            start: 0,
            end: 1e3 * Number(null != e ? e : 0),
          });
          return t > 0 ? ''.concat(t, 'M') : ''.concat(i, 'D');
        };
    },
    93319: function (e, t, i) {
      'use strict';
      i.d(t, {
        l: function () {
          return r;
        },
      }),
        i(35047);
      let r = (e) => {
        var t;
        let i = /^(\d*(\.\d+)?)([a-zA-Z]*)$/;
        if (null == e || !i.test(e)) return { value: e, unit: null };
        let r = e.match(i);
        return {
          value: null == r ? void 0 : r[1],
          unit: null !== (t = null == r ? void 0 : r[3]) && void 0 !== t ? t : null,
        };
      };
    },
    85718: function (e, t, i) {
      'use strict';
      i.d(t, {
        T: function () {
          return n;
        },
      });
      var r = i(58258);
      let n = (e) => {
        let t = (0, r.useRef)(null != e ? e : 0n),
          i = (0, r.useRef)(new Map()),
          n = (0, r.useCallback)((e) => {
            i.current.has(e)
              ? (t.current = i.current.get(e))
              : 0 === e && ((t.current = 0n), i.current.clear());
          }, []),
          a = (0, r.useCallback)((e, r) => {
            (t.current += e), i.current.set(r + 1, t.current);
          }, []);
        return { paginatedOffset: t, initOffset: n, setNextOffset: a };
      };
    },
    7518: function (e, t, i) {
      'use strict';
      i.d(t, {
        I: function () {
          return o;
        },
      });
      var r = i(58258),
        n = i(35047),
        a = i(91767);
      let o = (e) => {
        let { first: t, totalCount: i, pagination: o, columnsDefs: l, columnVisibility: s } = e;
        return (0, r.useMemo)(
          () =>
            Array.from({ length: (0, a.a)(t, i, o.pageIndex) }, () =>
              l
                .filter(
                  (e) =>
                    !(
                      (0, n.isDefined)(s) &&
                      (0, n.isDefined)(null == e ? void 0 : e.id) &&
                      (0, n.isDefined)(s[e.id])
                    ) || s[e.id]
                )
                .map((e) => e.skeletonCell)
            ),
          [l, t, o.pageIndex, i, s]
        );
      };
    },
    27987: function (e, t, i) {
      'use strict';
      i.d(t, {
        Z: function () {
          return a;
        },
      });
      var r = i(13191),
        n = i(4565);
      let a = new r.BlueSdkConverter({
        parseAddress: n.safeGetAddress,
        parseNumber: n.safeParseNumber,
      });
    },
  },
  function (e) {
    e.O(
      0,
      [
        9913, 1811, 3261, 1083, 3248, 7287, 6929, 3391, 3515, 6489, 4516, 3613, 92, 5328, 8051,
        7233, 5513, 469, 4655, 825, 8205, 9255, 9510, 7923, 6358, 9429, 6269, 8577, 1744,
      ],
      function () {
        return e((e.s = 24708));
      }
    ),
      (_N_E = e.O());
  },
]);
