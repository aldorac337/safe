try {
  let e =
      'undefined' != typeof window
        ? window
        : 'undefined' != typeof global
          ? global
          : 'undefined' != typeof globalThis
            ? globalThis
            : 'undefined' != typeof self
              ? self
              : {},
    t = new e.Error().stack;
  t &&
    ((e._sentryDebugIds = e._sentryDebugIds || {}),
    (e._sentryDebugIds[t] = '90f42107-e0f6-4370-9509-b0d75c1f3746'),
    (e._sentryDebugIdIdentifier = 'sentry-dbid-90f42107-e0f6-4370-9509-b0d75c1f3746'));
} catch (e) {}
(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
  [5852],
  {
    42625: function (e, t, n) {
      'use strict';
      var r, i;
      Object.defineProperty(t, '__esModule', { value: !0 }), (t.MetaMorphoAction = void 0);
      let a = n(52707),
        s = n(31470);
      ((i = r || (t.MetaMorphoAction = r = {})).setCurator = function (e) {
        return (0, a.encodeFunctionData)({
          abi: s.metaMorphoAbi,
          functionName: 'setCurator',
          args: [e],
        });
      }),
        (i.setIsAllocator = function (e, t) {
          return (0, a.encodeFunctionData)({
            abi: s.metaMorphoAbi,
            functionName: 'setIsAllocator',
            args: [e, t],
          });
        }),
        (i.setFeeRecipient = function (e) {
          return (0, a.encodeFunctionData)({
            abi: s.metaMorphoAbi,
            functionName: 'setFeeRecipient',
            args: [e],
          });
        }),
        (i.setSkimRecipient = function (e) {
          return (0, a.encodeFunctionData)({
            abi: s.metaMorphoAbi,
            functionName: 'setSkimRecipient',
            args: [e],
          });
        }),
        (i.setFee = function (e) {
          return (0, a.encodeFunctionData)({
            abi: s.metaMorphoAbi,
            functionName: 'setFee',
            args: [e],
          });
        }),
        (i.submitTimelock = function (e) {
          return (0, a.encodeFunctionData)({
            abi: s.metaMorphoAbi,
            functionName: 'submitTimelock',
            args: [e],
          });
        }),
        (i.acceptTimelock = function () {
          return (0, a.encodeFunctionData)({
            abi: s.metaMorphoAbi,
            functionName: 'acceptTimelock',
          });
        }),
        (i.revokePendingTimelock = function () {
          return (0, a.encodeFunctionData)({
            abi: s.metaMorphoAbi,
            functionName: 'revokePendingTimelock',
          });
        }),
        (i.submitCap = function (e, t) {
          return (0, a.encodeFunctionData)({
            abi: s.metaMorphoAbi,
            functionName: 'submitCap',
            args: [e, t],
          });
        }),
        (i.acceptCap = function (e) {
          return (0, a.encodeFunctionData)({
            abi: s.metaMorphoAbi,
            functionName: 'acceptCap',
            args: [e],
          });
        }),
        (i.revokePendingCap = function (e) {
          return (0, a.encodeFunctionData)({
            abi: s.metaMorphoAbi,
            functionName: 'revokePendingCap',
            args: [e],
          });
        }),
        (i.submitMarketRemoval = function (e) {
          return (0, a.encodeFunctionData)({
            abi: s.metaMorphoAbi,
            functionName: 'submitMarketRemoval',
            args: [e],
          });
        }),
        (i.revokePendingMarketRemoval = function (e) {
          return (0, a.encodeFunctionData)({
            abi: s.metaMorphoAbi,
            functionName: 'revokePendingMarketRemoval',
            args: [e],
          });
        }),
        (i.submitGuardian = function (e) {
          return (0, a.encodeFunctionData)({
            abi: s.metaMorphoAbi,
            functionName: 'submitGuardian',
            args: [e],
          });
        }),
        (i.acceptGuardian = function () {
          return (0, a.encodeFunctionData)({
            abi: s.metaMorphoAbi,
            functionName: 'acceptGuardian',
          });
        }),
        (i.revokePendingGuardian = function () {
          return (0, a.encodeFunctionData)({
            abi: s.metaMorphoAbi,
            functionName: 'revokePendingGuardian',
          });
        }),
        (i.skim = function (e) {
          return (0, a.encodeFunctionData)({
            abi: s.metaMorphoAbi,
            functionName: 'skim',
            args: [e],
          });
        }),
        (i.setSupplyQueue = function (e) {
          return (0, a.encodeFunctionData)({
            abi: s.metaMorphoAbi,
            functionName: 'setSupplyQueue',
            args: [e],
          });
        }),
        (i.updateWithdrawQueue = function (e) {
          return (0, a.encodeFunctionData)({
            abi: s.metaMorphoAbi,
            functionName: 'updateWithdrawQueue',
            args: [e],
          });
        }),
        (i.reallocate = function (e) {
          return (0, a.encodeFunctionData)({
            abi: s.metaMorphoAbi,
            functionName: 'reallocate',
            args: [e],
          });
        }),
        (i.mint = function (e, t) {
          return (0, a.encodeFunctionData)({
            abi: s.metaMorphoAbi,
            functionName: 'mint',
            args: [e, t],
          });
        }),
        (i.deposit = function (e, t) {
          return (0, a.encodeFunctionData)({
            abi: s.metaMorphoAbi,
            functionName: 'deposit',
            args: [e, t],
          });
        }),
        (i.withdraw = function (e, t, n) {
          return (0, a.encodeFunctionData)({
            abi: s.metaMorphoAbi,
            functionName: 'withdraw',
            args: [e, t, n],
          });
        }),
        (i.redeem = function (e, t, n) {
          return (0, a.encodeFunctionData)({
            abi: s.metaMorphoAbi,
            functionName: 'redeem',
            args: [e, t, n],
          });
        }),
        (t.default = r);
    },
    83602: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.optionalBoolean = void 0),
        (t.fetchHolding = u);
      let r = n(40252),
        i = n(52707),
        a = n(28893),
        s = n(35047),
        o = n(31470),
        l = n(30068);
      async function u(e, n, u, { deployless: c = !0, ...d } = {}) {
        if (((d.chainId ??= await (0, a.getChainId)(u)), n === r.NATIVE_ADDRESS))
          return new r.Holding({
            user: e,
            token: n,
            erc20Allowances: (0, s.fromEntries)(
              r.ERC20_ALLOWANCE_RECIPIENTS.map((e) => [e, i.maxUint256])
            ),
            permit2BundlerAllowance: { amount: 0n, expiration: 0n, nonce: 0n },
            balance: await (0, a.getBalance)(u, { ...d, address: e }),
          });
        if (c) {
          let {
            morpho: s,
            permit2: o = i.zeroAddress,
            bundler3: { generalAdapter1: c },
          } = (0, r.getChainAddresses)(d.chainId);
          try {
            let {
              balance: i,
              erc20Allowances: { generalAdapter1: p, ...h },
              permit2BundlerAllowance: y,
              isErc2612: f,
              erc2612Nonce: m,
              canTransfer: g,
            } = await (0, a.readContract)(u, {
              ...d,
              abi: l.abi,
              code: l.code,
              functionName: 'query',
              args: [
                n,
                e,
                s,
                o,
                c,
                !!r.permissionedBackedTokens[d.chainId]?.has(n),
                !!r.permissionedWrapperTokens[d.chainId]?.has(n),
              ],
            });
            return new r.Holding({
              user: e,
              token: n,
              erc20Allowances: { 'bundler3.generalAdapter1': p, ...h },
              permit2BundlerAllowance: y,
              erc2612Nonce: f ? m : void 0,
              balance: i,
              canTransfer: t.optionalBoolean[g],
            });
          } catch {}
        }
        let p = (0, r.getChainAddresses)(d.chainId),
          [h, y, f, m, g, b] = await Promise.all([
            (0, a.readContract)(u, {
              ...d,
              abi: i.erc20Abi,
              address: n,
              functionName: 'balanceOf',
              args: [e],
            }),
            Promise.all(
              r.ERC20_ALLOWANCE_RECIPIENTS.map(async (t) => {
                let r = (0, s.getValue)(p, t);
                return null == r
                  ? [t, 0n]
                  : [
                      t,
                      await (0, a.readContract)(u, {
                        ...d,
                        abi: i.erc20Abi,
                        address: n,
                        functionName: 'allowance',
                        args: [e, r],
                      }),
                    ];
              })
            ),
            null != p.permit2
              ? (0, a.readContract)(u, {
                  ...d,
                  abi: o.permit2Abi,
                  address: p.permit2,
                  functionName: 'allowance',
                  args: [e, n, p.bundler3.generalAdapter1],
                }).then(([e, t, n]) => ({ amount: e, expiration: BigInt(t), nonce: BigInt(n) }))
              : { amount: 0n, expiration: 0n, nonce: 0n },
            (0, a.readContract)(u, {
              ...d,
              abi: o.erc2612Abi,
              address: n,
              functionName: 'nonces',
              args: [e],
            }).catch(() => void 0),
            r.permissionedBackedTokens[d.chainId]?.has(n)
              ? (0, a.readContract)(u, {
                  ...d,
                  abi: o.wrappedBackedTokenAbi,
                  address: n,
                  functionName: 'whitelistControllerAggregator',
                })
              : void 0,
            (0, a.readContract)(u, {
              ...d,
              abi: o.permissionedErc20WrapperAbi,
              address: n,
              functionName: 'hasPermission',
              args: [e],
            }).catch(() => !r.permissionedWrapperTokens[d.chainId]?.has(n)),
          ]),
          w = new r.Holding({
            user: e,
            token: n,
            erc20Allowances: (0, s.fromEntries)(y),
            permit2BundlerAllowance: f,
            erc2612Nonce: m,
            balance: h,
            canTransfer: b,
          });
        return (
          g &&
            (w.canTransfer = await (0, a.readContract)(u, {
              ...d,
              abi: o.whitelistControllerAggregatorV2Abi,
              address: g,
              functionName: 'isWhitelisted',
              args: [e],
            }).catch(() => void 0)),
          w
        );
      }
      t.optionalBoolean = [void 0, !1, !0];
    },
    63304: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }), (t.fetchMarket = l);
      let r = n(52707),
        i = n(40252),
        a = n(28893),
        s = n(31470),
        o = n(69106);
      async function l(e, t, { deployless: n = !0, ...l } = {}) {
        l.chainId ??= await (0, a.getChainId)(t);
        let { morpho: u, adaptiveCurveIrm: c } = (0, i.getChainAddresses)(l.chainId);
        if (n)
          try {
            let {
              marketParams: n,
              market: {
                totalSupplyAssets: r,
                totalSupplyShares: s,
                totalBorrowAssets: d,
                totalBorrowShares: p,
                lastUpdate: h,
                fee: y,
              },
              hasPrice: f,
              price: m,
              rateAtTarget: g,
            } = await (0, a.readContract)(t, {
              ...l,
              abi: o.abi,
              code: o.code,
              functionName: 'query',
              args: [u, e, c],
            });
            return new i.Market({
              params: new i.MarketParams(n),
              totalSupplyAssets: r,
              totalBorrowAssets: d,
              totalSupplyShares: s,
              totalBorrowShares: p,
              lastUpdate: h,
              fee: y,
              price: f ? m : void 0,
              rateAtTarget: n.irm === c ? g : void 0,
            });
          } catch {}
        let [d, p, h, y, f] = await (0, a.readContract)(t, {
            ...l,
            address: u,
            abi: s.blueAbi,
            functionName: 'idToMarketParams',
            args: [e],
          }),
          m = new i.MarketParams({ loanToken: d, collateralToken: p, oracle: h, irm: y, lltv: f }),
          [[g, b, w, v, T, A], E, C] = await Promise.all([
            (0, a.readContract)(t, {
              ...l,
              address: u,
              abi: s.blueAbi,
              functionName: 'market',
              args: [m.id],
            }),
            m.oracle !== r.zeroAddress
              ? (0, a.readContract)(t, {
                  ...l,
                  address: m.oracle,
                  abi: s.blueOracleAbi,
                  functionName: 'price',
                }).catch(() => void 0)
              : void 0,
            m.irm === c
              ? await (0, a.readContract)(t, {
                  ...l,
                  address: c,
                  abi: s.adaptiveCurveIrmAbi,
                  functionName: 'rateAtTarget',
                  args: [m.id],
                })
              : void 0,
          ]);
        return new i.Market({
          params: m,
          totalSupplyAssets: g,
          totalBorrowAssets: w,
          totalSupplyShares: b,
          totalBorrowShares: v,
          lastUpdate: T,
          fee: A,
          price: E,
          rateAtTarget: C,
        });
      }
    },
    87706: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }), (t.fetchMarketParams = s);
      let r = n(40252),
        i = n(28893),
        a = n(31470);
      async function s(e, t, { chainId: n } = {}) {
        let s = (0, r._try)(() => r.MarketParams.get(e), r.UnknownMarketParamsError);
        if (!s) {
          n ??= await (0, i.getChainId)(t);
          let { morpho: o } = (0, r.getChainAddresses)(n),
            [l, u, c, d, p] = await (0, i.readContract)(t, {
              address: o,
              abi: a.blueAbi,
              functionName: 'idToMarketParams',
              args: [e],
              blockTag: 'latest',
            });
          s = new r.MarketParams({ loanToken: l, collateralToken: u, oracle: c, irm: d, lltv: p });
        }
        return s;
      }
    },
    91936: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.fetchPosition = o),
        (t.fetchPreLiquidationParams = l),
        (t.fetchAccrualPosition = u),
        (t.fetchPreLiquidationPosition = c);
      let r = n(40252),
        i = n(28893),
        a = n(31470),
        s = n(63304);
      async function o(e, t, n, s = {}) {
        s.chainId ??= await (0, i.getChainId)(n);
        let { morpho: o } = (0, r.getChainAddresses)(s.chainId),
          [l, u, c] = await (0, i.readContract)(n, {
            ...s,
            address: o,
            abi: a.blueAbi,
            functionName: 'position',
            args: [t, e],
          });
        return new r.Position({
          user: e,
          marketId: t,
          supplyShares: l,
          borrowShares: u,
          collateral: c,
        });
      }
      async function l(e, t, n = {}) {
        n.chainId = await (0, i.getChainId)(t);
        let {
          preLltv: s,
          preLIF1: o,
          preLIF2: l,
          preLCF1: u,
          preLCF2: c,
          preLiquidationOracle: d,
        } = await (0, i.readContract)(t, {
          ...n,
          address: e,
          abi: a.preLiquidationAbi,
          functionName: 'preLiquidationParams',
        });
        return new r.PreLiquidationParams({
          preLltv: s,
          preLCF1: u,
          preLCF2: c,
          preLIF1: o,
          preLIF2: l,
          preLiquidationOracle: d,
        });
      }
      async function u(e, t, n, a = {}) {
        a.chainId ??= await (0, i.getChainId)(n);
        let [l, u] = await Promise.all([await o(e, t, n, a), await (0, s.fetchMarket)(t, n, a)]);
        return new r.AccrualPosition(l, u);
      }
      async function c(e, t, n, u, c = {}) {
        c.chainId ??= await (0, i.getChainId)(u);
        let [d, p, h] = await Promise.all([o(e, t, u, c), (0, s.fetchMarket)(t, u, c), l(n, u, c)]),
          y = await (0, i.readContract)(u, {
            ...c,
            address: h.preLiquidationOracle,
            abi: a.blueOracleAbi,
            functionName: 'price',
          }).catch(() => void 0);
        return new r.PreLiquidationPosition(
          { ...d, preLiquidationParams: h, preLiquidation: n, preLiquidationOraclePrice: y },
          p
        );
      }
    },
    47622: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.decodeBytes32String = void 0),
        (t.fetchToken = l);
      let r = n(52707),
        i = n(40252),
        a = n(28893),
        s = n(31470),
        o = n(13496);
      async function l(e, n, { deployless: l = !0, ...u } = {}) {
        if (((u.chainId ??= await (0, a.getChainId)(n)), e === i.NATIVE_ADDRESS))
          return i.Token.native(u.chainId);
        let { wstEth: c, stEth: d } = (0, i.getChainAddresses)(u.chainId);
        if (l)
          try {
            let t = e === c,
              r = await (0, a.readContract)(n, {
                ...u,
                abi: o.abi,
                code: o.code,
                functionName: 'query',
                args: [e, t],
              }),
              s = r.hasEip5267Domain ? new i.Eip5267Domain(r.eip5267Domain) : void 0;
            if (t && null != d)
              return new i.ExchangeRateWrappedToken(
                { ...r, address: e, eip5267Domain: s },
                d,
                r.stEthPerWstEth
              );
            let l = (0, i.getUnwrappedToken)(e, u.chainId);
            if (l)
              return new i.ConstantWrappedToken(
                { ...r, address: e, eip5267Domain: s },
                l,
                r.decimals
              );
            return new i.Token({ ...r, address: e, eip5267Domain: s });
          } catch {}
        let [p, h, y, f] = await Promise.all([
            (0, a.readContract)(n, {
              ...u,
              address: e,
              abi: r.erc20Abi,
              functionName: 'decimals',
            }).catch(() => void 0),
            (0, a.readContract)(n, {
              ...u,
              address: e,
              abi: r.erc20Abi,
              functionName: 'symbol',
            }).catch(() =>
              (0, a.readContract)(n, {
                ...u,
                address: e,
                abi: r.erc20Abi_bytes32,
                functionName: 'symbol',
              })
                .then(t.decodeBytes32String)
                .catch(() => void 0)
            ),
            (0, a.readContract)(n, {
              ...u,
              address: e,
              abi: r.erc20Abi,
              functionName: 'name',
            }).catch(() =>
              (0, a.readContract)(n, {
                ...u,
                address: e,
                abi: r.erc20Abi_bytes32,
                functionName: 'name',
              })
                .then(t.decodeBytes32String)
                .catch(() => void 0)
            ),
            (0, a.readContract)(n, {
              ...u,
              address: e,
              abi: s.erc5267Abi,
              functionName: 'eip712Domain',
            })
              .then(
                ([e, t, n, r, a, s, o]) =>
                  new i.Eip5267Domain({
                    fields: e,
                    name: t,
                    version: n,
                    chainId: r,
                    verifyingContract: a,
                    salt: s,
                    extensions: o,
                  })
              )
              .catch(() => void 0),
          ]),
          m = { address: e, name: y, symbol: h, decimals: p, eip5267Domain: f };
        if (e === c && d) {
          let e = await (0, a.readContract)(n, {
            ...u,
            address: c,
            abi: s.wstEthAbi,
            functionName: 'stEthPerToken',
          });
          return new i.ExchangeRateWrappedToken(m, d, e);
        }
        let g = (0, i.getUnwrappedToken)(e, u.chainId);
        return g ? new i.ConstantWrappedToken(m, g, m.decimals) : new i.Token(m);
      }
      t.decodeBytes32String = (e) => ((0, r.isHex)(e) ? (0, r.hexToString)(e, { size: 32 }) : e);
    },
    41289: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }), (t.fetchUser = s);
      let r = n(40252),
        i = n(28893),
        a = n(31470);
      async function s(e, t, n = {}) {
        n.chainId ??= await (0, i.getChainId)(t);
        let {
            morpho: s,
            bundler3: { generalAdapter1: o },
          } = (0, r.getChainAddresses)(n.chainId),
          [l, u] = await Promise.all([
            (0, i.readContract)(t, {
              ...n,
              address: s,
              abi: a.blueAbi,
              functionName: 'isAuthorized',
              args: [e, o],
            }),
            (0, i.readContract)(t, {
              ...n,
              address: s,
              abi: a.blueAbi,
              functionName: 'nonce',
              args: [e],
            }),
          ]);
        return new r.User({ address: e, isBundlerAuthorized: l, morphoNonce: u });
      }
    },
    10843: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.fetchVault = c),
        (t.fetchAccrualVault = d);
      let r = n(52707),
        i = n(40252),
        a = n(28893),
        s = n(31470),
        o = n(2775),
        l = n(27065),
        u = n(36341);
      async function c(e, t, { deployless: n = !0, ...o } = {}) {
        let c;
        o.chainId ??= await (0, a.getChainId)(t);
        let { publicAllocator: d } = (0, i.getChainAddresses)(o.chainId);
        if (n)
          try {
            let {
              config: n,
              owner: s,
              curator: u,
              guardian: c,
              timelock: p,
              pendingTimelock: h,
              pendingGuardian: y,
              pendingOwner: f,
              fee: m,
              feeRecipient: g,
              skimRecipient: b,
              totalSupply: w,
              totalAssets: v,
              lastTotalAssets: T,
              supplyQueue: A,
              withdrawQueue: E,
              publicAllocatorConfig: C,
            } = await (0, a.readContract)(t, {
              ...o,
              abi: l.abi,
              code: l.code,
              functionName: 'query',
              args: [e, d ?? r.zeroAddress],
            });
            return new i.Vault({
              ...new i.VaultConfig({
                ...n,
                eip5267Domain: new i.Eip5267Domain(n.eip5267Domain),
                address: e,
              }),
              owner: s,
              curator: u,
              guardian: c,
              feeRecipient: g,
              skimRecipient: b,
              timelock: p,
              fee: m,
              pendingOwner: f,
              pendingGuardian: y,
              pendingTimelock: h,
              publicAllocatorConfig: null != d ? C : void 0,
              supplyQueue: A,
              withdrawQueue: E,
              totalSupply: w,
              totalAssets: v,
              lastTotalAssets: T,
            });
          } catch {}
        let [p, h, y, f, m, g, b, w, v, T, A, E, C, _, I, S, P, O] = await Promise.all([
          (0, u.fetchVaultConfig)(e, t, o),
          (0, a.readContract)(t, {
            ...o,
            address: e,
            abi: s.metaMorphoAbi,
            functionName: 'curator',
          }),
          (0, a.readContract)(t, { ...o, address: e, abi: s.metaMorphoAbi, functionName: 'owner' }),
          (0, a.readContract)(t, {
            ...o,
            address: e,
            abi: s.metaMorphoAbi,
            functionName: 'guardian',
          }),
          (0, a.readContract)(t, {
            ...o,
            address: e,
            abi: s.metaMorphoAbi,
            functionName: 'timelock',
          }),
          (0, a.readContract)(t, {
            ...o,
            address: e,
            abi: s.metaMorphoAbi,
            functionName: 'pendingTimelock',
          }).then(([e, t]) => ({ value: e, validAt: t })),
          (0, a.readContract)(t, {
            ...o,
            address: e,
            abi: s.metaMorphoAbi,
            functionName: 'pendingGuardian',
          }).then(([e, t]) => ({ value: e, validAt: t })),
          (0, a.readContract)(t, {
            ...o,
            address: e,
            abi: s.metaMorphoAbi,
            functionName: 'pendingOwner',
          }),
          (0, a.readContract)(t, { ...o, address: e, abi: s.metaMorphoAbi, functionName: 'fee' }),
          (0, a.readContract)(t, {
            ...o,
            address: e,
            abi: s.metaMorphoAbi,
            functionName: 'feeRecipient',
          }),
          (0, a.readContract)(t, {
            ...o,
            address: e,
            abi: s.metaMorphoAbi,
            functionName: 'skimRecipient',
          }),
          (0, a.readContract)(t, {
            ...o,
            address: e,
            abi: s.metaMorphoAbi,
            functionName: 'totalSupply',
          }),
          (0, a.readContract)(t, {
            ...o,
            address: e,
            abi: s.metaMorphoAbi,
            functionName: 'totalAssets',
          }),
          (0, a.readContract)(t, {
            ...o,
            address: e,
            abi: s.metaMorphoAbi,
            functionName: 'lastTotalAssets',
          }),
          (0, a.readContract)(t, {
            ...o,
            address: e,
            abi: s.metaMorphoAbi,
            functionName: 'lostAssets',
          }).catch(() => void 0),
          (0, a.readContract)(t, {
            ...o,
            address: e,
            abi: s.metaMorphoAbi,
            functionName: 'supplyQueueLength',
          }),
          (0, a.readContract)(t, {
            ...o,
            address: e,
            abi: s.metaMorphoAbi,
            functionName: 'withdrawQueueLength',
          }),
          null != d &&
            (0, a.readContract)(t, {
              ...o,
              address: e,
              abi: s.metaMorphoAbi,
              functionName: 'isAllocator',
              args: [d],
            }),
        ]);
        O &&
          (c = Promise.all([
            (0, a.readContract)(t, {
              ...o,
              address: d,
              abi: s.publicAllocatorAbi,
              functionName: 'admin',
              args: [e],
            }),
            (0, a.readContract)(t, {
              ...o,
              address: d,
              abi: s.publicAllocatorAbi,
              functionName: 'fee',
              args: [e],
            }),
            (0, a.readContract)(t, {
              ...o,
              address: d,
              abi: s.publicAllocatorAbi,
              functionName: 'accruedFee',
              args: [e],
            }),
          ]).then(([e, t, n]) => ({ admin: e, fee: t, accruedFee: n })));
        let [N, x, M] = await Promise.all([
          Promise.all(
            Array(Number(S))
              .fill(null)
              .map((n, r) =>
                (0, a.readContract)(t, {
                  ...o,
                  address: e,
                  abi: s.metaMorphoAbi,
                  functionName: 'supplyQueue',
                  args: [BigInt(r)],
                })
              )
          ),
          Promise.all(
            Array(Number(P))
              .fill(null)
              .map((n, r) =>
                (0, a.readContract)(t, {
                  ...o,
                  address: e,
                  abi: s.metaMorphoAbi,
                  functionName: 'withdrawQueue',
                  args: [BigInt(r)],
                })
              )
          ),
          c,
        ]);
        return new i.Vault({
          ...p,
          owner: y,
          curator: h,
          guardian: f,
          feeRecipient: T,
          skimRecipient: A,
          timelock: m,
          fee: v,
          pendingOwner: w,
          pendingGuardian: b,
          pendingTimelock: g,
          publicAllocatorConfig: M,
          supplyQueue: N,
          withdrawQueue: x,
          totalSupply: E,
          totalAssets: C,
          lastTotalAssets: _,
          lostAssets: I,
        });
      }
      async function d(e, t, n = {}) {
        n.chainId ??= await (0, a.getChainId)(t);
        let r = await c(e, t, n),
          s = await Promise.all(
            Array.from(r.withdrawQueue, (e) =>
              (0, o.fetchVaultMarketAllocation)(r.address, e, t, n)
            )
          );
        return new i.AccrualVault(r, s);
      }
    },
    36341: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }), (t.fetchVaultConfig = o);
      let r = n(40252),
        i = n(28893),
        a = n(31470),
        s = n(47622);
      async function o(e, t, n = {}) {
        n.chainId ??= await (0, i.getChainId)(t);
        let [o, l, u] = await Promise.all([
          (0, s.fetchToken)(e, t, n),
          (0, i.readContract)(t, { ...n, address: e, abi: a.metaMorphoAbi, functionName: 'asset' }),
          (0, i.readContract)(t, {
            ...n,
            address: e,
            abi: a.metaMorphoAbi,
            functionName: 'DECIMALS_OFFSET',
          }),
        ]);
        return new r.VaultConfig({ ...o, asset: l, decimalsOffset: BigInt(u) });
      }
    },
    2775: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }), (t.fetchVaultMarketAllocation = o);
      let r = n(40252),
        i = n(28893),
        a = n(91936),
        s = n(45581);
      async function o(e, t, n, o = {}) {
        o.chainId ??= await (0, i.getChainId)(n);
        let [l, u] = await Promise.all([
          (0, s.fetchVaultMarketConfig)(e, t, n, o),
          (0, a.fetchAccrualPosition)(e, t, n, o),
        ]);
        return new r.VaultMarketAllocation({ config: l, position: u });
      }
    },
    45581: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }), (t.fetchVaultMarketConfig = o);
      let r = n(40252),
        i = n(28893),
        a = n(31470),
        s = n(33113);
      async function o(e, t, n, o = {}) {
        o.chainId ??= await (0, i.getChainId)(n);
        let [[l, u, c], d, p] = await Promise.all([
          (0, i.readContract)(n, {
            ...o,
            address: e,
            abi: a.metaMorphoAbi,
            functionName: 'config',
            args: [t],
          }),
          (0, i.readContract)(n, {
            ...o,
            address: e,
            abi: a.metaMorphoAbi,
            functionName: 'pendingCap',
            args: [t],
          }).then(([e, t]) => ({ value: e, validAt: t })),
          (0, s.fetchVaultMarketPublicAllocatorConfig)(e, t, n, o),
        ]);
        return new r.VaultMarketConfig({
          vault: e,
          marketId: t,
          cap: l,
          pendingCap: d,
          enabled: u,
          removableAt: c,
          publicAllocatorConfig: p,
        });
      }
    },
    33113: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.fetchVaultMarketPublicAllocatorConfig = s);
      let r = n(40252),
        i = n(28893),
        a = n(31470);
      async function s(e, t, n, s = {}) {
        s.chainId ??= await (0, i.getChainId)(n);
        let { publicAllocator: o } = (0, r.getChainAddresses)(s.chainId);
        if (null == o) return;
        let [l, u] = await (0, i.readContract)(n, {
          ...s,
          address: o,
          abi: a.publicAllocatorAbi,
          functionName: 'flowCaps',
          args: [e, t],
        });
        return new r.VaultMarketPublicAllocatorConfig({
          vault: e,
          marketId: t,
          maxIn: l,
          maxOut: u,
        });
      }
    },
    86122: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }), (t.fetchVaultUser = u);
      let r = n(52707),
        i = n(40252),
        a = n(28893),
        s = n(31470),
        o = n(23008),
        l = n(36341);
      async function u(e, t, n, { deployless: u = !0, ...c } = {}) {
        if (((c.chainId ??= await (0, a.getChainId)(n)), u))
          try {
            let { isAllocator: r, allowance: s } = await (0, a.readContract)(n, {
              ...c,
              abi: o.abi,
              code: o.code,
              functionName: 'query',
              args: [e, t],
            });
            return new i.VaultUser({ vault: e, user: t, isAllocator: r, allowance: s });
          } catch {}
        let d = await (0, l.fetchVaultConfig)(e, n, c),
          [p, h] = await Promise.all([
            (0, a.readContract)(n, {
              ...c,
              address: d.asset,
              abi: r.erc20Abi,
              functionName: 'allowance',
              args: [t, e],
            }),
            (0, a.readContract)(n, {
              ...c,
              address: e,
              abi: s.metaMorphoAbi,
              functionName: 'isAllocator',
              args: [t],
            }),
          ]);
        return new i.VaultUser({ vault: e, user: t, isAllocator: h, allowance: p });
      }
    },
    66300: function (e, t, n) {
      'use strict';
      var r =
          (this && this.__createBinding) ||
          (Object.create
            ? function (e, t, n, r) {
                void 0 === r && (r = n);
                var i = Object.getOwnPropertyDescriptor(t, n);
                (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
                  (i = {
                    enumerable: !0,
                    get: function () {
                      return t[n];
                    },
                  }),
                  Object.defineProperty(e, r, i);
              }
            : function (e, t, n, r) {
                void 0 === r && (r = n), (e[r] = t[n]);
              }),
        i =
          (this && this.__exportStar) ||
          function (e, t) {
            for (var n in e)
              'default' === n || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n);
          };
      Object.defineProperty(t, '__esModule', { value: !0 }),
        i(n(83602), t),
        i(n(91936), t),
        i(n(87706), t),
        i(n(63304), t),
        i(n(47622), t),
        i(n(41289), t),
        i(n(36341), t),
        i(n(10843), t),
        i(n(86122), t),
        i(n(45581), t),
        i(n(2775), t),
        i(n(33113), t);
    },
    4565: function (e, t, n) {
      'use strict';
      var r =
          (this && this.__createBinding) ||
          (Object.create
            ? function (e, t, n, r) {
                void 0 === r && (r = n);
                var i = Object.getOwnPropertyDescriptor(t, n);
                (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
                  (i = {
                    enumerable: !0,
                    get: function () {
                      return t[n];
                    },
                  }),
                  Object.defineProperty(e, r, i);
              }
            : function (e, t, n, r) {
                void 0 === r && (r = n), (e[r] = t[n]);
              }),
        i =
          (this && this.__exportStar) ||
          function (e, t) {
            for (var n in e)
              'default' === n || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n);
          };
      Object.defineProperty(t, '__esModule', { value: !0 }),
        i(n(31470), t),
        i(n(66300), t),
        i(n(52954), t),
        i(n(18806), t),
        i(n(69321), t),
        i(n(42625), t);
    },
    30068: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.code = t.abi = void 0),
        (t.abi = [
          {
            inputs: [
              { internalType: 'contract IERC20Permit', name: 'token', type: 'address' },
              { internalType: 'address', name: 'account', type: 'address' },
              { internalType: 'address', name: 'morpho', type: 'address' },
              { internalType: 'contract IPermit2', name: 'permit2', type: 'address' },
              { internalType: 'address', name: 'generalAdapter1', type: 'address' },
              { internalType: 'bool', name: 'isWrappedBackedToken', type: 'bool' },
              { internalType: 'bool', name: 'isErc20Permissioned', type: 'bool' },
            ],
            name: 'query',
            outputs: [
              {
                components: [
                  { internalType: 'uint256', name: 'balance', type: 'uint256' },
                  {
                    components: [
                      { internalType: 'uint256', name: 'morpho', type: 'uint256' },
                      { internalType: 'uint256', name: 'permit2', type: 'uint256' },
                      { internalType: 'uint256', name: 'generalAdapter1', type: 'uint256' },
                    ],
                    internalType: 'struct ERC20Allowances',
                    name: 'erc20Allowances',
                    type: 'tuple',
                  },
                  {
                    components: [
                      { internalType: 'uint160', name: 'amount', type: 'uint160' },
                      { internalType: 'uint48', name: 'expiration', type: 'uint48' },
                      { internalType: 'uint48', name: 'nonce', type: 'uint48' },
                    ],
                    internalType: 'struct Permit2Allowance',
                    name: 'permit2BundlerAllowance',
                    type: 'tuple',
                  },
                  { internalType: 'bool', name: 'isErc2612', type: 'bool' },
                  { internalType: 'uint256', name: 'erc2612Nonce', type: 'uint256' },
                  { internalType: 'enum OptionalBoolean', name: 'canTransfer', type: 'uint8' },
                ],
                internalType: 'struct HoldingResponse',
                name: 'res',
                type: 'tuple',
              },
            ],
            stateMutability: 'view',
            type: 'function',
          },
        ]),
        (t.code =
          '0x6080806040523460155761077a908161001a8239f35b5f80fdfe60806040526004361015610011575f80fd5b5f3560e01c634755ff3e14610024575f80fd5b346104b05760e03660031901126104b0576004356001600160a01b03811681036104b057602435906001600160a01b03821682036104b057604435916001600160a01b03831683036104b057606435926001600160a01b03841684036104b057608435926001600160a01b03841684036104b05760a43580151581036104b05760c43580151581036104b0576101406040525f60805260a0966100c56106ef565b885260c0946100d26106ef565b86525f60e0818152610100829052610120919091526040516370a0823160e01b81526001600160a01b038981166004830152919991602090829060249082908b165afa9081156105c1575f91610669575b50608052604051636eb1769f60e11b81526001600160a01b03808a166004830152909216602483015260208280604481015b03816001600160a01b038a165afa9182156105c1575f92610635575b50604051636eb1769f60e11b81526001600160a01b0389811660048301528416602482015291602083806044810103816001600160a01b038b165afa80156105c1575f90610601575b604051636eb1769f60e11b81526001600160a01b03808c16600483015284166024820152935060208480604481015b03816001600160a01b038c165afa9081156105c1575f916105cc575b6060945060405192610216846106b1565b83526020830152604080830191909152908b525163927da10560e01b81526001600160a01b038981166004830152878116602483015291821660448201529283916064918391165afa9081156105c1575f9161054c575b508452604051623f675f60e91b81526001600160a01b0386811660048301526020908290602490829088165afa5f9181610518575b5061050a575b50604051624b894760e91b81526001600160a01b0386811660048301526020908290602490829088165afa5f91816104e9575b506104c65750156104bc576102f460015b610120610738565b61038e575b5065ffffffffffff91506040908180519560805187525180516020880152602081015182880152015160608601525160018060a01b0381511660808601528260208201511660a086015201511660c083015251151560e0820152608080015161010082015260a06080015190600382101561037a5761014091610120820152f35b634e487b7160e01b5f52602160045260245ffd5b5f6101205260405163650369bf60e01b815290602090829060049082906001600160a01b03165afa5f918161046a575b509065ffffffffffff93604093926103d9575b5050906102f9565b8351633af32abf60e01b81526001600160a01b0391821660048201529160209183916024918391165afa5f9181610439575b50610417575b806103d1565b1561042f576104296002610120610738565b5f610411565b61042960016102ec565b61045c91925060203d602011610463575b61045481836106cd565b810190610720565b905f61040b565b503d61044a565b909291506020813d6020116104b4575b81610487602093836106cd565b810103126104b05751916001600160a01b03831683036104b05790919065ffffffffffff6103be565b5f80fd5b3d915061047a565b6102f460026102ec565b1590506104df576104da6002610120610738565b6102f4565b6104da60016102ec565b61050391925060203d6020116104635761045481836106cd565b905f6102db565b60018752610100525f6102a8565b9091506020813d602011610544575b81610534602093836106cd565b810103126104b05751905f6102a2565b3d9150610527565b90506060813d6060116105b9575b81610567606093836106cd565b810103126104b0576040519061057c826106b1565b80516001600160a01b03811681036104b0576105ae9160409184526105a36020820161070d565b60208501520161070d565b60408201525f61026d565b3d915061055a565b6040513d5f823e3d90fd5b90506020843d6020116105f9575b816105e7602093836106cd565b810103126104b0576060935190610205565b3d91506105da565b506020833d60201161062d575b8161061b602093836106cd565b810103126104b0576101e992516101ba565b3d915061060e565b9091506020813d602011610661575b81610651602093836106cd565b810103126104b05751905f610171565b3d9150610644565b90506020813d602011610695575b81610684602093836106cd565b810103126104b05751610155610123565b3d9150610677565b634e487b7160e01b5f52604160045260245ffd5b6060810190811067ffffffffffffffff82111761069d57604052565b90601f8019910116810190811067ffffffffffffffff82111761069d57604052565b604051906106fc826106b1565b5f6040838281528260208201520152565b519065ffffffffffff821682036104b057565b908160209103126104b0575180151581036104b05790565b600382101561037a575256fea2646970667358221220be21ea669a9321ae5df187895f9c1db309e495cb210c0ad5f5474ec0a7be853b64736f6c634300081b0033');
    },
    69106: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.code = t.abi = void 0),
        (t.abi = [
          {
            inputs: [
              { internalType: 'contract IMorpho', name: 'morpho', type: 'address' },
              { internalType: 'Id', name: 'id', type: 'bytes32' },
              {
                internalType: 'contract IAdaptiveCurveIrm',
                name: 'adaptiveCurveIrm',
                type: 'address',
              },
            ],
            name: 'query',
            outputs: [
              {
                components: [
                  {
                    components: [
                      { internalType: 'address', name: 'loanToken', type: 'address' },
                      { internalType: 'address', name: 'collateralToken', type: 'address' },
                      { internalType: 'address', name: 'oracle', type: 'address' },
                      { internalType: 'address', name: 'irm', type: 'address' },
                      { internalType: 'uint256', name: 'lltv', type: 'uint256' },
                    ],
                    internalType: 'struct MarketParams',
                    name: 'marketParams',
                    type: 'tuple',
                  },
                  {
                    components: [
                      { internalType: 'uint128', name: 'totalSupplyAssets', type: 'uint128' },
                      { internalType: 'uint128', name: 'totalSupplyShares', type: 'uint128' },
                      { internalType: 'uint128', name: 'totalBorrowAssets', type: 'uint128' },
                      { internalType: 'uint128', name: 'totalBorrowShares', type: 'uint128' },
                      { internalType: 'uint128', name: 'lastUpdate', type: 'uint128' },
                      { internalType: 'uint128', name: 'fee', type: 'uint128' },
                    ],
                    internalType: 'struct Market',
                    name: 'market',
                    type: 'tuple',
                  },
                  { internalType: 'bool', name: 'hasPrice', type: 'bool' },
                  { internalType: 'uint256', name: 'price', type: 'uint256' },
                  { internalType: 'uint256', name: 'rateAtTarget', type: 'uint256' },
                ],
                internalType: 'struct MarketResponse',
                name: 'res',
                type: 'tuple',
              },
            ],
            stateMutability: 'view',
            type: 'function',
          },
        ]),
        (t.code =
          '0x608080604052346015576104f8908161001a8239f35b5f80fdfe6080806040526004361015610012575f80fd5b5f3560e01c63d8f172c414610025575f80fd5b34610285576060366003190112610285576004356001600160a01b0381169190829003610285576044356001600160a01b0381169290602435908490036102855761006f8361042c565b60405161007b8161042c565b5f81525f60208201525f60408201525f60608201525f60808201528352602083016040516100a88161045c565b5f81525f60208201525f60408201525f60608201525f60808201525f60a0820152815260408401905f825260608501925f845260808601945f8652604051632c3c915760e01b815282600482015260a081602481855afa908115610291575f9161039f575b5060249160c091895260405192838092632e3071cd60e11b82528660048301525afa908115610291575f91610302575b5082528551604001516001600160a01b03168061029c575b508551606001516001600160a01b0316871461021e575b5060408051955180516001600160a01b0390811688526020808301518216818a015282840151821689850152606080840151909216828a015260809283015189840152935180516001600160801b0390811660a08b81019190915295820151811660c08b015293810151841660e08a0152908101518316610100890152908101518216610120880152909101511661014085015251151561016084015251610180830152516101a08201526101c09150f35b6020906024604051809981936301977b5760e01b835260048301525afa958615610291575f96610258575b509483526101c09460a061016c565b95506020863d602011610289575b8161027360209383610478565b810103126102855794519460a0610249565b5f80fd5b3d9150610266565b6040513d5f823e3d90fd5b60206004916040519283809263501ad8ff60e11b82525afa5f91816102ce575b5015610155576001845284525f610155565b9091506020813d6020116102fa575b816102ea60209383610478565b810103126102855751905f6102bc565b3d91506102dd565b905060c0813d60c011610397575b8161031d60c09383610478565b810103126102855761038c60a0604051926103378461045c565b610340816104ae565b845261034e602082016104ae565b602085015261035f604082016104ae565b6040850152610370606082016104ae565b6060850152610381608082016104ae565b6080850152016104ae565b60a08201525f61013d565b3d9150610310565b905060a0813d60a011610424575b816103ba60a09383610478565b810103126102855760249160c0916080604051916103d78361042c565b6103e08161049a565b83526103ee6020820161049a565b60208401526103ff6040820161049a565b60408401526104106060820161049a565b60608401520151608082015291509161010d565b3d91506103ad565b60a0810190811067ffffffffffffffff82111761044857604052565b634e487b7160e01b5f52604160045260245ffd5b60c0810190811067ffffffffffffffff82111761044857604052565b90601f8019910116810190811067ffffffffffffffff82111761044857604052565b51906001600160a01b038216820361028557565b51906001600160801b03821682036102855756fea2646970667358221220acbd98f027aaca3ed2f90675c4eece5d7bd1a9fbbbb62956dae5a7491ebc745564736f6c634300081b0033');
    },
    13496: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.code = t.abi = void 0),
        (t.abi = [
          {
            inputs: [
              { internalType: 'contract IERC20', name: 'token', type: 'address' },
              { internalType: 'bool', name: 'isWstEth', type: 'bool' },
            ],
            name: 'query',
            outputs: [
              {
                components: [
                  { internalType: 'uint256', name: 'decimals', type: 'uint256' },
                  { internalType: 'bool', name: 'hasSymbol', type: 'bool' },
                  { internalType: 'string', name: 'symbol', type: 'string' },
                  { internalType: 'bool', name: 'hasName', type: 'bool' },
                  { internalType: 'string', name: 'name', type: 'string' },
                  { internalType: 'uint256', name: 'stEthPerWstEth', type: 'uint256' },
                  {
                    components: [
                      { internalType: 'bytes1', name: 'fields', type: 'bytes1' },
                      { internalType: 'string', name: 'name', type: 'string' },
                      { internalType: 'string', name: 'version', type: 'string' },
                      { internalType: 'uint256', name: 'chainId', type: 'uint256' },
                      { internalType: 'address', name: 'verifyingContract', type: 'address' },
                      { internalType: 'bytes32', name: 'salt', type: 'bytes32' },
                      { internalType: 'uint256[]', name: 'extensions', type: 'uint256[]' },
                    ],
                    internalType: 'struct Eip5267Domain',
                    name: 'eip5267Domain',
                    type: 'tuple',
                  },
                  { internalType: 'bool', name: 'hasEip5267Domain', type: 'bool' },
                ],
                internalType: 'struct TokenResponse',
                name: 'res',
                type: 'tuple',
              },
            ],
            stateMutability: 'view',
            type: 'function',
          },
        ]),
        (t.code =
          '0x60808060405234601557610635908161001a8239f35b5f80fdfe6080806040526004361015610012575f80fd5b5f3560e01c63287861f914610025575f80fd5b346103fb5760403660031901126103fb576004356001600160a01b03811691908290036103fb576024359182151583036103fb57610100820182811067ffffffffffffffff8211176103ff576040525f825260208201905f8252604083016060815260608401905f825260808501906060825260a08601945f865260c08701946040516100b181610542565b5f815260606020820152606060408201525f60608201525f60808201525f60a0820152606060c0820152865260e08801985f8a526040516306fdde0360e01b81525f81600481865afa5f9181610502575b506104f6575b506040516395d89b4160e01b81525f81600481865afa5f91816104d2575b506104c6575b5060405163313ce56760e01b8152602081600481865afa5f9181610488575b5061047d575b50610413575b5f600491604051928380926342580cb760e11b82525afa5f918161029b575b50916101ce959493916101b39361028f575b506040519860208a525160208a0152511515604089015251610100606089015261012088019061051e565b91511515608087015251858203601f190160a087015261051e565b915160c08401525192601f198383030160e084015260ff60f81b845116825260c061021d61020b602087015160e0602087015260e086019061051e565b6040870151858203604087015261051e565b946060810151606085015260018060a01b03608082015116608085015260a081015160a085015201519160c08186039101526020808351958681520192015f945b8086106102775750508293505115156101008301520390f35b9092602080600192865181520194019501949061025e565b60018b5287525f610188565b9091503d805f833e6102ad818361055e565b8101906020818303126103fb5780519067ffffffffffffffff82116103fb57019060e0828203126103fb57604051916102e583610542565b80516001600160f81b0319811681036103fb578352602081015167ffffffffffffffff81116103fb578261031a918301610580565b6020840152604081015167ffffffffffffffff81116103fb578261033f918301610580565b60408401526060818101519084015260808101516001600160a01b03811681036103fb57608084015260a081015160a084015260c08101519067ffffffffffffffff82116103fb57019080601f830112156103fb5781519167ffffffffffffffff83116103ff578260051b90604051936103bc602084018661055e565b84526020808501928201019283116103fb57602001905b8282106103eb5750505060c0820152906101b3610176565b81518152602091820191016103d3565b5f80fd5b634e487b7160e01b5f52604160045260245ffd5b6040516301afd7c160e11b8152602081600481855afa908115610472575f9161043f575b508752610157565b90506020813d60201161046a575b8161045a6020938361055e565b810103126103fb57516004610437565b3d915061044d565b6040513d5f823e3d90fd5b60ff1689525f610151565b9091506020813d6020116104be575b816104a46020938361055e565b810103126103fb575160ff811681036103fb57905f61014b565b3d9150610497565b6001845284525f61012c565b6104ef9192503d805f833e6104e7818361055e565b8101906105d6565b905f610126565b6001875285525f610108565b6105179192503d805f833e6104e7818361055e565b905f610102565b805180835260209291819084018484015e5f828201840152601f01601f1916010190565b60e0810190811067ffffffffffffffff8211176103ff57604052565b90601f8019910116810190811067ffffffffffffffff8211176103ff57604052565b81601f820112156103fb5780519067ffffffffffffffff82116103ff57604051926105b5601f8401601f19166020018561055e565b828452602083830101116103fb57815f9260208093018386015e8301015290565b906020828203126103fb57815167ffffffffffffffff81116103fb576105fc9201610580565b9056fea2646970667358221220389a149f2e0bd6ff1dee73cba200ac22d6611d304a114c8d87d33392f9d891a264736f6c634300081b0033');
    },
    27065: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.code = t.abi = void 0),
        (t.abi = [
          {
            inputs: [
              { internalType: 'contract IMetaMorpho', name: 'vault', type: 'address' },
              {
                internalType: 'contract IPublicAllocator',
                name: 'publicAllocator',
                type: 'address',
              },
            ],
            name: 'query',
            outputs: [
              {
                components: [
                  {
                    components: [
                      { internalType: 'address', name: 'asset', type: 'address' },
                      { internalType: 'string', name: 'symbol', type: 'string' },
                      { internalType: 'string', name: 'name', type: 'string' },
                      { internalType: 'uint256', name: 'decimals', type: 'uint256' },
                      { internalType: 'uint256', name: 'decimalsOffset', type: 'uint256' },
                      {
                        components: [
                          { internalType: 'bytes1', name: 'fields', type: 'bytes1' },
                          { internalType: 'string', name: 'name', type: 'string' },
                          { internalType: 'string', name: 'version', type: 'string' },
                          { internalType: 'uint256', name: 'chainId', type: 'uint256' },
                          { internalType: 'address', name: 'verifyingContract', type: 'address' },
                          { internalType: 'bytes32', name: 'salt', type: 'bytes32' },
                          { internalType: 'uint256[]', name: 'extensions', type: 'uint256[]' },
                        ],
                        internalType: 'struct Eip5267Domain',
                        name: 'eip5267Domain',
                        type: 'tuple',
                      },
                    ],
                    internalType: 'struct VaultConfig',
                    name: 'config',
                    type: 'tuple',
                  },
                  { internalType: 'address', name: 'owner', type: 'address' },
                  { internalType: 'address', name: 'curator', type: 'address' },
                  { internalType: 'address', name: 'guardian', type: 'address' },
                  { internalType: 'uint256', name: 'timelock', type: 'uint256' },
                  {
                    components: [
                      { internalType: 'uint192', name: 'value', type: 'uint192' },
                      { internalType: 'uint64', name: 'validAt', type: 'uint64' },
                    ],
                    internalType: 'struct PendingUint192',
                    name: 'pendingTimelock',
                    type: 'tuple',
                  },
                  {
                    components: [
                      { internalType: 'address', name: 'value', type: 'address' },
                      { internalType: 'uint64', name: 'validAt', type: 'uint64' },
                    ],
                    internalType: 'struct PendingAddress',
                    name: 'pendingGuardian',
                    type: 'tuple',
                  },
                  { internalType: 'address', name: 'pendingOwner', type: 'address' },
                  { internalType: 'uint256', name: 'fee', type: 'uint256' },
                  { internalType: 'address', name: 'feeRecipient', type: 'address' },
                  { internalType: 'address', name: 'skimRecipient', type: 'address' },
                  { internalType: 'uint256', name: 'totalSupply', type: 'uint256' },
                  { internalType: 'uint256', name: 'totalAssets', type: 'uint256' },
                  { internalType: 'uint256', name: 'lastTotalAssets', type: 'uint256' },
                  { internalType: 'Id[]', name: 'supplyQueue', type: 'bytes32[]' },
                  { internalType: 'Id[]', name: 'withdrawQueue', type: 'bytes32[]' },
                  {
                    components: [
                      { internalType: 'address', name: 'admin', type: 'address' },
                      { internalType: 'uint256', name: 'fee', type: 'uint256' },
                      { internalType: 'uint256', name: 'accruedFee', type: 'uint256' },
                    ],
                    internalType: 'struct PublicAllocatorConfig',
                    name: 'publicAllocatorConfig',
                    type: 'tuple',
                  },
                ],
                internalType: 'struct VaultResponse',
                name: 'res',
                type: 'tuple',
              },
            ],
            stateMutability: 'view',
            type: 'function',
          },
        ]),
        (t.code =
          '0x6080806040523460155761139e908161001a8239f35b5f80fdfe60806040526004361015610011575f80fd5b5f3560e01c63f6f030ce14610024575f80fd5b3461098e57604036600319011261098e576004356001600160a01b038116810361098e576024356001600160a01b038116810361098e576102a060405260405161006d816111ac565b5f815260606020820152606060408201525f60608201525f6080820152604051610096816111c7565b5f815260606020820152606060408201525f60608201525f60808201525f60a0820152606060c082015260a08201526080525f6020608001525f6040608001525f6060608001525f60808001526040516100ef816111fd565b5f808252602082015261012052604051610108816111fd565b5f80825260208201819052610140919091526101608190526101808190526101a08190526101c08190526101e08190526102008190526102205260606102408190526102605260405161015a816111e2565b5f81525f60208201525f6040820152610200608001526040516338d52e0f60e01b815260208160048160018060a01b0387165afa90811561099a575f91611107575b506040516395d89b4160e01b81525f816004816001600160a01b0388165afa90811561099a575f916110ed575b506040516306fdde0360e01b81525f816004816001600160a01b0389165afa90811561099a575f916110cb575b5060405163313ce56760e01b81526020816004816001600160a01b038a165afa90811561099a575f916110ac575b50604051632ba9c2b360e21b8152916020836004816001600160a01b038b165afa92831561099a575f9361107b575b506040516342580cb760e11b8152935f856004816001600160a01b038c165afa94851561099a575f95610f20575b509160ff939291849260405197610297896111ac565b60018060a01b031688526020880152604087015216606085015216608083015260a0820152608052604051638da5cb5b60e01b815260208160048160018060a01b0387165afa90811561099a575f91610ee6575b506001600160a01b0390811660a05260405163e66f53b760e01b8152906020908290600490829087165afa90811561099a575f91610eac575b506001600160a01b0390811660c052604051630229549960e51b8152906020908290600490829087165afa90811561099a575f91610e72575b506001600160a01b0390811660e0526040516334cc866d60e21b8152906020908290600490829087165afa90811561099a575f91610e40575b506101005260408051637cc4d9a160e01b815290816004816001600160a01b0387165afa90811561099a575f91610ddd575b506101205260408051633b1618dd60e11b815290816004816001600160a01b0387165afa90811561099a575f91610d84575b5061014052604051631c61872f60e31b81526020816004816001600160a01b0387165afa90811561099a575f91610d4a575b506001600160a01b039081166101605260405163ddca3f4360e01b8152906020908290600490829087165afa801561099a575f90610d01575b6001600160601b0316610180525060405163011a412160e61b81526020816004816001600160a01b0387165afa90811561099a575f91610cc7575b506001600160a01b039081166101a05260405163388af5b560e01b8152906020908290600490829087165afa90811561099a575f91610c8d575b506001600160a01b039081166101c0526040516318160ddd60e01b8152906020908290600490829087165afa90811561099a575f91610c5b575b506101e0526040516278744560e21b81526020816004816001600160a01b0387165afa90811561099a575f91610c29575b506102005260405163568efc0760e01b81526020816004816001600160a01b0387165afa90811561099a575f91610bf7575b5061022052604051630a17b31360e41b81526020816004816001600160a01b0387165afa90811561099a575f91610bc5575b506105b38161130e565b610240525f5b818110610b445750506040516333f91ebb60e01b81526020816004816001600160a01b0387165afa90811561099a575f91610b12575b506105f98161130e565b610260525f5b818110610a915750506001600160a01b038116151580610a16575b610881575b505060405160208152806080516102a0602083015260018060a01b038151166102c083015260a061067c610664602084015160c06102e0870152610380860190611155565b60408401518582036102bf1901610300870152611155565b916060810151610320850152608081015161034085015201516102bf198383030161036084015260ff60f81b815116825260c06106dd6106cb602084015160e0602087015260e0860190611155565b60408401518582036040870152611155565b916060810151606085015260018060a01b03608082015116608085015260a081015160a085015201519160c0818303910152602080835192838152019201905f5b81811061086857505060a080516001600160a01b03908116604086015260c080518216606087015260e0805183166080880152610100805194880194909452610120805180516001600160c01b0316938901939093526020928301516001600160401b0390811692890192909252610140805180518616968a01969096529490920151169086015261016080518216928601929092526101808051928601929092526101a080518216928601929092526101c08051909116918501919091526101e080519185019190915261020080519185019190915261022080519185019190915261024051848403601f19019185019190915261083892610822925090611179565b61026051838203601f1901610240850152611179565b610280805180516001600160a01b0316610260850152602081015191840191909152604001516102a08301520390f35b825184528594506020938401939092019160010161071e565b604051630c7508df60e31b81526001600160a01b0380841660048301529092906020908490602490829086165afa92831561099a575f936109da575b50604051636fcca69b60e01b81526001600160a01b0380831660048301529091906020908390602490829087165afa91821561099a575f926109a5575b506040516348d88a5960e11b81526001600160a01b0391821660048201529260209184916024918391165afa91821561099a575f92610962575b5060405192610942846111e2565b6001600160a01b0316835260208301526040820152610280525f8061061f565b9091506020813d602011610992575b8161097e60209383611218565b8101031261098e5751905f610934565b5f80fd5b3d9150610971565b6040513d5f823e3d90fd5b9091506020813d6020116109d2575b816109c160209383611218565b8101031261098e57519060206108fa565b3d91506109b4565b9092506020813d602011610a0e575b816109f660209383611218565b8101031261098e57610a0790611239565b915f6108bd565b3d91506109e9565b506040516326f6f90760e11b81526001600160a01b0382811660048301526020908290602490829087165afa90811561099a575f91610a56575b5061061a565b90506020813d602011610a89575b81610a7160209383611218565b8101031261098e5751801515810361098e575f610a50565b3d9150610a64565b6040516362518ddf60e01b815260048101829052906020826024816001600160a01b0389165afa801561099a575f90610ae0575b60019250610ad9826101e060800151611340565b52016105ff565b506020823d8211610b0a575b81610af960209383611218565b8101031261098e5760019151610ac5565b3d9150610aec565b90506020813d602011610b3c575b81610b2d60209383611218565b8101031261098e57515f6105ef565b3d9150610b20565b60405163f7d1852160e01b815260048101829052906020826024816001600160a01b0389165afa801561099a575f90610b93575b60019250610b8c826101c060800151611340565b52016105b9565b506020823d8211610bbd575b81610bac60209383611218565b8101031261098e5760019151610b78565b3d9150610b9f565b90506020813d602011610bef575b81610be060209383611218565b8101031261098e57515f6105a9565b3d9150610bd3565b90506020813d602011610c21575b81610c1260209383611218565b8101031261098e57515f610577565b3d9150610c05565b90506020813d602011610c53575b81610c4460209383611218565b8101031261098e57515f610545565b3d9150610c37565b90506020813d602011610c85575b81610c7660209383611218565b8101031261098e57515f610514565b3d9150610c69565b90506020813d602011610cbf575b81610ca860209383611218565b8101031261098e57610cb990611239565b5f6104da565b3d9150610c9b565b90506020813d602011610cf9575b81610ce260209383611218565b8101031261098e57610cf390611239565b5f6104a0565b3d9150610cd5565b506020813d602011610d42575b81610d1b60209383611218565b8101031261098e57516001600160601b038116810361098e576001600160601b0390610465565b3d9150610d0e565b90506020813d602011610d7c575b81610d6560209383611218565b8101031261098e57610d7690611239565b5f61042c565b3d9150610d58565b90506040813d604011610dd5575b81610d9f60409383611218565b8101031261098e57610dca602060405192610db9846111fd565b610dc281611239565b8452016112fa565b60208201525f6103fa565b3d9150610d92565b90506040813d604011610e38575b81610df860409383611218565b8101031261098e5760405190610e0d826111fd565b80516001600160c01b038116810361098e578252610e2d906020016112fa565b60208201525f6103c8565b3d9150610deb565b90506020813d602011610e6a575b81610e5b60209383611218565b8101031261098e57515f610396565b3d9150610e4e565b90506020813d602011610ea4575b81610e8d60209383611218565b8101031261098e57610e9e90611239565b5f61035d565b3d9150610e80565b90506020813d602011610ede575b81610ec760209383611218565b8101031261098e57610ed890611239565b5f610324565b3d9150610eba565b90506020813d602011610f18575b81610f0160209383611218565b8101031261098e57610f1290611239565b5f6102eb565b3d9150610ef4565b9094503d805f833e610f328183611218565b81019060208183031261098e578051906001600160401b03821161098e570160e08183031261098e5760405191610f68836111c7565b81516001600160f81b03198116810361098e57835260208201516001600160401b03811161098e5781610f9c91840161124d565b602084015260408201516001600160401b03811161098e5781610fc091840161124d565b604084015260608201516060840152610fdb60808301611239565b608084015260a082015160a084015260c0820151906001600160401b03821161098e5780601f83850101121561098e578183015191611019836112e3565b936110276040519586611218565b838552602085019260208560051b84840101011161098e5790602081830101925b60208560051b8385010101841061106b57505050505060c08201529360ff610281565b8351815260209384019301611048565b61109e91935060203d6020116110a5575b6110968183611218565b8101906112ca565b915f610253565b503d61108c565b6110c5915060203d6020116110a5576110968183611218565b5f610224565b6110e791503d805f833e6110df8183611218565b8101906112a2565b5f6101f6565b61110191503d805f833e6110df8183611218565b5f6101c9565b90506020813d602011611139575b8161112260209383611218565b8101031261098e5761113390611239565b5f61019c565b3d9150611115565b634e487b7160e01b5f52604160045260245ffd5b805180835260209291819084018484015e5f828201840152601f01601f1916010190565b90602080835192838152019201905f5b8181106111965750505090565b8251845260209384019390920191600101611189565b60c081019081106001600160401b0382111761114157604052565b60e081019081106001600160401b0382111761114157604052565b606081019081106001600160401b0382111761114157604052565b604081019081106001600160401b0382111761114157604052565b90601f801991011681019081106001600160401b0382111761114157604052565b51906001600160a01b038216820361098e57565b81601f8201121561098e578051906001600160401b0382116111415760405192611281601f8401601f191660200185611218565b8284526020838301011161098e57815f9260208093018386015e8301015290565b9060208282031261098e5781516001600160401b03811161098e576112c7920161124d565b90565b9081602091031261098e575160ff8116810361098e5790565b6001600160401b0381116111415760051b60200190565b51906001600160401b038216820361098e57565b90611318826112e3565b6113256040519182611218565b8281528092611336601f19916112e3565b0190602036910137565b80518210156113545760209160051b010190565b634e487b7160e01b5f52603260045260245ffdfea264697066735822122023293b2df005682d3a7c99045b7086cbb4e62e771a73844d3f8f7c0947c627a964736f6c634300081b0033');
    },
    23008: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.code = t.abi = void 0),
        (t.abi = [
          {
            inputs: [
              { internalType: 'contract IMetaMorpho', name: 'vault', type: 'address' },
              { internalType: 'address', name: 'user', type: 'address' },
            ],
            name: 'query',
            outputs: [
              {
                components: [
                  { internalType: 'bool', name: 'isAllocator', type: 'bool' },
                  { internalType: 'uint256', name: 'allowance', type: 'uint256' },
                ],
                internalType: 'struct VaultUserResponse',
                name: 'res',
                type: 'tuple',
              },
            ],
            stateMutability: 'view',
            type: 'function',
          },
        ]),
        (t.code =
          '0x6080806040523460155761025b908161001a8239f35b5f80fdfe6080806040526004361015610012575f80fd5b5f3560e01c63f6f030ce14610025575f80fd5b34610156576040366003190112610156576004356001600160a01b0381169190829003610156576024356001600160a01b0381169290839003610156576040820182811067ffffffffffffffff8211176101ef576040525f825260208201905f82526040516326f6f90760e11b8152846004820152602081602481855afa908115610162575f916101b4575b50151583526040516338d52e0f60e01b815293602085600481855afa948515610162575f9561016d575b509060446020926040519687938492636eb1769f60e11b84526004840152602483015260018060a01b03165afa8015610162575f9061012b575b6040935081528251915115158252516020820152f35b506020833d60201161015a575b8161014560209383610203565b810103126101565760409251610115565b5f80fd5b3d9150610138565b6040513d5f823e3d90fd5b9094506020813d6020116101ac575b8161018960209383610203565b810103126101565751906001600160a01b038216820361015657909360446100db565b3d915061017c565b90506020813d6020116101e7575b816101cf60209383610203565b8101031261015657518015158103610156575f6100b1565b3d91506101c2565b634e487b7160e01b5f52604160045260245ffd5b90601f8019910116810190811067ffffffffffffffff8211176101ef5760405256fea2646970667358221220dab07071235db46cf4ce3e33469d528ea840db8713e312abcc6046560cb9b95d64736f6c634300081b0033');
    },
    52954: function (e, t, n) {
      'use strict';
      var r =
          (this && this.__createBinding) ||
          (Object.create
            ? function (e, t, n, r) {
                void 0 === r && (r = n);
                var i = Object.getOwnPropertyDescriptor(t, n);
                (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
                  (i = {
                    enumerable: !0,
                    get: function () {
                      return t[n];
                    },
                  }),
                  Object.defineProperty(e, r, i);
              }
            : function (e, t, n, r) {
                void 0 === r && (r = n), (e[r] = t[n]);
              }),
        i =
          (this && this.__exportStar) ||
          function (e, t) {
            for (var n in e)
              'default' === n || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n);
          };
      Object.defineProperty(t, '__esModule', { value: !0 }),
        i(n(15711), t),
        i(n(44953), t),
        i(n(63831), t);
    },
    15711: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }), (t.getAuthorizationTypedData = void 0);
      let r = n(40252),
        i = {
          Authorization: [
            { name: 'authorizer', type: 'address' },
            { name: 'authorized', type: 'address' },
            { name: 'isAuthorized', type: 'bool' },
            { name: 'nonce', type: 'uint256' },
            { name: 'deadline', type: 'uint256' },
          ],
        };
      t.getAuthorizationTypedData = (
        { authorizer: e, authorized: t, isAuthorized: n, nonce: a, deadline: s },
        o
      ) => ({
        domain: { chainId: o, verifyingContract: (0, r.getChainAddresses)(o).morpho },
        types: i,
        message: { authorizer: e, authorized: t, isAuthorized: n, nonce: a, deadline: s },
        primaryType: 'Authorization',
      });
    },
    44953: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.getDaiPermitTypedData = t.getPermitTypedData = void 0);
      let r = n(40252),
        i = {
          Permit: [
            { name: 'owner', type: 'address' },
            { name: 'spender', type: 'address' },
            { name: 'value', type: 'uint256' },
            { name: 'nonce', type: 'uint256' },
            { name: 'deadline', type: 'uint256' },
          ],
        };
      t.getPermitTypedData = (
        { deadline: e, owner: t, nonce: n, spender: a, erc20: s, allowance: o },
        l
      ) => {
        let { usdc: u } = (0, r.getChainAddresses)(l);
        return {
          domain: s.eip5267Domain?.eip712Domain ?? {
            name: s.name,
            version: s.address === u ? '2' : '1',
            chainId: l,
            verifyingContract: s.address,
          },
          types: i,
          message: { owner: t, spender: a, value: o, nonce: n, deadline: e },
          primaryType: 'Permit',
        };
      };
      let a = {
        Permit: [
          { name: 'holder', type: 'address' },
          { name: 'spender', type: 'address' },
          { name: 'nonce', type: 'uint256' },
          { name: 'expiry', type: 'uint256' },
          { name: 'allowed', type: 'bool' },
        ],
      };
      t.getDaiPermitTypedData = (
        { deadline: e, owner: t, nonce: n, spender: i, allowance: s },
        o
      ) => {
        let { dai: l } = (0, r.getChainAddresses)(o);
        return {
          domain: { name: 'Dai Stablecoin', version: '1', chainId: o, verifyingContract: l },
          types: a,
          message: { holder: t, spender: i, allowed: s > 0n, nonce: n, expiry: e },
          primaryType: 'Permit',
        };
      };
    },
    63831: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.getPermit2TransferFromTypedData = t.getPermit2PermitTypedData = void 0);
      let r = n(40252),
        i = {
          PermitSingle: [
            { name: 'details', type: 'PermitDetails' },
            { name: 'spender', type: 'address' },
            { name: 'sigDeadline', type: 'uint256' },
          ],
          PermitDetails: [
            { name: 'token', type: 'address' },
            { name: 'amount', type: 'uint160' },
            { name: 'expiration', type: 'uint48' },
            { name: 'nonce', type: 'uint48' },
          ],
        };
      t.getPermit2PermitTypedData = (e, t) => ({
        domain: {
          name: 'Permit2',
          chainId: t,
          verifyingContract: (0, r.getChainAddresses)(t).permit2,
        },
        types: i,
        message: {
          details: {
            token: e.erc20,
            amount: r.MathLib.min(e.allowance, r.MathLib.MAX_UINT_160),
            expiration: r.MathLib.min(e.expiration ?? r.MathLib.MAX_UINT_48, r.MathLib.MAX_UINT_48),
            nonce: e.nonce,
          },
          spender: e.spender,
          sigDeadline: e.deadline,
        },
        primaryType: 'PermitSingle',
      });
      let a = {
        PermitTransferFrom: [
          { name: 'permitted', type: 'TokenPermissions' },
          { name: 'spender', type: 'address' },
          { name: 'nonce', type: 'uint256' },
          { name: 'deadline', type: 'uint256' },
        ],
        TokenPermissions: [
          { name: 'token', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
      };
      t.getPermit2TransferFromTypedData = (e, t) => ({
        domain: {
          name: 'Permit2',
          chainId: t,
          verifyingContract: (0, r.getChainAddresses)(t).permit2,
        },
        types: a,
        message: {
          permitted: { token: e.erc20, amount: r.MathLib.min(e.allowance, r.MathLib.MAX_UINT_160) },
          spender: e.spender,
          nonce: e.nonce,
          deadline: e.deadline,
        },
        primaryType: 'PermitTransferFrom',
      });
    },
    18806: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 });
    },
    69321: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.safeParseUnits = t.safeParseNumber = t.safeGetAddress = void 0);
      let r = n(52707),
        i = (e, t) =>
          new Intl.NumberFormat('en-US', {
            style: 'decimal',
            useGrouping: !1,
            maximumFractionDigits: t,
            minimumFractionDigits: t,
          }).format(e);
      (t.safeGetAddress = (e) => (0, r.getAddress)(e.toLowerCase())),
        (t.safeParseNumber = (e, n = 18) => (0, t.safeParseUnits)(i(e, n), n)),
        (t.safeParseUnits = (e, t = 18) => {
          if (!/[-+]?[0-9]*\.?[0-9]+/.test(e)) throw Error(`invalid number: ${e}`);
          let [n, i = ''] = e.split('.');
          return (
            (i = i.slice(0, t)),
            (0, r.parseUnits)([n || '0', i].filter((e) => e.length > 0).join('.'), t)
          );
        });
    },
    12309: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.ActionBundle = t.ActionBundleRequirements = void 0);
      let r = n(83761);
      class i {
        txs;
        signatures;
        constructor(e = [], t = []) {
          (this.txs = e), (this.signatures = t);
        }
        sign(e, t = e.account) {
          return Promise.all(this.signatures.map((n) => n.sign(e, t)));
        }
      }
      t.ActionBundleRequirements = i;
      class a {
        actions;
        requirements;
        steps;
        chainId;
        constructor(e, t = [], n = new i()) {
          (this.actions = t),
            (this.requirements = n),
            'number' == typeof e
              ? (this.chainId = e)
              : ((this.steps = e), (this.chainId = e[0].chainId));
        }
        tx() {
          return r.BundlerAction.encodeBundle(this.chainId, this.actions);
        }
        txs() {
          return this.requirements.txs.map(({ tx: e }) => e).concat([this.tx()]);
        }
      }
      t.ActionBundle = a;
    },
    83761: function (e, t, n) {
      'use strict';
      var r, i;
      Object.defineProperty(t, '__esModule', { value: !0 }), (t.BundlerAction = void 0);
      let a = n(24822),
        s = n(40252),
        o = n(4565),
        l = n(52707),
        u = n(73869),
        c = a.bundler3Abi.find((e) => 'reenter' === e.name).inputs;
      ((i = r || (t.BundlerAction = r = {})).encodeBundle = function (e, t) {
        let {
            bundler3: { bundler3: n, generalAdapter1: r },
          } = (0, s.getChainAddresses)(e),
          o = 0n;
        for (let { type: e, args: i } of t) {
          if ('nativeTransfer' !== e) continue;
          let [t, a, s] = i;
          t !== n && t !== r && (a === n || a === r) && (o += s);
        }
        let u = t.flatMap(i.encode.bind(null, e));
        return {
          to: n,
          value: o,
          data: (0, l.encodeFunctionData)({
            abi: a.bundler3Abi,
            functionName: 'multicall',
            args: [u],
          }),
        };
      }),
        (i.encode = function (e, { type: t, args: n }) {
          switch (t) {
            case 'nativeTransfer':
              return i.nativeTransfer(e, ...n);
            case 'erc20Transfer':
              return i.erc20Transfer(...n);
            case 'erc20TransferFrom':
              return i.erc20TransferFrom(e, ...n);
            case 'erc20WrapperDepositFor':
              return i.erc20WrapperDepositFor(e, ...n);
            case 'erc20WrapperWithdrawTo':
              return i.erc20WrapperWithdrawTo(e, ...n);
            case 'permit': {
              let [t, r, a, s, o, l] = n;
              if (null == o) throw new u.BundlerErrors.MissingSignature();
              return i.permit(e, t, r, a, s, o, l);
            }
            case 'permitDai': {
              let [t, r, a, s, o, l] = n;
              if (null == o) throw new u.BundlerErrors.MissingSignature();
              return i.permitDai(e, t, r, a, s, o, l);
            }
            case 'approve2': {
              let [t, r, a, s] = n;
              if (null == a) throw new u.BundlerErrors.MissingSignature();
              return i.approve2(e, t, r, a, s);
            }
            case 'transferFrom2':
              return i.transferFrom2(e, ...n);
            case 'erc4626Mint':
              return i.erc4626Mint(e, ...n);
            case 'erc4626Deposit':
              return i.erc4626Deposit(e, ...n);
            case 'erc4626Withdraw':
              return i.erc4626Withdraw(e, ...n);
            case 'erc4626Redeem':
              return i.erc4626Redeem(e, ...n);
            case 'morphoSetAuthorizationWithSig': {
              let [t, r, a] = n;
              if (null == r) throw new u.BundlerErrors.MissingSignature();
              return i.morphoSetAuthorizationWithSig(e, t, r, a);
            }
            case 'morphoSupply': {
              let [t, r, a, s, o, l, u] = n;
              return i.morphoSupply(e, t, r, a, s, o, l.flatMap(i.encode.bind(null, e)), u);
            }
            case 'morphoSupplyCollateral': {
              let [t, r, a, s, o] = n;
              return i.morphoSupplyCollateral(e, t, r, a, s.flatMap(i.encode.bind(null, e)), o);
            }
            case 'morphoBorrow':
              return i.morphoBorrow(e, ...n);
            case 'morphoRepay': {
              let [t, r, a, s, o, l, u] = n;
              return i.morphoRepay(e, t, r, a, s, o, l.flatMap(i.encode.bind(null, e)), u);
            }
            case 'morphoWithdraw':
              return i.morphoWithdraw(e, ...n);
            case 'morphoWithdrawCollateral':
              return i.morphoWithdrawCollateral(e, ...n);
            case 'reallocateTo':
              return i.publicAllocatorReallocateTo(e, ...n);
            case 'urdClaim':
              return i.urdClaim(...n);
            case 'wrapNative':
              return i.wrapNative(e, ...n);
            case 'unwrapNative':
              return i.unwrapNative(e, ...n);
            case 'stakeEth':
              return i.stakeEth(e, ...n);
            case 'wrapStEth':
              return i.wrapStEth(e, ...n);
            case 'unwrapStEth':
              return i.unwrapStEth(e, ...n);
            case 'aaveV2Repay':
              return i.aaveV2Repay(e, ...n);
            case 'aaveV2Withdraw':
              return i.aaveV2Withdraw(e, ...n);
            case 'aaveV3Repay':
              return i.aaveV3Repay(e, ...n);
            case 'aaveV3Withdraw':
              return i.aaveV3Withdraw(e, ...n);
            case 'aaveV3OptimizerRepay':
              return i.aaveV3OptimizerRepay(e, ...n);
            case 'aaveV3OptimizerWithdraw':
              return i.aaveV3OptimizerWithdraw(e, ...n);
            case 'aaveV3OptimizerWithdrawCollateral':
              return i.aaveV3OptimizerWithdrawCollateral(e, ...n);
            case 'aaveV3OptimizerApproveManagerWithSig': {
              let [t, r, a, s, o, l, c] = n;
              if (null == l) throw new u.BundlerErrors.MissingSignature();
              return i.aaveV3OptimizerApproveManagerWithSig(e, t, r, a, s, o, l, c);
            }
            case 'compoundV2Repay':
              return i.compoundV2Repay(e, ...n);
            case 'compoundV2Redeem':
              return i.compoundV2Redeem(e, ...n);
            case 'compoundV3Repay':
              return i.compoundV3Repay(e, ...n);
            case 'compoundV3WithdrawFrom':
              return i.compoundV3WithdrawFrom(e, ...n);
            case 'compoundV3AllowBySig': {
              let [t, r, a, s, o, l, c] = n;
              if (null == l) throw new u.BundlerErrors.MissingSignature();
              return i.compoundV3AllowBySig(e, t, r, a, s, o, l, c);
            }
            case 'morphoWrapperDepositFor':
              return i.morphoWrapperDepositFor(e, ...n);
          }
          throw Error(`unhandled action encoding: ${t}`);
        }),
        (i.nativeTransfer = function (e, t, n, r, i = !1) {
          let {
            bundler3: { bundler3: o, generalAdapter1: u },
          } = (0, s.getChainAddresses)(e);
          return n === o
            ? []
            : t === u
              ? [
                  {
                    to: u,
                    data: (0, l.encodeFunctionData)({
                      abi: a.coreAdapterAbi,
                      functionName: 'nativeTransfer',
                      args: [n, r],
                    }),
                    value: 0n,
                    skipRevert: !1,
                    callbackHash: l.zeroHash,
                  },
                ]
              : [{ to: n, data: '0x', value: r, skipRevert: i, callbackHash: l.zeroHash }];
        }),
        (i.erc20Transfer = function (e, t, n, r, i = !1) {
          return [
            {
              to: r,
              data: (0, l.encodeFunctionData)({
                abi: a.coreAdapterAbi,
                functionName: 'erc20Transfer',
                args: [e, t, n],
              }),
              value: 0n,
              skipRevert: i,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.erc20TransferFrom = function (e, t, n, r, i = !1) {
          let {
            bundler3: { generalAdapter1: o },
          } = (0, s.getChainAddresses)(e);
          return [
            {
              to: o,
              data: (0, l.encodeFunctionData)({
                abi: a.generalAdapter1Abi,
                functionName: 'erc20TransferFrom',
                args: [t, r, n],
              }),
              value: 0n,
              skipRevert: i,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.permit = function (e, t, n, r, i, a, u = !0) {
          let {
              bundler3: { generalAdapter1: c },
            } = (0, s.getChainAddresses)(e),
            { r: d, s: p, yParity: h } = (0, l.parseSignature)(a);
          return [
            {
              to: n,
              data: (0, l.encodeFunctionData)({
                abi: o.erc2612Abi,
                functionName: 'permit',
                args: [t, c, r, i, h + 27, d, p],
              }),
              value: 0n,
              skipRevert: u,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.permitDai = function (e, t, n, r, i, a, o = !0) {
          let {
            dai: c,
            bundler3: { generalAdapter1: d },
          } = (0, s.getChainAddresses)(e);
          if (null == c) throw new u.BundlerErrors.UnexpectedAction('permitDai', e);
          let { r: p, s: h, yParity: y } = (0, l.parseSignature)(a);
          return [
            {
              to: c,
              data: (0, l.encodeFunctionData)({
                abi: [
                  {
                    constant: !1,
                    inputs: [
                      { name: 'holder', type: 'address' },
                      { name: 'spender', type: 'address' },
                      { name: 'nonce', type: 'uint256' },
                      { name: 'expiry', type: 'uint256' },
                      { name: 'allowed', type: 'bool' },
                      { name: 'v', type: 'uint8' },
                      { name: 'r', type: 'bytes32' },
                      { name: 's', type: 'bytes32' },
                    ],
                    name: 'permit',
                    outputs: [],
                    payable: !1,
                    stateMutability: 'nonpayable',
                    type: 'function',
                  },
                ],
                functionName: 'permit',
                args: [t, d, n, r, i, y + 27, p, h],
              }),
              value: 0n,
              skipRevert: o,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.approve2 = function (e, t, n, r, i = !0) {
          let {
            permit2: a,
            bundler3: { generalAdapter1: c },
          } = (0, s.getChainAddresses)(e);
          if (null == a) throw new u.BundlerErrors.UnexpectedAction('approve2', e);
          return [
            {
              to: a,
              data: (0, l.encodeFunctionData)({
                abi: o.permit2Abi,
                functionName: 'permit',
                args: [t, { ...n, spender: c }, r],
              }),
              value: 0n,
              skipRevert: i,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.transferFrom2 = function (e, t, n, r, i = !1) {
          let {
            bundler3: { generalAdapter1: o },
          } = (0, s.getChainAddresses)(e);
          return [
            {
              to: o,
              data: (0, l.encodeFunctionData)({
                abi: a.generalAdapter1Abi,
                functionName: 'permit2TransferFrom',
                args: [t, r, n],
              }),
              value: 0n,
              skipRevert: i,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.morphoWrapperDepositFor = function (e, t, n, r = !1) {
          if (e !== s.ChainId.EthMainnet)
            throw Error('MORPHO wrapping is only available on ethereum mainnet');
          let {
            bundler3: { generalAdapter1: i },
          } = (0, s.getChainAddresses)(e);
          return [
            {
              to: i,
              data: (0, l.encodeFunctionData)({
                abi: a.ethereumGeneralAdapter1Abi,
                functionName: 'morphoWrapperDepositFor',
                args: [t, n],
              }),
              value: 0n,
              skipRevert: r,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.erc20WrapperDepositFor = function (e, t, n, r, i = !1) {
          let {
            bundler3: { generalAdapter1: o, erc20WrapperAdapter: c },
          } = (0, s.getChainAddresses)(e);
          if (null == c) throw new u.BundlerErrors.UnexpectedAction('erc20WrapperDepositFor', e);
          return [
            {
              to: o,
              data: (0, l.encodeFunctionData)({
                abi: a.generalAdapter1Abi,
                functionName: 'erc20Transfer',
                args: [n, c, l.maxUint256],
              }),
              value: 0n,
              skipRevert: i,
              callbackHash: l.zeroHash,
            },
            {
              to: c,
              data: (0, l.encodeFunctionData)({
                abi: a.erc20WrapperAdapterAbi,
                functionName: 'erc20WrapperDepositFor',
                args: [t, r],
              }),
              value: 0n,
              skipRevert: i,
              callbackHash: l.zeroHash,
            },
            {
              to: c,
              data: (0, l.encodeFunctionData)({
                abi: a.erc20WrapperAdapterAbi,
                functionName: 'erc20Transfer',
                args: [n, o, l.maxUint256],
              }),
              value: 0n,
              skipRevert: i,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.erc20WrapperWithdrawTo = function (e, t, n, r, i = !1) {
          let {
            bundler3: { generalAdapter1: o, erc20WrapperAdapter: c },
          } = (0, s.getChainAddresses)(e);
          if (null == c) throw new u.BundlerErrors.UnexpectedAction('erc20WrapperWithdrawTo', e);
          return [
            {
              to: o,
              data: (0, l.encodeFunctionData)({
                abi: a.generalAdapter1Abi,
                functionName: 'erc20Transfer',
                args: [t, c, l.maxUint256],
              }),
              value: 0n,
              skipRevert: i,
              callbackHash: l.zeroHash,
            },
            {
              to: c,
              data: (0, l.encodeFunctionData)({
                abi: a.erc20WrapperAdapterAbi,
                functionName: 'erc20WrapperWithdrawTo',
                args: [t, n, r],
              }),
              value: 0n,
              skipRevert: i,
              callbackHash: l.zeroHash,
            },
            {
              to: c,
              data: (0, l.encodeFunctionData)({
                abi: a.erc20WrapperAdapterAbi,
                functionName: 'erc20Transfer',
                args: [t, o, l.maxUint256],
              }),
              value: 0n,
              skipRevert: i,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.erc4626Mint = function (e, t, n, r, i, o = !1) {
          let {
            bundler3: { generalAdapter1: u },
          } = (0, s.getChainAddresses)(e);
          return [
            {
              to: u,
              data: (0, l.encodeFunctionData)({
                abi: a.generalAdapter1Abi,
                functionName: 'erc4626Mint',
                args: [t, n, r, i],
              }),
              value: 0n,
              skipRevert: o,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.erc4626Deposit = function (e, t, n, r, i, o = !1) {
          let {
            bundler3: { generalAdapter1: u },
          } = (0, s.getChainAddresses)(e);
          return [
            {
              to: u,
              data: (0, l.encodeFunctionData)({
                abi: a.generalAdapter1Abi,
                functionName: 'erc4626Deposit',
                args: [t, n, r, i],
              }),
              value: 0n,
              skipRevert: o,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.erc4626Withdraw = function (e, t, n, r, i, o, u = !1) {
          let {
            bundler3: { generalAdapter1: c },
          } = (0, s.getChainAddresses)(e);
          return [
            {
              to: c,
              data: (0, l.encodeFunctionData)({
                abi: a.generalAdapter1Abi,
                functionName: 'erc4626Withdraw',
                args: [t, n, r, i, o],
              }),
              value: 0n,
              skipRevert: u,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.erc4626Redeem = function (e, t, n, r, i, o, u = !1) {
          let {
            bundler3: { generalAdapter1: c },
          } = (0, s.getChainAddresses)(e);
          return [
            {
              to: c,
              data: (0, l.encodeFunctionData)({
                abi: a.generalAdapter1Abi,
                functionName: 'erc4626Redeem',
                args: [t, n, r, i, o],
              }),
              value: 0n,
              skipRevert: u,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.morphoSetAuthorizationWithSig = function (e, t, n, r = !0) {
          let {
              morpho: i,
              bundler3: { bundler3: a },
            } = (0, s.getChainAddresses)(e),
            { r: c, s: d, yParity: p } = (0, l.parseSignature)(n);
          if (t.authorized === a) throw new u.BundlerErrors.UnexpectedSignature(t.authorized);
          return [
            {
              to: i,
              data: (0, l.encodeFunctionData)({
                abi: o.blueAbi,
                functionName: 'setAuthorizationWithSig',
                args: [t, { v: p + 27, r: c, s: d }],
              }),
              value: 0n,
              skipRevert: r,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.morphoSupply = function (e, t, n, r, i, o, u, d = !1) {
          let {
              bundler3: { generalAdapter1: p },
            } = (0, s.getChainAddresses)(e),
            h = u.length > 0,
            y = h ? (0, l.encodeAbiParameters)(c, [u]) : '0x';
          return [
            {
              to: p,
              data: (0, l.encodeFunctionData)({
                abi: a.generalAdapter1Abi,
                functionName: 'morphoSupply',
                args: [t, n, r, i, o, y],
              }),
              value: 0n,
              skipRevert: d,
              callbackHash: h ? (0, l.keccak256)(y) : l.zeroHash,
            },
          ];
        }),
        (i.morphoSupplyCollateral = function (e, t, n, r, i, o = !1) {
          let {
              bundler3: { generalAdapter1: u },
            } = (0, s.getChainAddresses)(e),
            d = i.length > 0,
            p = d ? (0, l.encodeAbiParameters)(c, [i]) : '0x';
          return [
            {
              to: u,
              data: (0, l.encodeFunctionData)({
                abi: a.generalAdapter1Abi,
                functionName: 'morphoSupplyCollateral',
                args: [t, n, r, p],
              }),
              value: 0n,
              skipRevert: o,
              callbackHash: d ? (0, l.keccak256)(p) : l.zeroHash,
            },
          ];
        }),
        (i.morphoBorrow = function (e, t, n, r, i, o, u = !1) {
          let {
            bundler3: { generalAdapter1: c },
          } = (0, s.getChainAddresses)(e);
          return [
            {
              to: c,
              data: (0, l.encodeFunctionData)({
                abi: a.generalAdapter1Abi,
                functionName: 'morphoBorrow',
                args: [t, n, r, i, o],
              }),
              value: 0n,
              skipRevert: u,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.morphoRepay = function (e, t, n, r, i, o, u, d = !1) {
          let {
              bundler3: { generalAdapter1: p },
            } = (0, s.getChainAddresses)(e),
            h = u.length > 0,
            y = h ? (0, l.encodeAbiParameters)(c, [u]) : '0x';
          return [
            {
              to: p,
              data: (0, l.encodeFunctionData)({
                abi: a.generalAdapter1Abi,
                functionName: 'morphoRepay',
                args: [t, n, r, i, o, y],
              }),
              value: 0n,
              skipRevert: d,
              callbackHash: h ? (0, l.keccak256)(y) : l.zeroHash,
            },
          ];
        }),
        (i.morphoWithdraw = function (e, t, n, r, i, o, u = !1) {
          let {
            bundler3: { generalAdapter1: c },
          } = (0, s.getChainAddresses)(e);
          return [
            {
              to: c,
              data: (0, l.encodeFunctionData)({
                abi: a.generalAdapter1Abi,
                functionName: 'morphoWithdraw',
                args: [t, n, r, i, o],
              }),
              value: 0n,
              skipRevert: u,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.morphoWithdrawCollateral = function (e, t, n, r, i = !1) {
          let {
            bundler3: { generalAdapter1: o },
          } = (0, s.getChainAddresses)(e);
          return [
            {
              to: o,
              data: (0, l.encodeFunctionData)({
                abi: a.generalAdapter1Abi,
                functionName: 'morphoWithdrawCollateral',
                args: [t, n, r],
              }),
              value: 0n,
              skipRevert: i,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.morphoFlashLoan = function (e, t, n, r, i = !1) {
          let {
              bundler3: { generalAdapter1: o },
            } = (0, s.getChainAddresses)(e),
            u = r.length > 0,
            d = u ? (0, l.encodeAbiParameters)(c, [r]) : '0x';
          return [
            {
              to: o,
              data: (0, l.encodeFunctionData)({
                abi: a.generalAdapter1Abi,
                functionName: 'morphoFlashLoan',
                args: [t, n, d],
              }),
              value: 0n,
              skipRevert: i,
              callbackHash: u ? (0, l.keccak256)(d) : l.zeroHash,
            },
          ];
        }),
        (i.publicAllocatorReallocateTo = function (e, t, n, r, i, a = !1) {
          let { publicAllocator: c } = (0, s.getChainAddresses)(e);
          if (null == c) throw new u.BundlerErrors.UnexpectedAction('reallocateTo', e);
          return [
            {
              to: c,
              data: (0, l.encodeFunctionData)({
                abi: o.publicAllocatorAbi,
                functionName: 'reallocateTo',
                args: [t, r, i],
              }),
              value: n,
              skipRevert: a,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.urdClaim = function (e, t, n, r, i, s = !0) {
          return [
            {
              to: e,
              data: (0, l.encodeFunctionData)({
                abi: a.universalRewardsDistributorAbi,
                functionName: 'claim',
                args: [t, n, r, i],
              }),
              value: 0n,
              skipRevert: s,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.wrapNative = function (e, t, n, r = !1) {
          let {
            bundler3: { generalAdapter1: i },
          } = (0, s.getChainAddresses)(e);
          return [
            {
              to: i,
              data: (0, l.encodeFunctionData)({
                abi: a.generalAdapter1Abi,
                functionName: 'wrapNative',
                args: [t, n],
              }),
              value: 0n,
              skipRevert: r,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.unwrapNative = function (e, t, n, r = !1) {
          let {
            bundler3: { generalAdapter1: i },
          } = (0, s.getChainAddresses)(e);
          return [
            {
              to: i,
              data: (0, l.encodeFunctionData)({
                abi: a.generalAdapter1Abi,
                functionName: 'unwrapNative',
                args: [t, n],
              }),
              value: 0n,
              skipRevert: r,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.stakeEth = function (e, t, n, r, i, o = !1) {
          let {
            bundler3: { generalAdapter1: u },
          } = (0, s.getChainAddresses)(e);
          return [
            {
              to: u,
              data: (0, l.encodeFunctionData)({
                abi: a.ethereumGeneralAdapter1Abi,
                functionName: 'stakeEth',
                args: [t, n, r, i],
              }),
              value: 0n,
              skipRevert: o,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.wrapStEth = function (e, t, n, r = !1) {
          let {
            bundler3: { generalAdapter1: i },
          } = (0, s.getChainAddresses)(e);
          return [
            {
              to: i,
              data: (0, l.encodeFunctionData)({
                abi: a.ethereumGeneralAdapter1Abi,
                functionName: 'wrapStEth',
                args: [t, n],
              }),
              value: 0n,
              skipRevert: r,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.unwrapStEth = function (e, t, n, r = !1) {
          let {
            bundler3: { generalAdapter1: i },
          } = (0, s.getChainAddresses)(e);
          return [
            {
              to: i,
              data: (0, l.encodeFunctionData)({
                abi: a.ethereumGeneralAdapter1Abi,
                functionName: 'unwrapStEth',
                args: [t, n],
              }),
              value: 0n,
              skipRevert: r,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.aaveV2Repay = function (e, t, n, r, i = 1n, o = !1) {
          let {
            bundler3: { aaveV2MigrationAdapter: c },
          } = (0, s.getChainAddresses)(e);
          if (null == c) throw new u.BundlerErrors.UnexpectedAction('aaveV2Repay', e);
          return [
            {
              to: c,
              data: (0, l.encodeFunctionData)({
                abi: a.aaveV2MigrationAdapterAbi,
                functionName: 'aaveV2Repay',
                args: [t, n, i, r],
              }),
              value: 0n,
              skipRevert: o,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.aaveV2Withdraw = function (e, t, n, r, i = !1) {
          let {
            bundler3: { aaveV2MigrationAdapter: o },
          } = (0, s.getChainAddresses)(e);
          if (null == o) throw new u.BundlerErrors.UnexpectedAction('aaveV2Withdraw', e);
          return [
            {
              to: o,
              data: (0, l.encodeFunctionData)({
                abi: a.aaveV2MigrationAdapterAbi,
                functionName: 'aaveV2Withdraw',
                args: [t, n, r],
              }),
              value: 0n,
              skipRevert: i,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.aaveV3Repay = function (e, t, n, r, i = 1n, o = !1) {
          let {
            bundler3: { aaveV3CoreMigrationAdapter: c },
          } = (0, s.getChainAddresses)(e);
          if (null == c) throw new u.BundlerErrors.UnexpectedAction('aaveV3Repay', e);
          return [
            {
              to: c,
              data: (0, l.encodeFunctionData)({
                abi: a.aaveV3MigrationAdapterAbi,
                functionName: 'aaveV3Repay',
                args: [t, n, i, r],
              }),
              value: 0n,
              skipRevert: o,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.aaveV3Withdraw = function (e, t, n, r, i = !1) {
          let {
            bundler3: { aaveV3CoreMigrationAdapter: o },
          } = (0, s.getChainAddresses)(e);
          if (null == o) throw new u.BundlerErrors.UnexpectedAction('aaveV3Withdraw', e);
          return [
            {
              to: o,
              data: (0, l.encodeFunctionData)({
                abi: a.aaveV3MigrationAdapterAbi,
                functionName: 'aaveV3Withdraw',
                args: [t, n, r],
              }),
              value: 0n,
              skipRevert: i,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.aaveV3OptimizerRepay = function (e, t, n, r, i = !1) {
          let {
            bundler3: { aaveV3OptimizerMigrationAdapter: o },
          } = (0, s.getChainAddresses)(e);
          if (null == o) throw new u.BundlerErrors.UnexpectedAction('aaveV3OptimizerRepay', e);
          return [
            {
              to: o,
              data: (0, l.encodeFunctionData)({
                abi: a.aaveV3OptimizerMigrationAdapterAbi,
                functionName: 'aaveV3OptimizerRepay',
                args: [t, n, r],
              }),
              value: 0n,
              skipRevert: i,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.aaveV3OptimizerWithdraw = function (e, t, n, r, i, o = !1) {
          let {
            bundler3: { aaveV3OptimizerMigrationAdapter: c },
          } = (0, s.getChainAddresses)(e);
          if (null == c) throw new u.BundlerErrors.UnexpectedAction('aaveV3OptimizerWithdraw', e);
          return [
            {
              to: c,
              data: (0, l.encodeFunctionData)({
                abi: a.aaveV3OptimizerMigrationAdapterAbi,
                functionName: 'aaveV3OptimizerWithdraw',
                args: [t, n, r, i],
              }),
              value: 0n,
              skipRevert: o,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.aaveV3OptimizerWithdrawCollateral = function (e, t, n, r, i = !1) {
          let {
            bundler3: { aaveV3OptimizerMigrationAdapter: o },
          } = (0, s.getChainAddresses)(e);
          if (null == o)
            throw new u.BundlerErrors.UnexpectedAction('aaveV3OptimizerWithdrawCollateral', e);
          return [
            {
              to: o,
              data: (0, l.encodeFunctionData)({
                abi: a.aaveV3OptimizerMigrationAdapterAbi,
                functionName: 'aaveV3OptimizerWithdrawCollateral',
                args: [t, n, r],
              }),
              value: 0n,
              skipRevert: i,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.aaveV3OptimizerApproveManagerWithSig = function (e, t, n, r, i, a, o, c = !0) {
          let {
            bundler3: { aaveV3OptimizerMigrationAdapter: d },
          } = (0, s.getChainAddresses)(e);
          if (null == d)
            throw new u.BundlerErrors.UnexpectedAction('aaveV3OptimizerApproveManagerWithSig', e);
          let { r: p, s: h, yParity: y } = (0, l.parseSignature)(o);
          return [
            {
              to: t,
              data: (0, l.encodeFunctionData)({
                abi: [
                  {
                    inputs: [
                      { name: 'delegator', type: 'address' },
                      { name: 'manager', type: 'address' },
                      { name: 'isAllowed', type: 'bool' },
                      { name: 'nonce', type: 'uint256' },
                      { name: 'deadline', type: 'uint256' },
                      {
                        components: [
                          { name: 'v', type: 'uint8' },
                          { name: 'r', type: 'bytes32' },
                          { name: 's', type: 'bytes32' },
                        ],
                        internalType: 'struct Types.Signature',
                        name: 'signature',
                        type: 'tuple',
                      },
                    ],
                    name: 'approveManagerWithSig',
                    outputs: [],
                    stateMutability: 'nonpayable',
                    type: 'function',
                  },
                ],
                functionName: 'approveManagerWithSig',
                args: [n, d, r, i, a, { v: y + 27, r: p, s: h }],
              }),
              value: 0n,
              skipRevert: c,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.compoundV2Repay = function (e, t, n, r, i, o = !1) {
          let {
            bundler3: { compoundV2MigrationAdapter: c },
          } = (0, s.getChainAddresses)(e);
          if (null == c) throw new u.BundlerErrors.UnexpectedAction('compoundV2Repay', e);
          return [
            {
              to: c,
              data: r
                ? (0, l.encodeFunctionData)({
                    abi: a.compoundV2MigrationAdapterAbi,
                    functionName: 'compoundV2RepayEth',
                    args: [n, i],
                  })
                : (0, l.encodeFunctionData)({
                    abi: a.compoundV2MigrationAdapterAbi,
                    functionName: 'compoundV2RepayErc20',
                    args: [t, n, i],
                  }),
              value: r ? n : 0n,
              skipRevert: o,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.compoundV2Redeem = function (e, t, n, r, i, o = !1) {
          let {
            bundler3: { compoundV2MigrationAdapter: c },
          } = (0, s.getChainAddresses)(e);
          if (null == c) throw new u.BundlerErrors.UnexpectedAction('compoundV2Repay', e);
          return [
            {
              to: c,
              data: r
                ? (0, l.encodeFunctionData)({
                    abi: a.compoundV2MigrationAdapterAbi,
                    functionName: 'compoundV2RedeemEth',
                    args: [n, i],
                  })
                : (0, l.encodeFunctionData)({
                    abi: a.compoundV2MigrationAdapterAbi,
                    functionName: 'compoundV2RedeemErc20',
                    args: [t, n, i],
                  }),
              value: 0n,
              skipRevert: o,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.compoundV3Repay = function (e, t, n, r, i = !1) {
          let {
            bundler3: { compoundV3MigrationAdapter: o },
          } = (0, s.getChainAddresses)(e);
          if (null == o) throw new u.BundlerErrors.UnexpectedAction('compoundV3Repay', e);
          return [
            {
              to: o,
              data: (0, l.encodeFunctionData)({
                abi: a.compoundV3MigrationAdapterAbi,
                functionName: 'compoundV3Repay',
                args: [t, n, r],
              }),
              value: 0n,
              skipRevert: i,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.compoundV3WithdrawFrom = function (e, t, n, r, i, o = !1) {
          let {
            bundler3: { compoundV3MigrationAdapter: c },
          } = (0, s.getChainAddresses)(e);
          if (null == c) throw new u.BundlerErrors.UnexpectedAction('compoundV3WithdrawFrom', e);
          return [
            {
              to: c,
              data: (0, l.encodeFunctionData)({
                abi: a.compoundV3MigrationAdapterAbi,
                functionName: 'compoundV3WithdrawFrom',
                args: [t, n, r, i],
              }),
              value: 0n,
              skipRevert: o,
              callbackHash: l.zeroHash,
            },
          ];
        }),
        (i.compoundV3AllowBySig = function (e, t, n, r, i, a, o, c = !0) {
          let {
            bundler3: { compoundV3MigrationAdapter: d },
          } = (0, s.getChainAddresses)(e);
          if (null == d) throw new u.BundlerErrors.UnexpectedAction('compoundV3AllowBySig', e);
          let { r: p, s: h, yParity: y } = (0, l.parseSignature)(o);
          return [
            {
              to: t,
              data: (0, l.encodeFunctionData)({
                abi: [
                  {
                    inputs: [
                      { name: 'owner', type: 'address' },
                      { name: 'manager', type: 'address' },
                      { name: 'isAllowed_', type: 'bool' },
                      { name: 'nonce', type: 'uint256' },
                      { name: 'expiry', type: 'uint256' },
                      { name: 'v', type: 'uint8' },
                      { name: 'r', type: 'bytes32' },
                      { name: 's', type: 'bytes32' },
                    ],
                    name: 'allowBySig',
                    outputs: [],
                    stateMutability: 'nonpayable',
                    type: 'function',
                  },
                ],
                functionName: 'allowBySig',
                args: [n, d, r, i, a, y + 27, p, h],
              }),
              value: 0n,
              skipRevert: c,
              callbackHash: l.zeroHash,
            },
          ];
        });
    },
    24822: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.compoundV3MigrationAdapterAbi =
          t.compoundV2MigrationAdapterAbi =
          t.aaveV3OptimizerMigrationAdapterAbi =
          t.aaveV3MigrationAdapterAbi =
          t.aaveV2MigrationAdapterAbi =
          t.erc20WrapperAdapterAbi =
          t.paraswapAdapterAbi =
          t.ethereumGeneralAdapter1Abi =
          t.generalAdapter1Abi =
          t.coreAdapterAbi =
          t.bundler3Abi =
          t.universalRewardsDistributorAbi =
          t.compoundV3MigrationBundlerAbi =
          t.compoundV2MigrationBundlerAbi =
          t.aaveV3OptimizerMigrationBundlerAbi =
          t.aaveV3MigrationBundlerAbi =
          t.aaveV2MigrationBundlerAbi =
          t.stEthBundlerAbi =
          t.wNativeBundlerAbi =
          t.urdBundlerAbi =
          t.morphoBundlerAbi =
          t.erc4626BundlerAbi =
          t.erc20WrapperBundlerAbi =
          t.permit2BundlerAbi =
          t.ethereumPermitBundlerAbi =
          t.permitBundlerAbi =
          t.transferBundlerAbi =
          t.baseBundlerAbi =
            void 0),
        (t.baseBundlerAbi = [
          {
            type: 'function',
            name: 'initiator',
            inputs: [],
            outputs: [{ name: '', type: 'address', internalType: 'address' }],
            stateMutability: 'view',
          },
          {
            type: 'function',
            name: 'multicall',
            inputs: [{ name: 'data', type: 'bytes[]', internalType: 'bytes[]' }],
            outputs: [],
            stateMutability: 'payable',
          },
        ]),
        (t.transferBundlerAbi = [
          ...t.baseBundlerAbi,
          {
            type: 'function',
            name: 'erc20Transfer',
            inputs: [
              { name: 'asset', type: 'address', internalType: 'address' },
              { name: 'recipient', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
          {
            type: 'function',
            name: 'erc20TransferFrom',
            inputs: [
              { name: 'asset', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
          {
            type: 'function',
            name: 'nativeTransfer',
            inputs: [
              { name: 'recipient', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
        ]),
        (t.permitBundlerAbi = [
          ...t.baseBundlerAbi,
          {
            type: 'function',
            name: 'permit',
            inputs: [
              { name: 'asset', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
              { name: 'deadline', type: 'uint256', internalType: 'uint256' },
              { name: 'v', type: 'uint8', internalType: 'uint8' },
              { name: 'r', type: 'bytes32', internalType: 'bytes32' },
              { name: 's', type: 'bytes32', internalType: 'bytes32' },
              { name: 'skipRevert', type: 'bool', internalType: 'bool' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
        ]),
        (t.ethereumPermitBundlerAbi = [
          ...t.permitBundlerAbi,
          {
            type: 'function',
            name: 'permitDai',
            inputs: [
              { name: 'nonce', type: 'uint256', internalType: 'uint256' },
              { name: 'expiry', type: 'uint256', internalType: 'uint256' },
              { name: 'allowed', type: 'bool', internalType: 'bool' },
              { name: 'v', type: 'uint8', internalType: 'uint8' },
              { name: 'r', type: 'bytes32', internalType: 'bytes32' },
              { name: 's', type: 'bytes32', internalType: 'bytes32' },
              { name: 'skipRevert', type: 'bool', internalType: 'bool' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
        ]),
        (t.permit2BundlerAbi = [
          ...t.baseBundlerAbi,
          {
            type: 'function',
            name: 'approve2',
            inputs: [
              {
                name: 'permitSingle',
                type: 'tuple',
                internalType: 'struct IAllowanceTransfer.PermitSingle',
                components: [
                  {
                    name: 'details',
                    type: 'tuple',
                    internalType: 'struct IAllowanceTransfer.PermitDetails',
                    components: [
                      { name: 'token', type: 'address', internalType: 'address' },
                      { name: 'amount', type: 'uint160', internalType: 'uint160' },
                      { name: 'expiration', type: 'uint48', internalType: 'uint48' },
                      { name: 'nonce', type: 'uint48', internalType: 'uint48' },
                    ],
                  },
                  { name: 'spender', type: 'address', internalType: 'address' },
                  { name: 'sigDeadline', type: 'uint256', internalType: 'uint256' },
                ],
              },
              { name: 'signature', type: 'bytes', internalType: 'bytes' },
              { name: 'skipRevert', type: 'bool', internalType: 'bool' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
          {
            type: 'function',
            name: 'transferFrom2',
            inputs: [
              { name: 'asset', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
          { type: 'error', name: 'UnsafeCast', inputs: [] },
        ]),
        (t.erc20WrapperBundlerAbi = [
          ...t.baseBundlerAbi,
          {
            type: 'function',
            name: 'erc20WrapperDepositFor',
            inputs: [
              { name: 'wrapper', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
          {
            type: 'function',
            name: 'erc20WrapperWithdrawTo',
            inputs: [
              { name: 'wrapper', type: 'address', internalType: 'address' },
              { name: 'account', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
        ]),
        (t.erc4626BundlerAbi = [
          ...t.baseBundlerAbi,
          {
            type: 'function',
            name: 'erc4626Deposit',
            inputs: [
              { name: 'vault', type: 'address', internalType: 'address' },
              { name: 'assets', type: 'uint256', internalType: 'uint256' },
              { name: 'minShares', type: 'uint256', internalType: 'uint256' },
              { name: 'receiver', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
          {
            type: 'function',
            name: 'erc4626Mint',
            inputs: [
              { name: 'vault', type: 'address', internalType: 'address' },
              { name: 'shares', type: 'uint256', internalType: 'uint256' },
              { name: 'maxAssets', type: 'uint256', internalType: 'uint256' },
              { name: 'receiver', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
          {
            type: 'function',
            name: 'erc4626Redeem',
            inputs: [
              { name: 'vault', type: 'address', internalType: 'address' },
              { name: 'shares', type: 'uint256', internalType: 'uint256' },
              { name: 'minAssets', type: 'uint256', internalType: 'uint256' },
              { name: 'receiver', type: 'address', internalType: 'address' },
              { name: 'owner', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
          {
            type: 'function',
            name: 'erc4626Withdraw',
            inputs: [
              { name: 'vault', type: 'address', internalType: 'address' },
              { name: 'assets', type: 'uint256', internalType: 'uint256' },
              { name: 'maxShares', type: 'uint256', internalType: 'uint256' },
              { name: 'receiver', type: 'address', internalType: 'address' },
              { name: 'owner', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
        ]),
        (t.morphoBundlerAbi = [
          ...t.baseBundlerAbi,
          {
            type: 'function',
            name: 'MORPHO',
            inputs: [],
            outputs: [{ name: '', type: 'address', internalType: 'contract IMorpho' }],
            stateMutability: 'view',
          },
          {
            type: 'function',
            name: 'morphoBorrow',
            inputs: [
              {
                name: 'marketParams',
                type: 'tuple',
                internalType: 'struct MarketParams',
                components: [
                  { name: 'loanToken', type: 'address', internalType: 'address' },
                  { name: 'collateralToken', type: 'address', internalType: 'address' },
                  { name: 'oracle', type: 'address', internalType: 'address' },
                  { name: 'irm', type: 'address', internalType: 'address' },
                  { name: 'lltv', type: 'uint256', internalType: 'uint256' },
                ],
              },
              { name: 'assets', type: 'uint256', internalType: 'uint256' },
              { name: 'shares', type: 'uint256', internalType: 'uint256' },
              { name: 'slippageAmount', type: 'uint256', internalType: 'uint256' },
              { name: 'receiver', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
          {
            type: 'function',
            name: 'morphoFlashLoan',
            inputs: [
              { name: 'token', type: 'address', internalType: 'address' },
              { name: 'assets', type: 'uint256', internalType: 'uint256' },
              { name: 'data', type: 'bytes', internalType: 'bytes' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
          {
            type: 'function',
            name: 'morphoRepay',
            inputs: [
              {
                name: 'marketParams',
                type: 'tuple',
                internalType: 'struct MarketParams',
                components: [
                  { name: 'loanToken', type: 'address', internalType: 'address' },
                  { name: 'collateralToken', type: 'address', internalType: 'address' },
                  { name: 'oracle', type: 'address', internalType: 'address' },
                  { name: 'irm', type: 'address', internalType: 'address' },
                  { name: 'lltv', type: 'uint256', internalType: 'uint256' },
                ],
              },
              { name: 'assets', type: 'uint256', internalType: 'uint256' },
              { name: 'shares', type: 'uint256', internalType: 'uint256' },
              { name: 'slippageAmount', type: 'uint256', internalType: 'uint256' },
              { name: 'onBehalf', type: 'address', internalType: 'address' },
              { name: 'data', type: 'bytes', internalType: 'bytes' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
          {
            type: 'function',
            name: 'morphoSetAuthorizationWithSig',
            inputs: [
              {
                name: 'authorization',
                type: 'tuple',
                internalType: 'struct Authorization',
                components: [
                  { name: 'authorizer', type: 'address', internalType: 'address' },
                  { name: 'authorized', type: 'address', internalType: 'address' },
                  { name: 'isAuthorized', type: 'bool', internalType: 'bool' },
                  { name: 'nonce', type: 'uint256', internalType: 'uint256' },
                  { name: 'deadline', type: 'uint256', internalType: 'uint256' },
                ],
              },
              {
                name: 'signature',
                type: 'tuple',
                internalType: 'struct Signature',
                components: [
                  { name: 'v', type: 'uint8', internalType: 'uint8' },
                  { name: 'r', type: 'bytes32', internalType: 'bytes32' },
                  { name: 's', type: 'bytes32', internalType: 'bytes32' },
                ],
              },
              { name: 'skipRevert', type: 'bool', internalType: 'bool' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
          {
            type: 'function',
            name: 'morphoSupply',
            inputs: [
              {
                name: 'marketParams',
                type: 'tuple',
                internalType: 'struct MarketParams',
                components: [
                  { name: 'loanToken', type: 'address', internalType: 'address' },
                  { name: 'collateralToken', type: 'address', internalType: 'address' },
                  { name: 'oracle', type: 'address', internalType: 'address' },
                  { name: 'irm', type: 'address', internalType: 'address' },
                  { name: 'lltv', type: 'uint256', internalType: 'uint256' },
                ],
              },
              { name: 'assets', type: 'uint256', internalType: 'uint256' },
              { name: 'shares', type: 'uint256', internalType: 'uint256' },
              { name: 'slippageAmount', type: 'uint256', internalType: 'uint256' },
              { name: 'onBehalf', type: 'address', internalType: 'address' },
              { name: 'data', type: 'bytes', internalType: 'bytes' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
          {
            type: 'function',
            name: 'morphoSupplyCollateral',
            inputs: [
              {
                name: 'marketParams',
                type: 'tuple',
                internalType: 'struct MarketParams',
                components: [
                  { name: 'loanToken', type: 'address', internalType: 'address' },
                  { name: 'collateralToken', type: 'address', internalType: 'address' },
                  { name: 'oracle', type: 'address', internalType: 'address' },
                  { name: 'irm', type: 'address', internalType: 'address' },
                  { name: 'lltv', type: 'uint256', internalType: 'uint256' },
                ],
              },
              { name: 'assets', type: 'uint256', internalType: 'uint256' },
              { name: 'onBehalf', type: 'address', internalType: 'address' },
              { name: 'data', type: 'bytes', internalType: 'bytes' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
          {
            type: 'function',
            name: 'morphoWithdraw',
            inputs: [
              {
                name: 'marketParams',
                type: 'tuple',
                internalType: 'struct MarketParams',
                components: [
                  { name: 'loanToken', type: 'address', internalType: 'address' },
                  { name: 'collateralToken', type: 'address', internalType: 'address' },
                  { name: 'oracle', type: 'address', internalType: 'address' },
                  { name: 'irm', type: 'address', internalType: 'address' },
                  { name: 'lltv', type: 'uint256', internalType: 'uint256' },
                ],
              },
              { name: 'assets', type: 'uint256', internalType: 'uint256' },
              { name: 'shares', type: 'uint256', internalType: 'uint256' },
              { name: 'slippageAmount', type: 'uint256', internalType: 'uint256' },
              { name: 'receiver', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
          {
            type: 'function',
            name: 'morphoWithdrawCollateral',
            inputs: [
              {
                name: 'marketParams',
                type: 'tuple',
                internalType: 'struct MarketParams',
                components: [
                  { name: 'loanToken', type: 'address', internalType: 'address' },
                  { name: 'collateralToken', type: 'address', internalType: 'address' },
                  { name: 'oracle', type: 'address', internalType: 'address' },
                  { name: 'irm', type: 'address', internalType: 'address' },
                  { name: 'lltv', type: 'uint256', internalType: 'uint256' },
                ],
              },
              { name: 'assets', type: 'uint256', internalType: 'uint256' },
              { name: 'receiver', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
          {
            type: 'function',
            name: 'onMorphoFlashLoan',
            inputs: [
              { name: '', type: 'uint256', internalType: 'uint256' },
              { name: 'data', type: 'bytes', internalType: 'bytes' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'onMorphoRepay',
            inputs: [
              { name: '', type: 'uint256', internalType: 'uint256' },
              { name: 'data', type: 'bytes', internalType: 'bytes' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'onMorphoSupply',
            inputs: [
              { name: '', type: 'uint256', internalType: 'uint256' },
              { name: 'data', type: 'bytes', internalType: 'bytes' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'onMorphoSupplyCollateral',
            inputs: [
              { name: '', type: 'uint256', internalType: 'uint256' },
              { name: 'data', type: 'bytes', internalType: 'bytes' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'reallocateTo',
            inputs: [
              { name: 'publicAllocator', type: 'address', internalType: 'address' },
              { name: 'vault', type: 'address', internalType: 'address' },
              { name: 'value', type: 'uint256', internalType: 'uint256' },
              {
                name: 'withdrawals',
                type: 'tuple[]',
                internalType: 'struct Withdrawal[]',
                components: [
                  {
                    name: 'marketParams',
                    type: 'tuple',
                    internalType: 'struct MarketParams',
                    components: [
                      { name: 'loanToken', type: 'address', internalType: 'address' },
                      { name: 'collateralToken', type: 'address', internalType: 'address' },
                      { name: 'oracle', type: 'address', internalType: 'address' },
                      { name: 'irm', type: 'address', internalType: 'address' },
                      { name: 'lltv', type: 'uint256', internalType: 'uint256' },
                    ],
                  },
                  { name: 'amount', type: 'uint128', internalType: 'uint128' },
                ],
              },
              {
                name: 'supplyMarketParams',
                type: 'tuple',
                internalType: 'struct MarketParams',
                components: [
                  { name: 'loanToken', type: 'address', internalType: 'address' },
                  { name: 'collateralToken', type: 'address', internalType: 'address' },
                  { name: 'oracle', type: 'address', internalType: 'address' },
                  { name: 'irm', type: 'address', internalType: 'address' },
                  { name: 'lltv', type: 'uint256', internalType: 'uint256' },
                ],
              },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
        ]),
        (t.urdBundlerAbi = [
          ...t.baseBundlerAbi,
          {
            type: 'function',
            name: 'urdClaim',
            inputs: [
              { name: 'distributor', type: 'address', internalType: 'address' },
              { name: 'account', type: 'address', internalType: 'address' },
              { name: 'reward', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
              { name: 'proof', type: 'bytes32[]', internalType: 'bytes32[]' },
              { name: 'skipRevert', type: 'bool', internalType: 'bool' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
        ]),
        (t.wNativeBundlerAbi = [
          ...t.baseBundlerAbi,
          { type: 'receive', stateMutability: 'payable' },
          {
            type: 'function',
            name: 'WRAPPED_NATIVE',
            inputs: [],
            outputs: [{ name: '', type: 'address', internalType: 'address' }],
            stateMutability: 'view',
          },
          {
            type: 'function',
            name: 'unwrapNative',
            inputs: [{ name: 'amount', type: 'uint256', internalType: 'uint256' }],
            outputs: [],
            stateMutability: 'payable',
          },
          {
            type: 'function',
            name: 'wrapNative',
            inputs: [{ name: 'amount', type: 'uint256', internalType: 'uint256' }],
            outputs: [],
            stateMutability: 'payable',
          },
        ]),
        (t.stEthBundlerAbi = [
          ...t.baseBundlerAbi,
          {
            type: 'function',
            name: 'ST_ETH',
            inputs: [],
            outputs: [{ name: '', type: 'address', internalType: 'address' }],
            stateMutability: 'view',
          },
          {
            type: 'function',
            name: 'WST_ETH',
            inputs: [],
            outputs: [{ name: '', type: 'address', internalType: 'address' }],
            stateMutability: 'view',
          },
          {
            type: 'function',
            name: 'stakeEth',
            inputs: [
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
              { name: 'minShares', type: 'uint256', internalType: 'uint256' },
              { name: 'referral', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
          {
            type: 'function',
            name: 'unwrapStEth',
            inputs: [{ name: 'amount', type: 'uint256', internalType: 'uint256' }],
            outputs: [],
            stateMutability: 'payable',
          },
          {
            type: 'function',
            name: 'wrapStEth',
            inputs: [{ name: 'amount', type: 'uint256', internalType: 'uint256' }],
            outputs: [],
            stateMutability: 'payable',
          },
        ]),
        (t.aaveV2MigrationBundlerAbi = [
          ...t.transferBundlerAbi,
          ...t.permitBundlerAbi,
          ...t.permit2BundlerAbi,
          ...t.stEthBundlerAbi,
          ...t.erc4626BundlerAbi,
          ...t.morphoBundlerAbi,
          {
            type: 'constructor',
            inputs: [
              { name: 'morpho', type: 'address', internalType: 'address' },
              { name: 'aaveV2Pool', type: 'address', internalType: 'address' },
              { name: 'wstEth', type: 'address', internalType: 'address' },
            ],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'AAVE_V2_POOL',
            inputs: [],
            outputs: [{ name: '', type: 'address', internalType: 'contract IAaveV2' }],
            stateMutability: 'view',
          },
          {
            type: 'function',
            name: 'aaveV2Repay',
            inputs: [
              { name: 'asset', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
              { name: 'interestRateMode', type: 'uint256', internalType: 'uint256' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
          {
            type: 'function',
            name: 'aaveV2Withdraw',
            inputs: [
              { name: 'asset', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
          { type: 'error', name: 'UnsafeCast', inputs: [] },
        ]),
        (t.aaveV3MigrationBundlerAbi = [
          ...t.transferBundlerAbi,
          ...t.permitBundlerAbi,
          ...t.permit2BundlerAbi,
          ...t.stEthBundlerAbi,
          ...t.erc4626BundlerAbi,
          ...t.morphoBundlerAbi,
          {
            type: 'constructor',
            inputs: [
              { name: 'morpho', type: 'address', internalType: 'address' },
              { name: 'aaveV3Pool', type: 'address', internalType: 'address' },
            ],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'AAVE_V3_POOL',
            inputs: [],
            outputs: [{ name: '', type: 'address', internalType: 'contract IAaveV3' }],
            stateMutability: 'view',
          },
          {
            type: 'function',
            name: 'aaveV3Repay',
            inputs: [
              { name: 'asset', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
              { name: 'interestRateMode', type: 'uint256', internalType: 'uint256' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
          {
            type: 'function',
            name: 'aaveV3Withdraw',
            inputs: [
              { name: 'asset', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
          { type: 'error', name: 'UnsafeCast', inputs: [] },
        ]),
        (t.aaveV3OptimizerMigrationBundlerAbi = [
          ...t.transferBundlerAbi,
          ...t.permitBundlerAbi,
          ...t.permit2BundlerAbi,
          ...t.stEthBundlerAbi,
          ...t.erc4626BundlerAbi,
          ...t.morphoBundlerAbi,
          {
            type: 'constructor',
            inputs: [
              { name: 'morpho', type: 'address', internalType: 'address' },
              { name: 'aaveV3Optimizer', type: 'address', internalType: 'address' },
            ],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'AAVE_V3_OPTIMIZER',
            inputs: [],
            outputs: [{ name: '', type: 'address', internalType: 'contract IAaveV3Optimizer' }],
            stateMutability: 'view',
          },
          {
            type: 'function',
            name: 'aaveV3OptimizerApproveManagerWithSig',
            inputs: [
              { name: 'isApproved', type: 'bool', internalType: 'bool' },
              { name: 'nonce', type: 'uint256', internalType: 'uint256' },
              { name: 'deadline', type: 'uint256', internalType: 'uint256' },
              {
                name: 'signature',
                type: 'tuple',
                internalType: 'struct Signature',
                components: [
                  { name: 'v', type: 'uint8', internalType: 'uint8' },
                  { name: 'r', type: 'bytes32', internalType: 'bytes32' },
                  { name: 's', type: 'bytes32', internalType: 'bytes32' },
                ],
              },
              { name: 'skipRevert', type: 'bool', internalType: 'bool' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
          {
            type: 'function',
            name: 'aaveV3OptimizerRepay',
            inputs: [
              { name: 'underlying', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
          {
            type: 'function',
            name: 'aaveV3OptimizerWithdraw',
            inputs: [
              { name: 'underlying', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
              { name: 'maxIterations', type: 'uint256', internalType: 'uint256' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
          {
            type: 'function',
            name: 'aaveV3OptimizerWithdrawCollateral',
            inputs: [
              { name: 'underlying', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
          { type: 'error', name: 'UnsafeCast', inputs: [] },
        ]),
        (t.compoundV2MigrationBundlerAbi = [
          ...t.transferBundlerAbi,
          ...t.permitBundlerAbi,
          ...t.permit2BundlerAbi,
          ...t.stEthBundlerAbi,
          ...t.erc4626BundlerAbi,
          ...t.morphoBundlerAbi,
          {
            type: 'constructor',
            inputs: [
              { name: 'morpho', type: 'address', internalType: 'address' },
              { name: 'wNative', type: 'address', internalType: 'address' },
              { name: 'cEth', type: 'address', internalType: 'address' },
            ],
            stateMutability: 'nonpayable',
          },
          { type: 'receive', stateMutability: 'payable' },
          {
            type: 'function',
            name: 'C_ETH',
            inputs: [],
            outputs: [{ name: '', type: 'address', internalType: 'address' }],
            stateMutability: 'view',
          },
          {
            type: 'function',
            name: 'compoundV2Redeem',
            inputs: [
              { name: 'cToken', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
          {
            type: 'function',
            name: 'compoundV2Repay',
            inputs: [
              { name: 'cToken', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
          { type: 'error', name: 'UnsafeCast', inputs: [] },
        ]),
        (t.compoundV3MigrationBundlerAbi = [
          ...t.transferBundlerAbi,
          ...t.permitBundlerAbi,
          ...t.permit2BundlerAbi,
          ...t.stEthBundlerAbi,
          ...t.erc4626BundlerAbi,
          ...t.morphoBundlerAbi,
          {
            type: 'constructor',
            inputs: [{ name: 'morpho', type: 'address', internalType: 'address' }],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'compoundV3AllowBySig',
            inputs: [
              { name: 'instance', type: 'address', internalType: 'address' },
              { name: 'isAllowed', type: 'bool', internalType: 'bool' },
              { name: 'nonce', type: 'uint256', internalType: 'uint256' },
              { name: 'expiry', type: 'uint256', internalType: 'uint256' },
              { name: 'v', type: 'uint8', internalType: 'uint8' },
              { name: 'r', type: 'bytes32', internalType: 'bytes32' },
              { name: 's', type: 'bytes32', internalType: 'bytes32' },
              { name: 'skipRevert', type: 'bool', internalType: 'bool' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
          {
            type: 'function',
            name: 'compoundV3Repay',
            inputs: [
              { name: 'instance', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
          {
            type: 'function',
            name: 'compoundV3WithdrawFrom',
            inputs: [
              { name: 'instance', type: 'address', internalType: 'address' },
              { name: 'asset', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
          { type: 'error', name: 'UnsafeCast', inputs: [] },
        ]),
        (t.universalRewardsDistributorAbi = [
          {
            inputs: [
              { internalType: 'address', name: 'initialOwner', type: 'address' },
              { internalType: 'uint256', name: 'initialTimelock', type: 'uint256' },
              { internalType: 'bytes32', name: 'initialRoot', type: 'bytes32' },
              { internalType: 'bytes32', name: 'initialIpfsHash', type: 'bytes32' },
            ],
            stateMutability: 'nonpayable',
            type: 'constructor',
          },
          {
            inputs: [],
            name: 'acceptRoot',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'account', type: 'address' },
              { internalType: 'address', name: 'reward', type: 'address' },
              { internalType: 'uint256', name: 'claimable', type: 'uint256' },
              { internalType: 'bytes32[]', name: 'proof', type: 'bytes32[]' },
            ],
            name: 'claim',
            outputs: [{ internalType: 'uint256', name: 'amount', type: 'uint256' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'account', type: 'address' },
              { internalType: 'address', name: 'reward', type: 'address' },
            ],
            name: 'claimed',
            outputs: [{ internalType: 'uint256', name: 'amount', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'ipfsHash',
            outputs: [{ internalType: 'bytes32', name: '', type: 'bytes32' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: '', type: 'address' }],
            name: 'isUpdater',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'owner',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'pendingRoot',
            outputs: [
              { internalType: 'bytes32', name: 'root', type: 'bytes32' },
              { internalType: 'bytes32', name: 'ipfsHash', type: 'bytes32' },
              { internalType: 'uint256', name: 'validAt', type: 'uint256' },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'revokePendingRoot',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [],
            name: 'root',
            outputs: [{ internalType: 'bytes32', name: '', type: 'bytes32' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'newOwner', type: 'address' }],
            name: 'setOwner',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'bytes32', name: 'newRoot', type: 'bytes32' },
              { internalType: 'bytes32', name: 'newIpfsHash', type: 'bytes32' },
            ],
            name: 'setRoot',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'updater', type: 'address' },
              { internalType: 'bool', name: 'active', type: 'bool' },
            ],
            name: 'setRootUpdater',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'uint256', name: 'newTimelock', type: 'uint256' }],
            name: 'setTimelock',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'bytes32', name: 'newRoot', type: 'bytes32' },
              { internalType: 'bytes32', name: 'newIpfsHash', type: 'bytes32' },
            ],
            name: 'submitRoot',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [],
            name: 'timelock',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
        ]),
        (t.bundler3Abi = [
          {
            type: 'function',
            name: 'initiator',
            inputs: [],
            outputs: [{ name: '', type: 'address', internalType: 'address' }],
            stateMutability: 'view',
          },
          {
            type: 'function',
            name: 'multicall',
            inputs: [
              {
                name: 'bundle',
                type: 'tuple[]',
                internalType: 'struct Call[]',
                components: [
                  { name: 'to', type: 'address', internalType: 'address' },
                  { name: 'data', type: 'bytes', internalType: 'bytes' },
                  { name: 'value', type: 'uint256', internalType: 'uint256' },
                  { name: 'skipRevert', type: 'bool', internalType: 'bool' },
                  { name: 'callbackHash', type: 'bytes32', internalType: 'bytes32' },
                ],
              },
            ],
            outputs: [],
            stateMutability: 'payable',
          },
          {
            type: 'function',
            name: 'reenter',
            inputs: [
              {
                name: 'bundle',
                type: 'tuple[]',
                internalType: 'struct Call[]',
                components: [
                  { name: 'to', type: 'address', internalType: 'address' },
                  { name: 'data', type: 'bytes', internalType: 'bytes' },
                  { name: 'value', type: 'uint256', internalType: 'uint256' },
                  { name: 'skipRevert', type: 'bool', internalType: 'bool' },
                  { name: 'callbackHash', type: 'bytes32', internalType: 'bytes32' },
                ],
              },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'reenterHash',
            inputs: [],
            outputs: [{ name: '', type: 'bytes32', internalType: 'bytes32' }],
            stateMutability: 'view',
          },
          { type: 'error', name: 'AlreadyInitiated', inputs: [] },
          { type: 'error', name: 'EmptyBundle', inputs: [] },
          { type: 'error', name: 'IncorrectReenterHash', inputs: [] },
          { type: 'error', name: 'MissingExpectedReenter', inputs: [] },
        ]),
        (t.coreAdapterAbi = [
          { type: 'receive', stateMutability: 'payable' },
          {
            type: 'function',
            name: 'BUNDLER3',
            inputs: [],
            outputs: [{ name: '', type: 'address', internalType: 'address' }],
            stateMutability: 'view',
          },
          {
            type: 'function',
            name: 'erc20Transfer',
            inputs: [
              { name: 'token', type: 'address', internalType: 'address' },
              { name: 'receiver', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'nativeTransfer',
            inputs: [
              { name: 'receiver', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          { type: 'error', name: 'AdapterAddress', inputs: [] },
          { type: 'error', name: 'FailedCall', inputs: [] },
          {
            type: 'error',
            name: 'InsufficientBalance',
            inputs: [
              { name: 'balance', type: 'uint256', internalType: 'uint256' },
              { name: 'needed', type: 'uint256', internalType: 'uint256' },
            ],
          },
          {
            type: 'error',
            name: 'SafeERC20FailedOperation',
            inputs: [{ name: 'token', type: 'address', internalType: 'address' }],
          },
          { type: 'error', name: 'UnauthorizedSender', inputs: [] },
          { type: 'error', name: 'ZeroAddress', inputs: [] },
          { type: 'error', name: 'ZeroAmount', inputs: [] },
        ]),
        (t.generalAdapter1Abi = [
          ...t.coreAdapterAbi,
          {
            type: 'constructor',
            inputs: [
              { name: 'bundler3', type: 'address', internalType: 'address' },
              { name: 'morpho', type: 'address', internalType: 'address' },
              { name: 'wNative', type: 'address', internalType: 'address' },
            ],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'MORPHO',
            inputs: [],
            outputs: [{ name: '', type: 'address', internalType: 'contract IMorpho' }],
            stateMutability: 'view',
          },
          {
            type: 'function',
            name: 'WRAPPED_NATIVE',
            inputs: [],
            outputs: [{ name: '', type: 'address', internalType: 'contract IWNative' }],
            stateMutability: 'view',
          },
          {
            type: 'function',
            name: 'erc20TransferFrom',
            inputs: [
              { name: 'token', type: 'address', internalType: 'address' },
              { name: 'receiver', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'erc4626Deposit',
            inputs: [
              { name: 'vault', type: 'address', internalType: 'address' },
              { name: 'assets', type: 'uint256', internalType: 'uint256' },
              { name: 'maxSharePriceE27', type: 'uint256', internalType: 'uint256' },
              { name: 'receiver', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'erc4626Mint',
            inputs: [
              { name: 'vault', type: 'address', internalType: 'address' },
              { name: 'shares', type: 'uint256', internalType: 'uint256' },
              { name: 'maxSharePriceE27', type: 'uint256', internalType: 'uint256' },
              { name: 'receiver', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'erc4626Redeem',
            inputs: [
              { name: 'vault', type: 'address', internalType: 'address' },
              { name: 'shares', type: 'uint256', internalType: 'uint256' },
              { name: 'minSharePriceE27', type: 'uint256', internalType: 'uint256' },
              { name: 'receiver', type: 'address', internalType: 'address' },
              { name: 'owner', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'erc4626Withdraw',
            inputs: [
              { name: 'vault', type: 'address', internalType: 'address' },
              { name: 'assets', type: 'uint256', internalType: 'uint256' },
              { name: 'minSharePriceE27', type: 'uint256', internalType: 'uint256' },
              { name: 'receiver', type: 'address', internalType: 'address' },
              { name: 'owner', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'morphoBorrow',
            inputs: [
              {
                name: 'marketParams',
                type: 'tuple',
                internalType: 'struct MarketParams',
                components: [
                  { name: 'loanToken', type: 'address', internalType: 'address' },
                  { name: 'collateralToken', type: 'address', internalType: 'address' },
                  { name: 'oracle', type: 'address', internalType: 'address' },
                  { name: 'irm', type: 'address', internalType: 'address' },
                  { name: 'lltv', type: 'uint256', internalType: 'uint256' },
                ],
              },
              { name: 'assets', type: 'uint256', internalType: 'uint256' },
              { name: 'shares', type: 'uint256', internalType: 'uint256' },
              { name: 'minSharePriceE27', type: 'uint256', internalType: 'uint256' },
              { name: 'receiver', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'morphoFlashLoan',
            inputs: [
              { name: 'token', type: 'address', internalType: 'address' },
              { name: 'assets', type: 'uint256', internalType: 'uint256' },
              { name: 'data', type: 'bytes', internalType: 'bytes' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'morphoRepay',
            inputs: [
              {
                name: 'marketParams',
                type: 'tuple',
                internalType: 'struct MarketParams',
                components: [
                  { name: 'loanToken', type: 'address', internalType: 'address' },
                  { name: 'collateralToken', type: 'address', internalType: 'address' },
                  { name: 'oracle', type: 'address', internalType: 'address' },
                  { name: 'irm', type: 'address', internalType: 'address' },
                  { name: 'lltv', type: 'uint256', internalType: 'uint256' },
                ],
              },
              { name: 'assets', type: 'uint256', internalType: 'uint256' },
              { name: 'shares', type: 'uint256', internalType: 'uint256' },
              { name: 'maxSharePriceE27', type: 'uint256', internalType: 'uint256' },
              { name: 'onBehalf', type: 'address', internalType: 'address' },
              { name: 'data', type: 'bytes', internalType: 'bytes' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'morphoSupply',
            inputs: [
              {
                name: 'marketParams',
                type: 'tuple',
                internalType: 'struct MarketParams',
                components: [
                  { name: 'loanToken', type: 'address', internalType: 'address' },
                  { name: 'collateralToken', type: 'address', internalType: 'address' },
                  { name: 'oracle', type: 'address', internalType: 'address' },
                  { name: 'irm', type: 'address', internalType: 'address' },
                  { name: 'lltv', type: 'uint256', internalType: 'uint256' },
                ],
              },
              { name: 'assets', type: 'uint256', internalType: 'uint256' },
              { name: 'shares', type: 'uint256', internalType: 'uint256' },
              { name: 'maxSharePriceE27', type: 'uint256', internalType: 'uint256' },
              { name: 'onBehalf', type: 'address', internalType: 'address' },
              { name: 'data', type: 'bytes', internalType: 'bytes' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'morphoSupplyCollateral',
            inputs: [
              {
                name: 'marketParams',
                type: 'tuple',
                internalType: 'struct MarketParams',
                components: [
                  { name: 'loanToken', type: 'address', internalType: 'address' },
                  { name: 'collateralToken', type: 'address', internalType: 'address' },
                  { name: 'oracle', type: 'address', internalType: 'address' },
                  { name: 'irm', type: 'address', internalType: 'address' },
                  { name: 'lltv', type: 'uint256', internalType: 'uint256' },
                ],
              },
              { name: 'assets', type: 'uint256', internalType: 'uint256' },
              { name: 'onBehalf', type: 'address', internalType: 'address' },
              { name: 'data', type: 'bytes', internalType: 'bytes' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'morphoWithdraw',
            inputs: [
              {
                name: 'marketParams',
                type: 'tuple',
                internalType: 'struct MarketParams',
                components: [
                  { name: 'loanToken', type: 'address', internalType: 'address' },
                  { name: 'collateralToken', type: 'address', internalType: 'address' },
                  { name: 'oracle', type: 'address', internalType: 'address' },
                  { name: 'irm', type: 'address', internalType: 'address' },
                  { name: 'lltv', type: 'uint256', internalType: 'uint256' },
                ],
              },
              { name: 'assets', type: 'uint256', internalType: 'uint256' },
              { name: 'shares', type: 'uint256', internalType: 'uint256' },
              { name: 'minSharePriceE27', type: 'uint256', internalType: 'uint256' },
              { name: 'receiver', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'morphoWithdrawCollateral',
            inputs: [
              {
                name: 'marketParams',
                type: 'tuple',
                internalType: 'struct MarketParams',
                components: [
                  { name: 'loanToken', type: 'address', internalType: 'address' },
                  { name: 'collateralToken', type: 'address', internalType: 'address' },
                  { name: 'oracle', type: 'address', internalType: 'address' },
                  { name: 'irm', type: 'address', internalType: 'address' },
                  { name: 'lltv', type: 'uint256', internalType: 'uint256' },
                ],
              },
              { name: 'assets', type: 'uint256', internalType: 'uint256' },
              { name: 'receiver', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'onMorphoFlashLoan',
            inputs: [
              { name: '', type: 'uint256', internalType: 'uint256' },
              { name: 'data', type: 'bytes', internalType: 'bytes' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'onMorphoRepay',
            inputs: [
              { name: '', type: 'uint256', internalType: 'uint256' },
              { name: 'data', type: 'bytes', internalType: 'bytes' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'onMorphoSupply',
            inputs: [
              { name: '', type: 'uint256', internalType: 'uint256' },
              { name: 'data', type: 'bytes', internalType: 'bytes' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'onMorphoSupplyCollateral',
            inputs: [
              { name: '', type: 'uint256', internalType: 'uint256' },
              { name: 'data', type: 'bytes', internalType: 'bytes' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'permit2TransferFrom',
            inputs: [
              { name: 'token', type: 'address', internalType: 'address' },
              { name: 'receiver', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'unwrapNative',
            inputs: [
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
              { name: 'receiver', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'wrapNative',
            inputs: [
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
              { name: 'receiver', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          { type: 'error', name: 'SlippageExceeded', inputs: [] },
          { type: 'error', name: 'UnexpectedOwner', inputs: [] },
          { type: 'error', name: 'UnsafeCast', inputs: [] },
          { type: 'error', name: 'ZeroShares', inputs: [] },
        ]),
        (t.ethereumGeneralAdapter1Abi = [
          ...t.generalAdapter1Abi,
          {
            type: 'constructor',
            inputs: [
              { name: 'bundler3', type: 'address', internalType: 'address' },
              { name: 'morpho', type: 'address', internalType: 'address' },
              { name: 'weth', type: 'address', internalType: 'address' },
              { name: 'wStEth', type: 'address', internalType: 'address' },
              { name: 'morphoToken', type: 'address', internalType: 'address' },
              { name: 'morphoWrapper', type: 'address', internalType: 'address' },
            ],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'MORPHO_TOKEN',
            inputs: [],
            outputs: [{ name: '', type: 'address', internalType: 'address' }],
            stateMutability: 'view',
          },
          {
            type: 'function',
            name: 'MORPHO_WRAPPER',
            inputs: [],
            outputs: [{ name: '', type: 'address', internalType: 'address' }],
            stateMutability: 'view',
          },
          {
            type: 'function',
            name: 'ST_ETH',
            inputs: [],
            outputs: [{ name: '', type: 'address', internalType: 'address' }],
            stateMutability: 'view',
          },
          {
            type: 'function',
            name: 'WST_ETH',
            inputs: [],
            outputs: [{ name: '', type: 'address', internalType: 'address' }],
            stateMutability: 'view',
          },
          {
            type: 'function',
            name: 'morphoWrapperDepositFor',
            inputs: [
              { name: 'receiver', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'morphoWrapperWithdrawTo',
            inputs: [
              { name: 'receiver', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'stakeEth',
            inputs: [
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
              { name: 'maxSharePriceE27', type: 'uint256', internalType: 'uint256' },
              { name: 'referral', type: 'address', internalType: 'address' },
              { name: 'receiver', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'unwrapStEth',
            inputs: [
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
              { name: 'receiver', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'wrapStEth',
            inputs: [
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
              { name: 'receiver', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
        ]),
        (t.paraswapAdapterAbi = [
          ...t.coreAdapterAbi,
          {
            type: 'constructor',
            inputs: [
              { name: 'bundler3', type: 'address', internalType: 'address' },
              { name: 'morpho', type: 'address', internalType: 'address' },
              { name: 'augustusRegistry', type: 'address', internalType: 'address' },
            ],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'AUGUSTUS_REGISTRY',
            inputs: [],
            outputs: [{ name: '', type: 'address', internalType: 'contract IAugustusRegistry' }],
            stateMutability: 'view',
          },
          {
            type: 'function',
            name: 'MORPHO',
            inputs: [],
            outputs: [{ name: '', type: 'address', internalType: 'contract IMorpho' }],
            stateMutability: 'view',
          },
          {
            type: 'function',
            name: 'buy',
            inputs: [
              { name: 'augustus', type: 'address', internalType: 'address' },
              { name: 'callData', type: 'bytes', internalType: 'bytes' },
              { name: 'srcToken', type: 'address', internalType: 'address' },
              { name: 'destToken', type: 'address', internalType: 'address' },
              { name: 'newDestAmount', type: 'uint256', internalType: 'uint256' },
              {
                name: 'offsets',
                type: 'tuple',
                internalType: 'struct Offsets',
                components: [
                  { name: 'exactAmount', type: 'uint256', internalType: 'uint256' },
                  { name: 'limitAmount', type: 'uint256', internalType: 'uint256' },
                  { name: 'quotedAmount', type: 'uint256', internalType: 'uint256' },
                ],
              },
              { name: 'receiver', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'buyMorphoDebt',
            inputs: [
              { name: 'augustus', type: 'address', internalType: 'address' },
              { name: 'callData', type: 'bytes', internalType: 'bytes' },
              { name: 'srcToken', type: 'address', internalType: 'address' },
              {
                name: 'marketParams',
                type: 'tuple',
                internalType: 'struct MarketParams',
                components: [
                  { name: 'loanToken', type: 'address', internalType: 'address' },
                  { name: 'collateralToken', type: 'address', internalType: 'address' },
                  { name: 'oracle', type: 'address', internalType: 'address' },
                  { name: 'irm', type: 'address', internalType: 'address' },
                  { name: 'lltv', type: 'uint256', internalType: 'uint256' },
                ],
              },
              {
                name: 'offsets',
                type: 'tuple',
                internalType: 'struct Offsets',
                components: [
                  { name: 'exactAmount', type: 'uint256', internalType: 'uint256' },
                  { name: 'limitAmount', type: 'uint256', internalType: 'uint256' },
                  { name: 'quotedAmount', type: 'uint256', internalType: 'uint256' },
                ],
              },
              { name: 'onBehalf', type: 'address', internalType: 'address' },
              { name: 'receiver', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'sell',
            inputs: [
              { name: 'augustus', type: 'address', internalType: 'address' },
              { name: 'callData', type: 'bytes', internalType: 'bytes' },
              { name: 'srcToken', type: 'address', internalType: 'address' },
              { name: 'destToken', type: 'address', internalType: 'address' },
              { name: 'sellEntireBalance', type: 'bool', internalType: 'bool' },
              {
                name: 'offsets',
                type: 'tuple',
                internalType: 'struct Offsets',
                components: [
                  { name: 'exactAmount', type: 'uint256', internalType: 'uint256' },
                  { name: 'limitAmount', type: 'uint256', internalType: 'uint256' },
                  { name: 'quotedAmount', type: 'uint256', internalType: 'uint256' },
                ],
              },
              { name: 'receiver', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          { type: 'error', name: 'BuyAmountTooLow', inputs: [] },
          { type: 'error', name: 'InvalidAugustus', inputs: [] },
          { type: 'error', name: 'InvalidOffset', inputs: [] },
          { type: 'error', name: 'SellAmountTooHigh', inputs: [] },
        ]),
        (t.erc20WrapperAdapterAbi = [
          ...t.coreAdapterAbi,
          {
            type: 'constructor',
            inputs: [{ name: 'bundler3', type: 'address', internalType: 'address' }],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'erc20WrapperDepositFor',
            inputs: [
              { name: 'wrapper', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'erc20WrapperWithdrawTo',
            inputs: [
              { name: 'wrapper', type: 'address', internalType: 'address' },
              { name: 'receiver', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          { type: 'error', name: 'DepositFailed', inputs: [] },
          { type: 'error', name: 'WithdrawFailed', inputs: [] },
        ]),
        (t.aaveV2MigrationAdapterAbi = [
          ...t.coreAdapterAbi,
          {
            type: 'constructor',
            inputs: [
              { name: 'bundler3', type: 'address', internalType: 'address' },
              { name: 'aaveV2Pool', type: 'address', internalType: 'address' },
            ],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'aaveV2Repay',
            inputs: [
              { name: 'token', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
              { name: 'interestRateMode', type: 'uint256', internalType: 'uint256' },
              { name: 'onBehalf', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'aaveV2Withdraw',
            inputs: [
              { name: 'token', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
              { name: 'receiver', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
        ]),
        (t.aaveV3MigrationAdapterAbi = [
          ...t.coreAdapterAbi,
          {
            type: 'constructor',
            inputs: [
              { name: 'bundler3', type: 'address', internalType: 'address' },
              { name: 'aaveV3Pool', type: 'address', internalType: 'address' },
            ],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'aaveV3Repay',
            inputs: [
              { name: 'token', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
              { name: 'interestRateMode', type: 'uint256', internalType: 'uint256' },
              { name: 'onBehalf', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'aaveV3Withdraw',
            inputs: [
              { name: 'token', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
              { name: 'receiver', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
        ]),
        (t.aaveV3OptimizerMigrationAdapterAbi = [
          ...t.coreAdapterAbi,
          {
            type: 'constructor',
            inputs: [
              { name: 'bundler3', type: 'address', internalType: 'address' },
              { name: 'aaveV3Optimizer', type: 'address', internalType: 'address' },
            ],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'aaveV3OptimizerRepay',
            inputs: [
              { name: 'underlying', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
              { name: 'onBehalf', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'aaveV3OptimizerWithdraw',
            inputs: [
              { name: 'underlying', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
              { name: 'maxIterations', type: 'uint256', internalType: 'uint256' },
              { name: 'receiver', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'aaveV3OptimizerWithdrawCollateral',
            inputs: [
              { name: 'underlying', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
              { name: 'receiver', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
        ]),
        (t.compoundV2MigrationAdapterAbi = [
          ...t.coreAdapterAbi,
          {
            type: 'constructor',
            inputs: [
              { name: 'bundler3', type: 'address', internalType: 'address' },
              { name: 'cEth', type: 'address', internalType: 'address' },
            ],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'C_ETH',
            inputs: [],
            outputs: [{ name: '', type: 'address', internalType: 'address' }],
            stateMutability: 'view',
          },
          {
            type: 'function',
            name: 'compoundV2RedeemErc20',
            inputs: [
              { name: 'cToken', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
              { name: 'receiver', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'compoundV2RedeemEth',
            inputs: [
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
              { name: 'receiver', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'compoundV2RepayErc20',
            inputs: [
              { name: 'cToken', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
              { name: 'onBehalf', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'compoundV2RepayEth',
            inputs: [
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
              { name: 'onBehalf', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
        ]),
        (t.compoundV3MigrationAdapterAbi = [
          ...t.coreAdapterAbi,
          {
            type: 'constructor',
            inputs: [{ name: 'bundler3', type: 'address', internalType: 'address' }],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'compoundV3Repay',
            inputs: [
              { name: 'instance', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
              { name: 'onBehalf', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
          {
            type: 'function',
            name: 'compoundV3WithdrawFrom',
            inputs: [
              { name: 'instance', type: 'address', internalType: 'address' },
              { name: 'asset', type: 'address', internalType: 'address' },
              { name: 'amount', type: 'uint256', internalType: 'uint256' },
              { name: 'receiver', type: 'address', internalType: 'address' },
            ],
            outputs: [],
            stateMutability: 'nonpayable',
          },
        ]);
    },
    94007: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.encodeOperation = t.MAX_TOKEN_APPROVALS = t.APPROVE_ONLY_ONCE_TOKENS = void 0),
        (t.encodeBundle = p);
      let r = n(52707),
        i = n(40252),
        a = n(35047),
        s = n(51196),
        o = n(4565),
        l = n(28893),
        u = n(12309),
        c = n(73869);
      (t.APPROVE_ONLY_ONCE_TOKENS = {
        [i.ChainId.EthMainnet]: [
          '0xdAC17F958D2ee523a2206206994597C13D831ec7',
          '0xD533a949740bb3306d119CC777fa900bA034cd52',
        ],
      }),
        (t.MAX_TOKEN_APPROVALS = {
          [i.ChainId.EthMainnet]: {
            '0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984': i.MathLib.maxUint(96),
          },
        });
      let d = (e, n, a, s, o) => {
        let { chainId: l } = o,
          {
            morpho: u,
            bundler3: { generalAdapter1: c },
            permit2: d,
          } = (0, i.getChainAddresses)(l);
        s = i.MathLib.min(s, t.MAX_TOKEN_APPROVALS[l]?.[e] ?? r.maxUint256);
        let p = [];
        if (t.APPROVE_ONLY_ONCE_TOKENS[l]?.includes(e)) {
          let t =
            a === u
              ? 'morpho'
              : a === c
                ? 'bundler3.generalAdapter1'
                : a === d
                  ? 'permit2'
                  : void 0;
          0n !==
            (null != t
              ? o.getHolding(n, e).erc20Allowances[t]
              : o.vaults[a]?.asset === e
                ? o.getVaultUser(a, n).allowance
                : 0n) &&
            p.push({
              type: 'erc20Approve',
              args: [e, a, 0n],
              tx: {
                to: e,
                data: (0, r.encodeFunctionData)({
                  abi: r.erc20Abi,
                  functionName: 'approve',
                  args: [a, 0n],
                }),
              },
            });
        }
        return (
          p.push({
            type: 'erc20Approve',
            args: [e, a, s],
            tx: {
              to: e,
              data: (0, r.encodeFunctionData)({
                abi: r.erc20Abi,
                functionName: 'approve',
                args: [a, s],
              }),
            },
          }),
          p
        );
      };
      function p(e, n, r = !0) {
        let i = new u.ActionBundle([n]);
        for (let n = 0; n < e.length; ++n) {
          let {
            dataAfter: a,
            actions: s,
            requirements: o,
          } = (0, t.encodeOperation)(e[n], i.steps[n], r, n);
          i.steps.push(a),
            i.actions.push(...s),
            i.requirements.signatures.push(...o.signatures),
            i.requirements.txs.push(...o.txs);
        }
        return i;
      }
      t.encodeOperation = (e, t, n = !0, h = 0) => {
        let y;
        let { chainId: f } = t,
          m = a.Time.timestamp() + a.Time.s.from.h(24n),
          {
            morpho: g,
            bundler3: { bundler3: b, generalAdapter1: w },
            permit2: v,
            wNative: T,
            dai: A,
            wstEth: E,
            stEth: C,
          } = (0, i.getChainAddresses)(f),
          _ = [],
          I = new u.ActionBundleRequirements(),
          S = (0, a.getValue)(e.args, 'callback'),
          P = {
            ...e,
            args: {
              ...e.args,
              ...(S && { callback: (e) => ((y = p(S, (0, s.getCurrent)(e), n)), S) }),
            },
          },
          O = (0, s.simulateOperation)(P, t, h);
        y && (I.txs.push(...y.requirements.txs), I.signatures.push(...y.requirements.signatures));
        let { sender: N, address: x } = e;
        switch (e.type) {
          case 'Blue_SetAuthorization': {
            let { owner: i, isAuthorized: a, authorized: s } = e.args;
            if (s === b) throw new c.BundlerErrors.UnexpectedSignature(s);
            if (n) {
              let n = t.getUser(i),
                u = {
                  authorizer: i,
                  authorized: s,
                  isAuthorized: a,
                  deadline: m,
                  nonce: n.morphoNonce,
                },
                c = { type: 'morphoSetAuthorizationWithSig', args: [u, null, e.skipRevert] };
              _.push(c),
                I.signatures.push({
                  action: c,
                  async sign(e, t = e.account) {
                    let n = c.args[1];
                    if (null != n) return n;
                    let i = (0, o.getAuthorizationTypedData)(u, f);
                    return (
                      (n = await (0, l.signTypedData)(e, { ...i, account: t })),
                      await (0, r.verifyTypedData)({ ...i, address: N, signature: n }),
                      (c.args[1] = n)
                    );
                  },
                });
              break;
            }
            I.txs.push({
              type: 'morphoSetAuthorization',
              args: [s, a],
              tx: {
                to: g,
                data: (0, r.encodeFunctionData)({
                  abi: o.blueAbi,
                  functionName: 'setAuthorization',
                  args: [s, a],
                }),
              },
            });
            break;
          }
          case 'Erc20_Approve': {
            if (x === i.NATIVE_ADDRESS) break;
            let { amount: r, spender: a } = e.args;
            if (!n && a === v) break;
            I.txs.push(...d(x, N, a, r, t));
            break;
          }
          case 'Erc20_Permit': {
            if (x === i.NATIVE_ADDRESS) break;
            let { amount: a, spender: s, nonce: u } = e.args;
            if (s !== w) throw new c.BundlerErrors.UnexpectedSignature(s);
            if (n) {
              let n =
                x === A
                  ? { type: 'permitDai', args: [N, u, m, !0, null, e.skipRevert] }
                  : { type: 'permit', args: [N, x, a, m, null, e.skipRevert] };
              _.push(n);
              let i = t.getToken(x);
              I.signatures.push({
                action: n,
                async sign(e, t = e.account) {
                  let c = n.args[4];
                  if (null != c) return c;
                  if (x === A) {
                    let n = (0, o.getDaiPermitTypedData)(
                      { owner: N, spender: s, allowance: a, nonce: u, deadline: m },
                      f
                    );
                    (c = await (0, l.signTypedData)(e, { ...n, account: t })),
                      await (0, r.verifyTypedData)({ ...n, address: t.address, signature: c });
                  } else {
                    let n = (0, o.getPermitTypedData)(
                      { erc20: i, owner: N, spender: s, allowance: a, nonce: u, deadline: m },
                      f
                    );
                    (c = await (0, l.signTypedData)(e, { ...n, account: t })),
                      await (0, r.verifyTypedData)({ ...n, address: N, signature: c });
                  }
                  return (n.args[4] = c);
                },
              });
              break;
            }
            I.txs.push(...d(x, N, s, a, t));
            break;
          }
          case 'Erc20_Permit2': {
            if (x === i.NATIVE_ADDRESS) break;
            let { amount: a, expiration: s, nonce: u } = e.args;
            if (n) {
              let t = {
                type: 'approve2',
                args: [
                  N,
                  {
                    details: { token: x, amount: a, nonce: Number(u), expiration: Number(s) },
                    sigDeadline: m,
                  },
                  null,
                  e.skipRevert,
                ],
              };
              _.push(t),
                I.signatures.push({
                  action: t,
                  async sign(e, n = e.account) {
                    let { details: i, sigDeadline: a } = t.args[1],
                      s = t.args[2];
                    if (null != s) return s;
                    let u = (0, o.getPermit2PermitTypedData)(
                      {
                        spender: w,
                        allowance: i.amount,
                        erc20: i.token,
                        nonce: i.nonce,
                        deadline: a,
                        expiration: i.expiration,
                      },
                      f
                    );
                    return (
                      (s = await (0, l.signTypedData)(e, { ...u, account: n })),
                      await (0, r.verifyTypedData)({ ...u, address: N, signature: s }),
                      (t.args[2] = s)
                    );
                  },
                });
              break;
            }
            I.txs.push(...d(x, N, w, a, t));
            break;
          }
          case 'Erc20_Transfer': {
            let { amount: t, from: n, to: r } = e.args;
            if (x === i.NATIVE_ADDRESS) {
              _.push({ type: 'nativeTransfer', args: [n, r, t, e.skipRevert] });
              break;
            }
            if (n === w) {
              _.push({ type: 'erc20Transfer', args: [x, r, t, w, e.skipRevert] });
              break;
            }
            _.push({ type: 'erc20TransferFrom', args: [x, t, r, e.skipRevert] });
            break;
          }
          case 'Erc20_Transfer2': {
            let { amount: t, to: r } = e.args;
            if (n) {
              _.push({ type: 'transferFrom2', args: [x, t, r, e.skipRevert] });
              break;
            }
            _.push({ type: 'erc20TransferFrom', args: [x, t, r, e.skipRevert] });
            break;
          }
          case 'Erc20_Wrap': {
            let { amount: t } = e.args;
            switch (x) {
              case T:
                _.push({ type: 'wrapNative', args: [t, w, e.skipRevert] });
                break;
              case E:
                _.push({ type: 'wrapStEth', args: [t, w, e.skipRevert] });
                break;
              case C:
                _.push({
                  type: 'stakeEth',
                  args: [t, i.MathLib.MAX_UINT_256, r.zeroAddress, w, e.skipRevert],
                });
                break;
              default:
                if (i.erc20WrapperTokens[f]?.has(x)) {
                  let n = (0, i.getUnwrappedToken)(x, f);
                  if (null == n) throw Error(`unknown wrapped token: ${x}`);
                  _.push({ type: 'erc20WrapperDepositFor', args: [x, n, t, e.skipRevert] });
                  break;
                }
                if (!i.convexWrapperTokens[f]?.has(x)) throw Error(`unexpected token wrap: ${x}`);
            }
            break;
          }
          case 'Erc20_Unwrap': {
            let { amount: t, receiver: n } = e.args;
            switch (x) {
              case T:
                _.push({ type: 'unwrapNative', args: [t, w, e.skipRevert] });
                break;
              case E:
                _.push({ type: 'unwrapStEth', args: [t, w, e.skipRevert] });
                break;
              default:
                if (!i.erc20WrapperTokens[f]?.has(x)) throw Error(`unexpected token unwrap: ${x}`);
                _.push({ type: 'erc20WrapperWithdrawTo', args: [x, n, t, e.skipRevert] });
            }
            break;
          }
          case 'Blue_Supply': {
            let {
                id: n,
                assets: r = 0n,
                shares: a = 0n,
                onBehalf: s,
                slippage: o = i.DEFAULT_SLIPPAGE_TOLERANCE,
              } = e.args,
              l = t.getMarket(n).accrueInterest(t.block.timestamp),
              { assets: u, shares: c } = l.supply(r, a),
              d = i.MathLib.mulDivUp(u, i.MathLib.wToRay(i.MathLib.WAD + o), c);
            _.push({
              type: 'morphoSupply',
              args: [l.params, r, a, d, s, y?.actions ?? [], e.skipRevert],
            });
            break;
          }
          case 'Blue_Withdraw': {
            let {
                id: n,
                assets: r = 0n,
                shares: a = 0n,
                receiver: s,
                slippage: o = i.DEFAULT_SLIPPAGE_TOLERANCE,
              } = e.args,
              l = t.getMarket(n).accrueInterest(t.block.timestamp),
              { assets: u, shares: c } = l.withdraw(r, a),
              d = i.MathLib.mulDivUp(u, i.MathLib.wToRay(i.MathLib.WAD - o), c);
            _.push({ type: 'morphoWithdraw', args: [l.params, r, a, d, s, e.skipRevert] });
            break;
          }
          case 'Blue_Borrow': {
            let {
                id: n,
                assets: r = 0n,
                shares: a = 0n,
                receiver: s,
                slippage: o = i.DEFAULT_SLIPPAGE_TOLERANCE,
              } = e.args,
              l = t.getMarket(n).accrueInterest(t.block.timestamp),
              { assets: u, shares: c } = l.borrow(r, a),
              d = i.MathLib.mulDivUp(u, i.MathLib.wToRay(i.MathLib.WAD - o), c);
            _.push({ type: 'morphoBorrow', args: [l.params, r, a, d, s, e.skipRevert] });
            break;
          }
          case 'Blue_Repay': {
            let {
                id: n,
                assets: r = 0n,
                shares: a = 0n,
                onBehalf: s,
                slippage: o = i.DEFAULT_SLIPPAGE_TOLERANCE,
              } = e.args,
              l = t.getMarket(n).accrueInterest(t.block.timestamp),
              { assets: u, shares: c } = l.repay(r, a),
              d = i.MathLib.mulDivUp(u, i.MathLib.wToRay(i.MathLib.WAD + o), c);
            _.push({
              type: 'morphoRepay',
              args: [l.params, r, a, d, s, y?.actions ?? [], e.skipRevert],
            });
            break;
          }
          case 'Blue_SupplyCollateral': {
            let { id: n, assets: r, onBehalf: a } = e.args,
              { params: s } = t.getMarket(n);
            if (i.convexWrapperTokens[f]?.has(s.collateralToken)) {
              let t = (0, i.getUnwrappedToken)(x, f);
              if (null == t) throw Error(`unknown wrapped token: ${x}`);
              _.push({
                type: 'erc20WrapperDepositFor',
                args: [s.collateralToken, t, r, e.skipRevert],
              });
              break;
            }
            _.push({
              type: 'morphoSupplyCollateral',
              args: [s, r, a, y?.actions ?? [], e.skipRevert],
            });
            break;
          }
          case 'Blue_WithdrawCollateral': {
            let { id: n, assets: r, receiver: i } = e.args,
              { params: a } = t.getMarket(n);
            _.push({ type: 'morphoWithdrawCollateral', args: [a, r, i, e.skipRevert] });
            break;
          }
          case 'MetaMorpho_Deposit': {
            let {
                assets: n = 0n,
                shares: r = 0n,
                owner: a,
                slippage: s = i.DEFAULT_SLIPPAGE_TOLERANCE,
              } = e.args,
              o = t.getAccrualVault(x).accrueInterest(t.block.timestamp);
            if (0n === r) {
              let t = i.MathLib.mulDivUp(n, i.MathLib.wToRay(i.MathLib.WAD + s), o.toShares(n));
              _.push({ type: 'erc4626Deposit', args: [x, n, t, a, e.skipRevert] });
            } else {
              let t = i.MathLib.mulDivUp(o.toAssets(r), i.MathLib.wToRay(i.MathLib.WAD + s), r);
              _.push({ type: 'erc4626Mint', args: [x, r, t, a, e.skipRevert] });
            }
            break;
          }
          case 'MetaMorpho_Withdraw': {
            let {
                assets: n = 0n,
                shares: r = 0n,
                owner: a,
                receiver: s,
                slippage: o = i.DEFAULT_SLIPPAGE_TOLERANCE,
              } = e.args,
              l = t.getAccrualVault(x).accrueInterest(t.block.timestamp);
            if (0n === r) {
              let t = i.MathLib.mulDivUp(n, i.MathLib.wToRay(i.MathLib.WAD - o), l.toShares(n));
              _.push({ type: 'erc4626Withdraw', args: [x, n, t, s, a, e.skipRevert] });
            } else {
              let t = i.MathLib.mulDivUp(l.toAssets(r), i.MathLib.wToRay(i.MathLib.WAD - o), r);
              _.push({ type: 'erc4626Redeem', args: [x, r, t, s, a, e.skipRevert] });
            }
            break;
          }
          case 'MetaMorpho_PublicReallocate': {
            let { withdrawals: n, supplyMarketId: r } = e.args,
              { fee: i } = t.getVault(x).publicAllocatorConfig;
            _.push({
              type: 'reallocateTo',
              args: [
                x,
                i,
                n.map(({ id: e, assets: n }) => ({
                  marketParams: t.getMarket(e).params,
                  amount: n,
                })),
                t.getMarket(r).params,
                e.skipRevert,
              ],
            });
          }
        }
        return { dataAfter: O, actions: _, requirements: I };
      };
    },
    66311: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }), (t.setupBundle = void 0);
      let r = n(94007),
        i = n(61114);
      t.setupBundle = (
        e,
        t,
        n,
        { supportsSignature: a, unwrapTokens: s, unwrapSlippage: o, ...l } = {}
      ) => {
        let { operations: u } = (0, i.populateBundle)(e, t, l);
        u = (0, i.finalizeBundle)(u, t, n, s, o);
        let c = (0, r.encodeBundle)(u, t, a);
        return { operations: u, bundle: c };
      };
    },
    73869: function (e, t) {
      'use strict';
      var n;
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.BundlerErrors = void 0),
        (function (e) {
          class t extends Error {
            error;
            index;
            inputOperation;
            steps;
            constructor(e, t, n, r) {
              super(e.message),
                (this.error = e),
                (this.index = t),
                (this.inputOperation = n),
                (this.steps = r),
                (this.stack = e.stack);
            }
          }
          e.Bundle = t;
          class n extends Error {
            constructor() {
              super('missing signature');
            }
          }
          e.MissingSignature = n;
          class r extends Error {
            constructor(e, t) {
              super(`unexpected action "${e}" on chain "${t}"`);
            }
          }
          e.UnexpectedAction = r;
          class i extends Error {
            constructor(e) {
              super(`unexpected signature consumer "${e}"`);
            }
          }
          e.UnexpectedSignature = i;
        })(n || (t.BundlerErrors = n = {}));
    },
    56044: function (e, t, n) {
      'use strict';
      var r =
          (this && this.__createBinding) ||
          (Object.create
            ? function (e, t, n, r) {
                void 0 === r && (r = n);
                var i = Object.getOwnPropertyDescriptor(t, n);
                (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
                  (i = {
                    enumerable: !0,
                    get: function () {
                      return t[n];
                    },
                  }),
                  Object.defineProperty(e, r, i);
              }
            : function (e, t, n, r) {
                void 0 === r && (r = n), (e[r] = t[n]);
              }),
        i =
          (this && this.__exportStar) ||
          function (e, t) {
            for (var n in e)
              'default' === n || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n);
          };
      Object.defineProperty(t, '__esModule', { value: !0 }),
        i(n(94007), t),
        i(n(61114), t),
        i(n(73869), t),
        i(n(70576), t),
        i(n(83761), t),
        i(n(66311), t),
        i(n(12309), t),
        i(n(24822), t);
    },
    61114: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.simulateBundlerOperations =
          t.simulateBundlerOperation =
          t.handleBundlerOperations =
          t.handleBundlerOperation =
          t.getSimulatedBundlerOperation =
          t.simulateRequiredTokenAmounts =
          t.populateBundle =
          t.finalizeBundle =
          t.populateSubBundle =
          t.populateInputTransfer =
          t.DEFAULT_SUPPLY_TARGET_UTILIZATION =
            void 0);
      let r = n(40252),
        i = n(35047),
        a = n(51196),
        s = n(52707),
        o = n(73869);
      (t.DEFAULT_SUPPLY_TARGET_UTILIZATION = 0xc8f34b481ba8000n),
        (t.populateInputTransfer = (
          { address: e, args: { amount: t, from: n } },
          i,
          { hasSimplePermit: a = !1 } = {}
        ) => {
          let {
            bundler3: { generalAdapter1: s },
            permit2: o,
          } = (0, r.getChainAddresses)(i.chainId);
          if (e === r.NATIVE_ADDRESS)
            return [
              {
                type: 'Erc20_Transfer',
                sender: n,
                address: e,
                args: { amount: t, from: n, to: s },
              },
            ];
          let {
            erc20Allowances: l,
            permit2BundlerAllowance: u,
            erc2612Nonce: c,
          } = i.getHolding(n, e);
          if (l['bundler3.generalAdapter1'] >= t)
            return [
              {
                type: 'Erc20_Transfer',
                sender: s,
                address: e,
                args: { amount: t, from: n, to: s },
              },
            ];
          let d = [],
            p = null != c && (null != i.tryGetVault(e) || a),
            h =
              null == o ||
              !!r.permissionedWrapperTokens[i.chainId]?.has(e) ||
              !!r.permissionedBackedTokens[i.chainId]?.has(e);
          return (
            p
              ? d.push({
                  type: 'Erc20_Permit',
                  sender: n,
                  address: e,
                  args: { amount: t, spender: s, nonce: c },
                })
              : h &&
                d.push({
                  type: 'Erc20_Approve',
                  sender: n,
                  address: e,
                  args: { amount: t, spender: s },
                }),
            p || h
              ? d.push({
                  type: 'Erc20_Transfer',
                  sender: s,
                  address: e,
                  args: { amount: t, from: n, to: s },
                })
              : (l.permit2 < t &&
                  d.push({
                    type: 'Erc20_Approve',
                    sender: n,
                    address: e,
                    args: { amount: r.MathLib.MAX_UINT_160, spender: o },
                  }),
                (u.amount < t || u.expiration < i.block.timestamp) &&
                  d.push({
                    type: 'Erc20_Permit2',
                    sender: n,
                    address: e,
                    args: { amount: t, expiration: r.MathLib.MAX_UINT_48, nonce: u.nonce },
                  }),
                d.push({
                  type: 'Erc20_Transfer2',
                  sender: s,
                  address: e,
                  args: { amount: t, from: n, to: s },
                })),
            d
          );
        }),
        (t.populateSubBundle = (e, n, o = {}) => {
          let { sender: l } = e,
            {
              morpho: u,
              bundler3: { bundler3: c, generalAdapter1: d },
            } = (0, r.getChainAddresses)(n.chainId),
            {
              withSimplePermit: p = new Set(),
              publicAllocatorOptions: h,
              getRequirementOperations: y,
            } = o,
            f = [],
            m = 'Erc20_Wrap' === e.type ? n.getWrappedToken(e.address) : void 0,
            g = !!m && !!r.erc20WrapperTokens[n.chainId]?.has(m.address),
            b = (0, a.produceImmutable)(e, (e) => {
              switch (((e.sender = d), e.type)) {
                case 'Erc20_Wrap':
                  if (g) {
                    e.args.owner = l;
                    break;
                  }
                case 'MetaMorpho_Deposit':
                case 'MetaMorpho_Withdraw':
                  e.args.owner === l && (e.args.owner = d);
              }
              switch (e.type) {
                case 'Blue_Borrow':
                case 'Blue_Withdraw':
                case 'Blue_WithdrawCollateral':
                  e.args.onBehalf = l;
                case 'MetaMorpho_Withdraw':
                  e.args.receiver === l && (e.args.receiver = d);
              }
            });
          if (
            (('Blue_Borrow' !== b.type &&
              'Blue_Withdraw' !== b.type &&
              'Blue_WithdrawCollateral' !== b.type) ||
              n.getUser(l).isBundlerAuthorized ||
              f.push({
                type: 'Blue_SetAuthorization',
                sender: c,
                address: u,
                args: { owner: l, isAuthorized: !0, authorized: d },
              }),
            h?.enabled && ('Blue_Borrow' === b.type || 'Blue_Withdraw' === b.type))
          ) {
            let e = n.getMarket(b.args.id).accrueInterest(n.block.timestamp),
              a =
                'Blue_Borrow' === b.type ? (b.args.assets ?? e.toBorrowAssets(b.args.shares)) : 0n,
              s =
                'Blue_Withdraw' === b.type
                  ? (b.args.assets ?? e.toSupplyAssets(b.args.shares))
                  : 0n,
              o = e.totalSupplyAssets - s,
              u = e.totalBorrowAssets + a,
              d = {},
              p =
                h.supplyTargetUtilization?.[e.params.id] ??
                h.defaultSupplyTargetUtilization ??
                t.DEFAULT_SUPPLY_TARGET_UTILIZATION;
            if (r.MarketUtils.getUtilization({ totalSupplyAssets: o, totalBorrowAssets: u }) > p) {
              let t = 0n === p ? r.MathLib.MAX_UINT_160 : r.MathLib.wDivDown(u, p) - o,
                { withdrawals: y, data: m } = n.getMarketPublicReallocations(e.id, h),
                g = m.getMarket(e.id);
              for (let { vault: n, ...i } of (g.totalBorrowAssets + a > g.totalSupplyAssets - s &&
                ((t = u - o),
                y.push(
                  ...m.getMarketPublicReallocations(e.id, {
                    ...h,
                    defaultMaxWithdrawalUtilization: r.MathLib.WAD,
                    maxWithdrawalUtilization: {},
                  }).withdrawals
                )),
              y)) {
                let e = (d[n] ??= []),
                  a = e.find((e) => e.id === i.id),
                  s = r.MathLib.min(i.assets, t);
                if ((null != a ? (a.assets += s) : e.push({ ...i, assets: s }), 0n === (t -= s)))
                  break;
              }
              let b = (0, i.keys)(d).reduce(
                (e, t) => e + n.getVault(t).publicAllocatorConfig.fee,
                0n
              );
              b > 0n &&
                f.push({
                  type: 'Erc20_Transfer',
                  sender: l,
                  address: r.NATIVE_ADDRESS,
                  args: { amount: b, from: l, to: c },
                });
            }
            f.push(
              ...Object.entries(d).map(([t, n]) => ({
                type: 'MetaMorpho_PublicReallocate',
                sender: c,
                address: t,
                args: {
                  withdrawals: n.sort(({ id: e }, { id: t }) => (e > t ? 1 : -1)),
                  supplyMarketId: e.id,
                },
              }))
            );
          }
          let w = (0, i.getValue)(b.args, 'callback'),
            v = {
              ...b,
              args: {
                ...b.args,
                ...(w && {
                  callback: (e) => {
                    let n = w.flatMap((n) => {
                      let r = (0, t.populateSubBundle)(n, e, o);
                      return (0, t.handleBundlerOperations)(r, e), r;
                    });
                    return (b.args.callback = n), [];
                  },
                }),
              },
            },
            T = (0, t.simulateRequiredTokenAmounts)(f.concat([v]), n),
            A = f.concat([b]);
          if (
            ('amount' in b.args && b.args.amount === s.maxUint256) ||
            ('assets' in b.args && b.args.assets === s.maxUint256) ||
            ('shares' in b.args && b.args.shares === s.maxUint256)
          )
            return 'MetaMorpho_Withdraw' === b.type && (b.args.owner = d), A;
          let E = y?.(T) ?? [];
          return (
            (T = (0, t.simulateRequiredTokenAmounts)(
              E.concat(A).map((e) => (0, t.getSimulatedBundlerOperation)(e)),
              n
            )).forEach(({ token: e, required: r }) => {
              E.push(
                ...(0, t.populateInputTransfer)(
                  {
                    type: 'Erc20_Transfer',
                    sender: d,
                    address: e,
                    args: { amount: r, from: l, to: d },
                  },
                  n,
                  { hasSimplePermit: p.has(e) }
                )
              );
            }),
            E.concat(A)
          );
        }),
        (t.finalizeBundle = (e, n, a, o = new Set(), l = r.DEFAULT_SLIPPAGE_TOLERANCE) => {
          if (0 === e.length) return e;
          let {
            bundler3: { bundler3: u, generalAdapter1: c },
          } = (0, r.getChainAddresses)(n.chainId);
          if ((0, s.isAddressEqual)(a, u) || (0, s.isAddressEqual)(a, c))
            throw Error('receiver is bundler');
          let d = [],
            p = [],
            h = [],
            y = [],
            f = [],
            m = [];
          e.forEach((e) => {
            switch (e.type) {
              case 'Erc20_Approve': {
                let t = d.find(
                  (t) =>
                    t.address === e.address &&
                    t.sender === e.sender &&
                    t.args.spender === e.args.spender
                );
                if (null == t) return d.push(e);
                t.args.amount += e.args.amount;
                break;
              }
              case 'Erc20_Permit': {
                let t = p.find(
                  (t) =>
                    t.address === e.address &&
                    t.sender === e.sender &&
                    t.args.spender === e.args.spender
                );
                if (null == t) {
                  let t = p.findLast((t) => t.address === e.address && t.sender === e.sender);
                  t && (e.args.nonce = t.args.nonce + 1n), p.push(e);
                } else t.args.amount += e.args.amount;
                break;
              }
              case 'Erc20_Permit2': {
                let t = h.find((t) => t.address === e.address && t.sender === e.sender);
                if (null == t) {
                  let t = h.findLast((t) => t.address === e.address && t.sender === e.sender);
                  t && (e.args.nonce = t.args.nonce + 1n), h.push(e);
                } else t.args.amount += e.args.amount;
                break;
              }
              case 'Erc20_Transfer': {
                let {
                  address: t,
                  sender: i,
                  args: { amount: a, from: s, to: o },
                } = e;
                if (s !== c && o === c && !r.erc20WrapperTokens[n.chainId]?.has(t)) {
                  let r = y.find((e) => e.address === t && e.sender === i && e.args.from === s);
                  if (null == r || n.getHolding(s, t).balance < a) return y.push(e);
                  r.args.amount += a;
                  return;
                }
                m.push(e);
                break;
              }
              case 'Erc20_Transfer2': {
                let {
                  address: t,
                  sender: r,
                  args: { amount: i, from: a, to: s },
                } = e;
                if (a !== c && s === c) {
                  let s = f.find((e) => e.address === t && e.sender === r && e.args.from === a);
                  if (null == s || n.getHolding(a, t).balance < i) return f.push(e);
                  s.args.amount += i;
                  return;
                }
                m.push(e);
                break;
              }
              default:
                m.push(e);
            }
          }),
            (e = [d, p, h, y, f, m].flat(1));
          let g = (0, t.simulateBundlerOperations)(e, n);
          e.forEach((e, t) => {
            if ('MetaMorpho_Deposit' !== e.type || e.args.owner !== c) return;
            let n = e.address,
              r = g[t + 1].getHolding(c, n).balance - g[t].getHolding(c, n).balance;
            g.slice(t + 2).some((e) => e.getHolding(c, n).balance < r) || (e.args.owner = a);
          }),
            e.forEach((e, t) => {
              let r;
              switch (e.type) {
                case 'Blue_Borrow':
                case 'Blue_Withdraw':
                  r = n.getMarket(e.args.id).params.loanToken;
                  break;
                case 'Blue_WithdrawCollateral':
                  r = n.getMarket(e.args.id).params.collateralToken;
                  break;
                case 'MetaMorpho_Withdraw':
                  r = n.getVault(e.address).asset;
                  break;
                default:
                  return;
              }
              if (e.args.receiver !== c || o.has(r)) return;
              let i = g[t + 1].getHolding(c, r).balance - g[t].getHolding(c, r).balance;
              g.slice(t + 2).some((e) => e.getHolding(c, r).balance < i) || (e.args.receiver = a);
            }),
            e.forEach((t, n) => {
              if ('MetaMorpho_Withdraw' !== t.type || t.args.owner !== c) return;
              let r =
                  g[n].getHolding(c, t.address).balance - g[n + 1].getHolding(c, t.address).balance,
                i = e.findIndex(
                  (e) =>
                    'Erc20_Transfer' === e.type &&
                    e.address === t.address &&
                    e.sender === c &&
                    e.args.to === c &&
                    e.args.amount >= r
                );
              if (i <= 0) return;
              let a = e[i];
              (a.args.amount -= r), (t.args.owner = a.args.from);
            }),
            (e = e.filter((e, t) => {
              if ('Erc20_Transfer' !== e.type) return !0;
              let { amount: n, from: r, to: i } = e.args;
              if (r === c || i !== c) return !0;
              let a = e.address;
              return !!g.slice(t + 2).some((e) => e.getHolding(c, a).balance < n);
            })),
            (g = (0, t.simulateBundlerOperations)(e, n, { slippage: 0n }));
          let b = [],
            w = (0, i.getLast)(g).holdings[c] ?? {};
          o.forEach((e) => {
            (w[e]?.balance ?? 0n) <= 5n ||
              null == (0, r.getUnwrappedToken)(e, n.chainId) ||
              b.push({
                type: 'Erc20_Unwrap',
                address: e,
                sender: c,
                args: { amount: s.maxUint256, receiver: a, slippage: l },
              });
          }),
            b.length > 0 &&
              (g = (0, t.simulateBundlerOperations)(e.concat(b), n, { slippage: 0n }));
          let v = [];
          {
            let e = g[0].holdings[c] ?? {},
              t = (0, i.getLast)(g).holdings[c] ?? {};
            v.push(
              ...(0, i.entries)(t)
                .filter(([t, n]) => null != n && n.balance - (e[t]?.balance ?? 0n) > 5n)
                .map(([e]) => ({
                  type: 'Erc20_Transfer',
                  address: e,
                  sender: c,
                  args: { amount: s.maxUint256, from: c, to: a },
                }))
            );
          }
          return e.concat(b, v);
        }),
        (t.populateBundle = (e, n, r) => {
          let a = [n],
            s = n;
          return {
            operations: e.flatMap((e, n) => {
              try {
                let n = (0, t.populateSubBundle)(e, s, r);
                return a.push((s = (0, i.getLast)((0, t.simulateBundlerOperations)(n, s)))), n;
              } catch (t) {
                if (!(t instanceof Error)) throw t;
                throw new o.BundlerErrors.Bundle(t, n, e, a);
              }
            }),
            steps: a,
          };
        });
      class l extends r.Holding {
        required = 0n;
        get balance() {
          return this._balance;
        }
        set balance(e) {
          e < 0n ? ((this.required += -e), (this._balance = 0n)) : (this._balance = e);
        }
      }
      (t.simulateRequiredTokenAmounts = (e, t) => {
        let {
            bundler3: { generalAdapter1: n },
          } = (0, r.getChainAddresses)(t.chainId),
          s = (0, a.produceImmutable)(t, (e) => {
            let t = e.holdings[n];
            null != t &&
              (0, i.entries)(t).map(([e, n]) => {
                null != n && (t[e] = new l(n));
              });
          }),
          o = (0, a.simulateOperations)(e, s);
        return (0, i.entries)((0, i.getLast)(o).holdings[n] ?? {})
          .map(([e, t]) => ({ token: e, required: t.required }))
          .filter(({ required: e }) => e > 0n);
      }),
        (t.getSimulatedBundlerOperation = (e, { slippage: n } = {}) => {
          let r = (0, i.getValue)(e.args, 'callback'),
            a = {
              ...e,
              args: {
                ...e.args,
                ...(r && {
                  callback: () =>
                    r.map((e) => (0, t.getSimulatedBundlerOperation)(e, { slippage: n })),
                }),
              },
            };
          if (null != n)
            switch (a.type) {
              case 'Erc20_Wrap':
              case 'Erc20_Unwrap':
              case 'Blue_Supply':
              case 'Blue_Withdraw':
              case 'Blue_Borrow':
              case 'Blue_Repay':
              case 'MetaMorpho_Deposit':
              case 'MetaMorpho_Withdraw':
                a.args.slippage = n;
            }
          return a;
        }),
        (t.handleBundlerOperation = (e) => (n, r, i) =>
          (0, a.handleOperation)((0, t.getSimulatedBundlerOperation)(n, e), r, i)),
        (t.handleBundlerOperations = (e, n, r) =>
          (0, a.handleOperations)(e, n, (0, t.handleBundlerOperation)(r))),
        (t.simulateBundlerOperation = (e) => (n, r, i) =>
          (0, a.simulateOperation)((0, t.getSimulatedBundlerOperation)(n, e), r, i)),
        (t.simulateBundlerOperations = (e, n, r) =>
          (0, a.handleOperations)(e, n, (0, t.simulateBundlerOperation)(r)));
    },
    62912: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 });
    },
    70576: function (e, t, n) {
      'use strict';
      var r =
          (this && this.__createBinding) ||
          (Object.create
            ? function (e, t, n, r) {
                void 0 === r && (r = n);
                var i = Object.getOwnPropertyDescriptor(t, n);
                (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
                  (i = {
                    enumerable: !0,
                    get: function () {
                      return t[n];
                    },
                  }),
                  Object.defineProperty(e, r, i);
              }
            : function (e, t, n, r) {
                void 0 === r && (r = n), (e[r] = t[n]);
              }),
        i =
          (this && this.__exportStar) ||
          function (e, t) {
            for (var n in e)
              'default' === n || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n);
          };
      Object.defineProperty(t, '__esModule', { value: !0 }), i(n(62912), t), i(n(90796), t);
    },
    90796: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.isErc20InputBundlerOperation =
          t.isMetaMorphoInputBundlerOperation =
          t.isBlueInputBundlerOperation =
          t.ERC20_INPUT_OPERATIONS =
          t.METAMORPHO_INPUT_OPERATIONS =
          t.BLUE_INPUT_OPERATIONS =
          t.BUNDLER_OPERATIONS =
            void 0),
        (t.BUNDLER_OPERATIONS = [
          'Blue_SetAuthorization',
          'Blue_Borrow',
          'Blue_Repay',
          'Blue_Supply',
          'Blue_SupplyCollateral',
          'Blue_Withdraw',
          'Blue_WithdrawCollateral',
          'MetaMorpho_Deposit',
          'MetaMorpho_Withdraw',
          'MetaMorpho_PublicReallocate',
          'Erc20_Approve',
          'Erc20_Permit',
          'Erc20_Permit2',
          'Erc20_Transfer',
          'Erc20_Transfer2',
          'Erc20_Wrap',
          'Erc20_Unwrap',
        ]),
        (t.BLUE_INPUT_OPERATIONS = [
          'Blue_Borrow',
          'Blue_Repay',
          'Blue_Supply',
          'Blue_SupplyCollateral',
          'Blue_Withdraw',
          'Blue_WithdrawCollateral',
          'Blue_SetAuthorization',
        ]),
        (t.METAMORPHO_INPUT_OPERATIONS = ['MetaMorpho_Deposit', 'MetaMorpho_Withdraw']),
        (t.ERC20_INPUT_OPERATIONS = ['Erc20_Wrap', 'Erc20_Unwrap']),
        (t.isBlueInputBundlerOperation = (e) => t.BLUE_INPUT_OPERATIONS.includes(e.type)),
        (t.isMetaMorphoInputBundlerOperation = (e) =>
          t.METAMORPHO_INPUT_OPERATIONS.includes(e.type)),
        (t.isErc20InputBundlerOperation = (e) => t.ERC20_INPUT_OPERATIONS.includes(e.type));
    },
    14241: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.variableDebtTokenV2Abi =
          t.aaveV2OracleAbi =
          t.addressesProviderAbi =
          t.aTokenV2Abi =
          t.protocolDataProviderAbi =
          t.lendingPoolAbi =
            void 0),
        (t.lendingPoolAbi = [
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'reserve', type: 'address' },
              { indexed: !1, internalType: 'address', name: 'user', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'onBehalfOf', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'amount', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'borrowRateMode', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'borrowRate', type: 'uint256' },
              { indexed: !0, internalType: 'uint16', name: 'referral', type: 'uint16' },
            ],
            name: 'Borrow',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'reserve', type: 'address' },
              { indexed: !1, internalType: 'address', name: 'user', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'onBehalfOf', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'amount', type: 'uint256' },
              { indexed: !0, internalType: 'uint16', name: 'referral', type: 'uint16' },
            ],
            name: 'Deposit',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'target', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'initiator', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'asset', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'amount', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'premium', type: 'uint256' },
              { indexed: !1, internalType: 'uint16', name: 'referralCode', type: 'uint16' },
            ],
            name: 'FlashLoan',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'collateralAsset', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'debtAsset', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'user', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'debtToCover', type: 'uint256' },
              {
                indexed: !1,
                internalType: 'uint256',
                name: 'liquidatedCollateralAmount',
                type: 'uint256',
              },
              { indexed: !1, internalType: 'address', name: 'liquidator', type: 'address' },
              { indexed: !1, internalType: 'bool', name: 'receiveAToken', type: 'bool' },
            ],
            name: 'LiquidationCall',
            type: 'event',
          },
          { anonymous: !1, inputs: [], name: 'Paused', type: 'event' },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'reserve', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'user', type: 'address' },
            ],
            name: 'RebalanceStableBorrowRate',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'reserve', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'user', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'repayer', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'Repay',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'reserve', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'liquidityRate', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'stableBorrowRate', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'variableBorrowRate', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'liquidityIndex', type: 'uint256' },
              {
                indexed: !1,
                internalType: 'uint256',
                name: 'variableBorrowIndex',
                type: 'uint256',
              },
            ],
            name: 'ReserveDataUpdated',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'reserve', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'user', type: 'address' },
            ],
            name: 'ReserveUsedAsCollateralDisabled',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'reserve', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'user', type: 'address' },
            ],
            name: 'ReserveUsedAsCollateralEnabled',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'reserve', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'user', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'rateMode', type: 'uint256' },
            ],
            name: 'Swap',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'tokenRescued', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'receiver', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'amountRescued', type: 'uint256' },
            ],
            name: 'TokensRescued',
            type: 'event',
          },
          { anonymous: !1, inputs: [], name: 'Unpaused', type: 'event' },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'reserve', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'user', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'to', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'Withdraw',
            type: 'event',
          },
          {
            inputs: [],
            name: 'FLASHLOAN_PREMIUM_TOTAL',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'LENDINGPOOL_REVISION',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'MAX_NUMBER_RESERVES',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'MAX_STABLE_RATE_BORROW_SIZE_PERCENT',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'uint256', name: 'interestRateMode', type: 'uint256' },
              { internalType: 'uint16', name: 'referralCode', type: 'uint16' },
              { internalType: 'address', name: 'onBehalfOf', type: 'address' },
            ],
            name: 'borrow',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'address', name: 'onBehalfOf', type: 'address' },
              { internalType: 'uint16', name: 'referralCode', type: 'uint16' },
            ],
            name: 'deposit',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'address', name: 'from', type: 'address' },
              { internalType: 'address', name: 'to', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'uint256', name: 'balanceFromBefore', type: 'uint256' },
              { internalType: 'uint256', name: 'balanceToBefore', type: 'uint256' },
            ],
            name: 'finalizeTransfer',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'receiverAddress', type: 'address' },
              { internalType: 'address[]', name: 'assets', type: 'address[]' },
              { internalType: 'uint256[]', name: 'amounts', type: 'uint256[]' },
              { internalType: 'uint256[]', name: 'modes', type: 'uint256[]' },
              { internalType: 'address', name: 'onBehalfOf', type: 'address' },
              { internalType: 'bytes', name: 'params', type: 'bytes' },
              { internalType: 'uint16', name: 'referralCode', type: 'uint16' },
            ],
            name: 'flashLoan',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getAddressesProvider',
            outputs: [
              { internalType: 'contract ILendingPoolAddressesProvider', name: '', type: 'address' },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getConfiguration',
            outputs: [
              {
                components: [{ internalType: 'uint256', name: 'data', type: 'uint256' }],
                internalType: 'struct DataTypes.ReserveConfigurationMap',
                name: '',
                type: 'tuple',
              },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getReserveData',
            outputs: [
              {
                components: [
                  {
                    components: [{ internalType: 'uint256', name: 'data', type: 'uint256' }],
                    internalType: 'struct DataTypes.ReserveConfigurationMap',
                    name: 'configuration',
                    type: 'tuple',
                  },
                  { internalType: 'uint128', name: 'liquidityIndex', type: 'uint128' },
                  { internalType: 'uint128', name: 'variableBorrowIndex', type: 'uint128' },
                  { internalType: 'uint128', name: 'currentLiquidityRate', type: 'uint128' },
                  { internalType: 'uint128', name: 'currentVariableBorrowRate', type: 'uint128' },
                  { internalType: 'uint128', name: 'currentStableBorrowRate', type: 'uint128' },
                  { internalType: 'uint40', name: 'lastUpdateTimestamp', type: 'uint40' },
                  { internalType: 'address', name: 'aTokenAddress', type: 'address' },
                  { internalType: 'address', name: 'stableDebtTokenAddress', type: 'address' },
                  { internalType: 'address', name: 'variableDebtTokenAddress', type: 'address' },
                  { internalType: 'address', name: 'interestRateStrategyAddress', type: 'address' },
                  { internalType: 'uint8', name: 'id', type: 'uint8' },
                ],
                internalType: 'struct DataTypes.ReserveData',
                name: '',
                type: 'tuple',
              },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getReserveNormalizedIncome',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getReserveNormalizedVariableDebt',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getReservesList',
            outputs: [{ internalType: 'address[]', name: '', type: 'address[]' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'user', type: 'address' }],
            name: 'getUserAccountData',
            outputs: [
              { internalType: 'uint256', name: 'totalCollateralETH', type: 'uint256' },
              { internalType: 'uint256', name: 'totalDebtETH', type: 'uint256' },
              { internalType: 'uint256', name: 'availableBorrowsETH', type: 'uint256' },
              { internalType: 'uint256', name: 'currentLiquidationThreshold', type: 'uint256' },
              { internalType: 'uint256', name: 'ltv', type: 'uint256' },
              { internalType: 'uint256', name: 'healthFactor', type: 'uint256' },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'user', type: 'address' }],
            name: 'getUserConfiguration',
            outputs: [
              {
                components: [{ internalType: 'uint256', name: 'data', type: 'uint256' }],
                internalType: 'struct DataTypes.UserConfigurationMap',
                name: '',
                type: 'tuple',
              },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'address', name: 'aTokenAddress', type: 'address' },
              { internalType: 'address', name: 'stableDebtAddress', type: 'address' },
              { internalType: 'address', name: 'variableDebtAddress', type: 'address' },
              { internalType: 'address', name: 'interestRateStrategyAddress', type: 'address' },
            ],
            name: 'initReserve',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              {
                internalType: 'contract ILendingPoolAddressesProvider',
                name: 'provider',
                type: 'address',
              },
            ],
            name: 'initialize',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'collateralAsset', type: 'address' },
              { internalType: 'address', name: 'debtAsset', type: 'address' },
              { internalType: 'address', name: 'user', type: 'address' },
              { internalType: 'uint256', name: 'debtToCover', type: 'uint256' },
              { internalType: 'bool', name: 'receiveAToken', type: 'bool' },
            ],
            name: 'liquidationCall',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [],
            name: 'paused',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'address', name: 'user', type: 'address' },
            ],
            name: 'rebalanceStableBorrowRate',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'uint256', name: 'rateMode', type: 'uint256' },
              { internalType: 'address', name: 'onBehalfOf', type: 'address' },
            ],
            name: 'repay',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'token', type: 'address' },
              { internalType: 'address', name: 'to', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'rescueTokens',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'uint256', name: 'configuration', type: 'uint256' },
            ],
            name: 'setConfiguration',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'bool', name: 'val', type: 'bool' }],
            name: 'setPause',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'address', name: 'rateStrategyAddress', type: 'address' },
            ],
            name: 'setReserveInterestRateStrategyAddress',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'bool', name: 'useAsCollateral', type: 'bool' },
            ],
            name: 'setUserUseReserveAsCollateral',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'uint256', name: 'rateMode', type: 'uint256' },
            ],
            name: 'swapBorrowRateMode',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'address', name: 'user', type: 'address' },
            ],
            name: 'swapToVariable',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'address', name: 'to', type: 'address' },
            ],
            name: 'withdraw',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
        ]),
        (t.protocolDataProviderAbi = [
          {
            inputs: [
              {
                internalType: 'contract ILendingPoolAddressesProvider',
                name: 'addressesProvider',
                type: 'address',
              },
            ],
            stateMutability: 'nonpayable',
            type: 'constructor',
          },
          {
            inputs: [],
            name: 'ADDRESSES_PROVIDER',
            outputs: [
              { internalType: 'contract ILendingPoolAddressesProvider', name: '', type: 'address' },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getAllATokens',
            outputs: [
              {
                components: [
                  { internalType: 'string', name: 'symbol', type: 'string' },
                  { internalType: 'address', name: 'tokenAddress', type: 'address' },
                ],
                internalType: 'struct AaveProtocolDataProvider.TokenData[]',
                name: '',
                type: 'tuple[]',
              },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getAllReservesTokens',
            outputs: [
              {
                components: [
                  { internalType: 'string', name: 'symbol', type: 'string' },
                  { internalType: 'address', name: 'tokenAddress', type: 'address' },
                ],
                internalType: 'struct AaveProtocolDataProvider.TokenData[]',
                name: '',
                type: 'tuple[]',
              },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getReserveConfigurationData',
            outputs: [
              { internalType: 'uint256', name: 'decimals', type: 'uint256' },
              { internalType: 'uint256', name: 'ltv', type: 'uint256' },
              { internalType: 'uint256', name: 'liquidationThreshold', type: 'uint256' },
              { internalType: 'uint256', name: 'liquidationBonus', type: 'uint256' },
              { internalType: 'uint256', name: 'reserveFactor', type: 'uint256' },
              { internalType: 'bool', name: 'usageAsCollateralEnabled', type: 'bool' },
              { internalType: 'bool', name: 'borrowingEnabled', type: 'bool' },
              { internalType: 'bool', name: 'stableBorrowRateEnabled', type: 'bool' },
              { internalType: 'bool', name: 'isActive', type: 'bool' },
              { internalType: 'bool', name: 'isFrozen', type: 'bool' },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getReserveData',
            outputs: [
              { internalType: 'uint256', name: 'availableLiquidity', type: 'uint256' },
              { internalType: 'uint256', name: 'totalStableDebt', type: 'uint256' },
              { internalType: 'uint256', name: 'totalVariableDebt', type: 'uint256' },
              { internalType: 'uint256', name: 'liquidityRate', type: 'uint256' },
              { internalType: 'uint256', name: 'variableBorrowRate', type: 'uint256' },
              { internalType: 'uint256', name: 'stableBorrowRate', type: 'uint256' },
              { internalType: 'uint256', name: 'averageStableBorrowRate', type: 'uint256' },
              { internalType: 'uint256', name: 'liquidityIndex', type: 'uint256' },
              { internalType: 'uint256', name: 'variableBorrowIndex', type: 'uint256' },
              { internalType: 'uint40', name: 'lastUpdateTimestamp', type: 'uint40' },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getReserveTokensAddresses',
            outputs: [
              { internalType: 'address', name: 'aTokenAddress', type: 'address' },
              { internalType: 'address', name: 'stableDebtTokenAddress', type: 'address' },
              { internalType: 'address', name: 'variableDebtTokenAddress', type: 'address' },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'address', name: 'user', type: 'address' },
            ],
            name: 'getUserReserveData',
            outputs: [
              { internalType: 'uint256', name: 'currentATokenBalance', type: 'uint256' },
              { internalType: 'uint256', name: 'currentStableDebt', type: 'uint256' },
              { internalType: 'uint256', name: 'currentVariableDebt', type: 'uint256' },
              { internalType: 'uint256', name: 'principalStableDebt', type: 'uint256' },
              { internalType: 'uint256', name: 'scaledVariableDebt', type: 'uint256' },
              { internalType: 'uint256', name: 'stableBorrowRate', type: 'uint256' },
              { internalType: 'uint256', name: 'liquidityRate', type: 'uint256' },
              { internalType: 'uint40', name: 'stableRateLastUpdated', type: 'uint40' },
              { internalType: 'bool', name: 'usageAsCollateralEnabled', type: 'bool' },
            ],
            stateMutability: 'view',
            type: 'function',
          },
        ]),
        (t.aTokenV2Abi = [
          {
            inputs: [
              { internalType: 'contract ILendingPool', name: 'pool', type: 'address' },
              { internalType: 'address', name: 'underlyingAssetAddress', type: 'address' },
              { internalType: 'address', name: 'reserveTreasuryAddress', type: 'address' },
              { internalType: 'string', name: 'tokenName', type: 'string' },
              { internalType: 'string', name: 'tokenSymbol', type: 'string' },
              { internalType: 'address', name: 'incentivesController', type: 'address' },
            ],
            stateMutability: 'nonpayable',
            type: 'constructor',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'owner', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'spender', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'value', type: 'uint256' },
            ],
            name: 'Approval',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'from', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'to', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'value', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'index', type: 'uint256' },
            ],
            name: 'BalanceTransfer',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'from', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'target', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'value', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'index', type: 'uint256' },
            ],
            name: 'Burn',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'underlyingAsset', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'pool', type: 'address' },
              { indexed: !1, internalType: 'address', name: 'treasury', type: 'address' },
              {
                indexed: !1,
                internalType: 'address',
                name: 'incentivesController',
                type: 'address',
              },
              { indexed: !1, internalType: 'uint8', name: 'aTokenDecimals', type: 'uint8' },
              { indexed: !1, internalType: 'string', name: 'aTokenName', type: 'string' },
              { indexed: !1, internalType: 'string', name: 'aTokenSymbol', type: 'string' },
              { indexed: !1, internalType: 'bytes', name: 'params', type: 'bytes' },
            ],
            name: 'Initialized',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'from', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'value', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'index', type: 'uint256' },
            ],
            name: 'Mint',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'from', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'to', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'value', type: 'uint256' },
            ],
            name: 'Transfer',
            type: 'event',
          },
          {
            inputs: [],
            name: 'ATOKEN_REVISION',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'DOMAIN_SEPARATOR',
            outputs: [{ internalType: 'bytes32', name: '', type: 'bytes32' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'EIP712_REVISION',
            outputs: [{ internalType: 'bytes', name: '', type: 'bytes' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'PERMIT_TYPEHASH',
            outputs: [{ internalType: 'bytes32', name: '', type: 'bytes32' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'POOL',
            outputs: [{ internalType: 'contract ILendingPool', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'RESERVE_TREASURY_ADDRESS',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'UINT_MAX_VALUE',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'UNDERLYING_ASSET_ADDRESS',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: '', type: 'address' }],
            name: '_nonces',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'owner', type: 'address' },
              { internalType: 'address', name: 'spender', type: 'address' },
            ],
            name: 'allowance',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'spender', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'approve',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'user', type: 'address' }],
            name: 'balanceOf',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'user', type: 'address' },
              { internalType: 'address', name: 'receiverOfUnderlying', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'uint256', name: 'index', type: 'uint256' },
            ],
            name: 'burn',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [],
            name: 'decimals',
            outputs: [{ internalType: 'uint8', name: '', type: 'uint8' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'spender', type: 'address' },
              { internalType: 'uint256', name: 'subtractedValue', type: 'uint256' },
            ],
            name: 'decreaseAllowance',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getIncentivesController',
            outputs: [
              { internalType: 'contract IAaveIncentivesController', name: '', type: 'address' },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'user', type: 'address' }],
            name: 'getScaledUserBalanceAndSupply',
            outputs: [
              { internalType: 'uint256', name: '', type: 'uint256' },
              { internalType: 'uint256', name: '', type: 'uint256' },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'spender', type: 'address' },
              { internalType: 'uint256', name: 'addedValue', type: 'uint256' },
            ],
            name: 'increaseAllowance',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'uint8', name: 'underlyingAssetDecimals', type: 'uint8' },
              { internalType: 'string', name: 'tokenName', type: 'string' },
              { internalType: 'string', name: 'tokenSymbol', type: 'string' },
            ],
            name: 'initialize',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'user', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'uint256', name: 'index', type: 'uint256' },
            ],
            name: 'mint',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'uint256', name: 'index', type: 'uint256' },
            ],
            name: 'mintToTreasury',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [],
            name: 'name',
            outputs: [{ internalType: 'string', name: '', type: 'string' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'owner', type: 'address' },
              { internalType: 'address', name: 'spender', type: 'address' },
              { internalType: 'uint256', name: 'value', type: 'uint256' },
              { internalType: 'uint256', name: 'deadline', type: 'uint256' },
              { internalType: 'uint8', name: 'v', type: 'uint8' },
              { internalType: 'bytes32', name: 'r', type: 'bytes32' },
              { internalType: 'bytes32', name: 's', type: 'bytes32' },
            ],
            name: 'permit',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'user', type: 'address' }],
            name: 'scaledBalanceOf',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'scaledTotalSupply',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'symbol',
            outputs: [{ internalType: 'string', name: '', type: 'string' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'totalSupply',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'recipient', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'transfer',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'sender', type: 'address' },
              { internalType: 'address', name: 'recipient', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'transferFrom',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'from', type: 'address' },
              { internalType: 'address', name: 'to', type: 'address' },
              { internalType: 'uint256', name: 'value', type: 'uint256' },
            ],
            name: 'transferOnLiquidation',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'target', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'transferUnderlyingTo',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
        ]),
        (t.addressesProviderAbi = [
          {
            inputs: [{ internalType: 'string', name: 'marketId', type: 'string' }],
            stateMutability: 'nonpayable',
            type: 'constructor',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, internalType: 'bytes32', name: 'id', type: 'bytes32' },
              { indexed: !0, internalType: 'address', name: 'newAddress', type: 'address' },
              { indexed: !1, internalType: 'bool', name: 'hasProxy', type: 'bool' },
            ],
            name: 'AddressSet',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [{ indexed: !0, internalType: 'address', name: 'newAddress', type: 'address' }],
            name: 'ConfigurationAdminUpdated',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [{ indexed: !0, internalType: 'address', name: 'newAddress', type: 'address' }],
            name: 'EmergencyAdminUpdated',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [{ indexed: !0, internalType: 'address', name: 'newAddress', type: 'address' }],
            name: 'LendingPoolCollateralManagerUpdated',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [{ indexed: !0, internalType: 'address', name: 'newAddress', type: 'address' }],
            name: 'LendingPoolConfiguratorUpdated',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [{ indexed: !0, internalType: 'address', name: 'newAddress', type: 'address' }],
            name: 'LendingPoolUpdated',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [{ indexed: !0, internalType: 'address', name: 'newAddress', type: 'address' }],
            name: 'LendingRateOracleUpdated',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [{ indexed: !1, internalType: 'string', name: 'newMarketId', type: 'string' }],
            name: 'MarketIdSet',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'previousOwner', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'newOwner', type: 'address' },
            ],
            name: 'OwnershipTransferred',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [{ indexed: !0, internalType: 'address', name: 'newAddress', type: 'address' }],
            name: 'PriceOracleUpdated',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, internalType: 'bytes32', name: 'id', type: 'bytes32' },
              { indexed: !0, internalType: 'address', name: 'newAddress', type: 'address' },
            ],
            name: 'ProxyCreated',
            type: 'event',
          },
          {
            inputs: [{ internalType: 'bytes32', name: 'id', type: 'bytes32' }],
            name: 'getAddress',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getEmergencyAdmin',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getLendingPool',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getLendingPoolCollateralManager',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getLendingPoolConfigurator',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getLendingRateOracle',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getMarketId',
            outputs: [{ internalType: 'string', name: '', type: 'string' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getPoolAdmin',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getPriceOracle',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'owner',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'renounceOwnership',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'bytes32', name: 'id', type: 'bytes32' },
              { internalType: 'address', name: 'newAddress', type: 'address' },
            ],
            name: 'setAddress',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'bytes32', name: 'id', type: 'bytes32' },
              { internalType: 'address', name: 'implementationAddress', type: 'address' },
            ],
            name: 'setAddressAsProxy',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'emergencyAdmin', type: 'address' }],
            name: 'setEmergencyAdmin',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'manager', type: 'address' }],
            name: 'setLendingPoolCollateralManager',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'configurator', type: 'address' }],
            name: 'setLendingPoolConfiguratorImpl',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'pool', type: 'address' }],
            name: 'setLendingPoolImpl',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'lendingRateOracle', type: 'address' }],
            name: 'setLendingRateOracle',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'string', name: 'marketId', type: 'string' }],
            name: 'setMarketId',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'admin', type: 'address' }],
            name: 'setPoolAdmin',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'priceOracle', type: 'address' }],
            name: 'setPriceOracle',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'newOwner', type: 'address' }],
            name: 'transferOwnership',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
        ]),
        (t.aaveV2OracleAbi = [
          {
            inputs: [
              { internalType: 'address[]', name: 'assets', type: 'address[]' },
              { internalType: 'address[]', name: 'sources', type: 'address[]' },
              { internalType: 'address', name: 'fallbackOracle', type: 'address' },
              { internalType: 'address', name: 'weth', type: 'address' },
            ],
            stateMutability: 'nonpayable',
            type: 'constructor',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'asset', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'source', type: 'address' },
            ],
            name: 'AssetSourceUpdated',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'fallbackOracle', type: 'address' },
            ],
            name: 'FallbackOracleUpdated',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'previousOwner', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'newOwner', type: 'address' },
            ],
            name: 'OwnershipTransferred',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [{ indexed: !0, internalType: 'address', name: 'weth', type: 'address' }],
            name: 'WethSet',
            type: 'event',
          },
          {
            inputs: [],
            name: 'WETH',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getAssetPrice',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address[]', name: 'assets', type: 'address[]' }],
            name: 'getAssetsPrices',
            outputs: [{ internalType: 'uint256[]', name: '', type: 'uint256[]' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getFallbackOracle',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getSourceOfAsset',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'owner',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'renounceOwnership',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address[]', name: 'assets', type: 'address[]' },
              { internalType: 'address[]', name: 'sources', type: 'address[]' },
            ],
            name: 'setAssetSources',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'fallbackOracle', type: 'address' }],
            name: 'setFallbackOracle',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'newOwner', type: 'address' }],
            name: 'transferOwnership',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
        ]),
        (t.variableDebtTokenV2Abi = [
          {
            inputs: [
              { internalType: 'address', name: 'pool', type: 'address' },
              { internalType: 'address', name: 'underlyingAsset', type: 'address' },
              { internalType: 'string', name: 'name', type: 'string' },
              { internalType: 'string', name: 'symbol', type: 'string' },
              { internalType: 'address', name: 'incentivesController', type: 'address' },
            ],
            stateMutability: 'nonpayable',
            type: 'constructor',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'owner', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'spender', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'value', type: 'uint256' },
            ],
            name: 'Approval',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'fromUser', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'toUser', type: 'address' },
              { indexed: !1, internalType: 'address', name: 'asset', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'BorrowAllowanceDelegated',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'user', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'amount', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'index', type: 'uint256' },
            ],
            name: 'Burn',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'underlyingAsset', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'pool', type: 'address' },
              {
                indexed: !1,
                internalType: 'address',
                name: 'incentivesController',
                type: 'address',
              },
              { indexed: !1, internalType: 'uint8', name: 'debtTokenDecimals', type: 'uint8' },
              { indexed: !1, internalType: 'string', name: 'debtTokenName', type: 'string' },
              { indexed: !1, internalType: 'string', name: 'debtTokenSymbol', type: 'string' },
              { indexed: !1, internalType: 'bytes', name: 'params', type: 'bytes' },
            ],
            name: 'Initialized',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'from', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'onBehalfOf', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'value', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'index', type: 'uint256' },
            ],
            name: 'Mint',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'from', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'to', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'value', type: 'uint256' },
            ],
            name: 'Transfer',
            type: 'event',
          },
          {
            inputs: [],
            name: 'DEBT_TOKEN_REVISION',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'POOL',
            outputs: [{ internalType: 'contract ILendingPool', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'UNDERLYING_ASSET_ADDRESS',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'owner', type: 'address' },
              { internalType: 'address', name: 'spender', type: 'address' },
            ],
            name: 'allowance',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'spender', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'approve',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'delegatee', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'approveDelegation',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'user', type: 'address' }],
            name: 'balanceOf',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'fromUser', type: 'address' },
              { internalType: 'address', name: 'toUser', type: 'address' },
            ],
            name: 'borrowAllowance',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'user', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'uint256', name: 'index', type: 'uint256' },
            ],
            name: 'burn',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [],
            name: 'decimals',
            outputs: [{ internalType: 'uint8', name: '', type: 'uint8' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'spender', type: 'address' },
              { internalType: 'uint256', name: 'subtractedValue', type: 'uint256' },
            ],
            name: 'decreaseAllowance',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getIncentivesController',
            outputs: [
              { internalType: 'contract IAaveIncentivesController', name: '', type: 'address' },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'user', type: 'address' }],
            name: 'getScaledUserBalanceAndSupply',
            outputs: [
              { internalType: 'uint256', name: '', type: 'uint256' },
              { internalType: 'uint256', name: '', type: 'uint256' },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'spender', type: 'address' },
              { internalType: 'uint256', name: 'addedValue', type: 'uint256' },
            ],
            name: 'increaseAllowance',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'uint8', name: 'decimals', type: 'uint8' },
              { internalType: 'string', name: 'name', type: 'string' },
              { internalType: 'string', name: 'symbol', type: 'string' },
            ],
            name: 'initialize',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'user', type: 'address' },
              { internalType: 'address', name: 'onBehalfOf', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'uint256', name: 'index', type: 'uint256' },
            ],
            name: 'mint',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [],
            name: 'name',
            outputs: [{ internalType: 'string', name: '', type: 'string' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'user', type: 'address' }],
            name: 'scaledBalanceOf',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'scaledTotalSupply',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'symbol',
            outputs: [{ internalType: 'string', name: '', type: 'string' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'totalSupply',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'recipient', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'transfer',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'sender', type: 'address' },
              { internalType: 'address', name: 'recipient', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'transferFrom',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
        ]);
    },
    27256: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.addressesProviderAbi =
          t.aaveV3OracleAbi =
          t.variableDebtTokenV3Abi =
          t.aTokenV3Abi =
          t.protocolDataProviderAbi =
          t.poolAbi =
            void 0),
        (t.poolAbi = [
          {
            inputs: [
              {
                internalType: 'contract IPoolAddressesProvider',
                name: 'provider',
                type: 'address',
              },
            ],
            stateMutability: 'nonpayable',
            type: 'constructor',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'reserve', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'backer', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'amount', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'fee', type: 'uint256' },
            ],
            name: 'BackUnbacked',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'reserve', type: 'address' },
              { indexed: !1, internalType: 'address', name: 'user', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'onBehalfOf', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'amount', type: 'uint256' },
              {
                indexed: !1,
                internalType: 'enum DataTypes.InterestRateMode',
                name: 'interestRateMode',
                type: 'uint8',
              },
              { indexed: !1, internalType: 'uint256', name: 'borrowRate', type: 'uint256' },
              { indexed: !0, internalType: 'uint16', name: 'referralCode', type: 'uint16' },
            ],
            name: 'Borrow',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'target', type: 'address' },
              { indexed: !1, internalType: 'address', name: 'initiator', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'asset', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'amount', type: 'uint256' },
              {
                indexed: !1,
                internalType: 'enum DataTypes.InterestRateMode',
                name: 'interestRateMode',
                type: 'uint8',
              },
              { indexed: !1, internalType: 'uint256', name: 'premium', type: 'uint256' },
              { indexed: !0, internalType: 'uint16', name: 'referralCode', type: 'uint16' },
            ],
            name: 'FlashLoan',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'asset', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'totalDebt', type: 'uint256' },
            ],
            name: 'IsolationModeTotalDebtUpdated',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'collateralAsset', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'debtAsset', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'user', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'debtToCover', type: 'uint256' },
              {
                indexed: !1,
                internalType: 'uint256',
                name: 'liquidatedCollateralAmount',
                type: 'uint256',
              },
              { indexed: !1, internalType: 'address', name: 'liquidator', type: 'address' },
              { indexed: !1, internalType: 'bool', name: 'receiveAToken', type: 'bool' },
            ],
            name: 'LiquidationCall',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'reserve', type: 'address' },
              { indexed: !1, internalType: 'address', name: 'user', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'onBehalfOf', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'amount', type: 'uint256' },
              { indexed: !0, internalType: 'uint16', name: 'referralCode', type: 'uint16' },
            ],
            name: 'MintUnbacked',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'reserve', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'amountMinted', type: 'uint256' },
            ],
            name: 'MintedToTreasury',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'reserve', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'user', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'repayer', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'amount', type: 'uint256' },
              { indexed: !1, internalType: 'bool', name: 'useATokens', type: 'bool' },
            ],
            name: 'Repay',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'reserve', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'liquidityRate', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'stableBorrowRate', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'variableBorrowRate', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'liquidityIndex', type: 'uint256' },
              {
                indexed: !1,
                internalType: 'uint256',
                name: 'variableBorrowIndex',
                type: 'uint256',
              },
            ],
            name: 'ReserveDataUpdated',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'reserve', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'liquidityRate', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'stableBorrowRate', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'variableBorrowRate', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'liquidityIndex', type: 'uint256' },
              {
                indexed: !1,
                internalType: 'uint256',
                name: 'variableBorrowIndex',
                type: 'uint256',
              },
            ],
            name: 'ReserveDataUpdated',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'reserve', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'user', type: 'address' },
            ],
            name: 'ReserveUsedAsCollateralDisabled',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'reserve', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'user', type: 'address' },
            ],
            name: 'ReserveUsedAsCollateralEnabled',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'reserve', type: 'address' },
              { indexed: !1, internalType: 'address', name: 'user', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'onBehalfOf', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'amount', type: 'uint256' },
              { indexed: !0, internalType: 'uint16', name: 'referralCode', type: 'uint16' },
            ],
            name: 'Supply',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'user', type: 'address' },
              { indexed: !1, internalType: 'uint8', name: 'categoryId', type: 'uint8' },
            ],
            name: 'UserEModeSet',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'reserve', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'user', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'to', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'Withdraw',
            type: 'event',
          },
          {
            inputs: [],
            name: 'ADDRESSES_PROVIDER',
            outputs: [
              { internalType: 'contract IPoolAddressesProvider', name: '', type: 'address' },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'BRIDGE_PROTOCOL_FEE',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'FLASHLOAN_PREMIUM_TOTAL',
            outputs: [{ internalType: 'uint128', name: '', type: 'uint128' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'FLASHLOAN_PREMIUM_TO_PROTOCOL',
            outputs: [{ internalType: 'uint128', name: '', type: 'uint128' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'MAX_NUMBER_RESERVES',
            outputs: [{ internalType: 'uint16', name: '', type: 'uint16' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'POOL_REVISION',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'uint256', name: 'fee', type: 'uint256' },
            ],
            name: 'backUnbacked',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'uint256', name: 'interestRateMode', type: 'uint256' },
              { internalType: 'uint16', name: 'referralCode', type: 'uint16' },
              { internalType: 'address', name: 'onBehalfOf', type: 'address' },
            ],
            name: 'borrow',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'uint8', name: 'id', type: 'uint8' },
              {
                components: [
                  { internalType: 'uint16', name: 'ltv', type: 'uint16' },
                  { internalType: 'uint16', name: 'liquidationThreshold', type: 'uint16' },
                  { internalType: 'uint16', name: 'liquidationBonus', type: 'uint16' },
                  { internalType: 'string', name: 'label', type: 'string' },
                ],
                internalType: 'struct DataTypes.EModeCategoryBaseConfiguration',
                name: 'category',
                type: 'tuple',
              },
            ],
            name: 'configureEModeCategory',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'uint8', name: 'id', type: 'uint8' },
              { internalType: 'uint128', name: 'borrowableBitmap', type: 'uint128' },
            ],
            name: 'configureEModeCategoryBorrowableBitmap',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'uint8', name: 'id', type: 'uint8' },
              { internalType: 'uint128', name: 'collateralBitmap', type: 'uint128' },
            ],
            name: 'configureEModeCategoryCollateralBitmap',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'address', name: 'onBehalfOf', type: 'address' },
              { internalType: 'uint16', name: 'referralCode', type: 'uint16' },
            ],
            name: 'deposit',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'dropReserve',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'address', name: 'from', type: 'address' },
              { internalType: 'address', name: 'to', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'uint256', name: 'balanceFromBefore', type: 'uint256' },
              { internalType: 'uint256', name: 'balanceToBefore', type: 'uint256' },
            ],
            name: 'finalizeTransfer',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'receiverAddress', type: 'address' },
              { internalType: 'address[]', name: 'assets', type: 'address[]' },
              { internalType: 'uint256[]', name: 'amounts', type: 'uint256[]' },
              { internalType: 'uint256[]', name: 'interestRateModes', type: 'uint256[]' },
              { internalType: 'address', name: 'onBehalfOf', type: 'address' },
              { internalType: 'bytes', name: 'params', type: 'bytes' },
              { internalType: 'uint16', name: 'referralCode', type: 'uint16' },
            ],
            name: 'flashLoan',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'receiverAddress', type: 'address' },
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'bytes', name: 'params', type: 'bytes' },
              { internalType: 'uint16', name: 'referralCode', type: 'uint16' },
            ],
            name: 'flashLoanSimple',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getBorrowLogic',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'pure',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getBridgeLogic',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'pure',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getConfiguration',
            outputs: [
              {
                components: [{ internalType: 'uint256', name: 'data', type: 'uint256' }],
                internalType: 'struct DataTypes.ReserveConfigurationMap',
                name: '',
                type: 'tuple',
              },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'uint8', name: 'id', type: 'uint8' }],
            name: 'getEModeCategoryBorrowableBitmap',
            outputs: [{ internalType: 'uint128', name: '', type: 'uint128' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'uint8', name: 'id', type: 'uint8' }],
            name: 'getEModeCategoryCollateralBitmap',
            outputs: [{ internalType: 'uint128', name: '', type: 'uint128' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'uint8', name: 'id', type: 'uint8' }],
            name: 'getEModeCategoryCollateralConfig',
            outputs: [
              {
                components: [
                  { internalType: 'uint16', name: 'ltv', type: 'uint16' },
                  { internalType: 'uint16', name: 'liquidationThreshold', type: 'uint16' },
                  { internalType: 'uint16', name: 'liquidationBonus', type: 'uint16' },
                ],
                internalType: 'struct DataTypes.CollateralConfig',
                name: '',
                type: 'tuple',
              },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'uint8', name: 'id', type: 'uint8' }],
            name: 'getEModeCategoryData',
            outputs: [
              {
                components: [
                  { internalType: 'uint16', name: 'ltv', type: 'uint16' },
                  { internalType: 'uint16', name: 'liquidationThreshold', type: 'uint16' },
                  { internalType: 'uint16', name: 'liquidationBonus', type: 'uint16' },
                  { internalType: 'address', name: 'priceSource', type: 'address' },
                  { internalType: 'string', name: 'label', type: 'string' },
                ],
                internalType: 'struct DataTypes.EModeCategoryLegacy',
                name: '',
                type: 'tuple',
              },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'uint8', name: 'id', type: 'uint8' }],
            name: 'getEModeCategoryLabel',
            outputs: [{ internalType: 'string', name: '', type: 'string' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getEModeLogic',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'pure',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getFlashLoanLogic',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'pure',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getLiquidationGracePeriod',
            outputs: [{ internalType: 'uint40', name: '', type: 'uint40' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getLiquidationLogic',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'pure',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getPoolLogic',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'pure',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'uint16', name: 'id', type: 'uint16' }],
            name: 'getReserveAddressById',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getReserveData',
            outputs: [
              {
                components: [
                  {
                    components: [{ internalType: 'uint256', name: 'data', type: 'uint256' }],
                    internalType: 'struct DataTypes.ReserveConfigurationMap',
                    name: 'configuration',
                    type: 'tuple',
                  },
                  { internalType: 'uint128', name: 'liquidityIndex', type: 'uint128' },
                  { internalType: 'uint128', name: 'currentLiquidityRate', type: 'uint128' },
                  { internalType: 'uint128', name: 'variableBorrowIndex', type: 'uint128' },
                  { internalType: 'uint128', name: 'currentVariableBorrowRate', type: 'uint128' },
                  { internalType: 'uint128', name: 'currentStableBorrowRate', type: 'uint128' },
                  { internalType: 'uint40', name: 'lastUpdateTimestamp', type: 'uint40' },
                  { internalType: 'uint16', name: 'id', type: 'uint16' },
                  { internalType: 'address', name: 'aTokenAddress', type: 'address' },
                  { internalType: 'address', name: 'stableDebtTokenAddress', type: 'address' },
                  { internalType: 'address', name: 'variableDebtTokenAddress', type: 'address' },
                  { internalType: 'address', name: 'interestRateStrategyAddress', type: 'address' },
                  { internalType: 'uint128', name: 'accruedToTreasury', type: 'uint128' },
                  { internalType: 'uint128', name: 'unbacked', type: 'uint128' },
                  { internalType: 'uint128', name: 'isolationModeTotalDebt', type: 'uint128' },
                ],
                internalType: 'struct DataTypes.ReserveDataLegacy',
                name: '',
                type: 'tuple',
              },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getReserveDataExtended',
            outputs: [
              {
                components: [
                  {
                    components: [{ internalType: 'uint256', name: 'data', type: 'uint256' }],
                    internalType: 'struct DataTypes.ReserveConfigurationMap',
                    name: 'configuration',
                    type: 'tuple',
                  },
                  { internalType: 'uint128', name: 'liquidityIndex', type: 'uint128' },
                  { internalType: 'uint128', name: 'currentLiquidityRate', type: 'uint128' },
                  { internalType: 'uint128', name: 'variableBorrowIndex', type: 'uint128' },
                  { internalType: 'uint128', name: 'currentVariableBorrowRate', type: 'uint128' },
                  {
                    internalType: 'uint128',
                    name: '__deprecatedStableBorrowRate',
                    type: 'uint128',
                  },
                  { internalType: 'uint40', name: 'lastUpdateTimestamp', type: 'uint40' },
                  { internalType: 'uint16', name: 'id', type: 'uint16' },
                  { internalType: 'uint40', name: 'liquidationGracePeriodUntil', type: 'uint40' },
                  { internalType: 'address', name: 'aTokenAddress', type: 'address' },
                  {
                    internalType: 'address',
                    name: '__deprecatedStableDebtTokenAddress',
                    type: 'address',
                  },
                  { internalType: 'address', name: 'variableDebtTokenAddress', type: 'address' },
                  { internalType: 'address', name: 'interestRateStrategyAddress', type: 'address' },
                  { internalType: 'uint128', name: 'accruedToTreasury', type: 'uint128' },
                  { internalType: 'uint128', name: 'unbacked', type: 'uint128' },
                  { internalType: 'uint128', name: 'isolationModeTotalDebt', type: 'uint128' },
                  { internalType: 'uint128', name: 'virtualUnderlyingBalance', type: 'uint128' },
                ],
                internalType: 'struct DataTypes.ReserveData',
                name: '',
                type: 'tuple',
              },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getReserveNormalizedIncome',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getReserveNormalizedVariableDebt',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getReservesCount',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getReservesList',
            outputs: [{ internalType: 'address[]', name: '', type: 'address[]' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getSupplyLogic',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'pure',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'user', type: 'address' }],
            name: 'getUserAccountData',
            outputs: [
              { internalType: 'uint256', name: 'totalCollateralBase', type: 'uint256' },
              { internalType: 'uint256', name: 'totalDebtBase', type: 'uint256' },
              { internalType: 'uint256', name: 'availableBorrowsBase', type: 'uint256' },
              { internalType: 'uint256', name: 'currentLiquidationThreshold', type: 'uint256' },
              { internalType: 'uint256', name: 'ltv', type: 'uint256' },
              { internalType: 'uint256', name: 'healthFactor', type: 'uint256' },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'user', type: 'address' }],
            name: 'getUserConfiguration',
            outputs: [
              {
                components: [{ internalType: 'uint256', name: 'data', type: 'uint256' }],
                internalType: 'struct DataTypes.UserConfigurationMap',
                name: '',
                type: 'tuple',
              },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'user', type: 'address' }],
            name: 'getUserEMode',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getVirtualUnderlyingBalance',
            outputs: [{ internalType: 'uint128', name: '', type: 'uint128' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'address', name: 'aTokenAddress', type: 'address' },
              { internalType: 'address', name: 'variableDebtAddress', type: 'address' },
              { internalType: 'address', name: 'interestRateStrategyAddress', type: 'address' },
            ],
            name: 'initReserve',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              {
                internalType: 'contract IPoolAddressesProvider',
                name: 'provider',
                type: 'address',
              },
            ],
            name: 'initialize',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'collateralAsset', type: 'address' },
              { internalType: 'address', name: 'debtAsset', type: 'address' },
              { internalType: 'address', name: 'user', type: 'address' },
              { internalType: 'uint256', name: 'debtToCover', type: 'uint256' },
              { internalType: 'bool', name: 'receiveAToken', type: 'bool' },
            ],
            name: 'liquidationCall',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address[]', name: 'assets', type: 'address[]' }],
            name: 'mintToTreasury',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'address', name: 'onBehalfOf', type: 'address' },
              { internalType: 'uint16', name: 'referralCode', type: 'uint16' },
            ],
            name: 'mintUnbacked',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'uint256', name: 'interestRateMode', type: 'uint256' },
              { internalType: 'address', name: 'onBehalfOf', type: 'address' },
            ],
            name: 'repay',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'uint256', name: 'interestRateMode', type: 'uint256' },
            ],
            name: 'repayWithATokens',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'uint256', name: 'interestRateMode', type: 'uint256' },
              { internalType: 'address', name: 'onBehalfOf', type: 'address' },
              { internalType: 'uint256', name: 'deadline', type: 'uint256' },
              { internalType: 'uint8', name: 'permitV', type: 'uint8' },
              { internalType: 'bytes32', name: 'permitR', type: 'bytes32' },
              { internalType: 'bytes32', name: 'permitS', type: 'bytes32' },
            ],
            name: 'repayWithPermit',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'token', type: 'address' },
              { internalType: 'address', name: 'to', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'rescueTokens',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'resetIsolationModeTotalDebt',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              {
                components: [{ internalType: 'uint256', name: 'data', type: 'uint256' }],
                internalType: 'struct DataTypes.ReserveConfigurationMap',
                name: 'configuration',
                type: 'tuple',
              },
            ],
            name: 'setConfiguration',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'uint40', name: 'until', type: 'uint40' },
            ],
            name: 'setLiquidationGracePeriod',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'address', name: 'rateStrategyAddress', type: 'address' },
            ],
            name: 'setReserveInterestRateStrategyAddress',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'uint8', name: 'categoryId', type: 'uint8' }],
            name: 'setUserEMode',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'bool', name: 'useAsCollateral', type: 'bool' },
            ],
            name: 'setUserUseReserveAsCollateral',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'address', name: 'onBehalfOf', type: 'address' },
              { internalType: 'uint16', name: 'referralCode', type: 'uint16' },
            ],
            name: 'supply',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'address', name: 'onBehalfOf', type: 'address' },
              { internalType: 'uint16', name: 'referralCode', type: 'uint16' },
              { internalType: 'uint256', name: 'deadline', type: 'uint256' },
              { internalType: 'uint8', name: 'permitV', type: 'uint8' },
              { internalType: 'bytes32', name: 'permitR', type: 'bytes32' },
              { internalType: 'bytes32', name: 'permitS', type: 'bytes32' },
            ],
            name: 'supplyWithPermit',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'syncIndexesState',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'syncRatesState',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'uint256', name: 'protocolFee', type: 'uint256' }],
            name: 'updateBridgeProtocolFee',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'uint128', name: 'flashLoanPremiumTotal', type: 'uint128' },
              { internalType: 'uint128', name: 'flashLoanPremiumToProtocol', type: 'uint128' },
            ],
            name: 'updateFlashloanPremiums',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'address', name: 'to', type: 'address' },
            ],
            name: 'withdraw',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
        ]),
        (t.protocolDataProviderAbi = [
          {
            inputs: [
              {
                internalType: 'contract IPoolAddressesProvider',
                name: 'addressesProvider',
                type: 'address',
              },
            ],
            stateMutability: 'nonpayable',
            type: 'constructor',
          },
          {
            inputs: [],
            name: 'ADDRESSES_PROVIDER',
            outputs: [
              { internalType: 'contract IPoolAddressesProvider', name: '', type: 'address' },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getATokenTotalSupply',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getAllATokens',
            outputs: [
              {
                components: [
                  { internalType: 'string', name: 'symbol', type: 'string' },
                  { internalType: 'address', name: 'tokenAddress', type: 'address' },
                ],
                internalType: 'struct IPoolDataProvider.TokenData[]',
                name: '',
                type: 'tuple[]',
              },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getAllReservesTokens',
            outputs: [
              {
                components: [
                  { internalType: 'string', name: 'symbol', type: 'string' },
                  { internalType: 'address', name: 'tokenAddress', type: 'address' },
                ],
                internalType: 'struct IPoolDataProvider.TokenData[]',
                name: '',
                type: 'tuple[]',
              },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getDebtCeiling',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getDebtCeilingDecimals',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'pure',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getFlashLoanEnabled',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getInterestRateStrategyAddress',
            outputs: [{ internalType: 'address', name: 'irStrategyAddress', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getLiquidationProtocolFee',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getPaused',
            outputs: [{ internalType: 'bool', name: 'isPaused', type: 'bool' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getReserveCaps',
            outputs: [
              { internalType: 'uint256', name: 'borrowCap', type: 'uint256' },
              { internalType: 'uint256', name: 'supplyCap', type: 'uint256' },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getReserveConfigurationData',
            outputs: [
              { internalType: 'uint256', name: 'decimals', type: 'uint256' },
              { internalType: 'uint256', name: 'ltv', type: 'uint256' },
              { internalType: 'uint256', name: 'liquidationThreshold', type: 'uint256' },
              { internalType: 'uint256', name: 'liquidationBonus', type: 'uint256' },
              { internalType: 'uint256', name: 'reserveFactor', type: 'uint256' },
              { internalType: 'bool', name: 'usageAsCollateralEnabled', type: 'bool' },
              { internalType: 'bool', name: 'borrowingEnabled', type: 'bool' },
              { internalType: 'bool', name: 'stableBorrowRateEnabled', type: 'bool' },
              { internalType: 'bool', name: 'isActive', type: 'bool' },
              { internalType: 'bool', name: 'isFrozen', type: 'bool' },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getReserveData',
            outputs: [
              { internalType: 'uint256', name: 'unbacked', type: 'uint256' },
              { internalType: 'uint256', name: 'accruedToTreasuryScaled', type: 'uint256' },
              { internalType: 'uint256', name: 'totalAToken', type: 'uint256' },
              { internalType: 'uint256', name: 'totalStableDebt', type: 'uint256' },
              { internalType: 'uint256', name: 'totalVariableDebt', type: 'uint256' },
              { internalType: 'uint256', name: 'liquidityRate', type: 'uint256' },
              { internalType: 'uint256', name: 'variableBorrowRate', type: 'uint256' },
              { internalType: 'uint256', name: 'stableBorrowRate', type: 'uint256' },
              { internalType: 'uint256', name: 'averageStableBorrowRate', type: 'uint256' },
              { internalType: 'uint256', name: 'liquidityIndex', type: 'uint256' },
              { internalType: 'uint256', name: 'variableBorrowIndex', type: 'uint256' },
              { internalType: 'uint40', name: 'lastUpdateTimestamp', type: 'uint40' },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getReserveEModeCategory',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getReserveTokensAddresses',
            outputs: [
              { internalType: 'address', name: 'aTokenAddress', type: 'address' },
              { internalType: 'address', name: 'stableDebtTokenAddress', type: 'address' },
              { internalType: 'address', name: 'variableDebtTokenAddress', type: 'address' },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getSiloedBorrowing',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getTotalDebt',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getUnbackedMintCap',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'address', name: 'user', type: 'address' },
            ],
            name: 'getUserReserveData',
            outputs: [
              { internalType: 'uint256', name: 'currentATokenBalance', type: 'uint256' },
              { internalType: 'uint256', name: 'currentStableDebt', type: 'uint256' },
              { internalType: 'uint256', name: 'currentVariableDebt', type: 'uint256' },
              { internalType: 'uint256', name: 'principalStableDebt', type: 'uint256' },
              { internalType: 'uint256', name: 'scaledVariableDebt', type: 'uint256' },
              { internalType: 'uint256', name: 'stableBorrowRate', type: 'uint256' },
              { internalType: 'uint256', name: 'liquidityRate', type: 'uint256' },
              { internalType: 'uint40', name: 'stableRateLastUpdated', type: 'uint40' },
              { internalType: 'bool', name: 'usageAsCollateralEnabled', type: 'bool' },
            ],
            stateMutability: 'view',
            type: 'function',
          },
        ]),
        (t.aTokenV3Abi = [
          {
            inputs: [{ internalType: 'contract IPool', name: 'pool', type: 'address' }],
            stateMutability: 'nonpayable',
            type: 'constructor',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'owner', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'spender', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'value', type: 'uint256' },
            ],
            name: 'Approval',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'from', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'to', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'value', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'index', type: 'uint256' },
            ],
            name: 'BalanceTransfer',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'from', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'target', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'value', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'balanceIncrease', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'index', type: 'uint256' },
            ],
            name: 'Burn',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'underlyingAsset', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'pool', type: 'address' },
              { indexed: !1, internalType: 'address', name: 'treasury', type: 'address' },
              {
                indexed: !1,
                internalType: 'address',
                name: 'incentivesController',
                type: 'address',
              },
              { indexed: !1, internalType: 'uint8', name: 'aTokenDecimals', type: 'uint8' },
              { indexed: !1, internalType: 'string', name: 'aTokenName', type: 'string' },
              { indexed: !1, internalType: 'string', name: 'aTokenSymbol', type: 'string' },
              { indexed: !1, internalType: 'bytes', name: 'params', type: 'bytes' },
            ],
            name: 'Initialized',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'caller', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'onBehalfOf', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'value', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'balanceIncrease', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'index', type: 'uint256' },
            ],
            name: 'Mint',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'from', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'to', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'value', type: 'uint256' },
            ],
            name: 'Transfer',
            type: 'event',
          },
          {
            inputs: [],
            name: 'ATOKEN_REVISION',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'DOMAIN_SEPARATOR',
            outputs: [{ internalType: 'bytes32', name: '', type: 'bytes32' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'EIP712_REVISION',
            outputs: [{ internalType: 'bytes', name: '', type: 'bytes' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'PERMIT_TYPEHASH',
            outputs: [{ internalType: 'bytes32', name: '', type: 'bytes32' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'POOL',
            outputs: [{ internalType: 'contract IPool', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'RESERVE_TREASURY_ADDRESS',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'UNDERLYING_ASSET_ADDRESS',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'owner', type: 'address' },
              { internalType: 'address', name: 'spender', type: 'address' },
            ],
            name: 'allowance',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'spender', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'approve',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'user', type: 'address' }],
            name: 'balanceOf',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'from', type: 'address' },
              { internalType: 'address', name: 'receiverOfUnderlying', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'uint256', name: 'index', type: 'uint256' },
            ],
            name: 'burn',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [],
            name: 'decimals',
            outputs: [{ internalType: 'uint8', name: '', type: 'uint8' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'spender', type: 'address' },
              { internalType: 'uint256', name: 'subtractedValue', type: 'uint256' },
            ],
            name: 'decreaseAllowance',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getIncentivesController',
            outputs: [
              { internalType: 'contract IAaveIncentivesController', name: '', type: 'address' },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'user', type: 'address' }],
            name: 'getPreviousIndex',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'user', type: 'address' }],
            name: 'getScaledUserBalanceAndSupply',
            outputs: [
              { internalType: 'uint256', name: '', type: 'uint256' },
              { internalType: 'uint256', name: '', type: 'uint256' },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'user', type: 'address' },
              { internalType: 'address', name: 'onBehalfOf', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'handleRepayment',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'spender', type: 'address' },
              { internalType: 'uint256', name: 'addedValue', type: 'uint256' },
            ],
            name: 'increaseAllowance',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'contract IPool', name: 'initializingPool', type: 'address' },
              { internalType: 'address', name: 'treasury', type: 'address' },
              { internalType: 'address', name: 'underlyingAsset', type: 'address' },
              {
                internalType: 'contract IAaveIncentivesController',
                name: 'incentivesController',
                type: 'address',
              },
              { internalType: 'uint8', name: 'aTokenDecimals', type: 'uint8' },
              { internalType: 'string', name: 'aTokenName', type: 'string' },
              { internalType: 'string', name: 'aTokenSymbol', type: 'string' },
              { internalType: 'bytes', name: 'params', type: 'bytes' },
            ],
            name: 'initialize',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'caller', type: 'address' },
              { internalType: 'address', name: 'onBehalfOf', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'uint256', name: 'index', type: 'uint256' },
            ],
            name: 'mint',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'uint256', name: 'index', type: 'uint256' },
            ],
            name: 'mintToTreasury',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [],
            name: 'name',
            outputs: [{ internalType: 'string', name: '', type: 'string' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'owner', type: 'address' }],
            name: 'nonces',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'owner', type: 'address' },
              { internalType: 'address', name: 'spender', type: 'address' },
              { internalType: 'uint256', name: 'value', type: 'uint256' },
              { internalType: 'uint256', name: 'deadline', type: 'uint256' },
              { internalType: 'uint8', name: 'v', type: 'uint8' },
              { internalType: 'bytes32', name: 'r', type: 'bytes32' },
              { internalType: 'bytes32', name: 's', type: 'bytes32' },
            ],
            name: 'permit',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'token', type: 'address' },
              { internalType: 'address', name: 'to', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'rescueTokens',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'user', type: 'address' }],
            name: 'scaledBalanceOf',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'scaledTotalSupply',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              {
                internalType: 'contract IAaveIncentivesController',
                name: 'controller',
                type: 'address',
              },
            ],
            name: 'setIncentivesController',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [],
            name: 'symbol',
            outputs: [{ internalType: 'string', name: '', type: 'string' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'totalSupply',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'recipient', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'transfer',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'sender', type: 'address' },
              { internalType: 'address', name: 'recipient', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'transferFrom',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'from', type: 'address' },
              { internalType: 'address', name: 'to', type: 'address' },
              { internalType: 'uint256', name: 'value', type: 'uint256' },
            ],
            name: 'transferOnLiquidation',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'target', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'transferUnderlyingTo',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
        ]),
        (t.variableDebtTokenV3Abi = [
          {
            inputs: [
              { internalType: 'address', name: 'pool', type: 'address' },
              { internalType: 'address', name: 'underlyingAsset', type: 'address' },
              { internalType: 'string', name: 'name', type: 'string' },
              { internalType: 'string', name: 'symbol', type: 'string' },
              { internalType: 'address', name: 'incentivesController', type: 'address' },
            ],
            stateMutability: 'nonpayable',
            type: 'constructor',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'owner', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'spender', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'value', type: 'uint256' },
            ],
            name: 'Approval',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'fromUser', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'toUser', type: 'address' },
              { indexed: !1, internalType: 'address', name: 'asset', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'BorrowAllowanceDelegated',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'user', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'amount', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'index', type: 'uint256' },
            ],
            name: 'Burn',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'underlyingAsset', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'pool', type: 'address' },
              {
                indexed: !1,
                internalType: 'address',
                name: 'incentivesController',
                type: 'address',
              },
              { indexed: !1, internalType: 'uint8', name: 'debtTokenDecimals', type: 'uint8' },
              { indexed: !1, internalType: 'string', name: 'debtTokenName', type: 'string' },
              { indexed: !1, internalType: 'string', name: 'debtTokenSymbol', type: 'string' },
              { indexed: !1, internalType: 'bytes', name: 'params', type: 'bytes' },
            ],
            name: 'Initialized',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'from', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'onBehalfOf', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'value', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'index', type: 'uint256' },
            ],
            name: 'Mint',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'from', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'to', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'value', type: 'uint256' },
            ],
            name: 'Transfer',
            type: 'event',
          },
          {
            inputs: [],
            name: 'DEBT_TOKEN_REVISION',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'POOL',
            outputs: [{ internalType: 'contract ILendingPool', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'UNDERLYING_ASSET_ADDRESS',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'owner', type: 'address' },
              { internalType: 'address', name: 'spender', type: 'address' },
            ],
            name: 'allowance',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'spender', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'approve',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'delegatee', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'approveDelegation',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'user', type: 'address' }],
            name: 'balanceOf',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'fromUser', type: 'address' },
              { internalType: 'address', name: 'toUser', type: 'address' },
            ],
            name: 'borrowAllowance',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'user', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'uint256', name: 'index', type: 'uint256' },
            ],
            name: 'burn',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [],
            name: 'decimals',
            outputs: [{ internalType: 'uint8', name: '', type: 'uint8' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'spender', type: 'address' },
              { internalType: 'uint256', name: 'subtractedValue', type: 'uint256' },
            ],
            name: 'decreaseAllowance',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getIncentivesController',
            outputs: [
              { internalType: 'contract IAaveIncentivesController', name: '', type: 'address' },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'user', type: 'address' }],
            name: 'getScaledUserBalanceAndSupply',
            outputs: [
              { internalType: 'uint256', name: '', type: 'uint256' },
              { internalType: 'uint256', name: '', type: 'uint256' },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'spender', type: 'address' },
              { internalType: 'uint256', name: 'addedValue', type: 'uint256' },
            ],
            name: 'increaseAllowance',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'uint8', name: 'decimals', type: 'uint8' },
              { internalType: 'string', name: 'name', type: 'string' },
              { internalType: 'string', name: 'symbol', type: 'string' },
            ],
            name: 'initialize',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'user', type: 'address' },
              { internalType: 'address', name: 'onBehalfOf', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'uint256', name: 'index', type: 'uint256' },
            ],
            name: 'mint',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [],
            name: 'name',
            outputs: [{ internalType: 'string', name: '', type: 'string' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'user', type: 'address' }],
            name: 'scaledBalanceOf',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'scaledTotalSupply',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'symbol',
            outputs: [{ internalType: 'string', name: '', type: 'string' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'totalSupply',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'recipient', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'transfer',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'sender', type: 'address' },
              { internalType: 'address', name: 'recipient', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'transferFrom',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
        ]),
        (t.aaveV3OracleAbi = [
          {
            inputs: [
              {
                internalType: 'contract IPoolAddressesProvider',
                name: 'provider',
                type: 'address',
              },
              { internalType: 'address[]', name: 'assets', type: 'address[]' },
              { internalType: 'address[]', name: 'sources', type: 'address[]' },
              { internalType: 'address', name: 'fallbackOracle', type: 'address' },
              { internalType: 'address', name: 'baseCurrency', type: 'address' },
              { internalType: 'uint256', name: 'baseCurrencyUnit', type: 'uint256' },
            ],
            stateMutability: 'nonpayable',
            type: 'constructor',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'asset', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'source', type: 'address' },
            ],
            name: 'AssetSourceUpdated',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'baseCurrency', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'baseCurrencyUnit', type: 'uint256' },
            ],
            name: 'BaseCurrencySet',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'fallbackOracle', type: 'address' },
            ],
            name: 'FallbackOracleUpdated',
            type: 'event',
          },
          {
            inputs: [],
            name: 'ADDRESSES_PROVIDER',
            outputs: [
              { internalType: 'contract IPoolAddressesProvider', name: '', type: 'address' },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'BASE_CURRENCY',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'BASE_CURRENCY_UNIT',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getAssetPrice',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address[]', name: 'assets', type: 'address[]' }],
            name: 'getAssetsPrices',
            outputs: [{ internalType: 'uint256[]', name: '', type: 'uint256[]' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getFallbackOracle',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getSourceOfAsset',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address[]', name: 'assets', type: 'address[]' },
              { internalType: 'address[]', name: 'sources', type: 'address[]' },
            ],
            name: 'setAssetSources',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'fallbackOracle', type: 'address' }],
            name: 'setFallbackOracle',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
        ]),
        (t.addressesProviderAbi = [
          {
            inputs: [
              { internalType: 'string', name: 'marketId', type: 'string' },
              { internalType: 'address', name: 'owner', type: 'address' },
            ],
            stateMutability: 'nonpayable',
            type: 'constructor',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'oldAddress', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'newAddress', type: 'address' },
            ],
            name: 'ACLAdminUpdated',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'oldAddress', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'newAddress', type: 'address' },
            ],
            name: 'ACLManagerUpdated',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'bytes32', name: 'id', type: 'bytes32' },
              { indexed: !0, internalType: 'address', name: 'oldAddress', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'newAddress', type: 'address' },
            ],
            name: 'AddressSet',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'bytes32', name: 'id', type: 'bytes32' },
              { indexed: !0, internalType: 'address', name: 'proxyAddress', type: 'address' },
              {
                indexed: !1,
                internalType: 'address',
                name: 'oldImplementationAddress',
                type: 'address',
              },
              {
                indexed: !0,
                internalType: 'address',
                name: 'newImplementationAddress',
                type: 'address',
              },
            ],
            name: 'AddressSetAsProxy',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'string', name: 'oldMarketId', type: 'string' },
              { indexed: !0, internalType: 'string', name: 'newMarketId', type: 'string' },
            ],
            name: 'MarketIdSet',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'previousOwner', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'newOwner', type: 'address' },
            ],
            name: 'OwnershipTransferred',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'oldAddress', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'newAddress', type: 'address' },
            ],
            name: 'PoolConfiguratorUpdated',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'oldAddress', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'newAddress', type: 'address' },
            ],
            name: 'PoolDataProviderUpdated',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'oldAddress', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'newAddress', type: 'address' },
            ],
            name: 'PoolUpdated',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'oldAddress', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'newAddress', type: 'address' },
            ],
            name: 'PriceOracleSentinelUpdated',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'oldAddress', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'newAddress', type: 'address' },
            ],
            name: 'PriceOracleUpdated',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'bytes32', name: 'id', type: 'bytes32' },
              { indexed: !0, internalType: 'address', name: 'proxyAddress', type: 'address' },
              {
                indexed: !0,
                internalType: 'address',
                name: 'implementationAddress',
                type: 'address',
              },
            ],
            name: 'ProxyCreated',
            type: 'event',
          },
          {
            inputs: [],
            name: 'getACLAdmin',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getACLManager',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'bytes32', name: 'id', type: 'bytes32' }],
            name: 'getAddress',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getMarketId',
            outputs: [{ internalType: 'string', name: '', type: 'string' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getPool',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getPoolConfigurator',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getPoolDataProvider',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getPriceOracle',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getPriceOracleSentinel',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'owner',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'renounceOwnership',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'newAclAdmin', type: 'address' }],
            name: 'setACLAdmin',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'newAclManager', type: 'address' }],
            name: 'setACLManager',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'bytes32', name: 'id', type: 'bytes32' },
              { internalType: 'address', name: 'newAddress', type: 'address' },
            ],
            name: 'setAddress',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'bytes32', name: 'id', type: 'bytes32' },
              { internalType: 'address', name: 'newImplementationAddress', type: 'address' },
            ],
            name: 'setAddressAsProxy',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'string', name: 'newMarketId', type: 'string' }],
            name: 'setMarketId',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'newPoolConfiguratorImpl', type: 'address' }],
            name: 'setPoolConfiguratorImpl',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'newDataProvider', type: 'address' }],
            name: 'setPoolDataProvider',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'newPoolImpl', type: 'address' }],
            name: 'setPoolImpl',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'newPriceOracle', type: 'address' }],
            name: 'setPriceOracle',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'newPriceOracleSentinel', type: 'address' }],
            name: 'setPriceOracleSentinel',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'newOwner', type: 'address' }],
            name: 'transferOwnership',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
        ]);
    },
    4457: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.morphoAaveV3Abi = void 0),
        (t.morphoAaveV3Abi = [
          { inputs: [], name: 'AddressIsZero', type: 'error' },
          { inputs: [], name: 'AmountIsZero', type: 'error' },
          { inputs: [], name: 'AssetIsCollateralOnMorpho', type: 'error' },
          { inputs: [], name: 'AssetNotCollateralOnPool', type: 'error' },
          { inputs: [], name: 'BorrowNotPaused', type: 'error' },
          { inputs: [], name: 'ClaimRewardsPaused', type: 'error' },
          { inputs: [], name: 'ExceedsMaxBasisPoints', type: 'error' },
          { inputs: [], name: 'InvalidNonce', type: 'error' },
          { inputs: [], name: 'InvalidSignatory', type: 'error' },
          { inputs: [], name: 'InvalidValueS', type: 'error' },
          { inputs: [], name: 'InvalidValueV', type: 'error' },
          { inputs: [], name: 'MarketAlreadyCreated', type: 'error' },
          { inputs: [], name: 'MarketIsDeprecated', type: 'error' },
          { inputs: [], name: 'MarketIsNotListedOnAave', type: 'error' },
          { inputs: [], name: 'MarketLtTooLow', type: 'error' },
          { inputs: [], name: 'MarketNotCreated', type: 'error' },
          { inputs: [], name: 'SetAsCollateralOnPoolButMarketNotCreated', type: 'error' },
          { inputs: [], name: 'SignatureExpired', type: 'error' },
          { inputs: [], name: 'SiloedBorrowMarket', type: 'error' },
          { inputs: [], name: 'UnsafeCast', type: 'error' },
          {
            anonymous: !1,
            inputs: [{ indexed: !1, internalType: 'uint8', name: 'version', type: 'uint8' }],
            name: 'Initialized',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'previousOwner', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'newOwner', type: 'address' },
            ],
            name: 'OwnershipTransferStarted',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'previousOwner', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'newOwner', type: 'address' },
            ],
            name: 'OwnershipTransferred',
            type: 'event',
          },
          {
            inputs: [],
            name: 'DOMAIN_SEPARATOR',
            outputs: [{ internalType: 'bytes32', name: '', type: 'bytes32' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'acceptOwnership',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [],
            name: 'addressesProvider',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'manager', type: 'address' },
              { internalType: 'bool', name: 'isAllowed', type: 'bool' },
            ],
            name: 'approveManager',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'delegator', type: 'address' },
              { internalType: 'address', name: 'manager', type: 'address' },
              { internalType: 'bool', name: 'isAllowed', type: 'bool' },
              { internalType: 'uint256', name: 'nonce', type: 'uint256' },
              { internalType: 'uint256', name: 'deadline', type: 'uint256' },
              {
                components: [
                  { internalType: 'uint8', name: 'v', type: 'uint8' },
                  { internalType: 'bytes32', name: 'r', type: 'bytes32' },
                  { internalType: 'bytes32', name: 's', type: 'bytes32' },
                ],
                internalType: 'struct Types.Signature',
                name: 'signature',
                type: 'tuple',
              },
            ],
            name: 'approveManagerWithSig',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'address', name: 'onBehalf', type: 'address' },
              { internalType: 'address', name: 'receiver', type: 'address' },
              { internalType: 'uint256', name: 'maxIterations', type: 'uint256' },
            ],
            name: 'borrow',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'address', name: 'user', type: 'address' },
            ],
            name: 'borrowBalance',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address[]', name: 'assets', type: 'address[]' },
              { internalType: 'address', name: 'onBehalf', type: 'address' },
            ],
            name: 'claimRewards',
            outputs: [
              { internalType: 'address[]', name: 'rewardTokens', type: 'address[]' },
              { internalType: 'uint256[]', name: 'claimedAmounts', type: 'uint256[]' },
            ],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address[]', name: 'underlyings', type: 'address[]' },
              { internalType: 'uint256[]', name: 'amounts', type: 'uint256[]' },
            ],
            name: 'claimToTreasury',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'address', name: 'user', type: 'address' },
            ],
            name: 'collateralBalance',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'uint16', name: 'reserveFactor', type: 'uint16' },
              { internalType: 'uint16', name: 'p2pIndexCursor', type: 'uint16' },
            ],
            name: 'createMarket',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [],
            name: 'defaultIterations',
            outputs: [
              {
                components: [
                  { internalType: 'uint128', name: 'repay', type: 'uint128' },
                  { internalType: 'uint128', name: 'withdraw', type: 'uint128' },
                ],
                internalType: 'struct Types.Iterations',
                name: '',
                type: 'tuple',
              },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'eModeCategoryId',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'enum Types.Position', name: 'position', type: 'uint8' },
            ],
            name: 'getBucketsMask',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'enum Types.Position', name: 'position', type: 'uint8' },
              { internalType: 'address', name: 'user', type: 'address' },
            ],
            name: 'getNext',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'increaseP2PDeltas',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'addressesProvider', type: 'address' },
              { internalType: 'uint8', name: 'eModeCategoryId', type: 'uint8' },
              { internalType: 'address', name: 'positionsManager', type: 'address' },
              {
                components: [
                  { internalType: 'uint128', name: 'repay', type: 'uint128' },
                  { internalType: 'uint128', name: 'withdraw', type: 'uint128' },
                ],
                internalType: 'struct Types.Iterations',
                name: 'defaultIterations',
                type: 'tuple',
              },
            ],
            name: 'initialize',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [],
            name: 'isClaimRewardsPaused',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'delegator', type: 'address' },
              { internalType: 'address', name: 'manager', type: 'address' },
            ],
            name: 'isManagedBy',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlyingBorrowed', type: 'address' },
              { internalType: 'address', name: 'underlyingCollateral', type: 'address' },
              { internalType: 'address', name: 'user', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'liquidate',
            outputs: [
              { internalType: 'uint256', name: '', type: 'uint256' },
              { internalType: 'uint256', name: '', type: 'uint256' },
            ],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'user', type: 'address' }],
            name: 'liquidityData',
            outputs: [
              {
                components: [
                  { internalType: 'uint256', name: 'borrowable', type: 'uint256' },
                  { internalType: 'uint256', name: 'maxDebt', type: 'uint256' },
                  { internalType: 'uint256', name: 'debt', type: 'uint256' },
                ],
                internalType: 'struct Types.LiquidityData',
                name: '',
                type: 'tuple',
              },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'underlying', type: 'address' }],
            name: 'market',
            outputs: [
              {
                components: [
                  {
                    components: [
                      {
                        components: [
                          { internalType: 'uint128', name: 'poolIndex', type: 'uint128' },
                          { internalType: 'uint128', name: 'p2pIndex', type: 'uint128' },
                        ],
                        internalType: 'struct Types.MarketSideIndexes',
                        name: 'supply',
                        type: 'tuple',
                      },
                      {
                        components: [
                          { internalType: 'uint128', name: 'poolIndex', type: 'uint128' },
                          { internalType: 'uint128', name: 'p2pIndex', type: 'uint128' },
                        ],
                        internalType: 'struct Types.MarketSideIndexes',
                        name: 'borrow',
                        type: 'tuple',
                      },
                    ],
                    internalType: 'struct Types.Indexes',
                    name: 'indexes',
                    type: 'tuple',
                  },
                  {
                    components: [
                      {
                        components: [
                          { internalType: 'uint256', name: 'scaledDelta', type: 'uint256' },
                          { internalType: 'uint256', name: 'scaledP2PTotal', type: 'uint256' },
                        ],
                        internalType: 'struct Types.MarketSideDelta',
                        name: 'supply',
                        type: 'tuple',
                      },
                      {
                        components: [
                          { internalType: 'uint256', name: 'scaledDelta', type: 'uint256' },
                          { internalType: 'uint256', name: 'scaledP2PTotal', type: 'uint256' },
                        ],
                        internalType: 'struct Types.MarketSideDelta',
                        name: 'borrow',
                        type: 'tuple',
                      },
                    ],
                    internalType: 'struct Types.Deltas',
                    name: 'deltas',
                    type: 'tuple',
                  },
                  { internalType: 'address', name: 'underlying', type: 'address' },
                  {
                    components: [
                      { internalType: 'bool', name: 'isP2PDisabled', type: 'bool' },
                      { internalType: 'bool', name: 'isSupplyPaused', type: 'bool' },
                      { internalType: 'bool', name: 'isSupplyCollateralPaused', type: 'bool' },
                      { internalType: 'bool', name: 'isBorrowPaused', type: 'bool' },
                      { internalType: 'bool', name: 'isWithdrawPaused', type: 'bool' },
                      { internalType: 'bool', name: 'isWithdrawCollateralPaused', type: 'bool' },
                      { internalType: 'bool', name: 'isRepayPaused', type: 'bool' },
                      { internalType: 'bool', name: 'isLiquidateCollateralPaused', type: 'bool' },
                      { internalType: 'bool', name: 'isLiquidateBorrowPaused', type: 'bool' },
                      { internalType: 'bool', name: 'isDeprecated', type: 'bool' },
                    ],
                    internalType: 'struct Types.PauseStatuses',
                    name: 'pauseStatuses',
                    type: 'tuple',
                  },
                  { internalType: 'bool', name: 'isCollateral', type: 'bool' },
                  { internalType: 'address', name: 'variableDebtToken', type: 'address' },
                  { internalType: 'uint32', name: 'lastUpdateTimestamp', type: 'uint32' },
                  { internalType: 'uint16', name: 'reserveFactor', type: 'uint16' },
                  { internalType: 'uint16', name: 'p2pIndexCursor', type: 'uint16' },
                  { internalType: 'address', name: 'aToken', type: 'address' },
                  { internalType: 'address', name: 'stableDebtToken', type: 'address' },
                  { internalType: 'uint256', name: 'idleSupply', type: 'uint256' },
                ],
                internalType: 'struct Types.Market',
                name: '',
                type: 'tuple',
              },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'marketsCreated',
            outputs: [{ internalType: 'address[]', name: '', type: 'address[]' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'owner',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'pendingOwner',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'pool',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'positionsManager',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'renounceOwnership',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'address', name: 'onBehalf', type: 'address' },
            ],
            name: 'repay',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'address', name: 'onBehalf', type: 'address' },
              { internalType: 'uint256', name: 'deadline', type: 'uint256' },
              {
                components: [
                  { internalType: 'uint8', name: 'v', type: 'uint8' },
                  { internalType: 'bytes32', name: 'r', type: 'bytes32' },
                  { internalType: 'bytes32', name: 's', type: 'bytes32' },
                ],
                internalType: 'struct Types.Signature',
                name: 'signature',
                type: 'tuple',
              },
            ],
            name: 'repayWithPermit',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [],
            name: 'rewardsManager',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'address', name: 'user', type: 'address' },
            ],
            name: 'scaledCollateralBalance',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'address', name: 'user', type: 'address' },
            ],
            name: 'scaledP2PBorrowBalance',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'address', name: 'user', type: 'address' },
            ],
            name: 'scaledP2PSupplyBalance',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'address', name: 'user', type: 'address' },
            ],
            name: 'scaledPoolBorrowBalance',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'address', name: 'user', type: 'address' },
            ],
            name: 'scaledPoolSupplyBalance',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'bool', name: 'isCollateral', type: 'bool' },
            ],
            name: 'setAssetIsCollateral',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'bool', name: 'isCollateral', type: 'bool' },
            ],
            name: 'setAssetIsCollateralOnPool',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              {
                components: [
                  { internalType: 'uint128', name: 'repay', type: 'uint128' },
                  { internalType: 'uint128', name: 'withdraw', type: 'uint128' },
                ],
                internalType: 'struct Types.Iterations',
                name: 'defaultIterations',
                type: 'tuple',
              },
            ],
            name: 'setDefaultIterations',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'bool', name: 'isPaused', type: 'bool' },
            ],
            name: 'setIsBorrowPaused',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'bool', name: 'isPaused', type: 'bool' }],
            name: 'setIsClaimRewardsPaused',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'bool', name: 'isDeprecated', type: 'bool' },
            ],
            name: 'setIsDeprecated',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'bool', name: 'isPaused', type: 'bool' },
            ],
            name: 'setIsLiquidateBorrowPaused',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'bool', name: 'isPaused', type: 'bool' },
            ],
            name: 'setIsLiquidateCollateralPaused',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'bool', name: 'isP2PDisabled', type: 'bool' },
            ],
            name: 'setIsP2PDisabled',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'bool', name: 'isPaused', type: 'bool' },
            ],
            name: 'setIsPaused',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'bool', name: 'isPaused', type: 'bool' }],
            name: 'setIsPausedForAllMarkets',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'bool', name: 'isPaused', type: 'bool' },
            ],
            name: 'setIsRepayPaused',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'bool', name: 'isPaused', type: 'bool' },
            ],
            name: 'setIsSupplyCollateralPaused',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'bool', name: 'isPaused', type: 'bool' },
            ],
            name: 'setIsSupplyPaused',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'bool', name: 'isPaused', type: 'bool' },
            ],
            name: 'setIsWithdrawCollateralPaused',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'bool', name: 'isPaused', type: 'bool' },
            ],
            name: 'setIsWithdrawPaused',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'uint16', name: 'p2pIndexCursor', type: 'uint16' },
            ],
            name: 'setP2PIndexCursor',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'positionsManager', type: 'address' }],
            name: 'setPositionsManager',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'uint16', name: 'newReserveFactor', type: 'uint16' },
            ],
            name: 'setReserveFactor',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'rewardsManager', type: 'address' }],
            name: 'setRewardsManager',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'treasuryVault', type: 'address' }],
            name: 'setTreasuryVault',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'address', name: 'onBehalf', type: 'address' },
              { internalType: 'uint256', name: 'maxIterations', type: 'uint256' },
            ],
            name: 'supply',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'address', name: 'user', type: 'address' },
            ],
            name: 'supplyBalance',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'address', name: 'onBehalf', type: 'address' },
            ],
            name: 'supplyCollateral',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'address', name: 'onBehalf', type: 'address' },
              { internalType: 'uint256', name: 'deadline', type: 'uint256' },
              {
                components: [
                  { internalType: 'uint8', name: 'v', type: 'uint8' },
                  { internalType: 'bytes32', name: 'r', type: 'bytes32' },
                  { internalType: 'bytes32', name: 's', type: 'bytes32' },
                ],
                internalType: 'struct Types.Signature',
                name: 'signature',
                type: 'tuple',
              },
            ],
            name: 'supplyCollateralWithPermit',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'address', name: 'onBehalf', type: 'address' },
              { internalType: 'uint256', name: 'maxIterations', type: 'uint256' },
              { internalType: 'uint256', name: 'deadline', type: 'uint256' },
              {
                components: [
                  { internalType: 'uint8', name: 'v', type: 'uint8' },
                  { internalType: 'bytes32', name: 'r', type: 'bytes32' },
                  { internalType: 'bytes32', name: 's', type: 'bytes32' },
                ],
                internalType: 'struct Types.Signature',
                name: 'signature',
                type: 'tuple',
              },
            ],
            name: 'supplyWithPermit',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'newOwner', type: 'address' }],
            name: 'transferOwnership',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [],
            name: 'treasuryVault',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'underlying', type: 'address' }],
            name: 'updatedIndexes',
            outputs: [
              {
                components: [
                  {
                    components: [
                      { internalType: 'uint256', name: 'poolIndex', type: 'uint256' },
                      { internalType: 'uint256', name: 'p2pIndex', type: 'uint256' },
                    ],
                    internalType: 'struct Types.MarketSideIndexes256',
                    name: 'supply',
                    type: 'tuple',
                  },
                  {
                    components: [
                      { internalType: 'uint256', name: 'poolIndex', type: 'uint256' },
                      { internalType: 'uint256', name: 'p2pIndex', type: 'uint256' },
                    ],
                    internalType: 'struct Types.MarketSideIndexes256',
                    name: 'borrow',
                    type: 'tuple',
                  },
                ],
                internalType: 'struct Types.Indexes256',
                name: 'indexes',
                type: 'tuple',
              },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'user', type: 'address' }],
            name: 'userBorrows',
            outputs: [{ internalType: 'address[]', name: '', type: 'address[]' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'user', type: 'address' }],
            name: 'userCollaterals',
            outputs: [{ internalType: 'address[]', name: '', type: 'address[]' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'user', type: 'address' }],
            name: 'userNonce',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'address', name: 'onBehalf', type: 'address' },
              { internalType: 'address', name: 'receiver', type: 'address' },
              { internalType: 'uint256', name: 'maxIterations', type: 'uint256' },
            ],
            name: 'withdraw',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'underlying', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
              { internalType: 'address', name: 'onBehalf', type: 'address' },
              { internalType: 'address', name: 'receiver', type: 'address' },
            ],
            name: 'withdrawCollateral',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
        ]);
    },
    67317: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.mErc20Abi =
          t.cErc20Abi =
          t.cEtherAbi =
          t.crossChainCErc20Abi =
          t.comptrollerAbi =
            void 0),
        (t.comptrollerAbi = [
          { inputs: [], payable: !1, stateMutability: 'nonpayable', type: 'constructor' },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, internalType: 'string', name: 'action', type: 'string' },
              { indexed: !1, internalType: 'bool', name: 'pauseState', type: 'bool' },
            ],
            name: 'ActionPaused',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, internalType: 'contract CToken', name: 'cToken', type: 'address' },
              { indexed: !1, internalType: 'string', name: 'action', type: 'string' },
              { indexed: !1, internalType: 'bool', name: 'pauseState', type: 'bool' },
            ],
            name: 'ActionPaused',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'user', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'oldCompAccrued', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'newCompAccrued', type: 'uint256' },
            ],
            name: 'CompAccruedAdjusted',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'contract CToken', name: 'cToken', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'newSpeed', type: 'uint256' },
            ],
            name: 'CompBorrowSpeedUpdated',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, internalType: 'address', name: 'recipient', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'CompGranted',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'user', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'oldCompReceivable', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'newCompReceivable', type: 'uint256' },
            ],
            name: 'CompReceivableUpdated',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'contract CToken', name: 'cToken', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'newSpeed', type: 'uint256' },
            ],
            name: 'CompSupplySpeedUpdated',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'contributor', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'newSpeed', type: 'uint256' },
            ],
            name: 'ContributorCompSpeedUpdated',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'contract CToken', name: 'cToken', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'borrower', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'compDelta', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'compBorrowIndex', type: 'uint256' },
            ],
            name: 'DistributedBorrowerComp',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'contract CToken', name: 'cToken', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'supplier', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'compDelta', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'compSupplyIndex', type: 'uint256' },
            ],
            name: 'DistributedSupplierComp',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, internalType: 'uint256', name: 'error', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'info', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'detail', type: 'uint256' },
            ],
            name: 'Failure',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, internalType: 'contract CToken', name: 'cToken', type: 'address' },
              { indexed: !1, internalType: 'address', name: 'account', type: 'address' },
            ],
            name: 'MarketEntered',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, internalType: 'contract CToken', name: 'cToken', type: 'address' },
              { indexed: !1, internalType: 'address', name: 'account', type: 'address' },
            ],
            name: 'MarketExited',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, internalType: 'contract CToken', name: 'cToken', type: 'address' },
            ],
            name: 'MarketListed',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'contract CToken', name: 'cToken', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'newBorrowCap', type: 'uint256' },
            ],
            name: 'NewBorrowCap',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              {
                indexed: !1,
                internalType: 'address',
                name: 'oldBorrowCapGuardian',
                type: 'address',
              },
              {
                indexed: !1,
                internalType: 'address',
                name: 'newBorrowCapGuardian',
                type: 'address',
              },
            ],
            name: 'NewBorrowCapGuardian',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              {
                indexed: !1,
                internalType: 'uint256',
                name: 'oldCloseFactorMantissa',
                type: 'uint256',
              },
              {
                indexed: !1,
                internalType: 'uint256',
                name: 'newCloseFactorMantissa',
                type: 'uint256',
              },
            ],
            name: 'NewCloseFactor',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, internalType: 'contract CToken', name: 'cToken', type: 'address' },
              {
                indexed: !1,
                internalType: 'uint256',
                name: 'oldCollateralFactorMantissa',
                type: 'uint256',
              },
              {
                indexed: !1,
                internalType: 'uint256',
                name: 'newCollateralFactorMantissa',
                type: 'uint256',
              },
            ],
            name: 'NewCollateralFactor',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              {
                indexed: !1,
                internalType: 'uint256',
                name: 'oldLiquidationIncentiveMantissa',
                type: 'uint256',
              },
              {
                indexed: !1,
                internalType: 'uint256',
                name: 'newLiquidationIncentiveMantissa',
                type: 'uint256',
              },
            ],
            name: 'NewLiquidationIncentive',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, internalType: 'address', name: 'oldPauseGuardian', type: 'address' },
              { indexed: !1, internalType: 'address', name: 'newPauseGuardian', type: 'address' },
            ],
            name: 'NewPauseGuardian',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              {
                indexed: !1,
                internalType: 'contract PriceOracle',
                name: 'oldPriceOracle',
                type: 'address',
              },
              {
                indexed: !1,
                internalType: 'contract PriceOracle',
                name: 'newPriceOracle',
                type: 'address',
              },
            ],
            name: 'NewPriceOracle',
            type: 'event',
          },
          {
            constant: !1,
            inputs: [{ internalType: 'contract Unitroller', name: 'unitroller', type: 'address' }],
            name: '_become',
            outputs: [],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: '_borrowGuardianPaused',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { internalType: 'address', name: 'recipient', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: '_grantComp',
            outputs: [],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: '_mintGuardianPaused',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ internalType: 'address', name: 'newBorrowCapGuardian', type: 'address' }],
            name: '_setBorrowCapGuardian',
            outputs: [],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { internalType: 'contract CToken', name: 'cToken', type: 'address' },
              { internalType: 'bool', name: 'state', type: 'bool' },
            ],
            name: '_setBorrowPaused',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ internalType: 'uint256', name: 'newCloseFactorMantissa', type: 'uint256' }],
            name: '_setCloseFactor',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { internalType: 'contract CToken', name: 'cToken', type: 'address' },
              { internalType: 'uint256', name: 'newCollateralFactorMantissa', type: 'uint256' },
            ],
            name: '_setCollateralFactor',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { internalType: 'contract CToken[]', name: 'cTokens', type: 'address[]' },
              { internalType: 'uint256[]', name: 'supplySpeeds', type: 'uint256[]' },
              { internalType: 'uint256[]', name: 'borrowSpeeds', type: 'uint256[]' },
            ],
            name: '_setCompSpeeds',
            outputs: [],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { internalType: 'address', name: 'contributor', type: 'address' },
              { internalType: 'uint256', name: 'compSpeed', type: 'uint256' },
            ],
            name: '_setContributorCompSpeed',
            outputs: [],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { internalType: 'uint256', name: 'newLiquidationIncentiveMantissa', type: 'uint256' },
            ],
            name: '_setLiquidationIncentive',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { internalType: 'contract CToken[]', name: 'cTokens', type: 'address[]' },
              { internalType: 'uint256[]', name: 'newBorrowCaps', type: 'uint256[]' },
            ],
            name: '_setMarketBorrowCaps',
            outputs: [],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { internalType: 'contract CToken', name: 'cToken', type: 'address' },
              { internalType: 'bool', name: 'state', type: 'bool' },
            ],
            name: '_setMintPaused',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ internalType: 'address', name: 'newPauseGuardian', type: 'address' }],
            name: '_setPauseGuardian',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ internalType: 'contract PriceOracle', name: 'newOracle', type: 'address' }],
            name: '_setPriceOracle',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ internalType: 'bool', name: 'state', type: 'bool' }],
            name: '_setSeizePaused',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ internalType: 'bool', name: 'state', type: 'bool' }],
            name: '_setTransferPaused',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ internalType: 'contract CToken', name: 'cToken', type: 'address' }],
            name: '_supportMarket',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [
              { internalType: 'address', name: '', type: 'address' },
              { internalType: 'uint256', name: '', type: 'uint256' },
            ],
            name: 'accountAssets',
            outputs: [{ internalType: 'contract CToken', name: '', type: 'address' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'admin',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            name: 'allMarkets',
            outputs: [{ internalType: 'contract CToken', name: '', type: 'address' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { internalType: 'address', name: 'cToken', type: 'address' },
              { internalType: 'address', name: 'borrower', type: 'address' },
              { internalType: 'uint256', name: 'borrowAmount', type: 'uint256' },
            ],
            name: 'borrowAllowed',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'borrowCapGuardian',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [{ internalType: 'address', name: '', type: 'address' }],
            name: 'borrowCaps',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [{ internalType: 'address', name: '', type: 'address' }],
            name: 'borrowGuardianPaused',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { internalType: 'address', name: 'cToken', type: 'address' },
              { internalType: 'address', name: 'borrower', type: 'address' },
              { internalType: 'uint256', name: 'borrowAmount', type: 'uint256' },
            ],
            name: 'borrowVerify',
            outputs: [],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [
              { internalType: 'address', name: 'account', type: 'address' },
              { internalType: 'contract CToken', name: 'cToken', type: 'address' },
            ],
            name: 'checkMembership',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { internalType: 'address', name: 'holder', type: 'address' },
              { internalType: 'contract CToken[]', name: 'cTokens', type: 'address[]' },
            ],
            name: 'claimComp',
            outputs: [],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { internalType: 'address[]', name: 'holders', type: 'address[]' },
              { internalType: 'contract CToken[]', name: 'cTokens', type: 'address[]' },
              { internalType: 'bool', name: 'borrowers', type: 'bool' },
              { internalType: 'bool', name: 'suppliers', type: 'bool' },
            ],
            name: 'claimComp',
            outputs: [],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ internalType: 'address', name: 'holder', type: 'address' }],
            name: 'claimComp',
            outputs: [],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'closeFactorMantissa',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [{ internalType: 'address', name: '', type: 'address' }],
            name: 'compAccrued',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [{ internalType: 'address', name: '', type: 'address' }],
            name: 'compBorrowSpeeds',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [{ internalType: 'address', name: '', type: 'address' }],
            name: 'compBorrowState',
            outputs: [
              { internalType: 'uint224', name: 'index', type: 'uint224' },
              { internalType: 'uint32', name: 'block', type: 'uint32' },
            ],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [
              { internalType: 'address', name: '', type: 'address' },
              { internalType: 'address', name: '', type: 'address' },
            ],
            name: 'compBorrowerIndex',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [{ internalType: 'address', name: '', type: 'address' }],
            name: 'compContributorSpeeds',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'compInitialIndex',
            outputs: [{ internalType: 'uint224', name: '', type: 'uint224' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'compRate',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [{ internalType: 'address', name: '', type: 'address' }],
            name: 'compReceivable',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [{ internalType: 'address', name: '', type: 'address' }],
            name: 'compSpeeds',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [
              { internalType: 'address', name: '', type: 'address' },
              { internalType: 'address', name: '', type: 'address' },
            ],
            name: 'compSupplierIndex',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [{ internalType: 'address', name: '', type: 'address' }],
            name: 'compSupplySpeeds',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [{ internalType: 'address', name: '', type: 'address' }],
            name: 'compSupplyState',
            outputs: [
              { internalType: 'uint224', name: 'index', type: 'uint224' },
              { internalType: 'uint32', name: 'block', type: 'uint32' },
            ],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'comptrollerImplementation',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ internalType: 'address[]', name: 'cTokens', type: 'address[]' }],
            name: 'enterMarkets',
            outputs: [{ internalType: 'uint256[]', name: '', type: 'uint256[]' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ internalType: 'address', name: 'cTokenAddress', type: 'address' }],
            name: 'exitMarket',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { internalType: 'address[]', name: 'affectedUsers', type: 'address[]' },
              { internalType: 'uint256[]', name: 'amounts', type: 'uint256[]' },
            ],
            name: 'fixBadAccruals',
            outputs: [],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [{ internalType: 'address', name: 'account', type: 'address' }],
            name: 'getAccountLiquidity',
            outputs: [
              { internalType: 'uint256', name: '', type: 'uint256' },
              { internalType: 'uint256', name: '', type: 'uint256' },
              { internalType: 'uint256', name: '', type: 'uint256' },
            ],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'getAllMarkets',
            outputs: [{ internalType: 'contract CToken[]', name: '', type: 'address[]' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [{ internalType: 'address', name: 'account', type: 'address' }],
            name: 'getAssetsIn',
            outputs: [{ internalType: 'contract CToken[]', name: '', type: 'address[]' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'getBlockNumber',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'getCompAddress',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [
              { internalType: 'address', name: 'account', type: 'address' },
              { internalType: 'address', name: 'cTokenModify', type: 'address' },
              { internalType: 'uint256', name: 'redeemTokens', type: 'uint256' },
              { internalType: 'uint256', name: 'borrowAmount', type: 'uint256' },
            ],
            name: 'getHypotheticalAccountLiquidity',
            outputs: [
              { internalType: 'uint256', name: '', type: 'uint256' },
              { internalType: 'uint256', name: '', type: 'uint256' },
              { internalType: 'uint256', name: '', type: 'uint256' },
            ],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'isComptroller',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [{ internalType: 'contract CToken', name: 'cToken', type: 'address' }],
            name: 'isDeprecated',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [{ internalType: 'address', name: '', type: 'address' }],
            name: 'lastContributorBlock',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { internalType: 'address', name: 'cTokenBorrowed', type: 'address' },
              { internalType: 'address', name: 'cTokenCollateral', type: 'address' },
              { internalType: 'address', name: 'liquidator', type: 'address' },
              { internalType: 'address', name: 'borrower', type: 'address' },
              { internalType: 'uint256', name: 'repayAmount', type: 'uint256' },
            ],
            name: 'liquidateBorrowAllowed',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { internalType: 'address', name: 'cTokenBorrowed', type: 'address' },
              { internalType: 'address', name: 'cTokenCollateral', type: 'address' },
              { internalType: 'address', name: 'liquidator', type: 'address' },
              { internalType: 'address', name: 'borrower', type: 'address' },
              { internalType: 'uint256', name: 'actualRepayAmount', type: 'uint256' },
              { internalType: 'uint256', name: 'seizeTokens', type: 'uint256' },
            ],
            name: 'liquidateBorrowVerify',
            outputs: [],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [
              { internalType: 'address', name: 'cTokenBorrowed', type: 'address' },
              { internalType: 'address', name: 'cTokenCollateral', type: 'address' },
              { internalType: 'uint256', name: 'actualRepayAmount', type: 'uint256' },
            ],
            name: 'liquidateCalculateSeizeTokens',
            outputs: [
              { internalType: 'uint256', name: '', type: 'uint256' },
              { internalType: 'uint256', name: '', type: 'uint256' },
            ],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'liquidationIncentiveMantissa',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [{ internalType: 'address', name: '', type: 'address' }],
            name: 'markets',
            outputs: [
              { internalType: 'bool', name: 'isListed', type: 'bool' },
              { internalType: 'uint256', name: 'collateralFactorMantissa', type: 'uint256' },
              { internalType: 'bool', name: 'isComped', type: 'bool' },
            ],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'maxAssets',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { internalType: 'address', name: 'cToken', type: 'address' },
              { internalType: 'address', name: 'minter', type: 'address' },
              { internalType: 'uint256', name: 'mintAmount', type: 'uint256' },
            ],
            name: 'mintAllowed',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [{ internalType: 'address', name: '', type: 'address' }],
            name: 'mintGuardianPaused',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { internalType: 'address', name: 'cToken', type: 'address' },
              { internalType: 'address', name: 'minter', type: 'address' },
              { internalType: 'uint256', name: 'actualMintAmount', type: 'uint256' },
              { internalType: 'uint256', name: 'mintTokens', type: 'uint256' },
            ],
            name: 'mintVerify',
            outputs: [],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'oracle',
            outputs: [{ internalType: 'contract PriceOracle', name: '', type: 'address' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'pauseGuardian',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'pendingAdmin',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'pendingComptrollerImplementation',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'proposal65FixExecuted',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { internalType: 'address', name: 'cToken', type: 'address' },
              { internalType: 'address', name: 'redeemer', type: 'address' },
              { internalType: 'uint256', name: 'redeemTokens', type: 'uint256' },
            ],
            name: 'redeemAllowed',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { internalType: 'address', name: 'cToken', type: 'address' },
              { internalType: 'address', name: 'redeemer', type: 'address' },
              { internalType: 'uint256', name: 'redeemAmount', type: 'uint256' },
              { internalType: 'uint256', name: 'redeemTokens', type: 'uint256' },
            ],
            name: 'redeemVerify',
            outputs: [],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { internalType: 'address', name: 'cToken', type: 'address' },
              { internalType: 'address', name: 'payer', type: 'address' },
              { internalType: 'address', name: 'borrower', type: 'address' },
              { internalType: 'uint256', name: 'repayAmount', type: 'uint256' },
            ],
            name: 'repayBorrowAllowed',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { internalType: 'address', name: 'cToken', type: 'address' },
              { internalType: 'address', name: 'payer', type: 'address' },
              { internalType: 'address', name: 'borrower', type: 'address' },
              { internalType: 'uint256', name: 'actualRepayAmount', type: 'uint256' },
              { internalType: 'uint256', name: 'borrowerIndex', type: 'uint256' },
            ],
            name: 'repayBorrowVerify',
            outputs: [],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { internalType: 'address', name: 'cTokenCollateral', type: 'address' },
              { internalType: 'address', name: 'cTokenBorrowed', type: 'address' },
              { internalType: 'address', name: 'liquidator', type: 'address' },
              { internalType: 'address', name: 'borrower', type: 'address' },
              { internalType: 'uint256', name: 'seizeTokens', type: 'uint256' },
            ],
            name: 'seizeAllowed',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'seizeGuardianPaused',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { internalType: 'address', name: 'cTokenCollateral', type: 'address' },
              { internalType: 'address', name: 'cTokenBorrowed', type: 'address' },
              { internalType: 'address', name: 'liquidator', type: 'address' },
              { internalType: 'address', name: 'borrower', type: 'address' },
              { internalType: 'uint256', name: 'seizeTokens', type: 'uint256' },
            ],
            name: 'seizeVerify',
            outputs: [],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { internalType: 'address', name: 'cToken', type: 'address' },
              { internalType: 'address', name: 'src', type: 'address' },
              { internalType: 'address', name: 'dst', type: 'address' },
              { internalType: 'uint256', name: 'transferTokens', type: 'uint256' },
            ],
            name: 'transferAllowed',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'transferGuardianPaused',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { internalType: 'address', name: 'cToken', type: 'address' },
              { internalType: 'address', name: 'src', type: 'address' },
              { internalType: 'address', name: 'dst', type: 'address' },
              { internalType: 'uint256', name: 'transferTokens', type: 'uint256' },
            ],
            name: 'transferVerify',
            outputs: [],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ internalType: 'address', name: 'contributor', type: 'address' }],
            name: 'updateContributorRewards',
            outputs: [],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
        ]),
        (t.crossChainCErc20Abi = [
          {
            constant: !0,
            inputs: [],
            name: 'name',
            outputs: [{ name: '', type: 'string' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { name: 'spender', type: 'address' },
              { name: 'amount', type: 'uint256' },
            ],
            name: 'approve',
            outputs: [{ name: '', type: 'bool' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ name: 'repayAmount', type: 'uint256' }],
            name: 'repayBorrow',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'reserveFactorMantissa',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ name: 'account', type: 'address' }],
            name: 'borrowBalanceCurrent',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'totalSupply',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'exchangeRateStored',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { name: 'src', type: 'address' },
              { name: 'dst', type: 'address' },
              { name: 'amount', type: 'uint256' },
            ],
            name: 'transferFrom',
            outputs: [{ name: '', type: 'bool' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { name: 'borrower', type: 'address' },
              { name: 'repayAmount', type: 'uint256' },
            ],
            name: 'repayBorrowBehalf',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'pendingAdmin',
            outputs: [{ name: '', type: 'address' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'decimals',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ name: 'owner', type: 'address' }],
            name: 'balanceOfUnderlying',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'getCash',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ name: 'newComptroller', type: 'address' }],
            name: '_setComptroller',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'totalBorrows',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'comptroller',
            outputs: [{ name: '', type: 'address' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ name: 'reduceAmount', type: 'uint256' }],
            name: '_reduceReserves',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'initialExchangeRateMantissa',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'underlying',
            outputs: [{ name: '', type: 'address' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [{ name: 'owner', type: 'address' }],
            name: 'balanceOf',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [],
            name: 'totalBorrowsCurrent',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ name: 'redeemAmount', type: 'uint256' }],
            name: 'redeemUnderlying',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'totalReserves',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'symbol',
            outputs: [{ name: '', type: 'string' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [{ name: 'account', type: 'address' }],
            name: 'borrowBalanceStored',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ name: 'mintAmount', type: 'uint256' }],
            name: 'mint',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [],
            name: 'accrueInterest',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { name: 'dst', type: 'address' },
              { name: 'amount', type: 'uint256' },
            ],
            name: 'transfer',
            outputs: [{ name: '', type: 'bool' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'borrowIndex',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { name: 'liquidator', type: 'address' },
              { name: 'borrower', type: 'address' },
              { name: 'seizeTokens', type: 'uint256' },
            ],
            name: 'seize',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ name: 'newPendingAdmin', type: 'address' }],
            name: '_setPendingAdmin',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [],
            name: 'exchangeRateCurrent',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [{ name: 'account', type: 'address' }],
            name: 'getAccountSnapshot',
            outputs: [
              { name: '', type: 'uint256' },
              { name: '', type: 'uint256' },
              { name: '', type: 'uint256' },
              { name: '', type: 'uint256' },
            ],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ name: 'borrowAmount', type: 'uint256' }],
            name: 'borrow',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ name: 'redeemTokens', type: 'uint256' }],
            name: 'redeem',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [
              { name: 'owner', type: 'address' },
              { name: 'spender', type: 'address' },
            ],
            name: 'allowance',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [],
            name: '_acceptAdmin',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ name: 'newInterestRateModel', type: 'address' }],
            name: '_setInterestRateModel',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'interestRateModel',
            outputs: [{ name: '', type: 'address' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { name: 'borrower', type: 'address' },
              { name: 'repayAmount', type: 'uint256' },
              { name: 'cTokenCollateral', type: 'address' },
            ],
            name: 'liquidateBorrow',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'admin',
            outputs: [{ name: '', type: 'address' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ name: 'newReserveFactorMantissa', type: 'uint256' }],
            name: '_setReserveFactor',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'isCToken',
            outputs: [{ name: '', type: 'bool' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { name: 'underlying_', type: 'address' },
              { name: 'comptroller_', type: 'address' },
              { name: 'interestRateModel_', type: 'address' },
              { name: 'initialExchangeRateMantissa_', type: 'uint256' },
              { name: 'name_', type: 'string' },
              { name: 'symbol_', type: 'string' },
              { name: 'decimals_', type: 'uint256' },
            ],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'constructor',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, name: 'interestAccumulated', type: 'uint256' },
              { indexed: !1, name: 'borrowIndex', type: 'uint256' },
              { indexed: !1, name: 'totalBorrows', type: 'uint256' },
            ],
            name: 'AccrueInterest',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, name: 'minter', type: 'address' },
              { indexed: !1, name: 'mintAmount', type: 'uint256' },
              { indexed: !1, name: 'mintTokens', type: 'uint256' },
            ],
            name: 'Mint',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, name: 'redeemer', type: 'address' },
              { indexed: !1, name: 'redeemAmount', type: 'uint256' },
              { indexed: !1, name: 'redeemTokens', type: 'uint256' },
            ],
            name: 'Redeem',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, name: 'borrower', type: 'address' },
              { indexed: !1, name: 'borrowAmount', type: 'uint256' },
              { indexed: !1, name: 'accountBorrows', type: 'uint256' },
              { indexed: !1, name: 'totalBorrows', type: 'uint256' },
            ],
            name: 'Borrow',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, name: 'payer', type: 'address' },
              { indexed: !1, name: 'borrower', type: 'address' },
              { indexed: !1, name: 'repayAmount', type: 'uint256' },
              { indexed: !1, name: 'accountBorrows', type: 'uint256' },
              { indexed: !1, name: 'totalBorrows', type: 'uint256' },
            ],
            name: 'RepayBorrow',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, name: 'liquidator', type: 'address' },
              { indexed: !1, name: 'borrower', type: 'address' },
              { indexed: !1, name: 'repayAmount', type: 'uint256' },
              { indexed: !1, name: 'cTokenCollateral', type: 'address' },
              { indexed: !1, name: 'seizeTokens', type: 'uint256' },
            ],
            name: 'LiquidateBorrow',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, name: 'oldPendingAdmin', type: 'address' },
              { indexed: !1, name: 'newPendingAdmin', type: 'address' },
            ],
            name: 'NewPendingAdmin',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, name: 'oldAdmin', type: 'address' },
              { indexed: !1, name: 'newAdmin', type: 'address' },
            ],
            name: 'NewAdmin',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, name: 'oldComptroller', type: 'address' },
              { indexed: !1, name: 'newComptroller', type: 'address' },
            ],
            name: 'NewComptroller',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, name: 'oldInterestRateModel', type: 'address' },
              { indexed: !1, name: 'newInterestRateModel', type: 'address' },
            ],
            name: 'NewMarketInterestRateModel',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, name: 'oldReserveFactorMantissa', type: 'uint256' },
              { indexed: !1, name: 'newReserveFactorMantissa', type: 'uint256' },
            ],
            name: 'NewReserveFactor',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, name: 'admin', type: 'address' },
              { indexed: !1, name: 'reduceAmount', type: 'uint256' },
              { indexed: !1, name: 'newTotalReserves', type: 'uint256' },
            ],
            name: 'ReservesReduced',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, name: 'error', type: 'uint256' },
              { indexed: !1, name: 'info', type: 'uint256' },
              { indexed: !1, name: 'detail', type: 'uint256' },
            ],
            name: 'Failure',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, name: 'from', type: 'address' },
              { indexed: !0, name: 'to', type: 'address' },
              { indexed: !1, name: 'amount', type: 'uint256' },
            ],
            name: 'Transfer',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, name: 'owner', type: 'address' },
              { indexed: !0, name: 'spender', type: 'address' },
              { indexed: !1, name: 'amount', type: 'uint256' },
            ],
            name: 'Approval',
            type: 'event',
          },
        ]),
        (t.cEtherAbi = [
          {
            constant: !0,
            inputs: [],
            name: 'name',
            outputs: [{ name: '', type: 'string' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { name: 'spender', type: 'address' },
              { name: 'amount', type: 'uint256' },
            ],
            name: 'approve',
            outputs: [{ name: '', type: 'bool' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [],
            name: 'mint',
            outputs: [],
            payable: !0,
            stateMutability: 'payable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'reserveFactorMantissa',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ name: 'account', type: 'address' }],
            name: 'borrowBalanceCurrent',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'totalSupply',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'exchangeRateStored',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { name: 'src', type: 'address' },
              { name: 'dst', type: 'address' },
              { name: 'amount', type: 'uint256' },
            ],
            name: 'transferFrom',
            outputs: [{ name: '', type: 'bool' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'pendingAdmin',
            outputs: [{ name: '', type: 'address' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'decimals',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ name: 'owner', type: 'address' }],
            name: 'balanceOfUnderlying',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'getCash',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ name: 'newComptroller', type: 'address' }],
            name: '_setComptroller',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'totalBorrows',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [],
            name: 'repayBorrow',
            outputs: [],
            payable: !0,
            stateMutability: 'payable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'comptroller',
            outputs: [{ name: '', type: 'address' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ name: 'reduceAmount', type: 'uint256' }],
            name: '_reduceReserves',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'initialExchangeRateMantissa',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'accrualBlockNumber',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [{ name: 'owner', type: 'address' }],
            name: 'balanceOf',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [],
            name: 'totalBorrowsCurrent',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ name: 'redeemAmount', type: 'uint256' }],
            name: 'redeemUnderlying',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'totalReserves',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'symbol',
            outputs: [{ name: '', type: 'string' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [{ name: 'account', type: 'address' }],
            name: 'borrowBalanceStored',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [],
            name: 'accrueInterest',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { name: 'dst', type: 'address' },
              { name: 'amount', type: 'uint256' },
            ],
            name: 'transfer',
            outputs: [{ name: '', type: 'bool' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'borrowIndex',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { name: 'borrower', type: 'address' },
              { name: 'cTokenCollateral', type: 'address' },
            ],
            name: 'liquidateBorrow',
            outputs: [],
            payable: !0,
            stateMutability: 'payable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'supplyRatePerBlock',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [
              { name: 'liquidator', type: 'address' },
              { name: 'borrower', type: 'address' },
              { name: 'seizeTokens', type: 'uint256' },
            ],
            name: 'seize',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ name: 'newPendingAdmin', type: 'address' }],
            name: '_setPendingAdmin',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [],
            name: 'exchangeRateCurrent',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [{ name: 'account', type: 'address' }],
            name: 'getAccountSnapshot',
            outputs: [
              { name: '', type: 'uint256' },
              { name: '', type: 'uint256' },
              { name: '', type: 'uint256' },
              { name: '', type: 'uint256' },
            ],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ name: 'borrowAmount', type: 'uint256' }],
            name: 'borrow',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ name: 'redeemTokens', type: 'uint256' }],
            name: 'redeem',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [
              { name: 'owner', type: 'address' },
              { name: 'spender', type: 'address' },
            ],
            name: 'allowance',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ name: 'borrower', type: 'address' }],
            name: 'repayBorrowBehalf',
            outputs: [],
            payable: !0,
            stateMutability: 'payable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [],
            name: '_acceptAdmin',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ name: 'newInterestRateModel', type: 'address' }],
            name: '_setInterestRateModel',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'interestRateModel',
            outputs: [{ name: '', type: 'address' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'admin',
            outputs: [{ name: '', type: 'address' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'borrowRatePerBlock',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !1,
            inputs: [{ name: 'newReserveFactorMantissa', type: 'uint256' }],
            name: '_setReserveFactor',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'isCToken',
            outputs: [{ name: '', type: 'bool' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { name: 'comptroller_', type: 'address' },
              { name: 'interestRateModel_', type: 'address' },
              { name: 'initialExchangeRateMantissa_', type: 'uint256' },
              { name: 'name_', type: 'string' },
              { name: 'symbol_', type: 'string' },
              { name: 'decimals_', type: 'uint256' },
            ],
            payable: !1,
            stateMutability: 'nonpayable',
            type: 'constructor',
          },
          { payable: !0, stateMutability: 'payable', type: 'fallback' },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, name: 'interestAccumulated', type: 'uint256' },
              { indexed: !1, name: 'borrowIndex', type: 'uint256' },
              { indexed: !1, name: 'totalBorrows', type: 'uint256' },
            ],
            name: 'AccrueInterest',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, name: 'minter', type: 'address' },
              { indexed: !1, name: 'mintAmount', type: 'uint256' },
              { indexed: !1, name: 'mintTokens', type: 'uint256' },
            ],
            name: 'Mint',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, name: 'redeemer', type: 'address' },
              { indexed: !1, name: 'redeemAmount', type: 'uint256' },
              { indexed: !1, name: 'redeemTokens', type: 'uint256' },
            ],
            name: 'Redeem',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, name: 'borrower', type: 'address' },
              { indexed: !1, name: 'borrowAmount', type: 'uint256' },
              { indexed: !1, name: 'accountBorrows', type: 'uint256' },
              { indexed: !1, name: 'totalBorrows', type: 'uint256' },
            ],
            name: 'Borrow',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, name: 'payer', type: 'address' },
              { indexed: !1, name: 'borrower', type: 'address' },
              { indexed: !1, name: 'repayAmount', type: 'uint256' },
              { indexed: !1, name: 'accountBorrows', type: 'uint256' },
              { indexed: !1, name: 'totalBorrows', type: 'uint256' },
            ],
            name: 'RepayBorrow',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, name: 'liquidator', type: 'address' },
              { indexed: !1, name: 'borrower', type: 'address' },
              { indexed: !1, name: 'repayAmount', type: 'uint256' },
              { indexed: !1, name: 'cTokenCollateral', type: 'address' },
              { indexed: !1, name: 'seizeTokens', type: 'uint256' },
            ],
            name: 'LiquidateBorrow',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, name: 'oldPendingAdmin', type: 'address' },
              { indexed: !1, name: 'newPendingAdmin', type: 'address' },
            ],
            name: 'NewPendingAdmin',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, name: 'oldAdmin', type: 'address' },
              { indexed: !1, name: 'newAdmin', type: 'address' },
            ],
            name: 'NewAdmin',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, name: 'oldComptroller', type: 'address' },
              { indexed: !1, name: 'newComptroller', type: 'address' },
            ],
            name: 'NewComptroller',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, name: 'oldInterestRateModel', type: 'address' },
              { indexed: !1, name: 'newInterestRateModel', type: 'address' },
            ],
            name: 'NewMarketInterestRateModel',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, name: 'oldReserveFactorMantissa', type: 'uint256' },
              { indexed: !1, name: 'newReserveFactorMantissa', type: 'uint256' },
            ],
            name: 'NewReserveFactor',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, name: 'admin', type: 'address' },
              { indexed: !1, name: 'reduceAmount', type: 'uint256' },
              { indexed: !1, name: 'newTotalReserves', type: 'uint256' },
            ],
            name: 'ReservesReduced',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, name: 'error', type: 'uint256' },
              { indexed: !1, name: 'info', type: 'uint256' },
              { indexed: !1, name: 'detail', type: 'uint256' },
            ],
            name: 'Failure',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, name: 'from', type: 'address' },
              { indexed: !0, name: 'to', type: 'address' },
              { indexed: !1, name: 'amount', type: 'uint256' },
            ],
            name: 'Transfer',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, name: 'owner', type: 'address' },
              { indexed: !0, name: 'spender', type: 'address' },
              { indexed: !1, name: 'amount', type: 'uint256' },
            ],
            name: 'Approval',
            type: 'event',
          },
        ]),
        (t.cErc20Abi = [
          ...t.crossChainCErc20Abi,
          {
            constant: !0,
            inputs: [],
            name: 'accrualBlockNumber',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'supplyRatePerBlock',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
          {
            constant: !0,
            inputs: [],
            name: 'borrowRatePerBlock',
            outputs: [{ name: '', type: 'uint256' }],
            payable: !1,
            stateMutability: 'view',
            type: 'function',
          },
        ]),
        (t.mErc20Abi = [
          ...t.crossChainCErc20Abi,
          {
            inputs: [],
            name: 'accrualBlockTimestamp',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'supplyRatePerTimestamp',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'borrowRatePerTimestamp',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
        ]);
    },
    35727: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.configuratorAbi = t.cometExtAbi = t.cometAbi = void 0),
        (t.cometAbi = [
          {
            inputs: [
              {
                components: [
                  { internalType: 'address', name: 'governor', type: 'address' },
                  { internalType: 'address', name: 'pauseGuardian', type: 'address' },
                  { internalType: 'address', name: 'baseToken', type: 'address' },
                  { internalType: 'address', name: 'baseTokenPriceFeed', type: 'address' },
                  { internalType: 'address', name: 'extensionDelegate', type: 'address' },
                  { internalType: 'uint64', name: 'supplyKink', type: 'uint64' },
                  {
                    internalType: 'uint64',
                    name: 'supplyPerYearInterestRateSlopeLow',
                    type: 'uint64',
                  },
                  {
                    internalType: 'uint64',
                    name: 'supplyPerYearInterestRateSlopeHigh',
                    type: 'uint64',
                  },
                  { internalType: 'uint64', name: 'supplyPerYearInterestRateBase', type: 'uint64' },
                  { internalType: 'uint64', name: 'borrowKink', type: 'uint64' },
                  {
                    internalType: 'uint64',
                    name: 'borrowPerYearInterestRateSlopeLow',
                    type: 'uint64',
                  },
                  {
                    internalType: 'uint64',
                    name: 'borrowPerYearInterestRateSlopeHigh',
                    type: 'uint64',
                  },
                  { internalType: 'uint64', name: 'borrowPerYearInterestRateBase', type: 'uint64' },
                  { internalType: 'uint64', name: 'storeFrontPriceFactor', type: 'uint64' },
                  { internalType: 'uint64', name: 'trackingIndexScale', type: 'uint64' },
                  { internalType: 'uint64', name: 'baseTrackingSupplySpeed', type: 'uint64' },
                  { internalType: 'uint64', name: 'baseTrackingBorrowSpeed', type: 'uint64' },
                  { internalType: 'uint104', name: 'baseMinForRewards', type: 'uint104' },
                  { internalType: 'uint104', name: 'baseBorrowMin', type: 'uint104' },
                  { internalType: 'uint104', name: 'targetReserves', type: 'uint104' },
                  {
                    components: [
                      { internalType: 'address', name: 'asset', type: 'address' },
                      { internalType: 'address', name: 'priceFeed', type: 'address' },
                      { internalType: 'uint8', name: 'decimals', type: 'uint8' },
                      { internalType: 'uint64', name: 'borrowCollateralFactor', type: 'uint64' },
                      { internalType: 'uint64', name: 'liquidateCollateralFactor', type: 'uint64' },
                      { internalType: 'uint64', name: 'liquidationFactor', type: 'uint64' },
                      { internalType: 'uint128', name: 'supplyCap', type: 'uint128' },
                    ],
                    internalType: 'struct CometConfiguration.AssetConfig[]',
                    name: 'assetConfigs',
                    type: 'tuple[]',
                  },
                ],
                internalType: 'struct CometConfiguration.Configuration',
                name: 'config',
                type: 'tuple',
              },
            ],
            stateMutability: 'nonpayable',
            type: 'constructor',
          },
          { inputs: [], name: 'Absurd', type: 'error' },
          { inputs: [], name: 'AlreadyInitialized', type: 'error' },
          { inputs: [], name: 'BadAsset', type: 'error' },
          { inputs: [], name: 'BadDecimals', type: 'error' },
          { inputs: [], name: 'BadDiscount', type: 'error' },
          { inputs: [], name: 'BadMinimum', type: 'error' },
          { inputs: [], name: 'BadPrice', type: 'error' },
          { inputs: [], name: 'BorrowCFTooLarge', type: 'error' },
          { inputs: [], name: 'BorrowTooSmall', type: 'error' },
          { inputs: [], name: 'InsufficientReserves', type: 'error' },
          { inputs: [], name: 'InvalidInt104', type: 'error' },
          { inputs: [], name: 'InvalidInt256', type: 'error' },
          { inputs: [], name: 'InvalidUInt104', type: 'error' },
          { inputs: [], name: 'InvalidUInt128', type: 'error' },
          { inputs: [], name: 'InvalidUInt64', type: 'error' },
          { inputs: [], name: 'LiquidateCFTooLarge', type: 'error' },
          { inputs: [], name: 'NegativeNumber', type: 'error' },
          { inputs: [], name: 'NoSelfTransfer', type: 'error' },
          { inputs: [], name: 'NotCollateralized', type: 'error' },
          { inputs: [], name: 'NotForSale', type: 'error' },
          { inputs: [], name: 'NotLiquidatable', type: 'error' },
          { inputs: [], name: 'Paused', type: 'error' },
          { inputs: [], name: 'SupplyCapExceeded', type: 'error' },
          { inputs: [], name: 'TimestampTooLarge', type: 'error' },
          { inputs: [], name: 'TooManyAssets', type: 'error' },
          { inputs: [], name: 'TooMuchSlippage', type: 'error' },
          { inputs: [], name: 'TransferInFailed', type: 'error' },
          { inputs: [], name: 'TransferOutFailed', type: 'error' },
          { inputs: [], name: 'Unauthorized', type: 'error' },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'absorber', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'borrower', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'asset', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'collateralAbsorbed', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'usdValue', type: 'uint256' },
            ],
            name: 'AbsorbCollateral',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'absorber', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'borrower', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'basePaidOut', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'usdValue', type: 'uint256' },
            ],
            name: 'AbsorbDebt',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'buyer', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'asset', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'baseAmount', type: 'uint256' },
              { indexed: !1, internalType: 'uint256', name: 'collateralAmount', type: 'uint256' },
            ],
            name: 'BuyCollateral',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !1, internalType: 'bool', name: 'supplyPaused', type: 'bool' },
              { indexed: !1, internalType: 'bool', name: 'transferPaused', type: 'bool' },
              { indexed: !1, internalType: 'bool', name: 'withdrawPaused', type: 'bool' },
              { indexed: !1, internalType: 'bool', name: 'absorbPaused', type: 'bool' },
              { indexed: !1, internalType: 'bool', name: 'buyPaused', type: 'bool' },
            ],
            name: 'PauseAction',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'from', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'dst', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'Supply',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'from', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'dst', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'asset', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'SupplyCollateral',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'from', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'to', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'Transfer',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'from', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'to', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'asset', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'TransferCollateral',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'src', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'to', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'Withdraw',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'src', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'to', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'asset', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'WithdrawCollateral',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'to', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'WithdrawReserves',
            type: 'event',
          },
          { stateMutability: 'payable', type: 'fallback' },
          {
            inputs: [
              { internalType: 'address', name: 'absorber', type: 'address' },
              { internalType: 'address[]', name: 'accounts', type: 'address[]' },
            ],
            name: 'absorb',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'account', type: 'address' }],
            name: 'accrueAccount',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'manager', type: 'address' },
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'approveThis',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'account', type: 'address' }],
            name: 'balanceOf',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'baseBorrowMin',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'baseMinForRewards',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'baseScale',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'baseToken',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'baseTokenPriceFeed',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'baseTrackingBorrowSpeed',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'baseTrackingSupplySpeed',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'account', type: 'address' }],
            name: 'borrowBalanceOf',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'borrowKink',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'borrowPerSecondInterestRateBase',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'borrowPerSecondInterestRateSlopeHigh',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'borrowPerSecondInterestRateSlopeLow',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'uint256', name: 'minAmount', type: 'uint256' },
              { internalType: 'uint256', name: 'baseAmount', type: 'uint256' },
              { internalType: 'address', name: 'recipient', type: 'address' },
            ],
            name: 'buyCollateral',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [],
            name: 'decimals',
            outputs: [{ internalType: 'uint8', name: '', type: 'uint8' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'extensionDelegate',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'uint8', name: 'i', type: 'uint8' }],
            name: 'getAssetInfo',
            outputs: [
              {
                components: [
                  { internalType: 'uint8', name: 'offset', type: 'uint8' },
                  { internalType: 'address', name: 'asset', type: 'address' },
                  { internalType: 'address', name: 'priceFeed', type: 'address' },
                  { internalType: 'uint64', name: 'scale', type: 'uint64' },
                  { internalType: 'uint64', name: 'borrowCollateralFactor', type: 'uint64' },
                  { internalType: 'uint64', name: 'liquidateCollateralFactor', type: 'uint64' },
                  { internalType: 'uint64', name: 'liquidationFactor', type: 'uint64' },
                  { internalType: 'uint128', name: 'supplyCap', type: 'uint128' },
                ],
                internalType: 'struct CometCore.AssetInfo',
                name: '',
                type: 'tuple',
              },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getAssetInfoByAddress',
            outputs: [
              {
                components: [
                  { internalType: 'uint8', name: 'offset', type: 'uint8' },
                  { internalType: 'address', name: 'asset', type: 'address' },
                  { internalType: 'address', name: 'priceFeed', type: 'address' },
                  { internalType: 'uint64', name: 'scale', type: 'uint64' },
                  { internalType: 'uint64', name: 'borrowCollateralFactor', type: 'uint64' },
                  { internalType: 'uint64', name: 'liquidateCollateralFactor', type: 'uint64' },
                  { internalType: 'uint64', name: 'liquidationFactor', type: 'uint64' },
                  { internalType: 'uint128', name: 'supplyCap', type: 'uint128' },
                ],
                internalType: 'struct CometCore.AssetInfo',
                name: '',
                type: 'tuple',
              },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'uint256', name: 'utilization', type: 'uint256' }],
            name: 'getBorrowRate',
            outputs: [{ internalType: 'uint64', name: '', type: 'uint64' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'asset', type: 'address' }],
            name: 'getCollateralReserves',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'priceFeed', type: 'address' }],
            name: 'getPrice',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getReserves',
            outputs: [{ internalType: 'int256', name: '', type: 'int256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'uint256', name: 'utilization', type: 'uint256' }],
            name: 'getSupplyRate',
            outputs: [{ internalType: 'uint64', name: '', type: 'uint64' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'getUtilization',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'governor',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'owner', type: 'address' },
              { internalType: 'address', name: 'manager', type: 'address' },
            ],
            name: 'hasPermission',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'initializeStorage',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [],
            name: 'isAbsorbPaused',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: '', type: 'address' },
              { internalType: 'address', name: '', type: 'address' },
            ],
            name: 'isAllowed',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'account', type: 'address' }],
            name: 'isBorrowCollateralized',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'isBuyPaused',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'account', type: 'address' }],
            name: 'isLiquidatable',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'isSupplyPaused',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'isTransferPaused',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'isWithdrawPaused',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: '', type: 'address' }],
            name: 'liquidatorPoints',
            outputs: [
              { internalType: 'uint32', name: 'numAbsorbs', type: 'uint32' },
              { internalType: 'uint64', name: 'numAbsorbed', type: 'uint64' },
              { internalType: 'uint128', name: 'approxSpend', type: 'uint128' },
              { internalType: 'uint32', name: '_reserved', type: 'uint32' },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'numAssets',
            outputs: [{ internalType: 'uint8', name: '', type: 'uint8' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'bool', name: 'supplyPaused', type: 'bool' },
              { internalType: 'bool', name: 'transferPaused', type: 'bool' },
              { internalType: 'bool', name: 'withdrawPaused', type: 'bool' },
              { internalType: 'bool', name: 'absorbPaused', type: 'bool' },
              { internalType: 'bool', name: 'buyPaused', type: 'bool' },
            ],
            name: 'pause',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [],
            name: 'pauseGuardian',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'uint256', name: 'baseAmount', type: 'uint256' },
            ],
            name: 'quoteCollateral',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'storeFrontPriceFactor',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'supply',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'from', type: 'address' },
              { internalType: 'address', name: 'dst', type: 'address' },
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'supplyFrom',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [],
            name: 'supplyKink',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'supplyPerSecondInterestRateBase',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'supplyPerSecondInterestRateSlopeHigh',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'supplyPerSecondInterestRateSlopeLow',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'dst', type: 'address' },
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'supplyTo',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [],
            name: 'targetReserves',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'totalBorrow',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'totalSupply',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: '', type: 'address' }],
            name: 'totalsCollateral',
            outputs: [
              { internalType: 'uint128', name: 'totalSupplyAsset', type: 'uint128' },
              { internalType: 'uint128', name: '_reserved', type: 'uint128' },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'trackingIndexScale',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'dst', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'transfer',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'dst', type: 'address' },
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'transferAsset',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'src', type: 'address' },
              { internalType: 'address', name: 'dst', type: 'address' },
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'transferAssetFrom',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'src', type: 'address' },
              { internalType: 'address', name: 'dst', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'transferFrom',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: '', type: 'address' }],
            name: 'userBasic',
            outputs: [
              { internalType: 'int104', name: 'principal', type: 'int104' },
              { internalType: 'uint64', name: 'baseTrackingIndex', type: 'uint64' },
              { internalType: 'uint64', name: 'baseTrackingAccrued', type: 'uint64' },
              { internalType: 'uint16', name: 'assetsIn', type: 'uint16' },
              { internalType: 'uint8', name: '_reserved', type: 'uint8' },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: '', type: 'address' },
              { internalType: 'address', name: '', type: 'address' },
            ],
            name: 'userCollateral',
            outputs: [
              { internalType: 'uint128', name: 'balance', type: 'uint128' },
              { internalType: 'uint128', name: '_reserved', type: 'uint128' },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: '', type: 'address' }],
            name: 'userNonce',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'withdraw',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'src', type: 'address' },
              { internalType: 'address', name: 'to', type: 'address' },
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'withdrawFrom',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'to', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'withdrawReserves',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'to', type: 'address' },
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'withdrawTo',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
        ]),
        (t.cometExtAbi = [
          {
            inputs: [
              {
                components: [
                  { internalType: 'bytes32', name: 'name32', type: 'bytes32' },
                  { internalType: 'bytes32', name: 'symbol32', type: 'bytes32' },
                ],
                internalType: 'struct CometConfiguration.ExtConfiguration',
                name: 'config',
                type: 'tuple',
              },
            ],
            stateMutability: 'nonpayable',
            type: 'constructor',
          },
          { inputs: [], name: 'BadAmount', type: 'error' },
          { inputs: [], name: 'BadNonce', type: 'error' },
          { inputs: [], name: 'BadSignatory', type: 'error' },
          { inputs: [], name: 'InvalidInt104', type: 'error' },
          { inputs: [], name: 'InvalidInt256', type: 'error' },
          { inputs: [], name: 'InvalidUInt104', type: 'error' },
          { inputs: [], name: 'InvalidUInt128', type: 'error' },
          { inputs: [], name: 'InvalidUInt64', type: 'error' },
          { inputs: [], name: 'InvalidValueS', type: 'error' },
          { inputs: [], name: 'InvalidValueV', type: 'error' },
          { inputs: [], name: 'NegativeNumber', type: 'error' },
          { inputs: [], name: 'SignatureExpired', type: 'error' },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'owner', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'spender', type: 'address' },
              { indexed: !1, internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'Approval',
            type: 'event',
          },
          {
            inputs: [
              { internalType: 'address', name: 'manager', type: 'address' },
              { internalType: 'bool', name: 'isAllowed_', type: 'bool' },
            ],
            name: 'allow',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'owner', type: 'address' },
              { internalType: 'address', name: 'manager', type: 'address' },
              { internalType: 'bool', name: 'isAllowed_', type: 'bool' },
              { internalType: 'uint256', name: 'nonce', type: 'uint256' },
              { internalType: 'uint256', name: 'expiry', type: 'uint256' },
              { internalType: 'uint8', name: 'v', type: 'uint8' },
              { internalType: 'bytes32', name: 'r', type: 'bytes32' },
              { internalType: 'bytes32', name: 's', type: 'bytes32' },
            ],
            name: 'allowBySig',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'owner', type: 'address' },
              { internalType: 'address', name: 'spender', type: 'address' },
            ],
            name: 'allowance',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'spender', type: 'address' },
              { internalType: 'uint256', name: 'amount', type: 'uint256' },
            ],
            name: 'approve',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [],
            name: 'baseAccrualScale',
            outputs: [{ internalType: 'uint64', name: '', type: 'uint64' }],
            stateMutability: 'pure',
            type: 'function',
          },
          {
            inputs: [],
            name: 'baseIndexScale',
            outputs: [{ internalType: 'uint64', name: '', type: 'uint64' }],
            stateMutability: 'pure',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'account', type: 'address' }],
            name: 'baseTrackingAccrued',
            outputs: [{ internalType: 'uint64', name: '', type: 'uint64' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'account', type: 'address' },
              { internalType: 'address', name: 'asset', type: 'address' },
            ],
            name: 'collateralBalanceOf',
            outputs: [{ internalType: 'uint128', name: '', type: 'uint128' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'factorScale',
            outputs: [{ internalType: 'uint64', name: '', type: 'uint64' }],
            stateMutability: 'pure',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'owner', type: 'address' },
              { internalType: 'address', name: 'manager', type: 'address' },
            ],
            name: 'hasPermission',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: '', type: 'address' },
              { internalType: 'address', name: '', type: 'address' },
            ],
            name: 'isAllowed',
            outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: '', type: 'address' }],
            name: 'liquidatorPoints',
            outputs: [
              { internalType: 'uint32', name: 'numAbsorbs', type: 'uint32' },
              { internalType: 'uint64', name: 'numAbsorbed', type: 'uint64' },
              { internalType: 'uint128', name: 'approxSpend', type: 'uint128' },
              { internalType: 'uint32', name: '_reserved', type: 'uint32' },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'maxAssets',
            outputs: [{ internalType: 'uint8', name: '', type: 'uint8' }],
            stateMutability: 'pure',
            type: 'function',
          },
          {
            inputs: [],
            name: 'name',
            outputs: [{ internalType: 'string', name: '', type: 'string' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'priceScale',
            outputs: [{ internalType: 'uint64', name: '', type: 'uint64' }],
            stateMutability: 'pure',
            type: 'function',
          },
          {
            inputs: [],
            name: 'symbol',
            outputs: [{ internalType: 'string', name: '', type: 'string' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'totalsBasic',
            outputs: [
              {
                components: [
                  { internalType: 'uint64', name: 'baseSupplyIndex', type: 'uint64' },
                  { internalType: 'uint64', name: 'baseBorrowIndex', type: 'uint64' },
                  { internalType: 'uint64', name: 'trackingSupplyIndex', type: 'uint64' },
                  { internalType: 'uint64', name: 'trackingBorrowIndex', type: 'uint64' },
                  { internalType: 'uint104', name: 'totalSupplyBase', type: 'uint104' },
                  { internalType: 'uint104', name: 'totalBorrowBase', type: 'uint104' },
                  { internalType: 'uint40', name: 'lastAccrualTime', type: 'uint40' },
                  { internalType: 'uint8', name: 'pauseFlags', type: 'uint8' },
                ],
                internalType: 'struct CometStorage.TotalsBasic',
                name: '',
                type: 'tuple',
              },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: '', type: 'address' }],
            name: 'totalsCollateral',
            outputs: [
              { internalType: 'uint128', name: 'totalSupplyAsset', type: 'uint128' },
              { internalType: 'uint128', name: '_reserved', type: 'uint128' },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: '', type: 'address' }],
            name: 'userBasic',
            outputs: [
              { internalType: 'int104', name: 'principal', type: 'int104' },
              { internalType: 'uint64', name: 'baseTrackingIndex', type: 'uint64' },
              { internalType: 'uint64', name: 'baseTrackingAccrued', type: 'uint64' },
              { internalType: 'uint16', name: 'assetsIn', type: 'uint16' },
              { internalType: 'uint8', name: '_reserved', type: 'uint8' },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: '', type: 'address' },
              { internalType: 'address', name: '', type: 'address' },
            ],
            name: 'userCollateral',
            outputs: [
              { internalType: 'uint128', name: 'balance', type: 'uint128' },
              { internalType: 'uint128', name: '_reserved', type: 'uint128' },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: '', type: 'address' }],
            name: 'userNonce',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'version',
            outputs: [{ internalType: 'string', name: '', type: 'string' }],
            stateMutability: 'view',
            type: 'function',
          },
        ]),
        (t.configuratorAbi = [
          { inputs: [], stateMutability: 'nonpayable', type: 'constructor' },
          { inputs: [], name: 'AlreadyInitialized', type: 'error' },
          { inputs: [], name: 'AssetDoesNotExist', type: 'error' },
          { inputs: [], name: 'ConfigurationAlreadyExists', type: 'error' },
          { inputs: [], name: 'InvalidAddress', type: 'error' },
          { inputs: [], name: 'Unauthorized', type: 'error' },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'cometProxy', type: 'address' },
              {
                components: [
                  { internalType: 'address', name: 'asset', type: 'address' },
                  { internalType: 'address', name: 'priceFeed', type: 'address' },
                  { internalType: 'uint8', name: 'decimals', type: 'uint8' },
                  { internalType: 'uint64', name: 'borrowCollateralFactor', type: 'uint64' },
                  { internalType: 'uint64', name: 'liquidateCollateralFactor', type: 'uint64' },
                  { internalType: 'uint64', name: 'liquidationFactor', type: 'uint64' },
                  { internalType: 'uint128', name: 'supplyCap', type: 'uint128' },
                ],
                indexed: !1,
                internalType: 'struct CometConfiguration.AssetConfig',
                name: 'assetConfig',
                type: 'tuple',
              },
            ],
            name: 'AddAsset',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'cometProxy', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'newComet', type: 'address' },
            ],
            name: 'CometDeployed',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'oldGovernor', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'newGovernor', type: 'address' },
            ],
            name: 'GovernorTransferred',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'cometProxy', type: 'address' },
              { indexed: !1, internalType: 'uint104', name: 'oldBaseBorrowMin', type: 'uint104' },
              { indexed: !1, internalType: 'uint104', name: 'newBaseBorrowMin', type: 'uint104' },
            ],
            name: 'SetBaseBorrowMin',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'cometProxy', type: 'address' },
              {
                indexed: !1,
                internalType: 'uint104',
                name: 'oldBaseMinForRewards',
                type: 'uint104',
              },
              {
                indexed: !1,
                internalType: 'uint104',
                name: 'newBaseMinForRewards',
                type: 'uint104',
              },
            ],
            name: 'SetBaseMinForRewards',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'cometProxy', type: 'address' },
              {
                indexed: !0,
                internalType: 'address',
                name: 'oldBaseTokenPriceFeed',
                type: 'address',
              },
              {
                indexed: !0,
                internalType: 'address',
                name: 'newBaseTokenPriceFeed',
                type: 'address',
              },
            ],
            name: 'SetBaseTokenPriceFeed',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'cometProxy', type: 'address' },
              {
                indexed: !1,
                internalType: 'uint64',
                name: 'oldBaseTrackingBorrowSpeed',
                type: 'uint64',
              },
              {
                indexed: !1,
                internalType: 'uint64',
                name: 'newBaseTrackingBorrowSpeed',
                type: 'uint64',
              },
            ],
            name: 'SetBaseTrackingBorrowSpeed',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'cometProxy', type: 'address' },
              {
                indexed: !1,
                internalType: 'uint64',
                name: 'oldBaseTrackingSupplySpeed',
                type: 'uint64',
              },
              {
                indexed: !1,
                internalType: 'uint64',
                name: 'newBaseTrackingSupplySpeed',
                type: 'uint64',
              },
            ],
            name: 'SetBaseTrackingSupplySpeed',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'cometProxy', type: 'address' },
              { indexed: !1, internalType: 'uint64', name: 'oldKink', type: 'uint64' },
              { indexed: !1, internalType: 'uint64', name: 'newKink', type: 'uint64' },
            ],
            name: 'SetBorrowKink',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'cometProxy', type: 'address' },
              { indexed: !1, internalType: 'uint64', name: 'oldIRBase', type: 'uint64' },
              { indexed: !1, internalType: 'uint64', name: 'newIRBase', type: 'uint64' },
            ],
            name: 'SetBorrowPerYearInterestRateBase',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'cometProxy', type: 'address' },
              { indexed: !1, internalType: 'uint64', name: 'oldIRSlopeHigh', type: 'uint64' },
              { indexed: !1, internalType: 'uint64', name: 'newIRSlopeHigh', type: 'uint64' },
            ],
            name: 'SetBorrowPerYearInterestRateSlopeHigh',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'cometProxy', type: 'address' },
              { indexed: !1, internalType: 'uint64', name: 'oldIRSlopeLow', type: 'uint64' },
              { indexed: !1, internalType: 'uint64', name: 'newIRSlopeLow', type: 'uint64' },
            ],
            name: 'SetBorrowPerYearInterestRateSlopeLow',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'cometProxy', type: 'address' },
              {
                components: [
                  { internalType: 'address', name: 'governor', type: 'address' },
                  { internalType: 'address', name: 'pauseGuardian', type: 'address' },
                  { internalType: 'address', name: 'baseToken', type: 'address' },
                  { internalType: 'address', name: 'baseTokenPriceFeed', type: 'address' },
                  { internalType: 'address', name: 'extensionDelegate', type: 'address' },
                  { internalType: 'uint64', name: 'supplyKink', type: 'uint64' },
                  {
                    internalType: 'uint64',
                    name: 'supplyPerYearInterestRateSlopeLow',
                    type: 'uint64',
                  },
                  {
                    internalType: 'uint64',
                    name: 'supplyPerYearInterestRateSlopeHigh',
                    type: 'uint64',
                  },
                  { internalType: 'uint64', name: 'supplyPerYearInterestRateBase', type: 'uint64' },
                  { internalType: 'uint64', name: 'borrowKink', type: 'uint64' },
                  {
                    internalType: 'uint64',
                    name: 'borrowPerYearInterestRateSlopeLow',
                    type: 'uint64',
                  },
                  {
                    internalType: 'uint64',
                    name: 'borrowPerYearInterestRateSlopeHigh',
                    type: 'uint64',
                  },
                  { internalType: 'uint64', name: 'borrowPerYearInterestRateBase', type: 'uint64' },
                  { internalType: 'uint64', name: 'storeFrontPriceFactor', type: 'uint64' },
                  { internalType: 'uint64', name: 'trackingIndexScale', type: 'uint64' },
                  { internalType: 'uint64', name: 'baseTrackingSupplySpeed', type: 'uint64' },
                  { internalType: 'uint64', name: 'baseTrackingBorrowSpeed', type: 'uint64' },
                  { internalType: 'uint104', name: 'baseMinForRewards', type: 'uint104' },
                  { internalType: 'uint104', name: 'baseBorrowMin', type: 'uint104' },
                  { internalType: 'uint104', name: 'targetReserves', type: 'uint104' },
                  {
                    components: [
                      { internalType: 'address', name: 'asset', type: 'address' },
                      { internalType: 'address', name: 'priceFeed', type: 'address' },
                      { internalType: 'uint8', name: 'decimals', type: 'uint8' },
                      { internalType: 'uint64', name: 'borrowCollateralFactor', type: 'uint64' },
                      { internalType: 'uint64', name: 'liquidateCollateralFactor', type: 'uint64' },
                      { internalType: 'uint64', name: 'liquidationFactor', type: 'uint64' },
                      { internalType: 'uint128', name: 'supplyCap', type: 'uint128' },
                    ],
                    internalType: 'struct CometConfiguration.AssetConfig[]',
                    name: 'assetConfigs',
                    type: 'tuple[]',
                  },
                ],
                indexed: !1,
                internalType: 'struct CometConfiguration.Configuration',
                name: 'oldConfiguration',
                type: 'tuple',
              },
              {
                components: [
                  { internalType: 'address', name: 'governor', type: 'address' },
                  { internalType: 'address', name: 'pauseGuardian', type: 'address' },
                  { internalType: 'address', name: 'baseToken', type: 'address' },
                  { internalType: 'address', name: 'baseTokenPriceFeed', type: 'address' },
                  { internalType: 'address', name: 'extensionDelegate', type: 'address' },
                  { internalType: 'uint64', name: 'supplyKink', type: 'uint64' },
                  {
                    internalType: 'uint64',
                    name: 'supplyPerYearInterestRateSlopeLow',
                    type: 'uint64',
                  },
                  {
                    internalType: 'uint64',
                    name: 'supplyPerYearInterestRateSlopeHigh',
                    type: 'uint64',
                  },
                  { internalType: 'uint64', name: 'supplyPerYearInterestRateBase', type: 'uint64' },
                  { internalType: 'uint64', name: 'borrowKink', type: 'uint64' },
                  {
                    internalType: 'uint64',
                    name: 'borrowPerYearInterestRateSlopeLow',
                    type: 'uint64',
                  },
                  {
                    internalType: 'uint64',
                    name: 'borrowPerYearInterestRateSlopeHigh',
                    type: 'uint64',
                  },
                  { internalType: 'uint64', name: 'borrowPerYearInterestRateBase', type: 'uint64' },
                  { internalType: 'uint64', name: 'storeFrontPriceFactor', type: 'uint64' },
                  { internalType: 'uint64', name: 'trackingIndexScale', type: 'uint64' },
                  { internalType: 'uint64', name: 'baseTrackingSupplySpeed', type: 'uint64' },
                  { internalType: 'uint64', name: 'baseTrackingBorrowSpeed', type: 'uint64' },
                  { internalType: 'uint104', name: 'baseMinForRewards', type: 'uint104' },
                  { internalType: 'uint104', name: 'baseBorrowMin', type: 'uint104' },
                  { internalType: 'uint104', name: 'targetReserves', type: 'uint104' },
                  {
                    components: [
                      { internalType: 'address', name: 'asset', type: 'address' },
                      { internalType: 'address', name: 'priceFeed', type: 'address' },
                      { internalType: 'uint8', name: 'decimals', type: 'uint8' },
                      { internalType: 'uint64', name: 'borrowCollateralFactor', type: 'uint64' },
                      { internalType: 'uint64', name: 'liquidateCollateralFactor', type: 'uint64' },
                      { internalType: 'uint64', name: 'liquidationFactor', type: 'uint64' },
                      { internalType: 'uint128', name: 'supplyCap', type: 'uint128' },
                    ],
                    internalType: 'struct CometConfiguration.AssetConfig[]',
                    name: 'assetConfigs',
                    type: 'tuple[]',
                  },
                ],
                indexed: !1,
                internalType: 'struct CometConfiguration.Configuration',
                name: 'newConfiguration',
                type: 'tuple',
              },
            ],
            name: 'SetConfiguration',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'cometProxy', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'oldExt', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'newExt', type: 'address' },
            ],
            name: 'SetExtensionDelegate',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'cometProxy', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'oldFactory', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'newFactory', type: 'address' },
            ],
            name: 'SetFactory',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'cometProxy', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'oldGovernor', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'newGovernor', type: 'address' },
            ],
            name: 'SetGovernor',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'cometProxy', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'oldPauseGuardian', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'newPauseGuardian', type: 'address' },
            ],
            name: 'SetPauseGuardian',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'cometProxy', type: 'address' },
              {
                indexed: !1,
                internalType: 'uint64',
                name: 'oldStoreFrontPriceFactor',
                type: 'uint64',
              },
              {
                indexed: !1,
                internalType: 'uint64',
                name: 'newStoreFrontPriceFactor',
                type: 'uint64',
              },
            ],
            name: 'SetStoreFrontPriceFactor',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'cometProxy', type: 'address' },
              { indexed: !1, internalType: 'uint64', name: 'oldKink', type: 'uint64' },
              { indexed: !1, internalType: 'uint64', name: 'newKink', type: 'uint64' },
            ],
            name: 'SetSupplyKink',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'cometProxy', type: 'address' },
              { indexed: !1, internalType: 'uint64', name: 'oldIRBase', type: 'uint64' },
              { indexed: !1, internalType: 'uint64', name: 'newIRBase', type: 'uint64' },
            ],
            name: 'SetSupplyPerYearInterestRateBase',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'cometProxy', type: 'address' },
              { indexed: !1, internalType: 'uint64', name: 'oldIRSlopeHigh', type: 'uint64' },
              { indexed: !1, internalType: 'uint64', name: 'newIRSlopeHigh', type: 'uint64' },
            ],
            name: 'SetSupplyPerYearInterestRateSlopeHigh',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'cometProxy', type: 'address' },
              { indexed: !1, internalType: 'uint64', name: 'oldIRSlopeLow', type: 'uint64' },
              { indexed: !1, internalType: 'uint64', name: 'newIRSlopeLow', type: 'uint64' },
            ],
            name: 'SetSupplyPerYearInterestRateSlopeLow',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'cometProxy', type: 'address' },
              { indexed: !1, internalType: 'uint104', name: 'oldTargetReserves', type: 'uint104' },
              { indexed: !1, internalType: 'uint104', name: 'newTargetReserves', type: 'uint104' },
            ],
            name: 'SetTargetReserves',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'cometProxy', type: 'address' },
              {
                components: [
                  { internalType: 'address', name: 'asset', type: 'address' },
                  { internalType: 'address', name: 'priceFeed', type: 'address' },
                  { internalType: 'uint8', name: 'decimals', type: 'uint8' },
                  { internalType: 'uint64', name: 'borrowCollateralFactor', type: 'uint64' },
                  { internalType: 'uint64', name: 'liquidateCollateralFactor', type: 'uint64' },
                  { internalType: 'uint64', name: 'liquidationFactor', type: 'uint64' },
                  { internalType: 'uint128', name: 'supplyCap', type: 'uint128' },
                ],
                indexed: !1,
                internalType: 'struct CometConfiguration.AssetConfig',
                name: 'oldAssetConfig',
                type: 'tuple',
              },
              {
                components: [
                  { internalType: 'address', name: 'asset', type: 'address' },
                  { internalType: 'address', name: 'priceFeed', type: 'address' },
                  { internalType: 'uint8', name: 'decimals', type: 'uint8' },
                  { internalType: 'uint64', name: 'borrowCollateralFactor', type: 'uint64' },
                  { internalType: 'uint64', name: 'liquidateCollateralFactor', type: 'uint64' },
                  { internalType: 'uint64', name: 'liquidationFactor', type: 'uint64' },
                  { internalType: 'uint128', name: 'supplyCap', type: 'uint128' },
                ],
                indexed: !1,
                internalType: 'struct CometConfiguration.AssetConfig',
                name: 'newAssetConfig',
                type: 'tuple',
              },
            ],
            name: 'UpdateAsset',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'cometProxy', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'asset', type: 'address' },
              { indexed: !1, internalType: 'uint64', name: 'oldBorrowCF', type: 'uint64' },
              { indexed: !1, internalType: 'uint64', name: 'newBorrowCF', type: 'uint64' },
            ],
            name: 'UpdateAssetBorrowCollateralFactor',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'cometProxy', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'asset', type: 'address' },
              { indexed: !1, internalType: 'uint64', name: 'oldLiquidateCF', type: 'uint64' },
              { indexed: !1, internalType: 'uint64', name: 'newLiquidateCF', type: 'uint64' },
            ],
            name: 'UpdateAssetLiquidateCollateralFactor',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'cometProxy', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'asset', type: 'address' },
              { indexed: !1, internalType: 'uint64', name: 'oldLiquidationFactor', type: 'uint64' },
              { indexed: !1, internalType: 'uint64', name: 'newLiquidationFactor', type: 'uint64' },
            ],
            name: 'UpdateAssetLiquidationFactor',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'cometProxy', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'asset', type: 'address' },
              { indexed: !1, internalType: 'address', name: 'oldPriceFeed', type: 'address' },
              { indexed: !1, internalType: 'address', name: 'newPriceFeed', type: 'address' },
            ],
            name: 'UpdateAssetPriceFeed',
            type: 'event',
          },
          {
            anonymous: !1,
            inputs: [
              { indexed: !0, internalType: 'address', name: 'cometProxy', type: 'address' },
              { indexed: !0, internalType: 'address', name: 'asset', type: 'address' },
              { indexed: !1, internalType: 'uint128', name: 'oldSupplyCap', type: 'uint128' },
              { indexed: !1, internalType: 'uint128', name: 'newSupplyCap', type: 'uint128' },
            ],
            name: 'UpdateAssetSupplyCap',
            type: 'event',
          },
          {
            inputs: [
              { internalType: 'address', name: 'cometProxy', type: 'address' },
              {
                components: [
                  { internalType: 'address', name: 'asset', type: 'address' },
                  { internalType: 'address', name: 'priceFeed', type: 'address' },
                  { internalType: 'uint8', name: 'decimals', type: 'uint8' },
                  { internalType: 'uint64', name: 'borrowCollateralFactor', type: 'uint64' },
                  { internalType: 'uint64', name: 'liquidateCollateralFactor', type: 'uint64' },
                  { internalType: 'uint64', name: 'liquidationFactor', type: 'uint64' },
                  { internalType: 'uint128', name: 'supplyCap', type: 'uint128' },
                ],
                internalType: 'struct CometConfiguration.AssetConfig',
                name: 'assetConfig',
                type: 'tuple',
              },
            ],
            name: 'addAsset',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'cometProxy', type: 'address' }],
            name: 'deploy',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: '', type: 'address' }],
            name: 'factory',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'cometProxy', type: 'address' },
              { internalType: 'address', name: 'asset', type: 'address' },
            ],
            name: 'getAssetIndex',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'cometProxy', type: 'address' }],
            name: 'getConfiguration',
            outputs: [
              {
                components: [
                  { internalType: 'address', name: 'governor', type: 'address' },
                  { internalType: 'address', name: 'pauseGuardian', type: 'address' },
                  { internalType: 'address', name: 'baseToken', type: 'address' },
                  { internalType: 'address', name: 'baseTokenPriceFeed', type: 'address' },
                  { internalType: 'address', name: 'extensionDelegate', type: 'address' },
                  { internalType: 'uint64', name: 'supplyKink', type: 'uint64' },
                  {
                    internalType: 'uint64',
                    name: 'supplyPerYearInterestRateSlopeLow',
                    type: 'uint64',
                  },
                  {
                    internalType: 'uint64',
                    name: 'supplyPerYearInterestRateSlopeHigh',
                    type: 'uint64',
                  },
                  { internalType: 'uint64', name: 'supplyPerYearInterestRateBase', type: 'uint64' },
                  { internalType: 'uint64', name: 'borrowKink', type: 'uint64' },
                  {
                    internalType: 'uint64',
                    name: 'borrowPerYearInterestRateSlopeLow',
                    type: 'uint64',
                  },
                  {
                    internalType: 'uint64',
                    name: 'borrowPerYearInterestRateSlopeHigh',
                    type: 'uint64',
                  },
                  { internalType: 'uint64', name: 'borrowPerYearInterestRateBase', type: 'uint64' },
                  { internalType: 'uint64', name: 'storeFrontPriceFactor', type: 'uint64' },
                  { internalType: 'uint64', name: 'trackingIndexScale', type: 'uint64' },
                  { internalType: 'uint64', name: 'baseTrackingSupplySpeed', type: 'uint64' },
                  { internalType: 'uint64', name: 'baseTrackingBorrowSpeed', type: 'uint64' },
                  { internalType: 'uint104', name: 'baseMinForRewards', type: 'uint104' },
                  { internalType: 'uint104', name: 'baseBorrowMin', type: 'uint104' },
                  { internalType: 'uint104', name: 'targetReserves', type: 'uint104' },
                  {
                    components: [
                      { internalType: 'address', name: 'asset', type: 'address' },
                      { internalType: 'address', name: 'priceFeed', type: 'address' },
                      { internalType: 'uint8', name: 'decimals', type: 'uint8' },
                      { internalType: 'uint64', name: 'borrowCollateralFactor', type: 'uint64' },
                      { internalType: 'uint64', name: 'liquidateCollateralFactor', type: 'uint64' },
                      { internalType: 'uint64', name: 'liquidationFactor', type: 'uint64' },
                      { internalType: 'uint128', name: 'supplyCap', type: 'uint128' },
                    ],
                    internalType: 'struct CometConfiguration.AssetConfig[]',
                    name: 'assetConfigs',
                    type: 'tuple[]',
                  },
                ],
                internalType: 'struct CometConfiguration.Configuration',
                name: '',
                type: 'tuple',
              },
            ],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [],
            name: 'governor',
            outputs: [{ internalType: 'address', name: '', type: 'address' }],
            stateMutability: 'view',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'governor_', type: 'address' }],
            name: 'initialize',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'cometProxy', type: 'address' },
              { internalType: 'uint104', name: 'newBaseBorrowMin', type: 'uint104' },
            ],
            name: 'setBaseBorrowMin',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'cometProxy', type: 'address' },
              { internalType: 'uint104', name: 'newBaseMinForRewards', type: 'uint104' },
            ],
            name: 'setBaseMinForRewards',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'cometProxy', type: 'address' },
              { internalType: 'address', name: 'newBaseTokenPriceFeed', type: 'address' },
            ],
            name: 'setBaseTokenPriceFeed',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'cometProxy', type: 'address' },
              { internalType: 'uint64', name: 'newBaseTrackingBorrowSpeed', type: 'uint64' },
            ],
            name: 'setBaseTrackingBorrowSpeed',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'cometProxy', type: 'address' },
              { internalType: 'uint64', name: 'newBaseTrackingSupplySpeed', type: 'uint64' },
            ],
            name: 'setBaseTrackingSupplySpeed',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'cometProxy', type: 'address' },
              { internalType: 'uint64', name: 'newBorrowKink', type: 'uint64' },
            ],
            name: 'setBorrowKink',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'cometProxy', type: 'address' },
              { internalType: 'uint64', name: 'newBase', type: 'uint64' },
            ],
            name: 'setBorrowPerYearInterestRateBase',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'cometProxy', type: 'address' },
              { internalType: 'uint64', name: 'newSlope', type: 'uint64' },
            ],
            name: 'setBorrowPerYearInterestRateSlopeHigh',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'cometProxy', type: 'address' },
              { internalType: 'uint64', name: 'newSlope', type: 'uint64' },
            ],
            name: 'setBorrowPerYearInterestRateSlopeLow',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'cometProxy', type: 'address' },
              {
                components: [
                  { internalType: 'address', name: 'governor', type: 'address' },
                  { internalType: 'address', name: 'pauseGuardian', type: 'address' },
                  { internalType: 'address', name: 'baseToken', type: 'address' },
                  { internalType: 'address', name: 'baseTokenPriceFeed', type: 'address' },
                  { internalType: 'address', name: 'extensionDelegate', type: 'address' },
                  { internalType: 'uint64', name: 'supplyKink', type: 'uint64' },
                  {
                    internalType: 'uint64',
                    name: 'supplyPerYearInterestRateSlopeLow',
                    type: 'uint64',
                  },
                  {
                    internalType: 'uint64',
                    name: 'supplyPerYearInterestRateSlopeHigh',
                    type: 'uint64',
                  },
                  { internalType: 'uint64', name: 'supplyPerYearInterestRateBase', type: 'uint64' },
                  { internalType: 'uint64', name: 'borrowKink', type: 'uint64' },
                  {
                    internalType: 'uint64',
                    name: 'borrowPerYearInterestRateSlopeLow',
                    type: 'uint64',
                  },
                  {
                    internalType: 'uint64',
                    name: 'borrowPerYearInterestRateSlopeHigh',
                    type: 'uint64',
                  },
                  { internalType: 'uint64', name: 'borrowPerYearInterestRateBase', type: 'uint64' },
                  { internalType: 'uint64', name: 'storeFrontPriceFactor', type: 'uint64' },
                  { internalType: 'uint64', name: 'trackingIndexScale', type: 'uint64' },
                  { internalType: 'uint64', name: 'baseTrackingSupplySpeed', type: 'uint64' },
                  { internalType: 'uint64', name: 'baseTrackingBorrowSpeed', type: 'uint64' },
                  { internalType: 'uint104', name: 'baseMinForRewards', type: 'uint104' },
                  { internalType: 'uint104', name: 'baseBorrowMin', type: 'uint104' },
                  { internalType: 'uint104', name: 'targetReserves', type: 'uint104' },
                  {
                    components: [
                      { internalType: 'address', name: 'asset', type: 'address' },
                      { internalType: 'address', name: 'priceFeed', type: 'address' },
                      { internalType: 'uint8', name: 'decimals', type: 'uint8' },
                      { internalType: 'uint64', name: 'borrowCollateralFactor', type: 'uint64' },
                      { internalType: 'uint64', name: 'liquidateCollateralFactor', type: 'uint64' },
                      { internalType: 'uint64', name: 'liquidationFactor', type: 'uint64' },
                      { internalType: 'uint128', name: 'supplyCap', type: 'uint128' },
                    ],
                    internalType: 'struct CometConfiguration.AssetConfig[]',
                    name: 'assetConfigs',
                    type: 'tuple[]',
                  },
                ],
                internalType: 'struct CometConfiguration.Configuration',
                name: 'newConfiguration',
                type: 'tuple',
              },
            ],
            name: 'setConfiguration',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'cometProxy', type: 'address' },
              { internalType: 'address', name: 'newExtensionDelegate', type: 'address' },
            ],
            name: 'setExtensionDelegate',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'cometProxy', type: 'address' },
              { internalType: 'address', name: 'newFactory', type: 'address' },
            ],
            name: 'setFactory',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'cometProxy', type: 'address' },
              { internalType: 'address', name: 'newGovernor', type: 'address' },
            ],
            name: 'setGovernor',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'cometProxy', type: 'address' },
              { internalType: 'address', name: 'newPauseGuardian', type: 'address' },
            ],
            name: 'setPauseGuardian',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'cometProxy', type: 'address' },
              { internalType: 'uint64', name: 'newStoreFrontPriceFactor', type: 'uint64' },
            ],
            name: 'setStoreFrontPriceFactor',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'cometProxy', type: 'address' },
              { internalType: 'uint64', name: 'newSupplyKink', type: 'uint64' },
            ],
            name: 'setSupplyKink',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'cometProxy', type: 'address' },
              { internalType: 'uint64', name: 'newBase', type: 'uint64' },
            ],
            name: 'setSupplyPerYearInterestRateBase',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'cometProxy', type: 'address' },
              { internalType: 'uint64', name: 'newSlope', type: 'uint64' },
            ],
            name: 'setSupplyPerYearInterestRateSlopeHigh',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'cometProxy', type: 'address' },
              { internalType: 'uint64', name: 'newSlope', type: 'uint64' },
            ],
            name: 'setSupplyPerYearInterestRateSlopeLow',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'cometProxy', type: 'address' },
              { internalType: 'uint104', name: 'newTargetReserves', type: 'uint104' },
            ],
            name: 'setTargetReserves',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [{ internalType: 'address', name: 'newGovernor', type: 'address' }],
            name: 'transferGovernor',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'cometProxy', type: 'address' },
              {
                components: [
                  { internalType: 'address', name: 'asset', type: 'address' },
                  { internalType: 'address', name: 'priceFeed', type: 'address' },
                  { internalType: 'uint8', name: 'decimals', type: 'uint8' },
                  { internalType: 'uint64', name: 'borrowCollateralFactor', type: 'uint64' },
                  { internalType: 'uint64', name: 'liquidateCollateralFactor', type: 'uint64' },
                  { internalType: 'uint64', name: 'liquidationFactor', type: 'uint64' },
                  { internalType: 'uint128', name: 'supplyCap', type: 'uint128' },
                ],
                internalType: 'struct CometConfiguration.AssetConfig',
                name: 'newAssetConfig',
                type: 'tuple',
              },
            ],
            name: 'updateAsset',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'cometProxy', type: 'address' },
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'uint64', name: 'newBorrowCF', type: 'uint64' },
            ],
            name: 'updateAssetBorrowCollateralFactor',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'cometProxy', type: 'address' },
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'uint64', name: 'newLiquidateCF', type: 'uint64' },
            ],
            name: 'updateAssetLiquidateCollateralFactor',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'cometProxy', type: 'address' },
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'uint64', name: 'newLiquidationFactor', type: 'uint64' },
            ],
            name: 'updateAssetLiquidationFactor',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'cometProxy', type: 'address' },
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'address', name: 'newPriceFeed', type: 'address' },
            ],
            name: 'updateAssetPriceFeed',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [
              { internalType: 'address', name: 'cometProxy', type: 'address' },
              { internalType: 'address', name: 'asset', type: 'address' },
              { internalType: 'uint128', name: 'newSupplyCap', type: 'uint128' },
            ],
            name: 'updateAssetSupplyCap',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
          {
            inputs: [],
            name: 'version',
            outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
            stateMutability: 'view',
            type: 'function',
          },
        ]);
    },
    16316: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.migrationAddresses = t.migrationAddressesRegistry = void 0);
      let r = n(40252),
        i = n(14241),
        a = n(27256),
        s = n(4457),
        o = n(67317),
        l = n(35727),
        u = n(93001),
        c = r.addresses[r.ChainId.EthMainnet];
      (c.aaveV3Optimizer = '0x33333aea097c193e66081E930c33020272b33333'),
        (c.cEth = '0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5'),
        (t.migrationAddressesRegistry = {
          [r.ChainId.EthMainnet]: {
            [u.MigratableProtocol.aaveV3Optimizer]: {
              morpho: {
                address: '0x33333aea097c193e66081E930c33020272b33333',
                abi: s.morphoAaveV3Abi,
              },
              poolDataProvider: {
                address: '0x7B4EB56E7CD4b454BA8ff71E4518426369a138a3',
                abi: a.protocolDataProviderAbi,
              },
            },
            [u.MigratableProtocol.aaveV2]: {
              protocolDataProvider: {
                address: '0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d',
                abi: i.protocolDataProviderAbi,
              },
              lendingPool: {
                address: '0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9',
                abi: i.lendingPoolAbi,
              },
              addressesProvider: {
                address: '0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5',
                abi: i.addressesProviderAbi,
              },
            },
            [u.MigratableProtocol.aaveV3]: {
              pool: { address: '0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2', abi: a.poolAbi },
              protocolDataProvider: {
                address: '0x7B4EB56E7CD4b454BA8ff71E4518426369a138a3',
                abi: a.protocolDataProviderAbi,
              },
              addressesProvider: {
                address: '0x2f39d218133AFaB8F2B819B1066c7E434Ad94E9e',
                abi: a.addressesProviderAbi,
              },
            },
            [u.MigratableProtocol.compoundV3]: {
              usdc: { address: '0xc3d688B66703497DAA19211EEdff47f25384cdc3', abi: l.cometAbi },
              weth: { address: '0xA17581A9E3356d9A858b789D68B4d866e593aE94', abi: l.cometAbi },
            },
            [u.MigratableProtocol.compoundV2]: {
              cEth: { address: '0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5', abi: o.cEtherAbi },
              cUsdc: { address: '0x39AA39c021dfbaE8faC545936693aC917d5E7563', abi: o.cErc20Abi },
              comptroller: {
                address: '0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B',
                abi: o.comptrollerAbi,
              },
            },
          },
          [r.ChainId.BaseMainnet]: {
            [u.MigratableProtocol.aaveV3]: {
              pool: { address: '0xA238Dd80C259a72e81d7e4664a9801593F98d1c5', abi: a.poolAbi },
              protocolDataProvider: {
                address: '0x2d8A3C5677189723C4cB8873CfC9C8976FDF38Ac',
                abi: a.protocolDataProviderAbi,
              },
              addressesProvider: {
                address: '0xe20fCBdBfFC4Dd138cE8b2E6FBb6CB49777ad64D',
                abi: a.addressesProviderAbi,
              },
            },
            [u.MigratableProtocol.compoundV3]: {
              usdc: { address: '0xb125E6687d4313864e53df431d5425969c15Eb2F', abi: l.cometAbi },
              weth: { address: '0x46e6b214b524310239732D51387075E0e70970bf', abi: l.cometAbi },
            },
            [u.MigratableProtocol.compoundV2]: {
              mWeth: { address: '0x628ff693426583D9a7FB391E54366292F509D457', abi: o.mErc20Abi },
              mUsdc: { address: '0xEdc817A28E8B93B03976FBd4a3dDBc9f7D176c22', abi: o.mErc20Abi },
              comptroller: {
                address: '0xfBb21d0380beE3312B33c4353c8936a0F13EF26C',
                abi: o.comptrollerAbi,
              },
            },
            [u.MigratableProtocol.aaveV2]: null,
            [u.MigratableProtocol.aaveV3Optimizer]: null,
          },
        }),
        (t.migrationAddresses = t.migrationAddressesRegistry);
    },
    44311: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }), (t.fetchAaveV2Positions = y);
      let r = n(40252),
        i = n(35047),
        a = n(16316),
        s = n(54693),
        o = n(93001),
        l = n(4565),
        u = n(52707),
        c = n(28893),
        d = n(14241),
        p = n(82152),
        h = n(97992);
      async function y(e, t, n = {}) {
        n.chainId ??= await (0, c.getChainId)(t);
        let y = n.chainId,
          {
            morpho: f,
            bundler3: { generalAdapter1: m },
          } = (0, r.getChainAddresses)(y),
          g = a.migrationAddresses[y]?.[o.MigratableProtocol.aaveV2];
        if (!g) return [];
        let [b, w, v, T] = await Promise.all([
            (0, c.readContract)(t, {
              ...n,
              abi: g.protocolDataProvider.abi,
              address: g.protocolDataProvider.address,
              functionName: 'getAllATokens',
              args: [],
            }),
            (0, c.readContract)(t, {
              ...n,
              abi: g.lendingPool.abi,
              address: g.lendingPool.address,
              functionName: 'getUserConfiguration',
              args: [e],
            }),
            (0, c.readContract)(t, {
              ...n,
              abi: g.lendingPool.abi,
              address: g.lendingPool.address,
              functionName: 'getReservesList',
              args: [],
            }),
            (0, c.readContract)(t, {
              ...n,
              abi: g.addressesProvider.abi,
              address: g.addressesProvider.address,
              functionName: 'getPriceOracle',
              args: [],
            }),
          ]),
          A = w.data
            .toString(2)
            .split('')
            .reduceRight((e, t) => {
              let n = e[e.length - 1];
              return n && 2 !== n.length ? [...e.slice(0, -1), n + t] : e.concat(t);
            }, []),
          E = Object.fromEntries(
            v.map((e, t) => {
              let n = A[t] ?? '00';
              return [e, { isUsedAsCollateral: '1' === n[1], isBorrowed: '1' === n[0] }];
            })
          ),
          C = (
            await Promise.all(
              b.map(async ({ tokenAddress: r }) => {
                let [i, a, s, o] = await Promise.all([
                    (0, c.readContract)(t, {
                      ...n,
                      abi: d.aTokenV2Abi,
                      address: r,
                      functionName: 'UNDERLYING_ASSET_ADDRESS',
                      args: [],
                    }),
                    (0, c.readContract)(t, {
                      ...n,
                      abi: d.aTokenV2Abi,
                      address: r,
                      functionName: 'balanceOf',
                      args: [e],
                    }),
                    (0, c.readContract)(t, {
                      ...n,
                      abi: d.aTokenV2Abi,
                      address: r,
                      functionName: '_nonces',
                      args: [e],
                    }),
                    (0, l.fetchToken)(r, t, n),
                  ]),
                  p = E[i];
                if (!p) return;
                let [
                    h,
                    [, , y, , , b, , , w],
                    {
                      currentLiquidityRate: v,
                      variableDebtTokenAddress: A,
                      currentVariableBorrowRate: C,
                    },
                    _,
                  ] = await Promise.all([
                    (0, c.readContract)(t, {
                      ...n,
                      abi: u.erc20Abi,
                      address: i,
                      functionName: 'balanceOf',
                      args: [r],
                    }),
                    (0, c.readContract)(t, {
                      ...n,
                      abi: g.protocolDataProvider.abi,
                      address: g.protocolDataProvider.address,
                      functionName: 'getReserveConfigurationData',
                      args: [i],
                    }),
                    (0, c.readContract)(t, {
                      ...n,
                      abi: g.lendingPool.abi,
                      address: g.lendingPool.address,
                      functionName: 'getReserveData',
                      args: [i],
                    }),
                    (0, l.fetchToken)(i, t, n),
                  ]),
                  [I, S, P] = await Promise.all([
                    (0, c.readContract)(t, {
                      ...n,
                      abi: d.variableDebtTokenV2Abi,
                      address: A,
                      functionName: 'balanceOf',
                      args: [e],
                    }),
                    (0, c.readContract)(t, {
                      ...n,
                      abi: l.blueAbi,
                      address: f,
                      functionName: 'nonce',
                      args: [e],
                    }),
                    (0, c.readContract)(t, {
                      ...n,
                      abi: l.blueAbi,
                      address: f,
                      functionName: 'isAuthorized',
                      args: [e, m],
                    }),
                  ]),
                  O = await (0, c.readContract)(t, {
                    ...n,
                    abi: d.aaveV2OracleAbi,
                    address: T,
                    functionName: 'getAssetPrice',
                    args: [i],
                  });
                return {
                  underlying: _,
                  supply: {
                    isCollateral: p.isUsedAsCollateral && b,
                    poolLiquidity: h,
                    totalSupply: a,
                    isActive: w,
                    currentLiquidityRate: v,
                    aTokenData: o,
                    nonce: s,
                    ethPrice: O,
                  },
                  borrow: {
                    liquidationThreshold: y,
                    currentVariableBorrowRate: C,
                    totalBorrow: I,
                    isActive: w,
                    ethPrice: O,
                    morphoNonce: S,
                    isBundlerManaging: P,
                  },
                };
              })
            )
          ).filter(i.isDefined),
          _ = (0, i.values)(E).some(({ isBorrowed: e }) => e),
          I = C.map(
            ({
              underlying: t,
              supply: {
                isCollateral: n,
                isActive: i,
                poolLiquidity: a,
                totalSupply: l,
                currentLiquidityRate: u,
                nonce: c,
                aTokenData: d,
              },
            }) => {
              if (_ && n) return;
              let p = (() => {
                if (!i) return { value: 0n, limiter: o.SupplyMigrationLimiter.withdrawPaused };
                let e = r.MathLib.min(a, l);
                return e === a
                  ? { value: a, limiter: o.SupplyMigrationLimiter.liquidity }
                  : e === l
                    ? { value: l, limiter: o.SupplyMigrationLimiter.position }
                    : void 0;
              })();
              if (l > 0n)
                return new s.MigratableSupplyPosition_AaveV2({
                  user: e,
                  loanToken: t.address,
                  supply: l,
                  supplyApy: (0, h.rateToApy)(u, 's', 27, !0),
                  max: p,
                  nonce: c,
                  aToken: d,
                  chainId: y,
                });
            }
          ).filter(i.isDefined),
          S = C.filter(({ supply: { isCollateral: e, totalSupply: t } }) => e && t > 0n),
          P = C.filter(({ borrow: { totalBorrow: e } }) => e > 0n);
        if (1 === S.length && 1 === P.length) {
          let { underlying: t, supply: n } = S[0],
            { underlying: i, borrow: a } = P[0],
            s = (() => {
              if (!n.isActive)
                return { value: 0n, limiter: o.SupplyMigrationLimiter.withdrawPaused };
              let e = n.poolLiquidity,
                t = n.totalSupply,
                i = r.MathLib.min(e, t);
              return i === e
                ? { value: e, limiter: o.SupplyMigrationLimiter.liquidity }
                : i === t
                  ? { value: t, limiter: o.SupplyMigrationLimiter.position }
                  : void 0;
            })(),
            l = a.isActive
              ? { value: a.totalBorrow, limiter: o.BorrowMigrationLimiter.position }
              : { value: 0n, limiter: o.BorrowMigrationLimiter.repayPaused };
          I.push(
            new p.MigratableBorrowPosition_AaveV2({
              loanToken: i,
              collateralToken: t,
              collateral: n.totalSupply,
              borrow: a.totalBorrow,
              collateralApy: (0, h.rateToApy)(n.currentLiquidityRate, 's', 27, !0),
              borrowApy: (0, h.rateToApy)(a.currentVariableBorrowRate, 's', 27, !0),
              lltv: a.liquidationThreshold * (0, u.parseUnits)('1', 14),
              aToken: n.aTokenData,
              nonce: n.nonce,
              chainId: y,
              user: e,
              maxRepay: l,
              maxWithdraw: s,
              collateralPriceEth: n.ethPrice,
              loanPriceEth: a.ethPrice,
              morphoNonce: a.morphoNonce,
              isBundlerManaging: a.isBundlerManaging,
            })
          );
        }
        return I;
      }
    },
    21227: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }), (t.fetchAaveV3Positions = f);
      let r = n(40252),
        i = n(35047),
        a = n(4565),
        s = n(52707),
        o = n(28893),
        l = n(27256),
        u = n(16316),
        c = n(78711),
        d = n(18166),
        p = n(93001),
        h = n(33149),
        y = n(97992);
      async function f(e, t, n = {}) {
        n.chainId ??= await (0, o.getChainId)(t);
        let f = n.chainId,
          {
            morpho: m,
            bundler3: { generalAdapter1: g },
          } = (0, r.getChainAddresses)(f),
          b = u.migrationAddresses[f]?.[p.MigratableProtocol.aaveV3];
        if (!b) return [];
        let [w, v, T, A] = await Promise.all([
            (0, o.readContract)(t, {
              ...n,
              abi: b.protocolDataProvider.abi,
              address: b.protocolDataProvider.address,
              functionName: 'getAllATokens',
              args: [],
            }),
            (0, o.readContract)(t, {
              ...n,
              abi: b.pool.abi,
              address: b.pool.address,
              functionName: 'getUserConfiguration',
              args: [e],
            }),
            (0, o.readContract)(t, {
              ...n,
              abi: b.pool.abi,
              address: b.pool.address,
              functionName: 'getReservesList',
              args: [],
            }),
            (0, o.readContract)(t, {
              ...n,
              abi: b.addressesProvider.abi,
              address: b.addressesProvider.address,
              functionName: 'getPriceOracle',
              args: [],
            }),
          ]),
          E = v.data
            .toString(2)
            .split('')
            .reduceRight((e, t) => {
              let n = e[e.length - 1];
              return n && 2 !== n.length ? [...e.slice(0, -1), n + t] : e.concat(t);
            }, []),
          C = Object.fromEntries(
            T.map((e, t) => {
              let n = E[t] ?? '00';
              return [e, { isUsedAsCollateral: '1' === n[1], isBorrowed: '1' === n[0] }];
            })
          ),
          _ = (
            await Promise.all(
              w.map(async ({ tokenAddress: r }) => {
                let [i, u, c, d] = await Promise.all([
                    (0, o.readContract)(t, {
                      ...n,
                      abi: l.aTokenV3Abi,
                      address: r,
                      functionName: 'UNDERLYING_ASSET_ADDRESS',
                      args: [],
                    }),
                    (0, o.readContract)(t, {
                      ...n,
                      abi: l.aTokenV3Abi,
                      address: r,
                      functionName: 'balanceOf',
                      args: [e],
                    }),
                    (0, o.readContract)(t, {
                      ...n,
                      abi: l.aTokenV3Abi,
                      address: r,
                      functionName: 'nonces',
                      args: [e],
                    }),
                    (0, a.fetchToken)(r, t, n),
                  ]),
                  p = C[i];
                if (!p) return;
                let [
                    h,
                    [, , y, , , f, , , w],
                    {
                      currentLiquidityRate: v,
                      variableDebtTokenAddress: T,
                      currentVariableBorrowRate: E,
                    },
                    _,
                    I,
                  ] = await Promise.all([
                    (0, o.readContract)(t, {
                      ...n,
                      abi: s.erc20Abi,
                      address: i,
                      functionName: 'balanceOf',
                      args: [r],
                    }),
                    (0, o.readContract)(t, {
                      ...n,
                      abi: b.protocolDataProvider.abi,
                      address: b.protocolDataProvider.address,
                      functionName: 'getReserveConfigurationData',
                      args: [i],
                    }),
                    (0, o.readContract)(t, {
                      ...n,
                      abi: b.pool.abi,
                      address: b.pool.address,
                      functionName: 'getReserveData',
                      args: [i],
                    }),
                    (0, o.readContract)(t, {
                      ...n,
                      ...b.protocolDataProvider,
                      functionName: 'getReserveEModeCategory',
                      args: [i],
                    }),
                    (0, a.fetchToken)(i, t, n),
                  ]),
                  [S, P, O, N] = await Promise.all([
                    (0, o.readContract)(t, {
                      ...n,
                      abi: l.variableDebtTokenV3Abi,
                      address: T,
                      functionName: 'balanceOf',
                      args: [e],
                    }),
                    (0, o.readContract)(t, {
                      ...n,
                      ...b.pool,
                      functionName: 'getEModeCategoryData',
                      args: [Number(_)],
                    }),
                    (0, o.readContract)(t, {
                      ...n,
                      abi: a.blueAbi,
                      address: m,
                      functionName: 'nonce',
                      args: [e],
                    }),
                    (0, o.readContract)(t, {
                      ...n,
                      abi: a.blueAbi,
                      address: m,
                      functionName: 'isAuthorized',
                      args: [e, g],
                    }),
                  ]),
                  x = await (0, o.readContract)(t, {
                    ...n,
                    abi: l.aaveV3OracleAbi,
                    address: A,
                    functionName: 'getAssetPrice',
                    args: [0n === _ ? i : P.priceSource],
                  });
                return {
                  underlying: I,
                  supply: {
                    isCollateral: p.isUsedAsCollateral && f,
                    poolLiquidity: h,
                    totalSupply: u,
                    isActive: w,
                    currentLiquidityRate: v,
                    aTokenData: d,
                    nonce: c,
                    ethPrice: x,
                  },
                  borrow: {
                    liquidationThreshold: 0n === _ ? y : BigInt(P.liquidationThreshold),
                    currentVariableBorrowRate: E,
                    totalBorrow: S,
                    isActive: w,
                    ethPrice: x,
                    morphoNonce: O,
                    isBundlerManaging: N,
                  },
                };
              })
            )
          ).filter(i.isDefined),
          I = (0, i.values)(C).some(({ isBorrowed: e }) => e),
          S = _.map(
            ({
              underlying: t,
              supply: {
                isCollateral: n,
                isActive: i,
                poolLiquidity: a,
                totalSupply: s,
                currentLiquidityRate: o,
                nonce: l,
                aTokenData: u,
              },
            }) => {
              if (I && n) return;
              let d = (() => {
                if (!i) return { value: 0n, limiter: h.SupplyMigrationLimiter.withdrawPaused };
                let e = r.MathLib.min(a, s);
                return e === a
                  ? { value: a, limiter: h.SupplyMigrationLimiter.liquidity }
                  : e === s
                    ? { value: s, limiter: h.SupplyMigrationLimiter.position }
                    : void 0;
              })();
              if (s > 0n)
                return new c.MigratableSupplyPosition_AaveV3({
                  user: e,
                  loanToken: t.address,
                  supply: s,
                  supplyApy: (0, y.rateToApy)(o, 's', 27, !0),
                  max: d,
                  nonce: l,
                  aToken: u,
                  chainId: f,
                });
            }
          ).filter(i.isDefined),
          P = _.filter(({ supply: { isCollateral: e, totalSupply: t } }) => e && t > 0n),
          O = _.filter(({ borrow: { totalBorrow: e } }) => e > 0n);
        if (1 === P.length && 1 === O.length) {
          let { underlying: t, supply: n } = P[0],
            { underlying: i, borrow: a } = O[0],
            o = (() => {
              if (!n.isActive)
                return { value: 0n, limiter: h.SupplyMigrationLimiter.withdrawPaused };
              let e = n.poolLiquidity,
                t = n.totalSupply,
                i = r.MathLib.min(e, t);
              return i === e
                ? { value: e, limiter: h.SupplyMigrationLimiter.liquidity }
                : i === t
                  ? { value: t, limiter: h.SupplyMigrationLimiter.position }
                  : void 0;
            })(),
            l = a.isActive
              ? { value: a.totalBorrow, limiter: h.BorrowMigrationLimiter.position }
              : { value: 0n, limiter: h.BorrowMigrationLimiter.repayPaused };
          S.push(
            new d.MigratableBorrowPosition_AaveV3({
              loanToken: i,
              collateralToken: t,
              collateral: n.totalSupply,
              borrow: a.totalBorrow,
              collateralApy: (0, y.rateToApy)(n.currentLiquidityRate, 's', 27, !0),
              borrowApy: (0, y.rateToApy)(a.currentVariableBorrowRate, 's', 27, !0),
              lltv: a.liquidationThreshold * (0, s.parseUnits)('1', 14),
              aToken: n.aTokenData,
              nonce: n.nonce,
              chainId: f,
              user: e,
              maxRepay: l,
              maxWithdraw: o,
              collateralPriceEth: n.ethPrice,
              loanPriceEth: a.ethPrice,
              morphoNonce: a.morphoNonce,
              isBundlerManaging: a.isBundlerManaging,
            })
          );
        }
        return S;
      }
    },
    49891: function (e, t, n) {
      'use strict';
      var r;
      Object.defineProperty(t, '__esModule', { value: !0 }), (t.MorphoAaveMath = void 0);
      let i = n(40252),
        a = n(52707),
        s = n(97992);
      !(function (e) {
        function t(e) {
          return (0, a.parseUnits)((0, s.rateToApy)(e, 's', 27, !0).toFixed(4), 4);
        }
        (e.INDEX_ONE = (0, a.parseUnits)('1', 27)),
          (e.indexMul = (t, n) => i.MathLib.mulDivDown(BigInt(t), BigInt(n), e.INDEX_ONE)),
          (e.indexDiv = (t, n) => i.MathLib.mulDivDown(BigInt(t), e.INDEX_ONE, BigInt(n))),
          (e.indexDivUp = (t, n) =>
            i.MathLib.mulDivDown(BigInt(t) + e.INDEX_ONE / 2n, e.INDEX_ONE, BigInt(n))),
          (e.PERCENT_ONE = (0, a.parseUnits)('1', 4)),
          (e.percentMul = (t, n) => i.MathLib.mulDivDown(BigInt(t), BigInt(n), e.PERCENT_ONE)),
          (e.percentToWad = (t) => e.percentMul(t, (0, a.parseUnits)('1', 18))),
          (e.computeApysFromRates = function (n, r, i, a = 0n, s = 0n, o = 0n, l = 0n) {
            let {
              p2pBorrowRate: u,
              p2pSupplyRate: c,
              midRate: d,
            } = (function (t, n, r, i = 0n, a = 0n, s = 0n, o = 0n) {
              let l = n < t ? n : ((e.PERCENT_ONE - r) * t + n * r) / e.PERCENT_ONE,
                u = l - e.percentMul(l - t, i),
                c = l + e.percentMul(n - l, i);
              return {
                p2pSupplyRate: e.indexMul(e.INDEX_ONE - a - o, u) + e.indexMul(a, t),
                p2pBorrowRate: e.indexMul(e.INDEX_ONE - s, c) + e.indexMul(s, n),
                midRate: l,
              };
            })(n, r, BigInt(i), BigInt(l), a, s, o);
            return {
              poolBorrowAPY: t(r),
              poolSupplyAPY: t(n),
              p2pSupplyAPY: t(c),
              p2pBorrowAPY: t(u),
              p2pAPY: t(d),
            };
          });
      })(r || (t.MorphoAaveMath = r = {}));
    },
    84124: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }), (t.fetchAaveV3OptimizerPositions = y);
      let r = n(40252),
        i = n(35047),
        a = n(16316),
        s = n(74128),
        o = n(93001),
        l = n(33149),
        u = n(52707),
        c = n(28893),
        d = n(27256),
        p = n(49891),
        h = n(15347);
      async function y(e, t, n = {}) {
        n.chainId ??= await (0, c.getChainId)(t);
        let y = n.chainId,
          f = a.migrationAddresses[y]?.[o.MigratableProtocol.aaveV3Optimizer];
        if (!f) return [];
        let [m, g, b] = await Promise.all([
          [r.addressesRegistry[r.ChainId.EthMainnet].wNative],
          (0, c.readContract)(t, {
            ...n,
            abi: f.morpho.abi,
            address: f.morpho.address,
            functionName: 'isManagedBy',
            args: [
              e,
              r.addressesRegistry[r.ChainId.EthMainnet].bundler3.aaveV3OptimizerMigrationAdapter,
            ],
          }),
          (0, c.readContract)(t, {
            ...n,
            abi: f.morpho.abi,
            address: f.morpho.address,
            functionName: 'userNonce',
            args: [e],
          }),
        ]);
        return (
          await Promise.all(
            m.map(async (i) => {
              let [
                a,
                s,
                [, , , , , o, y, , , m, g, b],
                {
                  reserveFactor: w,
                  p2pIndexCursor: v,
                  deltas: T,
                  indexes: {
                    supply: { p2pIndex: A, poolIndex: E },
                    borrow: { p2pIndex: C, poolIndex: _ },
                  },
                  idleSupply: I,
                  pauseStatuses: { isWithdrawPaused: S },
                  variableDebtToken: P,
                  stableDebtToken: O,
                  aToken: N,
                },
                [x],
                M,
              ] = await Promise.all([
                (0, c.readContract)(t, {
                  ...n,
                  abi: f.morpho.abi,
                  address: f.morpho.address,
                  functionName: 'scaledP2PSupplyBalance',
                  args: [i, e],
                }),
                (0, c.readContract)(t, {
                  ...n,
                  abi: f.morpho.abi,
                  address: f.morpho.address,
                  functionName: 'scaledPoolSupplyBalance',
                  args: [i, e],
                }),
                (0, c.readContract)(t, {
                  ...n,
                  abi: f.poolDataProvider.abi,
                  address: f.poolDataProvider.address,
                  functionName: 'getReserveData',
                  args: [i],
                }),
                (0, c.readContract)(t, {
                  ...n,
                  abi: f.morpho.abi,
                  address: f.morpho.address,
                  functionName: 'market',
                  args: [i],
                }),
                (0, c.readContract)(t, {
                  ...n,
                  abi: f.poolDataProvider.abi,
                  address: f.poolDataProvider.address,
                  functionName: 'getReserveCaps',
                  args: [i],
                }),
                (0, c.getBlock)(t, { blockTag: 'latest', includeTransactions: !1 }),
              ]);
              if (0n === a && 0n === s) return null;
              let [k, R, D, B] = await Promise.all([
                  (0, c.readContract)(t, {
                    ...n,
                    abi: d.variableDebtTokenV3Abi,
                    address: P,
                    functionName: 'scaledTotalSupply',
                    args: [],
                  }),
                  (0, c.readContract)(t, {
                    ...n,
                    abi: u.erc20Abi,
                    address: O,
                    functionName: 'totalSupply',
                    args: [],
                  }),
                  (0, c.readContract)(t, {
                    ...n,
                    abi: u.erc20Abi,
                    address: i,
                    functionName: 'balanceOf',
                    args: [N],
                  }),
                  (0, c.readContract)(t, {
                    ...n,
                    abi: u.erc20Abi,
                    address: i,
                    functionName: 'decimals',
                    args: [],
                  }),
                ]),
                { newPoolSupplyIndex: U, newPoolBorrowIndex: L } =
                  h.PoolInterestRates.computePoolIndexes({
                    liquidityRate: o,
                    variableBorrowRate: y,
                    lastUpdateTimestamp: b,
                    liquidityIndex: m,
                    variableBorrowIndex: g,
                    currentTimestamp: BigInt(M.timestamp),
                  }),
                F =
                  0n === I
                    ? 0n
                    : r.MathLib.min(
                        p.MorphoAaveMath.INDEX_ONE,
                        p.MorphoAaveMath.indexDiv(
                          I,
                          p.MorphoAaveMath.indexMul(T.supply.scaledP2PTotal, A)
                        )
                      ),
                j =
                  0n === I
                    ? 0n
                    : r.MathLib.min(
                        p.MorphoAaveMath.INDEX_ONE - F,
                        p.MorphoAaveMath.indexDiv(
                          p.MorphoAaveMath.indexMul(T.supply.scaledDelta, U),
                          p.MorphoAaveMath.indexMul(T.supply.scaledP2PTotal, A)
                        )
                      ),
                q =
                  0n === I
                    ? 0n
                    : r.MathLib.min(
                        p.MorphoAaveMath.INDEX_ONE,
                        p.MorphoAaveMath.indexDiv(
                          p.MorphoAaveMath.indexMul(T.borrow.scaledDelta, L),
                          p.MorphoAaveMath.indexMul(T.borrow.scaledP2PTotal, C)
                        )
                      ),
                { newP2PSupplyIndex: V } = h.P2PInterestRates.computeP2PIndexes({
                  p2pIndexCursor: v,
                  lastBorrowIndexes: { p2pIndex: C, poolIndex: _ },
                  lastSupplyIndexes: { p2pIndex: A, poolIndex: E },
                  poolSupplyIndex: U,
                  poolBorrowIndex: L,
                  deltas: T,
                  reserveFactor: w,
                  proportionIdle: F,
                }),
                $ = p.MorphoAaveMath.computeApysFromRates(o, y, v, j, q, F, w),
                z = p.MorphoAaveMath.indexMul(a, V),
                W = p.MorphoAaveMath.indexMul(s, U),
                H = z + W,
                G = (() => {
                  let e = p.MorphoAaveMath.indexMul(k, L);
                  if (S) return { value: 0n, limiter: l.SupplyMigrationLimiter.withdrawPaused };
                  let t =
                      0n === x
                        ? u.maxUint256
                        : W + r.MathLib.max(x * (0, u.parseUnits)('1', B) - (e + R), 0n),
                    n = r.MathLib.min(D, t, H);
                  return n === D
                    ? { value: D, limiter: l.SupplyMigrationLimiter.liquidity }
                    : n === t
                      ? { value: t, limiter: l.SupplyMigrationLimiter.protocolCap }
                      : n === H
                        ? { value: H, limiter: l.SupplyMigrationLimiter.position }
                        : void 0;
                })();
              return {
                underlyingAddress: i,
                supply: H,
                supplyApy:
                  0n === H
                    ? 0
                    : Number(
                        (0, u.formatEther)(
                          r.MathLib.wDivDown($.p2pSupplyAPY * z + $.poolSupplyAPY * W, H)
                        )
                      ),
                max: G,
              };
            })
          )
        )
          .filter(i.isDefined)
          .flatMap(({ underlyingAddress: t, supply: n, supplyApy: r, max: i }) =>
            n > 0n
              ? [
                  new s.MigratableSupplyPosition_AaveV3Optimizer({
                    user: e,
                    loanToken: t,
                    supply: n,
                    supplyApy: r,
                    max: i,
                    isBundlerManaging: g,
                    nonce: b,
                    chainId: y,
                  }),
                ]
              : []
          );
      }
    },
    15347: function (e, t, n) {
      'use strict';
      var r, i;
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.P2PInterestRates = t.PoolInterestRates = void 0);
      let a = n(40252),
        s = n(35047),
        o = n(49891);
      ((r || (t.PoolInterestRates = r = {})).computePoolIndexes = function ({
        liquidityIndex: e,
        variableBorrowIndex: t,
        liquidityRate: n,
        variableBorrowRate: r,
        lastUpdateTimestamp: i,
        currentTimestamp: a,
      }) {
        return BigInt(i) >= a
          ? { newPoolSupplyIndex: e, newPoolBorrowIndex: t }
          : {
              newPoolSupplyIndex: o.MorphoAaveMath.indexMul(
                e,
                (function (e, t, n) {
                  let r = n - t;
                  return 0n === r
                    ? o.MorphoAaveMath.INDEX_ONE
                    : o.MorphoAaveMath.INDEX_ONE + (e * r) / s.Time.s.from.y(1n);
                })(n, BigInt(i), a)
              ),
              newPoolBorrowIndex: o.MorphoAaveMath.indexMul(
                t,
                (function (e, t, n) {
                  let r = n - t;
                  if (0n === r) return o.MorphoAaveMath.INDEX_ONE;
                  let i = r - 1n,
                    a =
                      o.MorphoAaveMath.indexMul(e, e) / (s.Time.s.from.y(1n) * s.Time.s.from.y(1n)),
                    l = o.MorphoAaveMath.indexMul(a, e) / s.Time.s.from.y(1n),
                    u = (r * i * a) / 2n;
                  return (
                    o.MorphoAaveMath.INDEX_ONE +
                    (e * r) / s.Time.s.from.y(1n) +
                    u +
                    (r * i * (r > 2n ? r - 2n : 0n) * l) / 6n
                  );
                })(r, BigInt(i), a)
              ),
            };
      }),
        (function (e) {
          function t(e, t, n, r, i, s) {
            if (0n === i || (0n === r && 0n === s)) return o.MorphoAaveMath.indexMul(n.p2pIndex, t);
            let l = a.MathLib.min(
              o.MorphoAaveMath.indexDivUp(
                o.MorphoAaveMath.indexMul(r, n.poolIndex),
                o.MorphoAaveMath.indexMul(i, n.p2pIndex)
              ),
              o.MorphoAaveMath.INDEX_ONE - s
            );
            return o.MorphoAaveMath.indexMul(
              n.p2pIndex,
              o.MorphoAaveMath.indexMul(t, o.MorphoAaveMath.INDEX_ONE - l - s) +
                o.MorphoAaveMath.indexMul(e, l) +
                s
            );
          }
          function n(e, t, n) {
            return (
              (e * (o.MorphoAaveMath.PERCENT_ONE - n) + t * n + o.MorphoAaveMath.PERCENT_ONE / 2n) /
              o.MorphoAaveMath.PERCENT_ONE
            );
          }
          (e.computeP2PIndexes = function ({
            p2pIndexCursor: e,
            lastBorrowIndexes: r,
            lastSupplyIndexes: i,
            poolBorrowIndex: a,
            poolSupplyIndex: s,
            deltas: l,
            reserveFactor: u,
            proportionIdle: c,
          }) {
            let {
              poolSupplyGrowthFactor: d,
              poolBorrowGrowthFactor: p,
              p2pBorrowGrowthFactor: h,
              p2pSupplyGrowthFactor: y,
            } = (function (e, t, r, i, a, s) {
              let l, u;
              let c = o.MorphoAaveMath.indexDiv(e, r),
                d = o.MorphoAaveMath.indexDiv(t, i);
              if (c <= d) {
                let e = n(c, d, a);
                (l = e - o.MorphoAaveMath.percentMul(e - c, s)),
                  (u = e + o.MorphoAaveMath.percentMul(d - e, s));
              } else (l = d), (u = d);
              return {
                poolSupplyGrowthFactor: c,
                p2pSupplyGrowthFactor: l,
                poolBorrowGrowthFactor: d,
                p2pBorrowGrowthFactor: u,
              };
            })(s, a, i.poolIndex, r.poolIndex, BigInt(e), BigInt(u));
            return {
              newP2PSupplyIndex: t(d, y, i, l.supply.scaledDelta, l.supply.scaledP2PTotal, c),
              newP2PBorrowIndex: t(p, h, r, l.borrow.scaledDelta, l.borrow.scaledP2PTotal, 0n),
            };
          }),
            (e.computeP2PSupplyRatePerYear = function ({
              poolSupplyRatePerYear: e,
              poolBorrowRatePerYear: t,
              poolIndex: r,
              p2pIndex: i,
              p2pIndexCursor: s,
              reserveFactor: l,
              proportionIdle: u,
              delta: c,
            }) {
              let d;
              if (e > t) d = t;
              else {
                let r = n(e, t, s);
                d = r - o.MorphoAaveMath.percentMul(r - t, l);
              }
              if (c.scaledDelta > 0n && c.scaledP2PTotal > 0n) {
                let t = a.MathLib.min(
                  o.MorphoAaveMath.indexDivUp(
                    o.MorphoAaveMath.indexMul(c.scaledDelta, r),
                    o.MorphoAaveMath.indexMul(c.scaledP2PTotal, i)
                  ),
                  o.MorphoAaveMath.INDEX_ONE - u
                );
                d =
                  o.MorphoAaveMath.indexMul(d, o.MorphoAaveMath.INDEX_ONE - t - u) +
                  o.MorphoAaveMath.indexMul(e, t) +
                  u;
              }
              return d;
            }),
            (e.computeP2PBorrowRatePerYear = function ({
              poolSupplyRatePerYear: e,
              poolBorrowRatePerYear: t,
              poolIndex: r,
              p2pIndex: i,
              p2pIndexCursor: s,
              reserveFactor: l,
              proportionIdle: u,
              delta: c,
            }) {
              let d;
              if (e > t) d = t;
              else {
                let r = n(e, t, s);
                d = r + o.MorphoAaveMath.percentMul(t - r, l);
              }
              if (c.scaledDelta > 0n && c.scaledP2PTotal > 0n) {
                let e = a.MathLib.min(
                  o.MorphoAaveMath.indexDivUp(
                    o.MorphoAaveMath.indexMul(c.scaledDelta, r),
                    o.MorphoAaveMath.indexMul(c.scaledP2PTotal, i)
                  ),
                  o.MorphoAaveMath.INDEX_ONE - u
                );
                d =
                  o.MorphoAaveMath.indexMul(d, o.MorphoAaveMath.INDEX_ONE - e - u) +
                  o.MorphoAaveMath.indexMul(t, e) +
                  u;
              }
              return d;
            });
        })(i || (t.P2PInterestRates = i = {}));
    },
    98144: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.COMPOUNDING_PERIOD = void 0),
        (t.fetchCompoundV2Positions = h);
      let r = n(40252),
        i = n(35047),
        a = n(16316),
        s = n(95556),
        o = n(93001),
        l = n(97992),
        u = n(28893),
        c = n(67317),
        d = n(66219);
      async function p(e, n, i, s = {}) {
        s.chainId ??= await (0, u.getChainId)(i);
        let p = s.chainId,
          { abi: h, calls: y } =
            p === r.ChainId.EthMainnet
              ? n ===
                a.migrationAddressesRegistry[r.ChainId.EthMainnet][o.MigratableProtocol.compoundV2]
                  .cEth.address
                ? {
                    calls: [
                      r.NATIVE_ADDRESS,
                      (0, u.readContract)(i, {
                        ...s,
                        abi: c.cEtherAbi,
                        address: n,
                        functionName: 'supplyRatePerBlock',
                        args: [],
                      }),
                    ],
                    abi: c.cEtherAbi,
                  }
                : {
                    calls: [
                      (0, u.readContract)(i, {
                        ...s,
                        abi: c.cErc20Abi,
                        address: n,
                        functionName: 'underlying',
                        args: [],
                      }),
                      (0, u.readContract)(i, {
                        ...s,
                        abi: c.cErc20Abi,
                        address: n,
                        functionName: 'supplyRatePerBlock',
                        args: [],
                      }),
                    ],
                    abi: c.cErc20Abi,
                  }
              : {
                  calls: [
                    (0, u.readContract)(i, {
                      ...s,
                      abi: c.mErc20Abi,
                      address: n,
                      functionName: 'underlying',
                      args: [],
                    }),
                    (0, u.readContract)(i, {
                      ...s,
                      abi: c.mErc20Abi,
                      address: n,
                      functionName: 'supplyRatePerTimestamp',
                      args: [],
                    }),
                  ],
                  abi: c.mErc20Abi,
                },
          {
            wNative: f,
            bundler3: { compoundV2MigrationAdapter: m },
          } = (0, r.getChainAddresses)(p);
        if (null == m) throw Error('missing compoundV2MigrationAdapter address');
        let g = t.COMPOUNDING_PERIOD[p];
        if (null == g) throw Error(`missing compounding period on chain ${p}`);
        let [b, w, v, T, A, E, C, _, I] = await Promise.all([
            (0, u.readContract)(i, {
              ...s,
              abi: h,
              address: n,
              functionName: 'balanceOf',
              args: [e],
            }),
            (0, u.readContract)(i, {
              ...s,
              abi: h,
              address: n,
              functionName: 'allowance',
              args: [e, m],
            }),
            (0, u.readContract)(i, { ...s, abi: h, address: n, functionName: 'getCash', args: [] }),
            (0, u.readContract)(i, { ...s, abi: h, address: n, functionName: 'name', args: [] }),
            (0, u.readContract)(i, {
              ...s,
              abi: h,
              address: n,
              functionName: 'decimals',
              args: [],
            }),
            (0, u.readContract)(i, { ...s, abi: h, address: n, functionName: 'symbol', args: [] }),
            (0, d.fetchAccruedExchangeRate)(n, i, s),
            ...y,
          ]),
          S = new r.ExchangeRateWrappedToken(
            { name: T, decimals: Number(A), symbol: E, address: n },
            _,
            C
          ),
          P = S.toUnwrappedExactAmountIn(b),
          O =
            v < P
              ? { value: v, limiter: o.SupplyMigrationLimiter.liquidity }
              : { value: P, limiter: o.SupplyMigrationLimiter.position };
        return {
          supplyBalance: P,
          cToken: S,
          cTokenBalance: b,
          loanToken: _ === r.NATIVE_ADDRESS ? f : _,
          max: O,
          supplyApy: (0, l.rateToApy)(I, g),
          bundlerAllowance: w,
        };
      }
      async function h(e, t, n = {}) {
        n.chainId ??= await (0, u.getChainId)(t);
        let r = n.chainId,
          l = a.migrationAddresses[r]?.[o.MigratableProtocol.compoundV2];
        if (!l) return [];
        let { comptroller: c, ...d } = l,
          h = new Set(
            await (0, u.readContract)(t, {
              ...n,
              abi: l.comptroller.abi,
              address: l.comptroller.address,
              functionName: 'getAssetsIn',
              args: [e],
            })
          );
        return (
          await Promise.all(
            (0, i.values)(d).map(({ address: r }) =>
              h.has(r) ? null : p(e, r, t, n).catch(() => null)
            )
          )
        )
          .filter(i.isDefined)
          .filter(i.isDefined)
          .flatMap(
            ({
              supplyBalance: t,
              cToken: n,
              loanToken: i,
              max: a,
              supplyApy: o,
              bundlerAllowance: l,
              cTokenBalance: u,
            }) =>
              0n === t
                ? []
                : [
                    new s.MigratableSupplyPosition_CompoundV2({
                      user: e,
                      chainId: r,
                      loanToken: i,
                      supply: t,
                      supplyApy: o,
                      max: a,
                      cToken: n,
                      bundlerAllowance: l,
                      cTokenBalance: u,
                    }),
                  ]
          );
      }
      t.COMPOUNDING_PERIOD = {
        [r.ChainId.BaseMainnet]: 's',
        [r.ChainId.EthMainnet]: { unit: 's', duration: 12 },
      };
    },
    66219: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.fetchAccruedExchangeRate = t.getAccruedExchangeRate = void 0);
      let r = n(40252),
        i = n(28893),
        a = n(67317);
      t.getAccruedExchangeRate = (
        {
          lastExchangeRate: e,
          lastUpdateUnit: t,
          cash: n,
          totalBorrows: i,
          totalSupply: a,
          totalReserves: s,
          reserveFactorMantissa: o,
          borrowRatePerUnit: l,
        },
        u
      ) => {
        let c = u - t;
        if (c < 0n) throw Error(`New block unit (${u}) must be bigger than last block unit (${t})`);
        if (0n === c) return e;
        let d = r.MathLib.wMulDown(l * c, i),
          p = d + i,
          h = r.MathLib.wMulDown(o, d) + s;
        return 0n === a ? e : r.MathLib.wDivDown(n + p - h, a);
      };
      let s = async (e, n, s = {}) => {
        s.chainId ??= await (0, i.getChainId)(n);
        let o = s.chainId,
          { abi: l, calls: u } =
            o === r.ChainId.EthMainnet
              ? {
                  calls: [
                    (0, i.readContract)(n, {
                      ...s,
                      abi: a.cErc20Abi,
                      address: e,
                      functionName: 'accrualBlockNumber',
                      args: [],
                    }),
                    (0, i.readContract)(n, {
                      ...s,
                      abi: a.cErc20Abi,
                      address: e,
                      functionName: 'borrowRatePerBlock',
                      args: [],
                    }),
                    (0, i.getBlock)(n, { blockTag: 'latest', includeTransactions: !1 }).then(
                      (e) => e.number
                    ),
                  ],
                  abi: a.cErc20Abi,
                }
              : {
                  calls: [
                    (0, i.readContract)(n, {
                      ...s,
                      abi: a.mErc20Abi,
                      address: e,
                      functionName: 'accrualBlockTimestamp',
                      args: [],
                    }),
                    (0, i.readContract)(n, {
                      ...s,
                      abi: a.mErc20Abi,
                      address: e,
                      functionName: 'borrowRatePerTimestamp',
                      args: [],
                    }),
                    (0, i.getBlock)(n, { blockTag: 'latest', includeTransactions: !1 }).then(
                      (e) => e.timestamp
                    ),
                  ],
                  abi: a.mErc20Abi,
                },
          [c, d, p, h, y, f, m, g, b] = await Promise.all([
            (0, i.readContract)(n, {
              ...s,
              abi: l,
              address: e,
              functionName: 'exchangeRateStored',
              args: [],
            }),
            (0, i.readContract)(n, {
              ...s,
              abi: l,
              address: e,
              functionName: 'totalBorrows',
              args: [],
            }),
            (0, i.readContract)(n, {
              ...s,
              abi: l,
              address: e,
              functionName: 'totalSupply',
              args: [],
            }),
            (0, i.readContract)(n, {
              ...s,
              abi: l,
              address: e,
              functionName: 'totalReserves',
              args: [],
            }),
            (0, i.readContract)(n, {
              ...s,
              abi: l,
              address: e,
              functionName: 'reserveFactorMantissa',
              args: [],
            }),
            (0, i.readContract)(n, { ...s, abi: l, address: e, functionName: 'getCash', args: [] }),
            ...u,
          ]);
        return (0, t.getAccruedExchangeRate)(
          {
            lastExchangeRate: c,
            lastUpdateUnit: m,
            cash: f,
            totalBorrows: d,
            totalSupply: p,
            totalReserves: h,
            reserveFactorMantissa: y,
            borrowRatePerUnit: g,
          },
          o === r.ChainId.BaseMainnet ? BigInt(b) + 2n : BigInt(b) + 1n
        );
      };
      t.fetchAccruedExchangeRate = s;
    },
    42675: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }), (t.fetchCompoundV3Positions = y);
      let r = n(40252),
        i = n(35047),
        a = n(4565),
        s = n(28893),
        o = n(35727),
        l = n(16316),
        u = n(46813),
        c = n(70800),
        d = n(93001),
        p = n(97992);
      async function h(e, t, n, i = {}) {
        i.chainId ??= await (0, s.getChainId)(n);
        let l = i.chainId,
          {
            morpho: h,
            bundler3: { generalAdapter1: y },
          } = (0, r.getChainAddresses)(l),
          [f, m, g, b, w, v, T, A, E, [, , , C]] = await Promise.all([
            (0, s.readContract)(n, {
              ...i,
              abi: o.cometAbi,
              address: t,
              functionName: 'balanceOf',
              args: [e],
            }),
            (0, s.readContract)(n, {
              ...i,
              abi: o.cometAbi,
              address: t,
              functionName: 'borrowBalanceOf',
              args: [e],
            }),
            (0, s.readContract)(n, {
              ...i,
              abi: o.cometAbi,
              address: t,
              functionName: 'userNonce',
              args: [e],
            }),
            (0, s.readContract)(n, {
              ...i,
              abi: o.cometAbi,
              address: t,
              functionName: 'baseToken',
              args: [],
            }),
            (0, s.readContract)(n, {
              ...i,
              abi: o.cometAbi,
              address: t,
              functionName: 'totalSupply',
              args: [],
            }),
            (0, s.readContract)(n, {
              ...i,
              abi: o.cometAbi,
              address: t,
              functionName: 'totalBorrow',
              args: [],
            }),
            (0, s.readContract)(n, {
              ...i,
              abi: o.cometAbi,
              address: t,
              functionName: 'getUtilization',
              args: [],
            }),
            (0, s.readContract)(n, {
              ...i,
              abi: o.cometExtAbi,
              address: t,
              functionName: 'name',
              args: [],
            }),
            (0, s.readContract)(n, {
              ...i,
              abi: o.cometAbi,
              address: t,
              functionName: 'baseBorrowMin',
              args: [],
            }),
            (0, s.readContract)(n, {
              ...i,
              abi: o.cometAbi,
              address: t,
              functionName: 'userBasic',
              args: [e],
            }),
          ]);
        if ((0n === f && 0n === m) || (C & (C - 1)) != 0) return;
        let _ = C.toString(2).split('').reverse().indexOf('1'),
          [I, S, P, O, N] = await Promise.all([
            (0, s.readContract)(n, {
              ...i,
              abi: o.cometAbi,
              address: t,
              functionName: 'getSupplyRate',
              args: [T],
            }),
            (0, s.readContract)(n, {
              ...i,
              abi: o.cometAbi,
              address: t,
              functionName: 'getBorrowRate',
              args: [T],
            }),
            _ > -1
              ? (0, s.readContract)(n, {
                  ...i,
                  abi: o.cometAbi,
                  address: t,
                  functionName: 'getAssetInfo',
                  args: [_],
                })
              : null,
            (0, s.readContract)(n, {
              ...i,
              abi: o.cometAbi,
              address: t,
              functionName: 'baseTokenPriceFeed',
              args: [],
            }),
            (0, s.readContract)(n, {
              ...i,
              abi: o.cometAbi,
              address: t,
              functionName: 'isWithdrawPaused',
              args: [],
            }),
          ]);
        if (P) {
          let [r, c, f, w, v, T, C, _] = await Promise.all([
              (0, s.readContract)(n, {
                ...i,
                abi: o.cometExtAbi,
                address: t,
                functionName: 'collateralBalanceOf',
                args: [e, P.asset],
              }),
              (0, s.readContract)(n, {
                ...i,
                abi: o.cometAbi,
                address: t,
                functionName: 'getPrice',
                args: [P.priceFeed],
              }),
              (0, s.readContract)(n, {
                ...i,
                abi: o.cometAbi,
                address: t,
                functionName: 'getPrice',
                args: [O],
              }),
              (0, s.readContract)(n, {
                ...i,
                abi: a.blueAbi,
                address: h,
                functionName: 'nonce',
                args: [e],
              }),
              (0, s.readContract)(n, {
                ...i,
                abi: a.blueAbi,
                address: h,
                functionName: 'isAuthorized',
                args: [e, y],
              }),
              (0, s.readContract)(n, {
                ...i,
                abi: o.cometAbi,
                address: t,
                functionName: 'isSupplyPaused',
                args: [],
              }),
              (0, a.fetchToken)(b, n, i),
              (0, a.fetchToken)(P.asset, n, i),
            ]),
            I = N
              ? { value: 0n, limiter: d.SupplyMigrationLimiter.withdrawPaused }
              : { value: r, limiter: d.SupplyMigrationLimiter.position },
            x = T
              ? { value: 0n, limiter: d.BorrowMigrationLimiter.repayPaused }
              : { value: m, limiter: d.BorrowMigrationLimiter.position };
          return new u.MigratableBorrowPosition_CompoundV3({
            chainId: l,
            collateral: r,
            borrow: m,
            collateralApy: 0,
            borrowApy: (0, p.rateToApy)(S, 's'),
            collateralPriceUsd: c,
            loanPriceUsd: f,
            loanToken: C,
            nonce: g,
            morphoNonce: w,
            isBundlerManaging: v,
            baseBorrowMin: E,
            cometAddress: t,
            cometName: A,
            user: e,
            collateralToken: _,
            lltv: P.liquidateCollateralFactor,
            maxWithdraw: I,
            maxRepay: x,
          });
        }
        let x = (() => {
          if (N) return { value: 0n, limiter: d.SupplyMigrationLimiter.withdrawPaused };
          let e = w - v;
          return e < f
            ? { value: e, limiter: d.SupplyMigrationLimiter.liquidity }
            : { value: f, limiter: d.SupplyMigrationLimiter.position };
        })();
        return new c.MigratableSupplyPosition_CompoundV3({
          user: e,
          chainId: l,
          nonce: g,
          loanToken: b,
          supply: f,
          supplyApy: (0, p.rateToApy)(I, 's'),
          max: x,
          cometAddress: t,
          cometName: A,
        });
      }
      async function y(e, t, n = {}) {
        n.chainId ??= await (0, s.getChainId)(t);
        let r = n.chainId,
          a = l.migrationAddresses[r]?.[d.MigratableProtocol.compoundV3];
        return a
          ? (
              await Promise.all(
                (0, i.values)(a).map(({ address: r }) => h(e, r, t, n).catch(() => null))
              )
            ).filter(i.isDefined)
          : [];
      }
    },
    13403: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }), (t.fetchMigratablePositions = d);
      let r = n(93001),
        i = n(35047),
        a = n(44311),
        s = n(21227),
        o = n(84124),
        l = n(98144),
        u = n(42675),
        c = {
          [r.MigratableProtocol.aaveV2]: a.fetchAaveV2Positions,
          [r.MigratableProtocol.aaveV3]: s.fetchAaveV3Positions,
          [r.MigratableProtocol.aaveV3Optimizer]: o.fetchAaveV3OptimizerPositions,
          [r.MigratableProtocol.compoundV2]: l.fetchCompoundV2Positions,
          [r.MigratableProtocol.compoundV3]: u.fetchCompoundV3Positions,
        };
      async function d(
        e,
        t,
        {
          parameters: n = {},
          protocols: a = [
            r.MigratableProtocol.aaveV3Optimizer,
            r.MigratableProtocol.aaveV3,
            r.MigratableProtocol.aaveV2,
            r.MigratableProtocol.compoundV3,
            r.MigratableProtocol.compoundV2,
          ],
        } = {}
      ) {
        return (0, i.fromEntries)(await Promise.all(a.map(async (r) => [r, await c[r](e, t, n)])));
      }
    },
    33764: function (e, t, n) {
      'use strict';
      var r =
          (this && this.__createBinding) ||
          (Object.create
            ? function (e, t, n, r) {
                void 0 === r && (r = n);
                var i = Object.getOwnPropertyDescriptor(t, n);
                (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
                  (i = {
                    enumerable: !0,
                    get: function () {
                      return t[n];
                    },
                  }),
                  Object.defineProperty(e, r, i);
              }
            : function (e, t, n, r) {
                void 0 === r && (r = n), (e[r] = t[n]);
              }),
        i =
          (this && this.__exportStar) ||
          function (e, t) {
            for (var n in e)
              'default' === n || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n);
          };
      Object.defineProperty(t, '__esModule', { value: !0 }),
        i(n(93001), t),
        i(n(25754), t),
        i(n(13403), t),
        i(n(16316), t);
    },
    36027: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }), (t.MigratableBorrowPosition = void 0);
      class n {
        protocol;
        user;
        loanToken;
        borrow;
        borrowApy;
        chainId;
        collateralToken;
        collateral;
        collateralApy;
        maxRepay;
        maxWithdraw;
        lltv;
        isBundlerManaging;
        morphoNonce;
        constructor(e) {
          (this.protocol = e.protocol),
            (this.user = e.user),
            (this.loanToken = e.loanToken),
            (this.borrow = e.borrow),
            (this.borrowApy = e.borrowApy),
            (this.maxWithdraw = e.maxWithdraw),
            (this.chainId = e.chainId),
            (this.collateralToken = e.collateralToken),
            (this.collateral = e.collateral),
            (this.collateralApy = e.collateralApy),
            (this.maxRepay = e.maxRepay),
            (this.lltv = e.lltv),
            (this.isBundlerManaging = e.isBundlerManaging),
            (this.morphoNonce = e.morphoNonce);
        }
        getMigrationTx(e, t) {
          return this._validateMigration(e), this._getMigrationTx(e, t);
        }
        _validateMigration({ marketTo: e, borrowAmount: t, collateralAmount: n }) {
          if (
            e.collateralToken !== this.collateralToken.address ||
            e.loanToken !== this.loanToken.address
          )
            throw Error('Invalid market');
          if (t > this.maxRepay.value)
            throw Error(`Max borrow migration limited by: ${this.maxRepay.limiter}`);
          if (n > this.maxWithdraw.value)
            throw Error(`Max collateral migration limited by: ${this.maxWithdraw.limiter}`);
        }
      }
      t.MigratableBorrowPosition = n;
    },
    82152: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.MigratableBorrowPosition_AaveV2 = void 0);
      let r = n(40252),
        i = n(4565),
        a = n(56044),
        s = n(35047),
        o = n(52707),
        l = n(28893),
        u = n(14241),
        c = n(93001),
        d = n(18166);
      class p extends d.MigratableBorrowPosition {
        _nonce;
        aToken;
        collateralPriceEth;
        loanPriceEth;
        constructor(e) {
          super({ ...e, protocol: c.MigratableProtocol.aaveV2 }),
            (this.aToken = e.aToken),
            (this._nonce = e.nonce),
            (this.collateralPriceEth = e.collateralPriceEth),
            (this.loanPriceEth = e.loanPriceEth);
        }
        getLtv({ withdrawn: e = 0n, repaid: t = 0n } = {}) {
          let n =
              ((this.collateral - e) * this.collateralPriceEth) /
              (0, o.parseUnits)('1', this.collateralToken.decimals),
            i =
              ((this.borrow - t) * this.loanPriceEth) /
              (0, o.parseUnits)('1', this.loanToken.decimals);
          return i <= 0n ? null : n <= 0n ? o.maxUint256 : r.MathLib.wDivUp(i, n);
        }
        get nonce() {
          return this._nonce;
        }
        _getMigrationTx(
          {
            collateralAmount: e,
            borrowAmount: t,
            marketTo: n,
            slippageFrom: d = r.DEFAULT_SLIPPAGE_TOLERANCE,
            minSharePrice: p,
          },
          h = !0
        ) {
          let y = this.user,
            f = this.chainId,
            m = new a.ActionBundle(f),
            {
              morpho: g,
              bundler3: { generalAdapter1: b, aaveV2MigrationAdapter: w },
            } = (0, r.getChainAddresses)(f);
          if (null == w) throw Error('missing aaveV2MigrationAdapter address');
          let v = this.aToken,
            T = t,
            A = e,
            E =
              this.maxRepay.limiter === c.BorrowMigrationLimiter.position &&
              this.maxRepay.value === T;
          E && (T = o.maxUint256);
          let C =
            this.maxWithdraw.limiter === c.SupplyMigrationLimiter.position &&
            this.maxWithdraw.value === A;
          if ((C && (A = o.maxUint256), h)) {
            let e = s.Time.timestamp() + s.Time.s.from.d(1n),
              t = this._nonce;
            if (T > 0n && !this.isBundlerManaging) {
              let t = {
                  authorizer: y,
                  authorized: b,
                  isAuthorized: !0,
                  deadline: e,
                  nonce: this.morphoNonce,
                },
                n = { type: 'morphoSetAuthorizationWithSig', args: [t, null] };
              m.actions.push(n),
                m.requirements.signatures.push({
                  action: n,
                  async sign(e, r = e.account) {
                    let a = n.args[1];
                    if (null != a) return a;
                    let s = (0, i.getAuthorizationTypedData)(t, f);
                    return (
                      (a = await (0, l.signTypedData)(e, { ...s, account: r })),
                      await (0, o.verifyTypedData)({ ...s, address: y, signature: a }),
                      (n.args[1] = a)
                    );
                  },
                });
            }
            if (A > 0n) {
              let n = { type: 'permit', args: [y, v.address, A, e, null] };
              m.actions.push(n),
                m.requirements.signatures.push({
                  action: n,
                  async sign(r, a = r.account) {
                    let s = n.args[4];
                    if (null != s) return s;
                    let u = (0, i.getPermitTypedData)(
                      { erc20: v, owner: y, spender: b, allowance: A, nonce: t, deadline: e },
                      f
                    );
                    return (
                      (s = await (0, l.signTypedData)(r, { ...u, account: a })),
                      await (0, o.verifyTypedData)({ ...u, address: y, signature: s }),
                      (n.args[4] = s)
                    );
                  },
                });
            }
          } else
            T > 0n &&
              !this.isBundlerManaging &&
              m.requirements.txs.push({
                type: 'morphoSetAuthorization',
                args: [b, !0],
                tx: {
                  to: g,
                  data: (0, o.encodeFunctionData)({
                    abi: i.blueAbi,
                    functionName: 'setAuthorization',
                    args: [b, !0],
                  }),
                },
              }),
              A > 0n &&
                m.requirements.txs.push({
                  type: 'erc20Approve',
                  args: [v.address, b, A],
                  tx: {
                    to: v.address,
                    data: (0, o.encodeFunctionData)({
                      abi: u.aTokenV2Abi,
                      functionName: 'approve',
                      args: [b, A],
                    }),
                  },
                });
          let _ =
            T > 0n
              ? [
                  {
                    type: 'morphoBorrow',
                    args: [n, E ? r.MathLib.wMulUp(this.borrow, r.MathLib.WAD + d) : T, 0n, p, w],
                  },
                  { type: 'aaveV2Repay', args: [this.loanToken.address, o.maxUint256, y, 2n] },
                ]
              : [];
          if (
            (E &&
              d > 0n &&
              _.push(
                { type: 'erc20Transfer', args: [n.loanToken, b, o.maxUint256, w] },
                { type: 'morphoRepay', args: [n, o.maxUint256, 0n, o.maxUint256, y, []] }
              ),
            A > 0n)
          ) {
            let t = _.concat(
              { type: 'erc20TransferFrom', args: [v.address, A, w] },
              { type: 'aaveV2Withdraw', args: [this.collateralToken.address, A, b] }
            );
            m.actions.push(
              { type: 'morphoSupplyCollateral', args: [n, e, y, t] },
              {
                type: 'erc20Transfer',
                args: [C ? this.collateralToken.address : this.aToken.address, y, o.maxUint256, b],
              }
            );
          } else m.actions.push(..._);
          return m;
        }
      }
      t.MigratableBorrowPosition_AaveV2 = p;
    },
    65831: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.MigratableBorrowPosition_AaveV3 = void 0);
      let r = n(40252),
        i = n(4565),
        a = n(56044),
        s = n(35047),
        o = n(52707),
        l = n(28893),
        u = n(27256),
        c = n(93001),
        d = n(18166);
      class p extends d.MigratableBorrowPosition {
        _nonce;
        aToken;
        collateralPriceEth;
        loanPriceEth;
        constructor(e) {
          super({ ...e, protocol: c.MigratableProtocol.aaveV3 }),
            (this.aToken = e.aToken),
            (this._nonce = e.nonce),
            (this.collateralPriceEth = e.collateralPriceEth),
            (this.loanPriceEth = e.loanPriceEth);
        }
        getLtv({ withdrawn: e = 0n, repaid: t = 0n } = {}) {
          let n =
              ((this.collateral - e) * this.collateralPriceEth) /
              (0, o.parseUnits)('1', this.collateralToken.decimals),
            i =
              ((this.borrow - t) * this.loanPriceEth) /
              (0, o.parseUnits)('1', this.loanToken.decimals);
          return i <= 0n ? null : n <= 0n ? o.maxUint256 : r.MathLib.wDivUp(i, n);
        }
        get nonce() {
          return this._nonce;
        }
        _getMigrationTx(
          {
            collateralAmount: e,
            borrowAmount: t,
            marketTo: n,
            slippageFrom: d = r.DEFAULT_SLIPPAGE_TOLERANCE,
            minSharePrice: p,
          },
          h = !0
        ) {
          let y = this.user,
            f = this.chainId,
            m = new a.ActionBundle(f),
            {
              morpho: g,
              bundler3: { generalAdapter1: b, aaveV3CoreMigrationAdapter: w },
            } = (0, r.getChainAddresses)(f);
          if (null == w) throw Error('missing aaveV3CoreMigrationAdapter address');
          let v = this.aToken,
            T = t,
            A = e,
            E =
              this.maxRepay.limiter === c.BorrowMigrationLimiter.position &&
              this.maxRepay.value === T;
          E && (T = o.maxUint256);
          let C =
            this.maxWithdraw.limiter === c.SupplyMigrationLimiter.position &&
            this.maxWithdraw.value === A;
          if ((C && (A = o.maxUint256), h)) {
            let e = s.Time.timestamp() + s.Time.s.from.d(1n),
              t = this._nonce;
            if (T > 0n && !this.isBundlerManaging) {
              let t = {
                  authorizer: y,
                  authorized: b,
                  isAuthorized: !0,
                  deadline: e,
                  nonce: this.morphoNonce,
                },
                n = { type: 'morphoSetAuthorizationWithSig', args: [t, null] };
              m.actions.push(n),
                m.requirements.signatures.push({
                  action: n,
                  async sign(e, r = e.account) {
                    let a = n.args[1];
                    if (null != a) return a;
                    let s = (0, i.getAuthorizationTypedData)(t, f);
                    return (
                      (a = await (0, l.signTypedData)(e, { ...s, account: r })),
                      await (0, o.verifyTypedData)({ ...s, address: y, signature: a }),
                      (n.args[1] = a)
                    );
                  },
                });
            }
            if (A > 0n) {
              let n = { type: 'permit', args: [y, v.address, A, e, null] };
              m.actions.push(n),
                m.requirements.signatures.push({
                  action: n,
                  async sign(r, a = r.account) {
                    let s = n.args[4];
                    if (null != s) return s;
                    let u = (0, i.getPermitTypedData)(
                      { erc20: v, owner: y, spender: b, allowance: A, nonce: t, deadline: e },
                      f
                    );
                    return (
                      (s = await (0, l.signTypedData)(r, { ...u, account: a })),
                      await (0, o.verifyTypedData)({ ...u, address: y, signature: s }),
                      (n.args[4] = s)
                    );
                  },
                });
            }
          } else
            T > 0n &&
              !this.isBundlerManaging &&
              m.requirements.txs.push({
                type: 'morphoSetAuthorization',
                args: [b, !0],
                tx: {
                  to: g,
                  data: (0, o.encodeFunctionData)({
                    abi: i.blueAbi,
                    functionName: 'setAuthorization',
                    args: [b, !0],
                  }),
                },
              }),
              A > 0n &&
                m.requirements.txs.push({
                  type: 'erc20Approve',
                  args: [v.address, b, A],
                  tx: {
                    to: v.address,
                    data: (0, o.encodeFunctionData)({
                      abi: u.aTokenV3Abi,
                      functionName: 'approve',
                      args: [b, A],
                    }),
                  },
                });
          let _ =
            T > 0n
              ? [
                  {
                    type: 'morphoBorrow',
                    args: [n, E ? r.MathLib.wMulUp(this.borrow, r.MathLib.WAD + d) : T, 0n, p, w],
                  },
                  { type: 'aaveV3Repay', args: [this.loanToken.address, o.maxUint256, y, 2n] },
                ]
              : [];
          if (
            (E &&
              d > 0n &&
              _.push(
                { type: 'erc20Transfer', args: [n.loanToken, b, o.maxUint256, w] },
                { type: 'morphoRepay', args: [n, o.maxUint256, 0n, o.maxUint256, y, []] }
              ),
            A > 0n)
          ) {
            let t = _.concat(
              { type: 'erc20TransferFrom', args: [v.address, A, w] },
              { type: 'aaveV3Withdraw', args: [this.collateralToken.address, A, b] }
            );
            m.actions.push(
              { type: 'morphoSupplyCollateral', args: [n, e, y, t] },
              {
                type: 'erc20Transfer',
                args: [C ? this.collateralToken.address : this.aToken.address, y, o.maxUint256, b],
              }
            );
          } else m.actions.push(..._);
          return m;
        }
      }
      t.MigratableBorrowPosition_AaveV3 = p;
    },
    12168: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.MigratableBorrowPosition_Blue = void 0);
      let r = n(40252),
        i = n(51196);
      class a {
        market;
        position;
        constructor(e) {
          (this.market = e.market), (this.position = e.position);
        }
        getMigrationOperations(
          {
            marketTo: e,
            collateralAssets: t,
            borrowAssets: n = 0n,
            borrowShares: a = 0n,
            slippageFrom: s = r.DEFAULT_SLIPPAGE_TOLERANCE,
            slippageTo: o = r.DEFAULT_SLIPPAGE_TOLERANCE,
          },
          l
        ) {
          let {
              bundler3: { generalAdapter1: u },
            } = (0, r.getChainAddresses)(l),
            c = n > 0n || a > 0n;
          if (0n === t) throw new i.BlueSimulationErrors.ZeroAssets();
          return (
            a > 0n && (n = this.market.toBorrowAssets(a)),
            {
              type: 'Blue_SupplyCollateral',
              address: '0x',
              sender: this.position.user,
              args: {
                id: e,
                assets: t,
                onBehalf: this.position.user,
                callback: [
                  ...(c
                    ? [
                        {
                          type: 'Blue_Borrow',
                          address: '0x',
                          sender: this.position.user,
                          args: {
                            id: e,
                            assets: a > 0n ? r.MathLib.wMulUp(n, r.MathLib.WAD + s) : n,
                            receiver: u,
                            onBehalf: this.position.user,
                            slippage: o,
                          },
                        },
                        {
                          type: 'Blue_Repay',
                          address: '0x',
                          sender: this.position.user,
                          args: {
                            id: this.market.id,
                            slippage: s,
                            ...(0n === a ? { assets: n } : { shares: a }),
                            onBehalf: this.position.user,
                          },
                        },
                      ]
                    : []),
                  {
                    type: 'Blue_WithdrawCollateral',
                    address: '0x',
                    sender: this.position.user,
                    args: {
                      id: this.market.id,
                      assets: t,
                      onBehalf: this.position.user,
                      receiver: u,
                    },
                  },
                ],
              },
            }
          );
        }
      }
      t.MigratableBorrowPosition_Blue = a;
    },
    46813: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.MigratableBorrowPosition_CompoundV3 = void 0);
      let r = n(40252),
        i = n(4565),
        a = n(56044),
        s = n(35047),
        o = n(52707),
        l = n(28893),
        u = n(35727),
        c = n(93001),
        d = n(53967),
        p = n(18166);
      class h extends p.MigratableBorrowPosition {
        _nonce;
        collateralPriceUsd;
        loanPriceUsd;
        baseBorrowMin;
        cometAddress;
        cometName;
        constructor(e) {
          super({ ...e, protocol: c.MigratableProtocol.compoundV3 }),
            (this._nonce = e.nonce),
            (this.collateralPriceUsd = e.collateralPriceUsd),
            (this.loanPriceUsd = e.loanPriceUsd),
            (this.baseBorrowMin = e.baseBorrowMin),
            (this.cometAddress = e.cometAddress),
            (this.cometName = e.cometName);
        }
        getLtv({ withdrawn: e = 0n, repaid: t = 0n } = {}) {
          let n =
              ((this.collateral - e) * this.collateralPriceUsd) /
              (0, o.parseUnits)('1', this.collateralToken.decimals),
            i =
              ((this.borrow - t) * this.loanPriceUsd) /
              (0, o.parseUnits)('1', this.loanToken.decimals);
          return i <= 0n ? null : n <= 0n ? o.maxUint256 : r.MathLib.wDivUp(i, n);
        }
        get nonce() {
          return this._nonce;
        }
        _getMigrationTx(
          {
            collateralAmount: e,
            borrowAmount: t,
            marketTo: n,
            slippageFrom: p = r.DEFAULT_SLIPPAGE_TOLERANCE,
            minSharePrice: h,
          },
          y = !0
        ) {
          let f = this.user,
            m = this.chainId,
            g = new a.ActionBundle(m),
            {
              morpho: b,
              bundler3: { generalAdapter1: w, compoundV3MigrationAdapter: v },
            } = (0, r.getChainAddresses)(m);
          if (null == v) throw Error('missing compoundV3MigrationAdapter address');
          let T = this.cometAddress,
            A = this.cometName,
            E = t,
            C =
              this.maxRepay.limiter === c.BorrowMigrationLimiter.position &&
              this.maxRepay.value === E;
          if ((C && (E = o.maxUint256), !C && this.borrow - t < this.baseBorrowMin))
            throw Error(
              `Cannot have remaining position smaller than ${s.format.commas.unit(this.loanToken.symbol).of(this.baseBorrowMin, this.loanToken.decimals)}`
            );
          if (y) {
            let t = s.Time.timestamp() + s.Time.s.from.d(1n),
              n = this._nonce;
            if (E > 0n && !this.isBundlerManaging) {
              let e = {
                  authorizer: f,
                  authorized: w,
                  isAuthorized: !0,
                  deadline: t,
                  nonce: this.morphoNonce,
                },
                n = { type: 'morphoSetAuthorizationWithSig', args: [e, null] };
              g.actions.push(n),
                g.requirements.signatures.push({
                  action: n,
                  async sign(t, r = t.account) {
                    let a = n.args[1];
                    if (null != a) return a;
                    let s = (0, i.getAuthorizationTypedData)(e, m);
                    return (
                      (a = await (0, l.signTypedData)(t, { ...s, account: r })),
                      await (0, o.verifyTypedData)({ ...s, address: f, signature: a }),
                      (n.args[1] = a)
                    );
                  },
                });
            }
            if (e > 0n) {
              let e = { type: 'compoundV3AllowBySig', args: [T, f, !0, n, t, null] };
              g.actions.push(e),
                g.requirements.signatures.push({
                  action: e,
                  async sign(r, i = r.account) {
                    let a = e.args[5];
                    if (null != a) return a;
                    let s = (0, d.getCompoundV3ManagerApprovalMessage)(
                      {
                        name: A,
                        instance: T,
                        owner: f,
                        manager: v,
                        isAllowed: !0,
                        nonce: n,
                        expiry: t,
                      },
                      m
                    );
                    return (
                      (a = await (0, l.signTypedData)(r, { ...s, account: i })),
                      await (0, o.verifyTypedData)({ ...s, address: f, signature: a }),
                      (e.args[5] = a)
                    );
                  },
                });
            }
          } else
            E > 0n &&
              !this.isBundlerManaging &&
              g.requirements.txs.push({
                type: 'morphoSetAuthorization',
                args: [w, !0],
                tx: {
                  to: b,
                  data: (0, o.encodeFunctionData)({
                    abi: i.blueAbi,
                    functionName: 'setAuthorization',
                    args: [w, !0],
                  }),
                },
              }),
              e > 0n &&
                g.requirements.txs.push({
                  type: 'compoundV3ApproveManager',
                  args: [v, !0],
                  tx: {
                    to: T,
                    data: (0, o.encodeFunctionData)({
                      abi: u.cometExtAbi,
                      functionName: 'allow',
                      args: [v, !0],
                    }),
                  },
                });
          let _ =
            E > 0n
              ? [
                  {
                    type: 'morphoBorrow',
                    args: [n, C ? r.MathLib.wMulUp(this.borrow, r.MathLib.WAD + p) : E, 0n, h, v],
                  },
                  { type: 'compoundV3Repay', args: [T, o.maxUint256, f] },
                ]
              : [];
          if (
            (C &&
              p > 0n &&
              _.push(
                { type: 'erc20Transfer', args: [n.loanToken, w, o.maxUint256, v] },
                { type: 'morphoRepay', args: [n, o.maxUint256, 0n, o.maxUint256, f, []] }
              ),
            e > 0n)
          ) {
            let t = _.concat({
              type: 'compoundV3WithdrawFrom',
              args: [T, this.collateralToken.address, e, w],
            });
            g.actions.push({ type: 'morphoSupplyCollateral', args: [n, e, f, t] });
          } else g.actions.push(..._);
          return g;
        }
      }
      t.MigratableBorrowPosition_CompoundV3 = h;
    },
    18166: function (e, t, n) {
      'use strict';
      var r =
          (this && this.__createBinding) ||
          (Object.create
            ? function (e, t, n, r) {
                void 0 === r && (r = n);
                var i = Object.getOwnPropertyDescriptor(t, n);
                (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
                  (i = {
                    enumerable: !0,
                    get: function () {
                      return t[n];
                    },
                  }),
                  Object.defineProperty(e, r, i);
              }
            : function (e, t, n, r) {
                void 0 === r && (r = n), (e[r] = t[n]);
              }),
        i =
          (this && this.__exportStar) ||
          function (e, t) {
            for (var n in e)
              'default' === n || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n);
          };
      Object.defineProperty(t, '__esModule', { value: !0 }),
        i(n(36027), t),
        i(n(65831), t),
        i(n(12168), t),
        i(n(82152), t),
        i(n(46813), t);
    },
    25754: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.MigratableBorrowPosition_Blue = t.MigratableSupplyPosition = void 0);
      var r = n(82982);
      Object.defineProperty(t, 'MigratableSupplyPosition', {
        enumerable: !0,
        get: function () {
          return r.MigratableSupplyPosition;
        },
      });
      var i = n(12168);
      Object.defineProperty(t, 'MigratableBorrowPosition_Blue', {
        enumerable: !0,
        get: function () {
          return i.MigratableBorrowPosition_Blue;
        },
      });
    },
    9549: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.getMorphoAaveV3ManagerApprovalTypedData = void 0);
      let r = n(40252),
        i = n(16316),
        a = n(93001),
        s = {
          Authorization: [
            { name: 'delegator', type: 'address' },
            { name: 'manager', type: 'address' },
            { name: 'isAllowed', type: 'bool' },
            { name: 'nonce', type: 'uint256' },
            { name: 'deadline', type: 'uint256' },
          ],
        };
      t.getMorphoAaveV3ManagerApprovalTypedData = (e, t) => {
        let n = i.migrationAddresses[t]?.[a.MigratableProtocol.aaveV3Optimizer];
        if (!n) throw new r.UnsupportedChainIdError(t);
        return {
          domain: {
            name: 'Morpho-AaveV3',
            chainId: t,
            verifyingContract: n.morpho.address,
            version: '0',
          },
          types: s,
          message: e,
          primaryType: 'Authorization',
        };
      };
    },
    53967: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.getCompoundV3ManagerApprovalMessage = void 0);
      let n = {
        Authorization: [
          { name: 'owner', type: 'address' },
          { name: 'manager', type: 'address' },
          { name: 'isAllowed', type: 'bool' },
          { name: 'nonce', type: 'uint256' },
          { name: 'expiry', type: 'uint256' },
        ],
      };
      t.getCompoundV3ManagerApprovalMessage = ({ instance: e, name: t, ...r }, i) => ({
        domain: { name: t, chainId: i, verifyingContract: e, version: '0' },
        message: r,
        primaryType: 'Authorization',
        types: n,
      });
    },
    3314: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }), (t.MigratableSupplyPosition = void 0);
      class n {
        protocol;
        user;
        loanToken;
        supply;
        supplyApy;
        max;
        chainId;
        constructor(e) {
          (this.protocol = e.protocol),
            (this.user = e.user),
            (this.loanToken = e.loanToken),
            (this.supply = e.supply),
            (this.supplyApy = e.supplyApy),
            (this.max = e.max),
            (this.chainId = e.chainId);
        }
        getMigrationTx(e, t) {
          return this._validateMigration(e), this._getMigrationTx(e, t);
        }
        _validateMigration({ amount: e }) {
          if (e > this.max.value) throw Error(`Max migration limited by: ${this.max.limiter}`);
        }
      }
      t.MigratableSupplyPosition = n;
    },
    54693: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.MigratableSupplyPosition_AaveV2 = void 0);
      let r = n(40252),
        i = n(35047),
        a = n(93001),
        s = n(4565),
        o = n(56044),
        l = n(52707),
        u = n(28893),
        c = n(14241),
        d = n(82982);
      class p extends d.MigratableSupplyPosition {
        _nonce;
        aToken;
        constructor(e) {
          super({ ...e, protocol: a.MigratableProtocol.aaveV2 }),
            (this.aToken = e.aToken),
            (this._nonce = e.nonce);
        }
        get nonce() {
          return this._nonce;
        }
        _getMigrationTx({ amount: e, maxSharePrice: t, vault: n }, d = !0) {
          let p = this.chainId,
            h = new o.ActionBundle(p),
            y = this.user,
            f = this.aToken,
            {
              bundler3: { generalAdapter1: m, aaveV2MigrationAdapter: g },
            } = (0, r.getChainAddresses)(p);
          if (null == g) throw Error('missing aaveV2MigrationAdapter address');
          let b = e;
          if (
            (this.max.limiter === a.SupplyMigrationLimiter.position &&
              this.max.value === e &&
              (b = l.maxUint256),
            d)
          ) {
            let e = i.Time.timestamp() + i.Time.s.from.d(1n),
              t = this._nonce,
              n = { type: 'permit', args: [y, f.address, b, e, null] };
            h.actions.push(n),
              h.requirements.signatures.push({
                action: n,
                async sign(r, i = r.account) {
                  let a = n.args[4];
                  if (null != a) return a;
                  let o = (0, s.getPermitTypedData)(
                    { erc20: f, owner: y, spender: m, allowance: b, nonce: t, deadline: e },
                    p
                  );
                  return (
                    (a = await (0, u.signTypedData)(r, { ...o, account: i })),
                    await (0, l.verifyTypedData)({ ...o, address: y, signature: a }),
                    (n.args[4] = a)
                  );
                },
              });
          } else
            h.requirements.txs.push({
              type: 'erc20Approve',
              args: [f.address, m, b],
              tx: {
                to: f.address,
                data: (0, l.encodeFunctionData)({
                  abi: c.aTokenV2Abi,
                  functionName: 'approve',
                  args: [m, b],
                }),
              },
            });
          return (
            h.actions.push({ type: 'erc20TransferFrom', args: [f.address, b, g] }),
            h.actions.push(
              { type: 'aaveV2Withdraw', args: [this.loanToken, l.maxUint256, m] },
              { type: 'erc4626Deposit', args: [n, l.maxUint256, t, y] }
            ),
            h
          );
        }
      }
      t.MigratableSupplyPosition_AaveV2 = p;
    },
    78711: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.MigratableSupplyPosition_AaveV3 = void 0);
      let r = n(40252),
        i = n(35047),
        a = n(93001),
        s = n(4565),
        o = n(56044),
        l = n(52707),
        u = n(28893),
        c = n(27256),
        d = n(82982);
      class p extends d.MigratableSupplyPosition {
        _nonce;
        aToken;
        constructor(e) {
          super({ ...e, protocol: a.MigratableProtocol.aaveV3 }),
            (this.aToken = e.aToken),
            (this._nonce = e.nonce);
        }
        get nonce() {
          return this._nonce;
        }
        _getMigrationTx({ amount: e, maxSharePrice: t, vault: n }, d = !0) {
          let p = this.chainId,
            h = new o.ActionBundle(p),
            y = this.user,
            {
              bundler3: { generalAdapter1: f, aaveV3CoreMigrationAdapter: m },
            } = (0, r.getChainAddresses)(p);
          if (null == m) throw Error('missing aaveV3CoreMigrationAdapter address');
          let g = this.aToken,
            b = e;
          if (
            (this.max.limiter === a.SupplyMigrationLimiter.position &&
              this.max.value === e &&
              (b = l.maxUint256),
            d)
          ) {
            let e = i.Time.timestamp() + i.Time.s.from.d(1n),
              t = this._nonce,
              n = { type: 'permit', args: [y, g.address, b, e, null] };
            h.actions.push(n),
              h.requirements.signatures.push({
                action: n,
                async sign(r, i = r.account) {
                  let a = n.args[4];
                  if (null != a) return a;
                  let o = (0, s.getPermitTypedData)(
                    { erc20: g, owner: y, spender: f, allowance: b, nonce: t, deadline: e },
                    p
                  );
                  return (
                    (a = await (0, u.signTypedData)(r, { ...o, account: i })),
                    await (0, l.verifyTypedData)({ ...o, address: y, signature: a }),
                    (n.args[4] = a)
                  );
                },
              });
          } else
            h.requirements.txs.push({
              type: 'erc20Approve',
              args: [g.address, f, b],
              tx: {
                to: g.address,
                data: (0, l.encodeFunctionData)({
                  abi: c.aTokenV3Abi,
                  functionName: 'approve',
                  args: [f, b],
                }),
              },
            });
          return (
            h.actions.push({ type: 'erc20TransferFrom', args: [g.address, b, m] }),
            h.actions.push(
              { type: 'aaveV3Withdraw', args: [this.loanToken, l.maxUint256, f] },
              { type: 'erc4626Deposit', args: [n, l.maxUint256, t, y] }
            ),
            h
          );
        }
      }
      t.MigratableSupplyPosition_AaveV3 = p;
    },
    74128: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.MigratableSupplyPosition_AaveV3Optimizer = void 0);
      let r = n(40252),
        i = n(35047),
        a = n(16316),
        s = n(93001),
        o = n(56044),
        l = n(52707),
        u = n(28893),
        c = n(4457),
        d = n(9549),
        p = n(82982);
      class h extends p.MigratableSupplyPosition {
        isBundlerManaging;
        _nonce;
        constructor(e) {
          super({ ...e, protocol: s.MigratableProtocol.aaveV3Optimizer }),
            (this.isBundlerManaging = e.isBundlerManaging),
            (this._nonce = e.nonce);
        }
        get nonce() {
          return this._nonce;
        }
        _getMigrationTx({ amount: e, maxSharePrice: t, vault: n }, p = !0) {
          let h = this.chainId,
            y = new o.ActionBundle(h),
            f = this.user,
            {
              bundler3: { generalAdapter1: m, aaveV3OptimizerMigrationAdapter: g },
            } = (0, r.getChainAddresses)(h);
          if (null == g) throw Error('missing aaveV3OptimizerMigrationAdapter address');
          let b = a.migrationAddresses[h]?.[s.MigratableProtocol.aaveV3Optimizer];
          if (!b) throw new r.UnsupportedChainIdError(h);
          if (!this.isBundlerManaging) {
            if (p) {
              let e = i.Time.timestamp() + i.Time.s.from.d(1n),
                t = this._nonce,
                n = {
                  type: 'aaveV3OptimizerApproveManagerWithSig',
                  args: [b.morpho.address, f, !0, t, e, null],
                };
              y.actions.push(n),
                y.requirements.signatures.push({
                  action: n,
                  async sign(r, i = r.account) {
                    let a = n.args[5];
                    if (null != a) return a;
                    let s = (0, d.getMorphoAaveV3ManagerApprovalTypedData)(
                      { delegator: f, manager: g, nonce: t, deadline: e, isAllowed: !0 },
                      h
                    );
                    return (
                      (a = await (0, u.signTypedData)(r, { ...s, account: i })),
                      await (0, l.verifyTypedData)({ ...s, address: f, signature: a }),
                      (n.args[5] = a)
                    );
                  },
                });
            } else
              y.requirements.txs.push({
                type: 'aaveV3OptimizerApproveManager',
                args: [g, !0],
                tx: {
                  to: b.morpho.address,
                  data: (0, l.encodeFunctionData)({
                    abi: c.morphoAaveV3Abi,
                    functionName: 'approveManager',
                    args: [g, !0],
                  }),
                },
              });
          }
          let w = e;
          return (
            this.max.limiter === s.SupplyMigrationLimiter.position &&
              this.max.value <= e &&
              (w = l.maxUint256),
            y.actions.push(
              { type: 'aaveV3OptimizerWithdraw', args: [this.loanToken, w, 4n, m] },
              { type: 'erc4626Deposit', args: [n, l.maxUint256, t, f] }
            ),
            y
          );
        }
      }
      t.MigratableSupplyPosition_AaveV3Optimizer = h;
    },
    95556: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.MigratableSupplyPosition_CompoundV2 = void 0);
      let r = n(40252),
        i = n(52707),
        a = n(56044),
        s = n(67317),
        o = n(16316),
        l = n(93001),
        u = n(82982);
      class c extends u.MigratableSupplyPosition {
        bundlerAllowance;
        cToken;
        cTokenBalance;
        constructor(e) {
          super({ ...e, protocol: l.MigratableProtocol.compoundV2 }),
            (this.bundlerAllowance = e.bundlerAllowance),
            (this.cToken = e.cToken),
            (this.cTokenBalance = e.cTokenBalance);
        }
        _getMigrationTx({ amount: e, maxSharePrice: t, vault: n }) {
          let u = this.chainId,
            c = new a.ActionBundle(u),
            d = this.user,
            p = this.cToken,
            {
              bundler3: { generalAdapter1: h, compoundV2MigrationAdapter: y },
            } = (0, r.getChainAddresses)(u);
          if (null == y) throw Error('missing compoundV2MigrationAdapter address');
          let f =
            this.max.limiter === l.SupplyMigrationLimiter.position && this.max.value === e
              ? this.cTokenBalance
              : this.cToken.toUnwrappedExactAmountOut(e);
          c.requirements.txs.push({
            type: 'erc20Approve',
            args: [p.address, h, f],
            tx: {
              to: p.address,
              data: (0, i.encodeFunctionData)({
                abi: s.cErc20Abi,
                functionName: 'approve',
                args: [h, f],
              }),
            },
          }),
            c.actions.push({ type: 'erc20TransferFrom', args: [p.address, f, y] });
          let m = this.cToken.underlying === r.NATIVE_ADDRESS;
          return (
            c.actions.push({ type: 'compoundV2Redeem', args: [p.address, i.maxUint256, m, h] }),
            (m ||
              this.cToken.address ===
                o.migrationAddresses[this.chainId]?.[l.MigratableProtocol.compoundV2]?.mWeth
                  ?.address) &&
              c.actions.push({ type: 'wrapNative', args: [i.maxUint256, h] }),
            c.actions.push({ type: 'erc4626Deposit', args: [n, i.maxUint256, t, d] }),
            c
          );
        }
      }
      t.MigratableSupplyPosition_CompoundV2 = c;
    },
    70800: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.MigratableSupplyPosition_CompoundV3 = void 0);
      let r = n(40252),
        i = n(35047),
        a = n(56044),
        s = n(52707),
        o = n(28893),
        l = n(35727),
        u = n(93001),
        c = n(53967),
        d = n(82982);
      class p extends d.MigratableSupplyPosition {
        _nonce;
        cometAddress;
        cometName;
        constructor(e) {
          super({ ...e, protocol: u.MigratableProtocol.compoundV3 }),
            (this._nonce = e.nonce),
            (this.cometAddress = e.cometAddress),
            (this.cometName = e.cometName);
        }
        get nonce() {
          return this._nonce;
        }
        _getMigrationTx({ amount: e, maxSharePrice: t, vault: n }, d = !0) {
          let p = this.chainId,
            h = new a.ActionBundle(p),
            y = this.user,
            {
              bundler3: { generalAdapter1: f, compoundV3MigrationAdapter: m },
            } = (0, r.getChainAddresses)(p);
          if (null == m) throw Error('missing compoundV3MigrationAdapter address');
          let g = this.max.limiter === u.SupplyMigrationLimiter.position && this.max.value === e,
            b = e;
          g && (b = s.maxUint256);
          let w = this.cometAddress,
            v = this._nonce,
            T = this.cometName;
          if (d) {
            let e = i.Time.timestamp() + i.Time.s.from.d(1n),
              t = { type: 'compoundV3AllowBySig', args: [w, y, !0, v, e, null] };
            h.actions.push(t),
              h.requirements.signatures.push({
                action: t,
                async sign(n, r = n.account) {
                  let i = t.args[5];
                  if (null != i) return i;
                  let a = (0, c.getCompoundV3ManagerApprovalMessage)(
                    {
                      name: T,
                      instance: w,
                      owner: y,
                      manager: m,
                      isAllowed: !0,
                      nonce: v,
                      expiry: e,
                    },
                    p
                  );
                  return (
                    (i = await (0, o.signTypedData)(n, { ...a, account: r })),
                    await (0, s.verifyTypedData)({ ...a, address: y, signature: i }),
                    (t.args[5] = i)
                  );
                },
              });
          } else
            h.requirements.txs.push({
              type: 'compoundV3ApproveManager',
              args: [m, !0],
              tx: {
                to: w,
                data: (0, s.encodeFunctionData)({
                  abi: l.cometExtAbi,
                  functionName: 'allow',
                  args: [m, !0],
                }),
              },
            });
          return (
            h.actions.push(
              { type: 'compoundV3WithdrawFrom', args: [w, this.loanToken, b, f] },
              { type: 'erc4626Deposit', args: [n, s.maxUint256, t, y] }
            ),
            h
          );
        }
      }
      t.MigratableSupplyPosition_CompoundV3 = p;
    },
    82982: function (e, t, n) {
      'use strict';
      var r =
          (this && this.__createBinding) ||
          (Object.create
            ? function (e, t, n, r) {
                void 0 === r && (r = n);
                var i = Object.getOwnPropertyDescriptor(t, n);
                (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
                  (i = {
                    enumerable: !0,
                    get: function () {
                      return t[n];
                    },
                  }),
                  Object.defineProperty(e, r, i);
              }
            : function (e, t, n, r) {
                void 0 === r && (r = n), (e[r] = t[n]);
              }),
        i =
          (this && this.__exportStar) ||
          function (e, t) {
            for (var n in e)
              'default' === n || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n);
          };
      Object.defineProperty(t, '__esModule', { value: !0 }),
        i(n(3314), t),
        i(n(54693), t),
        i(n(78711), t),
        i(n(74128), t),
        i(n(95556), t),
        i(n(70800), t);
    },
    63847: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 });
    },
    93001: function (e, t, n) {
      'use strict';
      var r,
        i,
        a =
          (this && this.__createBinding) ||
          (Object.create
            ? function (e, t, n, r) {
                void 0 === r && (r = n);
                var i = Object.getOwnPropertyDescriptor(t, n);
                (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
                  (i = {
                    enumerable: !0,
                    get: function () {
                      return t[n];
                    },
                  }),
                  Object.defineProperty(e, r, i);
              }
            : function (e, t, n, r) {
                void 0 === r && (r = n), (e[r] = t[n]);
              }),
        s =
          (this && this.__exportStar) ||
          function (e, t) {
            for (var n in e)
              'default' === n || Object.prototype.hasOwnProperty.call(t, n) || a(t, e, n);
          };
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.MigratableProtocol = void 0),
        s(n(63847), t),
        s(n(33149), t),
        ((r = i || (t.MigratableProtocol = i = {})).aaveV3Optimizer = 'aaveV3Optimizer'),
        (r.aaveV2 = 'aaveV2'),
        (r.aaveV3 = 'aaveV3'),
        (r.compoundV3 = 'compoundV3'),
        (r.compoundV2 = 'compoundV2');
    },
    33149: function (e, t) {
      'use strict';
      var n, r, i, a, s;
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.CollateralMigrationLimiter =
          t.BorrowMigrationLimiter =
          t.SupplyMigrationLimiter =
            void 0),
        ((a = n || (t.SupplyMigrationLimiter = n = {})).position = 'position'),
        (a.liquidity = 'liquidity'),
        (a.withdrawPaused = 'withdrawPaused'),
        (a.borrowPaused = 'borrowPaused'),
        (a.protocolCap = 'protocolCap'),
        ((s = r || (t.BorrowMigrationLimiter = r = {})).position = 'position'),
        (s.repayPaused = 'repayPaused'),
        i || (t.CollateralMigrationLimiter = i = {});
    },
    97992: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.rateToApy = function (e, t, n = 18, a = !1) {
          let { unit: s, duration: o } = r.Time.toPeriod(t),
            l = r.Time[s].from.y(1) / o;
          return (
            (e = BigInt(e)),
            a && (e /= r.Time[s].from.y(1n)),
            (1 + Number((0, i.formatUnits)(e, n))) ** l - 1
          );
        });
      let r = n(35047),
        i = n(52707);
    },
    59780: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.SimulationState = t.DEFAULT_WITHDRAWAL_TARGET_UTILIZATION = void 0);
      let r = n(40252),
        i = n(35047),
        a = n(26349),
        s = n(6382);
      t.DEFAULT_WITHDRAWAL_TARGET_UTILIZATION = 0xcc47f20295c0000n;
      class o {
        chainId;
        block;
        global;
        markets;
        users;
        tokens;
        vaults;
        positions;
        holdings;
        vaultMarketConfigs;
        vaultUsers;
        constructor({
          chainId: e,
          block: { number: t, timestamp: n },
          global: { feeRecipient: r } = {},
          markets: i = {},
          users: a = {},
          tokens: s = {},
          vaults: o = {},
          positions: l = {},
          holdings: u = {},
          vaultMarketConfigs: c = {},
          vaultUsers: d = {},
        }) {
          (this.chainId = e),
            (this.block = { number: t, timestamp: n }),
            (this.global = { feeRecipient: r }),
            (this.markets = i),
            (this.users = a),
            (this.tokens = s),
            (this.vaults = o),
            (this.positions = l),
            (this.holdings = u),
            (this.vaultMarketConfigs = c),
            (this.vaultUsers = d);
        }
        getMarket(e) {
          let t = this.markets[e];
          if (null == t) throw new a.UnknownMarketError(e);
          return t;
        }
        tryGetMarket(e) {
          return (0, r._try)(this.getMarket.bind(this, e), a.UnknownMarketError);
        }
        getUser(e) {
          let t = this.users[e];
          if (null == t) throw new a.UnknownUserError(e);
          return t;
        }
        tryGetUser(e) {
          return (0, r._try)(this.getUser.bind(this, e), a.UnknownUserError);
        }
        getToken(e) {
          let t = this.tokens[e];
          if (null == t) throw new r.UnknownTokenError(e);
          return t;
        }
        tryGetToken(e) {
          return (0, r._try)(this.getToken.bind(this, e), r.UnknownTokenError);
        }
        getVault(e) {
          let t = this.vaults[e];
          if (null == t) throw new a.UnknownVaultError(e);
          return t;
        }
        tryGetVault(e) {
          return (0, r._try)(this.getVault.bind(this, e), a.UnknownVaultError);
        }
        getAccrualVault(e) {
          let t = this.getVault(e);
          return new r.AccrualVault(
            t,
            t.withdrawQueue.map((t) => ({
              config: this.getVaultMarketConfig(e, t),
              position: this.getAccrualPosition(e, t),
            }))
          );
        }
        tryGetAccrualVault(e) {
          return (0, r._try)(this.getAccrualVault.bind(this, e), r.UnknownDataError);
        }
        getPosition(e, t) {
          let n = this.positions[e]?.[t];
          if (null == n) throw new a.UnknownPositionError(e, t);
          return n;
        }
        tryGetPosition(e, t) {
          return (0, r._try)(this.getPosition.bind(this, e, t), a.UnknownPositionError);
        }
        getAccrualPosition(e, t) {
          return new r.AccrualPosition(this.getPosition(e, t), this.getMarket(t));
        }
        tryGetAccrualPosition(e, t) {
          return (0, r._try)(this.getAccrualPosition.bind(this, e, t), r.UnknownDataError);
        }
        getHolding(e, t) {
          let n = this.holdings[e]?.[t];
          if (null == n) throw new a.UnknownHoldingError(e, t);
          return n;
        }
        tryGetHolding(e, t) {
          return (0, r._try)(this.getHolding.bind(this, e, t), a.UnknownHoldingError);
        }
        getVaultMarketConfig(e, t) {
          let n = this.vaultMarketConfigs[e]?.[t];
          if (null == n) throw new a.UnknownVaultMarketConfigError(e, t);
          return n;
        }
        tryGetVaultMarketConfig(e, t) {
          return (0, r._try)(
            this.getVaultMarketConfig.bind(this, e, t),
            a.UnknownVaultMarketConfigError
          );
        }
        getVaultUser(e, t) {
          let n = this.vaultUsers[e]?.[t];
          if (null == n) throw new a.UnknownVaultUserError(e, t);
          return n;
        }
        tryGetVaultUser(e, t) {
          return (0, r._try)(this.getVaultUser.bind(this, e, t), a.UnknownVaultUserError);
        }
        getWrappedToken(e) {
          let t = this.getToken(e);
          if (!(t instanceof r.WrappedToken)) {
            let n = this.tryGetAccrualVault(t.address);
            if (null == n) throw new a.UnknownWrappedTokenError(e);
            return n;
          }
          return t;
        }
        tryGetWrappedToken(e) {
          return (0, r._try)(this.getWrappedToken.bind(this, e), r.UnknownDataError);
        }
        getBundleBalance(e, t, n = !0) {
          return (0, r._try)(() => {
            let { balance: i } = this.getHolding(e, t);
            if (!n) return i;
            let {
              bundler3: { generalAdapter1: a },
            } = (0, r.getChainAddresses)(this.chainId);
            return (
              (0, r._try)(() => {
                i += this.getHolding(a, t).balance;
              }, r.UnknownDataError),
              i
            );
          }, r.UnknownDataError);
        }
        getBundleMaxBalance(e, t, n, r = new Set()) {
          let a = this.getBundleAssetBalances(e, t, n);
          return a
            ? (0, i.values)(a.allocations)
                .filter(i.isDefined)
                .filter(({ type: e }) => !r.has(e))
                .reduce((e, { dstAmount: t }) => e + t, 0n)
            : a;
        }
        getBundleMaxCapacities(e, t, n, i, a = new Set(), s) {
          return (0, r._try)(() => {
            let { loanToken: r, collateralToken: o } = this.getMarket(t).params,
              l = this.getBundleMaxBalance(e, r, n, a),
              u = this.getBundleMaxBalance(e, o, n, a);
            if (null != l && null != u)
              return this.getMarketPublicReallocations(t, i)
                .data.getAccrualPosition(e, t)
                .getMaxCapacities(l, u, s);
          }, r.UnknownDataError);
        }
        getBundleAssetBalances(e, t, n, s = !0) {
          return (0, r._try)(() => {
            let o = this.getBundleBalance(e, t, s);
            if (null == o) return;
            let l = new r.AssetBalances({ srcToken: this.getToken(t), srcAmount: o, dstAmount: o }),
              u = (0, r._try)(() => this.getWrappedToken(t), a.UnknownWrappedTokenError);
            if (!u) return l;
            (0, r._try)(() => {
              if (u instanceof r.VaultToken) return;
              let t = this.getBundleBalance(e, u.underlying);
              if (null != t) {
                let e = u.toWrappedExactAmountIn(t, n);
                l.add({
                  type: 'wrapped',
                  srcToken: this.getToken(u.underlying),
                  srcAmount: t,
                  dstAmount: e,
                });
              }
            }, r.UnknownDataError);
            let { wstEth: c, stEth: d, wNative: p } = (0, r.getChainAddresses)(this.chainId);
            return (
              this.chainId === r.ChainId.EthMainnet &&
                t === c &&
                null != p &&
                null != d &&
                ((0, r._try)(() => {
                  let t = this.getBundleBalance(e, p);
                  if (null != t) {
                    let e = this.getWrappedToken(d).toWrappedExactAmountIn(t, n),
                      r = u.toWrappedExactAmountIn(e, n);
                    l.add({
                      type: 'unwrapped-staked-wrapped',
                      srcToken: this.getToken(p),
                      srcAmount: t,
                      dstAmount: r,
                    });
                  }
                }, r.UnknownDataError),
                (0, r._try)(() => {
                  let t = this.getBundleBalance(e, r.NATIVE_ADDRESS);
                  if (null != t) {
                    let e = this.getWrappedToken(d).toWrappedExactAmountIn(t, n),
                      i = u.toWrappedExactAmountIn(e, n);
                    l.add({
                      type: 'staked-wrapped',
                      srcToken: this.getToken(r.NATIVE_ADDRESS),
                      srcAmount: t,
                      dstAmount: i,
                    });
                  }
                }, r.UnknownDataError)),
              (0, r._try)(() => {
                if (!(u instanceof r.VaultToken)) return;
                let t = this.getBundleAssetBalances(e, u.underlying, n);
                if (t)
                  for (let { type: e, srcToken: r, srcAmount: a, dstAmount: s } of (0, i.values)(
                    t.allocations
                  ).filter(i.isDefined)) {
                    let t = { base: 'vault', wrapped: 'wrapped-vault' }[e];
                    if (t) {
                      let e = u.toWrappedExactAmountIn(s, n);
                      l.add({ type: t, srcToken: r, srcAmount: a, dstAmount: e });
                    }
                  }
              }),
              l
            );
          }, r.UnknownDataError);
        }
        getMarketPublicReallocations(
          e,
          {
            enabled: n = !0,
            reallocatableVaults: a = (0, i.keys)(this.vaultMarketConfigs),
            defaultMaxWithdrawalUtilization: o = t.DEFAULT_WITHDRAWAL_TARGET_UTILIZATION,
            maxWithdrawalUtilization: l = {},
            delay: u = i.Time.s.from.h(1n),
          } = {}
        ) {
          if (!n) return { withdrawals: [], data: this };
          a = a.filter((t) => {
            let n = this.vaultMarketConfigs[t]?.[e];
            return !!n?.enabled && this.vaults[t]?.publicAllocatorConfig != null;
          });
          let c = this,
            d = [],
            p = () => {
              let t = a
                .map((t) =>
                  (0, r._try)(() => {
                    let { cap: n, publicAllocatorConfig: a } = c.getVaultMarketConfig(t, e),
                      s =
                        n -
                        c.getAccrualPosition(t, e).accrueInterest(this.block.timestamp + u)
                          .supplyAssets,
                      p = c
                        .getVault(t)
                        .withdrawQueue.filter(
                          (n) => n !== e && !d.some((e) => e.id === n && e.vault === t)
                        )
                        .map((e) => {
                          try {
                            let n = c.getAccrualPosition(t, e).accrueInterest(this.block.timestamp),
                              i = n.market.getWithdrawToUtilization(l[e] ?? o),
                              u = c.getVaultMarketConfig(t, e).publicAllocatorConfig;
                            return {
                              id: e,
                              assets: r.MathLib.min(
                                n.supplyAssets,
                                i,
                                s,
                                a?.maxIn ?? 0n,
                                u?.maxOut ?? 0n
                              ),
                            };
                          } catch {
                            return { id: e, assets: 0n };
                          }
                        })
                        .filter(({ assets: e }) => e > 0n)
                        .sort((0, i.bigIntComparator)(({ assets: e }) => e, 'desc'));
                    return { vault: t, largestWithdrawal: p[0] };
                  }, r.UnknownDataError)
                )
                .filter((e) => e?.largestWithdrawal != null && e.largestWithdrawal.assets > 0n)
                .sort((0, i.bigIntComparator)((e) => e.largestWithdrawal.assets, 'desc'))[0];
              if (null == t || null == t.largestWithdrawal) return { withdrawals: d, data: c };
              let { vault: n, largestWithdrawal: h } = t;
              return (
                d.push({ ...h, vault: n }),
                (c = (0, s.simulateOperation)(
                  {
                    type: 'MetaMorpho_PublicReallocate',
                    address: n,
                    sender: i.ZERO_ADDRESS,
                    args: { withdrawals: [h], supplyMarketId: e },
                  },
                  c
                )),
                p()
              );
            };
          return p();
        }
      }
      t.SimulationState = o;
    },
    26349: function (e, t, n) {
      'use strict';
      var r, i, a, s, o;
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.PublicAllocatorErrors =
          t.MetaMorphoErrors =
          t.BlueSimulationErrors =
          t.SimulationErrors =
          t.Erc20Errors =
          t.UnknownVaultMarketPublicAllocatorConfigError =
          t.UnknownVaultPublicAllocatorConfigError =
          t.UnknownEIP2612DataError =
          t.UnknownAllowanceError =
          t.UnknownContractError =
          t.UnknownWrappedTokenError =
          t.UnknownVaultUserError =
          t.UnknownVaultMarketConfigError =
          t.UnknownVaultError =
          t.UnknownHoldingError =
          t.UnknownPositionError =
          t.UnknownUserError =
          t.UnknownMarketError =
          t.UnexpectedOperation =
            void 0),
        (t.getWrappedInstanceOf = function e(t, ...n) {
          return n.find((e) => t instanceof e)
            ? t
            : t && 'object' == typeof t && 'error' in t
              ? e(t.error, ...n)
              : void 0;
        });
      let l = n(40252),
        u = n(35047);
      class c extends Error {
        constructor(e, t) {
          super(`unexpected operation "${e}" on chain "${t}"`);
        }
      }
      t.UnexpectedOperation = c;
      class d extends l.UnknownDataError {
        marketId;
        constructor(e) {
          super(`unknown market "${e}"`), (this.marketId = e);
        }
      }
      t.UnknownMarketError = d;
      class p extends l.UnknownDataError {
        user;
        constructor(e) {
          super(`unknown user "${e}"`), (this.user = e);
        }
      }
      t.UnknownUserError = p;
      class h extends l.UnknownDataError {
        user;
        marketId;
        constructor(e, t) {
          super(`unknown position of user "${e}" on market "${t}"`),
            (this.user = e),
            (this.marketId = t);
        }
      }
      t.UnknownPositionError = h;
      class y extends l.UnknownDataError {
        user;
        token;
        constructor(e, t) {
          super(`unknown holding of user "${e}" of token "${t}"`),
            (this.user = e),
            (this.token = t);
        }
      }
      t.UnknownHoldingError = y;
      class f extends l.UnknownDataError {
        vault;
        constructor(e) {
          super(`unknown vault "${e}"`), (this.vault = e);
        }
      }
      t.UnknownVaultError = f;
      class m extends l.UnknownDataError {
        vault;
        marketId;
        constructor(e, t) {
          super(`unknown config for vault "${e}" on market "${t}"`),
            (this.vault = e),
            (this.marketId = t);
        }
      }
      t.UnknownVaultMarketConfigError = m;
      class g extends l.UnknownDataError {
        vault;
        user;
        constructor(e, t) {
          super(`unknown user "${t}" of vault "${e}"`), (this.vault = e), (this.user = t);
        }
      }
      t.UnknownVaultUserError = g;
      class b extends l.UnknownDataError {
        token;
        constructor(e) {
          super(`unknown wrapped token "${e}"`), (this.token = e);
        }
      }
      t.UnknownWrappedTokenError = b;
      class w extends l.UnknownDataError {
        contract;
        constructor(e) {
          super(`unknown contract "${e}"`), (this.contract = e);
        }
      }
      t.UnknownContractError = w;
      class v extends l.UnknownDataError {
        token;
        owner;
        spender;
        constructor(e, t, n) {
          super(`unknown allowance for token "${e}" from owner "${t}" to spender "${n}"`),
            (this.token = e),
            (this.owner = t),
            (this.spender = n);
        }
      }
      t.UnknownAllowanceError = v;
      class T extends l.UnknownDataError {
        token;
        owner;
        constructor(e, t) {
          super(`unknown EIP-2612 data for token "${e}" of owner "${t}"`),
            (this.token = e),
            (this.owner = t);
        }
      }
      t.UnknownEIP2612DataError = T;
      class A extends l.UnknownDataError {
        vault;
        constructor(e) {
          super(`missing public allocator config for vault "${e}"`), (this.vault = e);
        }
      }
      t.UnknownVaultPublicAllocatorConfigError = A;
      class E extends l.UnknownDataError {
        vault;
        marketId;
        constructor(e, t) {
          super(`missing public allocator config for vault "${e}" on market "${t}"`),
            (this.vault = e),
            (this.marketId = t);
        }
      }
      (t.UnknownVaultMarketPublicAllocatorConfigError = E),
        (function (e) {
          class t extends Error {
            token;
            user;
            constructor(e, t) {
              super(`insufficient balance of user "${t}" for token "${e}"`),
                (this.token = e),
                (this.user = t);
            }
          }
          e.InsufficientBalance = t;
          class n extends Error {
            token;
            owner;
            spender;
            constructor(e, t, n) {
              super(`insufficient allowance for token "${e}" from owner "${t}" to spender "${n}"`),
                (this.token = e),
                (this.owner = t),
                (this.spender = n);
            }
          }
          e.InsufficientAllowance = n;
          class r extends Error {
            token;
            owner;
            nonce;
            constructor(e, t, n) {
              super(`invalid EIP-2612 nonce "${n}" for token "${e}" of owner "${t}"`),
                (this.token = e),
                (this.owner = t),
                (this.nonce = n);
            }
          }
          e.InvalidEIP2612Nonce = r;
          class i extends Error {
            token;
            owner;
            nonce;
            constructor(e, t, n) {
              super(`invalid permit2 nonce "${n}" for token "${e}" from owner "${t}"`),
                (this.token = e),
                (this.owner = t),
                (this.nonce = n);
            }
          }
          e.InvalidPermit2Nonce = i;
          class a extends Error {
            token;
            owner;
            constructor(e, t) {
              super(`insufficient permit2 allowance for token "${e}" from owner "${t}"`),
                (this.token = e),
                (this.owner = t);
            }
          }
          e.InsufficientPermit2Allowance = a;
          class s extends Error {
            token;
            user;
            constructor(e, t) {
              super(`unauthorized transfer of token "${e}" from owner "${t}"`),
                (this.token = e),
                (this.user = t);
            }
          }
          e.UnauthorizedTransfer = s;
        })(r || (t.Erc20Errors = r = {})),
        (function (e) {
          class t extends Error {
            error;
            index;
            operation;
            constructor(e, t, n) {
              super(e.message),
                (this.error = e),
                (this.index = t),
                (this.operation = n),
                (this.stack = e.stack);
            }
          }
          e.Simulation = t;
          class n extends Error {
            input;
            constructor(e) {
              super(
                `invalid input: ${(0, u.entries)(e)
                  .map((e) => e.join('='))
                  .join(', ')}`
              ),
                (this.input = e);
            }
          }
          e.InvalidInput = n;
        })(i || (t.SimulationErrors = i = {})),
        (function (e) {
          class t extends Error {
            marketId;
            constructor(e) {
              super(`market "${e}" not enabled`), (this.marketId = e);
            }
          }
          e.MarketNotEnabled = t;
          class n extends Error {
            constructor() {
              super('zero assets');
            }
          }
          e.ZeroAssets = n;
          class r extends Error {
            user;
            constructor(e) {
              super(`unauthorized bundler for user "${e}"`), (this.user = e);
            }
          }
          e.UnauthorizedBundler = r;
        })(a || (t.BlueSimulationErrors = a = {})),
        (function (e) {
          class t extends Error {
            constructor() {
              super('zero assets');
            }
          }
          e.ZeroAssets = t;
          class n extends Error {
            constructor() {
              super('zero shares');
            }
          }
          e.ZeroShares = n;
          class r extends Error {
            vault;
            account;
            constructor(e, t) {
              super(`account ${t} not allocator of vault "${e}"`),
                (this.vault = e),
                (this.account = t);
            }
          }
          e.NotAllocatorRole = r;
          class i extends Error {
            vault;
            remainingRequested;
            constructor(e, t) {
              super(`not enough liquidity on vault "${e}" (remaining requested: ${t})`),
                (this.vault = e),
                (this.remainingRequested = t);
            }
          }
          e.NotEnoughLiquidity = i;
          class a extends Error {
            vault;
            marketId;
            constructor(e, t) {
              super(`market "${t}" not enabled on vault "${e}"`),
                (this.vault = e),
                (this.marketId = t);
            }
          }
          e.MarketNotEnabled = a;
          class s extends Error {
            vault;
            marketId;
            constructor(e, t) {
              super(`unauthorized market "${t}" on vault "${e}"`),
                (this.vault = e),
                (this.marketId = t);
            }
          }
          e.UnauthorizedMarket = s;
          class o extends Error {
            vault;
            marketId;
            cap;
            constructor(e, t, n) {
              super(`supply cap of ${n} exceeded for vault "${e}" on market "${t}"`),
                (this.vault = e),
                (this.marketId = t),
                (this.cap = n);
            }
          }
          e.SupplyCapExceeded = o;
          class l extends Error {
            vault;
            remainingRequested;
            constructor(e, t) {
              super(`all caps reached on vault "${e}" (remaining requested: ${t})`),
                (this.vault = e),
                (this.remainingRequested = t);
            }
          }
          e.AllCapsReached = l;
          class u extends Error {
            vault;
            totalSupplied;
            totalWithdrawn;
            constructor(e, t, n) {
              super(
                `inconsistent reallocation for vault "${e}": total supplied (${t}) != total withdrawn (${n})`
              ),
                (this.vault = e),
                (this.totalSupplied = t),
                (this.totalWithdrawn = n);
            }
          }
          e.InconsistentReallocation = u;
        })(s || (t.MetaMorphoErrors = s = {})),
        (function (e) {
          class t extends Error {
            vault;
            marketId;
            constructor(e, t) {
              super(`vault "${e}" withdrawing 0 on market "${t}"`),
                (this.vault = e),
                (this.marketId = t);
            }
          }
          e.WithdrawZero = t;
          class n extends Error {
            vault;
            constructor(e) {
              super(`empty withdrawals for vault "${e}"`), (this.vault = e);
            }
          }
          e.EmptyWithdrawals = n;
          class r extends Error {
            vault;
            prevId;
            nextId;
            constructor(e, t, n) {
              super(
                `inconsistent withdrawals for vault "${e}": "${t}" is expected to appear before "${n}"`
              ),
                (this.vault = e),
                (this.prevId = t),
                (this.nextId = n);
            }
          }
          e.InconsistentWithdrawals = r;
          class i extends Error {
            vault;
            marketId;
            constructor(e, t) {
              super(`max outflow exceeded for vault "${e}" on market "${t}"`),
                (this.vault = e),
                (this.marketId = t);
            }
          }
          e.MaxOutflowExceeded = i;
          class a extends Error {
            vault;
            marketId;
            constructor(e, t) {
              super(`max inflow exceeded for vault "${e}" on market "${t}"`),
                (this.vault = e),
                (this.marketId = t);
            }
          }
          e.MaxInflowExceeded = a;
          class s extends Error {
            vault;
            supplyMarketId;
            constructor(e, t) {
              super(`supply market "${t}" in withdrawals of vault "${e}"`),
                (this.vault = e),
                (this.supplyMarketId = t);
            }
          }
          e.DepositMarketInWithdrawals = s;
          class o extends Error {
            vault;
            marketId;
            constructor(e, t) {
              super(`not enough supply of vault "${e}" on market "${t}"`),
                (this.vault = e),
                (this.marketId = t);
            }
          }
          e.NotEnoughSupply = o;
        })(o || (t.PublicAllocatorErrors = o = {}));
    },
    53794: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.handleBlueAccrueInterestOperation = void 0),
        (t.handleBlueAccrueInterestOperation = ({ args: { id: e } }, t) => {
          let n = t.getMarket(e),
            r = n.accrueInterest(t.block.timestamp);
          t.markets[e] = r;
          let { feeRecipient: i } = t.global;
          if (null != i) {
            let a = t.tryGetPosition(i, e);
            null != a && (a.supplyShares += r.totalSupplyShares - n.totalSupplyShares);
          }
        });
    },
    34805: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }), (t.handleBlueBorrowOperation = void 0);
      let r = n(40252),
        i = n(26349),
        a = n(55865),
        s = n(53794);
      t.handleBlueBorrowOperation = (
        {
          args: {
            id: e,
            assets: t = 0n,
            shares: n = 0n,
            onBehalf: o,
            receiver: l,
            slippage: u = 0n,
          },
          sender: c,
        },
        d
      ) => {
        let {
          morpho: p,
          bundler3: { generalAdapter1: h },
        } = (0, r.getChainAddresses)(d.chainId);
        if (c === h && !d.getUser(o).isBundlerAuthorized)
          throw new i.BlueSimulationErrors.UnauthorizedBundler(o);
        (0, s.handleBlueAccrueInterestOperation)(
          { type: 'Blue_AccrueInterest', sender: p, args: { id: e } },
          d
        );
        let y = d.getMarket(e);
        if (null == y.price) throw new r.BlueErrors.UnknownOraclePrice(e);
        if (
          (0n === n
            ? (n = r.MathLib.wMulUp(y.toBorrowShares(t, 'Up'), r.MathLib.WAD + u))
            : (t = y.toBorrowAssets(r.MathLib.wDivDown(n, r.MathLib.WAD + u), 'Down')),
          (y.totalBorrowAssets += t),
          (y.totalBorrowShares += n),
          y.totalBorrowAssets > y.totalSupplyAssets)
        )
          throw new r.BlueErrors.InsufficientLiquidity(e);
        let f = d.getPosition(o, e);
        if (((f.borrowShares += n), !y.isHealthy(f)))
          throw new r.BlueErrors.InsufficientCollateral(o, e);
        (0, a.handleErc20Operation)(
          {
            type: 'Erc20_Transfer',
            sender: p,
            address: y.params.loanToken,
            args: { amount: t, from: p, to: l },
          },
          d
        );
      };
    },
    45565: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }), (t.handleBlueOperation = void 0);
      let r = n(26349),
        i = n(53794),
        a = n(34805),
        s = n(56425),
        o = n(65503),
        l = n(99526),
        u = n(15991),
        c = n(74093),
        d = n(50511);
      t.handleBlueOperation = (e, t) => {
        if ('assets' in e.args) {
          let { assets: t = 0n } = e.args;
          if (t < 0n) throw new r.SimulationErrors.InvalidInput({ assets: t });
        }
        if ('shares' in e.args) {
          let { shares: t = 0n } = e.args;
          if (t < 0n) throw new r.SimulationErrors.InvalidInput({ shares: t });
        }
        switch (e.type) {
          case 'Blue_AccrueInterest':
            return (0, i.handleBlueAccrueInterestOperation)(e, t);
          case 'Blue_SetAuthorization':
            return (0, o.handleBlueSetAuthorizationOperation)(e, t);
          case 'Blue_Borrow':
            return (0, a.handleBlueBorrowOperation)(e, t);
          case 'Blue_Repay':
            return (0, s.handleBlueRepayOperation)(e, t);
          case 'Blue_Supply':
            return (0, l.handleBlueSupplyOperation)(e, t);
          case 'Blue_SupplyCollateral':
            return (0, u.handleBlueSupplyCollateralOperation)(e, t);
          case 'Blue_Withdraw':
            return (0, c.handleBlueWithdrawOperation)(e, t);
          case 'Blue_WithdrawCollateral':
            return (0, d.handleBlueWithdrawCollateralOperation)(e, t);
        }
      };
    },
    56425: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }), (t.handleBlueRepayOperation = void 0);
      let r = n(40252),
        i = n(99796),
        a = n(55865),
        s = n(53794);
      t.handleBlueRepayOperation = (
        {
          args: {
            id: e,
            assets: t = 0n,
            shares: n = 0n,
            onBehalf: o,
            callback: l,
            slippage: u = 0n,
          },
          sender: c,
        },
        d
      ) => {
        let {
          morpho: p,
          bundler3: { generalAdapter1: h },
        } = (0, r.getChainAddresses)(d.chainId);
        (0, s.handleBlueAccrueInterestOperation)(
          { type: 'Blue_AccrueInterest', sender: p, args: { id: e } },
          d
        );
        let y = d.getMarket(e);
        if (
          (c === h &&
            t === r.MathLib.MAX_UINT_256 &&
            (t = d.getHolding(c, y.params.loanToken).balance),
          0n === t && 0n === n)
        )
          throw new r.BlueErrors.InconsistentInput();
        0n === n
          ? (n = y.toBorrowShares(r.MathLib.wDivDown(t, r.MathLib.WAD + u)))
          : (t = r.MathLib.wMulUp(y.toBorrowAssets(n), r.MathLib.WAD + u)),
          (y.totalBorrowAssets -= t),
          (y.totalBorrowShares -= n);
        let f = d.getPosition(o, e);
        if (((f.borrowShares -= n), f.borrowShares < 0n))
          throw new r.BlueErrors.InsufficientPosition(o, y.id);
        l && (0, i.handleOperations)(l(d), d),
          (0, a.handleErc20Operation)(
            {
              type: 'Erc20_Transfer',
              sender: p,
              address: y.params.loanToken,
              args: { amount: t, from: c, to: p },
            },
            d
          );
      };
    },
    65503: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.handleBlueSetAuthorizationOperation = void 0);
      let r = n(40252);
      t.handleBlueSetAuthorizationOperation = (
        { args: { owner: e, authorized: t, isAuthorized: n } },
        i
      ) => {
        let a = i.getUser(e),
          {
            bundler3: { generalAdapter1: s },
          } = (0, r.getChainAddresses)(i.chainId);
        if (t === s) {
          if (a.isBundlerAuthorized === n)
            throw new r.BlueErrors.AlreadySet('isBundlerAuthorized', n.toString());
          a.isBundlerAuthorized = n;
        }
      };
    },
    99526: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }), (t.handleBlueSupplyOperation = void 0);
      let r = n(40252),
        i = n(99796),
        a = n(55865),
        s = n(53794);
      t.handleBlueSupplyOperation = (
        {
          args: {
            id: e,
            assets: t = 0n,
            shares: n = 0n,
            onBehalf: o,
            callback: l,
            slippage: u = 0n,
          },
          sender: c,
        },
        d
      ) => {
        let {
          morpho: p,
          bundler3: { generalAdapter1: h },
        } = (0, r.getChainAddresses)(d.chainId);
        (0, s.handleBlueAccrueInterestOperation)(
          { type: 'Blue_AccrueInterest', sender: p, args: { id: e } },
          d
        );
        let y = d.getMarket(e);
        if (
          (c === h &&
            t === r.MathLib.MAX_UINT_256 &&
            (t = d.getHolding(c, y.params.loanToken).balance),
          0n === t && 0n === n)
        )
          throw new r.BlueErrors.InconsistentInput();
        0n === n
          ? (n = y.toSupplyShares(r.MathLib.wDivDown(t, r.MathLib.WAD + u), 'Down'))
          : (t = r.MathLib.wMulUp(y.toSupplyAssets(n, 'Up'), r.MathLib.WAD + u)),
          (y.totalSupplyAssets += t),
          (y.totalSupplyShares += n);
        let f = d.getPosition(o, e);
        (f.supplyShares += n),
          l && (0, i.handleOperations)(l(d), d),
          (0, a.handleErc20Operation)(
            {
              type: 'Erc20_Transfer',
              sender: p,
              address: y.params.loanToken,
              args: { amount: t, from: c, to: p },
            },
            d
          );
      };
    },
    15991: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.handleBlueSupplyCollateralOperation = void 0);
      let r = n(40252),
        i = n(26349),
        a = n(99796),
        s = n(55865);
      t.handleBlueSupplyCollateralOperation = (
        { args: { id: e, assets: t, onBehalf: n, callback: o }, sender: l },
        u
      ) => {
        let {
            params: { collateralToken: c },
          } = u.getMarket(e),
          {
            morpho: d,
            bundler3: { generalAdapter1: p },
          } = (0, r.getChainAddresses)(u.chainId);
        if ((l === p && t === r.MathLib.MAX_UINT_256 && (t = u.getHolding(l, c).balance), 0n === t))
          throw new i.BlueSimulationErrors.ZeroAssets();
        let h = u.getPosition(n, e);
        (h.collateral += t),
          o && (0, a.handleOperations)(o(u), u),
          (0, s.handleErc20Operation)(
            { type: 'Erc20_Transfer', sender: d, address: c, args: { amount: t, from: l, to: d } },
            u
          );
      };
    },
    74093: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.handleBlueWithdrawOperation = void 0);
      let r = n(40252),
        i = n(26349),
        a = n(55865),
        s = n(53794);
      t.handleBlueWithdrawOperation = (
        {
          args: {
            id: e,
            assets: t = 0n,
            shares: n = 0n,
            onBehalf: o,
            receiver: l,
            slippage: u = 0n,
          },
          sender: c,
        },
        d
      ) => {
        let {
          morpho: p,
          bundler3: { generalAdapter1: h },
        } = (0, r.getChainAddresses)(d.chainId);
        if (c === h && !d.getUser(o).isBundlerAuthorized)
          throw new i.BlueSimulationErrors.UnauthorizedBundler(o);
        (0, s.handleBlueAccrueInterestOperation)(
          { type: 'Blue_AccrueInterest', sender: p, args: { id: e } },
          d
        );
        let y = d.getMarket(e);
        if (
          (0n === n
            ? (n = r.MathLib.wMulUp(y.toSupplyShares(t), r.MathLib.WAD + u))
            : (t = y.toSupplyAssets(r.MathLib.wDivDown(n, r.MathLib.WAD + u))),
          (y.totalSupplyAssets -= t),
          (y.totalSupplyShares -= n),
          y.totalBorrowAssets > y.totalSupplyAssets)
        )
          throw new r.BlueErrors.InsufficientLiquidity(e);
        let f = d.getPosition(o, e);
        if (((f.supplyShares -= n), f.supplyShares < 0n))
          throw new r.BlueErrors.InsufficientPosition(o, e);
        (0, a.handleErc20Operation)(
          {
            type: 'Erc20_Transfer',
            sender: p,
            address: y.params.loanToken,
            args: { amount: t, from: p, to: l },
          },
          d
        );
      };
    },
    50511: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.handleBlueWithdrawCollateralOperation = void 0);
      let r = n(40252),
        i = n(26349),
        a = n(55865),
        s = n(53794);
      t.handleBlueWithdrawCollateralOperation = (
        { args: { id: e, assets: t, onBehalf: n, receiver: o }, sender: l },
        u
      ) => {
        if (0n === t) throw new i.BlueSimulationErrors.ZeroAssets();
        let {
          morpho: c,
          bundler3: { generalAdapter1: d },
        } = (0, r.getChainAddresses)(u.chainId);
        if (l === d && !u.getUser(n).isBundlerAuthorized)
          throw new i.BlueSimulationErrors.UnauthorizedBundler(n);
        (0, s.handleBlueAccrueInterestOperation)(
          { type: 'Blue_AccrueInterest', sender: c, args: { id: e } },
          u
        );
        let p = u.getMarket(e);
        if (null == p.price) throw new r.BlueErrors.UnknownOraclePrice(e);
        let h = u.getPosition(n, e);
        if (((h.collateral -= t), h.collateral < 0n))
          throw new r.BlueErrors.InsufficientPosition(n, e);
        if (!p.isHealthy(h)) throw new r.BlueErrors.InsufficientCollateral(n, e);
        (0, a.handleErc20Operation)(
          {
            type: 'Erc20_Transfer',
            sender: c,
            address: p.params.collateralToken,
            args: { amount: t, from: c, to: o },
          },
          u
        );
      };
    },
    99796: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.simulateOperations =
          t.simulateOperation =
          t.handleOperation =
          t.produceImmutable =
            void 0),
        (t.handleOperations = u);
      let r = n(84945),
        i = n(26349),
        a = n(84700),
        s = n(45565),
        o = n(55865),
        l = n(46808);
      function u(e, n, r = t.handleOperation) {
        let i = [n];
        for (let t = 0; t < e.length; ++t) i.push(r(e[t], i[t], t));
        return i;
      }
      (t.produceImmutable = (0, r.makeCreator)({ mark: () => 'immutable', strict: !0 })),
        (t.handleOperation = (e, t, n = 0) => {
          try {
            return (
              (0, a.isBlueOperation)(e)
                ? (0, s.handleBlueOperation)(e, t)
                : (0, a.isMetaMorphoOperation)(e)
                  ? (0, l.handleMetaMorphoOperation)(e, t)
                  : (0, a.isErc20Operation)(e) && (0, o.handleErc20Operation)(e, t),
              t
            );
          } catch (t) {
            if (!(t instanceof Error)) throw t;
            throw new i.SimulationErrors.Simulation(t, n, e);
          }
        }),
        (t.simulateOperation = (e, n, r = 0) =>
          (0, t.produceImmutable)(n, (n) => {
            (0, t.handleOperation)(e, n, r);
          })),
        (t.simulateOperations = (e, n) => u(e, n, t.simulateOperation));
    },
    50988: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.handleErc20ApproveOperation = void 0);
      let r = n(40252),
        i = n(26349);
      t.handleErc20ApproveOperation = (
        { args: { spender: e, amount: t }, sender: n, address: a },
        s
      ) => {
        let o = s.getHolding(n, a),
          {
            morpho: l,
            bundler3: { generalAdapter1: u },
            permit2: c,
          } = (0, r.getChainAddresses)(s.chainId),
          d =
            e === l
              ? 'morpho'
              : e === u
                ? 'bundler3.generalAdapter1'
                : e === c
                  ? 'permit2'
                  : void 0;
        if (null != d) o.erc20Allowances[d] = t;
        else {
          let r = s.tryGetVault(e);
          if (null != r && r.asset === a) s.getVaultUser(e, n).allowance = t;
          else throw new i.UnknownAllowanceError(a, n, e);
        }
      };
    },
    55865: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }), (t.handleErc20Operation = void 0);
      let r = n(26349),
        i = n(50988),
        a = n(71675),
        s = n(69801),
        o = n(71404),
        l = n(70211),
        u = n(45578),
        c = n(45636);
      t.handleErc20Operation = (e, t) => {
        if ('amount' in e.args) {
          let { amount: t } = e.args;
          if (t < 0n) throw new r.SimulationErrors.InvalidInput({ amount: t });
        }
        switch (e.type) {
          case 'Erc20_Approve':
            return (0, i.handleErc20ApproveOperation)(e, t);
          case 'Erc20_Permit':
            return (0, a.handleErc20PermitOperation)(e, t);
          case 'Erc20_Permit2':
            return (0, s.handleErc20Permit2Operation)(e, t);
          case 'Erc20_Transfer':
            return (0, o.handleErc20TransferOperation)(e, t);
          case 'Erc20_Transfer2':
            return (0, l.handleErc20Transfer2Operation)(e, t);
          case 'Erc20_Wrap':
            return (0, c.handleErc20WrapOperation)(e, t);
          case 'Erc20_Unwrap':
            return (0, u.handleErc20UnwrapOperation)(e, t);
        }
      };
    },
    71675: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.handleErc20PermitOperation = void 0);
      let r = n(26349),
        i = n(50988);
      t.handleErc20PermitOperation = (
        { args: { spender: e, amount: t, nonce: n }, sender: a, address: s },
        o
      ) => {
        let l = o.getHolding(a, s);
        if (null == l.erc2612Nonce) throw new r.UnknownEIP2612DataError(s, a);
        if (l.erc2612Nonce !== n) throw new r.Erc20Errors.InvalidEIP2612Nonce(s, a, n);
        (l.erc2612Nonce += 1n),
          (0, i.handleErc20ApproveOperation)(
            { type: 'Erc20_Approve', sender: a, address: s, args: { amount: t, spender: e } },
            o
          );
      };
    },
    69801: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.handleErc20Permit2Operation = void 0);
      let r = n(26349);
      t.handleErc20Permit2Operation = (
        { args: { amount: e, expiration: t, nonce: n }, sender: i, address: a },
        s
      ) => {
        let { permit2BundlerAllowance: o } = s.getHolding(i, a);
        if (o.nonce !== n) throw new r.Erc20Errors.InvalidPermit2Nonce(a, i, n);
        (o.amount = e), (o.expiration = t), (o.nonce += 1n);
      };
    },
    71404: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.handleErc20TransferOperation = void 0);
      let r = n(40252),
        i = n(35047),
        a = n(26349);
      t.handleErc20TransferOperation = (
        { args: { amount: e, from: t, to: n }, sender: s, address: o },
        l
      ) => {
        let {
          morpho: u,
          bundler3: { generalAdapter1: c },
          permit2: d,
        } = (0, r.getChainAddresses)(l.chainId);
        if (t !== i.ZERO_ADDRESS && t !== u) {
          let n = l.getHolding(t, o);
          if (!1 === n.canTransfer) throw new a.Erc20Errors.UnauthorizedTransfer(o, t);
          if (
            (s === t &&
              t === c &&
              e === r.MathLib.MAX_UINT_256 &&
              (e = r.MathLib.min(e, n.balance)),
            s !== t && t !== c)
          ) {
            let r =
              s === u
                ? 'morpho'
                : s === c
                  ? 'bundler3.generalAdapter1'
                  : s === d
                    ? 'permit2'
                    : void 0;
            if (null != r) {
              if (n.erc20Allowances[r] < e) throw new a.Erc20Errors.InsufficientAllowance(o, t, s);
              n.erc20Allowances[r] -= e;
            } else {
              let n = l.tryGetVault(s),
                r = l.tryGetVaultUser(s, t);
              if (n?.asset === o && null != r) {
                if (r.allowance < e) throw new a.Erc20Errors.InsufficientAllowance(o, t, s);
                r.allowance -= e;
              }
            }
          }
          if (((n.balance -= e), n.balance < 0n)) throw new a.Erc20Errors.InsufficientBalance(o, t);
        }
        let p = l.tryGetHolding(n, o);
        null != p && (p.balance += e);
      };
    },
    70211: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.handleErc20Transfer2Operation = void 0);
      let r = n(40252),
        i = n(26349),
        a = n(71404);
      t.handleErc20Transfer2Operation = (
        { args: { amount: e, from: t, to: n }, address: s },
        o
      ) => {
        let l = o.tryGetHolding(t, s);
        if (null == l) throw new i.Erc20Errors.InsufficientBalance(s, t);
        let { permit2: u } = (0, r.getChainAddresses)(o.chainId);
        if (null == u) throw new i.UnexpectedOperation('Erc20_Transfer2', o.chainId);
        let { permit2BundlerAllowance: c } = l;
        if (c.expiration < o.block.timestamp || c.amount < e)
          throw new i.Erc20Errors.InsufficientPermit2Allowance(s, t);
        (c.amount -= e),
          (0, a.handleErc20TransferOperation)(
            { type: 'Erc20_Transfer', sender: u, address: s, args: { amount: e, from: t, to: n } },
            o
          );
      };
    },
    45578: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.handleErc20UnwrapOperation = void 0);
      let r = n(40252),
        i = n(35047),
        a = n(71404);
      t.handleErc20UnwrapOperation = (
        { address: e, args: { amount: t, receiver: n, slippage: s = 0n }, sender: o },
        l
      ) => {
        let {
          bundler3: { generalAdapter1: u },
        } = (0, r.getChainAddresses)(l.chainId);
        o === u && t === r.MathLib.MAX_UINT_256 && (t = l.getHolding(o, e).balance);
        let c = l.getWrappedToken(e),
          d = c.toUnwrappedExactAmountIn(t, s);
        r.erc20WrapperTokens[l.chainId]?.has(e) || (n = o),
          (0, a.handleErc20TransferOperation)(
            {
              type: 'Erc20_Transfer',
              sender: e,
              address: e,
              args: { amount: t, from: o, to: i.ZERO_ADDRESS },
            },
            l
          ),
          (0, a.handleErc20TransferOperation)(
            {
              type: 'Erc20_Transfer',
              sender: e,
              address: c.underlying,
              args: { amount: d, from: i.ZERO_ADDRESS, to: n },
            },
            l
          );
      };
    },
    45636: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }), (t.handleErc20WrapOperation = void 0);
      let r = n(40252),
        i = n(35047),
        a = n(71404);
      t.handleErc20WrapOperation = (
        { address: e, args: { amount: t, owner: n, slippage: s = 0n }, sender: o },
        l
      ) => {
        let {
          bundler3: { generalAdapter1: u },
        } = (0, r.getChainAddresses)(l.chainId);
        o === u && t === r.MathLib.MAX_UINT_256 && (t = l.getHolding(o, e).balance);
        let c = l.getWrappedToken(e),
          d = c.toWrappedExactAmountIn(t, s);
        (0, a.handleErc20TransferOperation)(
          {
            type: 'Erc20_Transfer',
            sender: e,
            address: c.underlying,
            args: { amount: t, from: o, to: i.ZERO_ADDRESS },
          },
          l
        ),
          (0, a.handleErc20TransferOperation)(
            {
              type: 'Erc20_Transfer',
              sender: e,
              address: c.address,
              args: { amount: d, from: i.ZERO_ADDRESS, to: n },
            },
            l
          );
      };
    },
    6382: function (e, t, n) {
      'use strict';
      var r =
          (this && this.__createBinding) ||
          (Object.create
            ? function (e, t, n, r) {
                void 0 === r && (r = n);
                var i = Object.getOwnPropertyDescriptor(t, n);
                (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
                  (i = {
                    enumerable: !0,
                    get: function () {
                      return t[n];
                    },
                  }),
                  Object.defineProperty(e, r, i);
              }
            : function (e, t, n, r) {
                void 0 === r && (r = n), (e[r] = t[n]);
              }),
        i =
          (this && this.__exportStar) ||
          function (e, t) {
            for (var n in e)
              'default' === n || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n);
          };
      Object.defineProperty(t, '__esModule', { value: !0 }), i(n(99796), t), i(n(2998), t);
    },
    16684: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.handleMetaMorphoAccrueInterestOperation = void 0);
      let r = n(40252),
        i = n(35047),
        a = n(55865);
      t.handleMetaMorphoAccrueInterestOperation = ({ address: e }, t) => {
        let n = t.getAccrualVault(e),
          s = n.accrueInterest(t.block.timestamp);
        t.vaults[e] = new r.Vault(s);
        let o = s.totalSupply - n.totalSupply;
        o > 0n &&
          n.feeRecipient !== i.ZERO_ADDRESS &&
          (0, a.handleErc20Operation)(
            {
              type: 'Erc20_Transfer',
              sender: e,
              address: e,
              args: { amount: o, from: i.ZERO_ADDRESS, to: n.feeRecipient },
            },
            t
          );
      };
    },
    72674: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.handleMetaMorphoDepositOperation = void 0);
      let r = n(40252),
        i = n(26349),
        a = n(45565),
        s = n(55865),
        o = n(35047),
        l = n(16684);
      t.handleMetaMorphoDepositOperation = (
        {
          args: { assets: e = 0n, shares: t = 0n, owner: n, slippage: u = 0n },
          sender: c,
          address: d,
        },
        p
      ) => {
        (0, l.handleMetaMorphoAccrueInterestOperation)(
          { type: 'MetaMorpho_AccrueInterest', sender: d, address: d, args: {} },
          p
        );
        let {
            bundler3: { generalAdapter1: h },
          } = (0, r.getChainAddresses)(p.chainId),
          y = p.getVault(d);
        if (0n === t) {
          if (
            c === h &&
            (e === r.MathLib.MAX_UINT_256 && (e = p.getHolding(c, y.asset).balance), 0n === e)
          )
            throw new i.MetaMorphoErrors.ZeroAssets();
          t = y.toShares(r.MathLib.wDivDown(e, r.MathLib.WAD + u), 'Down');
        } else {
          if (c === h && 0n === t) throw new i.MetaMorphoErrors.ZeroShares();
          e = r.MathLib.wMulUp(y.toAssets(t, 'Up'), r.MathLib.WAD + u);
        }
        (0, s.handleErc20Operation)(
          {
            type: 'Erc20_Transfer',
            sender: d,
            address: y.asset,
            args: { amount: e, from: c, to: d },
          },
          p
        );
        let f = e;
        for (let e of y.supplyQueue) {
          let { cap: t } = p.getVaultMarketConfig(d, e);
          if (0n === t) continue;
          (0, a.handleBlueOperation)(
            { type: 'Blue_AccrueInterest', sender: d, args: { id: e } },
            p
          );
          let { supplyAssets: n } = p.getAccrualPosition(d, e),
            i = r.MathLib.zeroFloorSub(t, n);
          if (0n === i) continue;
          let s = r.MathLib.min(f, i);
          if (
            ((0, a.handleBlueOperation)(
              { type: 'Blue_Supply', sender: d, args: { id: e, assets: s, onBehalf: d } },
              p
            ),
            (f -= s) <= 0n)
          )
            break;
        }
        if (0n !== f) throw new i.MetaMorphoErrors.AllCapsReached(d, f);
        (y.totalAssets += e),
          (y.lastTotalAssets = y.totalAssets),
          (y.totalSupply += t),
          (0, s.handleErc20Operation)(
            {
              type: 'Erc20_Transfer',
              sender: d,
              address: d,
              args: { amount: t, from: o.ZERO_ADDRESS, to: n },
            },
            p
          );
      };
    },
    46808: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }), (t.handleMetaMorphoOperation = void 0);
      let r = n(26349),
        i = n(16684),
        a = n(72674),
        s = n(12715),
        o = n(6494),
        l = n(70473);
      t.handleMetaMorphoOperation = (e, t) => {
        if ('assets' in e.args) {
          let { assets: t = 0n } = e.args;
          if (t < 0n) throw new r.SimulationErrors.InvalidInput({ assets: t });
        }
        if ('shares' in e.args) {
          let { shares: t = 0n } = e.args;
          if (t < 0n) throw new r.SimulationErrors.InvalidInput({ shares: t });
        }
        switch (e.type) {
          case 'MetaMorpho_AccrueInterest':
            return (0, i.handleMetaMorphoAccrueInterestOperation)(e, t);
          case 'MetaMorpho_Deposit':
            return (0, a.handleMetaMorphoDepositOperation)(e, t);
          case 'MetaMorpho_Withdraw':
            return (0, l.handleMetaMorphoWithdrawOperation)(e, t);
          case 'MetaMorpho_Reallocate':
            return (0, o.handleMetaMorphoReallocateOperation)(e, t);
          case 'MetaMorpho_PublicReallocate':
            return (0, s.handleMetaMorphoPublicReallocateOperation)(e, t);
        }
      };
    },
    12715: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.handleMetaMorphoPublicReallocateOperation = void 0);
      let r = n(40252),
        i = n(26349),
        a = n(45565),
        s = n(55865),
        o = n(35047),
        l = n(6494);
      t.handleMetaMorphoPublicReallocateOperation = (
        { args: { withdrawals: e, supplyMarketId: t }, sender: n, address: u },
        c
      ) => {
        let d;
        let { publicAllocatorConfig: p } = c.getVault(u);
        if (null == p) throw new i.UnknownVaultPublicAllocatorConfigError(u);
        let { fee: h } = p;
        if (
          (h > 0n &&
            ((0, s.handleErc20Operation)(
              {
                type: 'Erc20_Transfer',
                sender: u,
                address: r.NATIVE_ADDRESS,
                args: { amount: h, from: n, to: o.ZERO_ADDRESS },
              },
              c
            ),
            (p.accruedFee += h)),
          0 === e.length)
        )
          throw new i.PublicAllocatorErrors.EmptyWithdrawals(u);
        let y = c.getVaultMarketConfig(u, t);
        if (!y.enabled) throw new i.MetaMorphoErrors.MarketNotEnabled(u, t);
        if (null == y.publicAllocatorConfig)
          throw new i.UnknownVaultMarketPublicAllocatorConfigError(u, t);
        let f = 0n,
          m = [];
        for (let { id: n, assets: r } of e) {
          if (null != d && n <= d)
            throw new i.PublicAllocatorErrors.InconsistentWithdrawals(u, d, n);
          d = n;
          let e = c.getVaultMarketConfig(u, n);
          if (!e.enabled) throw new i.MetaMorphoErrors.MarketNotEnabled(u, n);
          if (null == e.publicAllocatorConfig)
            throw new i.UnknownVaultMarketPublicAllocatorConfigError(u, n);
          if (e.publicAllocatorConfig.maxOut < r)
            throw new i.PublicAllocatorErrors.MaxOutflowExceeded(u, n);
          if (0n === r) throw new i.PublicAllocatorErrors.WithdrawZero(u, n);
          if (n === t) throw new i.PublicAllocatorErrors.DepositMarketInWithdrawals(u, n);
          (0, a.handleBlueOperation)(
            { type: 'Blue_AccrueInterest', sender: u, args: { id: n } },
            c
          );
          let { supplyAssets: s } = c.getAccrualPosition(u, n);
          if (s < r) throw new i.PublicAllocatorErrors.NotEnoughSupply(u, n);
          (e.publicAllocatorConfig.maxIn += r),
            (e.publicAllocatorConfig.maxOut -= r),
            m.push({ id: n, assets: s - r }),
            (f += r);
        }
        if (y.publicAllocatorConfig.maxIn < f)
          throw new i.PublicAllocatorErrors.MaxInflowExceeded(u, t);
        (y.publicAllocatorConfig.maxIn -= f),
          (y.publicAllocatorConfig.maxOut += f),
          m.push({ id: t, assets: r.MathLib.MAX_UINT_256 }),
          (0, l.handleMetaMorphoReallocateOperation)(
            { type: 'MetaMorpho_Reallocate', sender: u, address: u, args: m },
            c
          );
      };
    },
    6494: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.handleMetaMorphoReallocateOperation = void 0);
      let r = n(40252),
        i = n(26349),
        a = n(45565);
      t.handleMetaMorphoReallocateOperation = ({ args: e, sender: t, address: n }, s) => {
        let { owner: o, publicAllocatorConfig: l } = s.getVault(n);
        if (t !== o && (!l || t !== n)) throw new i.MetaMorphoErrors.NotAllocatorRole(n, t);
        let u = 0n,
          c = 0n;
        for (let { id: t, assets: o } of e) {
          (0, a.handleBlueOperation)(
            { type: 'Blue_AccrueInterest', sender: n, args: { id: t } },
            s
          );
          let { cap: e, enabled: l } = s.getVaultMarketConfig(n, t),
            { supplyAssets: d, supplyShares: p } = s.getAccrualPosition(n, t),
            h = r.MathLib.zeroFloorSub(d, o);
          if (h > 0n) {
            if (!l) throw new i.MetaMorphoErrors.MarketNotEnabled(n, t);
            (0, a.handleBlueOperation)(
              {
                type: 'Blue_Withdraw',
                sender: n,
                args: {
                  id: t,
                  ...(0n === o ? { shares: p } : { assets: h }),
                  onBehalf: n,
                  receiver: n,
                },
              },
              s
            ),
              (c += h);
          } else {
            let l = o === r.MathLib.MAX_UINT_256 ? r.MathLib.zeroFloorSub(c, u) : o - d;
            if (0n === l) continue;
            if (0n === e) throw new i.MetaMorphoErrors.UnauthorizedMarket(n, t);
            if (d + l > e) throw new i.MetaMorphoErrors.SupplyCapExceeded(n, t, e);
            (0, a.handleBlueOperation)(
              { type: 'Blue_Supply', sender: n, args: { id: t, assets: l, onBehalf: n } },
              s
            ),
              (u += l);
          }
        }
        if (c !== u) throw new i.MetaMorphoErrors.InconsistentReallocation(n, u, c);
        let d = s.tryGetAccrualVault(n)?.accrueInterest(s.block.timestamp);
        null != d && (s.getVault(n).totalAssets = d.totalAssets);
      };
    },
    70473: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.handleMetaMorphoWithdrawOperation = void 0);
      let r = n(40252),
        i = n(26349),
        a = n(45565),
        s = n(55865),
        o = n(35047),
        l = n(16684);
      t.handleMetaMorphoWithdrawOperation = (
        {
          args: { assets: e = 0n, shares: t = 0n, owner: n, receiver: u, slippage: c = 0n },
          sender: d,
          address: p,
        },
        h
      ) => {
        (0, l.handleMetaMorphoAccrueInterestOperation)(
          { type: 'MetaMorpho_AccrueInterest', sender: p, address: p, args: {} },
          h
        );
        let {
            bundler3: { generalAdapter1: y },
          } = (0, r.getChainAddresses)(h.chainId),
          f = h.getVault(p);
        if (0n === t) {
          if (d === y && 0n === e) throw new i.MetaMorphoErrors.ZeroAssets();
          t = r.MathLib.wMulUp(f.toShares(e), r.MathLib.WAD + c);
        } else {
          if (
            d === y &&
            (t === r.MathLib.MAX_UINT_256 && (t = h.getHolding(n, p).balance), 0n === t)
          )
            throw new i.MetaMorphoErrors.ZeroShares();
          e = f.toAssets(r.MathLib.wDivDown(t, r.MathLib.WAD + c));
        }
        (0, s.handleErc20Operation)(
          {
            type: 'Erc20_Transfer',
            sender: d,
            address: p,
            args: { amount: t, from: n, to: o.ZERO_ADDRESS },
          },
          h
        );
        let m = e;
        for (let e of f.withdrawQueue) {
          let {
            withdrawCapacityLimit: { value: t },
          } = h.getAccrualPosition(p, e);
          if (
            ((0, a.handleBlueOperation)(
              { type: 'Blue_AccrueInterest', sender: p, args: { id: e } },
              h
            ),
            0n === t)
          )
            continue;
          let n = r.MathLib.min(m, t);
          if (
            ((0, a.handleBlueOperation)(
              {
                type: 'Blue_Withdraw',
                sender: p,
                args: { id: e, assets: n, onBehalf: p, receiver: p },
              },
              h
            ),
            (m -= n) <= 0n)
          )
            break;
        }
        if (0n !== m) throw new i.MetaMorphoErrors.NotEnoughLiquidity(p, m);
        (f.totalAssets -= e),
          (f.lastTotalAssets = f.totalAssets),
          (f.totalSupply -= t),
          (0, s.handleErc20Operation)(
            {
              type: 'Erc20_Transfer',
              sender: p,
              address: f.asset,
              args: { amount: e, from: p, to: u },
            },
            h
          );
      };
    },
    2998: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 });
    },
    89413: function (e, t, n) {
      'use strict';
      var r =
          (this && this.__createBinding) ||
          (Object.create
            ? function (e, t, n, r) {
                void 0 === r && (r = n);
                var i = Object.getOwnPropertyDescriptor(t, n);
                (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
                  (i = {
                    enumerable: !0,
                    get: function () {
                      return t[n];
                    },
                  }),
                  Object.defineProperty(e, r, i);
              }
            : function (e, t, n, r) {
                void 0 === r && (r = n), (e[r] = t[n]);
              }),
        i =
          (this && this.__exportStar) ||
          function (e, t) {
            for (var n in e)
              'default' === n || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n);
          };
      Object.defineProperty(t, '__esModule', { value: !0 }), i(n(79279), t);
    },
    79279: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }), (t.getCurrent = void 0);
      let r = n(84945);
      t.getCurrent = (e) => ((0, r.isDraft)(e) ? (0, r.current)(e) : e);
    },
    51196: function (e, t, n) {
      'use strict';
      var r =
          (this && this.__createBinding) ||
          (Object.create
            ? function (e, t, n, r) {
                void 0 === r && (r = n);
                var i = Object.getOwnPropertyDescriptor(t, n);
                (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
                  (i = {
                    enumerable: !0,
                    get: function () {
                      return t[n];
                    },
                  }),
                  Object.defineProperty(e, r, i);
              }
            : function (e, t, n, r) {
                void 0 === r && (r = n), (e[r] = t[n]);
              }),
        i =
          (this && this.__exportStar) ||
          function (e, t) {
            for (var n in e)
              'default' === n || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n);
          };
      Object.defineProperty(t, '__esModule', { value: !0 }),
        i(n(26349), t),
        i(n(84700), t),
        i(n(6382), t),
        i(n(59780), t),
        i(n(89413), t);
    },
    84700: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.isErc20Operation =
          t.isMetaMorphoOperation =
          t.isBlueOperation =
          t.CALLBACK_OPERATIONS =
          t.ERC20_OPERATIONS =
          t.METAMORPHO_OPERATIONS =
          t.BLUE_OPERATIONS =
            void 0),
        (t.BLUE_OPERATIONS = [
          'Blue_AccrueInterest',
          'Blue_SetAuthorization',
          'Blue_Borrow',
          'Blue_Repay',
          'Blue_Supply',
          'Blue_SupplyCollateral',
          'Blue_Withdraw',
          'Blue_WithdrawCollateral',
        ]),
        (t.METAMORPHO_OPERATIONS = [
          'MetaMorpho_AccrueInterest',
          'MetaMorpho_Deposit',
          'MetaMorpho_Withdraw',
          'MetaMorpho_Reallocate',
          'MetaMorpho_PublicReallocate',
        ]),
        (t.ERC20_OPERATIONS = [
          'Erc20_Approve',
          'Erc20_Permit',
          'Erc20_Permit2',
          'Erc20_Transfer',
          'Erc20_Transfer2',
          'Erc20_Wrap',
          'Erc20_Unwrap',
        ]),
        (t.CALLBACK_OPERATIONS = ['Blue_Repay', 'Blue_Supply', 'Blue_SupplyCollateral']),
        (t.isBlueOperation = (e) => t.BLUE_OPERATIONS.includes(e.type)),
        (t.isMetaMorphoOperation = (e) => t.METAMORPHO_OPERATIONS.includes(e.type)),
        (t.isErc20Operation = (e) => t.ERC20_OPERATIONS.includes(e.type));
    },
    46345: function (e, t, n) {
      'use strict';
      function r() {
        return (
          (null === n.g || void 0 === n.g ? void 0 : n.g.crypto) ||
          (null === n.g || void 0 === n.g ? void 0 : n.g.msCrypto) ||
          {}
        );
      }
      function i() {
        let e = r();
        return e.subtle || e.webkitSubtle;
      }
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.isBrowserCryptoAvailable = t.getSubtleCrypto = t.getBrowerCrypto = void 0),
        (t.getBrowerCrypto = r),
        (t.getSubtleCrypto = i),
        (t.isBrowserCryptoAvailable = function () {
          return !!r() && !!i();
        });
    },
    77680: function (e, t, n) {
      'use strict';
      var r = n(32608);
      function i() {
        return (
          'undefined' == typeof document &&
          'undefined' != typeof navigator &&
          'ReactNative' === navigator.product
        );
      }
      function a() {
        return void 0 !== r && void 0 !== r.versions && void 0 !== r.versions.node;
      }
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.isBrowser = t.isNode = t.isReactNative = void 0),
        (t.isReactNative = i),
        (t.isNode = a),
        (t.isBrowser = function () {
          return !i() && !a();
        });
    },
    67437: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 });
      let r = n(37412);
      r.__exportStar(n(46345), t), r.__exportStar(n(77680), t);
    },
    1030: function (e, t, n) {
      'use strict';
      n.d(t, {
        Ep: function () {
          return C;
        },
        Fd: function () {
          return E;
        },
        Rt: function () {
          return _;
        },
        gw: function () {
          return i.a;
        },
        jI: function () {
          return A;
        },
      });
      var r = n(28619),
        i = n.n(r),
        a = n(83729);
      let s = { level: 'info' },
        o = 'custom_context';
      class l {
        constructor(e) {
          (this.nodeValue = e),
            (this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length),
            (this.next = null);
        }
        get value() {
          return this.nodeValue;
        }
        get size() {
          return this.sizeInBytes;
        }
      }
      class u {
        constructor(e) {
          (this.head = null),
            (this.tail = null),
            (this.lengthInNodes = 0),
            (this.maxSizeInBytes = e),
            (this.sizeInBytes = 0);
        }
        append(e) {
          let t = new l(e);
          if (t.size > this.maxSizeInBytes)
            throw Error(`[LinkedList] Value too big to insert into list: ${e} with size ${t.size}`);
          for (; this.size + t.size > this.maxSizeInBytes; ) this.shift();
          this.head ? this.tail && (this.tail.next = t) : (this.head = t),
            (this.tail = t),
            this.lengthInNodes++,
            (this.sizeInBytes += t.size);
        }
        shift() {
          if (!this.head) return;
          let e = this.head;
          (this.head = this.head.next),
            this.head || (this.tail = null),
            this.lengthInNodes--,
            (this.sizeInBytes -= e.size);
        }
        toArray() {
          let e = [],
            t = this.head;
          for (; null !== t; ) e.push(t.value), (t = t.next);
          return e;
        }
        get length() {
          return this.lengthInNodes;
        }
        get size() {
          return this.sizeInBytes;
        }
        toOrderedArray() {
          return Array.from(this);
        }
        [Symbol.iterator]() {
          let e = this.head;
          return {
            next: () => {
              if (!e) return { done: !0, value: null };
              let t = e.value;
              return (e = e.next), { done: !1, value: t };
            },
          };
        }
      }
      class c {
        constructor(e, t = 1024e3) {
          (this.level = e ?? 'error'),
            (this.levelValue = r.levels.values[this.level]),
            (this.MAX_LOG_SIZE_IN_BYTES = t),
            (this.logs = new u(this.MAX_LOG_SIZE_IN_BYTES));
        }
        forwardToConsole(e, t) {
          t === r.levels.values.error
            ? console.error(e)
            : t === r.levels.values.warn
              ? console.warn(e)
              : t === r.levels.values.debug
                ? console.debug(e)
                : t === r.levels.values.trace
                  ? console.trace(e)
                  : console.log(e);
        }
        appendToLogs(e) {
          this.logs.append((0, a.u)({ timestamp: new Date().toISOString(), log: e }));
          let t = 'string' == typeof e ? JSON.parse(e).level : e.level;
          t >= this.levelValue && this.forwardToConsole(e, t);
        }
        getLogs() {
          return this.logs;
        }
        clearLogs() {
          this.logs = new u(this.MAX_LOG_SIZE_IN_BYTES);
        }
        getLogArray() {
          return Array.from(this.logs);
        }
        logsToBlob(e) {
          let t = this.getLogArray();
          return t.push((0, a.u)({ extraMetadata: e })), new Blob(t, { type: 'application/json' });
        }
      }
      class d {
        constructor(e, t = 1024e3) {
          this.baseChunkLogger = new c(e, t);
        }
        write(e) {
          this.baseChunkLogger.appendToLogs(e);
        }
        getLogs() {
          return this.baseChunkLogger.getLogs();
        }
        clearLogs() {
          this.baseChunkLogger.clearLogs();
        }
        getLogArray() {
          return this.baseChunkLogger.getLogArray();
        }
        logsToBlob(e) {
          return this.baseChunkLogger.logsToBlob(e);
        }
        downloadLogsBlobInBrowser(e) {
          let t = URL.createObjectURL(this.logsToBlob(e)),
            n = document.createElement('a');
          (n.href = t),
            (n.download = `walletconnect-logs-${new Date().toISOString()}.txt`),
            document.body.appendChild(n),
            n.click(),
            document.body.removeChild(n),
            URL.revokeObjectURL(t);
        }
      }
      class p {
        constructor(e, t = 1024e3) {
          this.baseChunkLogger = new c(e, t);
        }
        write(e) {
          this.baseChunkLogger.appendToLogs(e);
        }
        getLogs() {
          return this.baseChunkLogger.getLogs();
        }
        clearLogs() {
          this.baseChunkLogger.clearLogs();
        }
        getLogArray() {
          return this.baseChunkLogger.getLogArray();
        }
        logsToBlob(e) {
          return this.baseChunkLogger.logsToBlob(e);
        }
      }
      var h = Object.defineProperty,
        y = Object.defineProperties,
        f = Object.getOwnPropertyDescriptors,
        m = Object.getOwnPropertySymbols,
        g = Object.prototype.hasOwnProperty,
        b = Object.prototype.propertyIsEnumerable,
        w = (e, t, n) =>
          t in e
            ? h(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        v = (e, t) => {
          for (var n in t || (t = {})) g.call(t, n) && w(e, n, t[n]);
          if (m) for (var n of m(t)) b.call(t, n) && w(e, n, t[n]);
          return e;
        },
        T = (e, t) => y(e, f(t));
      function A(e) {
        return T(v({}, e), { level: e?.level || s.level });
      }
      function E(e, t = o) {
        return typeof e.bindings > 'u'
          ? (function (e, t = o) {
              return e[t] || '';
            })(e, t)
          : e.bindings().context || '';
      }
      function C(e, t, n = o) {
        let r = (function (e, t, n = o) {
          let r = E(e, n);
          return r.trim() ? `${r}/${t}` : t;
        })(e, t, n);
        return (function (e, t, n = o) {
          return (e[n] = t), e;
        })(e.child({ context: r }), r, n);
      }
      function _(e) {
        return 'u' > typeof e.loggerOverride && 'string' != typeof e.loggerOverride
          ? { logger: e.loggerOverride, chunkLoggerController: null }
          : 'u' > typeof window
            ? (function (e) {
                var t, n;
                let r = new d(null == (t = e.opts) ? void 0 : t.level, e.maxSizeInBytes);
                return {
                  logger: i()(
                    T(v({}, e.opts), {
                      level: 'trace',
                      browser: T(v({}, null == (n = e.opts) ? void 0 : n.browser), {
                        write: (e) => r.write(e),
                      }),
                    })
                  ),
                  chunkLoggerController: r,
                };
              })(e)
            : (function (e) {
                var t;
                let n = new p(null == (t = e.opts) ? void 0 : t.level, e.maxSizeInBytes);
                return {
                  logger: i()(T(v({}, e.opts), { level: 'trace' }), n),
                  chunkLoggerController: n,
                };
              })(e);
      }
    },
    83729: function (e, t, n) {
      'use strict';
      n.d(t, {
        D: function () {
          return a;
        },
        u: function () {
          return s;
        },
      });
      let r = (e) => JSON.stringify(e, (e, t) => ('bigint' == typeof t ? t.toString() + 'n' : t)),
        i = (e) =>
          JSON.parse(
            e.replace(
              /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g,
              '$1"$2n"$3'
            ),
            (e, t) =>
              'string' == typeof t && t.match(/^\d+n$/) ? BigInt(t.substring(0, t.length - 1)) : t
          );
      function a(e) {
        if ('string' != typeof e) throw Error(`Cannot safe json parse value of type ${typeof e}`);
        try {
          return i(e);
        } catch (t) {
          return e;
        }
      }
      function s(e) {
        return 'string' == typeof e ? e : r(e) || '';
      }
    },
    1106: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 });
      let r = n(37412);
      r.__exportStar(n(36809), t), r.__exportStar(n(57733), t);
    },
    36809: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.ONE_THOUSAND = t.ONE_HUNDRED = void 0),
        (t.ONE_HUNDRED = 100),
        (t.ONE_THOUSAND = 1e3);
    },
    57733: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.ONE_YEAR =
          t.FOUR_WEEKS =
          t.THREE_WEEKS =
          t.TWO_WEEKS =
          t.ONE_WEEK =
          t.THIRTY_DAYS =
          t.SEVEN_DAYS =
          t.FIVE_DAYS =
          t.THREE_DAYS =
          t.ONE_DAY =
          t.TWENTY_FOUR_HOURS =
          t.TWELVE_HOURS =
          t.SIX_HOURS =
          t.THREE_HOURS =
          t.ONE_HOUR =
          t.SIXTY_MINUTES =
          t.THIRTY_MINUTES =
          t.TEN_MINUTES =
          t.FIVE_MINUTES =
          t.ONE_MINUTE =
          t.SIXTY_SECONDS =
          t.THIRTY_SECONDS =
          t.TEN_SECONDS =
          t.FIVE_SECONDS =
          t.ONE_SECOND =
            void 0),
        (t.ONE_SECOND = 1),
        (t.FIVE_SECONDS = 5),
        (t.TEN_SECONDS = 10),
        (t.THIRTY_SECONDS = 30),
        (t.SIXTY_SECONDS = 60),
        (t.ONE_MINUTE = t.SIXTY_SECONDS),
        (t.FIVE_MINUTES = 5 * t.ONE_MINUTE),
        (t.TEN_MINUTES = 10 * t.ONE_MINUTE),
        (t.THIRTY_MINUTES = 30 * t.ONE_MINUTE),
        (t.SIXTY_MINUTES = 60 * t.ONE_MINUTE),
        (t.ONE_HOUR = t.SIXTY_MINUTES),
        (t.THREE_HOURS = 3 * t.ONE_HOUR),
        (t.SIX_HOURS = 6 * t.ONE_HOUR),
        (t.TWELVE_HOURS = 12 * t.ONE_HOUR),
        (t.TWENTY_FOUR_HOURS = 24 * t.ONE_HOUR),
        (t.ONE_DAY = t.TWENTY_FOUR_HOURS),
        (t.THREE_DAYS = 3 * t.ONE_DAY),
        (t.FIVE_DAYS = 5 * t.ONE_DAY),
        (t.SEVEN_DAYS = 7 * t.ONE_DAY),
        (t.THIRTY_DAYS = 30 * t.ONE_DAY),
        (t.ONE_WEEK = t.SEVEN_DAYS),
        (t.TWO_WEEKS = 2 * t.ONE_WEEK),
        (t.THREE_WEEKS = 3 * t.ONE_WEEK),
        (t.FOUR_WEEKS = 4 * t.ONE_WEEK),
        (t.ONE_YEAR = 365 * t.ONE_DAY);
    },
    91568: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 });
      let r = n(37412);
      r.__exportStar(n(60323), t),
        r.__exportStar(n(75387), t),
        r.__exportStar(n(8654), t),
        r.__exportStar(n(1106), t);
    },
    8654: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }), n(37412).__exportStar(n(92054), t);
    },
    92054: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }), (t.IWatch = void 0);
      class n {}
      t.IWatch = n;
    },
    99298: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.fromMiliseconds = t.toMiliseconds = void 0);
      let r = n(1106);
      (t.toMiliseconds = function (e) {
        return e * r.ONE_THOUSAND;
      }),
        (t.fromMiliseconds = function (e) {
          return Math.floor(e / r.ONE_THOUSAND);
        });
    },
    69148: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.delay = void 0),
        (t.delay = function (e) {
          return new Promise((t) => {
            setTimeout(() => {
              t(!0);
            }, e);
          });
        });
    },
    60323: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 });
      let r = n(37412);
      r.__exportStar(n(69148), t), r.__exportStar(n(99298), t);
    },
    75387: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }), (t.Watch = void 0);
      class n {
        constructor() {
          this.timestamps = new Map();
        }
        start(e) {
          if (this.timestamps.has(e)) throw Error(`Watch already started for label: ${e}`);
          this.timestamps.set(e, { started: Date.now() });
        }
        stop(e) {
          let t = this.get(e);
          if (void 0 !== t.elapsed) throw Error(`Watch already stopped for label: ${e}`);
          let n = Date.now() - t.started;
          this.timestamps.set(e, { started: t.started, elapsed: n });
        }
        get(e) {
          let t = this.timestamps.get(e);
          if (void 0 === t) throw Error(`No timestamp found for label: ${e}`);
          return t;
        }
        elapsed(e) {
          let t = this.get(e);
          return t.elapsed || Date.now() - t.started;
        }
      }
      (t.Watch = n), (t.default = n);
    },
    26651: function (e, t, n) {
      'use strict';
      let r;
      n.d(t, {
        Z: function () {
          return yW;
        },
      });
      var i = {};
      n.r(i),
        n.d(i, {
          identity: function () {
            return rZ;
          },
        });
      var a = {};
      n.r(a),
        n.d(a, {
          base2: function () {
            return rJ;
          },
        });
      var s = {};
      n.r(s),
        n.d(s, {
          base8: function () {
            return rX;
          },
        });
      var o = {};
      n.r(o),
        n.d(o, {
          base10: function () {
            return r0;
          },
        });
      var l = {};
      n.r(l),
        n.d(l, {
          base16: function () {
            return r1;
          },
          base16upper: function () {
            return r2;
          },
        });
      var u = {};
      n.r(u),
        n.d(u, {
          base32: function () {
            return r6;
          },
          base32hex: function () {
            return r4;
          },
          base32hexpad: function () {
            return r7;
          },
          base32hexpadupper: function () {
            return ie;
          },
          base32hexupper: function () {
            return r9;
          },
          base32pad: function () {
            return r8;
          },
          base32padupper: function () {
            return r3;
          },
          base32upper: function () {
            return r5;
          },
          base32z: function () {
            return it;
          },
        });
      var c = {};
      n.r(c),
        n.d(c, {
          base36: function () {
            return ir;
          },
          base36upper: function () {
            return ii;
          },
        });
      var d = {};
      n.r(d),
        n.d(d, {
          base58btc: function () {
            return ia;
          },
          base58flickr: function () {
            return is;
          },
        });
      var p = {};
      n.r(p),
        n.d(p, {
          base64: function () {
            return io;
          },
          base64pad: function () {
            return il;
          },
          base64url: function () {
            return iu;
          },
          base64urlpad: function () {
            return ic;
          },
        });
      var h = {};
      n.r(h),
        n.d(h, {
          base256emoji: function () {
            return iy;
          },
        });
      var y = {};
      n.r(y),
        n.d(y, {
          sha256: function () {
            return iP;
          },
          sha512: function () {
            return iO;
          },
        });
      var f = {};
      n.r(f),
        n.d(f, {
          identity: function () {
            return iN;
          },
        });
      var m = {};
      n.r(m),
        n.d(m, {
          code: function () {
            return iM;
          },
          decode: function () {
            return iR;
          },
          encode: function () {
            return ik;
          },
          name: function () {
            return ix;
          },
        });
      var g = {};
      n.r(g),
        n.d(g, {
          code: function () {
            return iL;
          },
          decode: function () {
            return ij;
          },
          encode: function () {
            return iF;
          },
          name: function () {
            return iU;
          },
        });
      var b = n(89354),
        w = n.n(b),
        v = n(91568);
      class T {}
      class A extends T {
        constructor(e) {
          super();
        }
      }
      let E = v.FIVE_SECONDS,
        C = 'heartbeat_pulse';
      class _ extends A {
        constructor(e) {
          super(e),
            (this.events = new b.EventEmitter()),
            (this.interval = E),
            (this.interval = e?.interval || E);
        }
        static async init(e) {
          let t = new _(e);
          return await t.init(), t;
        }
        async init() {
          await this.initialize();
        }
        stop() {
          clearInterval(this.intervalRef);
        }
        on(e, t) {
          this.events.on(e, t);
        }
        once(e, t) {
          this.events.once(e, t);
        }
        off(e, t) {
          this.events.off(e, t);
        }
        removeListener(e, t) {
          this.events.removeListener(e, t);
        }
        async initialize() {
          this.intervalRef = setInterval(() => this.pulse(), (0, v.toMiliseconds)(this.interval));
        }
        pulse() {
          this.events.emit(C);
        }
      }
      let I =
          /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/,
        S =
          /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/,
        P = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
      function O(e, t) {
        if (
          '__proto__' === e ||
          ('constructor' === e && t && 'object' == typeof t && 'prototype' in t)
        ) {
          console.warn(`[destr] Dropping "${e}" key to prevent prototype pollution.`);
          return;
        }
        return t;
      }
      function N(e, t = {}) {
        if ('string' != typeof e) return e;
        if ('"' === e[0] && '"' === e[e.length - 1] && -1 === e.indexOf('\\'))
          return e.slice(1, -1);
        let n = e.trim();
        if (n.length <= 9)
          switch (n.toLowerCase()) {
            case 'true':
              return !0;
            case 'false':
              return !1;
            case 'undefined':
              return;
            case 'null':
              return null;
            case 'nan':
              return Number.NaN;
            case 'infinity':
              return Number.POSITIVE_INFINITY;
            case '-infinity':
              return Number.NEGATIVE_INFINITY;
          }
        if (!P.test(e)) {
          if (t.strict) throw SyntaxError('[destr] Invalid JSON');
          return e;
        }
        try {
          if (I.test(e) || S.test(e)) {
            if (t.strict) throw Error('[destr] Possible prototype pollution');
            return JSON.parse(e, O);
          }
          return JSON.parse(e);
        } catch (n) {
          if (t.strict) throw n;
          return e;
        }
      }
      var x = n(87150).Buffer;
      function M(e, ...t) {
        try {
          var n;
          return (n = e(...t)) && 'function' == typeof n.then ? n : Promise.resolve(n);
        } catch (e) {
          return Promise.reject(e);
        }
      }
      function k(e) {
        if (
          (function (e) {
            let t = typeof e;
            return null === e || ('object' !== t && 'function' !== t);
          })(e)
        )
          return String(e);
        if (
          (function (e) {
            let t = Object.getPrototypeOf(e);
            return !t || t.isPrototypeOf(Object);
          })(e) ||
          Array.isArray(e)
        )
          return JSON.stringify(e);
        if ('function' == typeof e.toJSON) return k(e.toJSON());
        throw Error('[unstorage] Cannot stringify value!');
      }
      let R = 'base64:';
      function D(e) {
        return (
          (e &&
            e.split('?')[0]?.replace(/[/\\]/g, ':').replace(/:+/g, ':').replace(/^:|:$/g, '')) ||
          ''
        );
      }
      function B(e) {
        return (e = D(e)) ? e + ':' : '';
      }
      let U = () => {
        let e = new Map();
        return {
          name: 'memory',
          getInstance: () => e,
          hasItem: (t) => e.has(t),
          getItem: (t) => e.get(t) ?? null,
          getItemRaw: (t) => e.get(t) ?? null,
          setItem(t, n) {
            e.set(t, n);
          },
          setItemRaw(t, n) {
            e.set(t, n);
          },
          removeItem(t) {
            e.delete(t);
          },
          getKeys: () => [...e.keys()],
          clear() {
            e.clear();
          },
          dispose() {
            e.clear();
          },
        };
      };
      function L(e, t, n) {
        return e.watch ? e.watch((e, r) => t(e, n + r)) : () => {};
      }
      async function F(e) {
        'function' == typeof e.dispose && (await M(e.dispose));
      }
      function j(e) {
        return new Promise((t, n) => {
          (e.oncomplete = e.onsuccess = () => t(e.result)),
            (e.onabort = e.onerror = () => n(e.error));
        });
      }
      function q(e, t) {
        let n = indexedDB.open(e);
        n.onupgradeneeded = () => n.result.createObjectStore(t);
        let r = j(n);
        return (e, n) => r.then((r) => n(r.transaction(t, e).objectStore(t)));
      }
      function V() {
        return r || (r = q('keyval-store', 'keyval')), r;
      }
      function $(e, t = V()) {
        return t('readonly', (t) => j(t.get(e)));
      }
      var z = n(83729),
        W = (e = {}) => {
          let t;
          let n = e.base && e.base.length > 0 ? `${e.base}:` : '',
            r = (e) => n + e;
          return (
            e.dbName && e.storeName && (t = q(e.dbName, e.storeName)),
            {
              name: 'idb-keyval',
              options: e,
              hasItem: async (e) => !(typeof (await $(r(e), t)) > 'u'),
              getItem: async (e) => (await $(r(e), t)) ?? null,
              setItem: (e, n) =>
                (function (e, t, n = V()) {
                  return n('readwrite', (n) => (n.put(t, e), j(n.transaction)));
                })(r(e), n, t),
              removeItem: (e) =>
                (function (e, t = V()) {
                  return t('readwrite', (t) => (t.delete(e), j(t.transaction)));
                })(r(e), t),
              getKeys: () =>
                (function (e = V()) {
                  return e('readonly', (e) => {
                    var t;
                    if (e.getAllKeys) return j(e.getAllKeys());
                    let n = [];
                    return ((t = (e) => n.push(e.key)),
                    (e.openCursor().onsuccess = function () {
                      this.result && (t(this.result), this.result.continue());
                    }),
                    j(e.transaction)).then(() => n);
                  });
                })(t),
              clear: () =>
                (function (e = V()) {
                  return e('readwrite', (e) => (e.clear(), j(e.transaction)));
                })(t),
            }
          );
        };
      class H {
        constructor() {
          this.indexedDb = (function (e = {}) {
            let t = {
                mounts: { '': e.driver || U() },
                mountpoints: [''],
                watching: !1,
                watchListeners: [],
                unwatch: {},
              },
              n = (e) => {
                for (let n of t.mountpoints)
                  if (e.startsWith(n))
                    return { base: n, relativeKey: e.slice(n.length), driver: t.mounts[n] };
                return { base: '', relativeKey: e, driver: t.mounts[''] };
              },
              r = (e, n) =>
                t.mountpoints
                  .filter((t) => t.startsWith(e) || (n && e.startsWith(t)))
                  .map((n) => ({
                    relativeBase: e.length > n.length ? e.slice(n.length) : void 0,
                    mountpoint: n,
                    driver: t.mounts[n],
                  })),
              i = (e, n) => {
                if (t.watching) for (let r of ((n = D(n)), t.watchListeners)) r(e, n);
              },
              a = async () => {
                if (!t.watching)
                  for (let e in ((t.watching = !0), t.mounts))
                    t.unwatch[e] = await L(t.mounts[e], i, e);
              },
              s = async () => {
                if (t.watching) {
                  for (let e in t.unwatch) await t.unwatch[e]();
                  (t.unwatch = {}), (t.watching = !1);
                }
              },
              o = (e, t, r) => {
                let i = new Map(),
                  a = (e) => {
                    let t = i.get(e.base);
                    return (
                      t || ((t = { driver: e.driver, base: e.base, items: [] }), i.set(e.base, t)),
                      t
                    );
                  };
                for (let r of e) {
                  let e = 'string' == typeof r,
                    i = D(e ? r : r.key),
                    s = e ? void 0 : r.value,
                    o = e || !r.options ? t : { ...t, ...r.options },
                    l = n(i);
                  a(l).items.push({ key: i, value: s, relativeKey: l.relativeKey, options: o });
                }
                return Promise.all([...i.values()].map((e) => r(e))).then((e) => e.flat());
              },
              l = {
                hasItem(e, t = {}) {
                  let { relativeKey: r, driver: i } = n((e = D(e)));
                  return M(i.hasItem, r, t);
                },
                getItem(e, t = {}) {
                  let { relativeKey: r, driver: i } = n((e = D(e)));
                  return M(i.getItem, r, t).then((e) => N(e));
                },
                getItems: (e, t = {}) =>
                  o(e, t, (e) =>
                    e.driver.getItems
                      ? M(
                          e.driver.getItems,
                          e.items.map((e) => ({ key: e.relativeKey, options: e.options })),
                          t
                        ).then((t) =>
                          t.map((t) => ({
                            key: (function (...e) {
                              return D(e.join(':'));
                            })(e.base, t.key),
                            value: N(t.value),
                          }))
                        )
                      : Promise.all(
                          e.items.map((t) =>
                            M(e.driver.getItem, t.relativeKey, t.options).then((e) => ({
                              key: t.key,
                              value: N(e),
                            }))
                          )
                        )
                  ),
                getItemRaw(e, t = {}) {
                  let { relativeKey: r, driver: i } = n((e = D(e)));
                  return i.getItemRaw
                    ? M(i.getItemRaw, r, t)
                    : M(i.getItem, r, t).then((e) => {
                        var t;
                        return 'string' == typeof e && e.startsWith(R)
                          ? ((t = e.slice(R.length)),
                            globalThis.Buffer
                              ? x.from(t, 'base64')
                              : Uint8Array.from(globalThis.atob(t), (e) => e.codePointAt(0)))
                          : e;
                      });
                },
                async setItem(e, t, r = {}) {
                  if (void 0 === t) return l.removeItem(e);
                  let { relativeKey: a, driver: s } = n((e = D(e)));
                  s.setItem && (await M(s.setItem, a, k(t), r), s.watch || i('update', e));
                },
                async setItems(e, t) {
                  await o(e, t, async (e) => {
                    if (e.driver.setItems)
                      return M(
                        e.driver.setItems,
                        e.items.map((e) => ({
                          key: e.relativeKey,
                          value: k(e.value),
                          options: e.options,
                        })),
                        t
                      );
                    e.driver.setItem &&
                      (await Promise.all(
                        e.items.map((t) =>
                          M(e.driver.setItem, t.relativeKey, k(t.value), t.options)
                        )
                      ));
                  });
                },
                async setItemRaw(e, t, r = {}) {
                  if (void 0 === t) return l.removeItem(e, r);
                  let { relativeKey: a, driver: s } = n((e = D(e)));
                  if (s.setItemRaw) await M(s.setItemRaw, a, t, r);
                  else {
                    if (!s.setItem) return;
                    await M(
                      s.setItem,
                      a,
                      'string' == typeof t
                        ? t
                        : R +
                            (globalThis.Buffer
                              ? x.from(t).toString('base64')
                              : globalThis.btoa(String.fromCodePoint(...t))),
                      r
                    );
                  }
                  s.watch || i('update', e);
                },
                async removeItem(e, t = {}) {
                  'boolean' == typeof t && (t = { removeMeta: t });
                  let { relativeKey: r, driver: a } = n((e = D(e)));
                  a.removeItem &&
                    (await M(a.removeItem, r, t),
                    (t.removeMeta || t.removeMata) && (await M(a.removeItem, r + '$', t)),
                    a.watch || i('remove', e));
                },
                async getMeta(e, t = {}) {
                  'boolean' == typeof t && (t = { nativeOnly: t });
                  let { relativeKey: r, driver: i } = n((e = D(e))),
                    a = Object.create(null);
                  if ((i.getMeta && Object.assign(a, await M(i.getMeta, r, t)), !t.nativeOnly)) {
                    let e = await M(i.getItem, r + '$', t).then((e) => N(e));
                    e &&
                      'object' == typeof e &&
                      ('string' == typeof e.atime && (e.atime = new Date(e.atime)),
                      'string' == typeof e.mtime && (e.mtime = new Date(e.mtime)),
                      Object.assign(a, e));
                  }
                  return a;
                },
                setMeta(e, t, n = {}) {
                  return this.setItem(e + '$', t, n);
                },
                removeMeta(e, t = {}) {
                  return this.removeItem(e + '$', t);
                },
                async getKeys(e, t = {}) {
                  let n = r((e = B(e)), !0),
                    i = [],
                    a = [],
                    s = !0;
                  for (let e of n) {
                    for (let n of (e.driver.flags?.maxDepth || (s = !1),
                    await M(e.driver.getKeys, e.relativeBase, t))) {
                      let t = e.mountpoint + D(n);
                      i.some((e) => t.startsWith(e)) || a.push(t);
                    }
                    i = [e.mountpoint, ...i.filter((t) => !t.startsWith(e.mountpoint))];
                  }
                  let o = void 0 !== t.maxDepth && !s;
                  return a.filter((n) => {
                    var r;
                    return (
                      (!o ||
                        (function (e, t) {
                          if (void 0 === t) return !0;
                          let n = 0,
                            r = e.indexOf(':');
                          for (; r > -1; ) n++, (r = e.indexOf(':', r + 1));
                          return n <= t;
                        })(n, t.maxDepth)) &&
                      ((r = e)
                        ? n.startsWith(r) && '$' !== n[n.length - 1]
                        : '$' !== n[n.length - 1])
                    );
                  });
                },
                async clear(e, t = {}) {
                  (e = B(e)),
                    await Promise.all(
                      r(e, !1).map(async (e) =>
                        e.driver.clear
                          ? M(e.driver.clear, e.relativeBase, t)
                          : e.driver.removeItem
                            ? Promise.all(
                                (await e.driver.getKeys(e.relativeBase || '', t)).map((n) =>
                                  e.driver.removeItem(n, t)
                                )
                              )
                            : void 0
                      )
                    );
                },
                async dispose() {
                  await Promise.all(Object.values(t.mounts).map((e) => F(e)));
                },
                watch: async (e) => (
                  await a(),
                  t.watchListeners.push(e),
                  async () => {
                    (t.watchListeners = t.watchListeners.filter((t) => t !== e)),
                      0 === t.watchListeners.length && (await s());
                  }
                ),
                async unwatch() {
                  (t.watchListeners = []), await s();
                },
                mount(e, n) {
                  if ((e = B(e)) && t.mounts[e]) throw Error(`already mounted at ${e}`);
                  return (
                    e && (t.mountpoints.push(e), t.mountpoints.sort((e, t) => t.length - e.length)),
                    (t.mounts[e] = n),
                    t.watching &&
                      Promise.resolve(L(n, i, e))
                        .then((n) => {
                          t.unwatch[e] = n;
                        })
                        .catch(console.error),
                    l
                  );
                },
                async unmount(e, n = !0) {
                  (e = B(e)) &&
                    t.mounts[e] &&
                    (t.watching && e in t.unwatch && (t.unwatch[e]?.(), delete t.unwatch[e]),
                    n && (await F(t.mounts[e])),
                    (t.mountpoints = t.mountpoints.filter((t) => t !== e)),
                    delete t.mounts[e]);
                },
                getMount(e = '') {
                  let t = n((e = D(e) + ':'));
                  return { driver: t.driver, base: t.base };
                },
                getMounts: (e = '', t = {}) =>
                  r((e = D(e)), t.parents).map((e) => ({ driver: e.driver, base: e.mountpoint })),
                keys: (e, t = {}) => l.getKeys(e, t),
                get: (e, t = {}) => l.getItem(e, t),
                set: (e, t, n = {}) => l.setItem(e, t, n),
                has: (e, t = {}) => l.hasItem(e, t),
                del: (e, t = {}) => l.removeItem(e, t),
                remove: (e, t = {}) => l.removeItem(e, t),
              };
            return l;
          })({
            driver: W({ dbName: 'WALLET_CONNECT_V2_INDEXED_DB', storeName: 'keyvaluestorage' }),
          });
        }
        async getKeys() {
          return this.indexedDb.getKeys();
        }
        async getEntries() {
          return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((e) => [
            e.key,
            e.value,
          ]);
        }
        async getItem(e) {
          let t = await this.indexedDb.getItem(e);
          if (null !== t) return t;
        }
        async setItem(e, t) {
          await this.indexedDb.setItem(e, (0, z.u)(t));
        }
        async removeItem(e) {
          await this.indexedDb.removeItem(e);
        }
      }
      var G =
          'u' > typeof globalThis
            ? globalThis
            : 'u' > typeof window
              ? window
              : 'u' > typeof n.g
                ? n.g
                : 'u' > typeof self
                  ? self
                  : {},
        K = { exports: {} };
      function Q(e) {
        var t;
        return [e[0], (0, z.D)(null != (t = e[1]) ? t : '')];
      }
      !(function () {
        function e() {}
        (e.prototype.getItem = function (e) {
          return this.hasOwnProperty(e) ? String(this[e]) : null;
        }),
          (e.prototype.setItem = function (e, t) {
            this[e] = String(t);
          }),
          (e.prototype.removeItem = function (e) {
            delete this[e];
          }),
          (e.prototype.clear = function () {
            let e = this;
            Object.keys(e).forEach(function (t) {
              (e[t] = void 0), delete e[t];
            });
          }),
          (e.prototype.key = function (e) {
            return (e = e || 0), Object.keys(this)[e];
          }),
          e.prototype.__defineGetter__('length', function () {
            return Object.keys(this).length;
          }),
          'u' > typeof G && G.localStorage
            ? (K.exports = G.localStorage)
            : 'u' > typeof window && window.localStorage
              ? (K.exports = window.localStorage)
              : (K.exports = new e());
      })();
      class Y {
        constructor() {
          this.localStorage = K.exports;
        }
        async getKeys() {
          return Object.keys(this.localStorage);
        }
        async getEntries() {
          return Object.entries(this.localStorage).map(Q);
        }
        async getItem(e) {
          let t = this.localStorage.getItem(e);
          if (null !== t) return (0, z.D)(t);
        }
        async setItem(e, t) {
          this.localStorage.setItem(e, (0, z.u)(t));
        }
        async removeItem(e) {
          this.localStorage.removeItem(e);
        }
      }
      let Z = async (e, t, n) => {
          let r = 'wc_storage_version',
            i = await t.getItem(r);
          if (i && i >= 1) {
            n(t);
            return;
          }
          let a = await e.getKeys();
          if (!a.length) {
            n(t);
            return;
          }
          let s = [];
          for (; a.length; ) {
            let n = a.shift();
            if (!n) continue;
            let r = n.toLowerCase();
            if (
              r.includes('wc@') ||
              r.includes('walletconnect') ||
              r.includes('wc_') ||
              r.includes('wallet_connect')
            ) {
              let r = await e.getItem(n);
              await t.setItem(n, r), s.push(n);
            }
          }
          await t.setItem(r, 1), n(t), J(e, s);
        },
        J = async (e, t) => {
          t.length &&
            t.forEach(async (t) => {
              await e.removeItem(t);
            });
        };
      class X {
        constructor() {
          (this.initialized = !1),
            (this.setInitialized = (e) => {
              (this.storage = e), (this.initialized = !0);
            });
          let e = new Y();
          this.storage = e;
          try {
            let t = new H();
            Z(e, t, this.setInitialized);
          } catch {
            this.initialized = !0;
          }
        }
        async getKeys() {
          return await this.initialize(), this.storage.getKeys();
        }
        async getEntries() {
          return await this.initialize(), this.storage.getEntries();
        }
        async getItem(e) {
          return await this.initialize(), this.storage.getItem(e);
        }
        async setItem(e, t) {
          return await this.initialize(), this.storage.setItem(e, t);
        }
        async removeItem(e) {
          return await this.initialize(), this.storage.removeItem(e);
        }
        async initialize() {
          this.initialized ||
            (await new Promise((e) => {
              let t = setInterval(() => {
                this.initialized && (clearInterval(t), e());
              }, 20);
            }));
        }
      }
      var ee = n(1030),
        et = Object.defineProperty,
        en = (e, t, n) =>
          t in e
            ? et(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        er = (e, t, n) => en(e, 'symbol' != typeof t ? t + '' : t, n);
      class ei extends T {
        constructor(e) {
          super(), (this.opts = e), er(this, 'protocol', 'wc'), er(this, 'version', 2);
        }
      }
      var ea = Object.defineProperty,
        es = (e, t, n) =>
          t in e
            ? ea(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        eo = (e, t, n) => es(e, 'symbol' != typeof t ? t + '' : t, n);
      class el extends T {
        constructor(e, t) {
          super(), (this.core = e), (this.logger = t), eo(this, 'records', new Map());
        }
      }
      class eu {
        constructor(e, t) {
          (this.logger = e), (this.core = t);
        }
      }
      class ec extends T {
        constructor(e, t) {
          super(), (this.relayer = e), (this.logger = t);
        }
      }
      class ed extends T {
        constructor(e) {
          super();
        }
      }
      class ep {
        constructor(e, t, n, r) {
          (this.core = e), (this.logger = t), (this.name = n);
        }
      }
      class eh extends T {
        constructor(e, t) {
          super(), (this.relayer = e), (this.logger = t);
        }
      }
      class ey extends T {
        constructor(e, t) {
          super(), (this.core = e), (this.logger = t);
        }
      }
      class ef {
        constructor(e, t, n) {
          (this.core = e), (this.logger = t), (this.store = n);
        }
      }
      class em {
        constructor(e, t) {
          (this.projectId = e), (this.logger = t);
        }
      }
      class eg {
        constructor(e, t, n) {
          (this.core = e), (this.logger = t), (this.telemetryEnabled = n);
        }
      }
      var eb = Object.defineProperty,
        ew = (e, t, n) =>
          t in e
            ? eb(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        ev = (e, t, n) => ew(e, 'symbol' != typeof t ? t + '' : t, n);
      class eT {
        constructor(e) {
          (this.opts = e), ev(this, 'protocol', 'wc'), ev(this, 'version', 2);
        }
      }
      class eA {
        constructor(e) {
          this.client = e;
        }
      }
      function eE(e, ...t) {
        if (
          !(
            e instanceof Uint8Array ||
            (ArrayBuffer.isView(e) && 'Uint8Array' === e.constructor.name)
          )
        )
          throw Error('Uint8Array expected');
        if (t.length > 0 && !t.includes(e.length))
          throw Error('Uint8Array expected of length ' + t + ', got length=' + e.length);
      }
      function eC(e, t = !0) {
        if (e.destroyed) throw Error('Hash instance has been destroyed');
        if (t && e.finished) throw Error('Hash#digest() has already been called');
      }
      let e_ = 'object' == typeof globalThis && 'crypto' in globalThis ? globalThis.crypto : void 0,
        eI = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength);
      function eS(e) {
        return (
          'string' == typeof e &&
            (e = (function (e) {
              if ('string' != typeof e) throw Error('utf8ToBytes expected string, got ' + typeof e);
              return new Uint8Array(new TextEncoder().encode(e));
            })(e)),
          eE(e),
          e
        );
      }
      class eP {
        clone() {
          return this._cloneInto();
        }
      }
      function eO(e = 32) {
        if (e_ && 'function' == typeof e_.getRandomValues)
          return e_.getRandomValues(new Uint8Array(e));
        if (e_ && 'function' == typeof e_.randomBytes) return e_.randomBytes(e);
        throw Error('crypto.getRandomValues must be defined');
      }
      class eN extends eP {
        constructor(e, t, n, r) {
          super(),
            (this.blockLen = e),
            (this.outputLen = t),
            (this.padOffset = n),
            (this.isLE = r),
            (this.finished = !1),
            (this.length = 0),
            (this.pos = 0),
            (this.destroyed = !1),
            (this.buffer = new Uint8Array(e)),
            (this.view = eI(this.buffer));
        }
        update(e) {
          eC(this);
          let { view: t, buffer: n, blockLen: r } = this,
            i = (e = eS(e)).length;
          for (let a = 0; a < i; ) {
            let s = Math.min(r - this.pos, i - a);
            if (s === r) {
              let t = eI(e);
              for (; r <= i - a; a += r) this.process(t, a);
              continue;
            }
            n.set(e.subarray(a, a + s), this.pos),
              (this.pos += s),
              (a += s),
              this.pos === r && (this.process(t, 0), (this.pos = 0));
          }
          return (this.length += e.length), this.roundClean(), this;
        }
        digestInto(e) {
          eC(this),
            (function (e, t) {
              eE(e);
              let n = t.outputLen;
              if (e.length < n)
                throw Error('digestInto() expects output buffer of length at least ' + n);
            })(e, this),
            (this.finished = !0);
          let { buffer: t, view: n, blockLen: r, isLE: i } = this,
            { pos: a } = this;
          (t[a++] = 128),
            this.buffer.subarray(a).fill(0),
            this.padOffset > r - a && (this.process(n, 0), (a = 0));
          for (let e = a; e < r; e++) t[e] = 0;
          (function (e, t, n, r) {
            if ('function' == typeof e.setBigUint64) return e.setBigUint64(t, n, r);
            let i = BigInt(32),
              a = BigInt(4294967295),
              s = Number((n >> i) & a),
              o = Number(n & a),
              l = r ? 4 : 0,
              u = r ? 0 : 4;
            e.setUint32(t + l, s, r), e.setUint32(t + u, o, r);
          })(n, r - 8, BigInt(8 * this.length), i),
            this.process(n, 0);
          let s = eI(e),
            o = this.outputLen;
          if (o % 4) throw Error('_sha2: outputLen should be aligned to 32bit');
          let l = o / 4,
            u = this.get();
          if (l > u.length) throw Error('_sha2: outputLen bigger than state');
          for (let e = 0; e < l; e++) s.setUint32(4 * e, u[e], i);
        }
        digest() {
          let { buffer: e, outputLen: t } = this;
          this.digestInto(e);
          let n = e.slice(0, t);
          return this.destroy(), n;
        }
        _cloneInto(e) {
          e || (e = new this.constructor()), e.set(...this.get());
          let { blockLen: t, buffer: n, length: r, finished: i, destroyed: a, pos: s } = this;
          return (
            (e.length = r),
            (e.pos = s),
            (e.finished = i),
            (e.destroyed = a),
            r % t && e.buffer.set(n),
            e
          );
        }
      }
      let ex = BigInt(4294967296 - 1),
        eM = BigInt(32),
        ek = {
          split: function (e, t = !1) {
            let n = new Uint32Array(e.length),
              r = new Uint32Array(e.length);
            for (let i = 0; i < e.length; i++) {
              let { h: a, l: s } = (function (e, t = !1) {
                return t
                  ? { h: Number(e & ex), l: Number((e >> eM) & ex) }
                  : { h: 0 | Number((e >> eM) & ex), l: 0 | Number(e & ex) };
              })(e[i], t);
              [n[i], r[i]] = [a, s];
            }
            return [n, r];
          },
          shrSH: (e, t, n) => e >>> n,
          shrSL: (e, t, n) => (e << (32 - n)) | (t >>> n),
          rotrSH: (e, t, n) => (e >>> n) | (t << (32 - n)),
          rotrSL: (e, t, n) => (e << (32 - n)) | (t >>> n),
          rotrBH: (e, t, n) => (e << (64 - n)) | (t >>> (n - 32)),
          rotrBL: (e, t, n) => (e >>> (n - 32)) | (t << (64 - n)),
          add: function (e, t, n, r) {
            let i = (t >>> 0) + (r >>> 0);
            return { h: (e + n + ((i / 4294967296) | 0)) | 0, l: 0 | i };
          },
          add3L: (e, t, n) => (e >>> 0) + (t >>> 0) + (n >>> 0),
          add3H: (e, t, n, r) => (t + n + r + ((e / 4294967296) | 0)) | 0,
          add4L: (e, t, n, r) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0),
          add4H: (e, t, n, r, i) => (t + n + r + i + ((e / 4294967296) | 0)) | 0,
          add5H: (e, t, n, r, i, a) => (t + n + r + i + a + ((e / 4294967296) | 0)) | 0,
          add5L: (e, t, n, r, i) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0) + (i >>> 0),
        },
        [eR, eD] = ek.split(
          [
            '0x428a2f98d728ae22',
            '0x7137449123ef65cd',
            '0xb5c0fbcfec4d3b2f',
            '0xe9b5dba58189dbbc',
            '0x3956c25bf348b538',
            '0x59f111f1b605d019',
            '0x923f82a4af194f9b',
            '0xab1c5ed5da6d8118',
            '0xd807aa98a3030242',
            '0x12835b0145706fbe',
            '0x243185be4ee4b28c',
            '0x550c7dc3d5ffb4e2',
            '0x72be5d74f27b896f',
            '0x80deb1fe3b1696b1',
            '0x9bdc06a725c71235',
            '0xc19bf174cf692694',
            '0xe49b69c19ef14ad2',
            '0xefbe4786384f25e3',
            '0x0fc19dc68b8cd5b5',
            '0x240ca1cc77ac9c65',
            '0x2de92c6f592b0275',
            '0x4a7484aa6ea6e483',
            '0x5cb0a9dcbd41fbd4',
            '0x76f988da831153b5',
            '0x983e5152ee66dfab',
            '0xa831c66d2db43210',
            '0xb00327c898fb213f',
            '0xbf597fc7beef0ee4',
            '0xc6e00bf33da88fc2',
            '0xd5a79147930aa725',
            '0x06ca6351e003826f',
            '0x142929670a0e6e70',
            '0x27b70a8546d22ffc',
            '0x2e1b21385c26c926',
            '0x4d2c6dfc5ac42aed',
            '0x53380d139d95b3df',
            '0x650a73548baf63de',
            '0x766a0abb3c77b2a8',
            '0x81c2c92e47edaee6',
            '0x92722c851482353b',
            '0xa2bfe8a14cf10364',
            '0xa81a664bbc423001',
            '0xc24b8b70d0f89791',
            '0xc76c51a30654be30',
            '0xd192e819d6ef5218',
            '0xd69906245565a910',
            '0xf40e35855771202a',
            '0x106aa07032bbd1b8',
            '0x19a4c116b8d2d0c8',
            '0x1e376c085141ab53',
            '0x2748774cdf8eeb99',
            '0x34b0bcb5e19b48a8',
            '0x391c0cb3c5c95a63',
            '0x4ed8aa4ae3418acb',
            '0x5b9cca4f7763e373',
            '0x682e6ff3d6b2b8a3',
            '0x748f82ee5defb2fc',
            '0x78a5636f43172f60',
            '0x84c87814a1f0ab72',
            '0x8cc702081a6439ec',
            '0x90befffa23631e28',
            '0xa4506cebde82bde9',
            '0xbef9a3f7b2c67915',
            '0xc67178f2e372532b',
            '0xca273eceea26619c',
            '0xd186b8c721c0c207',
            '0xeada7dd6cde0eb1e',
            '0xf57d4f7fee6ed178',
            '0x06f067aa72176fba',
            '0x0a637dc5a2c898a6',
            '0x113f9804bef90dae',
            '0x1b710b35131c471b',
            '0x28db77f523047d84',
            '0x32caab7b40c72493',
            '0x3c9ebe0a15c9bebc',
            '0x431d67c49c100d4c',
            '0x4cc5d4becb3e42b6',
            '0x597f299cfc657e2a',
            '0x5fcb6fab3ad6faec',
            '0x6c44198c4a475817',
          ].map((e) => BigInt(e))
        ),
        eB = new Uint32Array(80),
        eU = new Uint32Array(80);
      class eL extends eN {
        constructor() {
          super(128, 64, 16, !1),
            (this.Ah = 1779033703),
            (this.Al = -205731576),
            (this.Bh = -1150833019),
            (this.Bl = -2067093701),
            (this.Ch = 1013904242),
            (this.Cl = -23791573),
            (this.Dh = -1521486534),
            (this.Dl = 1595750129),
            (this.Eh = 1359893119),
            (this.El = -1377402159),
            (this.Fh = -1694144372),
            (this.Fl = 725511199),
            (this.Gh = 528734635),
            (this.Gl = -79577749),
            (this.Hh = 1541459225),
            (this.Hl = 327033209);
        }
        get() {
          let {
            Ah: e,
            Al: t,
            Bh: n,
            Bl: r,
            Ch: i,
            Cl: a,
            Dh: s,
            Dl: o,
            Eh: l,
            El: u,
            Fh: c,
            Fl: d,
            Gh: p,
            Gl: h,
            Hh: y,
            Hl: f,
          } = this;
          return [e, t, n, r, i, a, s, o, l, u, c, d, p, h, y, f];
        }
        set(e, t, n, r, i, a, s, o, l, u, c, d, p, h, y, f) {
          (this.Ah = 0 | e),
            (this.Al = 0 | t),
            (this.Bh = 0 | n),
            (this.Bl = 0 | r),
            (this.Ch = 0 | i),
            (this.Cl = 0 | a),
            (this.Dh = 0 | s),
            (this.Dl = 0 | o),
            (this.Eh = 0 | l),
            (this.El = 0 | u),
            (this.Fh = 0 | c),
            (this.Fl = 0 | d),
            (this.Gh = 0 | p),
            (this.Gl = 0 | h),
            (this.Hh = 0 | y),
            (this.Hl = 0 | f);
        }
        process(e, t) {
          for (let n = 0; n < 16; n++, t += 4)
            (eB[n] = e.getUint32(t)), (eU[n] = e.getUint32((t += 4)));
          for (let e = 16; e < 80; e++) {
            let t = 0 | eB[e - 15],
              n = 0 | eU[e - 15],
              r = ek.rotrSH(t, n, 1) ^ ek.rotrSH(t, n, 8) ^ ek.shrSH(t, n, 7),
              i = ek.rotrSL(t, n, 1) ^ ek.rotrSL(t, n, 8) ^ ek.shrSL(t, n, 7),
              a = 0 | eB[e - 2],
              s = 0 | eU[e - 2],
              o = ek.rotrSH(a, s, 19) ^ ek.rotrBH(a, s, 61) ^ ek.shrSH(a, s, 6),
              l = ek.rotrSL(a, s, 19) ^ ek.rotrBL(a, s, 61) ^ ek.shrSL(a, s, 6),
              u = ek.add4L(i, l, eU[e - 7], eU[e - 16]),
              c = ek.add4H(u, r, o, eB[e - 7], eB[e - 16]);
            (eB[e] = 0 | c), (eU[e] = 0 | u);
          }
          let {
            Ah: n,
            Al: r,
            Bh: i,
            Bl: a,
            Ch: s,
            Cl: o,
            Dh: l,
            Dl: u,
            Eh: c,
            El: d,
            Fh: p,
            Fl: h,
            Gh: y,
            Gl: f,
            Hh: m,
            Hl: g,
          } = this;
          for (let e = 0; e < 80; e++) {
            let t = ek.rotrSH(c, d, 14) ^ ek.rotrSH(c, d, 18) ^ ek.rotrBH(c, d, 41),
              b = ek.rotrSL(c, d, 14) ^ ek.rotrSL(c, d, 18) ^ ek.rotrBL(c, d, 41),
              w = (c & p) ^ (~c & y),
              v = (d & h) ^ (~d & f),
              T = ek.add5L(g, b, v, eD[e], eU[e]),
              A = ek.add5H(T, m, t, w, eR[e], eB[e]),
              E = 0 | T,
              C = ek.rotrSH(n, r, 28) ^ ek.rotrBH(n, r, 34) ^ ek.rotrBH(n, r, 39),
              _ = ek.rotrSL(n, r, 28) ^ ek.rotrBL(n, r, 34) ^ ek.rotrBL(n, r, 39),
              I = (n & i) ^ (n & s) ^ (i & s),
              S = (r & a) ^ (r & o) ^ (a & o);
            (m = 0 | y),
              (g = 0 | f),
              (y = 0 | p),
              (f = 0 | h),
              (p = 0 | c),
              (h = 0 | d),
              ({ h: c, l: d } = ek.add(0 | l, 0 | u, 0 | A, 0 | E)),
              (l = 0 | s),
              (u = 0 | o),
              (s = 0 | i),
              (o = 0 | a),
              (i = 0 | n),
              (a = 0 | r);
            let P = ek.add3L(E, _, S);
            (n = ek.add3H(P, A, C, I)), (r = 0 | P);
          }
          ({ h: n, l: r } = ek.add(0 | this.Ah, 0 | this.Al, 0 | n, 0 | r)),
            ({ h: i, l: a } = ek.add(0 | this.Bh, 0 | this.Bl, 0 | i, 0 | a)),
            ({ h: s, l: o } = ek.add(0 | this.Ch, 0 | this.Cl, 0 | s, 0 | o)),
            ({ h: l, l: u } = ek.add(0 | this.Dh, 0 | this.Dl, 0 | l, 0 | u)),
            ({ h: c, l: d } = ek.add(0 | this.Eh, 0 | this.El, 0 | c, 0 | d)),
            ({ h: p, l: h } = ek.add(0 | this.Fh, 0 | this.Fl, 0 | p, 0 | h)),
            ({ h: y, l: f } = ek.add(0 | this.Gh, 0 | this.Gl, 0 | y, 0 | f)),
            ({ h: m, l: g } = ek.add(0 | this.Hh, 0 | this.Hl, 0 | m, 0 | g)),
            this.set(n, r, i, a, s, o, l, u, c, d, p, h, y, f, m, g);
        }
        roundClean() {
          eB.fill(0), eU.fill(0);
        }
        destroy() {
          this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
      }
      let eF = (function (e) {
          let t = (t) => e().update(eS(t)).digest(),
            n = e();
          return (t.outputLen = n.outputLen), (t.blockLen = n.blockLen), (t.create = () => e()), t;
        })(() => new eL()),
        ej = BigInt(0),
        eq = BigInt(1),
        eV = BigInt(2);
      function e$(e) {
        return (
          e instanceof Uint8Array || (ArrayBuffer.isView(e) && 'Uint8Array' === e.constructor.name)
        );
      }
      function ez(e) {
        if (!e$(e)) throw Error('Uint8Array expected');
      }
      function eW(e, t) {
        if ('boolean' != typeof t) throw Error(e + ' boolean expected, got ' + t);
      }
      let eH = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, '0'));
      function eG(e) {
        ez(e);
        let t = '';
        for (let n = 0; n < e.length; n++) t += eH[e[n]];
        return t;
      }
      function eK(e) {
        if ('string' != typeof e) throw Error('hex string expected, got ' + typeof e);
        return '' === e ? ej : BigInt('0x' + e);
      }
      let eQ = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
      function eY(e) {
        return e >= eQ._0 && e <= eQ._9
          ? e - eQ._0
          : e >= eQ.A && e <= eQ.F
            ? e - (eQ.A - 10)
            : e >= eQ.a && e <= eQ.f
              ? e - (eQ.a - 10)
              : void 0;
      }
      function eZ(e) {
        if ('string' != typeof e) throw Error('hex string expected, got ' + typeof e);
        let t = e.length,
          n = t / 2;
        if (t % 2) throw Error('hex string expected, got unpadded hex of length ' + t);
        let r = new Uint8Array(n);
        for (let t = 0, i = 0; t < n; t++, i += 2) {
          let n = eY(e.charCodeAt(i)),
            a = eY(e.charCodeAt(i + 1));
          if (void 0 === n || void 0 === a)
            throw Error(
              'hex string expected, got non-hex character "' + (e[i] + e[i + 1]) + '" at index ' + i
            );
          r[t] = 16 * n + a;
        }
        return r;
      }
      function eJ(e) {
        return ez(e), eK(eG(Uint8Array.from(e).reverse()));
      }
      function eX(e, t) {
        return eZ(e.toString(16).padStart(2 * t, '0'));
      }
      function e0(e, t) {
        return eX(e, t).reverse();
      }
      function e1(e, t, n) {
        let r;
        if ('string' == typeof t)
          try {
            r = eZ(t);
          } catch (t) {
            throw Error(e + ' must be hex string or Uint8Array, cause: ' + t);
          }
        else if (e$(t)) r = Uint8Array.from(t);
        else throw Error(e + ' must be hex string or Uint8Array');
        let i = r.length;
        if ('number' == typeof n && i !== n)
          throw Error(e + ' of length ' + n + ' expected, got ' + i);
        return r;
      }
      function e2(...e) {
        let t = 0;
        for (let n = 0; n < e.length; n++) {
          let r = e[n];
          ez(r), (t += r.length);
        }
        let n = new Uint8Array(t);
        for (let t = 0, r = 0; t < e.length; t++) {
          let i = e[t];
          n.set(i, r), (r += i.length);
        }
        return n;
      }
      let e6 = (e) => 'bigint' == typeof e && ej <= e;
      function e5(e, t, n, r) {
        if (!(e6(t) && e6(n) && e6(r)) || !(n <= t) || !(t < r))
          throw Error('expected valid ' + e + ': ' + n + ' <= n < ' + r + ', got ' + t);
      }
      let e8 = (e) => (eV << BigInt(e - 1)) - eq,
        e3 = {
          bigint: (e) => 'bigint' == typeof e,
          function: (e) => 'function' == typeof e,
          boolean: (e) => 'boolean' == typeof e,
          string: (e) => 'string' == typeof e,
          stringOrUint8Array: (e) => 'string' == typeof e || e$(e),
          isSafeInteger: (e) => Number.isSafeInteger(e),
          array: (e) => Array.isArray(e),
          field: (e, t) => t.Fp.isValid(e),
          hash: (e) => 'function' == typeof e && Number.isSafeInteger(e.outputLen),
        };
      function e4(e, t, n = {}) {
        let r = (t, n, r) => {
          let i = e3[n];
          if ('function' != typeof i) throw Error('invalid validator function');
          let a = e[t];
          if (!(r && void 0 === a) && !i(a, e))
            throw Error('param ' + String(t) + ' is invalid. Expected ' + n + ', got ' + a);
        };
        for (let [e, n] of Object.entries(t)) r(e, n, !1);
        for (let [e, t] of Object.entries(n)) r(e, t, !0);
        return e;
      }
      function e9(e) {
        let t = new WeakMap();
        return (n, ...r) => {
          let i = t.get(n);
          if (void 0 !== i) return i;
          let a = e(n, ...r);
          return t.set(n, a), a;
        };
      }
      let e7 = BigInt(0),
        te = BigInt(1),
        tt = BigInt(2),
        tn = BigInt(3),
        tr = BigInt(4),
        ti = BigInt(5),
        ta = BigInt(8);
      function ts(e, t) {
        let n = e % t;
        return n >= e7 ? n : t + n;
      }
      function to(e, t, n) {
        let r = e;
        for (; t-- > e7; ) (r *= r), (r %= n);
        return r;
      }
      function tl(e, t) {
        if (e === e7) throw Error('invert: expected non-zero number');
        if (t <= e7) throw Error('invert: expected positive modulus, got ' + t);
        let n = ts(e, t),
          r = t,
          i = e7,
          a = te;
        for (; n !== e7; ) {
          let e = r / n,
            t = r % n,
            s = i - a * e;
          (r = n), (n = t), (i = a), (a = s);
        }
        if (r !== te) throw Error('invert: does not exist');
        return ts(i, t);
      }
      let tu = (e, t) => (ts(e, t) & te) === te,
        tc = [
          'create',
          'isValid',
          'is0',
          'neg',
          'inv',
          'sqrt',
          'sqr',
          'eql',
          'add',
          'sub',
          'mul',
          'pow',
          'div',
          'addN',
          'subN',
          'mulN',
          'sqrN',
        ];
      function td(e, t) {
        let n = void 0 !== t ? t : e.toString(2).length;
        return { nBitLength: n, nByteLength: Math.ceil(n / 8) };
      }
      function tp(e, t, n = !1, r = {}) {
        let i;
        if (e <= e7) throw Error('invalid field: expected ORDER > 0, got ' + e);
        let { nBitLength: a, nByteLength: s } = td(e, t);
        if (s > 2048) throw Error('invalid field: expected ORDER of <= 2048 bytes');
        let o = Object.freeze({
          ORDER: e,
          isLE: n,
          BITS: a,
          BYTES: s,
          MASK: e8(a),
          ZERO: e7,
          ONE: te,
          create: (t) => ts(t, e),
          isValid: (t) => {
            if ('bigint' != typeof t)
              throw Error('invalid field element: expected bigint, got ' + typeof t);
            return e7 <= t && t < e;
          },
          is0: (e) => e === e7,
          isOdd: (e) => (e & te) === te,
          neg: (t) => ts(-t, e),
          eql: (e, t) => e === t,
          sqr: (t) => ts(t * t, e),
          add: (t, n) => ts(t + n, e),
          sub: (t, n) => ts(t - n, e),
          mul: (t, n) => ts(t * n, e),
          pow: (e, t) =>
            (function (e, t, n) {
              if (n < e7) throw Error('invalid exponent, negatives unsupported');
              if (n === e7) return e.ONE;
              if (n === te) return t;
              let r = e.ONE,
                i = t;
              for (; n > e7; ) n & te && (r = e.mul(r, i)), (i = e.sqr(i)), (n >>= te);
              return r;
            })(o, e, t),
          div: (t, n) => ts(t * tl(n, e), e),
          sqrN: (e) => e * e,
          addN: (e, t) => e + t,
          subN: (e, t) => e - t,
          mulN: (e, t) => e * t,
          inv: (t) => tl(t, e),
          sqrt:
            r.sqrt ||
            ((t) => (
              i ||
                (i = (function (e) {
                  if (e % tr === tn) {
                    let t = (e + te) / tr;
                    return function (e, n) {
                      let r = e.pow(n, t);
                      if (!e.eql(e.sqr(r), n)) throw Error('Cannot find square root');
                      return r;
                    };
                  }
                  if (e % ta === ti) {
                    let t = (e - ti) / ta;
                    return function (e, n) {
                      let r = e.mul(n, tt),
                        i = e.pow(r, t),
                        a = e.mul(n, i),
                        s = e.mul(e.mul(a, tt), i),
                        o = e.mul(a, e.sub(s, e.ONE));
                      if (!e.eql(e.sqr(o), n)) throw Error('Cannot find square root');
                      return o;
                    };
                  }
                  return (function (e) {
                    let t, n, r;
                    let i = (e - te) / tt;
                    for (t = e - te, n = 0; t % tt === e7; t /= tt, n++);
                    for (
                      r = tt;
                      r < e &&
                      (function (e, t, n) {
                        if (t < e7) throw Error('invalid exponent, negatives unsupported');
                        if (n <= e7) throw Error('invalid modulus');
                        if (n === te) return e7;
                        let r = te;
                        for (; t > e7; ) t & te && (r = (r * e) % n), (e = (e * e) % n), (t >>= te);
                        return r;
                      })(r, i, e) !==
                        e - te;
                      r++
                    )
                      if (r > 1e3) throw Error('Cannot find square root: likely non-prime P');
                    if (1 === n) {
                      let t = (e + te) / tr;
                      return function (e, n) {
                        let r = e.pow(n, t);
                        if (!e.eql(e.sqr(r), n)) throw Error('Cannot find square root');
                        return r;
                      };
                    }
                    let a = (t + te) / tt;
                    return function (e, s) {
                      if (e.pow(s, i) === e.neg(e.ONE)) throw Error('Cannot find square root');
                      let o = n,
                        l = e.pow(e.mul(e.ONE, r), t),
                        u = e.pow(s, a),
                        c = e.pow(s, t);
                      for (; !e.eql(c, e.ONE); ) {
                        if (e.eql(c, e.ZERO)) return e.ZERO;
                        let t = 1;
                        for (let n = e.sqr(c); t < o && !e.eql(n, e.ONE); t++) n = e.sqr(n);
                        let n = e.pow(l, te << BigInt(o - t - 1));
                        (l = e.sqr(n)), (u = e.mul(u, n)), (c = e.mul(c, l)), (o = t);
                      }
                      return u;
                    };
                  })(e);
                })(e)),
              i(o, t)
            )),
          invertBatch: (e) =>
            (function (e, t) {
              let n = Array(t.length),
                r = t.reduce((t, r, i) => (e.is0(r) ? t : ((n[i] = t), e.mul(t, r))), e.ONE),
                i = e.inv(r);
              return (
                t.reduceRight(
                  (t, r, i) => (e.is0(r) ? t : ((n[i] = e.mul(t, n[i])), e.mul(t, r))),
                  i
                ),
                n
              );
            })(o, e),
          cmov: (e, t, n) => (n ? t : e),
          toBytes: (e) => (n ? e0(e, s) : eX(e, s)),
          fromBytes: (e) => {
            if (e.length !== s)
              throw Error('Field.fromBytes: expected ' + s + ' bytes, got ' + e.length);
            return n ? eJ(e) : eK(eG(e));
          },
        });
        return Object.freeze(o);
      }
      let th = BigInt(0),
        ty = BigInt(1);
      function tf(e, t) {
        let n = t.negate();
        return e ? n : t;
      }
      function tm(e, t) {
        if (!Number.isSafeInteger(e) || e <= 0 || e > t)
          throw Error('invalid window size, expected [1..' + t + '], got W=' + e);
      }
      function tg(e, t) {
        return tm(e, t), { windows: Math.ceil(t / e) + 1, windowSize: 2 ** (e - 1) };
      }
      let tb = new WeakMap(),
        tw = new WeakMap();
      function tv(e) {
        return tw.get(e) || 1;
      }
      let tT = BigInt(0),
        tA = BigInt(1),
        tE = BigInt(2),
        tC = BigInt(8),
        t_ = { zip215: !0 };
      BigInt(0), BigInt(1);
      let tI = BigInt(
          '57896044618658097711785492504343953926634992332820282019728792003956564819949'
        ),
        tS = BigInt(
          '19681161376707505956807079304988542015446066515923890162744021073123829784752'
        );
      BigInt(0);
      let tP = BigInt(1),
        tO = BigInt(2);
      BigInt(3);
      let tN = BigInt(5),
        tx = BigInt(8),
        tM = tp(tI, void 0, !0),
        tk = (function (e) {
          var t;
          let n = (function (e) {
              let t =
                (e4(
                  e.Fp,
                  tc.reduce((e, t) => ((e[t] = 'function'), e), {
                    ORDER: 'bigint',
                    MASK: 'bigint',
                    BYTES: 'isSafeInteger',
                    BITS: 'isSafeInteger',
                  })
                ),
                e4(
                  e,
                  { n: 'bigint', h: 'bigint', Gx: 'field', Gy: 'field' },
                  { nBitLength: 'isSafeInteger', nByteLength: 'isSafeInteger' }
                ),
                Object.freeze({ ...td(e.n, e.nBitLength), ...e, p: e.Fp.ORDER }));
              return (
                e4(
                  e,
                  { hash: 'function', a: 'bigint', d: 'bigint', randomBytes: 'function' },
                  {
                    adjustScalarBytes: 'function',
                    domain: 'function',
                    uvRatio: 'function',
                    mapToCurve: 'function',
                  }
                ),
                Object.freeze({ ...t })
              );
            })(e),
            { Fp: r, n: i, prehash: a, hash: s, randomBytes: o, nByteLength: l, h: u } = n,
            c = tE << (BigInt(8 * l) - tA),
            d = r.create,
            p = tp(n.n, n.nBitLength),
            h =
              n.uvRatio ||
              ((e, t) => {
                try {
                  return { isValid: !0, value: r.sqrt(e * r.inv(t)) };
                } catch {
                  return { isValid: !1, value: tT };
                }
              }),
            y = n.adjustScalarBytes || ((e) => e),
            f =
              n.domain ||
              ((e, t, n) => {
                if ((eW('phflag', n), t.length || n))
                  throw Error('Contexts/pre-hash are not supported');
                return e;
              });
          function m(e, t) {
            e5('coordinate ' + e, t, tT, c);
          }
          function g(e) {
            if (!(e instanceof v)) throw Error('ExtendedPoint expected');
          }
          let b = e9((e, t) => {
              let { ex: n, ey: i, ez: a } = e,
                s = e.is0();
              null == t && (t = s ? tC : r.inv(a));
              let o = d(n * t),
                l = d(i * t),
                u = d(a * t);
              if (s) return { x: tT, y: tA };
              if (u !== tA) throw Error('invZ was invalid');
              return { x: o, y: l };
            }),
            w = e9((e) => {
              let { a: t, d: r } = n;
              if (e.is0()) throw Error('bad point: ZERO');
              let { ex: i, ey: a, ez: s, et: o } = e,
                l = d(i * i),
                u = d(a * a),
                c = d(s * s),
                p = d(c * c),
                h = d(l * t);
              if (d(c * d(h + u)) !== d(p + d(r * d(l * u))))
                throw Error('bad point: equation left != right (1)');
              if (d(i * a) !== d(s * o)) throw Error('bad point: equation left != right (2)');
              return !0;
            });
          class v {
            constructor(e, t, n, r) {
              (this.ex = e),
                (this.ey = t),
                (this.ez = n),
                (this.et = r),
                m('x', e),
                m('y', t),
                m('z', n),
                m('t', r),
                Object.freeze(this);
            }
            get x() {
              return this.toAffine().x;
            }
            get y() {
              return this.toAffine().y;
            }
            static fromAffine(e) {
              if (e instanceof v) throw Error('extended point not allowed');
              let { x: t, y: n } = e || {};
              return m('x', t), m('y', n), new v(t, n, tA, d(t * n));
            }
            static normalizeZ(e) {
              let t = r.invertBatch(e.map((e) => e.ez));
              return e.map((e, n) => e.toAffine(t[n])).map(v.fromAffine);
            }
            static msm(e, t) {
              return (function (e, t, n, r) {
                if (
                  ((function (e, t) {
                    if (!Array.isArray(e)) throw Error('array expected');
                    e.forEach((e, n) => {
                      if (!(e instanceof t)) throw Error('invalid point at index ' + n);
                    });
                  })(n, e),
                  (function (e, t) {
                    if (!Array.isArray(e)) throw Error('array of scalars expected');
                    e.forEach((e, n) => {
                      if (!t.isValid(e)) throw Error('invalid scalar at index ' + n);
                    });
                  })(r, t),
                  n.length !== r.length)
                )
                  throw Error('arrays of points and scalars must have equal length');
                let i = e.ZERO,
                  a = (function (e) {
                    let t;
                    for (t = 0; e > ej; e >>= eq, t += 1);
                    return t;
                  })(BigInt(n.length)),
                  s = a > 12 ? a - 3 : a > 4 ? a - 2 : a ? 2 : 1,
                  o = (1 << s) - 1,
                  l = Array(o + 1).fill(i),
                  u = Math.floor((t.BITS - 1) / s) * s,
                  c = i;
                for (let e = u; e >= 0; e -= s) {
                  l.fill(i);
                  for (let t = 0; t < r.length; t++) {
                    let i = Number((r[t] >> BigInt(e)) & BigInt(o));
                    l[i] = l[i].add(n[t]);
                  }
                  let t = i;
                  for (let e = l.length - 1, n = i; e > 0; e--) (n = n.add(l[e])), (t = t.add(n));
                  if (((c = c.add(t)), 0 !== e)) for (let e = 0; e < s; e++) c = c.double();
                }
                return c;
              })(v, p, e, t);
            }
            _setWindowSize(e) {
              E.setWindowSize(this, e);
            }
            assertValidity() {
              w(this);
            }
            equals(e) {
              g(e);
              let { ex: t, ey: n, ez: r } = this,
                { ex: i, ey: a, ez: s } = e,
                o = d(t * s),
                l = d(i * r),
                u = d(n * s),
                c = d(a * r);
              return o === l && u === c;
            }
            is0() {
              return this.equals(v.ZERO);
            }
            negate() {
              return new v(d(-this.ex), this.ey, this.ez, d(-this.et));
            }
            double() {
              let { a: e } = n,
                { ex: t, ey: r, ez: i } = this,
                a = d(t * t),
                s = d(r * r),
                o = d(tE * d(i * i)),
                l = d(e * a),
                u = t + r,
                c = d(d(u * u) - a - s),
                p = l + s,
                h = p - o,
                y = l - s,
                f = d(c * h),
                m = d(p * y),
                g = d(c * y);
              return new v(f, m, d(h * p), g);
            }
            add(e) {
              g(e);
              let { a: t, d: r } = n,
                { ex: i, ey: a, ez: s, et: o } = this,
                { ex: l, ey: u, ez: c, et: p } = e;
              if (t === BigInt(-1)) {
                let e = d((a - i) * (u + l)),
                  t = d((a + i) * (u - l)),
                  n = d(t - e);
                if (n === tT) return this.double();
                let r = d(s * tE * p),
                  h = d(o * tE * c),
                  y = h + r,
                  f = t + e,
                  m = h - r,
                  g = d(y * n),
                  b = d(f * m),
                  w = d(y * m);
                return new v(g, b, d(n * f), w);
              }
              let h = d(i * l),
                y = d(a * u),
                f = d(o * r * p),
                m = d(s * c),
                b = d((i + a) * (l + u) - h - y),
                w = m - f,
                T = m + f,
                A = d(y - t * h),
                E = d(b * w),
                C = d(T * A),
                _ = d(b * A);
              return new v(E, C, d(w * T), _);
            }
            subtract(e) {
              return this.add(e.negate());
            }
            wNAF(e) {
              return E.wNAFCached(this, e, v.normalizeZ);
            }
            multiply(e) {
              e5('scalar', e, tA, i);
              let { p: t, f: n } = this.wNAF(e);
              return v.normalizeZ([t, n])[0];
            }
            multiplyUnsafe(e, t = v.ZERO) {
              return (
                e5('scalar', e, tT, i),
                e === tT
                  ? A
                  : this.is0() || e === tA
                    ? this
                    : E.wNAFCachedUnsafe(this, e, v.normalizeZ, t)
              );
            }
            isSmallOrder() {
              return this.multiplyUnsafe(u).is0();
            }
            isTorsionFree() {
              return E.unsafeLadder(this, i).is0();
            }
            toAffine(e) {
              return b(this, e);
            }
            clearCofactor() {
              let { h: e } = n;
              return e === tA ? this : this.multiplyUnsafe(e);
            }
            static fromHex(e, t = !1) {
              let { d: i, a: a } = n,
                s = r.BYTES;
              (e = e1('pointHex', e, s)), eW('zip215', t);
              let o = e.slice(),
                l = e[s - 1];
              o[s - 1] = -129 & l;
              let u = eJ(o);
              e5('pointHex.y', u, tT, t ? c : r.ORDER);
              let p = d(u * u),
                { isValid: y, value: f } = h(d(p - tA), d(i * p - a));
              if (!y) throw Error('Point.fromHex: invalid y coordinate');
              let m = (f & tA) === tA,
                g = (128 & l) != 0;
              if (!t && f === tT && g) throw Error('Point.fromHex: x=0 and x_0=1');
              return g !== m && (f = d(-f)), v.fromAffine({ x: f, y: u });
            }
            static fromPrivateKey(e) {
              return C(e).point;
            }
            toRawBytes() {
              let { x: e, y: t } = this.toAffine(),
                n = e0(t, r.BYTES);
              return (n[n.length - 1] |= e & tA ? 128 : 0), n;
            }
            toHex() {
              return eG(this.toRawBytes());
            }
          }
          (v.BASE = new v(n.Gx, n.Gy, tA, d(n.Gx * n.Gy))), (v.ZERO = new v(tT, tA, tA, tT));
          let { BASE: T, ZERO: A } = v,
            E =
              ((t = 8 * l),
              {
                constTimeNegate: tf,
                hasPrecomputes: (e) => 1 !== tv(e),
                unsafeLadder(e, t, n = v.ZERO) {
                  let r = e;
                  for (; t > th; ) t & ty && (n = n.add(r)), (r = r.double()), (t >>= ty);
                  return n;
                },
                precomputeWindow(e, n) {
                  let { windows: r, windowSize: i } = tg(n, t),
                    a = [],
                    s = e,
                    o = s;
                  for (let e = 0; e < r; e++) {
                    (o = s), a.push(o);
                    for (let e = 1; e < i; e++) (o = o.add(s)), a.push(o);
                    s = o.double();
                  }
                  return a;
                },
                wNAF(e, n, r) {
                  let { windows: i, windowSize: a } = tg(e, t),
                    s = v.ZERO,
                    o = v.BASE,
                    l = BigInt(2 ** e - 1),
                    u = 2 ** e,
                    c = BigInt(e);
                  for (let e = 0; e < i; e++) {
                    let t = e * a,
                      i = Number(r & l);
                    (r >>= c), i > a && ((i -= u), (r += ty));
                    let d = t + Math.abs(i) - 1,
                      p = e % 2 != 0,
                      h = i < 0;
                    0 === i ? (o = o.add(tf(p, n[t]))) : (s = s.add(tf(h, n[d])));
                  }
                  return { p: s, f: o };
                },
                wNAFUnsafe(e, n, r, i = v.ZERO) {
                  let { windows: a, windowSize: s } = tg(e, t),
                    o = BigInt(2 ** e - 1),
                    l = 2 ** e,
                    u = BigInt(e);
                  for (let e = 0; e < a; e++) {
                    let t = e * s;
                    if (r === th) break;
                    let a = Number(r & o);
                    if (((r >>= u), a > s && ((a -= l), (r += ty)), 0 === a)) continue;
                    let c = n[t + Math.abs(a) - 1];
                    a < 0 && (c = c.negate()), (i = i.add(c));
                  }
                  return i;
                },
                getPrecomputes(e, t, n) {
                  let r = tb.get(t);
                  return r || ((r = this.precomputeWindow(t, e)), 1 !== e && tb.set(t, n(r))), r;
                },
                wNAFCached(e, t, n) {
                  let r = tv(e);
                  return this.wNAF(r, this.getPrecomputes(r, e, n), t);
                },
                wNAFCachedUnsafe(e, t, n, r) {
                  let i = tv(e);
                  return 1 === i
                    ? this.unsafeLadder(e, t, r)
                    : this.wNAFUnsafe(i, this.getPrecomputes(i, e, n), t, r);
                },
                setWindowSize(e, n) {
                  tm(n, t), tw.set(e, n), tb.delete(e);
                },
              });
          function C(e) {
            let t = r.BYTES;
            e = e1('private key', e, t);
            let n = e1('hashed private key', s(e), 2 * t),
              a = y(n.slice(0, t)),
              o = n.slice(t, 2 * t),
              l = ts(eJ(a), i),
              u = T.multiply(l),
              c = u.toRawBytes();
            return { head: a, prefix: o, scalar: l, point: u, pointBytes: c };
          }
          function _(e = new Uint8Array(), ...t) {
            return ts(eJ(s(f(e2(...t), e1('context', e), !!a))), i);
          }
          return (
            T._setWindowSize(8),
            {
              CURVE: n,
              getPublicKey: function (e) {
                return C(e).pointBytes;
              },
              sign: function (e, t, n = {}) {
                (e = e1('message', e)), a && (e = a(e));
                let { prefix: s, scalar: o, pointBytes: l } = C(t),
                  u = _(n.context, s, e),
                  c = T.multiply(u).toRawBytes(),
                  d = ts(u + _(n.context, c, l, e) * o, i);
                return (
                  e5('signature.s', d, tT, i), e1('result', e2(c, e0(d, r.BYTES)), 2 * r.BYTES)
                );
              },
              verify: function (e, t, n, i = t_) {
                let s, o, l;
                let { context: u, zip215: c } = i,
                  d = r.BYTES;
                (e = e1('signature', e, 2 * d)),
                  (t = e1('message', t)),
                  (n = e1('publicKey', n, d)),
                  void 0 !== c && eW('zip215', c),
                  a && (t = a(t));
                let p = eJ(e.slice(d, 2 * d));
                try {
                  (s = v.fromHex(n, c)),
                    (o = v.fromHex(e.slice(0, d), c)),
                    (l = T.multiplyUnsafe(p));
                } catch {
                  return !1;
                }
                if (!c && s.isSmallOrder()) return !1;
                let h = _(u, o.toRawBytes(), s.toRawBytes(), t);
                return o.add(s.multiplyUnsafe(h)).subtract(l).clearCofactor().equals(v.ZERO);
              },
              ExtendedPoint: v,
              utils: {
                getExtendedPublicKey: C,
                randomPrivateKey: () => o(r.BYTES),
                precompute: (e = 8, t = v.BASE) => (t._setWindowSize(e), t.multiply(BigInt(3)), t),
              },
            }
          );
        })({
          a: BigInt(-1),
          d: BigInt(
            '37095705934669439343138083508754565189542113879843219016388785533085940283555'
          ),
          Fp: tM,
          n: BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989'),
          h: tx,
          Gx: BigInt(
            '15112221349535400772501151409588531511454012693041857206046113283949847762202'
          ),
          Gy: BigInt(
            '46316835694926478169428394003475163141307993866256225615783033603165251855960'
          ),
          hash: eF,
          randomBytes: eO,
          adjustScalarBytes: function (e) {
            return (e[0] &= 248), (e[31] &= 127), (e[31] |= 64), e;
          },
          uvRatio: function (e, t) {
            let n = ts(t * t * t, tI),
              r = (function (e) {
                let t = BigInt(10),
                  n = BigInt(20),
                  r = BigInt(40),
                  i = BigInt(80),
                  a = (((e * e) % tI) * e) % tI,
                  s = (to(a, tO, tI) * a) % tI,
                  o = (to(s, tP, tI) * e) % tI,
                  l = (to(o, tN, tI) * o) % tI,
                  u = (to(l, t, tI) * l) % tI,
                  c = (to(u, n, tI) * u) % tI,
                  d = (to(c, r, tI) * c) % tI,
                  p = (to(d, i, tI) * d) % tI,
                  h = (to(p, i, tI) * d) % tI,
                  y = (to(h, t, tI) * l) % tI;
                return { pow_p_5_8: (to(y, tO, tI) * e) % tI, b2: a };
              })(e * ts(n * n * t, tI)).pow_p_5_8,
              i = ts(e * n * r, tI),
              a = ts(t * i * i, tI),
              s = i,
              o = ts(i * tS, tI),
              l = a === e,
              u = a === ts(-e, tI),
              c = a === ts(-e * tS, tI);
            return (
              l && (i = s),
              (u || c) && (i = o),
              tu(i, tI) && (i = ts(-i, tI)),
              { isValid: l || u, value: i }
            );
          },
        }),
        tR = 'base64url',
        tD = 'utf8',
        tB = 'utf8',
        tU = 'base58btc';
      function tL(e) {
        return null != globalThis.Buffer ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : e;
      }
      function tF(e = 0) {
        return null != globalThis.Buffer && null != globalThis.Buffer.allocUnsafe
          ? tL(globalThis.Buffer.allocUnsafe(e))
          : new Uint8Array(e);
      }
      function tj(e, t) {
        t || (t = e.reduce((e, t) => e + t.length, 0));
        let n = tF(t),
          r = 0;
        for (let t of e) n.set(t, r), (r += t.length);
        return tL(n);
      }
      var tq = function (e, t) {
        if (e.length >= 255) throw TypeError('Alphabet too long');
        for (var n = new Uint8Array(256), r = 0; r < n.length; r++) n[r] = 255;
        for (var i = 0; i < e.length; i++) {
          var a = e.charAt(i),
            s = a.charCodeAt(0);
          if (255 !== n[s]) throw TypeError(a + ' is ambiguous');
          n[s] = i;
        }
        var o = e.length,
          l = e.charAt(0),
          u = Math.log(o) / Math.log(256),
          c = Math.log(256) / Math.log(o);
        function d(e) {
          if ('string' != typeof e) throw TypeError('Expected String');
          if (0 === e.length) return new Uint8Array();
          var t = 0;
          if (' ' !== e[0]) {
            for (var r = 0, i = 0; e[t] === l; ) r++, t++;
            for (var a = ((e.length - t) * u + 1) >>> 0, s = new Uint8Array(a); e[t]; ) {
              var c = n[e.charCodeAt(t)];
              if (255 === c) return;
              for (var d = 0, p = a - 1; (0 !== c || d < i) && -1 !== p; p--, d++)
                (c += (o * s[p]) >>> 0), (s[p] = c % 256 >>> 0), (c = (c / 256) >>> 0);
              if (0 !== c) throw Error('Non-zero carry');
              (i = d), t++;
            }
            if (' ' !== e[t]) {
              for (var h = a - i; h !== a && 0 === s[h]; ) h++;
              for (var y = new Uint8Array(r + (a - h)), f = r; h !== a; ) y[f++] = s[h++];
              return y;
            }
          }
        }
        return {
          encode: function (t) {
            if (
              (t instanceof Uint8Array ||
                (ArrayBuffer.isView(t)
                  ? (t = new Uint8Array(t.buffer, t.byteOffset, t.byteLength))
                  : Array.isArray(t) && (t = Uint8Array.from(t))),
              !(t instanceof Uint8Array))
            )
              throw TypeError('Expected Uint8Array');
            if (0 === t.length) return '';
            for (var n = 0, r = 0, i = 0, a = t.length; i !== a && 0 === t[i]; ) i++, n++;
            for (var s = ((a - i) * c + 1) >>> 0, u = new Uint8Array(s); i !== a; ) {
              for (var d = t[i], p = 0, h = s - 1; (0 !== d || p < r) && -1 !== h; h--, p++)
                (d += (256 * u[h]) >>> 0), (u[h] = d % o >>> 0), (d = (d / o) >>> 0);
              if (0 !== d) throw Error('Non-zero carry');
              (r = p), i++;
            }
            for (var y = s - r; y !== s && 0 === u[y]; ) y++;
            for (var f = l.repeat(n); y < s; ++y) f += e.charAt(u[y]);
            return f;
          },
          decodeUnsafe: d,
          decode: function (e) {
            var n = d(e);
            if (n) return n;
            throw Error(`Non-${t} character`);
          },
        };
      };
      let tV = (e) => {
          if (e instanceof Uint8Array && 'Uint8Array' === e.constructor.name) return e;
          if (e instanceof ArrayBuffer) return new Uint8Array(e);
          if (ArrayBuffer.isView(e)) return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
          throw Error('Unknown type, must be binary type');
        },
        t$ = (e) => new TextEncoder().encode(e),
        tz = (e) => new TextDecoder().decode(e);
      class tW {
        constructor(e, t, n) {
          (this.name = e), (this.prefix = t), (this.baseEncode = n);
        }
        encode(e) {
          if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
          throw Error('Unknown type, must be binary type');
        }
      }
      class tH {
        constructor(e, t, n) {
          if (((this.name = e), (this.prefix = t), void 0 === t.codePointAt(0)))
            throw Error('Invalid prefix character');
          (this.prefixCodePoint = t.codePointAt(0)), (this.baseDecode = n);
        }
        decode(e) {
          if ('string' == typeof e) {
            if (e.codePointAt(0) !== this.prefixCodePoint)
              throw Error(
                `Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`
              );
            return this.baseDecode(e.slice(this.prefix.length));
          }
          throw Error('Can only multibase decode strings');
        }
        or(e) {
          return tK(this, e);
        }
      }
      class tG {
        constructor(e) {
          this.decoders = e;
        }
        or(e) {
          return tK(this, e);
        }
        decode(e) {
          let t = e[0],
            n = this.decoders[t];
          if (n) return n.decode(e);
          throw RangeError(
            `Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`
          );
        }
      }
      let tK = (e, t) =>
        new tG({ ...(e.decoders || { [e.prefix]: e }), ...(t.decoders || { [t.prefix]: t }) });
      class tQ {
        constructor(e, t, n, r) {
          (this.name = e),
            (this.prefix = t),
            (this.baseEncode = n),
            (this.baseDecode = r),
            (this.encoder = new tW(e, t, n)),
            (this.decoder = new tH(e, t, r));
        }
        encode(e) {
          return this.encoder.encode(e);
        }
        decode(e) {
          return this.decoder.decode(e);
        }
      }
      let tY = ({ name: e, prefix: t, encode: n, decode: r }) => new tQ(e, t, n, r),
        tZ = ({ prefix: e, name: t, alphabet: n }) => {
          let { encode: r, decode: i } = tq(n, t);
          return tY({ prefix: e, name: t, encode: r, decode: (e) => tV(i(e)) });
        },
        tJ = (e, t, n, r) => {
          let i = {};
          for (let e = 0; e < t.length; ++e) i[t[e]] = e;
          let a = e.length;
          for (; '=' === e[a - 1]; ) --a;
          let s = new Uint8Array(((a * n) / 8) | 0),
            o = 0,
            l = 0,
            u = 0;
          for (let t = 0; t < a; ++t) {
            let a = i[e[t]];
            if (void 0 === a) throw SyntaxError(`Non-${r} character`);
            (l = (l << n) | a), (o += n) >= 8 && ((o -= 8), (s[u++] = 255 & (l >> o)));
          }
          if (o >= n || 255 & (l << (8 - o))) throw SyntaxError('Unexpected end of data');
          return s;
        },
        tX = (e, t, n) => {
          let r = '=' === t[t.length - 1],
            i = (1 << n) - 1,
            a = '',
            s = 0,
            o = 0;
          for (let r = 0; r < e.length; ++r)
            for (o = (o << 8) | e[r], s += 8; s > n; ) (s -= n), (a += t[i & (o >> s)]);
          if ((s && (a += t[i & (o << (n - s))]), r)) for (; (a.length * n) & 7; ) a += '=';
          return a;
        },
        t0 = ({ name: e, prefix: t, bitsPerChar: n, alphabet: r }) =>
          tY({ prefix: t, name: e, encode: (e) => tX(e, r, n), decode: (t) => tJ(t, r, n, e) });
      var t1 = Object.freeze({
          __proto__: null,
          identity: tY({
            prefix: '\0',
            name: 'identity',
            encode: (e) => tz(e),
            decode: (e) => t$(e),
          }),
        }),
        t2 = Object.freeze({
          __proto__: null,
          base2: t0({ prefix: '0', name: 'base2', alphabet: '01', bitsPerChar: 1 }),
        }),
        t6 = Object.freeze({
          __proto__: null,
          base8: t0({ prefix: '7', name: 'base8', alphabet: '01234567', bitsPerChar: 3 }),
        }),
        t5 = Object.freeze({
          __proto__: null,
          base10: tZ({ prefix: '9', name: 'base10', alphabet: '0123456789' }),
        }),
        t8 = Object.freeze({
          __proto__: null,
          base16: t0({ prefix: 'f', name: 'base16', alphabet: '0123456789abcdef', bitsPerChar: 4 }),
          base16upper: t0({
            prefix: 'F',
            name: 'base16upper',
            alphabet: '0123456789ABCDEF',
            bitsPerChar: 4,
          }),
        });
      let t3 = t0({
          prefix: 'b',
          name: 'base32',
          alphabet: 'abcdefghijklmnopqrstuvwxyz234567',
          bitsPerChar: 5,
        }),
        t4 = t0({
          prefix: 'B',
          name: 'base32upper',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
          bitsPerChar: 5,
        }),
        t9 = t0({
          prefix: 'c',
          name: 'base32pad',
          alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',
          bitsPerChar: 5,
        }),
        t7 = t0({
          prefix: 'C',
          name: 'base32padupper',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
          bitsPerChar: 5,
        }),
        ne = t0({
          prefix: 'v',
          name: 'base32hex',
          alphabet: '0123456789abcdefghijklmnopqrstuv',
          bitsPerChar: 5,
        }),
        nt = t0({
          prefix: 'V',
          name: 'base32hexupper',
          alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
          bitsPerChar: 5,
        });
      var nn = Object.freeze({
          __proto__: null,
          base32: t3,
          base32upper: t4,
          base32pad: t9,
          base32padupper: t7,
          base32hex: ne,
          base32hexupper: nt,
          base32hexpad: t0({
            prefix: 't',
            name: 'base32hexpad',
            alphabet: '0123456789abcdefghijklmnopqrstuv=',
            bitsPerChar: 5,
          }),
          base32hexpadupper: t0({
            prefix: 'T',
            name: 'base32hexpadupper',
            alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
            bitsPerChar: 5,
          }),
          base32z: t0({
            prefix: 'h',
            name: 'base32z',
            alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',
            bitsPerChar: 5,
          }),
        }),
        nr = Object.freeze({
          __proto__: null,
          base36: tZ({
            prefix: 'k',
            name: 'base36',
            alphabet: '0123456789abcdefghijklmnopqrstuvwxyz',
          }),
          base36upper: tZ({
            prefix: 'K',
            name: 'base36upper',
            alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ',
          }),
        }),
        ni = Object.freeze({
          __proto__: null,
          base58btc: tZ({
            name: 'base58btc',
            prefix: 'z',
            alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz',
          }),
          base58flickr: tZ({
            name: 'base58flickr',
            prefix: 'Z',
            alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ',
          }),
        });
      let na = t0({
        prefix: 'm',
        name: 'base64',
        alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
        bitsPerChar: 6,
      });
      var ns = Object.freeze({
        __proto__: null,
        base64: na,
        base64pad: t0({
          prefix: 'M',
          name: 'base64pad',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
          bitsPerChar: 6,
        }),
        base64url: t0({
          prefix: 'u',
          name: 'base64url',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
          bitsPerChar: 6,
        }),
        base64urlpad: t0({
          prefix: 'U',
          name: 'base64urlpad',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
          bitsPerChar: 6,
        }),
      });
      let no = Array.from(
          '\uD83D\uDE80\uD83E\uDE90\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\uD83E\uDD19\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\uD83C\uDF1E\uD83C\uDF88\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\uD83D\uDC8E\uD83D\uDCB8\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42'
        ),
        nl = no.reduce((e, t, n) => ((e[n] = t), e), []),
        nu = no.reduce((e, t, n) => ((e[t.codePointAt(0)] = n), e), []);
      var nc = Object.freeze({
        __proto__: null,
        base256emoji: tY({
          prefix: '\uD83D\uDE80',
          name: 'base256emoji',
          encode: function (e) {
            return e.reduce((e, t) => (e += nl[t]), '');
          },
          decode: function (e) {
            let t = [];
            for (let n of e) {
              let e = nu[n.codePointAt(0)];
              if (void 0 === e) throw Error(`Non-base256emoji character: ${n}`);
              t.push(e);
            }
            return new Uint8Array(t);
          },
        }),
      });
      function nd(e, t) {
        var n,
          r = 0,
          t = t || 0,
          i = 0,
          a = t,
          s = e.length;
        do {
          if (a >= s) throw ((nd.bytes = 0), RangeError('Could not decode varint'));
          (n = e[a++]), (r += i < 28 ? (127 & n) << i : (127 & n) * Math.pow(2, i)), (i += 7);
        } while (n >= 128);
        return (nd.bytes = a - t), r;
      }
      var np = function e(t, n, r) {
        (n = n || []), (r = r || 0);
        for (var i = r; t >= 2147483648; ) (n[r++] = (255 & t) | 128), (t /= 128);
        for (; -128 & t; ) (n[r++] = (255 & t) | 128), (t >>>= 7);
        return (n[r] = 0 | t), (e.bytes = r - i + 1), n;
      };
      let nh = (e, t, n = 0) => (np(e, t, n), t),
        ny = (e) =>
          e < 128
            ? 1
            : e < 16384
              ? 2
              : e < 2097152
                ? 3
                : e < 268435456
                  ? 4
                  : e < 34359738368
                    ? 5
                    : e < 4398046511104
                      ? 6
                      : e < 562949953421312
                        ? 7
                        : e < 72057594037927940
                          ? 8
                          : e < 0x7fffffffffffffff
                            ? 9
                            : 10,
        nf = (e, t) => {
          let n = t.byteLength,
            r = ny(e),
            i = r + ny(n),
            a = new Uint8Array(i + n);
          return nh(e, a, 0), nh(n, a, r), a.set(t, i), new nm(e, n, t, a);
        };
      class nm {
        constructor(e, t, n, r) {
          (this.code = e), (this.size = t), (this.digest = n), (this.bytes = r);
        }
      }
      let ng = ({ name: e, code: t, encode: n }) => new nb(e, t, n);
      class nb {
        constructor(e, t, n) {
          (this.name = e), (this.code = t), (this.encode = n);
        }
        digest(e) {
          if (e instanceof Uint8Array) {
            let t = this.encode(e);
            return t instanceof Uint8Array ? nf(this.code, t) : t.then((e) => nf(this.code, e));
          }
          throw Error('Unknown type, must be binary type');
        }
      }
      let nw = (e) => async (t) => new Uint8Array(await crypto.subtle.digest(e, t));
      var nv = Object.freeze({
          __proto__: null,
          sha256: ng({ name: 'sha2-256', code: 18, encode: nw('SHA-256') }),
          sha512: ng({ name: 'sha2-512', code: 19, encode: nw('SHA-512') }),
        }),
        nT = Object.freeze({
          __proto__: null,
          identity: { code: 0, name: 'identity', encode: tV, digest: (e) => nf(0, tV(e)) },
        });
      new TextEncoder(), new TextDecoder();
      let nA = { ...t1, ...t2, ...t6, ...t5, ...t8, ...nn, ...nr, ...ni, ...ns, ...nc };
      function nE(e, t, n, r) {
        return {
          name: e,
          prefix: t,
          encoder: { name: e, prefix: t, encode: n },
          decoder: { decode: r },
        };
      }
      ({ ...nv, ...nT });
      let nC = nE(
          'utf8',
          'u',
          (e) => 'u' + new TextDecoder('utf8').decode(e),
          (e) => new TextEncoder().encode(e.substring(1))
        ),
        n_ = nE(
          'ascii',
          'a',
          (e) => {
            let t = 'a';
            for (let n = 0; n < e.length; n++) t += String.fromCharCode(e[n]);
            return t;
          },
          (e) => {
            let t = tF((e = e.substring(1)).length);
            for (let n = 0; n < e.length; n++) t[n] = e.charCodeAt(n);
            return t;
          }
        ),
        nI = { utf8: nC, 'utf-8': nC, hex: nA.base16, latin1: n_, ascii: n_, binary: n_, ...nA };
      function nS(e, t = 'utf8') {
        let n = nI[t];
        if (!n) throw Error(`Unsupported encoding "${t}"`);
        return ('utf8' === t || 'utf-8' === t) &&
          null != globalThis.Buffer &&
          null != globalThis.Buffer.from
          ? globalThis.Buffer.from(e.buffer, e.byteOffset, e.byteLength).toString('utf8')
          : n.encoder.encode(e).substring(1);
      }
      function nP(e, t = 'utf8') {
        let n = nI[t];
        if (!n) throw Error(`Unsupported encoding "${t}"`);
        return ('utf8' === t || 'utf-8' === t) &&
          null != globalThis.Buffer &&
          null != globalThis.Buffer.from
          ? tL(globalThis.Buffer.from(e, 'utf-8'))
          : n.decoder.decode(`${n.prefix}${e}`);
      }
      function nO(e) {
        return (0, z.D)(nS(nP(e, tR), tD));
      }
      function nN(e) {
        return nS(nP((0, z.u)(e), tD), tR);
      }
      function nx(e) {
        return ['did', 'key', 'z' + nS(tj([nP('K36', tU), e]), tU)].join(':');
      }
      function nM(e) {
        let t = e.split('.'),
          n = nO(t[0]);
        return {
          header: n,
          payload: nO(t[1]),
          signature: nP(t[2], tR),
          data: nP(t.slice(0, 2).join('.'), tB),
        };
      }
      function nk(e = eO(32)) {
        let t = tk.getPublicKey(e);
        return { secretKey: tj([e, t]), publicKey: t };
      }
      async function nR(e, t, n, r, i = (0, v.fromMiliseconds)(Date.now())) {
        var a, s;
        let o = { alg: 'EdDSA', typ: 'JWT' },
          l = { iss: nx(r.publicKey), sub: e, aud: t, iat: i, exp: i + n },
          u = nP([nN((a = { header: o, payload: l }).header), nN(a.payload)].join('.'), tB);
        return [
          nN(
            (s = { header: o, payload: l, signature: tk.sign(u, r.secretKey.slice(0, 32)) }).header
          ),
          nN(s.payload),
          nS(s.signature, tR),
        ].join('.');
      }
      var nD = n(32608),
        nB = function (e, t, n) {
          if (n || 2 == arguments.length)
            for (var r, i = 0, a = t.length; i < a; i++)
              (!r && i in t) || (r || (r = Array.prototype.slice.call(t, 0, i)), (r[i] = t[i]));
          return e.concat(r || Array.prototype.slice.call(t));
        },
        nU = function (e, t, n) {
          (this.name = e), (this.version = t), (this.os = n), (this.type = 'browser');
        },
        nL = function (e) {
          (this.version = e), (this.type = 'node'), (this.name = 'node'), (this.os = nD.platform);
        },
        nF = function (e, t, n, r) {
          (this.name = e),
            (this.version = t),
            (this.os = n),
            (this.bot = r),
            (this.type = 'bot-device');
        },
        nj = function () {
          (this.type = 'bot'),
            (this.bot = !0),
            (this.name = 'bot'),
            (this.version = null),
            (this.os = null);
        },
        nq = function () {
          (this.type = 'react-native'),
            (this.name = 'react-native'),
            (this.version = null),
            (this.os = null);
        },
        nV = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,
        n$ = [
          ['aol', /AOLShield\/([0-9\._]+)/],
          ['edge', /Edge\/([0-9\._]+)/],
          ['edge-ios', /EdgiOS\/([0-9\._]+)/],
          ['yandexbrowser', /YaBrowser\/([0-9\._]+)/],
          ['kakaotalk', /KAKAOTALK\s([0-9\.]+)/],
          ['samsung', /SamsungBrowser\/([0-9\.]+)/],
          ['silk', /\bSilk\/([0-9._-]+)\b/],
          ['miui', /MiuiBrowser\/([0-9\.]+)$/],
          ['beaker', /BeakerBrowser\/([0-9\.]+)/],
          ['edge-chromium', /EdgA?\/([0-9\.]+)/],
          ['chromium-webview', /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
          ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
          ['phantomjs', /PhantomJS\/([0-9\.]+)(:?\s|$)/],
          ['crios', /CriOS\/([0-9\.]+)(:?\s|$)/],
          ['firefox', /Firefox\/([0-9\.]+)(?:\s|$)/],
          ['fxios', /FxiOS\/([0-9\.]+)/],
          ['opera-mini', /Opera Mini.*Version\/([0-9\.]+)/],
          ['opera', /Opera\/([0-9\.]+)(?:\s|$)/],
          ['opera', /OPR\/([0-9\.]+)(:?\s|$)/],
          ['pie', /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
          [
            'pie',
            /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/,
          ],
          ['netfront', /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
          ['ie', /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
          ['ie', /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
          ['ie', /MSIE\s(7\.0)/],
          ['bb10', /BB10;\sTouch.*Version\/([0-9\.]+)/],
          ['android', /Android\s([0-9\.]+)/],
          ['ios', /Version\/([0-9\._]+).*Mobile.*Safari.*/],
          ['safari', /Version\/([0-9\._]+).*Safari/],
          ['facebook', /FB[AS]V\/([0-9\.]+)/],
          ['instagram', /Instagram\s([0-9\.]+)/],
          ['ios-webview', /AppleWebKit\/([0-9\.]+).*Mobile/],
          ['ios-webview', /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
          ['curl', /^curl\/([0-9\.]+)$/],
          [
            'searchbot',
            /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,
          ],
        ],
        nz = [
          ['iOS', /iP(hone|od|ad)/],
          ['Android OS', /Android/],
          ['BlackBerry OS', /BlackBerry|BB10/],
          ['Windows Mobile', /IEMobile/],
          ['Amazon OS', /Kindle/],
          ['Windows 3.11', /Win16/],
          ['Windows 95', /(Windows 95)|(Win95)|(Windows_95)/],
          ['Windows 98', /(Windows 98)|(Win98)/],
          ['Windows 2000', /(Windows NT 5.0)|(Windows 2000)/],
          ['Windows XP', /(Windows NT 5.1)|(Windows XP)/],
          ['Windows Server 2003', /(Windows NT 5.2)/],
          ['Windows Vista', /(Windows NT 6.0)/],
          ['Windows 7', /(Windows NT 6.1)/],
          ['Windows 8', /(Windows NT 6.2)/],
          ['Windows 8.1', /(Windows NT 6.3)/],
          ['Windows 10', /(Windows NT 10.0)/],
          ['Windows ME', /Windows ME/],
          ['Windows CE', /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
          ['Open BSD', /OpenBSD/],
          ['Sun OS', /SunOS/],
          ['Chrome OS', /CrOS/],
          ['Linux', /(Linux)|(X11)/],
          ['Mac OS', /(Mac_PowerPC)|(Macintosh)/],
          ['QNX', /QNX/],
          ['BeOS', /BeOS/],
          ['OS/2', /OS\/2/],
        ],
        nW = n(17421),
        nH = n(1073);
      let nG = '2.23.2',
        nK = {
          getDocsUrl: ({ docsBaseUrl: e, docsPath: t = '', docsSlug: n }) =>
            t ? `${e ?? 'https://viem.sh'}${t}${n ? `#${n}` : ''}` : void 0,
          version: `viem@${nG}`,
        };
      class nQ extends Error {
        constructor(e, t = {}) {
          let n =
              t.cause instanceof nQ
                ? t.cause.details
                : t.cause?.message
                  ? t.cause.message
                  : t.details,
            r = (t.cause instanceof nQ && t.cause.docsPath) || t.docsPath,
            i = nK.getDocsUrl?.({ ...t, docsPath: r });
          super(
            [
              e || 'An error occurred.',
              '',
              ...(t.metaMessages ? [...t.metaMessages, ''] : []),
              ...(i ? [`Docs: ${i}`] : []),
              ...(n ? [`Details: ${n}`] : []),
              ...(nK.version ? [`Version: ${nK.version}`] : []),
            ].join('\n'),
            t.cause ? { cause: t.cause } : void 0
          ),
            Object.defineProperty(this, 'details', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, 'docsPath', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, 'metaMessages', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, 'shortMessage', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, 'version', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, 'name', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: 'BaseError',
            }),
            (this.details = n),
            (this.docsPath = r),
            (this.metaMessages = t.metaMessages),
            (this.name = t.name ?? this.name),
            (this.shortMessage = e),
            (this.version = nG);
        }
        walk(e) {
          return (function e(t, n) {
            return n?.(t)
              ? t
              : t && 'object' == typeof t && 'cause' in t && void 0 !== t.cause
                ? e(t.cause, n)
                : n
                  ? null
                  : t;
          })(this, e);
        }
      }
      function nY(e, { strict: t = !0 } = {}) {
        return !!e && 'string' == typeof e && (t ? /^0x[0-9a-fA-F]*$/.test(e) : e.startsWith('0x'));
      }
      class nZ extends nQ {
        constructor({ size: e, targetSize: t, type: n }) {
          super(
            `${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (${e}) exceeds padding size (${t}).`,
            { name: 'SizeExceedsPaddingSizeError' }
          );
        }
      }
      function nJ(e, { dir: t, size: n = 32 } = {}) {
        return 'string' == typeof e
          ? (function (e, { dir: t, size: n = 32 } = {}) {
              if (null === n) return e;
              let r = e.replace('0x', '');
              if (r.length > 2 * n)
                throw new nZ({ size: Math.ceil(r.length / 2), targetSize: n, type: 'hex' });
              return `0x${r['right' === t ? 'padEnd' : 'padStart'](2 * n, '0')}`;
            })(e, { dir: t, size: n })
          : (function (e, { dir: t, size: n = 32 } = {}) {
              if (null === n) return e;
              if (e.length > n) throw new nZ({ size: e.length, targetSize: n, type: 'bytes' });
              let r = new Uint8Array(n);
              for (let i = 0; i < n; i++) {
                let a = 'right' === t;
                r[a ? i : n - i - 1] = e[a ? i : e.length - i - 1];
              }
              return r;
            })(e, { dir: t, size: n });
      }
      class nX extends nQ {
        constructor({ max: e, min: t, signed: n, size: r, value: i }) {
          super(
            `Number "${i}" is not in safe ${r ? `${8 * r}-bit ${n ? 'signed' : 'unsigned'} ` : ''}integer range ${e ? `(${t} to ${e})` : `(above ${t})`}`,
            { name: 'IntegerOutOfRangeError' }
          );
        }
      }
      class n0 extends nQ {
        constructor({ givenSize: e, maxSize: t }) {
          super(`Size cannot exceed ${t} bytes. Given size: ${e} bytes.`, {
            name: 'SizeOverflowError',
          });
        }
      }
      function n1(e) {
        return nY(e, { strict: !1 }) ? Math.ceil((e.length - 2) / 2) : e.length;
      }
      function n2(e, { size: t }) {
        if (n1(e) > t) throw new n0({ givenSize: n1(e), maxSize: t });
      }
      function n6(e, t = {}) {
        let { signed: n } = t;
        t.size && n2(e, { size: t.size });
        let r = BigInt(e);
        if (!n) return r;
        let i = (e.length - 2) / 2;
        return r <= (1n << (8n * BigInt(i) - 1n)) - 1n
          ? r
          : r - BigInt(`0x${'f'.padStart(2 * i, 'f')}`) - 1n;
      }
      let n5 = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, '0'));
      function n8(e, t = {}) {
        return 'number' == typeof e || 'bigint' == typeof e
          ? n4(e, t)
          : 'string' == typeof e
            ? (function (e, t = {}) {
                return n3(n9.encode(e), t);
              })(e, t)
            : 'boolean' == typeof e
              ? (function (e, t = {}) {
                  let n = `0x${Number(e)}`;
                  return 'number' == typeof t.size
                    ? (n2(n, { size: t.size }), nJ(n, { size: t.size }))
                    : n;
                })(e, t)
              : n3(e, t);
      }
      function n3(e, t = {}) {
        let n = '';
        for (let t = 0; t < e.length; t++) n += n5[e[t]];
        let r = `0x${n}`;
        return 'number' == typeof t.size
          ? (n2(r, { size: t.size }), nJ(r, { dir: 'right', size: t.size }))
          : r;
      }
      function n4(e, t = {}) {
        let n;
        let { signed: r, size: i } = t,
          a = BigInt(e);
        i
          ? (n = r ? (1n << (8n * BigInt(i) - 1n)) - 1n : 2n ** (8n * BigInt(i)) - 1n)
          : 'number' == typeof e && (n = BigInt(Number.MAX_SAFE_INTEGER));
        let s = 'bigint' == typeof n && r ? -n - 1n : 0;
        if ((n && a > n) || a < s) {
          let t = 'bigint' == typeof e ? 'n' : '';
          throw new nX({
            max: n ? `${n}${t}` : void 0,
            min: `${s}${t}`,
            signed: r,
            size: i,
            value: `${e}${t}`,
          });
        }
        let o = `0x${(r && a < 0 ? (1n << BigInt(8 * i)) + BigInt(a) : a).toString(16)}`;
        return i ? nJ(o, { size: i }) : o;
      }
      let n9 = new TextEncoder(),
        n7 = new TextEncoder(),
        re = { zero: 48, nine: 57, A: 65, F: 70, a: 97, f: 102 };
      function rt(e) {
        return e >= re.zero && e <= re.nine
          ? e - re.zero
          : e >= re.A && e <= re.F
            ? e - (re.A - 10)
            : e >= re.a && e <= re.f
              ? e - (re.a - 10)
              : void 0;
      }
      function rn(e, t = {}) {
        let n = e;
        t.size && (n2(n, { size: t.size }), (n = nJ(n, { dir: 'right', size: t.size })));
        let r = n.slice(2);
        r.length % 2 && (r = `0${r}`);
        let i = r.length / 2,
          a = new Uint8Array(i);
        for (let e = 0, t = 0; e < i; e++) {
          let n = rt(r.charCodeAt(t++)),
            i = rt(r.charCodeAt(t++));
          if (void 0 === n || void 0 === i)
            throw new nQ(`Invalid byte sequence ("${r[t - 2]}${r[t - 1]}" in "${r}").`);
          a[e] = 16 * n + i;
        }
        return a;
      }
      function rr(e, t = {}) {
        let n = n7.encode(e);
        return 'number' == typeof t.size
          ? (n2(n, { size: t.size }), nJ(n, { dir: 'right', size: t.size }))
          : n;
      }
      var ri = n(7885);
      let ra = BigInt(4294967296 - 1),
        rs = BigInt(32),
        ro = (e, t, n) => (e << n) | (t >>> (32 - n)),
        rl = (e, t, n) => (t << n) | (e >>> (32 - n)),
        ru = (e, t, n) => (t << (n - 32)) | (e >>> (64 - n)),
        rc = (e, t, n) => (e << (n - 32)) | (t >>> (64 - n));
      var rd = n(43921);
      let rp = [],
        rh = [],
        ry = [],
        rf = BigInt(0),
        rm = BigInt(1),
        rg = BigInt(2),
        rb = BigInt(7),
        rw = BigInt(256),
        rv = BigInt(113);
      for (let e = 0, t = rm, n = 1, r = 0; e < 24; e++) {
        ([n, r] = [r, (2 * n + 3 * r) % 5]),
          rp.push(2 * (5 * r + n)),
          rh.push((((e + 1) * (e + 2)) / 2) % 64);
        let i = rf;
        for (let e = 0; e < 7; e++)
          (t = ((t << rm) ^ ((t >> rb) * rv)) % rw) & rg && (i ^= rm << ((rm << BigInt(e)) - rm));
        ry.push(i);
      }
      let [rT, rA] = (function (e, t = !1) {
          let n = new Uint32Array(e.length),
            r = new Uint32Array(e.length);
          for (let i = 0; i < e.length; i++) {
            let { h: a, l: s } = (function (e, t = !1) {
              return t
                ? { h: Number(e & ra), l: Number((e >> rs) & ra) }
                : { h: 0 | Number((e >> rs) & ra), l: 0 | Number(e & ra) };
            })(e[i], t);
            [n[i], r[i]] = [a, s];
          }
          return [n, r];
        })(ry, !0),
        rE = (e, t, n) => (n > 32 ? ru(e, t, n) : ro(e, t, n)),
        rC = (e, t, n) => (n > 32 ? rc(e, t, n) : rl(e, t, n));
      class r_ extends rd.kb {
        constructor(e, t, n, r = !1, i = 24) {
          if (
            (super(),
            (this.blockLen = e),
            (this.suffix = t),
            (this.outputLen = n),
            (this.enableXOF = r),
            (this.rounds = i),
            (this.pos = 0),
            (this.posOut = 0),
            (this.finished = !1),
            (this.destroyed = !1),
            (0, ri.k8)(n),
            0 >= this.blockLen || this.blockLen >= 200)
          )
            throw Error('Sha3 supports only keccak-f1600 function');
          (this.state = new Uint8Array(200)), (this.state32 = (0, rd.Jq)(this.state));
        }
        keccak() {
          rd.iA || (0, rd.l1)(this.state32),
            (function (e, t = 24) {
              let n = new Uint32Array(10);
              for (let r = 24 - t; r < 24; r++) {
                for (let t = 0; t < 10; t++)
                  n[t] = e[t] ^ e[t + 10] ^ e[t + 20] ^ e[t + 30] ^ e[t + 40];
                for (let t = 0; t < 10; t += 2) {
                  let r = (t + 8) % 10,
                    i = (t + 2) % 10,
                    a = n[i],
                    s = n[i + 1],
                    o = rE(a, s, 1) ^ n[r],
                    l = rC(a, s, 1) ^ n[r + 1];
                  for (let n = 0; n < 50; n += 10) (e[t + n] ^= o), (e[t + n + 1] ^= l);
                }
                let t = e[2],
                  i = e[3];
                for (let n = 0; n < 24; n++) {
                  let r = rh[n],
                    a = rE(t, i, r),
                    s = rC(t, i, r),
                    o = rp[n];
                  (t = e[o]), (i = e[o + 1]), (e[o] = a), (e[o + 1] = s);
                }
                for (let t = 0; t < 50; t += 10) {
                  for (let r = 0; r < 10; r++) n[r] = e[t + r];
                  for (let r = 0; r < 10; r++) e[t + r] ^= ~n[(r + 2) % 10] & n[(r + 4) % 10];
                }
                (e[0] ^= rT[r]), (e[1] ^= rA[r]);
              }
              n.fill(0);
            })(this.state32, this.rounds),
            rd.iA || (0, rd.l1)(this.state32),
            (this.posOut = 0),
            (this.pos = 0);
        }
        update(e) {
          (0, ri.$h)(this);
          let { blockLen: t, state: n } = this,
            r = (e = (0, rd.O0)(e)).length;
          for (let i = 0; i < r; ) {
            let a = Math.min(t - this.pos, r - i);
            for (let t = 0; t < a; t++) n[this.pos++] ^= e[i++];
            this.pos === t && this.keccak();
          }
          return this;
        }
        finish() {
          if (this.finished) return;
          this.finished = !0;
          let { state: e, suffix: t, pos: n, blockLen: r } = this;
          (e[n] ^= t),
            (128 & t) != 0 && n === r - 1 && this.keccak(),
            (e[r - 1] ^= 128),
            this.keccak();
        }
        writeInto(e) {
          (0, ri.$h)(this, !1), (0, ri.gk)(e), this.finish();
          let t = this.state,
            { blockLen: n } = this;
          for (let r = 0, i = e.length; r < i; ) {
            this.posOut >= n && this.keccak();
            let a = Math.min(n - this.posOut, i - r);
            e.set(t.subarray(this.posOut, this.posOut + a), r), (this.posOut += a), (r += a);
          }
          return e;
        }
        xofInto(e) {
          if (!this.enableXOF) throw Error('XOF is not possible for this instance');
          return this.writeInto(e);
        }
        xof(e) {
          return (0, ri.k8)(e), this.xofInto(new Uint8Array(e));
        }
        digestInto(e) {
          if (((0, ri.eB)(e, this), this.finished)) throw Error('digest() was already called');
          return this.writeInto(e), this.destroy(), e;
        }
        digest() {
          return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
          (this.destroyed = !0), this.state.fill(0);
        }
        _cloneInto(e) {
          let { blockLen: t, suffix: n, outputLen: r, rounds: i, enableXOF: a } = this;
          return (
            e || (e = new r_(t, n, r, a, i)),
            e.state32.set(this.state32),
            (e.pos = this.pos),
            (e.posOut = this.posOut),
            (e.finished = this.finished),
            (e.rounds = i),
            (e.suffix = n),
            (e.outputLen = r),
            (e.enableXOF = a),
            (e.destroyed = this.destroyed),
            e
          );
        }
      }
      let rI = (0, rd.hE)(() => new r_(136, 1, 32));
      function rS(e, t) {
        let n = rI(
          nY(e, { strict: !1 })
            ? (function (e, t = {}) {
                return 'number' == typeof e || 'bigint' == typeof e
                  ? rn(n4(e, t))
                  : 'boolean' == typeof e
                    ? (function (e, t = {}) {
                        let n = new Uint8Array(1);
                        return ((n[0] = Number(e)), 'number' == typeof t.size)
                          ? (n2(n, { size: t.size }), nJ(n, { size: t.size }))
                          : n;
                      })(e, t)
                    : nY(e)
                      ? rn(e, t)
                      : rr(e, t);
              })(e)
            : e
        );
        return 'bytes' === (t || 'hex') ? n : n8(n);
      }
      class rP extends Map {
        constructor(e) {
          super(),
            Object.defineProperty(this, 'maxSize', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.maxSize = e);
        }
        get(e) {
          let t = super.get(e);
          return super.has(e) && void 0 !== t && (this.delete(e), super.set(e, t)), t;
        }
        set(e, t) {
          if ((super.set(e, t), this.maxSize && this.size > this.maxSize)) {
            let e = this.keys().next().value;
            e && this.delete(e);
          }
          return this;
        }
      }
      let rO = new rP(8192);
      async function rN({ hash: e, signature: t }) {
        let r = nY(e) ? e : n8(e),
          { secp256k1: i } = await n.e(4699).then(n.bind(n, 14699)),
          a = (() => {
            if ('object' == typeof t && 'r' in t && 's' in t) {
              let { r: e, s: n, v: r, yParity: a } = t,
                s = rx(Number(a ?? r));
              return new i.Signature(n6(e), n6(n)).addRecoveryBit(s);
            }
            let e = nY(t) ? t : n8(t),
              n = rx(
                (function (e, t = {}) {
                  return Number(n6(e, t));
                })(`0x${e.slice(130)}`)
              );
            return i.Signature.fromCompact(e.substring(2, 130)).addRecoveryBit(n);
          })()
            .recoverPublicKey(r.substring(2))
            .toHex(!1);
        return `0x${a}`;
      }
      function rx(e) {
        if (0 === e || 1 === e) return e;
        if (27 === e) return 0;
        if (28 === e) return 1;
        throw Error('Invalid yParityOrV value');
      }
      async function rM({ hash: e, signature: t }) {
        return (function (e) {
          let t = rS(`0x${e.substring(4)}`).substring(26);
          return (function (e, t) {
            if (rO.has(`${e}.undefined`)) return rO.get(`${e}.undefined`);
            let n = e.substring(2).toLowerCase(),
              r = rS(rr(n), 'bytes'),
              i = (t ? n.substring(`${t}0x`.length) : n).split('');
            for (let e = 0; e < 40; e += 2)
              r[e >> 1] >> 4 >= 8 && i[e] && (i[e] = i[e].toUpperCase()),
                (15 & r[e >> 1]) >= 8 && i[e + 1] && (i[e + 1] = i[e + 1].toUpperCase());
            let a = `0x${i.join('')}`;
            return rO.set(`${e}.${t}`, a), a;
          })(`0x${t}`);
        })(await rN({ hash: e, signature: t }));
      }
      var rk = n(96169);
      function rR(e = 0) {
        return null != globalThis.Buffer && null != globalThis.Buffer.allocUnsafe
          ? globalThis.Buffer.allocUnsafe(e)
          : new Uint8Array(e);
      }
      function rD(e, t) {
        t || (t = e.reduce((e, t) => e + t.length, 0));
        let n = rR(t),
          r = 0;
        for (let t of e) n.set(t, r), (r += t.length);
        return n;
      }
      var rB = function (e, t) {
        if (e.length >= 255) throw TypeError('Alphabet too long');
        for (var n = new Uint8Array(256), r = 0; r < n.length; r++) n[r] = 255;
        for (var i = 0; i < e.length; i++) {
          var a = e.charAt(i),
            s = a.charCodeAt(0);
          if (255 !== n[s]) throw TypeError(a + ' is ambiguous');
          n[s] = i;
        }
        var o = e.length,
          l = e.charAt(0),
          u = Math.log(o) / Math.log(256),
          c = Math.log(256) / Math.log(o);
        function d(e) {
          if ('string' != typeof e) throw TypeError('Expected String');
          if (0 === e.length) return new Uint8Array();
          var t = 0;
          if (' ' !== e[0]) {
            for (var r = 0, i = 0; e[t] === l; ) r++, t++;
            for (var a = ((e.length - t) * u + 1) >>> 0, s = new Uint8Array(a); e[t]; ) {
              var c = n[e.charCodeAt(t)];
              if (255 === c) return;
              for (var d = 0, p = a - 1; (0 !== c || d < i) && -1 !== p; p--, d++)
                (c += (o * s[p]) >>> 0), (s[p] = c % 256 >>> 0), (c = (c / 256) >>> 0);
              if (0 !== c) throw Error('Non-zero carry');
              (i = d), t++;
            }
            if (' ' !== e[t]) {
              for (var h = a - i; h !== a && 0 === s[h]; ) h++;
              for (var y = new Uint8Array(r + (a - h)), f = r; h !== a; ) y[f++] = s[h++];
              return y;
            }
          }
        }
        return {
          encode: function (t) {
            if (
              (t instanceof Uint8Array ||
                (ArrayBuffer.isView(t)
                  ? (t = new Uint8Array(t.buffer, t.byteOffset, t.byteLength))
                  : Array.isArray(t) && (t = Uint8Array.from(t))),
              !(t instanceof Uint8Array))
            )
              throw TypeError('Expected Uint8Array');
            if (0 === t.length) return '';
            for (var n = 0, r = 0, i = 0, a = t.length; i !== a && 0 === t[i]; ) i++, n++;
            for (var s = ((a - i) * c + 1) >>> 0, u = new Uint8Array(s); i !== a; ) {
              for (var d = t[i], p = 0, h = s - 1; (0 !== d || p < r) && -1 !== h; h--, p++)
                (d += (256 * u[h]) >>> 0), (u[h] = d % o >>> 0), (d = (d / o) >>> 0);
              if (0 !== d) throw Error('Non-zero carry');
              (r = p), i++;
            }
            for (var y = s - r; y !== s && 0 === u[y]; ) y++;
            for (var f = l.repeat(n); y < s; ++y) f += e.charAt(u[y]);
            return f;
          },
          decodeUnsafe: d,
          decode: function (e) {
            var n = d(e);
            if (n) return n;
            throw Error(`Non-${t} character`);
          },
        };
      };
      new Uint8Array(0);
      let rU = (e, t) => {
          if (e === t) return !0;
          if (e.byteLength !== t.byteLength) return !1;
          for (let n = 0; n < e.byteLength; n++) if (e[n] !== t[n]) return !1;
          return !0;
        },
        rL = (e) => {
          if (e instanceof Uint8Array && 'Uint8Array' === e.constructor.name) return e;
          if (e instanceof ArrayBuffer) return new Uint8Array(e);
          if (ArrayBuffer.isView(e)) return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
          throw Error('Unknown type, must be binary type');
        },
        rF = (e) => new TextEncoder().encode(e),
        rj = (e) => new TextDecoder().decode(e);
      class rq {
        constructor(e, t, n) {
          (this.name = e), (this.prefix = t), (this.baseEncode = n);
        }
        encode(e) {
          if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
          throw Error('Unknown type, must be binary type');
        }
      }
      class rV {
        constructor(e, t, n) {
          if (((this.name = e), (this.prefix = t), void 0 === t.codePointAt(0)))
            throw Error('Invalid prefix character');
          (this.prefixCodePoint = t.codePointAt(0)), (this.baseDecode = n);
        }
        decode(e) {
          if ('string' == typeof e) {
            if (e.codePointAt(0) !== this.prefixCodePoint)
              throw Error(
                `Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`
              );
            return this.baseDecode(e.slice(this.prefix.length));
          }
          throw Error('Can only multibase decode strings');
        }
        or(e) {
          return rz(this, e);
        }
      }
      class r$ {
        constructor(e) {
          this.decoders = e;
        }
        or(e) {
          return rz(this, e);
        }
        decode(e) {
          let t = e[0],
            n = this.decoders[t];
          if (n) return n.decode(e);
          throw RangeError(
            `Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`
          );
        }
      }
      let rz = (e, t) =>
        new r$({ ...(e.decoders || { [e.prefix]: e }), ...(t.decoders || { [t.prefix]: t }) });
      class rW {
        constructor(e, t, n, r) {
          (this.name = e),
            (this.prefix = t),
            (this.baseEncode = n),
            (this.baseDecode = r),
            (this.encoder = new rq(e, t, n)),
            (this.decoder = new rV(e, t, r));
        }
        encode(e) {
          return this.encoder.encode(e);
        }
        decode(e) {
          return this.decoder.decode(e);
        }
      }
      let rH = ({ name: e, prefix: t, encode: n, decode: r }) => new rW(e, t, n, r),
        rG = ({ prefix: e, name: t, alphabet: n }) => {
          let { encode: r, decode: i } = rB(n, t);
          return rH({ prefix: e, name: t, encode: r, decode: (e) => rL(i(e)) });
        },
        rK = (e, t, n, r) => {
          let i = {};
          for (let e = 0; e < t.length; ++e) i[t[e]] = e;
          let a = e.length;
          for (; '=' === e[a - 1]; ) --a;
          let s = new Uint8Array(((a * n) / 8) | 0),
            o = 0,
            l = 0,
            u = 0;
          for (let t = 0; t < a; ++t) {
            let a = i[e[t]];
            if (void 0 === a) throw SyntaxError(`Non-${r} character`);
            (l = (l << n) | a), (o += n) >= 8 && ((o -= 8), (s[u++] = 255 & (l >> o)));
          }
          if (o >= n || 255 & (l << (8 - o))) throw SyntaxError('Unexpected end of data');
          return s;
        },
        rQ = (e, t, n) => {
          let r = '=' === t[t.length - 1],
            i = (1 << n) - 1,
            a = '',
            s = 0,
            o = 0;
          for (let r = 0; r < e.length; ++r)
            for (o = (o << 8) | e[r], s += 8; s > n; ) (s -= n), (a += t[i & (o >> s)]);
          if ((s && (a += t[i & (o << (n - s))]), r)) for (; (a.length * n) & 7; ) a += '=';
          return a;
        },
        rY = ({ name: e, prefix: t, bitsPerChar: n, alphabet: r }) =>
          rH({ prefix: t, name: e, encode: (e) => rQ(e, r, n), decode: (t) => rK(t, r, n, e) }),
        rZ = rH({ prefix: '\0', name: 'identity', encode: (e) => rj(e), decode: (e) => rF(e) }),
        rJ = rY({ prefix: '0', name: 'base2', alphabet: '01', bitsPerChar: 1 }),
        rX = rY({ prefix: '7', name: 'base8', alphabet: '01234567', bitsPerChar: 3 }),
        r0 = rG({ prefix: '9', name: 'base10', alphabet: '0123456789' }),
        r1 = rY({ prefix: 'f', name: 'base16', alphabet: '0123456789abcdef', bitsPerChar: 4 }),
        r2 = rY({ prefix: 'F', name: 'base16upper', alphabet: '0123456789ABCDEF', bitsPerChar: 4 }),
        r6 = rY({
          prefix: 'b',
          name: 'base32',
          alphabet: 'abcdefghijklmnopqrstuvwxyz234567',
          bitsPerChar: 5,
        }),
        r5 = rY({
          prefix: 'B',
          name: 'base32upper',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
          bitsPerChar: 5,
        }),
        r8 = rY({
          prefix: 'c',
          name: 'base32pad',
          alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',
          bitsPerChar: 5,
        }),
        r3 = rY({
          prefix: 'C',
          name: 'base32padupper',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
          bitsPerChar: 5,
        }),
        r4 = rY({
          prefix: 'v',
          name: 'base32hex',
          alphabet: '0123456789abcdefghijklmnopqrstuv',
          bitsPerChar: 5,
        }),
        r9 = rY({
          prefix: 'V',
          name: 'base32hexupper',
          alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
          bitsPerChar: 5,
        }),
        r7 = rY({
          prefix: 't',
          name: 'base32hexpad',
          alphabet: '0123456789abcdefghijklmnopqrstuv=',
          bitsPerChar: 5,
        }),
        ie = rY({
          prefix: 'T',
          name: 'base32hexpadupper',
          alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
          bitsPerChar: 5,
        }),
        it = rY({
          prefix: 'h',
          name: 'base32z',
          alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',
          bitsPerChar: 5,
        }),
        ir = rG({ prefix: 'k', name: 'base36', alphabet: '0123456789abcdefghijklmnopqrstuvwxyz' }),
        ii = rG({
          prefix: 'K',
          name: 'base36upper',
          alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ',
        }),
        ia = rG({
          name: 'base58btc',
          prefix: 'z',
          alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz',
        }),
        is = rG({
          name: 'base58flickr',
          prefix: 'Z',
          alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ',
        }),
        io = rY({
          prefix: 'm',
          name: 'base64',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
          bitsPerChar: 6,
        }),
        il = rY({
          prefix: 'M',
          name: 'base64pad',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
          bitsPerChar: 6,
        }),
        iu = rY({
          prefix: 'u',
          name: 'base64url',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
          bitsPerChar: 6,
        }),
        ic = rY({
          prefix: 'U',
          name: 'base64urlpad',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
          bitsPerChar: 6,
        }),
        id = Array.from(
          '\uD83D\uDE80\uD83E\uDE90\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\uD83E\uDD19\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\uD83C\uDF1E\uD83C\uDF88\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\uD83D\uDC8E\uD83D\uDCB8\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42'
        ),
        ip = id.reduce((e, t, n) => ((e[n] = t), e), []),
        ih = id.reduce((e, t, n) => ((e[t.codePointAt(0)] = n), e), []),
        iy = rH({
          prefix: '\uD83D\uDE80',
          name: 'base256emoji',
          encode: function (e) {
            return e.reduce((e, t) => (e += ip[t]), '');
          },
          decode: function (e) {
            let t = [];
            for (let n of e) {
              let e = ih[n.codePointAt(0)];
              if (void 0 === e) throw Error(`Non-base256emoji character: ${n}`);
              t.push(e);
            }
            return new Uint8Array(t);
          },
        });
      var im = function e(t, n, r) {
          n = n || [];
          for (var i = (r = r || 0); t >= 2147483648; ) (n[r++] = (255 & t) | 128), (t /= 128);
          for (; -128 & t; ) (n[r++] = (255 & t) | 128), (t >>>= 7);
          return (n[r] = 0 | t), (e.bytes = r - i + 1), n;
        },
        ig = function e(t, n) {
          var r,
            i = 0,
            n = n || 0,
            a = 0,
            s = n,
            o = t.length;
          do {
            if (s >= o) throw ((e.bytes = 0), RangeError('Could not decode varint'));
            (r = t[s++]), (i += a < 28 ? (127 & r) << a : (127 & r) * Math.pow(2, a)), (a += 7);
          } while (r >= 128);
          return (e.bytes = s - n), i;
        };
      let ib = (e, t = 0) => [ig(e, t), ig.bytes],
        iw = (e, t, n = 0) => (im(e, t, n), t),
        iv = (e) =>
          e < 128
            ? 1
            : e < 16384
              ? 2
              : e < 2097152
                ? 3
                : e < 268435456
                  ? 4
                  : e < 34359738368
                    ? 5
                    : e < 4398046511104
                      ? 6
                      : e < 562949953421312
                        ? 7
                        : e < 72057594037927940
                          ? 8
                          : e < 0x7fffffffffffffff
                            ? 9
                            : 10,
        iT = (e, t) => {
          let n = t.byteLength,
            r = iv(e),
            i = r + iv(n),
            a = new Uint8Array(i + n);
          return iw(e, a, 0), iw(n, a, r), a.set(t, i), new iC(e, n, t, a);
        },
        iA = (e) => {
          let t = rL(e),
            [n, r] = ib(t),
            [i, a] = ib(t.subarray(r)),
            s = t.subarray(r + a);
          if (s.byteLength !== i) throw Error('Incorrect length');
          return new iC(n, i, s, t);
        },
        iE = (e, t) => e === t || (e.code === t.code && e.size === t.size && rU(e.bytes, t.bytes));
      class iC {
        constructor(e, t, n, r) {
          (this.code = e), (this.size = t), (this.digest = n), (this.bytes = r);
        }
      }
      let i_ = ({ name: e, code: t, encode: n }) => new iI(e, t, n);
      class iI {
        constructor(e, t, n) {
          (this.name = e), (this.code = t), (this.encode = n);
        }
        digest(e) {
          if (e instanceof Uint8Array) {
            let t = this.encode(e);
            return t instanceof Uint8Array ? iT(this.code, t) : t.then((e) => iT(this.code, e));
          }
          throw Error('Unknown type, must be binary type');
        }
      }
      let iS = (e) => async (t) => new Uint8Array(await crypto.subtle.digest(e, t)),
        iP = i_({ name: 'sha2-256', code: 18, encode: iS('SHA-256') }),
        iO = i_({ name: 'sha2-512', code: 19, encode: iS('SHA-512') }),
        iN = { code: 0, name: 'identity', encode: rL, digest: (e) => iT(0, rL(e)) },
        ix = 'raw',
        iM = 85,
        ik = (e) => rL(e),
        iR = (e) => rL(e),
        iD = new TextEncoder(),
        iB = new TextDecoder(),
        iU = 'json',
        iL = 512,
        iF = (e) => iD.encode(JSON.stringify(e)),
        ij = (e) => JSON.parse(iB.decode(e));
      class iq {
        constructor(e, t, n, r) {
          (this.code = t),
            (this.version = e),
            (this.multihash = n),
            (this.bytes = r),
            (this.byteOffset = r.byteOffset),
            (this.byteLength = r.byteLength),
            (this.asCID = this),
            (this._baseCache = new Map()),
            Object.defineProperties(this, {
              byteOffset: iY,
              byteLength: iY,
              code: iQ,
              version: iQ,
              multihash: iQ,
              bytes: iQ,
              _baseCache: iY,
              asCID: iY,
            });
        }
        toV0() {
          if (0 === this.version) return this;
          {
            let { code: e, multihash: t } = this;
            if (e !== iW) throw Error('Cannot convert a non dag-pb CID to CIDv0');
            if (t.code !== iH) throw Error('Cannot convert non sha2-256 multihash CID to CIDv0');
            return iq.createV0(t);
          }
        }
        toV1() {
          switch (this.version) {
            case 0: {
              let { code: e, digest: t } = this.multihash,
                n = iT(e, t);
              return iq.createV1(this.code, n);
            }
            case 1:
              return this;
            default:
              throw Error(
                `Can not convert CID version ${this.version} to version 0. This is a bug please report`
              );
          }
        }
        equals(e) {
          return (
            e &&
            this.code === e.code &&
            this.version === e.version &&
            iE(this.multihash, e.multihash)
          );
        }
        toString(e) {
          let { bytes: t, version: n, _baseCache: r } = this;
          return 0 === n ? i$(t, r, e || ia.encoder) : iz(t, r, e || r6.encoder);
        }
        toJSON() {
          return { code: this.code, version: this.version, hash: this.multihash.bytes };
        }
        get [Symbol.toStringTag]() {
          return 'CID';
        }
        [Symbol.for('nodejs.util.inspect.custom')]() {
          return 'CID(' + this.toString() + ')';
        }
        static isCID(e) {
          return iZ(/^0\.0/, iJ), !!(e && (e[iK] || e.asCID === e));
        }
        get toBaseEncodedString() {
          throw Error('Deprecated, use .toString()');
        }
        get codec() {
          throw Error('"codec" property is deprecated, use integer "code" property instead');
        }
        get buffer() {
          throw Error('Deprecated .buffer property, use .bytes to get Uint8Array instead');
        }
        get multibaseName() {
          throw Error('"multibaseName" property is deprecated');
        }
        get prefix() {
          throw Error('"prefix" property is deprecated');
        }
        static asCID(e) {
          if (e instanceof iq) return e;
          if (null != e && e.asCID === e) {
            let { version: t, code: n, multihash: r, bytes: i } = e;
            return new iq(t, n, r, i || iG(t, n, r.bytes));
          }
          if (null == e || !0 !== e[iK]) return null;
          {
            let { version: t, multihash: n, code: r } = e,
              i = iA(n);
            return iq.create(t, r, i);
          }
        }
        static create(e, t, n) {
          if ('number' != typeof t) throw Error('String codecs are no longer supported');
          switch (e) {
            case 0:
              if (t === iW) return new iq(e, t, n, n.bytes);
              throw Error(`Version 0 CID must use dag-pb (code: ${iW}) block encoding`);
            case 1: {
              let r = iG(e, t, n.bytes);
              return new iq(e, t, n, r);
            }
            default:
              throw Error('Invalid version');
          }
        }
        static createV0(e) {
          return iq.create(0, iW, e);
        }
        static createV1(e, t) {
          return iq.create(1, e, t);
        }
        static decode(e) {
          let [t, n] = iq.decodeFirst(e);
          if (n.length) throw Error('Incorrect length');
          return t;
        }
        static decodeFirst(e) {
          let t = iq.inspectBytes(e),
            n = t.size - t.multihashSize,
            r = rL(e.subarray(n, n + t.multihashSize));
          if (r.byteLength !== t.multihashSize) throw Error('Incorrect length');
          let i = r.subarray(t.multihashSize - t.digestSize),
            a = new iC(t.multihashCode, t.digestSize, i, r);
          return [0 === t.version ? iq.createV0(a) : iq.createV1(t.codec, a), e.subarray(t.size)];
        }
        static inspectBytes(e) {
          let t = 0,
            n = () => {
              let [n, r] = ib(e.subarray(t));
              return (t += r), n;
            },
            r = n(),
            i = iW;
          if ((18 === r ? ((r = 0), (t = 0)) : 1 === r && (i = n()), 0 !== r && 1 !== r))
            throw RangeError(`Invalid CID version ${r}`);
          let a = t,
            s = n(),
            o = n(),
            l = t + o;
          return {
            version: r,
            codec: i,
            multihashCode: s,
            digestSize: o,
            multihashSize: l - a,
            size: l,
          };
        }
        static parse(e, t) {
          let [n, r] = iV(e, t),
            i = iq.decode(r);
          return i._baseCache.set(n, e), i;
        }
      }
      let iV = (e, t) => {
          switch (e[0]) {
            case 'Q':
              return [ia.prefix, (t || ia).decode(`${ia.prefix}${e}`)];
            case ia.prefix:
              return [ia.prefix, (t || ia).decode(e)];
            case r6.prefix:
              return [r6.prefix, (t || r6).decode(e)];
            default:
              if (null == t)
                throw Error(
                  'To parse non base32 or base58btc encoded CID multibase decoder must be provided'
                );
              return [e[0], t.decode(e)];
          }
        },
        i$ = (e, t, n) => {
          let { prefix: r } = n;
          if (r !== ia.prefix) throw Error(`Cannot string encode V0 in ${n.name} encoding`);
          let i = t.get(r);
          if (null != i) return i;
          {
            let i = n.encode(e).slice(1);
            return t.set(r, i), i;
          }
        },
        iz = (e, t, n) => {
          let { prefix: r } = n,
            i = t.get(r);
          if (null != i) return i;
          {
            let i = n.encode(e);
            return t.set(r, i), i;
          }
        },
        iW = 112,
        iH = 18,
        iG = (e, t, n) => {
          let r = iv(e),
            i = r + iv(t),
            a = new Uint8Array(i + n.byteLength);
          return iw(e, a, 0), iw(t, a, r), a.set(n, i), a;
        },
        iK = Symbol.for('@ipld/js-cid/CID'),
        iQ = { writable: !1, configurable: !1, enumerable: !0 },
        iY = { writable: !1, enumerable: !1, configurable: !1 },
        iZ = (e, t) => {
          if (e.test('0.0.0-dev')) console.warn(t);
          else throw Error(t);
        },
        iJ = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`,
        iX = { ...i, ...a, ...s, ...o, ...l, ...u, ...c, ...d, ...p, ...h };
      function i0(e, t, n, r) {
        return {
          name: e,
          prefix: t,
          encoder: { name: e, prefix: t, encode: n },
          decoder: { decode: r },
        };
      }
      ({ ...y, ...f });
      let i1 = i0(
          'utf8',
          'u',
          (e) => 'u' + new TextDecoder('utf8').decode(e),
          (e) => new TextEncoder().encode(e.substring(1))
        ),
        i2 = i0(
          'ascii',
          'a',
          (e) => {
            let t = 'a';
            for (let n = 0; n < e.length; n++) t += String.fromCharCode(e[n]);
            return t;
          },
          (e) => {
            let t = rR((e = e.substring(1)).length);
            for (let n = 0; n < e.length; n++) t[n] = e.charCodeAt(n);
            return t;
          }
        ),
        i6 = { utf8: i1, 'utf-8': i1, hex: iX.base16, latin1: i2, ascii: i2, binary: i2, ...iX };
      function i5(e, t = 'utf8') {
        let n = i6[t];
        if (!n) throw Error(`Unsupported encoding "${t}"`);
        return ('utf8' === t || 'utf-8' === t) &&
          null != globalThis.Buffer &&
          null != globalThis.Buffer.from
          ? globalThis.Buffer.from(e, 'utf8')
          : n.decoder.decode(`${n.prefix}${e}`);
      }
      function i8(e, t = 'utf8') {
        let n = i6[t];
        if (!n) throw Error(`Unsupported encoding "${t}"`);
        return ('utf8' === t || 'utf-8' === t) &&
          null != globalThis.Buffer &&
          null != globalThis.Buffer.from
          ? globalThis.Buffer.from(e.buffer, e.byteOffset, e.byteLength).toString('utf8')
          : n.encoder.encode(e).substring(1);
      }
      let i3 = {
        waku: {
          publish: 'waku_publish',
          batchPublish: 'waku_batchPublish',
          subscribe: 'waku_subscribe',
          batchSubscribe: 'waku_batchSubscribe',
          subscription: 'waku_subscription',
          unsubscribe: 'waku_unsubscribe',
          batchUnsubscribe: 'waku_batchUnsubscribe',
          batchFetchMessages: 'waku_batchFetchMessages',
        },
        irn: {
          publish: 'irn_publish',
          batchPublish: 'irn_batchPublish',
          subscribe: 'irn_subscribe',
          batchSubscribe: 'irn_batchSubscribe',
          subscription: 'irn_subscription',
          unsubscribe: 'irn_unsubscribe',
          batchUnsubscribe: 'irn_batchUnsubscribe',
          batchFetchMessages: 'irn_batchFetchMessages',
        },
        iridium: {
          publish: 'iridium_publish',
          batchPublish: 'iridium_batchPublish',
          subscribe: 'iridium_subscribe',
          batchSubscribe: 'iridium_batchSubscribe',
          subscription: 'iridium_subscription',
          unsubscribe: 'iridium_unsubscribe',
          batchUnsubscribe: 'iridium_batchUnsubscribe',
          batchFetchMessages: 'iridium_batchFetchMessages',
        },
      };
      var i4 = n(32608),
        i9 = n(87150).Buffer;
      function i7(e) {
        let [t, n] = e.split(':');
        return { namespace: t, reference: n };
      }
      function ae(e, t) {
        return e.includes(':') ? [e] : t.chains || [];
      }
      var at = Object.defineProperty,
        an = Object.defineProperties,
        ar = Object.getOwnPropertyDescriptors,
        ai = Object.getOwnPropertySymbols,
        aa = Object.prototype.hasOwnProperty,
        as = Object.prototype.propertyIsEnumerable,
        ao = (e, t, n) =>
          t in e
            ? at(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        al = (e, t) => {
          for (var n in t || (t = {})) aa.call(t, n) && ao(e, n, t[n]);
          if (ai) for (var n of ai(t)) as.call(t, n) && ao(e, n, t[n]);
          return e;
        },
        au = (e, t) => an(e, ar(t));
      let ac = {
        reactNative: 'react-native',
        node: 'node',
        browser: 'browser',
        unknown: 'unknown',
      };
      function ad() {
        return 'u' > typeof i4 && 'u' > typeof i4.versions && 'u' > typeof i4.versions.node;
      }
      function ap() {
        return (
          !(0, nW.getDocument)() && !!(0, nW.getNavigator)() && 'ReactNative' === navigator.product
        );
      }
      function ah() {
        return !ad() && !!(0, nW.getNavigator)() && !!(0, nW.getDocument)();
      }
      function ay() {
        return ap() ? ac.reactNative : ad() ? ac.node : ah() ? ac.browser : ac.unknown;
      }
      function af() {
        var e;
        try {
          return ap() && 'u' > typeof n.g && 'u' > typeof (null == n.g ? void 0 : n.g.Application)
            ? null == (e = n.g.Application)
              ? void 0
              : e.applicationId
            : void 0;
        } catch {
          return;
        }
      }
      function am() {
        return (0, nH.D)() || { name: '', description: '', url: '', icons: [''] };
      }
      function ag(e, t, r) {
        let i = (function () {
            if (
              ay() === ac.reactNative &&
              'u' > typeof n.g &&
              'u' > typeof (null == n.g ? void 0 : n.g.Platform)
            ) {
              let { OS: e, Version: t } = n.g.Platform;
              return [e, t].join('-');
            }
            let e =
              'undefined' == typeof document &&
              'undefined' != typeof navigator &&
              'ReactNative' === navigator.product
                ? new nq()
                : 'undefined' != typeof navigator
                  ? (function (e) {
                      var t =
                        '' !== e &&
                        n$.reduce(function (t, n) {
                          var r = n[0],
                            i = n[1];
                          if (t) return t;
                          var a = i.exec(e);
                          return !!a && [r, a];
                        }, !1);
                      if (!t) return null;
                      var n = t[0],
                        r = t[1];
                      if ('searchbot' === n) return new nj();
                      var i = r[1] && r[1].split('.').join('_').split('_').slice(0, 3);
                      i
                        ? i.length < 3 &&
                          (i = nB(
                            nB([], i, !0),
                            (function (e) {
                              for (var t = [], n = 0; n < e; n++) t.push('0');
                              return t;
                            })(3 - i.length),
                            !0
                          ))
                        : (i = []);
                      var a = i.join('.'),
                        s = (function (e) {
                          for (var t = 0, n = nz.length; t < n; t++) {
                            var r = nz[t],
                              i = r[0];
                            if (r[1].exec(e)) return i;
                          }
                          return null;
                        })(e),
                        o = nV.exec(e);
                      return o && o[1] ? new nF(n, a, s, o[1]) : new nU(n, a, s);
                    })(navigator.userAgent)
                  : void 0 !== nD && nD.version
                    ? new nL(nD.version.slice(1))
                    : null;
            if (null === e) return 'unknown';
            let t = e.os ? e.os.replace(' ', '').toLowerCase() : 'unknown';
            return 'browser' === e.type
              ? [t, e.name, e.version].join('-')
              : [t, e.version].join('-');
          })(),
          a = (function () {
            var e;
            let t = ay();
            return t === ac.browser
              ? [t, (null == (e = (0, nW.getLocation)()) ? void 0 : e.host) || 'unknown'].join(':')
              : t;
          })();
        return [[e, t].join('-'), ['js', r].join('-'), i, a].join('/');
      }
      function ab(e, t) {
        return e.filter((e) => t.includes(e)).length === e.length;
      }
      function aw(e) {
        return Object.fromEntries(e.entries());
      }
      function av(e) {
        return new Map(Object.entries(e));
      }
      function aT(e = v.FIVE_MINUTES, t) {
        let n, r, i, a;
        let s = (0, v.toMiliseconds)(e || v.FIVE_MINUTES);
        return {
          resolve: (e) => {
            i && n && (clearTimeout(i), n(e), (a = Promise.resolve(e)));
          },
          reject: (e) => {
            i && r && (clearTimeout(i), r(e));
          },
          done: () =>
            new Promise((e, o) => {
              if (a) return e(a);
              (i = setTimeout(() => {
                let e = Error(t);
                (a = Promise.reject(e)), o(e);
              }, s)),
                (n = e),
                (r = o);
            }),
        };
      }
      function aA(e, t, n) {
        return new Promise(async (r, i) => {
          let a = setTimeout(() => i(Error(n)), t);
          try {
            let t = await e;
            r(t);
          } catch (e) {
            i(e);
          }
          clearTimeout(a);
        });
      }
      function aE(e, t) {
        if ('string' == typeof t && t.startsWith(`${e}:`)) return t;
        if ('topic' === e.toLowerCase()) {
          if ('string' != typeof t)
            throw Error('Value must be "string" for expirer target type: topic');
          return `topic:${t}`;
        }
        if ('id' === e.toLowerCase()) {
          if ('number' != typeof t)
            throw Error('Value must be "number" for expirer target type: id');
          return `id:${t}`;
        }
        throw Error(`Unknown expirer target type: ${e}`);
      }
      function aC(e) {
        let [t, n] = e.split(':'),
          r = { id: void 0, topic: void 0 };
        if ('topic' === t && 'string' == typeof n) r.topic = n;
        else if ('id' === t && Number.isInteger(Number(n))) r.id = Number(n);
        else throw Error(`Invalid target, expected id:number or topic:string, got ${t}:${n}`);
        return r;
      }
      function a_(e, t) {
        return (0, v.fromMiliseconds)((t || Date.now()) + (0, v.toMiliseconds)(e));
      }
      function aI(e) {
        return Date.now() >= (0, v.toMiliseconds)(e);
      }
      function aS(e, t) {
        return `${e}${t ? `:${t}` : ''}`;
      }
      function aP(e = [], t = []) {
        return [...new Set([...e, ...t])];
      }
      async function aO({ id: e, topic: t, wcDeepLink: r }) {
        var i;
        try {
          if (!r) return;
          let a = 'string' == typeof r ? JSON.parse(r) : r,
            s = a?.href;
          if ('string' != typeof s) return;
          let o = (function (e, t, n) {
              let r = `requestId=${t}&sessionTopic=${n}`;
              e.endsWith('/') && (e = e.slice(0, -1));
              let i = `${e}`;
              if (e.startsWith('https://t.me')) {
                let t = e.includes('?') ? '&startapp=' : '?startapp=';
                i = `${i}${t}${(function (e, t = !1) {
                  let n = i9.from(e).toString('base64');
                  return t ? n.replace(/[=]/g, '') : n;
                })(r, !0)}`;
              } else i = `${i}/wc?${r}`;
              return i;
            })(s, e, t),
            l = ay();
          if (l === ac.browser) {
            let e;
            if (!(null != (i = (0, nW.getDocument)()) && i.hasFocus())) {
              console.warn('Document does not have focus, skipping deeplink.');
              return;
            }
            (e = '_self'),
              (function () {
                try {
                  return window.self !== window.top;
                } catch {
                  return !1;
                }
              })()
                ? (e = '_top')
                : (('u' > typeof window &&
                    (!!window.TelegramWebviewProxy ||
                      !!window.Telegram ||
                      !!window.TelegramWebviewProxyProto)) ||
                    o.startsWith('https://') ||
                    o.startsWith('http://')) &&
                  (e = '_blank'),
              window.open(o, e, 'noreferrer noopener');
          } else
            l === ac.reactNative &&
              'u' > typeof (null == n.g ? void 0 : n.g.Linking) &&
              (await n.g.Linking.openURL(o));
        } catch (e) {
          console.error(e);
        }
      }
      async function aN(e, t) {
        let n = '';
        try {
          if (ah() && (n = localStorage.getItem(t))) return n;
          n = await e.getItem(t);
        } catch (e) {
          console.error(e);
        }
        return n;
      }
      function ax(e, t) {
        if (!e.includes(t)) return null;
        let n = e.split(/([&,?,=])/),
          r = n.indexOf(t);
        return n[r + 2];
      }
      function aM() {
        return 'u' > typeof crypto && null != crypto && crypto.randomUUID
          ? crypto.randomUUID()
          : 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/gu, (e) => {
              let t = (16 * Math.random()) | 0;
              return ('x' === e ? t : (3 & t) | 8).toString(16);
            });
      }
      function ak() {
        return 'u' > typeof i4 && 'true' === i4.env.IS_VITEST;
      }
      function aR(e) {
        return i9.from(e, 'base64').toString('utf-8');
      }
      function aD(e) {
        if (!Number.isSafeInteger(e) || e < 0) throw Error('positive integer expected, got ' + e);
      }
      function aB(e, ...t) {
        if (
          !(
            e instanceof Uint8Array ||
            (ArrayBuffer.isView(e) && 'Uint8Array' === e.constructor.name)
          )
        )
          throw Error('Uint8Array expected');
        if (t.length > 0 && !t.includes(e.length))
          throw Error('Uint8Array expected of length ' + t + ', got length=' + e.length);
      }
      function aU(e) {
        if ('function' != typeof e || 'function' != typeof e.create)
          throw Error('Hash should be wrapped by utils.wrapConstructor');
        aD(e.outputLen), aD(e.blockLen);
      }
      function aL(e, t = !0) {
        if (e.destroyed) throw Error('Hash instance has been destroyed');
        if (t && e.finished) throw Error('Hash#digest() has already been called');
      }
      function aF(e, t) {
        aB(e);
        let n = t.outputLen;
        if (e.length < n) throw Error('digestInto() expects output buffer of length at least ' + n);
      }
      let aj = BigInt(4294967296 - 1),
        aq = BigInt(32),
        aV = (e, t, n) => (e << n) | (t >>> (32 - n)),
        a$ = (e, t, n) => (t << n) | (e >>> (32 - n)),
        az = (e, t, n) => (t << (n - 32)) | (e >>> (64 - n)),
        aW = (e, t, n) => (e << (n - 32)) | (t >>> (64 - n)),
        aH = 'object' == typeof globalThis && 'crypto' in globalThis ? globalThis.crypto : void 0;
      function aG(e) {
        return new DataView(e.buffer, e.byteOffset, e.byteLength);
      }
      function aK(e, t) {
        return (e << (32 - t)) | (e >>> t);
      }
      let aQ = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0];
      function aY(e) {
        for (let n = 0; n < e.length; n++) {
          var t;
          e[n] =
            (((t = e[n]) << 24) & 4278190080) |
            ((t << 8) & 16711680) |
            ((t >>> 8) & 65280) |
            ((t >>> 24) & 255);
        }
      }
      function aZ(e) {
        return (
          'string' == typeof e &&
            (e = (function (e) {
              if ('string' != typeof e) throw Error('utf8ToBytes expected string, got ' + typeof e);
              return new Uint8Array(new TextEncoder().encode(e));
            })(e)),
          aB(e),
          e
        );
      }
      class aJ {
        clone() {
          return this._cloneInto();
        }
      }
      function aX(e) {
        let t = (t) => e().update(aZ(t)).digest(),
          n = e();
        return (t.outputLen = n.outputLen), (t.blockLen = n.blockLen), (t.create = () => e()), t;
      }
      function a0(e = 32) {
        if (aH && 'function' == typeof aH.getRandomValues)
          return aH.getRandomValues(new Uint8Array(e));
        if (aH && 'function' == typeof aH.randomBytes) return aH.randomBytes(e);
        throw Error('crypto.getRandomValues must be defined');
      }
      let a1 = [],
        a2 = [],
        a6 = [],
        a5 = BigInt(0),
        a8 = BigInt(1),
        a3 = BigInt(2),
        a4 = BigInt(7),
        a9 = BigInt(256),
        a7 = BigInt(113);
      for (let e = 0, t = a8, n = 1, r = 0; e < 24; e++) {
        ([n, r] = [r, (2 * n + 3 * r) % 5]),
          a1.push(2 * (5 * r + n)),
          a2.push((((e + 1) * (e + 2)) / 2) % 64);
        let i = a5;
        for (let e = 0; e < 7; e++)
          (t = ((t << a8) ^ ((t >> a4) * a7)) % a9) & a3 && (i ^= a8 << ((a8 << BigInt(e)) - a8));
        a6.push(i);
      }
      let [se, st] = (function (e, t = !1) {
          let n = new Uint32Array(e.length),
            r = new Uint32Array(e.length);
          for (let i = 0; i < e.length; i++) {
            let { h: a, l: s } = (function (e, t = !1) {
              return t
                ? { h: Number(e & aj), l: Number((e >> aq) & aj) }
                : { h: 0 | Number((e >> aq) & aj), l: 0 | Number(e & aj) };
            })(e[i], t);
            [n[i], r[i]] = [a, s];
          }
          return [n, r];
        })(a6, !0),
        sn = (e, t, n) => (n > 32 ? az(e, t, n) : aV(e, t, n)),
        sr = (e, t, n) => (n > 32 ? aW(e, t, n) : a$(e, t, n));
      class si extends aJ {
        constructor(e, t, n, r = !1, i = 24) {
          var a;
          if (
            (super(),
            (this.blockLen = e),
            (this.suffix = t),
            (this.outputLen = n),
            (this.enableXOF = r),
            (this.rounds = i),
            (this.pos = 0),
            (this.posOut = 0),
            (this.finished = !1),
            (this.destroyed = !1),
            aD(n),
            0 >= this.blockLen || this.blockLen >= 200)
          )
            throw Error('Sha3 supports only keccak-f1600 function');
          (this.state = new Uint8Array(200)),
            (this.state32 = new Uint32Array(
              (a = this.state).buffer,
              a.byteOffset,
              Math.floor(a.byteLength / 4)
            ));
        }
        keccak() {
          aQ || aY(this.state32),
            (function (e, t = 24) {
              let n = new Uint32Array(10);
              for (let r = 24 - t; r < 24; r++) {
                for (let t = 0; t < 10; t++)
                  n[t] = e[t] ^ e[t + 10] ^ e[t + 20] ^ e[t + 30] ^ e[t + 40];
                for (let t = 0; t < 10; t += 2) {
                  let r = (t + 8) % 10,
                    i = (t + 2) % 10,
                    a = n[i],
                    s = n[i + 1],
                    o = sn(a, s, 1) ^ n[r],
                    l = sr(a, s, 1) ^ n[r + 1];
                  for (let n = 0; n < 50; n += 10) (e[t + n] ^= o), (e[t + n + 1] ^= l);
                }
                let t = e[2],
                  i = e[3];
                for (let n = 0; n < 24; n++) {
                  let r = a2[n],
                    a = sn(t, i, r),
                    s = sr(t, i, r),
                    o = a1[n];
                  (t = e[o]), (i = e[o + 1]), (e[o] = a), (e[o + 1] = s);
                }
                for (let t = 0; t < 50; t += 10) {
                  for (let r = 0; r < 10; r++) n[r] = e[t + r];
                  for (let r = 0; r < 10; r++) e[t + r] ^= ~n[(r + 2) % 10] & n[(r + 4) % 10];
                }
                (e[0] ^= se[r]), (e[1] ^= st[r]);
              }
              n.fill(0);
            })(this.state32, this.rounds),
            aQ || aY(this.state32),
            (this.posOut = 0),
            (this.pos = 0);
        }
        update(e) {
          aL(this);
          let { blockLen: t, state: n } = this,
            r = (e = aZ(e)).length;
          for (let i = 0; i < r; ) {
            let a = Math.min(t - this.pos, r - i);
            for (let t = 0; t < a; t++) n[this.pos++] ^= e[i++];
            this.pos === t && this.keccak();
          }
          return this;
        }
        finish() {
          if (this.finished) return;
          this.finished = !0;
          let { state: e, suffix: t, pos: n, blockLen: r } = this;
          (e[n] ^= t),
            (128 & t) != 0 && n === r - 1 && this.keccak(),
            (e[r - 1] ^= 128),
            this.keccak();
        }
        writeInto(e) {
          aL(this, !1), aB(e), this.finish();
          let t = this.state,
            { blockLen: n } = this;
          for (let r = 0, i = e.length; r < i; ) {
            this.posOut >= n && this.keccak();
            let a = Math.min(n - this.posOut, i - r);
            e.set(t.subarray(this.posOut, this.posOut + a), r), (this.posOut += a), (r += a);
          }
          return e;
        }
        xofInto(e) {
          if (!this.enableXOF) throw Error('XOF is not possible for this instance');
          return this.writeInto(e);
        }
        xof(e) {
          return aD(e), this.xofInto(new Uint8Array(e));
        }
        digestInto(e) {
          if ((aF(e, this), this.finished)) throw Error('digest() was already called');
          return this.writeInto(e), this.destroy(), e;
        }
        digest() {
          return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
          (this.destroyed = !0), this.state.fill(0);
        }
        _cloneInto(e) {
          let { blockLen: t, suffix: n, outputLen: r, rounds: i, enableXOF: a } = this;
          return (
            e || (e = new si(t, n, r, a, i)),
            e.state32.set(this.state32),
            (e.pos = this.pos),
            (e.posOut = this.posOut),
            (e.finished = this.finished),
            (e.rounds = i),
            (e.suffix = n),
            (e.outputLen = r),
            (e.enableXOF = a),
            (e.destroyed = this.destroyed),
            e
          );
        }
      }
      let sa = aX(() => new si(136, 1, 32));
      function ss(e) {
        let t = `Ethereum Signed Message:
${e.length}`,
          n = new TextEncoder().encode(t + e);
        return '0x' + i9.from(sa(n)).toString('hex');
      }
      async function so(e, t, n, r, i, a) {
        switch (n.t) {
          case 'eip191':
            return await sl(e, t, n.s);
          case 'eip1271':
            return await su(e, t, n.s, r, i, a);
          default:
            throw Error(
              `verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${n.t}`
            );
        }
      }
      async function sl(e, t, n) {
        return (await rM({ hash: ss(t), signature: n })).toLowerCase() === e.toLowerCase();
      }
      async function su(e, t, n, r, i, a) {
        let s = i7(r);
        if (!s.namespace || !s.reference)
          throw Error(
            `isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${r}`
          );
        try {
          let s = '0x1626ba7e',
            o = n.substring(2),
            l = ss(t).substring(2),
            u = await fetch(
              `${a || 'https://rpc.walletconnect.org/v1'}/?chainId=${r}&projectId=${i}`,
              {
                method: 'POST',
                body: JSON.stringify({
                  id: Date.now() + Math.floor(1e3 * Math.random()),
                  jsonrpc: '2.0',
                  method: 'eth_call',
                  params: [
                    {
                      to: e,
                      data:
                        s +
                        l +
                        '00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000041' +
                        o,
                    },
                    'latest',
                  ],
                }),
              }
            ),
            { result: c } = await u.json();
          return !!c && c.slice(0, s.length).toLowerCase() === s.toLowerCase();
        } catch (e) {
          return console.error('isValidEip1271Signature: ', e), !1;
        }
      }
      var sc = Object.defineProperty,
        sd = Object.defineProperties,
        sp = Object.getOwnPropertyDescriptors,
        sh = Object.getOwnPropertySymbols,
        sy = Object.prototype.hasOwnProperty,
        sf = Object.prototype.propertyIsEnumerable,
        sm = (e, t, n) =>
          t in e
            ? sc(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        sg = (e, t) => {
          for (var n in t || (t = {})) sy.call(t, n) && sm(e, n, t[n]);
          if (sh) for (var n of sh(t)) sf.call(t, n) && sm(e, n, t[n]);
          return e;
        },
        sb = (e, t) => sd(e, sp(t));
      let sw = (e) => e?.split(':'),
        sv = (e) => {
          let t = e && sw(e);
          if (t) return e.includes('did:pkh:') ? t[3] : t[1];
        },
        sT = (e) => {
          let t = e && sw(e);
          if (t) return t[2] + ':' + t[3];
        },
        sA = (e) => {
          let t = e && sw(e);
          if (t) return t.pop();
        };
      async function sE(e) {
        let { cacao: t, projectId: n } = e,
          { s: r, p: i } = t,
          a = sC(i, i.iss),
          s = sA(i.iss);
        return await so(s, a, r, sT(i.iss), n);
      }
      let sC = (e, t) => {
        let n = `${e.domain} wants you to sign in with your Ethereum account:`,
          r = sA(t);
        if (!e.aud && !e.uri)
          throw Error('Either `aud` or `uri` is required to construct the message');
        let i = e.statement || void 0,
          a = `URI: ${e.aud || e.uri}`,
          s = `Version: ${e.version}`,
          o = `Chain ID: ${sv(t)}`,
          l = `Nonce: ${e.nonce}`,
          u = `Issued At: ${e.iat}`,
          c = e.exp ? `Expiration Time: ${e.exp}` : void 0,
          d = e.nbf ? `Not Before: ${e.nbf}` : void 0,
          p = e.requestId ? `Request ID: ${e.requestId}` : void 0,
          h = e.resources
            ? `Resources:${e.resources
                .map(
                  (e) => `
- ${e}`
                )
                .join('')}`
            : void 0,
          y = sN(e.resources);
        return (
          y &&
            (i = (function (e = '', t) {
              s_(t);
              let n =
                'I further authorize the stated URI to perform the following actions on my behalf: ';
              if (e.includes(n)) return e;
              let r = [],
                i = 0;
              Object.keys(t.att).forEach((e) => {
                let n = Object.keys(t.att[e]).map((e) => ({
                  ability: e.split('/')[0],
                  action: e.split('/')[1],
                }));
                n.sort((e, t) => e.action.localeCompare(t.action));
                let a = {};
                n.forEach((e) => {
                  a[e.ability] || (a[e.ability] = []), a[e.ability].push(e.action);
                });
                let s = Object.keys(a).map(
                  (t) => (i++, `(${i}) '${t}': '${a[t].join("', '")}' for '${e}'.`)
                );
                r.push(s.join(', ').replace('.,', '.'));
              });
              let a = r.join(' '),
                s = `${n}${a}`;
              return `${e ? e + ' ' : ''}${s}`;
            })(i, sS(y))),
          [n, r, '', i, '', a, s, o, l, u, c, d, p, h].filter((e) => null != e).join(`
`)
        );
      };
      function s_(e) {
        if (!e) throw Error('No recap provided, value is undefined');
        if (!e.att) throw Error('No `att` property found');
        let t = Object.keys(e.att);
        if (!(null != t && t.length)) throw Error('No resources found in `att` property');
        t.forEach((t) => {
          let n = e.att[t];
          if (Array.isArray(n) || 'object' != typeof n)
            throw Error(`Resource must be an object: ${t}`);
          if (!Object.keys(n).length) throw Error(`Resource object is empty: ${t}`);
          Object.keys(n).forEach((e) => {
            let t = n[e];
            if (!Array.isArray(t))
              throw Error(`Ability limits ${e} must be an array of objects, found: ${t}`);
            if (!t.length)
              throw Error(`Value of ${e} is empty array, must be an array with objects`);
            t.forEach((t) => {
              if ('object' != typeof t)
                throw Error(`Ability limits (${e}) must be an array of objects, found: ${t}`);
            });
          });
        });
      }
      function sI(e) {
        return (
          s_(e), `urn:recap:${i9.from(JSON.stringify(e)).toString('base64').replace(/=/g, '')}`
        );
      }
      function sS(e) {
        var t;
        let n =
          ((t = e.replace('urn:recap:', '')), JSON.parse(i9.from(t, 'base64').toString('utf-8')));
        return s_(n), n;
      }
      function sP(e) {
        var t;
        let n = sS(e);
        s_(n);
        let r = null == (t = n.att) ? void 0 : t.eip155;
        return r ? Object.keys(r).map((e) => e.split('/')[1]) : [];
      }
      function sO(e) {
        let t = sS(e);
        s_(t);
        let n = [];
        return (
          Object.values(t.att).forEach((e) => {
            Object.values(e).forEach((e) => {
              var t;
              null != (t = e?.[0]) && t.chains && n.push(e[0].chains);
            });
          }),
          [...new Set(n.flat())]
        );
      }
      function sN(e) {
        if (!e) return;
        let t = e?.[e.length - 1];
        return t && t.includes('urn:recap:') ? t : void 0;
      }
      function sx(e) {
        if (!Number.isSafeInteger(e) || e < 0) throw Error('positive integer expected, got ' + e);
      }
      function sM(e) {
        return (
          e instanceof Uint8Array || (ArrayBuffer.isView(e) && 'Uint8Array' === e.constructor.name)
        );
      }
      function sk(e, ...t) {
        if (!sM(e)) throw Error('Uint8Array expected');
        if (t.length > 0 && !t.includes(e.length))
          throw Error('Uint8Array expected of length ' + t + ', got length=' + e.length);
      }
      function sR(e, t = !0) {
        if (e.destroyed) throw Error('Hash instance has been destroyed');
        if (t && e.finished) throw Error('Hash#digest() has already been called');
      }
      function sD(e) {
        if ('boolean' != typeof e) throw Error(`boolean expected, not ${e}`);
      }
      let sB = (e) => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)),
        sU = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength);
      if (68 !== new Uint8Array(new Uint32Array([287454020]).buffer)[0])
        throw Error('Non little-endian hardware is not supported');
      function sL(e) {
        if ('string' == typeof e)
          e = (function (e) {
            if ('string' != typeof e) throw Error('string expected');
            return new Uint8Array(new TextEncoder().encode(e));
          })(e);
        else if (sM(e)) e = sq(e);
        else throw Error('Uint8Array expected, got ' + typeof e);
        return e;
      }
      function sF(e, t, n = !0) {
        if (void 0 === t) return new Uint8Array(e);
        if (t.length !== e)
          throw Error('invalid output length, expected ' + e + ', got: ' + t.length);
        if (n && t.byteOffset % 4 != 0) throw Error('invalid output, must be aligned');
        return t;
      }
      function sj(e, t, n, r) {
        if ('function' == typeof e.setBigUint64) return e.setBigUint64(t, n, r);
        let i = BigInt(32),
          a = BigInt(4294967295),
          s = Number((n >> i) & a),
          o = Number(n & a),
          l = r ? 4 : 0,
          u = r ? 0 : 4;
        e.setUint32(t + l, s, r), e.setUint32(t + u, o, r);
      }
      function sq(e) {
        return Uint8Array.from(e);
      }
      function sV(...e) {
        for (let t = 0; t < e.length; t++) e[t].fill(0);
      }
      let s$ = (e) => Uint8Array.from(e.split('').map((e) => e.charCodeAt(0))),
        sz = s$('expand 16-byte k'),
        sW = s$('expand 32-byte k'),
        sH = sB(sz),
        sG = sB(sW);
      function sK(e, t) {
        return (e << t) | (e >>> (32 - t));
      }
      function sQ(e) {
        return e.byteOffset % 4 == 0;
      }
      let sY = 4294967296 - 1,
        sZ = new Uint32Array(),
        sJ = (e, t) => (255 & e[t++]) | ((255 & e[t++]) << 8);
      class sX {
        constructor(e) {
          (this.blockLen = 16),
            (this.outputLen = 16),
            (this.buffer = new Uint8Array(16)),
            (this.r = new Uint16Array(10)),
            (this.h = new Uint16Array(10)),
            (this.pad = new Uint16Array(8)),
            (this.pos = 0),
            (this.finished = !1),
            sk((e = sL(e)), 32);
          let t = sJ(e, 0),
            n = sJ(e, 2),
            r = sJ(e, 4),
            i = sJ(e, 6),
            a = sJ(e, 8),
            s = sJ(e, 10),
            o = sJ(e, 12),
            l = sJ(e, 14);
          (this.r[0] = 8191 & t),
            (this.r[1] = ((t >>> 13) | (n << 3)) & 8191),
            (this.r[2] = ((n >>> 10) | (r << 6)) & 7939),
            (this.r[3] = ((r >>> 7) | (i << 9)) & 8191),
            (this.r[4] = ((i >>> 4) | (a << 12)) & 255),
            (this.r[5] = (a >>> 1) & 8190),
            (this.r[6] = ((a >>> 14) | (s << 2)) & 8191),
            (this.r[7] = ((s >>> 11) | (o << 5)) & 8065),
            (this.r[8] = ((o >>> 8) | (l << 8)) & 8191),
            (this.r[9] = (l >>> 5) & 127);
          for (let t = 0; t < 8; t++) this.pad[t] = sJ(e, 16 + 2 * t);
        }
        process(e, t, n = !1) {
          let { h: r, r: i } = this,
            a = i[0],
            s = i[1],
            o = i[2],
            l = i[3],
            u = i[4],
            c = i[5],
            d = i[6],
            p = i[7],
            h = i[8],
            y = i[9],
            f = sJ(e, t + 0),
            m = sJ(e, t + 2),
            g = sJ(e, t + 4),
            b = sJ(e, t + 6),
            w = sJ(e, t + 8),
            v = sJ(e, t + 10),
            T = sJ(e, t + 12),
            A = sJ(e, t + 14),
            E = r[0] + (8191 & f),
            C = r[1] + (((f >>> 13) | (m << 3)) & 8191),
            _ = r[2] + (((m >>> 10) | (g << 6)) & 8191),
            I = r[3] + (((g >>> 7) | (b << 9)) & 8191),
            S = r[4] + (((b >>> 4) | (w << 12)) & 8191),
            P = r[5] + ((w >>> 1) & 8191),
            O = r[6] + (((w >>> 14) | (v << 2)) & 8191),
            N = r[7] + (((v >>> 11) | (T << 5)) & 8191),
            x = r[8] + (((T >>> 8) | (A << 8)) & 8191),
            M = r[9] + ((A >>> 5) | (n ? 0 : 2048)),
            k = 0,
            R = 0 + E * a + 5 * y * C + 5 * h * _ + 5 * p * I + 5 * d * S;
          (k = R >>> 13),
            (R &= 8191),
            (R += 5 * c * P + 5 * u * O + 5 * l * N + 5 * o * x + 5 * s * M),
            (k += R >>> 13),
            (R &= 8191);
          let D = k + E * s + C * a + 5 * y * _ + 5 * h * I + 5 * p * S;
          (k = D >>> 13),
            (D &= 8191),
            (D += 5 * d * P + 5 * c * O + 5 * u * N + 5 * l * x + 5 * o * M),
            (k += D >>> 13),
            (D &= 8191);
          let B = k + E * o + C * s + _ * a + 5 * y * I + 5 * h * S;
          (k = B >>> 13),
            (B &= 8191),
            (B += 5 * p * P + 5 * d * O + 5 * c * N + 5 * u * x + 5 * l * M),
            (k += B >>> 13),
            (B &= 8191);
          let U = k + E * l + C * o + _ * s + I * a + 5 * y * S;
          (k = U >>> 13),
            (U &= 8191),
            (U += 5 * h * P + 5 * p * O + 5 * d * N + 5 * c * x + 5 * u * M),
            (k += U >>> 13),
            (U &= 8191);
          let L = k + E * u + C * l + _ * o + I * s + S * a;
          (k = L >>> 13),
            (L &= 8191),
            (L += 5 * y * P + 5 * h * O + 5 * p * N + 5 * d * x + 5 * c * M),
            (k += L >>> 13),
            (L &= 8191);
          let F = k + E * c + C * u + _ * l + I * o + S * s;
          (k = F >>> 13),
            (F &= 8191),
            (F += P * a + 5 * y * O + 5 * h * N + 5 * p * x + 5 * d * M),
            (k += F >>> 13),
            (F &= 8191);
          let j = k + E * d + C * c + _ * u + I * l + S * o;
          (k = j >>> 13),
            (j &= 8191),
            (j += P * s + O * a + 5 * y * N + 5 * h * x + 5 * p * M),
            (k += j >>> 13),
            (j &= 8191);
          let q = k + E * p + C * d + _ * c + I * u + S * l;
          (k = q >>> 13),
            (q &= 8191),
            (q += P * o + O * s + N * a + 5 * y * x + 5 * h * M),
            (k += q >>> 13),
            (q &= 8191);
          let V = k + E * h + C * p + _ * d + I * c + S * u;
          (k = V >>> 13),
            (V &= 8191),
            (V += P * l + O * o + N * s + x * a + 5 * y * M),
            (k += V >>> 13),
            (V &= 8191);
          let $ = k + E * y + C * h + _ * p + I * d + S * c;
          (k = $ >>> 13),
            ($ &= 8191),
            ($ += P * u + O * l + N * o + x * s + M * a),
            (k += $ >>> 13),
            ($ &= 8191),
            (R = 8191 & (k = ((k = ((k << 2) + k) | 0) + R) | 0)),
            (k >>>= 13),
            (D += k),
            (r[0] = R),
            (r[1] = D),
            (r[2] = B),
            (r[3] = U),
            (r[4] = L),
            (r[5] = F),
            (r[6] = j),
            (r[7] = q),
            (r[8] = V),
            (r[9] = $);
        }
        finalize() {
          let { h: e, pad: t } = this,
            n = new Uint16Array(10),
            r = e[1] >>> 13;
          e[1] &= 8191;
          for (let t = 2; t < 10; t++) (e[t] += r), (r = e[t] >>> 13), (e[t] &= 8191);
          (e[0] += 5 * r),
            (r = e[0] >>> 13),
            (e[0] &= 8191),
            (e[1] += r),
            (r = e[1] >>> 13),
            (e[1] &= 8191),
            (e[2] += r),
            (n[0] = e[0] + 5),
            (r = n[0] >>> 13),
            (n[0] &= 8191);
          for (let t = 1; t < 10; t++) (n[t] = e[t] + r), (r = n[t] >>> 13), (n[t] &= 8191);
          n[9] -= 8192;
          let i = (1 ^ r) - 1;
          for (let e = 0; e < 10; e++) n[e] &= i;
          i = ~i;
          for (let t = 0; t < 10; t++) e[t] = (e[t] & i) | n[t];
          (e[0] = (e[0] | (e[1] << 13)) & 65535),
            (e[1] = ((e[1] >>> 3) | (e[2] << 10)) & 65535),
            (e[2] = ((e[2] >>> 6) | (e[3] << 7)) & 65535),
            (e[3] = ((e[3] >>> 9) | (e[4] << 4)) & 65535),
            (e[4] = ((e[4] >>> 12) | (e[5] << 1) | (e[6] << 14)) & 65535),
            (e[5] = ((e[6] >>> 2) | (e[7] << 11)) & 65535),
            (e[6] = ((e[7] >>> 5) | (e[8] << 8)) & 65535),
            (e[7] = ((e[8] >>> 8) | (e[9] << 5)) & 65535);
          let a = e[0] + t[0];
          e[0] = 65535 & a;
          for (let n = 1; n < 8; n++)
            (a = (((e[n] + t[n]) | 0) + (a >>> 16)) | 0), (e[n] = 65535 & a);
          sV(n);
        }
        update(e) {
          sR(this);
          let { buffer: t, blockLen: n } = this,
            r = (e = sL(e)).length;
          for (let i = 0; i < r; ) {
            let a = Math.min(n - this.pos, r - i);
            if (a === n) {
              for (; n <= r - i; i += n) this.process(e, i);
              continue;
            }
            t.set(e.subarray(i, i + a), this.pos),
              (this.pos += a),
              (i += a),
              this.pos === n && (this.process(t, 0, !1), (this.pos = 0));
          }
          return this;
        }
        destroy() {
          sV(this.h, this.r, this.buffer, this.pad);
        }
        digestInto(e) {
          sR(this),
            (function (e, t) {
              sk(e);
              let n = t.outputLen;
              if (e.length < n)
                throw Error('digestInto() expects output buffer of length at least ' + n);
            })(e, this),
            (this.finished = !0);
          let { buffer: t, h: n } = this,
            { pos: r } = this;
          if (r) {
            for (t[r++] = 1; r < 16; r++) t[r] = 0;
            this.process(t, 0, !0);
          }
          this.finalize();
          let i = 0;
          for (let t = 0; t < 8; t++) (e[i++] = n[t] >>> 0), (e[i++] = n[t] >>> 8);
          return e;
        }
        digest() {
          let { buffer: e, outputLen: t } = this;
          this.digestInto(e);
          let n = e.slice(0, t);
          return this.destroy(), n;
        }
      }
      let s0 = (function (e) {
          let t = (t, n) => e(n).update(sL(t)).digest(),
            n = e(new Uint8Array(32));
          return (
            (t.outputLen = n.outputLen), (t.blockLen = n.blockLen), (t.create = (t) => e(t)), t
          );
        })((e) => new sX(e)),
        s1 = (function (e, t) {
          let {
            allowShortKeys: n,
            extendNonceFn: r,
            counterLength: i,
            counterRight: a,
            rounds: s,
          } = (function (e, t) {
            if (null == t || 'object' != typeof t) throw Error('options must be defined');
            return Object.assign(e, t);
          })({ allowShortKeys: !1, counterLength: 8, counterRight: !1, rounds: 20 }, t);
          if ('function' != typeof e) throw Error('core must be a function');
          return (
            sx(i),
            sx(s),
            sD(a),
            sD(n),
            (t, o, l, u, c = 0) => {
              sk(t), sk(o), sk(l);
              let d = l.length;
              if ((void 0 === u && (u = new Uint8Array(d)), sk(u), sx(c), c < 0 || c >= sY))
                throw Error('arx: counter overflow');
              if (u.length < d)
                throw Error(`arx: output (${u.length}) is shorter than data (${d})`);
              let p = [],
                h = t.length,
                y,
                f;
              if (32 === h) p.push((y = sq(t))), (f = sG);
              else if (16 === h && n)
                (y = new Uint8Array(32)).set(t), y.set(t, 16), (f = sH), p.push(y);
              else throw Error(`arx: invalid 32-byte key, got length=${h}`);
              sQ(o) || p.push((o = sq(o)));
              let m = sB(y);
              if (r) {
                if (24 !== o.length) throw Error('arx: extended nonce must be 24 bytes');
                r(f, m, sB(o.subarray(0, 16)), m), (o = o.subarray(16));
              }
              let g = 16 - i;
              if (g !== o.length) throw Error(`arx: nonce must be ${g} or 16 bytes`);
              if (12 !== g) {
                let e = new Uint8Array(12);
                e.set(o, a ? 0 : 12 - o.length), (o = e), p.push(o);
              }
              return (
                (function (e, t, n, r, i, a, s, o) {
                  let l = i.length,
                    u = new Uint8Array(64),
                    c = sB(u),
                    d = sQ(i) && sQ(a),
                    p = d ? sB(i) : sZ,
                    h = d ? sB(a) : sZ;
                  for (let y = 0; y < l; s++) {
                    if ((e(t, n, r, c, s, o), s >= sY)) throw Error('arx: counter overflow');
                    let f = Math.min(64, l - y);
                    if (d && 64 === f) {
                      let e = y / 4;
                      if (y % 4 != 0) throw Error('arx: invalid block position');
                      for (let t = 0, n; t < 16; t++) h[(n = e + t)] = p[n] ^ c[t];
                      y += 64;
                      continue;
                    }
                    for (let e = 0, t; e < f; e++) a[(t = y + e)] = i[t] ^ u[e];
                    y += f;
                  }
                })(e, f, m, sB(o), l, u, c, s),
                sV(...p),
                u
              );
            }
          );
        })(
          function (e, t, n, r, i, a = 20) {
            let s = e[0],
              o = e[1],
              l = e[2],
              u = e[3],
              c = t[0],
              d = t[1],
              p = t[2],
              h = t[3],
              y = t[4],
              f = t[5],
              m = t[6],
              g = t[7],
              b = n[0],
              w = n[1],
              v = n[2],
              T = s,
              A = o,
              E = l,
              C = u,
              _ = c,
              I = d,
              S = p,
              P = h,
              O = y,
              N = f,
              x = m,
              M = g,
              k = i,
              R = b,
              D = w,
              B = v;
            for (let e = 0; e < a; e += 2)
              (O = (O + (k = sK(k ^ (T = (T + _) | 0), 16))) | 0),
                (T = (T + (_ = sK(_ ^ O, 12))) | 0),
                (O = (O + (k = sK(k ^ T, 8))) | 0),
                (_ = sK(_ ^ O, 7)),
                (N = (N + (R = sK(R ^ (A = (A + I) | 0), 16))) | 0),
                (A = (A + (I = sK(I ^ N, 12))) | 0),
                (N = (N + (R = sK(R ^ A, 8))) | 0),
                (I = sK(I ^ N, 7)),
                (x = (x + (D = sK(D ^ (E = (E + S) | 0), 16))) | 0),
                (E = (E + (S = sK(S ^ x, 12))) | 0),
                (x = (x + (D = sK(D ^ E, 8))) | 0),
                (S = sK(S ^ x, 7)),
                (M = (M + (B = sK(B ^ (C = (C + P) | 0), 16))) | 0),
                (C = (C + (P = sK(P ^ M, 12))) | 0),
                (M = (M + (B = sK(B ^ C, 8))) | 0),
                (P = sK(P ^ M, 7)),
                (x = (x + (B = sK(B ^ (T = (T + I) | 0), 16))) | 0),
                (T = (T + (I = sK(I ^ x, 12))) | 0),
                (x = (x + (B = sK(B ^ T, 8))) | 0),
                (I = sK(I ^ x, 7)),
                (M = (M + (k = sK(k ^ (A = (A + S) | 0), 16))) | 0),
                (A = (A + (S = sK(S ^ M, 12))) | 0),
                (M = (M + (k = sK(k ^ A, 8))) | 0),
                (S = sK(S ^ M, 7)),
                (O = (O + (R = sK(R ^ (E = (E + P) | 0), 16))) | 0),
                (E = (E + (P = sK(P ^ O, 12))) | 0),
                (O = (O + (R = sK(R ^ E, 8))) | 0),
                (P = sK(P ^ O, 7)),
                (N = (N + (D = sK(D ^ (C = (C + _) | 0), 16))) | 0),
                (C = (C + (_ = sK(_ ^ N, 12))) | 0),
                (N = (N + (D = sK(D ^ C, 8))) | 0),
                (_ = sK(_ ^ N, 7));
            let U = 0;
            (r[U++] = (s + T) | 0),
              (r[U++] = (o + A) | 0),
              (r[U++] = (l + E) | 0),
              (r[U++] = (u + C) | 0),
              (r[U++] = (c + _) | 0),
              (r[U++] = (d + I) | 0),
              (r[U++] = (p + S) | 0),
              (r[U++] = (h + P) | 0),
              (r[U++] = (y + O) | 0),
              (r[U++] = (f + N) | 0),
              (r[U++] = (m + x) | 0),
              (r[U++] = (g + M) | 0),
              (r[U++] = (i + k) | 0),
              (r[U++] = (b + R) | 0),
              (r[U++] = (w + D) | 0),
              (r[U++] = (v + B) | 0);
          },
          { counterRight: !1, counterLength: 4, allowShortKeys: !1 }
        ),
        s2 = new Uint8Array(16),
        s6 = (e, t) => {
          e.update(t);
          let n = t.length % 16;
          n && e.update(s2.subarray(n));
        },
        s5 = new Uint8Array(32);
      function s8(e, t, n, r, i) {
        let a = e(t, n, s5),
          s = s0.create(a);
        i && s6(s, i), s6(s, r);
        let o = new Uint8Array(16),
          l = sU(o);
        sj(l, 0, BigInt(i ? i.length : 0), !0), sj(l, 8, BigInt(r.length), !0), s.update(o);
        let u = s.digest();
        return sV(a, o), u;
      }
      let s3 = ((e, t) => {
        function n(r, ...i) {
          if ((sk(r), void 0 !== e.nonceLength)) {
            let t = i[0];
            if (!t) throw Error('nonce / iv required');
            e.varSizeNonce ? sk(t) : sk(t, e.nonceLength);
          }
          let a = e.tagLength;
          a && void 0 !== i[1] && sk(i[1]);
          let s = t(r, ...i),
            o = (e, t) => {
              if (void 0 !== t) {
                if (2 !== e) throw Error('cipher output not supported');
                sk(t);
              }
            },
            l = !1;
          return {
            encrypt(e, t) {
              if (l) throw Error('cannot encrypt() twice with same key + nonce');
              return (l = !0), sk(e), o(s.encrypt.length, t), s.encrypt(e, t);
            },
            decrypt(e, t) {
              if ((sk(e), a && e.length < a))
                throw Error('invalid ciphertext length: smaller than tagLength=' + a);
              return o(s.decrypt.length, t), s.decrypt(e, t);
            },
          };
        }
        return Object.assign(n, e), n;
      })({ blockSize: 64, nonceLength: 12, tagLength: 16 }, (e, t, n) => ({
        encrypt(r, i) {
          let a = r.length;
          (i = sF(a + 16, i, !1)).set(r);
          let s = i.subarray(0, -16);
          s1(e, t, s, s, 1);
          let o = s8(s1, e, t, s, n);
          return i.set(o, a), sV(o), i;
        },
        decrypt(r, i) {
          i = sF(r.length - 16, i, !1);
          let a = r.subarray(0, -16),
            s = r.subarray(-16),
            o = s8(s1, e, t, a, n);
          if (
            !(function (e, t) {
              if (e.length !== t.length) return !1;
              let n = 0;
              for (let r = 0; r < e.length; r++) n |= e[r] ^ t[r];
              return 0 === n;
            })(s, o)
          )
            throw Error('invalid tag');
          return i.set(r.subarray(0, -16)), s1(e, t, i, i, 1), sV(o), i;
        },
      }));
      class s4 extends aJ {
        constructor(e, t) {
          super(), (this.finished = !1), (this.destroyed = !1), aU(e);
          let n = aZ(t);
          if (((this.iHash = e.create()), 'function' != typeof this.iHash.update))
            throw Error('Expected instance of class which extends utils.Hash');
          (this.blockLen = this.iHash.blockLen), (this.outputLen = this.iHash.outputLen);
          let r = this.blockLen,
            i = new Uint8Array(r);
          i.set(n.length > r ? e.create().update(n).digest() : n);
          for (let e = 0; e < i.length; e++) i[e] ^= 54;
          this.iHash.update(i), (this.oHash = e.create());
          for (let e = 0; e < i.length; e++) i[e] ^= 106;
          this.oHash.update(i), i.fill(0);
        }
        update(e) {
          return aL(this), this.iHash.update(e), this;
        }
        digestInto(e) {
          aL(this),
            aB(e, this.outputLen),
            (this.finished = !0),
            this.iHash.digestInto(e),
            this.oHash.update(e),
            this.oHash.digestInto(e),
            this.destroy();
        }
        digest() {
          let e = new Uint8Array(this.oHash.outputLen);
          return this.digestInto(e), e;
        }
        _cloneInto(e) {
          e || (e = Object.create(Object.getPrototypeOf(this), {}));
          let { oHash: t, iHash: n, finished: r, destroyed: i, blockLen: a, outputLen: s } = this;
          return (
            (e.finished = r),
            (e.destroyed = i),
            (e.blockLen = a),
            (e.outputLen = s),
            (e.oHash = t._cloneInto(e.oHash)),
            (e.iHash = n._cloneInto(e.iHash)),
            e
          );
        }
        destroy() {
          (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
        }
      }
      let s9 = (e, t, n) => new s4(e, t).update(n).digest();
      s9.create = (e, t) => new s4(e, t);
      let s7 = new Uint8Array([0]),
        oe = new Uint8Array(),
        ot = (e, t, n, r, i) => {
          var a;
          return (function (e, t, n, r = 32) {
            if ((aU(e), aD(r), r > 255 * e.outputLen))
              throw Error('Length should be <= 255*HashLen');
            let i = Math.ceil(r / e.outputLen);
            void 0 === n && (n = oe);
            let a = new Uint8Array(i * e.outputLen),
              s = s9.create(e, t),
              o = s._cloneInto(),
              l = new Uint8Array(s.outputLen);
            for (let t = 0; t < i; t++)
              (s7[0] = t + 1),
                o
                  .update(0 === t ? oe : l)
                  .update(n)
                  .update(s7)
                  .digestInto(l),
                a.set(l, e.outputLen * t),
                s._cloneInto(o);
            return s.destroy(), o.destroy(), l.fill(0), s7.fill(0), a.slice(0, r);
          })(
            e,
            ((a = n),
            aU(e),
            void 0 === a && (a = new Uint8Array(e.outputLen)),
            s9(e, aZ(a), aZ(t))),
            r,
            i
          );
        };
      class on extends aJ {
        constructor(e, t, n, r) {
          super(),
            (this.blockLen = e),
            (this.outputLen = t),
            (this.padOffset = n),
            (this.isLE = r),
            (this.finished = !1),
            (this.length = 0),
            (this.pos = 0),
            (this.destroyed = !1),
            (this.buffer = new Uint8Array(e)),
            (this.view = aG(this.buffer));
        }
        update(e) {
          aL(this);
          let { view: t, buffer: n, blockLen: r } = this,
            i = (e = aZ(e)).length;
          for (let a = 0; a < i; ) {
            let s = Math.min(r - this.pos, i - a);
            if (s === r) {
              let t = aG(e);
              for (; r <= i - a; a += r) this.process(t, a);
              continue;
            }
            n.set(e.subarray(a, a + s), this.pos),
              (this.pos += s),
              (a += s),
              this.pos === r && (this.process(t, 0), (this.pos = 0));
          }
          return (this.length += e.length), this.roundClean(), this;
        }
        digestInto(e) {
          aL(this), aF(e, this), (this.finished = !0);
          let { buffer: t, view: n, blockLen: r, isLE: i } = this,
            { pos: a } = this;
          (t[a++] = 128),
            this.buffer.subarray(a).fill(0),
            this.padOffset > r - a && (this.process(n, 0), (a = 0));
          for (let e = a; e < r; e++) t[e] = 0;
          (function (e, t, n, r) {
            if ('function' == typeof e.setBigUint64) return e.setBigUint64(t, n, r);
            let i = BigInt(32),
              a = BigInt(4294967295),
              s = Number((n >> i) & a),
              o = Number(n & a),
              l = r ? 4 : 0,
              u = r ? 0 : 4;
            e.setUint32(t + l, s, r), e.setUint32(t + u, o, r);
          })(n, r - 8, BigInt(8 * this.length), i),
            this.process(n, 0);
          let s = aG(e),
            o = this.outputLen;
          if (o % 4) throw Error('_sha2: outputLen should be aligned to 32bit');
          let l = o / 4,
            u = this.get();
          if (l > u.length) throw Error('_sha2: outputLen bigger than state');
          for (let e = 0; e < l; e++) s.setUint32(4 * e, u[e], i);
        }
        digest() {
          let { buffer: e, outputLen: t } = this;
          this.digestInto(e);
          let n = e.slice(0, t);
          return this.destroy(), n;
        }
        _cloneInto(e) {
          e || (e = new this.constructor()), e.set(...this.get());
          let { blockLen: t, buffer: n, length: r, finished: i, destroyed: a, pos: s } = this;
          return (
            (e.length = r),
            (e.pos = s),
            (e.finished = i),
            (e.destroyed = a),
            r % t && e.buffer.set(n),
            e
          );
        }
      }
      let or = new Uint32Array([
          1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748,
          2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206,
          2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983,
          1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671,
          3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372,
          1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
          3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734,
          506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
          1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479,
          3329325298,
        ]),
        oi = new Uint32Array([
          1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,
          1541459225,
        ]),
        oa = new Uint32Array(64);
      class os extends on {
        constructor() {
          super(64, 32, 8, !1),
            (this.A = 0 | oi[0]),
            (this.B = 0 | oi[1]),
            (this.C = 0 | oi[2]),
            (this.D = 0 | oi[3]),
            (this.E = 0 | oi[4]),
            (this.F = 0 | oi[5]),
            (this.G = 0 | oi[6]),
            (this.H = 0 | oi[7]);
        }
        get() {
          let { A: e, B: t, C: n, D: r, E: i, F: a, G: s, H: o } = this;
          return [e, t, n, r, i, a, s, o];
        }
        set(e, t, n, r, i, a, s, o) {
          (this.A = 0 | e),
            (this.B = 0 | t),
            (this.C = 0 | n),
            (this.D = 0 | r),
            (this.E = 0 | i),
            (this.F = 0 | a),
            (this.G = 0 | s),
            (this.H = 0 | o);
        }
        process(e, t) {
          for (let n = 0; n < 16; n++, t += 4) oa[n] = e.getUint32(t, !1);
          for (let e = 16; e < 64; e++) {
            let t = oa[e - 15],
              n = oa[e - 2],
              r = aK(t, 7) ^ aK(t, 18) ^ (t >>> 3),
              i = aK(n, 17) ^ aK(n, 19) ^ (n >>> 10);
            oa[e] = (i + oa[e - 7] + r + oa[e - 16]) | 0;
          }
          let { A: n, B: r, C: i, D: a, E: s, F: o, G: l, H: u } = this;
          for (let e = 0; e < 64; e++) {
            var c, d, p, h;
            let t =
                (u +
                  (aK(s, 6) ^ aK(s, 11) ^ aK(s, 25)) +
                  (((c = s) & o) ^ (~c & l)) +
                  or[e] +
                  oa[e]) |
                0,
              y =
                ((aK(n, 2) ^ aK(n, 13) ^ aK(n, 22)) +
                  (((d = n) & (p = r)) ^ (d & (h = i)) ^ (p & h))) |
                0;
            (u = l),
              (l = o),
              (o = s),
              (s = (a + t) | 0),
              (a = i),
              (i = r),
              (r = n),
              (n = (t + y) | 0);
          }
          (n = (n + this.A) | 0),
            (r = (r + this.B) | 0),
            (i = (i + this.C) | 0),
            (a = (a + this.D) | 0),
            (s = (s + this.E) | 0),
            (o = (o + this.F) | 0),
            (l = (l + this.G) | 0),
            (u = (u + this.H) | 0),
            this.set(n, r, i, a, s, o, l, u);
        }
        roundClean() {
          oa.fill(0);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
        }
      }
      let oo = aX(() => new os()),
        ol = BigInt(0),
        ou = BigInt(1),
        oc = BigInt(2);
      function od(e) {
        return (
          e instanceof Uint8Array || (ArrayBuffer.isView(e) && 'Uint8Array' === e.constructor.name)
        );
      }
      function op(e) {
        if (!od(e)) throw Error('Uint8Array expected');
      }
      function oh(e, t) {
        if ('boolean' != typeof t) throw Error(e + ' boolean expected, got ' + t);
      }
      let oy = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, '0'));
      function of(e) {
        op(e);
        let t = '';
        for (let n = 0; n < e.length; n++) t += oy[e[n]];
        return t;
      }
      function om(e) {
        let t = e.toString(16);
        return 1 & t.length ? '0' + t : t;
      }
      function og(e) {
        if ('string' != typeof e) throw Error('hex string expected, got ' + typeof e);
        return '' === e ? ol : BigInt('0x' + e);
      }
      let ob = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
      function ow(e) {
        return e >= ob._0 && e <= ob._9
          ? e - ob._0
          : e >= ob.A && e <= ob.F
            ? e - (ob.A - 10)
            : e >= ob.a && e <= ob.f
              ? e - (ob.a - 10)
              : void 0;
      }
      function ov(e) {
        if ('string' != typeof e) throw Error('hex string expected, got ' + typeof e);
        let t = e.length,
          n = t / 2;
        if (t % 2) throw Error('hex string expected, got unpadded hex of length ' + t);
        let r = new Uint8Array(n);
        for (let t = 0, i = 0; t < n; t++, i += 2) {
          let n = ow(e.charCodeAt(i)),
            a = ow(e.charCodeAt(i + 1));
          if (void 0 === n || void 0 === a)
            throw Error(
              'hex string expected, got non-hex character "' + (e[i] + e[i + 1]) + '" at index ' + i
            );
          r[t] = 16 * n + a;
        }
        return r;
      }
      function oT(e) {
        return og(of(e));
      }
      function oA(e) {
        return op(e), og(of(Uint8Array.from(e).reverse()));
      }
      function oE(e, t) {
        return ov(e.toString(16).padStart(2 * t, '0'));
      }
      function oC(e, t) {
        return oE(e, t).reverse();
      }
      function o_(e, t, n) {
        let r;
        if ('string' == typeof t)
          try {
            r = ov(t);
          } catch (t) {
            throw Error(e + ' must be hex string or Uint8Array, cause: ' + t);
          }
        else if (od(t)) r = Uint8Array.from(t);
        else throw Error(e + ' must be hex string or Uint8Array');
        let i = r.length;
        if ('number' == typeof n && i !== n)
          throw Error(e + ' of length ' + n + ' expected, got ' + i);
        return r;
      }
      function oI(...e) {
        let t = 0;
        for (let n = 0; n < e.length; n++) {
          let r = e[n];
          op(r), (t += r.length);
        }
        let n = new Uint8Array(t);
        for (let t = 0, r = 0; t < e.length; t++) {
          let i = e[t];
          n.set(i, r), (r += i.length);
        }
        return n;
      }
      let oS = (e) => 'bigint' == typeof e && ol <= e;
      function oP(e, t, n) {
        return oS(e) && oS(t) && oS(n) && t <= e && e < n;
      }
      function oO(e, t, n, r) {
        if (!oP(t, n, r))
          throw Error('expected valid ' + e + ': ' + n + ' <= n < ' + r + ', got ' + t);
      }
      function oN(e) {
        let t;
        for (t = 0; e > ol; e >>= ou, t += 1);
        return t;
      }
      let ox = (e) => (oc << BigInt(e - 1)) - ou,
        oM = (e) => new Uint8Array(e),
        ok = (e) => Uint8Array.from(e);
      function oR(e, t, n) {
        if ('number' != typeof e || e < 2) throw Error('hashLen must be a number');
        if ('number' != typeof t || t < 2) throw Error('qByteLen must be a number');
        if ('function' != typeof n) throw Error('hmacFn must be a function');
        let r = oM(e),
          i = oM(e),
          a = 0,
          s = () => {
            r.fill(1), i.fill(0), (a = 0);
          },
          o = (...e) => n(i, r, ...e),
          l = (e = oM()) => {
            (i = o(ok([0]), e)), (r = o()), 0 !== e.length && ((i = o(ok([1]), e)), (r = o()));
          },
          u = () => {
            if (a++ >= 1e3) throw Error('drbg: tried 1000 values');
            let e = 0,
              n = [];
            for (; e < t; ) {
              let t = (r = o()).slice();
              n.push(t), (e += r.length);
            }
            return oI(...n);
          };
        return (e, t) => {
          let n;
          for (s(), l(e); !(n = t(u())); ) l();
          return s(), n;
        };
      }
      let oD = {
        bigint: (e) => 'bigint' == typeof e,
        function: (e) => 'function' == typeof e,
        boolean: (e) => 'boolean' == typeof e,
        string: (e) => 'string' == typeof e,
        stringOrUint8Array: (e) => 'string' == typeof e || od(e),
        isSafeInteger: (e) => Number.isSafeInteger(e),
        array: (e) => Array.isArray(e),
        field: (e, t) => t.Fp.isValid(e),
        hash: (e) => 'function' == typeof e && Number.isSafeInteger(e.outputLen),
      };
      function oB(e, t, n = {}) {
        let r = (t, n, r) => {
          let i = oD[n];
          if ('function' != typeof i) throw Error('invalid validator function');
          let a = e[t];
          if (!(r && void 0 === a) && !i(a, e))
            throw Error('param ' + String(t) + ' is invalid. Expected ' + n + ', got ' + a);
        };
        for (let [e, n] of Object.entries(t)) r(e, n, !1);
        for (let [e, t] of Object.entries(n)) r(e, t, !0);
        return e;
      }
      function oU(e) {
        let t = new WeakMap();
        return (n, ...r) => {
          let i = t.get(n);
          if (void 0 !== i) return i;
          let a = e(n, ...r);
          return t.set(n, a), a;
        };
      }
      var oL = Object.freeze({
        __proto__: null,
        isBytes: od,
        abytes: op,
        abool: oh,
        bytesToHex: of,
        numberToHexUnpadded: om,
        hexToNumber: og,
        hexToBytes: ov,
        bytesToNumberBE: oT,
        bytesToNumberLE: oA,
        numberToBytesBE: oE,
        numberToBytesLE: oC,
        numberToVarBytesBE: function (e) {
          return ov(om(e));
        },
        ensureBytes: o_,
        concatBytes: oI,
        equalBytes: function (e, t) {
          if (e.length !== t.length) return !1;
          let n = 0;
          for (let r = 0; r < e.length; r++) n |= e[r] ^ t[r];
          return 0 === n;
        },
        utf8ToBytes: function (e) {
          if ('string' != typeof e) throw Error('string expected');
          return new Uint8Array(new TextEncoder().encode(e));
        },
        inRange: oP,
        aInRange: oO,
        bitLen: oN,
        bitGet: function (e, t) {
          return (e >> BigInt(t)) & ou;
        },
        bitSet: function (e, t, n) {
          return e | ((n ? ou : ol) << BigInt(t));
        },
        bitMask: ox,
        createHmacDrbg: oR,
        validateObject: oB,
        notImplemented: () => {
          throw Error('not implemented');
        },
        memoized: oU,
      });
      let oF = BigInt(0),
        oj = BigInt(1),
        oq = BigInt(2),
        oV = BigInt(3),
        o$ = BigInt(4),
        oz = BigInt(5),
        oW = BigInt(8);
      function oH(e, t) {
        let n = e % t;
        return n >= oF ? n : t + n;
      }
      function oG(e, t, n) {
        if (t < oF) throw Error('invalid exponent, negatives unsupported');
        if (n <= oF) throw Error('invalid modulus');
        if (n === oj) return oF;
        let r = oj;
        for (; t > oF; ) t & oj && (r = (r * e) % n), (e = (e * e) % n), (t >>= oj);
        return r;
      }
      function oK(e, t, n) {
        let r = e;
        for (; t-- > oF; ) (r *= r), (r %= n);
        return r;
      }
      function oQ(e, t) {
        if (e === oF) throw Error('invert: expected non-zero number');
        if (t <= oF) throw Error('invert: expected positive modulus, got ' + t);
        let n = oH(e, t),
          r = t,
          i = oF,
          a = oj;
        for (; n !== oF; ) {
          let e = r / n,
            t = r % n,
            s = i - a * e;
          (r = n), (n = t), (i = a), (a = s);
        }
        if (r !== oj) throw Error('invert: does not exist');
        return oH(i, t);
      }
      let oY = [
        'create',
        'isValid',
        'is0',
        'neg',
        'inv',
        'sqrt',
        'sqr',
        'eql',
        'add',
        'sub',
        'mul',
        'pow',
        'div',
        'addN',
        'subN',
        'mulN',
        'sqrN',
      ];
      function oZ(e, t) {
        let n = void 0 !== t ? t : e.toString(2).length;
        return { nBitLength: n, nByteLength: Math.ceil(n / 8) };
      }
      function oJ(e, t, n = !1, r = {}) {
        let i;
        if (e <= oF) throw Error('invalid field: expected ORDER > 0, got ' + e);
        let { nBitLength: a, nByteLength: s } = oZ(e, t);
        if (s > 2048) throw Error('invalid field: expected ORDER of <= 2048 bytes');
        let o = Object.freeze({
          ORDER: e,
          isLE: n,
          BITS: a,
          BYTES: s,
          MASK: ox(a),
          ZERO: oF,
          ONE: oj,
          create: (t) => oH(t, e),
          isValid: (t) => {
            if ('bigint' != typeof t)
              throw Error('invalid field element: expected bigint, got ' + typeof t);
            return oF <= t && t < e;
          },
          is0: (e) => e === oF,
          isOdd: (e) => (e & oj) === oj,
          neg: (t) => oH(-t, e),
          eql: (e, t) => e === t,
          sqr: (t) => oH(t * t, e),
          add: (t, n) => oH(t + n, e),
          sub: (t, n) => oH(t - n, e),
          mul: (t, n) => oH(t * n, e),
          pow: (e, t) =>
            (function (e, t, n) {
              if (n < oF) throw Error('invalid exponent, negatives unsupported');
              if (n === oF) return e.ONE;
              if (n === oj) return t;
              let r = e.ONE,
                i = t;
              for (; n > oF; ) n & oj && (r = e.mul(r, i)), (i = e.sqr(i)), (n >>= oj);
              return r;
            })(o, e, t),
          div: (t, n) => oH(t * oQ(n, e), e),
          sqrN: (e) => e * e,
          addN: (e, t) => e + t,
          subN: (e, t) => e - t,
          mulN: (e, t) => e * t,
          inv: (t) => oQ(t, e),
          sqrt:
            r.sqrt ||
            ((t) => (
              i ||
                (i = (function (e) {
                  if (e % o$ === oV) {
                    let t = (e + oj) / o$;
                    return function (e, n) {
                      let r = e.pow(n, t);
                      if (!e.eql(e.sqr(r), n)) throw Error('Cannot find square root');
                      return r;
                    };
                  }
                  if (e % oW === oz) {
                    let t = (e - oz) / oW;
                    return function (e, n) {
                      let r = e.mul(n, oq),
                        i = e.pow(r, t),
                        a = e.mul(n, i),
                        s = e.mul(e.mul(a, oq), i),
                        o = e.mul(a, e.sub(s, e.ONE));
                      if (!e.eql(e.sqr(o), n)) throw Error('Cannot find square root');
                      return o;
                    };
                  }
                  return (function (e) {
                    let t, n, r;
                    let i = (e - oj) / oq;
                    for (t = e - oj, n = 0; t % oq === oF; t /= oq, n++);
                    for (r = oq; r < e && oG(r, i, e) !== e - oj; r++)
                      if (r > 1e3) throw Error('Cannot find square root: likely non-prime P');
                    if (1 === n) {
                      let t = (e + oj) / o$;
                      return function (e, n) {
                        let r = e.pow(n, t);
                        if (!e.eql(e.sqr(r), n)) throw Error('Cannot find square root');
                        return r;
                      };
                    }
                    let a = (t + oj) / oq;
                    return function (e, s) {
                      if (e.pow(s, i) === e.neg(e.ONE)) throw Error('Cannot find square root');
                      let o = n,
                        l = e.pow(e.mul(e.ONE, r), t),
                        u = e.pow(s, a),
                        c = e.pow(s, t);
                      for (; !e.eql(c, e.ONE); ) {
                        if (e.eql(c, e.ZERO)) return e.ZERO;
                        let t = 1;
                        for (let n = e.sqr(c); t < o && !e.eql(n, e.ONE); t++) n = e.sqr(n);
                        let n = e.pow(l, oj << BigInt(o - t - 1));
                        (l = e.sqr(n)), (u = e.mul(u, n)), (c = e.mul(c, l)), (o = t);
                      }
                      return u;
                    };
                  })(e);
                })(e)),
              i(o, t)
            )),
          invertBatch: (e) =>
            (function (e, t) {
              let n = Array(t.length),
                r = t.reduce((t, r, i) => (e.is0(r) ? t : ((n[i] = t), e.mul(t, r))), e.ONE),
                i = e.inv(r);
              return (
                t.reduceRight(
                  (t, r, i) => (e.is0(r) ? t : ((n[i] = e.mul(t, n[i])), e.mul(t, r))),
                  i
                ),
                n
              );
            })(o, e),
          cmov: (e, t, n) => (n ? t : e),
          toBytes: (e) => (n ? oC(e, s) : oE(e, s)),
          fromBytes: (e) => {
            if (e.length !== s)
              throw Error('Field.fromBytes: expected ' + s + ' bytes, got ' + e.length);
            return n ? oA(e) : oT(e);
          },
        });
        return Object.freeze(o);
      }
      function oX(e) {
        if ('bigint' != typeof e) throw Error('field order must be bigint');
        return Math.ceil(e.toString(2).length / 8);
      }
      function o0(e) {
        let t = oX(e);
        return t + Math.ceil(t / 2);
      }
      let o1 = BigInt(0),
        o2 = BigInt(1);
      function o6(e, t) {
        let n = t.negate();
        return e ? n : t;
      }
      function o5(e, t) {
        if (!Number.isSafeInteger(e) || e <= 0 || e > t)
          throw Error('invalid window size, expected [1..' + t + '], got W=' + e);
      }
      function o8(e, t) {
        return o5(e, t), { windows: Math.ceil(t / e) + 1, windowSize: 2 ** (e - 1) };
      }
      let o3 = new WeakMap(),
        o4 = new WeakMap();
      function o9(e) {
        return o4.get(e) || 1;
      }
      function o7(e) {
        return (
          oB(
            e.Fp,
            oY.reduce((e, t) => ((e[t] = 'function'), e), {
              ORDER: 'bigint',
              MASK: 'bigint',
              BYTES: 'isSafeInteger',
              BITS: 'isSafeInteger',
            })
          ),
          oB(
            e,
            { n: 'bigint', h: 'bigint', Gx: 'field', Gy: 'field' },
            { nBitLength: 'isSafeInteger', nByteLength: 'isSafeInteger' }
          ),
          Object.freeze({ ...oZ(e.n, e.nBitLength), ...e, p: e.Fp.ORDER })
        );
      }
      BigInt(0), BigInt(1), BigInt(2), BigInt(8);
      let le = BigInt(0),
        lt = BigInt(1),
        ln = BigInt(
          '57896044618658097711785492504343953926634992332820282019728792003956564819949'
        );
      BigInt(0);
      let lr = BigInt(1),
        li = BigInt(2),
        la = BigInt(3),
        ls = BigInt(5);
      BigInt(8);
      let lo = (function (e) {
        let t =
            (oB(
              e,
              { a: 'bigint' },
              {
                montgomeryBits: 'isSafeInteger',
                nByteLength: 'isSafeInteger',
                adjustScalarBytes: 'function',
                domain: 'function',
                powPminus2: 'function',
                Gu: 'bigint',
              }
            ),
            Object.freeze({ ...e })),
          { P: n } = t,
          r = (e) => oH(e, n),
          i = t.montgomeryBits,
          a = Math.ceil(i / 8),
          s = t.nByteLength,
          o = t.adjustScalarBytes || ((e) => e),
          l = t.powPminus2 || ((e) => oG(e, n - BigInt(2), n));
        function u(e, t, n) {
          let i = r(e * (t - n));
          return [(t = r(t - i)), (n = r(n + i))];
        }
        let c = (t.a - BigInt(2)) / BigInt(4);
        function d(e, t) {
          let d = (function (e, t) {
            oO('u', e, le, n), oO('scalar', t, le, n);
            let a = lt,
              s = le,
              o = e,
              d = lt,
              p = le,
              h;
            for (let n = BigInt(i - 1); n >= le; n--) {
              let i = (t >> n) & lt;
              (p ^= i),
                (a = (h = u(p, a, o))[0]),
                (o = h[1]),
                (s = (h = u(p, s, d))[0]),
                (d = h[1]),
                (p = i);
              let l = a + s,
                y = r(l * l),
                f = a - s,
                m = r(f * f),
                g = y - m,
                b = o + d,
                w = r((o - d) * l),
                v = r(b * f),
                T = w + v,
                A = w - v;
              (o = r(T * T)), (d = r(e * r(A * A))), (a = r(y * m)), (s = r(g * (y + r(c * g))));
            }
            return (
              (a = (h = u(p, a, o))[0]),
              (o = h[1]),
              (s = (h = u(p, s, d))[0]),
              (d = h[1]),
              r(a * l(s))
            );
          })(
            (function (e) {
              let t = o_('u coordinate', e, a);
              return 32 === s && (t[31] &= 127), oA(t);
            })(t),
            (function (e) {
              let t = o_('scalar', e),
                n = t.length;
              if (n !== a && n !== s)
                throw Error('invalid scalar, expected ' + a + ' or ' + s + ' bytes, got ' + n);
              return oA(o(t));
            })(e)
          );
          if (d === le) throw Error('invalid private or public key received');
          return oC(r(d), a);
        }
        let p = oC(r(t.Gu), a);
        function h(e) {
          return d(e, p);
        }
        return {
          scalarMult: d,
          scalarMultBase: h,
          getSharedSecret: (e, t) => d(e, t),
          getPublicKey: (e) => h(e),
          utils: { randomPrivateKey: () => t.randomBytes(t.nByteLength) },
          GuBytes: p,
        };
      })({
        P: ln,
        a: BigInt(486662),
        montgomeryBits: 255,
        nByteLength: 32,
        Gu: BigInt(9),
        powPminus2: (e) => {
          let { pow_p_5_8: t, b2: n } = (function (e) {
            let t = BigInt(10),
              n = BigInt(20),
              r = BigInt(40),
              i = BigInt(80),
              a = (((e * e) % ln) * e) % ln,
              s = (oK(a, li, ln) * a) % ln,
              o = (oK(s, lr, ln) * e) % ln,
              l = (oK(o, ls, ln) * o) % ln,
              u = (oK(l, t, ln) * l) % ln,
              c = (oK(u, n, ln) * u) % ln,
              d = (oK(c, r, ln) * c) % ln,
              p = (oK(d, i, ln) * d) % ln,
              h = (oK(p, i, ln) * d) % ln,
              y = (oK(h, t, ln) * l) % ln;
            return { pow_p_5_8: (oK(y, li, ln) * e) % ln, b2: a };
          })(e);
          return oH(oK(t, la, ln) * n, ln);
        },
        adjustScalarBytes: function (e) {
          return (e[0] &= 248), (e[31] &= 127), (e[31] |= 64), e;
        },
        randomBytes: a0,
      });
      function ll(e) {
        void 0 !== e.lowS && oh('lowS', e.lowS), void 0 !== e.prehash && oh('prehash', e.prehash);
      }
      let { bytesToNumberBE: lu, hexToBytes: lc } = oL;
      class ld extends Error {
        constructor(e = '') {
          super(e);
        }
      }
      let lp = {
          Err: ld,
          _tlv: {
            encode: (e, t) => {
              let { Err: n } = lp;
              if (e < 0 || e > 256) throw new n('tlv.encode: wrong tag');
              if (1 & t.length) throw new n('tlv.encode: unpadded data');
              let r = t.length / 2,
                i = om(r);
              if ((i.length / 2) & 128) throw new n('tlv.encode: long form length too big');
              let a = r > 127 ? om((i.length / 2) | 128) : '';
              return om(e) + a + i + t;
            },
            decode(e, t) {
              let { Err: n } = lp,
                r = 0;
              if (e < 0 || e > 256) throw new n('tlv.encode: wrong tag');
              if (t.length < 2 || t[r++] !== e) throw new n('tlv.decode: wrong tlv');
              let i = t[r++],
                a = 0;
              if (128 & i) {
                let e = 127 & i;
                if (!e) throw new n('tlv.decode(long): indefinite length not supported');
                if (e > 4) throw new n('tlv.decode(long): byte length is too big');
                let s = t.subarray(r, r + e);
                if (s.length !== e) throw new n('tlv.decode: length bytes not complete');
                if (0 === s[0]) throw new n('tlv.decode(long): zero leftmost byte');
                for (let e of s) a = (a << 8) | e;
                if (((r += e), a < 128)) throw new n('tlv.decode(long): not minimal encoding');
              } else a = i;
              let s = t.subarray(r, r + a);
              if (s.length !== a) throw new n('tlv.decode: wrong value length');
              return { v: s, l: t.subarray(r + a) };
            },
          },
          _int: {
            encode(e) {
              let { Err: t } = lp;
              if (e < lh) throw new t('integer: negative integers are not allowed');
              let n = om(e);
              if ((8 & Number.parseInt(n[0], 16) && (n = '00' + n), 1 & n.length))
                throw new t('unexpected DER parsing assertion: unpadded hex');
              return n;
            },
            decode(e) {
              let { Err: t } = lp;
              if (128 & e[0]) throw new t('invalid signature integer: negative');
              if (0 === e[0] && !(128 & e[1]))
                throw new t('invalid signature integer: unnecessary leading zero');
              return lu(e);
            },
          },
          toSig(e) {
            let { Err: t, _int: n, _tlv: r } = lp,
              i = 'string' == typeof e ? lc(e) : e;
            op(i);
            let { v: a, l: s } = r.decode(48, i);
            if (s.length) throw new t('invalid signature: left bytes after parsing');
            let { v: o, l: l } = r.decode(2, a),
              { v: u, l: c } = r.decode(2, l);
            if (c.length) throw new t('invalid signature: left bytes after parsing');
            return { r: n.decode(o), s: n.decode(u) };
          },
          hexFromSig(e) {
            let { _tlv: t, _int: n } = lp,
              r = t.encode(2, n.encode(e.r)),
              i = t.encode(2, n.encode(e.s));
            return t.encode(48, r + i);
          },
        },
        lh = BigInt(0),
        ly = BigInt(1);
      BigInt(2);
      let lf = BigInt(3);
      BigInt(4);
      let lm = oJ(BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff')),
        lg = (function (e, t) {
          let n = (t) =>
            (function (e) {
              let t = (function (e) {
                  let t = o7(e);
                  return (
                    oB(
                      t,
                      { hash: 'hash', hmac: 'function', randomBytes: 'function' },
                      { bits2int: 'function', bits2int_modN: 'function', lowS: 'boolean' }
                    ),
                    Object.freeze({ lowS: !0, ...t })
                  );
                })(e),
                { Fp: n, n: r } = t,
                i = n.BYTES + 1,
                a = 2 * n.BYTES + 1;
              function s(e) {
                return oH(e, r);
              }
              let {
                  ProjectivePoint: o,
                  normPrivateKeyToScalar: l,
                  weierstrassEquation: u,
                  isWithinCurveOrder: c,
                } = (function (e) {
                  var t;
                  let n = (function (e) {
                      let t = o7(e);
                      oB(
                        t,
                        { a: 'field', b: 'field' },
                        {
                          allowedPrivateKeyLengths: 'array',
                          wrapPrivateKey: 'boolean',
                          isTorsionFree: 'function',
                          clearCofactor: 'function',
                          allowInfinityPoint: 'boolean',
                          fromBytes: 'function',
                          toBytes: 'function',
                        }
                      );
                      let { endo: n, Fp: r, a: i } = t;
                      if (n) {
                        if (!r.eql(i, r.ZERO))
                          throw Error(
                            'invalid endomorphism, can only be defined for Koblitz curves that have a=0'
                          );
                        if (
                          'object' != typeof n ||
                          'bigint' != typeof n.beta ||
                          'function' != typeof n.splitScalar
                        )
                          throw Error(
                            'invalid endomorphism, expected beta: bigint and splitScalar: function'
                          );
                      }
                      return Object.freeze({ ...t });
                    })(e),
                    { Fp: r } = n,
                    i = oJ(n.n, n.nBitLength),
                    a =
                      n.toBytes ||
                      ((e, t, n) => {
                        let i = t.toAffine();
                        return oI(Uint8Array.from([4]), r.toBytes(i.x), r.toBytes(i.y));
                      }),
                    s =
                      n.fromBytes ||
                      ((e) => {
                        let t = e.subarray(1);
                        return {
                          x: r.fromBytes(t.subarray(0, r.BYTES)),
                          y: r.fromBytes(t.subarray(r.BYTES, 2 * r.BYTES)),
                        };
                      });
                  function o(e) {
                    let { a: t, b: i } = n,
                      a = r.sqr(e),
                      s = r.mul(a, e);
                    return r.add(r.add(s, r.mul(e, t)), i);
                  }
                  if (!r.eql(r.sqr(n.Gy), o(n.Gx)))
                    throw Error('bad generator point: equation left != right');
                  function l(e) {
                    let t;
                    let {
                      allowedPrivateKeyLengths: r,
                      nByteLength: i,
                      wrapPrivateKey: a,
                      n: s,
                    } = n;
                    if (r && 'bigint' != typeof e) {
                      if ((od(e) && (e = of(e)), 'string' != typeof e || !r.includes(e.length)))
                        throw Error('invalid private key');
                      e = e.padStart(2 * i, '0');
                    }
                    try {
                      t = 'bigint' == typeof e ? e : oT(o_('private key', e, i));
                    } catch {
                      throw Error(
                        'invalid private key, expected hex or ' + i + ' bytes, got ' + typeof e
                      );
                    }
                    return a && (t = oH(t, s)), oO('private key', t, ly, s), t;
                  }
                  function u(e) {
                    if (!(e instanceof p)) throw Error('ProjectivePoint expected');
                  }
                  let c = oU((e, t) => {
                      let { px: n, py: i, pz: a } = e;
                      if (r.eql(a, r.ONE)) return { x: n, y: i };
                      let s = e.is0();
                      null == t && (t = s ? r.ONE : r.inv(a));
                      let o = r.mul(n, t),
                        l = r.mul(i, t),
                        u = r.mul(a, t);
                      if (s) return { x: r.ZERO, y: r.ZERO };
                      if (!r.eql(u, r.ONE)) throw Error('invZ was invalid');
                      return { x: o, y: l };
                    }),
                    d = oU((e) => {
                      if (e.is0()) {
                        if (n.allowInfinityPoint && !r.is0(e.py)) return;
                        throw Error('bad point: ZERO');
                      }
                      let { x: t, y: i } = e.toAffine();
                      if (!r.isValid(t) || !r.isValid(i)) throw Error('bad point: x or y not FE');
                      let a = r.sqr(i),
                        s = o(t);
                      if (!r.eql(a, s)) throw Error('bad point: equation left != right');
                      if (!e.isTorsionFree()) throw Error('bad point: not in prime-order subgroup');
                      return !0;
                    });
                  class p {
                    constructor(e, t, n) {
                      if (((this.px = e), (this.py = t), (this.pz = n), null == e || !r.isValid(e)))
                        throw Error('x required');
                      if (null == t || !r.isValid(t)) throw Error('y required');
                      if (null == n || !r.isValid(n)) throw Error('z required');
                      Object.freeze(this);
                    }
                    static fromAffine(e) {
                      let { x: t, y: n } = e || {};
                      if (!e || !r.isValid(t) || !r.isValid(n)) throw Error('invalid affine point');
                      if (e instanceof p) throw Error('projective point not allowed');
                      let i = (e) => r.eql(e, r.ZERO);
                      return i(t) && i(n) ? p.ZERO : new p(t, n, r.ONE);
                    }
                    get x() {
                      return this.toAffine().x;
                    }
                    get y() {
                      return this.toAffine().y;
                    }
                    static normalizeZ(e) {
                      let t = r.invertBatch(e.map((e) => e.pz));
                      return e.map((e, n) => e.toAffine(t[n])).map(p.fromAffine);
                    }
                    static fromHex(e) {
                      let t = p.fromAffine(s(o_('pointHex', e)));
                      return t.assertValidity(), t;
                    }
                    static fromPrivateKey(e) {
                      return p.BASE.multiply(l(e));
                    }
                    static msm(e, t) {
                      return (function (e, t, n, r) {
                        if (
                          ((function (e, t) {
                            if (!Array.isArray(e)) throw Error('array expected');
                            e.forEach((e, n) => {
                              if (!(e instanceof t)) throw Error('invalid point at index ' + n);
                            });
                          })(n, e),
                          (function (e, t) {
                            if (!Array.isArray(e)) throw Error('array of scalars expected');
                            e.forEach((e, n) => {
                              if (!t.isValid(e)) throw Error('invalid scalar at index ' + n);
                            });
                          })(r, t),
                          n.length !== r.length)
                        )
                          throw Error('arrays of points and scalars must have equal length');
                        let i = e.ZERO,
                          a = oN(BigInt(n.length)),
                          s = a > 12 ? a - 3 : a > 4 ? a - 2 : a ? 2 : 1,
                          o = (1 << s) - 1,
                          l = Array(o + 1).fill(i),
                          u = Math.floor((t.BITS - 1) / s) * s,
                          c = i;
                        for (let e = u; e >= 0; e -= s) {
                          l.fill(i);
                          for (let t = 0; t < r.length; t++) {
                            let i = Number((r[t] >> BigInt(e)) & BigInt(o));
                            l[i] = l[i].add(n[t]);
                          }
                          let t = i;
                          for (let e = l.length - 1, n = i; e > 0; e--)
                            (n = n.add(l[e])), (t = t.add(n));
                          if (((c = c.add(t)), 0 !== e)) for (let e = 0; e < s; e++) c = c.double();
                        }
                        return c;
                      })(p, i, e, t);
                    }
                    _setWindowSize(e) {
                      y.setWindowSize(this, e);
                    }
                    assertValidity() {
                      d(this);
                    }
                    hasEvenY() {
                      let { y: e } = this.toAffine();
                      if (r.isOdd) return !r.isOdd(e);
                      throw Error("Field doesn't support isOdd");
                    }
                    equals(e) {
                      u(e);
                      let { px: t, py: n, pz: i } = this,
                        { px: a, py: s, pz: o } = e,
                        l = r.eql(r.mul(t, o), r.mul(a, i)),
                        c = r.eql(r.mul(n, o), r.mul(s, i));
                      return l && c;
                    }
                    negate() {
                      return new p(this.px, r.neg(this.py), this.pz);
                    }
                    double() {
                      let { a: e, b: t } = n,
                        i = r.mul(t, lf),
                        { px: a, py: s, pz: o } = this,
                        l = r.ZERO,
                        u = r.ZERO,
                        c = r.ZERO,
                        d = r.mul(a, a),
                        h = r.mul(s, s),
                        y = r.mul(o, o),
                        f = r.mul(a, s);
                      return (
                        (f = r.add(f, f)),
                        (c = r.mul(a, o)),
                        (c = r.add(c, c)),
                        (l = r.mul(e, c)),
                        (u = r.mul(i, y)),
                        (u = r.add(l, u)),
                        (l = r.sub(h, u)),
                        (u = r.add(h, u)),
                        (u = r.mul(l, u)),
                        (l = r.mul(f, l)),
                        (c = r.mul(i, c)),
                        (y = r.mul(e, y)),
                        (f = r.sub(d, y)),
                        (f = r.mul(e, f)),
                        (f = r.add(f, c)),
                        (c = r.add(d, d)),
                        (d = r.add(c, d)),
                        (d = r.add(d, y)),
                        (d = r.mul(d, f)),
                        (u = r.add(u, d)),
                        (y = r.mul(s, o)),
                        (y = r.add(y, y)),
                        (d = r.mul(y, f)),
                        (l = r.sub(l, d)),
                        (c = r.mul(y, h)),
                        (c = r.add(c, c)),
                        new p(l, u, (c = r.add(c, c)))
                      );
                    }
                    add(e) {
                      u(e);
                      let { px: t, py: i, pz: a } = this,
                        { px: s, py: o, pz: l } = e,
                        c = r.ZERO,
                        d = r.ZERO,
                        h = r.ZERO,
                        y = n.a,
                        f = r.mul(n.b, lf),
                        m = r.mul(t, s),
                        g = r.mul(i, o),
                        b = r.mul(a, l),
                        w = r.add(t, i),
                        v = r.add(s, o);
                      (w = r.mul(w, v)), (v = r.add(m, g)), (w = r.sub(w, v)), (v = r.add(t, a));
                      let T = r.add(s, l);
                      return (
                        (v = r.mul(v, T)),
                        (T = r.add(m, b)),
                        (v = r.sub(v, T)),
                        (T = r.add(i, a)),
                        (c = r.add(o, l)),
                        (T = r.mul(T, c)),
                        (c = r.add(g, b)),
                        (T = r.sub(T, c)),
                        (h = r.mul(y, v)),
                        (c = r.mul(f, b)),
                        (h = r.add(c, h)),
                        (c = r.sub(g, h)),
                        (h = r.add(g, h)),
                        (d = r.mul(c, h)),
                        (g = r.add(m, m)),
                        (g = r.add(g, m)),
                        (b = r.mul(y, b)),
                        (v = r.mul(f, v)),
                        (g = r.add(g, b)),
                        (b = r.sub(m, b)),
                        (b = r.mul(y, b)),
                        (v = r.add(v, b)),
                        (m = r.mul(g, v)),
                        (d = r.add(d, m)),
                        (m = r.mul(T, v)),
                        (c = r.mul(w, c)),
                        (c = r.sub(c, m)),
                        (m = r.mul(w, g)),
                        (h = r.mul(T, h)),
                        new p(c, d, (h = r.add(h, m)))
                      );
                    }
                    subtract(e) {
                      return this.add(e.negate());
                    }
                    is0() {
                      return this.equals(p.ZERO);
                    }
                    wNAF(e) {
                      return y.wNAFCached(this, e, p.normalizeZ);
                    }
                    multiplyUnsafe(e) {
                      let { endo: t, n: i } = n;
                      oO('scalar', e, lh, i);
                      let a = p.ZERO;
                      if (e === lh) return a;
                      if (this.is0() || e === ly) return this;
                      if (!t || y.hasPrecomputes(this))
                        return y.wNAFCachedUnsafe(this, e, p.normalizeZ);
                      let { k1neg: s, k1: o, k2neg: l, k2: u } = t.splitScalar(e),
                        c = a,
                        d = a,
                        h = this;
                      for (; o > lh || u > lh; )
                        o & ly && (c = c.add(h)),
                          u & ly && (d = d.add(h)),
                          (h = h.double()),
                          (o >>= ly),
                          (u >>= ly);
                      return (
                        s && (c = c.negate()),
                        l && (d = d.negate()),
                        (d = new p(r.mul(d.px, t.beta), d.py, d.pz)),
                        c.add(d)
                      );
                    }
                    multiply(e) {
                      let t, i;
                      let { endo: a, n: s } = n;
                      if ((oO('scalar', e, ly, s), a)) {
                        let { k1neg: n, k1: s, k2neg: o, k2: l } = a.splitScalar(e),
                          { p: u, f: c } = this.wNAF(s),
                          { p: d, f: h } = this.wNAF(l);
                        (u = y.constTimeNegate(n, u)),
                          (d = y.constTimeNegate(o, d)),
                          (d = new p(r.mul(d.px, a.beta), d.py, d.pz)),
                          (t = u.add(d)),
                          (i = c.add(h));
                      } else {
                        let { p: n, f: r } = this.wNAF(e);
                        (t = n), (i = r);
                      }
                      return p.normalizeZ([t, i])[0];
                    }
                    multiplyAndAddUnsafe(e, t, n) {
                      let r = p.BASE,
                        i = (e, t) =>
                          t !== lh && t !== ly && e.equals(r) ? e.multiply(t) : e.multiplyUnsafe(t),
                        a = i(this, t).add(i(e, n));
                      return a.is0() ? void 0 : a;
                    }
                    toAffine(e) {
                      return c(this, e);
                    }
                    isTorsionFree() {
                      let { h: e, isTorsionFree: t } = n;
                      if (e === ly) return !0;
                      if (t) return t(p, this);
                      throw Error('isTorsionFree() has not been declared for the elliptic curve');
                    }
                    clearCofactor() {
                      let { h: e, clearCofactor: t } = n;
                      return e === ly ? this : t ? t(p, this) : this.multiplyUnsafe(n.h);
                    }
                    toRawBytes(e = !0) {
                      return oh('isCompressed', e), this.assertValidity(), a(p, this, e);
                    }
                    toHex(e = !0) {
                      return oh('isCompressed', e), of(this.toRawBytes(e));
                    }
                  }
                  (p.BASE = new p(n.Gx, n.Gy, r.ONE)), (p.ZERO = new p(r.ZERO, r.ONE, r.ZERO));
                  let h = n.nBitLength,
                    y =
                      ((t = n.endo ? Math.ceil(h / 2) : h),
                      {
                        constTimeNegate: o6,
                        hasPrecomputes: (e) => 1 !== o9(e),
                        unsafeLadder(e, t, n = p.ZERO) {
                          let r = e;
                          for (; t > o1; ) t & o2 && (n = n.add(r)), (r = r.double()), (t >>= o2);
                          return n;
                        },
                        precomputeWindow(e, n) {
                          let { windows: r, windowSize: i } = o8(n, t),
                            a = [],
                            s = e,
                            o = s;
                          for (let e = 0; e < r; e++) {
                            (o = s), a.push(o);
                            for (let e = 1; e < i; e++) (o = o.add(s)), a.push(o);
                            s = o.double();
                          }
                          return a;
                        },
                        wNAF(e, n, r) {
                          let { windows: i, windowSize: a } = o8(e, t),
                            s = p.ZERO,
                            o = p.BASE,
                            l = BigInt(2 ** e - 1),
                            u = 2 ** e,
                            c = BigInt(e);
                          for (let e = 0; e < i; e++) {
                            let t = e * a,
                              i = Number(r & l);
                            (r >>= c), i > a && ((i -= u), (r += o2));
                            let d = t + Math.abs(i) - 1,
                              p = e % 2 != 0,
                              h = i < 0;
                            0 === i ? (o = o.add(o6(p, n[t]))) : (s = s.add(o6(h, n[d])));
                          }
                          return { p: s, f: o };
                        },
                        wNAFUnsafe(e, n, r, i = p.ZERO) {
                          let { windows: a, windowSize: s } = o8(e, t),
                            o = BigInt(2 ** e - 1),
                            l = 2 ** e,
                            u = BigInt(e);
                          for (let e = 0; e < a; e++) {
                            let t = e * s;
                            if (r === o1) break;
                            let a = Number(r & o);
                            if (((r >>= u), a > s && ((a -= l), (r += o2)), 0 === a)) continue;
                            let c = n[t + Math.abs(a) - 1];
                            a < 0 && (c = c.negate()), (i = i.add(c));
                          }
                          return i;
                        },
                        getPrecomputes(e, t, n) {
                          let r = o3.get(t);
                          return (
                            r || ((r = this.precomputeWindow(t, e)), 1 !== e && o3.set(t, n(r))), r
                          );
                        },
                        wNAFCached(e, t, n) {
                          let r = o9(e);
                          return this.wNAF(r, this.getPrecomputes(r, e, n), t);
                        },
                        wNAFCachedUnsafe(e, t, n, r) {
                          let i = o9(e);
                          return 1 === i
                            ? this.unsafeLadder(e, t, r)
                            : this.wNAFUnsafe(i, this.getPrecomputes(i, e, n), t, r);
                        },
                        setWindowSize(e, n) {
                          o5(n, t), o4.set(e, n), o3.delete(e);
                        },
                      });
                  return {
                    CURVE: n,
                    ProjectivePoint: p,
                    normPrivateKeyToScalar: l,
                    weierstrassEquation: o,
                    isWithinCurveOrder: function (e) {
                      return oP(e, ly, n.n);
                    },
                  };
                })({
                  ...t,
                  toBytes(e, t, r) {
                    let i = t.toAffine(),
                      a = n.toBytes(i.x);
                    return (
                      oh('isCompressed', r),
                      r
                        ? oI(Uint8Array.from([t.hasEvenY() ? 2 : 3]), a)
                        : oI(Uint8Array.from([4]), a, n.toBytes(i.y))
                    );
                  },
                  fromBytes(e) {
                    let t = e.length,
                      r = e[0],
                      s = e.subarray(1);
                    if (t === i && (2 === r || 3 === r)) {
                      let e;
                      let t = oT(s);
                      if (!oP(t, ly, n.ORDER)) throw Error('Point is not on curve');
                      let i = u(t);
                      try {
                        e = n.sqrt(i);
                      } catch (e) {
                        throw Error(
                          'Point is not on curve' + (e instanceof Error ? ': ' + e.message : '')
                        );
                      }
                      return ((1 & r) == 1) != ((e & ly) === ly) && (e = n.neg(e)), { x: t, y: e };
                    }
                    if (t === a && 4 === r)
                      return {
                        x: n.fromBytes(s.subarray(0, n.BYTES)),
                        y: n.fromBytes(s.subarray(n.BYTES, 2 * n.BYTES)),
                      };
                    throw Error(
                      'invalid Point, expected length of ' +
                        i +
                        ', or uncompressed ' +
                        a +
                        ', got ' +
                        t
                    );
                  },
                }),
                d = (e) => of(oE(e, t.nByteLength)),
                p = (e, t, n) => oT(e.slice(t, n));
              class h {
                constructor(e, t, n) {
                  (this.r = e), (this.s = t), (this.recovery = n), this.assertValidity();
                }
                static fromCompact(e) {
                  let n = t.nByteLength;
                  return new h(p((e = o_('compactSignature', e, 2 * n)), 0, n), p(e, n, 2 * n));
                }
                static fromDER(e) {
                  let { r: t, s: n } = lp.toSig(o_('DER', e));
                  return new h(t, n);
                }
                assertValidity() {
                  oO('r', this.r, ly, r), oO('s', this.s, ly, r);
                }
                addRecoveryBit(e) {
                  return new h(this.r, this.s, e);
                }
                recoverPublicKey(e) {
                  let { r: i, s: a, recovery: l } = this,
                    u = m(o_('msgHash', e));
                  if (null == l || ![0, 1, 2, 3].includes(l)) throw Error('recovery id invalid');
                  let c = 2 === l || 3 === l ? i + t.n : i;
                  if (c >= n.ORDER) throw Error('recovery id 2 or 3 invalid');
                  let p = (1 & l) == 0 ? '02' : '03',
                    h = o.fromHex(p + d(c)),
                    y = oQ(c, r),
                    f = s(-u * y),
                    g = s(a * y),
                    b = o.BASE.multiplyAndAddUnsafe(h, f, g);
                  if (!b) throw Error('point at infinify');
                  return b.assertValidity(), b;
                }
                hasHighS() {
                  return this.s > r >> ly;
                }
                normalizeS() {
                  return this.hasHighS() ? new h(this.r, s(-this.s), this.recovery) : this;
                }
                toDERRawBytes() {
                  return ov(this.toDERHex());
                }
                toDERHex() {
                  return lp.hexFromSig({ r: this.r, s: this.s });
                }
                toCompactRawBytes() {
                  return ov(this.toCompactHex());
                }
                toCompactHex() {
                  return d(this.r) + d(this.s);
                }
              }
              function y(e) {
                let t = od(e),
                  n = 'string' == typeof e,
                  r = (t || n) && e.length;
                return t ? r === i || r === a : n ? r === 2 * i || r === 2 * a : e instanceof o;
              }
              let f =
                  t.bits2int ||
                  function (e) {
                    if (e.length > 8192) throw Error('input is too large');
                    let n = oT(e),
                      r = 8 * e.length - t.nBitLength;
                    return r > 0 ? n >> BigInt(r) : n;
                  },
                m =
                  t.bits2int_modN ||
                  function (e) {
                    return s(f(e));
                  },
                g = ox(t.nBitLength);
              function b(e) {
                return oO('num < 2^' + t.nBitLength, e, lh, g), oE(e, t.nByteLength);
              }
              let w = { lowS: t.lowS, prehash: !1 },
                v = { lowS: t.lowS, prehash: !1 };
              return (
                o.BASE._setWindowSize(8),
                {
                  CURVE: t,
                  getPublicKey: function (e, t = !0) {
                    return o.fromPrivateKey(e).toRawBytes(t);
                  },
                  getSharedSecret: function (e, t, n = !0) {
                    if (y(e)) throw Error('first arg must be private key');
                    if (!y(t)) throw Error('second arg must be public key');
                    return o.fromHex(t).multiply(l(e)).toRawBytes(n);
                  },
                  sign: function (e, i, a = w) {
                    let { seed: u, k2sig: d } = (function (e, i, a = w) {
                      if (['recovered', 'canonical'].some((e) => e in a))
                        throw Error('sign() legacy options not supported');
                      let { hash: u, randomBytes: d } = t,
                        { lowS: p, prehash: y, extraEntropy: g } = a;
                      null == p && (p = !0),
                        (e = o_('msgHash', e)),
                        ll(a),
                        y && (e = o_('prehashed msgHash', u(e)));
                      let v = m(e),
                        T = l(i),
                        A = [b(T), b(v)];
                      if (null != g && !1 !== g) {
                        let e = !0 === g ? d(n.BYTES) : g;
                        A.push(o_('extraEntropy', e));
                      }
                      return {
                        seed: oI(...A),
                        k2sig: function (e) {
                          let t = f(e);
                          if (!c(t)) return;
                          let n = oQ(t, r),
                            i = o.BASE.multiply(t).toAffine(),
                            a = s(i.x);
                          if (a === lh) return;
                          let l = s(n * s(v + a * T));
                          if (l === lh) return;
                          let u = (i.x === a ? 0 : 2) | Number(i.y & ly),
                            d = l;
                          return (
                            p && l > r >> ly && ((d = l > r >> ly ? s(-l) : l), (u ^= 1)),
                            new h(a, d, u)
                          );
                        },
                      };
                    })(e, i, a);
                    return oR(t.hash.outputLen, t.nByteLength, t.hmac)(u, d);
                  },
                  verify: function (e, n, i, a = v) {
                    let l, u;
                    (n = o_('msgHash', n)), (i = o_('publicKey', i));
                    let { lowS: c, prehash: d, format: p } = a;
                    if ((ll(a), 'strict' in a)) throw Error('options.strict was renamed to lowS');
                    if (void 0 !== p && 'compact' !== p && 'der' !== p)
                      throw Error('format must be compact or der');
                    let y = 'string' == typeof e || od(e),
                      f =
                        !y &&
                        !p &&
                        'object' == typeof e &&
                        null !== e &&
                        'bigint' == typeof e.r &&
                        'bigint' == typeof e.s;
                    if (!y && !f)
                      throw Error(
                        'invalid signature, expected Uint8Array, hex string or Signature instance'
                      );
                    try {
                      if ((f && (l = new h(e.r, e.s)), y)) {
                        try {
                          'compact' !== p && (l = h.fromDER(e));
                        } catch (e) {
                          if (!(e instanceof lp.Err)) throw e;
                        }
                        l || 'der' === p || (l = h.fromCompact(e));
                      }
                      u = o.fromHex(i);
                    } catch {
                      return !1;
                    }
                    if (!l || (c && l.hasHighS())) return !1;
                    d && (n = t.hash(n));
                    let { r: g, s: b } = l,
                      w = m(n),
                      T = oQ(b, r),
                      A = s(w * T),
                      E = s(g * T),
                      C = o.BASE.multiplyAndAddUnsafe(u, A, E)?.toAffine();
                    return !!C && s(C.x) === g;
                  },
                  ProjectivePoint: o,
                  Signature: h,
                  utils: {
                    isValidPrivateKey(e) {
                      try {
                        return l(e), !0;
                      } catch {
                        return !1;
                      }
                    },
                    normPrivateKeyToScalar: l,
                    randomPrivateKey: () => {
                      let e = o0(t.n);
                      return (function (e, t, n = !1) {
                        let r = e.length,
                          i = oX(t),
                          a = o0(t);
                        if (r < 16 || r < a || r > 1024)
                          throw Error('expected ' + a + '-1024 bytes of input, got ' + r);
                        let s = oH(n ? oA(e) : oT(e), t - oj) + oj;
                        return n ? oC(s, i) : oE(s, i);
                      })(t.randomBytes(e), t.n);
                    },
                    precompute: (e = 8, t = o.BASE) => (
                      t._setWindowSize(e), t.multiply(BigInt(3)), t
                    ),
                  },
                }
              );
            })({
              ...e,
              hash: t,
              hmac: (e, ...n) =>
                s9(
                  t,
                  e,
                  (function (...e) {
                    let t = 0;
                    for (let n = 0; n < e.length; n++) {
                      let r = e[n];
                      aB(r), (t += r.length);
                    }
                    let n = new Uint8Array(t);
                    for (let t = 0, r = 0; t < e.length; t++) {
                      let i = e[t];
                      n.set(i, r), (r += i.length);
                    }
                    return n;
                  })(...n)
                ),
              randomBytes: a0,
            });
          return { ...n(t), create: n };
        })(
          {
            a: lm.create(BigInt('-3')),
            b: BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b'),
            Fp: lm,
            n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),
            Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),
            Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),
            h: BigInt(1),
            lowS: !1,
          },
          oo
        ),
        lb = 'base10',
        lw = 'base16',
        lv = 'base64pad',
        lT = 'base64url',
        lA = 'utf8';
      function lE() {
        return i8(a0(32), lw);
      }
      function lC(e) {
        return i8(oo(i5(e, lw)), lw);
      }
      function l_(e) {
        return i8(oo(i5(e, lA)), lw);
      }
      function lI(e) {
        return Number(i8(e, lb));
      }
      function lS(e) {
        return e.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
      }
      function lP(e) {
        let t = e.replace(/-/g, '+').replace(/_/g, '/'),
          n = (4 - (t.length % 4)) % 4;
        return t + '='.repeat(n);
      }
      function lO(e) {
        if (2 === lI(e.type)) return i8(rD([e.type, e.sealed]), lv);
        if (1 === lI(e.type)) {
          if (typeof e.senderPublicKey > 'u')
            throw Error('Missing sender public key for type 1 envelope');
          return i8(rD([e.type, e.senderPublicKey, e.iv, e.sealed]), lv);
        }
        return i8(rD([e.type, e.iv, e.sealed]), lv);
      }
      function lN(e) {
        let t = i5((e.encoding || lv) === lT ? lP(e.encoded) : e.encoded, lv),
          n = t.slice(0, 1);
        if (1 === lI(n)) {
          let e = t.slice(1, 33),
            r = t.slice(33, 45);
          return { type: n, sealed: t.slice(45), iv: r, senderPublicKey: e };
        }
        if (2 === lI(n)) return { type: n, sealed: t.slice(1), iv: a0(12) };
        let r = t.slice(1, 13);
        return { type: n, sealed: t.slice(13), iv: r };
      }
      function lx(e) {
        let t = e?.type || 0;
        if (1 === t) {
          if (typeof e?.senderPublicKey > 'u') throw Error('missing sender public key');
          if (typeof e?.receiverPublicKey > 'u') throw Error('missing receiver public key');
        }
        return {
          type: t,
          senderPublicKey: e?.senderPublicKey,
          receiverPublicKey: e?.receiverPublicKey,
        };
      }
      function lM(e) {
        return (
          1 === e.type &&
          'string' == typeof e.senderPublicKey &&
          'string' == typeof e.receiverPublicKey
        );
      }
      function lk(e) {
        return e?.relay || { protocol: 'irn' };
      }
      function lR(e) {
        let t = i3[e];
        if (typeof t > 'u') throw Error(`Relay Protocol not supported: ${e}`);
        return t;
      }
      function lD(e) {
        var t;
        if (!e.includes('wc:')) {
          let t = aR(e);
          null != t && t.includes('wc:') && (e = t);
        }
        let n = (e = (e = e.includes('wc://') ? e.replace('wc://', '') : e).includes('wc:')
            ? e.replace('wc:', '')
            : e).indexOf(':'),
          r = -1 !== e.indexOf('?') ? e.indexOf('?') : void 0,
          i = e.substring(0, n),
          a = e.substring(n + 1, r).split('@'),
          s = new URLSearchParams('u' > typeof r ? e.substring(r) : ''),
          o = {};
        s.forEach((e, t) => {
          o[t] = e;
        });
        let l = 'string' == typeof o.methods ? o.methods.split(',') : void 0;
        return {
          protocol: i,
          topic: (t = a[0]).startsWith('//') ? t.substring(2) : t,
          version: parseInt(a[1], 10),
          symKey: o.symKey,
          relay: (function (e, t = '-') {
            let n = {},
              r = 'relay' + t;
            return (
              Object.keys(e).forEach((t) => {
                if (t.startsWith(r)) {
                  let i = t.replace(r, ''),
                    a = e[t];
                  n[i] = a;
                }
              }),
              n
            );
          })(o),
          methods: l,
          expiryTimestamp: o.expiryTimestamp ? parseInt(o.expiryTimestamp, 10) : void 0,
        };
      }
      function lB(e) {
        let t = new URLSearchParams(),
          n = (function (e, t = '-') {
            let n = {};
            return (
              Object.keys(e).forEach((r) => {
                e[r] && (n['relay' + t + r] = e[r]);
              }),
              n
            );
          })(e.relay);
        Object.keys(n)
          .sort()
          .forEach((e) => {
            t.set(e, n[e]);
          }),
          t.set('symKey', e.symKey),
          e.expiryTimestamp && t.set('expiryTimestamp', e.expiryTimestamp.toString()),
          e.methods && t.set('methods', e.methods.join(','));
        let r = t.toString();
        return `${e.protocol}:${e.topic}@${e.version}?${r}`;
      }
      function lU(e, t, n) {
        return `${e}?wc_ev=${n}&topic=${t}`;
      }
      function lL(e) {
        let t = [];
        return (
          e.forEach((e) => {
            let [n, r] = e.split(':');
            t.push(`${n}:${r}`);
          }),
          t
        );
      }
      function lF(e) {
        return e.includes(':');
      }
      function lj(e) {
        return lF(e) ? e.split(':')[0] : e;
      }
      function lq(e, t) {
        let n = (function (e) {
          let t = {};
          return (
            e?.forEach((e) => {
              var n;
              let [r, i] = e.split(':');
              t[r] || (t[r] = { accounts: [], chains: [], events: [], methods: [] }),
                t[r].accounts.push(e),
                null == (n = t[r].chains) || n.push(`${r}:${i}`);
            }),
            t
          );
        })((t = t.map((e) => e.replace('did:pkh:', ''))));
        for (let [t, r] of Object.entries(n))
          r.methods ? (r.methods = aP(r.methods, e)) : (r.methods = e),
            (r.events = ['chainChanged', 'accountsChanged']);
        return n;
      }
      Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable;
      let lV = {
          INVALID_METHOD: { message: 'Invalid method.', code: 1001 },
          INVALID_EVENT: { message: 'Invalid event.', code: 1002 },
          INVALID_UPDATE_REQUEST: { message: 'Invalid update request.', code: 1003 },
          INVALID_EXTEND_REQUEST: { message: 'Invalid extend request.', code: 1004 },
          INVALID_SESSION_SETTLE_REQUEST: {
            message: 'Invalid session settle request.',
            code: 1005,
          },
          UNAUTHORIZED_METHOD: { message: 'Unauthorized method.', code: 3001 },
          UNAUTHORIZED_EVENT: { message: 'Unauthorized event.', code: 3002 },
          UNAUTHORIZED_UPDATE_REQUEST: { message: 'Unauthorized update request.', code: 3003 },
          UNAUTHORIZED_EXTEND_REQUEST: { message: 'Unauthorized extend request.', code: 3004 },
          USER_REJECTED: { message: 'User rejected.', code: 5e3 },
          USER_REJECTED_CHAINS: { message: 'User rejected chains.', code: 5001 },
          USER_REJECTED_METHODS: { message: 'User rejected methods.', code: 5002 },
          USER_REJECTED_EVENTS: { message: 'User rejected events.', code: 5003 },
          UNSUPPORTED_CHAINS: { message: 'Unsupported chains.', code: 5100 },
          UNSUPPORTED_METHODS: { message: 'Unsupported methods.', code: 5101 },
          UNSUPPORTED_EVENTS: { message: 'Unsupported events.', code: 5102 },
          UNSUPPORTED_ACCOUNTS: { message: 'Unsupported accounts.', code: 5103 },
          UNSUPPORTED_NAMESPACE_KEY: { message: 'Unsupported namespace key.', code: 5104 },
          USER_DISCONNECTED: { message: 'User disconnected.', code: 6e3 },
          SESSION_SETTLEMENT_FAILED: { message: 'Session settlement failed.', code: 7e3 },
          WC_METHOD_UNSUPPORTED: { message: 'Unsupported wc_ method.', code: 10001 },
        },
        l$ = {
          NOT_INITIALIZED: { message: 'Not initialized.', code: 1 },
          NO_MATCHING_KEY: { message: 'No matching key.', code: 2 },
          RESTORE_WILL_OVERRIDE: { message: 'Restore will override.', code: 3 },
          RESUBSCRIBED: { message: 'Resubscribed.', code: 4 },
          MISSING_OR_INVALID: { message: 'Missing or invalid.', code: 5 },
          EXPIRED: { message: 'Expired.', code: 6 },
          UNKNOWN_TYPE: { message: 'Unknown type.', code: 7 },
          MISMATCHED_TOPIC: { message: 'Mismatched topic.', code: 8 },
          NON_CONFORMING_NAMESPACES: { message: 'Non conforming namespaces.', code: 9 },
        };
      function lz(e, t) {
        let { message: n, code: r } = l$[e];
        return { message: t ? `${n} ${t}` : n, code: r };
      }
      function lW(e, t) {
        let { message: n, code: r } = lV[e];
        return { message: t ? `${n} ${t}` : n, code: r };
      }
      function lH(e, t) {
        return !!Array.isArray(e) && (!('u' > typeof t) || !e.length || e.every(t));
      }
      function lG(e) {
        return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;
      }
      function lK(e) {
        return typeof e > 'u';
      }
      function lQ(e, t) {
        return !!(t && lK(e)) || ('string' == typeof e && !!e.trim().length);
      }
      function lY(e, t) {
        return !!(t && lK(e)) || ('number' == typeof e && !isNaN(e));
      }
      function lZ(e) {
        return !!(lQ(e, !1) && e.includes(':')) && 2 === e.split(':').length;
      }
      function lJ(e) {
        let t = !0;
        return lH(e) ? e.length && (t = e.every((e) => lQ(e, !1))) : (t = !1), t;
      }
      function lX(e, t) {
        let n = null;
        return (
          Object.values(e).forEach((e) => {
            var r;
            let i;
            if (n) return;
            let a =
              ((r = `${t}, namespace`),
              (i = null),
              lJ(e?.methods)
                ? lJ(e?.events) ||
                  (i = lW(
                    'UNSUPPORTED_EVENTS',
                    `${r}, events should be an array of strings or empty array for no events`
                  ))
                : (i = lW(
                    'UNSUPPORTED_METHODS',
                    `${r}, methods should be an array of strings or empty array for no methods`
                  )),
              i);
            a && (n = a);
          }),
          n
        );
      }
      function l0(e, t) {
        let n = null;
        if (e && lG(e)) {
          let r;
          let i = lX(e, t);
          i && (n = i);
          let a =
            ((r = null),
            Object.values(e).forEach((e) => {
              var n, i;
              let a;
              if (r) return;
              let s =
                ((n = e?.accounts),
                (i = `${t} namespace`),
                (a = null),
                lH(n)
                  ? n.forEach((e) => {
                      a ||
                        (function (e) {
                          if (lQ(e, !1) && e.includes(':')) {
                            let t = e.split(':');
                            if (3 === t.length) {
                              let e = t[0] + ':' + t[1];
                              return !!t[2] && lZ(e);
                            }
                          }
                          return !1;
                        })(e) ||
                        (a = lW(
                          'UNSUPPORTED_ACCOUNTS',
                          `${i}, account ${e} should be a string and conform to "namespace:chainId:address" format`
                        ));
                    })
                  : (a = lW(
                      'UNSUPPORTED_ACCOUNTS',
                      `${i}, accounts should be an array of strings conforming to "namespace:chainId:address" format`
                    )),
                a);
              s && (r = s);
            }),
            r);
          a && (n = a);
        } else n = lz('MISSING_OR_INVALID', `${t}, namespaces should be an object with data`);
        return n;
      }
      function l1(e) {
        return lQ(e.protocol, !0);
      }
      function l2(e) {
        return 'u' > typeof e;
      }
      function l6(e, t) {
        return !(
          !lZ(t) ||
          !(function (e) {
            let t = [];
            return (
              Object.values(e).forEach((e) => {
                t.push(...lL(e.accounts));
              }),
              t
            );
          })(e).includes(t)
        );
      }
      function l5(e, t, n) {
        let r = null,
          i = (function (e) {
            let t = {};
            return (
              Object.keys(e).forEach((n) => {
                var r;
                n.includes(':')
                  ? (t[n] = e[n])
                  : null == (r = e[n].chains) ||
                    r.forEach((r) => {
                      t[r] = { methods: e[n].methods, events: e[n].events };
                    });
              }),
              t
            );
          })(e),
          a = (function (e) {
            let t = {};
            return (
              Object.keys(e).forEach((n) => {
                if (n.includes(':')) t[n] = e[n];
                else {
                  let r = lL(e[n].accounts);
                  r?.forEach((r) => {
                    t[r] = {
                      accounts: e[n].accounts.filter((e) => e.includes(`${r}:`)),
                      methods: e[n].methods,
                      events: e[n].events,
                    };
                  });
                }
              }),
              t
            );
          })(t),
          s = Object.keys(i),
          o = Object.keys(a),
          l = l8(Object.keys(e)),
          u = l8(Object.keys(t)),
          c = l.filter((e) => !u.includes(e));
        return (
          c.length &&
            (r = lz(
              'NON_CONFORMING_NAMESPACES',
              `${n} namespaces keys don't satisfy requiredNamespaces.
      Required: ${c.toString()}
      Received: ${Object.keys(t).toString()}`
            )),
          ab(s, o) ||
            (r = lz(
              'NON_CONFORMING_NAMESPACES',
              `${n} namespaces chains don't satisfy required namespaces.
      Required: ${s.toString()}
      Approved: ${o.toString()}`
            )),
          Object.keys(t).forEach((e) => {
            if (!e.includes(':') || r) return;
            let i = lL(t[e].accounts);
            i.includes(e) ||
              (r = lz(
                'NON_CONFORMING_NAMESPACES',
                `${n} namespaces accounts don't satisfy namespace accounts for ${e}
        Required: ${e}
        Approved: ${i.toString()}`
              ));
          }),
          s.forEach((e) => {
            r ||
              (ab(i[e].methods, a[e].methods)
                ? ab(i[e].events, a[e].events) ||
                  (r = lz(
                    'NON_CONFORMING_NAMESPACES',
                    `${n} namespaces events don't satisfy namespace events for ${e}`
                  ))
                : (r = lz(
                    'NON_CONFORMING_NAMESPACES',
                    `${n} namespaces methods don't satisfy namespace methods for ${e}`
                  )));
          }),
          r
        );
      }
      function l8(e) {
        return [...new Set(e.map((e) => (e.includes(':') ? e.split(':')[0] : e)))];
      }
      function l3() {
        let e = ay();
        return new Promise((t) => {
          switch (e) {
            case ac.browser:
              t(ah() && navigator?.onLine);
              break;
            case ac.reactNative:
              t(l4());
              break;
            case ac.node:
            default:
              t(!0);
          }
        });
      }
      async function l4() {
        if (ap() && 'u' > typeof n.g && null != n.g && n.g.NetInfo) {
          let e = await (null == n.g ? void 0 : n.g.NetInfo.fetch());
          return e?.isConnected;
        }
        return !0;
      }
      let l9 = {};
      class l7 {
        static get(e) {
          return l9[e];
        }
        static set(e, t) {
          l9[e] = t;
        }
        static delete(e) {
          delete l9[e];
        }
      }
      let ue = 'INTERNAL_ERROR',
        ut = 'SERVER_ERROR',
        un = [-32700, -32600, -32601, -32602, -32603],
        ur = {
          PARSE_ERROR: { code: -32700, message: 'Parse error' },
          INVALID_REQUEST: { code: -32600, message: 'Invalid Request' },
          METHOD_NOT_FOUND: { code: -32601, message: 'Method not found' },
          INVALID_PARAMS: { code: -32602, message: 'Invalid params' },
          [ue]: { code: -32603, message: 'Internal error' },
          [ut]: { code: -32e3, message: 'Server error' },
        };
      function ui(e) {
        return Object.keys(ur).includes(e) ? ur[e] : ur[ut];
      }
      function ua(e, t, n) {
        return e.message.includes('getaddrinfo ENOTFOUND') ||
          e.message.includes('connect ECONNREFUSED')
          ? Error(`Unavailable ${n} RPC url at ${t}`)
          : e;
      }
      var us = n(67437);
      function uo(e = 3) {
        return Date.now() * Math.pow(10, e) + Math.floor(Math.random() * Math.pow(10, e));
      }
      function ul(e = 6) {
        return BigInt(uo(e));
      }
      function uu(e, t, n) {
        return { id: n || uo(), jsonrpc: '2.0', method: e, params: t };
      }
      function uc(e, t) {
        return { id: e, jsonrpc: '2.0', result: t };
      }
      function ud(e, t, n) {
        var r, i, a;
        return {
          id: e,
          jsonrpc: '2.0',
          error:
            void 0 === (r = t)
              ? ui(ue)
              : ('string' == typeof r &&
                  (r = Object.assign(Object.assign({}, ui(ut)), { message: r })),
                void 0 !== n && (r.data = n),
                (i = r.code),
                un.includes(i) &&
                  ((a = r.code), (r = Object.values(ur).find((e) => e.code === a) || ur[ut])),
                r),
        };
      }
      class up {}
      class uh extends up {
        constructor() {
          super();
        }
      }
      class uy extends uh {
        constructor(e) {
          super();
        }
      }
      function uf(e, t) {
        let n = (function (e) {
          let t = e.match(RegExp(/^\w+:/, 'gi'));
          if (t && t.length) return t[0];
        })(e);
        return void 0 !== n && new RegExp(t).test(n);
      }
      function um(e) {
        return uf(e, '^https?:');
      }
      function ug(e) {
        return uf(e, '^wss?:');
      }
      function ub(e) {
        return 'object' == typeof e && 'id' in e && 'jsonrpc' in e && '2.0' === e.jsonrpc;
      }
      function uw(e) {
        return ub(e) && 'method' in e;
      }
      function uv(e) {
        return ub(e) && (uT(e) || uA(e));
      }
      function uT(e) {
        return 'result' in e;
      }
      function uA(e) {
        return 'error' in e;
      }
      class uE extends uy {
        constructor(e) {
          super(e),
            (this.events = new b.EventEmitter()),
            (this.hasRegisteredEventListeners = !1),
            (this.connection = this.setConnection(e)),
            this.connection.connected && this.registerEventListeners();
        }
        async connect(e = this.connection) {
          await this.open(e);
        }
        async disconnect() {
          await this.close();
        }
        on(e, t) {
          this.events.on(e, t);
        }
        once(e, t) {
          this.events.once(e, t);
        }
        off(e, t) {
          this.events.off(e, t);
        }
        removeListener(e, t) {
          this.events.removeListener(e, t);
        }
        async request(e, t) {
          return this.requestStrict(uu(e.method, e.params || [], e.id || ul().toString()), t);
        }
        async requestStrict(e, t) {
          return new Promise(async (n, r) => {
            if (!this.connection.connected)
              try {
                await this.open();
              } catch (e) {
                r(e);
              }
            this.events.on(`${e.id}`, (e) => {
              uA(e) ? r(e.error) : n(e.result);
            });
            try {
              await this.connection.send(e, t);
            } catch (e) {
              r(e);
            }
          });
        }
        setConnection(e = this.connection) {
          return e;
        }
        onPayload(e) {
          this.events.emit('payload', e),
            uv(e)
              ? this.events.emit(`${e.id}`, e)
              : this.events.emit('message', { type: e.method, data: e.params });
        }
        onClose(e) {
          e &&
            3e3 === e.code &&
            this.events.emit(
              'error',
              Error(
                `WebSocket connection closed abnormally with code: ${e.code} ${e.reason ? `(${e.reason})` : ''}`
              )
            ),
            this.events.emit('disconnect');
        }
        async open(e = this.connection) {
          (this.connection === e && this.connection.connected) ||
            (this.connection.connected && this.close(),
            'string' == typeof e && (await this.connection.open(e), (e = this.connection)),
            (this.connection = this.setConnection(e)),
            await this.connection.open(),
            this.registerEventListeners(),
            this.events.emit('connect'));
        }
        async close() {
          await this.connection.close();
        }
        registerEventListeners() {
          this.hasRegisteredEventListeners ||
            (this.connection.on('payload', (e) => this.onPayload(e)),
            this.connection.on('close', (e) => this.onClose(e)),
            this.connection.on('error', (e) => this.events.emit('error', e)),
            this.connection.on('register_error', (e) => this.onClose()),
            (this.hasRegisteredEventListeners = !0));
        }
      }
      let uC = () =>
          'u' > typeof WebSocket ||
          ('u' > typeof n.g && 'u' > typeof n.g.WebSocket) ||
          ('u' > typeof window && 'u' > typeof window.WebSocket) ||
          ('u' > typeof self && 'u' > typeof self.WebSocket),
        u_ = (e) => e.split('?')[0],
        uI =
          'u' > typeof WebSocket
            ? WebSocket
            : 'u' > typeof n.g && 'u' > typeof n.g.WebSocket
              ? n.g.WebSocket
              : 'u' > typeof window && 'u' > typeof window.WebSocket
                ? window.WebSocket
                : 'u' > typeof self && 'u' > typeof self.WebSocket
                  ? self.WebSocket
                  : n(96803);
      class uS {
        constructor(e) {
          if (
            ((this.url = e), (this.events = new b.EventEmitter()), (this.registering = !1), !ug(e))
          )
            throw Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
          this.url = e;
        }
        get connected() {
          return 'u' > typeof this.socket;
        }
        get connecting() {
          return this.registering;
        }
        on(e, t) {
          this.events.on(e, t);
        }
        once(e, t) {
          this.events.once(e, t);
        }
        off(e, t) {
          this.events.off(e, t);
        }
        removeListener(e, t) {
          this.events.removeListener(e, t);
        }
        async open(e = this.url) {
          await this.register(e);
        }
        async close() {
          return new Promise((e, t) => {
            if (typeof this.socket > 'u') {
              t(Error('Connection already closed'));
              return;
            }
            (this.socket.onclose = (t) => {
              this.onClose(t), e();
            }),
              this.socket.close();
          });
        }
        async send(e) {
          typeof this.socket > 'u' && (this.socket = await this.register());
          try {
            this.socket.send((0, z.u)(e));
          } catch (t) {
            this.onError(e.id, t);
          }
        }
        register(e = this.url) {
          if (!ug(e)) throw Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
          if (this.registering) {
            let e = this.events.getMaxListeners();
            return (
              (this.events.listenerCount('register_error') >= e ||
                this.events.listenerCount('open') >= e) &&
                this.events.setMaxListeners(e + 1),
              new Promise((e, t) => {
                this.events.once('register_error', (e) => {
                  this.resetMaxListeners(), t(e);
                }),
                  this.events.once('open', () => {
                    if ((this.resetMaxListeners(), typeof this.socket > 'u'))
                      return t(Error('WebSocket connection is missing or invalid'));
                    e(this.socket);
                  });
              })
            );
          }
          return (
            (this.url = e),
            (this.registering = !0),
            new Promise((t, n) => {
              let r = (0, us.isReactNative)()
                  ? void 0
                  : { rejectUnauthorized: !RegExp('wss?://localhost(:d{2,5})?').test(e) },
                i = new uI(e, [], r);
              uC()
                ? (i.onerror = (e) => {
                    n(this.emitError(e.error));
                  })
                : i.on('error', (e) => {
                    n(this.emitError(e));
                  }),
                (i.onopen = () => {
                  this.onOpen(i), t(i);
                });
            })
          );
        }
        onOpen(e) {
          (e.onmessage = (e) => this.onPayload(e)),
            (e.onclose = (e) => this.onClose(e)),
            (this.socket = e),
            (this.registering = !1),
            this.events.emit('open');
        }
        onClose(e) {
          (this.socket = void 0), (this.registering = !1), this.events.emit('close', e);
        }
        onPayload(e) {
          if (typeof e.data > 'u') return;
          let t = 'string' == typeof e.data ? (0, z.D)(e.data) : e.data;
          this.events.emit('payload', t);
        }
        onError(e, t) {
          let n = this.parseError(t),
            r = ud(e, n.message || n.toString());
          this.events.emit('payload', r);
        }
        parseError(e, t = this.url) {
          return ua(e, u_(t), 'WS');
        }
        resetMaxListeners() {
          this.events.getMaxListeners() > 10 && this.events.setMaxListeners(10);
        }
        emitError(e) {
          let t = this.parseError(
            Error(e?.message || `WebSocket connection failed for host: ${u_(this.url)}`)
          );
          return this.events.emit('register_error', t), t;
        }
      }
      var uP = n(87150).Buffer,
        uO = n(32608);
      let uN = 'core',
        ux = `wc@2:${uN}:`,
        uM = { logger: 'error' },
        uk = { database: ':memory:' },
        uR = 'client_ed25519_seed',
        uD = v.ONE_DAY,
        uB = v.SIX_HOURS,
        uU = 'wss://relay.walletconnect.org',
        uL = {
          message: 'relayer_message',
          message_ack: 'relayer_message_ack',
          connect: 'relayer_connect',
          disconnect: 'relayer_disconnect',
          error: 'relayer_error',
          connection_stalled: 'relayer_connection_stalled',
          publish: 'relayer_publish',
        },
        uF = { payload: 'payload', connect: 'connect', disconnect: 'disconnect', error: 'error' },
        uj = '2.19.2',
        uq = { link_mode: 'link_mode', relay: 'relay' },
        uV = { inbound: 'inbound', outbound: 'outbound' },
        u$ = 'WALLETCONNECT_LINK_MODE_APPS',
        uz = {
          created: 'subscription_created',
          deleted: 'subscription_deleted',
          sync: 'subscription_sync',
          resubscribed: 'subscription_resubscribed',
        },
        uW =
          (v.FIVE_SECONDS,
          {
            wc_pairingDelete: {
              req: { ttl: v.ONE_DAY, prompt: !1, tag: 1e3 },
              res: { ttl: v.ONE_DAY, prompt: !1, tag: 1001 },
            },
            wc_pairingPing: {
              req: { ttl: v.THIRTY_SECONDS, prompt: !1, tag: 1002 },
              res: { ttl: v.THIRTY_SECONDS, prompt: !1, tag: 1003 },
            },
            unregistered_method: {
              req: { ttl: v.ONE_DAY, prompt: !1, tag: 0 },
              res: { ttl: v.ONE_DAY, prompt: !1, tag: 0 },
            },
          }),
        uH = {
          create: 'pairing_create',
          expire: 'pairing_expire',
          delete: 'pairing_delete',
          ping: 'pairing_ping',
        },
        uG = {
          created: 'history_created',
          updated: 'history_updated',
          deleted: 'history_deleted',
          sync: 'history_sync',
        },
        uK = {
          created: 'expirer_created',
          deleted: 'expirer_deleted',
          expired: 'expirer_expired',
          sync: 'expirer_sync',
        },
        uQ = 'https://verify.walletconnect.org',
        uY = `${uQ}/v3`,
        uZ = ['https://verify.walletconnect.com', uQ],
        uJ = {
          pairing_started: 'pairing_started',
          pairing_uri_validation_success: 'pairing_uri_validation_success',
          pairing_uri_not_expired: 'pairing_uri_not_expired',
          store_new_pairing: 'store_new_pairing',
          subscribing_pairing_topic: 'subscribing_pairing_topic',
          subscribe_pairing_topic_success: 'subscribe_pairing_topic_success',
          existing_pairing: 'existing_pairing',
          pairing_not_expired: 'pairing_not_expired',
          emit_inactive_pairing: 'emit_inactive_pairing',
          emit_session_proposal: 'emit_session_proposal',
        },
        uX = {
          no_internet_connection: 'no_internet_connection',
          malformed_pairing_uri: 'malformed_pairing_uri',
          active_pairing_already_exists: 'active_pairing_already_exists',
          subscribe_pairing_topic_failure: 'subscribe_pairing_topic_failure',
          pairing_expired: 'pairing_expired',
          proposal_listener_not_found: 'proposal_listener_not_found',
        },
        u0 = {
          session_approve_started: 'session_approve_started',
          session_namespaces_validation_success: 'session_namespaces_validation_success',
          subscribing_session_topic: 'subscribing_session_topic',
          subscribe_session_topic_success: 'subscribe_session_topic_success',
          publishing_session_approve: 'publishing_session_approve',
          session_approve_publish_success: 'session_approve_publish_success',
          store_session: 'store_session',
          publishing_session_settle: 'publishing_session_settle',
          session_settle_publish_success: 'session_settle_publish_success',
        },
        u1 = {
          no_internet_connection: 'no_internet_connection',
          proposal_expired: 'proposal_expired',
          subscribe_session_topic_failure: 'subscribe_session_topic_failure',
          session_approve_publish_failure: 'session_approve_publish_failure',
          session_settle_publish_failure: 'session_settle_publish_failure',
          session_approve_namespace_validation_failure:
            'session_approve_namespace_validation_failure',
          proposal_not_found: 'proposal_not_found',
        },
        u2 = {
          authenticated_session_approve_started: 'authenticated_session_approve_started',
          create_authenticated_session_topic: 'create_authenticated_session_topic',
          cacaos_verified: 'cacaos_verified',
          store_authenticated_session: 'store_authenticated_session',
          subscribing_authenticated_session_topic: 'subscribing_authenticated_session_topic',
          subscribe_authenticated_session_topic_success:
            'subscribe_authenticated_session_topic_success',
          publishing_authenticated_session_approve: 'publishing_authenticated_session_approve',
        },
        u6 = {
          no_internet_connection: 'no_internet_connection',
          invalid_cacao: 'invalid_cacao',
          subscribe_authenticated_session_topic_failure:
            'subscribe_authenticated_session_topic_failure',
          authenticated_session_approve_publish_failure:
            'authenticated_session_approve_publish_failure',
          authenticated_session_pending_request_not_found:
            'authenticated_session_pending_request_not_found',
        };
      var u5 = function (e, t) {
        if (e.length >= 255) throw TypeError('Alphabet too long');
        for (var n = new Uint8Array(256), r = 0; r < n.length; r++) n[r] = 255;
        for (var i = 0; i < e.length; i++) {
          var a = e.charAt(i),
            s = a.charCodeAt(0);
          if (255 !== n[s]) throw TypeError(a + ' is ambiguous');
          n[s] = i;
        }
        var o = e.length,
          l = e.charAt(0),
          u = Math.log(o) / Math.log(256),
          c = Math.log(256) / Math.log(o);
        function d(e) {
          if ('string' != typeof e) throw TypeError('Expected String');
          if (0 === e.length) return new Uint8Array();
          var t = 0;
          if (' ' !== e[0]) {
            for (var r = 0, i = 0; e[t] === l; ) r++, t++;
            for (var a = ((e.length - t) * u + 1) >>> 0, s = new Uint8Array(a); e[t]; ) {
              var c = n[e.charCodeAt(t)];
              if (255 === c) return;
              for (var d = 0, p = a - 1; (0 !== c || d < i) && -1 !== p; p--, d++)
                (c += (o * s[p]) >>> 0), (s[p] = c % 256 >>> 0), (c = (c / 256) >>> 0);
              if (0 !== c) throw Error('Non-zero carry');
              (i = d), t++;
            }
            if (' ' !== e[t]) {
              for (var h = a - i; h !== a && 0 === s[h]; ) h++;
              for (var y = new Uint8Array(r + (a - h)), f = r; h !== a; ) y[f++] = s[h++];
              return y;
            }
          }
        }
        return {
          encode: function (t) {
            if (
              (t instanceof Uint8Array ||
                (ArrayBuffer.isView(t)
                  ? (t = new Uint8Array(t.buffer, t.byteOffset, t.byteLength))
                  : Array.isArray(t) && (t = Uint8Array.from(t))),
              !(t instanceof Uint8Array))
            )
              throw TypeError('Expected Uint8Array');
            if (0 === t.length) return '';
            for (var n = 0, r = 0, i = 0, a = t.length; i !== a && 0 === t[i]; ) i++, n++;
            for (var s = ((a - i) * c + 1) >>> 0, u = new Uint8Array(s); i !== a; ) {
              for (var d = t[i], p = 0, h = s - 1; (0 !== d || p < r) && -1 !== h; h--, p++)
                (d += (256 * u[h]) >>> 0), (u[h] = d % o >>> 0), (d = (d / o) >>> 0);
              if (0 !== d) throw Error('Non-zero carry');
              (r = p), i++;
            }
            for (var y = s - r; y !== s && 0 === u[y]; ) y++;
            for (var f = l.repeat(n); y < s; ++y) f += e.charAt(u[y]);
            return f;
          },
          decodeUnsafe: d,
          decode: function (e) {
            var n = d(e);
            if (n) return n;
            throw Error(`Non-${t} character`);
          },
        };
      };
      let u8 = (e) => {
          if (e instanceof Uint8Array && 'Uint8Array' === e.constructor.name) return e;
          if (e instanceof ArrayBuffer) return new Uint8Array(e);
          if (ArrayBuffer.isView(e)) return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
          throw Error('Unknown type, must be binary type');
        },
        u3 = (e) => new TextEncoder().encode(e),
        u4 = (e) => new TextDecoder().decode(e);
      class u9 {
        constructor(e, t, n) {
          (this.name = e), (this.prefix = t), (this.baseEncode = n);
        }
        encode(e) {
          if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
          throw Error('Unknown type, must be binary type');
        }
      }
      class u7 {
        constructor(e, t, n) {
          if (((this.name = e), (this.prefix = t), void 0 === t.codePointAt(0)))
            throw Error('Invalid prefix character');
          (this.prefixCodePoint = t.codePointAt(0)), (this.baseDecode = n);
        }
        decode(e) {
          if ('string' == typeof e) {
            if (e.codePointAt(0) !== this.prefixCodePoint)
              throw Error(
                `Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`
              );
            return this.baseDecode(e.slice(this.prefix.length));
          }
          throw Error('Can only multibase decode strings');
        }
        or(e) {
          return ct(this, e);
        }
      }
      class ce {
        constructor(e) {
          this.decoders = e;
        }
        or(e) {
          return ct(this, e);
        }
        decode(e) {
          let t = e[0],
            n = this.decoders[t];
          if (n) return n.decode(e);
          throw RangeError(
            `Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`
          );
        }
      }
      let ct = (e, t) =>
        new ce({ ...(e.decoders || { [e.prefix]: e }), ...(t.decoders || { [t.prefix]: t }) });
      class cn {
        constructor(e, t, n, r) {
          (this.name = e),
            (this.prefix = t),
            (this.baseEncode = n),
            (this.baseDecode = r),
            (this.encoder = new u9(e, t, n)),
            (this.decoder = new u7(e, t, r));
        }
        encode(e) {
          return this.encoder.encode(e);
        }
        decode(e) {
          return this.decoder.decode(e);
        }
      }
      let cr = ({ name: e, prefix: t, encode: n, decode: r }) => new cn(e, t, n, r),
        ci = ({ prefix: e, name: t, alphabet: n }) => {
          let { encode: r, decode: i } = u5(n, t);
          return cr({ prefix: e, name: t, encode: r, decode: (e) => u8(i(e)) });
        },
        ca = (e, t, n, r) => {
          let i = {};
          for (let e = 0; e < t.length; ++e) i[t[e]] = e;
          let a = e.length;
          for (; '=' === e[a - 1]; ) --a;
          let s = new Uint8Array(((a * n) / 8) | 0),
            o = 0,
            l = 0,
            u = 0;
          for (let t = 0; t < a; ++t) {
            let a = i[e[t]];
            if (void 0 === a) throw SyntaxError(`Non-${r} character`);
            (l = (l << n) | a), (o += n) >= 8 && ((o -= 8), (s[u++] = 255 & (l >> o)));
          }
          if (o >= n || 255 & (l << (8 - o))) throw SyntaxError('Unexpected end of data');
          return s;
        },
        cs = (e, t, n) => {
          let r = '=' === t[t.length - 1],
            i = (1 << n) - 1,
            a = '',
            s = 0,
            o = 0;
          for (let r = 0; r < e.length; ++r)
            for (o = (o << 8) | e[r], s += 8; s > n; ) (s -= n), (a += t[i & (o >> s)]);
          if ((s && (a += t[i & (o << (n - s))]), r)) for (; (a.length * n) & 7; ) a += '=';
          return a;
        },
        co = ({ name: e, prefix: t, bitsPerChar: n, alphabet: r }) =>
          cr({ prefix: t, name: e, encode: (e) => cs(e, r, n), decode: (t) => ca(t, r, n, e) });
      var cl = Object.freeze({
          __proto__: null,
          identity: cr({
            prefix: '\0',
            name: 'identity',
            encode: (e) => u4(e),
            decode: (e) => u3(e),
          }),
        }),
        cu = Object.freeze({
          __proto__: null,
          base2: co({ prefix: '0', name: 'base2', alphabet: '01', bitsPerChar: 1 }),
        }),
        cc = Object.freeze({
          __proto__: null,
          base8: co({ prefix: '7', name: 'base8', alphabet: '01234567', bitsPerChar: 3 }),
        }),
        cd = Object.freeze({
          __proto__: null,
          base10: ci({ prefix: '9', name: 'base10', alphabet: '0123456789' }),
        }),
        cp = Object.freeze({
          __proto__: null,
          base16: co({ prefix: 'f', name: 'base16', alphabet: '0123456789abcdef', bitsPerChar: 4 }),
          base16upper: co({
            prefix: 'F',
            name: 'base16upper',
            alphabet: '0123456789ABCDEF',
            bitsPerChar: 4,
          }),
        });
      let ch = co({
          prefix: 'b',
          name: 'base32',
          alphabet: 'abcdefghijklmnopqrstuvwxyz234567',
          bitsPerChar: 5,
        }),
        cy = co({
          prefix: 'B',
          name: 'base32upper',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
          bitsPerChar: 5,
        }),
        cf = co({
          prefix: 'c',
          name: 'base32pad',
          alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',
          bitsPerChar: 5,
        }),
        cm = co({
          prefix: 'C',
          name: 'base32padupper',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
          bitsPerChar: 5,
        }),
        cg = co({
          prefix: 'v',
          name: 'base32hex',
          alphabet: '0123456789abcdefghijklmnopqrstuv',
          bitsPerChar: 5,
        }),
        cb = co({
          prefix: 'V',
          name: 'base32hexupper',
          alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
          bitsPerChar: 5,
        });
      var cw = Object.freeze({
          __proto__: null,
          base32: ch,
          base32upper: cy,
          base32pad: cf,
          base32padupper: cm,
          base32hex: cg,
          base32hexupper: cb,
          base32hexpad: co({
            prefix: 't',
            name: 'base32hexpad',
            alphabet: '0123456789abcdefghijklmnopqrstuv=',
            bitsPerChar: 5,
          }),
          base32hexpadupper: co({
            prefix: 'T',
            name: 'base32hexpadupper',
            alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
            bitsPerChar: 5,
          }),
          base32z: co({
            prefix: 'h',
            name: 'base32z',
            alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',
            bitsPerChar: 5,
          }),
        }),
        cv = Object.freeze({
          __proto__: null,
          base36: ci({
            prefix: 'k',
            name: 'base36',
            alphabet: '0123456789abcdefghijklmnopqrstuvwxyz',
          }),
          base36upper: ci({
            prefix: 'K',
            name: 'base36upper',
            alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ',
          }),
        }),
        cT = Object.freeze({
          __proto__: null,
          base58btc: ci({
            name: 'base58btc',
            prefix: 'z',
            alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz',
          }),
          base58flickr: ci({
            name: 'base58flickr',
            prefix: 'Z',
            alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ',
          }),
        });
      let cA = co({
        prefix: 'm',
        name: 'base64',
        alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
        bitsPerChar: 6,
      });
      var cE = Object.freeze({
        __proto__: null,
        base64: cA,
        base64pad: co({
          prefix: 'M',
          name: 'base64pad',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
          bitsPerChar: 6,
        }),
        base64url: co({
          prefix: 'u',
          name: 'base64url',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
          bitsPerChar: 6,
        }),
        base64urlpad: co({
          prefix: 'U',
          name: 'base64urlpad',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
          bitsPerChar: 6,
        }),
      });
      let cC = Array.from(
          '\uD83D\uDE80\uD83E\uDE90\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\uD83E\uDD19\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\uD83C\uDF1E\uD83C\uDF88\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\uD83D\uDC8E\uD83D\uDCB8\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42'
        ),
        c_ = cC.reduce((e, t, n) => ((e[n] = t), e), []),
        cI = cC.reduce((e, t, n) => ((e[t.codePointAt(0)] = n), e), []);
      var cS = Object.freeze({
        __proto__: null,
        base256emoji: cr({
          prefix: '\uD83D\uDE80',
          name: 'base256emoji',
          encode: function (e) {
            return e.reduce((e, t) => (e += c_[t]), '');
          },
          decode: function (e) {
            let t = [];
            for (let n of e) {
              let e = cI[n.codePointAt(0)];
              if (void 0 === e) throw Error(`Non-base256emoji character: ${n}`);
              t.push(e);
            }
            return new Uint8Array(t);
          },
        }),
      });
      function cP(e, t) {
        var n,
          r = 0,
          t = t || 0,
          i = 0,
          a = t,
          s = e.length;
        do {
          if (a >= s) throw ((cP.bytes = 0), RangeError('Could not decode varint'));
          (n = e[a++]), (r += i < 28 ? (127 & n) << i : (127 & n) * Math.pow(2, i)), (i += 7);
        } while (n >= 128);
        return (cP.bytes = a - t), r;
      }
      var cO = function e(t, n, r) {
        (n = n || []), (r = r || 0);
        for (var i = r; t >= 2147483648; ) (n[r++] = (255 & t) | 128), (t /= 128);
        for (; -128 & t; ) (n[r++] = (255 & t) | 128), (t >>>= 7);
        return (n[r] = 0 | t), (e.bytes = r - i + 1), n;
      };
      let cN = (e, t, n = 0) => (cO(e, t, n), t),
        cx = (e) =>
          e < 128
            ? 1
            : e < 16384
              ? 2
              : e < 2097152
                ? 3
                : e < 268435456
                  ? 4
                  : e < 34359738368
                    ? 5
                    : e < 4398046511104
                      ? 6
                      : e < 562949953421312
                        ? 7
                        : e < 72057594037927940
                          ? 8
                          : e < 0x7fffffffffffffff
                            ? 9
                            : 10,
        cM = (e, t) => {
          let n = t.byteLength,
            r = cx(e),
            i = r + cx(n),
            a = new Uint8Array(i + n);
          return cN(e, a, 0), cN(n, a, r), a.set(t, i), new ck(e, n, t, a);
        };
      class ck {
        constructor(e, t, n, r) {
          (this.code = e), (this.size = t), (this.digest = n), (this.bytes = r);
        }
      }
      let cR = ({ name: e, code: t, encode: n }) => new cD(e, t, n);
      class cD {
        constructor(e, t, n) {
          (this.name = e), (this.code = t), (this.encode = n);
        }
        digest(e) {
          if (e instanceof Uint8Array) {
            let t = this.encode(e);
            return t instanceof Uint8Array ? cM(this.code, t) : t.then((e) => cM(this.code, e));
          }
          throw Error('Unknown type, must be binary type');
        }
      }
      let cB = (e) => async (t) => new Uint8Array(await crypto.subtle.digest(e, t));
      var cU = Object.freeze({
          __proto__: null,
          sha256: cR({ name: 'sha2-256', code: 18, encode: cB('SHA-256') }),
          sha512: cR({ name: 'sha2-512', code: 19, encode: cB('SHA-512') }),
        }),
        cL = Object.freeze({
          __proto__: null,
          identity: { code: 0, name: 'identity', encode: u8, digest: (e) => cM(0, u8(e)) },
        });
      new TextEncoder(), new TextDecoder();
      let cF = { ...cl, ...cu, ...cc, ...cd, ...cp, ...cw, ...cv, ...cT, ...cE, ...cS };
      function cj(e, t, n, r) {
        return {
          name: e,
          prefix: t,
          encoder: { name: e, prefix: t, encode: n },
          decoder: { decode: r },
        };
      }
      ({ ...cU, ...cL });
      let cq = cj(
          'utf8',
          'u',
          (e) => 'u' + new TextDecoder('utf8').decode(e),
          (e) => new TextEncoder().encode(e.substring(1))
        ),
        cV = cj(
          'ascii',
          'a',
          (e) => {
            let t = 'a';
            for (let n = 0; n < e.length; n++) t += String.fromCharCode(e[n]);
            return t;
          },
          (e) => {
            let t = (function (e = 0) {
              return null != globalThis.Buffer && null != globalThis.Buffer.allocUnsafe
                ? globalThis.Buffer.allocUnsafe(e)
                : new Uint8Array(e);
            })((e = e.substring(1)).length);
            for (let n = 0; n < e.length; n++) t[n] = e.charCodeAt(n);
            return t;
          }
        ),
        c$ = { utf8: cq, 'utf-8': cq, hex: cF.base16, latin1: cV, ascii: cV, binary: cV, ...cF };
      var cz = Object.defineProperty,
        cW = (e, t, n) =>
          t in e
            ? cz(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        cH = (e, t, n) => cW(e, 'symbol' != typeof t ? t + '' : t, n);
      class cG {
        constructor(e, t) {
          (this.core = e),
            (this.logger = t),
            cH(this, 'keychain', new Map()),
            cH(this, 'name', 'keychain'),
            cH(this, 'version', '0.3'),
            cH(this, 'initialized', !1),
            cH(this, 'storagePrefix', ux),
            cH(this, 'init', async () => {
              if (!this.initialized) {
                let e = await this.getKeyChain();
                'u' > typeof e && (this.keychain = e), (this.initialized = !0);
              }
            }),
            cH(this, 'has', (e) => (this.isInitialized(), this.keychain.has(e))),
            cH(this, 'set', async (e, t) => {
              this.isInitialized(), this.keychain.set(e, t), await this.persist();
            }),
            cH(this, 'get', (e) => {
              this.isInitialized();
              let t = this.keychain.get(e);
              if (typeof t > 'u') {
                let { message: t } = lz('NO_MATCHING_KEY', `${this.name}: ${e}`);
                throw Error(t);
              }
              return t;
            }),
            cH(this, 'del', async (e) => {
              this.isInitialized(), this.keychain.delete(e), await this.persist();
            }),
            (this.core = e),
            (this.logger = (0, ee.Ep)(t, this.name));
        }
        get context() {
          return (0, ee.Fd)(this.logger);
        }
        get storageKey() {
          return (
            this.storagePrefix + this.version + this.core.customStoragePrefix + '//' + this.name
          );
        }
        async setKeyChain(e) {
          await this.core.storage.setItem(this.storageKey, aw(e));
        }
        async getKeyChain() {
          let e = await this.core.storage.getItem(this.storageKey);
          return 'u' > typeof e ? av(e) : void 0;
        }
        async persist() {
          await this.setKeyChain(this.keychain);
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = lz('NOT_INITIALIZED', this.name);
            throw Error(e);
          }
        }
      }
      var cK = Object.defineProperty,
        cQ = (e, t, n) =>
          t in e
            ? cK(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        cY = (e, t, n) => cQ(e, 'symbol' != typeof t ? t + '' : t, n);
      class cZ {
        constructor(e, t, n) {
          (this.core = e),
            (this.logger = t),
            cY(this, 'name', 'crypto'),
            cY(this, 'keychain'),
            cY(this, 'randomSessionIdentifier', lE()),
            cY(this, 'initialized', !1),
            cY(this, 'init', async () => {
              this.initialized || (await this.keychain.init(), (this.initialized = !0));
            }),
            cY(this, 'hasKeys', (e) => (this.isInitialized(), this.keychain.has(e))),
            cY(
              this,
              'getClientId',
              async () => (this.isInitialized(), nx(nk(await this.getClientSeed()).publicKey))
            ),
            cY(this, 'generateKeyPair', () => {
              this.isInitialized();
              let e = (function () {
                let e = lo.utils.randomPrivateKey(),
                  t = lo.getPublicKey(e);
                return { privateKey: i8(e, lw), publicKey: i8(t, lw) };
              })();
              return this.setPrivateKey(e.publicKey, e.privateKey);
            }),
            cY(this, 'signJWT', async (e) => {
              this.isInitialized();
              let t = nk(await this.getClientSeed()),
                n = this.randomSessionIdentifier;
              return await nR(n, e, uD, t);
            }),
            cY(this, 'generateSharedKey', (e, t, n) => {
              var r;
              this.isInitialized();
              let i =
                ((r = this.getPrivateKey(e)),
                i8(ot(oo, lo.getSharedSecret(i5(r, lw), i5(t, lw)), void 0, void 0, 32), lw));
              return this.setSymKey(i, n);
            }),
            cY(this, 'setSymKey', async (e, t) => {
              this.isInitialized();
              let n = t || lC(e);
              return await this.keychain.set(n, e), n;
            }),
            cY(this, 'deleteKeyPair', async (e) => {
              this.isInitialized(), await this.keychain.del(e);
            }),
            cY(this, 'deleteSymKey', async (e) => {
              this.isInitialized(), await this.keychain.del(e);
            }),
            cY(this, 'encode', async (e, t, n) => {
              this.isInitialized();
              let r = lx(n),
                i = (0, z.u)(t);
              if (2 === r.type)
                return (function (e, t) {
                  let n = i5('2', lb),
                    r = a0(12),
                    i = lO({ type: n, sealed: i5(e, lA), iv: r });
                  return t === lT ? lS(i) : i;
                })(i, n?.encoding);
              if (lM(r)) {
                let t = r.senderPublicKey,
                  n = r.receiverPublicKey;
                e = await this.generateSharedKey(t, n);
              }
              let a = this.getSymKey(e),
                { type: s, senderPublicKey: o } = r;
              return (function (e) {
                var t;
                let n = ((t = 'u' > typeof e.type ? e.type : 0), i5(`${t}`, lb));
                if (1 === lI(n) && typeof e.senderPublicKey > 'u')
                  throw Error('Missing sender public key for type 1 envelope');
                let r = 'u' > typeof e.senderPublicKey ? i5(e.senderPublicKey, lw) : void 0,
                  i = 'u' > typeof e.iv ? i5(e.iv, lw) : a0(12),
                  a = lO({
                    type: n,
                    sealed: s3(i5(e.symKey, lw), i).encrypt(i5(e.message, lA)),
                    iv: i,
                    senderPublicKey: r,
                  });
                return e.encoding === lT ? lS(a) : a;
              })({ type: s, symKey: a, message: i, senderPublicKey: o, encoding: n?.encoding });
            }),
            cY(this, 'decode', async (e, t, n) => {
              this.isInitialized();
              let r = (function (e, t) {
                let n = lN({ encoded: e, encoding: t?.encoding });
                return lx({
                  type: lI(n.type),
                  senderPublicKey:
                    'u' > typeof n.senderPublicKey ? i8(n.senderPublicKey, lw) : void 0,
                  receiverPublicKey: t?.receiverPublicKey,
                });
              })(t, n);
              if (2 === r.type) {
                let e = (function (e, t) {
                  let { sealed: n } = lN({ encoded: e, encoding: t });
                  return i8(n, lA);
                })(t, n?.encoding);
                return (0, z.D)(e);
              }
              if (lM(r)) {
                let t = r.receiverPublicKey,
                  n = r.senderPublicKey;
                e = await this.generateSharedKey(t, n);
              }
              try {
                let r = this.getSymKey(e),
                  i = (function (e) {
                    let t = i5(e.symKey, lw),
                      { sealed: n, iv: r } = lN({ encoded: e.encoded, encoding: e.encoding }),
                      i = s3(t, r).decrypt(n);
                    if (null === i) throw Error('Failed to decrypt');
                    return i8(i, lA);
                  })({ symKey: r, encoded: t, encoding: n?.encoding });
                return (0, z.D)(i);
              } catch (t) {
                this.logger.error(
                  `Failed to decode message from topic: '${e}', clientId: '${await this.getClientId()}'`
                ),
                  this.logger.error(t);
              }
            }),
            cY(this, 'getPayloadType', (e, t = lv) => lI(lN({ encoded: e, encoding: t }).type)),
            cY(this, 'getPayloadSenderPublicKey', (e, t = lv) => {
              let n = lN({ encoded: e, encoding: t });
              return n.senderPublicKey ? i8(n.senderPublicKey, lw) : void 0;
            }),
            (this.core = e),
            (this.logger = (0, ee.Ep)(t, this.name)),
            (this.keychain = n || new cG(this.core, this.logger));
        }
        get context() {
          return (0, ee.Fd)(this.logger);
        }
        async setPrivateKey(e, t) {
          return await this.keychain.set(e, t), e;
        }
        getPrivateKey(e) {
          return this.keychain.get(e);
        }
        async getClientSeed() {
          let e = '';
          try {
            e = this.keychain.get(uR);
          } catch {
            (e = lE()), await this.keychain.set(uR, e);
          }
          return (function (e, t = 'utf8') {
            let n = c$[t];
            if (!n) throw Error(`Unsupported encoding "${t}"`);
            return ('utf8' === t || 'utf-8' === t) &&
              null != globalThis.Buffer &&
              null != globalThis.Buffer.from
              ? globalThis.Buffer.from(e, 'utf8')
              : n.decoder.decode(`${n.prefix}${e}`);
          })(e, 'base16');
        }
        getSymKey(e) {
          return this.keychain.get(e);
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = lz('NOT_INITIALIZED', this.name);
            throw Error(e);
          }
        }
      }
      var cJ = Object.defineProperty,
        cX = Object.defineProperties,
        c0 = Object.getOwnPropertyDescriptors,
        c1 = Object.getOwnPropertySymbols,
        c2 = Object.prototype.hasOwnProperty,
        c6 = Object.prototype.propertyIsEnumerable,
        c5 = (e, t, n) =>
          t in e
            ? cJ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        c8 = (e, t) => {
          for (var n in t || (t = {})) c2.call(t, n) && c5(e, n, t[n]);
          if (c1) for (var n of c1(t)) c6.call(t, n) && c5(e, n, t[n]);
          return e;
        },
        c3 = (e, t) => cX(e, c0(t)),
        c4 = (e, t, n) => c5(e, 'symbol' != typeof t ? t + '' : t, n);
      class c9 extends eu {
        constructor(e, t) {
          super(e, t),
            (this.logger = e),
            (this.core = t),
            c4(this, 'messages', new Map()),
            c4(this, 'messagesWithoutClientAck', new Map()),
            c4(this, 'name', 'messages'),
            c4(this, 'version', '0.3'),
            c4(this, 'initialized', !1),
            c4(this, 'storagePrefix', ux),
            c4(this, 'init', async () => {
              if (!this.initialized) {
                this.logger.trace('Initialized');
                try {
                  let e = await this.getRelayerMessages();
                  'u' > typeof e && (this.messages = e);
                  let t = await this.getRelayerMessagesWithoutClientAck();
                  'u' > typeof t && (this.messagesWithoutClientAck = t),
                    this.logger.debug(`Successfully Restored records for ${this.name}`),
                    this.logger.trace({
                      type: 'method',
                      method: 'restore',
                      size: this.messages.size,
                    });
                } catch (e) {
                  this.logger.debug(`Failed to Restore records for ${this.name}`),
                    this.logger.error(e);
                } finally {
                  this.initialized = !0;
                }
              }
            }),
            c4(this, 'set', async (e, t, n) => {
              this.isInitialized();
              let r = l_(t),
                i = this.messages.get(e);
              if ((typeof i > 'u' && (i = {}), 'u' > typeof i[r])) return r;
              if (((i[r] = t), this.messages.set(e, i), n === uV.inbound)) {
                let n = this.messagesWithoutClientAck.get(e) || {};
                this.messagesWithoutClientAck.set(e, c3(c8({}, n), { [r]: t }));
              }
              return await this.persist(), r;
            }),
            c4(this, 'get', (e) => {
              this.isInitialized();
              let t = this.messages.get(e);
              return typeof t > 'u' && (t = {}), t;
            }),
            c4(this, 'getWithoutAck', (e) => {
              this.isInitialized();
              let t = {};
              for (let n of e) {
                let e = this.messagesWithoutClientAck.get(n) || {};
                t[n] = Object.values(e);
              }
              return t;
            }),
            c4(this, 'has', (e, t) => (this.isInitialized(), 'u' > typeof this.get(e)[l_(t)])),
            c4(this, 'ack', async (e, t) => {
              this.isInitialized();
              let n = this.messagesWithoutClientAck.get(e);
              if (typeof n > 'u') return;
              let r = l_(t);
              delete n[r],
                0 === Object.keys(n).length
                  ? this.messagesWithoutClientAck.delete(e)
                  : this.messagesWithoutClientAck.set(e, n),
                await this.persist();
            }),
            c4(this, 'del', async (e) => {
              this.isInitialized(),
                this.messages.delete(e),
                this.messagesWithoutClientAck.delete(e),
                await this.persist();
            }),
            (this.logger = (0, ee.Ep)(e, this.name)),
            (this.core = t);
        }
        get context() {
          return (0, ee.Fd)(this.logger);
        }
        get storageKey() {
          return (
            this.storagePrefix + this.version + this.core.customStoragePrefix + '//' + this.name
          );
        }
        get storageKeyWithoutClientAck() {
          return (
            this.storagePrefix +
            this.version +
            this.core.customStoragePrefix +
            '//' +
            this.name +
            '_withoutClientAck'
          );
        }
        async setRelayerMessages(e) {
          await this.core.storage.setItem(this.storageKey, aw(e));
        }
        async setRelayerMessagesWithoutClientAck(e) {
          await this.core.storage.setItem(this.storageKeyWithoutClientAck, aw(e));
        }
        async getRelayerMessages() {
          let e = await this.core.storage.getItem(this.storageKey);
          return 'u' > typeof e ? av(e) : void 0;
        }
        async getRelayerMessagesWithoutClientAck() {
          let e = await this.core.storage.getItem(this.storageKeyWithoutClientAck);
          return 'u' > typeof e ? av(e) : void 0;
        }
        async persist() {
          await this.setRelayerMessages(this.messages),
            await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck);
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = lz('NOT_INITIALIZED', this.name);
            throw Error(e);
          }
        }
      }
      var c7 = Object.defineProperty,
        de = Object.defineProperties,
        dt = Object.getOwnPropertyDescriptors,
        dn = Object.getOwnPropertySymbols,
        dr = Object.prototype.hasOwnProperty,
        di = Object.prototype.propertyIsEnumerable,
        da = (e, t, n) =>
          t in e
            ? c7(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        ds = (e, t) => {
          for (var n in t || (t = {})) dr.call(t, n) && da(e, n, t[n]);
          if (dn) for (var n of dn(t)) di.call(t, n) && da(e, n, t[n]);
          return e;
        },
        dl = (e, t) => de(e, dt(t)),
        du = (e, t, n) => da(e, 'symbol' != typeof t ? t + '' : t, n);
      class dc extends ec {
        constructor(e, t) {
          super(e, t),
            (this.relayer = e),
            (this.logger = t),
            du(this, 'events', new b.EventEmitter()),
            du(this, 'name', 'publisher'),
            du(this, 'queue', new Map()),
            du(this, 'publishTimeout', (0, v.toMiliseconds)(v.ONE_MINUTE)),
            du(this, 'initialPublishTimeout', (0, v.toMiliseconds)(15 * v.ONE_SECOND)),
            du(this, 'needsTransportRestart', !1),
            du(this, 'publish', async (e, t, n) => {
              var r;
              this.logger.debug('Publishing Payload'),
                this.logger.trace({
                  type: 'method',
                  method: 'publish',
                  params: { topic: e, message: t, opts: n },
                });
              let i = n?.ttl || uB,
                a = lk(n),
                s = n?.prompt || !1,
                o = n?.tag || 0,
                l = n?.id || ul().toString(),
                u = {
                  topic: e,
                  message: t,
                  opts: {
                    ttl: i,
                    relay: a,
                    prompt: s,
                    tag: o,
                    id: l,
                    attestation: n?.attestation,
                    tvf: n?.tvf,
                  },
                },
                c = `Failed to publish payload, please try again. id:${l} tag:${o}`;
              try {
                let r = new Promise(async (r) => {
                  let a = ({ id: e }) => {
                    u.opts.id === e &&
                      (this.removeRequestFromQueue(e),
                      this.relayer.events.removeListener(uL.publish, a),
                      r(u));
                  };
                  this.relayer.events.on(uL.publish, a);
                  let c = aA(
                    new Promise((r, a) => {
                      this.rpcPublish({
                        topic: e,
                        message: t,
                        ttl: i,
                        prompt: s,
                        tag: o,
                        id: l,
                        attestation: n?.attestation,
                        tvf: n?.tvf,
                      })
                        .then(r)
                        .catch((e) => {
                          this.logger.warn(e, e?.message), a(e);
                        });
                    }),
                    this.initialPublishTimeout,
                    `Failed initial publish, retrying.... id:${l} tag:${o}`
                  );
                  try {
                    await c, this.events.removeListener(uL.publish, a);
                  } catch (e) {
                    this.queue.set(l, dl(ds({}, u), { attempt: 1 })),
                      this.logger.warn(e, e?.message);
                  }
                });
                this.logger.trace({
                  type: 'method',
                  method: 'publish',
                  params: { id: l, topic: e, message: t, opts: n },
                }),
                  await aA(r, this.publishTimeout, c);
              } catch (e) {
                if (
                  (this.logger.debug('Failed to Publish Payload'),
                  this.logger.error(e),
                  null != (r = n?.internal) && r.throwOnFailedPublish)
                )
                  throw e;
              } finally {
                this.queue.delete(l);
              }
            }),
            du(this, 'on', (e, t) => {
              this.events.on(e, t);
            }),
            du(this, 'once', (e, t) => {
              this.events.once(e, t);
            }),
            du(this, 'off', (e, t) => {
              this.events.off(e, t);
            }),
            du(this, 'removeListener', (e, t) => {
              this.events.removeListener(e, t);
            }),
            (this.relayer = e),
            (this.logger = (0, ee.Ep)(t, this.name)),
            this.registerEventListeners();
        }
        get context() {
          return (0, ee.Fd)(this.logger);
        }
        async rpcPublish(e) {
          var t, n, r, i;
          let {
              topic: a,
              message: s,
              ttl: o = uB,
              prompt: l,
              tag: u,
              id: c,
              attestation: d,
              tvf: p,
            } = e,
            h = {
              method: lR(lk().protocol).publish,
              params: ds({ topic: a, message: s, ttl: o, prompt: l, tag: u, attestation: d }, p),
              id: c,
            };
          lK(null == (t = h.params) ? void 0 : t.prompt) &&
            (null == (n = h.params) || delete n.prompt),
            lK(null == (r = h.params) ? void 0 : r.tag) && (null == (i = h.params) || delete i.tag),
            this.logger.debug('Outgoing Relay Payload'),
            this.logger.trace({ type: 'message', direction: 'outgoing', request: h });
          let y = await this.relayer.request(h);
          return (
            this.relayer.events.emit(uL.publish, e),
            this.logger.debug('Successfully Published Payload'),
            y
          );
        }
        removeRequestFromQueue(e) {
          this.queue.delete(e);
        }
        checkQueue() {
          this.queue.forEach(async (e, t) => {
            let n = e.attempt + 1;
            this.queue.set(t, dl(ds({}, e), { attempt: n }));
            let { topic: r, message: i, opts: a, attestation: s } = e;
            this.logger.warn(
              {},
              `Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${n}`
            ),
              await this.rpcPublish(
                dl(ds({}, e), {
                  topic: r,
                  message: i,
                  ttl: a.ttl,
                  prompt: a.prompt,
                  tag: a.tag,
                  id: a.id,
                  attestation: s,
                  tvf: a.tvf,
                })
              ),
              this.logger.warn({}, `Publisher: queue->published: ${e.opts.id}`);
          });
        }
        registerEventListeners() {
          this.relayer.core.heartbeat.on(C, () => {
            if (this.needsTransportRestart) {
              (this.needsTransportRestart = !1), this.relayer.events.emit(uL.connection_stalled);
              return;
            }
            this.checkQueue();
          }),
            this.relayer.on(uL.message_ack, (e) => {
              this.removeRequestFromQueue(e.id.toString());
            });
        }
      }
      var dd = Object.defineProperty,
        dp = (e, t, n) =>
          t in e
            ? dd(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        dh = (e, t, n) => dp(e, 'symbol' != typeof t ? t + '' : t, n);
      class dy {
        constructor() {
          dh(this, 'map', new Map()),
            dh(this, 'set', (e, t) => {
              let n = this.get(e);
              this.exists(e, t) || this.map.set(e, [...n, t]);
            }),
            dh(this, 'get', (e) => this.map.get(e) || []),
            dh(this, 'exists', (e, t) => this.get(e).includes(t)),
            dh(this, 'delete', (e, t) => {
              if (typeof t > 'u') {
                this.map.delete(e);
                return;
              }
              if (!this.map.has(e)) return;
              let n = this.get(e);
              if (!this.exists(e, t)) return;
              let r = n.filter((e) => e !== t);
              if (!r.length) {
                this.map.delete(e);
                return;
              }
              this.map.set(e, r);
            }),
            dh(this, 'clear', () => {
              this.map.clear();
            });
        }
        get topics() {
          return Array.from(this.map.keys());
        }
      }
      var df = Object.defineProperty,
        dm = Object.defineProperties,
        dg = Object.getOwnPropertyDescriptors,
        db = Object.getOwnPropertySymbols,
        dw = Object.prototype.hasOwnProperty,
        dv = Object.prototype.propertyIsEnumerable,
        dT = (e, t, n) =>
          t in e
            ? df(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        dA = (e, t) => {
          for (var n in t || (t = {})) dw.call(t, n) && dT(e, n, t[n]);
          if (db) for (var n of db(t)) dv.call(t, n) && dT(e, n, t[n]);
          return e;
        },
        dE = (e, t) => dm(e, dg(t)),
        dC = (e, t, n) => dT(e, 'symbol' != typeof t ? t + '' : t, n);
      class d_ extends eh {
        constructor(e, t) {
          super(e, t),
            (this.relayer = e),
            (this.logger = t),
            dC(this, 'subscriptions', new Map()),
            dC(this, 'topicMap', new dy()),
            dC(this, 'events', new b.EventEmitter()),
            dC(this, 'name', 'subscription'),
            dC(this, 'version', '0.3'),
            dC(this, 'pending', new Map()),
            dC(this, 'cached', []),
            dC(this, 'initialized', !1),
            dC(this, 'storagePrefix', ux),
            dC(this, 'subscribeTimeout', (0, v.toMiliseconds)(v.ONE_MINUTE)),
            dC(this, 'initialSubscribeTimeout', (0, v.toMiliseconds)(15 * v.ONE_SECOND)),
            dC(this, 'clientId'),
            dC(this, 'batchSubscribeTopicsLimit', 500),
            dC(this, 'init', async () => {
              this.initialized ||
                (this.logger.trace('Initialized'),
                this.registerEventListeners(),
                await this.restore()),
                (this.initialized = !0);
            }),
            dC(this, 'subscribe', async (e, t) => {
              this.isInitialized(),
                this.logger.debug('Subscribing Topic'),
                this.logger.trace({
                  type: 'method',
                  method: 'subscribe',
                  params: { topic: e, opts: t },
                });
              try {
                let n = lk(t),
                  r = { topic: e, relay: n, transportType: t?.transportType };
                this.pending.set(e, r);
                let i = await this.rpcSubscribe(e, n, t);
                return (
                  'string' == typeof i &&
                    (this.onSubscribe(i, r),
                    this.logger.debug('Successfully Subscribed Topic'),
                    this.logger.trace({
                      type: 'method',
                      method: 'subscribe',
                      params: { topic: e, opts: t },
                    })),
                  i
                );
              } catch (e) {
                throw (this.logger.debug('Failed to Subscribe Topic'), this.logger.error(e), e);
              }
            }),
            dC(this, 'unsubscribe', async (e, t) => {
              this.isInitialized(),
                'u' > typeof t?.id
                  ? await this.unsubscribeById(e, t.id, t)
                  : await this.unsubscribeByTopic(e, t);
            }),
            dC(
              this,
              'isSubscribed',
              (e) =>
                new Promise((t) => {
                  t(this.topicMap.topics.includes(e));
                })
            ),
            dC(
              this,
              'isKnownTopic',
              (e) =>
                new Promise((t) => {
                  t(
                    this.topicMap.topics.includes(e) ||
                      this.pending.has(e) ||
                      this.cached.some((t) => t.topic === e)
                  );
                })
            ),
            dC(this, 'on', (e, t) => {
              this.events.on(e, t);
            }),
            dC(this, 'once', (e, t) => {
              this.events.once(e, t);
            }),
            dC(this, 'off', (e, t) => {
              this.events.off(e, t);
            }),
            dC(this, 'removeListener', (e, t) => {
              this.events.removeListener(e, t);
            }),
            dC(this, 'start', async () => {
              await this.onConnect();
            }),
            dC(this, 'stop', async () => {
              await this.onDisconnect();
            }),
            dC(this, 'restart', async () => {
              await this.restore(), await this.onRestart();
            }),
            dC(this, 'checkPending', async () => {
              if (0 === this.pending.size && (!this.initialized || !this.relayer.connected)) return;
              let e = [];
              this.pending.forEach((t) => {
                e.push(t);
              }),
                await this.batchSubscribe(e);
            }),
            dC(this, 'registerEventListeners', () => {
              this.relayer.core.heartbeat.on(C, async () => {
                await this.checkPending();
              }),
                this.events.on(uz.created, async (e) => {
                  let t = uz.created;
                  this.logger.info(`Emitting ${t}`),
                    this.logger.debug({ type: 'event', event: t, data: e }),
                    await this.persist();
                }),
                this.events.on(uz.deleted, async (e) => {
                  let t = uz.deleted;
                  this.logger.info(`Emitting ${t}`),
                    this.logger.debug({ type: 'event', event: t, data: e }),
                    await this.persist();
                });
            }),
            (this.relayer = e),
            (this.logger = (0, ee.Ep)(t, this.name)),
            (this.clientId = '');
        }
        get context() {
          return (0, ee.Fd)(this.logger);
        }
        get storageKey() {
          return (
            this.storagePrefix +
            this.version +
            this.relayer.core.customStoragePrefix +
            '//' +
            this.name
          );
        }
        get length() {
          return this.subscriptions.size;
        }
        get ids() {
          return Array.from(this.subscriptions.keys());
        }
        get values() {
          return Array.from(this.subscriptions.values());
        }
        get topics() {
          return this.topicMap.topics;
        }
        get hasAnyTopics() {
          return (
            this.topicMap.topics.length > 0 ||
            this.pending.size > 0 ||
            this.cached.length > 0 ||
            this.subscriptions.size > 0
          );
        }
        hasSubscription(e, t) {
          let n = !1;
          try {
            n = this.getSubscription(e).topic === t;
          } catch {}
          return n;
        }
        reset() {
          (this.cached = []), (this.initialized = !0);
        }
        onDisable() {
          (this.cached = this.values), this.subscriptions.clear(), this.topicMap.clear();
        }
        async unsubscribeByTopic(e, t) {
          let n = this.topicMap.get(e);
          await Promise.all(n.map(async (n) => await this.unsubscribeById(e, n, t)));
        }
        async unsubscribeById(e, t, n) {
          this.logger.debug('Unsubscribing Topic'),
            this.logger.trace({
              type: 'method',
              method: 'unsubscribe',
              params: { topic: e, id: t, opts: n },
            });
          try {
            let r = lk(n);
            await this.restartToComplete({ topic: e, id: t, relay: r }),
              await this.rpcUnsubscribe(e, t, r);
            let i = lW('USER_DISCONNECTED', `${this.name}, ${e}`);
            await this.onUnsubscribe(e, t, i),
              this.logger.debug('Successfully Unsubscribed Topic'),
              this.logger.trace({
                type: 'method',
                method: 'unsubscribe',
                params: { topic: e, id: t, opts: n },
              });
          } catch (e) {
            throw (this.logger.debug('Failed to Unsubscribe Topic'), this.logger.error(e), e);
          }
        }
        async rpcSubscribe(e, t, n) {
          var r;
          (n && n?.transportType !== uq.relay) ||
            (await this.restartToComplete({ topic: e, id: e, relay: t }));
          let i = { method: lR(t.protocol).subscribe, params: { topic: e } };
          this.logger.debug('Outgoing Relay Payload'),
            this.logger.trace({ type: 'payload', direction: 'outgoing', request: i });
          let a = null == (r = n?.internal) ? void 0 : r.throwOnFailedPublish;
          try {
            let t = await this.getSubscriptionId(e);
            if (n?.transportType === uq.link_mode)
              return (
                setTimeout(
                  () => {
                    (this.relayer.connected || this.relayer.connecting) &&
                      this.relayer.request(i).catch((e) => this.logger.warn(e));
                  },
                  (0, v.toMiliseconds)(v.ONE_SECOND)
                ),
                t
              );
            let r = new Promise(async (t) => {
                let n = (r) => {
                  r.topic === e && (this.events.removeListener(uz.created, n), t(r.id));
                };
                this.events.on(uz.created, n);
                try {
                  let r = await aA(
                    new Promise((e, t) => {
                      this.relayer
                        .request(i)
                        .catch((e) => {
                          this.logger.warn(e, e?.message), t(e);
                        })
                        .then(e);
                    }),
                    this.initialSubscribeTimeout,
                    `Subscribing to ${e} failed, please try again`
                  );
                  this.events.removeListener(uz.created, n), t(r);
                } catch {}
              }),
              s = await aA(
                r,
                this.subscribeTimeout,
                `Subscribing to ${e} failed, please try again`
              );
            if (!s && a) throw Error(`Subscribing to ${e} failed, please try again`);
            return s ? t : null;
          } catch (e) {
            if (
              (this.logger.debug('Outgoing Relay Subscribe Payload stalled'),
              this.relayer.events.emit(uL.connection_stalled),
              a)
            )
              throw e;
          }
          return null;
        }
        async rpcBatchSubscribe(e) {
          if (!e.length) return;
          let t = {
            method: lR(e[0].relay.protocol).batchSubscribe,
            params: { topics: e.map((e) => e.topic) },
          };
          this.logger.debug('Outgoing Relay Payload'),
            this.logger.trace({ type: 'payload', direction: 'outgoing', request: t });
          try {
            await await aA(
              new Promise((e) => {
                this.relayer
                  .request(t)
                  .catch((e) => this.logger.warn(e))
                  .then(e);
              }),
              this.subscribeTimeout,
              'rpcBatchSubscribe failed, please try again'
            );
          } catch {
            this.relayer.events.emit(uL.connection_stalled);
          }
        }
        async rpcBatchFetchMessages(e) {
          let t;
          if (!e.length) return;
          let n = {
            method: lR(e[0].relay.protocol).batchFetchMessages,
            params: { topics: e.map((e) => e.topic) },
          };
          this.logger.debug('Outgoing Relay Payload'),
            this.logger.trace({ type: 'payload', direction: 'outgoing', request: n });
          try {
            t = await await aA(
              new Promise((e, t) => {
                this.relayer
                  .request(n)
                  .catch((e) => {
                    this.logger.warn(e), t(e);
                  })
                  .then(e);
              }),
              this.subscribeTimeout,
              'rpcBatchFetchMessages failed, please try again'
            );
          } catch {
            this.relayer.events.emit(uL.connection_stalled);
          }
          return t;
        }
        rpcUnsubscribe(e, t, n) {
          let r = { method: lR(n.protocol).unsubscribe, params: { topic: e, id: t } };
          return (
            this.logger.debug('Outgoing Relay Payload'),
            this.logger.trace({ type: 'payload', direction: 'outgoing', request: r }),
            this.relayer.request(r)
          );
        }
        onSubscribe(e, t) {
          this.setSubscription(e, dE(dA({}, t), { id: e })), this.pending.delete(t.topic);
        }
        onBatchSubscribe(e) {
          e.length &&
            e.forEach((e) => {
              this.setSubscription(e.id, dA({}, e)), this.pending.delete(e.topic);
            });
        }
        async onUnsubscribe(e, t, n) {
          this.events.removeAllListeners(t),
            this.hasSubscription(t, e) && this.deleteSubscription(t, n),
            await this.relayer.messages.del(e);
        }
        async setRelayerSubscriptions(e) {
          await this.relayer.core.storage.setItem(this.storageKey, e);
        }
        async getRelayerSubscriptions() {
          return await this.relayer.core.storage.getItem(this.storageKey);
        }
        setSubscription(e, t) {
          this.logger.debug('Setting subscription'),
            this.logger.trace({
              type: 'method',
              method: 'setSubscription',
              id: e,
              subscription: t,
            }),
            this.addSubscription(e, t);
        }
        addSubscription(e, t) {
          this.subscriptions.set(e, dA({}, t)),
            this.topicMap.set(t.topic, e),
            this.events.emit(uz.created, t);
        }
        getSubscription(e) {
          this.logger.debug('Getting subscription'),
            this.logger.trace({ type: 'method', method: 'getSubscription', id: e });
          let t = this.subscriptions.get(e);
          if (!t) {
            let { message: t } = lz('NO_MATCHING_KEY', `${this.name}: ${e}`);
            throw Error(t);
          }
          return t;
        }
        deleteSubscription(e, t) {
          this.logger.debug('Deleting subscription'),
            this.logger.trace({ type: 'method', method: 'deleteSubscription', id: e, reason: t });
          let n = this.getSubscription(e);
          this.subscriptions.delete(e),
            this.topicMap.delete(n.topic, e),
            this.events.emit(uz.deleted, dE(dA({}, n), { reason: t }));
        }
        async persist() {
          await this.setRelayerSubscriptions(this.values), this.events.emit(uz.sync);
        }
        async onRestart() {
          if (this.cached.length) {
            let e = [...this.cached],
              t = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
            for (let n = 0; n < t; n++) {
              let t = e.splice(0, this.batchSubscribeTopicsLimit);
              await this.batchSubscribe(t);
            }
          }
          this.events.emit(uz.resubscribed);
        }
        async restore() {
          try {
            let e = await this.getRelayerSubscriptions();
            if (typeof e > 'u' || !e.length) return;
            if (this.subscriptions.size) {
              let { message: e } = lz('RESTORE_WILL_OVERRIDE', this.name);
              throw (
                (this.logger.error(e),
                this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`),
                Error(e))
              );
            }
            (this.cached = e),
              this.logger.debug(`Successfully Restored subscriptions for ${this.name}`),
              this.logger.trace({ type: 'method', method: 'restore', subscriptions: this.values });
          } catch (e) {
            this.logger.debug(`Failed to Restore subscriptions for ${this.name}`),
              this.logger.error(e);
          }
        }
        async batchSubscribe(e) {
          e.length &&
            (await this.rpcBatchSubscribe(e),
            this.onBatchSubscribe(
              await Promise.all(
                e.map(async (e) => dE(dA({}, e), { id: await this.getSubscriptionId(e.topic) }))
              )
            ));
        }
        async batchFetchMessages(e) {
          var t;
          if (!e.length) return;
          this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);
          let n = await this.rpcBatchFetchMessages(e);
          n &&
            n.messages &&
            (await ((t = (0, v.toMiliseconds)(v.ONE_SECOND)), new Promise((e) => setTimeout(e, t))),
            await this.relayer.handleBatchMessageEvents(n.messages));
        }
        async onConnect() {
          await this.restart(), this.reset();
        }
        onDisconnect() {
          this.onDisable();
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = lz('NOT_INITIALIZED', this.name);
            throw Error(e);
          }
        }
        async restartToComplete(e) {
          this.relayer.connected ||
            this.relayer.connecting ||
            (this.cached.push(e), await this.relayer.transportOpen());
        }
        async getClientId() {
          return (
            this.clientId || (this.clientId = await this.relayer.core.crypto.getClientId()),
            this.clientId
          );
        }
        async getSubscriptionId(e) {
          return l_(e + (await this.getClientId()));
        }
      }
      var dI = Object.defineProperty,
        dS = Object.getOwnPropertySymbols,
        dP = Object.prototype.hasOwnProperty,
        dO = Object.prototype.propertyIsEnumerable,
        dN = (e, t, n) =>
          t in e
            ? dI(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        dx = (e, t) => {
          for (var n in t || (t = {})) dP.call(t, n) && dN(e, n, t[n]);
          if (dS) for (var n of dS(t)) dO.call(t, n) && dN(e, n, t[n]);
          return e;
        },
        dM = (e, t, n) => dN(e, 'symbol' != typeof t ? t + '' : t, n);
      class dk extends ed {
        constructor(e) {
          super(e),
            dM(this, 'protocol', 'wc'),
            dM(this, 'version', 2),
            dM(this, 'core'),
            dM(this, 'logger'),
            dM(this, 'events', new b.EventEmitter()),
            dM(this, 'provider'),
            dM(this, 'messages'),
            dM(this, 'subscriber'),
            dM(this, 'publisher'),
            dM(this, 'name', 'relayer'),
            dM(this, 'transportExplicitlyClosed', !1),
            dM(this, 'initialized', !1),
            dM(this, 'connectionAttemptInProgress', !1),
            dM(this, 'relayUrl'),
            dM(this, 'projectId'),
            dM(this, 'packageName'),
            dM(this, 'bundleId'),
            dM(this, 'hasExperiencedNetworkDisruption', !1),
            dM(this, 'pingTimeout'),
            dM(this, 'heartBeatTimeout', (0, v.toMiliseconds)(v.THIRTY_SECONDS + v.FIVE_SECONDS)),
            dM(this, 'reconnectTimeout'),
            dM(this, 'connectPromise'),
            dM(this, 'reconnectInProgress', !1),
            dM(this, 'requestsInFlight', []),
            dM(this, 'connectTimeout', (0, v.toMiliseconds)(15 * v.ONE_SECOND)),
            dM(this, 'request', async (e) => {
              var t, n;
              this.logger.debug('Publishing Request Payload');
              let r = e.id || ul().toString();
              await this.toEstablishConnection();
              try {
                this.logger.trace(
                  { id: r, method: e.method, topic: null == (t = e.params) ? void 0 : t.topic },
                  'relayer.request - publishing...'
                );
                let i = `${r}:${(null == (n = e.params) ? void 0 : n.tag) || ''}`;
                this.requestsInFlight.push(i);
                let a = await this.provider.request(e);
                return (this.requestsInFlight = this.requestsInFlight.filter((e) => e !== i)), a;
              } catch (e) {
                throw (this.logger.debug(`Failed to Publish Request: ${r}`), e);
              }
            }),
            dM(this, 'resetPingTimeout', () => {
              ad() &&
                (clearTimeout(this.pingTimeout),
                (this.pingTimeout = setTimeout(() => {
                  var e, t, n, r;
                  try {
                    this.logger.debug({}, 'pingTimeout: Connection stalled, terminating...'),
                      null ==
                        (r =
                          null ==
                          (n =
                            null == (t = null == (e = this.provider) ? void 0 : e.connection)
                              ? void 0
                              : t.socket)
                            ? void 0
                            : n.terminate) || r.call(n);
                  } catch (e) {
                    this.logger.warn(e, e?.message);
                  }
                }, this.heartBeatTimeout)));
            }),
            dM(this, 'onPayloadHandler', (e) => {
              this.onProviderPayload(e), this.resetPingTimeout();
            }),
            dM(this, 'onConnectHandler', () => {
              this.logger.warn({}, 'Relayer connected \uD83D\uDEDC'),
                this.startPingTimeout(),
                this.events.emit(uL.connect);
            }),
            dM(this, 'onDisconnectHandler', () => {
              this.logger.warn({}, 'Relayer disconnected \uD83D\uDED1'),
                (this.requestsInFlight = []),
                this.onProviderDisconnect();
            }),
            dM(this, 'onProviderErrorHandler', (e) => {
              this.logger.fatal(`Fatal socket error: ${e.message}`),
                this.events.emit(uL.error, e),
                this.logger.fatal('Fatal socket error received, closing transport'),
                this.transportClose();
            }),
            dM(this, 'registerProviderListeners', () => {
              this.provider.on(uF.payload, this.onPayloadHandler),
                this.provider.on(uF.connect, this.onConnectHandler),
                this.provider.on(uF.disconnect, this.onDisconnectHandler),
                this.provider.on(uF.error, this.onProviderErrorHandler);
            }),
            (this.core = e.core),
            (this.logger =
              'u' > typeof e.logger && 'string' != typeof e.logger
                ? (0, ee.Ep)(e.logger, this.name)
                : (0, ee.gw)((0, ee.jI)({ level: e.logger || 'error' }))),
            (this.messages = new c9(this.logger, e.core)),
            (this.subscriber = new d_(this, this.logger)),
            (this.publisher = new dc(this, this.logger)),
            (this.relayUrl = e?.relayUrl || uU),
            (this.projectId = e.projectId),
            ap() &&
            'u' > typeof n.g &&
            'u' > typeof (null == n.g ? void 0 : n.g.Platform) &&
            (null == n.g ? void 0 : n.g.Platform.OS) === 'android'
              ? (this.packageName = af())
              : ap() &&
                'u' > typeof n.g &&
                'u' > typeof (null == n.g ? void 0 : n.g.Platform) &&
                (null == n.g ? void 0 : n.g.Platform.OS) === 'ios' &&
                (this.bundleId = af()),
            (this.provider = {});
        }
        async init() {
          if (
            (this.logger.trace('Initialized'),
            this.registerEventListeners(),
            await Promise.all([this.messages.init(), this.subscriber.init()]),
            (this.initialized = !0),
            this.subscriber.hasAnyTopics)
          )
            try {
              await this.transportOpen();
            } catch (e) {
              this.logger.warn(e, e?.message);
            }
        }
        get context() {
          return (0, ee.Fd)(this.logger);
        }
        get connected() {
          var e, t, n;
          return (
            (null ==
            (n =
              null == (t = null == (e = this.provider) ? void 0 : e.connection) ? void 0 : t.socket)
              ? void 0
              : n.readyState) === 1
          );
        }
        get connecting() {
          var e, t, n;
          return (
            (null ==
            (n =
              null == (t = null == (e = this.provider) ? void 0 : e.connection) ? void 0 : t.socket)
              ? void 0
              : n.readyState) === 0 || void 0 !== this.connectPromise
          );
        }
        async publish(e, t, n) {
          this.isInitialized(),
            await this.publisher.publish(e, t, n),
            await this.recordMessageEvent(
              { topic: e, message: t, publishedAt: Date.now(), transportType: uq.relay },
              uV.outbound
            );
        }
        async subscribe(e, t) {
          var n, r, i;
          this.isInitialized(),
            (null != t && t.transportType && t?.transportType !== 'relay') ||
              (await this.toEstablishConnection());
          let a =
              typeof (null == (n = t?.internal) ? void 0 : n.throwOnFailedPublish) > 'u' ||
              (null == (r = t?.internal) ? void 0 : r.throwOnFailedPublish),
            s = (null == (i = this.subscriber.topicMap.get(e)) ? void 0 : i[0]) || '',
            o,
            l = (t) => {
              t.topic === e && (this.subscriber.off(uz.created, l), o());
            };
          return (
            await Promise.all([
              new Promise((e) => {
                (o = e), this.subscriber.on(uz.created, l);
              }),
              new Promise(async (n, r) => {
                (s =
                  (await this.subscriber
                    .subscribe(e, dx({ internal: { throwOnFailedPublish: a } }, t))
                    .catch((e) => {
                      a && r(e);
                    })) || s),
                  n();
              }),
            ]),
            s
          );
        }
        async unsubscribe(e, t) {
          this.isInitialized(), await this.subscriber.unsubscribe(e, t);
        }
        on(e, t) {
          this.events.on(e, t);
        }
        once(e, t) {
          this.events.once(e, t);
        }
        off(e, t) {
          this.events.off(e, t);
        }
        removeListener(e, t) {
          this.events.removeListener(e, t);
        }
        async transportDisconnect() {
          this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected)
            ? await aA(this.provider.disconnect(), 2e3, 'provider.disconnect()').catch(() =>
                this.onProviderDisconnect()
              )
            : this.onProviderDisconnect();
        }
        async transportClose() {
          (this.transportExplicitlyClosed = !0), await this.transportDisconnect();
        }
        async transportOpen(e) {
          if (!this.subscriber.hasAnyTopics) {
            this.logger.warn(
              'Starting WS connection skipped because the client has no topics to work with.'
            );
            return;
          }
          if (
            (this.connectPromise
              ? (this.logger.debug({}, 'Waiting for existing connection attempt to resolve...'),
                await this.connectPromise,
                this.logger.debug({}, 'Existing connection attempt resolved'))
              : ((this.connectPromise = new Promise(async (t, n) => {
                  await this.connect(e)
                    .then(t)
                    .catch(n)
                    .finally(() => {
                      this.connectPromise = void 0;
                    });
                })),
                await this.connectPromise),
            !this.connected)
          )
            throw Error(
              `Couldn't establish socket connection to the relay server: ${this.relayUrl}`
            );
        }
        async restartTransport(e) {
          this.logger.debug({}, 'Restarting transport...'),
            this.connectionAttemptInProgress ||
              ((this.relayUrl = e || this.relayUrl),
              await this.confirmOnlineStateOrThrow(),
              await this.transportClose(),
              await this.transportOpen());
        }
        async confirmOnlineStateOrThrow() {
          if (!(await l3()))
            throw Error(
              'No internet connection detected. Please restart your network and try again.'
            );
        }
        async handleBatchMessageEvents(e) {
          if (e?.length === 0) {
            this.logger.trace('Batch message events is empty. Ignoring...');
            return;
          }
          let t = e.sort((e, t) => e.publishedAt - t.publishedAt);
          for (let e of (this.logger.debug(`Batch of ${t.length} message events sorted`), t))
            try {
              await this.onMessageEvent(e);
            } catch (e) {
              this.logger.warn(e, 'Error while processing batch message event: ' + e?.message);
            }
          this.logger.trace(`Batch of ${t.length} message events processed`);
        }
        async onLinkMessageEvent(e, t) {
          let { topic: n } = e;
          if (!t.sessionExists) {
            let e = a_(v.FIVE_MINUTES);
            await this.core.pairing.pairings.set(n, {
              topic: n,
              expiry: e,
              relay: { protocol: 'irn' },
              active: !1,
            });
          }
          this.events.emit(uL.message, e), await this.recordMessageEvent(e, uV.inbound);
        }
        async connect(e) {
          await this.confirmOnlineStateOrThrow(),
            e && e !== this.relayUrl && ((this.relayUrl = e), await this.transportDisconnect()),
            (this.connectionAttemptInProgress = !0),
            (this.transportExplicitlyClosed = !1);
          let t = 1;
          for (; t < 6; ) {
            try {
              if (this.transportExplicitlyClosed) break;
              this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${t}...`),
                await this.createProvider(),
                await new Promise(async (e, t) => {
                  let n = () => {
                    t(Error('Connection interrupted while trying to subscribe'));
                  };
                  this.provider.once(uF.disconnect, n),
                    await aA(
                      new Promise((e, t) => {
                        this.provider.connect().then(e).catch(t);
                      }),
                      this.connectTimeout,
                      `Socket stalled when trying to connect to ${this.relayUrl}`
                    )
                      .catch((e) => {
                        t(e);
                      })
                      .finally(() => {
                        this.provider.off(uF.disconnect, n), clearTimeout(this.reconnectTimeout);
                      }),
                    await new Promise(async (e, t) => {
                      let n = () => {
                        t(Error('Connection interrupted while trying to subscribe'));
                      };
                      this.provider.once(uF.disconnect, n),
                        await this.subscriber
                          .start()
                          .then(e)
                          .catch(t)
                          .finally(() => {
                            this.provider.off(uF.disconnect, n);
                          });
                    }),
                    (this.hasExperiencedNetworkDisruption = !1),
                    e();
                });
            } catch (e) {
              await this.subscriber.stop(),
                this.logger.warn({}, e.message),
                (this.hasExperiencedNetworkDisruption = !0);
            } finally {
              this.connectionAttemptInProgress = !1;
            }
            if (this.connected) {
              this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${t}`);
              break;
            }
            await new Promise((e) => setTimeout(e, (0, v.toMiliseconds)(1 * t))), t++;
          }
        }
        startPingTimeout() {
          var e, t, n, r, i;
          if (ad())
            try {
              null != (t = null == (e = this.provider) ? void 0 : e.connection) &&
                t.socket &&
                (null ==
                  (i =
                    null == (r = null == (n = this.provider) ? void 0 : n.connection)
                      ? void 0
                      : r.socket) ||
                  i.on('ping', () => {
                    this.resetPingTimeout();
                  })),
                this.resetPingTimeout();
            } catch (e) {
              this.logger.warn(e, e?.message);
            }
        }
        async createProvider() {
          this.provider.connection && this.unregisterProviderListeners();
          let e = await this.core.crypto.signJWT(this.relayUrl);
          (this.provider = new uE(
            new uS(
              (function ({
                protocol: e,
                version: t,
                relayUrl: n,
                sdkVersion: r,
                auth: i,
                projectId: a,
                useOnCloseEvent: s,
                bundleId: o,
                packageName: l,
              }) {
                let u = n.split('?'),
                  c = ag(e, t, r),
                  d = (function (e, t) {
                    let n = new URLSearchParams(e);
                    for (let e of Object.keys(t).sort())
                      if (t.hasOwnProperty(e)) {
                        let r = t[e];
                        void 0 !== r && n.set(e, r);
                      }
                    return n.toString();
                  })(u[1] || '', {
                    auth: i,
                    ua: c,
                    projectId: a,
                    useOnCloseEvent: s || void 0,
                    packageName: l || void 0,
                    bundleId: o || void 0,
                  });
                return u[0] + '?' + d;
              })({
                sdkVersion: uj,
                protocol: this.protocol,
                version: this.version,
                relayUrl: this.relayUrl,
                projectId: this.projectId,
                auth: e,
                useOnCloseEvent: !0,
                bundleId: this.bundleId,
                packageName: this.packageName,
              })
            )
          )),
            this.registerProviderListeners();
        }
        async recordMessageEvent(e, t) {
          let { topic: n, message: r } = e;
          await this.messages.set(n, r, t);
        }
        async shouldIgnoreMessageEvent(e) {
          let { topic: t, message: n } = e;
          if (!n || 0 === n.length)
            return this.logger.warn(`Ignoring invalid/empty message: ${n}`), !0;
          if (!(await this.subscriber.isKnownTopic(t)))
            return this.logger.warn(`Ignoring message for unknown topic ${t}`), !0;
          let r = this.messages.has(t, n);
          return r && this.logger.warn(`Ignoring duplicate message: ${n}`), r;
        }
        async onProviderPayload(e) {
          if (
            (this.logger.debug('Incoming Relay Payload'),
            this.logger.trace({ type: 'payload', direction: 'incoming', payload: e }),
            uw(e))
          ) {
            if (!e.method.endsWith('_subscription')) return;
            let t = e.params,
              { topic: n, message: r, publishedAt: i, attestation: a } = t.data,
              s = { topic: n, message: r, publishedAt: i, transportType: uq.relay, attestation: a };
            this.logger.debug('Emitting Relayer Payload'),
              this.logger.trace(dx({ type: 'event', event: t.id }, s)),
              this.events.emit(t.id, s),
              await this.acknowledgePayload(e),
              await this.onMessageEvent(s);
          } else uv(e) && this.events.emit(uL.message_ack, e);
        }
        async onMessageEvent(e) {
          (await this.shouldIgnoreMessageEvent(e)) ||
            (await this.recordMessageEvent(e, uV.inbound), this.events.emit(uL.message, e));
        }
        async acknowledgePayload(e) {
          let t = uc(e.id, !0);
          await this.provider.connection.send(t);
        }
        unregisterProviderListeners() {
          this.provider.off(uF.payload, this.onPayloadHandler),
            this.provider.off(uF.connect, this.onConnectHandler),
            this.provider.off(uF.disconnect, this.onDisconnectHandler),
            this.provider.off(uF.error, this.onProviderErrorHandler),
            clearTimeout(this.pingTimeout);
        }
        async registerEventListeners() {
          let e = await l3();
          !(function (e) {
            switch (ay()) {
              case ac.browser:
                !ap() &&
                  ah() &&
                  (window.addEventListener('online', () => e(!0)),
                  window.addEventListener('offline', () => e(!1)));
                break;
              case ac.reactNative:
                ap() &&
                  'u' > typeof n.g &&
                  null != n.g &&
                  n.g.NetInfo &&
                  n.g?.NetInfo.addEventListener((t) => e(t?.isConnected));
              case ac.node:
            }
          })(async (t) => {
            e !== t &&
              ((e = t),
              t
                ? await this.transportOpen().catch((e) => this.logger.error(e, e?.message))
                : ((this.hasExperiencedNetworkDisruption = !0),
                  await this.transportDisconnect(),
                  (this.transportExplicitlyClosed = !1)));
          });
        }
        async onProviderDisconnect() {
          clearTimeout(this.pingTimeout),
            this.events.emit(uL.disconnect),
            (this.connectionAttemptInProgress = !1),
            !this.reconnectInProgress &&
              ((this.reconnectInProgress = !0),
              await this.subscriber.stop(),
              this.subscriber.hasAnyTopics &&
                (this.transportExplicitlyClosed ||
                  (this.reconnectTimeout = setTimeout(
                    async () => {
                      await this.transportOpen().catch((e) => this.logger.error(e, e?.message)),
                        (this.reconnectTimeout = void 0),
                        (this.reconnectInProgress = !1);
                    },
                    (0, v.toMiliseconds)(0.1)
                  ))));
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = lz('NOT_INITIALIZED', this.name);
            throw Error(e);
          }
        }
        async toEstablishConnection() {
          await this.confirmOnlineStateOrThrow(), this.connected || (await this.connect());
        }
      }
      function dR() {}
      function dD(e) {
        if (!e || 'object' != typeof e) return !1;
        let t = Object.getPrototypeOf(e);
        return (
          (null === t || t === Object.prototype || null === Object.getPrototypeOf(t)) &&
          '[object Object]' === Object.prototype.toString.call(e)
        );
      }
      function dB(e) {
        return Object.getOwnPropertySymbols(e).filter((t) =>
          Object.prototype.propertyIsEnumerable.call(e, t)
        );
      }
      function dU(e) {
        return null == e
          ? void 0 === e
            ? '[object Undefined]'
            : '[object Null]'
          : Object.prototype.toString.call(e);
      }
      let dL = '[object Arguments]',
        dF = '[object Object]';
      var dj = Object.defineProperty,
        dq = Object.getOwnPropertySymbols,
        dV = Object.prototype.hasOwnProperty,
        d$ = Object.prototype.propertyIsEnumerable,
        dz = (e, t, n) =>
          t in e
            ? dj(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        dW = (e, t) => {
          for (var n in t || (t = {})) dV.call(t, n) && dz(e, n, t[n]);
          if (dq) for (var n of dq(t)) d$.call(t, n) && dz(e, n, t[n]);
          return e;
        },
        dH = (e, t, n) => dz(e, 'symbol' != typeof t ? t + '' : t, n);
      class dG extends ep {
        constructor(e, t, n, r = ux, i) {
          super(e, t, n, r),
            (this.core = e),
            (this.logger = t),
            (this.name = n),
            dH(this, 'map', new Map()),
            dH(this, 'version', '0.3'),
            dH(this, 'cached', []),
            dH(this, 'initialized', !1),
            dH(this, 'getKey'),
            dH(this, 'storagePrefix', ux),
            dH(this, 'recentlyDeleted', []),
            dH(this, 'recentlyDeletedLimit', 200),
            dH(this, 'init', async () => {
              this.initialized ||
                (this.logger.trace('Initialized'),
                await this.restore(),
                this.cached.forEach((e) => {
                  var t;
                  this.getKey && null !== e && !lK(e)
                    ? this.map.set(this.getKey(e), e)
                    : (null == (t = e?.proposer) ? void 0 : t.publicKey)
                      ? this.map.set(e.id, e)
                      : e?.topic && this.map.set(e.topic, e);
                }),
                (this.cached = []),
                (this.initialized = !0));
            }),
            dH(this, 'set', async (e, t) => {
              this.isInitialized(),
                this.map.has(e)
                  ? await this.update(e, t)
                  : (this.logger.debug('Setting value'),
                    this.logger.trace({ type: 'method', method: 'set', key: e, value: t }),
                    this.map.set(e, t),
                    await this.persist());
            }),
            dH(
              this,
              'get',
              (e) => (
                this.isInitialized(),
                this.logger.debug('Getting value'),
                this.logger.trace({ type: 'method', method: 'get', key: e }),
                this.getData(e)
              )
            ),
            dH(
              this,
              'getAll',
              (e) => (
                this.isInitialized(),
                e
                  ? this.values.filter((t) =>
                      Object.keys(e).every((n) =>
                        (function e(t, n, r, i, a, s, o) {
                          let l = o(t, n, r, i, a, s);
                          if (void 0 !== l) return l;
                          if (typeof t == typeof n)
                            switch (typeof t) {
                              case 'bigint':
                              case 'string':
                              case 'boolean':
                              case 'symbol':
                              case 'undefined':
                              case 'function':
                                return t === n;
                              case 'number':
                                return t === n || Object.is(t, n);
                            }
                          return (function t(n, r, i, a) {
                            if (Object.is(n, r)) return !0;
                            let s = dU(n),
                              o = dU(r);
                            if ((s === dL && (s = dF), o === dL && (o = dF), s !== o)) return !1;
                            switch (s) {
                              case '[object String]':
                                return n.toString() === r.toString();
                              case '[object Number]': {
                                let e = n.valueOf(),
                                  t = r.valueOf();
                                return e === t || (Number.isNaN(e) && Number.isNaN(t));
                              }
                              case '[object Boolean]':
                              case '[object Date]':
                              case '[object Symbol]':
                                return Object.is(n.valueOf(), r.valueOf());
                              case '[object RegExp]':
                                return n.source === r.source && n.flags === r.flags;
                              case '[object Function]':
                                return n === r;
                            }
                            let l = (i = i ?? new Map()).get(n),
                              u = i.get(r);
                            if (null != l && null != u) return l === r;
                            i.set(n, r), i.set(r, n);
                            try {
                              switch (s) {
                                case '[object Map]':
                                  if (n.size !== r.size) return !1;
                                  for (let [t, s] of n.entries())
                                    if (!r.has(t) || !e(s, r.get(t), t, n, r, i, a)) return !1;
                                  return !0;
                                case '[object Set]': {
                                  if (n.size !== r.size) return !1;
                                  let t = Array.from(n.values()),
                                    s = Array.from(r.values());
                                  for (let o = 0; o < t.length; o++) {
                                    let l = t[o],
                                      u = s.findIndex((t) => e(l, t, void 0, n, r, i, a));
                                    if (-1 === u) return !1;
                                    s.splice(u, 1);
                                  }
                                  return !0;
                                }
                                case '[object Array]':
                                case '[object Uint8Array]':
                                case '[object Uint8ClampedArray]':
                                case '[object Uint16Array]':
                                case '[object Uint32Array]':
                                case '[object BigUint64Array]':
                                case '[object Int8Array]':
                                case '[object Int16Array]':
                                case '[object Int32Array]':
                                case '[object BigInt64Array]':
                                case '[object Float32Array]':
                                case '[object Float64Array]':
                                  if (
                                    ('u' > typeof uP && uP.isBuffer(n) !== uP.isBuffer(r)) ||
                                    n.length !== r.length
                                  )
                                    return !1;
                                  for (let t = 0; t < n.length; t++)
                                    if (!e(n[t], r[t], t, n, r, i, a)) return !1;
                                  return !0;
                                case '[object ArrayBuffer]':
                                  return (
                                    n.byteLength === r.byteLength &&
                                    t(new Uint8Array(n), new Uint8Array(r), i, a)
                                  );
                                case '[object DataView]':
                                  return (
                                    n.byteLength === r.byteLength &&
                                    n.byteOffset === r.byteOffset &&
                                    t(new Uint8Array(n), new Uint8Array(r), i, a)
                                  );
                                case '[object Error]':
                                  return n.name === r.name && n.message === r.message;
                                case dF: {
                                  if (!(t(n.constructor, r.constructor, i, a) || (dD(n) && dD(r))))
                                    return !1;
                                  let s = [...Object.keys(n), ...dB(n)],
                                    o = [...Object.keys(r), ...dB(r)];
                                  if (s.length !== o.length) return !1;
                                  for (let t = 0; t < s.length; t++) {
                                    let o = s[t],
                                      l = n[o];
                                    if (!Object.hasOwn(r, o)) return !1;
                                    let u = r[o];
                                    if (!e(l, u, o, n, r, i, a)) return !1;
                                  }
                                  return !0;
                                }
                                default:
                                  return !1;
                              }
                            } finally {
                              i.delete(n), i.delete(r);
                            }
                          })(t, n, s, o);
                        })(t[n], e[n], void 0, void 0, void 0, void 0, dR)
                      )
                    )
                  : this.values
              )
            ),
            dH(this, 'update', async (e, t) => {
              this.isInitialized(),
                this.logger.debug('Updating value'),
                this.logger.trace({ type: 'method', method: 'update', key: e, update: t });
              let n = dW(dW({}, this.getData(e)), t);
              this.map.set(e, n), await this.persist();
            }),
            dH(this, 'delete', async (e, t) => {
              this.isInitialized(),
                this.map.has(e) &&
                  (this.logger.debug('Deleting value'),
                  this.logger.trace({ type: 'method', method: 'delete', key: e, reason: t }),
                  this.map.delete(e),
                  this.addToRecentlyDeleted(e),
                  await this.persist());
            }),
            (this.logger = (0, ee.Ep)(t, this.name)),
            (this.storagePrefix = r),
            (this.getKey = i);
        }
        get context() {
          return (0, ee.Fd)(this.logger);
        }
        get storageKey() {
          return (
            this.storagePrefix + this.version + this.core.customStoragePrefix + '//' + this.name
          );
        }
        get length() {
          return this.map.size;
        }
        get keys() {
          return Array.from(this.map.keys());
        }
        get values() {
          return Array.from(this.map.values());
        }
        addToRecentlyDeleted(e) {
          this.recentlyDeleted.push(e),
            this.recentlyDeleted.length >= this.recentlyDeletedLimit &&
              this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
        }
        async setDataStore(e) {
          await this.core.storage.setItem(this.storageKey, e);
        }
        async getDataStore() {
          return await this.core.storage.getItem(this.storageKey);
        }
        getData(e) {
          let t = this.map.get(e);
          if (!t) {
            if (this.recentlyDeleted.includes(e)) {
              let { message: t } = lz(
                'MISSING_OR_INVALID',
                `Record was recently deleted - ${this.name}: ${e}`
              );
              throw (this.logger.error(t), Error(t));
            }
            let { message: t } = lz('NO_MATCHING_KEY', `${this.name}: ${e}`);
            throw (this.logger.error(t), Error(t));
          }
          return t;
        }
        async persist() {
          await this.setDataStore(this.values);
        }
        async restore() {
          try {
            let e = await this.getDataStore();
            if (typeof e > 'u' || !e.length) return;
            if (this.map.size) {
              let { message: e } = lz('RESTORE_WILL_OVERRIDE', this.name);
              throw (this.logger.error(e), Error(e));
            }
            (this.cached = e),
              this.logger.debug(`Successfully Restored value for ${this.name}`),
              this.logger.trace({ type: 'method', method: 'restore', value: this.values });
          } catch (e) {
            this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
          }
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = lz('NOT_INITIALIZED', this.name);
            throw Error(e);
          }
        }
      }
      var dK = Object.defineProperty,
        dQ = (e, t, n) =>
          t in e
            ? dK(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        dY = (e, t, n) => dQ(e, 'symbol' != typeof t ? t + '' : t, n);
      class dZ {
        constructor(e, t) {
          (this.core = e),
            (this.logger = t),
            dY(this, 'name', 'pairing'),
            dY(this, 'version', '0.3'),
            dY(this, 'events', new (w())()),
            dY(this, 'pairings'),
            dY(this, 'initialized', !1),
            dY(this, 'storagePrefix', ux),
            dY(this, 'ignoredPayloadTypes', [1]),
            dY(this, 'registeredMethods', []),
            dY(this, 'init', async () => {
              this.initialized ||
                (await this.pairings.init(),
                await this.cleanup(),
                this.registerRelayerEvents(),
                this.registerExpirerEvents(),
                (this.initialized = !0),
                this.logger.trace('Initialized'));
            }),
            dY(this, 'register', ({ methods: e }) => {
              this.isInitialized(),
                (this.registeredMethods = [...new Set([...this.registeredMethods, ...e])]);
            }),
            dY(this, 'create', async (e) => {
              this.isInitialized();
              let t = lE(),
                n = await this.core.crypto.setSymKey(t),
                r = a_(v.FIVE_MINUTES),
                i = { protocol: 'irn' },
                a = { topic: n, expiry: r, relay: i, active: !1, methods: e?.methods },
                s = lB({
                  protocol: this.core.protocol,
                  version: this.core.version,
                  topic: n,
                  symKey: t,
                  relay: i,
                  expiryTimestamp: r,
                  methods: e?.methods,
                });
              return (
                this.events.emit(uH.create, a),
                this.core.expirer.set(n, r),
                await this.pairings.set(n, a),
                await this.core.relayer.subscribe(n, { transportType: e?.transportType }),
                { topic: n, uri: s }
              );
            }),
            dY(this, 'pair', async (e) => {
              let t;
              this.isInitialized();
              let n = this.core.eventClient.createEvent({
                properties: { topic: e?.uri, trace: [uJ.pairing_started] },
              });
              this.isValidPair(e, n);
              let { topic: r, symKey: i, relay: a, expiryTimestamp: s, methods: o } = lD(e.uri);
              if (
                ((n.props.properties.topic = r),
                n.addTrace(uJ.pairing_uri_validation_success),
                n.addTrace(uJ.pairing_uri_not_expired),
                this.pairings.keys.includes(r))
              ) {
                if (((t = this.pairings.get(r)), n.addTrace(uJ.existing_pairing), t.active))
                  throw (
                    (n.setError(uX.active_pairing_already_exists),
                    Error(
                      `Pairing already exists: ${r}. Please try again with a new connection URI.`
                    ))
                  );
                n.addTrace(uJ.pairing_not_expired);
              }
              let l = s || a_(v.FIVE_MINUTES),
                u = { topic: r, relay: a, expiry: l, active: !1, methods: o };
              this.core.expirer.set(r, l),
                await this.pairings.set(r, u),
                n.addTrace(uJ.store_new_pairing),
                e.activatePairing && (await this.activate({ topic: r })),
                this.events.emit(uH.create, u),
                n.addTrace(uJ.emit_inactive_pairing),
                this.core.crypto.keychain.has(r) || (await this.core.crypto.setSymKey(i, r)),
                n.addTrace(uJ.subscribing_pairing_topic);
              try {
                await this.core.relayer.confirmOnlineStateOrThrow();
              } catch {
                n.setError(uX.no_internet_connection);
              }
              try {
                await this.core.relayer.subscribe(r, { relay: a });
              } catch (e) {
                throw (n.setError(uX.subscribe_pairing_topic_failure), e);
              }
              return n.addTrace(uJ.subscribe_pairing_topic_success), u;
            }),
            dY(this, 'activate', async ({ topic: e }) => {
              this.isInitialized();
              let t = a_(v.FIVE_MINUTES);
              this.core.expirer.set(e, t), await this.pairings.update(e, { active: !0, expiry: t });
            }),
            dY(this, 'ping', async (e) => {
              this.isInitialized(),
                await this.isValidPing(e),
                this.logger.warn(
                  'ping() is deprecated and will be removed in the next major release.'
                );
              let { topic: t } = e;
              if (this.pairings.keys.includes(t)) {
                let e = await this.sendRequest(t, 'wc_pairingPing', {}),
                  { done: n, resolve: r, reject: i } = aT();
                this.events.once(aS('pairing_ping', e), ({ error: e }) => {
                  e ? i(e) : r();
                }),
                  await n();
              }
            }),
            dY(this, 'updateExpiry', async ({ topic: e, expiry: t }) => {
              this.isInitialized(), await this.pairings.update(e, { expiry: t });
            }),
            dY(this, 'updateMetadata', async ({ topic: e, metadata: t }) => {
              this.isInitialized(), await this.pairings.update(e, { peerMetadata: t });
            }),
            dY(this, 'getPairings', () => (this.isInitialized(), this.pairings.values)),
            dY(this, 'disconnect', async (e) => {
              this.isInitialized(), await this.isValidDisconnect(e);
              let { topic: t } = e;
              this.pairings.keys.includes(t) &&
                (await this.sendRequest(t, 'wc_pairingDelete', lW('USER_DISCONNECTED')),
                await this.deletePairing(t));
            }),
            dY(this, 'formatUriFromPairing', (e) => {
              this.isInitialized();
              let { topic: t, relay: n, expiry: r, methods: i } = e,
                a = this.core.crypto.keychain.get(t);
              return lB({
                protocol: this.core.protocol,
                version: this.core.version,
                topic: t,
                symKey: a,
                relay: n,
                expiryTimestamp: r,
                methods: i,
              });
            }),
            dY(this, 'sendRequest', async (e, t, n) => {
              let r = uu(t, n),
                i = await this.core.crypto.encode(e, r),
                a = uW[t].req;
              return this.core.history.set(e, r), this.core.relayer.publish(e, i, a), r.id;
            }),
            dY(this, 'sendResult', async (e, t, n) => {
              let r = uc(e, n),
                i = await this.core.crypto.encode(t, r),
                a = uW[(await this.core.history.get(t, e)).request.method].res;
              await this.core.relayer.publish(t, i, a), await this.core.history.resolve(r);
            }),
            dY(this, 'sendError', async (e, t, n) => {
              let r = ud(e, n),
                i = await this.core.crypto.encode(t, r),
                a = (await this.core.history.get(t, e)).request.method,
                s = uW[a] ? uW[a].res : uW.unregistered_method.res;
              await this.core.relayer.publish(t, i, s), await this.core.history.resolve(r);
            }),
            dY(this, 'deletePairing', async (e, t) => {
              await this.core.relayer.unsubscribe(e),
                await Promise.all([
                  this.pairings.delete(e, lW('USER_DISCONNECTED')),
                  this.core.crypto.deleteSymKey(e),
                  t ? Promise.resolve() : this.core.expirer.del(e),
                ]);
            }),
            dY(this, 'cleanup', async () => {
              let e = this.pairings.getAll().filter((e) => aI(e.expiry));
              await Promise.all(e.map((e) => this.deletePairing(e.topic)));
            }),
            dY(this, 'onRelayEventRequest', async (e) => {
              let { topic: t, payload: n } = e;
              switch (n.method) {
                case 'wc_pairingPing':
                  return await this.onPairingPingRequest(t, n);
                case 'wc_pairingDelete':
                  return await this.onPairingDeleteRequest(t, n);
                default:
                  return await this.onUnknownRpcMethodRequest(t, n);
              }
            }),
            dY(this, 'onRelayEventResponse', async (e) => {
              let { topic: t, payload: n } = e,
                r = (await this.core.history.get(t, n.id)).request.method;
              return 'wc_pairingPing' === r
                ? this.onPairingPingResponse(t, n)
                : this.onUnknownRpcMethodResponse(r);
            }),
            dY(this, 'onPairingPingRequest', async (e, t) => {
              let { id: n } = t;
              try {
                this.isValidPing({ topic: e }),
                  await this.sendResult(n, e, !0),
                  this.events.emit(uH.ping, { id: n, topic: e });
              } catch (t) {
                await this.sendError(n, e, t), this.logger.error(t);
              }
            }),
            dY(this, 'onPairingPingResponse', (e, t) => {
              let { id: n } = t;
              setTimeout(() => {
                uT(t)
                  ? this.events.emit(aS('pairing_ping', n), {})
                  : uA(t) && this.events.emit(aS('pairing_ping', n), { error: t.error });
              }, 500);
            }),
            dY(this, 'onPairingDeleteRequest', async (e, t) => {
              let { id: n } = t;
              try {
                this.isValidDisconnect({ topic: e }),
                  await this.deletePairing(e),
                  this.events.emit(uH.delete, { id: n, topic: e });
              } catch (t) {
                await this.sendError(n, e, t), this.logger.error(t);
              }
            }),
            dY(this, 'onUnknownRpcMethodRequest', async (e, t) => {
              let { id: n, method: r } = t;
              try {
                if (this.registeredMethods.includes(r)) return;
                let t = lW('WC_METHOD_UNSUPPORTED', r);
                await this.sendError(n, e, t), this.logger.error(t);
              } catch (t) {
                await this.sendError(n, e, t), this.logger.error(t);
              }
            }),
            dY(this, 'onUnknownRpcMethodResponse', (e) => {
              this.registeredMethods.includes(e) ||
                this.logger.error(lW('WC_METHOD_UNSUPPORTED', e));
            }),
            dY(this, 'isValidPair', (e, t) => {
              var n;
              if (!l2(e)) {
                let { message: n } = lz('MISSING_OR_INVALID', `pair() params: ${e}`);
                throw (t.setError(uX.malformed_pairing_uri), Error(n));
              }
              if (
                !(function (e) {
                  function t(e) {
                    try {
                      return 'u' > typeof new URL(e);
                    } catch {
                      return !1;
                    }
                  }
                  try {
                    if (lQ(e, !1)) {
                      if (t(e)) return !0;
                      let n = aR(e);
                      return t(n);
                    }
                  } catch {}
                  return !1;
                })(e.uri)
              ) {
                let { message: n } = lz('MISSING_OR_INVALID', `pair() uri: ${e.uri}`);
                throw (t.setError(uX.malformed_pairing_uri), Error(n));
              }
              let r = lD(e?.uri);
              if (!(null != (n = r?.relay) && n.protocol)) {
                let { message: e } = lz('MISSING_OR_INVALID', 'pair() uri#relay-protocol');
                throw (t.setError(uX.malformed_pairing_uri), Error(e));
              }
              if (!(null != r && r.symKey)) {
                let { message: e } = lz('MISSING_OR_INVALID', 'pair() uri#symKey');
                throw (t.setError(uX.malformed_pairing_uri), Error(e));
              }
              if (
                null != r &&
                r.expiryTimestamp &&
                (0, v.toMiliseconds)(r?.expiryTimestamp) < Date.now()
              ) {
                t.setError(uX.pairing_expired);
                let { message: e } = lz(
                  'EXPIRED',
                  'pair() URI has expired. Please try again with a new connection URI.'
                );
                throw Error(e);
              }
            }),
            dY(this, 'isValidPing', async (e) => {
              if (!l2(e)) {
                let { message: t } = lz('MISSING_OR_INVALID', `ping() params: ${e}`);
                throw Error(t);
              }
              let { topic: t } = e;
              await this.isValidPairingTopic(t);
            }),
            dY(this, 'isValidDisconnect', async (e) => {
              if (!l2(e)) {
                let { message: t } = lz('MISSING_OR_INVALID', `disconnect() params: ${e}`);
                throw Error(t);
              }
              let { topic: t } = e;
              await this.isValidPairingTopic(t);
            }),
            dY(this, 'isValidPairingTopic', async (e) => {
              if (!lQ(e, !1)) {
                let { message: t } = lz(
                  'MISSING_OR_INVALID',
                  `pairing topic should be a string: ${e}`
                );
                throw Error(t);
              }
              if (!this.pairings.keys.includes(e)) {
                let { message: t } = lz('NO_MATCHING_KEY', `pairing topic doesn't exist: ${e}`);
                throw Error(t);
              }
              if (aI(this.pairings.get(e).expiry)) {
                await this.deletePairing(e);
                let { message: t } = lz('EXPIRED', `pairing topic: ${e}`);
                throw Error(t);
              }
            }),
            (this.core = e),
            (this.logger = (0, ee.Ep)(t, this.name)),
            (this.pairings = new dG(this.core, this.logger, this.name, this.storagePrefix));
        }
        get context() {
          return (0, ee.Fd)(this.logger);
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = lz('NOT_INITIALIZED', this.name);
            throw Error(e);
          }
        }
        registerRelayerEvents() {
          this.core.relayer.on(uL.message, async (e) => {
            let { topic: t, message: n, transportType: r } = e;
            if (
              this.pairings.keys.includes(t) &&
              r !== uq.link_mode &&
              !this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(n))
            )
              try {
                let e = await this.core.crypto.decode(t, n);
                uw(e)
                  ? (this.core.history.set(t, e),
                    await this.onRelayEventRequest({ topic: t, payload: e }))
                  : uv(e) &&
                    (await this.core.history.resolve(e),
                    await this.onRelayEventResponse({ topic: t, payload: e }),
                    this.core.history.delete(t, e.id)),
                  await this.core.relayer.messages.ack(t, n);
              } catch (e) {
                this.logger.error(e);
              }
          });
        }
        registerExpirerEvents() {
          this.core.expirer.on(uK.expired, async (e) => {
            let { topic: t } = aC(e.target);
            t &&
              this.pairings.keys.includes(t) &&
              (await this.deletePairing(t, !0), this.events.emit(uH.expire, { topic: t }));
          });
        }
      }
      var dJ = Object.defineProperty,
        dX = (e, t, n) =>
          t in e
            ? dJ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        d0 = (e, t, n) => dX(e, 'symbol' != typeof t ? t + '' : t, n);
      class d1 extends el {
        constructor(e, t) {
          super(e, t),
            (this.core = e),
            (this.logger = t),
            d0(this, 'records', new Map()),
            d0(this, 'events', new b.EventEmitter()),
            d0(this, 'name', 'history'),
            d0(this, 'version', '0.3'),
            d0(this, 'cached', []),
            d0(this, 'initialized', !1),
            d0(this, 'storagePrefix', ux),
            d0(this, 'init', async () => {
              this.initialized ||
                (this.logger.trace('Initialized'),
                await this.restore(),
                this.cached.forEach((e) => this.records.set(e.id, e)),
                (this.cached = []),
                this.registerEventListeners(),
                (this.initialized = !0));
            }),
            d0(this, 'set', (e, t, n) => {
              if (
                (this.isInitialized(),
                this.logger.debug('Setting JSON-RPC request history record'),
                this.logger.trace({
                  type: 'method',
                  method: 'set',
                  topic: e,
                  request: t,
                  chainId: n,
                }),
                this.records.has(t.id))
              )
                return;
              let r = {
                id: t.id,
                topic: e,
                request: { method: t.method, params: t.params || null },
                chainId: n,
                expiry: a_(v.THIRTY_DAYS),
              };
              this.records.set(r.id, r), this.persist(), this.events.emit(uG.created, r);
            }),
            d0(this, 'resolve', async (e) => {
              if (
                (this.isInitialized(),
                this.logger.debug('Updating JSON-RPC response history record'),
                this.logger.trace({ type: 'method', method: 'update', response: e }),
                !this.records.has(e.id))
              )
                return;
              let t = await this.getRecord(e.id);
              typeof t.response > 'u' &&
                ((t.response = uA(e) ? { error: e.error } : { result: e.result }),
                this.records.set(t.id, t),
                this.persist(),
                this.events.emit(uG.updated, t));
            }),
            d0(
              this,
              'get',
              async (e, t) => (
                this.isInitialized(),
                this.logger.debug('Getting record'),
                this.logger.trace({ type: 'method', method: 'get', topic: e, id: t }),
                await this.getRecord(t)
              )
            ),
            d0(this, 'delete', (e, t) => {
              this.isInitialized(),
                this.logger.debug('Deleting record'),
                this.logger.trace({ type: 'method', method: 'delete', id: t }),
                this.values.forEach((n) => {
                  n.topic !== e ||
                    ('u' > typeof t && n.id !== t) ||
                    (this.records.delete(n.id), this.events.emit(uG.deleted, n));
                }),
                this.persist();
            }),
            d0(
              this,
              'exists',
              async (e, t) => (
                this.isInitialized(), !!this.records.has(t) && (await this.getRecord(t)).topic === e
              )
            ),
            d0(this, 'on', (e, t) => {
              this.events.on(e, t);
            }),
            d0(this, 'once', (e, t) => {
              this.events.once(e, t);
            }),
            d0(this, 'off', (e, t) => {
              this.events.off(e, t);
            }),
            d0(this, 'removeListener', (e, t) => {
              this.events.removeListener(e, t);
            }),
            (this.logger = (0, ee.Ep)(t, this.name));
        }
        get context() {
          return (0, ee.Fd)(this.logger);
        }
        get storageKey() {
          return (
            this.storagePrefix + this.version + this.core.customStoragePrefix + '//' + this.name
          );
        }
        get size() {
          return this.records.size;
        }
        get keys() {
          return Array.from(this.records.keys());
        }
        get values() {
          return Array.from(this.records.values());
        }
        get pending() {
          let e = [];
          return (
            this.values.forEach((t) => {
              if ('u' > typeof t.response) return;
              let n = {
                topic: t.topic,
                request: uu(t.request.method, t.request.params, t.id),
                chainId: t.chainId,
              };
              return e.push(n);
            }),
            e
          );
        }
        async setJsonRpcRecords(e) {
          await this.core.storage.setItem(this.storageKey, e);
        }
        async getJsonRpcRecords() {
          return await this.core.storage.getItem(this.storageKey);
        }
        getRecord(e) {
          this.isInitialized();
          let t = this.records.get(e);
          if (!t) {
            let { message: t } = lz('NO_MATCHING_KEY', `${this.name}: ${e}`);
            throw Error(t);
          }
          return t;
        }
        async persist() {
          await this.setJsonRpcRecords(this.values), this.events.emit(uG.sync);
        }
        async restore() {
          try {
            let e = await this.getJsonRpcRecords();
            if (typeof e > 'u' || !e.length) return;
            if (this.records.size) {
              let { message: e } = lz('RESTORE_WILL_OVERRIDE', this.name);
              throw (this.logger.error(e), Error(e));
            }
            (this.cached = e),
              this.logger.debug(`Successfully Restored records for ${this.name}`),
              this.logger.trace({ type: 'method', method: 'restore', records: this.values });
          } catch (e) {
            this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
          }
        }
        registerEventListeners() {
          this.events.on(uG.created, (e) => {
            let t = uG.created;
            this.logger.info(`Emitting ${t}`),
              this.logger.debug({ type: 'event', event: t, record: e });
          }),
            this.events.on(uG.updated, (e) => {
              let t = uG.updated;
              this.logger.info(`Emitting ${t}`),
                this.logger.debug({ type: 'event', event: t, record: e });
            }),
            this.events.on(uG.deleted, (e) => {
              let t = uG.deleted;
              this.logger.info(`Emitting ${t}`),
                this.logger.debug({ type: 'event', event: t, record: e });
            }),
            this.core.heartbeat.on(C, () => {
              this.cleanup();
            });
        }
        cleanup() {
          try {
            this.isInitialized();
            let e = !1;
            this.records.forEach((t) => {
              (0, v.toMiliseconds)(t.expiry || 0) - Date.now() <= 0 &&
                (this.logger.info(`Deleting expired history log: ${t.id}`),
                this.records.delete(t.id),
                this.events.emit(uG.deleted, t, !1),
                (e = !0));
            }),
              e && this.persist();
          } catch (e) {
            this.logger.warn(e);
          }
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = lz('NOT_INITIALIZED', this.name);
            throw Error(e);
          }
        }
      }
      var d2 = Object.defineProperty,
        d6 = (e, t, n) =>
          t in e
            ? d2(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        d5 = (e, t, n) => d6(e, 'symbol' != typeof t ? t + '' : t, n);
      class d8 extends ey {
        constructor(e, t) {
          super(e, t),
            (this.core = e),
            (this.logger = t),
            d5(this, 'expirations', new Map()),
            d5(this, 'events', new b.EventEmitter()),
            d5(this, 'name', 'expirer'),
            d5(this, 'version', '0.3'),
            d5(this, 'cached', []),
            d5(this, 'initialized', !1),
            d5(this, 'storagePrefix', ux),
            d5(this, 'init', async () => {
              this.initialized ||
                (this.logger.trace('Initialized'),
                await this.restore(),
                this.cached.forEach((e) => this.expirations.set(e.target, e)),
                (this.cached = []),
                this.registerEventListeners(),
                (this.initialized = !0));
            }),
            d5(this, 'has', (e) => {
              try {
                let t = this.formatTarget(e);
                return 'u' > typeof this.getExpiration(t);
              } catch {
                return !1;
              }
            }),
            d5(this, 'set', (e, t) => {
              this.isInitialized();
              let n = this.formatTarget(e),
                r = { target: n, expiry: t };
              this.expirations.set(n, r),
                this.checkExpiry(n, r),
                this.events.emit(uK.created, { target: n, expiration: r });
            }),
            d5(this, 'get', (e) => {
              this.isInitialized();
              let t = this.formatTarget(e);
              return this.getExpiration(t);
            }),
            d5(this, 'del', (e) => {
              if ((this.isInitialized(), this.has(e))) {
                let t = this.formatTarget(e),
                  n = this.getExpiration(t);
                this.expirations.delete(t),
                  this.events.emit(uK.deleted, { target: t, expiration: n });
              }
            }),
            d5(this, 'on', (e, t) => {
              this.events.on(e, t);
            }),
            d5(this, 'once', (e, t) => {
              this.events.once(e, t);
            }),
            d5(this, 'off', (e, t) => {
              this.events.off(e, t);
            }),
            d5(this, 'removeListener', (e, t) => {
              this.events.removeListener(e, t);
            }),
            (this.logger = (0, ee.Ep)(t, this.name));
        }
        get context() {
          return (0, ee.Fd)(this.logger);
        }
        get storageKey() {
          return (
            this.storagePrefix + this.version + this.core.customStoragePrefix + '//' + this.name
          );
        }
        get length() {
          return this.expirations.size;
        }
        get keys() {
          return Array.from(this.expirations.keys());
        }
        get values() {
          return Array.from(this.expirations.values());
        }
        formatTarget(e) {
          if ('string' == typeof e) return aE('topic', e);
          if ('number' == typeof e) return aE('id', e);
          let { message: t } = lz('UNKNOWN_TYPE', `Target type: ${typeof e}`);
          throw Error(t);
        }
        async setExpirations(e) {
          await this.core.storage.setItem(this.storageKey, e);
        }
        async getExpirations() {
          return await this.core.storage.getItem(this.storageKey);
        }
        async persist() {
          await this.setExpirations(this.values), this.events.emit(uK.sync);
        }
        async restore() {
          try {
            let e = await this.getExpirations();
            if (typeof e > 'u' || !e.length) return;
            if (this.expirations.size) {
              let { message: e } = lz('RESTORE_WILL_OVERRIDE', this.name);
              throw (this.logger.error(e), Error(e));
            }
            (this.cached = e),
              this.logger.debug(`Successfully Restored expirations for ${this.name}`),
              this.logger.trace({ type: 'method', method: 'restore', expirations: this.values });
          } catch (e) {
            this.logger.debug(`Failed to Restore expirations for ${this.name}`),
              this.logger.error(e);
          }
        }
        getExpiration(e) {
          let t = this.expirations.get(e);
          if (!t) {
            let { message: t } = lz('NO_MATCHING_KEY', `${this.name}: ${e}`);
            throw (this.logger.warn(t), Error(t));
          }
          return t;
        }
        checkExpiry(e, t) {
          let { expiry: n } = t;
          (0, v.toMiliseconds)(n) - Date.now() <= 0 && this.expire(e, t);
        }
        expire(e, t) {
          this.expirations.delete(e), this.events.emit(uK.expired, { target: e, expiration: t });
        }
        checkExpirations() {
          this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));
        }
        registerEventListeners() {
          this.core.heartbeat.on(C, () => this.checkExpirations()),
            this.events.on(uK.created, (e) => {
              let t = uK.created;
              this.logger.info(`Emitting ${t}`),
                this.logger.debug({ type: 'event', event: t, data: e }),
                this.persist();
            }),
            this.events.on(uK.expired, (e) => {
              let t = uK.expired;
              this.logger.info(`Emitting ${t}`),
                this.logger.debug({ type: 'event', event: t, data: e }),
                this.persist();
            }),
            this.events.on(uK.deleted, (e) => {
              let t = uK.deleted;
              this.logger.info(`Emitting ${t}`),
                this.logger.debug({ type: 'event', event: t, data: e }),
                this.persist();
            });
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = lz('NOT_INITIALIZED', this.name);
            throw Error(e);
          }
        }
      }
      var d3 = Object.defineProperty,
        d4 = (e, t, n) =>
          t in e
            ? d3(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        d9 = (e, t, n) => d4(e, 'symbol' != typeof t ? t + '' : t, n);
      class d7 extends ef {
        constructor(e, t, n) {
          super(e, t, n),
            (this.core = e),
            (this.logger = t),
            (this.store = n),
            d9(this, 'name', 'verify-api'),
            d9(this, 'abortController'),
            d9(this, 'isDevEnv'),
            d9(this, 'verifyUrlV3', uY),
            d9(this, 'storagePrefix', ux),
            d9(this, 'version', 2),
            d9(this, 'publicKey'),
            d9(this, 'fetchPromise'),
            d9(this, 'init', async () => {
              var e;
              this.isDevEnv ||
                ((this.publicKey = await this.store.getItem(this.storeKey)),
                this.publicKey &&
                  (0, v.toMiliseconds)(null == (e = this.publicKey) ? void 0 : e.expiresAt) <
                    Date.now() &&
                  (this.logger.debug('verify v2 public key expired'),
                  await this.removePublicKey()));
            }),
            d9(this, 'register', async (e) => {
              if (!ah() || this.isDevEnv) return;
              let t = window.location.origin,
                { id: n, decryptedId: r } = e,
                i = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${t}&id=${n}&decryptedId=${r}`;
              try {
                let e = (0, nW.getDocument)(),
                  t = this.startAbortTimer(5 * v.ONE_SECOND),
                  r = await new Promise((r, a) => {
                    let s = () => {
                      window.removeEventListener('message', l),
                        e.body.removeChild(o),
                        a('attestation aborted');
                    };
                    this.abortController.signal.addEventListener('abort', s);
                    let o = e.createElement('iframe');
                    (o.src = i),
                      (o.style.display = 'none'),
                      o.addEventListener('error', s, { signal: this.abortController.signal });
                    let l = (i) => {
                      if (i.data && 'string' == typeof i.data)
                        try {
                          let a = JSON.parse(i.data);
                          if ('verify_attestation' === a.type) {
                            if (nM(a.attestation).payload.id !== n) return;
                            clearInterval(t),
                              e.body.removeChild(o),
                              this.abortController.signal.removeEventListener('abort', s),
                              window.removeEventListener('message', l),
                              r(null === a.attestation ? '' : a.attestation);
                          }
                        } catch (e) {
                          this.logger.warn(e);
                        }
                    };
                    e.body.appendChild(o),
                      window.addEventListener('message', l, {
                        signal: this.abortController.signal,
                      });
                  });
                return this.logger.debug('jwt attestation', r), r;
              } catch (e) {
                this.logger.warn(e);
              }
              return '';
            }),
            d9(this, 'resolve', async (e) => {
              if (this.isDevEnv) return '';
              let { attestationId: t, hash: n, encryptedId: r } = e;
              if ('' === t) {
                this.logger.debug('resolve: attestationId is empty, skipping');
                return;
              }
              if (t) {
                if (nM(t).payload.id !== r) return;
                let e = await this.isValidJwtAttestation(t);
                if (e) {
                  if (!e.isVerified) {
                    this.logger.warn('resolve: jwt attestation: origin url not verified');
                    return;
                  }
                  return e;
                }
              }
              if (!n) return;
              let i = this.getVerifyUrl(e?.verifyUrl);
              return this.fetchAttestation(n, i);
            }),
            d9(this, 'fetchAttestation', async (e, t) => {
              this.logger.debug(`resolving attestation: ${e} from url: ${t}`);
              let n = this.startAbortTimer(5 * v.ONE_SECOND),
                r = await fetch(`${t}/attestation/${e}?v2Supported=true`, {
                  signal: this.abortController.signal,
                });
              return clearTimeout(n), 200 === r.status ? await r.json() : void 0;
            }),
            d9(this, 'getVerifyUrl', (e) => {
              let t = e || uQ;
              return (
                uZ.includes(t) ||
                  (this.logger.info(
                    `verify url: ${t}, not included in trusted list, assigning default: ${uQ}`
                  ),
                  (t = uQ)),
                t
              );
            }),
            d9(this, 'fetchPublicKey', async () => {
              try {
                this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
                let e = this.startAbortTimer(v.FIVE_SECONDS),
                  t = await fetch(`${this.verifyUrlV3}/public-key`, {
                    signal: this.abortController.signal,
                  });
                return clearTimeout(e), await t.json();
              } catch (e) {
                this.logger.warn(e);
              }
            }),
            d9(this, 'persistPublicKey', async (e) => {
              this.logger.debug('persisting public key to local storage', e),
                await this.store.setItem(this.storeKey, e),
                (this.publicKey = e);
            }),
            d9(this, 'removePublicKey', async () => {
              this.logger.debug('removing verify v2 public key from storage'),
                await this.store.removeItem(this.storeKey),
                (this.publicKey = void 0);
            }),
            d9(this, 'isValidJwtAttestation', async (e) => {
              let t = await this.getPublicKey();
              try {
                if (t) return this.validateAttestation(e, t);
              } catch (e) {
                this.logger.error(e), this.logger.warn('error validating attestation');
              }
              let n = await this.fetchAndPersistPublicKey();
              try {
                if (n) return this.validateAttestation(e, n);
              } catch (e) {
                this.logger.error(e), this.logger.warn('error validating attestation');
              }
            }),
            d9(this, 'getPublicKey', async () =>
              this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey()
            ),
            d9(this, 'fetchAndPersistPublicKey', async () => {
              if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
              this.fetchPromise = new Promise(async (e) => {
                let t = await this.fetchPublicKey();
                t && (await this.persistPublicKey(t), e(t));
              });
              let e = await this.fetchPromise;
              return (this.fetchPromise = void 0), e;
            }),
            d9(this, 'validateAttestation', (e, t) => {
              let n = (function (e, t) {
                  let [n, r, i] = e.split('.'),
                    a = i9.from(lP(i), 'base64');
                  if (64 !== a.length) throw Error('Invalid signature length');
                  let s = a.slice(0, 32),
                    o = a.slice(32, 64),
                    l = oo(`${n}.${r}`),
                    u = (function (e) {
                      let t = i9.from(e.x, 'base64'),
                        n = i9.from(e.y, 'base64');
                      return rD([new Uint8Array([4]), t, n]);
                    })(t);
                  if (!lg.verify(rD([s, o]), l, u)) throw Error('Invalid signature');
                  return nM(e).payload;
                })(e, t.publicKey),
                r = { hasExpired: (0, v.toMiliseconds)(n.exp) < Date.now(), payload: n };
              if (r.hasExpired)
                throw (
                  (this.logger.warn('resolve: jwt attestation expired'),
                  Error('JWT attestation expired'))
                );
              return {
                origin: r.payload.origin,
                isScam: r.payload.isScam,
                isVerified: r.payload.isVerified,
              };
            }),
            (this.logger = (0, ee.Ep)(t, this.name)),
            (this.abortController = new AbortController()),
            (this.isDevEnv = ak()),
            this.init();
        }
        get storeKey() {
          return (
            this.storagePrefix +
            this.version +
            this.core.customStoragePrefix +
            '//verify:public:key'
          );
        }
        get context() {
          return (0, ee.Fd)(this.logger);
        }
        startAbortTimer(e) {
          return (
            (this.abortController = new AbortController()),
            setTimeout(() => this.abortController.abort(), (0, v.toMiliseconds)(e))
          );
        }
      }
      var pe = Object.defineProperty,
        pt = (e, t, n) =>
          t in e
            ? pe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        pn = (e, t, n) => pt(e, 'symbol' != typeof t ? t + '' : t, n);
      class pr extends em {
        constructor(e, t) {
          super(e, t),
            (this.projectId = e),
            (this.logger = t),
            pn(this, 'context', 'echo'),
            pn(this, 'registerDeviceToken', async (e) => {
              let { clientId: t, token: n, notificationType: r, enableEncrypted: i = !1 } = e,
                a = `https://echo.walletconnect.com/${this.projectId}/clients`;
              await fetch(a, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ client_id: t, type: r, token: n, always_raw: i }),
              });
            }),
            (this.logger = (0, ee.Ep)(t, this.context));
        }
      }
      var pi = Object.defineProperty,
        pa = Object.getOwnPropertySymbols,
        ps = Object.prototype.hasOwnProperty,
        po = Object.prototype.propertyIsEnumerable,
        pl = (e, t, n) =>
          t in e
            ? pi(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        pu = (e, t) => {
          for (var n in t || (t = {})) ps.call(t, n) && pl(e, n, t[n]);
          if (pa) for (var n of pa(t)) po.call(t, n) && pl(e, n, t[n]);
          return e;
        },
        pc = (e, t, n) => pl(e, 'symbol' != typeof t ? t + '' : t, n);
      class pd extends eg {
        constructor(e, t, n = !0) {
          super(e, t, n),
            (this.core = e),
            (this.logger = t),
            pc(this, 'context', 'event-client'),
            pc(this, 'storagePrefix', ux),
            pc(this, 'storageVersion', 0.1),
            pc(this, 'events', new Map()),
            pc(this, 'shouldPersist', !1),
            pc(this, 'init', async () => {
              if (!ak())
                try {
                  let e = {
                    eventId: aM(),
                    timestamp: Date.now(),
                    domain: this.getAppDomain(),
                    props: {
                      event: 'INIT',
                      type: '',
                      properties: {
                        client_id: await this.core.crypto.getClientId(),
                        user_agent: ag(this.core.relayer.protocol, this.core.relayer.version, uj),
                      },
                    },
                  };
                  await this.sendEvent([e]);
                } catch (e) {
                  this.logger.warn(e);
                }
            }),
            pc(this, 'createEvent', (e) => {
              let {
                  event: t = 'ERROR',
                  type: n = '',
                  properties: { topic: r, trace: i },
                } = e,
                a = aM(),
                s = this.core.projectId || '',
                o = pu(
                  {
                    eventId: a,
                    timestamp: Date.now(),
                    props: { event: t, type: n, properties: { topic: r, trace: i } },
                    bundleId: s,
                    domain: this.getAppDomain(),
                  },
                  this.setMethods(a)
                );
              return this.telemetryEnabled && (this.events.set(a, o), (this.shouldPersist = !0)), o;
            }),
            pc(this, 'getEvent', (e) => {
              let { eventId: t, topic: n } = e;
              if (t) return this.events.get(t);
              let r = Array.from(this.events.values()).find((e) => e.props.properties.topic === n);
              if (r) return pu(pu({}, r), this.setMethods(r.eventId));
            }),
            pc(this, 'deleteEvent', (e) => {
              let { eventId: t } = e;
              this.events.delete(t), (this.shouldPersist = !0);
            }),
            pc(this, 'setEventListeners', () => {
              this.core.heartbeat.on(C, async () => {
                this.shouldPersist && (await this.persist()),
                  this.events.forEach((e) => {
                    (0, v.fromMiliseconds)(Date.now()) - (0, v.fromMiliseconds)(e.timestamp) >
                      86400 && (this.events.delete(e.eventId), (this.shouldPersist = !0));
                  });
              });
            }),
            pc(this, 'setMethods', (e) => ({
              addTrace: (t) => this.addTrace(e, t),
              setError: (t) => this.setError(e, t),
            })),
            pc(this, 'addTrace', (e, t) => {
              let n = this.events.get(e);
              n &&
                (n.props.properties.trace.push(t),
                this.events.set(e, n),
                (this.shouldPersist = !0));
            }),
            pc(this, 'setError', (e, t) => {
              let n = this.events.get(e);
              n &&
                ((n.props.type = t),
                (n.timestamp = Date.now()),
                this.events.set(e, n),
                (this.shouldPersist = !0));
            }),
            pc(this, 'persist', async () => {
              await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())),
                (this.shouldPersist = !1);
            }),
            pc(this, 'restore', async () => {
              try {
                let e = (await this.core.storage.getItem(this.storageKey)) || [];
                if (!e.length) return;
                e.forEach((e) => {
                  this.events.set(e.eventId, pu(pu({}, e), this.setMethods(e.eventId)));
                });
              } catch (e) {
                this.logger.warn(e);
              }
            }),
            pc(this, 'submit', async () => {
              if (!this.telemetryEnabled || 0 === this.events.size) return;
              let e = [];
              for (let [t, n] of this.events) n.props.type && e.push(n);
              if (0 !== e.length)
                try {
                  if ((await this.sendEvent(e)).ok)
                    for (let t of e) this.events.delete(t.eventId), (this.shouldPersist = !0);
                } catch (e) {
                  this.logger.warn(e);
                }
            }),
            pc(this, 'sendEvent', async (e) => {
              let t = this.getAppDomain() ? '' : '&sp=desktop';
              return await fetch(
                `https://pulse.walletconnect.org/batch?projectId=${this.core.projectId}&st=events_sdk&sv=js-${uj}${t}`,
                { method: 'POST', body: JSON.stringify(e) }
              );
            }),
            pc(this, 'getAppDomain', () => am().url),
            (this.logger = (0, ee.Ep)(t, this.context)),
            (this.telemetryEnabled = n),
            n
              ? this.restore().then(async () => {
                  await this.submit(), this.setEventListeners();
                })
              : this.persist();
        }
        get storageKey() {
          return (
            this.storagePrefix +
            this.storageVersion +
            this.core.customStoragePrefix +
            '//' +
            this.context
          );
        }
      }
      var pp = Object.defineProperty,
        ph = Object.getOwnPropertySymbols,
        py = Object.prototype.hasOwnProperty,
        pf = Object.prototype.propertyIsEnumerable,
        pm = (e, t, n) =>
          t in e
            ? pp(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        pg = (e, t) => {
          for (var n in t || (t = {})) py.call(t, n) && pm(e, n, t[n]);
          if (ph) for (var n of ph(t)) pf.call(t, n) && pm(e, n, t[n]);
          return e;
        },
        pb = (e, t, n) => pm(e, 'symbol' != typeof t ? t + '' : t, n);
      class pw extends ei {
        constructor(e) {
          var t;
          super(e),
            pb(this, 'protocol', 'wc'),
            pb(this, 'version', 2),
            pb(this, 'name', uN),
            pb(this, 'relayUrl'),
            pb(this, 'projectId'),
            pb(this, 'customStoragePrefix'),
            pb(this, 'events', new b.EventEmitter()),
            pb(this, 'logger'),
            pb(this, 'heartbeat'),
            pb(this, 'relayer'),
            pb(this, 'crypto'),
            pb(this, 'storage'),
            pb(this, 'history'),
            pb(this, 'expirer'),
            pb(this, 'pairing'),
            pb(this, 'verify'),
            pb(this, 'echoClient'),
            pb(this, 'linkModeSupportedApps'),
            pb(this, 'eventClient'),
            pb(this, 'initialized', !1),
            pb(this, 'logChunkController'),
            pb(this, 'on', (e, t) => this.events.on(e, t)),
            pb(this, 'once', (e, t) => this.events.once(e, t)),
            pb(this, 'off', (e, t) => this.events.off(e, t)),
            pb(this, 'removeListener', (e, t) => this.events.removeListener(e, t)),
            pb(this, 'dispatchEnvelope', ({ topic: e, message: t, sessionExists: n }) => {
              if (!e || !t) return;
              let r = {
                topic: e,
                message: t,
                publishedAt: Date.now(),
                transportType: uq.link_mode,
              };
              this.relayer.onLinkMessageEvent(r, { sessionExists: n });
            });
          let n = this.getGlobalCore(e?.customStoragePrefix);
          if (n)
            try {
              return (
                (this.customStoragePrefix = n.customStoragePrefix),
                (this.logger = n.logger),
                (this.heartbeat = n.heartbeat),
                (this.crypto = n.crypto),
                (this.history = n.history),
                (this.expirer = n.expirer),
                (this.storage = n.storage),
                (this.relayer = n.relayer),
                (this.pairing = n.pairing),
                (this.verify = n.verify),
                (this.echoClient = n.echoClient),
                (this.linkModeSupportedApps = n.linkModeSupportedApps),
                (this.eventClient = n.eventClient),
                (this.initialized = n.initialized),
                (this.logChunkController = n.logChunkController),
                n
              );
            } catch (e) {
              console.warn('Failed to copy global core', e);
            }
          (this.projectId = e?.projectId),
            (this.relayUrl = e?.relayUrl || uU),
            (this.customStoragePrefix =
              null != e && e.customStoragePrefix ? `:${e.customStoragePrefix}` : '');
          let r = (0, ee.jI)({
              level: 'string' == typeof e?.logger && e.logger ? e.logger : uM.logger,
              name: uN,
            }),
            { logger: i, chunkLoggerController: a } = (0, ee.Rt)({
              opts: r,
              maxSizeInBytes: e?.maxLogBlobSizeInBytes,
              loggerOverride: e?.logger,
            });
          (this.logChunkController = a),
            null != (t = this.logChunkController) &&
              t.downloadLogsBlobInBrowser &&
              (window.downloadLogsBlobInBrowser = async () => {
                var e, t;
                null != (e = this.logChunkController) &&
                  e.downloadLogsBlobInBrowser &&
                  (null == (t = this.logChunkController) ||
                    t.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
              }),
            (this.logger = (0, ee.Ep)(i, this.name)),
            (this.heartbeat = new _()),
            (this.crypto = new cZ(this, this.logger, e?.keychain)),
            (this.history = new d1(this, this.logger)),
            (this.expirer = new d8(this, this.logger)),
            (this.storage =
              null != e && e.storage ? e.storage : new X(pg(pg({}, uk), e?.storageOptions))),
            (this.relayer = new dk({
              core: this,
              logger: this.logger,
              relayUrl: this.relayUrl,
              projectId: this.projectId,
            })),
            (this.pairing = new dZ(this, this.logger)),
            (this.verify = new d7(this, this.logger, this.storage)),
            (this.echoClient = new pr(this.projectId || '', this.logger)),
            (this.linkModeSupportedApps = []),
            (this.eventClient = new pd(this, this.logger, e?.telemetryEnabled)),
            this.setGlobalCore(this);
        }
        static async init(e) {
          let t = new pw(e);
          await t.initialize();
          let n = await t.crypto.getClientId();
          return await t.storage.setItem('WALLETCONNECT_CLIENT_ID', n), t;
        }
        get context() {
          return (0, ee.Fd)(this.logger);
        }
        async start() {
          this.initialized || (await this.initialize());
        }
        async getLogsBlob() {
          var e;
          return null == (e = this.logChunkController)
            ? void 0
            : e.logsToBlob({ clientId: await this.crypto.getClientId() });
        }
        async addLinkModeSupportedApp(e) {
          this.linkModeSupportedApps.includes(e) ||
            (this.linkModeSupportedApps.push(e),
            await this.storage.setItem(u$, this.linkModeSupportedApps));
        }
        async initialize() {
          this.logger.trace('Initialized');
          try {
            await this.crypto.init(),
              await this.history.init(),
              await this.expirer.init(),
              await this.relayer.init(),
              await this.heartbeat.init(),
              await this.pairing.init(),
              (this.linkModeSupportedApps = (await this.storage.getItem(u$)) || []),
              (this.initialized = !0),
              this.logger.info('Core Initialization Success');
          } catch (e) {
            throw (
              (this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e),
              this.logger.error(e.message),
              e)
            );
          }
        }
        getGlobalCore(e = '') {
          try {
            if (this.isGlobalCoreDisabled()) return;
            let t = `_walletConnectCore_${e}`,
              n = `${t}_count`;
            return (
              (globalThis[n] = (globalThis[n] || 0) + 1),
              globalThis[n] > 1 &&
                console.warn(
                  `WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[n]} times.`
                ),
              globalThis[t]
            );
          } catch (e) {
            console.warn('Failed to get global WalletConnect core', e);
            return;
          }
        }
        setGlobalCore(e) {
          var t;
          try {
            if (this.isGlobalCoreDisabled()) return;
            let n = `_walletConnectCore_${(null == (t = e.opts) ? void 0 : t.customStoragePrefix) || ''}`;
            globalThis[n] = e;
          } catch (e) {
            console.warn('Failed to set global WalletConnect core', e);
          }
        }
        isGlobalCoreDisabled() {
          try {
            return 'u' > typeof uO && 'true' === uO.env.DISABLE_GLOBAL_CORE;
          } catch {
            return !0;
          }
        }
      }
      let pv = 'client',
        pT = `wc@2:${pv}:`,
        pA = { name: pv, logger: 'error' },
        pE = 'WALLETCONNECT_DEEPLINK_CHOICE',
        pC = 'Proposal expired',
        p_ = v.SEVEN_DAYS,
        pI = {
          wc_sessionPropose: {
            req: { ttl: v.FIVE_MINUTES, prompt: !0, tag: 1100 },
            res: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1101 },
            reject: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1120 },
            autoReject: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1121 },
          },
          wc_sessionSettle: {
            req: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1102 },
            res: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1103 },
          },
          wc_sessionUpdate: {
            req: { ttl: v.ONE_DAY, prompt: !1, tag: 1104 },
            res: { ttl: v.ONE_DAY, prompt: !1, tag: 1105 },
          },
          wc_sessionExtend: {
            req: { ttl: v.ONE_DAY, prompt: !1, tag: 1106 },
            res: { ttl: v.ONE_DAY, prompt: !1, tag: 1107 },
          },
          wc_sessionRequest: {
            req: { ttl: v.FIVE_MINUTES, prompt: !0, tag: 1108 },
            res: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1109 },
          },
          wc_sessionEvent: {
            req: { ttl: v.FIVE_MINUTES, prompt: !0, tag: 1110 },
            res: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1111 },
          },
          wc_sessionDelete: {
            req: { ttl: v.ONE_DAY, prompt: !1, tag: 1112 },
            res: { ttl: v.ONE_DAY, prompt: !1, tag: 1113 },
          },
          wc_sessionPing: {
            req: { ttl: v.ONE_DAY, prompt: !1, tag: 1114 },
            res: { ttl: v.ONE_DAY, prompt: !1, tag: 1115 },
          },
          wc_sessionAuthenticate: {
            req: { ttl: v.ONE_HOUR, prompt: !0, tag: 1116 },
            res: { ttl: v.ONE_HOUR, prompt: !1, tag: 1117 },
            reject: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1118 },
            autoReject: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1119 },
          },
        },
        pS = { min: v.FIVE_MINUTES, max: v.SEVEN_DAYS },
        pP = { idle: 'IDLE', active: 'ACTIVE' },
        pO = {
          eth_sendTransaction: { key: '' },
          eth_sendRawTransaction: { key: '' },
          wallet_sendCalls: { key: '' },
          solana_signTransaction: { key: 'signature' },
          solana_signAllTransactions: { key: 'transactions' },
          solana_signAndSendTransaction: { key: 'signature' },
        },
        pN = ['wc_sessionPropose', 'wc_sessionRequest', 'wc_authRequest', 'wc_sessionAuthenticate'],
        px = 'wc@1.5:auth:',
        pM = `${px}:PUB_KEY`;
      var pk = Object.defineProperty,
        pR = Object.defineProperties,
        pD = Object.getOwnPropertyDescriptors,
        pB = Object.getOwnPropertySymbols,
        pU = Object.prototype.hasOwnProperty,
        pL = Object.prototype.propertyIsEnumerable,
        pF = (e, t, n) =>
          t in e
            ? pk(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        pj = (e, t) => {
          for (var n in t || (t = {})) pU.call(t, n) && pF(e, n, t[n]);
          if (pB) for (var n of pB(t)) pL.call(t, n) && pF(e, n, t[n]);
          return e;
        },
        pq = (e, t) => pR(e, pD(t)),
        pV = (e, t, n) => pF(e, 'symbol' != typeof t ? t + '' : t, n);
      class p$ extends eA {
        constructor(e) {
          super(e),
            pV(this, 'name', 'engine'),
            pV(this, 'events', new (w())()),
            pV(this, 'initialized', !1),
            pV(this, 'requestQueue', { state: pP.idle, queue: [] }),
            pV(this, 'sessionRequestQueue', { state: pP.idle, queue: [] }),
            pV(this, 'requestQueueDelay', v.ONE_SECOND),
            pV(this, 'expectedPairingMethodMap', new Map()),
            pV(this, 'recentlyDeletedMap', new Map()),
            pV(this, 'recentlyDeletedLimit', 200),
            pV(this, 'relayMessageCache', []),
            pV(this, 'pendingSessions', new Map()),
            pV(this, 'init', async () => {
              this.initialized ||
                (await this.cleanup(),
                this.registerRelayerEvents(),
                this.registerExpirerEvents(),
                this.registerPairingEvents(),
                await this.registerLinkModeListeners(),
                this.client.core.pairing.register({ methods: Object.keys(pI) }),
                (this.initialized = !0),
                setTimeout(
                  async () => {
                    await this.processPendingMessageEvents(),
                      (this.sessionRequestQueue.queue = this.getPendingSessionRequests()),
                      this.processSessionRequestQueue();
                  },
                  (0, v.toMiliseconds)(this.requestQueueDelay)
                ));
            }),
            pV(this, 'connect', async (e) => {
              this.isInitialized(), await this.confirmOnlineStateOrThrow();
              let t = pq(pj({}, e), {
                requiredNamespaces: e.requiredNamespaces || {},
                optionalNamespaces: e.optionalNamespaces || {},
              });
              await this.isValidConnect(t);
              let {
                  pairingTopic: n,
                  requiredNamespaces: r,
                  optionalNamespaces: i,
                  sessionProperties: a,
                  scopedProperties: s,
                  relays: o,
                } = t,
                l = n,
                u,
                c = !1;
              try {
                if (l) {
                  let e = this.client.core.pairing.pairings.get(l);
                  this.client.logger.warn(
                    'connect() with existing pairing topic is deprecated and will be removed in the next major release.'
                  ),
                    (c = e.active);
                }
              } catch (e) {
                throw (this.client.logger.error(`connect() -> pairing.get(${l}) failed`), e);
              }
              if (!l || !c) {
                let { topic: e, uri: t } = await this.client.core.pairing.create();
                (l = e), (u = t);
              }
              if (!l) {
                let { message: e } = lz('NO_MATCHING_KEY', `connect() pairing topic: ${l}`);
                throw Error(e);
              }
              let d = await this.client.core.crypto.generateKeyPair(),
                p = pI.wc_sessionPropose.req.ttl || v.FIVE_MINUTES,
                h = a_(p),
                y = pq(
                  pj(
                    pj(
                      {
                        requiredNamespaces: r,
                        optionalNamespaces: i,
                        relays: o ?? [{ protocol: 'irn' }],
                        proposer: { publicKey: d, metadata: this.client.metadata },
                        expiryTimestamp: h,
                        pairingTopic: l,
                      },
                      a && { sessionProperties: a }
                    ),
                    s && { scopedProperties: s }
                  ),
                  { id: uo() }
                ),
                f = aS('session_connect', y.id),
                { reject: m, resolve: g, done: b } = aT(p, pC),
                w = ({ id: e }) => {
                  e === y.id &&
                    (this.client.events.off('proposal_expire', w),
                    this.pendingSessions.delete(y.id),
                    this.events.emit(f, { error: { message: pC, code: 0 } }));
                };
              return (
                this.client.events.on('proposal_expire', w),
                this.events.once(f, ({ error: e, session: t }) => {
                  this.client.events.off('proposal_expire', w), e ? m(e) : t && g(t);
                }),
                await this.sendRequest({
                  topic: l,
                  method: 'wc_sessionPropose',
                  params: y,
                  throwOnFailedPublish: !0,
                  clientRpcId: y.id,
                }),
                await this.setProposal(y.id, y),
                { uri: u, approval: b }
              );
            }),
            pV(this, 'pair', async (e) => {
              this.isInitialized(), await this.confirmOnlineStateOrThrow();
              try {
                return await this.client.core.pairing.pair(e);
              } catch (e) {
                throw (this.client.logger.error('pair() failed'), e);
              }
            }),
            pV(this, 'approve', async (e) => {
              var t, n, r;
              let i = this.client.core.eventClient.createEvent({
                properties: {
                  topic: null == (t = e?.id) ? void 0 : t.toString(),
                  trace: [u0.session_approve_started],
                },
              });
              try {
                this.isInitialized(), await this.confirmOnlineStateOrThrow();
              } catch (e) {
                throw (i.setError(u1.no_internet_connection), e);
              }
              try {
                await this.isValidProposalId(e?.id);
              } catch (t) {
                throw (
                  (this.client.logger.error(`approve() -> proposal.get(${e?.id}) failed`),
                  i.setError(u1.proposal_not_found),
                  t)
                );
              }
              try {
                await this.isValidApprove(e);
              } catch (e) {
                throw (
                  (this.client.logger.error('approve() -> isValidApprove() failed'),
                  i.setError(u1.session_approve_namespace_validation_failure),
                  e)
                );
              }
              let {
                  id: a,
                  relayProtocol: s,
                  namespaces: o,
                  sessionProperties: l,
                  scopedProperties: u,
                  sessionConfig: c,
                } = e,
                d = this.client.proposal.get(a);
              this.client.core.eventClient.deleteEvent({ eventId: i.eventId });
              let {
                  pairingTopic: p,
                  proposer: h,
                  requiredNamespaces: y,
                  optionalNamespaces: f,
                } = d,
                m = null == (n = this.client.core.eventClient) ? void 0 : n.getEvent({ topic: p });
              m ||
                (m =
                  null == (r = this.client.core.eventClient)
                    ? void 0
                    : r.createEvent({
                        type: u0.session_approve_started,
                        properties: {
                          topic: p,
                          trace: [
                            u0.session_approve_started,
                            u0.session_namespaces_validation_success,
                          ],
                        },
                      }));
              let g = await this.client.core.crypto.generateKeyPair(),
                b = h.publicKey,
                w = await this.client.core.crypto.generateSharedKey(g, b),
                v = pj(
                  pj(
                    pj(
                      {
                        relay: { protocol: s ?? 'irn' },
                        namespaces: o,
                        controller: { publicKey: g, metadata: this.client.metadata },
                        expiry: a_(p_),
                      },
                      l && { sessionProperties: l }
                    ),
                    u && { scopedProperties: u }
                  ),
                  c && { sessionConfig: c }
                ),
                T = uq.relay;
              m.addTrace(u0.subscribing_session_topic);
              try {
                await this.client.core.relayer.subscribe(w, { transportType: T });
              } catch (e) {
                throw (m.setError(u1.subscribe_session_topic_failure), e);
              }
              m.addTrace(u0.subscribe_session_topic_success);
              let A = pq(pj({}, v), {
                topic: w,
                requiredNamespaces: y,
                optionalNamespaces: f,
                pairingTopic: p,
                acknowledged: !1,
                self: v.controller,
                peer: { publicKey: h.publicKey, metadata: h.metadata },
                controller: g,
                transportType: uq.relay,
              });
              await this.client.session.set(w, A), m.addTrace(u0.store_session);
              try {
                m.addTrace(u0.publishing_session_settle),
                  await this.sendRequest({
                    topic: w,
                    method: 'wc_sessionSettle',
                    params: v,
                    throwOnFailedPublish: !0,
                  }).catch((e) => {
                    throw (m?.setError(u1.session_settle_publish_failure), e);
                  }),
                  m.addTrace(u0.session_settle_publish_success),
                  m.addTrace(u0.publishing_session_approve),
                  await this.sendResult({
                    id: a,
                    topic: p,
                    result: { relay: { protocol: s ?? 'irn' }, responderPublicKey: g },
                    throwOnFailedPublish: !0,
                  }).catch((e) => {
                    throw (m?.setError(u1.session_approve_publish_failure), e);
                  }),
                  m.addTrace(u0.session_approve_publish_success);
              } catch (e) {
                throw (
                  (this.client.logger.error(e),
                  this.client.session.delete(w, lW('USER_DISCONNECTED')),
                  await this.client.core.relayer.unsubscribe(w),
                  e)
                );
              }
              return (
                this.client.core.eventClient.deleteEvent({ eventId: m.eventId }),
                await this.client.core.pairing.updateMetadata({ topic: p, metadata: h.metadata }),
                await this.client.proposal.delete(a, lW('USER_DISCONNECTED')),
                await this.client.core.pairing.activate({ topic: p }),
                await this.setExpiry(w, a_(p_)),
                { topic: w, acknowledged: () => Promise.resolve(this.client.session.get(w)) }
              );
            }),
            pV(this, 'reject', async (e) => {
              let t;
              this.isInitialized(), await this.confirmOnlineStateOrThrow();
              try {
                await this.isValidReject(e);
              } catch (e) {
                throw (this.client.logger.error('reject() -> isValidReject() failed'), e);
              }
              let { id: n, reason: r } = e;
              try {
                t = this.client.proposal.get(n).pairingTopic;
              } catch (e) {
                throw (this.client.logger.error(`reject() -> proposal.get(${n}) failed`), e);
              }
              t &&
                (await this.sendError({
                  id: n,
                  topic: t,
                  error: r,
                  rpcOpts: pI.wc_sessionPropose.reject,
                }),
                await this.client.proposal.delete(n, lW('USER_DISCONNECTED')));
            }),
            pV(this, 'update', async (e) => {
              this.isInitialized(), await this.confirmOnlineStateOrThrow();
              try {
                await this.isValidUpdate(e);
              } catch (e) {
                throw (this.client.logger.error('update() -> isValidUpdate() failed'), e);
              }
              let { topic: t, namespaces: n } = e,
                { done: r, resolve: i, reject: a } = aT(),
                s = uo(),
                o = ul().toString(),
                l = this.client.session.get(t).namespaces;
              return (
                this.events.once(aS('session_update', s), ({ error: e }) => {
                  e ? a(e) : i();
                }),
                await this.client.session.update(t, { namespaces: n }),
                await this.sendRequest({
                  topic: t,
                  method: 'wc_sessionUpdate',
                  params: { namespaces: n },
                  throwOnFailedPublish: !0,
                  clientRpcId: s,
                  relayRpcId: o,
                }).catch((e) => {
                  this.client.logger.error(e),
                    this.client.session.update(t, { namespaces: l }),
                    a(e);
                }),
                { acknowledged: r }
              );
            }),
            pV(this, 'extend', async (e) => {
              this.isInitialized(), await this.confirmOnlineStateOrThrow();
              try {
                await this.isValidExtend(e);
              } catch (e) {
                throw (this.client.logger.error('extend() -> isValidExtend() failed'), e);
              }
              let { topic: t } = e,
                n = uo(),
                { done: r, resolve: i, reject: a } = aT();
              return (
                this.events.once(aS('session_extend', n), ({ error: e }) => {
                  e ? a(e) : i();
                }),
                await this.setExpiry(t, a_(p_)),
                this.sendRequest({
                  topic: t,
                  method: 'wc_sessionExtend',
                  params: {},
                  clientRpcId: n,
                  throwOnFailedPublish: !0,
                }).catch((e) => {
                  a(e);
                }),
                { acknowledged: r }
              );
            }),
            pV(this, 'request', async (e) => {
              this.isInitialized();
              try {
                await this.isValidRequest(e);
              } catch (e) {
                throw (this.client.logger.error('request() -> isValidRequest() failed'), e);
              }
              let {
                  chainId: t,
                  request: n,
                  topic: r,
                  expiry: i = pI.wc_sessionRequest.req.ttl,
                } = e,
                a = this.client.session.get(r);
              a?.transportType === uq.relay && (await this.confirmOnlineStateOrThrow());
              let s = uo(),
                o = ul().toString(),
                { done: l, resolve: u, reject: c } = aT(i, 'Request expired. Please try again.');
              this.events.once(aS('session_request', s), ({ error: e, result: t }) => {
                e ? c(e) : u(t);
              });
              let d = 'wc_sessionRequest',
                p = this.getAppLinkIfEnabled(a.peer.metadata, a.transportType);
              if (p)
                return (
                  await this.sendRequest({
                    clientRpcId: s,
                    relayRpcId: o,
                    topic: r,
                    method: d,
                    params: { request: pq(pj({}, n), { expiryTimestamp: a_(i) }), chainId: t },
                    expiry: i,
                    throwOnFailedPublish: !0,
                    appLink: p,
                  }).catch((e) => c(e)),
                  this.client.events.emit('session_request_sent', {
                    topic: r,
                    request: n,
                    chainId: t,
                    id: s,
                  }),
                  await l()
                );
              let h = { request: pq(pj({}, n), { expiryTimestamp: a_(i) }), chainId: t },
                y = this.shouldSetTVF(d, h);
              return await Promise.all([
                new Promise(async (e) => {
                  await this.sendRequest(
                    pj(
                      {
                        clientRpcId: s,
                        relayRpcId: o,
                        topic: r,
                        method: d,
                        params: h,
                        expiry: i,
                        throwOnFailedPublish: !0,
                      },
                      y && { tvf: this.getTVFParams(s, h) }
                    )
                  ).catch((e) => c(e)),
                    this.client.events.emit('session_request_sent', {
                      topic: r,
                      request: n,
                      chainId: t,
                      id: s,
                    }),
                    e();
                }),
                new Promise(async (e) => {
                  var t;
                  if (!(null != (t = a.sessionConfig) && t.disableDeepLink)) {
                    let e = await aN(this.client.core.storage, pE);
                    await aO({ id: s, topic: r, wcDeepLink: e });
                  }
                  e();
                }),
                l(),
              ]).then((e) => e[2]);
            }),
            pV(this, 'respond', async (e) => {
              this.isInitialized(), await this.isValidRespond(e);
              let { topic: t, response: n } = e,
                { id: r } = n,
                i = this.client.session.get(t);
              i.transportType === uq.relay && (await this.confirmOnlineStateOrThrow());
              let a = this.getAppLinkIfEnabled(i.peer.metadata, i.transportType);
              uT(n)
                ? await this.sendResult({
                    id: r,
                    topic: t,
                    result: n.result,
                    throwOnFailedPublish: !0,
                    appLink: a,
                  })
                : uA(n) && (await this.sendError({ id: r, topic: t, error: n.error, appLink: a })),
                this.cleanupAfterResponse(e);
            }),
            pV(this, 'ping', async (e) => {
              this.isInitialized(), await this.confirmOnlineStateOrThrow();
              try {
                await this.isValidPing(e);
              } catch (e) {
                throw (this.client.logger.error('ping() -> isValidPing() failed'), e);
              }
              let { topic: t } = e;
              if (this.client.session.keys.includes(t)) {
                let e = uo(),
                  n = ul().toString(),
                  { done: r, resolve: i, reject: a } = aT();
                this.events.once(aS('session_ping', e), ({ error: e }) => {
                  e ? a(e) : i();
                }),
                  await Promise.all([
                    this.sendRequest({
                      topic: t,
                      method: 'wc_sessionPing',
                      params: {},
                      throwOnFailedPublish: !0,
                      clientRpcId: e,
                      relayRpcId: n,
                    }),
                    r(),
                  ]);
              } else
                this.client.core.pairing.pairings.keys.includes(t) &&
                  (this.client.logger.warn(
                    'ping() on pairing topic is deprecated and will be removed in the next major release.'
                  ),
                  await this.client.core.pairing.ping({ topic: t }));
            }),
            pV(this, 'emit', async (e) => {
              this.isInitialized(),
                await this.confirmOnlineStateOrThrow(),
                await this.isValidEmit(e);
              let { topic: t, event: n, chainId: r } = e,
                i = ul().toString(),
                a = uo();
              await this.sendRequest({
                topic: t,
                method: 'wc_sessionEvent',
                params: { event: n, chainId: r },
                throwOnFailedPublish: !0,
                relayRpcId: i,
                clientRpcId: a,
              });
            }),
            pV(this, 'disconnect', async (e) => {
              this.isInitialized(),
                await this.confirmOnlineStateOrThrow(),
                await this.isValidDisconnect(e);
              let { topic: t } = e;
              if (this.client.session.keys.includes(t))
                await this.sendRequest({
                  topic: t,
                  method: 'wc_sessionDelete',
                  params: lW('USER_DISCONNECTED'),
                  throwOnFailedPublish: !0,
                }),
                  await this.deleteSession({ topic: t, emitEvent: !1 });
              else if (this.client.core.pairing.pairings.keys.includes(t))
                await this.client.core.pairing.disconnect({ topic: t });
              else {
                let { message: e } = lz(
                  'MISMATCHED_TOPIC',
                  `Session or pairing topic not found: ${t}`
                );
                throw Error(e);
              }
            }),
            pV(
              this,
              'find',
              (e) => (
                this.isInitialized(),
                this.client.session.getAll().filter((t) =>
                  (function (e, t) {
                    let { requiredNamespaces: n } = t,
                      r = Object.keys(e.namespaces),
                      i = Object.keys(n),
                      a = !0;
                    return (
                      !!ab(i, r) &&
                      (r.forEach((t) => {
                        let { accounts: r, methods: i, events: s } = e.namespaces[t],
                          o = lL(r),
                          l = n[t];
                        (ab(ae(t, l), o) && ab(l.methods, i) && ab(l.events, s)) || (a = !1);
                      }),
                      a)
                    );
                  })(t, e)
                )
              )
            ),
            pV(this, 'getPendingSessionRequests', () => this.client.pendingRequest.getAll()),
            pV(this, 'authenticate', async (e, t) => {
              var n, r, i;
              let a;
              this.isInitialized(), this.isValidAuthenticate(e);
              let s =
                  t &&
                  this.client.core.linkModeSupportedApps.includes(t) &&
                  (null == (n = this.client.metadata.redirect) ? void 0 : n.linkMode),
                o = s ? uq.link_mode : uq.relay;
              o === uq.relay && (await this.confirmOnlineStateOrThrow());
              let {
                  chains: l,
                  statement: u = '',
                  uri: c,
                  domain: d,
                  nonce: p,
                  type: h,
                  exp: y,
                  nbf: f,
                  methods: m = [],
                  expiry: g,
                } = e,
                b = [...(e.resources || [])],
                { topic: w, uri: v } = await this.client.core.pairing.create({
                  methods: ['wc_sessionAuthenticate'],
                  transportType: o,
                });
              this.client.logger.info({
                message: 'Generated new pairing',
                pairing: { topic: w, uri: v },
              });
              let T = await this.client.core.crypto.generateKeyPair(),
                A = lC(T);
              if (
                (await Promise.all([
                  this.client.auth.authKeys.set(pM, { responseTopic: A, publicKey: T }),
                  this.client.auth.pairingTopics.set(A, { topic: A, pairingTopic: w }),
                ]),
                await this.client.core.relayer.subscribe(A, { transportType: o }),
                this.client.logger.info(`sending request to new pairing topic: ${w}`),
                m.length > 0)
              ) {
                let { namespace: e } = i7(l[0]),
                  t = sI(
                    (function (e, t, n, r = {}) {
                      return (
                        n?.sort((e, t) => e.localeCompare(t)),
                        {
                          att: {
                            [e]: (function (e, t, n = {}) {
                              return Object.assign(
                                {},
                                ...(t = t?.sort((e, t) => e.localeCompare(t))).map((t) => ({
                                  [`${e}/${t}`]: [n],
                                }))
                              );
                            })(t, n, r),
                          },
                        }
                      );
                    })(e, 'request', m)
                  );
                sN(b) &&
                  ((r = t),
                  (i = b.pop()),
                  (t = sI(
                    (function (e, t) {
                      s_(e), s_(t);
                      let n = Object.keys(e.att)
                          .concat(Object.keys(t.att))
                          .sort((e, t) => e.localeCompare(t)),
                        r = { att: {} };
                      return (
                        n.forEach((n) => {
                          var i, a;
                          Object.keys((null == (i = e.att) ? void 0 : i[n]) || {})
                            .concat(Object.keys((null == (a = t.att) ? void 0 : a[n]) || {}))
                            .sort((e, t) => e.localeCompare(t))
                            .forEach((i) => {
                              var a, s;
                              r.att[n] = sb(sg({}, r.att[n]), {
                                [i]:
                                  (null == (a = e.att[n]) ? void 0 : a[i]) ||
                                  (null == (s = t.att[n]) ? void 0 : s[i]),
                              });
                            });
                        }),
                        r
                      );
                    })(sS(r), sS(i))
                  ))),
                  b.push(t);
              }
              let E =
                  g && g > pI.wc_sessionAuthenticate.req.ttl
                    ? g
                    : pI.wc_sessionAuthenticate.req.ttl,
                C = {
                  authPayload: {
                    type: h ?? 'caip122',
                    chains: l,
                    statement: u,
                    aud: c,
                    domain: d,
                    version: '1',
                    nonce: p,
                    iat: new Date().toISOString(),
                    exp: y,
                    nbf: f,
                    resources: b,
                  },
                  requester: { publicKey: T, metadata: this.client.metadata },
                  expiryTimestamp: a_(E),
                },
                _ = {
                  requiredNamespaces: {},
                  optionalNamespaces: {
                    eip155: {
                      chains: l,
                      methods: [...new Set(['personal_sign', ...m])],
                      events: ['chainChanged', 'accountsChanged'],
                    },
                  },
                  relays: [{ protocol: 'irn' }],
                  pairingTopic: w,
                  proposer: { publicKey: T, metadata: this.client.metadata },
                  expiryTimestamp: a_(pI.wc_sessionPropose.req.ttl),
                  id: uo(),
                },
                { done: I, resolve: S, reject: P } = aT(E, 'Request expired'),
                O = uo(),
                N = aS('session_connect', _.id),
                x = aS('session_request', O),
                M = async ({ error: e, session: t }) => {
                  this.events.off(x, k), e ? P(e) : t && S({ session: t });
                },
                k = async (e) => {
                  var n, r, i;
                  let a;
                  if (
                    (await this.deletePendingAuthRequest(O, { message: 'fulfilled', code: 0 }),
                    e.error)
                  ) {
                    let t = lW('WC_METHOD_UNSUPPORTED', 'wc_sessionAuthenticate');
                    return e.error.code === t.code
                      ? void 0
                      : (this.events.off(N, M), P(e.error.message));
                  }
                  await this.deleteProposal(_.id), this.events.off(N, M);
                  let { cacaos: s, responder: l } = e.result,
                    u = [],
                    c = [];
                  for (let e of s) {
                    (await sE({ cacao: e, projectId: this.client.core.projectId })) ||
                      (this.client.logger.error(e, 'Signature verification failed'),
                      P(lW('SESSION_SETTLEMENT_FAILED', 'Signature verification failed')));
                    let { p: t } = e,
                      n = sN(t.resources),
                      r = [sT(t.iss)],
                      i = sA(t.iss);
                    if (n) {
                      let e = sP(n),
                        t = sO(n);
                      u.push(...e), r.push(...t);
                    }
                    for (let e of r) c.push(`${e}:${i}`);
                  }
                  let d = await this.client.core.crypto.generateSharedKey(T, l.publicKey);
                  u.length > 0 &&
                    ((a = {
                      topic: d,
                      acknowledged: !0,
                      self: { publicKey: T, metadata: this.client.metadata },
                      peer: l,
                      controller: l.publicKey,
                      expiry: a_(p_),
                      requiredNamespaces: {},
                      optionalNamespaces: {},
                      relay: { protocol: 'irn' },
                      pairingTopic: w,
                      namespaces: lq([...new Set(u)], [...new Set(c)]),
                      transportType: o,
                    }),
                    await this.client.core.relayer.subscribe(d, { transportType: o }),
                    await this.client.session.set(d, a),
                    w &&
                      (await this.client.core.pairing.updateMetadata({
                        topic: w,
                        metadata: l.metadata,
                      })),
                    (a = this.client.session.get(d))),
                    null != (n = this.client.metadata.redirect) &&
                      n.linkMode &&
                      null != (r = l.metadata.redirect) &&
                      r.linkMode &&
                      null != (i = l.metadata.redirect) &&
                      i.universal &&
                      t &&
                      (this.client.core.addLinkModeSupportedApp(l.metadata.redirect.universal),
                      this.client.session.update(d, { transportType: uq.link_mode })),
                    S({ auths: s, session: a });
                };
              this.events.once(N, M), this.events.once(x, k);
              try {
                if (s) {
                  let e = uu('wc_sessionAuthenticate', C, O);
                  this.client.core.history.set(w, e);
                  let n = await this.client.core.crypto.encode('', e, { type: 2, encoding: lT });
                  a = lU(t, w, n);
                } else
                  await Promise.all([
                    this.sendRequest({
                      topic: w,
                      method: 'wc_sessionAuthenticate',
                      params: C,
                      expiry: e.expiry,
                      throwOnFailedPublish: !0,
                      clientRpcId: O,
                    }),
                    this.sendRequest({
                      topic: w,
                      method: 'wc_sessionPropose',
                      params: _,
                      expiry: pI.wc_sessionPropose.req.ttl,
                      throwOnFailedPublish: !0,
                      clientRpcId: _.id,
                    }),
                  ]);
              } catch (e) {
                throw (this.events.off(N, M), this.events.off(x, k), e);
              }
              return (
                await this.setProposal(_.id, _),
                await this.setAuthRequest(O, {
                  request: pq(pj({}, C), { verifyContext: {} }),
                  pairingTopic: w,
                  transportType: o,
                }),
                { uri: a ?? v, response: I }
              );
            }),
            pV(this, 'approveSessionAuthenticate', async (e) => {
              let t;
              let { id: n, auths: r } = e,
                i = this.client.core.eventClient.createEvent({
                  properties: {
                    topic: n.toString(),
                    trace: [u2.authenticated_session_approve_started],
                  },
                });
              try {
                this.isInitialized();
              } catch (e) {
                throw (i.setError(u6.no_internet_connection), e);
              }
              let a = this.getPendingAuthRequest(n);
              if (!a)
                throw (
                  (i.setError(u6.authenticated_session_pending_request_not_found),
                  Error(`Could not find pending auth request with id ${n}`))
                );
              let s = a.transportType || uq.relay;
              s === uq.relay && (await this.confirmOnlineStateOrThrow());
              let o = a.requester.publicKey,
                l = await this.client.core.crypto.generateKeyPair(),
                u = lC(o),
                c = { type: 1, receiverPublicKey: o, senderPublicKey: l },
                d = [],
                p = [];
              for (let e of r) {
                if (!(await sE({ cacao: e, projectId: this.client.core.projectId }))) {
                  i.setError(u6.invalid_cacao);
                  let e = lW('SESSION_SETTLEMENT_FAILED', 'Signature verification failed');
                  throw (
                    (await this.sendError({ id: n, topic: u, error: e, encodeOpts: c }),
                    Error(e.message))
                  );
                }
                i.addTrace(u2.cacaos_verified);
                let { p: t } = e,
                  r = sN(t.resources),
                  a = [sT(t.iss)],
                  s = sA(t.iss);
                if (r) {
                  let e = sP(r),
                    t = sO(r);
                  d.push(...e), a.push(...t);
                }
                for (let e of a) p.push(`${e}:${s}`);
              }
              let h = await this.client.core.crypto.generateSharedKey(l, o);
              if ((i.addTrace(u2.create_authenticated_session_topic), d?.length > 0)) {
                (t = {
                  topic: h,
                  acknowledged: !0,
                  self: { publicKey: l, metadata: this.client.metadata },
                  peer: { publicKey: o, metadata: a.requester.metadata },
                  controller: o,
                  expiry: a_(p_),
                  authentication: r,
                  requiredNamespaces: {},
                  optionalNamespaces: {},
                  relay: { protocol: 'irn' },
                  pairingTopic: a.pairingTopic,
                  namespaces: lq([...new Set(d)], [...new Set(p)]),
                  transportType: s,
                }),
                  i.addTrace(u2.subscribing_authenticated_session_topic);
                try {
                  await this.client.core.relayer.subscribe(h, { transportType: s });
                } catch (e) {
                  throw (i.setError(u6.subscribe_authenticated_session_topic_failure), e);
                }
                i.addTrace(u2.subscribe_authenticated_session_topic_success),
                  await this.client.session.set(h, t),
                  i.addTrace(u2.store_authenticated_session),
                  await this.client.core.pairing.updateMetadata({
                    topic: a.pairingTopic,
                    metadata: a.requester.metadata,
                  });
              }
              i.addTrace(u2.publishing_authenticated_session_approve);
              try {
                await this.sendResult({
                  topic: u,
                  id: n,
                  result: {
                    cacaos: r,
                    responder: { publicKey: l, metadata: this.client.metadata },
                  },
                  encodeOpts: c,
                  throwOnFailedPublish: !0,
                  appLink: this.getAppLinkIfEnabled(a.requester.metadata, s),
                });
              } catch (e) {
                throw (i.setError(u6.authenticated_session_approve_publish_failure), e);
              }
              return (
                await this.client.auth.requests.delete(n, { message: 'fulfilled', code: 0 }),
                await this.client.core.pairing.activate({ topic: a.pairingTopic }),
                this.client.core.eventClient.deleteEvent({ eventId: i.eventId }),
                { session: t }
              );
            }),
            pV(this, 'rejectSessionAuthenticate', async (e) => {
              this.isInitialized();
              let { id: t, reason: n } = e,
                r = this.getPendingAuthRequest(t);
              if (!r) throw Error(`Could not find pending auth request with id ${t}`);
              r.transportType === uq.relay && (await this.confirmOnlineStateOrThrow());
              let i = r.requester.publicKey,
                a = await this.client.core.crypto.generateKeyPair(),
                s = lC(i);
              await this.sendError({
                id: t,
                topic: s,
                error: n,
                encodeOpts: { type: 1, receiverPublicKey: i, senderPublicKey: a },
                rpcOpts: pI.wc_sessionAuthenticate.reject,
                appLink: this.getAppLinkIfEnabled(r.requester.metadata, r.transportType),
              }),
                await this.client.auth.requests.delete(t, { message: 'rejected', code: 0 }),
                await this.client.proposal.delete(t, lW('USER_DISCONNECTED'));
            }),
            pV(this, 'formatAuthMessage', (e) => {
              this.isInitialized();
              let { request: t, iss: n } = e;
              return sC(t, n);
            }),
            pV(this, 'processRelayMessageCache', () => {
              setTimeout(async () => {
                if (0 !== this.relayMessageCache.length)
                  for (; this.relayMessageCache.length > 0; )
                    try {
                      let e = this.relayMessageCache.shift();
                      e && (await this.onRelayMessage(e));
                    } catch (e) {
                      this.client.logger.error(e);
                    }
              }, 50);
            }),
            pV(this, 'cleanupDuplicatePairings', async (e) => {
              if (e.pairingTopic)
                try {
                  let t = this.client.core.pairing.pairings.get(e.pairingTopic),
                    n = this.client.core.pairing.pairings.getAll().filter((n) => {
                      var r, i;
                      return (
                        (null == (r = n.peerMetadata) ? void 0 : r.url) &&
                        (null == (i = n.peerMetadata) ? void 0 : i.url) === e.peer.metadata.url &&
                        n.topic &&
                        n.topic !== t.topic
                      );
                    });
                  if (0 === n.length) return;
                  this.client.logger.info(`Cleaning up ${n.length} duplicate pairing(s)`),
                    await Promise.all(
                      n.map((e) => this.client.core.pairing.disconnect({ topic: e.topic }))
                    ),
                    this.client.logger.info('Duplicate pairings clean up finished');
                } catch (e) {
                  this.client.logger.error(e);
                }
            }),
            pV(this, 'deleteSession', async (e) => {
              var t;
              let { topic: n, expirerHasDeleted: r = !1, emitEvent: i = !0, id: a = 0 } = e,
                { self: s } = this.client.session.get(n);
              await this.client.core.relayer.unsubscribe(n),
                await this.client.session.delete(n, lW('USER_DISCONNECTED')),
                this.addToRecentlyDeleted(n, 'session'),
                this.client.core.crypto.keychain.has(s.publicKey) &&
                  (await this.client.core.crypto.deleteKeyPair(s.publicKey)),
                this.client.core.crypto.keychain.has(n) &&
                  (await this.client.core.crypto.deleteSymKey(n)),
                r || this.client.core.expirer.del(n),
                this.client.core.storage.removeItem(pE).catch((e) => this.client.logger.warn(e)),
                this.getPendingSessionRequests().forEach((e) => {
                  e.topic === n && this.deletePendingSessionRequest(e.id, lW('USER_DISCONNECTED'));
                }),
                n === (null == (t = this.sessionRequestQueue.queue[0]) ? void 0 : t.topic) &&
                  (this.sessionRequestQueue.state = pP.idle),
                i && this.client.events.emit('session_delete', { id: a, topic: n });
            }),
            pV(this, 'deleteProposal', async (e, t) => {
              if (t)
                try {
                  let t = this.client.proposal.get(e),
                    n = this.client.core.eventClient.getEvent({ topic: t.pairingTopic });
                  n?.setError(u1.proposal_expired);
                } catch {}
              await Promise.all([
                this.client.proposal.delete(e, lW('USER_DISCONNECTED')),
                t ? Promise.resolve() : this.client.core.expirer.del(e),
              ]),
                this.addToRecentlyDeleted(e, 'proposal');
            }),
            pV(this, 'deletePendingSessionRequest', async (e, t, n = !1) => {
              await Promise.all([
                this.client.pendingRequest.delete(e, t),
                n ? Promise.resolve() : this.client.core.expirer.del(e),
              ]),
                this.addToRecentlyDeleted(e, 'request'),
                (this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter(
                  (t) => t.id !== e
                )),
                n &&
                  ((this.sessionRequestQueue.state = pP.idle),
                  this.client.events.emit('session_request_expire', { id: e }));
            }),
            pV(this, 'deletePendingAuthRequest', async (e, t, n = !1) => {
              await Promise.all([
                this.client.auth.requests.delete(e, t),
                n ? Promise.resolve() : this.client.core.expirer.del(e),
              ]);
            }),
            pV(this, 'setExpiry', async (e, t) => {
              this.client.session.keys.includes(e) &&
                (this.client.core.expirer.set(e, t),
                await this.client.session.update(e, { expiry: t }));
            }),
            pV(this, 'setProposal', async (e, t) => {
              this.client.core.expirer.set(e, a_(pI.wc_sessionPropose.req.ttl)),
                await this.client.proposal.set(e, t);
            }),
            pV(this, 'setAuthRequest', async (e, t) => {
              let { request: n, pairingTopic: r, transportType: i = uq.relay } = t;
              this.client.core.expirer.set(e, n.expiryTimestamp),
                await this.client.auth.requests.set(e, {
                  authPayload: n.authPayload,
                  requester: n.requester,
                  expiryTimestamp: n.expiryTimestamp,
                  id: e,
                  pairingTopic: r,
                  verifyContext: n.verifyContext,
                  transportType: i,
                });
            }),
            pV(this, 'setPendingSessionRequest', async (e) => {
              let { id: t, topic: n, params: r, verifyContext: i } = e,
                a = r.request.expiryTimestamp || a_(pI.wc_sessionRequest.req.ttl);
              this.client.core.expirer.set(t, a),
                await this.client.pendingRequest.set(t, {
                  id: t,
                  topic: n,
                  params: r,
                  verifyContext: i,
                });
            }),
            pV(this, 'sendRequest', async (e) => {
              let t, r;
              let {
                  topic: i,
                  method: a,
                  params: s,
                  expiry: o,
                  relayRpcId: l,
                  clientRpcId: u,
                  throwOnFailedPublish: c,
                  appLink: d,
                  tvf: p,
                } = e,
                h = uu(a, s, u),
                y = !!d;
              try {
                let e = y ? lT : lv;
                t = await this.client.core.crypto.encode(i, h, { encoding: e });
              } catch (e) {
                throw (
                  (await this.cleanup(),
                  this.client.logger.error(
                    `sendRequest() -> core.crypto.encode() for topic ${i} failed`
                  ),
                  e)
                );
              }
              if (pN.includes(a)) {
                let e = l_(JSON.stringify(h)),
                  n = l_(t);
                r = await this.client.core.verify.register({ id: n, decryptedId: e });
              }
              let f = pI[a].req;
              if (
                ((f.attestation = r),
                o && (f.ttl = o),
                l && (f.id = l),
                this.client.core.history.set(i, h),
                y)
              ) {
                let e = lU(d, i, t);
                await n.g.Linking.openURL(e, this.client.name);
              } else {
                let e = pI[a].req;
                o && (e.ttl = o),
                  l && (e.id = l),
                  (e.tvf = pq(pj({}, p), { correlationId: h.id })),
                  c
                    ? ((e.internal = pq(pj({}, e.internal), { throwOnFailedPublish: !0 })),
                      await this.client.core.relayer.publish(i, t, e))
                    : this.client.core.relayer
                        .publish(i, t, e)
                        .catch((e) => this.client.logger.error(e));
              }
              return h.id;
            }),
            pV(this, 'sendResult', async (e) => {
              let t, r, i;
              let {
                  id: a,
                  topic: s,
                  result: o,
                  throwOnFailedPublish: l,
                  encodeOpts: u,
                  appLink: c,
                } = e,
                d = uc(a, o),
                p = c && 'u' > typeof (null == n.g ? void 0 : n.g.Linking);
              try {
                let e = p ? lT : lv;
                t = await this.client.core.crypto.encode(
                  s,
                  d,
                  pq(pj({}, u || {}), { encoding: e })
                );
              } catch (e) {
                throw (
                  (await this.cleanup(),
                  this.client.logger.error(
                    `sendResult() -> core.crypto.encode() for topic ${s} failed`
                  ),
                  e)
                );
              }
              try {
                let e = (r = await this.client.core.history.get(s, a)).request;
                try {
                  this.shouldSetTVF(e.method, e.params) && (i = this.getTVFParams(a, e.params, o));
                } catch (e) {
                  this.client.logger.warn('sendResult() -> getTVFParams() failed', e);
                }
              } catch (e) {
                throw (
                  (this.client.logger.error(`sendResult() -> history.get(${s}, ${a}) failed`), e)
                );
              }
              if (p) {
                let e = lU(c, s, t);
                await n.g.Linking.openURL(e, this.client.name);
              } else {
                let e = pI[r.request.method].res;
                (e.tvf = pq(pj({}, i), { correlationId: a })),
                  l
                    ? ((e.internal = pq(pj({}, e.internal), { throwOnFailedPublish: !0 })),
                      await this.client.core.relayer.publish(s, t, e))
                    : this.client.core.relayer
                        .publish(s, t, e)
                        .catch((e) => this.client.logger.error(e));
              }
              await this.client.core.history.resolve(d);
            }),
            pV(this, 'sendError', async (e) => {
              let t, r;
              let { id: i, topic: a, error: s, encodeOpts: o, rpcOpts: l, appLink: u } = e,
                c = ud(i, s),
                d = u && 'u' > typeof (null == n.g ? void 0 : n.g.Linking);
              try {
                let e = d ? lT : lv;
                t = await this.client.core.crypto.encode(
                  a,
                  c,
                  pq(pj({}, o || {}), { encoding: e })
                );
              } catch (e) {
                throw (
                  (await this.cleanup(),
                  this.client.logger.error(
                    `sendError() -> core.crypto.encode() for topic ${a} failed`
                  ),
                  e)
                );
              }
              try {
                r = await this.client.core.history.get(a, i);
              } catch (e) {
                throw (
                  (this.client.logger.error(`sendError() -> history.get(${a}, ${i}) failed`), e)
                );
              }
              if (d) {
                let e = lU(u, a, t);
                await n.g.Linking.openURL(e, this.client.name);
              } else {
                let e = r.request.method,
                  n = l || pI[e].res;
                this.client.core.relayer.publish(a, t, n);
              }
              await this.client.core.history.resolve(c);
            }),
            pV(this, 'cleanup', async () => {
              let e = [],
                t = [];
              this.client.session.getAll().forEach((t) => {
                let n = !1;
                aI(t.expiry) && (n = !0),
                  this.client.core.crypto.keychain.has(t.topic) || (n = !0),
                  n && e.push(t.topic);
              }),
                this.client.proposal.getAll().forEach((e) => {
                  aI(e.expiryTimestamp) && t.push(e.id);
                }),
                await Promise.all([
                  ...e.map((e) => this.deleteSession({ topic: e })),
                  ...t.map((e) => this.deleteProposal(e)),
                ]);
            }),
            pV(this, 'onProviderMessageEvent', async (e) => {
              !this.initialized || this.relayMessageCache.length > 0
                ? this.relayMessageCache.push(e)
                : await this.onRelayMessage(e);
            }),
            pV(this, 'onRelayEventRequest', async (e) => {
              this.requestQueue.queue.push(e), await this.processRequestsQueue();
            }),
            pV(this, 'processRequestsQueue', async () => {
              if (this.requestQueue.state === pP.active) {
                this.client.logger.info('Request queue already active, skipping...');
                return;
              }
              for (
                this.client.logger.info(
                  `Request queue starting with ${this.requestQueue.queue.length} requests`
                );
                this.requestQueue.queue.length > 0;

              ) {
                this.requestQueue.state = pP.active;
                let e = this.requestQueue.queue.shift();
                if (e)
                  try {
                    await this.processRequest(e);
                  } catch (e) {
                    this.client.logger.warn(e);
                  }
              }
              this.requestQueue.state = pP.idle;
            }),
            pV(this, 'processRequest', async (e) => {
              let { topic: t, payload: n, attestation: r, transportType: i, encryptedId: a } = e,
                s = n.method;
              if (!this.shouldIgnorePairingRequest({ topic: t, requestMethod: s }))
                switch (s) {
                  case 'wc_sessionPropose':
                    return await this.onSessionProposeRequest({
                      topic: t,
                      payload: n,
                      attestation: r,
                      encryptedId: a,
                    });
                  case 'wc_sessionSettle':
                    return await this.onSessionSettleRequest(t, n);
                  case 'wc_sessionUpdate':
                    return await this.onSessionUpdateRequest(t, n);
                  case 'wc_sessionExtend':
                    return await this.onSessionExtendRequest(t, n);
                  case 'wc_sessionPing':
                    return await this.onSessionPingRequest(t, n);
                  case 'wc_sessionDelete':
                    return await this.onSessionDeleteRequest(t, n);
                  case 'wc_sessionRequest':
                    return await this.onSessionRequest({
                      topic: t,
                      payload: n,
                      attestation: r,
                      encryptedId: a,
                      transportType: i,
                    });
                  case 'wc_sessionEvent':
                    return await this.onSessionEventRequest(t, n);
                  case 'wc_sessionAuthenticate':
                    return await this.onSessionAuthenticateRequest({
                      topic: t,
                      payload: n,
                      attestation: r,
                      encryptedId: a,
                      transportType: i,
                    });
                  default:
                    return this.client.logger.info(`Unsupported request method ${s}`);
                }
            }),
            pV(this, 'onRelayEventResponse', async (e) => {
              let { topic: t, payload: n, transportType: r } = e,
                i = (await this.client.core.history.get(t, n.id)).request.method;
              switch (i) {
                case 'wc_sessionPropose':
                  return this.onSessionProposeResponse(t, n, r);
                case 'wc_sessionSettle':
                  return this.onSessionSettleResponse(t, n);
                case 'wc_sessionUpdate':
                  return this.onSessionUpdateResponse(t, n);
                case 'wc_sessionExtend':
                  return this.onSessionExtendResponse(t, n);
                case 'wc_sessionPing':
                  return this.onSessionPingResponse(t, n);
                case 'wc_sessionRequest':
                  return this.onSessionRequestResponse(t, n);
                case 'wc_sessionAuthenticate':
                  return this.onSessionAuthenticateResponse(t, n);
                default:
                  return this.client.logger.info(`Unsupported response method ${i}`);
              }
            }),
            pV(this, 'onRelayEventUnknownPayload', (e) => {
              let { topic: t } = e,
                { message: n } = lz(
                  'MISSING_OR_INVALID',
                  `Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`
                );
              throw Error(n);
            }),
            pV(this, 'shouldIgnorePairingRequest', (e) => {
              let { topic: t, requestMethod: n } = e,
                r = this.expectedPairingMethodMap.get(t);
              return (
                !(!r || r.includes(n)) &&
                !!(
                  r.includes('wc_sessionAuthenticate') &&
                  this.client.events.listenerCount('session_authenticate') > 0
                )
              );
            }),
            pV(this, 'onSessionProposeRequest', async (e) => {
              let { topic: t, payload: n, attestation: r, encryptedId: i } = e,
                { params: a, id: s } = n;
              try {
                let e = this.client.core.eventClient.getEvent({ topic: t });
                0 === this.client.events.listenerCount('session_proposal') &&
                  (console.warn('No listener for session_proposal event'),
                  e?.setError(uX.proposal_listener_not_found)),
                  this.isValidConnect(pj({}, n.params));
                let o = a.expiryTimestamp || a_(pI.wc_sessionPropose.req.ttl),
                  l = pj({ id: s, pairingTopic: t, expiryTimestamp: o }, a);
                await this.setProposal(s, l);
                let u = await this.getVerifyContext({
                  attestationId: r,
                  hash: l_(JSON.stringify(n)),
                  encryptedId: i,
                  metadata: l.proposer.metadata,
                });
                e?.addTrace(uJ.emit_session_proposal),
                  this.client.events.emit('session_proposal', {
                    id: s,
                    params: l,
                    verifyContext: u,
                  });
              } catch (e) {
                await this.sendError({
                  id: s,
                  topic: t,
                  error: e,
                  rpcOpts: pI.wc_sessionPropose.autoReject,
                }),
                  this.client.logger.error(e);
              }
            }),
            pV(this, 'onSessionProposeResponse', async (e, t, n) => {
              let { id: r } = t;
              if (uT(t)) {
                let { result: i } = t;
                this.client.logger.trace({
                  type: 'method',
                  method: 'onSessionProposeResponse',
                  result: i,
                });
                let a = this.client.proposal.get(r);
                this.client.logger.trace({
                  type: 'method',
                  method: 'onSessionProposeResponse',
                  proposal: a,
                });
                let s = a.proposer.publicKey;
                this.client.logger.trace({
                  type: 'method',
                  method: 'onSessionProposeResponse',
                  selfPublicKey: s,
                });
                let o = i.responderPublicKey;
                this.client.logger.trace({
                  type: 'method',
                  method: 'onSessionProposeResponse',
                  peerPublicKey: o,
                });
                let l = await this.client.core.crypto.generateSharedKey(s, o);
                this.pendingSessions.set(r, {
                  sessionTopic: l,
                  pairingTopic: e,
                  proposalId: r,
                  publicKey: s,
                });
                let u = await this.client.core.relayer.subscribe(l, { transportType: n });
                this.client.logger.trace({
                  type: 'method',
                  method: 'onSessionProposeResponse',
                  subscriptionId: u,
                }),
                  await this.client.core.pairing.activate({ topic: e });
              } else if (uA(t)) {
                await this.client.proposal.delete(r, lW('USER_DISCONNECTED'));
                let e = aS('session_connect', r);
                if (0 === this.events.listenerCount(e))
                  throw Error(`emitting ${e} without any listeners, 954`);
                this.events.emit(e, { error: t.error });
              }
            }),
            pV(this, 'onSessionSettleRequest', async (e, t) => {
              let { id: n, params: r } = t;
              try {
                this.isValidSessionSettleRequest(r);
                let {
                    relay: n,
                    controller: i,
                    expiry: a,
                    namespaces: s,
                    sessionProperties: o,
                    scopedProperties: l,
                    sessionConfig: u,
                  } = t.params,
                  c = [...this.pendingSessions.values()].find((t) => t.sessionTopic === e);
                if (!c) return this.client.logger.error(`Pending session not found for topic ${e}`);
                let d = this.client.proposal.get(c.proposalId),
                  p = pq(
                    pj(
                      pj(
                        pj(
                          {
                            topic: e,
                            relay: n,
                            expiry: a,
                            namespaces: s,
                            acknowledged: !0,
                            pairingTopic: c.pairingTopic,
                            requiredNamespaces: d.requiredNamespaces,
                            optionalNamespaces: d.optionalNamespaces,
                            controller: i.publicKey,
                            self: { publicKey: c.publicKey, metadata: this.client.metadata },
                            peer: { publicKey: i.publicKey, metadata: i.metadata },
                          },
                          o && { sessionProperties: o }
                        ),
                        l && { scopedProperties: l }
                      ),
                      u && { sessionConfig: u }
                    ),
                    { transportType: uq.relay }
                  );
                await this.client.session.set(p.topic, p),
                  await this.setExpiry(p.topic, p.expiry),
                  await this.client.core.pairing.updateMetadata({
                    topic: c.pairingTopic,
                    metadata: p.peer.metadata,
                  }),
                  this.client.events.emit('session_connect', { session: p }),
                  this.events.emit(aS('session_connect', c.proposalId), { session: p }),
                  this.pendingSessions.delete(c.proposalId),
                  this.deleteProposal(c.proposalId, !1),
                  this.cleanupDuplicatePairings(p),
                  await this.sendResult({
                    id: t.id,
                    topic: e,
                    result: !0,
                    throwOnFailedPublish: !0,
                  });
              } catch (t) {
                await this.sendError({ id: n, topic: e, error: t }), this.client.logger.error(t);
              }
            }),
            pV(this, 'onSessionSettleResponse', async (e, t) => {
              let { id: n } = t;
              uT(t)
                ? (await this.client.session.update(e, { acknowledged: !0 }),
                  this.events.emit(aS('session_approve', n), {}))
                : uA(t) &&
                  (await this.client.session.delete(e, lW('USER_DISCONNECTED')),
                  this.events.emit(aS('session_approve', n), { error: t.error }));
            }),
            pV(this, 'onSessionUpdateRequest', async (e, t) => {
              let { params: n, id: r } = t;
              try {
                let t = `${e}_session_update`,
                  i = l7.get(t);
                if (i && this.isRequestOutOfSync(i, r)) {
                  this.client.logger.warn(`Discarding out of sync request - ${r}`),
                    this.sendError({ id: r, topic: e, error: lW('INVALID_UPDATE_REQUEST') });
                  return;
                }
                this.isValidUpdate(pj({ topic: e }, n));
                try {
                  l7.set(t, r),
                    await this.client.session.update(e, { namespaces: n.namespaces }),
                    await this.sendResult({
                      id: r,
                      topic: e,
                      result: !0,
                      throwOnFailedPublish: !0,
                    });
                } catch (e) {
                  throw (l7.delete(t), e);
                }
                this.client.events.emit('session_update', { id: r, topic: e, params: n });
              } catch (t) {
                await this.sendError({ id: r, topic: e, error: t }), this.client.logger.error(t);
              }
            }),
            pV(
              this,
              'isRequestOutOfSync',
              (e, t) => t.toString().slice(0, -3) < e.toString().slice(0, -3)
            ),
            pV(this, 'onSessionUpdateResponse', (e, t) => {
              let { id: n } = t,
                r = aS('session_update', n);
              if (0 === this.events.listenerCount(r))
                throw Error(`emitting ${r} without any listeners`);
              uT(t)
                ? this.events.emit(aS('session_update', n), {})
                : uA(t) && this.events.emit(aS('session_update', n), { error: t.error });
            }),
            pV(this, 'onSessionExtendRequest', async (e, t) => {
              let { id: n } = t;
              try {
                this.isValidExtend({ topic: e }),
                  await this.setExpiry(e, a_(p_)),
                  await this.sendResult({ id: n, topic: e, result: !0, throwOnFailedPublish: !0 }),
                  this.client.events.emit('session_extend', { id: n, topic: e });
              } catch (t) {
                await this.sendError({ id: n, topic: e, error: t }), this.client.logger.error(t);
              }
            }),
            pV(this, 'onSessionExtendResponse', (e, t) => {
              let { id: n } = t,
                r = aS('session_extend', n);
              if (0 === this.events.listenerCount(r))
                throw Error(`emitting ${r} without any listeners`);
              uT(t)
                ? this.events.emit(aS('session_extend', n), {})
                : uA(t) && this.events.emit(aS('session_extend', n), { error: t.error });
            }),
            pV(this, 'onSessionPingRequest', async (e, t) => {
              let { id: n } = t;
              try {
                this.isValidPing({ topic: e }),
                  await this.sendResult({ id: n, topic: e, result: !0, throwOnFailedPublish: !0 }),
                  this.client.events.emit('session_ping', { id: n, topic: e });
              } catch (t) {
                await this.sendError({ id: n, topic: e, error: t }), this.client.logger.error(t);
              }
            }),
            pV(this, 'onSessionPingResponse', (e, t) => {
              let { id: n } = t,
                r = aS('session_ping', n);
              setTimeout(() => {
                if (0 === this.events.listenerCount(r))
                  throw Error(`emitting ${r} without any listeners 2176`);
                uT(t)
                  ? this.events.emit(aS('session_ping', n), {})
                  : uA(t) && this.events.emit(aS('session_ping', n), { error: t.error });
              }, 500);
            }),
            pV(this, 'onSessionDeleteRequest', async (e, t) => {
              let { id: n } = t;
              try {
                this.isValidDisconnect({ topic: e, reason: t.params }),
                  Promise.all([
                    new Promise((t) => {
                      this.client.core.relayer.once(uL.publish, async () => {
                        t(await this.deleteSession({ topic: e, id: n }));
                      });
                    }),
                    this.sendResult({ id: n, topic: e, result: !0, throwOnFailedPublish: !0 }),
                    this.cleanupPendingSentRequestsForTopic({
                      topic: e,
                      error: lW('USER_DISCONNECTED'),
                    }),
                  ]).catch((e) => this.client.logger.error(e));
              } catch (e) {
                this.client.logger.error(e);
              }
            }),
            pV(this, 'onSessionRequest', async (e) => {
              var t, n, r;
              let { topic: i, payload: a, attestation: s, encryptedId: o, transportType: l } = e,
                { id: u, params: c } = a;
              try {
                await this.isValidRequest(pj({ topic: i }, c));
                let e = this.client.session.get(i),
                  a = await this.getVerifyContext({
                    attestationId: s,
                    hash: l_(JSON.stringify(uu('wc_sessionRequest', c, u))),
                    encryptedId: o,
                    metadata: e.peer.metadata,
                    transportType: l,
                  }),
                  d = { id: u, topic: i, params: c, verifyContext: a };
                await this.setPendingSessionRequest(d),
                  l === uq.link_mode &&
                    null != (t = e.peer.metadata.redirect) &&
                    t.universal &&
                    this.client.core.addLinkModeSupportedApp(
                      null == (n = e.peer.metadata.redirect) ? void 0 : n.universal
                    ),
                  null != (r = this.client.signConfig) && r.disableRequestQueue
                    ? this.emitSessionRequest(d)
                    : (this.addSessionRequestToSessionRequestQueue(d),
                      this.processSessionRequestQueue());
              } catch (e) {
                await this.sendError({ id: u, topic: i, error: e }), this.client.logger.error(e);
              }
            }),
            pV(this, 'onSessionRequestResponse', (e, t) => {
              let { id: n } = t,
                r = aS('session_request', n);
              if (0 === this.events.listenerCount(r))
                throw Error(`emitting ${r} without any listeners`);
              uT(t)
                ? this.events.emit(aS('session_request', n), { result: t.result })
                : uA(t) && this.events.emit(aS('session_request', n), { error: t.error });
            }),
            pV(this, 'onSessionEventRequest', async (e, t) => {
              let { id: n, params: r } = t;
              try {
                let t = `${e}_session_event_${r.event.name}`,
                  i = l7.get(t);
                if (i && this.isRequestOutOfSync(i, n)) {
                  this.client.logger.info(`Discarding out of sync request - ${n}`);
                  return;
                }
                this.isValidEmit(pj({ topic: e }, r)),
                  this.client.events.emit('session_event', { id: n, topic: e, params: r }),
                  l7.set(t, n);
              } catch (t) {
                await this.sendError({ id: n, topic: e, error: t }), this.client.logger.error(t);
              }
            }),
            pV(this, 'onSessionAuthenticateResponse', (e, t) => {
              let { id: n } = t;
              this.client.logger.trace({
                type: 'method',
                method: 'onSessionAuthenticateResponse',
                topic: e,
                payload: t,
              }),
                uT(t)
                  ? this.events.emit(aS('session_request', n), { result: t.result })
                  : uA(t) && this.events.emit(aS('session_request', n), { error: t.error });
            }),
            pV(this, 'onSessionAuthenticateRequest', async (e) => {
              var t;
              let { topic: n, payload: r, attestation: i, encryptedId: a, transportType: s } = e;
              try {
                let { requester: e, authPayload: o, expiryTimestamp: l } = r.params,
                  u = await this.getVerifyContext({
                    attestationId: i,
                    hash: l_(JSON.stringify(r)),
                    encryptedId: a,
                    metadata: e.metadata,
                    transportType: s,
                  }),
                  c = {
                    requester: e,
                    pairingTopic: n,
                    id: r.id,
                    authPayload: o,
                    verifyContext: u,
                    expiryTimestamp: l,
                  };
                await this.setAuthRequest(r.id, { request: c, pairingTopic: n, transportType: s }),
                  s === uq.link_mode &&
                    null != (t = e.metadata.redirect) &&
                    t.universal &&
                    this.client.core.addLinkModeSupportedApp(e.metadata.redirect.universal),
                  this.client.events.emit('session_authenticate', {
                    topic: n,
                    params: r.params,
                    id: r.id,
                    verifyContext: u,
                  });
              } catch (a) {
                this.client.logger.error(a);
                let e = r.params.requester.publicKey,
                  t = await this.client.core.crypto.generateKeyPair(),
                  i = this.getAppLinkIfEnabled(r.params.requester.metadata, s);
                await this.sendError({
                  id: r.id,
                  topic: n,
                  error: a,
                  encodeOpts: { type: 1, receiverPublicKey: e, senderPublicKey: t },
                  rpcOpts: pI.wc_sessionAuthenticate.autoReject,
                  appLink: i,
                });
              }
            }),
            pV(this, 'addSessionRequestToSessionRequestQueue', (e) => {
              this.sessionRequestQueue.queue.push(e);
            }),
            pV(this, 'cleanupAfterResponse', (e) => {
              this.deletePendingSessionRequest(e.response.id, { message: 'fulfilled', code: 0 }),
                setTimeout(
                  () => {
                    (this.sessionRequestQueue.state = pP.idle), this.processSessionRequestQueue();
                  },
                  (0, v.toMiliseconds)(this.requestQueueDelay)
                );
            }),
            pV(this, 'cleanupPendingSentRequestsForTopic', ({ topic: e, error: t }) => {
              let n = this.client.core.history.pending;
              n.length > 0 &&
                n
                  .filter((t) => t.topic === e && 'wc_sessionRequest' === t.request.method)
                  .forEach((e) => {
                    let n = aS('session_request', e.request.id);
                    if (0 === this.events.listenerCount(n))
                      throw Error(`emitting ${n} without any listeners`);
                    this.events.emit(aS('session_request', e.request.id), { error: t });
                  });
            }),
            pV(this, 'processSessionRequestQueue', () => {
              if (this.sessionRequestQueue.state === pP.active) {
                this.client.logger.info('session request queue is already active.');
                return;
              }
              let e = this.sessionRequestQueue.queue[0];
              if (!e) {
                this.client.logger.info('session request queue is empty.');
                return;
              }
              try {
                (this.sessionRequestQueue.state = pP.active), this.emitSessionRequest(e);
              } catch (e) {
                this.client.logger.error(e);
              }
            }),
            pV(this, 'emitSessionRequest', (e) => {
              this.client.events.emit('session_request', e);
            }),
            pV(this, 'onPairingCreated', (e) => {
              if ((e.methods && this.expectedPairingMethodMap.set(e.topic, e.methods), e.active))
                return;
              let t = this.client.proposal.getAll().find((t) => t.pairingTopic === e.topic);
              t &&
                this.onSessionProposeRequest({
                  topic: e.topic,
                  payload: uu(
                    'wc_sessionPropose',
                    pq(pj({}, t), {
                      requiredNamespaces: t.requiredNamespaces,
                      optionalNamespaces: t.optionalNamespaces,
                      relays: t.relays,
                      proposer: t.proposer,
                      sessionProperties: t.sessionProperties,
                      scopedProperties: t.scopedProperties,
                    }),
                    t.id
                  ),
                });
            }),
            pV(this, 'isValidConnect', async (e) => {
              let t;
              if (!l2(e)) {
                let { message: t } = lz(
                  'MISSING_OR_INVALID',
                  `connect() params: ${JSON.stringify(e)}`
                );
                throw Error(t);
              }
              let {
                pairingTopic: n,
                requiredNamespaces: r,
                optionalNamespaces: i,
                sessionProperties: a,
                scopedProperties: s,
                relays: o,
              } = e;
              if (
                (lK(n) || (await this.isValidPairingTopic(n)),
                (t = !1),
                o
                  ? o &&
                    lH(o) &&
                    o.length &&
                    o.forEach((e) => {
                      t = l1(e);
                    })
                  : (t = !0),
                !t)
              ) {
                let { message: e } = lz('MISSING_OR_INVALID', `connect() relays: ${o}`);
                throw Error(e);
              }
              if (
                (lK(r) || 0 === lG(r) || this.validateNamespaces(r, 'requiredNamespaces'),
                lK(i) || 0 === lG(i) || this.validateNamespaces(i, 'optionalNamespaces'),
                lK(a) || this.validateSessionProps(a, 'sessionProperties'),
                !lK(s))
              ) {
                this.validateSessionProps(s, 'scopedProperties');
                let e = Object.keys(r || {}).concat(Object.keys(i || {}));
                if (!Object.keys(s).every((t) => e.includes(t)))
                  throw Error(
                    `Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(s)}, required/optional namespaces: ${JSON.stringify(e)}`
                  );
              }
            }),
            pV(this, 'validateNamespaces', (e, t) => {
              let n = (function (e, t, n) {
                let r = null;
                if (e && lG(e)) {
                  let i;
                  let a = lX(e, t);
                  a && (r = a);
                  let s =
                    ((i = null),
                    Object.entries(e).forEach(([e, r]) => {
                      var a, s;
                      let o;
                      if (i) return;
                      let l =
                        ((a = ae(e, r)),
                        (s = `${t} ${n}`),
                        (o = null),
                        lH(a) && a.length
                          ? a.forEach((e) => {
                              o ||
                                lZ(e) ||
                                (o = lW(
                                  'UNSUPPORTED_CHAINS',
                                  `${s}, chain ${e} should be a string and conform to "namespace:chainId" format`
                                ));
                            })
                          : lZ(e) ||
                            (o = lW(
                              'UNSUPPORTED_CHAINS',
                              `${s}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`
                            )),
                        o);
                      l && (i = l);
                    }),
                    i);
                  s && (r = s);
                } else r = lz('MISSING_OR_INVALID', `${t}, ${n} should be an object with data`);
                return r;
              })(e, 'connect()', t);
              if (n) throw Error(n.message);
            }),
            pV(this, 'isValidApprove', async (e) => {
              if (!l2(e)) throw Error(lz('MISSING_OR_INVALID', `approve() params: ${e}`).message);
              let {
                id: t,
                namespaces: n,
                relayProtocol: r,
                sessionProperties: i,
                scopedProperties: a,
              } = e;
              this.checkRecentlyDeleted(t), await this.isValidProposalId(t);
              let s = this.client.proposal.get(t),
                o = l0(n, 'approve()');
              if (o) throw Error(o.message);
              let l = l5(s.requiredNamespaces, n, 'approve()');
              if (l) throw Error(l.message);
              if (!lQ(r, !0)) {
                let { message: e } = lz('MISSING_OR_INVALID', `approve() relayProtocol: ${r}`);
                throw Error(e);
              }
              if ((lK(i) || this.validateSessionProps(i, 'sessionProperties'), !lK(a))) {
                this.validateSessionProps(a, 'scopedProperties');
                let e = new Set(Object.keys(n));
                if (!Object.keys(a).every((t) => e.has(t)))
                  throw Error(
                    `Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(a)}, approved namespaces: ${Array.from(e).join(', ')}`
                  );
              }
            }),
            pV(this, 'isValidReject', async (e) => {
              if (!l2(e)) {
                let { message: t } = lz('MISSING_OR_INVALID', `reject() params: ${e}`);
                throw Error(t);
              }
              let { id: t, reason: n } = e;
              if (
                (this.checkRecentlyDeleted(t),
                await this.isValidProposalId(t),
                !n ||
                  'object' != typeof n ||
                  !n.code ||
                  !lY(n.code, !1) ||
                  !n.message ||
                  !lQ(n.message, !1))
              ) {
                let { message: e } = lz(
                  'MISSING_OR_INVALID',
                  `reject() reason: ${JSON.stringify(n)}`
                );
                throw Error(e);
              }
            }),
            pV(this, 'isValidSessionSettleRequest', (e) => {
              let t;
              if (!l2(e)) {
                let { message: t } = lz(
                  'MISSING_OR_INVALID',
                  `onSessionSettleRequest() params: ${e}`
                );
                throw Error(t);
              }
              let { relay: n, controller: r, namespaces: i, expiry: a } = e;
              if (!l1(n)) {
                let { message: e } = lz(
                  'MISSING_OR_INVALID',
                  'onSessionSettleRequest() relay protocol should be a string'
                );
                throw Error(e);
              }
              let s =
                ((t = null),
                lQ(r?.publicKey, !1) ||
                  (t = lz(
                    'MISSING_OR_INVALID',
                    'onSessionSettleRequest() controller public key should be a string'
                  )),
                t);
              if (s) throw Error(s.message);
              let o = l0(i, 'onSessionSettleRequest()');
              if (o) throw Error(o.message);
              if (aI(a)) {
                let { message: e } = lz('EXPIRED', 'onSessionSettleRequest()');
                throw Error(e);
              }
            }),
            pV(this, 'isValidUpdate', async (e) => {
              if (!l2(e)) {
                let { message: t } = lz('MISSING_OR_INVALID', `update() params: ${e}`);
                throw Error(t);
              }
              let { topic: t, namespaces: n } = e;
              this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
              let r = this.client.session.get(t),
                i = l0(n, 'update()');
              if (i) throw Error(i.message);
              let a = l5(r.requiredNamespaces, n, 'update()');
              if (a) throw Error(a.message);
            }),
            pV(this, 'isValidExtend', async (e) => {
              if (!l2(e)) {
                let { message: t } = lz('MISSING_OR_INVALID', `extend() params: ${e}`);
                throw Error(t);
              }
              let { topic: t } = e;
              this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
            }),
            pV(this, 'isValidRequest', async (e) => {
              var t;
              if (!l2(e)) {
                let { message: t } = lz('MISSING_OR_INVALID', `request() params: ${e}`);
                throw Error(t);
              }
              let { topic: n, request: r, chainId: i, expiry: a } = e;
              this.checkRecentlyDeleted(n), await this.isValidSessionTopic(n);
              let { namespaces: s } = this.client.session.get(n);
              if (!l6(s, i)) {
                let { message: e } = lz('MISSING_OR_INVALID', `request() chainId: ${i}`);
                throw Error(e);
              }
              if (lK(r) || !lQ(r.method, !1)) {
                let { message: e } = lz('MISSING_OR_INVALID', `request() ${JSON.stringify(r)}`);
                throw Error(e);
              }
              if (
                !(
                  lQ((t = r.method), !1) &&
                  (function (e, t) {
                    let n = [];
                    return (
                      Object.values(e).forEach((e) => {
                        lL(e.accounts).includes(t) && n.push(...e.methods);
                      }),
                      n
                    );
                  })(s, i).includes(t)
                )
              ) {
                let { message: e } = lz('MISSING_OR_INVALID', `request() method: ${r.method}`);
                throw Error(e);
              }
              if (a && (!lY(a, !1) || !(a <= pS.max) || !(a >= pS.min))) {
                let { message: e } = lz(
                  'MISSING_OR_INVALID',
                  `request() expiry: ${a}. Expiry must be a number (in seconds) between ${pS.min} and ${pS.max}`
                );
                throw Error(e);
              }
            }),
            pV(this, 'isValidRespond', async (e) => {
              var t;
              if (!l2(e)) {
                let { message: t } = lz('MISSING_OR_INVALID', `respond() params: ${e}`);
                throw Error(t);
              }
              let { topic: n, response: r } = e;
              try {
                await this.isValidSessionTopic(n);
              } catch (n) {
                throw (null != (t = e?.response) && t.id && this.cleanupAfterResponse(e), n);
              }
              if (lK(r) || (lK(r.result) && lK(r.error)) || !lY(r.id, !1) || !lQ(r.jsonrpc, !1)) {
                let { message: e } = lz(
                  'MISSING_OR_INVALID',
                  `respond() response: ${JSON.stringify(r)}`
                );
                throw Error(e);
              }
            }),
            pV(this, 'isValidPing', async (e) => {
              if (!l2(e)) {
                let { message: t } = lz('MISSING_OR_INVALID', `ping() params: ${e}`);
                throw Error(t);
              }
              let { topic: t } = e;
              await this.isValidSessionOrPairingTopic(t);
            }),
            pV(this, 'isValidEmit', async (e) => {
              var t;
              if (!l2(e)) {
                let { message: t } = lz('MISSING_OR_INVALID', `emit() params: ${e}`);
                throw Error(t);
              }
              let { topic: n, event: r, chainId: i } = e;
              await this.isValidSessionTopic(n);
              let { namespaces: a } = this.client.session.get(n);
              if (!l6(a, i)) {
                let { message: e } = lz('MISSING_OR_INVALID', `emit() chainId: ${i}`);
                throw Error(e);
              }
              if (lK(r) || !lQ(r.name, !1)) {
                let { message: e } = lz('MISSING_OR_INVALID', `emit() event: ${JSON.stringify(r)}`);
                throw Error(e);
              }
              if (
                !(
                  lQ((t = r.name), !1) &&
                  (function (e, t) {
                    let n = [];
                    return (
                      Object.values(e).forEach((e) => {
                        lL(e.accounts).includes(t) && n.push(...e.events);
                      }),
                      n
                    );
                  })(a, i).includes(t)
                )
              ) {
                let { message: e } = lz('MISSING_OR_INVALID', `emit() event: ${JSON.stringify(r)}`);
                throw Error(e);
              }
            }),
            pV(this, 'isValidDisconnect', async (e) => {
              if (!l2(e)) {
                let { message: t } = lz('MISSING_OR_INVALID', `disconnect() params: ${e}`);
                throw Error(t);
              }
              let { topic: t } = e;
              await this.isValidSessionOrPairingTopic(t);
            }),
            pV(this, 'isValidAuthenticate', (e) => {
              let { chains: t, uri: n, domain: r, nonce: i } = e;
              if (!Array.isArray(t) || 0 === t.length)
                throw Error('chains is required and must be a non-empty array');
              if (!lQ(n, !1)) throw Error('uri is required parameter');
              if (!lQ(r, !1)) throw Error('domain is required parameter');
              if (!lQ(i, !1)) throw Error('nonce is required parameter');
              if ([...new Set(t.map((e) => i7(e).namespace))].length > 1)
                throw Error(
                  'Multi-namespace requests are not supported. Please request single namespace only.'
                );
              let { namespace: a } = i7(t[0]);
              if ('eip155' !== a)
                throw Error(
                  'Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.'
                );
            }),
            pV(this, 'getVerifyContext', async (e) => {
              let { attestationId: t, hash: n, encryptedId: r, metadata: i, transportType: a } = e,
                s = {
                  verified: {
                    verifyUrl: i.verifyUrl || uQ,
                    validation: 'UNKNOWN',
                    origin: i.url || '',
                  },
                };
              try {
                if (a === uq.link_mode) {
                  let e = this.getAppLinkIfEnabled(i, a);
                  return (
                    (s.verified.validation =
                      e && new URL(e).origin === new URL(i.url).origin ? 'VALID' : 'INVALID'),
                    s
                  );
                }
                let e = await this.client.core.verify.resolve({
                  attestationId: t,
                  hash: n,
                  encryptedId: r,
                  verifyUrl: i.verifyUrl,
                });
                e &&
                  ((s.verified.origin = e.origin),
                  (s.verified.isScam = e.isScam),
                  (s.verified.validation =
                    e.origin === new URL(i.url).origin ? 'VALID' : 'INVALID'));
              } catch (e) {
                this.client.logger.warn(e);
              }
              return this.client.logger.debug(`Verify context: ${JSON.stringify(s)}`), s;
            }),
            pV(this, 'validateSessionProps', (e, t) => {
              Object.values(e).forEach((n, r) => {
                if (null == n) {
                  let { message: i } = lz(
                    'MISSING_OR_INVALID',
                    `${t} must contain an existing value for each key. Received: ${n} for key ${Object.keys(e)[r]}`
                  );
                  throw Error(i);
                }
              });
            }),
            pV(this, 'getPendingAuthRequest', (e) => {
              let t = this.client.auth.requests.get(e);
              return 'object' == typeof t ? t : void 0;
            }),
            pV(this, 'addToRecentlyDeleted', (e, t) => {
              if (
                (this.recentlyDeletedMap.set(e, t),
                this.recentlyDeletedMap.size >= this.recentlyDeletedLimit)
              ) {
                let e = 0,
                  t = this.recentlyDeletedLimit / 2;
                for (let n of this.recentlyDeletedMap.keys()) {
                  if (e++ >= t) break;
                  this.recentlyDeletedMap.delete(n);
                }
              }
            }),
            pV(this, 'checkRecentlyDeleted', (e) => {
              let t = this.recentlyDeletedMap.get(e);
              if (t) {
                let { message: n } = lz(
                  'MISSING_OR_INVALID',
                  `Record was recently deleted - ${t}: ${e}`
                );
                throw Error(n);
              }
            }),
            pV(this, 'isLinkModeEnabled', (e, t) => {
              var r, i, a, s, o, l, u, c, d;
              return (
                !!e &&
                t === uq.link_mode &&
                (null == (i = null == (r = this.client.metadata) ? void 0 : r.redirect)
                  ? void 0
                  : i.linkMode) === !0 &&
                (null == (s = null == (a = this.client.metadata) ? void 0 : a.redirect)
                  ? void 0
                  : s.universal) !== void 0 &&
                (null == (l = null == (o = this.client.metadata) ? void 0 : o.redirect)
                  ? void 0
                  : l.universal) !== '' &&
                (null == (u = e?.redirect) ? void 0 : u.universal) !== void 0 &&
                (null == (c = e?.redirect) ? void 0 : c.universal) !== '' &&
                (null == (d = e?.redirect) ? void 0 : d.linkMode) === !0 &&
                this.client.core.linkModeSupportedApps.includes(e.redirect.universal) &&
                'u' > typeof (null == n.g ? void 0 : n.g.Linking)
              );
            }),
            pV(this, 'getAppLinkIfEnabled', (e, t) => {
              var n;
              return this.isLinkModeEnabled(e, t)
                ? null == (n = e?.redirect)
                  ? void 0
                  : n.universal
                : void 0;
            }),
            pV(this, 'handleLinkModeMessage', ({ url: e }) => {
              if (!e || !e.includes('wc_ev') || !e.includes('topic')) return;
              let t = ax(e, 'topic') || '',
                n = decodeURIComponent(ax(e, 'wc_ev') || ''),
                r = this.client.session.keys.includes(t);
              r && this.client.session.update(t, { transportType: uq.link_mode }),
                this.client.core.dispatchEnvelope({ topic: t, message: n, sessionExists: r });
            }),
            pV(this, 'registerLinkModeListeners', async () => {
              var e;
              if (ak() || (ap() && null != (e = this.client.metadata.redirect) && e.linkMode)) {
                let e = null == n.g ? void 0 : n.g.Linking;
                if ('u' > typeof e) {
                  e.addEventListener('url', this.handleLinkModeMessage, this.client.name);
                  let t = await e.getInitialURL();
                  t &&
                    setTimeout(() => {
                      this.handleLinkModeMessage({ url: t });
                    }, 50);
                }
              }
            }),
            pV(this, 'shouldSetTVF', (e, t) => {
              if (!t || 'wc_sessionRequest' !== e) return !1;
              let { request: n } = t;
              return Object.keys(pO).includes(n.method);
            }),
            pV(this, 'getTVFParams', (e, t, n) => {
              var r, i;
              try {
                let a = t.request.method,
                  s = this.extractTxHashesFromResult(a, n);
                return pq(
                  pj(
                    { correlationId: e, rpcMethods: [a], chainId: t.chainId },
                    this.isValidContractData(t.request.params) && {
                      contractAddresses: [
                        null == (i = null == (r = t.request.params) ? void 0 : r[0])
                          ? void 0
                          : i.to,
                      ],
                    }
                  ),
                  { txHashes: s }
                );
              } catch (e) {
                this.client.logger.warn('Error getting TVF params', e);
              }
              return {};
            }),
            pV(this, 'isValidContractData', (e) => {
              var t;
              if (!e) return !1;
              try {
                let n = e?.data || (null == (t = e?.[0]) ? void 0 : t.data);
                if (!n.startsWith('0x')) return !1;
                let r = n.slice(2);
                return !!/^[0-9a-fA-F]*$/.test(r) && r.length % 2 == 0;
              } catch {}
              return !1;
            }),
            pV(this, 'extractTxHashesFromResult', (e, t) => {
              try {
                let n = pO[e];
                if ('string' == typeof t) return [t];
                let r = t[n.key];
                if (lH(r))
                  return 'solana_signAllTransactions' === e
                    ? r.map((e) =>
                        (function (e) {
                          let t = atob(e),
                            n = new Uint8Array(t.length);
                          for (let e = 0; e < t.length; e++) n[e] = t.charCodeAt(e);
                          let r = n[0];
                          if (0 === r) throw Error('No signatures found');
                          if (n.length < 1 + 64 * r)
                            throw Error('Transaction data too short for claimed signature count');
                          if (n.length < 100) throw Error('Transaction too short');
                          let i = i9.from(e, 'base64').slice(1, 65);
                          return rk.Z.encode(i);
                        })(e)
                      )
                    : r;
                if ('string' == typeof r) return [r];
              } catch (e) {
                this.client.logger.warn('Error extracting tx hashes from result', e);
              }
              return [];
            });
        }
        async processPendingMessageEvents() {
          try {
            let e = this.client.session.keys,
              t = this.client.core.relayer.messages.getWithoutAck(e);
            for (let [e, n] of Object.entries(t))
              for (let t of n)
                try {
                  await this.onProviderMessageEvent({
                    topic: e,
                    message: t,
                    publishedAt: Date.now(),
                  });
                } catch {
                  this.client.logger.warn(
                    `Error processing pending message event for topic: ${e}, message: ${t}`
                  );
                }
          } catch (e) {
            this.client.logger.warn('processPendingMessageEvents failed', e);
          }
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = lz('NOT_INITIALIZED', this.name);
            throw Error(e);
          }
        }
        async confirmOnlineStateOrThrow() {
          await this.client.core.relayer.confirmOnlineStateOrThrow();
        }
        registerRelayerEvents() {
          this.client.core.relayer.on(uL.message, (e) => {
            this.onProviderMessageEvent(e);
          });
        }
        async onRelayMessage(e) {
          let { topic: t, message: n, attestation: r, transportType: i } = e,
            { publicKey: a } = this.client.auth.authKeys.keys.includes(pM)
              ? this.client.auth.authKeys.get(pM)
              : { responseTopic: void 0, publicKey: void 0 };
          try {
            let e = await this.client.core.crypto.decode(t, n, {
              receiverPublicKey: a,
              encoding: i === uq.link_mode ? lT : lv,
            });
            uw(e)
              ? (this.client.core.history.set(t, e),
                await this.onRelayEventRequest({
                  topic: t,
                  payload: e,
                  attestation: r,
                  transportType: i,
                  encryptedId: l_(n),
                }))
              : uv(e)
                ? (await this.client.core.history.resolve(e),
                  await this.onRelayEventResponse({ topic: t, payload: e, transportType: i }),
                  this.client.core.history.delete(t, e.id))
                : await this.onRelayEventUnknownPayload({ topic: t, payload: e, transportType: i }),
              await this.client.core.relayer.messages.ack(t, n);
          } catch (e) {
            this.client.logger.error(e);
          }
        }
        registerExpirerEvents() {
          this.client.core.expirer.on(uK.expired, async (e) => {
            let { topic: t, id: n } = aC(e.target);
            return n && this.client.pendingRequest.keys.includes(n)
              ? await this.deletePendingSessionRequest(n, lz('EXPIRED'), !0)
              : n && this.client.auth.requests.keys.includes(n)
                ? await this.deletePendingAuthRequest(n, lz('EXPIRED'), !0)
                : void (t
                    ? this.client.session.keys.includes(t) &&
                      (await this.deleteSession({ topic: t, expirerHasDeleted: !0 }),
                      this.client.events.emit('session_expire', { topic: t }))
                    : n &&
                      (await this.deleteProposal(n, !0),
                      this.client.events.emit('proposal_expire', { id: n })));
          });
        }
        registerPairingEvents() {
          this.client.core.pairing.events.on(uH.create, (e) => this.onPairingCreated(e)),
            this.client.core.pairing.events.on(uH.delete, (e) => {
              this.addToRecentlyDeleted(e.topic, 'pairing');
            });
        }
        isValidPairingTopic(e) {
          if (!lQ(e, !1)) {
            let { message: t } = lz('MISSING_OR_INVALID', `pairing topic should be a string: ${e}`);
            throw Error(t);
          }
          if (!this.client.core.pairing.pairings.keys.includes(e)) {
            let { message: t } = lz('NO_MATCHING_KEY', `pairing topic doesn't exist: ${e}`);
            throw Error(t);
          }
          if (aI(this.client.core.pairing.pairings.get(e).expiry)) {
            let { message: t } = lz('EXPIRED', `pairing topic: ${e}`);
            throw Error(t);
          }
        }
        async isValidSessionTopic(e) {
          if (!lQ(e, !1)) {
            let { message: t } = lz('MISSING_OR_INVALID', `session topic should be a string: ${e}`);
            throw Error(t);
          }
          if ((this.checkRecentlyDeleted(e), !this.client.session.keys.includes(e))) {
            let { message: t } = lz('NO_MATCHING_KEY', `session topic doesn't exist: ${e}`);
            throw Error(t);
          }
          if (aI(this.client.session.get(e).expiry)) {
            await this.deleteSession({ topic: e });
            let { message: t } = lz('EXPIRED', `session topic: ${e}`);
            throw Error(t);
          }
          if (!this.client.core.crypto.keychain.has(e)) {
            let { message: t } = lz(
              'MISSING_OR_INVALID',
              `session topic does not exist in keychain: ${e}`
            );
            throw (await this.deleteSession({ topic: e }), Error(t));
          }
        }
        async isValidSessionOrPairingTopic(e) {
          if ((this.checkRecentlyDeleted(e), this.client.session.keys.includes(e)))
            await this.isValidSessionTopic(e);
          else if (this.client.core.pairing.pairings.keys.includes(e)) this.isValidPairingTopic(e);
          else if (lQ(e, !1)) {
            let { message: t } = lz(
              'NO_MATCHING_KEY',
              `session or pairing topic doesn't exist: ${e}`
            );
            throw Error(t);
          } else {
            let { message: t } = lz(
              'MISSING_OR_INVALID',
              `session or pairing topic should be a string: ${e}`
            );
            throw Error(t);
          }
        }
        async isValidProposalId(e) {
          if ('number' != typeof e) {
            let { message: t } = lz('MISSING_OR_INVALID', `proposal id should be a number: ${e}`);
            throw Error(t);
          }
          if (!this.client.proposal.keys.includes(e)) {
            let { message: t } = lz('NO_MATCHING_KEY', `proposal id doesn't exist: ${e}`);
            throw Error(t);
          }
          if (aI(this.client.proposal.get(e).expiryTimestamp)) {
            await this.deleteProposal(e);
            let { message: t } = lz('EXPIRED', `proposal id: ${e}`);
            throw Error(t);
          }
        }
      }
      class pz extends dG {
        constructor(e, t) {
          super(e, t, 'proposal', pT), (this.core = e), (this.logger = t);
        }
      }
      class pW extends dG {
        constructor(e, t) {
          super(e, t, 'session', pT), (this.core = e), (this.logger = t);
        }
      }
      class pH extends dG {
        constructor(e, t) {
          super(e, t, 'request', pT, (e) => e.id), (this.core = e), (this.logger = t);
        }
      }
      class pG extends dG {
        constructor(e, t) {
          super(e, t, 'authKeys', px, () => pM), (this.core = e), (this.logger = t);
        }
      }
      class pK extends dG {
        constructor(e, t) {
          super(e, t, 'pairingTopics', px), (this.core = e), (this.logger = t);
        }
      }
      class pQ extends dG {
        constructor(e, t) {
          super(e, t, 'requests', px, (e) => e.id), (this.core = e), (this.logger = t);
        }
      }
      var pY = Object.defineProperty,
        pZ = (e, t, n) =>
          t in e
            ? pY(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        pJ = (e, t, n) => pZ(e, 'symbol' != typeof t ? t + '' : t, n);
      class pX {
        constructor(e, t) {
          (this.core = e),
            (this.logger = t),
            pJ(this, 'authKeys'),
            pJ(this, 'pairingTopics'),
            pJ(this, 'requests'),
            (this.authKeys = new pG(this.core, this.logger)),
            (this.pairingTopics = new pK(this.core, this.logger)),
            (this.requests = new pQ(this.core, this.logger));
        }
        async init() {
          await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
        }
      }
      var p0 = Object.defineProperty,
        p1 = (e, t, n) =>
          t in e
            ? p0(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        p2 = (e, t, n) => p1(e, 'symbol' != typeof t ? t + '' : t, n);
      class p6 extends eT {
        constructor(e) {
          super(e),
            p2(this, 'protocol', 'wc'),
            p2(this, 'version', 2),
            p2(this, 'name', pA.name),
            p2(this, 'metadata'),
            p2(this, 'core'),
            p2(this, 'logger'),
            p2(this, 'events', new b.EventEmitter()),
            p2(this, 'engine'),
            p2(this, 'session'),
            p2(this, 'proposal'),
            p2(this, 'pendingRequest'),
            p2(this, 'auth'),
            p2(this, 'signConfig'),
            p2(this, 'on', (e, t) => this.events.on(e, t)),
            p2(this, 'once', (e, t) => this.events.once(e, t)),
            p2(this, 'off', (e, t) => this.events.off(e, t)),
            p2(this, 'removeListener', (e, t) => this.events.removeListener(e, t)),
            p2(this, 'removeAllListeners', (e) => this.events.removeAllListeners(e)),
            p2(this, 'connect', async (e) => {
              try {
                return await this.engine.connect(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            p2(this, 'pair', async (e) => {
              try {
                return await this.engine.pair(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            p2(this, 'approve', async (e) => {
              try {
                return await this.engine.approve(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            p2(this, 'reject', async (e) => {
              try {
                return await this.engine.reject(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            p2(this, 'update', async (e) => {
              try {
                return await this.engine.update(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            p2(this, 'extend', async (e) => {
              try {
                return await this.engine.extend(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            p2(this, 'request', async (e) => {
              try {
                return await this.engine.request(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            p2(this, 'respond', async (e) => {
              try {
                return await this.engine.respond(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            p2(this, 'ping', async (e) => {
              try {
                return await this.engine.ping(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            p2(this, 'emit', async (e) => {
              try {
                return await this.engine.emit(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            p2(this, 'disconnect', async (e) => {
              try {
                return await this.engine.disconnect(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            p2(this, 'find', (e) => {
              try {
                return this.engine.find(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            p2(this, 'getPendingSessionRequests', () => {
              try {
                return this.engine.getPendingSessionRequests();
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            p2(this, 'authenticate', async (e, t) => {
              try {
                return await this.engine.authenticate(e, t);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            p2(this, 'formatAuthMessage', (e) => {
              try {
                return this.engine.formatAuthMessage(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            p2(this, 'approveSessionAuthenticate', async (e) => {
              try {
                return await this.engine.approveSessionAuthenticate(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            p2(this, 'rejectSessionAuthenticate', async (e) => {
              try {
                return await this.engine.rejectSessionAuthenticate(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            (this.name = e?.name || pA.name),
            (this.metadata = (function (e) {
              var t, n;
              let r = am();
              try {
                return (
                  null != e &&
                    e.url &&
                    r.url &&
                    e.url !== r.url &&
                    (console.warn(
                      `The configured WalletConnect 'metadata.url':${e.url} differs from the actual page url:${r.url}. This is probably unintended and can lead to issues.`
                    ),
                    (e.url = r.url)),
                  null != (t = e?.icons) &&
                    t.length &&
                    e.icons.length > 0 &&
                    (e.icons = e.icons.filter((e) => '' !== e)),
                  au(al(al({}, r), e), {
                    url: e?.url || r.url,
                    name: e?.name || r.name,
                    description: e?.description || r.description,
                    icons:
                      null != (n = e?.icons) && n.length && e.icons.length > 0 ? e.icons : r.icons,
                  })
                );
              } catch (t) {
                return console.warn('Error populating app metadata', t), e || r;
              }
            })(e?.metadata)),
            (this.signConfig = e?.signConfig);
          let t =
            'u' > typeof e?.logger && 'string' != typeof e?.logger
              ? e.logger
              : (0, ee.gw)((0, ee.jI)({ level: e?.logger || pA.logger }));
          (this.core = e?.core || new pw(e)),
            (this.logger = (0, ee.Ep)(t, this.name)),
            (this.session = new pW(this.core, this.logger)),
            (this.proposal = new pz(this.core, this.logger)),
            (this.pendingRequest = new pH(this.core, this.logger)),
            (this.engine = new p$(this)),
            (this.auth = new pX(this.core, this.logger));
        }
        static async init(e) {
          let t = new p6(e);
          return await t.initialize(), t;
        }
        get context() {
          return (0, ee.Fd)(this.logger);
        }
        get pairing() {
          return this.core.pairing.pairings;
        }
        async initialize() {
          this.logger.trace('Initialized');
          try {
            await this.core.start(),
              await this.session.init(),
              await this.proposal.init(),
              await this.pendingRequest.init(),
              await this.auth.init(),
              await this.engine.init(),
              this.logger.info('SignClient Initialization Success'),
              setTimeout(
                () => {
                  this.engine.processRelayMessageCache();
                },
                (0, v.toMiliseconds)(v.ONE_SECOND)
              );
          } catch (e) {
            throw (
              (this.logger.info('SignClient Initialization Failure'),
              this.logger.error(e.message),
              e)
            );
          }
        }
      }
      var p5 = n(19896),
        p8 = n.n(p5),
        p3 = Object.defineProperty,
        p4 = Object.defineProperties,
        p9 = Object.getOwnPropertyDescriptors,
        p7 = Object.getOwnPropertySymbols,
        he = Object.prototype.hasOwnProperty,
        ht = Object.prototype.propertyIsEnumerable,
        hn = (e, t, n) =>
          t in e
            ? p3(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        hr = (e, t) => {
          for (var n in t || (t = {})) he.call(t, n) && hn(e, n, t[n]);
          if (p7) for (var n of p7(t)) ht.call(t, n) && hn(e, n, t[n]);
          return e;
        },
        hi = (e, t) => p4(e, p9(t));
      let ha = {
        headers: { Accept: 'application/json', 'Content-Type': 'application/json' },
        method: 'POST',
      };
      class hs {
        constructor(e, t = !1) {
          if (
            ((this.url = e),
            (this.disableProviderPing = t),
            (this.events = new b.EventEmitter()),
            (this.isAvailable = !1),
            (this.registering = !1),
            !um(e))
          )
            throw Error(`Provided URL is not compatible with HTTP connection: ${e}`);
          (this.url = e), (this.disableProviderPing = t);
        }
        get connected() {
          return this.isAvailable;
        }
        get connecting() {
          return this.registering;
        }
        on(e, t) {
          this.events.on(e, t);
        }
        once(e, t) {
          this.events.once(e, t);
        }
        off(e, t) {
          this.events.off(e, t);
        }
        removeListener(e, t) {
          this.events.removeListener(e, t);
        }
        async open(e = this.url) {
          await this.register(e);
        }
        async close() {
          if (!this.isAvailable) throw Error('Connection already closed');
          this.onClose();
        }
        async send(e) {
          this.isAvailable || (await this.register());
          try {
            let t = (0, z.u)(e),
              n = await (await p8()(this.url, hi(hr({}, ha), { body: t }))).json();
            this.onPayload({ data: n });
          } catch (t) {
            this.onError(e.id, t);
          }
        }
        async register(e = this.url) {
          if (!um(e)) throw Error(`Provided URL is not compatible with HTTP connection: ${e}`);
          if (this.registering) {
            let e = this.events.getMaxListeners();
            return (
              (this.events.listenerCount('register_error') >= e ||
                this.events.listenerCount('open') >= e) &&
                this.events.setMaxListeners(e + 1),
              new Promise((e, t) => {
                this.events.once('register_error', (e) => {
                  this.resetMaxListeners(), t(e);
                }),
                  this.events.once('open', () => {
                    if ((this.resetMaxListeners(), typeof this.isAvailable > 'u'))
                      return t(Error('HTTP connection is missing or invalid'));
                    e();
                  });
              })
            );
          }
          (this.url = e), (this.registering = !0);
          try {
            if (!this.disableProviderPing) {
              let t = (0, z.u)({ id: 1, jsonrpc: '2.0', method: 'test', params: [] });
              await p8()(e, hi(hr({}, ha), { body: t }));
            }
            this.onOpen();
          } catch (t) {
            let e = this.parseError(t);
            throw (this.events.emit('register_error', e), this.onClose(), e);
          }
        }
        onOpen() {
          (this.isAvailable = !0), (this.registering = !1), this.events.emit('open');
        }
        onClose() {
          (this.isAvailable = !1), (this.registering = !1), this.events.emit('close');
        }
        onPayload(e) {
          if (typeof e.data > 'u') return;
          let t = 'string' == typeof e.data ? (0, z.D)(e.data) : e.data;
          this.events.emit('payload', t);
        }
        onError(e, t) {
          let n = this.parseError(t),
            r = ud(e, n.message || n.toString());
          this.events.emit('payload', r);
        }
        parseError(e, t = this.url) {
          return ua(e, t, 'HTTP');
        }
        resetMaxListeners() {
          this.events.getMaxListeners() > 10 && this.events.setMaxListeners(10);
        }
      }
      var ho = n(87150).Buffer;
      let hl = 'error',
        hu = 'wc@2:universal_provider:',
        hc = 'https://rpc.walletconnect.org/v1/',
        hd = 'generic',
        hp = `${hc}bundler`,
        hh = 'default_chain_changed';
      function hy() {}
      function hf(e) {
        return null == e || ('object' != typeof e && 'function' != typeof e);
      }
      function hm(e) {
        return ArrayBuffer.isView(e) && !(e instanceof DataView);
      }
      function hg(e) {
        return 'object' == typeof e && null !== e;
      }
      function hb(e) {
        return Object.getOwnPropertySymbols(e).filter((t) =>
          Object.prototype.propertyIsEnumerable.call(e, t)
        );
      }
      function hw(e) {
        return null == e
          ? void 0 === e
            ? '[object Undefined]'
            : '[object Null]'
          : Object.prototype.toString.call(e);
      }
      let hv = '[object String]',
        hT = '[object Number]',
        hA = '[object Boolean]',
        hE = '[object Arguments]';
      function hC(e, t, n, r = new Map(), i) {
        let a = i?.(e, t, n, r);
        if (null != a) return a;
        if (hf(e)) return e;
        if (r.has(e)) return r.get(e);
        if (Array.isArray(e)) {
          let t = Array(e.length);
          r.set(e, t);
          for (let a = 0; a < e.length; a++) t[a] = hC(e[a], a, n, r, i);
          return (
            Object.hasOwn(e, 'index') && (t.index = e.index),
            Object.hasOwn(e, 'input') && (t.input = e.input),
            t
          );
        }
        if (e instanceof Date) return new Date(e.getTime());
        if (e instanceof RegExp) {
          let t = new RegExp(e.source, e.flags);
          return (t.lastIndex = e.lastIndex), t;
        }
        if (e instanceof Map) {
          let t = new Map();
          for (let [a, s] of (r.set(e, t), e)) t.set(a, hC(s, a, n, r, i));
          return t;
        }
        if (e instanceof Set) {
          let t = new Set();
          for (let a of (r.set(e, t), e)) t.add(hC(a, void 0, n, r, i));
          return t;
        }
        if ('u' > typeof ho && ho.isBuffer(e)) return e.subarray();
        if (hm(e)) {
          let t = new (Object.getPrototypeOf(e).constructor)(e.length);
          r.set(e, t);
          for (let a = 0; a < e.length; a++) t[a] = hC(e[a], a, n, r, i);
          return t;
        }
        if (
          e instanceof ArrayBuffer ||
          ('u' > typeof SharedArrayBuffer && e instanceof SharedArrayBuffer)
        )
          return e.slice(0);
        if (e instanceof DataView) {
          let t = new DataView(e.buffer.slice(0), e.byteOffset, e.byteLength);
          return r.set(e, t), h_(t, e, n, r, i), t;
        }
        if ('u' > typeof File && e instanceof File) {
          let t = new File([e], e.name, { type: e.type });
          return r.set(e, t), h_(t, e, n, r, i), t;
        }
        if (e instanceof Blob) {
          let t = new Blob([e], { type: e.type });
          return r.set(e, t), h_(t, e, n, r, i), t;
        }
        if (e instanceof Error) {
          let t = new e.constructor();
          return (
            r.set(e, t),
            (t.message = e.message),
            (t.name = e.name),
            (t.stack = e.stack),
            (t.cause = e.cause),
            h_(t, e, n, r, i),
            t
          );
        }
        if (
          'object' == typeof e &&
          (function (e) {
            switch (hw(e)) {
              case hE:
              case '[object Array]':
              case '[object ArrayBuffer]':
              case '[object DataView]':
              case hA:
              case '[object Date]':
              case '[object Float32Array]':
              case '[object Float64Array]':
              case '[object Int8Array]':
              case '[object Int16Array]':
              case '[object Int32Array]':
              case '[object Map]':
              case hT:
              case '[object Object]':
              case '[object RegExp]':
              case '[object Set]':
              case hv:
              case '[object Symbol]':
              case '[object Uint8Array]':
              case '[object Uint8ClampedArray]':
              case '[object Uint16Array]':
              case '[object Uint32Array]':
                return !0;
              default:
                return !1;
            }
          })(e)
        ) {
          let t = Object.create(Object.getPrototypeOf(e));
          return r.set(e, t), h_(t, e, n, r, i), t;
        }
        return e;
      }
      function h_(e, t, n = e, r, i) {
        let a = [...Object.keys(t), ...hb(t)];
        for (let s = 0; s < a.length; s++) {
          let o = a[s],
            l = Object.getOwnPropertyDescriptor(e, o);
          (null == l || l.writable) && (e[o] = hC(t[o], o, n, r, i));
        }
      }
      function hI(e) {
        var t;
        return (
          (t = (t, n, r, i) => {
            let a = void 0;
            if (null != a) return a;
            if ('object' == typeof e)
              switch (Object.prototype.toString.call(e)) {
                case hT:
                case hv:
                case hA: {
                  let t = new e.constructor(e?.valueOf());
                  return h_(t, e), t;
                }
                case hE: {
                  let t = {};
                  return (
                    h_(t, e), (t.length = e.length), (t[Symbol.iterator] = e[Symbol.iterator]), t
                  );
                }
                default:
                  return;
              }
          }),
          hC(e, void 0, e, new Map(), t)
        );
      }
      function hS(e) {
        return null !== e && 'object' == typeof e && '[object Arguments]' === hw(e);
      }
      var hP = Object.defineProperty,
        hO = Object.defineProperties,
        hN = Object.getOwnPropertyDescriptors,
        hx = Object.getOwnPropertySymbols,
        hM = Object.prototype.hasOwnProperty,
        hk = Object.prototype.propertyIsEnumerable,
        hR = (e, t, n) =>
          t in e
            ? hP(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        hD = (e, t) => {
          for (var n in t || (t = {})) hM.call(t, n) && hR(e, n, t[n]);
          if (hx) for (var n of hx(t)) hk.call(t, n) && hR(e, n, t[n]);
          return e;
        },
        hB = (e, t) => hO(e, hN(t));
      function hU(e, t, n) {
        var r;
        let i = i7(e);
        return (
          (null == (r = t.rpcMap) ? void 0 : r[i.reference]) ||
          `${hc}?chainId=${i.namespace}:${i.reference}&projectId=${n}`
        );
      }
      function hL(e) {
        return e.includes(':') ? e.split(':')[1] : e;
      }
      function hF(e) {
        return e.map((e) => `${e.split(':')[0]}:${e.split(':')[1]}`);
      }
      function hj(e = {}, t = {}) {
        return (function (e, ...t) {
          return (function (e, ...t) {
            let n = t.slice(0, -1),
              r = t[t.length - 1],
              i = e;
            for (let e = 0; e < n.length; e++)
              i = (function e(t, n, r, i) {
                if ((hf(t) && (t = Object(t)), null == n || 'object' != typeof n)) return t;
                if (i.has(n))
                  return (function (e) {
                    if (hf(e)) return e;
                    if (
                      Array.isArray(e) ||
                      hm(e) ||
                      e instanceof ArrayBuffer ||
                      ('u' > typeof SharedArrayBuffer && e instanceof SharedArrayBuffer)
                    )
                      return e.slice(0);
                    let t = Object.getPrototypeOf(e),
                      n = t.constructor;
                    if (e instanceof Date || e instanceof Map || e instanceof Set) return new n(e);
                    if (e instanceof RegExp) {
                      let t = new n(e);
                      return (t.lastIndex = e.lastIndex), t;
                    }
                    if (e instanceof DataView) return new n(e.buffer.slice(0));
                    if (e instanceof Error) {
                      let t = new n(e.message);
                      return (t.stack = e.stack), (t.name = e.name), (t.cause = e.cause), t;
                    }
                    return 'u' > typeof File && e instanceof File
                      ? new n([e], e.name, { type: e.type, lastModified: e.lastModified })
                      : 'object' == typeof e
                        ? Object.assign(Object.create(t), e)
                        : e;
                  })(i.get(n));
                if ((i.set(n, t), Array.isArray(n))) {
                  n = n.slice();
                  for (let e = 0; e < n.length; e++) n[e] = n[e] ?? void 0;
                }
                let a = [...Object.keys(n), ...hb(n)];
                for (let s = 0; s < a.length; s++) {
                  let o = a[s],
                    l = n[o],
                    u = t[o];
                  if (
                    (hS(l) && (l = { ...l }),
                    hS(u) && (u = { ...u }),
                    'u' > typeof ho && ho.isBuffer(l) && (l = hI(l)),
                    Array.isArray(l))
                  ) {
                    if ('object' == typeof u && null != u) {
                      let e = [],
                        t = Reflect.ownKeys(u);
                      for (let n = 0; n < t.length; n++) {
                        let r = t[n];
                        e[r] = u[r];
                      }
                      u = e;
                    } else u = [];
                  }
                  let c = r(u, l, o, t, n, i);
                  null != c
                    ? (t[o] = c)
                    : Array.isArray(l) || (hg(u) && hg(l))
                      ? (t[o] = e(u, l, r, i))
                      : null == u &&
                          (function (e) {
                            if ('object' != typeof e || null == e) return !1;
                            if (null === Object.getPrototypeOf(e)) return !0;
                            if ('[object Object]' !== Object.prototype.toString.call(e)) {
                              let t = e[Symbol.toStringTag];
                              return (
                                !!(
                                  null != t &&
                                  Object.getOwnPropertyDescriptor(e, Symbol.toStringTag)?.writable
                                ) && e.toString() === `[object ${t}]`
                              );
                            }
                            let t = e;
                            for (; null !== Object.getPrototypeOf(t); )
                              t = Object.getPrototypeOf(t);
                            return Object.getPrototypeOf(e) === t;
                          })(l)
                        ? (t[o] = e({}, l, r, i))
                        : null == u && hm(l)
                          ? (t[o] = hI(l))
                          : (void 0 === u || void 0 !== l) && (t[o] = l);
                }
                return t;
              })(i, n[e], r, new Map());
            return i;
          })(e, ...t, hy);
        })(hq(e), hq(t));
      }
      function hq(e) {
        var t, n, r, i;
        let a = {};
        if (!lG(e)) return a;
        for (let [s, o] of Object.entries(e)) {
          let e = lF(s) ? [s] : o.chains,
            l = o.methods || [],
            u = o.events || [],
            c = o.rpcMap || {},
            d = lj(s);
          a[d] = hB(hD(hD({}, a[d]), o), {
            chains: aP(e, null == (t = a[d]) ? void 0 : t.chains),
            methods: aP(l, null == (n = a[d]) ? void 0 : n.methods),
            events: aP(u, null == (r = a[d]) ? void 0 : r.events),
            rpcMap: hD(hD({}, c), null == (i = a[d]) ? void 0 : i.rpcMap),
          });
        }
        return a;
      }
      function hV(e) {
        return e.includes(':') ? e.split(':')[2] : e;
      }
      function h$(e) {
        let t = {};
        for (let [n, r] of Object.entries(e)) {
          let e = r.methods || [],
            i = r.events || [],
            a = r.accounts || [],
            s = lF(n) ? [n] : r.chains ? r.chains : hF(r.accounts);
          t[n] = { chains: s, methods: e, events: i, accounts: a };
        }
        return t;
      }
      function hz(e) {
        return 'number' == typeof e
          ? e
          : e.includes('0x')
            ? parseInt(e, 16)
            : isNaN(Number((e = e.includes(':') ? e.split(':')[1] : e)))
              ? e
              : Number(e);
      }
      let hW = {},
        hH = (e) => hW[e],
        hG = (e, t) => {
          hW[e] = t;
        };
      var hK = Object.defineProperty,
        hQ = (e, t, n) =>
          t in e
            ? hK(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        hY = (e, t, n) => hQ(e, 'symbol' != typeof t ? t + '' : t, n);
      class hZ {
        constructor(e) {
          hY(this, 'name', 'polkadot'),
            hY(this, 'client'),
            hY(this, 'httpProviders'),
            hY(this, 'events'),
            hY(this, 'namespace'),
            hY(this, 'chainId'),
            (this.namespace = e.namespace),
            (this.events = hH('events')),
            (this.client = hH('client')),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error('ChainId not found');
          return e.split(':')[1];
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(hh, `${this.name}:${e}`);
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return (
            (e &&
              e
                .filter((e) => e.split(':')[1] === this.chainId.toString())
                .map((e) => e.split(':')[2])) ||
            []
          );
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var n;
              let r = hL(t);
              e[r] = this.createHttpProvider(
                r,
                null == (n = this.namespace.rpcMap) ? void 0 : n[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > 'u') throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let n = this.createHttpProvider(e, t);
          n && (this.httpProviders[e] = n);
        }
        createHttpProvider(e, t) {
          let n = t || hU(e, this.namespace, this.client.core.projectId);
          if (!n) throw Error(`No RPC url provided for chainId: ${e}`);
          return new uE(new hs(n, hH('disableProviderPing')));
        }
      }
      var hJ = Object.defineProperty,
        hX = Object.defineProperties,
        h0 = Object.getOwnPropertyDescriptors,
        h1 = Object.getOwnPropertySymbols,
        h2 = Object.prototype.hasOwnProperty,
        h6 = Object.prototype.propertyIsEnumerable,
        h5 = (e, t, n) =>
          t in e
            ? hJ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        h8 = (e, t) => {
          for (var n in t || (t = {})) h2.call(t, n) && h5(e, n, t[n]);
          if (h1) for (var n of h1(t)) h6.call(t, n) && h5(e, n, t[n]);
          return e;
        },
        h3 = (e, t) => hX(e, h0(t)),
        h4 = (e, t, n) => h5(e, 'symbol' != typeof t ? t + '' : t, n);
      class h9 {
        constructor(e) {
          h4(this, 'name', 'eip155'),
            h4(this, 'client'),
            h4(this, 'chainId'),
            h4(this, 'namespace'),
            h4(this, 'httpProviders'),
            h4(this, 'events'),
            (this.namespace = e.namespace),
            (this.events = hH('events')),
            (this.client = hH('client')),
            (this.httpProviders = this.createHttpProviders()),
            (this.chainId = parseInt(this.getDefaultChain()));
        }
        async request(e) {
          switch (e.request.method) {
            case 'eth_requestAccounts':
            case 'eth_accounts':
              return this.getAccounts();
            case 'wallet_switchEthereumChain':
              return await this.handleSwitchChain(e);
            case 'eth_chainId':
              return parseInt(this.getDefaultChain());
            case 'wallet_getCapabilities':
              return await this.getCapabilities(e);
            case 'wallet_getCallsStatus':
              return await this.getCallStatus(e);
          }
          return this.namespace.methods.includes(e.request.method)
            ? await this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(parseInt(e), t),
            (this.chainId = parseInt(e)),
            this.events.emit(hh, `${this.name}:${e}`);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId.toString();
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error('ChainId not found');
          return e.split(':')[1];
        }
        createHttpProvider(e, t) {
          let n = t || hU(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
          if (!n) throw Error(`No RPC url provided for chainId: ${e}`);
          return new uE(new hs(n, hH('disableProviderPing')));
        }
        setHttpProvider(e, t) {
          let n = this.createHttpProvider(e, t);
          n && (this.httpProviders[e] = n);
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var n;
              let r = parseInt(hL(t));
              e[r] = this.createHttpProvider(
                r,
                null == (n = this.namespace.rpcMap) ? void 0 : n[t]
              );
            }),
            e
          );
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(':')[1] === this.chainId.toString())
                    .map((e) => e.split(':')[2])
                ),
              ]
            : [];
        }
        getHttpProvider() {
          let e = this.chainId,
            t = this.httpProviders[e];
          if (typeof t > 'u') throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        async handleSwitchChain(e) {
          var t, n;
          let r = e.request.params
              ? null == (t = e.request.params[0])
                ? void 0
                : t.chainId
              : '0x0',
            i = parseInt((r = r.startsWith('0x') ? r : `0x${r}`), 16);
          if (this.isChainApproved(i)) this.setDefaultChain(`${i}`);
          else if (this.namespace.methods.includes('wallet_switchEthereumChain'))
            await this.client.request({
              topic: e.topic,
              request: { method: e.request.method, params: [{ chainId: r }] },
              chainId: null == (n = this.namespace.chains) ? void 0 : n[0],
            }),
              this.setDefaultChain(`${i}`);
          else
            throw Error(
              `Failed to switch to chain 'eip155:${i}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`
            );
          return null;
        }
        isChainApproved(e) {
          return this.namespace.chains.includes(`${this.name}:${e}`);
        }
        async getCapabilities(e) {
          var t, n, r;
          let i = null == (n = null == (t = e.request) ? void 0 : t.params) ? void 0 : n[0];
          if (!i) throw Error('Missing address parameter in `wallet_getCapabilities` request');
          let a = this.client.session.get(e.topic),
            s = (null == (r = a?.sessionProperties) ? void 0 : r.capabilities) || {};
          if (null != s && s[i]) return s?.[i];
          let o = await this.client.request(e);
          try {
            await this.client.session.update(e.topic, {
              sessionProperties: h3(h8({}, a.sessionProperties || {}), {
                capabilities: h3(h8({}, s || {}), { [i]: o }),
              }),
            });
          } catch (e) {
            console.warn('Failed to update session with capabilities', e);
          }
          return o;
        }
        async getCallStatus(e) {
          var t, n;
          let r = this.client.session.get(e.topic),
            i = null == (t = r.sessionProperties) ? void 0 : t.bundler_name;
          if (i) {
            let t = this.getBundlerUrl(e.chainId, i);
            try {
              return await this.getUserOperationReceipt(t, e);
            } catch (e) {
              console.warn('Failed to fetch call status from bundler', e, t);
            }
          }
          let a = null == (n = r.sessionProperties) ? void 0 : n.bundler_url;
          if (a)
            try {
              return await this.getUserOperationReceipt(a, e);
            } catch (e) {
              console.warn('Failed to fetch call status from custom bundler', e, a);
            }
          if (this.namespace.methods.includes(e.request.method))
            return await this.client.request(e);
          throw Error('Fetching call status not approved by the wallet.');
        }
        async getUserOperationReceipt(e, t) {
          var n;
          let r = new URL(e),
            i = await fetch(r, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(
                uu('eth_getUserOperationReceipt', [null == (n = t.request.params) ? void 0 : n[0]])
              ),
            });
          if (!i.ok) throw Error(`Failed to fetch user operation receipt - ${i.status}`);
          return await i.json();
        }
        getBundlerUrl(e, t) {
          return `${hp}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${t}`;
        }
      }
      var h7 = Object.defineProperty,
        ye = (e, t, n) =>
          t in e
            ? h7(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        yt = (e, t, n) => ye(e, 'symbol' != typeof t ? t + '' : t, n);
      class yn {
        constructor(e) {
          yt(this, 'name', 'solana'),
            yt(this, 'client'),
            yt(this, 'httpProviders'),
            yt(this, 'events'),
            yt(this, 'namespace'),
            yt(this, 'chainId'),
            (this.namespace = e.namespace),
            (this.events = hH('events')),
            (this.client = hH('client')),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(hh, `${this.name}:${e}`);
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error('ChainId not found');
          return e.split(':')[1];
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(':')[1] === this.chainId.toString())
                    .map((e) => e.split(':')[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var n;
              let r = hL(t);
              e[r] = this.createHttpProvider(
                r,
                null == (n = this.namespace.rpcMap) ? void 0 : n[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > 'u') throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let n = this.createHttpProvider(e, t);
          n && (this.httpProviders[e] = n);
        }
        createHttpProvider(e, t) {
          let n = t || hU(e, this.namespace, this.client.core.projectId);
          if (!n) throw Error(`No RPC url provided for chainId: ${e}`);
          return new uE(new hs(n, hH('disableProviderPing')));
        }
      }
      var yr = Object.defineProperty,
        yi = (e, t, n) =>
          t in e
            ? yr(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        ya = (e, t, n) => yi(e, 'symbol' != typeof t ? t + '' : t, n);
      class ys {
        constructor(e) {
          ya(this, 'name', 'cosmos'),
            ya(this, 'client'),
            ya(this, 'httpProviders'),
            ya(this, 'events'),
            ya(this, 'namespace'),
            ya(this, 'chainId'),
            (this.namespace = e.namespace),
            (this.events = hH('events')),
            (this.client = hH('client')),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error('ChainId not found');
          return e.split(':')[1];
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(hh, `${this.name}:${this.chainId}`);
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(':')[1] === this.chainId.toString())
                    .map((e) => e.split(':')[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var n;
              let r = hL(t);
              e[r] = this.createHttpProvider(
                r,
                null == (n = this.namespace.rpcMap) ? void 0 : n[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > 'u') throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let n = this.createHttpProvider(e, t);
          n && (this.httpProviders[e] = n);
        }
        createHttpProvider(e, t) {
          let n = t || hU(e, this.namespace, this.client.core.projectId);
          if (!n) throw Error(`No RPC url provided for chainId: ${e}`);
          return new uE(new hs(n, hH('disableProviderPing')));
        }
      }
      var yo = Object.defineProperty,
        yl = (e, t, n) =>
          t in e
            ? yo(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        yu = (e, t, n) => yl(e, 'symbol' != typeof t ? t + '' : t, n);
      class yc {
        constructor(e) {
          yu(this, 'name', 'algorand'),
            yu(this, 'client'),
            yu(this, 'httpProviders'),
            yu(this, 'events'),
            yu(this, 'namespace'),
            yu(this, 'chainId'),
            (this.namespace = e.namespace),
            (this.events = hH('events')),
            (this.client = hH('client')),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          if (!this.httpProviders[e]) {
            let n = t || hU(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
            if (!n) throw Error(`No RPC url provided for chainId: ${e}`);
            this.setHttpProvider(e, n);
          }
          (this.chainId = e), this.events.emit(hh, `${this.name}:${this.chainId}`);
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error('ChainId not found');
          return e.split(':')[1];
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(':')[1] === this.chainId.toString())
                    .map((e) => e.split(':')[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var n;
              e[t] = this.createHttpProvider(
                t,
                null == (n = this.namespace.rpcMap) ? void 0 : n[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > 'u') throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let n = this.createHttpProvider(e, t);
          n && (this.httpProviders[e] = n);
        }
        createHttpProvider(e, t) {
          let n = t || hU(e, this.namespace, this.client.core.projectId);
          return typeof n > 'u' ? void 0 : new uE(new hs(n, hH('disableProviderPing')));
        }
      }
      var yd = Object.defineProperty,
        yp = (e, t, n) =>
          t in e
            ? yd(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        yh = (e, t, n) => yp(e, 'symbol' != typeof t ? t + '' : t, n);
      class yy {
        constructor(e) {
          yh(this, 'name', 'cip34'),
            yh(this, 'client'),
            yh(this, 'httpProviders'),
            yh(this, 'events'),
            yh(this, 'namespace'),
            yh(this, 'chainId'),
            (this.namespace = e.namespace),
            (this.events = hH('events')),
            (this.client = hH('client')),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error('ChainId not found');
          return e.split(':')[1];
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(hh, `${this.name}:${this.chainId}`);
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(':')[1] === this.chainId.toString())
                    .map((e) => e.split(':')[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              let n = this.getCardanoRPCUrl(t),
                r = hL(t);
              e[r] = this.createHttpProvider(r, n);
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > 'u') throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        getCardanoRPCUrl(e) {
          let t = this.namespace.rpcMap;
          if (t) return t[e];
        }
        setHttpProvider(e, t) {
          let n = this.createHttpProvider(e, t);
          n && (this.httpProviders[e] = n);
        }
        createHttpProvider(e, t) {
          let n = t || this.getCardanoRPCUrl(e);
          if (!n) throw Error(`No RPC url provided for chainId: ${e}`);
          return new uE(new hs(n, hH('disableProviderPing')));
        }
      }
      var yf = Object.defineProperty,
        ym = (e, t, n) =>
          t in e
            ? yf(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        yg = (e, t, n) => ym(e, 'symbol' != typeof t ? t + '' : t, n);
      class yb {
        constructor(e) {
          yg(this, 'name', 'elrond'),
            yg(this, 'client'),
            yg(this, 'httpProviders'),
            yg(this, 'events'),
            yg(this, 'namespace'),
            yg(this, 'chainId'),
            (this.namespace = e.namespace),
            (this.events = hH('events')),
            (this.client = hH('client')),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(hh, `${this.name}:${e}`);
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error('ChainId not found');
          return e.split(':')[1];
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(':')[1] === this.chainId.toString())
                    .map((e) => e.split(':')[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var n;
              let r = hL(t);
              e[r] = this.createHttpProvider(
                r,
                null == (n = this.namespace.rpcMap) ? void 0 : n[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > 'u') throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let n = this.createHttpProvider(e, t);
          n && (this.httpProviders[e] = n);
        }
        createHttpProvider(e, t) {
          let n = t || hU(e, this.namespace, this.client.core.projectId);
          if (!n) throw Error(`No RPC url provided for chainId: ${e}`);
          return new uE(new hs(n, hH('disableProviderPing')));
        }
      }
      var yw = Object.defineProperty,
        yv = (e, t, n) =>
          t in e
            ? yw(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        yT = (e, t, n) => yv(e, 'symbol' != typeof t ? t + '' : t, n);
      class yA {
        constructor(e) {
          yT(this, 'name', 'multiversx'),
            yT(this, 'client'),
            yT(this, 'httpProviders'),
            yT(this, 'events'),
            yT(this, 'namespace'),
            yT(this, 'chainId'),
            (this.namespace = e.namespace),
            (this.events = hH('events')),
            (this.client = hH('client')),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(hh, `${this.name}:${e}`);
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error('ChainId not found');
          return e.split(':')[1];
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(':')[1] === this.chainId.toString())
                    .map((e) => e.split(':')[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var n;
              let r = hL(t);
              e[r] = this.createHttpProvider(
                r,
                null == (n = this.namespace.rpcMap) ? void 0 : n[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > 'u') throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let n = this.createHttpProvider(e, t);
          n && (this.httpProviders[e] = n);
        }
        createHttpProvider(e, t) {
          let n = t || hU(e, this.namespace, this.client.core.projectId);
          if (!n) throw Error(`No RPC url provided for chainId: ${e}`);
          return new uE(new hs(n, hH('disableProviderPing')));
        }
      }
      var yE = Object.defineProperty,
        yC = (e, t, n) =>
          t in e
            ? yE(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        y_ = (e, t, n) => yC(e, 'symbol' != typeof t ? t + '' : t, n);
      class yI {
        constructor(e) {
          y_(this, 'name', 'near'),
            y_(this, 'client'),
            y_(this, 'httpProviders'),
            y_(this, 'events'),
            y_(this, 'namespace'),
            y_(this, 'chainId'),
            (this.namespace = e.namespace),
            (this.events = hH('events')),
            (this.client = hH('client')),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error('ChainId not found');
          return e.split(':')[1];
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          if (((this.chainId = e), !this.httpProviders[e])) {
            let n = t || hU(`${this.name}:${e}`, this.namespace);
            if (!n) throw Error(`No RPC url provided for chainId: ${e}`);
            this.setHttpProvider(e, n);
          }
          this.events.emit(hh, `${this.name}:${this.chainId}`);
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return (
            (e &&
              e
                .filter((e) => e.split(':')[1] === this.chainId.toString())
                .map((e) => e.split(':')[2])) ||
            []
          );
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var n;
              e[t] = this.createHttpProvider(
                t,
                null == (n = this.namespace.rpcMap) ? void 0 : n[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > 'u') throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let n = this.createHttpProvider(e, t);
          n && (this.httpProviders[e] = n);
        }
        createHttpProvider(e, t) {
          let n = t || hU(e, this.namespace);
          return typeof n > 'u' ? void 0 : new uE(new hs(n, hH('disableProviderPing')));
        }
      }
      var yS = Object.defineProperty,
        yP = (e, t, n) =>
          t in e
            ? yS(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        yO = (e, t, n) => yP(e, 'symbol' != typeof t ? t + '' : t, n);
      class yN {
        constructor(e) {
          yO(this, 'name', 'tezos'),
            yO(this, 'client'),
            yO(this, 'httpProviders'),
            yO(this, 'events'),
            yO(this, 'namespace'),
            yO(this, 'chainId'),
            (this.namespace = e.namespace),
            (this.events = hH('events')),
            (this.client = hH('client')),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error('ChainId not found');
          return e.split(':')[1];
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          if (((this.chainId = e), !this.httpProviders[e])) {
            let n = t || hU(`${this.name}:${e}`, this.namespace);
            if (!n) throw Error(`No RPC url provided for chainId: ${e}`);
            this.setHttpProvider(e, n);
          }
          this.events.emit(hh, `${this.name}:${this.chainId}`);
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return (
            (e &&
              e
                .filter((e) => e.split(':')[1] === this.chainId.toString())
                .map((e) => e.split(':')[2])) ||
            []
          );
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              e[t] = this.createHttpProvider(t);
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > 'u') throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let n = this.createHttpProvider(e, t);
          n && (this.httpProviders[e] = n);
        }
        createHttpProvider(e, t) {
          let n = t || hU(e, this.namespace);
          return typeof n > 'u' ? void 0 : new uE(new hs(n));
        }
      }
      var yx = Object.defineProperty,
        yM = (e, t, n) =>
          t in e
            ? yx(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        yk = (e, t, n) => yM(e, 'symbol' != typeof t ? t + '' : t, n);
      class yR {
        constructor(e) {
          yk(this, 'name', hd),
            yk(this, 'client'),
            yk(this, 'httpProviders'),
            yk(this, 'events'),
            yk(this, 'namespace'),
            yk(this, 'chainId'),
            (this.namespace = e.namespace),
            (this.events = hH('events')),
            (this.client = hH('client')),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          (this.namespace.chains = [
            ...new Set((this.namespace.chains || []).concat(e.chains || [])),
          ]),
            (this.namespace.accounts = [
              ...new Set((this.namespace.accounts || []).concat(e.accounts || [])),
            ]),
            (this.namespace.methods = [
              ...new Set((this.namespace.methods || []).concat(e.methods || [])),
            ]),
            (this.namespace.events = [
              ...new Set((this.namespace.events || []).concat(e.events || [])),
            ]),
            (this.httpProviders = this.createHttpProviders());
        }
        requestAccounts() {
          return this.getAccounts();
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider(e.chainId).request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(hh, `${this.name}:${e}`);
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error('ChainId not found');
          return e.split(':')[1];
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(':')[1] === this.chainId.toString())
                    .map((e) => e.split(':')[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          var e, t;
          let n = {};
          return (
            null == (t = null == (e = this.namespace) ? void 0 : e.accounts) ||
              t.forEach((e) => {
                let t = i7(e);
                n[`${t.namespace}:${t.reference}`] = this.createHttpProvider(e);
              }),
            n
          );
        }
        getHttpProvider(e) {
          let t = this.httpProviders[e];
          if (typeof t > 'u') throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let n = this.createHttpProvider(e, t);
          n && (this.httpProviders[e] = n);
        }
        createHttpProvider(e, t) {
          let n = t || hU(e, this.namespace, this.client.core.projectId);
          if (!n) throw Error(`No RPC url provided for chainId: ${e}`);
          return new uE(new hs(n, hH('disableProviderPing')));
        }
      }
      var yD = Object.defineProperty,
        yB = Object.defineProperties,
        yU = Object.getOwnPropertyDescriptors,
        yL = Object.getOwnPropertySymbols,
        yF = Object.prototype.hasOwnProperty,
        yj = Object.prototype.propertyIsEnumerable,
        yq = (e, t, n) =>
          t in e
            ? yD(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
            : (e[t] = n),
        yV = (e, t) => {
          for (var n in t || (t = {})) yF.call(t, n) && yq(e, n, t[n]);
          if (yL) for (var n of yL(t)) yj.call(t, n) && yq(e, n, t[n]);
          return e;
        },
        y$ = (e, t) => yB(e, yU(t)),
        yz = (e, t, n) => yq(e, 'symbol' != typeof t ? t + '' : t, n);
      class yW {
        constructor(e) {
          yz(this, 'client'),
            yz(this, 'namespaces'),
            yz(this, 'optionalNamespaces'),
            yz(this, 'sessionProperties'),
            yz(this, 'scopedProperties'),
            yz(this, 'events', new (w())()),
            yz(this, 'rpcProviders', {}),
            yz(this, 'session'),
            yz(this, 'providerOpts'),
            yz(this, 'logger'),
            yz(this, 'uri'),
            yz(this, 'disableProviderPing', !1),
            (this.providerOpts = e),
            (this.logger =
              'u' > typeof e?.logger && 'string' != typeof e?.logger
                ? e.logger
                : (0, ee.gw)((0, ee.jI)({ level: e?.logger || hl }))),
            (this.disableProviderPing = e?.disableProviderPing || !1);
        }
        static async init(e) {
          let t = new yW(e);
          return await t.initialize(), t;
        }
        async request(e, t, n) {
          let [r, i] = this.validateChain(t);
          if (!this.session) throw Error('Please call connect() before request()');
          return await this.getProvider(r).request({
            request: yV({}, e),
            chainId: `${r}:${i}`,
            topic: this.session.topic,
            expiry: n,
          });
        }
        sendAsync(e, t, n, r) {
          let i = new Date().getTime();
          this.request(e, n, r)
            .then((e) => t(null, uc(i, e)))
            .catch((e) => t(e, void 0));
        }
        async enable() {
          if (!this.client) throw Error('Sign Client not initialized');
          return (
            this.session ||
              (await this.connect({
                namespaces: this.namespaces,
                optionalNamespaces: this.optionalNamespaces,
                sessionProperties: this.sessionProperties,
                scopedProperties: this.scopedProperties,
              })),
            await this.requestAccounts()
          );
        }
        async disconnect() {
          var e;
          if (!this.session) throw Error('Please call connect() before enable()');
          await this.client.disconnect({
            topic: null == (e = this.session) ? void 0 : e.topic,
            reason: lW('USER_DISCONNECTED'),
          }),
            await this.cleanup();
        }
        async connect(e) {
          if (!this.client) throw Error('Sign Client not initialized');
          if ((this.setNamespaces(e), await this.cleanupPendingPairings(), !e.skipPairing))
            return await this.pair(e.pairingTopic);
        }
        async authenticate(e, t) {
          if (!this.client) throw Error('Sign Client not initialized');
          this.setNamespaces(e), await this.cleanupPendingPairings();
          let { uri: n, response: r } = await this.client.authenticate(e, t);
          n && ((this.uri = n), this.events.emit('display_uri', n));
          let i = await r();
          if (((this.session = i.session), this.session)) {
            let e = h$(this.session.namespaces);
            (this.namespaces = hj(this.namespaces, e)),
              await this.persist('namespaces', this.namespaces),
              this.onConnect();
          }
          return i;
        }
        on(e, t) {
          this.events.on(e, t);
        }
        once(e, t) {
          this.events.once(e, t);
        }
        removeListener(e, t) {
          this.events.removeListener(e, t);
        }
        off(e, t) {
          this.events.off(e, t);
        }
        get isWalletConnect() {
          return !0;
        }
        async pair(e) {
          let { uri: t, approval: n } = await this.client.connect({
            pairingTopic: e,
            requiredNamespaces: this.namespaces,
            optionalNamespaces: this.optionalNamespaces,
            sessionProperties: this.sessionProperties,
            scopedProperties: this.scopedProperties,
          });
          t && ((this.uri = t), this.events.emit('display_uri', t));
          let r = await n();
          this.session = r;
          let i = h$(r.namespaces);
          return (
            (this.namespaces = hj(this.namespaces, i)),
            await this.persist('namespaces', this.namespaces),
            await this.persist('optionalNamespaces', this.optionalNamespaces),
            this.onConnect(),
            this.session
          );
        }
        setDefaultChain(e, t) {
          try {
            if (!this.session) return;
            let [n, r] = this.validateChain(e),
              i = this.getProvider(n);
            i.name === hd ? i.setDefaultChain(`${n}:${r}`, t) : i.setDefaultChain(r, t);
          } catch (e) {
            if (!/Please call connect/.test(e.message)) throw e;
          }
        }
        async cleanupPendingPairings(e = {}) {
          this.logger.info('Cleaning up inactive pairings...');
          let t = this.client.pairing.getAll();
          if (lH(t)) {
            for (let n of t)
              e.deletePairings
                ? this.client.core.expirer.set(n.topic, 0)
                : await this.client.core.relayer.subscriber.unsubscribe(n.topic);
            this.logger.info(`Inactive pairings cleared: ${t.length}`);
          }
        }
        abortPairingAttempt() {
          this.logger.warn('abortPairingAttempt is deprecated. This is now a no-op.');
        }
        async checkStorage() {
          (this.namespaces = (await this.getFromStore('namespaces')) || {}),
            (this.optionalNamespaces = (await this.getFromStore('optionalNamespaces')) || {}),
            this.session && this.createProviders();
        }
        async initialize() {
          this.logger.trace('Initialized'),
            await this.createClient(),
            await this.checkStorage(),
            this.registerEventListeners();
        }
        async createClient() {
          var e, t;
          if (
            ((this.client =
              this.providerOpts.client ||
              (await p6.init({
                core: this.providerOpts.core,
                logger: this.providerOpts.logger || hl,
                relayUrl: this.providerOpts.relayUrl || 'wss://relay.walletconnect.org',
                projectId: this.providerOpts.projectId,
                metadata: this.providerOpts.metadata,
                storageOptions: this.providerOpts.storageOptions,
                storage: this.providerOpts.storage,
                name: this.providerOpts.name,
                customStoragePrefix: this.providerOpts.customStoragePrefix,
                telemetryEnabled: this.providerOpts.telemetryEnabled,
              }))),
            this.providerOpts.session)
          )
            try {
              this.session = this.client.session.get(this.providerOpts.session.topic);
            } catch (n) {
              throw (
                (this.logger.error('Failed to get session', n),
                Error(
                  `The provided session: ${null == (t = null == (e = this.providerOpts) ? void 0 : e.session) ? void 0 : t.topic} doesn't exist in the Sign client`
                ))
              );
            }
          else {
            let e = this.client.session.getAll();
            this.session = e[0];
          }
          this.logger.trace('SignClient Initialized');
        }
        createProviders() {
          if (!this.client) throw Error('Sign Client not initialized');
          if (!this.session)
            throw Error('Session not initialized. Please call connect() before enable()');
          let e = [...new Set(Object.keys(this.session.namespaces).map((e) => lj(e)))];
          hG('client', this.client),
            hG('events', this.events),
            hG('disableProviderPing', this.disableProviderPing),
            e.forEach((e) => {
              if (!this.session) return;
              let t = (function (e, t) {
                  let n = Object.keys(t.namespaces).filter((t) => t.includes(e));
                  if (!n.length) return [];
                  let r = [];
                  return (
                    n.forEach((e) => {
                      let n = t.namespaces[e].accounts;
                      r.push(...n);
                    }),
                    r
                  );
                })(e, this.session),
                n = hF(t),
                r = y$(yV({}, hj(this.namespaces, this.optionalNamespaces)[e]), {
                  accounts: t,
                  chains: n,
                });
              switch (e) {
                case 'eip155':
                  this.rpcProviders[e] = new h9({ namespace: r });
                  break;
                case 'algorand':
                  this.rpcProviders[e] = new yc({ namespace: r });
                  break;
                case 'solana':
                  this.rpcProviders[e] = new yn({ namespace: r });
                  break;
                case 'cosmos':
                  this.rpcProviders[e] = new ys({ namespace: r });
                  break;
                case 'polkadot':
                  this.rpcProviders[e] = new hZ({ namespace: r });
                  break;
                case 'cip34':
                  this.rpcProviders[e] = new yy({ namespace: r });
                  break;
                case 'elrond':
                  this.rpcProviders[e] = new yb({ namespace: r });
                  break;
                case 'multiversx':
                  this.rpcProviders[e] = new yA({ namespace: r });
                  break;
                case 'near':
                  this.rpcProviders[e] = new yI({ namespace: r });
                  break;
                case 'tezos':
                  this.rpcProviders[e] = new yN({ namespace: r });
                  break;
                default:
                  this.rpcProviders[hd]
                    ? this.rpcProviders[hd].updateNamespace(r)
                    : (this.rpcProviders[hd] = new yR({ namespace: r }));
              }
            });
        }
        registerEventListeners() {
          if (typeof this.client > 'u') throw Error('Sign Client is not initialized');
          this.client.on('session_ping', (e) => {
            var t;
            let { topic: n } = e;
            n === (null == (t = this.session) ? void 0 : t.topic) &&
              this.events.emit('session_ping', e);
          }),
            this.client.on('session_event', (e) => {
              var t;
              let { params: n, topic: r } = e;
              if (r !== (null == (t = this.session) ? void 0 : t.topic)) return;
              let { event: i } = n;
              if ('accountsChanged' === i.name) {
                let e = i.data;
                e && lH(e) && this.events.emit('accountsChanged', e.map(hV));
              } else if ('chainChanged' === i.name) {
                let e = n.chainId,
                  t = n.event.data,
                  r = lj(e),
                  i = hz(e) !== hz(t) ? `${r}:${hz(t)}` : e;
                this.onChainChanged(i);
              } else this.events.emit(i.name, i.data);
              this.events.emit('session_event', e);
            }),
            this.client.on('session_update', ({ topic: e, params: t }) => {
              var n, r;
              if (e !== (null == (n = this.session) ? void 0 : n.topic)) return;
              let { namespaces: i } = t,
                a = null == (r = this.client) ? void 0 : r.session.get(e);
              (this.session = y$(yV({}, a), { namespaces: i })),
                this.onSessionUpdate(),
                this.events.emit('session_update', { topic: e, params: t });
            }),
            this.client.on('session_delete', async (e) => {
              var t;
              e.topic === (null == (t = this.session) ? void 0 : t.topic) &&
                (await this.cleanup(),
                this.events.emit('session_delete', e),
                this.events.emit(
                  'disconnect',
                  y$(yV({}, lW('USER_DISCONNECTED')), { data: e.topic })
                ));
            }),
            this.on(hh, (e) => {
              this.onChainChanged(e, !0);
            });
        }
        getProvider(e) {
          return this.rpcProviders[e] || this.rpcProviders[hd];
        }
        onSessionUpdate() {
          Object.keys(this.rpcProviders).forEach((e) => {
            var t;
            this.getProvider(e).updateNamespace(
              null == (t = this.session) ? void 0 : t.namespaces[e]
            );
          });
        }
        setNamespaces(e) {
          let {
            namespaces: t,
            optionalNamespaces: n,
            sessionProperties: r,
            scopedProperties: i,
          } = e;
          t && Object.keys(t).length && (this.namespaces = t),
            n && Object.keys(n).length && (this.optionalNamespaces = n),
            (this.sessionProperties = r),
            (this.scopedProperties = i);
        }
        validateChain(e) {
          let [t, n] = e?.split(':') || ['', ''];
          if (!this.namespaces || !Object.keys(this.namespaces).length) return [t, n];
          if (
            t &&
            !Object.keys(this.namespaces || {})
              .map((e) => lj(e))
              .includes(t)
          )
            throw Error(
              `Namespace '${t}' is not configured. Please call connect() first with namespace config.`
            );
          if (t && n) return [t, n];
          let r = lj(Object.keys(this.namespaces)[0]),
            i = this.rpcProviders[r].getDefaultChain();
          return [r, i];
        }
        async requestAccounts() {
          let [e] = this.validateChain();
          return await this.getProvider(e).requestAccounts();
        }
        async onChainChanged(e, t = !1) {
          if (!this.namespaces) return;
          let [n, r] = this.validateChain(e);
          if (!r) return;
          this.updateNamespaceChain(n, r), this.events.emit('chainChanged', r);
          let i = this.getProvider(n).getDefaultChain();
          t || this.getProvider(n).setDefaultChain(r),
            this.emitAccountsChangedOnChainChange({
              namespace: n,
              previousChainId: i,
              newChainId: e,
            }),
            await this.persist('namespaces', this.namespaces);
        }
        emitAccountsChangedOnChainChange({ namespace: e, previousChainId: t, newChainId: n }) {
          var r, i;
          try {
            if (t === n) return;
            let a =
              null == (i = null == (r = this.session) ? void 0 : r.namespaces[e])
                ? void 0
                : i.accounts;
            if (!a) return;
            let s = a.filter((e) => e.includes(`${n}:`)).map(hV);
            if (!lH(s)) return;
            this.events.emit('accountsChanged', s);
          } catch (e) {
            this.logger.warn('Failed to emit accountsChanged on chain change', e);
          }
        }
        updateNamespaceChain(e, t) {
          if (!this.namespaces) return;
          let n = this.namespaces[e] ? e : `${e}:${t}`;
          this.namespaces[n]
            ? this.namespaces[n] && (this.namespaces[n].defaultChain = t)
            : (this.namespaces[n] = { chains: [], methods: [], events: [], defaultChain: t });
        }
        onConnect() {
          this.createProviders(), this.events.emit('connect', { session: this.session });
        }
        async cleanup() {
          (this.namespaces = void 0),
            (this.optionalNamespaces = void 0),
            (this.sessionProperties = void 0),
            await this.deleteFromStore('namespaces'),
            await this.deleteFromStore('optionalNamespaces'),
            await this.deleteFromStore('sessionProperties'),
            (this.session = void 0),
            await this.cleanupPendingPairings({ deletePairings: !0 }),
            await this.cleanupStorage();
        }
        async persist(e, t) {
          var n;
          let r = (null == (n = this.session) ? void 0 : n.topic) || '';
          await this.client.core.storage.setItem(`${hu}/${e}${r}`, t);
        }
        async getFromStore(e) {
          var t;
          let n = (null == (t = this.session) ? void 0 : t.topic) || '';
          return await this.client.core.storage.getItem(`${hu}/${e}${n}`);
        }
        async deleteFromStore(e) {
          var t;
          let n = (null == (t = this.session) ? void 0 : t.topic) || '';
          await this.client.core.storage.removeItem(`${hu}/${e}${n}`);
        }
        async cleanupStorage() {
          var e;
          try {
            if ((null == (e = this.client) ? void 0 : e.session.length) > 0) return;
            for (let e of await this.client.core.storage.getKeys())
              e.startsWith(hu) && (await this.client.core.storage.removeItem(e));
          } catch (e) {
            this.logger.warn('Failed to cleanup storage', e);
          }
        }
      }
    },
    17421: function (e, t) {
      'use strict';
      function n(e) {
        let t;
        return 'undefined' != typeof window && void 0 !== window[e] && (t = window[e]), t;
      }
      function r(e) {
        let t = n(e);
        if (!t) throw Error(`${e} is not defined in Window`);
        return t;
      }
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.getLocalStorage =
          t.getLocalStorageOrThrow =
          t.getCrypto =
          t.getCryptoOrThrow =
          t.getLocation =
          t.getLocationOrThrow =
          t.getNavigator =
          t.getNavigatorOrThrow =
          t.getDocument =
          t.getDocumentOrThrow =
          t.getFromWindowOrThrow =
          t.getFromWindow =
            void 0),
        (t.getFromWindow = n),
        (t.getFromWindowOrThrow = r),
        (t.getDocumentOrThrow = function () {
          return r('document');
        }),
        (t.getDocument = function () {
          return n('document');
        }),
        (t.getNavigatorOrThrow = function () {
          return r('navigator');
        }),
        (t.getNavigator = function () {
          return n('navigator');
        }),
        (t.getLocationOrThrow = function () {
          return r('location');
        }),
        (t.getLocation = function () {
          return n('location');
        }),
        (t.getCryptoOrThrow = function () {
          return r('crypto');
        }),
        (t.getCrypto = function () {
          return n('crypto');
        }),
        (t.getLocalStorageOrThrow = function () {
          return r('localStorage');
        }),
        (t.getLocalStorage = function () {
          return n('localStorage');
        });
    },
    1073: function (e, t, n) {
      'use strict';
      t.D = void 0;
      let r = n(17421);
      t.D = function () {
        let e, t, n;
        try {
          (e = r.getDocumentOrThrow()), (t = r.getLocationOrThrow());
        } catch (e) {
          return null;
        }
        function i(...t) {
          let n = e.getElementsByTagName('meta');
          for (let e = 0; e < n.length; e++) {
            let r = n[e],
              i = ['itemprop', 'property', 'name']
                .map((e) => r.getAttribute(e))
                .filter((e) => !!e && t.includes(e));
            if (i.length && i) {
              let e = r.getAttribute('content');
              if (e) return e;
            }
          }
          return '';
        }
        let a = ((n = i('name', 'og:site_name', 'og:title', 'twitter:title')) || (n = e.title), n),
          s = i('description', 'og:description', 'twitter:description', 'keywords');
        return {
          description: s,
          url: t.origin,
          icons: (function () {
            let n = e.getElementsByTagName('link'),
              r = [];
            for (let e = 0; e < n.length; e++) {
              let i = n[e],
                a = i.getAttribute('rel');
              if (a && a.toLowerCase().indexOf('icon') > -1) {
                let e = i.getAttribute('href');
                if (e) {
                  if (
                    -1 === e.toLowerCase().indexOf('https:') &&
                    -1 === e.toLowerCase().indexOf('http:') &&
                    0 !== e.indexOf('//')
                  ) {
                    let n = t.protocol + '//' + t.host;
                    if (0 === e.indexOf('/')) n += e;
                    else {
                      let r = t.pathname.split('/');
                      r.pop(), (n += r.join('/') + '/' + e);
                    }
                    r.push(n);
                  } else if (0 === e.indexOf('//')) {
                    let n = t.protocol + e;
                    r.push(n);
                  } else r.push(e);
                }
              }
            }
            return r;
          })(),
          name: a,
        };
      };
    },
    35987: function (e, t) {
      'use strict';
      (t.byteLength = function (e) {
        var t = l(e),
          n = t[0],
          r = t[1];
        return ((n + r) * 3) / 4 - r;
      }),
        (t.toByteArray = function (e) {
          var t,
            n,
            a = l(e),
            s = a[0],
            o = a[1],
            u = new i(((s + o) * 3) / 4 - o),
            c = 0,
            d = o > 0 ? s - 4 : s;
          for (n = 0; n < d; n += 4)
            (t =
              (r[e.charCodeAt(n)] << 18) |
              (r[e.charCodeAt(n + 1)] << 12) |
              (r[e.charCodeAt(n + 2)] << 6) |
              r[e.charCodeAt(n + 3)]),
              (u[c++] = (t >> 16) & 255),
              (u[c++] = (t >> 8) & 255),
              (u[c++] = 255 & t);
          return (
            2 === o &&
              ((t = (r[e.charCodeAt(n)] << 2) | (r[e.charCodeAt(n + 1)] >> 4)), (u[c++] = 255 & t)),
            1 === o &&
              ((t =
                (r[e.charCodeAt(n)] << 10) |
                (r[e.charCodeAt(n + 1)] << 4) |
                (r[e.charCodeAt(n + 2)] >> 2)),
              (u[c++] = (t >> 8) & 255),
              (u[c++] = 255 & t)),
            u
          );
        }),
        (t.fromByteArray = function (e) {
          for (var t, r = e.length, i = r % 3, a = [], s = 0, o = r - i; s < o; s += 16383)
            a.push(
              (function (e, t, r) {
                for (var i, a = [], s = t; s < r; s += 3)
                  a.push(
                    n[
                      ((i =
                        ((e[s] << 16) & 16711680) + ((e[s + 1] << 8) & 65280) + (255 & e[s + 2])) >>
                        18) &
                        63
                    ] +
                      n[(i >> 12) & 63] +
                      n[(i >> 6) & 63] +
                      n[63 & i]
                  );
                return a.join('');
              })(e, s, s + 16383 > o ? o : s + 16383)
            );
          return (
            1 === i
              ? a.push(n[(t = e[r - 1]) >> 2] + n[(t << 4) & 63] + '==')
              : 2 === i &&
                a.push(
                  n[(t = (e[r - 2] << 8) + e[r - 1]) >> 10] +
                    n[(t >> 4) & 63] +
                    n[(t << 2) & 63] +
                    '='
                ),
            a.join('')
          );
        });
      for (
        var n = [],
          r = [],
          i = 'undefined' != typeof Uint8Array ? Uint8Array : Array,
          a = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
          s = 0,
          o = a.length;
        s < o;
        ++s
      )
        (n[s] = a[s]), (r[a.charCodeAt(s)] = s);
      function l(e) {
        var t = e.length;
        if (t % 4 > 0) throw Error('Invalid string. Length must be a multiple of 4');
        var n = e.indexOf('=');
        -1 === n && (n = t);
        var r = n === t ? 0 : 4 - (n % 4);
        return [n, r];
      }
      (r['-'.charCodeAt(0)] = 62), (r['_'.charCodeAt(0)] = 63);
    },
    87150: function (e, t, n) {
      'use strict';
      let r = n(35987),
        i = n(32039),
        a =
          'function' == typeof Symbol && 'function' == typeof Symbol.for
            ? Symbol.for('nodejs.util.inspect.custom')
            : null;
      function s(e) {
        if (e > 2147483647) throw RangeError('The value "' + e + '" is invalid for option "size"');
        let t = new Uint8Array(e);
        return Object.setPrototypeOf(t, o.prototype), t;
      }
      function o(e, t, n) {
        if ('number' == typeof e) {
          if ('string' == typeof t)
            throw TypeError('The "string" argument must be of type string. Received type number');
          return c(e);
        }
        return l(e, t, n);
      }
      function l(e, t, n) {
        if ('string' == typeof e)
          return (function (e, t) {
            if ((('string' != typeof t || '' === t) && (t = 'utf8'), !o.isEncoding(t)))
              throw TypeError('Unknown encoding: ' + t);
            let n = 0 | y(e, t),
              r = s(n),
              i = r.write(e, t);
            return i !== n && (r = r.slice(0, i)), r;
          })(e, t);
        if (ArrayBuffer.isView(e))
          return (function (e) {
            if (U(e, Uint8Array)) {
              let t = new Uint8Array(e);
              return p(t.buffer, t.byteOffset, t.byteLength);
            }
            return d(e);
          })(e);
        if (null == e)
          throw TypeError(
            'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
              typeof e
          );
        if (
          U(e, ArrayBuffer) ||
          (e && U(e.buffer, ArrayBuffer)) ||
          ('undefined' != typeof SharedArrayBuffer &&
            (U(e, SharedArrayBuffer) || (e && U(e.buffer, SharedArrayBuffer))))
        )
          return p(e, t, n);
        if ('number' == typeof e)
          throw TypeError('The "value" argument must not be of type number. Received type number');
        let r = e.valueOf && e.valueOf();
        if (null != r && r !== e) return o.from(r, t, n);
        let i = (function (e) {
          var t;
          if (o.isBuffer(e)) {
            let t = 0 | h(e.length),
              n = s(t);
            return 0 === n.length || e.copy(n, 0, 0, t), n;
          }
          return void 0 !== e.length
            ? 'number' != typeof e.length || (t = e.length) != t
              ? s(0)
              : d(e)
            : 'Buffer' === e.type && Array.isArray(e.data)
              ? d(e.data)
              : void 0;
        })(e);
        if (i) return i;
        if (
          'undefined' != typeof Symbol &&
          null != Symbol.toPrimitive &&
          'function' == typeof e[Symbol.toPrimitive]
        )
          return o.from(e[Symbol.toPrimitive]('string'), t, n);
        throw TypeError(
          'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
            typeof e
        );
      }
      function u(e) {
        if ('number' != typeof e) throw TypeError('"size" argument must be of type number');
        if (e < 0) throw RangeError('The value "' + e + '" is invalid for option "size"');
      }
      function c(e) {
        return u(e), s(e < 0 ? 0 : 0 | h(e));
      }
      function d(e) {
        let t = e.length < 0 ? 0 : 0 | h(e.length),
          n = s(t);
        for (let r = 0; r < t; r += 1) n[r] = 255 & e[r];
        return n;
      }
      function p(e, t, n) {
        let r;
        if (t < 0 || e.byteLength < t) throw RangeError('"offset" is outside of buffer bounds');
        if (e.byteLength < t + (n || 0)) throw RangeError('"length" is outside of buffer bounds');
        return (
          Object.setPrototypeOf(
            (r =
              void 0 === t && void 0 === n
                ? new Uint8Array(e)
                : void 0 === n
                  ? new Uint8Array(e, t)
                  : new Uint8Array(e, t, n)),
            o.prototype
          ),
          r
        );
      }
      function h(e) {
        if (e >= 2147483647)
          throw RangeError('Attempt to allocate Buffer larger than maximum size: 0x7fffffff bytes');
        return 0 | e;
      }
      function y(e, t) {
        if (o.isBuffer(e)) return e.length;
        if (ArrayBuffer.isView(e) || U(e, ArrayBuffer)) return e.byteLength;
        if ('string' != typeof e)
          throw TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
              typeof e
          );
        let n = e.length,
          r = arguments.length > 2 && !0 === arguments[2];
        if (!r && 0 === n) return 0;
        let i = !1;
        for (;;)
          switch (t) {
            case 'ascii':
            case 'latin1':
            case 'binary':
              return n;
            case 'utf8':
            case 'utf-8':
              return R(e).length;
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return 2 * n;
            case 'hex':
              return n >>> 1;
            case 'base64':
              return D(e).length;
            default:
              if (i) return r ? -1 : R(e).length;
              (t = ('' + t).toLowerCase()), (i = !0);
          }
      }
      function f(e, t, n) {
        let i = !1;
        if (
          ((void 0 === t || t < 0) && (t = 0),
          t > this.length ||
            ((void 0 === n || n > this.length) && (n = this.length),
            n <= 0 || (n >>>= 0) <= (t >>>= 0)))
        )
          return '';
        for (e || (e = 'utf8'); ; )
          switch (e) {
            case 'hex':
              return (function (e, t, n) {
                let r = e.length;
                (!t || t < 0) && (t = 0), (!n || n < 0 || n > r) && (n = r);
                let i = '';
                for (let r = t; r < n; ++r) i += L[e[r]];
                return i;
              })(this, t, n);
            case 'utf8':
            case 'utf-8':
              return w(this, t, n);
            case 'ascii':
              return (function (e, t, n) {
                let r = '';
                n = Math.min(e.length, n);
                for (let i = t; i < n; ++i) r += String.fromCharCode(127 & e[i]);
                return r;
              })(this, t, n);
            case 'latin1':
            case 'binary':
              return (function (e, t, n) {
                let r = '';
                n = Math.min(e.length, n);
                for (let i = t; i < n; ++i) r += String.fromCharCode(e[i]);
                return r;
              })(this, t, n);
            case 'base64':
              var a, s;
              return (
                (a = t),
                (s = n),
                0 === a && s === this.length
                  ? r.fromByteArray(this)
                  : r.fromByteArray(this.slice(a, s))
              );
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return (function (e, t, n) {
                let r = e.slice(t, n),
                  i = '';
                for (let e = 0; e < r.length - 1; e += 2)
                  i += String.fromCharCode(r[e] + 256 * r[e + 1]);
                return i;
              })(this, t, n);
            default:
              if (i) throw TypeError('Unknown encoding: ' + e);
              (e = (e + '').toLowerCase()), (i = !0);
          }
      }
      function m(e, t, n) {
        let r = e[t];
        (e[t] = e[n]), (e[n] = r);
      }
      function g(e, t, n, r, i) {
        var a;
        if (0 === e.length) return -1;
        if (
          ('string' == typeof n
            ? ((r = n), (n = 0))
            : n > 2147483647
              ? (n = 2147483647)
              : n < -2147483648 && (n = -2147483648),
          (a = n = +n) != a && (n = i ? 0 : e.length - 1),
          n < 0 && (n = e.length + n),
          n >= e.length)
        ) {
          if (i) return -1;
          n = e.length - 1;
        } else if (n < 0) {
          if (!i) return -1;
          n = 0;
        }
        if (('string' == typeof t && (t = o.from(t, r)), o.isBuffer(t)))
          return 0 === t.length ? -1 : b(e, t, n, r, i);
        if ('number' == typeof t)
          return ((t &= 255), 'function' == typeof Uint8Array.prototype.indexOf)
            ? i
              ? Uint8Array.prototype.indexOf.call(e, t, n)
              : Uint8Array.prototype.lastIndexOf.call(e, t, n)
            : b(e, [t], n, r, i);
        throw TypeError('val must be string, number or Buffer');
      }
      function b(e, t, n, r, i) {
        let a,
          s = 1,
          o = e.length,
          l = t.length;
        if (
          void 0 !== r &&
          ('ucs2' === (r = String(r).toLowerCase()) ||
            'ucs-2' === r ||
            'utf16le' === r ||
            'utf-16le' === r)
        ) {
          if (e.length < 2 || t.length < 2) return -1;
          (s = 2), (o /= 2), (l /= 2), (n /= 2);
        }
        function u(e, t) {
          return 1 === s ? e[t] : e.readUInt16BE(t * s);
        }
        if (i) {
          let r = -1;
          for (a = n; a < o; a++)
            if (u(e, a) === u(t, -1 === r ? 0 : a - r)) {
              if ((-1 === r && (r = a), a - r + 1 === l)) return r * s;
            } else -1 !== r && (a -= a - r), (r = -1);
        } else
          for (n + l > o && (n = o - l), a = n; a >= 0; a--) {
            let n = !0;
            for (let r = 0; r < l; r++)
              if (u(e, a + r) !== u(t, r)) {
                n = !1;
                break;
              }
            if (n) return a;
          }
        return -1;
      }
      function w(e, t, n) {
        n = Math.min(e.length, n);
        let r = [],
          i = t;
        for (; i < n; ) {
          let t = e[i],
            a = null,
            s = t > 239 ? 4 : t > 223 ? 3 : t > 191 ? 2 : 1;
          if (i + s <= n) {
            let n, r, o, l;
            switch (s) {
              case 1:
                t < 128 && (a = t);
                break;
              case 2:
                (192 & (n = e[i + 1])) == 128 && (l = ((31 & t) << 6) | (63 & n)) > 127 && (a = l);
                break;
              case 3:
                (n = e[i + 1]),
                  (r = e[i + 2]),
                  (192 & n) == 128 &&
                    (192 & r) == 128 &&
                    (l = ((15 & t) << 12) | ((63 & n) << 6) | (63 & r)) > 2047 &&
                    (l < 55296 || l > 57343) &&
                    (a = l);
                break;
              case 4:
                (n = e[i + 1]),
                  (r = e[i + 2]),
                  (o = e[i + 3]),
                  (192 & n) == 128 &&
                    (192 & r) == 128 &&
                    (192 & o) == 128 &&
                    (l = ((15 & t) << 18) | ((63 & n) << 12) | ((63 & r) << 6) | (63 & o)) >
                      65535 &&
                    l < 1114112 &&
                    (a = l);
            }
          }
          null === a
            ? ((a = 65533), (s = 1))
            : a > 65535 &&
              ((a -= 65536), r.push(((a >>> 10) & 1023) | 55296), (a = 56320 | (1023 & a))),
            r.push(a),
            (i += s);
        }
        return (function (e) {
          let t = e.length;
          if (t <= 4096) return String.fromCharCode.apply(String, e);
          let n = '',
            r = 0;
          for (; r < t; ) n += String.fromCharCode.apply(String, e.slice(r, (r += 4096)));
          return n;
        })(r);
      }
      function v(e, t, n) {
        if (e % 1 != 0 || e < 0) throw RangeError('offset is not uint');
        if (e + t > n) throw RangeError('Trying to access beyond buffer length');
      }
      function T(e, t, n, r, i, a) {
        if (!o.isBuffer(e)) throw TypeError('"buffer" argument must be a Buffer instance');
        if (t > i || t < a) throw RangeError('"value" argument is out of bounds');
        if (n + r > e.length) throw RangeError('Index out of range');
      }
      function A(e, t, n, r, i) {
        N(t, r, i, e, n, 7);
        let a = Number(t & BigInt(4294967295));
        (e[n++] = a), (a >>= 8), (e[n++] = a), (a >>= 8), (e[n++] = a), (a >>= 8), (e[n++] = a);
        let s = Number((t >> BigInt(32)) & BigInt(4294967295));
        return (
          (e[n++] = s), (s >>= 8), (e[n++] = s), (s >>= 8), (e[n++] = s), (s >>= 8), (e[n++] = s), n
        );
      }
      function E(e, t, n, r, i) {
        N(t, r, i, e, n, 7);
        let a = Number(t & BigInt(4294967295));
        (e[n + 7] = a),
          (a >>= 8),
          (e[n + 6] = a),
          (a >>= 8),
          (e[n + 5] = a),
          (a >>= 8),
          (e[n + 4] = a);
        let s = Number((t >> BigInt(32)) & BigInt(4294967295));
        return (
          (e[n + 3] = s),
          (s >>= 8),
          (e[n + 2] = s),
          (s >>= 8),
          (e[n + 1] = s),
          (s >>= 8),
          (e[n] = s),
          n + 8
        );
      }
      function C(e, t, n, r, i, a) {
        if (n + r > e.length || n < 0) throw RangeError('Index out of range');
      }
      function _(e, t, n, r, a) {
        return (
          (t = +t),
          (n >>>= 0),
          a || C(e, t, n, 4, 34028234663852886e22, -34028234663852886e22),
          i.write(e, t, n, r, 23, 4),
          n + 4
        );
      }
      function I(e, t, n, r, a) {
        return (
          (t = +t),
          (n >>>= 0),
          a || C(e, t, n, 8, 17976931348623157e292, -17976931348623157e292),
          i.write(e, t, n, r, 52, 8),
          n + 8
        );
      }
      (t.Buffer = o),
        (t.SlowBuffer = function (e) {
          return +e != e && (e = 0), o.alloc(+e);
        }),
        (t.INSPECT_MAX_BYTES = 50),
        (t.kMaxLength = 2147483647),
        (o.TYPED_ARRAY_SUPPORT = (function () {
          try {
            let e = new Uint8Array(1),
              t = {
                foo: function () {
                  return 42;
                },
              };
            return (
              Object.setPrototypeOf(t, Uint8Array.prototype),
              Object.setPrototypeOf(e, t),
              42 === e.foo()
            );
          } catch (e) {
            return !1;
          }
        })()),
        o.TYPED_ARRAY_SUPPORT ||
          'undefined' == typeof console ||
          'function' != typeof console.error ||
          console.error(
            'This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
          ),
        Object.defineProperty(o.prototype, 'parent', {
          enumerable: !0,
          get: function () {
            if (o.isBuffer(this)) return this.buffer;
          },
        }),
        Object.defineProperty(o.prototype, 'offset', {
          enumerable: !0,
          get: function () {
            if (o.isBuffer(this)) return this.byteOffset;
          },
        }),
        (o.poolSize = 8192),
        (o.from = function (e, t, n) {
          return l(e, t, n);
        }),
        Object.setPrototypeOf(o.prototype, Uint8Array.prototype),
        Object.setPrototypeOf(o, Uint8Array),
        (o.alloc = function (e, t, n) {
          return (u(e), e <= 0)
            ? s(e)
            : void 0 !== t
              ? 'string' == typeof n
                ? s(e).fill(t, n)
                : s(e).fill(t)
              : s(e);
        }),
        (o.allocUnsafe = function (e) {
          return c(e);
        }),
        (o.allocUnsafeSlow = function (e) {
          return c(e);
        }),
        (o.isBuffer = function (e) {
          return null != e && !0 === e._isBuffer && e !== o.prototype;
        }),
        (o.compare = function (e, t) {
          if (
            (U(e, Uint8Array) && (e = o.from(e, e.offset, e.byteLength)),
            U(t, Uint8Array) && (t = o.from(t, t.offset, t.byteLength)),
            !o.isBuffer(e) || !o.isBuffer(t))
          )
            throw TypeError(
              'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
            );
          if (e === t) return 0;
          let n = e.length,
            r = t.length;
          for (let i = 0, a = Math.min(n, r); i < a; ++i)
            if (e[i] !== t[i]) {
              (n = e[i]), (r = t[i]);
              break;
            }
          return n < r ? -1 : r < n ? 1 : 0;
        }),
        (o.isEncoding = function (e) {
          switch (String(e).toLowerCase()) {
            case 'hex':
            case 'utf8':
            case 'utf-8':
            case 'ascii':
            case 'latin1':
            case 'binary':
            case 'base64':
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return !0;
            default:
              return !1;
          }
        }),
        (o.concat = function (e, t) {
          let n;
          if (!Array.isArray(e)) throw TypeError('"list" argument must be an Array of Buffers');
          if (0 === e.length) return o.alloc(0);
          if (void 0 === t) for (n = 0, t = 0; n < e.length; ++n) t += e[n].length;
          let r = o.allocUnsafe(t),
            i = 0;
          for (n = 0; n < e.length; ++n) {
            let t = e[n];
            if (U(t, Uint8Array))
              i + t.length > r.length
                ? (o.isBuffer(t) || (t = o.from(t)), t.copy(r, i))
                : Uint8Array.prototype.set.call(r, t, i);
            else if (o.isBuffer(t)) t.copy(r, i);
            else throw TypeError('"list" argument must be an Array of Buffers');
            i += t.length;
          }
          return r;
        }),
        (o.byteLength = y),
        (o.prototype._isBuffer = !0),
        (o.prototype.swap16 = function () {
          let e = this.length;
          if (e % 2 != 0) throw RangeError('Buffer size must be a multiple of 16-bits');
          for (let t = 0; t < e; t += 2) m(this, t, t + 1);
          return this;
        }),
        (o.prototype.swap32 = function () {
          let e = this.length;
          if (e % 4 != 0) throw RangeError('Buffer size must be a multiple of 32-bits');
          for (let t = 0; t < e; t += 4) m(this, t, t + 3), m(this, t + 1, t + 2);
          return this;
        }),
        (o.prototype.swap64 = function () {
          let e = this.length;
          if (e % 8 != 0) throw RangeError('Buffer size must be a multiple of 64-bits');
          for (let t = 0; t < e; t += 8)
            m(this, t, t + 7), m(this, t + 1, t + 6), m(this, t + 2, t + 5), m(this, t + 3, t + 4);
          return this;
        }),
        (o.prototype.toString = function () {
          let e = this.length;
          return 0 === e ? '' : 0 == arguments.length ? w(this, 0, e) : f.apply(this, arguments);
        }),
        (o.prototype.toLocaleString = o.prototype.toString),
        (o.prototype.equals = function (e) {
          if (!o.isBuffer(e)) throw TypeError('Argument must be a Buffer');
          return this === e || 0 === o.compare(this, e);
        }),
        (o.prototype.inspect = function () {
          let e = '',
            n = t.INSPECT_MAX_BYTES;
          return (
            (e = this.toString('hex', 0, n)
              .replace(/(.{2})/g, '$1 ')
              .trim()),
            this.length > n && (e += ' ... '),
            '<Buffer ' + e + '>'
          );
        }),
        a && (o.prototype[a] = o.prototype.inspect),
        (o.prototype.compare = function (e, t, n, r, i) {
          if ((U(e, Uint8Array) && (e = o.from(e, e.offset, e.byteLength)), !o.isBuffer(e)))
            throw TypeError(
              'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
                typeof e
            );
          if (
            (void 0 === t && (t = 0),
            void 0 === n && (n = e ? e.length : 0),
            void 0 === r && (r = 0),
            void 0 === i && (i = this.length),
            t < 0 || n > e.length || r < 0 || i > this.length)
          )
            throw RangeError('out of range index');
          if (r >= i && t >= n) return 0;
          if (r >= i) return -1;
          if (t >= n) return 1;
          if (((t >>>= 0), (n >>>= 0), (r >>>= 0), (i >>>= 0), this === e)) return 0;
          let a = i - r,
            s = n - t,
            l = Math.min(a, s),
            u = this.slice(r, i),
            c = e.slice(t, n);
          for (let e = 0; e < l; ++e)
            if (u[e] !== c[e]) {
              (a = u[e]), (s = c[e]);
              break;
            }
          return a < s ? -1 : s < a ? 1 : 0;
        }),
        (o.prototype.includes = function (e, t, n) {
          return -1 !== this.indexOf(e, t, n);
        }),
        (o.prototype.indexOf = function (e, t, n) {
          return g(this, e, t, n, !0);
        }),
        (o.prototype.lastIndexOf = function (e, t, n) {
          return g(this, e, t, n, !1);
        }),
        (o.prototype.write = function (e, t, n, r) {
          var i, a, s, o, l, u, c, d;
          if (void 0 === t) (r = 'utf8'), (n = this.length), (t = 0);
          else if (void 0 === n && 'string' == typeof t) (r = t), (n = this.length), (t = 0);
          else if (isFinite(t))
            (t >>>= 0),
              isFinite(n) ? ((n >>>= 0), void 0 === r && (r = 'utf8')) : ((r = n), (n = void 0));
          else
            throw Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
          let p = this.length - t;
          if (
            ((void 0 === n || n > p) && (n = p),
            (e.length > 0 && (n < 0 || t < 0)) || t > this.length)
          )
            throw RangeError('Attempt to write outside buffer bounds');
          r || (r = 'utf8');
          let h = !1;
          for (;;)
            switch (r) {
              case 'hex':
                return (function (e, t, n, r) {
                  let i;
                  n = Number(n) || 0;
                  let a = e.length - n;
                  r ? (r = Number(r)) > a && (r = a) : (r = a);
                  let s = t.length;
                  for (r > s / 2 && (r = s / 2), i = 0; i < r; ++i) {
                    let r = parseInt(t.substr(2 * i, 2), 16);
                    if (r != r) break;
                    e[n + i] = r;
                  }
                  return i;
                })(this, e, t, n);
              case 'utf8':
              case 'utf-8':
                return (i = t), (a = n), B(R(e, this.length - i), this, i, a);
              case 'ascii':
              case 'latin1':
              case 'binary':
                return (
                  (s = t),
                  (o = n),
                  B(
                    (function (e) {
                      let t = [];
                      for (let n = 0; n < e.length; ++n) t.push(255 & e.charCodeAt(n));
                      return t;
                    })(e),
                    this,
                    s,
                    o
                  )
                );
              case 'base64':
                return (l = t), (u = n), B(D(e), this, l, u);
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return (
                  (c = t),
                  (d = n),
                  B(
                    (function (e, t) {
                      let n, r;
                      let i = [];
                      for (let a = 0; a < e.length && !((t -= 2) < 0); ++a)
                        (r = (n = e.charCodeAt(a)) >> 8), i.push(n % 256), i.push(r);
                      return i;
                    })(e, this.length - c),
                    this,
                    c,
                    d
                  )
                );
              default:
                if (h) throw TypeError('Unknown encoding: ' + r);
                (r = ('' + r).toLowerCase()), (h = !0);
            }
        }),
        (o.prototype.toJSON = function () {
          return { type: 'Buffer', data: Array.prototype.slice.call(this._arr || this, 0) };
        }),
        (o.prototype.slice = function (e, t) {
          let n = this.length;
          (e = ~~e),
            (t = void 0 === t ? n : ~~t),
            e < 0 ? (e += n) < 0 && (e = 0) : e > n && (e = n),
            t < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n),
            t < e && (t = e);
          let r = this.subarray(e, t);
          return Object.setPrototypeOf(r, o.prototype), r;
        }),
        (o.prototype.readUintLE = o.prototype.readUIntLE =
          function (e, t, n) {
            (e >>>= 0), (t >>>= 0), n || v(e, t, this.length);
            let r = this[e],
              i = 1,
              a = 0;
            for (; ++a < t && (i *= 256); ) r += this[e + a] * i;
            return r;
          }),
        (o.prototype.readUintBE = o.prototype.readUIntBE =
          function (e, t, n) {
            (e >>>= 0), (t >>>= 0), n || v(e, t, this.length);
            let r = this[e + --t],
              i = 1;
            for (; t > 0 && (i *= 256); ) r += this[e + --t] * i;
            return r;
          }),
        (o.prototype.readUint8 = o.prototype.readUInt8 =
          function (e, t) {
            return (e >>>= 0), t || v(e, 1, this.length), this[e];
          }),
        (o.prototype.readUint16LE = o.prototype.readUInt16LE =
          function (e, t) {
            return (e >>>= 0), t || v(e, 2, this.length), this[e] | (this[e + 1] << 8);
          }),
        (o.prototype.readUint16BE = o.prototype.readUInt16BE =
          function (e, t) {
            return (e >>>= 0), t || v(e, 2, this.length), (this[e] << 8) | this[e + 1];
          }),
        (o.prototype.readUint32LE = o.prototype.readUInt32LE =
          function (e, t) {
            return (
              (e >>>= 0),
              t || v(e, 4, this.length),
              (this[e] | (this[e + 1] << 8) | (this[e + 2] << 16)) + 16777216 * this[e + 3]
            );
          }),
        (o.prototype.readUint32BE = o.prototype.readUInt32BE =
          function (e, t) {
            return (
              (e >>>= 0),
              t || v(e, 4, this.length),
              16777216 * this[e] + ((this[e + 1] << 16) | (this[e + 2] << 8) | this[e + 3])
            );
          }),
        (o.prototype.readBigUInt64LE = F(function (e) {
          x((e >>>= 0), 'offset');
          let t = this[e],
            n = this[e + 7];
          (void 0 === t || void 0 === n) && M(e, this.length - 8);
          let r = t + 256 * this[++e] + 65536 * this[++e] + 16777216 * this[++e],
            i = this[++e] + 256 * this[++e] + 65536 * this[++e] + 16777216 * n;
          return BigInt(r) + (BigInt(i) << BigInt(32));
        })),
        (o.prototype.readBigUInt64BE = F(function (e) {
          x((e >>>= 0), 'offset');
          let t = this[e],
            n = this[e + 7];
          (void 0 === t || void 0 === n) && M(e, this.length - 8);
          let r = 16777216 * t + 65536 * this[++e] + 256 * this[++e] + this[++e],
            i = 16777216 * this[++e] + 65536 * this[++e] + 256 * this[++e] + n;
          return (BigInt(r) << BigInt(32)) + BigInt(i);
        })),
        (o.prototype.readIntLE = function (e, t, n) {
          (e >>>= 0), (t >>>= 0), n || v(e, t, this.length);
          let r = this[e],
            i = 1,
            a = 0;
          for (; ++a < t && (i *= 256); ) r += this[e + a] * i;
          return r >= (i *= 128) && (r -= Math.pow(2, 8 * t)), r;
        }),
        (o.prototype.readIntBE = function (e, t, n) {
          (e >>>= 0), (t >>>= 0), n || v(e, t, this.length);
          let r = t,
            i = 1,
            a = this[e + --r];
          for (; r > 0 && (i *= 256); ) a += this[e + --r] * i;
          return a >= (i *= 128) && (a -= Math.pow(2, 8 * t)), a;
        }),
        (o.prototype.readInt8 = function (e, t) {
          return ((e >>>= 0), t || v(e, 1, this.length), 128 & this[e])
            ? -((255 - this[e] + 1) * 1)
            : this[e];
        }),
        (o.prototype.readInt16LE = function (e, t) {
          (e >>>= 0), t || v(e, 2, this.length);
          let n = this[e] | (this[e + 1] << 8);
          return 32768 & n ? 4294901760 | n : n;
        }),
        (o.prototype.readInt16BE = function (e, t) {
          (e >>>= 0), t || v(e, 2, this.length);
          let n = this[e + 1] | (this[e] << 8);
          return 32768 & n ? 4294901760 | n : n;
        }),
        (o.prototype.readInt32LE = function (e, t) {
          return (
            (e >>>= 0),
            t || v(e, 4, this.length),
            this[e] | (this[e + 1] << 8) | (this[e + 2] << 16) | (this[e + 3] << 24)
          );
        }),
        (o.prototype.readInt32BE = function (e, t) {
          return (
            (e >>>= 0),
            t || v(e, 4, this.length),
            (this[e] << 24) | (this[e + 1] << 16) | (this[e + 2] << 8) | this[e + 3]
          );
        }),
        (o.prototype.readBigInt64LE = F(function (e) {
          x((e >>>= 0), 'offset');
          let t = this[e],
            n = this[e + 7];
          return (
            (void 0 === t || void 0 === n) && M(e, this.length - 8),
            (BigInt(this[e + 4] + 256 * this[e + 5] + 65536 * this[e + 6] + (n << 24)) <<
              BigInt(32)) +
              BigInt(t + 256 * this[++e] + 65536 * this[++e] + 16777216 * this[++e])
          );
        })),
        (o.prototype.readBigInt64BE = F(function (e) {
          x((e >>>= 0), 'offset');
          let t = this[e],
            n = this[e + 7];
          return (
            (void 0 === t || void 0 === n) && M(e, this.length - 8),
            (BigInt((t << 24) + 65536 * this[++e] + 256 * this[++e] + this[++e]) << BigInt(32)) +
              BigInt(16777216 * this[++e] + 65536 * this[++e] + 256 * this[++e] + n)
          );
        })),
        (o.prototype.readFloatLE = function (e, t) {
          return (e >>>= 0), t || v(e, 4, this.length), i.read(this, e, !0, 23, 4);
        }),
        (o.prototype.readFloatBE = function (e, t) {
          return (e >>>= 0), t || v(e, 4, this.length), i.read(this, e, !1, 23, 4);
        }),
        (o.prototype.readDoubleLE = function (e, t) {
          return (e >>>= 0), t || v(e, 8, this.length), i.read(this, e, !0, 52, 8);
        }),
        (o.prototype.readDoubleBE = function (e, t) {
          return (e >>>= 0), t || v(e, 8, this.length), i.read(this, e, !1, 52, 8);
        }),
        (o.prototype.writeUintLE = o.prototype.writeUIntLE =
          function (e, t, n, r) {
            if (((e = +e), (t >>>= 0), (n >>>= 0), !r)) {
              let r = Math.pow(2, 8 * n) - 1;
              T(this, e, t, n, r, 0);
            }
            let i = 1,
              a = 0;
            for (this[t] = 255 & e; ++a < n && (i *= 256); ) this[t + a] = (e / i) & 255;
            return t + n;
          }),
        (o.prototype.writeUintBE = o.prototype.writeUIntBE =
          function (e, t, n, r) {
            if (((e = +e), (t >>>= 0), (n >>>= 0), !r)) {
              let r = Math.pow(2, 8 * n) - 1;
              T(this, e, t, n, r, 0);
            }
            let i = n - 1,
              a = 1;
            for (this[t + i] = 255 & e; --i >= 0 && (a *= 256); ) this[t + i] = (e / a) & 255;
            return t + n;
          }),
        (o.prototype.writeUint8 = o.prototype.writeUInt8 =
          function (e, t, n) {
            return (e = +e), (t >>>= 0), n || T(this, e, t, 1, 255, 0), (this[t] = 255 & e), t + 1;
          }),
        (o.prototype.writeUint16LE = o.prototype.writeUInt16LE =
          function (e, t, n) {
            return (
              (e = +e),
              (t >>>= 0),
              n || T(this, e, t, 2, 65535, 0),
              (this[t] = 255 & e),
              (this[t + 1] = e >>> 8),
              t + 2
            );
          }),
        (o.prototype.writeUint16BE = o.prototype.writeUInt16BE =
          function (e, t, n) {
            return (
              (e = +e),
              (t >>>= 0),
              n || T(this, e, t, 2, 65535, 0),
              (this[t] = e >>> 8),
              (this[t + 1] = 255 & e),
              t + 2
            );
          }),
        (o.prototype.writeUint32LE = o.prototype.writeUInt32LE =
          function (e, t, n) {
            return (
              (e = +e),
              (t >>>= 0),
              n || T(this, e, t, 4, 4294967295, 0),
              (this[t + 3] = e >>> 24),
              (this[t + 2] = e >>> 16),
              (this[t + 1] = e >>> 8),
              (this[t] = 255 & e),
              t + 4
            );
          }),
        (o.prototype.writeUint32BE = o.prototype.writeUInt32BE =
          function (e, t, n) {
            return (
              (e = +e),
              (t >>>= 0),
              n || T(this, e, t, 4, 4294967295, 0),
              (this[t] = e >>> 24),
              (this[t + 1] = e >>> 16),
              (this[t + 2] = e >>> 8),
              (this[t + 3] = 255 & e),
              t + 4
            );
          }),
        (o.prototype.writeBigUInt64LE = F(function (e, t = 0) {
          return A(this, e, t, BigInt(0), BigInt('0xffffffffffffffff'));
        })),
        (o.prototype.writeBigUInt64BE = F(function (e, t = 0) {
          return E(this, e, t, BigInt(0), BigInt('0xffffffffffffffff'));
        })),
        (o.prototype.writeIntLE = function (e, t, n, r) {
          if (((e = +e), (t >>>= 0), !r)) {
            let r = Math.pow(2, 8 * n - 1);
            T(this, e, t, n, r - 1, -r);
          }
          let i = 0,
            a = 1,
            s = 0;
          for (this[t] = 255 & e; ++i < n && (a *= 256); )
            e < 0 && 0 === s && 0 !== this[t + i - 1] && (s = 1),
              (this[t + i] = (((e / a) >> 0) - s) & 255);
          return t + n;
        }),
        (o.prototype.writeIntBE = function (e, t, n, r) {
          if (((e = +e), (t >>>= 0), !r)) {
            let r = Math.pow(2, 8 * n - 1);
            T(this, e, t, n, r - 1, -r);
          }
          let i = n - 1,
            a = 1,
            s = 0;
          for (this[t + i] = 255 & e; --i >= 0 && (a *= 256); )
            e < 0 && 0 === s && 0 !== this[t + i + 1] && (s = 1),
              (this[t + i] = (((e / a) >> 0) - s) & 255);
          return t + n;
        }),
        (o.prototype.writeInt8 = function (e, t, n) {
          return (
            (e = +e),
            (t >>>= 0),
            n || T(this, e, t, 1, 127, -128),
            e < 0 && (e = 255 + e + 1),
            (this[t] = 255 & e),
            t + 1
          );
        }),
        (o.prototype.writeInt16LE = function (e, t, n) {
          return (
            (e = +e),
            (t >>>= 0),
            n || T(this, e, t, 2, 32767, -32768),
            (this[t] = 255 & e),
            (this[t + 1] = e >>> 8),
            t + 2
          );
        }),
        (o.prototype.writeInt16BE = function (e, t, n) {
          return (
            (e = +e),
            (t >>>= 0),
            n || T(this, e, t, 2, 32767, -32768),
            (this[t] = e >>> 8),
            (this[t + 1] = 255 & e),
            t + 2
          );
        }),
        (o.prototype.writeInt32LE = function (e, t, n) {
          return (
            (e = +e),
            (t >>>= 0),
            n || T(this, e, t, 4, 2147483647, -2147483648),
            (this[t] = 255 & e),
            (this[t + 1] = e >>> 8),
            (this[t + 2] = e >>> 16),
            (this[t + 3] = e >>> 24),
            t + 4
          );
        }),
        (o.prototype.writeInt32BE = function (e, t, n) {
          return (
            (e = +e),
            (t >>>= 0),
            n || T(this, e, t, 4, 2147483647, -2147483648),
            e < 0 && (e = 4294967295 + e + 1),
            (this[t] = e >>> 24),
            (this[t + 1] = e >>> 16),
            (this[t + 2] = e >>> 8),
            (this[t + 3] = 255 & e),
            t + 4
          );
        }),
        (o.prototype.writeBigInt64LE = F(function (e, t = 0) {
          return A(this, e, t, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
        })),
        (o.prototype.writeBigInt64BE = F(function (e, t = 0) {
          return E(this, e, t, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
        })),
        (o.prototype.writeFloatLE = function (e, t, n) {
          return _(this, e, t, !0, n);
        }),
        (o.prototype.writeFloatBE = function (e, t, n) {
          return _(this, e, t, !1, n);
        }),
        (o.prototype.writeDoubleLE = function (e, t, n) {
          return I(this, e, t, !0, n);
        }),
        (o.prototype.writeDoubleBE = function (e, t, n) {
          return I(this, e, t, !1, n);
        }),
        (o.prototype.copy = function (e, t, n, r) {
          if (!o.isBuffer(e)) throw TypeError('argument should be a Buffer');
          if (
            (n || (n = 0),
            r || 0 === r || (r = this.length),
            t >= e.length && (t = e.length),
            t || (t = 0),
            r > 0 && r < n && (r = n),
            r === n || 0 === e.length || 0 === this.length)
          )
            return 0;
          if (t < 0) throw RangeError('targetStart out of bounds');
          if (n < 0 || n >= this.length) throw RangeError('Index out of range');
          if (r < 0) throw RangeError('sourceEnd out of bounds');
          r > this.length && (r = this.length), e.length - t < r - n && (r = e.length - t + n);
          let i = r - n;
          return (
            this === e && 'function' == typeof Uint8Array.prototype.copyWithin
              ? this.copyWithin(t, n, r)
              : Uint8Array.prototype.set.call(e, this.subarray(n, r), t),
            i
          );
        }),
        (o.prototype.fill = function (e, t, n, r) {
          let i;
          if ('string' == typeof e) {
            if (
              ('string' == typeof t
                ? ((r = t), (t = 0), (n = this.length))
                : 'string' == typeof n && ((r = n), (n = this.length)),
              void 0 !== r && 'string' != typeof r)
            )
              throw TypeError('encoding must be a string');
            if ('string' == typeof r && !o.isEncoding(r)) throw TypeError('Unknown encoding: ' + r);
            if (1 === e.length) {
              let t = e.charCodeAt(0);
              (('utf8' === r && t < 128) || 'latin1' === r) && (e = t);
            }
          } else 'number' == typeof e ? (e &= 255) : 'boolean' == typeof e && (e = Number(e));
          if (t < 0 || this.length < t || this.length < n) throw RangeError('Out of range index');
          if (n <= t) return this;
          if (
            ((t >>>= 0),
            (n = void 0 === n ? this.length : n >>> 0),
            e || (e = 0),
            'number' == typeof e)
          )
            for (i = t; i < n; ++i) this[i] = e;
          else {
            let a = o.isBuffer(e) ? e : o.from(e, r),
              s = a.length;
            if (0 === s) throw TypeError('The value "' + e + '" is invalid for argument "value"');
            for (i = 0; i < n - t; ++i) this[i + t] = a[i % s];
          }
          return this;
        });
      let S = {};
      function P(e, t, n) {
        S[e] = class extends n {
          constructor() {
            super(),
              Object.defineProperty(this, 'message', {
                value: t.apply(this, arguments),
                writable: !0,
                configurable: !0,
              }),
              (this.name = `${this.name} [${e}]`),
              this.stack,
              delete this.name;
          }
          get code() {
            return e;
          }
          set code(e) {
            Object.defineProperty(this, 'code', {
              configurable: !0,
              enumerable: !0,
              value: e,
              writable: !0,
            });
          }
          toString() {
            return `${this.name} [${e}]: ${this.message}`;
          }
        };
      }
      function O(e) {
        let t = '',
          n = e.length,
          r = '-' === e[0] ? 1 : 0;
        for (; n >= r + 4; n -= 3) t = `_${e.slice(n - 3, n)}${t}`;
        return `${e.slice(0, n)}${t}`;
      }
      function N(e, t, n, r, i, a) {
        if (e > n || e < t) {
          let r;
          let i = 'bigint' == typeof t ? 'n' : '';
          throw (
            ((r =
              a > 3
                ? 0 === t || t === BigInt(0)
                  ? `>= 0${i} and < 2${i} ** ${(a + 1) * 8}${i}`
                  : `>= -(2${i} ** ${(a + 1) * 8 - 1}${i}) and < 2 ** ${(a + 1) * 8 - 1}${i}`
                : `>= ${t}${i} and <= ${n}${i}`),
            new S.ERR_OUT_OF_RANGE('value', r, e))
          );
        }
        x(i, 'offset'), (void 0 === r[i] || void 0 === r[i + a]) && M(i, r.length - (a + 1));
      }
      function x(e, t) {
        if ('number' != typeof e) throw new S.ERR_INVALID_ARG_TYPE(t, 'number', e);
      }
      function M(e, t, n) {
        if (Math.floor(e) !== e)
          throw (x(e, n), new S.ERR_OUT_OF_RANGE(n || 'offset', 'an integer', e));
        if (t < 0) throw new S.ERR_BUFFER_OUT_OF_BOUNDS();
        throw new S.ERR_OUT_OF_RANGE(n || 'offset', `>= ${n ? 1 : 0} and <= ${t}`, e);
      }
      P(
        'ERR_BUFFER_OUT_OF_BOUNDS',
        function (e) {
          return e
            ? `${e} is outside of buffer bounds`
            : 'Attempt to access memory outside buffer bounds';
        },
        RangeError
      ),
        P(
          'ERR_INVALID_ARG_TYPE',
          function (e, t) {
            return `The "${e}" argument must be of type number. Received type ${typeof t}`;
          },
          TypeError
        ),
        P(
          'ERR_OUT_OF_RANGE',
          function (e, t, n) {
            let r = `The value of "${e}" is out of range.`,
              i = n;
            return (
              Number.isInteger(n) && Math.abs(n) > 4294967296
                ? (i = O(String(n)))
                : 'bigint' == typeof n &&
                  ((i = String(n)),
                  (n > BigInt(2) ** BigInt(32) || n < -(BigInt(2) ** BigInt(32))) && (i = O(i)),
                  (i += 'n')),
              (r += ` It must be ${t}. Received ${i}`)
            );
          },
          RangeError
        );
      let k = /[^+/0-9A-Za-z-_]/g;
      function R(e, t) {
        let n;
        t = t || 1 / 0;
        let r = e.length,
          i = null,
          a = [];
        for (let s = 0; s < r; ++s) {
          if ((n = e.charCodeAt(s)) > 55295 && n < 57344) {
            if (!i) {
              if (n > 56319 || s + 1 === r) {
                (t -= 3) > -1 && a.push(239, 191, 189);
                continue;
              }
              i = n;
              continue;
            }
            if (n < 56320) {
              (t -= 3) > -1 && a.push(239, 191, 189), (i = n);
              continue;
            }
            n = (((i - 55296) << 10) | (n - 56320)) + 65536;
          } else i && (t -= 3) > -1 && a.push(239, 191, 189);
          if (((i = null), n < 128)) {
            if ((t -= 1) < 0) break;
            a.push(n);
          } else if (n < 2048) {
            if ((t -= 2) < 0) break;
            a.push((n >> 6) | 192, (63 & n) | 128);
          } else if (n < 65536) {
            if ((t -= 3) < 0) break;
            a.push((n >> 12) | 224, ((n >> 6) & 63) | 128, (63 & n) | 128);
          } else if (n < 1114112) {
            if ((t -= 4) < 0) break;
            a.push((n >> 18) | 240, ((n >> 12) & 63) | 128, ((n >> 6) & 63) | 128, (63 & n) | 128);
          } else throw Error('Invalid code point');
        }
        return a;
      }
      function D(e) {
        return r.toByteArray(
          (function (e) {
            if ((e = (e = e.split('=')[0]).trim().replace(k, '')).length < 2) return '';
            for (; e.length % 4 != 0; ) e += '=';
            return e;
          })(e)
        );
      }
      function B(e, t, n, r) {
        let i;
        for (i = 0; i < r && !(i + n >= t.length) && !(i >= e.length); ++i) t[i + n] = e[i];
        return i;
      }
      function U(e, t) {
        return (
          e instanceof t ||
          (null != e &&
            null != e.constructor &&
            null != e.constructor.name &&
            e.constructor.name === t.name)
        );
      }
      let L = (function () {
        let e = '0123456789abcdef',
          t = Array(256);
        for (let n = 0; n < 16; ++n) {
          let r = 16 * n;
          for (let i = 0; i < 16; ++i) t[r + i] = e[n] + e[i];
        }
        return t;
      })();
      function F(e) {
        return 'undefined' == typeof BigInt ? j : e;
      }
      function j() {
        throw Error('BigInt not supported');
      }
    },
    19896: function (e, t, n) {
      var r =
          ('undefined' != typeof globalThis && globalThis) ||
          ('undefined' != typeof self && self) ||
          (void 0 !== n.g && n.g),
        i = (function () {
          function e() {
            (this.fetch = !1), (this.DOMException = r.DOMException);
          }
          return (e.prototype = r), new e();
        })();
      (function (e) {
        var t =
            (void 0 !== i && i) ||
            ('undefined' != typeof self && self) ||
            (void 0 !== n.g && n.g) ||
            {},
          r = {
            searchParams: 'URLSearchParams' in t,
            iterable: 'Symbol' in t && 'iterator' in Symbol,
            blob:
              'FileReader' in t &&
              'Blob' in t &&
              (function () {
                try {
                  return new Blob(), !0;
                } catch (e) {
                  return !1;
                }
              })(),
            formData: 'FormData' in t,
            arrayBuffer: 'ArrayBuffer' in t,
          };
        if (r.arrayBuffer)
          var a = [
              '[object Int8Array]',
              '[object Uint8Array]',
              '[object Uint8ClampedArray]',
              '[object Int16Array]',
              '[object Uint16Array]',
              '[object Int32Array]',
              '[object Uint32Array]',
              '[object Float32Array]',
              '[object Float64Array]',
            ],
            s =
              ArrayBuffer.isView ||
              function (e) {
                return e && a.indexOf(Object.prototype.toString.call(e)) > -1;
              };
        function o(e) {
          if (
            ('string' != typeof e && (e = String(e)),
            /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(e) || '' === e)
          )
            throw TypeError('Invalid character in header field name: "' + e + '"');
          return e.toLowerCase();
        }
        function l(e) {
          return 'string' != typeof e && (e = String(e)), e;
        }
        function u(e) {
          var t = {
            next: function () {
              var t = e.shift();
              return { done: void 0 === t, value: t };
            },
          };
          return (
            r.iterable &&
              (t[Symbol.iterator] = function () {
                return t;
              }),
            t
          );
        }
        function c(e) {
          (this.map = {}),
            e instanceof c
              ? e.forEach(function (e, t) {
                  this.append(t, e);
                }, this)
              : Array.isArray(e)
                ? e.forEach(function (e) {
                    if (2 != e.length)
                      throw TypeError(
                        'Headers constructor: expected name/value pair to be length 2, found' +
                          e.length
                      );
                    this.append(e[0], e[1]);
                  }, this)
                : e &&
                  Object.getOwnPropertyNames(e).forEach(function (t) {
                    this.append(t, e[t]);
                  }, this);
        }
        function d(e) {
          if (!e._noBody) {
            if (e.bodyUsed) return Promise.reject(TypeError('Already read'));
            e.bodyUsed = !0;
          }
        }
        function p(e) {
          return new Promise(function (t, n) {
            (e.onload = function () {
              t(e.result);
            }),
              (e.onerror = function () {
                n(e.error);
              });
          });
        }
        function h(e) {
          var t = new FileReader(),
            n = p(t);
          return t.readAsArrayBuffer(e), n;
        }
        function y(e) {
          if (e.slice) return e.slice(0);
          var t = new Uint8Array(e.byteLength);
          return t.set(new Uint8Array(e)), t.buffer;
        }
        function f() {
          return (
            (this.bodyUsed = !1),
            (this._initBody = function (e) {
              if (((this.bodyUsed = this.bodyUsed), (this._bodyInit = e), e)) {
                if ('string' == typeof e) this._bodyText = e;
                else if (r.blob && Blob.prototype.isPrototypeOf(e)) this._bodyBlob = e;
                else if (r.formData && FormData.prototype.isPrototypeOf(e)) this._bodyFormData = e;
                else if (r.searchParams && URLSearchParams.prototype.isPrototypeOf(e))
                  this._bodyText = e.toString();
                else {
                  var t;
                  r.arrayBuffer && r.blob && (t = e) && DataView.prototype.isPrototypeOf(t)
                    ? ((this._bodyArrayBuffer = y(e.buffer)),
                      (this._bodyInit = new Blob([this._bodyArrayBuffer])))
                    : r.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(e) || s(e))
                      ? (this._bodyArrayBuffer = y(e))
                      : (this._bodyText = e = Object.prototype.toString.call(e));
                }
              } else (this._noBody = !0), (this._bodyText = '');
              !this.headers.get('content-type') &&
                ('string' == typeof e
                  ? this.headers.set('content-type', 'text/plain;charset=UTF-8')
                  : this._bodyBlob && this._bodyBlob.type
                    ? this.headers.set('content-type', this._bodyBlob.type)
                    : r.searchParams &&
                      URLSearchParams.prototype.isPrototypeOf(e) &&
                      this.headers.set(
                        'content-type',
                        'application/x-www-form-urlencoded;charset=UTF-8'
                      ));
            }),
            r.blob &&
              (this.blob = function () {
                var e = d(this);
                if (e) return e;
                if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                if (this._bodyArrayBuffer)
                  return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                if (!this._bodyFormData) return Promise.resolve(new Blob([this._bodyText]));
                throw Error('could not read FormData body as blob');
              }),
            (this.arrayBuffer = function () {
              if (this._bodyArrayBuffer)
                return (
                  d(this) ||
                  (ArrayBuffer.isView(this._bodyArrayBuffer)
                    ? Promise.resolve(
                        this._bodyArrayBuffer.buffer.slice(
                          this._bodyArrayBuffer.byteOffset,
                          this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                        )
                      )
                    : Promise.resolve(this._bodyArrayBuffer))
                );
              if (r.blob) return this.blob().then(h);
              throw Error('could not read as ArrayBuffer');
            }),
            (this.text = function () {
              var e,
                t,
                n,
                r,
                i,
                a = d(this);
              if (a) return a;
              if (this._bodyBlob)
                return (
                  (e = this._bodyBlob),
                  (n = p((t = new FileReader()))),
                  (i = (r = /charset=([A-Za-z0-9_-]+)/.exec(e.type)) ? r[1] : 'utf-8'),
                  t.readAsText(e, i),
                  n
                );
              if (this._bodyArrayBuffer)
                return Promise.resolve(
                  (function (e) {
                    for (var t = new Uint8Array(e), n = Array(t.length), r = 0; r < t.length; r++)
                      n[r] = String.fromCharCode(t[r]);
                    return n.join('');
                  })(this._bodyArrayBuffer)
                );
              if (!this._bodyFormData) return Promise.resolve(this._bodyText);
              throw Error('could not read FormData body as text');
            }),
            r.formData &&
              (this.formData = function () {
                return this.text().then(b);
              }),
            (this.json = function () {
              return this.text().then(JSON.parse);
            }),
            this
          );
        }
        (c.prototype.append = function (e, t) {
          (e = o(e)), (t = l(t));
          var n = this.map[e];
          this.map[e] = n ? n + ', ' + t : t;
        }),
          (c.prototype.delete = function (e) {
            delete this.map[o(e)];
          }),
          (c.prototype.get = function (e) {
            return (e = o(e)), this.has(e) ? this.map[e] : null;
          }),
          (c.prototype.has = function (e) {
            return this.map.hasOwnProperty(o(e));
          }),
          (c.prototype.set = function (e, t) {
            this.map[o(e)] = l(t);
          }),
          (c.prototype.forEach = function (e, t) {
            for (var n in this.map) this.map.hasOwnProperty(n) && e.call(t, this.map[n], n, this);
          }),
          (c.prototype.keys = function () {
            var e = [];
            return (
              this.forEach(function (t, n) {
                e.push(n);
              }),
              u(e)
            );
          }),
          (c.prototype.values = function () {
            var e = [];
            return (
              this.forEach(function (t) {
                e.push(t);
              }),
              u(e)
            );
          }),
          (c.prototype.entries = function () {
            var e = [];
            return (
              this.forEach(function (t, n) {
                e.push([n, t]);
              }),
              u(e)
            );
          }),
          r.iterable && (c.prototype[Symbol.iterator] = c.prototype.entries);
        var m = ['CONNECT', 'DELETE', 'GET', 'HEAD', 'OPTIONS', 'PATCH', 'POST', 'PUT', 'TRACE'];
        function g(e, n) {
          if (!(this instanceof g))
            throw TypeError(
              'Please use the "new" operator, this DOM object constructor cannot be called as a function.'
            );
          var r,
            i,
            a = (n = n || {}).body;
          if (e instanceof g) {
            if (e.bodyUsed) throw TypeError('Already read');
            (this.url = e.url),
              (this.credentials = e.credentials),
              n.headers || (this.headers = new c(e.headers)),
              (this.method = e.method),
              (this.mode = e.mode),
              (this.signal = e.signal),
              a || null == e._bodyInit || ((a = e._bodyInit), (e.bodyUsed = !0));
          } else this.url = String(e);
          if (
            ((this.credentials = n.credentials || this.credentials || 'same-origin'),
            (n.headers || !this.headers) && (this.headers = new c(n.headers)),
            (this.method =
              ((i = (r = n.method || this.method || 'GET').toUpperCase()),
              m.indexOf(i) > -1 ? i : r)),
            (this.mode = n.mode || this.mode || null),
            (this.signal =
              n.signal ||
              this.signal ||
              (function () {
                if ('AbortController' in t) return new AbortController().signal;
              })()),
            (this.referrer = null),
            ('GET' === this.method || 'HEAD' === this.method) && a)
          )
            throw TypeError('Body not allowed for GET or HEAD requests');
          if (
            (this._initBody(a),
            ('GET' === this.method || 'HEAD' === this.method) &&
              ('no-store' === n.cache || 'no-cache' === n.cache))
          ) {
            var s = /([?&])_=[^&]*/;
            s.test(this.url)
              ? (this.url = this.url.replace(s, '$1_=' + new Date().getTime()))
              : (this.url += (/\?/.test(this.url) ? '&' : '?') + '_=' + new Date().getTime());
          }
        }
        function b(e) {
          var t = new FormData();
          return (
            e
              .trim()
              .split('&')
              .forEach(function (e) {
                if (e) {
                  var n = e.split('='),
                    r = n.shift().replace(/\+/g, ' '),
                    i = n.join('=').replace(/\+/g, ' ');
                  t.append(decodeURIComponent(r), decodeURIComponent(i));
                }
              }),
            t
          );
        }
        function w(e, t) {
          if (!(this instanceof w))
            throw TypeError(
              'Please use the "new" operator, this DOM object constructor cannot be called as a function.'
            );
          if (
            (t || (t = {}),
            (this.type = 'default'),
            (this.status = void 0 === t.status ? 200 : t.status),
            this.status < 200 || this.status > 599)
          )
            throw RangeError(
              "Failed to construct 'Response': The status provided (0) is outside the range [200, 599]."
            );
          (this.ok = this.status >= 200 && this.status < 300),
            (this.statusText = void 0 === t.statusText ? '' : '' + t.statusText),
            (this.headers = new c(t.headers)),
            (this.url = t.url || ''),
            this._initBody(e);
        }
        (g.prototype.clone = function () {
          return new g(this, { body: this._bodyInit });
        }),
          f.call(g.prototype),
          f.call(w.prototype),
          (w.prototype.clone = function () {
            return new w(this._bodyInit, {
              status: this.status,
              statusText: this.statusText,
              headers: new c(this.headers),
              url: this.url,
            });
          }),
          (w.error = function () {
            var e = new w(null, { status: 200, statusText: '' });
            return (e.ok = !1), (e.status = 0), (e.type = 'error'), e;
          });
        var v = [301, 302, 303, 307, 308];
        (w.redirect = function (e, t) {
          if (-1 === v.indexOf(t)) throw RangeError('Invalid status code');
          return new w(null, { status: t, headers: { location: e } });
        }),
          (e.DOMException = t.DOMException);
        try {
          new e.DOMException();
        } catch (t) {
          (e.DOMException = function (e, t) {
            (this.message = e), (this.name = t);
            var n = Error(e);
            this.stack = n.stack;
          }),
            (e.DOMException.prototype = Object.create(Error.prototype)),
            (e.DOMException.prototype.constructor = e.DOMException);
        }
        function T(n, i) {
          return new Promise(function (a, s) {
            var u = new g(n, i);
            if (u.signal && u.signal.aborted) return s(new e.DOMException('Aborted', 'AbortError'));
            var d = new XMLHttpRequest();
            function p() {
              d.abort();
            }
            if (
              ((d.onload = function () {
                var e,
                  t,
                  n = {
                    statusText: d.statusText,
                    headers:
                      ((e = d.getAllResponseHeaders() || ''),
                      (t = new c()),
                      e
                        .replace(/\r?\n[\t ]+/g, ' ')
                        .split('\r')
                        .map(function (e) {
                          return 0 === e.indexOf('\n') ? e.substr(1, e.length) : e;
                        })
                        .forEach(function (e) {
                          var n = e.split(':'),
                            r = n.shift().trim();
                          if (r) {
                            var i = n.join(':').trim();
                            try {
                              t.append(r, i);
                            } catch (e) {
                              console.warn('Response ' + e.message);
                            }
                          }
                        }),
                      t),
                  };
                0 === u.url.indexOf('file://') && (d.status < 200 || d.status > 599)
                  ? (n.status = 200)
                  : (n.status = d.status),
                  (n.url = 'responseURL' in d ? d.responseURL : n.headers.get('X-Request-URL'));
                var r = 'response' in d ? d.response : d.responseText;
                setTimeout(function () {
                  a(new w(r, n));
                }, 0);
              }),
              (d.onerror = function () {
                setTimeout(function () {
                  s(TypeError('Network request failed'));
                }, 0);
              }),
              (d.ontimeout = function () {
                setTimeout(function () {
                  s(TypeError('Network request timed out'));
                }, 0);
              }),
              (d.onabort = function () {
                setTimeout(function () {
                  s(new e.DOMException('Aborted', 'AbortError'));
                }, 0);
              }),
              d.open(
                u.method,
                (function (e) {
                  try {
                    return '' === e && t.location.href ? t.location.href : e;
                  } catch (t) {
                    return e;
                  }
                })(u.url),
                !0
              ),
              'include' === u.credentials
                ? (d.withCredentials = !0)
                : 'omit' === u.credentials && (d.withCredentials = !1),
              'responseType' in d &&
                (r.blob
                  ? (d.responseType = 'blob')
                  : r.arrayBuffer && (d.responseType = 'arraybuffer')),
              i &&
                'object' == typeof i.headers &&
                !(i.headers instanceof c || (t.Headers && i.headers instanceof t.Headers)))
            ) {
              var h = [];
              Object.getOwnPropertyNames(i.headers).forEach(function (e) {
                h.push(o(e)), d.setRequestHeader(e, l(i.headers[e]));
              }),
                u.headers.forEach(function (e, t) {
                  -1 === h.indexOf(t) && d.setRequestHeader(t, e);
                });
            } else
              u.headers.forEach(function (e, t) {
                d.setRequestHeader(t, e);
              });
            u.signal &&
              (u.signal.addEventListener('abort', p),
              (d.onreadystatechange = function () {
                4 === d.readyState && u.signal.removeEventListener('abort', p);
              })),
              d.send(void 0 === u._bodyInit ? null : u._bodyInit);
          });
        }
        (T.polyfill = !0),
          t.fetch || ((t.fetch = T), (t.Headers = c), (t.Request = g), (t.Response = w)),
          (e.Headers = c),
          (e.Request = g),
          (e.Response = w),
          (e.fetch = T),
          Object.defineProperty(e, '__esModule', { value: !0 });
      })({}),
        (i.fetch.ponyfill = !0),
        delete i.fetch.polyfill;
      var a = r.fetch ? r : i;
      ((t = a.fetch).default = a.fetch),
        (t.fetch = a.fetch),
        (t.Headers = a.Headers),
        (t.Request = a.Request),
        (t.Response = a.Response),
        (e.exports = t);
    },
    54476: function (e) {
      var t;
      (t = function () {
        'use strict';
        var e = 'millisecond',
          t = 'second',
          n = 'minute',
          r = 'hour',
          i = 'week',
          a = 'month',
          s = 'quarter',
          o = 'year',
          l = 'date',
          u = 'Invalid Date',
          c =
            /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
          d = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
          p = function (e, t, n) {
            var r = String(e);
            return !r || r.length >= t ? e : '' + Array(t + 1 - r.length).join(n) + e;
          },
          h = 'en',
          y = {};
        y[h] = {
          name: 'en',
          weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
          months:
            'January_February_March_April_May_June_July_August_September_October_November_December'.split(
              '_'
            ),
          ordinal: function (e) {
            var t = ['th', 'st', 'nd', 'rd'],
              n = e % 100;
            return '[' + e + (t[(n - 20) % 10] || t[n] || 'th') + ']';
          },
        };
        var f = '$isDayjsObject',
          m = function (e) {
            return e instanceof v || !(!e || !e[f]);
          },
          g = function e(t, n, r) {
            var i;
            if (!t) return h;
            if ('string' == typeof t) {
              var a = t.toLowerCase();
              y[a] && (i = a), n && ((y[a] = n), (i = a));
              var s = t.split('-');
              if (!i && s.length > 1) return e(s[0]);
            } else {
              var o = t.name;
              (y[o] = t), (i = o);
            }
            return !r && i && (h = i), i || (!r && h);
          },
          b = function (e, t) {
            if (m(e)) return e.clone();
            var n = 'object' == typeof t ? t : {};
            return (n.date = e), (n.args = arguments), new v(n);
          },
          w = {
            s: p,
            z: function (e) {
              var t = -e.utcOffset(),
                n = Math.abs(t);
              return (t <= 0 ? '+' : '-') + p(Math.floor(n / 60), 2, '0') + ':' + p(n % 60, 2, '0');
            },
            m: function e(t, n) {
              if (t.date() < n.date()) return -e(n, t);
              var r = 12 * (n.year() - t.year()) + (n.month() - t.month()),
                i = t.clone().add(r, a),
                s = n - i < 0,
                o = t.clone().add(r + (s ? -1 : 1), a);
              return +(-(r + (n - i) / (s ? i - o : o - i)) || 0);
            },
            a: function (e) {
              return e < 0 ? Math.ceil(e) || 0 : Math.floor(e);
            },
            p: function (u) {
              return (
                { M: a, y: o, w: i, d: 'day', D: l, h: r, m: n, s: t, ms: e, Q: s }[u] ||
                String(u || '')
                  .toLowerCase()
                  .replace(/s$/, '')
              );
            },
            u: function (e) {
              return void 0 === e;
            },
          };
        (w.l = g),
          (w.i = m),
          (w.w = function (e, t) {
            return b(e, { locale: t.$L, utc: t.$u, x: t.$x, $offset: t.$offset });
          });
        var v = (function () {
            function p(e) {
              (this.$L = g(e.locale, null, !0)),
                this.parse(e),
                (this.$x = this.$x || e.x || {}),
                (this[f] = !0);
            }
            var h = p.prototype;
            return (
              (h.parse = function (e) {
                (this.$d = (function (e) {
                  var t = e.date,
                    n = e.utc;
                  if (null === t) return new Date(NaN);
                  if (w.u(t)) return new Date();
                  if (t instanceof Date) return new Date(t);
                  if ('string' == typeof t && !/Z$/i.test(t)) {
                    var r = t.match(c);
                    if (r) {
                      var i = r[2] - 1 || 0,
                        a = (r[7] || '0').substring(0, 3);
                      return n
                        ? new Date(Date.UTC(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, a))
                        : new Date(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, a);
                    }
                  }
                  return new Date(t);
                })(e)),
                  this.init();
              }),
              (h.init = function () {
                var e = this.$d;
                (this.$y = e.getFullYear()),
                  (this.$M = e.getMonth()),
                  (this.$D = e.getDate()),
                  (this.$W = e.getDay()),
                  (this.$H = e.getHours()),
                  (this.$m = e.getMinutes()),
                  (this.$s = e.getSeconds()),
                  (this.$ms = e.getMilliseconds());
              }),
              (h.$utils = function () {
                return w;
              }),
              (h.isValid = function () {
                return this.$d.toString() !== u;
              }),
              (h.isSame = function (e, t) {
                var n = b(e);
                return this.startOf(t) <= n && n <= this.endOf(t);
              }),
              (h.isAfter = function (e, t) {
                return b(e) < this.startOf(t);
              }),
              (h.isBefore = function (e, t) {
                return this.endOf(t) < b(e);
              }),
              (h.$g = function (e, t, n) {
                return w.u(e) ? this[t] : this.set(n, e);
              }),
              (h.unix = function () {
                return Math.floor(this.valueOf() / 1e3);
              }),
              (h.valueOf = function () {
                return this.$d.getTime();
              }),
              (h.startOf = function (e, s) {
                var u = this,
                  c = !!w.u(s) || s,
                  d = w.p(e),
                  p = function (e, t) {
                    var n = w.w(u.$u ? Date.UTC(u.$y, t, e) : new Date(u.$y, t, e), u);
                    return c ? n : n.endOf('day');
                  },
                  h = function (e, t) {
                    return w.w(
                      u
                        .toDate()
                        [e].apply(u.toDate('s'), (c ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(t)),
                      u
                    );
                  },
                  y = this.$W,
                  f = this.$M,
                  m = this.$D,
                  g = 'set' + (this.$u ? 'UTC' : '');
                switch (d) {
                  case o:
                    return c ? p(1, 0) : p(31, 11);
                  case a:
                    return c ? p(1, f) : p(0, f + 1);
                  case i:
                    var b = this.$locale().weekStart || 0,
                      v = (y < b ? y + 7 : y) - b;
                    return p(c ? m - v : m + (6 - v), f);
                  case 'day':
                  case l:
                    return h(g + 'Hours', 0);
                  case r:
                    return h(g + 'Minutes', 1);
                  case n:
                    return h(g + 'Seconds', 2);
                  case t:
                    return h(g + 'Milliseconds', 3);
                  default:
                    return this.clone();
                }
              }),
              (h.endOf = function (e) {
                return this.startOf(e, !1);
              }),
              (h.$set = function (i, s) {
                var u,
                  c = w.p(i),
                  d = 'set' + (this.$u ? 'UTC' : ''),
                  p = (((u = {}).day = d + 'Date'),
                  (u[l] = d + 'Date'),
                  (u[a] = d + 'Month'),
                  (u[o] = d + 'FullYear'),
                  (u[r] = d + 'Hours'),
                  (u[n] = d + 'Minutes'),
                  (u[t] = d + 'Seconds'),
                  (u[e] = d + 'Milliseconds'),
                  u)[c],
                  h = 'day' === c ? this.$D + (s - this.$W) : s;
                if (c === a || c === o) {
                  var y = this.clone().set(l, 1);
                  y.$d[p](h), y.init(), (this.$d = y.set(l, Math.min(this.$D, y.daysInMonth())).$d);
                } else p && this.$d[p](h);
                return this.init(), this;
              }),
              (h.set = function (e, t) {
                return this.clone().$set(e, t);
              }),
              (h.get = function (e) {
                return this[w.p(e)]();
              }),
              (h.add = function (e, s) {
                var l,
                  u = this;
                e = Number(e);
                var c = w.p(s),
                  d = function (t) {
                    var n = b(u);
                    return w.w(n.date(n.date() + Math.round(t * e)), u);
                  };
                if (c === a) return this.set(a, this.$M + e);
                if (c === o) return this.set(o, this.$y + e);
                if ('day' === c) return d(1);
                if (c === i) return d(7);
                var p = (((l = {})[n] = 6e4), (l[r] = 36e5), (l[t] = 1e3), l)[c] || 1,
                  h = this.$d.getTime() + e * p;
                return w.w(h, this);
              }),
              (h.subtract = function (e, t) {
                return this.add(-1 * e, t);
              }),
              (h.format = function (e) {
                var t = this,
                  n = this.$locale();
                if (!this.isValid()) return n.invalidDate || u;
                var r = e || 'YYYY-MM-DDTHH:mm:ssZ',
                  i = w.z(this),
                  a = this.$H,
                  s = this.$m,
                  o = this.$M,
                  l = n.weekdays,
                  c = n.months,
                  p = n.meridiem,
                  h = function (e, n, i, a) {
                    return (e && (e[n] || e(t, r))) || i[n].slice(0, a);
                  },
                  y = function (e) {
                    return w.s(a % 12 || 12, e, '0');
                  },
                  f =
                    p ||
                    function (e, t, n) {
                      var r = e < 12 ? 'AM' : 'PM';
                      return n ? r.toLowerCase() : r;
                    };
                return r.replace(d, function (e, r) {
                  return (
                    r ||
                    (function (e) {
                      switch (e) {
                        case 'YY':
                          return String(t.$y).slice(-2);
                        case 'YYYY':
                          return w.s(t.$y, 4, '0');
                        case 'M':
                          return o + 1;
                        case 'MM':
                          return w.s(o + 1, 2, '0');
                        case 'MMM':
                          return h(n.monthsShort, o, c, 3);
                        case 'MMMM':
                          return h(c, o);
                        case 'D':
                          return t.$D;
                        case 'DD':
                          return w.s(t.$D, 2, '0');
                        case 'd':
                          return String(t.$W);
                        case 'dd':
                          return h(n.weekdaysMin, t.$W, l, 2);
                        case 'ddd':
                          return h(n.weekdaysShort, t.$W, l, 3);
                        case 'dddd':
                          return l[t.$W];
                        case 'H':
                          return String(a);
                        case 'HH':
                          return w.s(a, 2, '0');
                        case 'h':
                          return y(1);
                        case 'hh':
                          return y(2);
                        case 'a':
                          return f(a, s, !0);
                        case 'A':
                          return f(a, s, !1);
                        case 'm':
                          return String(s);
                        case 'mm':
                          return w.s(s, 2, '0');
                        case 's':
                          return String(t.$s);
                        case 'ss':
                          return w.s(t.$s, 2, '0');
                        case 'SSS':
                          return w.s(t.$ms, 3, '0');
                        case 'Z':
                          return i;
                      }
                      return null;
                    })(e) ||
                    i.replace(':', '')
                  );
                });
              }),
              (h.utcOffset = function () {
                return -(15 * Math.round(this.$d.getTimezoneOffset() / 15));
              }),
              (h.diff = function (e, l, u) {
                var c,
                  d = this,
                  p = w.p(l),
                  h = b(e),
                  y = (h.utcOffset() - this.utcOffset()) * 6e4,
                  f = this - h,
                  m = function () {
                    return w.m(d, h);
                  };
                switch (p) {
                  case o:
                    c = m() / 12;
                    break;
                  case a:
                    c = m();
                    break;
                  case s:
                    c = m() / 3;
                    break;
                  case i:
                    c = (f - y) / 6048e5;
                    break;
                  case 'day':
                    c = (f - y) / 864e5;
                    break;
                  case r:
                    c = f / 36e5;
                    break;
                  case n:
                    c = f / 6e4;
                    break;
                  case t:
                    c = f / 1e3;
                    break;
                  default:
                    c = f;
                }
                return u ? c : w.a(c);
              }),
              (h.daysInMonth = function () {
                return this.endOf(a).$D;
              }),
              (h.$locale = function () {
                return y[this.$L];
              }),
              (h.locale = function (e, t) {
                if (!e) return this.$L;
                var n = this.clone(),
                  r = g(e, t, !0);
                return r && (n.$L = r), n;
              }),
              (h.clone = function () {
                return w.w(this.$d, this);
              }),
              (h.toDate = function () {
                return new Date(this.valueOf());
              }),
              (h.toJSON = function () {
                return this.isValid() ? this.toISOString() : null;
              }),
              (h.toISOString = function () {
                return this.$d.toISOString();
              }),
              (h.toString = function () {
                return this.$d.toUTCString();
              }),
              p
            );
          })(),
          T = v.prototype;
        return (
          (b.prototype = T),
          [
            ['$ms', e],
            ['$s', t],
            ['$m', n],
            ['$H', r],
            ['$W', 'day'],
            ['$M', a],
            ['$y', o],
            ['$D', l],
          ].forEach(function (e) {
            T[e[1]] = function (t) {
              return this.$g(t, e[0], e[1]);
            };
          }),
          (b.extend = function (e, t) {
            return e.$i || (e(t, v, b), (e.$i = !0)), b;
          }),
          (b.locale = g),
          (b.isDayjs = m),
          (b.unix = function (e) {
            return b(1e3 * e);
          }),
          (b.en = y[h]),
          (b.Ls = y),
          (b.p = {}),
          b
        );
      }),
        (e.exports = t());
    },
    47971: function (e) {
      var t;
      (t = function () {
        return {
          name: 'en',
          weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
          months:
            'January_February_March_April_May_June_July_August_September_October_November_December'.split(
              '_'
            ),
          ordinal: function (e) {
            var t = ['th', 'st', 'nd', 'rd'],
              n = e % 100;
            return '[' + e + (t[(n - 20) % 10] || t[n] || 'th') + ']';
          },
        };
      }),
        (e.exports = t());
    },
    17339: function (e) {
      var t;
      (t = function () {
        return function (e, t, n) {
          e = e || {};
          var r = t.prototype,
            i = {
              future: 'in %s',
              past: '%s ago',
              s: 'a few seconds',
              m: 'a minute',
              mm: '%d minutes',
              h: 'an hour',
              hh: '%d hours',
              d: 'a day',
              dd: '%d days',
              M: 'a month',
              MM: '%d months',
              y: 'a year',
              yy: '%d years',
            };
          function a(e, t, n, i) {
            return r.fromToBase(e, t, n, i);
          }
          (n.en.relativeTime = i),
            (r.fromToBase = function (t, r, a, s, o) {
              for (
                var l,
                  u,
                  c,
                  d = a.$locale().relativeTime || i,
                  p = e.thresholds || [
                    { l: 's', r: 44, d: 'second' },
                    { l: 'm', r: 89 },
                    { l: 'mm', r: 44, d: 'minute' },
                    { l: 'h', r: 89 },
                    { l: 'hh', r: 21, d: 'hour' },
                    { l: 'd', r: 35 },
                    { l: 'dd', r: 25, d: 'day' },
                    { l: 'M', r: 45 },
                    { l: 'MM', r: 10, d: 'month' },
                    { l: 'y', r: 17 },
                    { l: 'yy', d: 'year' },
                  ],
                  h = p.length,
                  y = 0;
                y < h;
                y += 1
              ) {
                var f = p[y];
                f.d && (l = s ? n(t).diff(a, f.d, !0) : a.diff(t, f.d, !0));
                var m = (e.rounding || Math.round)(Math.abs(l));
                if (((c = l > 0), m <= f.r || !f.r)) {
                  m <= 1 && y > 0 && (f = p[y - 1]);
                  var g = d[f.l];
                  o && (m = o('' + m)),
                    (u = 'string' == typeof g ? g.replace('%d', m) : g(m, r, f.l, c));
                  break;
                }
              }
              if (r) return u;
              var b = c ? d.future : d.past;
              return 'function' == typeof b ? b(u) : b.replace('%s', u);
            }),
            (r.to = function (e, t) {
              return a(e, t, this, !0);
            }),
            (r.from = function (e, t) {
              return a(e, t, this);
            });
          var s = function (e) {
            return e.$u ? n.utc() : n();
          };
          (r.toNow = function (e) {
            return this.to(s(this), e);
          }),
            (r.fromNow = function (e) {
              return this.from(s(this), e);
            });
        };
      }),
        (e.exports = t());
    },
    30401: function (e) {
      var t;
      (t = function () {
        return function (e, t, n) {
          n.updateLocale = function (e, t) {
            var r = n.Ls[e];
            if (r)
              return (
                (t ? Object.keys(t) : []).forEach(function (e) {
                  r[e] = t[e];
                }),
                r
              );
          };
        };
      }),
        (e.exports = t());
    },
    47869: function (e) {
      'use strict';
      var t = Object.prototype.hasOwnProperty,
        n = '~';
      function r() {}
      function i(e, t, n) {
        (this.fn = e), (this.context = t), (this.once = n || !1);
      }
      function a(e, t, r, a, s) {
        if ('function' != typeof r) throw TypeError('The listener must be a function');
        var o = new i(r, a || e, s),
          l = n ? n + t : t;
        return (
          e._events[l]
            ? e._events[l].fn
              ? (e._events[l] = [e._events[l], o])
              : e._events[l].push(o)
            : ((e._events[l] = o), e._eventsCount++),
          e
        );
      }
      function s(e, t) {
        0 == --e._eventsCount ? (e._events = new r()) : delete e._events[t];
      }
      function o() {
        (this._events = new r()), (this._eventsCount = 0);
      }
      Object.create && ((r.prototype = Object.create(null)), new r().__proto__ || (n = !1)),
        (o.prototype.eventNames = function () {
          var e,
            r,
            i = [];
          if (0 === this._eventsCount) return i;
          for (r in (e = this._events)) t.call(e, r) && i.push(n ? r.slice(1) : r);
          return Object.getOwnPropertySymbols ? i.concat(Object.getOwnPropertySymbols(e)) : i;
        }),
        (o.prototype.listeners = function (e) {
          var t = n ? n + e : e,
            r = this._events[t];
          if (!r) return [];
          if (r.fn) return [r.fn];
          for (var i = 0, a = r.length, s = Array(a); i < a; i++) s[i] = r[i].fn;
          return s;
        }),
        (o.prototype.listenerCount = function (e) {
          var t = n ? n + e : e,
            r = this._events[t];
          return r ? (r.fn ? 1 : r.length) : 0;
        }),
        (o.prototype.emit = function (e, t, r, i, a, s) {
          var o = n ? n + e : e;
          if (!this._events[o]) return !1;
          var l,
            u,
            c = this._events[o],
            d = arguments.length;
          if (c.fn) {
            switch ((c.once && this.removeListener(e, c.fn, void 0, !0), d)) {
              case 1:
                return c.fn.call(c.context), !0;
              case 2:
                return c.fn.call(c.context, t), !0;
              case 3:
                return c.fn.call(c.context, t, r), !0;
              case 4:
                return c.fn.call(c.context, t, r, i), !0;
              case 5:
                return c.fn.call(c.context, t, r, i, a), !0;
              case 6:
                return c.fn.call(c.context, t, r, i, a, s), !0;
            }
            for (u = 1, l = Array(d - 1); u < d; u++) l[u - 1] = arguments[u];
            c.fn.apply(c.context, l);
          } else {
            var p,
              h = c.length;
            for (u = 0; u < h; u++)
              switch ((c[u].once && this.removeListener(e, c[u].fn, void 0, !0), d)) {
                case 1:
                  c[u].fn.call(c[u].context);
                  break;
                case 2:
                  c[u].fn.call(c[u].context, t);
                  break;
                case 3:
                  c[u].fn.call(c[u].context, t, r);
                  break;
                case 4:
                  c[u].fn.call(c[u].context, t, r, i);
                  break;
                default:
                  if (!l) for (p = 1, l = Array(d - 1); p < d; p++) l[p - 1] = arguments[p];
                  c[u].fn.apply(c[u].context, l);
              }
          }
          return !0;
        }),
        (o.prototype.on = function (e, t, n) {
          return a(this, e, t, n, !1);
        }),
        (o.prototype.once = function (e, t, n) {
          return a(this, e, t, n, !0);
        }),
        (o.prototype.removeListener = function (e, t, r, i) {
          var a = n ? n + e : e;
          if (!this._events[a]) return this;
          if (!t) return s(this, a), this;
          var o = this._events[a];
          if (o.fn) o.fn !== t || (i && !o.once) || (r && o.context !== r) || s(this, a);
          else {
            for (var l = 0, u = [], c = o.length; l < c; l++)
              (o[l].fn !== t || (i && !o[l].once) || (r && o[l].context !== r)) && u.push(o[l]);
            u.length ? (this._events[a] = 1 === u.length ? u[0] : u) : s(this, a);
          }
          return this;
        }),
        (o.prototype.removeAllListeners = function (e) {
          var t;
          return (
            e
              ? ((t = n ? n + e : e), this._events[t] && s(this, t))
              : ((this._events = new r()), (this._eventsCount = 0)),
            this
          );
        }),
        (o.prototype.off = o.prototype.removeListener),
        (o.prototype.addListener = o.prototype.on),
        (o.prefixed = n),
        (o.EventEmitter = o),
        (e.exports = o);
    },
    89354: function (e) {
      'use strict';
      var t,
        n = 'object' == typeof Reflect ? Reflect : null,
        r =
          n && 'function' == typeof n.apply
            ? n.apply
            : function (e, t, n) {
                return Function.prototype.apply.call(e, t, n);
              };
      t =
        n && 'function' == typeof n.ownKeys
          ? n.ownKeys
          : Object.getOwnPropertySymbols
            ? function (e) {
                return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
              }
            : function (e) {
                return Object.getOwnPropertyNames(e);
              };
      var i =
        Number.isNaN ||
        function (e) {
          return e != e;
        };
      function a() {
        a.init.call(this);
      }
      (e.exports = a),
        (e.exports.once = function (e, t) {
          return new Promise(function (n, r) {
            var i;
            function a(n) {
              e.removeListener(t, s), r(n);
            }
            function s() {
              'function' == typeof e.removeListener && e.removeListener('error', a),
                n([].slice.call(arguments));
            }
            f(e, t, s, { once: !0 }),
              'error' !== t &&
                ((i = { once: !0 }), 'function' == typeof e.on && f(e, 'error', a, i));
          });
        }),
        (a.EventEmitter = a),
        (a.prototype._events = void 0),
        (a.prototype._eventsCount = 0),
        (a.prototype._maxListeners = void 0);
      var s = 10;
      function o(e) {
        if ('function' != typeof e)
          throw TypeError(
            'The "listener" argument must be of type Function. Received type ' + typeof e
          );
      }
      function l(e) {
        return void 0 === e._maxListeners ? a.defaultMaxListeners : e._maxListeners;
      }
      function u(e, t, n, r) {
        if (
          (o(n),
          void 0 === (a = e._events)
            ? ((a = e._events = Object.create(null)), (e._eventsCount = 0))
            : (void 0 !== a.newListener &&
                (e.emit('newListener', t, n.listener ? n.listener : n), (a = e._events)),
              (s = a[t])),
          void 0 === s)
        )
          (s = a[t] = n), ++e._eventsCount;
        else if (
          ('function' == typeof s ? (s = a[t] = r ? [n, s] : [s, n]) : r ? s.unshift(n) : s.push(n),
          (i = l(e)) > 0 && s.length > i && !s.warned)
        ) {
          s.warned = !0;
          var i,
            a,
            s,
            u = Error(
              'Possible EventEmitter memory leak detected. ' +
                s.length +
                ' ' +
                String(t) +
                ' listeners added. Use emitter.setMaxListeners() to increase limit'
            );
          (u.name = 'MaxListenersExceededWarning'),
            (u.emitter = e),
            (u.type = t),
            (u.count = s.length),
            console && console.warn && console.warn(u);
        }
        return e;
      }
      function c() {
        if (!this.fired)
          return (this.target.removeListener(this.type, this.wrapFn),
          (this.fired = !0),
          0 == arguments.length)
            ? this.listener.call(this.target)
            : this.listener.apply(this.target, arguments);
      }
      function d(e, t, n) {
        var r = { fired: !1, wrapFn: void 0, target: e, type: t, listener: n },
          i = c.bind(r);
        return (i.listener = n), (r.wrapFn = i), i;
      }
      function p(e, t, n) {
        var r = e._events;
        if (void 0 === r) return [];
        var i = r[t];
        return void 0 === i
          ? []
          : 'function' == typeof i
            ? n
              ? [i.listener || i]
              : [i]
            : n
              ? (function (e) {
                  for (var t = Array(e.length), n = 0; n < t.length; ++n)
                    t[n] = e[n].listener || e[n];
                  return t;
                })(i)
              : y(i, i.length);
      }
      function h(e) {
        var t = this._events;
        if (void 0 !== t) {
          var n = t[e];
          if ('function' == typeof n) return 1;
          if (void 0 !== n) return n.length;
        }
        return 0;
      }
      function y(e, t) {
        for (var n = Array(t), r = 0; r < t; ++r) n[r] = e[r];
        return n;
      }
      function f(e, t, n, r) {
        if ('function' == typeof e.on) r.once ? e.once(t, n) : e.on(t, n);
        else if ('function' == typeof e.addEventListener)
          e.addEventListener(t, function i(a) {
            r.once && e.removeEventListener(t, i), n(a);
          });
        else
          throw TypeError(
            'The "emitter" argument must be of type EventEmitter. Received type ' + typeof e
          );
      }
      Object.defineProperty(a, 'defaultMaxListeners', {
        enumerable: !0,
        get: function () {
          return s;
        },
        set: function (e) {
          if ('number' != typeof e || e < 0 || i(e))
            throw RangeError(
              'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
                e +
                '.'
            );
          s = e;
        },
      }),
        (a.init = function () {
          (void 0 === this._events || this._events === Object.getPrototypeOf(this)._events) &&
            ((this._events = Object.create(null)), (this._eventsCount = 0)),
            (this._maxListeners = this._maxListeners || void 0);
        }),
        (a.prototype.setMaxListeners = function (e) {
          if ('number' != typeof e || e < 0 || i(e))
            throw RangeError(
              'The value of "n" is out of range. It must be a non-negative number. Received ' +
                e +
                '.'
            );
          return (this._maxListeners = e), this;
        }),
        (a.prototype.getMaxListeners = function () {
          return l(this);
        }),
        (a.prototype.emit = function (e) {
          for (var t = [], n = 1; n < arguments.length; n++) t.push(arguments[n]);
          var i = 'error' === e,
            a = this._events;
          if (void 0 !== a) i = i && void 0 === a.error;
          else if (!i) return !1;
          if (i) {
            if ((t.length > 0 && (s = t[0]), s instanceof Error)) throw s;
            var s,
              o = Error('Unhandled error.' + (s ? ' (' + s.message + ')' : ''));
            throw ((o.context = s), o);
          }
          var l = a[e];
          if (void 0 === l) return !1;
          if ('function' == typeof l) r(l, this, t);
          else for (var u = l.length, c = y(l, u), n = 0; n < u; ++n) r(c[n], this, t);
          return !0;
        }),
        (a.prototype.addListener = function (e, t) {
          return u(this, e, t, !1);
        }),
        (a.prototype.on = a.prototype.addListener),
        (a.prototype.prependListener = function (e, t) {
          return u(this, e, t, !0);
        }),
        (a.prototype.once = function (e, t) {
          return o(t), this.on(e, d(this, e, t)), this;
        }),
        (a.prototype.prependOnceListener = function (e, t) {
          return o(t), this.prependListener(e, d(this, e, t)), this;
        }),
        (a.prototype.removeListener = function (e, t) {
          var n, r, i, a, s;
          if ((o(t), void 0 === (r = this._events) || void 0 === (n = r[e]))) return this;
          if (n === t || n.listener === t)
            0 == --this._eventsCount
              ? (this._events = Object.create(null))
              : (delete r[e], r.removeListener && this.emit('removeListener', e, n.listener || t));
          else if ('function' != typeof n) {
            for (i = -1, a = n.length - 1; a >= 0; a--)
              if (n[a] === t || n[a].listener === t) {
                (s = n[a].listener), (i = a);
                break;
              }
            if (i < 0) return this;
            0 === i
              ? n.shift()
              : (function (e, t) {
                  for (; t + 1 < e.length; t++) e[t] = e[t + 1];
                  e.pop();
                })(n, i),
              1 === n.length && (r[e] = n[0]),
              void 0 !== r.removeListener && this.emit('removeListener', e, s || t);
          }
          return this;
        }),
        (a.prototype.off = a.prototype.removeListener),
        (a.prototype.removeAllListeners = function (e) {
          var t, n, r;
          if (void 0 === (n = this._events)) return this;
          if (void 0 === n.removeListener)
            return (
              0 == arguments.length
                ? ((this._events = Object.create(null)), (this._eventsCount = 0))
                : void 0 !== n[e] &&
                  (0 == --this._eventsCount ? (this._events = Object.create(null)) : delete n[e]),
              this
            );
          if (0 == arguments.length) {
            var i,
              a = Object.keys(n);
            for (r = 0; r < a.length; ++r)
              'removeListener' !== (i = a[r]) && this.removeAllListeners(i);
            return (
              this.removeAllListeners('removeListener'),
              (this._events = Object.create(null)),
              (this._eventsCount = 0),
              this
            );
          }
          if ('function' == typeof (t = n[e])) this.removeListener(e, t);
          else if (void 0 !== t) for (r = t.length - 1; r >= 0; r--) this.removeListener(e, t[r]);
          return this;
        }),
        (a.prototype.listeners = function (e) {
          return p(this, e, !0);
        }),
        (a.prototype.rawListeners = function (e) {
          return p(this, e, !1);
        }),
        (a.listenerCount = function (e, t) {
          return 'function' == typeof e.listenerCount ? e.listenerCount(t) : h.call(e, t);
        }),
        (a.prototype.listenerCount = h),
        (a.prototype.eventNames = function () {
          return this._eventsCount > 0 ? t(this._events) : [];
        });
    },
    3245: function (e, t, n) {
      'use strict';
      n.d(t, {
        Ps: function () {
          return V;
        },
      });
      var r,
        i,
        a,
        s,
        o,
        l = n(85192);
      let u = /\r\n|[\n\r]/g;
      function c(e, t) {
        let n = 0,
          r = 1;
        for (let i of e.body.matchAll(u)) {
          if (
            ('number' == typeof i.index ||
              (function (e, t) {
                if (!e) throw Error('Unexpected invariant triggered.');
              })(!1),
            i.index >= t)
          )
            break;
          (n = i.index + i[0].length), (r += 1);
        }
        return { line: r, column: t + 1 - n };
      }
      function d(e, t) {
        let n = e.locationOffset.column - 1,
          r = ''.padStart(n) + e.body,
          i = t.line - 1,
          a = e.locationOffset.line - 1,
          s = t.line + a,
          o = 1 === t.line ? n : 0,
          l = t.column + o,
          u = `${e.name}:${s}:${l}
`,
          c = r.split(/\r\n|[\n\r]/g),
          d = c[i];
        if (d.length > 120) {
          let e = Math.floor(l / 80),
            t = [];
          for (let e = 0; e < d.length; e += 80) t.push(d.slice(e, e + 80));
          return (
            u +
            p([
              [`${s} |`, t[0]],
              ...t.slice(1, e + 1).map((e) => ['|', e]),
              ['|', '^'.padStart(l % 80)],
              ['|', t[e + 1]],
            ])
          );
        }
        return (
          u +
          p([
            [`${s - 1} |`, c[i - 1]],
            [`${s} |`, d],
            ['|', '^'.padStart(l)],
            [`${s + 1} |`, c[i + 1]],
          ])
        );
      }
      function p(e) {
        let t = e.filter(([e, t]) => void 0 !== t),
          n = Math.max(...t.map(([e]) => e.length));
        return t.map(([e, t]) => e.padStart(n) + (t ? ' ' + t : '')).join('\n');
      }
      class h extends Error {
        constructor(e, ...t) {
          var n, r, i, a;
          let {
            nodes: s,
            source: o,
            positions: l,
            path: u,
            originalError: d,
            extensions: p,
          } = (function (e) {
            let t = e[0];
            return null == t || 'kind' in t || 'length' in t
              ? {
                  nodes: t,
                  source: e[1],
                  positions: e[2],
                  path: e[3],
                  originalError: e[4],
                  extensions: e[5],
                }
              : t;
          })(t);
          super(e),
            (this.name = 'GraphQLError'),
            (this.path = null != u ? u : void 0),
            (this.originalError = null != d ? d : void 0),
            (this.nodes = y(Array.isArray(s) ? s : s ? [s] : void 0));
          let f = y(
            null === (n = this.nodes) || void 0 === n
              ? void 0
              : n.map((e) => e.loc).filter((e) => null != e)
          );
          (this.source =
            null != o
              ? o
              : null == f
                ? void 0
                : null === (r = f[0]) || void 0 === r
                  ? void 0
                  : r.source),
            (this.positions = null != l ? l : null == f ? void 0 : f.map((e) => e.start)),
            (this.locations =
              l && o
                ? l.map((e) => c(o, e))
                : null == f
                  ? void 0
                  : f.map((e) => c(e.source, e.start)));
          let m =
            'object' == typeof (a = null == d ? void 0 : d.extensions) && null !== a
              ? null == d
                ? void 0
                : d.extensions
              : void 0;
          (this.extensions =
            null !== (i = null != p ? p : m) && void 0 !== i ? i : Object.create(null)),
            Object.defineProperties(this, {
              message: { writable: !0, enumerable: !0 },
              name: { enumerable: !1 },
              nodes: { enumerable: !1 },
              source: { enumerable: !1 },
              positions: { enumerable: !1 },
              originalError: { enumerable: !1 },
            }),
            null != d && d.stack
              ? Object.defineProperty(this, 'stack', {
                  value: d.stack,
                  writable: !0,
                  configurable: !0,
                })
              : Error.captureStackTrace
                ? Error.captureStackTrace(this, h)
                : Object.defineProperty(this, 'stack', {
                    value: Error().stack,
                    writable: !0,
                    configurable: !0,
                  });
        }
        get [Symbol.toStringTag]() {
          return 'GraphQLError';
        }
        toString() {
          let e = this.message;
          if (this.nodes) {
            for (let n of this.nodes)
              if (n.loc) {
                var t;
                e += '\n\n' + d((t = n.loc).source, c(t.source, t.start));
              }
          } else if (this.source && this.locations)
            for (let t of this.locations) e += '\n\n' + d(this.source, t);
          return e;
        }
        toJSON() {
          let e = { message: this.message };
          return (
            null != this.locations && (e.locations = this.locations),
            null != this.path && (e.path = this.path),
            null != this.extensions &&
              Object.keys(this.extensions).length > 0 &&
              (e.extensions = this.extensions),
            e
          );
        }
      }
      function y(e) {
        return void 0 === e || 0 === e.length ? void 0 : e;
      }
      function f(e, t, n) {
        return new h(`Syntax Error: ${n}`, { source: e, positions: [t] });
      }
      var m = n(57564);
      ((r = s || (s = {})).QUERY = 'QUERY'),
        (r.MUTATION = 'MUTATION'),
        (r.SUBSCRIPTION = 'SUBSCRIPTION'),
        (r.FIELD = 'FIELD'),
        (r.FRAGMENT_DEFINITION = 'FRAGMENT_DEFINITION'),
        (r.FRAGMENT_SPREAD = 'FRAGMENT_SPREAD'),
        (r.INLINE_FRAGMENT = 'INLINE_FRAGMENT'),
        (r.VARIABLE_DEFINITION = 'VARIABLE_DEFINITION'),
        (r.SCHEMA = 'SCHEMA'),
        (r.SCALAR = 'SCALAR'),
        (r.OBJECT = 'OBJECT'),
        (r.FIELD_DEFINITION = 'FIELD_DEFINITION'),
        (r.ARGUMENT_DEFINITION = 'ARGUMENT_DEFINITION'),
        (r.INTERFACE = 'INTERFACE'),
        (r.UNION = 'UNION'),
        (r.ENUM = 'ENUM'),
        (r.ENUM_VALUE = 'ENUM_VALUE'),
        (r.INPUT_OBJECT = 'INPUT_OBJECT'),
        (r.INPUT_FIELD_DEFINITION = 'INPUT_FIELD_DEFINITION');
      var g = n(60832),
        b = n(67728),
        w = n(3069);
      ((i = o || (o = {})).SOF = '<SOF>'),
        (i.EOF = '<EOF>'),
        (i.BANG = '!'),
        (i.DOLLAR = '$'),
        (i.AMP = '&'),
        (i.PAREN_L = '('),
        (i.PAREN_R = ')'),
        (i.SPREAD = '...'),
        (i.COLON = ':'),
        (i.EQUALS = '='),
        (i.AT = '@'),
        (i.BRACKET_L = '['),
        (i.BRACKET_R = ']'),
        (i.BRACE_L = '{'),
        (i.PIPE = '|'),
        (i.BRACE_R = '}'),
        (i.NAME = 'Name'),
        (i.INT = 'Int'),
        (i.FLOAT = 'Float'),
        (i.STRING = 'String'),
        (i.BLOCK_STRING = 'BlockString'),
        (i.COMMENT = 'Comment');
      class v {
        constructor(e) {
          let t = new m.WU(o.SOF, 0, 0, 0, 0);
          (this.source = e),
            (this.lastToken = t),
            (this.token = t),
            (this.line = 1),
            (this.lineStart = 0);
        }
        get [Symbol.toStringTag]() {
          return 'Lexer';
        }
        advance() {
          return (this.lastToken = this.token), (this.token = this.lookahead());
        }
        lookahead() {
          let e = this.token;
          if (e.kind !== o.EOF)
            do
              if (e.next) e = e.next;
              else {
                let t = (function (e, t) {
                  let n = e.source.body,
                    r = n.length,
                    i = t;
                  for (; i < r; ) {
                    let t = n.charCodeAt(i);
                    switch (t) {
                      case 65279:
                      case 9:
                      case 32:
                      case 44:
                        ++i;
                        continue;
                      case 10:
                        ++i, ++e.line, (e.lineStart = i);
                        continue;
                      case 13:
                        10 === n.charCodeAt(i + 1) ? (i += 2) : ++i, ++e.line, (e.lineStart = i);
                        continue;
                      case 35:
                        return (function (e, t) {
                          let n = e.source.body,
                            r = n.length,
                            i = t + 1;
                          for (; i < r; ) {
                            let e = n.charCodeAt(i);
                            if (10 === e || 13 === e) break;
                            if (T(e)) ++i;
                            else if (A(n, i)) i += 2;
                            else break;
                          }
                          return I(e, o.COMMENT, t, i, n.slice(t + 1, i));
                        })(e, i);
                      case 33:
                        return I(e, o.BANG, i, i + 1);
                      case 36:
                        return I(e, o.DOLLAR, i, i + 1);
                      case 38:
                        return I(e, o.AMP, i, i + 1);
                      case 40:
                        return I(e, o.PAREN_L, i, i + 1);
                      case 41:
                        return I(e, o.PAREN_R, i, i + 1);
                      case 46:
                        if (46 === n.charCodeAt(i + 1) && 46 === n.charCodeAt(i + 2))
                          return I(e, o.SPREAD, i, i + 3);
                        break;
                      case 58:
                        return I(e, o.COLON, i, i + 1);
                      case 61:
                        return I(e, o.EQUALS, i, i + 1);
                      case 64:
                        return I(e, o.AT, i, i + 1);
                      case 91:
                        return I(e, o.BRACKET_L, i, i + 1);
                      case 93:
                        return I(e, o.BRACKET_R, i, i + 1);
                      case 123:
                        return I(e, o.BRACE_L, i, i + 1);
                      case 124:
                        return I(e, o.PIPE, i, i + 1);
                      case 125:
                        return I(e, o.BRACE_R, i, i + 1);
                      case 34:
                        if (34 === n.charCodeAt(i + 1) && 34 === n.charCodeAt(i + 2))
                          return (function (e, t) {
                            let n = e.source.body,
                              r = n.length,
                              i = e.lineStart,
                              a = t + 3,
                              s = a,
                              l = '',
                              u = [];
                            for (; a < r; ) {
                              let r = n.charCodeAt(a);
                              if (
                                34 === r &&
                                34 === n.charCodeAt(a + 1) &&
                                34 === n.charCodeAt(a + 2)
                              ) {
                                (l += n.slice(s, a)), u.push(l);
                                let r = I(e, o.BLOCK_STRING, t, a + 3, (0, b.wv)(u).join('\n'));
                                return (e.line += u.length - 1), (e.lineStart = i), r;
                              }
                              if (
                                92 === r &&
                                34 === n.charCodeAt(a + 1) &&
                                34 === n.charCodeAt(a + 2) &&
                                34 === n.charCodeAt(a + 3)
                              ) {
                                (l += n.slice(s, a)), (s = a + 1), (a += 4);
                                continue;
                              }
                              if (10 === r || 13 === r) {
                                (l += n.slice(s, a)),
                                  u.push(l),
                                  13 === r && 10 === n.charCodeAt(a + 1) ? (a += 2) : ++a,
                                  (l = ''),
                                  (s = a),
                                  (i = a);
                                continue;
                              }
                              if (T(r)) ++a;
                              else if (A(n, a)) a += 2;
                              else
                                throw f(
                                  e.source,
                                  a,
                                  `Invalid character within String: ${_(e, a)}.`
                                );
                            }
                            throw f(e.source, a, 'Unterminated string.');
                          })(e, i);
                        return (function (e, t) {
                          let n = e.source.body,
                            r = n.length,
                            i = t + 1,
                            a = i,
                            s = '';
                          for (; i < r; ) {
                            let r = n.charCodeAt(i);
                            if (34 === r) return (s += n.slice(a, i)), I(e, o.STRING, t, i + 1, s);
                            if (92 === r) {
                              s += n.slice(a, i);
                              let t =
                                117 === n.charCodeAt(i + 1)
                                  ? 123 === n.charCodeAt(i + 2)
                                    ? (function (e, t) {
                                        let n = e.source.body,
                                          r = 0,
                                          i = 3;
                                        for (; i < 12; ) {
                                          let e = n.charCodeAt(t + i++);
                                          if (125 === e) {
                                            if (i < 5 || !T(r)) break;
                                            return { value: String.fromCodePoint(r), size: i };
                                          }
                                          if ((r = (r << 4) | O(e)) < 0) break;
                                        }
                                        throw f(
                                          e.source,
                                          t,
                                          `Invalid Unicode escape sequence: "${n.slice(t, t + i)}".`
                                        );
                                      })(e, i)
                                    : (function (e, t) {
                                        let n = e.source.body,
                                          r = P(n, t + 2);
                                        if (T(r))
                                          return { value: String.fromCodePoint(r), size: 6 };
                                        if (
                                          E(r) &&
                                          92 === n.charCodeAt(t + 6) &&
                                          117 === n.charCodeAt(t + 7)
                                        ) {
                                          let e = P(n, t + 8);
                                          if (C(e))
                                            return { value: String.fromCodePoint(r, e), size: 12 };
                                        }
                                        throw f(
                                          e.source,
                                          t,
                                          `Invalid Unicode escape sequence: "${n.slice(t, t + 6)}".`
                                        );
                                      })(e, i)
                                  : (function (e, t) {
                                      let n = e.source.body;
                                      switch (n.charCodeAt(t + 1)) {
                                        case 34:
                                          return { value: '"', size: 2 };
                                        case 92:
                                          return { value: '\\', size: 2 };
                                        case 47:
                                          return { value: '/', size: 2 };
                                        case 98:
                                          return { value: '\b', size: 2 };
                                        case 102:
                                          return { value: '\f', size: 2 };
                                        case 110:
                                          return { value: '\n', size: 2 };
                                        case 114:
                                          return { value: '\r', size: 2 };
                                        case 116:
                                          return { value: '	', size: 2 };
                                      }
                                      throw f(
                                        e.source,
                                        t,
                                        `Invalid character escape sequence: "${n.slice(t, t + 2)}".`
                                      );
                                    })(e, i);
                              (s += t.value), (i += t.size), (a = i);
                              continue;
                            }
                            if (10 === r || 13 === r) break;
                            if (T(r)) ++i;
                            else if (A(n, i)) i += 2;
                            else
                              throw f(e.source, i, `Invalid character within String: ${_(e, i)}.`);
                          }
                          throw f(e.source, i, 'Unterminated string.');
                        })(e, i);
                    }
                    if ((0, w.X1)(t) || 45 === t)
                      return (function (e, t, n) {
                        let r = e.source.body,
                          i = t,
                          a = n,
                          s = !1;
                        if ((45 === a && (a = r.charCodeAt(++i)), 48 === a)) {
                          if (((a = r.charCodeAt(++i)), (0, w.X1)(a)))
                            throw f(
                              e.source,
                              i,
                              `Invalid number, unexpected digit after 0: ${_(e, i)}.`
                            );
                        } else (i = S(e, i, a)), (a = r.charCodeAt(i));
                        if (
                          (46 === a &&
                            ((s = !0),
                            (a = r.charCodeAt(++i)),
                            (i = S(e, i, a)),
                            (a = r.charCodeAt(i))),
                          (69 === a || 101 === a) &&
                            ((s = !0),
                            (43 === (a = r.charCodeAt(++i)) || 45 === a) && (a = r.charCodeAt(++i)),
                            (i = S(e, i, a)),
                            (a = r.charCodeAt(i))),
                          46 === a || (0, w.LQ)(a))
                        )
                          throw f(
                            e.source,
                            i,
                            `Invalid number, expected digit but got: ${_(e, i)}.`
                          );
                        return I(e, s ? o.FLOAT : o.INT, t, i, r.slice(t, i));
                      })(e, i, t);
                    if ((0, w.LQ)(t))
                      return (function (e, t) {
                        let n = e.source.body,
                          r = n.length,
                          i = t + 1;
                        for (; i < r; ) {
                          let e = n.charCodeAt(i);
                          if ((0, w.HQ)(e)) ++i;
                          else break;
                        }
                        return I(e, o.NAME, t, i, n.slice(t, i));
                      })(e, i);
                    throw f(
                      e.source,
                      i,
                      39 === t
                        ? 'Unexpected single quote character (\'), did you mean to use a double quote (")?'
                        : T(t) || A(n, i)
                          ? `Unexpected character: ${_(e, i)}.`
                          : `Invalid character: ${_(e, i)}.`
                    );
                  }
                  return I(e, o.EOF, r, r);
                })(this, e.end);
                (e.next = t), (t.prev = e), (e = t);
              }
            while (e.kind === o.COMMENT);
          return e;
        }
      }
      function T(e) {
        return (e >= 0 && e <= 55295) || (e >= 57344 && e <= 1114111);
      }
      function A(e, t) {
        return E(e.charCodeAt(t)) && C(e.charCodeAt(t + 1));
      }
      function E(e) {
        return e >= 55296 && e <= 56319;
      }
      function C(e) {
        return e >= 56320 && e <= 57343;
      }
      function _(e, t) {
        let n = e.source.body.codePointAt(t);
        if (void 0 === n) return o.EOF;
        if (n >= 32 && n <= 126) {
          let e = String.fromCodePoint(n);
          return '"' === e ? "'\"'" : `"${e}"`;
        }
        return 'U+' + n.toString(16).toUpperCase().padStart(4, '0');
      }
      function I(e, t, n, r, i) {
        let a = e.line,
          s = 1 + n - e.lineStart;
        return new m.WU(t, n, r, a, s, i);
      }
      function S(e, t, n) {
        if (!(0, w.X1)(n))
          throw f(e.source, t, `Invalid number, expected digit but got: ${_(e, t)}.`);
        let r = e.source.body,
          i = t + 1;
        for (; (0, w.X1)(r.charCodeAt(i)); ) ++i;
        return i;
      }
      function P(e, t) {
        return (
          (O(e.charCodeAt(t)) << 12) |
          (O(e.charCodeAt(t + 1)) << 8) |
          (O(e.charCodeAt(t + 2)) << 4) |
          O(e.charCodeAt(t + 3))
        );
      }
      function O(e) {
        return e >= 48 && e <= 57
          ? e - 48
          : e >= 65 && e <= 70
            ? e - 55
            : e >= 97 && e <= 102
              ? e - 87
              : -1;
      }
      var N = n(89304),
        x = n(14208);
      let M = globalThis.process
        ? function (e, t) {
            return e instanceof t;
          }
        : function (e, t) {
            if (e instanceof t) return !0;
            if ('object' == typeof e && null !== e) {
              var n;
              let r = t.prototype[Symbol.toStringTag];
              if (
                r ===
                (Symbol.toStringTag in e
                  ? e[Symbol.toStringTag]
                  : null === (n = e.constructor) || void 0 === n
                    ? void 0
                    : n.name)
              ) {
                let t = (0, x.X)(e);
                throw Error(`Cannot use ${r} "${t}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
              }
            }
            return !1;
          };
      class k {
        constructor(e, t = 'GraphQL request', n = { line: 1, column: 1 }) {
          'string' == typeof e || (0, N.a)(!1, `Body must be a string. Received: ${(0, x.X)(e)}.`),
            (this.body = e),
            (this.name = t),
            (this.locationOffset = n),
            this.locationOffset.line > 0 ||
              (0, N.a)(!1, 'line in locationOffset is 1-indexed and must be positive.'),
            this.locationOffset.column > 0 ||
              (0, N.a)(!1, 'column in locationOffset is 1-indexed and must be positive.');
        }
        get [Symbol.toStringTag]() {
          return 'Source';
        }
      }
      class R {
        constructor(e, t = {}) {
          let n = M(e, k) ? e : new k(e);
          (this._lexer = new v(n)), (this._options = t), (this._tokenCounter = 0);
        }
        get tokenCount() {
          return this._tokenCounter;
        }
        parseName() {
          let e = this.expectToken(o.NAME);
          return this.node(e, { kind: g.h.NAME, value: e.value });
        }
        parseDocument() {
          return this.node(this._lexer.token, {
            kind: g.h.DOCUMENT,
            definitions: this.many(o.SOF, this.parseDefinition, o.EOF),
          });
        }
        parseDefinition() {
          if (this.peek(o.BRACE_L)) return this.parseOperationDefinition();
          let e = this.peekDescription(),
            t = e ? this._lexer.lookahead() : this._lexer.token;
          if (t.kind === o.NAME) {
            switch (t.value) {
              case 'schema':
                return this.parseSchemaDefinition();
              case 'scalar':
                return this.parseScalarTypeDefinition();
              case 'type':
                return this.parseObjectTypeDefinition();
              case 'interface':
                return this.parseInterfaceTypeDefinition();
              case 'union':
                return this.parseUnionTypeDefinition();
              case 'enum':
                return this.parseEnumTypeDefinition();
              case 'input':
                return this.parseInputObjectTypeDefinition();
              case 'directive':
                return this.parseDirectiveDefinition();
            }
            if (e)
              throw f(
                this._lexer.source,
                this._lexer.token.start,
                'Unexpected description, descriptions are supported only on type definitions.'
              );
            switch (t.value) {
              case 'query':
              case 'mutation':
              case 'subscription':
                return this.parseOperationDefinition();
              case 'fragment':
                return this.parseFragmentDefinition();
              case 'extend':
                return this.parseTypeSystemExtension();
            }
          }
          throw this.unexpected(t);
        }
        parseOperationDefinition() {
          let e;
          let t = this._lexer.token;
          if (this.peek(o.BRACE_L))
            return this.node(t, {
              kind: g.h.OPERATION_DEFINITION,
              operation: m.ku.QUERY,
              name: void 0,
              variableDefinitions: [],
              directives: [],
              selectionSet: this.parseSelectionSet(),
            });
          let n = this.parseOperationType();
          return (
            this.peek(o.NAME) && (e = this.parseName()),
            this.node(t, {
              kind: g.h.OPERATION_DEFINITION,
              operation: n,
              name: e,
              variableDefinitions: this.parseVariableDefinitions(),
              directives: this.parseDirectives(!1),
              selectionSet: this.parseSelectionSet(),
            })
          );
        }
        parseOperationType() {
          let e = this.expectToken(o.NAME);
          switch (e.value) {
            case 'query':
              return m.ku.QUERY;
            case 'mutation':
              return m.ku.MUTATION;
            case 'subscription':
              return m.ku.SUBSCRIPTION;
          }
          throw this.unexpected(e);
        }
        parseVariableDefinitions() {
          return this.optionalMany(o.PAREN_L, this.parseVariableDefinition, o.PAREN_R);
        }
        parseVariableDefinition() {
          return this.node(this._lexer.token, {
            kind: g.h.VARIABLE_DEFINITION,
            variable: this.parseVariable(),
            type: (this.expectToken(o.COLON), this.parseTypeReference()),
            defaultValue: this.expectOptionalToken(o.EQUALS)
              ? this.parseConstValueLiteral()
              : void 0,
            directives: this.parseConstDirectives(),
          });
        }
        parseVariable() {
          let e = this._lexer.token;
          return (
            this.expectToken(o.DOLLAR), this.node(e, { kind: g.h.VARIABLE, name: this.parseName() })
          );
        }
        parseSelectionSet() {
          return this.node(this._lexer.token, {
            kind: g.h.SELECTION_SET,
            selections: this.many(o.BRACE_L, this.parseSelection, o.BRACE_R),
          });
        }
        parseSelection() {
          return this.peek(o.SPREAD) ? this.parseFragment() : this.parseField();
        }
        parseField() {
          let e, t;
          let n = this._lexer.token,
            r = this.parseName();
          return (
            this.expectOptionalToken(o.COLON) ? ((e = r), (t = this.parseName())) : (t = r),
            this.node(n, {
              kind: g.h.FIELD,
              alias: e,
              name: t,
              arguments: this.parseArguments(!1),
              directives: this.parseDirectives(!1),
              selectionSet: this.peek(o.BRACE_L) ? this.parseSelectionSet() : void 0,
            })
          );
        }
        parseArguments(e) {
          let t = e ? this.parseConstArgument : this.parseArgument;
          return this.optionalMany(o.PAREN_L, t, o.PAREN_R);
        }
        parseArgument(e = !1) {
          let t = this._lexer.token,
            n = this.parseName();
          return (
            this.expectToken(o.COLON),
            this.node(t, { kind: g.h.ARGUMENT, name: n, value: this.parseValueLiteral(e) })
          );
        }
        parseConstArgument() {
          return this.parseArgument(!0);
        }
        parseFragment() {
          let e = this._lexer.token;
          this.expectToken(o.SPREAD);
          let t = this.expectOptionalKeyword('on');
          return !t && this.peek(o.NAME)
            ? this.node(e, {
                kind: g.h.FRAGMENT_SPREAD,
                name: this.parseFragmentName(),
                directives: this.parseDirectives(!1),
              })
            : this.node(e, {
                kind: g.h.INLINE_FRAGMENT,
                typeCondition: t ? this.parseNamedType() : void 0,
                directives: this.parseDirectives(!1),
                selectionSet: this.parseSelectionSet(),
              });
        }
        parseFragmentDefinition() {
          let e = this._lexer.token;
          return (this.expectKeyword('fragment'), !0 === this._options.allowLegacyFragmentVariables)
            ? this.node(e, {
                kind: g.h.FRAGMENT_DEFINITION,
                name: this.parseFragmentName(),
                variableDefinitions: this.parseVariableDefinitions(),
                typeCondition: (this.expectKeyword('on'), this.parseNamedType()),
                directives: this.parseDirectives(!1),
                selectionSet: this.parseSelectionSet(),
              })
            : this.node(e, {
                kind: g.h.FRAGMENT_DEFINITION,
                name: this.parseFragmentName(),
                typeCondition: (this.expectKeyword('on'), this.parseNamedType()),
                directives: this.parseDirectives(!1),
                selectionSet: this.parseSelectionSet(),
              });
        }
        parseFragmentName() {
          if ('on' === this._lexer.token.value) throw this.unexpected();
          return this.parseName();
        }
        parseValueLiteral(e) {
          let t = this._lexer.token;
          switch (t.kind) {
            case o.BRACKET_L:
              return this.parseList(e);
            case o.BRACE_L:
              return this.parseObject(e);
            case o.INT:
              return this.advanceLexer(), this.node(t, { kind: g.h.INT, value: t.value });
            case o.FLOAT:
              return this.advanceLexer(), this.node(t, { kind: g.h.FLOAT, value: t.value });
            case o.STRING:
            case o.BLOCK_STRING:
              return this.parseStringLiteral();
            case o.NAME:
              switch ((this.advanceLexer(), t.value)) {
                case 'true':
                  return this.node(t, { kind: g.h.BOOLEAN, value: !0 });
                case 'false':
                  return this.node(t, { kind: g.h.BOOLEAN, value: !1 });
                case 'null':
                  return this.node(t, { kind: g.h.NULL });
                default:
                  return this.node(t, { kind: g.h.ENUM, value: t.value });
              }
            case o.DOLLAR:
              if (e) {
                if ((this.expectToken(o.DOLLAR), this._lexer.token.kind === o.NAME)) {
                  let e = this._lexer.token.value;
                  throw f(
                    this._lexer.source,
                    t.start,
                    `Unexpected variable "$${e}" in constant value.`
                  );
                }
                throw this.unexpected(t);
              }
              return this.parseVariable();
            default:
              throw this.unexpected();
          }
        }
        parseConstValueLiteral() {
          return this.parseValueLiteral(!0);
        }
        parseStringLiteral() {
          let e = this._lexer.token;
          return (
            this.advanceLexer(),
            this.node(e, { kind: g.h.STRING, value: e.value, block: e.kind === o.BLOCK_STRING })
          );
        }
        parseList(e) {
          return this.node(this._lexer.token, {
            kind: g.h.LIST,
            values: this.any(o.BRACKET_L, () => this.parseValueLiteral(e), o.BRACKET_R),
          });
        }
        parseObject(e) {
          return this.node(this._lexer.token, {
            kind: g.h.OBJECT,
            fields: this.any(o.BRACE_L, () => this.parseObjectField(e), o.BRACE_R),
          });
        }
        parseObjectField(e) {
          let t = this._lexer.token,
            n = this.parseName();
          return (
            this.expectToken(o.COLON),
            this.node(t, { kind: g.h.OBJECT_FIELD, name: n, value: this.parseValueLiteral(e) })
          );
        }
        parseDirectives(e) {
          let t = [];
          for (; this.peek(o.AT); ) t.push(this.parseDirective(e));
          return t;
        }
        parseConstDirectives() {
          return this.parseDirectives(!0);
        }
        parseDirective(e) {
          let t = this._lexer.token;
          return (
            this.expectToken(o.AT),
            this.node(t, {
              kind: g.h.DIRECTIVE,
              name: this.parseName(),
              arguments: this.parseArguments(e),
            })
          );
        }
        parseTypeReference() {
          let e;
          let t = this._lexer.token;
          if (this.expectOptionalToken(o.BRACKET_L)) {
            let n = this.parseTypeReference();
            this.expectToken(o.BRACKET_R), (e = this.node(t, { kind: g.h.LIST_TYPE, type: n }));
          } else e = this.parseNamedType();
          return this.expectOptionalToken(o.BANG)
            ? this.node(t, { kind: g.h.NON_NULL_TYPE, type: e })
            : e;
        }
        parseNamedType() {
          return this.node(this._lexer.token, { kind: g.h.NAMED_TYPE, name: this.parseName() });
        }
        peekDescription() {
          return this.peek(o.STRING) || this.peek(o.BLOCK_STRING);
        }
        parseDescription() {
          if (this.peekDescription()) return this.parseStringLiteral();
        }
        parseSchemaDefinition() {
          let e = this._lexer.token,
            t = this.parseDescription();
          this.expectKeyword('schema');
          let n = this.parseConstDirectives(),
            r = this.many(o.BRACE_L, this.parseOperationTypeDefinition, o.BRACE_R);
          return this.node(e, {
            kind: g.h.SCHEMA_DEFINITION,
            description: t,
            directives: n,
            operationTypes: r,
          });
        }
        parseOperationTypeDefinition() {
          let e = this._lexer.token,
            t = this.parseOperationType();
          this.expectToken(o.COLON);
          let n = this.parseNamedType();
          return this.node(e, { kind: g.h.OPERATION_TYPE_DEFINITION, operation: t, type: n });
        }
        parseScalarTypeDefinition() {
          let e = this._lexer.token,
            t = this.parseDescription();
          this.expectKeyword('scalar');
          let n = this.parseName(),
            r = this.parseConstDirectives();
          return this.node(e, {
            kind: g.h.SCALAR_TYPE_DEFINITION,
            description: t,
            name: n,
            directives: r,
          });
        }
        parseObjectTypeDefinition() {
          let e = this._lexer.token,
            t = this.parseDescription();
          this.expectKeyword('type');
          let n = this.parseName(),
            r = this.parseImplementsInterfaces(),
            i = this.parseConstDirectives(),
            a = this.parseFieldsDefinition();
          return this.node(e, {
            kind: g.h.OBJECT_TYPE_DEFINITION,
            description: t,
            name: n,
            interfaces: r,
            directives: i,
            fields: a,
          });
        }
        parseImplementsInterfaces() {
          return this.expectOptionalKeyword('implements')
            ? this.delimitedMany(o.AMP, this.parseNamedType)
            : [];
        }
        parseFieldsDefinition() {
          return this.optionalMany(o.BRACE_L, this.parseFieldDefinition, o.BRACE_R);
        }
        parseFieldDefinition() {
          let e = this._lexer.token,
            t = this.parseDescription(),
            n = this.parseName(),
            r = this.parseArgumentDefs();
          this.expectToken(o.COLON);
          let i = this.parseTypeReference(),
            a = this.parseConstDirectives();
          return this.node(e, {
            kind: g.h.FIELD_DEFINITION,
            description: t,
            name: n,
            arguments: r,
            type: i,
            directives: a,
          });
        }
        parseArgumentDefs() {
          return this.optionalMany(o.PAREN_L, this.parseInputValueDef, o.PAREN_R);
        }
        parseInputValueDef() {
          let e;
          let t = this._lexer.token,
            n = this.parseDescription(),
            r = this.parseName();
          this.expectToken(o.COLON);
          let i = this.parseTypeReference();
          this.expectOptionalToken(o.EQUALS) && (e = this.parseConstValueLiteral());
          let a = this.parseConstDirectives();
          return this.node(t, {
            kind: g.h.INPUT_VALUE_DEFINITION,
            description: n,
            name: r,
            type: i,
            defaultValue: e,
            directives: a,
          });
        }
        parseInterfaceTypeDefinition() {
          let e = this._lexer.token,
            t = this.parseDescription();
          this.expectKeyword('interface');
          let n = this.parseName(),
            r = this.parseImplementsInterfaces(),
            i = this.parseConstDirectives(),
            a = this.parseFieldsDefinition();
          return this.node(e, {
            kind: g.h.INTERFACE_TYPE_DEFINITION,
            description: t,
            name: n,
            interfaces: r,
            directives: i,
            fields: a,
          });
        }
        parseUnionTypeDefinition() {
          let e = this._lexer.token,
            t = this.parseDescription();
          this.expectKeyword('union');
          let n = this.parseName(),
            r = this.parseConstDirectives(),
            i = this.parseUnionMemberTypes();
          return this.node(e, {
            kind: g.h.UNION_TYPE_DEFINITION,
            description: t,
            name: n,
            directives: r,
            types: i,
          });
        }
        parseUnionMemberTypes() {
          return this.expectOptionalToken(o.EQUALS)
            ? this.delimitedMany(o.PIPE, this.parseNamedType)
            : [];
        }
        parseEnumTypeDefinition() {
          let e = this._lexer.token,
            t = this.parseDescription();
          this.expectKeyword('enum');
          let n = this.parseName(),
            r = this.parseConstDirectives(),
            i = this.parseEnumValuesDefinition();
          return this.node(e, {
            kind: g.h.ENUM_TYPE_DEFINITION,
            description: t,
            name: n,
            directives: r,
            values: i,
          });
        }
        parseEnumValuesDefinition() {
          return this.optionalMany(o.BRACE_L, this.parseEnumValueDefinition, o.BRACE_R);
        }
        parseEnumValueDefinition() {
          let e = this._lexer.token,
            t = this.parseDescription(),
            n = this.parseEnumValueName(),
            r = this.parseConstDirectives();
          return this.node(e, {
            kind: g.h.ENUM_VALUE_DEFINITION,
            description: t,
            name: n,
            directives: r,
          });
        }
        parseEnumValueName() {
          if (
            'true' === this._lexer.token.value ||
            'false' === this._lexer.token.value ||
            'null' === this._lexer.token.value
          )
            throw f(
              this._lexer.source,
              this._lexer.token.start,
              `${D(this._lexer.token)} is reserved and cannot be used for an enum value.`
            );
          return this.parseName();
        }
        parseInputObjectTypeDefinition() {
          let e = this._lexer.token,
            t = this.parseDescription();
          this.expectKeyword('input');
          let n = this.parseName(),
            r = this.parseConstDirectives(),
            i = this.parseInputFieldsDefinition();
          return this.node(e, {
            kind: g.h.INPUT_OBJECT_TYPE_DEFINITION,
            description: t,
            name: n,
            directives: r,
            fields: i,
          });
        }
        parseInputFieldsDefinition() {
          return this.optionalMany(o.BRACE_L, this.parseInputValueDef, o.BRACE_R);
        }
        parseTypeSystemExtension() {
          let e = this._lexer.lookahead();
          if (e.kind === o.NAME)
            switch (e.value) {
              case 'schema':
                return this.parseSchemaExtension();
              case 'scalar':
                return this.parseScalarTypeExtension();
              case 'type':
                return this.parseObjectTypeExtension();
              case 'interface':
                return this.parseInterfaceTypeExtension();
              case 'union':
                return this.parseUnionTypeExtension();
              case 'enum':
                return this.parseEnumTypeExtension();
              case 'input':
                return this.parseInputObjectTypeExtension();
            }
          throw this.unexpected(e);
        }
        parseSchemaExtension() {
          let e = this._lexer.token;
          this.expectKeyword('extend'), this.expectKeyword('schema');
          let t = this.parseConstDirectives(),
            n = this.optionalMany(o.BRACE_L, this.parseOperationTypeDefinition, o.BRACE_R);
          if (0 === t.length && 0 === n.length) throw this.unexpected();
          return this.node(e, { kind: g.h.SCHEMA_EXTENSION, directives: t, operationTypes: n });
        }
        parseScalarTypeExtension() {
          let e = this._lexer.token;
          this.expectKeyword('extend'), this.expectKeyword('scalar');
          let t = this.parseName(),
            n = this.parseConstDirectives();
          if (0 === n.length) throw this.unexpected();
          return this.node(e, { kind: g.h.SCALAR_TYPE_EXTENSION, name: t, directives: n });
        }
        parseObjectTypeExtension() {
          let e = this._lexer.token;
          this.expectKeyword('extend'), this.expectKeyword('type');
          let t = this.parseName(),
            n = this.parseImplementsInterfaces(),
            r = this.parseConstDirectives(),
            i = this.parseFieldsDefinition();
          if (0 === n.length && 0 === r.length && 0 === i.length) throw this.unexpected();
          return this.node(e, {
            kind: g.h.OBJECT_TYPE_EXTENSION,
            name: t,
            interfaces: n,
            directives: r,
            fields: i,
          });
        }
        parseInterfaceTypeExtension() {
          let e = this._lexer.token;
          this.expectKeyword('extend'), this.expectKeyword('interface');
          let t = this.parseName(),
            n = this.parseImplementsInterfaces(),
            r = this.parseConstDirectives(),
            i = this.parseFieldsDefinition();
          if (0 === n.length && 0 === r.length && 0 === i.length) throw this.unexpected();
          return this.node(e, {
            kind: g.h.INTERFACE_TYPE_EXTENSION,
            name: t,
            interfaces: n,
            directives: r,
            fields: i,
          });
        }
        parseUnionTypeExtension() {
          let e = this._lexer.token;
          this.expectKeyword('extend'), this.expectKeyword('union');
          let t = this.parseName(),
            n = this.parseConstDirectives(),
            r = this.parseUnionMemberTypes();
          if (0 === n.length && 0 === r.length) throw this.unexpected();
          return this.node(e, { kind: g.h.UNION_TYPE_EXTENSION, name: t, directives: n, types: r });
        }
        parseEnumTypeExtension() {
          let e = this._lexer.token;
          this.expectKeyword('extend'), this.expectKeyword('enum');
          let t = this.parseName(),
            n = this.parseConstDirectives(),
            r = this.parseEnumValuesDefinition();
          if (0 === n.length && 0 === r.length) throw this.unexpected();
          return this.node(e, { kind: g.h.ENUM_TYPE_EXTENSION, name: t, directives: n, values: r });
        }
        parseInputObjectTypeExtension() {
          let e = this._lexer.token;
          this.expectKeyword('extend'), this.expectKeyword('input');
          let t = this.parseName(),
            n = this.parseConstDirectives(),
            r = this.parseInputFieldsDefinition();
          if (0 === n.length && 0 === r.length) throw this.unexpected();
          return this.node(e, {
            kind: g.h.INPUT_OBJECT_TYPE_EXTENSION,
            name: t,
            directives: n,
            fields: r,
          });
        }
        parseDirectiveDefinition() {
          let e = this._lexer.token,
            t = this.parseDescription();
          this.expectKeyword('directive'), this.expectToken(o.AT);
          let n = this.parseName(),
            r = this.parseArgumentDefs(),
            i = this.expectOptionalKeyword('repeatable');
          this.expectKeyword('on');
          let a = this.parseDirectiveLocations();
          return this.node(e, {
            kind: g.h.DIRECTIVE_DEFINITION,
            description: t,
            name: n,
            arguments: r,
            repeatable: i,
            locations: a,
          });
        }
        parseDirectiveLocations() {
          return this.delimitedMany(o.PIPE, this.parseDirectiveLocation);
        }
        parseDirectiveLocation() {
          let e = this._lexer.token,
            t = this.parseName();
          if (Object.prototype.hasOwnProperty.call(s, t.value)) return t;
          throw this.unexpected(e);
        }
        node(e, t) {
          return (
            !0 !== this._options.noLocation &&
              (t.loc = new m.Ye(e, this._lexer.lastToken, this._lexer.source)),
            t
          );
        }
        peek(e) {
          return this._lexer.token.kind === e;
        }
        expectToken(e) {
          let t = this._lexer.token;
          if (t.kind === e) return this.advanceLexer(), t;
          throw f(this._lexer.source, t.start, `Expected ${B(e)}, found ${D(t)}.`);
        }
        expectOptionalToken(e) {
          return this._lexer.token.kind === e && (this.advanceLexer(), !0);
        }
        expectKeyword(e) {
          let t = this._lexer.token;
          if (t.kind === o.NAME && t.value === e) this.advanceLexer();
          else throw f(this._lexer.source, t.start, `Expected "${e}", found ${D(t)}.`);
        }
        expectOptionalKeyword(e) {
          let t = this._lexer.token;
          return t.kind === o.NAME && t.value === e && (this.advanceLexer(), !0);
        }
        unexpected(e) {
          let t = null != e ? e : this._lexer.token;
          return f(this._lexer.source, t.start, `Unexpected ${D(t)}.`);
        }
        any(e, t, n) {
          this.expectToken(e);
          let r = [];
          for (; !this.expectOptionalToken(n); ) r.push(t.call(this));
          return r;
        }
        optionalMany(e, t, n) {
          if (this.expectOptionalToken(e)) {
            let e = [];
            do e.push(t.call(this));
            while (!this.expectOptionalToken(n));
            return e;
          }
          return [];
        }
        many(e, t, n) {
          this.expectToken(e);
          let r = [];
          do r.push(t.call(this));
          while (!this.expectOptionalToken(n));
          return r;
        }
        delimitedMany(e, t) {
          this.expectOptionalToken(e);
          let n = [];
          do n.push(t.call(this));
          while (this.expectOptionalToken(e));
          return n;
        }
        advanceLexer() {
          let { maxTokens: e } = this._options,
            t = this._lexer.advance();
          if (t.kind !== o.EOF && (++this._tokenCounter, void 0 !== e && this._tokenCounter > e))
            throw f(
              this._lexer.source,
              t.start,
              `Document contains more that ${e} tokens. Parsing aborted.`
            );
        }
      }
      function D(e) {
        let t = e.value;
        return B(e.kind) + (null != t ? ` "${t}"` : '');
      }
      function B(e) {
        return e === o.BANG ||
          e === o.DOLLAR ||
          e === o.AMP ||
          e === o.PAREN_L ||
          e === o.PAREN_R ||
          e === o.SPREAD ||
          e === o.COLON ||
          e === o.EQUALS ||
          e === o.AT ||
          e === o.BRACKET_L ||
          e === o.BRACKET_R ||
          e === o.BRACE_L ||
          e === o.PIPE ||
          e === o.BRACE_R
          ? `"${e}"`
          : e;
      }
      var U = new Map(),
        L = new Map(),
        F = !0,
        j = !1;
      function q(e) {
        return e.replace(/[\s,]+/g, ' ').trim();
      }
      function V(e) {
        for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
        'string' == typeof e && (e = [e]);
        var r = e[0];
        return (
          t.forEach(function (t, n) {
            t && 'Document' === t.kind ? (r += t.loc.source.body) : (r += t), (r += e[n + 1]);
          }),
          (function (e) {
            var t = q(e);
            if (!U.has(t)) {
              var n,
                r,
                i,
                a,
                s,
                o = (function (e, t) {
                  let n = new R(e, t),
                    r = n.parseDocument();
                  return (
                    Object.defineProperty(r, 'tokenCount', { enumerable: !1, value: n.tokenCount }),
                    r
                  );
                })(e, { experimentalFragmentVariables: j, allowLegacyFragmentVariables: j });
              if (!o || 'Document' !== o.kind) throw Error('Not a valid GraphQL document.');
              U.set(
                t,
                ((a = new Set(
                  ((n = new Set()),
                  (r = []),
                  o.definitions.forEach(function (e) {
                    if ('FragmentDefinition' === e.kind) {
                      var t,
                        i = e.name.value,
                        a = q((t = e.loc).source.body.substring(t.start, t.end)),
                        s = L.get(i);
                      s && !s.has(a)
                        ? F &&
                          console.warn(
                            'Warning: fragment with name ' +
                              i +
                              ' already exists.\ngraphql-tag enforces all fragment names across your application to be unique; read more about\nthis in the docs: http://dev.apollodata.com/core/fragments.html#unique-names'
                          )
                        : s || L.set(i, (s = new Set())),
                        s.add(a),
                        n.has(a) || (n.add(a), r.push(e));
                    } else r.push(e);
                  }),
                  (i = (0, l.__assign)((0, l.__assign)({}, o), { definitions: r }))).definitions
                )).forEach(function (e) {
                  e.loc && delete e.loc,
                    Object.keys(e).forEach(function (t) {
                      var n = e[t];
                      n && 'object' == typeof n && a.add(n);
                    });
                }),
                (s = i.loc) && (delete s.startToken, delete s.endToken),
                i)
              );
            }
            return U.get(t);
          })(r)
        );
      }
      var $ = V;
      ((a = V || (V = {})).gql = $),
        (a.resetCaches = function () {
          U.clear(), L.clear();
        }),
        (a.disableFragmentWarnings = function () {
          F = !1;
        }),
        (a.enableExperimentalFragmentVariables = function () {
          j = !0;
        }),
        (a.disableExperimentalFragmentVariables = function () {
          j = !1;
        }),
        (V.default = V);
    },
    32039: function (e, t) {
      (t.read = function (e, t, n, r, i) {
        var a,
          s,
          o = 8 * i - r - 1,
          l = (1 << o) - 1,
          u = l >> 1,
          c = -7,
          d = n ? i - 1 : 0,
          p = n ? -1 : 1,
          h = e[t + d];
        for (
          d += p, a = h & ((1 << -c) - 1), h >>= -c, c += o;
          c > 0;
          a = 256 * a + e[t + d], d += p, c -= 8
        );
        for (
          s = a & ((1 << -c) - 1), a >>= -c, c += r;
          c > 0;
          s = 256 * s + e[t + d], d += p, c -= 8
        );
        if (0 === a) a = 1 - u;
        else {
          if (a === l) return s ? NaN : (1 / 0) * (h ? -1 : 1);
          (s += Math.pow(2, r)), (a -= u);
        }
        return (h ? -1 : 1) * s * Math.pow(2, a - r);
      }),
        (t.write = function (e, t, n, r, i, a) {
          var s,
            o,
            l,
            u = 8 * a - i - 1,
            c = (1 << u) - 1,
            d = c >> 1,
            p = 23 === i ? 5960464477539062e-23 : 0,
            h = r ? 0 : a - 1,
            y = r ? 1 : -1,
            f = t < 0 || (0 === t && 1 / t < 0) ? 1 : 0;
          for (
            isNaN((t = Math.abs(t))) || t === 1 / 0
              ? ((o = isNaN(t) ? 1 : 0), (s = c))
              : ((s = Math.floor(Math.log(t) / Math.LN2)),
                t * (l = Math.pow(2, -s)) < 1 && (s--, (l *= 2)),
                s + d >= 1 ? (t += p / l) : (t += p * Math.pow(2, 1 - d)),
                t * l >= 2 && (s++, (l /= 2)),
                s + d >= c
                  ? ((o = 0), (s = c))
                  : s + d >= 1
                    ? ((o = (t * l - 1) * Math.pow(2, i)), (s += d))
                    : ((o = t * Math.pow(2, d - 1) * Math.pow(2, i)), (s = 0)));
            i >= 8;
            e[n + h] = 255 & o, h += y, o /= 256, i -= 8
          );
          for (s = (s << i) | o, u += i; u > 0; e[n + h] = 255 & s, h += y, s /= 256, u -= 8);
          e[n + h - y] |= 128 * f;
        });
    },
    84945: function (e, t, n) {
      'use strict';
      e.exports = n(88119);
    },
    88119: function (e, t) {
      'use strict';
      let n = { Remove: 'remove', Replace: 'replace', Add: 'add' },
        r = Symbol.for('__MUTATIVE_PROXY_DRAFT__'),
        i = Symbol('__MUTATIVE_RAW_RETURN_SYMBOL__'),
        a = Symbol.iterator,
        s = { mutable: 'mutable', immutable: 'immutable' },
        o = {};
      function l(e, t) {
        return e instanceof Map ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
      }
      function u(e, t) {
        if (t in e) {
          let n = Reflect.getPrototypeOf(e);
          for (; n; ) {
            let e = Reflect.getOwnPropertyDescriptor(n, t);
            if (e) return e;
            n = Reflect.getPrototypeOf(n);
          }
        }
      }
      function c(e) {
        return Object.getPrototypeOf(e) === Set.prototype;
      }
      function d(e) {
        return Object.getPrototypeOf(e) === Map.prototype;
      }
      function p(e) {
        var t;
        return null !== (t = e.copy) && void 0 !== t ? t : e.original;
      }
      function h(e) {
        return !!y(e);
      }
      function y(e) {
        return 'object' != typeof e ? null : null == e ? void 0 : e[r];
      }
      function f(e) {
        var t;
        let n = y(e);
        return n ? (null !== (t = n.copy) && void 0 !== t ? t : n.original) : e;
      }
      function m(e, t) {
        let n;
        return (
          !!e &&
          'object' == typeof e &&
          (Object.getPrototypeOf(e) === Object.prototype ||
            Array.isArray(e) ||
            e instanceof Map ||
            e instanceof Set ||
            (!!(null == t ? void 0 : t.mark) &&
              ((n = t.mark(e, s)) === s.immutable || 'function' == typeof n)))
        );
      }
      function g(e) {
        return Array.isArray(e) ? 1 : e instanceof Map ? 2 : e instanceof Set ? 3 : 0;
      }
      function b(e, t) {
        return 2 === g(e) ? e.get(t) : e[t];
      }
      function w(e, t, n) {
        2 === g(e) ? e.set(t, n) : (e[t] = n);
      }
      function v(e, t) {
        let n = y(e);
        return (n ? p(n) : e)[t];
      }
      function T(e, t) {
        return e === t ? 0 !== e || 1 / e == 1 / t : e != e && t != t;
      }
      function A(e) {
        if (e) for (; e.finalities.revoke.length > 0; ) e.finalities.revoke.pop()();
      }
      function E(e, t) {
        return t
          ? e
          : ['']
              .concat(e)
              .map((e) => {
                let t = `${e}`;
                return -1 === t.indexOf('/') && -1 === t.indexOf('~')
                  ? t
                  : t.replace(/~/g, '~0').replace(/\//g, '~1');
              })
              .join('/');
      }
      let C = Object.prototype.propertyIsEnumerable;
      function _(e, t) {
        let n;
        if (Array.isArray(e)) return Array.prototype.concat.call(e);
        if (e instanceof Set)
          return c(e)
            ? Set.prototype.difference
              ? Set.prototype.difference.call(e, new Set())
              : new Set(e.values())
            : new (Object.getPrototypeOf(e).constructor)(e.values());
        if (e instanceof Map)
          return d(e) ? new Map(e) : new (Object.getPrototypeOf(e).constructor)(e);
        if ((null == t ? void 0 : t.mark) && void 0 !== (n = t.mark(e, s)) && n !== s.mutable) {
          if (n === s.immutable)
            return (function (e) {
              let t = Object.create(Object.getPrototypeOf(e));
              return (
                Reflect.ownKeys(e).forEach((n) => {
                  let r = Reflect.getOwnPropertyDescriptor(e, n);
                  r.enumerable && r.configurable && r.writable
                    ? (t[n] = e[n])
                    : (r.writable || ((r.writable = !0), (r.configurable = !0)),
                      (r.get || r.set) &&
                        (r = {
                          configurable: !0,
                          writable: !0,
                          enumerable: r.enumerable,
                          value: e[n],
                        }),
                      Reflect.defineProperty(t, n, r));
                }),
                t
              );
            })(e);
          if ('function' == typeof n) return n();
          throw Error(`Unsupported mark result: ${n}`);
        }
        if ('object' == typeof e && Object.getPrototypeOf(e) === Object.prototype) {
          let t = {};
          return (
            Object.keys(e).forEach((n) => {
              t[n] = e[n];
            }),
            Object.getOwnPropertySymbols(e).forEach((n) => {
              C.call(e, n) && (t[n] = e[n]);
            }),
            t
          );
        }
        throw Error('Please check mark() to ensure that it is a stable marker draftable function.');
      }
      function I(e) {
        e.copy || (e.copy = _(e.original, e.options));
      }
      function S(e) {
        if (!m(e)) return f(e);
        if (Array.isArray(e)) return e.map(S);
        if (e instanceof Map) {
          let t = Array.from(e.entries()).map(([e, t]) => [e, S(t)]);
          return d(e) ? new Map(t) : new (Object.getPrototypeOf(e).constructor)(t);
        }
        if (e instanceof Set) {
          let t = Array.from(e).map(S);
          return c(e) ? new Set(t) : new (Object.getPrototypeOf(e).constructor)(t);
        }
        let t = Object.create(Object.getPrototypeOf(e));
        for (let n in e) t[n] = S(e[n]);
        return t;
      }
      function P(e) {
        return h(e) ? S(e) : e;
      }
      function O(e) {
        var t;
        (e.assignedMap = null !== (t = e.assignedMap) && void 0 !== t ? t : new Map()),
          e.operated || ((e.operated = !0), e.parent && O(e.parent));
      }
      function N() {
        throw Error('Cannot modify frozen object');
      }
      function x(e) {
        return e && 'object' == typeof e && !Object.isFrozen(e);
      }
      function M(e, t) {
        let n = g(e);
        if (0 === n)
          Reflect.ownKeys(e).forEach((n) => {
            t(n, e[n], e);
          });
        else if (1 === n) {
          let n = 0;
          for (let r of e) t(n, r, e), (n += 1);
        } else e.forEach((n, r) => t(r, n, e));
      }
      function k(e) {
        3 === e.type &&
          e.copy &&
          (e.copy.clear(),
          e.setMap.forEach((t) => {
            e.copy.add(f(t));
          }));
      }
      function R(e, t, n, r) {
        if (e.operated && e.assignedMap && e.assignedMap.size > 0 && !e.finalized) {
          if (n && r) {
            let i = (function e(t, n = []) {
              if (Object.hasOwnProperty.call(t, 'key')) {
                let e = t.parent.copy,
                  r = y(b(e, t.key));
                if (null !== r && (null == r ? void 0 : r.original) !== t.original) return null;
                let i = 3 === t.parent.type,
                  a = i ? Array.from(t.parent.setMap.keys()).indexOf(t.key) : t.key;
                if (!((i && e.size > a) || l(e, a))) return null;
                n.push(a);
              }
              if (t.parent) return e(t.parent, n);
              n.reverse();
              try {
                !(function (e, t) {
                  for (let n = 0; n < t.length - 1; n += 1) {
                    let r = t[n];
                    if ('object' != typeof (e = b(3 === g(e) ? Array.from(e) : e, r)))
                      throw Error(`Cannot resolve patch at '${t.join('/')}'.`);
                  }
                })(t.copy, n);
              } catch (e) {
                return null;
              }
              return n;
            })(e);
            i && t(e, i, n, r);
          }
          e.finalized = !0;
        }
      }
      function D(e, t, n, r) {
        let i = y(n);
        i &&
          (i.callbacks || (i.callbacks = []),
          i.callbacks.push((a, s) => {
            let o = 3 === e.type ? e.setMap : e.copy;
            if (T(b(o, t), n)) {
              let n = i.original;
              i.copy && (n = i.copy), k(e), R(e, r, a, s), w(o, t, n);
            }
          }),
          e.options.enableAutoFreeze &&
            i.finalities !== e.finalities &&
            (e.options.enableAutoFreeze = !1)),
          m(n, e.options) &&
            e.finalities.draft.push(() => {
              T(b(3 === e.type ? e.setMap : e.copy, t), n) &&
                (function (e, t) {
                  let n = 3 === e.type ? e.setMap : e.copy;
                  e.finalities.revoke.length > 1 &&
                    e.assignedMap.get(t) &&
                    n &&
                    (function e(t, n, r) {
                      if (h(t) || !m(t, r) || n.has(t) || Object.isFrozen(t)) return;
                      let i = t instanceof Set,
                        a = i ? new Map() : void 0;
                      if (
                        (n.add(t),
                        M(t, (s, o) => {
                          var l;
                          if (h(o)) {
                            let e = y(o);
                            I(e),
                              w(
                                i ? a : t,
                                s,
                                (null === (l = e.assignedMap) || void 0 === l ? void 0 : l.size) ||
                                  e.operated
                                  ? e.copy
                                  : e.original
                              );
                          } else e(o, n, r);
                        }),
                        a)
                      ) {
                        let e = Array.from(t);
                        t.clear(),
                          e.forEach((e) => {
                            t.add(a.has(e) ? a.get(e) : e);
                          });
                      }
                    })(b(n, t), e.finalities.handledSet, e.options);
                })(e, t);
            });
      }
      function B(e, t, r, i) {
        let { pathAsArray: a = !0 } = e.options.enablePatches;
        switch (e.type) {
          case 0:
          case 2:
            return (function ({ original: e, copy: t, assignedMap: r }, i, a, s, o) {
              r.forEach((r, u) => {
                let c = b(e, u),
                  d = P(b(t, u)),
                  p = r ? (l(e, u) ? n.Replace : n.Add) : n.Remove;
                if (T(c, d) && p === n.Replace) return;
                let h = E(i.concat(u), o);
                a.push(p === n.Remove ? { op: p, path: h } : { op: p, path: h, value: d }),
                  s.push(
                    p === n.Add
                      ? { op: n.Remove, path: h }
                      : p === n.Remove
                        ? { op: n.Add, path: h, value: c }
                        : { op: n.Replace, path: h, value: c }
                  );
              });
            })(e, t, r, i, a);
          case 1:
            return (function (e, t, r, i, a) {
              let { original: s, assignedMap: o, options: l } = e,
                u = e.copy;
              u.length < s.length && (([s, u] = [u, s]), ([r, i] = [i, r]));
              for (let e = 0; e < s.length; e += 1)
                if (o.get(e.toString()) && u[e] !== s[e]) {
                  let o = E(t.concat([e]), a);
                  r.push({ op: n.Replace, path: o, value: P(u[e]) }),
                    i.push({ op: n.Replace, path: o, value: P(s[e]) });
                }
              for (let e = s.length; e < u.length; e += 1) {
                let i = E(t.concat([e]), a);
                r.push({ op: n.Add, path: i, value: P(u[e]) });
              }
              if (s.length < u.length) {
                let { arrayLengthAssignment: e = !0 } = l.enablePatches;
                if (e) {
                  let e = E(t.concat(['length']), a);
                  i.push({ op: n.Replace, path: e, value: s.length });
                } else
                  for (let e = u.length; s.length < e; e -= 1) {
                    let r = E(t.concat([e - 1]), a);
                    i.push({ op: n.Remove, path: r });
                  }
              }
            })(e, t, r, i, a);
          case 3:
            return (function ({ original: e, copy: t }, r, i, a, s) {
              let o = 0;
              e.forEach((e) => {
                if (!t.has(e)) {
                  let t = E(r.concat([o]), s);
                  i.push({ op: n.Remove, path: t, value: e }),
                    a.unshift({ op: n.Add, path: t, value: e });
                }
                o += 1;
              }),
                (o = 0),
                t.forEach((t) => {
                  if (!e.has(t)) {
                    let e = E(r.concat([o]), s);
                    i.push({ op: n.Add, path: e, value: t }),
                      a.unshift({ op: n.Remove, path: e, value: t });
                  }
                  o += 1;
                });
            })(e, t, r, i, a);
        }
      }
      let U = !1,
        L = (e, t, n = !1) => {
          if ('object' == typeof e && null !== e && (!m(e, t) || n) && !U)
            throw Error(
              "Strict mode: Mutable data cannot be accessed directly, please use 'unsafe(callback)' wrap."
            );
        },
        F = {
          get size() {
            return p(y(this)).size;
          },
          has(e) {
            return p(y(this)).has(e);
          },
          set(e, t) {
            let n = y(this),
              r = p(n);
            return (
              (r.has(e) && T(r.get(e), t)) ||
                (I(n), O(n), n.assignedMap.set(e, !0), n.copy.set(e, t), D(n, e, t, B)),
              this
            );
          },
          delete(e) {
            if (!this.has(e)) return !1;
            let t = y(this);
            return (
              I(t),
              O(t),
              t.original.has(e) ? t.assignedMap.set(e, !1) : t.assignedMap.delete(e),
              t.copy.delete(e),
              !0
            );
          },
          clear() {
            let e = y(this);
            if (this.size) {
              for (let [t] of (I(e), O(e), (e.assignedMap = new Map()), e.original))
                e.assignedMap.set(t, !1);
              e.copy.clear();
            }
          },
          forEach(e, t) {
            p(y(this)).forEach((n, r) => {
              e.call(t, this.get(r), r, this);
            });
          },
          get(e) {
            var t, n;
            let r = y(this),
              i = p(r).get(e),
              a =
                (null === (n = (t = r.options).mark) || void 0 === n ? void 0 : n.call(t, i, s)) ===
                s.mutable;
            if (
              (r.options.strict && L(i, r.options, a),
              a || r.finalized || !m(i, r.options) || i !== r.original.get(e))
            )
              return i;
            let l = o.createDraft({
              original: i,
              parentDraft: r,
              key: e,
              finalities: r.finalities,
              options: r.options,
            });
            return I(r), r.copy.set(e, l), l;
          },
          keys() {
            return p(y(this)).keys();
          },
          values() {
            let e = this.keys();
            return {
              [a]: () => this.values(),
              next: () => {
                let t = e.next();
                return t.done ? t : { done: !1, value: this.get(t.value) };
              },
            };
          },
          entries() {
            let e = this.keys();
            return {
              [a]: () => this.entries(),
              next: () => {
                let t = e.next();
                if (t.done) return t;
                let n = this.get(t.value);
                return { done: !1, value: [t.value, n] };
              },
            };
          },
          [a]() {
            return this.entries();
          },
        },
        j = Reflect.ownKeys(F),
        q =
          (e, t, { isValuesIterator: n }) =>
          () => {
            var r, i;
            let a = t.next();
            if (a.done) return a;
            let l = a.value,
              u = e.setMap.get(l),
              c = y(u),
              d =
                (null === (i = (r = e.options).mark) || void 0 === i ? void 0 : i.call(r, u, s)) ===
                s.mutable;
            if (
              (e.options.strict && L(l, e.options, d),
              d || c || !m(l, e.options) || e.finalized || !e.original.has(l))
            )
              c && (u = c.proxy);
            else {
              let t = o.createDraft({
                original: l,
                parentDraft: e,
                key: l,
                finalities: e.finalities,
                options: e.options,
              });
              e.setMap.set(l, t), (u = t);
            }
            return { done: !1, value: n ? u : [u, u] };
          },
        V = {
          get size() {
            return y(this).setMap.size;
          },
          has(e) {
            let t = y(this);
            if (t.setMap.has(e)) return !0;
            I(t);
            let n = y(e);
            return !(!n || !t.setMap.has(n.original));
          },
          add(e) {
            let t = y(this);
            return (
              this.has(e) ||
                (I(t), O(t), t.assignedMap.set(e, !0), t.setMap.set(e, e), D(t, e, e, B)),
              this
            );
          },
          delete(e) {
            if (!this.has(e)) return !1;
            let t = y(this);
            I(t), O(t);
            let n = y(e);
            return n && t.setMap.has(n.original)
              ? (t.assignedMap.set(n.original, !1), t.setMap.delete(n.original))
              : (!n && t.setMap.has(e) ? t.assignedMap.set(e, !1) : t.assignedMap.delete(e),
                t.setMap.delete(e));
          },
          clear() {
            if (!this.size) return;
            let e = y(this);
            for (let t of (I(e), O(e), e.original)) e.assignedMap.set(t, !1);
            e.setMap.clear();
          },
          values() {
            let e = y(this);
            I(e);
            let t = e.setMap.keys();
            return {
              [Symbol.iterator]: () => this.values(),
              next: q(e, t, { isValuesIterator: !0 }),
            };
          },
          entries() {
            let e = y(this);
            I(e);
            let t = e.setMap.keys();
            return {
              [Symbol.iterator]: () => this.entries(),
              next: q(e, t, { isValuesIterator: !1 }),
            };
          },
          keys() {
            return this.values();
          },
          [a]() {
            return this.values();
          },
          forEach(e, t) {
            let n = this.values(),
              r = n.next();
            for (; !r.done; ) e.call(t, r.value, r.value, this), (r = n.next());
          },
        };
      Set.prototype.difference &&
        Object.assign(V, {
          intersection(e) {
            return Set.prototype.intersection.call(new Set(this.values()), e);
          },
          union(e) {
            return Set.prototype.union.call(new Set(this.values()), e);
          },
          difference(e) {
            return Set.prototype.difference.call(new Set(this.values()), e);
          },
          symmetricDifference(e) {
            return Set.prototype.symmetricDifference.call(new Set(this.values()), e);
          },
          isSubsetOf(e) {
            return Set.prototype.isSubsetOf.call(new Set(this.values()), e);
          },
          isSupersetOf(e) {
            return Set.prototype.isSupersetOf.call(new Set(this.values()), e);
          },
          isDisjointFrom(e) {
            return Set.prototype.isDisjointFrom.call(new Set(this.values()), e);
          },
        });
      let $ = Reflect.ownKeys(V),
        z = new WeakSet(),
        W = {
          get(e, t, n) {
            var i, a;
            let o;
            let c = null === (i = e.copy) || void 0 === i ? void 0 : i[t];
            if (c && z.has(c)) return c;
            if (t === r) return e;
            if (e.options.mark) {
              let r =
                'size' === t && (e.original instanceof Map || e.original instanceof Set)
                  ? Reflect.get(e.original, t)
                  : Reflect.get(e.original, t, n);
              if ((o = e.options.mark(r, s)) === s.mutable)
                return e.options.strict && L(r, e.options, !0), r;
            }
            let d = p(e);
            if (d instanceof Map && j.includes(t)) {
              if ('size' === t) return Object.getOwnPropertyDescriptor(F, 'size').get.call(e.proxy);
              let n = F[t];
              if (n) return n.bind(e.proxy);
            }
            if (d instanceof Set && $.includes(t)) {
              if ('size' === t) return Object.getOwnPropertyDescriptor(V, 'size').get.call(e.proxy);
              let n = V[t];
              if (n) return n.bind(e.proxy);
            }
            if (!l(d, t)) {
              let n = u(d, t);
              return n
                ? 'value' in n
                  ? n.value
                  : null === (a = n.get) || void 0 === a
                    ? void 0
                    : a.call(e.proxy)
                : void 0;
            }
            let h = d[t];
            if ((e.options.strict && L(h, e.options), e.finalized || !m(h, e.options))) return h;
            if (h === v(e.original, t)) {
              if (
                (I(e),
                (e.copy[t] = H({
                  original: e.original[t],
                  parentDraft: e,
                  key: 1 === e.type ? Number(t) : t,
                  finalities: e.finalities,
                  options: e.options,
                })),
                'function' == typeof o)
              ) {
                let n = y(e.copy[t]);
                return I(n), O(n), n.copy;
              }
              return e.copy[t];
            }
            return h;
          },
          set(e, t, n) {
            var r;
            let i;
            if (3 === e.type || 2 === e.type)
              throw Error('Map/Set draft does not support any property assignment.');
            if (
              1 === e.type &&
              'length' !== t &&
              (!(Number.isInteger((i = Number(t))) && i >= 0) ||
                (0 !== t && 0 !== i && String(i) !== String(t)))
            )
              throw Error("Only supports setting array indices and the 'length' property.");
            let a = u(p(e), t);
            if (null == a ? void 0 : a.set) return a.set.call(e.proxy, n), !0;
            let s = v(p(e), t),
              o = y(s);
            return (
              o && T(o.original, n)
                ? ((e.copy[t] = n),
                  (e.assignedMap = null !== (r = e.assignedMap) && void 0 !== r ? r : new Map()),
                  e.assignedMap.set(t, !1))
                : (T(n, s) && (void 0 !== n || l(e.original, t))) ||
                  (I(e),
                  O(e),
                  l(e.original, t) && T(n, e.original[t])
                    ? e.assignedMap.delete(t)
                    : e.assignedMap.set(t, !0),
                  (e.copy[t] = n),
                  D(e, t, n, B)),
              !0
            );
          },
          has: (e, t) => t in p(e),
          ownKeys: (e) => Reflect.ownKeys(p(e)),
          getOwnPropertyDescriptor(e, t) {
            let n = p(e),
              r = Reflect.getOwnPropertyDescriptor(n, t);
            return r
              ? {
                  writable: !0,
                  configurable: 1 !== e.type || 'length' !== t,
                  enumerable: r.enumerable,
                  value: n[t],
                }
              : r;
          },
          getPrototypeOf: (e) => Reflect.getPrototypeOf(e.original),
          setPrototypeOf() {
            throw Error("Cannot call 'setPrototypeOf()' on drafts");
          },
          defineProperty() {
            throw Error("Cannot call 'defineProperty()' on drafts");
          },
          deleteProperty(e, t) {
            var n;
            return 1 === e.type
              ? W.set.call(this, e, t, void 0, e.proxy)
              : (void 0 !== v(e.original, t) || t in e.original
                  ? (I(e), O(e), e.assignedMap.set(t, !1))
                  : ((e.assignedMap = null !== (n = e.assignedMap) && void 0 !== n ? n : new Map()),
                    e.assignedMap.delete(t)),
                e.copy && delete e.copy[t],
                !0);
          },
        };
      function H(e) {
        let { original: t, parentDraft: n, key: r, finalities: i, options: a } = e,
          s = g(t),
          o = {
            type: s,
            finalized: !1,
            parent: n,
            original: t,
            copy: null,
            proxy: null,
            finalities: i,
            options: a,
            setMap: 3 === s ? new Map(t.entries()) : void 0,
          };
        (r || 'key' in e) && (o.key = r);
        let { proxy: l, revoke: u } = Proxy.revocable(1 === s ? Object.assign([], o) : o, W);
        if ((i.revoke.push(u), z.add(l), (o.proxy = l), n))
          n.finalities.draft.push((e, t) => {
            var i;
            let a = y(l),
              s = 3 === n.type ? n.setMap : n.copy,
              o = b(s, r),
              u = y(o);
            if (u) {
              let n = u.original;
              u.operated && (n = f(o)), k(u), R(u, B, e, t), w(s, r, n);
            }
            null === (i = a.callbacks) ||
              void 0 === i ||
              i.forEach((n) => {
                n(e, t);
              });
          });
        else {
          let e = y(l);
          e.finalities.draft.push((t, n) => {
            k(e), R(e, B, t, n);
          });
        }
        return l;
      }
      function G(e) {
        let { rootDraft: t, value: n, useRawReturn: r = !1, isRoot: i = !0 } = e;
        M(n, (n, r, i) => {
          let a = y(r);
          if (a && t && a.finalities === t.finalities) {
            e.isContainDraft = !0;
            let t = a.original;
            if (i instanceof Set) {
              let e = Array.from(i);
              i.clear(), e.forEach((e) => i.add(n === e ? t : e));
            } else w(i, n, t);
          } else 'object' == typeof r && null !== r && ((e.value = r), (e.isRoot = !1), G(e));
        });
      }
      function K(e) {
        if (!h(e)) throw Error(`current() is only used for Draft, parameter: ${e}`);
        return (function e(t) {
          var n;
          let r;
          let i = y(t);
          if (!m(t, null == i ? void 0 : i.options)) return t;
          let a = g(t);
          if (i && !i.operated) return i.original;
          function s() {
            r =
              2 === a
                ? d(t)
                  ? new Map(t)
                  : new (Object.getPrototypeOf(t).constructor)(t)
                : 3 === a
                  ? Array.from(i.setMap.values())
                  : _(t, null == i ? void 0 : i.options);
          }
          if (i) {
            i.finalized = !0;
            try {
              s();
            } finally {
              i.finalized = !1;
            }
          } else r = t;
          if (
            (M(r, (n, a) => {
              if (i && T(b(i.original, n), a)) return;
              let o = e(a);
              o !== a && (r === t && s(), w(r, n, o));
            }),
            3 === a)
          ) {
            let e = null !== (n = null == i ? void 0 : i.original) && void 0 !== n ? n : r;
            return c(e) ? new Set(r) : new (Object.getPrototypeOf(e).constructor)(r);
          }
          return r;
        })(e);
      }
      o.createDraft = H;
      let Q = (e) =>
          function t(r, a, o) {
            var l, u, c;
            let d;
            if ('function' == typeof r && 'function' != typeof a)
              return function (e, ...n) {
                return t(e, (e) => r.call(this, e, ...n), a);
              };
            let p = o;
            'function' != typeof a && (p = a), (p = Object.assign(Object.assign({}, e), p));
            let f = h(r) ? K(r) : r,
              b = Array.isArray(p.mark)
                ? (e, t) => {
                    for (let n of p.mark) {
                      let r = n(e, t);
                      if (r) return r;
                    }
                  }
                : p.mark,
              w = null !== (l = p.enablePatches) && void 0 !== l && l,
              v = null !== (u = p.strict) && void 0 !== u && u,
              E = {
                enableAutoFreeze: null !== (c = p.enableAutoFreeze) && void 0 !== c && c,
                mark: b,
                strict: v,
                enablePatches: w,
              };
            if (!m(f, E) && 'object' == typeof f && null !== f)
              throw Error(
                'Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.'
              );
            let [C, _] = (function (e, t) {
              var r;
              let i, a;
              let o = { draft: [], revoke: [], handledSet: new WeakSet() };
              t.enablePatches && ((i = []), (a = []));
              let l =
                (null === (r = t.mark) || void 0 === r ? void 0 : r.call(t, e, s)) !== s.mutable &&
                m(e, t)
                  ? H({ original: e, parentDraft: null, finalities: o, options: t })
                  : e;
              return [
                l,
                (e = []) => {
                  let [r, s, o] = (function (e, t, r, i, a) {
                    var s;
                    let o = y(e),
                      l = null !== (s = null == o ? void 0 : o.original) && void 0 !== s ? s : e,
                      u = !!t.length;
                    if (null == o ? void 0 : o.operated)
                      for (; o.finalities.draft.length > 0; ) o.finalities.draft.pop()(r, i);
                    let c = u ? t[0] : o ? (o.operated ? o.copy : o.original) : e;
                    return (
                      o && A(o),
                      a &&
                        (function e(t, n, r, i, a) {
                          if (!(Object.isFrozen(t) || h(t)))
                            switch (g(t)) {
                              case 2:
                                for (let [n, r] of t) x(n) && e(n), x(r) && e(r);
                                t.set = t.clear = t.delete = N;
                                break;
                              case 3:
                                for (let n of t) x(n) && e(n);
                                t.add = t.clear = t.delete = N;
                                break;
                              case 1:
                                for (let n of (Object.freeze(t), t)) x(n) && e(n);
                                break;
                              default:
                                Object.freeze(t),
                                  Object.keys(t).forEach((n) => {
                                    let r = t[n];
                                    x(r) && e(r);
                                  });
                            }
                        })(c, 0, null == o || o.options.updatedValues),
                      [
                        c,
                        r && u ? [{ op: n.Replace, path: [], value: t[0] }] : r,
                        i && u ? [{ op: n.Replace, path: [], value: l }] : i,
                      ]
                    );
                  })(l, e, i, a, t.enableAutoFreeze);
                  return t.enablePatches ? [r, s, o] : r;
                },
              ];
            })(f, E);
            if ('function' != typeof a) {
              if (!m(f, E))
                throw Error(
                  'Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.'
                );
              return [C, _];
            }
            try {
              d = a(C);
            } catch (e) {
              throw (A(y(C)), e);
            }
            let I = (e) => {
              let t = y(C);
              if (!h(e)) {
                if (void 0 !== e && !T(e, C) && (null == t ? void 0 : t.operated))
                  throw Error(
                    'Either the value is returned as a new non-draft value, or only the draft is modified without returning any value.'
                  );
                let n = null == e ? void 0 : e[i];
                if (n) {
                  let r = n[0];
                  return (
                    E.strict &&
                      'object' == typeof e &&
                      null !== e &&
                      G({ rootDraft: t, value: e, useRawReturn: !0 }),
                    _([r])
                  );
                }
                if (void 0 !== e)
                  return (
                    'object' == typeof e && null !== e && G({ rootDraft: t, value: e }), _([e])
                  );
              }
              if (e === C || void 0 === e) return _([]);
              let n = y(e);
              if (E === n.options) {
                if (n.operated) throw Error('Cannot return a modified child draft.');
                return _([K(e)]);
              }
              return _([e]);
            };
            return d instanceof Promise
              ? d.then(I, (e) => {
                  throw (A(y(C)), e);
                })
              : I(d);
          },
        Y = Q(),
        Z = Object.prototype.constructor.toString();
      (t.apply = function (e, t, r) {
        let i;
        for (i = t.length - 1; i >= 0; i -= 1) {
          let { value: r, op: a, path: s } = t[i];
          if ((!s.length && a === n.Replace) || ('' === s && a === n.Add)) {
            e = r;
            break;
          }
        }
        i > -1 && (t = t.slice(i + 1));
        let a = (e) => {
          t.forEach((t) => {
            let { path: r, op: i } = t,
              a = Array.isArray(r)
                ? r
                : r
                    .split('/')
                    .map((e) => e.replace(/~1/g, '/').replace(/~0/g, '~'))
                    .slice(1),
              s = e;
            for (let e = 0; e < a.length - 1; e += 1) {
              let t = g(s),
                n = a[e];
              if (
                ('string' != typeof n && 'number' != typeof n && (n = String(n)),
                ((0 === t || 1 === t) && ('__proto__' === n || 'constructor' === n)) ||
                  ('function' == typeof s && 'prototype' === n))
              )
                throw Error(
                  'Patching reserved attributes like __proto__ and constructor is not allowed.'
                );
              if ('object' != typeof (s = b(3 === t ? Array.from(s) : s, n)))
                throw Error(`Cannot apply patch at '${a.join('/')}'.`);
            }
            let o = g(s),
              l = S(t.value),
              u = a[a.length - 1];
            switch (i) {
              case n.Replace:
                switch (o) {
                  case 2:
                    return s.set(u, l);
                  case 3:
                    throw Error('Cannot apply replace patch to set.');
                  default:
                    return (s[u] = l);
                }
              case n.Add:
                switch (o) {
                  case 1:
                    return '-' === u ? s.push(l) : s.splice(u, 0, l);
                  case 2:
                    return s.set(u, l);
                  case 3:
                    return s.add(l);
                  default:
                    return (s[u] = l);
                }
              case n.Remove:
                switch (o) {
                  case 1:
                    return s.splice(u, 1);
                  case 2:
                    return s.delete(u);
                  case 3:
                    return s.delete(t.value);
                  default:
                    return delete s[u];
                }
              default:
                throw Error(`Unsupported patch operation: ${i}.`);
            }
          });
        };
        if (h(e)) {
          if (void 0 !== r) throw Error('Cannot apply patches with options to a draft.');
          return a(e), e;
        }
        return Y(e, a, Object.assign(Object.assign({}, r), { enablePatches: !1 }));
      }),
        (t.castDraft = function (e) {
          return e;
        }),
        (t.castImmutable = function (e) {
          return e;
        }),
        (t.castMutable = function (e) {
          return e;
        }),
        (t.create = Y),
        (t.current = K),
        (t.isDraft = h),
        (t.isDraftable = m),
        (t.makeCreator = Q),
        (t.markSimpleObject = (e) => {
          if (
            ((e) => {
              if (!e || 'object' != typeof e) return !1;
              let t = Object.getPrototypeOf(e);
              if (null === t) return !0;
              let n = Object.hasOwnProperty.call(t, 'constructor') && t.constructor;
              return n === Object || ('function' == typeof n && Function.toString.call(n) === Z);
            })(e)
          )
            return s.immutable;
        }),
        (t.original = function (e) {
          let t = y(e);
          if (!t) throw Error(`original() is only used for a draft, parameter: ${e}`);
          return t.original;
        }),
        (t.rawReturn = function (e) {
          if (0 == arguments.length) throw Error('rawReturn() must be called with a value.');
          if (arguments.length > 1) throw Error('rawReturn() must be called with one argument.');
          return { [i]: [e] };
        }),
        (t.unsafe = function (e) {
          let t;
          U = !0;
          try {
            t = e();
          } finally {
            U = !1;
          }
          return t;
        });
    },
    85957: function (e, t, n) {
      'use strict';
      var r = n(21876);
      n.o(r, 'useParams') &&
        n.d(t, {
          useParams: function () {
            return r.useParams;
          },
        }),
        n.o(r, 'usePathname') &&
          n.d(t, {
            usePathname: function () {
              return r.usePathname;
            },
          }),
        n.o(r, 'useRouter') &&
          n.d(t, {
            useRouter: function () {
              return r.useRouter;
            },
          }),
        n.o(r, 'useSearchParams') &&
          n.d(t, {
            useSearchParams: function () {
              return r.useSearchParams;
            },
          });
    },
    56398: function (e) {
      'use strict';
      function t(e) {
        try {
          return JSON.stringify(e);
        } catch (e) {
          return '"[Circular]"';
        }
      }
      e.exports = function (e, n, r) {
        var i = (r && r.stringify) || t;
        if ('object' == typeof e && null !== e) {
          var a = n.length + 1;
          if (1 === a) return e;
          var s = Array(a);
          s[0] = i(e);
          for (var o = 1; o < a; o++) s[o] = i(n[o]);
          return s.join(' ');
        }
        if ('string' != typeof e) return e;
        var l = n.length;
        if (0 === l) return e;
        for (var u = '', c = 0, d = -1, p = (e && e.length) || 0, h = 0; h < p; ) {
          if (37 === e.charCodeAt(h) && h + 1 < p) {
            switch (((d = d > -1 ? d : 0), e.charCodeAt(h + 1))) {
              case 100:
              case 102:
                if (c >= l || null == n[c]) break;
                d < h && (u += e.slice(d, h)), (u += Number(n[c])), (d = h + 2), h++;
                break;
              case 105:
                if (c >= l || null == n[c]) break;
                d < h && (u += e.slice(d, h)), (u += Math.floor(Number(n[c]))), (d = h + 2), h++;
                break;
              case 79:
              case 111:
              case 106:
                if (c >= l || void 0 === n[c]) break;
                d < h && (u += e.slice(d, h));
                var y = typeof n[c];
                if ('string' === y) {
                  (u += "'" + n[c] + "'"), (d = h + 2), h++;
                  break;
                }
                if ('function' === y) {
                  (u += n[c].name || '<anonymous>'), (d = h + 2), h++;
                  break;
                }
                (u += i(n[c])), (d = h + 2), h++;
                break;
              case 115:
                if (c >= l) break;
                d < h && (u += e.slice(d, h)), (u += String(n[c])), (d = h + 2), h++;
                break;
              case 37:
                d < h && (u += e.slice(d, h)), (u += '%'), (d = h + 2), h++, c--;
            }
            ++c;
          }
          ++h;
        }
        return -1 === d ? e : (d < p && (u += e.slice(d)), u);
      };
    },
    90746: function (e, t, n) {
      'use strict';
      (e.exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = void 0),
        (e.exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = void 0),
        (e.exports.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = void 0),
        Object.assign(e.exports, n(58258));
    },
    37412: function (e, t, n) {
      'use strict';
      n.r(t),
        n.d(t, {
          __assign: function () {
            return a;
          },
          __asyncDelegator: function () {
            return v;
          },
          __asyncGenerator: function () {
            return w;
          },
          __asyncValues: function () {
            return T;
          },
          __await: function () {
            return b;
          },
          __awaiter: function () {
            return c;
          },
          __classPrivateFieldGet: function () {
            return _;
          },
          __classPrivateFieldSet: function () {
            return I;
          },
          __createBinding: function () {
            return p;
          },
          __decorate: function () {
            return o;
          },
          __exportStar: function () {
            return h;
          },
          __extends: function () {
            return i;
          },
          __generator: function () {
            return d;
          },
          __importDefault: function () {
            return C;
          },
          __importStar: function () {
            return E;
          },
          __makeTemplateObject: function () {
            return A;
          },
          __metadata: function () {
            return u;
          },
          __param: function () {
            return l;
          },
          __read: function () {
            return f;
          },
          __rest: function () {
            return s;
          },
          __spread: function () {
            return m;
          },
          __spreadArrays: function () {
            return g;
          },
          __values: function () {
            return y;
          },
        });
      var r = function (e, t) {
        return (r =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (e, t) {
              e.__proto__ = t;
            }) ||
          function (e, t) {
            for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]);
          })(e, t);
      };
      function i(e, t) {
        function n() {
          this.constructor = e;
        }
        r(e, t),
          (e.prototype = null === t ? Object.create(t) : ((n.prototype = t.prototype), new n()));
      }
      var a = function () {
        return (a =
          Object.assign ||
          function (e) {
            for (var t, n = 1, r = arguments.length; n < r; n++)
              for (var i in (t = arguments[n]))
                Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e;
          }).apply(this, arguments);
      };
      function s(e, t) {
        var n = {};
        for (var r in e)
          Object.prototype.hasOwnProperty.call(e, r) && 0 > t.indexOf(r) && (n[r] = e[r]);
        if (null != e && 'function' == typeof Object.getOwnPropertySymbols)
          for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
            0 > t.indexOf(r[i]) &&
              Object.prototype.propertyIsEnumerable.call(e, r[i]) &&
              (n[r[i]] = e[r[i]]);
        return n;
      }
      function o(e, t, n, r) {
        var i,
          a = arguments.length,
          s = a < 3 ? t : null === r ? (r = Object.getOwnPropertyDescriptor(t, n)) : r;
        if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate)
          s = Reflect.decorate(e, t, n, r);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (i = e[o]) && (s = (a < 3 ? i(s) : a > 3 ? i(t, n, s) : i(t, n)) || s);
        return a > 3 && s && Object.defineProperty(t, n, s), s;
      }
      function l(e, t) {
        return function (n, r) {
          t(n, r, e);
        };
      }
      function u(e, t) {
        if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata)
          return Reflect.metadata(e, t);
      }
      function c(e, t, n, r) {
        return new (n || (n = Promise))(function (i, a) {
          function s(e) {
            try {
              l(r.next(e));
            } catch (e) {
              a(e);
            }
          }
          function o(e) {
            try {
              l(r.throw(e));
            } catch (e) {
              a(e);
            }
          }
          function l(e) {
            var t;
            e.done
              ? i(e.value)
              : ((t = e.value) instanceof n
                  ? t
                  : new n(function (e) {
                      e(t);
                    })
                ).then(s, o);
          }
          l((r = r.apply(e, t || [])).next());
        });
      }
      function d(e, t) {
        var n,
          r,
          i,
          a,
          s = {
            label: 0,
            sent: function () {
              if (1 & i[0]) throw i[1];
              return i[1];
            },
            trys: [],
            ops: [],
          };
        return (
          (a = { next: o(0), throw: o(1), return: o(2) }),
          'function' == typeof Symbol &&
            (a[Symbol.iterator] = function () {
              return this;
            }),
          a
        );
        function o(a) {
          return function (o) {
            return (function (a) {
              if (n) throw TypeError('Generator is already executing.');
              for (; s; )
                try {
                  if (
                    ((n = 1),
                    r &&
                      (i =
                        2 & a[0]
                          ? r.return
                          : a[0]
                            ? r.throw || ((i = r.return) && i.call(r), 0)
                            : r.next) &&
                      !(i = i.call(r, a[1])).done)
                  )
                    return i;
                  switch (((r = 0), i && (a = [2 & a[0], i.value]), a[0])) {
                    case 0:
                    case 1:
                      i = a;
                      break;
                    case 4:
                      return s.label++, { value: a[1], done: !1 };
                    case 5:
                      s.label++, (r = a[1]), (a = [0]);
                      continue;
                    case 7:
                      (a = s.ops.pop()), s.trys.pop();
                      continue;
                    default:
                      if (
                        !(i = (i = s.trys).length > 0 && i[i.length - 1]) &&
                        (6 === a[0] || 2 === a[0])
                      ) {
                        s = 0;
                        continue;
                      }
                      if (3 === a[0] && (!i || (a[1] > i[0] && a[1] < i[3]))) {
                        s.label = a[1];
                        break;
                      }
                      if (6 === a[0] && s.label < i[1]) {
                        (s.label = i[1]), (i = a);
                        break;
                      }
                      if (i && s.label < i[2]) {
                        (s.label = i[2]), s.ops.push(a);
                        break;
                      }
                      i[2] && s.ops.pop(), s.trys.pop();
                      continue;
                  }
                  a = t.call(e, s);
                } catch (e) {
                  (a = [6, e]), (r = 0);
                } finally {
                  n = i = 0;
                }
              if (5 & a[0]) throw a[1];
              return { value: a[0] ? a[1] : void 0, done: !0 };
            })([a, o]);
          };
        }
      }
      function p(e, t, n, r) {
        void 0 === r && (r = n), (e[r] = t[n]);
      }
      function h(e, t) {
        for (var n in e) 'default' === n || t.hasOwnProperty(n) || (t[n] = e[n]);
      }
      function y(e) {
        var t = 'function' == typeof Symbol && Symbol.iterator,
          n = t && e[t],
          r = 0;
        if (n) return n.call(e);
        if (e && 'number' == typeof e.length)
          return {
            next: function () {
              return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e };
            },
          };
        throw TypeError(t ? 'Object is not iterable.' : 'Symbol.iterator is not defined.');
      }
      function f(e, t) {
        var n = 'function' == typeof Symbol && e[Symbol.iterator];
        if (!n) return e;
        var r,
          i,
          a = n.call(e),
          s = [];
        try {
          for (; (void 0 === t || t-- > 0) && !(r = a.next()).done; ) s.push(r.value);
        } catch (e) {
          i = { error: e };
        } finally {
          try {
            r && !r.done && (n = a.return) && n.call(a);
          } finally {
            if (i) throw i.error;
          }
        }
        return s;
      }
      function m() {
        for (var e = [], t = 0; t < arguments.length; t++) e = e.concat(f(arguments[t]));
        return e;
      }
      function g() {
        for (var e = 0, t = 0, n = arguments.length; t < n; t++) e += arguments[t].length;
        for (var r = Array(e), i = 0, t = 0; t < n; t++)
          for (var a = arguments[t], s = 0, o = a.length; s < o; s++, i++) r[i] = a[s];
        return r;
      }
      function b(e) {
        return this instanceof b ? ((this.v = e), this) : new b(e);
      }
      function w(e, t, n) {
        if (!Symbol.asyncIterator) throw TypeError('Symbol.asyncIterator is not defined.');
        var r,
          i = n.apply(e, t || []),
          a = [];
        return (
          (r = {}),
          s('next'),
          s('throw'),
          s('return'),
          (r[Symbol.asyncIterator] = function () {
            return this;
          }),
          r
        );
        function s(e) {
          i[e] &&
            (r[e] = function (t) {
              return new Promise(function (n, r) {
                a.push([e, t, n, r]) > 1 || o(e, t);
              });
            });
        }
        function o(e, t) {
          try {
            var n;
            (n = i[e](t)).value instanceof b
              ? Promise.resolve(n.value.v).then(l, u)
              : c(a[0][2], n);
          } catch (e) {
            c(a[0][3], e);
          }
        }
        function l(e) {
          o('next', e);
        }
        function u(e) {
          o('throw', e);
        }
        function c(e, t) {
          e(t), a.shift(), a.length && o(a[0][0], a[0][1]);
        }
      }
      function v(e) {
        var t, n;
        return (
          (t = {}),
          r('next'),
          r('throw', function (e) {
            throw e;
          }),
          r('return'),
          (t[Symbol.iterator] = function () {
            return this;
          }),
          t
        );
        function r(r, i) {
          t[r] = e[r]
            ? function (t) {
                return (n = !n) ? { value: b(e[r](t)), done: 'return' === r } : i ? i(t) : t;
              }
            : i;
        }
      }
      function T(e) {
        if (!Symbol.asyncIterator) throw TypeError('Symbol.asyncIterator is not defined.');
        var t,
          n = e[Symbol.asyncIterator];
        return n
          ? n.call(e)
          : ((e = y(e)),
            (t = {}),
            r('next'),
            r('throw'),
            r('return'),
            (t[Symbol.asyncIterator] = function () {
              return this;
            }),
            t);
        function r(n) {
          t[n] =
            e[n] &&
            function (t) {
              return new Promise(function (r, i) {
                !(function (e, t, n, r) {
                  Promise.resolve(r).then(function (t) {
                    e({ value: t, done: n });
                  }, t);
                })(r, i, (t = e[n](t)).done, t.value);
              });
            };
        }
      }
      function A(e, t) {
        return (
          Object.defineProperty ? Object.defineProperty(e, 'raw', { value: t }) : (e.raw = t), e
        );
      }
      function E(e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e) for (var n in e) Object.hasOwnProperty.call(e, n) && (t[n] = e[n]);
        return (t.default = e), t;
      }
      function C(e) {
        return e && e.__esModule ? e : { default: e };
      }
      function _(e, t) {
        if (!t.has(e)) throw TypeError('attempted to get private field on non-instance');
        return t.get(e);
      }
      function I(e, t, n) {
        if (!t.has(e)) throw TypeError('attempted to set private field on non-instance');
        return t.set(e, n), n;
      }
    },
    4780: function (e, t, n) {
      'use strict';
      var r = n(58258),
        i =
          'function' == typeof Object.is
            ? Object.is
            : function (e, t) {
                return (e === t && (0 !== e || 1 / e == 1 / t)) || (e != e && t != t);
              },
        a = r.useState,
        s = r.useEffect,
        o = r.useLayoutEffect,
        l = r.useDebugValue;
      function u(e) {
        var t = e.getSnapshot;
        e = e.value;
        try {
          var n = t();
          return !i(e, n);
        } catch (e) {
          return !0;
        }
      }
      var c =
        'undefined' == typeof window ||
        void 0 === window.document ||
        void 0 === window.document.createElement
          ? function (e, t) {
              return t();
            }
          : function (e, t) {
              var n = t(),
                r = a({ inst: { value: n, getSnapshot: t } }),
                i = r[0].inst,
                c = r[1];
              return (
                o(
                  function () {
                    (i.value = n), (i.getSnapshot = t), u(i) && c({ inst: i });
                  },
                  [e, n, t]
                ),
                s(
                  function () {
                    return (
                      u(i) && c({ inst: i }),
                      e(function () {
                        u(i) && c({ inst: i });
                      })
                    );
                  },
                  [e]
                ),
                l(n),
                n
              );
            };
      t.useSyncExternalStore = void 0 !== r.useSyncExternalStore ? r.useSyncExternalStore : c;
    },
    55246: function (e, t, n) {
      'use strict';
      var r = n(58258),
        i = n(72463),
        a =
          'function' == typeof Object.is
            ? Object.is
            : function (e, t) {
                return (e === t && (0 !== e || 1 / e == 1 / t)) || (e != e && t != t);
              },
        s = i.useSyncExternalStore,
        o = r.useRef,
        l = r.useEffect,
        u = r.useMemo,
        c = r.useDebugValue;
      t.useSyncExternalStoreWithSelector = function (e, t, n, r, i) {
        var d = o(null);
        if (null === d.current) {
          var p = { hasValue: !1, value: null };
          d.current = p;
        } else p = d.current;
        var h = s(
          e,
          (d = u(
            function () {
              function e(e) {
                if (!l) {
                  if (((l = !0), (s = e), (e = r(e)), void 0 !== i && p.hasValue)) {
                    var t = p.value;
                    if (i(t, e)) return (o = t);
                  }
                  return (o = e);
                }
                if (((t = o), a(s, e))) return t;
                var n = r(e);
                return void 0 !== i && i(t, n) ? ((s = e), t) : ((s = e), (o = n));
              }
              var s,
                o,
                l = !1,
                u = void 0 === n ? null : n;
              return [
                function () {
                  return e(t());
                },
                null === u
                  ? void 0
                  : function () {
                      return e(u());
                    },
              ];
            },
            [t, n, r, i]
          ))[0],
          d[1]
        );
        return (
          l(
            function () {
              (p.hasValue = !0), (p.value = h);
            },
            [h]
          ),
          c(h),
          h
        );
      };
    },
    72463: function (e, t, n) {
      'use strict';
      e.exports = n(4780);
    },
    96261: function (e, t, n) {
      'use strict';
      e.exports = n(55246);
    },
    96803: function (e) {
      'use strict';
      e.exports = function () {
        throw Error(
          'ws does not work in the browser. Browser clients must use the native WebSocket object'
        );
      };
    },
    28619: function (e, t, n) {
      'use strict';
      let r = n(56398);
      e.exports = a;
      let i =
        (function () {
          function e(e) {
            return void 0 !== e && e;
          }
          try {
            if ('undefined' != typeof globalThis) return globalThis;
            return (
              Object.defineProperty(Object.prototype, 'globalThis', {
                get: function () {
                  return delete Object.prototype.globalThis, (this.globalThis = this);
                },
                configurable: !0,
              }),
              globalThis
            );
          } catch (t) {
            return e(self) || e(window) || e(this) || {};
          }
        })().console || {};
      function a(e) {
        var t, n;
        (e = e || {}).browser = e.browser || {};
        let r = e.browser.transmit;
        if (r && 'function' != typeof r.send)
          throw Error('pino: transmit option must have a send function');
        let c = e.browser.write || i;
        e.browser.write && (e.browser.asObject = !0);
        let d = e.serializers || {},
          f = Array.isArray((t = e.browser.serialize))
            ? t.filter(function (e) {
                return '!stdSerializers.err' !== e;
              })
            : !0 === t && Object.keys(d),
          m = e.browser.serialize;
        Array.isArray(e.browser.serialize) &&
          e.browser.serialize.indexOf('!stdSerializers.err') > -1 &&
          (m = !1),
          'function' == typeof c && (c.error = c.fatal = c.warn = c.info = c.debug = c.trace = c),
          !1 === e.enabled && (e.level = 'silent');
        let g = e.level || 'info',
          b = Object.create(c);
        b.log || (b.log = p),
          Object.defineProperty(b, 'levelVal', {
            get: function () {
              return 'silent' === this.level ? 1 / 0 : this.levels.values[this.level];
            },
          }),
          Object.defineProperty(b, 'level', {
            get: function () {
              return this._level;
            },
            set: function (e) {
              if ('silent' !== e && !this.levels.values[e]) throw Error('unknown level ' + e);
              (this._level = e),
                s(w, b, 'error', 'log'),
                s(w, b, 'fatal', 'error'),
                s(w, b, 'warn', 'error'),
                s(w, b, 'info', 'log'),
                s(w, b, 'debug', 'log'),
                s(w, b, 'trace', 'log');
            },
          });
        let w = {
          transmit: r,
          serialize: f,
          asObject: e.browser.asObject,
          levels: ['error', 'fatal', 'warn', 'info', 'debug', 'trace'],
          timestamp:
            'function' == typeof (n = e).timestamp ? n.timestamp : !1 === n.timestamp ? h : y,
        };
        return (
          (b.levels = a.levels),
          (b.level = g),
          (b.setMaxListeners =
            b.getMaxListeners =
            b.emit =
            b.addListener =
            b.on =
            b.prependListener =
            b.once =
            b.prependOnceListener =
            b.removeListener =
            b.removeAllListeners =
            b.listeners =
            b.listenerCount =
            b.eventNames =
            b.write =
            b.flush =
              p),
          (b.serializers = d),
          (b._serialize = f),
          (b._stdErrSerialize = m),
          (b.child = function (t, n) {
            if (!t) throw Error('missing bindings for child Pino');
            (n = n || {}), f && t.serializers && (n.serializers = t.serializers);
            let i = n.serializers;
            if (f && i) {
              var a = Object.assign({}, d, i),
                s = !0 === e.browser.serialize ? Object.keys(a) : f;
              delete t.serializers, o([t], s, a, this._stdErrSerialize);
            }
            function c(e) {
              (this._childLevel = (0 | e._childLevel) + 1),
                (this.error = l(e, t, 'error')),
                (this.fatal = l(e, t, 'fatal')),
                (this.warn = l(e, t, 'warn')),
                (this.info = l(e, t, 'info')),
                (this.debug = l(e, t, 'debug')),
                (this.trace = l(e, t, 'trace')),
                a && ((this.serializers = a), (this._serialize = s)),
                r && (this._logEvent = u([].concat(e._logEvent.bindings, t)));
            }
            return (c.prototype = this), new c(this);
          }),
          r && (b._logEvent = u()),
          b
        );
      }
      function s(e, t, n, s) {
        let l = Object.getPrototypeOf(t);
        (t[n] = t.levelVal > t.levels.values[n] ? p : l[n] ? l[n] : i[n] || i[s] || p),
          (function (e, t, n) {
            if (e.transmit || t[n] !== p) {
              var s;
              t[n] =
                ((s = t[n]),
                function () {
                  let l = e.timestamp(),
                    c = Array(arguments.length),
                    d = Object.getPrototypeOf && Object.getPrototypeOf(this) === i ? i : this;
                  for (var p = 0; p < c.length; p++) c[p] = arguments[p];
                  if (
                    (e.serialize &&
                      !e.asObject &&
                      o(c, this._serialize, this.serializers, this._stdErrSerialize),
                    e.asObject
                      ? s.call(
                          d,
                          (function (e, t, n, i) {
                            e._serialize && o(n, e._serialize, e.serializers, e._stdErrSerialize);
                            let s = n.slice(),
                              l = s[0],
                              u = {};
                            i && (u.time = i), (u.level = a.levels.values[t]);
                            let c = (0 | e._childLevel) + 1;
                            if ((c < 1 && (c = 1), null !== l && 'object' == typeof l)) {
                              for (; c-- && 'object' == typeof s[0]; ) Object.assign(u, s.shift());
                              l = s.length ? r(s.shift(), s) : void 0;
                            } else 'string' == typeof l && (l = r(s.shift(), s));
                            return void 0 !== l && (u.msg = l), u;
                          })(this, n, c, l)
                        )
                      : s.apply(d, c),
                    e.transmit)
                  ) {
                    let r = e.transmit.level || t.level,
                      i = a.levels.values[r],
                      s = a.levels.values[n];
                    if (s < i) return;
                    (function (e, t, n) {
                      let r = t.send,
                        i = t.ts,
                        a = t.methodLevel,
                        s = t.methodValue,
                        l = t.val,
                        c = e._logEvent.bindings;
                      o(
                        n,
                        e._serialize || Object.keys(e.serializers),
                        e.serializers,
                        void 0 === e._stdErrSerialize || e._stdErrSerialize
                      ),
                        (e._logEvent.ts = i),
                        (e._logEvent.messages = n.filter(function (e) {
                          return -1 === c.indexOf(e);
                        })),
                        (e._logEvent.level.label = a),
                        (e._logEvent.level.value = s),
                        r(a, e._logEvent, l),
                        (e._logEvent = u(c));
                    })(
                      this,
                      {
                        ts: l,
                        methodLevel: n,
                        methodValue: s,
                        transmitLevel: r,
                        transmitValue: a.levels.values[e.transmit.level || t.level],
                        send: e.transmit.send,
                        val: t.levelVal,
                      },
                      c
                    );
                  }
                });
            }
          })(e, t, n);
      }
      function o(e, t, n, r) {
        for (let i in e)
          if (r && e[i] instanceof Error) e[i] = a.stdSerializers.err(e[i]);
          else if ('object' == typeof e[i] && !Array.isArray(e[i]))
            for (let r in e[i]) t && t.indexOf(r) > -1 && r in n && (e[i][r] = n[r](e[i][r]));
      }
      function l(e, t, n) {
        return function () {
          let r = Array(1 + arguments.length);
          r[0] = t;
          for (var i = 1; i < r.length; i++) r[i] = arguments[i - 1];
          return e[n].apply(this, r);
        };
      }
      function u(e) {
        return { ts: 0, messages: [], bindings: e || [], level: { label: '', value: 0 } };
      }
      function c() {
        return {};
      }
      function d(e) {
        return e;
      }
      function p() {}
      function h() {
        return !1;
      }
      function y() {
        return Date.now();
      }
      (a.levels = {
        values: { fatal: 60, error: 50, warn: 40, info: 30, debug: 20, trace: 10 },
        labels: { 10: 'trace', 20: 'debug', 30: 'info', 40: 'warn', 50: 'error', 60: 'fatal' },
      }),
        (a.stdSerializers = {
          mapHttpRequest: c,
          mapHttpResponse: c,
          wrapRequestSerializer: d,
          wrapResponseSerializer: d,
          wrapErrorSerializer: d,
          req: c,
          res: c,
          err: function (e) {
            let t = { type: e.constructor.name, msg: e.message, stack: e.stack };
            for (let n in e) void 0 === t[n] && (t[n] = e[n]);
            return t;
          },
        }),
        (a.stdTimeFunctions = Object.assign(
          {},
          {
            nullTime: h,
            epochTime: y,
            unixTime: function () {
              return Math.round(Date.now() / 1e3);
            },
            isoTime: function () {
              return new Date(Date.now()).toISOString();
            },
          }
        ));
    },
    28893: function (e, t, n) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 }),
        (t.watchPendingTransactions =
          t.watchEvent =
          t.watchBlockNumber =
          t.watchBlocks =
          t.simulateCalls =
          t.simulate =
          t.simulateBlocks =
          t.multicall =
          t.mine =
          t.loadState =
          t.increaseTime =
          t.impersonateAccount =
          t.getTransactionReceipt =
          t.getTransaction =
          t.getTransactionCount =
          t.getTransactionConfirmations =
          t.getStorageAt =
          t.getLogs =
          t.getGasPrice =
          t.getFilterLogs =
          t.getFilterChanges =
          t.getFeeHistory =
          t.getEip712Domain =
          t.getContractEvents =
          t.getCode =
          t.getBytecode =
          t.getChainId =
          t.getBlockTransactionCount =
          t.getBlockNumber =
          t.getBlock =
          t.getBlobBaseFee =
          t.getBalance =
          t.estimateGas =
          t.estimateMaxPriorityFeePerGas =
          t.estimateFeesPerGas =
          t.estimateContractGas =
          t.dumpState =
          t.createPendingTransactionFilter =
          t.createEventFilter =
          t.createContractEventFilter =
          t.createBlockFilter =
          t.createAccessList =
          t.call =
          t.getEnsText =
          t.getEnsResolver =
          t.getEnsName =
          t.getEnsAvatar =
          t.getEnsAddress =
          t.deployContract =
          t.addChain =
            void 0),
        (t.verifyHash =
          t.uninstallFilter =
          t.switchChain =
          t.stopImpersonatingAccount =
          t.simulateContract =
          t.signTypedData =
          t.signMessage =
          t.snapshot =
          t.setStorageAt =
          t.setRpcUrl =
          t.setNonce =
          t.setNextBlockTimestamp =
          t.setNextBlockBaseFeePerGas =
          t.setMinGasPrice =
          t.setLoggingEnabled =
          t.setIntervalMining =
          t.setCoinbase =
          t.setCode =
          t.setBlockTimestampInterval =
          t.setBlockGasLimit =
          t.setAutomine =
          t.setBalance =
          t.sendUnsignedTransaction =
          t.sendRawTransaction =
          t.signTransaction =
          t.signAuthorization =
          t.sendTransaction =
          t.defaultPrepareTransactionRequestParameters =
          t.prepareTransactionRequest =
          t.prepareAuthorization =
          t.revert =
          t.reset =
          t.removeBlockTimestampInterval =
          t.inspectTxpool =
          t.getTxpoolStatus =
          t.getTxpoolContent =
          t.getAutomine =
          t.dropTransaction =
          t.requestPermissions =
          t.requestAddresses =
          t.waitForTransactionReceipt =
          t.getProof =
          t.waitForCallsStatus =
          t.showCallsStatus =
          t.getCallsStatus =
          t.sendCalls =
          t.getCapabilities =
          t.getPermissions =
          t.getAddresses =
          t.readContract =
            void 0),
        (t.writeContract =
          t.watchContractEvent =
          t.watchAsset =
          t.verifyTypedData =
          t.verifyMessage =
            void 0);
      var r = n(52448);
      Object.defineProperty(t, 'addChain', {
        enumerable: !0,
        get: function () {
          return r.addChain;
        },
      });
      var i = n(4400);
      Object.defineProperty(t, 'deployContract', {
        enumerable: !0,
        get: function () {
          return i.deployContract;
        },
      });
      var a = n(36918);
      Object.defineProperty(t, 'getEnsAddress', {
        enumerable: !0,
        get: function () {
          return a.getEnsAddress;
        },
      });
      var s = n(4284);
      Object.defineProperty(t, 'getEnsAvatar', {
        enumerable: !0,
        get: function () {
          return s.getEnsAvatar;
        },
      });
      var o = n(26978);
      Object.defineProperty(t, 'getEnsName', {
        enumerable: !0,
        get: function () {
          return o.getEnsName;
        },
      });
      var l = n(42148);
      Object.defineProperty(t, 'getEnsResolver', {
        enumerable: !0,
        get: function () {
          return l.getEnsResolver;
        },
      });
      var u = n(24036);
      Object.defineProperty(t, 'getEnsText', {
        enumerable: !0,
        get: function () {
          return u.getEnsText;
        },
      });
      var c = n(40813);
      Object.defineProperty(t, 'call', {
        enumerable: !0,
        get: function () {
          return c.call;
        },
      });
      var d = n(94697);
      Object.defineProperty(t, 'createAccessList', {
        enumerable: !0,
        get: function () {
          return d.createAccessList;
        },
      });
      var p = n(6174);
      Object.defineProperty(t, 'createBlockFilter', {
        enumerable: !0,
        get: function () {
          return p.createBlockFilter;
        },
      });
      var h = n(32729);
      Object.defineProperty(t, 'createContractEventFilter', {
        enumerable: !0,
        get: function () {
          return h.createContractEventFilter;
        },
      });
      var y = n(43557);
      Object.defineProperty(t, 'createEventFilter', {
        enumerable: !0,
        get: function () {
          return y.createEventFilter;
        },
      });
      var f = n(56245);
      Object.defineProperty(t, 'createPendingTransactionFilter', {
        enumerable: !0,
        get: function () {
          return f.createPendingTransactionFilter;
        },
      });
      var m = n(9233);
      Object.defineProperty(t, 'dumpState', {
        enumerable: !0,
        get: function () {
          return m.dumpState;
        },
      });
      var g = n(19808);
      Object.defineProperty(t, 'estimateContractGas', {
        enumerable: !0,
        get: function () {
          return g.estimateContractGas;
        },
      });
      var b = n(87433);
      Object.defineProperty(t, 'estimateFeesPerGas', {
        enumerable: !0,
        get: function () {
          return b.estimateFeesPerGas;
        },
      });
      var w = n(77254);
      Object.defineProperty(t, 'estimateMaxPriorityFeePerGas', {
        enumerable: !0,
        get: function () {
          return w.estimateMaxPriorityFeePerGas;
        },
      });
      var v = n(85378);
      Object.defineProperty(t, 'estimateGas', {
        enumerable: !0,
        get: function () {
          return v.estimateGas;
        },
      });
      var T = n(90167);
      Object.defineProperty(t, 'getBalance', {
        enumerable: !0,
        get: function () {
          return T.getBalance;
        },
      });
      var A = n(84250);
      Object.defineProperty(t, 'getBlobBaseFee', {
        enumerable: !0,
        get: function () {
          return A.getBlobBaseFee;
        },
      });
      var E = n(59387);
      Object.defineProperty(t, 'getBlock', {
        enumerable: !0,
        get: function () {
          return E.getBlock;
        },
      });
      var C = n(14203);
      Object.defineProperty(t, 'getBlockNumber', {
        enumerable: !0,
        get: function () {
          return C.getBlockNumber;
        },
      });
      var _ = n(96282);
      Object.defineProperty(t, 'getBlockTransactionCount', {
        enumerable: !0,
        get: function () {
          return _.getBlockTransactionCount;
        },
      });
      var I = n(16570);
      Object.defineProperty(t, 'getChainId', {
        enumerable: !0,
        get: function () {
          return I.getChainId;
        },
      });
      var S = n(11847);
      Object.defineProperty(t, 'getBytecode', {
        enumerable: !0,
        get: function () {
          return S.getCode;
        },
      }),
        Object.defineProperty(t, 'getCode', {
          enumerable: !0,
          get: function () {
            return S.getCode;
          },
        });
      var P = n(76678);
      Object.defineProperty(t, 'getContractEvents', {
        enumerable: !0,
        get: function () {
          return P.getContractEvents;
        },
      });
      var O = n(28906);
      Object.defineProperty(t, 'getEip712Domain', {
        enumerable: !0,
        get: function () {
          return O.getEip712Domain;
        },
      });
      var N = n(98389);
      Object.defineProperty(t, 'getFeeHistory', {
        enumerable: !0,
        get: function () {
          return N.getFeeHistory;
        },
      });
      var x = n(98804);
      Object.defineProperty(t, 'getFilterChanges', {
        enumerable: !0,
        get: function () {
          return x.getFilterChanges;
        },
      });
      var M = n(82744);
      Object.defineProperty(t, 'getFilterLogs', {
        enumerable: !0,
        get: function () {
          return M.getFilterLogs;
        },
      });
      var k = n(42796);
      Object.defineProperty(t, 'getGasPrice', {
        enumerable: !0,
        get: function () {
          return k.getGasPrice;
        },
      });
      var R = n(9033);
      Object.defineProperty(t, 'getLogs', {
        enumerable: !0,
        get: function () {
          return R.getLogs;
        },
      });
      var D = n(30703);
      Object.defineProperty(t, 'getStorageAt', {
        enumerable: !0,
        get: function () {
          return D.getStorageAt;
        },
      });
      var B = n(44483);
      Object.defineProperty(t, 'getTransactionConfirmations', {
        enumerable: !0,
        get: function () {
          return B.getTransactionConfirmations;
        },
      });
      var U = n(98595);
      Object.defineProperty(t, 'getTransactionCount', {
        enumerable: !0,
        get: function () {
          return U.getTransactionCount;
        },
      });
      var L = n(65572);
      Object.defineProperty(t, 'getTransaction', {
        enumerable: !0,
        get: function () {
          return L.getTransaction;
        },
      });
      var F = n(27759);
      Object.defineProperty(t, 'getTransactionReceipt', {
        enumerable: !0,
        get: function () {
          return F.getTransactionReceipt;
        },
      });
      var j = n(87325);
      Object.defineProperty(t, 'impersonateAccount', {
        enumerable: !0,
        get: function () {
          return j.impersonateAccount;
        },
      });
      var q = n(3859);
      Object.defineProperty(t, 'increaseTime', {
        enumerable: !0,
        get: function () {
          return q.increaseTime;
        },
      });
      var V = n(73605);
      Object.defineProperty(t, 'loadState', {
        enumerable: !0,
        get: function () {
          return V.loadState;
        },
      });
      var $ = n(4226);
      Object.defineProperty(t, 'mine', {
        enumerable: !0,
        get: function () {
          return $.mine;
        },
      });
      var z = n(23555);
      Object.defineProperty(t, 'multicall', {
        enumerable: !0,
        get: function () {
          return z.multicall;
        },
      });
      var W = n(29694);
      Object.defineProperty(t, 'simulateBlocks', {
        enumerable: !0,
        get: function () {
          return W.simulateBlocks;
        },
      }),
        Object.defineProperty(t, 'simulate', {
          enumerable: !0,
          get: function () {
            return W.simulateBlocks;
          },
        });
      var H = n(48646);
      Object.defineProperty(t, 'simulateCalls', {
        enumerable: !0,
        get: function () {
          return H.simulateCalls;
        },
      });
      var G = n(32601);
      Object.defineProperty(t, 'watchBlocks', {
        enumerable: !0,
        get: function () {
          return G.watchBlocks;
        },
      });
      var K = n(50201);
      Object.defineProperty(t, 'watchBlockNumber', {
        enumerable: !0,
        get: function () {
          return K.watchBlockNumber;
        },
      });
      var Q = n(80302);
      Object.defineProperty(t, 'watchEvent', {
        enumerable: !0,
        get: function () {
          return Q.watchEvent;
        },
      });
      var Y = n(26354);
      Object.defineProperty(t, 'watchPendingTransactions', {
        enumerable: !0,
        get: function () {
          return Y.watchPendingTransactions;
        },
      });
      var Z = n(95031);
      Object.defineProperty(t, 'readContract', {
        enumerable: !0,
        get: function () {
          return Z.readContract;
        },
      });
      var J = n(80954);
      Object.defineProperty(t, 'getAddresses', {
        enumerable: !0,
        get: function () {
          return J.getAddresses;
        },
      });
      var X = n(25085);
      Object.defineProperty(t, 'getPermissions', {
        enumerable: !0,
        get: function () {
          return X.getPermissions;
        },
      });
      var ee = n(3838);
      Object.defineProperty(t, 'getCapabilities', {
        enumerable: !0,
        get: function () {
          return ee.getCapabilities;
        },
      });
      var et = n(47667);
      Object.defineProperty(t, 'sendCalls', {
        enumerable: !0,
        get: function () {
          return et.sendCalls;
        },
      });
      var en = n(43303);
      Object.defineProperty(t, 'getCallsStatus', {
        enumerable: !0,
        get: function () {
          return en.getCallsStatus;
        },
      });
      var er = n(9787);
      Object.defineProperty(t, 'showCallsStatus', {
        enumerable: !0,
        get: function () {
          return er.showCallsStatus;
        },
      });
      var ei = n(38001);
      Object.defineProperty(t, 'waitForCallsStatus', {
        enumerable: !0,
        get: function () {
          return ei.waitForCallsStatus;
        },
      });
      var ea = n(59172);
      Object.defineProperty(t, 'getProof', {
        enumerable: !0,
        get: function () {
          return ea.getProof;
        },
      });
      var es = n(75583);
      Object.defineProperty(t, 'waitForTransactionReceipt', {
        enumerable: !0,
        get: function () {
          return es.waitForTransactionReceipt;
        },
      });
      var eo = n(12429);
      Object.defineProperty(t, 'requestAddresses', {
        enumerable: !0,
        get: function () {
          return eo.requestAddresses;
        },
      });
      var el = n(28700);
      Object.defineProperty(t, 'requestPermissions', {
        enumerable: !0,
        get: function () {
          return el.requestPermissions;
        },
      });
      var eu = n(23405);
      Object.defineProperty(t, 'dropTransaction', {
        enumerable: !0,
        get: function () {
          return eu.dropTransaction;
        },
      });
      var ec = n(56356);
      Object.defineProperty(t, 'getAutomine', {
        enumerable: !0,
        get: function () {
          return ec.getAutomine;
        },
      });
      var ed = n(45141);
      Object.defineProperty(t, 'getTxpoolContent', {
        enumerable: !0,
        get: function () {
          return ed.getTxpoolContent;
        },
      });
      var ep = n(38470);
      Object.defineProperty(t, 'getTxpoolStatus', {
        enumerable: !0,
        get: function () {
          return ep.getTxpoolStatus;
        },
      });
      var eh = n(40274);
      Object.defineProperty(t, 'inspectTxpool', {
        enumerable: !0,
        get: function () {
          return eh.inspectTxpool;
        },
      });
      var ey = n(19918);
      Object.defineProperty(t, 'removeBlockTimestampInterval', {
        enumerable: !0,
        get: function () {
          return ey.removeBlockTimestampInterval;
        },
      });
      var ef = n(33889);
      Object.defineProperty(t, 'reset', {
        enumerable: !0,
        get: function () {
          return ef.reset;
        },
      });
      var em = n(68919);
      Object.defineProperty(t, 'revert', {
        enumerable: !0,
        get: function () {
          return em.revert;
        },
      });
      var eg = n(90601);
      Object.defineProperty(t, 'prepareAuthorization', {
        enumerable: !0,
        get: function () {
          return eg.prepareAuthorization;
        },
      });
      var eb = n(31484);
      Object.defineProperty(t, 'prepareTransactionRequest', {
        enumerable: !0,
        get: function () {
          return eb.prepareTransactionRequest;
        },
      }),
        Object.defineProperty(t, 'defaultPrepareTransactionRequestParameters', {
          enumerable: !0,
          get: function () {
            return eb.defaultParameters;
          },
        });
      var ew = n(84535);
      Object.defineProperty(t, 'sendTransaction', {
        enumerable: !0,
        get: function () {
          return ew.sendTransaction;
        },
      });
      var ev = n(93745);
      Object.defineProperty(t, 'signAuthorization', {
        enumerable: !0,
        get: function () {
          return ev.signAuthorization;
        },
      });
      var eT = n(99834);
      Object.defineProperty(t, 'signTransaction', {
        enumerable: !0,
        get: function () {
          return eT.signTransaction;
        },
      });
      var eA = n(96133);
      Object.defineProperty(t, 'sendRawTransaction', {
        enumerable: !0,
        get: function () {
          return eA.sendRawTransaction;
        },
      });
      var eE = n(26209);
      Object.defineProperty(t, 'sendUnsignedTransaction', {
        enumerable: !0,
        get: function () {
          return eE.sendUnsignedTransaction;
        },
      });
      var eC = n(34385);
      Object.defineProperty(t, 'setBalance', {
        enumerable: !0,
        get: function () {
          return eC.setBalance;
        },
      });
      var e_ = n(47255);
      Object.defineProperty(t, 'setAutomine', {
        enumerable: !0,
        get: function () {
          return e_.setAutomine;
        },
      });
      var eI = n(29757);
      Object.defineProperty(t, 'setBlockGasLimit', {
        enumerable: !0,
        get: function () {
          return eI.setBlockGasLimit;
        },
      });
      var eS = n(3405);
      Object.defineProperty(t, 'setBlockTimestampInterval', {
        enumerable: !0,
        get: function () {
          return eS.setBlockTimestampInterval;
        },
      });
      var eP = n(15101);
      Object.defineProperty(t, 'setCode', {
        enumerable: !0,
        get: function () {
          return eP.setCode;
        },
      });
      var eO = n(29428);
      Object.defineProperty(t, 'setCoinbase', {
        enumerable: !0,
        get: function () {
          return eO.setCoinbase;
        },
      });
      var eN = n(5277);
      Object.defineProperty(t, 'setIntervalMining', {
        enumerable: !0,
        get: function () {
          return eN.setIntervalMining;
        },
      });
      var ex = n(22318);
      Object.defineProperty(t, 'setLoggingEnabled', {
        enumerable: !0,
        get: function () {
          return ex.setLoggingEnabled;
        },
      });
      var eM = n(16461);
      Object.defineProperty(t, 'setMinGasPrice', {
        enumerable: !0,
        get: function () {
          return eM.setMinGasPrice;
        },
      });
      var ek = n(37148);
      Object.defineProperty(t, 'setNextBlockBaseFeePerGas', {
        enumerable: !0,
        get: function () {
          return ek.setNextBlockBaseFeePerGas;
        },
      });
      var eR = n(39364);
      Object.defineProperty(t, 'setNextBlockTimestamp', {
        enumerable: !0,
        get: function () {
          return eR.setNextBlockTimestamp;
        },
      });
      var eD = n(82836);
      Object.defineProperty(t, 'setNonce', {
        enumerable: !0,
        get: function () {
          return eD.setNonce;
        },
      });
      var eB = n(52324);
      Object.defineProperty(t, 'setRpcUrl', {
        enumerable: !0,
        get: function () {
          return eB.setRpcUrl;
        },
      });
      var eU = n(51571);
      Object.defineProperty(t, 'setStorageAt', {
        enumerable: !0,
        get: function () {
          return eU.setStorageAt;
        },
      });
      var eL = n(91885);
      Object.defineProperty(t, 'snapshot', {
        enumerable: !0,
        get: function () {
          return eL.snapshot;
        },
      });
      var eF = n(37184);
      Object.defineProperty(t, 'signMessage', {
        enumerable: !0,
        get: function () {
          return eF.signMessage;
        },
      });
      var ej = n(21453);
      Object.defineProperty(t, 'signTypedData', {
        enumerable: !0,
        get: function () {
          return ej.signTypedData;
        },
      });
      var eq = n(47634);
      Object.defineProperty(t, 'simulateContract', {
        enumerable: !0,
        get: function () {
          return eq.simulateContract;
        },
      });
      var eV = n(94406);
      Object.defineProperty(t, 'stopImpersonatingAccount', {
        enumerable: !0,
        get: function () {
          return eV.stopImpersonatingAccount;
        },
      });
      var e$ = n(37600);
      Object.defineProperty(t, 'switchChain', {
        enumerable: !0,
        get: function () {
          return e$.switchChain;
        },
      });
      var ez = n(48504);
      Object.defineProperty(t, 'uninstallFilter', {
        enumerable: !0,
        get: function () {
          return ez.uninstallFilter;
        },
      });
      var eW = n(17695);
      Object.defineProperty(t, 'verifyHash', {
        enumerable: !0,
        get: function () {
          return eW.verifyHash;
        },
      });
      var eH = n(27087);
      Object.defineProperty(t, 'verifyMessage', {
        enumerable: !0,
        get: function () {
          return eH.verifyMessage;
        },
      });
      var eG = n(55692);
      Object.defineProperty(t, 'verifyTypedData', {
        enumerable: !0,
        get: function () {
          return eG.verifyTypedData;
        },
      });
      var eK = n(59351);
      Object.defineProperty(t, 'watchAsset', {
        enumerable: !0,
        get: function () {
          return eK.watchAsset;
        },
      });
      var eQ = n(88387);
      Object.defineProperty(t, 'watchContractEvent', {
        enumerable: !0,
        get: function () {
          return eQ.watchContractEvent;
        },
      });
      var eY = n(16071);
      Object.defineProperty(t, 'writeContract', {
        enumerable: !0,
        get: function () {
          return eY.writeContract;
        },
      });
    },
    40657: function (e, t, n) {
      'use strict';
      n.d(t, {
        u: function () {
          return b;
        },
        D: function () {
          return v;
        },
      });
      var r = n(85192),
        i = n(47189),
        a = n(84539),
        s = n(7289),
        o = n(32483),
        l = n(65968),
        u = n(32505),
        c = n(2584),
        d = n(17085),
        p = n(79143),
        h = n(35862),
        y = n(66682),
        f = n(88197),
        m = Object.assign,
        g = Object.hasOwnProperty,
        b = (function (e) {
          function t(n) {
            var i = n.queryManager,
              a = n.queryInfo,
              s = n.options,
              l = this,
              u = t.inactiveOnCreation.getValue();
            ((l =
              e.call(this, function (e) {
                u && (i.queries.set(l.queryId, a), (u = !1));
                try {
                  var t = e._subscription._observer;
                  t && !t.error && (t.error = w);
                } catch (e) {}
                var n = !l.observers.size;
                l.observers.add(e);
                var r = l.last;
                return (
                  r && r.error
                    ? e.error && e.error(r.error)
                    : r && r.result && e.next && e.next(l.maskResult(r.result)),
                  n && l.reobserve().catch(function () {}),
                  function () {
                    l.observers.delete(e) && !l.observers.size && l.tearDownQuery();
                  }
                );
              }) || this).observers = new Set()),
              (l.subscriptions = new Set()),
              (l.dirty = !1),
              (l.queryInfo = a),
              (l.queryManager = i),
              (l.waitForOwnResult = T(s.fetchPolicy)),
              (l.isTornDown = !1),
              (l.subscribeToMore = l.subscribeToMore.bind(l)),
              (l.maskResult = l.maskResult.bind(l));
            var c = i.defaultOptions.watchQuery,
              d = (void 0 === c ? {} : c).fetchPolicy,
              p = void 0 === d ? 'cache-first' : d,
              h = s.fetchPolicy,
              y = void 0 === h ? p : h,
              f = s.initialFetchPolicy,
              m = void 0 === f ? ('standby' === y ? p : y) : f;
            (l.options = (0, r.__assign)((0, r.__assign)({}, s), {
              initialFetchPolicy: m,
              fetchPolicy: y,
            })),
              (l.queryId = a.queryId || i.generateQueryId());
            var g = (0, o.$H)(l.query);
            return (l.queryName = g && g.name && g.name.value), l;
          }
          return (
            (0, r.__extends)(t, e),
            Object.defineProperty(t.prototype, 'query', {
              get: function () {
                return this.lastQuery || this.options.query;
              },
              enumerable: !1,
              configurable: !0,
            }),
            Object.defineProperty(t.prototype, 'variables', {
              get: function () {
                return this.options.variables;
              },
              enumerable: !1,
              configurable: !0,
            }),
            (t.prototype.result = function () {
              var e = this;
              return new Promise(function (t, n) {
                var r = {
                    next: function (n) {
                      t(n),
                        e.observers.delete(r),
                        e.observers.size || e.queryManager.removeQuery(e.queryId),
                        setTimeout(function () {
                          i.unsubscribe();
                        }, 0);
                    },
                    error: n,
                  },
                  i = e.subscribe(r);
              });
            }),
            (t.prototype.resetDiff = function () {
              this.queryInfo.resetDiff();
            }),
            (t.prototype.getCurrentFullResult = function (e) {
              void 0 === e && (e = !0);
              var t = this.getLastResult(!0),
                n = this.queryInfo.networkStatus || (t && t.networkStatus) || s.Ie.ready,
                i = (0, r.__assign)((0, r.__assign)({}, t), {
                  loading: (0, s.Oj)(n),
                  networkStatus: n,
                }),
                o = this.options.fetchPolicy,
                l = void 0 === o ? 'cache-first' : o;
              if (T(l) || this.queryManager.getDocumentInfo(this.query).hasForcedResolvers);
              else if (this.waitForOwnResult) this.queryInfo.updateWatch();
              else {
                var u = this.queryInfo.getDiff();
                (u.complete || this.options.returnPartialData) && (i.data = u.result),
                  (0, a.D)(i.data, {}) && (i.data = void 0),
                  u.complete
                    ? (delete i.partial,
                      u.complete &&
                        i.networkStatus === s.Ie.loading &&
                        ('cache-first' === l || 'cache-only' === l) &&
                        ((i.networkStatus = s.Ie.ready), (i.loading = !1)))
                    : (i.partial = !0),
                  i.networkStatus === s.Ie.ready &&
                    (i.error || i.errors) &&
                    (i.networkStatus = s.Ie.error),
                  !1 === globalThis.__DEV__ ||
                    u.complete ||
                    this.options.partialRefetch ||
                    i.loading ||
                    i.data ||
                    i.error ||
                    v(u.missing);
              }
              return e && this.updateLastResult(i), i;
            }),
            (t.prototype.getCurrentResult = function (e) {
              return void 0 === e && (e = !0), this.maskResult(this.getCurrentFullResult(e));
            }),
            (t.prototype.isDifferentFromLastResult = function (e, t) {
              if (!this.last) return !0;
              var n = this.queryManager.getDocumentInfo(this.query),
                r = this.queryManager.dataMasking,
                i = r ? n.nonReactiveQuery : this.query;
              return (
                (r || n.hasNonreactiveDirective
                  ? !(0, y.W)(i, this.last.result, e, this.variables)
                  : !(0, a.D)(this.last.result, e)) ||
                (t && !(0, a.D)(this.last.variables, t))
              );
            }),
            (t.prototype.getLast = function (e, t) {
              var n = this.last;
              if (n && n[e] && (!t || (0, a.D)(n.variables, this.variables))) return n[e];
            }),
            (t.prototype.getLastResult = function (e) {
              return this.getLast('result', e);
            }),
            (t.prototype.getLastError = function (e) {
              return this.getLast('error', e);
            }),
            (t.prototype.resetLastResults = function () {
              delete this.last, (this.isTornDown = !1);
            }),
            (t.prototype.resetQueryStoreErrors = function () {
              this.queryManager.resetErrors(this.queryId);
            }),
            (t.prototype.refetch = function (e) {
              var t,
                n = { pollInterval: 0 };
              if (
                ('no-cache' === this.options.fetchPolicy
                  ? (n.fetchPolicy = 'no-cache')
                  : (n.fetchPolicy = 'network-only'),
                !1 !== globalThis.__DEV__ && e && g.call(e, 'variables'))
              ) {
                var l = (0, o.iW)(this.query),
                  u = l.variableDefinitions;
                (u &&
                  u.some(function (e) {
                    return 'variables' === e.variable.name.value;
                  })) ||
                  !1 === globalThis.__DEV__ ||
                  i.kG.warn(21, e, (null === (t = l.name) || void 0 === t ? void 0 : t.value) || l);
              }
              return (
                e &&
                  !(0, a.D)(this.options.variables, e) &&
                  (n.variables = this.options.variables =
                    (0, r.__assign)((0, r.__assign)({}, this.options.variables), e)),
                this.queryInfo.resetLastWrite(),
                this.reobserve(n, s.Ie.refetch)
              );
            }),
            (t.prototype.fetchMore = function (e) {
              var t = this,
                n = (0, r.__assign)(
                  (0, r.__assign)(
                    {},
                    e.query
                      ? e
                      : (0, r.__assign)(
                          (0, r.__assign)(
                            (0, r.__assign)((0, r.__assign)({}, this.options), {
                              query: this.options.query,
                            }),
                            e
                          ),
                          {
                            variables: (0, r.__assign)(
                              (0, r.__assign)({}, this.options.variables),
                              e.variables
                            ),
                          }
                        )
                  ),
                  { fetchPolicy: 'no-cache' }
                );
              n.query = this.transformDocument(n.query);
              var a = this.queryManager.generateQueryId();
              this.lastQuery = e.query ? this.transformDocument(this.options.query) : n.query;
              var o = this.queryInfo,
                l = o.networkStatus;
              (o.networkStatus = s.Ie.fetchMore), n.notifyOnNetworkStatusChange && this.observe();
              var u = new Set(),
                c = null == e ? void 0 : e.updateQuery,
                d = 'no-cache' !== this.options.fetchPolicy;
              return (
                d || (0, i.kG)(c, 22),
                this.queryManager
                  .fetchQuery(a, n, s.Ie.fetchMore)
                  .then(function (i) {
                    if (
                      (t.queryManager.removeQuery(a),
                      o.networkStatus === s.Ie.fetchMore && (o.networkStatus = l),
                      d)
                    )
                      t.queryManager.cache.batch({
                        update: function (r) {
                          var a = e.updateQuery;
                          a
                            ? r.updateQuery(
                                {
                                  query: t.query,
                                  variables: t.variables,
                                  returnPartialData: !0,
                                  optimistic: !1,
                                },
                                function (e) {
                                  return a(e, { fetchMoreResult: i.data, variables: n.variables });
                                }
                              )
                            : r.writeQuery({
                                query: n.query,
                                variables: n.variables,
                                data: i.data,
                              });
                        },
                        onWatchUpdated: function (e) {
                          u.add(e.query);
                        },
                      });
                    else {
                      var p = t.getLast('result'),
                        h = c(p.data, { fetchMoreResult: i.data, variables: n.variables });
                      t.reportResult(
                        (0, r.__assign)((0, r.__assign)({}, p), {
                          networkStatus: l,
                          loading: (0, s.Oj)(l),
                          data: h,
                        }),
                        t.variables
                      );
                    }
                    return t.maskResult(i);
                  })
                  .finally(function () {
                    d && !u.has(t.query) && t.reobserveCacheFirst();
                  })
              );
            }),
            (t.prototype.subscribeToMore = function (e) {
              var t = this,
                n = this.queryManager
                  .startGraphQLSubscription({
                    query: e.document,
                    variables: e.variables,
                    context: e.context,
                  })
                  .subscribe({
                    next: function (n) {
                      var i = e.updateQuery;
                      i &&
                        t.updateQuery(function (e, t) {
                          return i(e, (0, r.__assign)({ subscriptionData: n }, t));
                        });
                    },
                    error: function (t) {
                      if (e.onError) {
                        e.onError(t);
                        return;
                      }
                      !1 !== globalThis.__DEV__ && i.kG.error(23, t);
                    },
                  });
              return (
                this.subscriptions.add(n),
                function () {
                  t.subscriptions.delete(n) && n.unsubscribe();
                }
              );
            }),
            (t.prototype.setOptions = function (e) {
              return this.reobserve(e);
            }),
            (t.prototype.silentSetOptions = function (e) {
              var t = (0, l.o)(this.options, e || {});
              m(this.options, t);
            }),
            (t.prototype.setVariables = function (e) {
              return (0, a.D)(this.variables, e)
                ? this.observers.size
                  ? this.result()
                  : Promise.resolve()
                : ((this.options.variables = e), this.observers.size)
                  ? this.reobserve(
                      { fetchPolicy: this.options.initialFetchPolicy, variables: e },
                      s.Ie.setVariables
                    )
                  : Promise.resolve();
            }),
            (t.prototype.updateQuery = function (e) {
              var t = this.queryManager,
                n = t.cache.diff({
                  query: this.options.query,
                  variables: this.variables,
                  returnPartialData: !0,
                  optimistic: !1,
                }),
                r = n.result,
                i = n.complete,
                a = e(r, { variables: this.variables, complete: !!i, previousData: r });
              a &&
                (t.cache.writeQuery({
                  query: this.options.query,
                  data: a,
                  variables: this.variables,
                }),
                t.broadcastQueries());
            }),
            (t.prototype.startPolling = function (e) {
              (this.options.pollInterval = e), this.updatePolling();
            }),
            (t.prototype.stopPolling = function () {
              (this.options.pollInterval = 0), this.updatePolling();
            }),
            (t.prototype.applyNextFetchPolicy = function (e, t) {
              if (t.nextFetchPolicy) {
                var n = t.fetchPolicy,
                  r = void 0 === n ? 'cache-first' : n,
                  i = t.initialFetchPolicy,
                  a = void 0 === i ? r : i;
                'standby' === r ||
                  ('function' == typeof t.nextFetchPolicy
                    ? (t.fetchPolicy = t.nextFetchPolicy(r, {
                        reason: e,
                        options: t,
                        observable: this,
                        initialFetchPolicy: a,
                      }))
                    : 'variables-changed' === e
                      ? (t.fetchPolicy = a)
                      : (t.fetchPolicy = t.nextFetchPolicy));
              }
              return t.fetchPolicy;
            }),
            (t.prototype.fetch = function (e, t, n) {
              var r = this.queryManager.getOrCreateQuery(this.queryId);
              return r.setObservableQuery(this), this.queryManager.fetchConcastWithInfo(r, e, t, n);
            }),
            (t.prototype.updatePolling = function () {
              var e = this;
              if (!this.queryManager.ssrMode) {
                var t = this.pollingInfo,
                  n = this.options.pollInterval;
                if (!n || !this.hasObservers()) {
                  t && (clearTimeout(t.timeout), delete this.pollingInfo);
                  return;
                }
                if (!t || t.interval !== n) {
                  (0, i.kG)(n, 24), ((t || (this.pollingInfo = {})).interval = n);
                  var r = function () {
                      var t, n;
                      e.pollingInfo &&
                        ((0, s.Oj)(e.queryInfo.networkStatus) ||
                        (null === (n = (t = e.options).skipPollAttempt) || void 0 === n
                          ? void 0
                          : n.call(t))
                          ? a()
                          : e
                              .reobserve(
                                {
                                  fetchPolicy:
                                    'no-cache' === e.options.initialFetchPolicy
                                      ? 'no-cache'
                                      : 'network-only',
                                },
                                s.Ie.poll
                              )
                              .then(a, a));
                    },
                    a = function () {
                      var t = e.pollingInfo;
                      t && (clearTimeout(t.timeout), (t.timeout = setTimeout(r, t.interval)));
                    };
                  a();
                }
              }
            }),
            (t.prototype.updateLastResult = function (e, t) {
              void 0 === t && (t = this.variables);
              var n = this.getLastError();
              return (
                n && this.last && !(0, a.D)(t, this.last.variables) && (n = void 0),
                (this.last = (0, r.__assign)(
                  {
                    result: this.queryManager.assumeImmutableResults ? e : (0, u.X)(e),
                    variables: t,
                  },
                  n ? { error: n } : null
                ))
              );
            }),
            (t.prototype.reobserveAsConcast = function (e, t) {
              var n = this;
              this.isTornDown = !1;
              var i = t === s.Ie.refetch || t === s.Ie.fetchMore || t === s.Ie.poll,
                o = this.options.variables,
                u = this.options.fetchPolicy,
                c = (0, l.o)(this.options, e || {}),
                d = i ? c : m(this.options, c),
                p = this.transformDocument(d.query);
              (this.lastQuery = p),
                !i &&
                  (this.updatePolling(),
                  e &&
                    e.variables &&
                    !(0, a.D)(e.variables, o) &&
                    'standby' !== d.fetchPolicy &&
                    (d.fetchPolicy === u || 'function' == typeof d.nextFetchPolicy) &&
                    (this.applyNextFetchPolicy('variables-changed', d),
                    void 0 === t && (t = s.Ie.setVariables))),
                this.waitForOwnResult && (this.waitForOwnResult = T(d.fetchPolicy));
              var y = function () {
                  n.concast === b && (n.waitForOwnResult = !1);
                },
                f = d.variables && (0, r.__assign)({}, d.variables),
                g = this.fetch(d, t, p),
                b = g.concast,
                w = g.fromLink,
                v = {
                  next: function (e) {
                    (0, a.D)(n.variables, f) && (y(), n.reportResult(e, f));
                  },
                  error: function (e) {
                    (0, a.D)(n.variables, f) &&
                      ((0, h.MS)(e) || (e = new h.cA({ networkError: e })),
                      y(),
                      n.reportError(e, f));
                  },
                };
              return (
                i ||
                  (!w && this.concast) ||
                  (this.concast && this.observer && this.concast.removeObserver(this.observer),
                  (this.concast = b),
                  (this.observer = v)),
                b.addObserver(v),
                b
              );
            }),
            (t.prototype.reobserve = function (e, t) {
              var n;
              return (
                (n = this.reobserveAsConcast(e, t).promise.then(this.maskResult)).catch(
                  function () {}
                ),
                n
              );
            }),
            (t.prototype.resubscribeAfterError = function () {
              for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
              var n = this.last;
              this.resetLastResults();
              var r = this.subscribe.apply(this, e);
              return (this.last = n), r;
            }),
            (t.prototype.observe = function () {
              this.reportResult(this.getCurrentFullResult(!1), this.variables);
            }),
            (t.prototype.reportResult = function (e, t) {
              var n = this.getLastError(),
                r = this.isDifferentFromLastResult(e, t);
              (n || !e.partial || this.options.returnPartialData) && this.updateLastResult(e, t),
                (n || r) && (0, c.p)(this.observers, 'next', this.maskResult(e));
            }),
            (t.prototype.reportError = function (e, t) {
              var n = (0, r.__assign)((0, r.__assign)({}, this.getLastResult()), {
                error: e,
                errors: e.graphQLErrors,
                networkStatus: s.Ie.error,
                loading: !1,
              });
              this.updateLastResult(n, t), (0, c.p)(this.observers, 'error', (this.last.error = e));
            }),
            (t.prototype.hasObservers = function () {
              return this.observers.size > 0;
            }),
            (t.prototype.tearDownQuery = function () {
              this.isTornDown ||
                (this.concast &&
                  this.observer &&
                  (this.concast.removeObserver(this.observer),
                  delete this.concast,
                  delete this.observer),
                this.stopPolling(),
                this.subscriptions.forEach(function (e) {
                  return e.unsubscribe();
                }),
                this.subscriptions.clear(),
                this.queryManager.stopQuery(this.queryId),
                this.observers.clear(),
                (this.isTornDown = !0));
            }),
            (t.prototype.transformDocument = function (e) {
              return this.queryManager.transform(e);
            }),
            (t.prototype.maskResult = function (e) {
              return e && 'data' in e
                ? (0, r.__assign)((0, r.__assign)({}, e), {
                    data: this.queryManager.maskOperation({
                      document: this.query,
                      data: e.data,
                      fetchPolicy: this.options.fetchPolicy,
                      id: this.queryId,
                    }),
                  })
                : e;
            }),
            (t.prototype.resetNotifications = function () {
              this.cancelNotifyTimeout(), (this.dirty = !1);
            }),
            (t.prototype.cancelNotifyTimeout = function () {
              this.notifyTimeout &&
                (clearTimeout(this.notifyTimeout), (this.notifyTimeout = void 0));
            }),
            (t.prototype.scheduleNotify = function () {
              var e = this;
              this.dirty ||
                ((this.dirty = !0),
                this.notifyTimeout ||
                  (this.notifyTimeout = setTimeout(function () {
                    return e.notify();
                  }, 0)));
            }),
            (t.prototype.notify = function () {
              this.cancelNotifyTimeout(),
                this.dirty &&
                  ('cache-only' == this.options.fetchPolicy ||
                    'cache-and-network' == this.options.fetchPolicy ||
                    !(0, s.Oj)(this.queryInfo.networkStatus)) &&
                  (this.queryInfo.getDiff().fromOptimisticTransaction
                    ? this.observe()
                    : this.reobserveCacheFirst()),
                (this.dirty = !1);
            }),
            (t.prototype.reobserveCacheFirst = function () {
              var e = this.options,
                t = e.fetchPolicy,
                n = e.nextFetchPolicy;
              return 'cache-and-network' === t || 'network-only' === t
                ? this.reobserve({
                    fetchPolicy: 'cache-first',
                    nextFetchPolicy: function (e, r) {
                      return ((this.nextFetchPolicy = n), 'function' == typeof this.nextFetchPolicy)
                        ? this.nextFetchPolicy(e, r)
                        : t;
                    },
                  })
                : this.reobserve();
            }),
            (t.inactiveOnCreation = new f.g7()),
            t
          );
        })(d.y);
      function w(e) {
        !1 !== globalThis.__DEV__ && i.kG.error(25, e.message, e.stack);
      }
      function v(e) {
        !1 !== globalThis.__DEV__ && e && !1 !== globalThis.__DEV__ && i.kG.debug(26, e);
      }
      function T(e) {
        return 'network-only' === e || 'no-cache' === e || 'standby' === e;
      }
      (0, p.D)(b);
    },
    66682: function (e, t, n) {
      'use strict';
      n.d(t, {
        W: function () {
          return u;
        },
      });
      var r = n(85192),
        i = n(84539),
        a = n(32483),
        s = n(55204),
        o = n(78034),
        l = n(35792);
      function u(e, t, n, u) {
        var d = t.data,
          p = (0, r.__rest)(t, ['data']),
          h = n.data,
          y = (0, r.__rest)(n, ['data']);
        return (
          (0, i.Z)(p, y) &&
          (function e(t, n, r, a) {
            if (n === r) return !0;
            var u = new Set();
            return t.selections.every(function (t) {
              if (u.has(t) || (u.add(t), !(0, o.LZ)(t, a.variables) || c(t))) return !0;
              if ((0, l.My)(t)) {
                var d = (0, l.u2)(t),
                  p = n && n[d],
                  h = r && r[d],
                  y = t.selectionSet;
                if (!y) return (0, i.Z)(p, h);
                var f = Array.isArray(p),
                  m = Array.isArray(h);
                if (f !== m) return !1;
                if (f && m) {
                  var g = p.length;
                  if (h.length !== g) return !1;
                  for (var b = 0; b < g; ++b) if (!e(y, p[b], h[b], a)) return !1;
                  return !0;
                }
                return e(y, p, h, a);
              }
              var w = (0, s.hi)(t, a.fragmentMap);
              if (w) return !!c(w) || e(w.selectionSet, n, r, a);
            });
          })((0, a.p$)(e).selectionSet, d, h, { fragmentMap: (0, s.F)((0, a.kU)(e)), variables: u })
        );
      }
      function c(e) {
        return !!e.directives && e.directives.some(d);
      }
      function d(e) {
        return 'nonreactive' === e.name.value;
      }
    },
    7289: function (e, t, n) {
      'use strict';
      var r, i;
      function a(e) {
        return !!e && e < 7;
      }
      n.d(t, {
        Ie: function () {
          return r;
        },
        Oj: function () {
          return a;
        },
      }),
        ((i = r || (r = {}))[(i.loading = 1)] = 'loading'),
        (i[(i.setVariables = 2)] = 'setVariables'),
        (i[(i.fetchMore = 3)] = 'fetchMore'),
        (i[(i.refetch = 4)] = 'refetch'),
        (i[(i.poll = 6)] = 'poll'),
        (i[(i.ready = 7)] = 'ready'),
        (i[(i.error = 8)] = 'error');
    },
    35862: function (e, t, n) {
      'use strict';
      n.d(t, {
        MS: function () {
          return o;
        },
        YG: function () {
          return a;
        },
        cA: function () {
          return u;
        },
        ls: function () {
          return s;
        },
      });
      var r = n(85192);
      n(47189);
      var i = n(9402),
        a = Symbol();
      function s(e) {
        return !!e.extensions && Array.isArray(e.extensions[a]);
      }
      function o(e) {
        return e.hasOwnProperty('graphQLErrors');
      }
      var l = function (e) {
          var t = (0, r.__spreadArray)(
            (0, r.__spreadArray)((0, r.__spreadArray)([], e.graphQLErrors, !0), e.clientErrors, !0),
            e.protocolErrors,
            !0
          );
          return (
            e.networkError && t.push(e.networkError),
            t
              .map(function (e) {
                return ((0, i.s)(e) && e.message) || 'Error message not found.';
              })
              .join('\n')
          );
        },
        u = (function (e) {
          function t(n) {
            var i = n.graphQLErrors,
              a = n.protocolErrors,
              s = n.clientErrors,
              o = n.networkError,
              u = n.errorMessage,
              c = n.extraInfo,
              d = e.call(this, u) || this;
            return (
              (d.name = 'ApolloError'),
              (d.graphQLErrors = i || []),
              (d.protocolErrors = a || []),
              (d.clientErrors = s || []),
              (d.networkError = o || null),
              (d.message = u || l(d)),
              (d.extraInfo = c),
              (d.cause =
                (0, r.__spreadArray)(
                  (0, r.__spreadArray)((0, r.__spreadArray)([o], i || [], !0), a || [], !0),
                  s || [],
                  !0
                ).find(function (e) {
                  return !!e;
                }) || null),
              (d.__proto__ = t.prototype),
              d
            );
          }
          return (0, r.__extends)(t, e), t;
        })(Error);
    },
    16147: function (e, t, n) {
      'use strict';
      n.d(t, {
        K: function () {
          return l;
        },
      });
      var r,
        i = n(90746),
        a = n(40431),
        s = n(47189),
        o = a.aS ? Symbol.for('__APOLLO_CONTEXT__') : '__APOLLO_CONTEXT__';
      function l() {
        (0, s.kG)('createContext' in (r || (r = n.t(i, 2))), 54);
        var e = i.createContext[o];
        return (
          e ||
            (Object.defineProperty(i.createContext, o, {
              value: (e = i.createContext({})),
              enumerable: !1,
              writable: !1,
              configurable: !0,
            }),
            (e.displayName = 'ApolloContext')),
          e
        );
      }
    },
    95413: function (e, t, n) {
      'use strict';
      n.d(t, {
        aM: function () {
          return k;
        },
      });
      var r,
        i,
        a,
        s = n(85192),
        o = n(47189),
        l = n(90746),
        u = n.t(l, 2),
        c = n(40431),
        d = !1,
        p =
          u.useSyncExternalStore ||
          function (e, t, n) {
            var r = t();
            !1 === globalThis.__DEV__ ||
              d ||
              r === t() ||
              ((d = !0), !1 !== globalThis.__DEV__ && o.kG.error(68));
            var i = l.useState({ inst: { value: r, getSnapshot: t } }),
              a = i[0].inst,
              s = i[1];
            return (
              c.JC
                ? l.useLayoutEffect(
                    function () {
                      Object.assign(a, { value: r, getSnapshot: t }), h(a) && s({ inst: a });
                    },
                    [e, r, t]
                  )
                : Object.assign(a, { value: r, getSnapshot: t }),
              l.useEffect(
                function () {
                  return (
                    h(a) && s({ inst: a }),
                    e(function () {
                      h(a) && s({ inst: a });
                    })
                  );
                },
                [e]
              ),
              r
            );
          };
      function h(e) {
        var t = e.value,
          n = e.getSnapshot;
        try {
          return t !== n();
        } catch (e) {
          return !0;
        }
      }
      var y = n(84539),
        f = n(94263),
        m = n(16147),
        g = n(35862),
        b = n(40657),
        w = n(7289),
        v = n(98517),
        T = n(29645),
        A = n(39341);
      function E(e) {
        var t;
        switch (e) {
          case i.Query:
            t = 'Query';
            break;
          case i.Mutation:
            t = 'Mutation';
            break;
          case i.Subscription:
            t = 'Subscription';
        }
        return t;
      }
      function C(e) {
        a || (a = new v.s(T.Q.parser || 1e3));
        var t,
          n,
          r = a.get(e);
        if (r) return r;
        (0, o.kG)(!!e && !!e.kind, 70, e);
        for (var s = [], l = [], u = [], c = [], d = 0, p = e.definitions; d < p.length; d++) {
          var h = p[d];
          if ('FragmentDefinition' === h.kind) {
            s.push(h);
            continue;
          }
          if ('OperationDefinition' === h.kind)
            switch (h.operation) {
              case 'query':
                l.push(h);
                break;
              case 'mutation':
                u.push(h);
                break;
              case 'subscription':
                c.push(h);
            }
        }
        (0, o.kG)(!s.length || l.length || u.length || c.length, 71),
          (0, o.kG)(l.length + u.length + c.length <= 1, 72, e, l.length, c.length, u.length),
          (n = l.length ? i.Query : i.Mutation),
          l.length || u.length || (n = i.Subscription);
        var y = l.length ? l : u.length ? u : c;
        (0, o.kG)(1 === y.length, 73, e, y.length);
        var f = y[0];
        t = f.variableDefinitions || [];
        var m = {
          name: f.name && 'Name' === f.name.kind ? f.name.value : 'data',
          type: n,
          variables: t,
        };
        return a.set(e, m), m;
      }
      function _(e) {
        var t = l.useContext((0, m.K)()),
          n = e || t.client;
        return (0, o.kG)(!!n, 58), n;
      }
      ((r = i || (i = {}))[(r.Query = 0)] = 'Query'),
        (r[(r.Mutation = 1)] = 'Mutation'),
        (r[(r.Subscription = 2)] = 'Subscription'),
        (C.resetCache = function () {
          a = void 0;
        }),
        !1 !== globalThis.__DEV__ &&
          (0, A.zP)('parser', function () {
            return a ? a.size : 0;
          });
      var I = n(65968),
        S = n(73664),
        P = n(11625),
        O = Symbol.for('apollo.hook.wrappers'),
        N = Object.prototype.hasOwnProperty;
      function x() {}
      var M = Symbol();
      function k(e, t) {
        var n, r, i, a;
        return (
          void 0 === t && (t = Object.create(null)),
          ((n = R),
          (a = (i = (r = _(t && t.client).queryManager) && r[O]) && i.useQuery) ? a(n) : n)(e, t)
        );
      }
      function R(e, t) {
        var n,
          r,
          a,
          u,
          c,
          d,
          h,
          f,
          g,
          v,
          T,
          A,
          I,
          S,
          P,
          O,
          k,
          R,
          V,
          $,
          z,
          W,
          H,
          G,
          K =
            ((c = _(t.client)),
            (h = !!(d = l.useContext((0, m.K)()).renderPromises)),
            (f = c.disableNetworkFetches),
            (g = !1 !== t.ssr && !t.skip),
            (v = t.partialRefetch),
            void 0 === (n = t) && (n = {}),
            (r = n.skip),
            n.ssr,
            n.onCompleted,
            n.onError,
            (a = n.defaultOptions),
            (u = (0, s.__rest)(n, ['skip', 'ssr', 'onCompleted', 'onError', 'defaultOptions'])),
            (T = function (t) {
              var n = Object.assign(u, { query: e });
              return (
                h &&
                  ('network-only' === n.fetchPolicy || 'cache-and-network' === n.fetchPolicy) &&
                  (n.fetchPolicy = 'cache-first'),
                n.variables || (n.variables = {}),
                r
                  ? ((n.initialFetchPolicy =
                      n.initialFetchPolicy || n.fetchPolicy || L(a, c.defaultOptions)),
                    (n.fetchPolicy = 'standby'))
                  : n.fetchPolicy ||
                    (n.fetchPolicy =
                      (null == t ? void 0 : t.options.initialFetchPolicy) ||
                      L(a, c.defaultOptions)),
                n
              );
            }),
            (S = (I = (A = (function (e, t, n, r, a) {
              function u(s) {
                var l, u, c, d, p;
                return (
                  (l = i.Query),
                  (u = C(t)),
                  (c = E(l)),
                  (d = E(u.type)),
                  (0, o.kG)(u.type === l, 74, c, c, d),
                  {
                    client: e,
                    query: t,
                    observable:
                      (r && r.getSSRObservable(a())) ||
                      b.u.inactiveOnCreation.withValue(!r, function () {
                        return e.watchQuery(D(void 0, e, n, a()));
                      }),
                    resultData: {
                      previousData:
                        null === (p = null == s ? void 0 : s.resultData.current) || void 0 === p
                          ? void 0
                          : p.data,
                    },
                  }
                );
              }
              var c = l.useState(u),
                d = c[0],
                p = c[1];
              function h(e) {
                Object.assign(d.observable, (((t = {})[M] = e), t));
                var t,
                  n,
                  r = d.resultData;
                p(
                  (0, s.__assign)((0, s.__assign)({}, d), {
                    query: e.query,
                    resultData: Object.assign(r, {
                      previousData:
                        (null === (n = r.current) || void 0 === n ? void 0 : n.data) ||
                        r.previousData,
                      current: void 0,
                    }),
                  })
                );
              }
              if (e !== d.client || t !== d.query) {
                var y = u(d);
                return p(y), [y, h];
              }
              return [d, h];
            })(c, e, t, d, T))[0]).observable),
            (P = I.resultData),
            (O = A[1]),
            (k = T(S)),
            S[M] &&
              !(0, y.D)(S[M], k) &&
              (S.reobserve(D(S, c, t, k)),
              (P.previousData =
                (null === (R = P.current) || void 0 === R ? void 0 : R.data) || P.previousData),
              (P.current = void 0)),
            (S[M] = k),
            (V = l.useMemo(
              function () {
                return {
                  refetch: S.refetch.bind(S),
                  reobserve: S.reobserve.bind(S),
                  fetchMore: S.fetchMore.bind(S),
                  updateQuery: S.updateQuery.bind(S),
                  startPolling: S.startPolling.bind(S),
                  stopPolling: S.stopPolling.bind(S),
                  subscribeToMore: S.subscribeToMore.bind(S),
                };
              },
              [S]
            )),
            d &&
              g &&
              (d.registerSSRObservable(S),
              S.getCurrentResult().loading && d.addObservableQueryPromise(S)),
            {
              result:
                (($ = { onCompleted: t.onCompleted || x, onError: t.onError || x }),
                (z = l.useRef($)),
                l.useEffect(function () {
                  z.current = $;
                }),
                (W =
                  (h || f) && !1 === t.ssr && !t.skip
                    ? j
                    : t.skip || 'standby' === k.fetchPolicy
                      ? q
                      : void 0),
                (H = P.previousData),
                (G = l.useMemo(
                  function () {
                    return W && F(W, H, S, c);
                  },
                  [c, S, W, H]
                )),
                p(
                  l.useCallback(
                    function (e) {
                      if (h) return function () {};
                      var t = function () {
                          var t = P.current,
                            n = S.getCurrentResult();
                          (t &&
                            t.loading === n.loading &&
                            t.networkStatus === n.networkStatus &&
                            (0, y.D)(t.data, n.data)) ||
                            B(n, P, S, c, v, e, z.current);
                        },
                        n = function (i) {
                          if (
                            (r.current.unsubscribe(),
                            (r.current = S.resubscribeAfterError(t, n)),
                            !N.call(i, 'graphQLErrors'))
                          )
                            throw i;
                          var a = P.current;
                          (!a || (a && a.loading) || !(0, y.D)(i, a.error)) &&
                            B(
                              {
                                data: a && a.data,
                                error: i,
                                loading: !1,
                                networkStatus: w.Ie.error,
                              },
                              P,
                              S,
                              c,
                              v,
                              e,
                              z.current
                            );
                        },
                        r = { current: S.subscribe(t, n) };
                      return function () {
                        setTimeout(function () {
                          return r.current.unsubscribe();
                        });
                      };
                    },
                    [f, h, S, P, v, c]
                  ),
                  function () {
                    return G || U(P, S, z.current, v, c);
                  },
                  function () {
                    return G || U(P, S, z.current, v, c);
                  }
                )),
              obsQueryFields: V,
              observable: S,
              resultData: P,
              client: c,
              onQueryExecuted: O,
            }),
          Q = K.result,
          Y = K.obsQueryFields;
        return l.useMemo(
          function () {
            return (0, s.__assign)((0, s.__assign)({}, Q), Y);
          },
          [Q, Y]
        );
      }
      function D(e, t, n, r) {
        var i = [],
          a = t.defaultOptions.watchQuery;
        return (
          a && i.push(a),
          n.defaultOptions && i.push(n.defaultOptions),
          i.push((0, I.o)(e && e.options, r)),
          i.reduce(f.J)
        );
      }
      function B(e, t, n, r, i, a, l) {
        var u = t.current;
        u && u.data && (t.previousData = u.data),
          !e.error && (0, S.O)(e.errors) && (e.error = new g.cA({ graphQLErrors: e.errors })),
          (t.current = F(
            e.partial &&
              i &&
              !e.loading &&
              (!e.data || 0 === Object.keys(e.data).length) &&
              'cache-only' !== n.options.fetchPolicy
              ? (n.refetch(),
                (0, s.__assign)((0, s.__assign)({}, e), {
                  loading: !0,
                  networkStatus: w.Ie.refetch,
                }))
              : e,
            t.previousData,
            n,
            r
          )),
          a(),
          (function (e, t, n) {
            if (!e.loading) {
              var r = (0, S.O)(e.errors) ? new g.cA({ graphQLErrors: e.errors }) : e.error;
              Promise.resolve()
                .then(function () {
                  r
                    ? n.onError(r)
                    : e.data &&
                      t !== e.networkStatus &&
                      e.networkStatus === w.Ie.ready &&
                      n.onCompleted(e.data);
                })
                .catch(function (e) {
                  !1 !== globalThis.__DEV__ && o.kG.warn(e);
                });
            }
          })(e, null == u ? void 0 : u.networkStatus, l);
      }
      function U(e, t, n, r, i) {
        return e.current || B(t.getCurrentResult(), e, t, i, r, function () {}, n), e.current;
      }
      function L(e, t) {
        var n;
        return (
          (null == e ? void 0 : e.fetchPolicy) ||
          (null === (n = null == t ? void 0 : t.watchQuery) || void 0 === n
            ? void 0
            : n.fetchPolicy) ||
          'cache-first'
        );
      }
      function F(e, t, n, r) {
        var i = e.data,
          a = (e.partial, (0, s.__rest)(e, ['data', 'partial']));
        return (0, s.__assign)((0, s.__assign)({ data: i }, a), {
          client: r,
          observable: n,
          variables: n.variables,
          called: e !== j && e !== q,
          previousData: t,
        });
      }
      var j = (0, P.J)({ loading: !0, data: void 0, error: void 0, networkStatus: w.Ie.loading }),
        q = (0, P.J)({ loading: !1, data: void 0, error: void 0, networkStatus: w.Ie.ready });
    },
    98517: function (e, t, n) {
      'use strict';
      n.d(t, {
        L: function () {
          return l;
        },
        s: function () {
          return o;
        },
      });
      var r = n(37811),
        i = n(27305),
        a = new WeakSet();
      function s(e) {
        !(e.size <= (e.max || -1)) &&
          (a.has(e) ||
            (a.add(e),
            setTimeout(function () {
              e.clean(), a.delete(e);
            }, 100)));
      }
      var o = function (e, t) {
          var n = new r.k(e, t);
          return (
            (n.set = function (e, t) {
              var n = r.k.prototype.set.call(this, e, t);
              return s(this), n;
            }),
            n
          );
        },
        l = function (e, t) {
          var n = new i.e(e, t);
          return (
            (n.set = function (e, t) {
              var n = i.e.prototype.set.call(this, e, t);
              return s(this), n;
            }),
            n
          );
        };
    },
    39341: function (e, t, n) {
      'use strict';
      n.d(t, {
        Kb: function () {
          return u;
        },
        q4: function () {
          return l;
        },
        su: function () {
          return o;
        },
        zP: function () {
          return s;
        },
      });
      var r = n(85192),
        i = n(29645),
        a = {};
      function s(e, t) {
        a[e] = t;
      }
      var o =
          !1 !== globalThis.__DEV__
            ? function () {
                var e, t, n, s, o;
                if (!(!1 !== globalThis.__DEV__)) throw Error('only supported in development mode');
                return {
                  limits: Object.fromEntries(
                    Object.entries({
                      parser: 1e3,
                      canonicalStringify: 1e3,
                      print: 2e3,
                      'documentTransform.cache': 2e3,
                      'queryManager.getDocumentInfo': 2e3,
                      'PersistedQueryLink.persistedQueryHashes': 2e3,
                      'fragmentRegistry.transform': 2e3,
                      'fragmentRegistry.lookup': 1e3,
                      'fragmentRegistry.findFragmentSpreads': 4e3,
                      'cache.fragmentQueryDocuments': 1e3,
                      'removeTypenameFromVariables.getVariableDefinitions': 2e3,
                      'inMemoryCache.maybeBroadcastWatch': 5e3,
                      'inMemoryCache.executeSelectionSet': 5e4,
                      'inMemoryCache.executeSubSelectedArray': 1e4,
                    }).map(function (e) {
                      var t = e[0],
                        n = e[1];
                      return [t, i.Q[t] || n];
                    })
                  ),
                  sizes: (0, r.__assign)(
                    {
                      print: null === (e = a.print) || void 0 === e ? void 0 : e.call(a),
                      parser: null === (t = a.parser) || void 0 === t ? void 0 : t.call(a),
                      canonicalStringify:
                        null === (n = a.canonicalStringify) || void 0 === n ? void 0 : n.call(a),
                      links: (function e(t) {
                        var n;
                        return t
                          ? (0, r.__spreadArray)(
                              (0, r.__spreadArray)(
                                [
                                  null === (n = null == t ? void 0 : t.getMemoryInternals) ||
                                  void 0 === n
                                    ? void 0
                                    : n.call(t),
                                ],
                                e(null == t ? void 0 : t.left),
                                !0
                              ),
                              e(null == t ? void 0 : t.right),
                              !0
                            ).filter(p)
                          : [];
                      })(this.link),
                      queryManager: {
                        getDocumentInfo: this.queryManager.transformCache.size,
                        documentTransforms: h(this.queryManager.documentTransform),
                      },
                    },
                    null === (o = (s = this.cache).getMemoryInternals) || void 0 === o
                      ? void 0
                      : o.call(s)
                  ),
                };
              }
            : void 0,
        l =
          !1 !== globalThis.__DEV__
            ? function () {
                var e = this.config.fragments;
                return (0, r.__assign)((0, r.__assign)({}, c.apply(this)), {
                  addTypenameDocumentTransform: h(this.addTypenameTransform),
                  inMemoryCache: {
                    executeSelectionSet: d(this.storeReader.executeSelectionSet),
                    executeSubSelectedArray: d(this.storeReader.executeSubSelectedArray),
                    maybeBroadcastWatch: d(this.maybeBroadcastWatch),
                  },
                  fragmentRegistry: {
                    findFragmentSpreads: d(null == e ? void 0 : e.findFragmentSpreads),
                    lookup: d(null == e ? void 0 : e.lookup),
                    transform: d(null == e ? void 0 : e.transform),
                  },
                });
              }
            : void 0,
        u = !1 !== globalThis.__DEV__ ? c : void 0;
      function c() {
        return { cache: { fragmentQueryDocuments: d(this.getFragmentDoc) } };
      }
      function d(e) {
        return e && 'dirtyKey' in e ? e.size : void 0;
      }
      function p(e) {
        return null != e;
      }
      function h(e) {
        return (function e(t) {
          return t
            ? (0, r.__spreadArray)(
                (0, r.__spreadArray)(
                  [d(null == t ? void 0 : t.performWork)],
                  e(null == t ? void 0 : t.left),
                  !0
                ),
                e(null == t ? void 0 : t.right),
                !0
              ).filter(p)
            : [];
        })(e).map(function (e) {
          return { cache: e };
        });
      }
    },
    29645: function (e, t, n) {
      'use strict';
      n.d(t, {
        Q: function () {
          return s;
        },
      });
      var r = n(85192),
        i = n(47189),
        a = Symbol.for('apollo.cacheSize'),
        s = (0, r.__assign)({}, i.CO[a]);
    },
    73664: function (e, t, n) {
      'use strict';
      n.d(t, {
        O: function () {
          return i;
        },
        k: function () {
          return r;
        },
      });
      var r = Array.isArray;
      function i(e) {
        return Array.isArray(e) && e.length > 0;
      }
    },
    40431: function (e, t, n) {
      'use strict';
      n.d(t, {
        DN: function () {
          return l;
        },
        JC: function () {
          return d;
        },
        aS: function () {
          return o;
        },
        mr: function () {
          return a;
        },
        sy: function () {
          return s;
        },
      });
      var r = n(47189),
        i =
          'ReactNative' ==
          (0, r.wY)(function () {
            return navigator.product;
          }),
        a = 'function' == typeof WeakMap && !(i && !global.HermesInternal),
        s = 'function' == typeof WeakSet,
        o = 'function' == typeof Symbol && 'function' == typeof Symbol.for,
        l = o && Symbol.asyncIterator,
        u =
          'function' ==
          typeof (0, r.wY)(function () {
            return window.document.createElement;
          }),
        c =
          (0, r.wY)(function () {
            return navigator.userAgent.indexOf('jsdom') >= 0;
          }) || !1,
        d = (u || i) && !c;
    },
    13532: function (e, t, n) {
      'use strict';
      n.d(t, {
        B: function () {
          return o;
        },
      });
      var r,
        i = n(98517),
        a = n(29645),
        s = n(39341),
        o = Object.assign(
          function (e) {
            return JSON.stringify(e, l);
          },
          {
            reset: function () {
              r = new i.L(a.Q.canonicalStringify || 1e3);
            },
          }
        );
      function l(e, t) {
        if (t && 'object' == typeof t) {
          var n = Object.getPrototypeOf(t);
          if (n === Object.prototype || null === n) {
            var i = Object.keys(t);
            if (i.every(u)) return t;
            var a = JSON.stringify(i),
              s = r.get(a);
            if (!s) {
              i.sort();
              var o = JSON.stringify(i);
              (s = r.get(o) || i), r.set(a, s), r.set(o, s);
            }
            var l = Object.create(n);
            return (
              s.forEach(function (e) {
                l[e] = t[e];
              }),
              l
            );
          }
        }
        return t;
      }
      function u(e, t, n) {
        return 0 === t || n[t - 1] <= e;
      }
      !1 !== globalThis.__DEV__ &&
        (0, s.zP)('canonicalStringify', function () {
          return r.size;
        }),
        o.reset();
    },
    32505: function (e, t, n) {
      'use strict';
      n.d(t, {
        X: function () {
          return i;
        },
      });
      var r = Object.prototype.toString;
      function i(e) {
        return (function e(t, n) {
          switch (r.call(t)) {
            case '[object Array]':
              if ((n = n || new Map()).has(t)) return n.get(t);
              var i = t.slice(0);
              return (
                n.set(t, i),
                i.forEach(function (t, r) {
                  i[r] = e(t, n);
                }),
                i
              );
            case '[object Object]':
              if ((n = n || new Map()).has(t)) return n.get(t);
              var a = Object.create(Object.getPrototypeOf(t));
              return (
                n.set(t, a),
                Object.keys(t).forEach(function (r) {
                  a[r] = e(t[r], n);
                }),
                a
              );
            default:
              return t;
          }
        })(e);
      }
    },
    65968: function (e, t, n) {
      'use strict';
      function r() {
        for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
        var n = Object.create(null);
        return (
          e.forEach(function (e) {
            e &&
              Object.keys(e).forEach(function (t) {
                var r = e[t];
                void 0 !== r && (n[t] = r);
              });
          }),
          n
        );
      }
      n.d(t, {
        o: function () {
          return r;
        },
      });
    },
    95092: function (e, t, n) {
      'use strict';
      n.d(t, {
        X: function () {
          return i;
        },
      });
      var r = new Map();
      function i(e) {
        var t = r.get(e) || 1;
        return (
          r.set(e, t + 1),
          ''.concat(e, ':').concat(t, ':').concat(Math.random().toString(36).slice(2))
        );
      }
    },
    11625: function (e, t, n) {
      'use strict';
      n.d(t, {
        J: function () {
          return i;
        },
      });
      var r = n(9402);
      function i(e) {
        if (!1 !== globalThis.__DEV__) {
          var t;
          (t = new Set([e])).forEach(function (e) {
            (0, r.s)(e) &&
              (function (e) {
                if (!1 !== globalThis.__DEV__ && !Object.isFrozen(e))
                  try {
                    Object.freeze(e);
                  } catch (e) {
                    if (e instanceof TypeError) return null;
                    throw e;
                  }
                return e;
              })(e) === e &&
              Object.getOwnPropertyNames(e).forEach(function (n) {
                (0, r.s)(e[n]) && t.add(e[n]);
              });
          });
        }
        return e;
      }
    },
    94263: function (e, t, n) {
      'use strict';
      n.d(t, {
        J: function () {
          return a;
        },
      });
      var r = n(85192),
        i = n(65968);
      function a(e, t) {
        return (0, i.o)(
          e,
          t,
          t.variables && {
            variables: (0, i.o)(
              (0, r.__assign)((0, r.__assign)({}, e && e.variables), t.variables)
            ),
          }
        );
      }
    },
    9402: function (e, t, n) {
      'use strict';
      function r(e) {
        return null !== e && 'object' == typeof e;
      }
      n.d(t, {
        s: function () {
          return r;
        },
      });
    },
    28994: function (e, t, n) {
      'use strict';
      n.d(t, {
        v: function () {
          return i;
        },
      });
      var r = n(95092);
      function i(e, t) {
        void 0 === t && (t = 0);
        var n = (0, r.X)('stringifyForDisplay');
        return JSON.stringify(
          e,
          function (e, t) {
            return void 0 === t ? n : t;
          },
          t
        )
          .split(JSON.stringify(n))
          .join('<undefined>');
      }
    },
    47189: function (e, t, n) {
      'use strict';
      n.d(t, {
        CO: function () {
          return f;
        },
        kG: function () {
          return b;
        },
        wY: function () {
          return y;
        },
        _K: function () {
          return w;
        },
      });
      var r,
        i = n(85192),
        a = 'Invariant Violation',
        s = Object.setPrototypeOf,
        o =
          void 0 === s
            ? function (e, t) {
                return (e.__proto__ = t), e;
              }
            : s,
        l = (function (e) {
          function t(n) {
            void 0 === n && (n = a);
            var r =
              e.call(
                this,
                'number' == typeof n
                  ? a + ': ' + n + ' (see https://github.com/apollographql/invariant-packages)'
                  : n
              ) || this;
            return (r.framesToPop = 1), (r.name = a), o(r, t.prototype), r;
          }
          return (0, i.__extends)(t, e), t;
        })(Error);
      function u(e, t) {
        if (!e) throw new l(t);
      }
      var c = ['debug', 'log', 'warn', 'error', 'silent'],
        d = c.indexOf('log');
      function p(e) {
        return function () {
          if (c.indexOf(e) >= d) return (console[e] || console.log).apply(console, arguments);
        };
      }
      ((r = u || (u = {})).debug = p('debug')),
        (r.log = p('log')),
        (r.warn = p('warn')),
        (r.error = p('error'));
      var h = n(2511);
      function y(e) {
        try {
          return e();
        } catch (e) {}
      }
      var f =
          y(function () {
            return globalThis;
          }) ||
          y(function () {
            return window;
          }) ||
          y(function () {
            return self;
          }) ||
          y(function () {
            return global;
          }) ||
          y(function () {
            return y.constructor('return this')();
          }),
        m = n(28994);
      function g(e) {
        return function (t) {
          for (var n = [], r = 1; r < arguments.length; r++) n[r - 1] = arguments[r];
          if ('number' == typeof t) {
            var i = t;
            (t = A(i)) || ((t = E(i, n)), (n = []));
          }
          e.apply(void 0, [t].concat(n));
        };
      }
      var b = Object.assign(
        function (e, t) {
          for (var n = [], r = 2; r < arguments.length; r++) n[r - 2] = arguments[r];
          e || u(e, A(t, n) || E(t, n));
        },
        { debug: g(u.debug), log: g(u.log), warn: g(u.warn), error: g(u.error) }
      );
      function w(e) {
        for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
        return new l(A(e, t) || E(e, t));
      }
      var v = Symbol.for('ApolloErrorMessageHandler_' + h.i);
      function T(e) {
        if ('string' == typeof e) return e;
        try {
          return (0, m.v)(e, 2).slice(0, 1e3);
        } catch (e) {
          return '<non-serializable>';
        }
      }
      function A(e, t) {
        if ((void 0 === t && (t = []), e)) return f[v] && f[v](e, t.map(T));
      }
      function E(e, t) {
        if ((void 0 === t && (t = []), e))
          return 'An error occurred! For more details, see the full error text at https://go.apollo.dev/c/err#'.concat(
            encodeURIComponent(JSON.stringify({ version: h.i, message: e, args: t.map(T) }))
          );
      }
    },
    78034: function (e, t, n) {
      'use strict';
      n.d(t, {
        FS: function () {
          return o;
        },
        GT: function () {
          return u;
        },
        LZ: function () {
          return s;
        },
        mj: function () {
          return l;
        },
      });
      var r = n(47189),
        i = n(31836),
        a = n(60832);
      function s(e, t) {
        var n,
          i = e.directives;
        return (
          !i ||
          !i.length ||
          ((n = []),
          i &&
            i.length &&
            i.forEach(function (e) {
              var t;
              if (!('skip' !== (t = e.name.value) && 'include' !== t)) {
                var i = e.arguments,
                  a = e.name.value;
                (0, r.kG)(i && 1 === i.length, 79, a);
                var s = i[0];
                (0, r.kG)(s.name && 'if' === s.name.value, 80, a);
                var o = s.value;
                (0, r.kG)(o && ('Variable' === o.kind || 'BooleanValue' === o.kind), 81, a),
                  n.push({ directive: e, ifArgument: s });
              }
            }),
          n).every(function (e) {
            var n = e.directive,
              i = e.ifArgument,
              a = !1;
            return (
              'Variable' === i.value.kind
                ? ((a = t && t[i.value.name.value]), (0, r.kG)(void 0 !== a, 78, n.name.value))
                : (a = i.value.value),
              'skip' === n.name.value ? !a : a
            );
          })
        );
      }
      function o(e, t, n) {
        var r = new Set(e),
          a = r.size;
        return (
          (0, i.Vn)(t, {
            Directive: function (e) {
              if (r.delete(e.name.value) && (!n || !r.size)) return i.$_;
            },
          }),
          n ? !r.size : r.size < a
        );
      }
      function l(e) {
        return e && o(['client', 'export'], e, !0);
      }
      function u(e) {
        var t,
          n,
          i =
            null === (t = e.directives) || void 0 === t
              ? void 0
              : t.find(function (e) {
                  return 'unmask' === e.name.value;
                });
        if (!i) return 'mask';
        var s =
          null === (n = i.arguments) || void 0 === n
            ? void 0
            : n.find(function (e) {
                return 'mode' === e.name.value;
              });
        return (!1 !== globalThis.__DEV__ &&
          s &&
          (s.value.kind === a.h.VARIABLE
            ? !1 !== globalThis.__DEV__ && r.kG.warn(82)
            : s.value.kind !== a.h.STRING
              ? !1 !== globalThis.__DEV__ && r.kG.warn(83)
              : 'migrate' !== s.value.value &&
                !1 !== globalThis.__DEV__ &&
                r.kG.warn(84, s.value.value)),
        s && 'value' in s.value && 'migrate' === s.value.value)
          ? 'migrate'
          : 'unmask';
      }
    },
    55204: function (e, t, n) {
      'use strict';
      n.d(t, {
        F: function () {
          return o;
        },
        YU: function () {
          return u;
        },
        Yk: function () {
          return s;
        },
        hi: function () {
          return l;
        },
      });
      var r = n(85192),
        i = n(47189),
        a = n(31836);
      function s(e, t) {
        var n = t,
          a = [];
        return (
          e.definitions.forEach(function (e) {
            if ('OperationDefinition' === e.kind)
              throw (0, i._K)(85, e.operation, e.name ? " named '".concat(e.name.value, "'") : '');
            'FragmentDefinition' === e.kind && a.push(e);
          }),
          void 0 === n && ((0, i.kG)(1 === a.length, 86, a.length), (n = a[0].name.value)),
          (0, r.__assign)((0, r.__assign)({}, e), {
            definitions: (0, r.__spreadArray)(
              [
                {
                  kind: 'OperationDefinition',
                  operation: 'query',
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [{ kind: 'FragmentSpread', name: { kind: 'Name', value: n } }],
                  },
                },
              ],
              e.definitions,
              !0
            ),
          })
        );
      }
      function o(e) {
        void 0 === e && (e = []);
        var t = {};
        return (
          e.forEach(function (e) {
            t[e.name.value] = e;
          }),
          t
        );
      }
      function l(e, t) {
        switch (e.kind) {
          case 'InlineFragment':
            return e;
          case 'FragmentSpread':
            var n = e.name.value;
            if ('function' == typeof t) return t(n);
            var r = t && t[n];
            return (0, i.kG)(r, 87, n), r || null;
          default:
            return null;
        }
      }
      function u(e) {
        var t = !0;
        return (
          (0, a.Vn)(e, {
            FragmentSpread: function (e) {
              if (
                !(t =
                  !!e.directives &&
                  e.directives.some(function (e) {
                    return 'unmask' === e.name.value;
                  }))
              )
                return a.$_;
            },
          }),
          t
        );
      }
    },
    32483: function (e, t, n) {
      'use strict';
      n.d(t, {
        $H: function () {
          return s;
        },
        A$: function () {
          return a;
        },
        O4: function () {
          return p;
        },
        iW: function () {
          return u;
        },
        kU: function () {
          return l;
        },
        p$: function () {
          return d;
        },
        pD: function () {
          return c;
        },
        rY: function () {
          return o;
        },
      });
      var r = n(47189),
        i = n(35792);
      function a(e) {
        (0, r.kG)(e && 'Document' === e.kind, 88);
        var t = e.definitions
          .filter(function (e) {
            return 'FragmentDefinition' !== e.kind;
          })
          .map(function (e) {
            if ('OperationDefinition' !== e.kind) throw (0, r._K)(89, e.kind);
            return e;
          });
        return (0, r.kG)(t.length <= 1, 90, t.length), e;
      }
      function s(e) {
        return (
          a(e),
          e.definitions.filter(function (e) {
            return 'OperationDefinition' === e.kind;
          })[0]
        );
      }
      function o(e) {
        return (
          e.definitions
            .filter(function (e) {
              return 'OperationDefinition' === e.kind && !!e.name;
            })
            .map(function (e) {
              return e.name.value;
            })[0] || null
        );
      }
      function l(e) {
        return e.definitions.filter(function (e) {
          return 'FragmentDefinition' === e.kind;
        });
      }
      function u(e) {
        var t = s(e);
        return (0, r.kG)(t && 'query' === t.operation, 91), t;
      }
      function c(e) {
        (0, r.kG)('Document' === e.kind, 92), (0, r.kG)(e.definitions.length <= 1, 93);
        var t = e.definitions[0];
        return (0, r.kG)('FragmentDefinition' === t.kind, 94), t;
      }
      function d(e) {
        a(e);
        for (var t, n = 0, i = e.definitions; n < i.length; n++) {
          var s = i[n];
          if ('OperationDefinition' === s.kind) {
            var o = s.operation;
            if ('query' === o || 'mutation' === o || 'subscription' === o) return s;
          }
          'FragmentDefinition' !== s.kind || t || (t = s);
        }
        if (t) return t;
        throw (0, r._K)(95);
      }
      function p(e) {
        var t = Object.create(null),
          n = e && e.variableDefinitions;
        return (
          n &&
            n.length &&
            n.forEach(function (e) {
              e.defaultValue && (0, i.vb)(t, e.variable.name, e.defaultValue);
            }),
          t
        );
      }
    },
    35792: function (e, t, n) {
      'use strict';
      n.d(t, {
        Ao: function () {
          return b;
        },
        JW: function () {
          return u;
        },
        My: function () {
          return g;
        },
        NC: function () {
          return f;
        },
        PT: function () {
          return y;
        },
        Yk: function () {
          return l;
        },
        kQ: function () {
          return o;
        },
        qw: function () {
          return function e(t, n, r) {
            for (var i, s = 0, o = n.selections; s < o.length; s++) {
              var l = o[s];
              if (g(l)) {
                if ('__typename' === l.name.value) return t[m(l)];
              } else i ? i.push(l) : (i = [l]);
            }
            if ('string' == typeof t.__typename) return t.__typename;
            if (i)
              for (var u = 0, c = i; u < c.length; u++) {
                var l = c[u],
                  d = e(t, (0, a.hi)(l, r).selectionSet, r);
                if ('string' == typeof d) return d;
              }
          };
        },
        u2: function () {
          return m;
        },
        vb: function () {
          return c;
        },
        vf: function () {
          return d;
        },
      });
      var r = n(47189),
        i = n(9402),
        a = n(55204),
        s = n(13532);
      function o(e) {
        return { __ref: String(e) };
      }
      function l(e) {
        return !!(e && 'object' == typeof e && 'string' == typeof e.__ref);
      }
      function u(e) {
        return (0, i.s)(e) && 'Document' === e.kind && Array.isArray(e.definitions);
      }
      function c(e, t, n, i) {
        if ('IntValue' === n.kind || 'FloatValue' === n.kind) e[t.value] = Number(n.value);
        else if ('BooleanValue' === n.kind || 'StringValue' === n.kind) e[t.value] = n.value;
        else if ('ObjectValue' === n.kind) {
          var a = {};
          n.fields.map(function (e) {
            return c(a, e.name, e.value, i);
          }),
            (e[t.value] = a);
        } else if ('Variable' === n.kind) {
          var s = (i || {})[n.name.value];
          e[t.value] = s;
        } else if ('ListValue' === n.kind)
          e[t.value] = n.values.map(function (e) {
            var n = {};
            return c(n, t, e, i), n[t.value];
          });
        else if ('EnumValue' === n.kind) e[t.value] = n.value;
        else if ('NullValue' === n.kind) e[t.value] = null;
        else throw (0, r._K)(96, t.value, n.kind);
      }
      function d(e, t) {
        var n = null;
        e.directives &&
          ((n = {}),
          e.directives.forEach(function (e) {
            (n[e.name.value] = {}),
              e.arguments &&
                e.arguments.forEach(function (r) {
                  var i = r.name,
                    a = r.value;
                  return c(n[e.name.value], i, a, t);
                });
          }));
        var r = null;
        return (
          e.arguments &&
            e.arguments.length &&
            ((r = {}),
            e.arguments.forEach(function (e) {
              var n = e.name,
                i = e.value;
              return c(r, n, i, t);
            })),
          y(e.name.value, r, n)
        );
      }
      var p = ['connection', 'include', 'skip', 'client', 'rest', 'export', 'nonreactive'],
        h = s.B,
        y = Object.assign(
          function (e, t, n) {
            if (t && n && n.connection && n.connection.key) {
              if (!n.connection.filter || !(n.connection.filter.length > 0))
                return n.connection.key;
              var r = n.connection.filter ? n.connection.filter : [];
              r.sort();
              var i = {};
              return (
                r.forEach(function (e) {
                  i[e] = t[e];
                }),
                ''.concat(n.connection.key, '(').concat(h(i), ')')
              );
            }
            var a = e;
            if (t) {
              var s = h(t);
              a += '('.concat(s, ')');
            }
            return (
              n &&
                Object.keys(n).forEach(function (e) {
                  -1 === p.indexOf(e) &&
                    (n[e] && Object.keys(n[e]).length
                      ? (a += '@'.concat(e, '(').concat(h(n[e]), ')'))
                      : (a += '@'.concat(e)));
                }),
              a
            );
          },
          {
            setStringify: function (e) {
              var t = h;
              return (h = e), t;
            },
          }
        );
      function f(e, t) {
        if (e.arguments && e.arguments.length) {
          var n = {};
          return (
            e.arguments.forEach(function (e) {
              return c(n, e.name, e.value, t);
            }),
            n
          );
        }
        return null;
      }
      function m(e) {
        return e.alias ? e.alias.value : e.name.value;
      }
      function g(e) {
        return 'Field' === e.kind;
      }
      function b(e) {
        return 'InlineFragment' === e.kind;
      }
    },
    2584: function (e, t, n) {
      'use strict';
      function r(e, t, n) {
        var r = [];
        e.forEach(function (e) {
          return e[t] && r.push(e);
        }),
          r.forEach(function (e) {
            return e[t](n);
          });
      }
      n.d(t, {
        p: function () {
          return r;
        },
      });
    },
    79143: function (e, t, n) {
      'use strict';
      n.d(t, {
        D: function () {
          return a;
        },
      });
      var r = n(17085),
        i = n(40431);
      function a(e) {
        function t(t) {
          Object.defineProperty(e, t, { value: r.y });
        }
        return i.aS && Symbol.species && t(Symbol.species), t('@@species'), e;
      }
    },
    2511: function (e, t, n) {
      'use strict';
      n.d(t, {
        i: function () {
          return r;
        },
      });
      var r = '3.13.8';
    },
    36007: function (e, t, n) {
      'use strict';
      n.d(t, {
        fl: function () {
          return I;
        },
        iv: function () {
          return u;
        },
        Ts: function () {
          return E;
        },
        Qu: function () {
          return C;
        },
        $m: function () {
          return l;
        },
      });
      let r = globalThis,
        i =
          r.ShadowRoot &&
          (void 0 === r.ShadyCSS || r.ShadyCSS.nativeShadow) &&
          'adoptedStyleSheets' in Document.prototype &&
          'replace' in CSSStyleSheet.prototype,
        a = Symbol(),
        s = new WeakMap();
      class o {
        constructor(e, t, n) {
          if (((this._$cssResult$ = !0), n !== a))
            throw Error('CSSResult is not constructable. Use `unsafeCSS` or `css` instead.');
          (this.cssText = e), (this.t = t);
        }
        get styleSheet() {
          let e = this.o,
            t = this.t;
          if (i && void 0 === e) {
            let n = void 0 !== t && 1 === t.length;
            n && (e = s.get(t)),
              void 0 === e &&
                ((this.o = e = new CSSStyleSheet()).replaceSync(this.cssText), n && s.set(t, e));
          }
          return e;
        }
        toString() {
          return this.cssText;
        }
      }
      let l = (e) => new o('string' == typeof e ? e : e + '', void 0, a),
        u = (e, ...t) =>
          new o(
            1 === e.length
              ? e[0]
              : t.reduce(
                  (t, n, r) =>
                    t +
                    ((e) => {
                      if (!0 === e._$cssResult$) return e.cssText;
                      if ('number' == typeof e) return e;
                      throw Error(
                        "Value passed to 'css' function must be a 'css' function result: " +
                          e +
                          ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security."
                      );
                    })(n) +
                    e[r + 1],
                  e[0]
                ),
            e,
            a
          ),
        c = (e, t) => {
          if (i)
            e.adoptedStyleSheets = t.map((e) => (e instanceof CSSStyleSheet ? e : e.styleSheet));
          else
            for (let n of t) {
              let t = document.createElement('style'),
                i = r.litNonce;
              void 0 !== i && t.setAttribute('nonce', i),
                (t.textContent = n.cssText),
                e.appendChild(t);
            }
        },
        d = i
          ? (e) => e
          : (e) =>
              e instanceof CSSStyleSheet
                ? ((e) => {
                    let t = '';
                    for (let n of e.cssRules) t += n.cssText;
                    return l(t);
                  })(e)
                : e,
        {
          is: p,
          defineProperty: h,
          getOwnPropertyDescriptor: y,
          getOwnPropertyNames: f,
          getOwnPropertySymbols: m,
          getPrototypeOf: g,
        } = Object,
        b = globalThis,
        w = b.trustedTypes,
        v = w ? w.emptyScript : '',
        T = b.reactiveElementPolyfillSupport,
        A = (e, t) => e,
        E = {
          toAttribute(e, t) {
            switch (t) {
              case Boolean:
                e = e ? v : null;
                break;
              case Object:
              case Array:
                e = null == e ? e : JSON.stringify(e);
            }
            return e;
          },
          fromAttribute(e, t) {
            let n = e;
            switch (t) {
              case Boolean:
                n = null !== e;
                break;
              case Number:
                n = null === e ? null : Number(e);
                break;
              case Object:
              case Array:
                try {
                  n = JSON.parse(e);
                } catch (e) {
                  n = null;
                }
            }
            return n;
          },
        },
        C = (e, t) => !p(e, t),
        _ = {
          attribute: !0,
          type: String,
          converter: E,
          reflect: !1,
          useDefault: !1,
          hasChanged: C,
        };
      (Symbol.metadata ??= Symbol('metadata')), (b.litPropertyMetadata ??= new WeakMap());
      class I extends HTMLElement {
        static addInitializer(e) {
          this._$Ei(), (this.l ??= []).push(e);
        }
        static get observedAttributes() {
          return this.finalize(), this._$Eh && [...this._$Eh.keys()];
        }
        static createProperty(e, t = _) {
          if (
            (t.state && (t.attribute = !1),
            this._$Ei(),
            this.prototype.hasOwnProperty(e) && ((t = Object.create(t)).wrapped = !0),
            this.elementProperties.set(e, t),
            !t.noAccessor)
          ) {
            let n = Symbol(),
              r = this.getPropertyDescriptor(e, n, t);
            void 0 !== r && h(this.prototype, e, r);
          }
        }
        static getPropertyDescriptor(e, t, n) {
          let { get: r, set: i } = y(this.prototype, e) ?? {
            get() {
              return this[t];
            },
            set(e) {
              this[t] = e;
            },
          };
          return {
            get: r,
            set(t) {
              let a = r?.call(this);
              i?.call(this, t), this.requestUpdate(e, a, n);
            },
            configurable: !0,
            enumerable: !0,
          };
        }
        static getPropertyOptions(e) {
          return this.elementProperties.get(e) ?? _;
        }
        static _$Ei() {
          if (this.hasOwnProperty(A('elementProperties'))) return;
          let e = g(this);
          e.finalize(),
            void 0 !== e.l && (this.l = [...e.l]),
            (this.elementProperties = new Map(e.elementProperties));
        }
        static finalize() {
          if (this.hasOwnProperty(A('finalized'))) return;
          if (((this.finalized = !0), this._$Ei(), this.hasOwnProperty(A('properties')))) {
            let e = this.properties;
            for (let t of [...f(e), ...m(e)]) this.createProperty(t, e[t]);
          }
          let e = this[Symbol.metadata];
          if (null !== e) {
            let t = litPropertyMetadata.get(e);
            if (void 0 !== t) for (let [e, n] of t) this.elementProperties.set(e, n);
          }
          for (let [e, t] of ((this._$Eh = new Map()), this.elementProperties)) {
            let n = this._$Eu(e, t);
            void 0 !== n && this._$Eh.set(n, e);
          }
          this.elementStyles = this.finalizeStyles(this.styles);
        }
        static finalizeStyles(e) {
          let t = [];
          if (Array.isArray(e)) for (let n of new Set(e.flat(1 / 0).reverse())) t.unshift(d(n));
          else void 0 !== e && t.push(d(e));
          return t;
        }
        static _$Eu(e, t) {
          let n = t.attribute;
          return !1 === n
            ? void 0
            : 'string' == typeof n
              ? n
              : 'string' == typeof e
                ? e.toLowerCase()
                : void 0;
        }
        constructor() {
          super(),
            (this._$Ep = void 0),
            (this.isUpdatePending = !1),
            (this.hasUpdated = !1),
            (this._$Em = null),
            this._$Ev();
        }
        _$Ev() {
          (this._$ES = new Promise((e) => (this.enableUpdating = e))),
            (this._$AL = new Map()),
            this._$E_(),
            this.requestUpdate(),
            this.constructor.l?.forEach((e) => e(this));
        }
        addController(e) {
          (this._$EO ??= new Set()).add(e),
            void 0 !== this.renderRoot && this.isConnected && e.hostConnected?.();
        }
        removeController(e) {
          this._$EO?.delete(e);
        }
        _$E_() {
          let e = new Map();
          for (let t of this.constructor.elementProperties.keys())
            this.hasOwnProperty(t) && (e.set(t, this[t]), delete this[t]);
          e.size > 0 && (this._$Ep = e);
        }
        createRenderRoot() {
          let e = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
          return c(e, this.constructor.elementStyles), e;
        }
        connectedCallback() {
          (this.renderRoot ??= this.createRenderRoot()),
            this.enableUpdating(!0),
            this._$EO?.forEach((e) => e.hostConnected?.());
        }
        enableUpdating(e) {}
        disconnectedCallback() {
          this._$EO?.forEach((e) => e.hostDisconnected?.());
        }
        attributeChangedCallback(e, t, n) {
          this._$AK(e, n);
        }
        _$ET(e, t) {
          let n = this.constructor.elementProperties.get(e),
            r = this.constructor._$Eu(e, n);
          if (void 0 !== r && !0 === n.reflect) {
            let i = (void 0 !== n.converter?.toAttribute ? n.converter : E).toAttribute(t, n.type);
            (this._$Em = e),
              null == i ? this.removeAttribute(r) : this.setAttribute(r, i),
              (this._$Em = null);
          }
        }
        _$AK(e, t) {
          let n = this.constructor,
            r = n._$Eh.get(e);
          if (void 0 !== r && this._$Em !== r) {
            let e = n.getPropertyOptions(r),
              i =
                'function' == typeof e.converter
                  ? { fromAttribute: e.converter }
                  : void 0 !== e.converter?.fromAttribute
                    ? e.converter
                    : E;
            (this._$Em = r),
              (this[r] = i.fromAttribute(t, e.type) ?? this._$Ej?.get(r) ?? null),
              (this._$Em = null);
          }
        }
        requestUpdate(e, t, n) {
          if (void 0 !== e) {
            let r = this.constructor,
              i = this[e];
            if (
              !(
                ((n ??= r.getPropertyOptions(e)).hasChanged ?? C)(i, t) ||
                (n.useDefault &&
                  n.reflect &&
                  i === this._$Ej?.get(e) &&
                  !this.hasAttribute(r._$Eu(e, n)))
              )
            )
              return;
            this.C(e, t, n);
          }
          !1 === this.isUpdatePending && (this._$ES = this._$EP());
        }
        C(e, t, { useDefault: n, reflect: r, wrapped: i }, a) {
          (n &&
            !(this._$Ej ??= new Map()).has(e) &&
            (this._$Ej.set(e, a ?? t ?? this[e]), !0 !== i || void 0 !== a)) ||
            (this._$AL.has(e) || (this.hasUpdated || n || (t = void 0), this._$AL.set(e, t)),
            !0 === r && this._$Em !== e && (this._$Eq ??= new Set()).add(e));
        }
        async _$EP() {
          this.isUpdatePending = !0;
          try {
            await this._$ES;
          } catch (e) {
            Promise.reject(e);
          }
          let e = this.scheduleUpdate();
          return null != e && (await e), !this.isUpdatePending;
        }
        scheduleUpdate() {
          return this.performUpdate();
        }
        performUpdate() {
          if (!this.isUpdatePending) return;
          if (!this.hasUpdated) {
            if (((this.renderRoot ??= this.createRenderRoot()), this._$Ep)) {
              for (let [e, t] of this._$Ep) this[e] = t;
              this._$Ep = void 0;
            }
            let e = this.constructor.elementProperties;
            if (e.size > 0)
              for (let [t, n] of e) {
                let { wrapped: e } = n,
                  r = this[t];
                !0 !== e || this._$AL.has(t) || void 0 === r || this.C(t, void 0, n, r);
              }
          }
          let e = !1,
            t = this._$AL;
          try {
            (e = this.shouldUpdate(t))
              ? (this.willUpdate(t), this._$EO?.forEach((e) => e.hostUpdate?.()), this.update(t))
              : this._$EM();
          } catch (t) {
            throw ((e = !1), this._$EM(), t);
          }
          e && this._$AE(t);
        }
        willUpdate(e) {}
        _$AE(e) {
          this._$EO?.forEach((e) => e.hostUpdated?.()),
            this.hasUpdated || ((this.hasUpdated = !0), this.firstUpdated(e)),
            this.updated(e);
        }
        _$EM() {
          (this._$AL = new Map()), (this.isUpdatePending = !1);
        }
        get updateComplete() {
          return this.getUpdateComplete();
        }
        getUpdateComplete() {
          return this._$ES;
        }
        shouldUpdate(e) {
          return !0;
        }
        update(e) {
          (this._$Eq &&= this._$Eq.forEach((e) => this._$ET(e, this[e]))), this._$EM();
        }
        updated(e) {}
        firstUpdated(e) {}
      }
      (I.elementStyles = []),
        (I.shadowRootOptions = { mode: 'open' }),
        (I[A('elementProperties')] = new Map()),
        (I[A('finalized')] = new Map()),
        T?.({ ReactiveElement: I }),
        (b.reactiveElementVersions ??= []).push('2.1.0');
    },
    81239: function (e, t, n) {
      'use strict';
      n.d(t, {
        c: function () {
          return g;
        },
      });
      var r = n(40252),
        i = n(4565),
        a = n(65386);
      function s(e) {
        let t = (0, a.useChainId)(e);
        return e?.chainId ?? t;
      }
      var o = n(24755),
        l = n(35047),
        u = n(30785),
        c = n(58258),
        d = n(81082);
      function p(e) {
        return Array.isArray(e) && e.length === Object.keys(e).length;
      }
      function h(e, t) {
        if (e === t) return e;
        if (
          null == e ||
          'number' == typeof e ||
          'string' == typeof e ||
          'boolean' == typeof e ||
          'bigint' == typeof e ||
          'symbol' == typeof e ||
          null == t
        )
          return t;
        let n = p(e) && p(t),
          r = n ? e : Object.keys(e),
          i = r.length,
          a = n ? t : Object.keys(t),
          s = a.length,
          o = Object.create(Object.getPrototypeOf(e), Object.getOwnPropertyDescriptors(e)),
          l = 0;
        for (let i = 0; i < s; i++) {
          let s = n ? i : a[i];
          ((!n && r.includes(s)) || n) && void 0 === e[s] && void 0 === t[s]
            ? ((o[s] = void 0), l++)
            : ((o[s] = h(e[s], t[s])), o[s] === e[s] && void 0 !== e[s] && l++);
        }
        for (let e = 0; e < i; e++) {
          let t = n ? e : r[e];
          n || a.includes(t) || delete o[t];
        }
        return i === s && l === i ? e : o;
      }
      let y = (e, t) => {
        let n = new Set(),
          r = [];
        for (let i of e) {
          let e = t(i);
          n.has(e) || (n.add(e), r.push(i));
        }
        return r;
      };
      var f = n(51196),
        m = n(50964);
      function g({ block: e, accrueInterest: t = !0, includeVaultQueues: n = !0, ...a }) {
        let p = (a.query?.staleTime ?? e?.number != null) ? Number.POSITIVE_INFINITY : void 0,
          g = s(a),
          { morpho: b } = r.addresses[g],
          w = (0, m.useReadContract)({
            ...a,
            blockNumber: e?.number,
            address: b,
            abi: i.blueAbi,
            functionName: 'feeRecipient',
            query: { ...a.query, enabled: null != e && a.query?.enabled, staleTime: p },
          }),
          v = (function ({ vaults: e, query: t = {}, ...n }) {
            let r = (0, d.useConfig)(n),
              a = s(n),
              p = new Set(e),
              y = (0, u.h)({
                queries: Array.from(p, (e) => ({
                  ...t,
                  async queryFn({ queryKey: e }) {
                    let { vault: t, chainId: n, ...a } = e[1];
                    if (!t) throw Error('vault is required');
                    return (0, i.fetchVault)(t, r.getClient({ chainId: n }), { chainId: n, ...a });
                  },
                  queryKey: (function ({
                    vault: e,
                    chainId: t,
                    blockTag: n,
                    blockNumber: r,
                    deployless: i,
                    account: a,
                    stateOverride: s,
                  }) {
                    return [
                      'fetchVault',
                      {
                        vault: e,
                        chainId: t,
                        blockTag: n,
                        blockNumber: r,
                        deployless: i,
                        account: a,
                        stateOverride: s,
                      },
                    ];
                  })({ ...n, vault: e, chainId: a }),
                  queryKeyHashFn: o.kq,
                  enabled: null != e && t.enabled,
                  structuralSharing: t.structuralSharing ?? h,
                  staleTime:
                    t.staleTime ?? (null != n.blockNumber ? Number.POSITIVE_INFINITY : void 0),
                })),
              }),
              f = { data: {}, error: {}, isFetching: {}, isFetchingAny: !1 };
            p.values()
              .filter(l.isDefined)
              .forEach((e, t) => {
                let { data: n, error: r, isFetching: i } = y[t];
                (f.data[e] = n),
                  (f.error[e] = r),
                  (f.isFetching[e] = i),
                  i && (f.isFetchingAny = !0);
              });
            let m = (0, c.useRef)(f);
            return (m.current = h(m.current, f)), m.current;
          })({
            ...a,
            blockNumber: e?.number,
            query: { ...a.query, enabled: null != e && a.query?.enabled },
          }),
          T = n
            ? Array.from(a.marketIds).concat(
                (0, l.values)(v.data).flatMap((e) => e?.supplyQueue.concat(e.withdrawQueue) ?? [])
              )
            : a.marketIds,
          A = (function ({ marketIds: e, query: t = {}, ...n }) {
            let r = (0, d.useConfig)(n),
              a = s(n),
              p = new Set(e),
              y = (0, u.h)({
                queries: Array.from(p, (e) => ({
                  ...t,
                  async queryFn({ queryKey: e }) {
                    let { marketId: t, chainId: n, ...a } = e[1];
                    if (!t) throw Error('marketId is required');
                    return (0, i.fetchMarket)(t, r.getClient({ chainId: n }), { chainId: n, ...a });
                  },
                  queryKey: (function ({
                    marketId: e,
                    chainId: t,
                    blockTag: n,
                    blockNumber: r,
                    deployless: i,
                    account: a,
                    stateOverride: s,
                  }) {
                    return [
                      'fetchMarket',
                      {
                        marketId: e,
                        chainId: t,
                        blockTag: n,
                        blockNumber: r,
                        deployless: i,
                        account: a,
                        stateOverride: s,
                      },
                    ];
                  })({ ...n, marketId: e, chainId: a }),
                  queryKeyHashFn: o.kq,
                  enabled: null != e && t.enabled,
                  structuralSharing: t.structuralSharing ?? h,
                  staleTime:
                    t.staleTime ?? (null != n.blockNumber ? Number.POSITIVE_INFINITY : void 0),
                })),
              }),
              f = { data: {}, error: {}, isFetching: {}, isFetchingAny: !1 };
            p.values()
              .filter(l.isDefined)
              .forEach((e, t) => {
                let { data: n, error: r, isFetching: i } = y[t];
                (f.data[e] = n),
                  (f.error[e] = r),
                  (f.isFetching[e] = i),
                  i && (f.isFetchingAny = !0);
              });
            let m = (0, c.useRef)(f);
            return (m.current = h(m.current, f)), m.current;
          })({
            ...a,
            marketIds: T,
            blockNumber: e?.number,
            query: {
              ...a.query,
              enabled: null != e && a.query?.enabled,
              select: t ? (t) => t.accrueInterest(e?.timestamp) : void 0,
            },
          }),
          E = (function ({ users: e, query: t = {}, ...n }) {
            let r = (0, d.useConfig)(n),
              a = s(n),
              p = new Set(e),
              y = (0, u.h)({
                queries: Array.from(p, (e) => ({
                  ...t,
                  async queryFn({ queryKey: e }) {
                    let { user: t, chainId: n, ...a } = e[1];
                    if (!t) throw Error('user is required');
                    return (0, i.fetchUser)(t, r.getClient({ chainId: n }), { chainId: n, ...a });
                  },
                  queryKey: (function ({
                    user: e,
                    chainId: t,
                    blockTag: n,
                    blockNumber: r,
                    account: i,
                    stateOverride: a,
                  }) {
                    return [
                      'fetchUser',
                      {
                        user: e,
                        chainId: t,
                        blockTag: n,
                        blockNumber: r,
                        account: i,
                        stateOverride: a,
                      },
                    ];
                  })({ ...n, user: e, chainId: a }),
                  queryKeyHashFn: o.kq,
                  enabled: null != e && t.enabled,
                  structuralSharing: t.structuralSharing ?? h,
                  staleTime:
                    t.staleTime ?? (null != n.blockNumber ? Number.POSITIVE_INFINITY : void 0),
                })),
              }),
              f = { data: {}, error: {}, isFetching: {}, isFetchingAny: !1 };
            p.values()
              .filter(l.isDefined)
              .forEach((e, t) => {
                let { data: n, error: r, isFetching: i } = y[t];
                (f.data[e] = n),
                  (f.error[e] = r),
                  (f.isFetching[e] = i),
                  i && (f.isFetchingAny = !0);
              });
            let m = (0, c.useRef)(f);
            return (m.current = h(m.current, f)), m.current;
          })({
            ...a,
            blockNumber: e?.number,
            query: { ...a.query, enabled: null != e && a.query?.enabled },
          }),
          C = (function ({ tokens: e, query: t = {}, ...n }) {
            let r = (0, d.useConfig)(n),
              a = s(n),
              p = new Set(e),
              y = (0, u.h)({
                queries: Array.from(p, (e) => ({
                  ...t,
                  async queryFn({ queryKey: e }) {
                    let { token: t, chainId: n, ...a } = e[1];
                    if (!t) throw Error('token is required');
                    return (0, i.fetchToken)(t, r.getClient({ chainId: n }), { chainId: n, ...a });
                  },
                  queryKey: (function ({
                    token: e,
                    chainId: t,
                    blockTag: n,
                    blockNumber: r,
                    deployless: i,
                    account: a,
                    stateOverride: s,
                  }) {
                    return [
                      'fetchToken',
                      {
                        token: e,
                        chainId: t,
                        blockTag: n,
                        blockNumber: r,
                        deployless: i,
                        account: a,
                        stateOverride: s,
                      },
                    ];
                  })({ ...n, token: e, chainId: a }),
                  queryKeyHashFn: o.kq,
                  enabled: null != e && t.enabled,
                  structuralSharing: t.structuralSharing ?? h,
                  staleTime:
                    t.staleTime ?? (null != n.blockNumber ? Number.POSITIVE_INFINITY : void 0),
                })),
              }),
              f = { data: {}, error: {}, isFetching: {}, isFetchingAny: !1 };
            p.values()
              .filter(l.isDefined)
              .forEach((e, t) => {
                let { data: n, error: r, isFetching: i } = y[t];
                (f.data[e] = n),
                  (f.error[e] = r),
                  (f.isFetching[e] = i),
                  i && (f.isFetchingAny = !0);
              });
            let m = (0, c.useRef)(f);
            return (m.current = h(m.current, f)), m.current;
          })({
            ...a,
            blockNumber: e?.number,
            query: { ...a.query, enabled: null != e && a.query?.enabled },
          }),
          _ = (function ({ positions: e, query: t = {}, ...n }) {
            let r = (0, d.useConfig)(n),
              a = s(n),
              l = y(e, ({ user: e, marketId: t }) => `${e},${t}`),
              p = (0, u.h)({
                queries: l.map((e) => ({
                  ...t,
                  async queryFn({ queryKey: e }) {
                    let { user: t, marketId: n, chainId: a, ...s } = e[1];
                    if (!t) throw Error('user is required');
                    if (!n) throw Error('marketId is required');
                    return (0, i.fetchPosition)(t, n, r.getClient({ chainId: a }), {
                      chainId: a,
                      ...s,
                    });
                  },
                  queryKey: (function ({
                    user: e,
                    marketId: t,
                    chainId: n,
                    blockTag: r,
                    blockNumber: i,
                    account: a,
                    stateOverride: s,
                  }) {
                    return [
                      'fetchPosition',
                      {
                        user: e,
                        marketId: t,
                        chainId: n,
                        blockTag: r,
                        blockNumber: i,
                        account: a,
                        stateOverride: s,
                      },
                    ];
                  })({ ...n, ...e, chainId: a }),
                  queryKeyHashFn: o.kq,
                  enabled: null != e.user && null != e.marketId && t.enabled,
                  structuralSharing: t.structuralSharing ?? h,
                  staleTime:
                    t.staleTime ?? (null != n.blockNumber ? Number.POSITIVE_INFINITY : void 0),
                })),
              }),
              f = { data: {}, error: {}, isFetching: {}, isFetchingAny: !1 };
            l.forEach(({ user: e, marketId: t }, n) => {
              if (null == e || null == t) return;
              let { data: r, error: i, isFetching: a } = p[n];
              ((f.data[e] ??= {})[t] = r),
                ((f.error[e] ??= {})[t] = i),
                ((f.isFetching[e] ??= {})[t] = a),
                a && (f.isFetchingAny = !0);
            });
            let m = (0, c.useRef)(f);
            return (m.current = h(m.current, f)), m.current;
          })({
            ...a,
            blockNumber: e?.number,
            positions: (0, c.useMemo)(
              () =>
                Array.from(a.users).flatMap((e) =>
                  Array.from(T, (t) => ({ user: e, marketId: t }))
                ),
              [a.users, T]
            ),
            query: { ...a.query, enabled: null != e && a.query?.enabled },
          }),
          I = (function ({ holdings: e, query: t = {}, ...n }) {
            let r = (0, d.useConfig)(n),
              a = s(n),
              l = y(e, ({ user: e, token: t }) => `${e},${t}`),
              p = (0, u.h)({
                queries: l.map((e) => ({
                  ...t,
                  async queryFn({ queryKey: e }) {
                    let { user: t, token: n, chainId: a, ...s } = e[1];
                    if (!t) throw Error('user is required');
                    if (!n) throw Error('token is required');
                    return (0, i.fetchHolding)(t, n, r.getClient({ chainId: a }), {
                      chainId: a,
                      ...s,
                    });
                  },
                  queryKey: (function ({
                    user: e,
                    token: t,
                    chainId: n,
                    blockTag: r,
                    blockNumber: i,
                    deployless: a,
                    account: s,
                    stateOverride: o,
                  }) {
                    return [
                      'fetchHolding',
                      {
                        user: e,
                        token: t,
                        chainId: n,
                        blockTag: r,
                        blockNumber: i,
                        deployless: a,
                        account: s,
                        stateOverride: o,
                      },
                    ];
                  })({ ...n, ...e, chainId: a }),
                  queryKeyHashFn: o.kq,
                  enabled: null != e.user && null != e.token && t.enabled,
                  structuralSharing: t.structuralSharing ?? h,
                  staleTime:
                    t.staleTime ?? (null != n.blockNumber ? Number.POSITIVE_INFINITY : void 0),
                })),
              }),
              f = { data: {}, error: {}, isFetching: {}, isFetchingAny: !1 };
            l.forEach(({ user: e, token: t }, n) => {
              if (null == e || null == t) return;
              let { data: r, error: i, isFetching: a } = p[n];
              ((f.data[e] ??= {})[t] = r),
                ((f.error[e] ??= {})[t] = i),
                ((f.isFetching[e] ??= {})[t] = a),
                a && (f.isFetchingAny = !0);
            });
            let m = (0, c.useRef)(f);
            return (m.current = h(m.current, f)), m.current;
          })({
            ...a,
            blockNumber: e?.number,
            holdings: (0, c.useMemo)(
              () =>
                Array.from(a.users).flatMap((e) =>
                  Array.from(a.tokens, (t) => ({ user: e, token: t }))
                ),
              [a.users, a.tokens]
            ),
            query: { ...a.query, enabled: null != e && a.query?.enabled },
          }),
          S = (function ({ configs: e, query: t = {}, ...n }) {
            let r = (0, d.useConfig)(n),
              a = s(n),
              l = y(e, ({ vault: e, marketId: t }) => `${e},${t}`),
              p = (0, u.h)({
                queries: l.map((e) => ({
                  ...t,
                  async queryFn({ queryKey: e }) {
                    let { vault: t, marketId: n, chainId: a, ...s } = e[1];
                    if (!t) throw Error('vault is required');
                    if (!n) throw Error('marketId is required');
                    return (0, i.fetchVaultMarketConfig)(t, n, r.getClient({ chainId: a }), {
                      chainId: a,
                      ...s,
                    });
                  },
                  queryKey: (function ({
                    vault: e,
                    marketId: t,
                    chainId: n,
                    blockTag: r,
                    blockNumber: i,
                    account: a,
                    stateOverride: s,
                  }) {
                    return [
                      'fetchVaultMarketConfig',
                      {
                        vault: e,
                        marketId: t,
                        chainId: n,
                        blockTag: r,
                        blockNumber: i,
                        account: a,
                        stateOverride: s,
                      },
                    ];
                  })({ ...n, ...e, chainId: a }),
                  queryKeyHashFn: o.kq,
                  enabled: null != e.vault && null != e.marketId && t.enabled,
                  structuralSharing: t.structuralSharing ?? h,
                  staleTime:
                    t.staleTime ?? (null != n.blockNumber ? Number.POSITIVE_INFINITY : void 0),
                })),
              }),
              f = { data: {}, error: {}, isFetching: {}, isFetchingAny: !1 };
            l.forEach(({ vault: e, marketId: t }, n) => {
              if (null == e || null == t) return;
              let { data: r, error: i, isFetching: a } = p[n];
              ((f.data[e] ??= {})[t] = r),
                ((f.error[e] ??= {})[t] = i),
                ((f.isFetching[e] ??= {})[t] = a),
                a && (f.isFetchingAny = !0);
            });
            let m = (0, c.useRef)(f);
            return (m.current = h(m.current, f)), m.current;
          })({
            ...a,
            blockNumber: e?.number,
            configs: (0, c.useMemo)(
              () =>
                Array.from(a.vaults).flatMap((e) =>
                  Array.from(T, (t) => ({ vault: e, marketId: t }))
                ),
              [a.vaults, T]
            ),
            query: { ...a.query, enabled: null != e && a.query?.enabled },
          }),
          P = (function ({ vaultUsers: e, query: t = {}, ...n }) {
            let r = (0, d.useConfig)(n),
              a = s(n),
              l = y(e, ({ vault: e, user: t }) => `${e},${t}`),
              p = (0, u.h)({
                queries: l.map(({ vault: e, user: s }) => ({
                  ...t,
                  async queryFn({ queryKey: e }) {
                    let { vault: t, user: n, chainId: a, ...s } = e[1];
                    if (!t) throw Error('vault is required');
                    if (!n) throw Error('user is required');
                    return (0, i.fetchVaultUser)(t, n, r.getClient({ chainId: a }), {
                      chainId: a,
                      ...s,
                    });
                  },
                  queryKey: (function ({
                    vault: e,
                    user: t,
                    chainId: n,
                    blockTag: r,
                    blockNumber: i,
                    deployless: a,
                    account: s,
                    stateOverride: o,
                  }) {
                    return [
                      'fetchVaultUser',
                      {
                        vault: e,
                        user: t,
                        chainId: n,
                        blockTag: r,
                        blockNumber: i,
                        deployless: a,
                        account: s,
                        stateOverride: o,
                      },
                    ];
                  })({ ...n, vault: e, user: s, chainId: a }),
                  queryKeyHashFn: o.kq,
                  enabled: null != e && null != s && t.enabled,
                  structuralSharing: t.structuralSharing ?? h,
                  staleTime:
                    t.staleTime ?? (null != n.blockNumber ? Number.POSITIVE_INFINITY : void 0),
                })),
              }),
              f = { data: {}, error: {}, isFetching: {}, isFetchingAny: !1 };
            l.forEach(({ vault: e, user: t }, n) => {
              if (null == e || null == t) return;
              let { data: r, error: i, isFetching: a } = p[n];
              ((f.data[e] ??= {})[t] = r),
                ((f.error[e] ??= {})[t] = i),
                ((f.isFetching[e] ??= {})[t] = a),
                a && (f.isFetchingAny = !0);
            });
            let m = (0, c.useRef)(f);
            return (m.current = h(m.current, f)), m.current;
          })({
            ...a,
            blockNumber: e?.number,
            vaultUsers: (0, c.useMemo)(
              () =>
                Array.from(a.vaults).flatMap((e) =>
                  Array.from(a.users, (t) => ({ vault: e, user: t }))
                ),
              [a.vaults, a.users]
            ),
            query: { ...a.query, enabled: null != e && a.query?.enabled },
          }),
          O = (0, c.useMemo)(() => {
            if (null != e)
              return new f.SimulationState({
                chainId: g,
                block: e,
                global: { feeRecipient: w.data },
                markets: A.data,
                users: E.data,
                tokens: C.data,
                vaults: v.data,
                positions: _.data,
                holdings: I.data,
                vaultMarketConfigs: S.data,
                vaultUsers: P.data,
              });
          }, [g, e, w.data, A.data, E.data, C.data, v.data, _.data, I.data, S.data, P.data]),
          N = (0, c.useMemo)(
            () => ({
              global: { feeRecipient: w.error },
              markets: A.error,
              users: E.error,
              tokens: C.error,
              vaults: v.error,
              positions: _.error,
              holdings: I.error,
              vaultMarketConfigs: S.error,
              vaultUsers: P.error,
            }),
            [w.error, A.error, E.error, C.error, v.error, _.error, I.error, S.error, P.error]
          );
        return null == e
          ? { data: void 0, error: {}, isFetchingAny: !1, isFetching: {}, isPending: !0 }
          : {
              data: O,
              error: N,
              isFetchingAny:
                w.isFetching ||
                A.isFetchingAny ||
                E.isFetchingAny ||
                C.isFetchingAny ||
                v.isFetchingAny ||
                _.isFetchingAny ||
                I.isFetchingAny ||
                S.isFetchingAny ||
                P.isFetchingAny,
              isFetching: {
                global: { feeRecipient: w.isFetching },
                markets: A.isFetching,
                users: E.isFetching,
                tokens: C.isFetching,
                vaults: v.isFetching,
                positions: _.isFetching,
                holdings: I.isFetching,
                vaultMarketConfigs: S.isFetching,
                vaultUsers: P.isFetching,
              },
              isPending: !1,
            };
      }
    },
    7885: function (e, t, n) {
      'use strict';
      function r(e) {
        if (!Number.isSafeInteger(e) || e < 0) throw Error('positive integer expected, got ' + e);
      }
      function i(e, ...t) {
        if (
          !(
            e instanceof Uint8Array ||
            (ArrayBuffer.isView(e) && 'Uint8Array' === e.constructor.name)
          )
        )
          throw Error('Uint8Array expected');
        if (t.length > 0 && !t.includes(e.length))
          throw Error('Uint8Array expected of length ' + t + ', got length=' + e.length);
      }
      function a(e) {
        if ('function' != typeof e || 'function' != typeof e.create)
          throw Error('Hash should be wrapped by utils.wrapConstructor');
        r(e.outputLen), r(e.blockLen);
      }
      function s(e, t = !0) {
        if (e.destroyed) throw Error('Hash instance has been destroyed');
        if (t && e.finished) throw Error('Hash#digest() has already been called');
      }
      function o(e, t) {
        i(e);
        let n = t.outputLen;
        if (e.length < n) throw Error('digestInto() expects output buffer of length at least ' + n);
      }
      n.d(t, {
        $h: function () {
          return s;
        },
        eB: function () {
          return o;
        },
        gk: function () {
          return i;
        },
        k8: function () {
          return r;
        },
        z3: function () {
          return a;
        },
      });
    },
    43921: function (e, t, n) {
      'use strict';
      n.d(t, {
        kb: function () {
          return p;
        },
        l1: function () {
          return u;
        },
        eV: function () {
          return d;
        },
        GL: function () {
          return s;
        },
        iA: function () {
          return l;
        },
        O6: function () {
          return y;
        },
        np: function () {
          return o;
        },
        O0: function () {
          return c;
        },
        Jq: function () {
          return a;
        },
        hE: function () {
          return h;
        },
      });
      let r = 'object' == typeof globalThis && 'crypto' in globalThis ? globalThis.crypto : void 0;
      var i = n(7885);
      function a(e) {
        return new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4));
      }
      function s(e) {
        return new DataView(e.buffer, e.byteOffset, e.byteLength);
      }
      function o(e, t) {
        return (e << (32 - t)) | (e >>> t);
      }
      let l = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0];
      function u(e) {
        for (let n = 0; n < e.length; n++) {
          var t;
          e[n] =
            (((t = e[n]) << 24) & 4278190080) |
            ((t << 8) & 16711680) |
            ((t >>> 8) & 65280) |
            ((t >>> 24) & 255);
        }
      }
      function c(e) {
        return (
          'string' == typeof e &&
            (e = (function (e) {
              if ('string' != typeof e) throw Error('utf8ToBytes expected string, got ' + typeof e);
              return new Uint8Array(new TextEncoder().encode(e));
            })(e)),
          (0, i.gk)(e),
          e
        );
      }
      function d(...e) {
        let t = 0;
        for (let n = 0; n < e.length; n++) {
          let r = e[n];
          (0, i.gk)(r), (t += r.length);
        }
        let n = new Uint8Array(t);
        for (let t = 0, r = 0; t < e.length; t++) {
          let i = e[t];
          n.set(i, r), (r += i.length);
        }
        return n;
      }
      class p {
        clone() {
          return this._cloneInto();
        }
      }
      function h(e) {
        let t = (t) => e().update(c(t)).digest(),
          n = e();
        return (t.outputLen = n.outputLen), (t.blockLen = n.blockLen), (t.create = () => e()), t;
      }
      function y(e = 32) {
        if (r && 'function' == typeof r.getRandomValues)
          return r.getRandomValues(new Uint8Array(e));
        if (r && 'function' == typeof r.randomBytes) return r.randomBytes(e);
        throw Error('crypto.getRandomValues must be defined');
      }
    },
    17203: function (e, t, n) {
      'use strict';
      let r;
      n.d(t, {
        K: function () {
          return ep;
        },
      });
      var i = n(80827),
        a = n(18059);
      let s = (e) => (t, n, r) => {
          let i = r.subscribe;
          return (
            (r.subscribe = (e, t, n) => {
              let a = e;
              if (t) {
                let i = (null == n ? void 0 : n.equalityFn) || Object.is,
                  s = e(r.getState());
                (a = (n) => {
                  let r = e(n);
                  if (!i(s, r)) {
                    let e = s;
                    t((s = r), e);
                  }
                }),
                  (null == n ? void 0 : n.fireImmediately) && t(s, s);
              }
              return i(a);
            }),
            e(t, n, r)
          );
        },
        o = (e) => (t) => {
          try {
            let n = e(t);
            if (n instanceof Promise) return n;
            return {
              then: (e) => o(e)(n),
              catch(e) {
                return this;
              },
            };
          } catch (e) {
            return {
              then(e) {
                return this;
              },
              catch: (t) => o(t)(e),
            };
          }
        },
        l = (e, t) => (n, r, i) => {
          let a,
            s = {
              storage: (function (e, t) {
                let n;
                try {
                  n = e();
                } catch (e) {
                  return;
                }
                return {
                  getItem: (e) => {
                    var t;
                    let r = (e) => (null === e ? null : JSON.parse(e, void 0)),
                      i = null != (t = n.getItem(e)) ? t : null;
                    return i instanceof Promise ? i.then(r) : r(i);
                  },
                  setItem: (e, t) => n.setItem(e, JSON.stringify(t, void 0)),
                  removeItem: (e) => n.removeItem(e),
                };
              })(() => localStorage),
              partialize: (e) => e,
              version: 0,
              merge: (e, t) => ({ ...t, ...e }),
              ...t,
            },
            l = !1,
            u = new Set(),
            c = new Set(),
            d = s.storage;
          if (!d)
            return e(
              (...e) => {
                console.warn(
                  `[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`
                ),
                  n(...e);
              },
              r,
              i
            );
          let p = () => {
              let e = s.partialize({ ...r() });
              return d.setItem(s.name, { state: e, version: s.version });
            },
            h = i.setState;
          i.setState = (e, t) => {
            h(e, t), p();
          };
          let y = e(
            (...e) => {
              n(...e), p();
            },
            r,
            i
          );
          i.getInitialState = () => y;
          let f = () => {
            var e, t;
            if (!d) return;
            (l = !1),
              u.forEach((e) => {
                var t;
                return e(null != (t = r()) ? t : y);
              });
            let i =
              (null == (t = s.onRehydrateStorage)
                ? void 0
                : t.call(s, null != (e = r()) ? e : y)) || void 0;
            return o(d.getItem.bind(d))(s.name)
              .then((e) => {
                if (e) {
                  if ('number' != typeof e.version || e.version === s.version) return [!1, e.state];
                  if (s.migrate) return [!0, s.migrate(e.state, e.version)];
                  console.error(
                    "State loaded from storage couldn't be migrated since no migrate function was provided"
                  );
                }
                return [!1, void 0];
              })
              .then((e) => {
                var t;
                let [i, o] = e;
                if ((n((a = s.merge(o, null != (t = r()) ? t : y)), !0), i)) return p();
              })
              .then(() => {
                null == i || i(a, void 0), (a = r()), (l = !0), c.forEach((e) => e(a));
              })
              .catch((e) => {
                null == i || i(void 0, e);
              });
          };
          return (
            (i.persist = {
              setOptions: (e) => {
                (s = { ...s, ...e }), e.storage && (d = e.storage);
              },
              clearStorage: () => {
                null == d || d.removeItem(s.name);
              },
              getOptions: () => s,
              rehydrate: () => f(),
              hasHydrated: () => l,
              onHydrate: (e) => (
                u.add(e),
                () => {
                  u.delete(e);
                }
              ),
              onFinishHydration: (e) => (
                c.add(e),
                () => {
                  c.delete(e);
                }
              ),
            }),
            s.skipHydration || f(),
            a || y
          );
        },
        u = (e) => {
          let t;
          let n = new Set(),
            r = (e, r) => {
              let i = 'function' == typeof e ? e(t) : e;
              if (!Object.is(i, t)) {
                let e = t;
                (t = (null != r ? r : 'object' != typeof i || null === i)
                  ? i
                  : Object.assign({}, t, i)),
                  n.forEach((n) => n(t, e));
              }
            },
            i = () => t,
            a = {
              setState: r,
              getState: i,
              getInitialState: () => s,
              subscribe: (e) => (n.add(e), () => n.delete(e)),
            },
            s = (t = e(r, i, a));
          return a;
        },
        c = (e) => (e ? u(e) : u);
      var d = n(88496),
        p = n(66467);
      class h {
        constructor(e) {
          Object.defineProperty(this, 'uid', {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: e,
          }),
            Object.defineProperty(this, '_emitter', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: new p.v(),
            });
        }
        on(e, t) {
          this._emitter.on(e, t);
        }
        once(e, t) {
          this._emitter.once(e, t);
        }
        off(e, t) {
          this._emitter.off(e, t);
        }
        emit(e, ...t) {
          let n = t[0];
          this._emitter.emit(e, { uid: this.uid, ...n });
        }
        listenerCount(e) {
          return this._emitter.listenerCount(e);
        }
      }
      var y = n(34725),
        f = n(88396);
      let m = 256;
      var g = n(98291),
        b = n(37737),
        w = n(5333),
        v = n(83847),
        T = n(95705),
        A = n(87933),
        E = n(48894),
        C = n(25342),
        _ = n(9905),
        I = n(65036),
        S = n(33022),
        P = n(33873),
        O = n(75496),
        N = n(63230),
        x = n(28297),
        M = n(14886),
        k = n(96238),
        R = n(65110),
        D = n(25964),
        B = n(41592),
        U = n(28213),
        L = n(34814),
        F = n(58628),
        j = n(49786),
        q = n(48261),
        V = n(14537),
        $ = n(31507),
        z = n(49162),
        W = n(9281),
        H = n(23893),
        G = n(41291),
        K = n(31399),
        Q = n(43485),
        Y = n(18292),
        Z = n(28346),
        J = n(10423),
        X = n(60725),
        ee = n(3138),
        et = n(80487),
        en = n(77406);
      n(26651);
      var er = n(84196),
        ei = n(97059),
        ea = n(8924);
      function es(e, t) {
        let n, r, i, a, s, o, l;
        let u = e.isNewChainsStale ?? !0;
        return (0, Q.K)((e) => ({
          id: 'walletConnect',
          name: 'WalletConnect',
          type: es.type,
          async setup() {
            let e = await this.getProvider().catch(() => null);
            e &&
              (a || ((a = this.onConnect.bind(this)), e.on('connect', a)),
              o || ((o = this.onSessionDelete.bind(this)), e.on('session_delete', o)));
          },
          async connect({ ...e } = {}) {
            try {
              let t = ei.R.getCaipNetworks(),
                n = await this.getProvider();
              if (!n) throw new en.M();
              s || ((s = this.onDisplayUri), n.on('display_uri', s));
              let u = await this.isChainsStale();
              n.session && u && (await n.disconnect());
              let c = ea.OptionsController.state.universalProviderConfigOverride;
              if (!n.session || u) {
                let r = F.sQ.createNamespaces(t, c);
                await n.connect({
                  optionalNamespaces: r,
                  ...('pairingTopic' in e ? { pairingTopic: e.pairingTopic } : {}),
                }),
                  this.setRequestedChainsIds(t.map((e) => Number(e.id)));
              }
              let d = await this.getAccounts(),
                p = await this.getChainId(),
                h = n.session?.namespaces?.eip155?.chains,
                y = h?.some((e) => Number(e.split(':')[1]) === p),
                f = 1;
              y ? (f = p) : h?.[0] && (f = Number(h[0].split(':')[1])),
                s && (n.removeListener('display_uri', s), (s = void 0)),
                a && (n.removeListener('connect', a), (a = void 0)),
                r || ((r = this.onAccountsChanged.bind(this)), n.on('accountsChanged', r)),
                i || ((i = this.onChainChanged.bind(this)), n.on('chainChanged', i)),
                l || ((l = this.onDisconnect.bind(this)), n.on('disconnect', l)),
                o || ((o = this.onSessionDelete.bind(this)), n.on('session_delete', o));
              let m = c?.defaultChain;
              return n.setDefaultChain(m ?? `eip155:${f}`), { accounts: d, chainId: f };
            } catch (e) {
              if (/(user rejected|connection request reset)/i.test(e?.message)) throw new Y.ab(e);
              throw e;
            }
          },
          async disconnect() {
            let e = await this.getProvider();
            try {
              await e?.disconnect();
            } catch (e) {
              if (!/No matching key/i.test(e.message)) throw e;
            } finally {
              i && (e?.removeListener('chainChanged', i), (i = void 0)),
                l && (e?.removeListener('disconnect', l), (l = void 0)),
                a || ((a = this.onConnect.bind(this)), e?.on('connect', a)),
                r && (e?.removeListener('accountsChanged', r), (r = void 0)),
                o && (e?.removeListener('session_delete', o), (o = void 0)),
                this.setRequestedChainsIds([]);
            }
          },
          async getAccounts() {
            let e = await this.getProvider();
            if (!e?.session?.namespaces) return [];
            let t = e?.session?.namespaces[j.b.CHAIN.EVM]?.accounts;
            return t?.map((e) => e.split(':')[2]) ?? [];
          },
          async getProvider({ chainId: e } = {}) {
            n ||
              ((n = await t.getUniversalProvider()),
              n?.events.setMaxListeners(Number.POSITIVE_INFINITY));
            let r = $.M.getActiveNamespace(),
              i = t.getCaipNetwork()?.id;
            if (e && i !== e && r) {
              let e = $.M.getStoredActiveCaipNetworkId(),
                n = t.getCaipNetworks(r),
                i = n?.find((t) => t.id === e);
              i &&
                i.chainNamespace === j.b.CHAIN.EVM &&
                (await this.switchChain?.({ chainId: Number(i.id) }));
            }
            return n;
          },
          async getChainId() {
            let e = t.getCaipNetwork(j.b.CHAIN.EVM)?.id;
            if (e) return e;
            let n = await this.getProvider(),
              r = n.session?.namespaces[j.b.CHAIN.EVM]?.chains?.[0],
              i = ei.R.getCaipNetworks().find((e) => e.id === r);
            return i?.id;
          },
          async isAuthorized() {
            try {
              let [e, t] = await Promise.all([this.getAccounts(), this.getProvider()]);
              if (!e.length) return !1;
              if ((await this.isChainsStale()) && t.session)
                return await t.disconnect().catch(() => {}), !1;
              return !0;
            } catch {
              return !1;
            }
          },
          async switchChain({ addEthereumChainParameter: t, chainId: n }) {
            let r = await this.getProvider();
            if (!r) throw new en.M();
            let i = ei.R.getCaipNetworks().find((e) => e.id === n);
            if (!i) throw new Y.x3(new f.X4());
            try {
              await r.request({
                method: 'wallet_switchEthereumChain',
                params: [{ chainId: (0, er.eC)(n) }],
              }),
                i?.caipNetworkId && r.setDefaultChain(i?.caipNetworkId),
                e.emitter.emit('change', { chainId: Number(n) });
              let t = await this.getRequestedChainsIds();
              return this.setRequestedChainsIds([...t, n]), { ...i, id: i.id };
            } catch (e) {
              if (/(?:user rejected)/iu.test(e.message)) throw new Y.ab(e);
              try {
                let e;
                e = t?.blockExplorerUrls
                  ? t.blockExplorerUrls
                  : i.blockExplorers?.default.url
                    ? [i.blockExplorers?.default.url]
                    : [];
                let a = i.rpcUrls?.chainDefault?.http || [],
                  s = {
                    blockExplorerUrls: e,
                    chainId: (0, er.eC)(n),
                    chainName: i.name,
                    iconUrls: t?.iconUrls,
                    nativeCurrency: i.nativeCurrency,
                    rpcUrls: a,
                  };
                await r.request({ method: 'wallet_addEthereumChain', params: [s] });
                let o = await this.getRequestedChainsIds();
                return this.setRequestedChainsIds([...o, n]), { ...i, id: i.id };
              } catch (e) {
                throw new Y.ab(e);
              }
            }
          },
          onAccountsChanged(t) {
            0 === t.length
              ? this.onDisconnect()
              : e.emitter.emit('change', { accounts: t.map((e) => (0, Z.K)(e)) });
          },
          onChainChanged(t) {
            let n = Number(t);
            e.emitter.emit('change', { chainId: n });
          },
          onConnect(e) {
            this.setRequestedChainsIds(ei.R.getCaipNetworks().map((e) => Number(e.id)));
          },
          async onDisconnect(t) {
            this.setRequestedChainsIds([]), e.emitter.emit('disconnect');
            let n = await this.getProvider();
            r && (n.removeListener('accountsChanged', r), (r = void 0)),
              i && (n.removeListener('chainChanged', i), (i = void 0)),
              l && (n.removeListener('disconnect', l), (l = void 0)),
              o && (n.removeListener('session_delete', o), (o = void 0)),
              a || ((a = this.onConnect.bind(this)), n.on('connect', a));
          },
          onDisplayUri(t) {
            e.emitter.emit('message', { type: 'display_uri', data: t });
          },
          onSessionDelete() {
            this.onDisconnect();
          },
          getNamespaceChainsIds() {
            if (!n?.session?.namespaces) return [];
            let e = n?.session?.namespaces[j.b.CHAIN.EVM]?.accounts;
            return e?.map((e) => Number.parseInt(e.split(':')[1] ?? '')) ?? [];
          },
          async getRequestedChainsIds() {
            return [...new Set((await e.storage?.getItem(this.requestedChainsStorageKey)) ?? [])];
          },
          async isChainsStale() {
            if (!u) return !1;
            let t = e.chains.map((e) => e.id),
              n = this.getNamespaceChainsIds();
            if (n.length && !n.some((e) => t.includes(e))) return !1;
            let r = await this.getRequestedChainsIds();
            return !t.every((e) => r.includes(Number(e)));
          },
          async setRequestedChainsIds(t) {
            await e.storage?.setItem(this.requestedChainsStorageKey, t);
          },
          get requestedChainsStorageKey() {
            return `${this.id}.requestedChains`;
          },
        }));
      }
      es.type = 'walletConnect';
      var eo = n(94583),
        el = n(95759);
      let eu = (0, eo.sj)({ pendingTransactions: 0 }),
        ec = {
          state: eu,
          subscribeKey: (e, t) => (0, el.VW)(eu, e, t),
          increase(e) {
            eu[e] += 1;
          },
          decrease(e) {
            eu[e] -= 1;
          },
          reset(e) {
            eu[e] = 0;
          },
        },
        ed = { enable: !1, pollingInterval: 3e4 };
      class ep extends G.q {
        constructor(e) {
          let t = W.f.extendCaipNetworks(e.networks, {
            projectId: e.projectId,
            customNetworkImageUrls: {},
            customRpcUrls: e.customRpcUrls,
          });
          super({
            projectId: e.projectId,
            adapterType: j.b.ADAPTER_TYPES.WAGMI,
            namespace: j.b.CHAIN.EVM,
          }),
            (this.balancePromises = {}),
            (this.pendingTransactionsFilter = { ...ed, ...(e.pendingTransactionsFilter ?? {}) }),
            this.createConfig({ ...e, networks: t }),
            this.setupWatchers();
        }
        async getAccounts(e) {
          let t = this.getWagmiConnector(e.id);
          if (!t) return { accounts: [] };
          if (t.id === j.b.CONNECTOR_ID.AUTH) {
            let e = t.provider;
            if (!e.user) return { accounts: [] };
            let { address: n, accounts: r } = e.user;
            return Promise.resolve({
              accounts: (r || [{ address: n, type: 'eoa' }]).map((e) =>
                V.j.createAccount('eip155', e.address, e.type)
              ),
            });
          }
          let { addresses: n, address: r } = (0, i.D)(this.wagmiConfig);
          return Promise.resolve({
            accounts: (n || [r])?.map((e) => V.j.createAccount('eip155', e || '', 'eoa')),
          });
        }
        getWagmiConnector(e) {
          return this.wagmiConfig.connectors.find((t) => t.id === e);
        }
        createConfig(e) {
          this.wagmiChains = e.networks.filter((e) => e.chainNamespace === j.b.CHAIN.EVM);
          let t = {},
            n = [...(e.connectors ?? [])];
          this.wagmiChains.forEach((n) => {
            let r = e.transports?.[n.id],
              i = W.f.getCaipNetworkId(n);
            r
              ? (t[n.id] = W.f.extendWagmiTransports(n, e.projectId, r))
              : (t[n.id] = W.f.getViemTransport(n, e.projectId, e.customRpcUrls?.[i]));
          }),
            (this.wagmiConfig = (function (e) {
              let t;
              let {
                  multiInjectedProviderDiscovery: n = !0,
                  storage: i = (0, y.o6)({ storage: (0, y.ns)() }),
                  syncConnectedChain: o = !0,
                  ssr: u = !1,
                  ...p
                } = e,
                b =
                  'undefined' != typeof window && n
                    ? (function () {
                        let e = new Set(),
                          t = [],
                          n = () =>
                            (function (e) {
                              if ('undefined' == typeof window) return;
                              let t = (t) => e(t.detail);
                              return (
                                window.addEventListener('eip6963:announceProvider', t),
                                window.dispatchEvent(new CustomEvent('eip6963:requestProvider')),
                                () => window.removeEventListener('eip6963:announceProvider', t)
                              );
                            })((n) => {
                              t.some(({ info: e }) => e.uuid === n.info.uuid) ||
                                ((t = [...t, n]), e.forEach((e) => e(t, { added: [n] })));
                            }),
                          r = n();
                        return {
                          _listeners: () => e,
                          clear() {
                            e.forEach((e) => e([], { removed: [...t] })), (t = []);
                          },
                          destroy() {
                            this.clear(), e.clear(), r?.();
                          },
                          findProvider: ({ rdns: e }) => t.find((t) => t.info.rdns === e),
                          getProviders: () => t,
                          reset() {
                            this.clear(), r?.(), (r = n());
                          },
                          subscribe: (n, { emitImmediately: r } = {}) => (
                            e.add(n), r && n(t, { added: t }), () => e.delete(n)
                          ),
                        };
                      })()
                    : void 0,
                w = c(() => p.chains),
                v = c(() => {
                  let e = [],
                    t = new Set();
                  for (let n of p.connectors ?? []) {
                    let r = T(n);
                    if ((e.push(r), !u && r.rdns))
                      for (let e of 'string' == typeof r.rdns ? [r.rdns] : r.rdns) t.add(e);
                  }
                  if (!u && b)
                    for (let n of b.getProviders()) t.has(n.info.rdns) || e.push(T(A(n)));
                  return e;
                });
              function T(e) {
                let t = new h(
                    (function (e = 11) {
                      if (!r || m + e > 512) {
                        (r = ''), (m = 0);
                        for (let e = 0; e < 256; e++)
                          r += ((256 + 256 * Math.random()) | 0).toString(16).substring(1);
                      }
                      return r.substring(m, m++ + e);
                    })()
                  ),
                  n = {
                    ...e({
                      emitter: t,
                      chains: w.getState(),
                      storage: i,
                      transports: p.transports,
                    }),
                    emitter: t,
                    uid: t.uid,
                  };
                return t.on('connect', O), n.setup?.(), n;
              }
              function A(e) {
                let { info: t } = e,
                  n = e.provider;
                return (0, d.L)({ target: { ...t, id: t.rdns, provider: n } });
              }
              let E = new Map();
              function C() {
                return {
                  chainId: w.getState()[0].id,
                  connections: new Map(),
                  current: null,
                  status: 'disconnected',
                };
              }
              let _ = '0.0.0-canary-';
              t = g.i.startsWith(_)
                ? Number.parseInt(g.i.replace(_, ''))
                : Number.parseInt(g.i.split('.')[0] ?? '0');
              let I = c(
                s(
                  i
                    ? l(C, {
                        migrate(e, n) {
                          if (n === t) return e;
                          let r = C(),
                            i = S(e, r.chainId);
                          return { ...r, chainId: i };
                        },
                        name: 'store',
                        partialize: (e) => ({
                          connections: {
                            __type: 'Map',
                            value: Array.from(e.connections.entries()).map(([e, t]) => {
                              let { id: n, name: r, type: i, uid: a } = t.connector;
                              return [e, { ...t, connector: { id: n, name: r, type: i, uid: a } }];
                            }),
                          },
                          chainId: e.chainId,
                          current: e.current,
                        }),
                        merge(e, t) {
                          'object' == typeof e && e && 'status' in e && delete e.status;
                          let n = S(e, t.chainId);
                          return { ...t, ...e, chainId: n };
                        },
                        skipHydration: u,
                        storage: i,
                        version: t,
                      })
                    : C
                )
              );
              function S(e, t) {
                return e &&
                  'object' == typeof e &&
                  'chainId' in e &&
                  'number' == typeof e.chainId &&
                  w.getState().some((t) => t.id === e.chainId)
                  ? e.chainId
                  : t;
              }
              function P(e) {
                I.setState((t) => {
                  let n = t.connections.get(e.uid);
                  return n
                    ? {
                        ...t,
                        connections: new Map(t.connections).set(e.uid, {
                          accounts: e.accounts ?? n.accounts,
                          chainId: e.chainId ?? n.chainId,
                          connector: n.connector,
                        }),
                      }
                    : t;
                });
              }
              function O(e) {
                'connecting' !== I.getState().status &&
                  'reconnecting' !== I.getState().status &&
                  I.setState((t) => {
                    let n = v.getState().find((t) => t.uid === e.uid);
                    return n
                      ? (n.emitter.listenerCount('connect') && n.emitter.off('connect', P),
                        n.emitter.listenerCount('change') || n.emitter.on('change', P),
                        n.emitter.listenerCount('disconnect') || n.emitter.on('disconnect', N),
                        {
                          ...t,
                          connections: new Map(t.connections).set(e.uid, {
                            accounts: e.accounts,
                            chainId: e.chainId,
                            connector: n,
                          }),
                          current: e.uid,
                          status: 'connected',
                        })
                      : t;
                  });
              }
              function N(e) {
                I.setState((t) => {
                  let n = t.connections.get(e.uid);
                  if (n) {
                    let e = n.connector;
                    e.emitter.listenerCount('change') && n.connector.emitter.off('change', P),
                      e.emitter.listenerCount('disconnect') &&
                        n.connector.emitter.off('disconnect', N),
                      e.emitter.listenerCount('connect') || n.connector.emitter.on('connect', O);
                  }
                  if ((t.connections.delete(e.uid), 0 === t.connections.size))
                    return { ...t, connections: new Map(), current: null, status: 'disconnected' };
                  let r = t.connections.values().next().value;
                  return { ...t, connections: new Map(t.connections), current: r.connector.uid };
                });
              }
              return (
                I.setState(C()),
                o &&
                  I.subscribe(
                    ({ connections: e, current: t }) => (t ? e.get(t)?.chainId : void 0),
                    (e) => {
                      if (w.getState().some((t) => t.id === e))
                        return I.setState((t) => ({ ...t, chainId: e ?? t.chainId }));
                    }
                  ),
                b?.subscribe((e) => {
                  let t = new Set(),
                    n = new Set();
                  for (let e of v.getState())
                    if ((t.add(e.id), e.rdns))
                      for (let t of 'string' == typeof e.rdns ? [e.rdns] : e.rdns) n.add(t);
                  let r = [];
                  for (let i of e) {
                    if (n.has(i.info.rdns)) continue;
                    let e = T(A(i));
                    t.has(e.id) || r.push(e);
                  }
                  (!i || I.persist.hasHydrated()) && v.setState((e) => [...e, ...r], !0);
                }),
                {
                  get chains() {
                    return w.getState();
                  },
                  get connectors() {
                    return v.getState();
                  },
                  storage: i,
                  getClient: function (e = {}) {
                    let t;
                    let n = e.chainId ?? I.getState().chainId,
                      r = w.getState().find((e) => e.id === n);
                    if (e.chainId && !r) throw new f.X4();
                    {
                      let e = E.get(I.getState().chainId);
                      if (e && !r) return e;
                      if (!r) throw new f.X4();
                    }
                    {
                      let e = E.get(n);
                      if (e) return e;
                    }
                    if (p.client) t = p.client({ chain: r });
                    else {
                      let e = r.id,
                        n = w.getState().map((e) => e.id),
                        i = {};
                      for (let [t, r] of Object.entries(p))
                        if (
                          'chains' !== t &&
                          'client' !== t &&
                          'connectors' !== t &&
                          'transports' !== t
                        ) {
                          if ('object' == typeof r) {
                            if (e in r) i[t] = r[e];
                            else {
                              if (n.some((e) => e in r)) continue;
                              i[t] = r;
                            }
                          } else i[t] = r;
                        }
                      t = (0, a.e)({
                        ...i,
                        chain: r,
                        batch: i.batch ?? { multicall: !0 },
                        transport: (t) => p.transports[e]({ ...t, connectors: v }),
                      });
                    }
                    return E.set(n, t), t;
                  },
                  get state() {
                    return I.getState();
                  },
                  setState(e) {
                    let t;
                    t = 'function' == typeof e ? e(I.getState()) : e;
                    let n = C();
                    'object' != typeof t && (t = n),
                      Object.keys(n).some((e) => !(e in t)) && (t = n),
                      I.setState(t, !0);
                  },
                  subscribe: (e, t, n) =>
                    I.subscribe(e, t, n ? { ...n, fireImmediately: n.emitImmediately } : void 0),
                  _internal: {
                    mipd: b,
                    store: I,
                    ssr: !!u,
                    syncConnectedChain: o,
                    transports: p.transports,
                    chains: {
                      setState(e) {
                        let t = 'function' == typeof e ? e(w.getState()) : e;
                        if (0 !== t.length) return w.setState(t, !0);
                      },
                      subscribe: (e) => w.subscribe(e),
                    },
                    connectors: {
                      providerDetailToConnector: A,
                      setup: T,
                      setState: (e) => v.setState('function' == typeof e ? e(v.getState()) : e, !0),
                      subscribe: (e) => v.subscribe(e),
                    },
                    events: { change: P, connect: O, disconnect: N },
                  },
                }
              );
            })({ ...e, chains: this.wagmiChains, connectors: n, transports: t }));
        }
        setupWatchPendingTransactions() {
          if (!this.pendingTransactionsFilter.enable || this.unwatchPendingTransactions) return;
          this.unwatchPendingTransactions = (0, b.O)(this.wagmiConfig, {
            pollingInterval: this.pendingTransactionsFilter.pollingInterval,
            onError: () => {},
            onTransactions: () => {
              this.emit('pendingTransactions'), ec.increase('pendingTransactions');
            },
          });
          let e = ec.subscribeKey('pendingTransactions', (t) => {
            t >= j.b.LIMITS.PENDING_TRANSACTIONS && (this.unwatchPendingTransactions?.(), e());
          });
        }
        setupWatchers() {
          (0, w.u)(this.wagmiConfig, {
            onChange: (e, t) => {
              'disconnected' === e.status && t.address && this.emit('disconnect'),
                'connected' === e.status &&
                  ((e.address !== t?.address || 'connected' !== t.status) &&
                    (this.setupWatchPendingTransactions(),
                    this.emit('accountChanged', { address: e.address, chainId: e.chainId })),
                  e.chainId !== t?.chainId &&
                    this.emit('switchNetwork', { address: e.address, chainId: e.chainId }));
            },
          });
        }
        async addThirdPartyConnectors(e) {
          let t = [];
          if (!1 !== e.enableCoinbase)
            try {
              let { coinbaseWallet: r } = await n.e(5061).then(n.bind(n, 85061));
              r &&
                t.push(
                  r({
                    version: '4',
                    appName: e.metadata?.name ?? 'Unknown',
                    appLogoUrl: e.metadata?.icons[0] ?? 'Unknown',
                    preference: e.coinbasePreference ?? 'all',
                  })
                );
            } catch (e) {
              console.error('Failed to import Coinbase Wallet SDK:', e);
            }
          t.forEach((e) => {
            let t = this.wagmiConfig._internal.connectors.setup(e);
            this.wagmiConfig._internal.connectors.setState((e) => [...e, t]);
          });
        }
        addWagmiConnectors(e, t) {
          let n = [];
          !1 !== e.enableWalletConnect && n.push(es(e, t)),
            !1 !== e.enableInjected && n.push((0, d.L)({ shimDisconnect: !0 }));
          let r = e.features?.email === void 0 ? z.bq.DEFAULT_FEATURES.email : e.features?.email,
            i = e.features?.socials
              ? e.features?.socials?.length > 0
              : z.bq.DEFAULT_FEATURES.socials;
          (r || i) &&
            n.push(
              (function (e) {
                let t,
                  n,
                  r = [];
                function i(e) {
                  return q.p.parseEvmChainId(e) || 1;
                }
                async function a(n = {}) {
                  let a =
                      (t ||
                        (t = et.D.getInstance({
                          projectId: e.options.projectId,
                          enableLogger: e.options.enableAuthLogger,
                          onTimeout: () => {
                            J.AlertController.open(ee.j.ALERT_ERRORS.SOCIALS_TIMEOUT, 'error');
                          },
                        })),
                      t),
                    s = n.chainId;
                  if (n.isReconnecting) {
                    let t = q.p.parseEvmChainId(a.getLastUsedChainId() || ''),
                      n = e.chains?.[0].id;
                    if (!(s = t || n)) throw Error('ChainId not found in provider');
                  }
                  let o = X.AccountController.state.preferredAccountTypes?.eip155,
                    {
                      address: l,
                      chainId: u,
                      accounts: c,
                    } = await a.connect({ chainId: s, preferredAccountType: o });
                  r = c?.map((e) => e.address) || [l];
                  let d = i(u);
                  return { accounts: r, account: l, chainId: d, chain: { id: d, unsuported: !1 } };
                }
                return (0, Q.K)((t) => ({
                  id: j.b.CONNECTOR_ID.AUTH,
                  name: j.b.CONNECTOR_NAMES.AUTH,
                  type: 'AUTH',
                  chain: j.b.CHAIN.EVM,
                  async connect(e = {}) {
                    if (n) return n;
                    n ||
                      (n = new Promise((t) => {
                        t(a(e));
                      }));
                    let t = await n;
                    return (n = void 0), t;
                  },
                  async disconnect() {
                    let e = await this.getProvider();
                    await e.disconnect();
                  },
                  getAccounts: () =>
                    r?.length
                      ? (t.emitter.emit('change', { accounts: r }), Promise.resolve(r))
                      : Promise.resolve([]),
                  async getProvider() {
                    return (
                      this.provider ||
                        (this.provider = et.D.getInstance({
                          projectId: e.options.projectId,
                          enableLogger: e.options.enableAuthLogger,
                          onTimeout: () => {
                            J.AlertController.open(ee.j.ALERT_ERRORS.SOCIALS_TIMEOUT, 'error');
                          },
                        })),
                      Promise.resolve(this.provider)
                    );
                  },
                  async getChainId() {
                    let e = await this.getProvider(),
                      { chainId: t } = await e.getChainId();
                    return i(t);
                  },
                  async isAuthorized() {
                    return Promise.resolve((await this.getProvider()).getLoginEmailUsed());
                  },
                  async switchChain({ chainId: e }) {
                    try {
                      let n = t.chains.find((t) => t.id === e);
                      if (!n) throw new Y.x3(Error('chain not found on connector.'));
                      let i = await this.getProvider(),
                        a = X.AccountController.state.preferredAccountTypes?.eip155,
                        s = await i.connect({ chainId: e, preferredAccountType: a });
                      return (
                        (r = s?.accounts?.map((e) => e.address) || [s.address]),
                        t.emitter.emit('change', { chainId: Number(e), accounts: r }),
                        n
                      );
                    } catch (e) {
                      if (e instanceof Error) throw new Y.x3(e);
                      throw e;
                    }
                  },
                  onAccountsChanged(e) {
                    0 === e.length
                      ? this.onDisconnect()
                      : t.emitter.emit('change', { accounts: e.map(Z.K) });
                  },
                  onChainChanged(e) {
                    let n = Number(e);
                    t.emitter.emit('change', { chainId: n });
                  },
                  async onDisconnect(e) {
                    let t = await this.getProvider();
                    await t.disconnect();
                  },
                }));
              })({
                chains: this.wagmiChains,
                options: { projectId: e.projectId, enableAuthLogger: e.enableAuthLogger },
              })
            ),
            n.forEach((e) => {
              let t = this.wagmiConfig._internal.connectors.setup(e);
              this.wagmiConfig._internal.connectors.setState((e) => [...e, t]);
            });
        }
        async signMessage(e) {
          try {
            return {
              signature: await (0, v.l)(this.wagmiConfig, {
                message: e.message,
                account: e.address,
              }),
            };
          } catch (e) {
            throw Error('WagmiAdapter:signMessage - Sign message failed');
          }
        }
        async sendTransaction(e) {
          let { chainId: t } = (0, i.D)(this.wagmiConfig),
            n = {
              account: e.address,
              to: e.to,
              value: e.value,
              gas: e.gas,
              gasPrice: e.gasPrice,
              data: e.data,
              chainId: t,
              type: 'legacy',
              parameters: ['nonce'],
            };
          await (0, T.Z)(this.wagmiConfig, n);
          let r = await (0, A.T)(this.wagmiConfig, n);
          return await (0, E.e)(this.wagmiConfig, { hash: r, timeout: 25e3 }), { hash: r };
        }
        async writeContract(e) {
          let { caipNetwork: t, ...n } = e,
            r = Number(q.p.caipNetworkIdToNumber(t.caipNetworkId));
          return {
            hash: await (0, C.n)(this.wagmiConfig, {
              chain: this.wagmiChains?.[r],
              chainId: r,
              address: n.tokenAddress,
              account: n.fromAddress,
              abi: n.abi,
              functionName: n.method,
              args: n.args,
              __mode: 'prepared',
            }),
          };
        }
        async getEnsAddress(e) {
          let { name: t, caipNetwork: n } = e;
          try {
            if (!this.wagmiConfig)
              throw Error(
                'networkControllerClient:getApprovedCaipNetworksData - wagmiConfig is undefined'
              );
            let e = !1,
              r = !1;
            return (
              (t?.endsWith(j.b.WC_NAME_SUFFIX_LEGACY) || t?.endsWith(j.b.WC_NAME_SUFFIX)) &&
                (r = (await F.sQ.resolveReownName(t)) || !1),
              1 === n.id &&
                (e = await (0, _.O)(this.wagmiConfig, { name: (0, L.F)(t), chainId: n.id })),
              { address: e || r || !1 }
            );
          } catch {
            return { address: !1 };
          }
        }
        async estimateGas(e) {
          try {
            return {
              gas: await (0, I.Q)(this.wagmiConfig, {
                account: e.address,
                to: e.to,
                data: e.data,
                type: 'legacy',
              }),
            };
          } catch (e) {
            throw Error('WagmiAdapter:estimateGas - error estimating gas');
          }
        }
        parseUnits(e) {
          return (0, B.v)(e.value, e.decimals);
        }
        formatUnits(e) {
          return (0, U.b)(e.value, e.decimals);
        }
        async addWagmiConnector(e, t) {
          if (e.id === j.b.CONNECTOR_ID.AUTH || e.id === j.b.CONNECTOR_ID.WALLET_CONNECT) return;
          let n = await e.getProvider().catch(() => void 0);
          this.addConnector({
            id: e.id,
            explorerId: H.C.ConnectorExplorerIds[e.id],
            imageUrl: t?.connectorImages?.[e.id] ?? e.icon,
            name: H.C.ConnectorNamesMap[e.id] ?? e.name,
            imageId: H.C.ConnectorImageIds[e.id],
            type: H.C.ConnectorTypesMap[e.type] ?? 'EXTERNAL',
            info: e.id === j.b.CONNECTOR_ID.INJECTED ? void 0 : { rdns: e.id },
            provider: n,
            chain: this.namespace,
            chains: [],
          });
        }
        async syncConnectors(e, t) {
          (0, S.f)(this.wagmiConfig, {
            onChange: (t) => t.forEach((t) => this.addWagmiConnector(t, e)),
          }),
            await Promise.all(this.wagmiConfig.connectors.map((t) => this.addWagmiConnector(t, e))),
            this.addWagmiConnectors(e, t),
            await this.addThirdPartyConnectors(e);
        }
        async syncConnection(e) {
          let { id: t } = e,
            n = (0, P.E)(this.wagmiConfig).find((e) => e.connector.id === t),
            r = this.getWagmiConnector(t),
            i = await r?.getProvider();
          return {
            chainId: Number(n?.chainId),
            address: n?.accounts[0],
            provider: i,
            type: n?.connector.type,
            id: n?.connector.id,
          };
        }
        async connectWalletConnect(e) {
          let t = this.getWalletConnectConnector();
          await t.authenticate();
          let n = this.getWagmiConnector('walletConnect');
          if (!n) throw Error('UniversalAdapter:connectWalletConnect - connector not found');
          let r = await (0, O.$)(this.wagmiConfig, {
            connector: n,
            chainId: e ? Number(e) : void 0,
          });
          return (
            r.chainId !== Number(e) && (await (0, N.c)(this.wagmiConfig, { chainId: r.chainId })),
            { clientId: await t.provider.client.core.crypto.getClientId() }
          );
        }
        async connect(e) {
          let { id: t, provider: n, type: r, info: i, chainId: a } = e,
            s = this.getWagmiConnector(t);
          if (!s)
            throw Error('connectionControllerClient:connectExternal - connector is undefined');
          if (
            (n &&
              i &&
              s.id === j.b.CONNECTOR_ID.EIP6963 &&
              s.setEip6963Wallet?.({ provider: n, info: i }),
            s.uid === this.wagmiConfig?.state?.current)
          ) {
            let e = this.wagmiConfig.state?.connections?.get(s.uid);
            if (e)
              return { address: e?.accounts[0], chainId: e?.chainId, provider: n, type: r, id: t };
          }
          let o = await (0, O.$)(this.wagmiConfig, {
            connector: s,
            chainId: a ? Number(a) : void 0,
          });
          return { address: o.accounts[0], chainId: o.chainId, provider: n, type: r, id: t };
        }
        async reconnect(e) {
          let { id: t } = e,
            n = this.getWagmiConnector(t);
          if (!n)
            throw Error('connectionControllerClient:connectExternal - connector is undefined');
          await (0, x.G)(this.wagmiConfig, { connectors: [n] });
        }
        async getBalance(e) {
          let t = e.address,
            n = this.getCaipNetworks().find((t) => t.id === e.chainId);
          if (!t) return Promise.resolve({ balance: '0.00', symbol: 'ETH' });
          if (n && this.wagmiConfig) {
            let t = `${n.caipNetworkId}:${e.address}`,
              r = this.balancePromises[t];
            if (r) return r;
            let i = $.M.getNativeBalanceCacheForCaipAddress(t);
            return i
              ? { balance: i.balance, symbol: i.symbol }
              : ((this.balancePromises[t] = new Promise(async (r) => {
                  try {
                    let i = Number(e.chainId),
                      a = await (0, M.s)(this.wagmiConfig, {
                        address: e.address,
                        chainId: i,
                        token: e.tokens?.[n.caipNetworkId]?.address,
                      });
                    $.M.updateNativeBalanceCache({
                      caipAddress: t,
                      balance: a.formatted,
                      symbol: a.symbol,
                      timestamp: Date.now(),
                    }),
                      r({ balance: a.formatted, symbol: a.symbol });
                  } catch (e) {
                    console.warn('Appkit:WagmiAdapter:getBalance - Error getting balance', e),
                      r({ balance: '0.00', symbol: 'ETH' });
                  }
                }).finally(() => {
                  delete this.balancePromises[t];
                })),
                this.balancePromises[t] || { balance: '0.00', symbol: 'ETH' });
          }
          return { balance: '', symbol: '' };
        }
        async getProfile(e) {
          let t = e.chainId,
            n = await (0, k.w)(this.wagmiConfig, { address: e.address, chainId: t });
          if (n) {
            let e = await (0, R.r)(this.wagmiConfig, { name: n, chainId: t });
            return { profileName: n, profileImage: e ?? void 0 };
          }
          return { profileName: void 0, profileImage: void 0 };
        }
        getWalletConnectProvider() {
          return this.getWagmiConnector('walletConnect')?.provider;
        }
        async disconnect() {
          let e = (0, P.E)(this.wagmiConfig);
          await Promise.all(
            e.map(async (e) => {
              let t = this.getWagmiConnector(e.connector.id);
              t && (await (0, D.z)(this.wagmiConfig, { connector: t }));
            })
          );
        }
        async switchNetwork(e) {
          await (0, N.c)(this.wagmiConfig, { chainId: e.caipNetwork.id }),
            await super.switchNetwork(e);
        }
        async getCapabilities(e) {
          if (!this.wagmiConfig)
            throw Error('connectionControllerClient:getCapabilities - wagmiConfig is undefined');
          let t = (0, P.E)(this.wagmiConfig)[0],
            n = t ? this.getWagmiConnector(t.connector.id) : null;
          if (!n)
            throw Error('connectionControllerClient:getCapabilities - connector is undefined');
          let r = await n.getProvider();
          if (!r) throw Error('connectionControllerClient:getCapabilities - provider is undefined');
          let i = r.session?.sessionProperties?.capabilities;
          if (i) {
            let t = (function (e) {
              try {
                return JSON.parse(e);
              } catch (e) {
                throw Error('Error parsing wallet capabilities');
              }
            })(i)[e];
            if (t) return t;
          }
          return await r.request({ method: 'wallet_getCapabilities', params: [e] });
        }
        async grantPermissions(e) {
          if (!this.wagmiConfig)
            throw Error('connectionControllerClient:grantPermissions - wagmiConfig is undefined');
          let t = (0, P.E)(this.wagmiConfig)[0],
            n = t ? this.getWagmiConnector(t.connector.id) : null;
          if (!n)
            throw Error('connectionControllerClient:grantPermissions - connector is undefined');
          let r = await n.getProvider();
          if (!r)
            throw Error('connectionControllerClient:grantPermissions - provider is undefined');
          return r.request({ method: 'wallet_grantPermissions', params: e });
        }
        async revokePermissions(e) {
          if (!this.wagmiConfig)
            throw Error('connectionControllerClient:revokePermissions - wagmiConfig is undefined');
          let t = (0, P.E)(this.wagmiConfig)[0],
            n = t ? this.getWagmiConnector(t.connector.id) : null;
          if (!n)
            throw Error('connectionControllerClient:revokePermissions - connector is undefined');
          let r = await n.getProvider();
          if (!r)
            throw Error('connectionControllerClient:revokePermissions - provider is undefined');
          return r.request({ method: 'wallet_revokePermissions', params: e });
        }
        async walletGetAssets(e) {
          if (!this.wagmiConfig)
            throw Error('connectionControllerClient:walletGetAssets - wagmiConfig is undefined');
          let t = (0, P.E)(this.wagmiConfig)[0],
            n = t ? this.getWagmiConnector(t.connector.id) : null;
          if (!n)
            throw Error('connectionControllerClient:walletGetAssets - connector is undefined');
          let r = await n.getProvider();
          if (!r) throw Error('connectionControllerClient:walletGetAssets - provider is undefined');
          return r.request({ method: 'wallet_getAssets', params: [e] });
        }
        setUniversalProvider(e) {
          this.addConnector(
            new K.z({ provider: e, caipNetworks: this.getCaipNetworks(), namespace: 'eip155' })
          );
        }
      }
    },
    49786: function (e, t, n) {
      'use strict';
      n.d(t, {
        b: function () {
          return r;
        },
      });
      let r = {
        WC_NAME_SUFFIX: '.reown.id',
        WC_NAME_SUFFIX_LEGACY: '.wcn.id',
        BLOCKCHAIN_API_RPC_URL: 'https://rpc.walletconnect.org',
        PULSE_API_URL: 'https://pulse.walletconnect.org',
        W3M_API_URL: 'https://api.web3modal.org',
        CONNECTOR_ID: {
          WALLET_CONNECT: 'walletConnect',
          INJECTED: 'injected',
          WALLET_STANDARD: 'announced',
          COINBASE: 'coinbaseWallet',
          COINBASE_SDK: 'coinbaseWalletSDK',
          SAFE: 'safe',
          LEDGER: 'ledger',
          OKX: 'okx',
          EIP6963: 'eip6963',
          AUTH: 'ID_AUTH',
        },
        CONNECTOR_NAMES: { AUTH: 'Auth' },
        AUTH_CONNECTOR_SUPPORTED_CHAINS: ['eip155', 'solana'],
        LIMITS: { PENDING_TRANSACTIONS: 99 },
        CHAIN: { EVM: 'eip155', SOLANA: 'solana', POLKADOT: 'polkadot', BITCOIN: 'bip122' },
        CHAIN_NAME_MAP: {
          eip155: 'EVM Networks',
          solana: 'Solana',
          polkadot: 'Polkadot',
          bip122: 'Bitcoin',
        },
        ADAPTER_TYPES: {
          BITCOIN: 'bitcoin',
          SOLANA: 'solana',
          WAGMI: 'wagmi',
          ETHERS: 'ethers',
          ETHERS5: 'ethers5',
        },
        USDT_CONTRACT_ADDRESSES: [
          '0xdac17f958d2ee523a2206206994597c13d831ec7',
          '0xc2132d05d31c914a87c6611c10748aeb04b58e8f',
          '0x9702230a8ea53601f5cd2dc00fdbc13d4df4a8c7',
          '0x919C1c267BC06a7039e03fcc2eF738525769109c',
          '0x48065fbBE25f71C9282ddf5e1cD6D6A887483D5e',
          '0x55d398326f99059fF775485246999027B3197955',
          '0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9',
        ],
        HTTP_STATUS_CODES: { SERVICE_UNAVAILABLE: 503, FORBIDDEN: 403 },
        UNSUPPORTED_NETWORK_NAME: 'Unknown Network',
      };
    },
    70871: function (e, t, n) {
      'use strict';
      n.d(t, {
        E: function () {
          return u;
        },
      });
      var r = n(54476),
        i = n(47971),
        a = n(17339),
        s = n(30401);
      r.extend(a), r.extend(s);
      let o = {
          ...i,
          name: 'en-web3-modal',
          relativeTime: {
            future: 'in %s',
            past: '%s ago',
            s: '%d sec',
            m: '1 min',
            mm: '%d min',
            h: '1 hr',
            hh: '%d hrs',
            d: '1 d',
            dd: '%d d',
            M: '1 mo',
            MM: '%d mo',
            y: '1 yr',
            yy: '%d yr',
          },
        },
        l = [
          'January',
          'February',
          'March',
          'April',
          'May',
          'June',
          'July',
          'August',
          'September',
          'October',
          'November',
          'December',
        ];
      r.locale('en-web3-modal', o);
      let u = {
        getMonthNameByIndex: (e) => l[e],
        getYear: (e = new Date().toISOString()) => r(e).year(),
        getRelativeDateFromNow: (e) => r(e).locale('en-web3-modal').fromNow(!0),
        formatDate: (e, t = 'DD MMM') => r(e).format(t),
      };
    },
    48261: function (e, t, n) {
      'use strict';
      n.d(t, {
        p: function () {
          return r;
        },
      });
      let r = {
        caipNetworkIdToNumber: (e) => (e ? Number(e.split(':')[1]) : void 0),
        parseEvmChainId(e) {
          return 'string' == typeof e ? this.caipNetworkIdToNumber(e) : e;
        },
        getNetworksByNamespace: (e, t) => e?.filter((e) => e.chainNamespace === t) || [],
        getFirstNetworkByNamespace(e, t) {
          return this.getNetworksByNamespace(e, t)[0];
        },
      };
    },
    91709: function (e, t, n) {
      'use strict';
      n.d(t, {
        C: function () {
          return y;
        },
      });
      var r = '[big.js] ',
        i = r + 'Invalid ',
        a = i + 'decimal places',
        s = i + 'rounding mode',
        o = r + 'Division by zero',
        l = {},
        u = void 0,
        c = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
      function d(e, t, n, r) {
        var i = e.c;
        if ((n === u && (n = e.constructor.RM), 0 !== n && 1 !== n && 2 !== n && 3 !== n))
          throw Error(s);
        if (t < 1)
          (r =
            (3 === n && (r || !!i[0])) ||
            (0 === t &&
              ((1 === n && i[0] >= 5) ||
                (2 === n && (i[0] > 5 || (5 === i[0] && (r || i[1] !== u))))))),
            (i.length = 1),
            r ? ((e.e = e.e - t + 1), (i[0] = 1)) : (i[0] = e.e = 0);
        else if (t < i.length) {
          if (
            ((r =
              (1 === n && i[t] >= 5) ||
              (2 === n && (i[t] > 5 || (5 === i[t] && (r || i[t + 1] !== u || 1 & i[t - 1])))) ||
              (3 === n && (r || !!i[0]))),
            (i.length = t),
            r)
          ) {
            for (; ++i[--t] > 9; )
              if (((i[t] = 0), 0 === t)) {
                ++e.e, i.unshift(1);
                break;
              }
          }
          for (t = i.length; !i[--t]; ) i.pop();
        }
        return e;
      }
      function p(e, t, n) {
        var r = e.e,
          i = e.c.join(''),
          a = i.length;
        if (t) i = i.charAt(0) + (a > 1 ? '.' + i.slice(1) : '') + (r < 0 ? 'e' : 'e+') + r;
        else if (r < 0) {
          for (; ++r; ) i = '0' + i;
          i = '0.' + i;
        } else if (r > 0) {
          if (++r > a) for (r -= a; r--; ) i += '0';
          else r < a && (i = i.slice(0, r) + '.' + i.slice(r));
        } else a > 1 && (i = i.charAt(0) + '.' + i.slice(1));
        return e.s < 0 && n ? '-' + i : i;
      }
      (l.abs = function () {
        var e = new this.constructor(this);
        return (e.s = 1), e;
      }),
        (l.cmp = function (e) {
          var t,
            n = this.c,
            r = (e = new this.constructor(e)).c,
            i = this.s,
            a = e.s,
            s = this.e,
            o = e.e;
          if (!n[0] || !r[0]) return n[0] ? i : r[0] ? -a : 0;
          if (i != a) return i;
          if (((t = i < 0), s != o)) return (s > o) ^ t ? 1 : -1;
          for (i = -1, a = (s = n.length) < (o = r.length) ? s : o; ++i < a; )
            if (n[i] != r[i]) return (n[i] > r[i]) ^ t ? 1 : -1;
          return s == o ? 0 : (s > o) ^ t ? 1 : -1;
        }),
        (l.div = function (e) {
          var t = this.constructor,
            n = this.c,
            r = (e = new t(e)).c,
            i = this.s == e.s ? 1 : -1,
            s = t.DP;
          if (s !== ~~s || s < 0 || s > 1e6) throw Error(a);
          if (!r[0]) throw Error(o);
          if (!n[0]) return (e.s = i), (e.c = [(e.e = 0)]), e;
          var l,
            c,
            p,
            h,
            y,
            f = r.slice(),
            m = (l = r.length),
            g = n.length,
            b = n.slice(0, l),
            w = b.length,
            v = e,
            T = (v.c = []),
            A = 0,
            E = s + (v.e = this.e - e.e) + 1;
          for (v.s = i, i = E < 0 ? 0 : E, f.unshift(0); w++ < l; ) b.push(0);
          do {
            for (p = 0; p < 10; p++) {
              if (l != (w = b.length)) h = l > w ? 1 : -1;
              else
                for (y = -1, h = 0; ++y < l; )
                  if (r[y] != b[y]) {
                    h = r[y] > b[y] ? 1 : -1;
                    break;
                  }
              if (h < 0) {
                for (c = w == l ? r : f; w; ) {
                  if (b[--w] < c[w]) {
                    for (y = w; y && !b[--y]; ) b[y] = 9;
                    --b[y], (b[w] += 10);
                  }
                  b[w] -= c[w];
                }
                for (; !b[0]; ) b.shift();
              } else break;
            }
            (T[A++] = h ? p : ++p), b[0] && h ? (b[w] = n[m] || 0) : (b = [n[m]]);
          } while ((m++ < g || b[0] !== u) && i--);
          return !T[0] && 1 != A && (T.shift(), v.e--, E--), A > E && d(v, E, t.RM, b[0] !== u), v;
        }),
        (l.eq = function (e) {
          return 0 === this.cmp(e);
        }),
        (l.gt = function (e) {
          return this.cmp(e) > 0;
        }),
        (l.gte = function (e) {
          return this.cmp(e) > -1;
        }),
        (l.lt = function (e) {
          return 0 > this.cmp(e);
        }),
        (l.lte = function (e) {
          return 1 > this.cmp(e);
        }),
        (l.minus = l.sub =
          function (e) {
            var t,
              n,
              r,
              i,
              a = this.constructor,
              s = this.s,
              o = (e = new a(e)).s;
            if (s != o) return (e.s = -o), this.plus(e);
            var l = this.c.slice(),
              u = this.e,
              c = e.c,
              d = e.e;
            if (!l[0] || !c[0]) return c[0] ? (e.s = -o) : l[0] ? (e = new a(this)) : (e.s = 1), e;
            if ((s = u - d)) {
              for (
                (i = s < 0) ? ((s = -s), (r = l)) : ((d = u), (r = c)), r.reverse(), o = s;
                o--;

              )
                r.push(0);
              r.reverse();
            } else
              for (n = ((i = l.length < c.length) ? l : c).length, s = o = 0; o < n; o++)
                if (l[o] != c[o]) {
                  i = l[o] < c[o];
                  break;
                }
            if (
              (i && ((r = l), (l = c), (c = r), (e.s = -e.s)),
              (o = (n = c.length) - (t = l.length)) > 0)
            )
              for (; o--; ) l[t++] = 0;
            for (o = t; n > s; ) {
              if (l[--n] < c[n]) {
                for (t = n; t && !l[--t]; ) l[t] = 9;
                --l[t], (l[n] += 10);
              }
              l[n] -= c[n];
            }
            for (; 0 === l[--o]; ) l.pop();
            for (; 0 === l[0]; ) l.shift(), --d;
            return l[0] || ((e.s = 1), (l = [(d = 0)])), (e.c = l), (e.e = d), e;
          }),
        (l.mod = function (e) {
          var t,
            n = this,
            r = n.constructor,
            i = n.s,
            a = (e = new r(e)).s;
          if (!e.c[0]) throw Error(o);
          return ((n.s = e.s = 1), (t = 1 == e.cmp(n)), (n.s = i), (e.s = a), t)
            ? new r(n)
            : ((i = r.DP),
              (a = r.RM),
              (r.DP = r.RM = 0),
              (n = n.div(e)),
              (r.DP = i),
              (r.RM = a),
              this.minus(n.times(e)));
        }),
        (l.neg = function () {
          var e = new this.constructor(this);
          return (e.s = -e.s), e;
        }),
        (l.plus = l.add =
          function (e) {
            var t,
              n,
              r,
              i = this.constructor;
            if (((e = new i(e)), this.s != e.s)) return (e.s = -e.s), this.minus(e);
            var a = this.e,
              s = this.c,
              o = e.e,
              l = e.c;
            if (!s[0] || !l[0]) return l[0] || (s[0] ? (e = new i(this)) : (e.s = this.s)), e;
            if (((s = s.slice()), (t = a - o))) {
              for (t > 0 ? ((o = a), (r = l)) : ((t = -t), (r = s)), r.reverse(); t--; ) r.push(0);
              r.reverse();
            }
            for (
              s.length - l.length < 0 && ((r = l), (l = s), (s = r)), t = l.length, n = 0;
              t;
              s[t] %= 10
            )
              n = ((s[--t] = s[t] + l[t] + n) / 10) | 0;
            for (n && (s.unshift(n), ++o), t = s.length; 0 === s[--t]; ) s.pop();
            return (e.c = s), (e.e = o), e;
          }),
        (l.pow = function (e) {
          var t = this,
            n = new t.constructor('1'),
            r = n,
            a = e < 0;
          if (e !== ~~e || e < -1e6 || e > 1e6) throw Error(i + 'exponent');
          for (a && (e = -e); 1 & e && (r = r.times(t)), (e >>= 1); ) t = t.times(t);
          return a ? n.div(r) : r;
        }),
        (l.prec = function (e, t) {
          if (e !== ~~e || e < 1 || e > 1e6) throw Error(i + 'precision');
          return d(new this.constructor(this), e, t);
        }),
        (l.round = function (e, t) {
          if (e === u) e = 0;
          else if (e !== ~~e || e < -1e6 || e > 1e6) throw Error(a);
          return d(new this.constructor(this), e + this.e + 1, t);
        }),
        (l.sqrt = function () {
          var e,
            t,
            n,
            i = this.constructor,
            a = this.s,
            s = this.e,
            o = new i('0.5');
          if (!this.c[0]) return new i(this);
          if (a < 0) throw Error(r + 'No square root');
          0 === (a = Math.sqrt(+p(this, !0, !0))) || a === 1 / 0
            ? (((t = this.c.join('')).length + s) & 1 || (t += '0'),
              (s = (((s + 1) / 2) | 0) - (s < 0 || 1 & s)),
              (e = new i(
                ((a = Math.sqrt(t)) == 1 / 0
                  ? '5e'
                  : (a = a.toExponential()).slice(0, a.indexOf('e') + 1)) + s
              )))
            : (e = new i(a + '')),
            (s = e.e + (i.DP += 4));
          do (n = e), (e = o.times(n.plus(this.div(n))));
          while (n.c.slice(0, s).join('') !== e.c.slice(0, s).join(''));
          return d(e, (i.DP -= 4) + e.e + 1, i.RM);
        }),
        (l.times = l.mul =
          function (e) {
            var t,
              n = this.constructor,
              r = this.c,
              i = (e = new n(e)).c,
              a = r.length,
              s = i.length,
              o = this.e,
              l = e.e;
            if (((e.s = this.s == e.s ? 1 : -1), !r[0] || !i[0])) return (e.c = [(e.e = 0)]), e;
            for (
              e.e = o + l,
                a < s && ((t = r), (r = i), (i = t), (l = a), (a = s), (s = l)),
                t = Array((l = a + s));
              l--;

            )
              t[l] = 0;
            for (o = s; o--; ) {
              for (s = 0, l = a + o; l > o; )
                (s = t[l] + i[o] * r[l - o - 1] + s), (t[l--] = s % 10), (s = (s / 10) | 0);
              t[l] = s;
            }
            for (s ? ++e.e : t.shift(), o = t.length; !t[--o]; ) t.pop();
            return (e.c = t), e;
          }),
        (l.toExponential = function (e, t) {
          var n = this,
            r = n.c[0];
          if (e !== u) {
            if (e !== ~~e || e < 0 || e > 1e6) throw Error(a);
            for (n = d(new n.constructor(n), ++e, t); n.c.length < e; ) n.c.push(0);
          }
          return p(n, !0, !!r);
        }),
        (l.toFixed = function (e, t) {
          var n = this,
            r = n.c[0];
          if (e !== u) {
            if (e !== ~~e || e < 0 || e > 1e6) throw Error(a);
            for (n = d(new n.constructor(n), e + n.e + 1, t), e = e + n.e + 1; n.c.length < e; )
              n.c.push(0);
          }
          return p(n, !1, !!r);
        }),
        (l[Symbol.for('nodejs.util.inspect.custom')] =
          l.toJSON =
          l.toString =
            function () {
              var e = this.constructor;
              return p(this, this.e <= e.NE || this.e >= e.PE, !!this.c[0]);
            }),
        (l.toNumber = function () {
          var e = +p(this, !0, !0);
          if (!0 === this.constructor.strict && !this.eq(e.toString()))
            throw Error(r + 'Imprecise conversion');
          return e;
        }),
        (l.toPrecision = function (e, t) {
          var n = this,
            r = n.constructor,
            a = n.c[0];
          if (e !== u) {
            if (e !== ~~e || e < 1 || e > 1e6) throw Error(i + 'precision');
            for (n = d(new r(n), e, t); n.c.length < e; ) n.c.push(0);
          }
          return p(n, e <= n.e || n.e <= r.NE || n.e >= r.PE, !!a);
        }),
        (l.valueOf = function () {
          var e = this.constructor;
          if (!0 === e.strict) throw Error(r + 'valueOf disallowed');
          return p(this, this.e <= e.NE || this.e >= e.PE, !0);
        });
      var h = (function e() {
        function t(n) {
          if (!(this instanceof t)) return n === u ? e() : new t(n);
          if (n instanceof t) (this.s = n.s), (this.e = n.e), (this.c = n.c.slice());
          else {
            if ('string' != typeof n) {
              if (!0 === t.strict && 'bigint' != typeof n) throw TypeError(i + 'value');
              n = 0 === n && 1 / n < 0 ? '-0' : String(n);
            }
            !(function (e, t) {
              var n, r, a;
              if (!c.test(t)) throw Error(i + 'number');
              for (
                e.s = '-' == t.charAt(0) ? ((t = t.slice(1)), -1) : 1,
                  (n = t.indexOf('.')) > -1 && (t = t.replace('.', '')),
                  (r = t.search(/e/i)) > 0
                    ? (n < 0 && (n = r), (n += +t.slice(r + 1)), (t = t.substring(0, r)))
                    : n < 0 && (n = t.length),
                  a = t.length,
                  r = 0;
                r < a && '0' == t.charAt(r);

              )
                ++r;
              if (r == a) e.c = [(e.e = 0)];
              else {
                for (; a > 0 && '0' == t.charAt(--a); );
                for (e.e = n - r - 1, e.c = [], n = 0; r <= a; ) e.c[n++] = +t.charAt(r++);
              }
            })(this, n);
          }
          this.constructor = t;
        }
        return (
          (t.prototype = l),
          (t.DP = 20),
          (t.RM = 1),
          (t.NE = -7),
          (t.PE = 21),
          (t.strict = !1),
          (t.roundDown = 0),
          (t.roundHalfUp = 1),
          (t.roundHalfEven = 2),
          (t.roundUp = 3),
          t
        );
      })();
      let y = {
        bigNumber: (e) => new h(e || 0),
        multiply(e, t) {
          if (void 0 === e || void 0 === t) return new h(0);
          let n = new h(e),
            r = new h(t);
          return n.times(r);
        },
        formatNumberToLocalString: (e, t = 2) =>
          void 0 === e
            ? '0.00'
            : 'number' == typeof e
              ? e.toLocaleString('en-US', { maximumFractionDigits: t, minimumFractionDigits: t })
              : parseFloat(e).toLocaleString('en-US', {
                  maximumFractionDigits: t,
                  minimumFractionDigits: t,
                }),
        parseLocalStringToNumber: (e) => (void 0 === e ? 0 : parseFloat(e.replace(/,/gu, ''))),
      };
    },
    86923: function (e, t, n) {
      'use strict';
      n.d(t, {
        $U: function () {
          return s;
        },
        Vk: function () {
          return i;
        },
        mr: function () {
          return a;
        },
        uJ: function () {
          return r;
        },
      });
      let r = {
        WALLET_ID: '@appkit/wallet_id',
        WALLET_NAME: '@appkit/wallet_name',
        SOLANA_WALLET: '@appkit/solana_wallet',
        SOLANA_CAIP_CHAIN: '@appkit/solana_caip_chain',
        ACTIVE_CAIP_NETWORK_ID: '@appkit/active_caip_network_id',
        CONNECTED_SOCIAL: '@appkit/connected_social',
        CONNECTED_SOCIAL_USERNAME: '@appkit-wallet/SOCIAL_USERNAME',
        RECENT_WALLETS: '@appkit/recent_wallets',
        DEEPLINK_CHOICE: 'WALLETCONNECT_DEEPLINK_CHOICE',
        ACTIVE_NAMESPACE: '@appkit/active_namespace',
        CONNECTED_NAMESPACES: '@appkit/connected_namespaces',
        CONNECTION_STATUS: '@appkit/connection_status',
        SIWX_AUTH_TOKEN: '@appkit/siwx-auth-token',
        SIWX_NONCE_TOKEN: '@appkit/siwx-nonce-token',
        TELEGRAM_SOCIAL_PROVIDER: '@appkit/social_provider',
        NATIVE_BALANCE_CACHE: '@appkit/native_balance_cache',
        PORTFOLIO_CACHE: '@appkit/portfolio_cache',
        ENS_CACHE: '@appkit/ens_cache',
        IDENTITY_CACHE: '@appkit/identity_cache',
        PREFERRED_ACCOUNT_TYPES: '@appkit/preferred_account_types',
      };
      function i(e) {
        if (!e) throw Error('Namespace is required for CONNECTED_CONNECTOR_ID');
        return `@appkit/${e}:connected_connector_id`;
      }
      let a = {
        setItem(e, t) {
          s() && void 0 !== t && localStorage.setItem(e, t);
        },
        getItem(e) {
          if (s()) return localStorage.getItem(e) || void 0;
        },
        removeItem(e) {
          s() && localStorage.removeItem(e);
        },
        clear() {
          s() && localStorage.clear();
        },
      };
      function s() {
        return 'undefined' != typeof window && 'undefined' != typeof localStorage;
      }
    },
    29931: function (e, t, n) {
      'use strict';
      function r(e, t) {
        return 'light' === t
          ? {
              '--w3m-accent': e?.['--w3m-accent'] || 'hsla(231, 100%, 70%, 1)',
              '--w3m-background': '#fff',
            }
          : {
              '--w3m-accent': e?.['--w3m-accent'] || 'hsla(230, 100%, 67%, 1)',
              '--w3m-background': '#121313',
            };
      }
      n.d(t, {
        t: function () {
          return r;
        },
      });
    },
    60725: function (e, t, n) {
      'use strict';
      n.d(t, {
        AccountController: function () {
          return c;
        },
      });
      var r = n(94583),
        i = n(49162),
        a = n(14537),
        s = n(98583),
        o = n(97059),
        l = n(19165);
      let u = (0, r.sj)({
          currentTab: 0,
          tokenBalance: [],
          smartAccountDeployed: !1,
          addressLabels: new Map(),
          allAccounts: [],
        }),
        c = {
          state: u,
          replaceState(e) {
            e && Object.assign(u, (0, r.iH)(e));
          },
          subscribe: (e) =>
            o.R.subscribeChainProp('accountState', (t) => {
              if (t) return e(t);
            }),
          subscribeKey(e, t, n) {
            let r;
            return o.R.subscribeChainProp(
              'accountState',
              (n) => {
                if (n) {
                  let i = n[e];
                  r !== i && ((r = i), t(i));
                }
              },
              n
            );
          },
          setStatus(e, t) {
            o.R.setAccountProp('status', e, t);
          },
          getCaipAddress: (e) => o.R.getAccountProp('caipAddress', e),
          setCaipAddress(e, t) {
            let n = e ? a.j.getPlainAddress(e) : void 0;
            t === o.R.state.activeChain && (o.R.state.activeCaipAddress = e),
              o.R.setAccountProp('caipAddress', e, t),
              o.R.setAccountProp('address', n, t);
          },
          setBalance(e, t, n) {
            o.R.setAccountProp('balance', e, n), o.R.setAccountProp('balanceSymbol', t, n);
          },
          setProfileName(e, t) {
            o.R.setAccountProp('profileName', e, t);
          },
          setProfileImage(e, t) {
            o.R.setAccountProp('profileImage', e, t);
          },
          setUser(e, t) {
            o.R.setAccountProp('user', e, t);
          },
          setAddressExplorerUrl(e, t) {
            o.R.setAccountProp('addressExplorerUrl', e, t);
          },
          setSmartAccountDeployed(e, t) {
            o.R.setAccountProp('smartAccountDeployed', e, t);
          },
          setCurrentTab(e) {
            o.R.setAccountProp('currentTab', e, o.R.state.activeChain);
          },
          setTokenBalance(e, t) {
            e && o.R.setAccountProp('tokenBalance', e, t);
          },
          setShouldUpdateToAddress(e, t) {
            o.R.setAccountProp('shouldUpdateToAddress', e, t);
          },
          setAllAccounts(e, t) {
            o.R.setAccountProp('allAccounts', e, t);
          },
          addAddressLabel(e, t, n) {
            let r = o.R.getAccountProp('addressLabels', n) || new Map();
            r.set(e, t), o.R.setAccountProp('addressLabels', r, n);
          },
          removeAddressLabel(e, t) {
            let n = o.R.getAccountProp('addressLabels', t) || new Map();
            n.delete(e), o.R.setAccountProp('addressLabels', n, t);
          },
          setConnectedWalletInfo(e, t) {
            o.R.setAccountProp('connectedWalletInfo', e, t, !1);
          },
          setPreferredAccountType(e, t) {
            o.R.setAccountProp('preferredAccountTypes', { ...u.preferredAccountTypes, [t]: e }, t);
          },
          setPreferredAccountTypes(e) {
            u.preferredAccountTypes = e;
          },
          setSocialProvider(e, t) {
            e && o.R.setAccountProp('socialProvider', e, t);
          },
          setSocialWindow(e, t) {
            o.R.setAccountProp('socialWindow', e ? (0, r.iH)(e) : void 0, t);
          },
          setFarcasterUrl(e, t) {
            o.R.setAccountProp('farcasterUrl', e, t);
          },
          async fetchTokenBalance(e) {
            u.balanceLoading = !0;
            let t = o.R.state.activeCaipNetwork?.caipNetworkId,
              n = o.R.state.activeCaipNetwork?.chainNamespace,
              r = o.R.state.activeCaipAddress,
              c = r ? a.j.getPlainAddress(r) : void 0;
            if (u.lastRetry && !a.j.isAllowedRetry(u.lastRetry, 30 * i.bq.ONE_SEC_MS))
              return (u.balanceLoading = !1), [];
            try {
              if (c && t && n) {
                let e = (await s.L.getBalance(c, t)).balances.filter(
                  (e) => '0' !== e.quantity.decimals
                );
                return (
                  this.setTokenBalance(e, n), (u.lastRetry = void 0), (u.balanceLoading = !1), e
                );
              }
            } catch (t) {
              (u.lastRetry = Date.now()),
                e?.(t),
                l.SnackController.showError('Token Balance Unavailable');
            } finally {
              u.balanceLoading = !1;
            }
            return [];
          },
          resetAccount(e) {
            o.R.resetAccount(e);
          },
        };
    },
    10423: function (e, t, n) {
      'use strict';
      n.d(t, {
        AlertController: function () {
          return o;
        },
      });
      var r = n(94583),
        i = n(95759),
        a = n(8924);
      let s = (0, r.sj)({ message: '', variant: 'info', open: !1 }),
        o = {
          state: s,
          subscribeKey: (e, t) => (0, i.VW)(s, e, t),
          open(e, t) {
            let { debug: n } = a.OptionsController.state,
              { shortMessage: r, longMessage: i } = e;
            n && ((s.message = r), (s.variant = t), (s.open = !0)),
              i && console.error('function' == typeof i ? i() : i);
          },
          close() {
            (s.open = !1), (s.message = ''), (s.variant = 'info');
          },
        };
    },
    82093: function (e, t, n) {
      'use strict';
      n.d(t, {
        ApiController: function () {
          return b;
        },
      });
      var r = n(94583),
        i = n(95759),
        a = n(94498),
        s = n(14537),
        o = n(83118),
        l = n(31507),
        u = n(24979),
        c = n(97059),
        d = n(3230),
        p = n(27837),
        h = n(8924);
      let y = [
          '1ca0bdd4747578705b1939af023d120677c64fe6ca76add81fda36e350605e79',
          'fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa',
          'a797aa35c0fadbfc1a53e7f675162ed5226968b44a19ee3d24385c64d1d3c393',
        ],
        f = s.j.getApiUrl(),
        m = new o.V({ baseUrl: f, clientId: null }),
        g = (0, r.sj)({
          promises: {},
          page: 1,
          count: 0,
          featured: [],
          allFeatured: [],
          recommended: [],
          allRecommended: [],
          wallets: [],
          search: [],
          isAnalyticsEnabled: !1,
          excludedWallets: [],
          isFetchingRecommendedWallets: !1,
        }),
        b = {
          state: g,
          subscribeKey: (e, t) => (0, i.VW)(g, e, t),
          _getSdkProperties() {
            let { projectId: e, sdkType: t, sdkVersion: n } = h.OptionsController.state;
            return { projectId: e, st: t || 'appkit', sv: n || 'html-wagmi-4.2.2' };
          },
          _filterOutExtensions: (e) =>
            h.OptionsController.state.isUniversalProvider
              ? e.filter((e) => !!(e.mobile_link || e.desktop_link || e.webapp_link))
              : e,
          async _fetchWalletImage(e) {
            let t = `${m.baseUrl}/getWalletImage/${e}`,
              n = await m.getBlob({ path: t, params: b._getSdkProperties() });
            u.W.setWalletImage(e, URL.createObjectURL(n));
          },
          async _fetchNetworkImage(e) {
            let t = `${m.baseUrl}/public/getAssetImage/${e}`,
              n = await m.getBlob({ path: t, params: b._getSdkProperties() });
            u.W.setNetworkImage(e, URL.createObjectURL(n));
          },
          async _fetchConnectorImage(e) {
            let t = `${m.baseUrl}/public/getAssetImage/${e}`,
              n = await m.getBlob({ path: t, params: b._getSdkProperties() });
            u.W.setConnectorImage(e, URL.createObjectURL(n));
          },
          async _fetchCurrencyImage(e) {
            let t = `${m.baseUrl}/public/getCurrencyImage/${e}`,
              n = await m.getBlob({ path: t, params: b._getSdkProperties() });
            u.W.setCurrencyImage(e, URL.createObjectURL(n));
          },
          async _fetchTokenImage(e) {
            let t = `${m.baseUrl}/public/getTokenImage/${e}`,
              n = await m.getBlob({ path: t, params: b._getSdkProperties() });
            u.W.setTokenImage(e, URL.createObjectURL(n));
          },
          async fetchNetworkImages() {
            let e = c.R.getAllRequestedCaipNetworks(),
              t = e
                ?.map(({ assets: e }) => e?.imageId)
                .filter(Boolean)
                .filter((e) => !a.f.getNetworkImageById(e));
            t && (await Promise.allSettled(t.map((e) => b._fetchNetworkImage(e))));
          },
          async fetchConnectorImages() {
            let { connectors: e } = d.ConnectorController.state,
              t = e.map(({ imageId: e }) => e).filter(Boolean);
            await Promise.allSettled(t.map((e) => b._fetchConnectorImage(e)));
          },
          async fetchCurrencyImages(e = []) {
            await Promise.allSettled(e.map((e) => b._fetchCurrencyImage(e)));
          },
          async fetchTokenImages(e = []) {
            await Promise.allSettled(e.map((e) => b._fetchTokenImage(e)));
          },
          async fetchWallets(e) {
            let t = e.exclude ?? [];
            return (
              b._getSdkProperties().sv.startsWith('html-core-') && t.push(...y),
              await m.get({
                path: '/getWallets',
                params: {
                  ...b._getSdkProperties(),
                  ...e,
                  page: String(e.page),
                  entries: String(e.entries),
                  include: e.include?.join(','),
                  exclude: e.exclude?.join(','),
                },
              })
            );
          },
          async fetchFeaturedWallets() {
            let { featuredWalletIds: e } = h.OptionsController.state;
            if (e?.length) {
              let t = { ...b._getSdkProperties(), page: 1, entries: e?.length ?? 4, include: e },
                { data: n } = await b.fetchWallets(t);
              n.sort((t, n) => e.indexOf(t.id) - e.indexOf(n.id));
              let r = n.map((e) => e.image_id).filter(Boolean);
              await Promise.allSettled(r.map((e) => b._fetchWalletImage(e))),
                (g.featured = n),
                (g.allFeatured = n);
            }
          },
          async fetchRecommendedWallets() {
            try {
              g.isFetchingRecommendedWallets = !0;
              let {
                  includeWalletIds: e,
                  excludeWalletIds: t,
                  featuredWalletIds: n,
                } = h.OptionsController.state,
                r = [...(t ?? []), ...(n ?? [])].filter(Boolean),
                i = c.R.getRequestedCaipNetworkIds().join(','),
                { data: a, count: s } = await b.fetchWallets({
                  page: 1,
                  entries: 4,
                  include: e,
                  exclude: r,
                  chains: i,
                }),
                o = l.M.getRecentWallets(),
                u = a.map((e) => e.image_id).filter(Boolean),
                d = o.map((e) => e.image_id).filter(Boolean);
              await Promise.allSettled([...u, ...d].map((e) => b._fetchWalletImage(e))),
                (g.recommended = a),
                (g.allRecommended = a),
                (g.count = s ?? 0);
            } catch {
            } finally {
              g.isFetchingRecommendedWallets = !1;
            }
          },
          async fetchWalletsByPage({ page: e }) {
            let {
                includeWalletIds: t,
                excludeWalletIds: n,
                featuredWalletIds: r,
              } = h.OptionsController.state,
              i = c.R.getRequestedCaipNetworkIds().join(','),
              a = [...g.recommended.map(({ id: e }) => e), ...(n ?? []), ...(r ?? [])].filter(
                Boolean
              ),
              { data: o, count: l } = await b.fetchWallets({
                page: e,
                entries: 40,
                include: t,
                exclude: a,
                chains: i,
              }),
              u = o
                .slice(0, 20)
                .map((e) => e.image_id)
                .filter(Boolean);
            await Promise.allSettled(u.map((e) => b._fetchWalletImage(e))),
              (g.wallets = s.j.uniqueBy([...g.wallets, ...b._filterOutExtensions(o)], 'id')),
              (g.count = l > g.count ? l : g.count),
              (g.page = e);
          },
          async initializeExcludedWallets({ ids: e }) {
            let t = c.R.getRequestedCaipNetworkIds().join(','),
              n = { page: 1, entries: e.length, include: e, chains: t },
              { data: r } = await b.fetchWallets(n);
            r &&
              r.forEach((e) => {
                g.excludedWallets.push({ rdns: e.rdns, name: e.name });
              });
          },
          async searchWallet({ search: e, badge: t }) {
            let { includeWalletIds: n, excludeWalletIds: r } = h.OptionsController.state,
              i = c.R.getRequestedCaipNetworkIds().join(',');
            g.search = [];
            let a = {
                page: 1,
                entries: 100,
                search: e?.trim(),
                badge_type: t,
                include: n,
                exclude: r,
                chains: i,
              },
              { data: o } = await b.fetchWallets(a);
            p.X.sendEvent({
              type: 'track',
              event: 'SEARCH_WALLET',
              properties: { badge: t ?? '', search: e ?? '' },
            });
            let l = o.map((e) => e.image_id).filter(Boolean);
            await Promise.allSettled([...l.map((e) => b._fetchWalletImage(e)), s.j.wait(300)]),
              (g.search = b._filterOutExtensions(o));
          },
          initPromise: (e, t) => g.promises[e] || (g.promises[e] = t()),
          prefetch: ({
            fetchConnectorImages: e = !0,
            fetchFeaturedWallets: t = !0,
            fetchRecommendedWallets: n = !0,
            fetchNetworkImages: r = !0,
          } = {}) =>
            Promise.allSettled(
              [
                e && b.initPromise('connectorImages', b.fetchConnectorImages),
                t && b.initPromise('featuredWallets', b.fetchFeaturedWallets),
                n && b.initPromise('recommendedWallets', b.fetchRecommendedWallets),
                r && b.initPromise('networkImages', b.fetchNetworkImages),
              ].filter(Boolean)
            ),
          prefetchAnalyticsConfig() {
            h.OptionsController.state.features?.analytics && b.fetchAnalyticsConfig();
          },
          async fetchAnalyticsConfig() {
            try {
              let { isAnalyticsEnabled: e } = await m.get({
                path: '/getAnalyticsConfig',
                params: b._getSdkProperties(),
              });
              h.OptionsController.setFeatures({ analytics: e });
            } catch (e) {
              h.OptionsController.setFeatures({ analytics: !1 });
            }
          },
          setFilterByNamespace(e) {
            if (!e) {
              (g.featured = g.allFeatured), (g.recommended = g.allRecommended);
              return;
            }
            let t = c.R.getRequestedCaipNetworkIds().join(',');
            (g.featured = g.allFeatured.filter((e) => e.chains?.some((e) => t.includes(e)))),
              (g.recommended = g.allRecommended.filter((e) =>
                e.chains?.some((e) => t.includes(e))
              ));
          },
        };
    },
    24979: function (e, t, n) {
      'use strict';
      n.d(t, {
        W: function () {
          return s;
        },
      });
      var r = n(94583),
        i = n(95759);
      let a = (0, r.sj)({
          walletImages: {},
          networkImages: {},
          chainImages: {},
          connectorImages: {},
          tokenImages: {},
          currencyImages: {},
        }),
        s = {
          state: a,
          subscribeNetworkImages: (e) => (0, r.Ld)(a.networkImages, () => e(a.networkImages)),
          subscribeKey: (e, t) => (0, i.VW)(a, e, t),
          subscribe: (e) => (0, r.Ld)(a, () => e(a)),
          setWalletImage(e, t) {
            a.walletImages[e] = t;
          },
          setNetworkImage(e, t) {
            a.networkImages[e] = t;
          },
          setChainImage(e, t) {
            a.chainImages[e] = t;
          },
          setConnectorImage(e, t) {
            a.connectorImages = { ...a.connectorImages, [e]: t };
          },
          setTokenImage(e, t) {
            a.tokenImages[e] = t;
          },
          setCurrencyImage(e, t) {
            a.currencyImages[e] = t;
          },
        };
    },
    98583: function (e, t, n) {
      'use strict';
      n.d(t, {
        L: function () {
          return f;
        },
      });
      var r = n(94583),
        i = n(49162),
        a = n(14537),
        s = n(83118),
        o = n(31507),
        l = n(60725),
        u = n(97059),
        c = n(8924),
        d = n(19165);
      let p = {
          purchaseCurrencies: [
            {
              id: '2b92315d-eab7-5bef-84fa-089a131333f5',
              name: 'USD Coin',
              symbol: 'USDC',
              networks: [
                {
                  name: 'ethereum-mainnet',
                  display_name: 'Ethereum',
                  chain_id: '1',
                  contract_address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
                },
                {
                  name: 'polygon-mainnet',
                  display_name: 'Polygon',
                  chain_id: '137',
                  contract_address: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',
                },
              ],
            },
            {
              id: '2b92315d-eab7-5bef-84fa-089a131333f5',
              name: 'Ether',
              symbol: 'ETH',
              networks: [
                {
                  name: 'ethereum-mainnet',
                  display_name: 'Ethereum',
                  chain_id: '1',
                  contract_address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
                },
                {
                  name: 'polygon-mainnet',
                  display_name: 'Polygon',
                  chain_id: '137',
                  contract_address: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',
                },
              ],
            },
          ],
          paymentCurrencies: [
            {
              id: 'USD',
              payment_method_limits: [
                { id: 'card', min: '10.00', max: '7500.00' },
                { id: 'ach_bank_account', min: '10.00', max: '25000.00' },
              ],
            },
            {
              id: 'EUR',
              payment_method_limits: [
                { id: 'card', min: '10.00', max: '7500.00' },
                { id: 'ach_bank_account', min: '10.00', max: '25000.00' },
              ],
            },
          ],
        },
        h = a.j.getBlockchainApiUrl(),
        y = (0, r.sj)({
          clientId: null,
          api: new s.V({ baseUrl: h, clientId: null }),
          supportedChains: { http: [], ws: [] },
        }),
        f = {
          state: y,
          async get(e) {
            let { st: t, sv: n } = f.getSdkProperties(),
              r = c.OptionsController.state.projectId,
              i = { ...(e.params || {}), st: t, sv: n, projectId: r };
            return y.api.get({ ...e, params: i });
          },
          getSdkProperties() {
            let { sdkType: e, sdkVersion: t } = c.OptionsController.state;
            return { st: e || 'unknown', sv: t || 'unknown' };
          },
          async isNetworkSupported(e) {
            if (!e) return !1;
            try {
              y.supportedChains.http.length || (await f.getSupportedNetworks());
            } catch (e) {
              return !1;
            }
            return y.supportedChains.http.includes(e);
          },
          async getSupportedNetworks() {
            let e = await f.get({ path: 'v1/supported-chains' });
            return (y.supportedChains = e), e;
          },
          async fetchIdentity({ address: e, caipNetworkId: t }) {
            if (!(await f.isNetworkSupported(t))) return { avatar: '', name: '' };
            let n = o.M.getIdentityFromCacheForAddress(e);
            if (n) return n;
            let r = await f.get({
              path: `/v1/identity/${e}`,
              params: {
                sender: u.R.state.activeCaipAddress
                  ? a.j.getPlainAddress(u.R.state.activeCaipAddress)
                  : void 0,
              },
            });
            return o.M.updateIdentityCache({ address: e, identity: r, timestamp: Date.now() }), r;
          },
          fetchTransactions: async ({
            account: e,
            cursor: t,
            onramp: n,
            signal: r,
            cache: i,
            chainId: a,
          }) =>
            (await f.isNetworkSupported(u.R.state.activeCaipNetwork?.caipNetworkId))
              ? f.get({
                  path: `/v1/account/${e}/history`,
                  params: { cursor: t, onramp: n, chainId: a },
                  signal: r,
                  cache: i,
                })
              : { data: [], next: void 0 },
          fetchSwapQuote: async ({ amount: e, userAddress: t, from: n, to: r, gasPrice: i }) =>
            (await f.isNetworkSupported(u.R.state.activeCaipNetwork?.caipNetworkId))
              ? f.get({
                  path: '/v1/convert/quotes',
                  headers: { 'Content-Type': 'application/json' },
                  params: { amount: e, userAddress: t, from: n, to: r, gasPrice: i },
                })
              : { quotes: [] },
          fetchSwapTokens: async ({ chainId: e }) =>
            (await f.isNetworkSupported(u.R.state.activeCaipNetwork?.caipNetworkId))
              ? f.get({ path: '/v1/convert/tokens', params: { chainId: e } })
              : { tokens: [] },
          fetchTokenPrice: async ({ addresses: e }) =>
            (await f.isNetworkSupported(u.R.state.activeCaipNetwork?.caipNetworkId))
              ? y.api.post({
                  path: '/v1/fungible/price',
                  body: {
                    currency: 'usd',
                    addresses: e,
                    projectId: c.OptionsController.state.projectId,
                  },
                  headers: { 'Content-Type': 'application/json' },
                })
              : { fungibles: [] },
          fetchSwapAllowance: async ({ tokenAddress: e, userAddress: t }) =>
            (await f.isNetworkSupported(u.R.state.activeCaipNetwork?.caipNetworkId))
              ? f.get({
                  path: '/v1/convert/allowance',
                  params: { tokenAddress: e, userAddress: t },
                  headers: { 'Content-Type': 'application/json' },
                })
              : { allowance: '0' },
          async fetchGasPrice({ chainId: e }) {
            let { st: t, sv: n } = f.getSdkProperties();
            if (!(await f.isNetworkSupported(u.R.state.activeCaipNetwork?.caipNetworkId)))
              throw Error('Network not supported for Gas Price');
            return f.get({
              path: '/v1/convert/gas-price',
              headers: { 'Content-Type': 'application/json' },
              params: { chainId: e, st: t, sv: n },
            });
          },
          async generateSwapCalldata({
            amount: e,
            from: t,
            to: n,
            userAddress: r,
            disableEstimate: a,
          }) {
            if (!(await f.isNetworkSupported(u.R.state.activeCaipNetwork?.caipNetworkId)))
              throw Error('Network not supported for Swaps');
            return y.api.post({
              path: '/v1/convert/build-transaction',
              headers: { 'Content-Type': 'application/json' },
              body: {
                amount: e,
                eip155: { slippage: i.bq.CONVERT_SLIPPAGE_TOLERANCE },
                projectId: c.OptionsController.state.projectId,
                from: t,
                to: n,
                userAddress: r,
                disableEstimate: a,
              },
            });
          },
          async generateApproveCalldata({ from: e, to: t, userAddress: n }) {
            let { st: r, sv: i } = f.getSdkProperties();
            if (!(await f.isNetworkSupported(u.R.state.activeCaipNetwork?.caipNetworkId)))
              throw Error('Network not supported for Swaps');
            return f.get({
              path: '/v1/convert/build-approve',
              headers: { 'Content-Type': 'application/json' },
              params: { userAddress: n, from: e, to: t, st: r, sv: i },
            });
          },
          async getBalance(e, t, n) {
            let { st: r, sv: i } = f.getSdkProperties();
            if (!(await f.isNetworkSupported(u.R.state.activeCaipNetwork?.caipNetworkId)))
              return d.SnackController.showError('Token Balance Unavailable'), { balances: [] };
            let a = `${t}:${e}`,
              s = o.M.getBalanceCacheForCaipAddress(a);
            if (s) return s;
            let l = await f.get({
              path: `/v1/account/${e}/balance`,
              params: { currency: 'usd', chainId: t, forceUpdate: n, st: r, sv: i },
            });
            return o.M.updateBalanceCache({ caipAddress: a, balance: l, timestamp: Date.now() }), l;
          },
          lookupEnsName: async (e) =>
            (await f.isNetworkSupported(u.R.state.activeCaipNetwork?.caipNetworkId))
              ? f.get({ path: `/v1/profile/account/${e}`, params: { apiVersion: '2' } })
              : { addresses: {}, attributes: [] },
          reverseLookupEnsName: async ({ address: e }) =>
            (await f.isNetworkSupported(u.R.state.activeCaipNetwork?.caipNetworkId))
              ? f.get({
                  path: `/v1/profile/reverse/${e}`,
                  params: { sender: l.AccountController.state.address, apiVersion: '2' },
                })
              : [],
          getEnsNameSuggestions: async (e) =>
            (await f.isNetworkSupported(u.R.state.activeCaipNetwork?.caipNetworkId))
              ? f.get({ path: `/v1/profile/suggestions/${e}`, params: { zone: 'reown.id' } })
              : { suggestions: [] },
          registerEnsName: async ({ coinType: e, address: t, message: n, signature: r }) =>
            (await f.isNetworkSupported(u.R.state.activeCaipNetwork?.caipNetworkId))
              ? y.api.post({
                  path: '/v1/profile/account',
                  body: { coin_type: e, address: t, message: n, signature: r },
                  headers: { 'Content-Type': 'application/json' },
                })
              : { success: !1 },
          generateOnRampURL: async ({
            destinationWallets: e,
            partnerUserId: t,
            defaultNetwork: n,
            purchaseAmount: r,
            paymentAmount: i,
          }) =>
            (await f.isNetworkSupported(u.R.state.activeCaipNetwork?.caipNetworkId))
              ? (
                  await y.api.post({
                    path: '/v1/generators/onrampurl',
                    params: { projectId: c.OptionsController.state.projectId },
                    body: {
                      destinationWallets: e,
                      defaultNetwork: n,
                      partnerUserId: t,
                      defaultExperience: 'buy',
                      presetCryptoAmount: r,
                      presetFiatAmount: i,
                    },
                  })
                ).url
              : '',
          async getOnrampOptions() {
            if (!(await f.isNetworkSupported(u.R.state.activeCaipNetwork?.caipNetworkId)))
              return { paymentCurrencies: [], purchaseCurrencies: [] };
            try {
              return await f.get({ path: '/v1/onramp/options' });
            } catch (e) {
              return p;
            }
          },
          async getOnrampQuote({ purchaseCurrency: e, paymentCurrency: t, amount: n, network: r }) {
            try {
              if (!(await f.isNetworkSupported(u.R.state.activeCaipNetwork?.caipNetworkId)))
                return null;
              return await y.api.post({
                path: '/v1/onramp/quote',
                params: { projectId: c.OptionsController.state.projectId },
                body: { purchaseCurrency: e, paymentCurrency: t, amount: n, network: r },
              });
            } catch (e) {
              return {
                coinbaseFee: { amount: n, currency: t.id },
                networkFee: { amount: n, currency: t.id },
                paymentSubtotal: { amount: n, currency: t.id },
                paymentTotal: { amount: n, currency: t.id },
                purchaseAmount: { amount: n, currency: t.id },
                quoteId: 'mocked-quote-id',
              };
            }
          },
          getSmartSessions: async (e) =>
            (await f.isNetworkSupported(u.R.state.activeCaipNetwork?.caipNetworkId))
              ? f.get({ path: `/v1/sessions/${e}` })
              : [],
          revokeSmartSession: async (e, t, n) =>
            (await f.isNetworkSupported(u.R.state.activeCaipNetwork?.caipNetworkId))
              ? y.api.post({
                  path: `/v1/sessions/${e}/revoke`,
                  params: { projectId: c.OptionsController.state.projectId },
                  body: { pci: t, signature: n },
                })
              : { success: !1 },
          setClientId(e) {
            (y.clientId = e), (y.api = new s.V({ baseUrl: h, clientId: e }));
          },
        };
    },
    97059: function (e, t, n) {
      'use strict';
      n.d(t, {
        R: function () {
          return E;
        },
      });
      var r = n(94583),
        i = n(95759),
        a = n(48261),
        s = n(49786),
        o = n(3230);
      function l(e, t) {
        return o.ConnectorController.getConnectorId(e) === t;
      }
      var u = n(49162),
        c = n(14537),
        d = n(31507),
        p = n(60725),
        h = n(17409),
        y = n(27837),
        f = n(26038),
        m = n(8924),
        g = n(61564),
        b = n(88667),
        w = n(53207);
      let v = {
          currentTab: 0,
          tokenBalance: [],
          smartAccountDeployed: !1,
          addressLabels: new Map(),
          allAccounts: [],
          user: void 0,
        },
        T = { caipNetwork: void 0, supportsAllNetworks: !0, smartAccountEnabledNetworks: [] },
        A = (0, r.sj)({
          chains: (0, i.Yr)(),
          activeCaipAddress: void 0,
          activeChain: void 0,
          activeCaipNetwork: void 0,
          noAdapters: !1,
          universalAdapter: { networkControllerClient: void 0, connectionControllerClient: void 0 },
          isSwitchingNamespace: !1,
        }),
        E = {
          state: A,
          subscribe: (e) =>
            (0, r.Ld)(A, () => {
              e(A);
            }),
          subscribeKey: (e, t) => (0, i.VW)(A, e, t),
          subscribeChainProp(e, t, n) {
            let i;
            return (0, r.Ld)(A.chains, () => {
              let r = n || A.activeChain;
              if (r) {
                let n = A.chains.get(r)?.[e];
                i !== n && ((i = n), t(n));
              }
            });
          },
          initialize(e, t, n) {
            let { chainId: i, namespace: a } = d.M.getActiveNetworkProps(),
              s = t?.find((e) => e.id.toString() === i?.toString()),
              o = e.find((e) => e?.namespace === a) || e?.[0],
              l = new Set([...(t?.map((e) => e.chainNamespace) ?? [])]);
            (e?.length !== 0 && o) || (A.noAdapters = !0),
              !A.noAdapters &&
                ((A.activeChain = o?.namespace),
                (A.activeCaipNetwork = s),
                this.setChainNetworkData(o?.namespace, { caipNetwork: s }),
                A.activeChain && g.I.set({ activeChain: o?.namespace })),
              l.forEach((e) => {
                let i = t?.filter((t) => t.chainNamespace === e);
                E.state.chains.set(e, {
                  namespace: e,
                  networkState: (0, r.sj)({ ...T, caipNetwork: i?.[0] }),
                  accountState: (0, r.sj)(v),
                  caipNetworks: i ?? [],
                  ...n,
                }),
                  this.setRequestedCaipNetworks(i ?? [], e);
              });
          },
          removeAdapter(e) {
            if (A.activeChain === e) {
              let t = Array.from(A.chains.entries()).find(([t]) => t !== e);
              if (t) {
                let e = t[1]?.caipNetworks?.[0];
                e && this.setActiveCaipNetwork(e);
              }
            }
            A.chains.delete(e);
          },
          addAdapter(e, { networkControllerClient: t, connectionControllerClient: n }, r) {
            A.chains.set(e.namespace, {
              namespace: e.namespace,
              networkState: { ...T, caipNetwork: r[0] },
              accountState: v,
              caipNetworks: r,
              connectionControllerClient: n,
              networkControllerClient: t,
            }),
              this.setRequestedCaipNetworks(
                r?.filter((t) => t.chainNamespace === e.namespace) ?? [],
                e.namespace
              );
          },
          addNetwork(e) {
            let t = A.chains.get(e.chainNamespace);
            if (t) {
              let n = [...(t.caipNetworks || [])];
              t.caipNetworks?.find((t) => t.id === e.id) || n.push(e),
                A.chains.set(e.chainNamespace, { ...t, caipNetworks: n }),
                this.setRequestedCaipNetworks(n, e.chainNamespace);
            }
          },
          removeNetwork(e, t) {
            let n = A.chains.get(e);
            if (n) {
              let r = A.activeCaipNetwork?.id === t,
                i = [...(n.caipNetworks?.filter((e) => e.id !== t) || [])];
              r && n?.caipNetworks?.[0] && this.setActiveCaipNetwork(n.caipNetworks[0]),
                A.chains.set(e, { ...n, caipNetworks: i }),
                this.setRequestedCaipNetworks(i || [], e);
            }
          },
          setAdapterNetworkState(e, t) {
            let n = A.chains.get(e);
            n && ((n.networkState = { ...(n.networkState || T), ...t }), A.chains.set(e, n));
          },
          setChainAccountData(e, t, n = !0) {
            if (!e) throw Error('Chain is required to update chain account data');
            let r = A.chains.get(e);
            if (r) {
              let n = { ...(r.accountState || v), ...t };
              A.chains.set(e, { ...r, accountState: n }),
                (1 === A.chains.size || A.activeChain === e) &&
                  (t.caipAddress && (A.activeCaipAddress = t.caipAddress),
                  p.AccountController.replaceState(n));
            }
          },
          setChainNetworkData(e, t) {
            if (!e) return;
            let n = A.chains.get(e);
            if (n) {
              let r = { ...(n.networkState || T), ...t };
              A.chains.set(e, { ...n, networkState: r });
            }
          },
          setAccountProp(e, t, n, r = !0) {
            this.setChainAccountData(n, { [e]: t }, r),
              'status' === e &&
                'disconnected' === t &&
                n &&
                o.ConnectorController.removeConnectorId(n);
          },
          setActiveNamespace(e) {
            A.activeChain = e;
            let t = e ? A.chains.get(e) : void 0,
              n = t?.networkState?.caipNetwork;
            n?.id &&
              e &&
              ((A.activeCaipAddress = t?.accountState?.caipAddress),
              (A.activeCaipNetwork = n),
              this.setChainNetworkData(e, { caipNetwork: n }),
              d.M.setActiveCaipNetworkId(n?.caipNetworkId),
              g.I.set({ activeChain: e, selectedNetworkId: n?.caipNetworkId }));
          },
          setActiveCaipNetwork(e) {
            if (!e) return;
            A.activeChain !== e.chainNamespace && this.setIsSwitchingNamespace(!0);
            let t = A.chains.get(e.chainNamespace);
            (A.activeChain = e.chainNamespace),
              (A.activeCaipNetwork = e),
              this.setChainNetworkData(e.chainNamespace, { caipNetwork: e }),
              t?.accountState?.address
                ? (A.activeCaipAddress = `${e.chainNamespace}:${e.id}:${t?.accountState?.address}`)
                : (A.activeCaipAddress = void 0),
              this.setAccountProp('caipAddress', A.activeCaipAddress, e.chainNamespace),
              t && p.AccountController.replaceState(t.accountState),
              w.S.resetSend(),
              g.I.set({
                activeChain: A.activeChain,
                selectedNetworkId: A.activeCaipNetwork?.caipNetworkId,
              }),
              d.M.setActiveCaipNetworkId(e.caipNetworkId),
              this.checkIfSupportedNetwork(e.chainNamespace) ||
                !m.OptionsController.state.enableNetworkSwitch ||
                m.OptionsController.state.allowUnsupportedChain ||
                h.ConnectionController.state.wcBasic ||
                this.showUnsupportedChainUI();
          },
          addCaipNetwork(e) {
            if (!e) return;
            let t = A.chains.get(e.chainNamespace);
            t && t?.caipNetworks?.push(e);
          },
          async switchActiveNamespace(e) {
            if (!e) return;
            let t = e !== E.state.activeChain,
              n = E.getNetworkData(e)?.caipNetwork,
              r = E.getCaipNetworkByNamespace(e, n?.id);
            t && r && (await E.switchActiveNetwork(r));
          },
          async switchActiveNetwork(e) {
            let t = E.state.chains.get(E.state.activeChain);
            t?.caipNetworks?.some((e) => e.id === A.activeCaipNetwork?.id) ||
              b.RouterController.goBack();
            let n = this.getNetworkControllerClient(e.chainNamespace);
            n &&
              (await n.switchCaipNetwork(e),
              y.X.sendEvent({
                type: 'track',
                event: 'SWITCH_NETWORK',
                properties: { network: e.caipNetworkId },
              }));
          },
          getNetworkControllerClient(e) {
            let t = e || A.activeChain,
              n = A.chains.get(t);
            if (!n) throw Error('Chain adapter not found');
            if (!n.networkControllerClient) throw Error('NetworkController client not set');
            return n.networkControllerClient;
          },
          getConnectionControllerClient(e) {
            let t = e || A.activeChain;
            if (!t) throw Error('Chain is required to get connection controller client');
            let n = A.chains.get(t);
            if (!n?.connectionControllerClient) throw Error('ConnectionController client not set');
            return n.connectionControllerClient;
          },
          getAccountProp(e, t) {
            let n = A.activeChain;
            if ((t && (n = t), !n)) return;
            let r = A.chains.get(n)?.accountState;
            if (r) return r[e];
          },
          getNetworkProp(e, t) {
            let n = A.chains.get(t)?.networkState;
            if (n) return n[e];
          },
          getRequestedCaipNetworks(e) {
            let t = A.chains.get(e),
              { approvedCaipNetworkIds: n = [], requestedCaipNetworks: r = [] } =
                t?.networkState || {};
            return c.j.sortRequestedNetworks(n, r);
          },
          getAllRequestedCaipNetworks() {
            let e = [];
            return (
              A.chains.forEach((t) => {
                let n = this.getRequestedCaipNetworks(t.namespace);
                e.push(...n);
              }),
              e
            );
          },
          setRequestedCaipNetworks(e, t) {
            this.setAdapterNetworkState(t, { requestedCaipNetworks: e });
          },
          getAllApprovedCaipNetworkIds() {
            let e = [];
            return (
              A.chains.forEach((t) => {
                let n = this.getApprovedCaipNetworkIds(t.namespace);
                e.push(...n);
              }),
              e
            );
          },
          getActiveCaipNetwork: () => A.activeCaipNetwork,
          getActiveCaipAddress: () => A.activeCaipAddress,
          getApprovedCaipNetworkIds(e) {
            let t = A.chains.get(e);
            return t?.networkState?.approvedCaipNetworkIds || [];
          },
          async setApprovedCaipNetworksData(e) {
            let t = this.getNetworkControllerClient(),
              n = await t?.getApprovedCaipNetworksData();
            this.setAdapterNetworkState(e, {
              approvedCaipNetworkIds: n?.approvedCaipNetworkIds,
              supportsAllNetworks: n?.supportsAllNetworks,
            });
          },
          checkIfSupportedNetwork(e, t) {
            let n = t || A.activeCaipNetwork,
              r = this.getRequestedCaipNetworks(e);
            return !r.length || r?.some((e) => e.id === n?.id);
          },
          checkIfSupportedChainId(e) {
            if (!A.activeChain) return !0;
            let t = this.getRequestedCaipNetworks(A.activeChain);
            return t?.some((t) => t.id === e);
          },
          setSmartAccountEnabledNetworks(e, t) {
            this.setAdapterNetworkState(t, { smartAccountEnabledNetworks: e });
          },
          checkIfSmartAccountEnabled() {
            let e = a.p.caipNetworkIdToNumber(A.activeCaipNetwork?.caipNetworkId),
              t = A.activeChain;
            if (!t || !e) return !1;
            let n = this.getNetworkProp('smartAccountEnabledNetworks', t);
            return !!n?.includes(Number(e));
          },
          getActiveNetworkTokenAddress() {
            let e = A.activeCaipNetwork?.chainNamespace || 'eip155',
              t = A.activeCaipNetwork?.id || 1,
              n = u.bq.NATIVE_TOKEN_ADDRESS[e];
            return `${e}:${t}:${n}`;
          },
          showUnsupportedChainUI() {
            f.I.open({ view: 'UnsupportedChain' });
          },
          checkIfNamesSupported() {
            let e = A.activeCaipNetwork;
            return !!(
              e?.chainNamespace && u.bq.NAMES_SUPPORTED_CHAIN_NAMESPACES.includes(e.chainNamespace)
            );
          },
          resetNetwork(e) {
            this.setAdapterNetworkState(e, {
              approvedCaipNetworkIds: void 0,
              supportsAllNetworks: !0,
              smartAccountEnabledNetworks: [],
            });
          },
          resetAccount(e) {
            if (!e) throw Error('Chain is required to set account prop');
            (A.activeCaipAddress = void 0),
              this.setChainAccountData(e, {
                smartAccountDeployed: !1,
                currentTab: 0,
                caipAddress: void 0,
                address: void 0,
                balance: void 0,
                balanceSymbol: void 0,
                profileName: void 0,
                profileImage: void 0,
                addressExplorerUrl: void 0,
                tokenBalance: [],
                connectedWalletInfo: void 0,
                preferredAccountTypes: void 0,
                socialProvider: void 0,
                socialWindow: void 0,
                farcasterUrl: void 0,
                allAccounts: [],
                user: void 0,
                status: 'disconnected',
              }),
              o.ConnectorController.removeConnectorId(e);
          },
          async disconnect(e) {
            let t = (function (e) {
              let t = Array.from(E.state.chains.keys()),
                n = [];
              return (
                e
                  ? (n.push([e, E.state.chains.get(e)]),
                    l(e, s.b.CONNECTOR_ID.WALLET_CONNECT)
                      ? t.forEach((t) => {
                          t !== e &&
                            l(t, s.b.CONNECTOR_ID.WALLET_CONNECT) &&
                            n.push([t, E.state.chains.get(t)]);
                        })
                      : l(e, s.b.CONNECTOR_ID.AUTH) &&
                        t.forEach((t) => {
                          t !== e &&
                            l(t, s.b.CONNECTOR_ID.AUTH) &&
                            n.push([t, E.state.chains.get(t)]);
                        }))
                  : (n = Array.from(E.state.chains.entries())),
                n
              );
            })(e);
            try {
              w.S.resetSend();
              let n = await Promise.allSettled(
                t.map(async ([e, t]) => {
                  try {
                    let { caipAddress: n } = this.getAccountData(e) || {};
                    n &&
                      t.connectionControllerClient?.disconnect &&
                      (await t.connectionControllerClient.disconnect(e)),
                      this.resetAccount(e),
                      this.resetNetwork(e);
                  } catch (t) {
                    throw Error(`Failed to disconnect chain ${e}: ${t.message}`);
                  }
                })
              );
              h.ConnectionController.resetWcConnection();
              let r = n.filter((e) => 'rejected' === e.status);
              if (r.length > 0) throw Error(r.map((e) => e.reason.message).join(', '));
              d.M.deleteConnectedSocialProvider(),
                e
                  ? o.ConnectorController.removeConnectorId(e)
                  : o.ConnectorController.resetConnectorIds(),
                y.X.sendEvent({
                  type: 'track',
                  event: 'DISCONNECT_SUCCESS',
                  properties: { namespace: e || 'all' },
                });
            } catch (e) {
              console.error(e.message || 'Failed to disconnect chains'),
                y.X.sendEvent({
                  type: 'track',
                  event: 'DISCONNECT_ERROR',
                  properties: { message: e.message || 'Failed to disconnect chains' },
                });
            }
          },
          setIsSwitchingNamespace(e) {
            A.isSwitchingNamespace = e;
          },
          getFirstCaipNetworkSupportsAuthConnector() {
            let e = [];
            if (
              (A.chains.forEach((t) => {
                s.b.AUTH_CONNECTOR_SUPPORTED_CHAINS.find((e) => e === t.namespace) &&
                  t.namespace &&
                  e.push(t.namespace);
              }),
              e.length > 0)
            ) {
              let t = e[0];
              return t ? A.chains.get(t)?.caipNetworks?.[0] : void 0;
            }
          },
          getAccountData: (e) =>
            e ? E.state.chains.get(e)?.accountState : p.AccountController.state,
          getNetworkData(e) {
            let t = e || A.activeChain;
            if (t) return E.state.chains.get(t)?.networkState;
          },
          getCaipNetworkByNamespace(e, t) {
            if (!e) return;
            let n = E.state.chains.get(e);
            return (
              n?.caipNetworks?.find((e) => e.id === t) ||
              n?.networkState?.caipNetwork ||
              n?.caipNetworks?.[0]
            );
          },
          getRequestedCaipNetworkIds() {
            let e = o.ConnectorController.state.filterByNamespace;
            return (e ? [A.chains.get(e)] : Array.from(A.chains.values()))
              .flatMap((e) => e?.caipNetworks || [])
              .map((e) => e.caipNetworkId);
          },
          getCaipNetworks: (e) =>
            e ? E.getRequestedCaipNetworks(e) : E.getAllRequestedCaipNetworks(),
        };
    },
    17409: function (e, t, n) {
      'use strict';
      let r;
      n.d(t, {
        ConnectionController: function () {
          return g;
        },
      });
      var i = n(94583),
        a = n(95759),
        s = n(14537),
        o = n(60824),
        l = n(31507),
        u = n(60725),
        c = n(97059),
        d = n(3230),
        p = n(27837),
        h = n(26038),
        y = n(88667),
        f = n(47592);
      let m = (0, i.sj)({ wcError: !1, buffering: !1, status: 'disconnected' }),
        g = {
          state: m,
          subscribeKey: (e, t) => (0, a.VW)(m, e, t),
          _getClient: () => m._client,
          setClient(e) {
            m._client = (0, i.iH)(e);
          },
          async connectWalletConnect() {
            if (s.j.isTelegram() || (s.j.isSafari() && s.j.isIos())) {
              if (r) {
                await r, (r = void 0);
                return;
              }
              if (!s.j.isPairingExpired(m?.wcPairingExpiry)) {
                let e = m.wcUri;
                m.wcUri = e;
                return;
              }
              (r = this._getClient()
                ?.connectWalletConnect?.()
                .catch(() => void 0)),
                (this.state.status = 'connecting'),
                await r,
                (r = void 0),
                (m.wcPairingExpiry = void 0),
                (this.state.status = 'connected');
            } else await this._getClient()?.connectWalletConnect?.();
          },
          async connectExternal(e, t, n = !0) {
            await this._getClient()?.connectExternal?.(e), n && c.R.setActiveNamespace(t);
          },
          async reconnectExternal(e) {
            await this._getClient()?.reconnectExternal?.(e);
            let t = e.chain || c.R.state.activeChain;
            t && d.ConnectorController.setConnectorId(e.id, t);
          },
          async setPreferredAccountType(e, t) {
            h.I.setLoading(!0, c.R.state.activeChain);
            let n = d.ConnectorController.getAuthConnector();
            n &&
              (u.AccountController.setPreferredAccountType(e, t),
              await n.provider.setPreferredAccount(e),
              l.M.setPreferredAccountTypes(
                u.AccountController.state.preferredAccountTypes ?? { [t]: e }
              ),
              await this.reconnectExternal(n),
              h.I.setLoading(!1, c.R.state.activeChain),
              p.X.sendEvent({
                type: 'track',
                event: 'SET_PREFERRED_ACCOUNT_TYPE',
                properties: {
                  accountType: e,
                  network: c.R.state.activeCaipNetwork?.caipNetworkId || '',
                },
              }));
          },
          async signMessage(e) {
            return this._getClient()?.signMessage(e);
          },
          parseUnits(e, t) {
            return this._getClient()?.parseUnits(e, t);
          },
          formatUnits(e, t) {
            return this._getClient()?.formatUnits(e, t);
          },
          async sendTransaction(e) {
            return this._getClient()?.sendTransaction(e);
          },
          async getCapabilities(e) {
            return this._getClient()?.getCapabilities(e);
          },
          async grantPermissions(e) {
            return this._getClient()?.grantPermissions(e);
          },
          async walletGetAssets(e) {
            return this._getClient()?.walletGetAssets(e) ?? {};
          },
          async estimateGas(e) {
            return this._getClient()?.estimateGas(e);
          },
          async writeContract(e) {
            return this._getClient()?.writeContract(e);
          },
          async getEnsAddress(e) {
            return this._getClient()?.getEnsAddress(e);
          },
          async getEnsAvatar(e) {
            return this._getClient()?.getEnsAvatar(e);
          },
          checkInstalled(e) {
            return this._getClient()?.checkInstalled?.(e) || !1;
          },
          resetWcConnection() {
            (m.wcUri = void 0),
              (m.wcPairingExpiry = void 0),
              (m.wcLinking = void 0),
              (m.recentWallet = void 0),
              (m.status = 'disconnected'),
              f.s.resetTransactions(),
              l.M.deleteWalletConnectDeepLink();
          },
          resetUri() {
            (m.wcUri = void 0), (m.wcPairingExpiry = void 0);
          },
          finalizeWcConnection() {
            let { wcLinking: e, recentWallet: t } = g.state;
            e && l.M.setWalletConnectDeepLink(e),
              t && l.M.setAppKitRecent(t),
              p.X.sendEvent({
                type: 'track',
                event: 'CONNECT_SUCCESS',
                properties: {
                  method: e ? 'mobile' : 'qrcode',
                  name: y.RouterController.state.data?.wallet?.name || 'Unknown',
                },
              });
          },
          setWcBasic(e) {
            m.wcBasic = e;
          },
          setUri(e) {
            (m.wcUri = e), (m.wcPairingExpiry = s.j.getPairingExpiry());
          },
          setWcLinking(e) {
            m.wcLinking = e;
          },
          setWcError(e) {
            (m.wcError = e), (m.buffering = !1);
          },
          setRecentWallet(e) {
            m.recentWallet = e;
          },
          setBuffering(e) {
            m.buffering = e;
          },
          setStatus(e) {
            m.status = e;
          },
          async disconnect(e) {
            try {
              h.I.setLoading(!0, e),
                await o.w.clearSessions(),
                await c.R.disconnect(e),
                h.I.setLoading(!1, e),
                d.ConnectorController.setFilterByNamespace(void 0);
            } catch (e) {
              throw Error('Failed to disconnect');
            }
          },
        };
    },
    3230: function (e, t, n) {
      'use strict';
      n.d(t, {
        ConnectorController: function () {
          return m;
        },
      });
      var r = n(94583),
        i = n(95759),
        a = n(49786),
        s = n(29931),
        o = n(97059);
      let l = {
        handleSolanaDeeplinkRedirect(e) {
          if (o.R.state.activeChain === a.b.CHAIN.SOLANA) {
            let t = window.location.href,
              n = encodeURIComponent(t);
            if ('Phantom' === e && !('phantom' in window)) {
              let e = t.startsWith('https') ? 'https' : 'http',
                r = t.split('/')[2],
                i = encodeURIComponent(`${e}://${r}`);
              window.location.href = `https://phantom.app/ul/browse/${n}?ref=${i}`;
            }
            'Coinbase Wallet' !== e ||
              'coinbaseSolana' in window ||
              (window.location.href = `https://go.cb-w.com/dapp?cb_url=${n}`);
          }
        },
      };
      var u = n(31507),
        c = n(82093),
        d = n(8924),
        p = n(88667),
        h = n(44744);
      let y = { eip155: void 0, solana: void 0, polkadot: void 0, bip122: void 0 },
        f = (0, r.sj)({
          allConnectors: [],
          connectors: [],
          activeConnector: void 0,
          filterByNamespace: void 0,
          activeConnectorIds: { ...y },
        }),
        m = {
          state: f,
          subscribe: (e) =>
            (0, r.Ld)(f, () => {
              e(f);
            }),
          subscribeKey: (e, t) => (0, i.VW)(f, e, t),
          initialize(e) {
            e.forEach((e) => {
              let t = u.M.getConnectedConnectorId(e);
              t && this.setConnectorId(t, e);
            });
          },
          setActiveConnector(e) {
            e && (f.activeConnector = (0, r.iH)(e));
          },
          setConnectors(e) {
            e
              .filter(
                (e) =>
                  !f.allConnectors.some(
                    (t) =>
                      t.id === e.id &&
                      this.getConnectorName(t.name) === this.getConnectorName(e.name) &&
                      t.chain === e.chain
                  )
              )
              .forEach((e) => {
                'MULTI_CHAIN' !== e.type && f.allConnectors.push((0, r.iH)(e));
              }),
              (f.connectors = this.mergeMultiChainConnectors(f.allConnectors));
          },
          removeAdapter(e) {
            (f.allConnectors = f.allConnectors.filter((t) => t.chain !== e)),
              (f.connectors = this.mergeMultiChainConnectors(f.allConnectors));
          },
          mergeMultiChainConnectors(e) {
            let t = this.generateConnectorMapByName(e),
              n = [];
            return (
              t.forEach((e) => {
                let t = e[0],
                  r = t?.id === a.b.CONNECTOR_ID.AUTH;
                e.length > 1 && t
                  ? n.push({
                      name: t.name,
                      imageUrl: t.imageUrl,
                      imageId: t.imageId,
                      connectors: [...e],
                      type: r ? 'AUTH' : 'MULTI_CHAIN',
                      chain: 'eip155',
                      id: t?.id || '',
                    })
                  : t && n.push(t);
              }),
              n
            );
          },
          generateConnectorMapByName(e) {
            let t = new Map();
            return (
              e.forEach((e) => {
                let { name: n } = e,
                  r = this.getConnectorName(n);
                if (!r) return;
                let i = t.get(r) || [];
                i.find((t) => t.chain === e.chain) || i.push(e), t.set(r, i);
              }),
              t
            );
          },
          getConnectorName: (e) => (e && { 'Trust Wallet': 'Trust' }[e]) || e,
          getUniqueConnectorsByName(e) {
            let t = [];
            return (
              e.forEach((e) => {
                t.find((t) => t.chain === e.chain) || t.push(e);
              }),
              t
            );
          },
          addConnector(e) {
            if (e.id === a.b.CONNECTOR_ID.AUTH) {
              let t = (0, r.CO)(d.OptionsController.state),
                n = h.ThemeController.getSnapshot().themeMode,
                i = h.ThemeController.getSnapshot().themeVariables;
              e?.provider?.syncDappData?.({
                metadata: t.metadata,
                sdkVersion: t.sdkVersion,
                projectId: t.projectId,
                sdkType: t.sdkType,
              }),
                e?.provider?.syncTheme({
                  themeMode: n,
                  themeVariables: i,
                  w3mThemeVariables: s.t(i, n),
                }),
                this.setConnectors([e]);
            } else this.setConnectors([e]);
          },
          getAuthConnector(e) {
            let t = e || o.R.state.activeChain,
              n = f.connectors.find((e) => e.id === a.b.CONNECTOR_ID.AUTH);
            return n
              ? n?.connectors?.length
                ? n.connectors.find((e) => e.chain === t)
                : n
              : void 0;
          },
          getAnnouncedConnectorRdns: () =>
            f.connectors.filter((e) => 'ANNOUNCED' === e.type).map((e) => e.info?.rdns),
          getConnectorById: (e) => f.allConnectors.find((t) => t.id === e),
          getConnector: (e, t) =>
            f.allConnectors
              .filter((e) => e.chain === o.R.state.activeChain)
              .find((n) => n.explorerId === e || n.info?.rdns === t),
          syncIfAuthConnector(e) {
            if ('ID_AUTH' !== e.id) return;
            let t = (0, r.CO)(d.OptionsController.state),
              n = h.ThemeController.getSnapshot().themeMode,
              i = h.ThemeController.getSnapshot().themeVariables;
            e?.provider?.syncDappData?.({
              metadata: t.metadata,
              sdkVersion: t.sdkVersion,
              sdkType: t.sdkType,
              projectId: t.projectId,
            }),
              e.provider.syncTheme({
                themeMode: n,
                themeVariables: i,
                w3mThemeVariables: (0, s.t)(i, n),
              });
          },
          getConnectorsByNamespace(e) {
            let t = f.allConnectors.filter((t) => t.chain === e);
            return this.mergeMultiChainConnectors(t);
          },
          selectWalletConnector(e) {
            let t = m.getConnector(e.id, e.rdns);
            o.R.state.activeChain === a.b.CHAIN.SOLANA &&
              l.handleSolanaDeeplinkRedirect(t?.name || e.name || ''),
              t
                ? p.RouterController.push('ConnectingExternal', { connector: t })
                : p.RouterController.push('ConnectingWalletConnect', { wallet: e });
          },
          getConnectors(e) {
            return e
              ? this.getConnectorsByNamespace(e)
              : this.mergeMultiChainConnectors(f.allConnectors);
          },
          setFilterByNamespace(e) {
            (f.filterByNamespace = e),
              (f.connectors = this.getConnectors(e)),
              c.ApiController.setFilterByNamespace(e);
          },
          setConnectorId(e, t) {
            e &&
              ((f.activeConnectorIds = { ...f.activeConnectorIds, [t]: e }),
              u.M.setConnectedConnectorId(t, e));
          },
          removeConnectorId(e) {
            (f.activeConnectorIds = { ...f.activeConnectorIds, [e]: void 0 }),
              u.M.deleteConnectedConnectorId(e);
          },
          getConnectorId(e) {
            if (e) return f.activeConnectorIds[e];
          },
          isConnected: (e) =>
            e ? !!f.activeConnectorIds[e] : Object.values(f.activeConnectorIds).some((e) => !!e),
          resetConnectorIds() {
            f.activeConnectorIds = { ...y };
          },
        };
    },
    28119: function (e, t, n) {
      'use strict';
      n.d(t, {
        a: function () {
          return y;
        },
      });
      var r = n(94583),
        i = n(95759);
      let a = {
        convertEVMChainIdToCoinType(e) {
          if (e >= 2147483648) throw Error('Invalid chainId');
          return (2147483648 | e) >>> 0;
        },
      };
      var s = n(31507),
        o = n(60725),
        l = n(98583),
        u = n(97059),
        c = n(17409),
        d = n(3230),
        p = n(88667);
      let h = (0, r.sj)({ suggestions: [], loading: !1 }),
        y = {
          state: h,
          subscribe: (e) => (0, r.Ld)(h, () => e(h)),
          subscribeKey: (e, t) => (0, i.VW)(h, e, t),
          async resolveName(e) {
            try {
              return await l.L.lookupEnsName(e);
            } catch (e) {
              throw Error(e?.reasons?.[0]?.description || 'Error resolving name');
            }
          },
          async isNameRegistered(e) {
            try {
              return await l.L.lookupEnsName(e), !0;
            } catch {
              return !1;
            }
          },
          async getSuggestions(e) {
            try {
              (h.loading = !0), (h.suggestions = []);
              let t = await l.L.getEnsNameSuggestions(e);
              return (
                (h.suggestions = t.suggestions.map((e) => ({ ...e, name: e.name })) || []),
                h.suggestions
              );
            } catch (e) {
              throw Error(this.parseEnsApiError(e, 'Error fetching name suggestions'));
            } finally {
              h.loading = !1;
            }
          },
          async getNamesForAddress(e) {
            try {
              if (!u.R.state.activeCaipNetwork) return [];
              let t = s.M.getEnsFromCacheForAddress(e);
              if (t) return t;
              let n = await l.L.reverseLookupEnsName({ address: e });
              return s.M.updateEnsCache({ address: e, ens: n, timestamp: Date.now() }), n;
            } catch (e) {
              throw Error(this.parseEnsApiError(e, 'Error fetching names for address'));
            }
          },
          async registerName(e) {
            let t = u.R.state.activeCaipNetwork;
            if (!t) throw Error('Network not found');
            let n = o.AccountController.state.address,
              r = d.ConnectorController.getAuthConnector();
            if (!n || !r) throw Error('Address or auth connector not found');
            h.loading = !0;
            try {
              let r = JSON.stringify({
                name: e,
                attributes: {},
                timestamp: Math.floor(Date.now() / 1e3),
              });
              p.RouterController.pushTransactionStack({
                view: 'RegisterAccountNameSuccess',
                goBack: !1,
                replace: !0,
                onCancel() {
                  h.loading = !1;
                },
              });
              let i = await c.ConnectionController.signMessage(r),
                s = t.id;
              if (!s) throw Error('Network not found');
              let u = a.convertEVMChainIdToCoinType(Number(s));
              await l.L.registerEnsName({ coinType: u, address: n, signature: i, message: r }),
                o.AccountController.setProfileName(e, t.chainNamespace),
                p.RouterController.replace('RegisterAccountNameSuccess');
            } catch (n) {
              let t = this.parseEnsApiError(n, `Error registering name ${e}`);
              throw (p.RouterController.replace('RegisterAccountName'), Error(t));
            } finally {
              h.loading = !1;
            }
          },
          validateName: (e) => /^[a-zA-Z0-9-]{4,}$/u.test(e),
          parseEnsApiError: (e, t) => e?.reasons?.[0]?.description || t,
        };
    },
    27837: function (e, t, n) {
      'use strict';
      n.d(t, {
        X: function () {
          return f;
        },
      });
      var r = n(94583),
        i = n(49786),
        a = n(86923),
        s = n(14537),
        o = n(83118),
        l = n(60725),
        u = n(10423),
        c = n(8924);
      let d = s.j.getAnalyticsUrl(),
        p = new o.V({ baseUrl: d, clientId: null }),
        h = ['MODAL_CREATED'],
        y = (0, r.sj)({
          timestamp: Date.now(),
          reportedErrors: {},
          data: { type: 'track', event: 'MODAL_CREATED' },
        }),
        f = {
          state: y,
          subscribe: (e) => (0, r.Ld)(y, () => e(y)),
          getSdkProperties() {
            let { projectId: e, sdkType: t, sdkVersion: n } = c.OptionsController.state;
            return { projectId: e, st: t, sv: n || 'html-wagmi-4.2.2' };
          },
          async _sendAnalyticsEvent(e) {
            try {
              let t = l.AccountController.state.address;
              if (h.includes(e.data.event) || 'undefined' == typeof window) return;
              await p.post({
                path: '/e',
                params: f.getSdkProperties(),
                body: {
                  eventId: s.j.getUUID(),
                  url: window.location.href,
                  domain: window.location.hostname,
                  timestamp: e.timestamp,
                  props: { ...e.data, address: t },
                },
              }),
                (y.reportedErrors.FORBIDDEN = !1);
            } catch (e) {
              e instanceof Error &&
                e.cause instanceof Response &&
                e.cause.status === i.b.HTTP_STATUS_CODES.FORBIDDEN &&
                !y.reportedErrors.FORBIDDEN &&
                (u.AlertController.open(
                  {
                    shortMessage: 'Invalid App Configuration',
                    longMessage: `Origin ${(0, a.$U)() ? window.origin : 'uknown'} not found on Allowlist - update configuration on cloud.reown.com`,
                  },
                  'error'
                ),
                (y.reportedErrors.FORBIDDEN = !0));
            }
          },
          sendEvent(e) {
            (y.timestamp = Date.now()),
              (y.data = e),
              c.OptionsController.state.features?.analytics && f._sendAnalyticsEvent(y);
          },
        };
    },
    26038: function (e, t, n) {
      'use strict';
      n.d(t, {
        I: function () {
          return m;
        },
      });
      var r = n(94583),
        i = n(95759),
        a = n(14537),
        s = n(60725),
        o = n(82093),
        l = n(97059),
        u = n(17409),
        c = n(3230),
        d = n(27837),
        p = n(8924),
        h = n(61564),
        y = n(88667);
      let f = (0, r.sj)({
          loading: !1,
          loadingNamespaceMap: new Map(),
          open: !1,
          shake: !1,
          namespace: void 0,
        }),
        m = {
          state: f,
          subscribe: (e) => (0, r.Ld)(f, () => e(f)),
          subscribeKey: (e, t) => (0, i.VW)(f, e, t),
          async open(e) {
            let t = 'connected' === s.AccountController.state.status;
            u.ConnectionController.state.wcBasic
              ? o.ApiController.prefetch({ fetchNetworkImages: !1, fetchConnectorImages: !1 })
              : await o.ApiController.prefetch({
                  fetchConnectorImages: !t,
                  fetchFeaturedWallets: !t,
                  fetchRecommendedWallets: !t,
                }),
              e?.namespace
                ? (await l.R.switchActiveNamespace(e.namespace), m.setLoading(!0, e.namespace))
                : m.setLoading(!0),
              c.ConnectorController.setFilterByNamespace(e?.namespace);
            let n = l.R.getAccountData(e?.namespace)?.caipAddress;
            l.R.state.noAdapters && !n
              ? a.j.isMobile()
                ? y.RouterController.reset('AllWallets')
                : y.RouterController.reset('ConnectingWalletConnectBasic')
              : e?.view
                ? y.RouterController.reset(e.view, e.data)
                : n
                  ? y.RouterController.reset('Account')
                  : y.RouterController.reset('Connect'),
              (f.open = !0),
              h.I.set({ open: !0 }),
              d.X.sendEvent({ type: 'track', event: 'MODAL_OPEN', properties: { connected: !!n } });
          },
          close() {
            let e = p.OptionsController.state.enableEmbedded,
              t = !!l.R.state.activeCaipAddress;
            f.open &&
              d.X.sendEvent({ type: 'track', event: 'MODAL_CLOSE', properties: { connected: t } }),
              (f.open = !1),
              m.clearLoading(),
              e
                ? t
                  ? y.RouterController.replace('Account')
                  : y.RouterController.push('Connect')
                : h.I.set({ open: !1 }),
              u.ConnectionController.resetUri();
          },
          setLoading(e, t) {
            t && f.loadingNamespaceMap.set(t, e), (f.loading = e), h.I.set({ loading: e });
          },
          clearLoading() {
            f.loadingNamespaceMap.clear(), (f.loading = !1);
          },
          shake() {
            f.shake ||
              ((f.shake = !0),
              setTimeout(() => {
                f.shake = !1;
              }, 500));
          },
        };
    },
    8924: function (e, t, n) {
      'use strict';
      n.d(t, {
        OptionsController: function () {
          return u;
        },
      });
      var r = n(94583),
        i = n(95759),
        a = n(49162),
        s = n(14537);
      let o = {
          getFeatureValue(e, t) {
            let n = t?.[e];
            return void 0 === n ? a.bq.DEFAULT_FEATURES[e] : n;
          },
          filterSocialsByPlatform(e) {
            if (!e || !e.length) return e;
            if (s.j.isTelegram()) {
              if (s.j.isIos()) return e.filter((e) => 'google' !== e);
              if (s.j.isMac()) return e.filter((e) => 'x' !== e);
              if (s.j.isAndroid()) return e.filter((e) => !['facebook', 'x'].includes(e));
            }
            return e;
          },
        },
        l = (0, r.sj)({
          features: a.bq.DEFAULT_FEATURES,
          projectId: '',
          sdkType: 'appkit',
          sdkVersion: 'html-wagmi-undefined',
          defaultAccountTypes: {
            solana: 'eoa',
            bip122: 'payment',
            polkadot: 'eoa',
            eip155: 'smartAccount',
          },
          enableNetworkSwitch: !0,
        }),
        u = {
          state: l,
          subscribeKey: (e, t) => (0, i.VW)(l, e, t),
          setOptions(e) {
            Object.assign(l, e);
          },
          setFeatures(e) {
            if (!e) return;
            l.features || (l.features = a.bq.DEFAULT_FEATURES);
            let t = { ...l.features, ...e };
            (l.features = t),
              l.features.socials &&
                (l.features.socials = o.filterSocialsByPlatform(l.features.socials));
          },
          setProjectId(e) {
            l.projectId = e;
          },
          setCustomRpcUrls(e) {
            l.customRpcUrls = e;
          },
          setAllWallets(e) {
            l.allWallets = e;
          },
          setIncludeWalletIds(e) {
            l.includeWalletIds = e;
          },
          setExcludeWalletIds(e) {
            l.excludeWalletIds = e;
          },
          setFeaturedWalletIds(e) {
            l.featuredWalletIds = e;
          },
          setTokens(e) {
            l.tokens = e;
          },
          setTermsConditionsUrl(e) {
            l.termsConditionsUrl = e;
          },
          setPrivacyPolicyUrl(e) {
            l.privacyPolicyUrl = e;
          },
          setCustomWallets(e) {
            l.customWallets = e;
          },
          setIsSiweEnabled(e) {
            l.isSiweEnabled = e;
          },
          setIsUniversalProvider(e) {
            l.isUniversalProvider = e;
          },
          setSdkVersion(e) {
            l.sdkVersion = e;
          },
          setMetadata(e) {
            l.metadata = e;
          },
          setDisableAppend(e) {
            l.disableAppend = e;
          },
          setEIP6963Enabled(e) {
            l.enableEIP6963 = e;
          },
          setDebug(e) {
            l.debug = e;
          },
          setEnableWalletConnect(e) {
            l.enableWalletConnect = e;
          },
          setEnableWalletGuide(e) {
            l.enableWalletGuide = e;
          },
          setEnableAuthLogger(e) {
            l.enableAuthLogger = e;
          },
          setEnableWallets(e) {
            l.enableWallets = e;
          },
          setHasMultipleAddresses(e) {
            l.hasMultipleAddresses = e;
          },
          setSIWX(e) {
            l.siwx = e;
          },
          setConnectMethodsOrder(e) {
            l.features = { ...l.features, connectMethodsOrder: e };
          },
          setWalletFeaturesOrder(e) {
            l.features = { ...l.features, walletFeaturesOrder: e };
          },
          setSocialsOrder(e) {
            l.features = { ...l.features, socials: e };
          },
          setCollapseWallets(e) {
            l.features = { ...l.features, collapseWallets: e };
          },
          setEnableEmbedded(e) {
            l.enableEmbedded = e;
          },
          setAllowUnsupportedChain(e) {
            l.allowUnsupportedChain = e;
          },
          setManualWCControl(e) {
            l.manualWCControl = e;
          },
          setEnableNetworkSwitch(e) {
            l.enableNetworkSwitch = e;
          },
          setDefaultAccountTypes(e = {}) {
            Object.entries(e).forEach(([e, t]) => {
              t && (l.defaultAccountTypes[e] = t);
            });
          },
          setUniversalProviderConfigOverride(e) {
            l.universalProviderConfigOverride = e;
          },
          getUniversalProviderConfigOverride: () => l.universalProviderConfigOverride,
          getSnapshot: () => (0, r.CO)(l),
        };
    },
    61564: function (e, t, n) {
      'use strict';
      n.d(t, {
        I: function () {
          return s;
        },
      });
      var r = n(94583),
        i = n(95759);
      let a = (0, r.sj)({
          loading: !1,
          open: !1,
          selectedNetworkId: void 0,
          activeChain: void 0,
          initialized: !1,
        }),
        s = {
          state: a,
          subscribe: (e) => (0, r.Ld)(a, () => e(a)),
          subscribeOpen: (e) => (0, i.VW)(a, 'open', e),
          set(e) {
            Object.assign(a, { ...a, ...e });
          },
        };
    },
    88667: function (e, t, n) {
      'use strict';
      n.d(t, {
        RouterController: function () {
          return d;
        },
      });
      var r = n(94583),
        i = n(95759),
        a = n(60725),
        s = n(97059),
        o = n(3230),
        l = n(26038),
        u = n(8924);
      let c = (0, r.sj)({ view: 'Connect', history: ['Connect'], transactionStack: [] }),
        d = {
          state: c,
          subscribeKey: (e, t) => (0, i.VW)(c, e, t),
          pushTransactionStack(e) {
            c.transactionStack.push(e);
          },
          popTransactionStack(e) {
            let t = c.transactionStack.pop();
            if (t) {
              if (e) this.goBack(), t?.onCancel?.();
              else {
                if (t.goBack) this.goBack();
                else if (t.replace) {
                  let e = c.history.indexOf('ConnectingSiwe');
                  e > 0 ? this.goBackToIndex(e - 1) : (l.I.close(), (c.history = []));
                } else t.view && this.reset(t.view);
                t?.onSuccess?.();
              }
            }
          },
          push(e, t) {
            e !== c.view && ((c.view = e), c.history.push(e), (c.data = t));
          },
          reset(e, t) {
            (c.view = e), (c.history = [e]), (c.data = t);
          },
          replace(e, t) {
            c.history.at(-1) !== e &&
              ((c.view = e), (c.history[c.history.length - 1] = e), (c.data = t));
          },
          goBack() {
            let e = !s.R.state.activeCaipAddress && 'ConnectingFarcaster' === this.state.view;
            if (c.history.length > 1 && !c.history.includes('UnsupportedChain')) {
              c.history.pop();
              let [e] = c.history.slice(-1);
              e && (c.view = e);
            } else l.I.close();
            c.data?.wallet && (c.data.wallet = void 0),
              setTimeout(() => {
                if (e) {
                  a.AccountController.setFarcasterUrl(void 0, s.R.state.activeChain);
                  let e = o.ConnectorController.getAuthConnector();
                  e?.provider?.reload();
                  let t = (0, r.CO)(u.OptionsController.state);
                  e?.provider?.syncDappData?.({
                    metadata: t.metadata,
                    sdkVersion: t.sdkVersion,
                    projectId: t.projectId,
                    sdkType: t.sdkType,
                  });
                }
              }, 100);
          },
          goBackToIndex(e) {
            if (c.history.length > 1) {
              c.history = c.history.slice(0, e + 1);
              let [t] = c.history.slice(-1);
              t && (c.view = t);
            }
          },
        };
    },
    53207: function (e, t, n) {
      'use strict';
      n.d(t, {
        S: function () {
          return T;
        },
      });
      var r = n(94583),
        i = n(95759),
        a = n(91709);
      let s = [
          {
            type: 'function',
            name: 'transfer',
            stateMutability: 'nonpayable',
            inputs: [
              { name: '_to', type: 'address' },
              { name: '_value', type: 'uint256' },
            ],
            outputs: [{ name: '', type: 'bool' }],
          },
          {
            type: 'function',
            name: 'transferFrom',
            stateMutability: 'nonpayable',
            inputs: [
              { name: '_from', type: 'address' },
              { name: '_to', type: 'address' },
              { name: '_value', type: 'uint256' },
            ],
            outputs: [{ name: '', type: 'bool' }],
          },
        ],
        o = [
          {
            type: 'function',
            name: 'transfer',
            stateMutability: 'nonpayable',
            inputs: [
              { name: 'recipient', type: 'address' },
              { name: 'amount', type: 'uint256' },
            ],
            outputs: [],
          },
          {
            type: 'function',
            name: 'transferFrom',
            stateMutability: 'nonpayable',
            inputs: [
              { name: 'sender', type: 'address' },
              { name: 'recipient', type: 'address' },
              { name: 'amount', type: 'uint256' },
            ],
            outputs: [{ name: '', type: 'bool' }],
          },
        ];
      var l = n(49786);
      let u = { getERC20Abi: (e) => (l.b.USDT_CONTRACT_ADDRESSES.includes(e) ? o : s) };
      var c = n(41428),
        d = n(49162),
        p = n(14537),
        h = n(80582),
        y = n(60725),
        f = n(97059),
        m = n(17409),
        g = n(27837),
        b = n(88667),
        w = n(19165);
      let v = (0, r.sj)({ tokenBalances: [], loading: !1 }),
        T = {
          state: v,
          subscribe: (e) => (0, r.Ld)(v, () => e(v)),
          subscribeKey: (e, t) => (0, i.VW)(v, e, t),
          setToken(e) {
            e && (v.token = (0, r.iH)(e));
          },
          setTokenAmount(e) {
            v.sendTokenAmount = e;
          },
          setReceiverAddress(e) {
            v.receiverAddress = e;
          },
          setReceiverProfileImageUrl(e) {
            v.receiverProfileImageUrl = e;
          },
          setReceiverProfileName(e) {
            v.receiverProfileName = e;
          },
          setGasPrice(e) {
            v.gasPrice = e;
          },
          setGasPriceInUsd(e) {
            v.gasPriceInUSD = e;
          },
          setNetworkBalanceInUsd(e) {
            v.networkBalanceInUSD = e;
          },
          setLoading(e) {
            v.loading = e;
          },
          sendToken() {
            switch (f.R.state.activeCaipNetwork?.chainNamespace) {
              case 'eip155':
                this.sendEvmToken();
                return;
              case 'solana':
                this.sendSolanaToken();
                return;
              default:
                throw Error('Unsupported chain');
            }
          },
          sendEvmToken() {
            let e = f.R.state.activeChain,
              t = y.AccountController.state.preferredAccountTypes?.[e];
            this.state.token?.address && this.state.sendTokenAmount && this.state.receiverAddress
              ? (g.X.sendEvent({
                  type: 'track',
                  event: 'SEND_INITIATED',
                  properties: {
                    isSmartAccount: t === c.y_.ACCOUNT_TYPES.SMART_ACCOUNT,
                    token: this.state.token.address,
                    amount: this.state.sendTokenAmount,
                    network: f.R.state.activeCaipNetwork?.caipNetworkId || '',
                  },
                }),
                this.sendERC20Token({
                  receiverAddress: this.state.receiverAddress,
                  tokenAddress: this.state.token.address,
                  sendTokenAmount: this.state.sendTokenAmount,
                  decimals: this.state.token.quantity.decimals,
                }))
              : this.state.receiverAddress &&
                this.state.sendTokenAmount &&
                this.state.gasPrice &&
                this.state.token?.quantity.decimals &&
                (g.X.sendEvent({
                  type: 'track',
                  event: 'SEND_INITIATED',
                  properties: {
                    isSmartAccount: t === c.y_.ACCOUNT_TYPES.SMART_ACCOUNT,
                    token: this.state.token?.symbol,
                    amount: this.state.sendTokenAmount,
                    network: f.R.state.activeCaipNetwork?.caipNetworkId || '',
                  },
                }),
                this.sendNativeToken({
                  receiverAddress: this.state.receiverAddress,
                  sendTokenAmount: this.state.sendTokenAmount,
                  gasPrice: this.state.gasPrice,
                  decimals: this.state.token.quantity.decimals,
                }));
          },
          async fetchTokenBalance(e) {
            v.loading = !0;
            let t = f.R.state.activeCaipNetwork?.caipNetworkId,
              n = f.R.state.activeCaipNetwork?.chainNamespace,
              r = f.R.state.activeCaipAddress,
              i = r ? p.j.getPlainAddress(r) : void 0;
            if (v.lastRetry && !p.j.isAllowedRetry(v.lastRetry, 30 * d.bq.ONE_SEC_MS))
              return (v.loading = !1), [];
            try {
              if (i && t && n) {
                let e = await h.y.getMyTokensWithBalance();
                return (v.tokenBalances = e), (v.lastRetry = void 0), e;
              }
            } catch (t) {
              (v.lastRetry = Date.now()),
                e?.(t),
                w.SnackController.showError('Token Balance Unavailable');
            } finally {
              v.loading = !1;
            }
            return [];
          },
          fetchNetworkBalance() {
            if (0 === v.tokenBalances.length) return;
            let e = h.y.mapBalancesToSwapTokens(v.tokenBalances);
            if (!e) return;
            let t = e.find((e) => e.address === f.R.getActiveNetworkTokenAddress());
            t &&
              (v.networkBalanceInUSD = t
                ? a.C.multiply(t.quantity.numeric, t.price).toString()
                : '0');
          },
          isInsufficientNetworkTokenForGas: (e, t) =>
            !!a.C.bigNumber(e).eq(0) || a.C.bigNumber(a.C.bigNumber(t || '0')).gt(e),
          hasInsufficientGasFunds() {
            let e = f.R.state.activeChain,
              t = !0;
            return (
              y.AccountController.state.preferredAccountTypes?.[e] ===
              c.y_.ACCOUNT_TYPES.SMART_ACCOUNT
                ? (t = !1)
                : v.networkBalanceInUSD &&
                  (t = this.isInsufficientNetworkTokenForGas(
                    v.networkBalanceInUSD,
                    v.gasPriceInUSD
                  )),
              t
            );
          },
          async sendNativeToken(e) {
            let t = f.R.state.activeChain;
            b.RouterController.pushTransactionStack({ view: 'Account', goBack: !1 });
            let n = e.receiverAddress,
              r = y.AccountController.state.address,
              i = m.ConnectionController.parseUnits(
                e.sendTokenAmount.toString(),
                Number(e.decimals)
              );
            try {
              await m.ConnectionController.sendTransaction({
                chainNamespace: 'eip155',
                to: n,
                address: r,
                data: '0x',
                value: i ?? BigInt(0),
                gasPrice: e.gasPrice,
              }),
                w.SnackController.showSuccess('Transaction started'),
                g.X.sendEvent({
                  type: 'track',
                  event: 'SEND_SUCCESS',
                  properties: {
                    isSmartAccount:
                      y.AccountController.state.preferredAccountTypes?.[t] ===
                      c.y_.ACCOUNT_TYPES.SMART_ACCOUNT,
                    token: this.state.token?.symbol || '',
                    amount: e.sendTokenAmount,
                    network: f.R.state.activeCaipNetwork?.caipNetworkId || '',
                  },
                }),
                this.resetSend();
            } catch (r) {
              console.error('SendController:sendERC20Token - failed to send native token', r);
              let n = r instanceof Error ? r.message : 'Unknown error';
              g.X.sendEvent({
                type: 'track',
                event: 'SEND_ERROR',
                properties: {
                  message: n,
                  isSmartAccount:
                    y.AccountController.state.preferredAccountTypes?.[t] ===
                    c.y_.ACCOUNT_TYPES.SMART_ACCOUNT,
                  token: this.state.token?.symbol || '',
                  amount: e.sendTokenAmount,
                  network: f.R.state.activeCaipNetwork?.caipNetworkId || '',
                },
              }),
                w.SnackController.showError('Something went wrong');
            }
          },
          async sendERC20Token(e) {
            b.RouterController.pushTransactionStack({ view: 'Account', goBack: !1 });
            let t = m.ConnectionController.parseUnits(
              e.sendTokenAmount.toString(),
              Number(e.decimals)
            );
            try {
              if (
                y.AccountController.state.address &&
                e.sendTokenAmount &&
                e.receiverAddress &&
                e.tokenAddress
              ) {
                let n = p.j.getPlainAddress(e.tokenAddress);
                await m.ConnectionController.writeContract({
                  fromAddress: y.AccountController.state.address,
                  tokenAddress: n,
                  args: [e.receiverAddress, t ?? BigInt(0)],
                  method: 'transfer',
                  abi: u.getERC20Abi(n),
                  chainNamespace: 'eip155',
                }),
                  w.SnackController.showSuccess('Transaction started'),
                  this.resetSend();
              }
            } catch (n) {
              console.error('SendController:sendERC20Token - failed to send erc20 token', n);
              let t = n instanceof Error ? n.message : 'Unknown error';
              g.X.sendEvent({
                type: 'track',
                event: 'SEND_ERROR',
                properties: {
                  message: t,
                  isSmartAccount:
                    y.AccountController.state.preferredAccountTypes?.eip155 ===
                    c.y_.ACCOUNT_TYPES.SMART_ACCOUNT,
                  token: this.state.token?.symbol || '',
                  amount: e.sendTokenAmount,
                  network: f.R.state.activeCaipNetwork?.caipNetworkId || '',
                },
              }),
                w.SnackController.showError('Something went wrong');
            }
          },
          sendSolanaToken() {
            if (!this.state.sendTokenAmount || !this.state.receiverAddress) {
              w.SnackController.showError('Please enter a valid amount and receiver address');
              return;
            }
            b.RouterController.pushTransactionStack({ view: 'Account', goBack: !1 }),
              m.ConnectionController.sendTransaction({
                chainNamespace: 'solana',
                to: this.state.receiverAddress,
                value: this.state.sendTokenAmount,
              })
                .then(() => {
                  this.resetSend(), y.AccountController.fetchTokenBalance();
                })
                .catch((e) => {
                  w.SnackController.showError('Failed to send transaction. Please try again.'),
                    console.error(
                      'SendController:sendToken - failed to send solana transaction',
                      e
                    );
                });
          },
          resetSend() {
            (v.token = void 0),
              (v.sendTokenAmount = void 0),
              (v.receiverAddress = void 0),
              (v.receiverProfileImageUrl = void 0),
              (v.receiverProfileName = void 0),
              (v.loading = !1),
              (v.tokenBalances = []);
          },
        };
    },
    19165: function (e, t, n) {
      'use strict';
      n.d(t, {
        SnackController: function () {
          return l;
        },
      });
      var r = n(94583),
        i = n(95759),
        a = n(14537);
      let s = Object.freeze({
          message: '',
          variant: 'success',
          svg: void 0,
          open: !1,
          autoClose: !0,
        }),
        o = (0, r.sj)({ ...s }),
        l = {
          state: o,
          subscribeKey: (e, t) => (0, i.VW)(o, e, t),
          showLoading(e, t = {}) {
            this._showMessage({ message: e, variant: 'loading', ...t });
          },
          showSuccess(e) {
            this._showMessage({ message: e, variant: 'success' });
          },
          showSvg(e, t) {
            this._showMessage({ message: e, svg: t });
          },
          showError(e) {
            let t = a.j.parseError(e);
            this._showMessage({ message: t, variant: 'error' });
          },
          hide() {
            (o.message = s.message),
              (o.variant = s.variant),
              (o.svg = s.svg),
              (o.open = s.open),
              (o.autoClose = s.autoClose);
          },
          _showMessage({ message: e, svg: t, variant: n = 'success', autoClose: r = s.autoClose }) {
            o.open
              ? ((o.open = !1),
                setTimeout(() => {
                  (o.message = e), (o.variant = n), (o.svg = t), (o.open = !0), (o.autoClose = r);
                }, 150))
              : ((o.message = e), (o.variant = n), (o.svg = t), (o.open = !0), (o.autoClose = r));
          },
        };
    },
    44744: function (e, t, n) {
      'use strict';
      n.d(t, {
        ThemeController: function () {
          return o;
        },
      });
      var r = n(94583),
        i = n(29931),
        a = n(3230);
      let s = (0, r.sj)({ themeMode: 'dark', themeVariables: {}, w3mThemeVariables: void 0 }),
        o = {
          state: s,
          subscribe: (e) => (0, r.Ld)(s, () => e(s)),
          setThemeMode(e) {
            s.themeMode = e;
            try {
              let t = a.ConnectorController.getAuthConnector();
              if (t) {
                let n = o.getSnapshot().themeVariables;
                t.provider.syncTheme({
                  themeMode: e,
                  themeVariables: n,
                  w3mThemeVariables: (0, i.t)(n, e),
                });
              }
            } catch {
              console.info('Unable to sync theme to auth connector');
            }
          },
          setThemeVariables(e) {
            s.themeVariables = { ...s.themeVariables, ...e };
            try {
              let e = a.ConnectorController.getAuthConnector();
              if (e) {
                let t = o.getSnapshot().themeVariables;
                e.provider.syncTheme({
                  themeVariables: t,
                  w3mThemeVariables: (0, i.t)(s.themeVariables, s.themeMode),
                });
              }
            } catch {
              console.info('Unable to sync theme to auth connector');
            }
          },
          getSnapshot: () => (0, r.CO)(s),
        };
    },
    47592: function (e, t, n) {
      'use strict';
      n.d(t, {
        s: function () {
          return p;
        },
      });
      var r = n(94583),
        i = n(41428),
        a = n(60725),
        s = n(98583),
        o = n(97059),
        l = n(27837),
        u = n(8924),
        c = n(19165);
      let d = (0, r.sj)({
          transactions: [],
          coinbaseTransactions: {},
          transactionsByYear: {},
          lastNetworkInView: void 0,
          loading: !1,
          empty: !1,
          next: void 0,
        }),
        p = {
          state: d,
          subscribe: (e) => (0, r.Ld)(d, () => e(d)),
          setLastNetworkInView(e) {
            d.lastNetworkInView = e;
          },
          async fetchTransactions(e, t) {
            if (!e) throw Error("Transactions can't be fetched without an accountAddress");
            d.loading = !0;
            try {
              let n = await s.L.fetchTransactions({
                  account: e,
                  cursor: d.next,
                  onramp: t,
                  cache: 'coinbase' === t ? 'no-cache' : void 0,
                  chainId: o.R.state.activeCaipNetwork?.caipNetworkId,
                }),
                r = this.filterSpamTransactions(n.data),
                i = this.filterByConnectedChain(r),
                a = [...d.transactions, ...i];
              (d.loading = !1),
                'coinbase' === t
                  ? (d.coinbaseTransactions = this.groupTransactionsByYearAndMonth(
                      d.coinbaseTransactions,
                      n.data
                    ))
                  : ((d.transactions = a),
                    (d.transactionsByYear = this.groupTransactionsByYearAndMonth(
                      d.transactionsByYear,
                      i
                    ))),
                (d.empty = 0 === a.length),
                (d.next = n.next ? n.next : void 0);
            } catch (n) {
              let t = o.R.state.activeChain;
              l.X.sendEvent({
                type: 'track',
                event: 'ERROR_FETCH_TRANSACTIONS',
                properties: {
                  address: e,
                  projectId: u.OptionsController.state.projectId,
                  cursor: d.next,
                  isSmartAccount:
                    a.AccountController.state.preferredAccountTypes?.[t] ===
                    i.y_.ACCOUNT_TYPES.SMART_ACCOUNT,
                },
              }),
                c.SnackController.showError('Failed to fetch transactions'),
                (d.loading = !1),
                (d.empty = !0),
                (d.next = void 0);
            }
          },
          groupTransactionsByYearAndMonth: (e = {}, t = []) => (
            t.forEach((t) => {
              let n = new Date(t.metadata.minedAt).getFullYear(),
                r = new Date(t.metadata.minedAt).getMonth(),
                i = e[n] ?? {},
                a = (i[r] ?? []).filter((e) => e.id !== t.id);
              e[n] = {
                ...i,
                [r]: [...a, t].sort(
                  (e, t) =>
                    new Date(t.metadata.minedAt).getTime() - new Date(e.metadata.minedAt).getTime()
                ),
              };
            }),
            e
          ),
          filterSpamTransactions: (e) =>
            e.filter((e) => !e.transfers.every((e) => e.nft_info?.flags.is_spam === !0)),
          filterByConnectedChain(e) {
            let t = o.R.state.activeCaipNetwork?.caipNetworkId;
            return e.filter((e) => e.metadata.chain === t);
          },
          clearCursor() {
            d.next = void 0;
          },
          resetTransactions() {
            (d.transactions = []),
              (d.transactionsByYear = {}),
              (d.lastNetworkInView = void 0),
              (d.loading = !1),
              (d.empty = !1),
              (d.next = void 0);
          },
        };
    },
    94498: function (e, t, n) {
      'use strict';
      n.d(t, {
        f: function () {
          return l;
        },
      });
      var r = n(94583),
        i = n(82093),
        a = n(24979);
      let s = {
          eip155: 'ba0ba0cd-17c6-4806-ad93-f9d174f17900',
          solana: 'a1b58899-f671-4276-6a5e-56ca5bd59700',
          polkadot: '',
          bip122: '0b4838db-0161-4ffe-022d-532bf03dba00',
        },
        o = (0, r.sj)({ networkImagePromises: {} }),
        l = {
          async fetchWalletImage(e) {
            if (e) return await i.ApiController._fetchWalletImage(e), this.getWalletImageById(e);
          },
          async fetchNetworkImage(e) {
            if (e)
              return (
                this.getNetworkImageById(e) ||
                (o.networkImagePromises[e] ||
                  (o.networkImagePromises[e] = i.ApiController._fetchNetworkImage(e)),
                await o.networkImagePromises[e],
                this.getNetworkImageById(e))
              );
          },
          getWalletImageById(e) {
            if (e) return a.W.state.walletImages[e];
          },
          getWalletImage: (e) =>
            e?.image_url ? e?.image_url : e?.image_id ? a.W.state.walletImages[e.image_id] : void 0,
          getNetworkImage: (e) =>
            e?.assets?.imageUrl
              ? e?.assets?.imageUrl
              : e?.assets?.imageId
                ? a.W.state.networkImages[e.assets.imageId]
                : void 0,
          getNetworkImageById(e) {
            if (e) return a.W.state.networkImages[e];
          },
          getConnectorImage: (e) =>
            e?.imageUrl ? e.imageUrl : e?.imageId ? a.W.state.connectorImages[e.imageId] : void 0,
          getChainImage: (e) => a.W.state.networkImages[s[e]],
        };
    },
    49162: function (e, t, n) {
      'use strict';
      n.d(t, {
        a$: function () {
          return s;
        },
        bq: function () {
          return o;
        },
        gy: function () {
          return a;
        },
      });
      var r = n(32608);
      let i =
          (void 0 !== r && void 0 !== r.env ? r.env.NEXT_PUBLIC_SECURE_SITE_ORIGIN : void 0) ||
          'https://secure.walletconnect.org',
        a = [
          {
            label: 'Coinbase',
            name: 'coinbase',
            feeRange: '1-2%',
            url: '',
            supportedChains: ['eip155'],
          },
          {
            label: 'Meld.io',
            name: 'meld',
            feeRange: '1-2%',
            url: 'https://meldcrypto.com',
            supportedChains: ['eip155', 'solana'],
          },
        ],
        s = 'WXETMuFUQmqqybHuRkSgxv:25B8LJHSfpG6LVjR2ytU5Cwh7Z4Sch2ocoU',
        o = {
          FOUR_MINUTES_MS: 24e4,
          TEN_SEC_MS: 1e4,
          FIVE_SEC_MS: 5e3,
          THREE_SEC_MS: 3e3,
          ONE_SEC_MS: 1e3,
          SECURE_SITE: i,
          SECURE_SITE_DASHBOARD: `${i}/dashboard`,
          SECURE_SITE_FAVICON: `${i}/images/favicon.png`,
          RESTRICTED_TIMEZONES: [
            'ASIA/SHANGHAI',
            'ASIA/URUMQI',
            'ASIA/CHONGQING',
            'ASIA/HARBIN',
            'ASIA/KASHGAR',
            'ASIA/MACAU',
            'ASIA/HONG_KONG',
            'ASIA/MACAO',
            'ASIA/BEIJING',
            'ASIA/HARBIN',
          ],
          WC_COINBASE_PAY_SDK_CHAINS: [
            'ethereum',
            'arbitrum',
            'polygon',
            'berachain',
            'avalanche-c-chain',
            'optimism',
            'celo',
            'base',
          ],
          WC_COINBASE_PAY_SDK_FALLBACK_CHAIN: 'ethereum',
          WC_COINBASE_PAY_SDK_CHAIN_NAME_MAP: {
            Ethereum: 'ethereum',
            'Arbitrum One': 'arbitrum',
            Polygon: 'polygon',
            Berachain: 'berachain',
            Avalanche: 'avalanche-c-chain',
            'OP Mainnet': 'optimism',
            Celo: 'celo',
            Base: 'base',
          },
          WC_COINBASE_ONRAMP_APP_ID: 'bf18c88d-495a-463b-b249-0b9d3656cf5e',
          SWAP_SUGGESTED_TOKENS: [
            'ETH',
            'UNI',
            '1INCH',
            'AAVE',
            'SOL',
            'ADA',
            'AVAX',
            'DOT',
            'LINK',
            'NITRO',
            'GAIA',
            'MILK',
            'TRX',
            'NEAR',
            'GNO',
            'WBTC',
            'DAI',
            'WETH',
            'USDC',
            'USDT',
            'ARB',
            'BAL',
            'BICO',
            'CRV',
            'ENS',
            'MATIC',
            'OP',
          ],
          SWAP_POPULAR_TOKENS: [
            'ETH',
            'UNI',
            '1INCH',
            'AAVE',
            'SOL',
            'ADA',
            'AVAX',
            'DOT',
            'LINK',
            'NITRO',
            'GAIA',
            'MILK',
            'TRX',
            'NEAR',
            'GNO',
            'WBTC',
            'DAI',
            'WETH',
            'USDC',
            'USDT',
            'ARB',
            'BAL',
            'BICO',
            'CRV',
            'ENS',
            'MATIC',
            'OP',
            'METAL',
            'DAI',
            'CHAMP',
            'WOLF',
            'SALE',
            'BAL',
            'BUSD',
            'MUST',
            'BTCpx',
            'ROUTE',
            'HEX',
            'WELT',
            'amDAI',
            'VSQ',
            'VISION',
            'AURUM',
            'pSP',
            'SNX',
            'VC',
            'LINK',
            'CHP',
            'amUSDT',
            'SPHERE',
            'FOX',
            'GIDDY',
            'GFC',
            'OMEN',
            'OX_OLD',
            'DE',
            'WNT',
          ],
          BALANCE_SUPPORTED_CHAINS: ['eip155', 'solana'],
          SWAP_SUPPORTED_NETWORKS: [
            'eip155:1',
            'eip155:42161',
            'eip155:10',
            'eip155:324',
            'eip155:8453',
            'eip155:56',
            'eip155:137',
            'eip155:100',
            'eip155:43114',
            'eip155:250',
            'eip155:8217',
            'eip155:1313161554',
          ],
          NAMES_SUPPORTED_CHAIN_NAMESPACES: ['eip155'],
          ONRAMP_SUPPORTED_CHAIN_NAMESPACES: ['eip155', 'solana'],
          ACTIVITY_ENABLED_CHAIN_NAMESPACES: ['eip155'],
          NATIVE_TOKEN_ADDRESS: {
            eip155: '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee',
            solana: 'So11111111111111111111111111111111111111111',
            polkadot: '0x',
            bip122: '0x',
          },
          CONVERT_SLIPPAGE_TOLERANCE: 1,
          CONNECT_LABELS: { MOBILE: 'Open and continue in a new browser tab' },
          DEFAULT_FEATURES: {
            swaps: !0,
            onramp: !0,
            receive: !0,
            send: !0,
            email: !0,
            emailShowWallets: !0,
            socials: ['google', 'x', 'discord', 'farcaster', 'github', 'apple', 'facebook'],
            connectorTypeOrder: [
              'walletConnect',
              'recent',
              'injected',
              'featured',
              'custom',
              'external',
              'recommended',
            ],
            history: !0,
            analytics: !0,
            allWallets: !0,
            legalCheckbox: !1,
            smartSessions: !1,
            collapseWallets: !1,
            walletFeaturesOrder: ['onramp', 'swaps', 'receive', 'send'],
            connectMethodsOrder: void 0,
          },
          DEFAULT_ACCOUNT_TYPES: {
            bip122: 'payment',
            eip155: 'smartAccount',
            polkadot: 'eoa',
            solana: 'eoa',
          },
          ADAPTER_TYPES: {
            UNIVERSAL: 'universal',
            SOLANA: 'solana',
            WAGMI: 'wagmi',
            ETHERS: 'ethers',
            ETHERS5: 'ethers5',
            BITCOIN: 'bitcoin',
          },
        };
    },
    14537: function (e, t, n) {
      'use strict';
      n.d(t, {
        j: function () {
          return s;
        },
      });
      var r = n(49786),
        i = n(49162),
        a = n(31507);
      let s = {
        isMobile() {
          return (
            !!this.isClient() &&
            !!(
              window?.matchMedia('(pointer:coarse)')?.matches ||
              /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent)
            )
          );
        },
        checkCaipNetwork: (e, t = '') =>
          e?.caipNetworkId.toLocaleLowerCase().includes(t.toLowerCase()),
        isAndroid() {
          if (!this.isMobile()) return !1;
          let e = window?.navigator.userAgent.toLowerCase();
          return s.isMobile() && e.includes('android');
        },
        isIos() {
          if (!this.isMobile()) return !1;
          let e = window?.navigator.userAgent.toLowerCase();
          return e.includes('iphone') || e.includes('ipad');
        },
        isSafari() {
          return !!this.isClient() && window?.navigator.userAgent.toLowerCase().includes('safari');
        },
        isClient: () => 'undefined' != typeof window,
        isPairingExpired: (e) => !e || e - Date.now() <= i.bq.TEN_SEC_MS,
        isAllowedRetry: (e, t = i.bq.ONE_SEC_MS) => Date.now() - e >= t,
        copyToClopboard(e) {
          navigator.clipboard.writeText(e);
        },
        isIframe() {
          try {
            return window?.self !== window?.top;
          } catch (e) {
            return !1;
          }
        },
        getPairingExpiry: () => Date.now() + i.bq.FOUR_MINUTES_MS,
        getNetworkId: (e) => e?.split(':')[1],
        getPlainAddress: (e) => e?.split(':')[2],
        wait: async (e) =>
          new Promise((t) => {
            setTimeout(t, e);
          }),
        debounce(e, t = 500) {
          let n;
          return (...r) => {
            n && clearTimeout(n),
              (n = setTimeout(function () {
                e(...r);
              }, t));
          };
        },
        isHttpUrl: (e) => e.startsWith('http://') || e.startsWith('https://'),
        formatNativeUrl(e, t) {
          if (s.isHttpUrl(e)) return this.formatUniversalUrl(e, t);
          let n = e;
          n.includes('://') || ((n = e.replaceAll('/', '').replaceAll(':', '')), (n = `${n}://`)),
            n.endsWith('/') || (n = `${n}/`),
            this.isTelegram() && this.isAndroid() && (t = encodeURIComponent(t));
          let r = encodeURIComponent(t);
          return { redirect: `${n}wc?uri=${r}`, href: n };
        },
        formatUniversalUrl(e, t) {
          if (!s.isHttpUrl(e)) return this.formatNativeUrl(e, t);
          let n = e;
          n.endsWith('/') || (n = `${n}/`);
          let r = encodeURIComponent(t);
          return { redirect: `${n}wc?uri=${r}`, href: n };
        },
        getOpenTargetForPlatform(e) {
          return 'popupWindow' === e
            ? e
            : this.isTelegram()
              ? a.M.getTelegramSocialProvider()
                ? '_top'
                : '_blank'
              : e;
        },
        openHref(e, t, n) {
          window?.open(e, this.getOpenTargetForPlatform(t), n || 'noreferrer noopener');
        },
        returnOpenHref(e, t, n) {
          return window?.open(e, this.getOpenTargetForPlatform(t), n || 'noreferrer noopener');
        },
        isTelegram: () =>
          'undefined' != typeof window &&
          (!!window.TelegramWebviewProxy ||
            !!window.Telegram ||
            !!window.TelegramWebviewProxyProto),
        preloadImage: async (e) =>
          Promise.race([
            new Promise((t, n) => {
              let r = new Image();
              (r.onload = t), (r.onerror = n), (r.crossOrigin = 'anonymous'), (r.src = e);
            }),
            s.wait(2e3),
          ]),
        formatBalance(e, t) {
          let n = '0.000';
          if ('string' == typeof e) {
            let t = Number(e);
            if (t) {
              let e = Math.floor(1e3 * t) / 1e3;
              e && (n = e.toString());
            }
          }
          return `${n}${t ? ` ${t}` : ''}`;
        },
        formatBalance2(e, t) {
          let n;
          if ('0' === e) n = '0';
          else if ('string' == typeof e) {
            let t = Number(e);
            t && (n = t.toString().match(/^-?\d+(?:\.\d{0,3})?/u)?.[0]);
          }
          return { value: n ?? '0', rest: '0' === n ? '000' : '', symbol: t };
        },
        getApiUrl: () => r.b.W3M_API_URL,
        getBlockchainApiUrl: () => r.b.BLOCKCHAIN_API_RPC_URL,
        getAnalyticsUrl: () => r.b.PULSE_API_URL,
        getUUID: () =>
          crypto?.randomUUID
            ? crypto.randomUUID()
            : 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/gu, (e) => {
                let t = (16 * Math.random()) | 0;
                return ('x' === e ? t : (3 & t) | 8).toString(16);
              }),
        parseError: (e) =>
          'string' == typeof e
            ? e
            : 'string' == typeof e?.issues?.[0]?.message
              ? e.issues[0].message
              : e instanceof Error
                ? e.message
                : 'Unknown error',
        sortRequestedNetworks(e, t = []) {
          let n = {};
          return (
            t &&
              e &&
              (e.forEach((e, t) => {
                n[e] = t;
              }),
              t.sort((e, t) => {
                let r = n[e.id],
                  i = n[t.id];
                return void 0 !== r && void 0 !== i
                  ? r - i
                  : void 0 !== r
                    ? -1
                    : void 0 !== i
                      ? 1
                      : 0;
              })),
            t
          );
        },
        calculateBalance(e) {
          let t = 0;
          for (let n of e) t += n.value ?? 0;
          return t;
        },
        formatTokenBalance(e) {
          let [t, n] = e.toFixed(2).split('.');
          return { dollars: t, pennies: n };
        },
        isAddress(e, t = 'eip155') {
          switch (t) {
            case 'eip155':
              if (
                /^(?:0x)?[0-9a-f]{40}$/iu.test(e) &&
                (/^(?:0x)?[0-9a-f]{40}$/iu.test(e) || /^(?:0x)?[0-9A-F]{40}$/iu.test(e))
              )
                return !0;
              return !1;
            case 'solana':
              return /[1-9A-HJ-NP-Za-km-z]{32,44}$/iu.test(e);
            default:
              return !1;
          }
        },
        uniqueBy(e, t) {
          let n = new Set();
          return e.filter((e) => {
            let r = e[t];
            return !n.has(r) && (n.add(r), !0);
          });
        },
        generateSdkVersion(e, t, n) {
          let r =
            0 === e.length ? i.bq.ADAPTER_TYPES.UNIVERSAL : e.map((e) => e.adapterType).join(',');
          return `${t}-${r}-${n}`;
        },
        createAccount: (e, t, n, r, i) => ({
          namespace: e,
          address: t,
          type: n,
          publicKey: r,
          path: i,
        }),
        isCaipAddress(e) {
          if ('string' != typeof e) return !1;
          let t = e.split(':'),
            n = t[0];
          return 3 === t.filter(Boolean).length && n in r.b.CHAIN_NAME_MAP;
        },
        isMac() {
          let e = window?.navigator.userAgent.toLowerCase();
          return e.includes('macintosh') && !e.includes('safari');
        },
        formatTelegramSocialLoginUrl(e) {
          let t = `--${encodeURIComponent(window?.location.href)}`,
            n = 'state=';
          if ('auth.magic.link' === new URL(e).host) {
            let r = 'provider_authorization_url=',
              i = e.substring(e.indexOf(r) + r.length),
              a = this.injectIntoUrl(decodeURIComponent(i), n, t);
            return e.replace(i, encodeURIComponent(a));
          }
          return this.injectIntoUrl(e, n, t);
        },
        injectIntoUrl(e, t, n) {
          let r = e.indexOf(t);
          if (-1 === r) throw Error(`${t} parameter not found in the URL: ${e}`);
          let i = e.indexOf('&', r),
            a = t.length,
            s = -1 !== i ? i : e.length,
            o = e.substring(0, r + a);
          return o + (e.substring(r + a, s) + n) + e.substring(i);
        },
      };
    },
    83118: function (e, t, n) {
      'use strict';
      async function r(...e) {
        let t = await fetch(...e);
        if (!t.ok) throw Error(`HTTP status code: ${t.status}`, { cause: t });
        return t;
      }
      n.d(t, {
        V: function () {
          return i;
        },
      });
      class i {
        constructor({ baseUrl: e, clientId: t }) {
          (this.baseUrl = e), (this.clientId = t);
        }
        async get({ headers: e, signal: t, cache: n, ...i }) {
          let a = this.createUrl(i);
          return (await r(a, { method: 'GET', headers: e, signal: t, cache: n })).json();
        }
        async getBlob({ headers: e, signal: t, ...n }) {
          let i = this.createUrl(n);
          return (await r(i, { method: 'GET', headers: e, signal: t })).blob();
        }
        async post({ body: e, headers: t, signal: n, ...i }) {
          let a = this.createUrl(i);
          return (
            await r(a, {
              method: 'POST',
              headers: t,
              body: e ? JSON.stringify(e) : void 0,
              signal: n,
            })
          ).json();
        }
        async put({ body: e, headers: t, signal: n, ...i }) {
          let a = this.createUrl(i);
          return (
            await r(a, {
              method: 'PUT',
              headers: t,
              body: e ? JSON.stringify(e) : void 0,
              signal: n,
            })
          ).json();
        }
        async delete({ body: e, headers: t, signal: n, ...i }) {
          let a = this.createUrl(i);
          return (
            await r(a, {
              method: 'DELETE',
              headers: t,
              body: e ? JSON.stringify(e) : void 0,
              signal: n,
            })
          ).json();
        }
        createUrl({ path: e, params: t }) {
          let n = new URL(e, this.baseUrl);
          return (
            t &&
              Object.entries(t).forEach(([e, t]) => {
                t && n.searchParams.append(e, t);
              }),
            this.clientId && n.searchParams.append('clientId', this.clientId),
            n
          );
        }
      }
    },
    60824: function (e, t, n) {
      'use strict';
      n.d(t, {
        w: function () {
          return f;
        },
      }),
        n(26651);
      var r = n(49786),
        i = n(41428),
        a = n(60725),
        s = n(97059),
        o = n(17409),
        l = n(3230),
        u = n(27837),
        c = n(26038),
        d = n(8924),
        p = n(88667),
        h = n(19165),
        y = n(14537);
      let f = {
        getSIWX: () => d.OptionsController.state.siwx,
        async initializeIfEnabled() {
          let e = d.OptionsController.state.siwx,
            t = s.R.getActiveCaipAddress();
          if (!(e && t)) return;
          let [n, r, i] = t.split(':');
          if (s.R.checkIfSupportedNetwork(n))
            try {
              if ((await e.getSessions(`${n}:${r}`, i)).length) return;
              await c.I.open({ view: 'SIWXSignMessage' });
            } catch (e) {
              console.error('SIWXUtil:initializeIfEnabled', e),
                u.X.sendEvent({
                  type: 'track',
                  event: 'SIWX_AUTH_ERROR',
                  properties: this.getSIWXEventProperties(),
                }),
                await o.ConnectionController._getClient()?.disconnect().catch(console.error),
                p.RouterController.reset('Connect'),
                h.SnackController.showError(
                  'A problem occurred while trying initialize authentication'
                );
            }
        },
        async requestSignMessage() {
          let e = d.OptionsController.state.siwx,
            t = y.j.getPlainAddress(s.R.getActiveCaipAddress()),
            n = s.R.getActiveCaipNetwork(),
            i = o.ConnectionController._getClient();
          if (!e) throw Error('SIWX is not enabled');
          if (!t) throw Error('No ActiveCaipAddress found');
          if (!n) throw Error('No ActiveCaipNetwork or client found');
          if (!i) throw Error('No ConnectionController client found');
          try {
            let a = await e.createMessage({ chainId: n.caipNetworkId, accountAddress: t }),
              s = a.toString();
            l.ConnectorController.getConnectorId(n.chainNamespace) === r.b.CONNECTOR_ID.AUTH &&
              p.RouterController.pushTransactionStack({ view: null, goBack: !1, replace: !0 });
            let o = await i.signMessage(s);
            await e.addSession({ data: a, message: s, signature: o }),
              c.I.close(),
              u.X.sendEvent({
                type: 'track',
                event: 'SIWX_AUTH_SUCCESS',
                properties: this.getSIWXEventProperties(),
              });
          } catch (t) {
            let e = this.getSIWXEventProperties();
            (c.I.state.open && 'ApproveTransaction' !== p.RouterController.state.view) ||
              (await c.I.open({ view: 'SIWXSignMessage' })),
              e.isSmartAccount
                ? h.SnackController.showError('This application might not support Smart Accounts')
                : h.SnackController.showError('Signature declined'),
              u.X.sendEvent({ type: 'track', event: 'SIWX_AUTH_ERROR', properties: e }),
              console.error('SWIXUtil:requestSignMessage', t);
          }
        },
        async cancelSignMessage() {
          try {
            let e = this.getSIWX();
            e?.getRequired?.() ? await o.ConnectionController.disconnect() : c.I.close(),
              p.RouterController.reset('Connect'),
              u.X.sendEvent({
                event: 'CLICK_CANCEL_SIWX',
                type: 'track',
                properties: this.getSIWXEventProperties(),
              });
          } catch (e) {
            console.error('SIWXUtil:cancelSignMessage', e);
          }
        },
        async getSessions() {
          let e = d.OptionsController.state.siwx,
            t = y.j.getPlainAddress(s.R.getActiveCaipAddress()),
            n = s.R.getActiveCaipNetwork();
          return e && t && n ? e.getSessions(n.caipNetworkId, t) : [];
        },
        async isSIWXCloseDisabled() {
          let e = this.getSIWX();
          if (e) {
            let t = 'ApproveTransaction' === p.RouterController.state.view,
              n = 'SIWXSignMessage' === p.RouterController.state.view;
            if (t || n) return e.getRequired?.() && 0 === (await this.getSessions()).length;
          }
          return !1;
        },
        async universalProviderAuthenticate({ universalProvider: e, chains: t, methods: n }) {
          let r = f.getSIWX(),
            i = new Set(t.map((e) => e.split(':')[0]));
          if (!r || 1 !== i.size || !i.has('eip155')) return !1;
          let o = await r.createMessage({
              chainId: s.R.getActiveCaipNetwork()?.caipNetworkId || '',
              accountAddress: '',
            }),
            l = await e.authenticate({
              nonce: o.nonce,
              domain: o.domain,
              uri: o.uri,
              exp: o.expirationTime,
              iat: o.issuedAt,
              nbf: o.notBefore,
              requestId: o.requestId,
              version: o.version,
              resources: o.resources,
              statement: o.statement,
              chainId: o.chainId,
              methods: n,
              chains: [o.chainId, ...t.filter((e) => e !== o.chainId)],
            });
          if (
            (h.SnackController.showLoading('Authenticating...', { autoClose: !1 }),
            a.AccountController.setConnectedWalletInfo(
              {
                ...l.session.peer.metadata,
                name: l.session.peer.metadata.name,
                icon: l.session.peer.metadata.icons?.[0],
                type: 'WALLET_CONNECT',
              },
              Array.from(i)[0]
            ),
            l?.auths?.length)
          ) {
            let t = l.auths.map((t) => {
              let n = e.client.formatAuthMessage({ request: t.p, iss: t.p.iss });
              return {
                data: {
                  ...t.p,
                  accountAddress: t.p.iss.split(':').slice(-1).join(''),
                  chainId: t.p.iss.split(':').slice(2, 4).join(':'),
                  uri: t.p.aud,
                  version: t.p.version || o.version,
                  expirationTime: t.p.exp,
                  issuedAt: t.p.iat,
                  notBefore: t.p.nbf,
                },
                message: n,
                signature: t.s.s,
                cacao: t,
              };
            });
            try {
              await r.setSessions(t),
                u.X.sendEvent({
                  type: 'track',
                  event: 'SIWX_AUTH_SUCCESS',
                  properties: f.getSIWXEventProperties(),
                });
            } catch (t) {
              throw (
                (console.error('SIWX:universalProviderAuth - failed to set sessions', t),
                u.X.sendEvent({
                  type: 'track',
                  event: 'SIWX_AUTH_ERROR',
                  properties: f.getSIWXEventProperties(),
                }),
                await e.disconnect().catch(console.error),
                t)
              );
            } finally {
              h.SnackController.hide();
            }
          }
          return !0;
        },
        getSIWXEventProperties() {
          let e = s.R.state.activeChain;
          return {
            network: s.R.state.activeCaipNetwork?.caipNetworkId || '',
            isSmartAccount:
              a.AccountController.state.preferredAccountTypes?.[e] ===
              i.y_.ACCOUNT_TYPES.SMART_ACCOUNT,
          };
        },
        async clearSessions() {
          let e = this.getSIWX();
          e && (await e.setSessions([]));
        },
      };
    },
    80582: function (e, t, n) {
      'use strict';
      n.d(t, {
        y: function () {
          return u;
        },
      });
      var r = n(60725),
        i = n(98583),
        a = n(97059),
        s = n(17409),
        o = n(28213);
      let l = {
          createBalance(e, t) {
            let n = {
              name: e.metadata.name || '',
              symbol: e.metadata.symbol || '',
              decimals: e.metadata.decimals || 0,
              value: e.metadata.value || 0,
              price: e.metadata.price || 0,
              iconUrl: e.metadata.iconUrl || '',
            };
            return {
              name: n.name,
              symbol: n.symbol,
              chainId: t,
              address:
                'native' === e.address ? void 0 : this.convertAddressToCAIP10Address(e.address, t),
              value: n.value,
              price: n.price,
              quantity: {
                decimals: n.decimals.toString(),
                numeric: this.convertHexToBalance({ hex: e.balance, decimals: n.decimals }),
              },
              iconUrl: n.iconUrl,
            };
          },
          convertHexToBalance: ({ hex: e, decimals: t }) => (0, o.b)(BigInt(e), t),
          convertAddressToCAIP10Address: (e, t) => `${t}:${e}`,
          createCAIP2ChainId: (e, t) => `${t}:${parseInt(e, 16)}`,
          getChainIdHexFromCAIP2ChainId(e) {
            let t = e.split(':');
            if (t.length < 2 || !t[1]) return '0x0';
            let n = parseInt(t[1], 10);
            return isNaN(n) ? '0x0' : `0x${n.toString(16)}`;
          },
          isWalletGetAssetsResponse(e) {
            return (
              'object' == typeof e &&
              null !== e &&
              Object.values(e).every(
                (e) => Array.isArray(e) && e.every((e) => this.isValidAsset(e))
              )
            );
          },
          isValidAsset: (e) =>
            'object' == typeof e &&
            null !== e &&
            'string' == typeof e.address &&
            'string' == typeof e.balance &&
            ('ERC20' === e.type || 'NATIVE' === e.type) &&
            'object' == typeof e.metadata &&
            null !== e.metadata &&
            'string' == typeof e.metadata.name &&
            'string' == typeof e.metadata.symbol &&
            'number' == typeof e.metadata.decimals &&
            'number' == typeof e.metadata.price &&
            'string' == typeof e.metadata.iconUrl,
        },
        u = {
          async getMyTokensWithBalance(e) {
            let t = r.AccountController.state.address,
              n = a.R.state.activeCaipNetwork;
            if (!t || !n) return [];
            if ('eip155' === n.chainNamespace) {
              let e = await this.getEIP155Balances(t, n);
              if (e) return this.filterLowQualityTokens(e);
            }
            let s = await i.L.getBalance(t, n.caipNetworkId, e);
            return this.filterLowQualityTokens(s.balances);
          },
          async getEIP155Balances(e, t) {
            try {
              let n = l.getChainIdHexFromCAIP2ChainId(t.caipNetworkId),
                r = await s.ConnectionController.getCapabilities(e);
              if (!r?.[n]?.assetDiscovery?.supported) return null;
              let i = await s.ConnectionController.walletGetAssets({
                account: e,
                chainFilter: [n],
              });
              if (!l.isWalletGetAssetsResponse(i)) return null;
              return (i[n] || []).map((e) => l.createBalance(e, t.caipNetworkId));
            } catch (e) {
              return null;
            }
          },
          filterLowQualityTokens: (e) => e.filter((e) => '0' !== e.quantity.decimals),
          mapBalancesToSwapTokens: (e) =>
            e?.map((e) => ({
              ...e,
              address: e?.address ? e.address : a.R.getActiveNetworkTokenAddress(),
              decimals: parseInt(e.quantity.decimals, 10),
              logoUri: e.iconUrl,
              eip2612: !1,
            })) || [],
        };
    },
    31507: function (e, t, n) {
      'use strict';
      n.d(t, {
        M: function () {
          return i;
        },
      });
      var r = n(86923);
      let i = {
        cacheExpiry: { portfolio: 3e4, nativeBalance: 3e4, ens: 3e5, identity: 3e5 },
        isCacheExpired: (e, t) => Date.now() - e > t,
        getActiveNetworkProps() {
          let e = i.getActiveNamespace(),
            t = i.getActiveCaipNetworkId(),
            n = t ? t.split(':')[1] : void 0;
          return {
            namespace: e,
            caipNetworkId: t,
            chainId: n ? (isNaN(Number(n)) ? n : Number(n)) : void 0,
          };
        },
        setWalletConnectDeepLink({ name: e, href: t }) {
          try {
            r.mr.setItem(r.uJ.DEEPLINK_CHOICE, JSON.stringify({ href: t, name: e }));
          } catch {
            console.info('Unable to set WalletConnect deep link');
          }
        },
        getWalletConnectDeepLink() {
          try {
            let e = r.mr.getItem(r.uJ.DEEPLINK_CHOICE);
            if (e) return JSON.parse(e);
          } catch {
            console.info('Unable to get WalletConnect deep link');
          }
        },
        deleteWalletConnectDeepLink() {
          try {
            r.mr.removeItem(r.uJ.DEEPLINK_CHOICE);
          } catch {
            console.info('Unable to delete WalletConnect deep link');
          }
        },
        setActiveNamespace(e) {
          try {
            r.mr.setItem(r.uJ.ACTIVE_NAMESPACE, e);
          } catch {
            console.info('Unable to set active namespace');
          }
        },
        setActiveCaipNetworkId(e) {
          try {
            r.mr.setItem(r.uJ.ACTIVE_CAIP_NETWORK_ID, e), i.setActiveNamespace(e.split(':')[0]);
          } catch {
            console.info('Unable to set active caip network id');
          }
        },
        getActiveCaipNetworkId() {
          try {
            return r.mr.getItem(r.uJ.ACTIVE_CAIP_NETWORK_ID);
          } catch {
            console.info('Unable to get active caip network id');
            return;
          }
        },
        deleteActiveCaipNetworkId() {
          try {
            r.mr.removeItem(r.uJ.ACTIVE_CAIP_NETWORK_ID);
          } catch {
            console.info('Unable to delete active caip network id');
          }
        },
        deleteConnectedConnectorId(e) {
          try {
            let t = (0, r.Vk)(e);
            r.mr.removeItem(t);
          } catch {
            console.info('Unable to delete connected connector id');
          }
        },
        setAppKitRecent(e) {
          try {
            let t = i.getRecentWallets();
            t.find((t) => t.id === e.id) ||
              (t.unshift(e),
              t.length > 2 && t.pop(),
              r.mr.setItem(r.uJ.RECENT_WALLETS, JSON.stringify(t)));
          } catch {
            console.info('Unable to set AppKit recent');
          }
        },
        getRecentWallets() {
          try {
            let e = r.mr.getItem(r.uJ.RECENT_WALLETS);
            return e ? JSON.parse(e) : [];
          } catch {
            console.info('Unable to get AppKit recent');
          }
          return [];
        },
        setConnectedConnectorId(e, t) {
          try {
            let n = (0, r.Vk)(e);
            r.mr.setItem(n, t);
          } catch {
            console.info('Unable to set Connected Connector Id');
          }
        },
        getActiveNamespace() {
          try {
            return r.mr.getItem(r.uJ.ACTIVE_NAMESPACE);
          } catch {
            console.info('Unable to get active namespace');
          }
        },
        getConnectedConnectorId(e) {
          if (e)
            try {
              let t = (0, r.Vk)(e);
              return r.mr.getItem(t);
            } catch (t) {
              console.info('Unable to get connected connector id in namespace ', e);
            }
        },
        setConnectedSocialProvider(e) {
          try {
            r.mr.setItem(r.uJ.CONNECTED_SOCIAL, e);
          } catch {
            console.info('Unable to set connected social provider');
          }
        },
        getConnectedSocialProvider() {
          try {
            return r.mr.getItem(r.uJ.CONNECTED_SOCIAL);
          } catch {
            console.info('Unable to get connected social provider');
          }
        },
        deleteConnectedSocialProvider() {
          try {
            r.mr.removeItem(r.uJ.CONNECTED_SOCIAL);
          } catch {
            console.info('Unable to delete connected social provider');
          }
        },
        getConnectedSocialUsername() {
          try {
            return r.mr.getItem(r.uJ.CONNECTED_SOCIAL_USERNAME);
          } catch {
            console.info('Unable to get connected social username');
          }
        },
        getStoredActiveCaipNetworkId() {
          let e = r.mr.getItem(r.uJ.ACTIVE_CAIP_NETWORK_ID);
          return e?.split(':')?.[1];
        },
        setConnectionStatus(e) {
          try {
            r.mr.setItem(r.uJ.CONNECTION_STATUS, e);
          } catch {
            console.info('Unable to set connection status');
          }
        },
        getConnectionStatus() {
          try {
            return r.mr.getItem(r.uJ.CONNECTION_STATUS);
          } catch {
            return;
          }
        },
        getConnectedNamespaces() {
          try {
            let e = r.mr.getItem(r.uJ.CONNECTED_NAMESPACES);
            if (!e?.length) return [];
            return e.split(',');
          } catch {
            return [];
          }
        },
        setConnectedNamespaces(e) {
          try {
            let t = Array.from(new Set(e));
            r.mr.setItem(r.uJ.CONNECTED_NAMESPACES, t.join(','));
          } catch {
            console.info('Unable to set namespaces in storage');
          }
        },
        addConnectedNamespace(e) {
          try {
            let t = i.getConnectedNamespaces();
            t.includes(e) || (t.push(e), i.setConnectedNamespaces(t));
          } catch {
            console.info('Unable to add connected namespace');
          }
        },
        removeConnectedNamespace(e) {
          try {
            let t = i.getConnectedNamespaces(),
              n = t.indexOf(e);
            n > -1 && (t.splice(n, 1), i.setConnectedNamespaces(t));
          } catch {
            console.info('Unable to remove connected namespace');
          }
        },
        getTelegramSocialProvider() {
          try {
            return r.mr.getItem(r.uJ.TELEGRAM_SOCIAL_PROVIDER);
          } catch {
            return console.info('Unable to get telegram social provider'), null;
          }
        },
        setTelegramSocialProvider(e) {
          try {
            r.mr.setItem(r.uJ.TELEGRAM_SOCIAL_PROVIDER, e);
          } catch {
            console.info('Unable to set telegram social provider');
          }
        },
        removeTelegramSocialProvider() {
          try {
            r.mr.removeItem(r.uJ.TELEGRAM_SOCIAL_PROVIDER);
          } catch {
            console.info('Unable to remove telegram social provider');
          }
        },
        getBalanceCache() {
          let e = {};
          try {
            let t = r.mr.getItem(r.uJ.PORTFOLIO_CACHE);
            e = t ? JSON.parse(t) : {};
          } catch {
            console.info('Unable to get balance cache');
          }
          return e;
        },
        removeAddressFromBalanceCache(e) {
          try {
            let t = i.getBalanceCache();
            r.mr.setItem(r.uJ.PORTFOLIO_CACHE, JSON.stringify({ ...t, [e]: void 0 }));
          } catch {
            console.info('Unable to remove address from balance cache', e);
          }
        },
        getBalanceCacheForCaipAddress(e) {
          try {
            let t = i.getBalanceCache()[e];
            if (t && !this.isCacheExpired(t.timestamp, this.cacheExpiry.portfolio))
              return t.balance;
            i.removeAddressFromBalanceCache(e);
          } catch {
            console.info('Unable to get balance cache for address', e);
          }
        },
        updateBalanceCache(e) {
          try {
            let t = i.getBalanceCache();
            (t[e.caipAddress] = e), r.mr.setItem(r.uJ.PORTFOLIO_CACHE, JSON.stringify(t));
          } catch {
            console.info('Unable to update balance cache', e);
          }
        },
        getNativeBalanceCache() {
          let e = {};
          try {
            let t = r.mr.getItem(r.uJ.NATIVE_BALANCE_CACHE);
            e = t ? JSON.parse(t) : {};
          } catch {
            console.info('Unable to get balance cache');
          }
          return e;
        },
        removeAddressFromNativeBalanceCache(e) {
          try {
            let t = i.getBalanceCache();
            r.mr.setItem(r.uJ.NATIVE_BALANCE_CACHE, JSON.stringify({ ...t, [e]: void 0 }));
          } catch {
            console.info('Unable to remove address from balance cache', e);
          }
        },
        getNativeBalanceCacheForCaipAddress(e) {
          try {
            let t = i.getNativeBalanceCache()[e];
            if (t && !this.isCacheExpired(t.timestamp, this.cacheExpiry.nativeBalance)) return t;
            console.info('Discarding cache for address', e), i.removeAddressFromBalanceCache(e);
          } catch {
            console.info('Unable to get balance cache for address', e);
          }
        },
        updateNativeBalanceCache(e) {
          try {
            let t = i.getNativeBalanceCache();
            (t[e.caipAddress] = e), r.mr.setItem(r.uJ.NATIVE_BALANCE_CACHE, JSON.stringify(t));
          } catch {
            console.info('Unable to update balance cache', e);
          }
        },
        getEnsCache() {
          let e = {};
          try {
            let t = r.mr.getItem(r.uJ.ENS_CACHE);
            e = t ? JSON.parse(t) : {};
          } catch {
            console.info('Unable to get ens name cache');
          }
          return e;
        },
        getEnsFromCacheForAddress(e) {
          try {
            let t = i.getEnsCache()[e];
            if (t && !this.isCacheExpired(t.timestamp, this.cacheExpiry.ens)) return t.ens;
            i.removeEnsFromCache(e);
          } catch {
            console.info('Unable to get ens name from cache', e);
          }
        },
        updateEnsCache(e) {
          try {
            let t = i.getEnsCache();
            (t[e.address] = e), r.mr.setItem(r.uJ.ENS_CACHE, JSON.stringify(t));
          } catch {
            console.info('Unable to update ens name cache', e);
          }
        },
        removeEnsFromCache(e) {
          try {
            let t = i.getEnsCache();
            r.mr.setItem(r.uJ.ENS_CACHE, JSON.stringify({ ...t, [e]: void 0 }));
          } catch {
            console.info('Unable to remove ens name from cache', e);
          }
        },
        getIdentityCache() {
          let e = {};
          try {
            let t = r.mr.getItem(r.uJ.IDENTITY_CACHE);
            e = t ? JSON.parse(t) : {};
          } catch {
            console.info('Unable to get identity cache');
          }
          return e;
        },
        getIdentityFromCacheForAddress(e) {
          try {
            let t = i.getIdentityCache()[e];
            if (t && !this.isCacheExpired(t.timestamp, this.cacheExpiry.identity))
              return t.identity;
            i.removeIdentityFromCache(e);
          } catch {
            console.info('Unable to get identity from cache', e);
          }
        },
        updateIdentityCache(e) {
          try {
            let t = i.getIdentityCache();
            (t[e.address] = { identity: e.identity, timestamp: e.timestamp }),
              r.mr.setItem(r.uJ.IDENTITY_CACHE, JSON.stringify(t));
          } catch {
            console.info('Unable to update identity cache', e);
          }
        },
        removeIdentityFromCache(e) {
          try {
            let t = i.getIdentityCache();
            r.mr.setItem(r.uJ.IDENTITY_CACHE, JSON.stringify({ ...t, [e]: void 0 }));
          } catch {
            console.info('Unable to remove identity from cache', e);
          }
        },
        clearAddressCache() {
          try {
            r.mr.removeItem(r.uJ.PORTFOLIO_CACHE),
              r.mr.removeItem(r.uJ.NATIVE_BALANCE_CACHE),
              r.mr.removeItem(r.uJ.ENS_CACHE),
              r.mr.removeItem(r.uJ.IDENTITY_CACHE);
          } catch {
            console.info('Unable to clear address cache');
          }
        },
        setPreferredAccountTypes(e) {
          try {
            r.mr.setItem(r.uJ.PREFERRED_ACCOUNT_TYPES, JSON.stringify(e));
          } catch {
            console.info('Unable to set preferred account types', e);
          }
        },
        getPreferredAccountTypes() {
          try {
            let e = r.mr.getItem(r.uJ.PREFERRED_ACCOUNT_TYPES);
            return JSON.parse(e);
          } catch {
            console.info('Unable to get preferred account types');
          }
        },
      };
    },
    40810: function (e, t, n) {
      'use strict';
      n.d(t, {
        C: function () {
          return h;
        },
      });
      var r = n(49786),
        i = n(8924),
        a = n(31507),
        s = n(82093),
        o = n(14537),
        l = n(17409),
        u = n(97059),
        c = n(3230),
        d = n(62692),
        p = n(39184);
      let h = {
        getConnectorsByType(e, t, n) {
          let { customWallets: r } = i.OptionsController.state,
            s = a.M.getRecentWallets(),
            o = p.J.filterOutDuplicateWallets(t),
            l = p.J.filterOutDuplicateWallets(n),
            u = e.filter((e) => 'MULTI_CHAIN' === e.type),
            c = e.filter((e) => 'ANNOUNCED' === e.type),
            d = e.filter((e) => 'INJECTED' === e.type);
          return {
            custom: r,
            recent: s,
            external: e.filter((e) => 'EXTERNAL' === e.type),
            multiChain: u,
            announced: c,
            injected: d,
            recommended: o,
            featured: l,
          };
        },
        showConnector(e) {
          let t = e.info?.rdns,
            n = !!t && s.ApiController.state.excludedWallets.some((e) => !!e.rdns && e.rdns === t),
            r =
              !!e.name &&
              s.ApiController.state.excludedWallets.some((t) =>
                d.g.isLowerCaseMatch(t.name, e.name)
              );
          return (
            ('INJECTED' !== e.type ||
              ((!!o.j.isMobile() || 'Browser Wallet' !== e.name) &&
                (!!t || !!l.ConnectionController.checkInstalled()) &&
                !n &&
                !r)) &&
            (('ANNOUNCED' !== e.type && 'EXTERNAL' !== e.type) || (!n && !r))
          );
        },
        getIsConnectedWithWC: () =>
          Array.from(u.R.state.chains.values()).some(
            (e) =>
              c.ConnectorController.getConnectorId(e.namespace) === r.b.CONNECTOR_ID.WALLET_CONNECT
          ),
        getConnectorTypeOrder({
          recommended: e,
          featured: t,
          custom: n,
          recent: r,
          announced: a,
          injected: s,
          multiChain: o,
          external: l,
          overriddenConnectors: u = i.OptionsController.state.features?.connectorTypeOrder ?? [],
        }) {
          let c = h.getIsConnectedWithWC(),
            d = [
              {
                type: 'walletConnect',
                isEnabled: i.OptionsController.state.enableWalletConnect && !c,
              },
              { type: 'recent', isEnabled: r.length > 0 },
              { type: 'injected', isEnabled: [...s, ...a, ...o].length > 0 },
              { type: 'featured', isEnabled: t.length > 0 },
              { type: 'custom', isEnabled: n && n.length > 0 },
              { type: 'external', isEnabled: l.length > 0 },
              { type: 'recommended', isEnabled: e.length > 0 },
            ].filter((e) => e.isEnabled),
            p = new Set(d.map((e) => e.type)),
            y = u.filter((e) => p.has(e)).map((e) => ({ type: e, isEnabled: !0 })),
            f = d.filter(({ type: e }) => !y.some(({ type: t }) => t === e));
          return Array.from(new Set([...y, ...f].map(({ type: e }) => e)));
        },
      };
    },
    22953: function (e, t, n) {
      'use strict';
      n.d(t, {
        b: function () {
          return i;
        },
      });
      var r = n(32608);
      let i = {
        ACCOUNT_TABS: [{ label: 'Tokens' }, { label: 'NFTs' }, { label: 'Activity' }],
        SECURE_SITE_ORIGIN:
          (void 0 !== r && void 0 !== r.env ? r.env.NEXT_PUBLIC_SECURE_SITE_ORIGIN : void 0) ||
          'https://secure.walletconnect.org',
        VIEW_DIRECTION: { Next: 'next', Prev: 'prev' },
        DEFAULT_CONNECT_METHOD_ORDER: ['email', 'social', 'wallet'],
        ANIMATION_DURATIONS: { HeaderText: 120, ModalHeight: 150, ViewTransition: 150 },
      };
    },
    39184: function (e, t, n) {
      'use strict';
      n.d(t, {
        J: function () {
          return d;
        },
      });
      var r = n(8924),
        i = n(3230),
        a = n(31507),
        s = n(14537),
        o = n(82093),
        l = n(62692),
        u = n(40810),
        c = n(22953);
      let d = {
        filterOutDuplicatesByRDNS(e) {
          let t = r.OptionsController.state.enableEIP6963
              ? i.ConnectorController.state.connectors
              : [],
            n = a.M.getRecentWallets(),
            o = t.map((e) => e.info?.rdns).filter(Boolean),
            l = n.map((e) => e.rdns).filter(Boolean),
            u = o.concat(l);
          if (u.includes('io.metamask.mobile') && s.j.isMobile()) {
            let e = u.indexOf('io.metamask.mobile');
            u[e] = 'io.metamask';
          }
          return e.filter((e) => !u.includes(String(e?.rdns)));
        },
        filterOutDuplicatesByIds(e) {
          let t = i.ConnectorController.state.connectors.filter(
              (e) => 'ANNOUNCED' === e.type || 'INJECTED' === e.type
            ),
            n = a.M.getRecentWallets(),
            r = t.map((e) => e.explorerId),
            s = n.map((e) => e.id),
            o = r.concat(s);
          return e.filter((e) => !o.includes(e?.id));
        },
        filterOutDuplicateWallets(e) {
          let t = this.filterOutDuplicatesByRDNS(e);
          return this.filterOutDuplicatesByIds(t);
        },
        markWalletsAsInstalled(e) {
          let { connectors: t } = i.ConnectorController.state,
            n = t
              .filter((e) => 'ANNOUNCED' === e.type)
              .reduce((e, t) => (t.info?.rdns && (e[t.info.rdns] = !0), e), {});
          return e
            .map((e) => ({ ...e, installed: !!e.rdns && !!n[e.rdns ?? ''] }))
            .sort((e, t) => Number(t.installed) - Number(e.installed));
        },
        getConnectOrderMethod(e, t) {
          let n = e?.connectMethodsOrder || r.OptionsController.state.features?.connectMethodsOrder,
            a = t || i.ConnectorController.state.connectors;
          if (n) return n;
          let { injected: s, announced: l } = u.C.getConnectorsByType(
              a,
              o.ApiController.state.recommended,
              o.ApiController.state.featured
            ),
            d = s.filter(u.C.showConnector),
            p = l.filter(u.C.showConnector);
          return d.length || p.length
            ? ['wallet', 'email', 'social']
            : c.b.DEFAULT_CONNECT_METHOD_ORDER;
        },
        isExcluded(e) {
          let t = !!e.rdns && o.ApiController.state.excludedWallets.some((t) => t.rdns === e.rdns),
            n =
              !!e.name &&
              o.ApiController.state.excludedWallets.some((t) =>
                l.g.isLowerCaseMatch(t.name, e.name)
              );
          return t || n;
        },
      };
    },
    91527: function (e, t, n) {
      'use strict';
      n.d(t, {
        kj: function () {
          return r;
        },
        AI: function () {
          return u;
        },
        Hg: function () {
          return a.H;
        },
        Mo: function () {
          return c.M;
        },
        n: function () {
          return i.n;
        },
        Hs: function () {
          return i.Hs;
        },
        R: function () {
          return i.R;
        },
      });
      let r = {
        interpolate(e, t, n) {
          if (2 !== e.length || 2 !== t.length)
            throw Error('inputRange and outputRange must be an array of length 2');
          let r = e[0] || 0,
            i = e[1] || 0,
            a = t[0] || 0,
            s = t[1] || 0;
          return n < r ? a : n > i ? s : ((s - a) / (i - r)) * (n - r) + a;
        },
      };
      var i = n(38573),
        a = n(82072),
        s = n(70871);
      let o = ['receive', 'deposit', 'borrow', 'claim'],
        l = ['withdraw', 'repay', 'burn'],
        u = {
          getTransactionGroupTitle(e, t) {
            let n = s.E.getYear(),
              r = s.E.getMonthNameByIndex(t);
            return e === n ? r : `${r} ${e}`;
          },
          getTransactionImages(e) {
            let [t, n] = e,
              r = !!t && e?.every((e) => !!e.nft_info),
              i = e?.length > 1;
            return e?.length !== 2 || r
              ? i
                ? e.map((e) => this.getTransactionImage(e))
                : [this.getTransactionImage(t)]
              : [this.getTransactionImage(t), this.getTransactionImage(n)];
          },
          getTransactionImage: (e) => ({
            type: u.getTransactionTransferTokenType(e),
            url: u.getTransactionImageURL(e),
          }),
          getTransactionImageURL(e) {
            let t;
            let n = !!e?.nft_info,
              r = !!e?.fungible_info;
            return (
              e && n
                ? (t = e?.nft_info?.content?.preview?.url)
                : e && r && (t = e?.fungible_info?.icon?.url),
              t
            );
          },
          getTransactionTransferTokenType: (e) =>
            e?.fungible_info ? 'FUNGIBLE' : e?.nft_info ? 'NFT' : void 0,
          getTransactionDescriptions(e) {
            let t = e?.metadata?.operationType,
              n = e?.transfers,
              r = e?.transfers?.length > 0,
              i = e?.transfers?.length > 1,
              s = r && n?.every((e) => !!e?.fungible_info),
              [u, c] = n,
              d = this.getTransferDescription(u);
            if ((this.getTransferDescription(c), !r))
              return ('send' === t || 'receive' === t) && s
                ? [
                    (d = a.H.getTruncateString({
                      string: e?.metadata.sentFrom,
                      charsStart: 4,
                      charsEnd: 6,
                      truncate: 'middle',
                    })),
                    a.H.getTruncateString({
                      string: e?.metadata.sentTo,
                      charsStart: 4,
                      charsEnd: 6,
                      truncate: 'middle',
                    }),
                  ]
                : [e.metadata.status];
            if (i) return n.map((e) => this.getTransferDescription(e));
            let p = '';
            return o.includes(t) ? (p = '+') : l.includes(t) && (p = '-'), [(d = p.concat(d))];
          },
          getTransferDescription(e) {
            let t = '';
            return (
              e &&
                (e?.nft_info
                  ? (t = e?.nft_info?.name || '-')
                  : e?.fungible_info && (t = this.getFungibleTransferDescription(e) || '-')),
              t
            );
          },
          getFungibleTransferDescription(e) {
            return e
              ? [this.getQuantityFixedValue(e?.quantity.numeric), e?.fungible_info?.symbol]
                  .join(' ')
                  .trim()
              : null;
          },
          getQuantityFixedValue: (e) => (e ? parseFloat(e).toFixed(3) : null),
        };
      var c = n(55202);
    },
    38573: function (e, t, n) {
      'use strict';
      let r, i, a;
      n.d(t, {
        Bp: function () {
          return y;
        },
        ET: function () {
          return p;
        },
        Hs: function () {
          return u;
        },
        R: function () {
          return c;
        },
        ZM: function () {
          return h;
        },
        n: function () {
          return l;
        },
      });
      var s = n(98670),
        o = n(29931);
      function l(e, t) {
        (r = document.createElement('style')),
          (i = document.createElement('style')),
          (a = document.createElement('style')),
          (r.textContent = d(e).core.cssText),
          (i.textContent = d(e).dark.cssText),
          (a.textContent = d(e).light.cssText),
          document.head.appendChild(r),
          document.head.appendChild(i),
          document.head.appendChild(a),
          u(t);
      }
      function u(e) {
        i &&
          a &&
          ('light' === e
            ? (i.removeAttribute('media'), (a.media = 'enabled'))
            : (a.removeAttribute('media'), (i.media = 'enabled')));
      }
      function c(e) {
        r &&
          i &&
          a &&
          ((r.textContent = d(e).core.cssText),
          (i.textContent = d(e).dark.cssText),
          (a.textContent = d(e).light.cssText));
      }
      function d(e) {
        return {
          core: (0, s.iv)`
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
      @keyframes w3m-shake {
        0% {
          transform: scale(1) rotate(0deg);
        }
        20% {
          transform: scale(1) rotate(-1deg);
        }
        40% {
          transform: scale(1) rotate(1.5deg);
        }
        60% {
          transform: scale(1) rotate(-1.5deg);
        }
        80% {
          transform: scale(1) rotate(1deg);
        }
        100% {
          transform: scale(1) rotate(0deg);
        }
      }
      @keyframes w3m-iframe-fade-out {
        0% {
          opacity: 1;
        }
        100% {
          opacity: 0;
        }
      }
      @keyframes w3m-iframe-zoom-in {
        0% {
          transform: translateY(50px);
          opacity: 0;
        }
        100% {
          transform: translateY(0px);
          opacity: 1;
        }
      }
      @keyframes w3m-iframe-zoom-in-mobile {
        0% {
          transform: scale(0.95);
          opacity: 0;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
      :root {
        --w3m-modal-width: 360px;
        --w3m-color-mix-strength: ${(0, s.$m)(e?.['--w3m-color-mix-strength'] ? `${e['--w3m-color-mix-strength']}%` : '0%')};
        --w3m-font-family: ${(0, s.$m)(e?.['--w3m-font-family'] || 'Inter, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;')};
        --w3m-font-size-master: ${(0, s.$m)(e?.['--w3m-font-size-master'] || '10px')};
        --w3m-border-radius-master: ${(0, s.$m)(e?.['--w3m-border-radius-master'] || '4px')};
        --w3m-z-index: ${(0, s.$m)(e?.['--w3m-z-index'] || 999)};

        --wui-font-family: var(--w3m-font-family);

        --wui-font-size-mini: calc(var(--w3m-font-size-master) * 0.8);
        --wui-font-size-micro: var(--w3m-font-size-master);
        --wui-font-size-tiny: calc(var(--w3m-font-size-master) * 1.2);
        --wui-font-size-small: calc(var(--w3m-font-size-master) * 1.4);
        --wui-font-size-paragraph: calc(var(--w3m-font-size-master) * 1.6);
        --wui-font-size-medium: calc(var(--w3m-font-size-master) * 1.8);
        --wui-font-size-large: calc(var(--w3m-font-size-master) * 2);
        --wui-font-size-title-6: calc(var(--w3m-font-size-master) * 2.2);
        --wui-font-size-medium-title: calc(var(--w3m-font-size-master) * 2.4);
        --wui-font-size-2xl: calc(var(--w3m-font-size-master) * 4);

        --wui-border-radius-5xs: var(--w3m-border-radius-master);
        --wui-border-radius-4xs: calc(var(--w3m-border-radius-master) * 1.5);
        --wui-border-radius-3xs: calc(var(--w3m-border-radius-master) * 2);
        --wui-border-radius-xxs: calc(var(--w3m-border-radius-master) * 3);
        --wui-border-radius-xs: calc(var(--w3m-border-radius-master) * 4);
        --wui-border-radius-s: calc(var(--w3m-border-radius-master) * 5);
        --wui-border-radius-m: calc(var(--w3m-border-radius-master) * 7);
        --wui-border-radius-l: calc(var(--w3m-border-radius-master) * 9);
        --wui-border-radius-3xl: calc(var(--w3m-border-radius-master) * 20);

        --wui-font-weight-light: 400;
        --wui-font-weight-regular: 500;
        --wui-font-weight-medium: 600;
        --wui-font-weight-bold: 700;

        --wui-letter-spacing-2xl: -1.6px;
        --wui-letter-spacing-medium-title: -0.96px;
        --wui-letter-spacing-title-6: -0.88px;
        --wui-letter-spacing-large: -0.8px;
        --wui-letter-spacing-medium: -0.72px;
        --wui-letter-spacing-paragraph: -0.64px;
        --wui-letter-spacing-small: -0.56px;
        --wui-letter-spacing-tiny: -0.48px;
        --wui-letter-spacing-micro: -0.2px;
        --wui-letter-spacing-mini: -0.16px;

        --wui-spacing-0: 0px;
        --wui-spacing-4xs: 2px;
        --wui-spacing-3xs: 4px;
        --wui-spacing-xxs: 6px;
        --wui-spacing-2xs: 7px;
        --wui-spacing-xs: 8px;
        --wui-spacing-1xs: 10px;
        --wui-spacing-s: 12px;
        --wui-spacing-m: 14px;
        --wui-spacing-l: 16px;
        --wui-spacing-2l: 18px;
        --wui-spacing-xl: 20px;
        --wui-spacing-xxl: 24px;
        --wui-spacing-2xl: 32px;
        --wui-spacing-3xl: 40px;
        --wui-spacing-4xl: 90px;
        --wui-spacing-5xl: 95px;

        --wui-icon-box-size-xxs: 14px;
        --wui-icon-box-size-xs: 20px;
        --wui-icon-box-size-sm: 24px;
        --wui-icon-box-size-md: 32px;
        --wui-icon-box-size-mdl: 36px;
        --wui-icon-box-size-lg: 40px;
        --wui-icon-box-size-2lg: 48px;
        --wui-icon-box-size-xl: 64px;

        --wui-icon-size-inherit: inherit;
        --wui-icon-size-xxs: 10px;
        --wui-icon-size-xs: 12px;
        --wui-icon-size-sm: 14px;
        --wui-icon-size-md: 16px;
        --wui-icon-size-mdl: 18px;
        --wui-icon-size-lg: 20px;
        --wui-icon-size-xl: 24px;
        --wui-icon-size-xxl: 28px;

        --wui-wallet-image-size-inherit: inherit;
        --wui-wallet-image-size-sm: 40px;
        --wui-wallet-image-size-md: 56px;
        --wui-wallet-image-size-lg: 80px;

        --wui-visual-size-size-inherit: inherit;
        --wui-visual-size-sm: 40px;
        --wui-visual-size-md: 55px;
        --wui-visual-size-lg: 80px;

        --wui-box-size-md: 100px;
        --wui-box-size-lg: 120px;

        --wui-ease-out-power-2: cubic-bezier(0, 0, 0.22, 1);
        --wui-ease-out-power-1: cubic-bezier(0, 0, 0.55, 1);

        --wui-ease-in-power-3: cubic-bezier(0.66, 0, 1, 1);
        --wui-ease-in-power-2: cubic-bezier(0.45, 0, 1, 1);
        --wui-ease-in-power-1: cubic-bezier(0.3, 0, 1, 1);

        --wui-ease-inout-power-1: cubic-bezier(0.45, 0, 0.55, 1);

        --wui-duration-lg: 200ms;
        --wui-duration-md: 125ms;
        --wui-duration-sm: 75ms;

        --wui-path-network-sm: path(
          'M15.4 2.1a5.21 5.21 0 0 1 5.2 0l11.61 6.7a5.21 5.21 0 0 1 2.61 4.52v13.4c0 1.87-1 3.59-2.6 4.52l-11.61 6.7c-1.62.93-3.6.93-5.22 0l-11.6-6.7a5.21 5.21 0 0 1-2.61-4.51v-13.4c0-1.87 1-3.6 2.6-4.52L15.4 2.1Z'
        );

        --wui-path-network-md: path(
          'M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z'
        );

        --wui-path-network-lg: path(
          'M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z'
        );

        --wui-width-network-sm: 36px;
        --wui-width-network-md: 48px;
        --wui-width-network-lg: 86px;

        --wui-height-network-sm: 40px;
        --wui-height-network-md: 54px;
        --wui-height-network-lg: 96px;

        --wui-icon-size-network-xs: 12px;
        --wui-icon-size-network-sm: 16px;
        --wui-icon-size-network-md: 24px;
        --wui-icon-size-network-lg: 42px;

        --wui-color-inherit: inherit;

        --wui-color-inverse-100: #fff;
        --wui-color-inverse-000: #000;

        --wui-cover: rgba(20, 20, 20, 0.8);

        --wui-color-modal-bg: var(--wui-color-modal-bg-base);

        --wui-color-accent-100: var(--wui-color-accent-base-100);
        --wui-color-accent-090: var(--wui-color-accent-base-090);
        --wui-color-accent-080: var(--wui-color-accent-base-080);

        --wui-color-success-100: var(--wui-color-success-base-100);
        --wui-color-success-125: var(--wui-color-success-base-125);

        --wui-color-warning-100: var(--wui-color-warning-base-100);

        --wui-color-error-100: var(--wui-color-error-base-100);
        --wui-color-error-125: var(--wui-color-error-base-125);

        --wui-color-blue-100: var(--wui-color-blue-base-100);
        --wui-color-blue-90: var(--wui-color-blue-base-90);

        --wui-icon-box-bg-error-100: var(--wui-icon-box-bg-error-base-100);
        --wui-icon-box-bg-blue-100: var(--wui-icon-box-bg-blue-base-100);
        --wui-icon-box-bg-success-100: var(--wui-icon-box-bg-success-base-100);
        --wui-icon-box-bg-inverse-100: var(--wui-icon-box-bg-inverse-base-100);

        --wui-all-wallets-bg-100: var(--wui-all-wallets-bg-100);

        --wui-avatar-border: var(--wui-avatar-border-base);

        --wui-thumbnail-border: var(--wui-thumbnail-border-base);

        --wui-wallet-button-bg: var(--wui-wallet-button-bg-base);

        --wui-box-shadow-blue: var(--wui-color-accent-glass-020);
      }

      @supports (background: color-mix(in srgb, white 50%, black)) {
        :root {
          --wui-color-modal-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-modal-bg-base)
          );

          --wui-box-shadow-blue: color-mix(in srgb, var(--wui-color-accent-100) 20%, transparent);

          --wui-color-accent-100: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 100%,
            transparent
          );
          --wui-color-accent-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-color-accent-glass-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-glass-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-color-accent-glass-020: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 20%,
            transparent
          );
          --wui-color-accent-glass-015: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 15%,
            transparent
          );
          --wui-color-accent-glass-010: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 10%,
            transparent
          );
          --wui-color-accent-glass-005: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 5%,
            transparent
          );
          --wui-color-accent-002: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 2%,
            transparent
          );

          --wui-color-fg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-100)
          );
          --wui-color-fg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-125)
          );
          --wui-color-fg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-150)
          );
          --wui-color-fg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-175)
          );
          --wui-color-fg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-200)
          );
          --wui-color-fg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-225)
          );
          --wui-color-fg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-250)
          );
          --wui-color-fg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-275)
          );
          --wui-color-fg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-300)
          );
          --wui-color-fg-325: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-325)
          );
          --wui-color-fg-350: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-350)
          );

          --wui-color-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-100)
          );
          --wui-color-bg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-125)
          );
          --wui-color-bg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-150)
          );
          --wui-color-bg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-175)
          );
          --wui-color-bg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-200)
          );
          --wui-color-bg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-225)
          );
          --wui-color-bg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-250)
          );
          --wui-color-bg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-275)
          );
          --wui-color-bg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-300)
          );
          --wui-color-bg-325: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-325)
          );
          --wui-color-bg-350: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-350)
          );

          --wui-color-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-100)
          );
          --wui-color-success-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-125)
          );

          --wui-color-warning-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-warning-base-100)
          );

          --wui-color-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-100)
          );
          --wui-color-blue-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-blue-base-100)
          );
          --wui-color-blue-90: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-blue-base-90)
          );
          --wui-color-error-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-125)
          );

          --wui-icon-box-bg-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-error-base-100)
          );
          --wui-icon-box-bg-accent-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-blue-base-100)
          );
          --wui-icon-box-bg-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-success-base-100)
          );
          --wui-icon-box-bg-inverse-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-inverse-base-100)
          );

          --wui-all-wallets-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-all-wallets-bg-100)
          );

          --wui-avatar-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-avatar-border-base)
          );

          --wui-thumbnail-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-thumbnail-border-base)
          );

          --wui-wallet-button-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-wallet-button-bg-base)
          );
        }
      }
    `,
          light: (0, s.iv)`
      :root {
        --w3m-color-mix: ${(0, s.$m)(e?.['--w3m-color-mix'] || '#fff')};
        --w3m-accent: ${(0, s.$m)((0, o.t)(e, 'dark')['--w3m-accent'])};
        --w3m-default: #fff;

        --wui-color-modal-bg-base: ${(0, s.$m)((0, o.t)(e, 'dark')['--w3m-background'])};
        --wui-color-accent-base-100: var(--w3m-accent);

        --wui-color-blueberry-100: hsla(230, 100%, 67%, 1);
        --wui-color-blueberry-090: hsla(231, 76%, 61%, 1);
        --wui-color-blueberry-080: hsla(230, 59%, 55%, 1);
        --wui-color-blueberry-050: hsla(231, 100%, 70%, 0.1);

        --wui-color-fg-100: #e4e7e7;
        --wui-color-fg-125: #d0d5d5;
        --wui-color-fg-150: #a8b1b1;
        --wui-color-fg-175: #a8b0b0;
        --wui-color-fg-200: #949e9e;
        --wui-color-fg-225: #868f8f;
        --wui-color-fg-250: #788080;
        --wui-color-fg-275: #788181;
        --wui-color-fg-300: #6e7777;
        --wui-color-fg-325: #9a9a9a;
        --wui-color-fg-350: #363636;

        --wui-color-bg-100: #141414;
        --wui-color-bg-125: #191a1a;
        --wui-color-bg-150: #1e1f1f;
        --wui-color-bg-175: #222525;
        --wui-color-bg-200: #272a2a;
        --wui-color-bg-225: #2c3030;
        --wui-color-bg-250: #313535;
        --wui-color-bg-275: #363b3b;
        --wui-color-bg-300: #3b4040;
        --wui-color-bg-325: #252525;
        --wui-color-bg-350: #ffffff;

        --wui-color-success-base-100: #26d962;
        --wui-color-success-base-125: #30a46b;

        --wui-color-warning-base-100: #f3a13f;

        --wui-color-error-base-100: #f25a67;
        --wui-color-error-base-125: #df4a34;

        --wui-color-blue-base-100: rgba(102, 125, 255, 1);
        --wui-color-blue-base-90: rgba(102, 125, 255, 0.9);

        --wui-color-success-glass-001: rgba(38, 217, 98, 0.01);
        --wui-color-success-glass-002: rgba(38, 217, 98, 0.02);
        --wui-color-success-glass-005: rgba(38, 217, 98, 0.05);
        --wui-color-success-glass-010: rgba(38, 217, 98, 0.1);
        --wui-color-success-glass-015: rgba(38, 217, 98, 0.15);
        --wui-color-success-glass-020: rgba(38, 217, 98, 0.2);
        --wui-color-success-glass-025: rgba(38, 217, 98, 0.25);
        --wui-color-success-glass-030: rgba(38, 217, 98, 0.3);
        --wui-color-success-glass-060: rgba(38, 217, 98, 0.6);
        --wui-color-success-glass-080: rgba(38, 217, 98, 0.8);

        --wui-color-success-glass-reown-020: rgba(48, 164, 107, 0.2);

        --wui-color-warning-glass-reown-020: rgba(243, 161, 63, 0.2);

        --wui-color-error-glass-001: rgba(242, 90, 103, 0.01);
        --wui-color-error-glass-002: rgba(242, 90, 103, 0.02);
        --wui-color-error-glass-005: rgba(242, 90, 103, 0.05);
        --wui-color-error-glass-010: rgba(242, 90, 103, 0.1);
        --wui-color-error-glass-015: rgba(242, 90, 103, 0.15);
        --wui-color-error-glass-020: rgba(242, 90, 103, 0.2);
        --wui-color-error-glass-025: rgba(242, 90, 103, 0.25);
        --wui-color-error-glass-030: rgba(242, 90, 103, 0.3);
        --wui-color-error-glass-060: rgba(242, 90, 103, 0.6);
        --wui-color-error-glass-080: rgba(242, 90, 103, 0.8);

        --wui-color-error-glass-reown-020: rgba(223, 74, 52, 0.2);

        --wui-color-gray-glass-001: rgba(255, 255, 255, 0.01);
        --wui-color-gray-glass-002: rgba(255, 255, 255, 0.02);
        --wui-color-gray-glass-005: rgba(255, 255, 255, 0.05);
        --wui-color-gray-glass-010: rgba(255, 255, 255, 0.1);
        --wui-color-gray-glass-015: rgba(255, 255, 255, 0.15);
        --wui-color-gray-glass-020: rgba(255, 255, 255, 0.2);
        --wui-color-gray-glass-025: rgba(255, 255, 255, 0.25);
        --wui-color-gray-glass-030: rgba(255, 255, 255, 0.3);
        --wui-color-gray-glass-060: rgba(255, 255, 255, 0.6);
        --wui-color-gray-glass-080: rgba(255, 255, 255, 0.8);
        --wui-color-gray-glass-090: rgba(255, 255, 255, 0.9);

        --wui-color-dark-glass-100: rgba(42, 42, 42, 1);

        --wui-icon-box-bg-error-base-100: #3c2426;
        --wui-icon-box-bg-blue-base-100: #20303f;
        --wui-icon-box-bg-success-base-100: #1f3a28;
        --wui-icon-box-bg-inverse-base-100: #243240;

        --wui-all-wallets-bg-100: #222b35;

        --wui-avatar-border-base: #252525;

        --wui-thumbnail-border-base: #252525;

        --wui-wallet-button-bg-base: var(--wui-color-bg-125);

        --w3m-card-embedded-shadow-color: rgb(17 17 18 / 25%);
      }
    `,
          dark: (0, s.iv)`
      :root {
        --w3m-color-mix: ${(0, s.$m)(e?.['--w3m-color-mix'] || '#000')};
        --w3m-accent: ${(0, s.$m)((0, o.t)(e, 'light')['--w3m-accent'])};
        --w3m-default: #000;

        --wui-color-modal-bg-base: ${(0, s.$m)((0, o.t)(e, 'light')['--w3m-background'])};
        --wui-color-accent-base-100: var(--w3m-accent);

        --wui-color-blueberry-100: hsla(231, 100%, 70%, 1);
        --wui-color-blueberry-090: hsla(231, 97%, 72%, 1);
        --wui-color-blueberry-080: hsla(231, 92%, 74%, 1);

        --wui-color-fg-100: #141414;
        --wui-color-fg-125: #2d3131;
        --wui-color-fg-150: #474d4d;
        --wui-color-fg-175: #636d6d;
        --wui-color-fg-200: #798686;
        --wui-color-fg-225: #828f8f;
        --wui-color-fg-250: #8b9797;
        --wui-color-fg-275: #95a0a0;
        --wui-color-fg-300: #9ea9a9;
        --wui-color-fg-325: #9a9a9a;
        --wui-color-fg-350: #d0d0d0;

        --wui-color-bg-100: #ffffff;
        --wui-color-bg-125: #f5fafa;
        --wui-color-bg-150: #f3f8f8;
        --wui-color-bg-175: #eef4f4;
        --wui-color-bg-200: #eaf1f1;
        --wui-color-bg-225: #e5eded;
        --wui-color-bg-250: #e1e9e9;
        --wui-color-bg-275: #dce7e7;
        --wui-color-bg-300: #d8e3e3;
        --wui-color-bg-325: #f3f3f3;
        --wui-color-bg-350: #202020;

        --wui-color-success-base-100: #26b562;
        --wui-color-success-base-125: #30a46b;

        --wui-color-warning-base-100: #f3a13f;

        --wui-color-error-base-100: #f05142;
        --wui-color-error-base-125: #df4a34;

        --wui-color-blue-base-100: rgba(102, 125, 255, 1);
        --wui-color-blue-base-90: rgba(102, 125, 255, 0.9);

        --wui-color-success-glass-001: rgba(38, 181, 98, 0.01);
        --wui-color-success-glass-002: rgba(38, 181, 98, 0.02);
        --wui-color-success-glass-005: rgba(38, 181, 98, 0.05);
        --wui-color-success-glass-010: rgba(38, 181, 98, 0.1);
        --wui-color-success-glass-015: rgba(38, 181, 98, 0.15);
        --wui-color-success-glass-020: rgba(38, 181, 98, 0.2);
        --wui-color-success-glass-025: rgba(38, 181, 98, 0.25);
        --wui-color-success-glass-030: rgba(38, 181, 98, 0.3);
        --wui-color-success-glass-060: rgba(38, 181, 98, 0.6);
        --wui-color-success-glass-080: rgba(38, 181, 98, 0.8);

        --wui-color-success-glass-reown-020: rgba(48, 164, 107, 0.2);

        --wui-color-warning-glass-reown-020: rgba(243, 161, 63, 0.2);

        --wui-color-error-glass-001: rgba(240, 81, 66, 0.01);
        --wui-color-error-glass-002: rgba(240, 81, 66, 0.02);
        --wui-color-error-glass-005: rgba(240, 81, 66, 0.05);
        --wui-color-error-glass-010: rgba(240, 81, 66, 0.1);
        --wui-color-error-glass-015: rgba(240, 81, 66, 0.15);
        --wui-color-error-glass-020: rgba(240, 81, 66, 0.2);
        --wui-color-error-glass-025: rgba(240, 81, 66, 0.25);
        --wui-color-error-glass-030: rgba(240, 81, 66, 0.3);
        --wui-color-error-glass-060: rgba(240, 81, 66, 0.6);
        --wui-color-error-glass-080: rgba(240, 81, 66, 0.8);

        --wui-color-error-glass-reown-020: rgba(223, 74, 52, 0.2);

        --wui-icon-box-bg-error-base-100: #f4dfdd;
        --wui-icon-box-bg-blue-base-100: #d9ecfb;
        --wui-icon-box-bg-success-base-100: #daf0e4;
        --wui-icon-box-bg-inverse-base-100: #dcecfc;

        --wui-all-wallets-bg-100: #e8f1fa;

        --wui-avatar-border-base: #f3f4f4;

        --wui-thumbnail-border-base: #eaefef;

        --wui-wallet-button-bg-base: var(--wui-color-bg-125);

        --wui-color-gray-glass-001: rgba(0, 0, 0, 0.01);
        --wui-color-gray-glass-002: rgba(0, 0, 0, 0.02);
        --wui-color-gray-glass-005: rgba(0, 0, 0, 0.05);
        --wui-color-gray-glass-010: rgba(0, 0, 0, 0.1);
        --wui-color-gray-glass-015: rgba(0, 0, 0, 0.15);
        --wui-color-gray-glass-020: rgba(0, 0, 0, 0.2);
        --wui-color-gray-glass-025: rgba(0, 0, 0, 0.25);
        --wui-color-gray-glass-030: rgba(0, 0, 0, 0.3);
        --wui-color-gray-glass-060: rgba(0, 0, 0, 0.6);
        --wui-color-gray-glass-080: rgba(0, 0, 0, 0.8);
        --wui-color-gray-glass-090: rgba(0, 0, 0, 0.9);

        --wui-color-dark-glass-100: rgba(233, 233, 233, 1);

        --w3m-card-embedded-shadow-color: rgb(224 225 233 / 25%);
      }
    `,
        };
      }
      let p = (0, s.iv)`
  *,
  *::after,
  *::before,
  :host {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-style: normal;
    text-rendering: optimizeSpeed;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    font-family: var(--wui-font-family);
    backface-visibility: hidden;
  }
`,
        h = (0, s.iv)`
  button,
  a {
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    transition:
      color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      background-color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      border var(--wui-duration-lg) var(--wui-ease-out-power-1),
      border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1),
      box-shadow var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: background-color, color, border, box-shadow, border-radius;
    outline: none;
    border: none;
    column-gap: var(--wui-spacing-3xs);
    background-color: transparent;
    text-decoration: none;
  }

  wui-flex {
    transition: border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: border-radius;
  }

  button:disabled > wui-wallet-image,
  button:disabled > wui-all-wallets-image,
  button:disabled > wui-network-image,
  button:disabled > wui-image,
  button:disabled > wui-transaction-visual,
  button:disabled > wui-logo {
    filter: grayscale(1);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-gray-glass-005);
    }

    button:active:enabled {
      background-color: var(--wui-color-gray-glass-010);
    }
  }

  button:disabled > wui-icon-box {
    opacity: 0.5;
  }

  input {
    border: none;
    outline: none;
    appearance: none;
  }
`,
        y = (0, s.iv)`
  .wui-color-inherit {
    color: var(--wui-color-inherit);
  }

  .wui-color-accent-100 {
    color: var(--wui-color-accent-100);
  }

  .wui-color-error-100 {
    color: var(--wui-color-error-100);
  }

  .wui-color-blue-100 {
    color: var(--wui-color-blue-100);
  }

  .wui-color-blue-90 {
    color: var(--wui-color-blue-90);
  }

  .wui-color-error-125 {
    color: var(--wui-color-error-125);
  }

  .wui-color-success-100 {
    color: var(--wui-color-success-100);
  }

  .wui-color-success-125 {
    color: var(--wui-color-success-125);
  }

  .wui-color-inverse-100 {
    color: var(--wui-color-inverse-100);
  }

  .wui-color-inverse-000 {
    color: var(--wui-color-inverse-000);
  }

  .wui-color-fg-100 {
    color: var(--wui-color-fg-100);
  }

  .wui-color-fg-200 {
    color: var(--wui-color-fg-200);
  }

  .wui-color-fg-300 {
    color: var(--wui-color-fg-300);
  }

  .wui-color-fg-325 {
    color: var(--wui-color-fg-325);
  }

  .wui-color-fg-350 {
    color: var(--wui-color-fg-350);
  }

  .wui-bg-color-inherit {
    background-color: var(--wui-color-inherit);
  }

  .wui-bg-color-blue-100 {
    background-color: var(--wui-color-accent-100);
  }

  .wui-bg-color-error-100 {
    background-color: var(--wui-color-error-100);
  }

  .wui-bg-color-error-125 {
    background-color: var(--wui-color-error-125);
  }

  .wui-bg-color-success-100 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-success-125 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-inverse-100 {
    background-color: var(--wui-color-inverse-100);
  }

  .wui-bg-color-inverse-000 {
    background-color: var(--wui-color-inverse-000);
  }

  .wui-bg-color-fg-100 {
    background-color: var(--wui-color-fg-100);
  }

  .wui-bg-color-fg-200 {
    background-color: var(--wui-color-fg-200);
  }

  .wui-bg-color-fg-300 {
    background-color: var(--wui-color-fg-300);
  }

  .wui-color-fg-325 {
    background-color: var(--wui-color-fg-325);
  }

  .wui-color-fg-350 {
    background-color: var(--wui-color-fg-350);
  }
`;
    },
    82072: function (e, t, n) {
      'use strict';
      n.d(t, {
        H: function () {
          return r;
        },
      });
      let r = {
        getSpacingStyles: (e, t) =>
          Array.isArray(e)
            ? e[t]
              ? `var(--wui-spacing-${e[t]})`
              : void 0
            : 'string' == typeof e
              ? `var(--wui-spacing-${e})`
              : void 0,
        getFormattedDate: (e) =>
          new Intl.DateTimeFormat('en-US', { month: 'short', day: 'numeric' }).format(e),
        getHostName(e) {
          try {
            return new URL(e).hostname;
          } catch (e) {
            return '';
          }
        },
        getTruncateString: ({ string: e, charsStart: t, charsEnd: n, truncate: r }) =>
          e.length <= t + n
            ? e
            : 'end' === r
              ? `${e.substring(0, t)}...`
              : 'start' === r
                ? `...${e.substring(e.length - n)}`
                : `${e.substring(0, Math.floor(t))}...${e.substring(e.length - Math.floor(n))}`,
        generateAvatarColors(e) {
          let t = e
              .toLowerCase()
              .replace(/^0x/iu, '')
              .replace(/[^a-f0-9]/gu, '')
              .substring(0, 6)
              .padEnd(6, '0'),
            n = this.hexToRgb(t),
            r = getComputedStyle(document.documentElement).getPropertyValue(
              '--w3m-border-radius-master'
            ),
            i = 100 - 3 * Number(r?.replace('px', '')),
            a = `${i}% ${i}% at 65% 40%`,
            s = [];
          for (let e = 0; e < 5; e += 1) {
            let t = this.tintColor(n, 0.15 * e);
            s.push(`rgb(${t[0]}, ${t[1]}, ${t[2]})`);
          }
          return `
    --local-color-1: ${s[0]};
    --local-color-2: ${s[1]};
    --local-color-3: ${s[2]};
    --local-color-4: ${s[3]};
    --local-color-5: ${s[4]};
    --local-radial-circle: ${a}
   `;
        },
        hexToRgb(e) {
          let t = parseInt(e, 16);
          return [(t >> 16) & 255, (t >> 8) & 255, 255 & t];
        },
        tintColor(e, t) {
          let [n, r, i] = e;
          return [
            Math.round(n + (255 - n) * t),
            Math.round(r + (255 - r) * t),
            Math.round(i + (255 - i) * t),
          ];
        },
        isNumber: (e) => /^[0-9]+$/u.test(e),
        getColorTheme: (e) =>
          e ||
          ('undefined' != typeof window && window.matchMedia
            ? window.matchMedia('(prefers-color-scheme: dark)')?.matches
              ? 'dark'
              : 'light'
            : 'dark'),
        splitBalance(e) {
          let t = e.split('.');
          return 2 === t.length ? [t[0], t[1]] : ['0', '00'];
        },
        roundNumber: (e, t, n) => (e.toString().length >= t ? Number(e).toFixed(n) : e),
        formatNumberToLocalString: (e, t = 2) =>
          void 0 === e
            ? '0.00'
            : 'number' == typeof e
              ? e.toLocaleString('en-US', { maximumFractionDigits: t, minimumFractionDigits: t })
              : parseFloat(e).toLocaleString('en-US', {
                  maximumFractionDigits: t,
                  minimumFractionDigits: t,
                }),
      };
    },
    55202: function (e, t, n) {
      'use strict';
      function r(e) {
        return function (t) {
          return 'function' == typeof t
            ? (customElements.get(e) || customElements.define(e, t), t)
            : (function (e, t) {
                let { kind: n, elements: r } = t;
                return {
                  kind: n,
                  elements: r,
                  finisher(t) {
                    customElements.get(e) || customElements.define(e, t);
                  },
                };
              })(e, t);
        };
      }
      n.d(t, {
        M: function () {
          return r;
        },
      });
    },
    9281: function (e, t, n) {
      'use strict';
      n.d(t, {
        f: function () {
          return d;
        },
      });
      var r = n(32224),
        i = n(22791),
        a = n(49786),
        s = n(31507),
        o = n(97059),
        l = n(23893);
      function u(e, t) {
        let n = new URL('https://rpc.walletconnect.org/v1/');
        return n.searchParams.set('chainId', e), n.searchParams.set('projectId', t), n.toString();
      }
      let c = [
          'near:mainnet',
          'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',
          'eip155:1101',
          'eip155:56',
          'eip155:42161',
          'eip155:7777777',
          'eip155:59144',
          'eip155:324',
          'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1',
          'eip155:5000',
          'solana:4sgjmw1sunhzsxgspuhpqldx6wiyjntz',
          'eip155:80084',
          'eip155:5003',
          'eip155:100',
          'eip155:8453',
          'eip155:42220',
          'eip155:1313161555',
          'eip155:17000',
          'eip155:1',
          'eip155:300',
          'eip155:1313161554',
          'eip155:1329',
          'eip155:84532',
          'eip155:421614',
          'eip155:11155111',
          'eip155:8217',
          'eip155:43114',
          'solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z',
          'eip155:999999999',
          'eip155:11155420',
          'eip155:80002',
          'eip155:97',
          'eip155:43113',
          'eip155:137',
          'eip155:10',
          'eip155:1301',
          'bip122:000000000019d6689c085ae165831e93',
          'bip122:000000000933ea01ad0ee984209779ba',
        ],
        d = {
          extendRpcUrlWithProjectId(e, t) {
            let n = !1;
            try {
              n = 'rpc.walletconnect.org' === new URL(e).host;
            } catch (e) {
              n = !1;
            }
            if (n) {
              let n = new URL(e);
              return (
                n.searchParams.has('projectId') || n.searchParams.set('projectId', t), n.toString()
              );
            }
            return e;
          },
          isCaipNetwork: (e) => 'chainNamespace' in e && 'caipNetworkId' in e,
          getChainNamespace(e) {
            return this.isCaipNetwork(e) ? e.chainNamespace : a.b.CHAIN.EVM;
          },
          getCaipNetworkId(e) {
            return this.isCaipNetwork(e) ? e.caipNetworkId : `${a.b.CHAIN.EVM}:${e.id}`;
          },
          getDefaultRpcUrl(e, t, n) {
            let r = e.rpcUrls?.default?.http?.[0];
            return c.includes(t) ? u(t, n) : r || '';
          },
          extendCaipNetwork(e, { customNetworkImageUrls: t, projectId: n, customRpcUrls: r }) {
            let i = this.getChainNamespace(e),
              a = this.getCaipNetworkId(e),
              s = e.rpcUrls.default.http?.[0],
              o = this.getDefaultRpcUrl(e, a, n),
              u = e?.rpcUrls?.chainDefault?.http?.[0] || s,
              c = r?.[a]?.map((e) => e.url) || [],
              d = [...c, o],
              p = [...c];
            return (
              u && !p.includes(u) && p.push(u),
              {
                ...e,
                chainNamespace: i,
                caipNetworkId: a,
                assets: { imageId: l.C.NetworkImageIds[e.id], imageUrl: t?.[e.id] },
                rpcUrls: { ...e.rpcUrls, default: { http: d }, chainDefault: { http: p } },
              }
            );
          },
          extendCaipNetworks: (e, { customNetworkImageUrls: t, projectId: n, customRpcUrls: r }) =>
            e.map((e) =>
              d.extendCaipNetwork(e, { customNetworkImageUrls: t, customRpcUrls: r, projectId: n })
            ),
          getViemTransport(e, t, n) {
            let a = [];
            return (
              n?.forEach((e) => {
                a.push(r.d(e.url, e.config));
              }),
              c.includes(e.caipNetworkId) &&
                a.push(
                  (0, r.d)(u(e.caipNetworkId, t), {
                    fetchOptions: { headers: { 'Content-Type': 'text/plain' } },
                  })
                ),
              e?.rpcUrls?.default?.http?.forEach((e) => {
                a.push(r.d(e));
              }),
              (0, i.tv)(a)
            );
          },
          extendWagmiTransports(e, t, n) {
            if (c.includes(e.caipNetworkId)) {
              let a = this.getDefaultRpcUrl(e, e.caipNetworkId, t);
              return (0, i.tv)([n, (0, r.d)(a)]);
            }
            return n;
          },
          getUnsupportedNetwork: (e) => ({
            id: e.split(':')[1],
            caipNetworkId: e,
            name: a.b.UNSUPPORTED_NETWORK_NAME,
            chainNamespace: e.split(':')[0],
            nativeCurrency: { name: '', decimals: 0, symbol: '' },
            rpcUrls: { default: { http: [] } },
          }),
          getCaipNetworkFromStorage(e) {
            let t = s.M.getActiveCaipNetworkId(),
              n = o.R.getAllRequestedCaipNetworks(),
              r = Array.from(o.R.state.chains?.keys() || []),
              i = t?.split(':')[0],
              a = !!i && r.includes(i),
              l = n?.find((e) => e.caipNetworkId === t);
            return a && !l && t ? this.getUnsupportedNetwork(t) : l || e || n?.[0];
          },
        };
    },
    5436: function (e, t, n) {
      'use strict';
      n.d(t, {
        b: function () {
          return r;
        },
      });
      let r = {
        METMASK_CONNECTOR_NAME: 'MetaMask',
        TRUST_CONNECTOR_NAME: 'Trust Wallet',
        SOLFLARE_CONNECTOR_NAME: 'Solflare',
        PHANTOM_CONNECTOR_NAME: 'Phantom',
        COIN98_CONNECTOR_NAME: 'Coin98',
        MAGIC_EDEN_CONNECTOR_NAME: 'Magic Eden',
        BACKPACK_CONNECTOR_NAME: 'Backpack',
        BITGET_CONNECTOR_NAME: 'Bitget Wallet',
        FRONTIER_CONNECTOR_NAME: 'Frontier',
        XVERSE_CONNECTOR_NAME: 'Xverse Wallet',
        LEATHER_CONNECTOR_NAME: 'Leather',
        EIP155: 'eip155',
        ADD_CHAIN_METHOD: 'wallet_addEthereumChain',
        EIP6963_ANNOUNCE_EVENT: 'eip6963:announceProvider',
        EIP6963_REQUEST_EVENT: 'eip6963:requestProvider',
        CONNECTOR_RDNS_MAP: {
          coinbaseWallet: 'com.coinbase.wallet',
          coinbaseWalletSDK: 'com.coinbase.wallet',
        },
        CONNECTOR_TYPE_EXTERNAL: 'EXTERNAL',
        CONNECTOR_TYPE_WALLET_CONNECT: 'WALLET_CONNECT',
        CONNECTOR_TYPE_INJECTED: 'INJECTED',
        CONNECTOR_TYPE_ANNOUNCED: 'ANNOUNCED',
        CONNECTOR_TYPE_AUTH: 'AUTH',
        CONNECTOR_TYPE_MULTI_CHAIN: 'MULTI_CHAIN',
        CONNECTOR_TYPE_W3M_AUTH: 'ID_AUTH',
      };
    },
    3138: function (e, t, n) {
      'use strict';
      n.d(t, {
        j: function () {
          return r;
        },
      });
      let r = {
        UniversalProviderErrors: {
          UNAUTHORIZED_DOMAIN_NOT_ALLOWED: {
            message: 'Unauthorized: origin not allowed',
            alertErrorKey: 'INVALID_APP_CONFIGURATION',
          },
          JWT_VALIDATION_ERROR: {
            message: 'JWT validation error: JWT Token is not yet valid',
            alertErrorKey: 'JWT_TOKEN_NOT_VALID',
          },
          INVALID_KEY: {
            message: 'Unauthorized: invalid key',
            alertErrorKey: 'INVALID_PROJECT_ID',
          },
        },
        ALERT_ERRORS: {
          SWITCH_NETWORK_NOT_FOUND: {
            shortMessage: 'Network Not Found',
            longMessage:
              "Network not found - please make sure it is included in 'networks' array in createAppKit function",
          },
          INVALID_APP_CONFIGURATION: {
            shortMessage: 'Invalid App Configuration',
            longMessage: () =>
              `Origin ${'undefined' != typeof window ? window.origin : 'unknown'} not found on Allowlist - update configuration on cloud.reown.com`,
          },
          SOCIALS_TIMEOUT: {
            shortMessage: 'Invalid App Configuration',
            longMessage: () =>
              'There was an issue loading the embedded wallet. Please verify that your domain is allowed at cloud.reown.com',
          },
          JWT_TOKEN_NOT_VALID: {
            shortMessage: 'Session Expired',
            longMessage:
              'Invalid session found on UniversalProvider - please check your time settings and connect again',
          },
          INVALID_PROJECT_ID: {
            shortMessage: 'Invalid App Configuration',
            longMessage: 'Invalid Project ID - update configuration',
          },
          PROJECT_ID_NOT_CONFIGURED: {
            shortMessage: 'Project ID Not Configured',
            longMessage: 'Project ID Not Configured - update configuration on cloud.reown.com',
          },
        },
      };
    },
    62692: function (e, t, n) {
      'use strict';
      n.d(t, {
        g: function () {
          return i;
        },
      });
      var r = n(5436);
      let i = {
        getCaipTokens(e) {
          if (!e) return;
          let t = {};
          return (
            Object.entries(e).forEach(([e, n]) => {
              t[`${r.b.EIP155}:${e}`] = n;
            }),
            t
          );
        },
        isLowerCaseMatch: (e, t) => e?.toLowerCase() === t?.toLowerCase(),
      };
    },
    23893: function (e, t, n) {
      'use strict';
      n.d(t, {
        C: function () {
          return a;
        },
      });
      var r = n(49786),
        i = n(5436);
      let a = {
        ConnectorExplorerIds: {
          [r.b.CONNECTOR_ID.COINBASE]:
            'fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa',
          [r.b.CONNECTOR_ID.COINBASE_SDK]:
            'fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa',
          [r.b.CONNECTOR_ID.SAFE]:
            '225affb176778569276e484e1b92637ad061b01e13a048b35a9d280c3b58970f',
          [r.b.CONNECTOR_ID.LEDGER]:
            '19177a98252e07ddfc9af2083ba8e07ef627cb6103467ffebb3f8f4205fd7927',
          [r.b.CONNECTOR_ID.OKX]:
            '971e689d0a5be527bac79629b4ee9b925e82208e5168b733496a09c0faed0709',
          [i.b.METMASK_CONNECTOR_NAME]:
            'c57ca95b47569778a828d19178114f4db188b89b763c899ba0be274e97267d96',
          [i.b.TRUST_CONNECTOR_NAME]:
            '4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0',
          [i.b.SOLFLARE_CONNECTOR_NAME]:
            '1ca0bdd4747578705b1939af023d120677c64fe6ca76add81fda36e350605e79',
          [i.b.PHANTOM_CONNECTOR_NAME]:
            'a797aa35c0fadbfc1a53e7f675162ed5226968b44a19ee3d24385c64d1d3c393',
          [i.b.COIN98_CONNECTOR_NAME]:
            '2a3c89040ac3b723a1972a33a125b1db11e258a6975d3a61252cd64e6ea5ea01',
          [i.b.MAGIC_EDEN_CONNECTOR_NAME]:
            '8b830a2b724a9c3fbab63af6f55ed29c9dfa8a55e732dc88c80a196a2ba136c6',
          [i.b.BACKPACK_CONNECTOR_NAME]:
            '2bd8c14e035c2d48f184aaa168559e86b0e3433228d3c4075900a221785019b0',
          [i.b.BITGET_CONNECTOR_NAME]:
            '38f5d18bd8522c244bdd70cb4a68e0e718865155811c043f052fb9f1c51de662',
          [i.b.FRONTIER_CONNECTOR_NAME]:
            '85db431492aa2e8672e93f4ea7acf10c88b97b867b0d373107af63dc4880f041',
          [i.b.XVERSE_CONNECTOR_NAME]:
            '2a87d74ae02e10bdd1f51f7ce6c4e1cc53cd5f2c0b6b5ad0d7b3007d2b13de7b',
          [i.b.LEATHER_CONNECTOR_NAME]:
            '483afe1df1df63daf313109971ff3ef8356ddf1cc4e45877d205eee0b7893a13',
        },
        NetworkImageIds: {
          1: 'ba0ba0cd-17c6-4806-ad93-f9d174f17900',
          42161: '3bff954d-5cb0-47a0-9a23-d20192e74600',
          43114: '30c46e53-e989-45fb-4549-be3bd4eb3b00',
          56: '93564157-2e8e-4ce7-81df-b264dbee9b00',
          250: '06b26297-fe0c-4733-5d6b-ffa5498aac00',
          10: 'ab9c186a-c52f-464b-2906-ca59d760a400',
          137: '41d04d42-da3b-4453-8506-668cc0727900',
          5e3: 'e86fae9b-b770-4eea-e520-150e12c81100',
          295: '6a97d510-cac8-4e58-c7ce-e8681b044c00',
          11155111: 'e909ea0a-f92a-4512-c8fc-748044ea6800',
          84532: 'a18a7ecd-e307-4360-4746-283182228e00',
          1301: '4eeea7ef-0014-4649-5d1d-07271a80f600',
          130: '2257980a-3463-48c6-cbac-a42d2a956e00',
          10143: '0a728e83-bacb-46db-7844-948f05434900',
          100: '02b53f6a-e3d4-479e-1cb4-21178987d100',
          9001: 'f926ff41-260d-4028-635e-91913fc28e00',
          324: 'b310f07f-4ef7-49f3-7073-2a0a39685800',
          314: '5a73b3dd-af74-424e-cae0-0de859ee9400',
          4689: '34e68754-e536-40da-c153-6ef2e7188a00',
          1088: '3897a66d-40b9-4833-162f-a2c90531c900',
          1284: '161038da-44ae-4ec7-1208-0ea569454b00',
          1285: 'f1d73bb6-5450-4e18-38f7-fb6484264a00',
          7777777: '845c60df-d429-4991-e687-91ae45791600',
          42220: 'ab781bbc-ccc6-418d-d32d-789b15da1f00',
          8453: '7289c336-3981-4081-c5f4-efc26ac64a00',
          1313161554: '3ff73439-a619-4894-9262-4470c773a100',
          2020: 'b8101fc0-9c19-4b6f-ec65-f6dfff106e00',
          2021: 'b8101fc0-9c19-4b6f-ec65-f6dfff106e00',
          80094: 'e329c2c9-59b0-4a02-83e4-212ff3779900',
          2741: 'fc2427d1-5af9-4a9c-8da5-6f94627cd900',
          '5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp': 'a1b58899-f671-4276-6a5e-56ca5bd59700',
          '4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z': 'a1b58899-f671-4276-6a5e-56ca5bd59700',
          EtWTRABZaYq6iMfeYKouRu166VU2xqa1: 'a1b58899-f671-4276-6a5e-56ca5bd59700',
          '000000000019d6689c085ae165831e93': '0b4838db-0161-4ffe-022d-532bf03dba00',
          '000000000933ea01ad0ee984209779ba': '39354064-d79b-420b-065d-f980c4b78200',
        },
        ConnectorImageIds: {
          [r.b.CONNECTOR_ID.COINBASE]: '0c2840c3-5b04-4c44-9661-fbd4b49e1800',
          [r.b.CONNECTOR_ID.COINBASE_SDK]: '0c2840c3-5b04-4c44-9661-fbd4b49e1800',
          [r.b.CONNECTOR_ID.SAFE]: '461db637-8616-43ce-035a-d89b8a1d5800',
          [r.b.CONNECTOR_ID.LEDGER]: '54a1aa77-d202-4f8d-0fb2-5d2bb6db0300',
          [r.b.CONNECTOR_ID.WALLET_CONNECT]: 'ef1a1fcf-7fe8-4d69-bd6d-fda1345b4400',
          [r.b.CONNECTOR_ID.INJECTED]: '07ba87ed-43aa-4adf-4540-9e6a2b9cae00',
        },
        ConnectorNamesMap: {
          [r.b.CONNECTOR_ID.INJECTED]: 'Browser Wallet',
          [r.b.CONNECTOR_ID.WALLET_CONNECT]: 'WalletConnect',
          [r.b.CONNECTOR_ID.COINBASE]: 'Coinbase',
          [r.b.CONNECTOR_ID.COINBASE_SDK]: 'Coinbase',
          [r.b.CONNECTOR_ID.LEDGER]: 'Ledger',
          [r.b.CONNECTOR_ID.SAFE]: 'Safe',
        },
        ConnectorTypesMap: {
          [r.b.CONNECTOR_ID.INJECTED]: 'INJECTED',
          [r.b.CONNECTOR_ID.WALLET_CONNECT]: 'WALLET_CONNECT',
          [r.b.CONNECTOR_ID.EIP6963]: 'ANNOUNCED',
          [r.b.CONNECTOR_ID.AUTH]: 'AUTH',
        },
        WalletConnectRpcChainIds: [
          1, 5, 11155111, 10, 420, 42161, 421613, 137, 80001, 42220, 1313161554, 1313161555, 56, 97,
          43114, 43113, 100, 8453, 84531, 7777777, 999, 324, 280,
        ],
      };
    },
    41428: function (e, t, n) {
      'use strict';
      n.d(t, {
        $0: function () {
          return o;
        },
        Dr: function () {
          return i;
        },
        jd: function () {
          return a;
        },
        y_: function () {
          return l;
        },
        zN: function () {
          return s;
        },
      });
      var r = n(32608);
      let i =
          (void 0 !== r && void 0 !== r.env ? r.env.NEXT_PUBLIC_SECURE_SITE_SDK_URL : void 0) ||
          'https://secure.walletconnect.org/sdk',
        a =
          (void 0 !== r && void 0 !== r.env ? r.env.NEXT_PUBLIC_DEFAULT_LOG_LEVEL : void 0) ||
          'error',
        s =
          (void 0 !== r && void 0 !== r.env ? r.env.NEXT_PUBLIC_SECURE_SITE_SDK_VERSION : void 0) ||
          '4',
        o = {
          APP_EVENT_KEY: '@w3m-app/',
          FRAME_EVENT_KEY: '@w3m-frame/',
          RPC_METHOD_KEY: 'RPC_',
          STORAGE_KEY: '@appkit-wallet/',
          SESSION_TOKEN_KEY: 'SESSION_TOKEN_KEY',
          EMAIL_LOGIN_USED_KEY: 'EMAIL_LOGIN_USED_KEY',
          LAST_USED_CHAIN_KEY: 'LAST_USED_CHAIN_KEY',
          LAST_EMAIL_LOGIN_TIME: 'LAST_EMAIL_LOGIN_TIME',
          EMAIL: 'EMAIL',
          PREFERRED_ACCOUNT_TYPE: 'PREFERRED_ACCOUNT_TYPE',
          SMART_ACCOUNT_ENABLED: 'SMART_ACCOUNT_ENABLED',
          SMART_ACCOUNT_ENABLED_NETWORKS: 'SMART_ACCOUNT_ENABLED_NETWORKS',
          SOCIAL_USERNAME: 'SOCIAL_USERNAME',
          APP_SWITCH_NETWORK: '@w3m-app/SWITCH_NETWORK',
          APP_CONNECT_EMAIL: '@w3m-app/CONNECT_EMAIL',
          APP_CONNECT_DEVICE: '@w3m-app/CONNECT_DEVICE',
          APP_CONNECT_OTP: '@w3m-app/CONNECT_OTP',
          APP_CONNECT_SOCIAL: '@w3m-app/CONNECT_SOCIAL',
          APP_GET_SOCIAL_REDIRECT_URI: '@w3m-app/GET_SOCIAL_REDIRECT_URI',
          APP_GET_USER: '@w3m-app/GET_USER',
          APP_SIGN_OUT: '@w3m-app/SIGN_OUT',
          APP_IS_CONNECTED: '@w3m-app/IS_CONNECTED',
          APP_GET_CHAIN_ID: '@w3m-app/GET_CHAIN_ID',
          APP_RPC_REQUEST: '@w3m-app/RPC_REQUEST',
          APP_UPDATE_EMAIL: '@w3m-app/UPDATE_EMAIL',
          APP_UPDATE_EMAIL_PRIMARY_OTP: '@w3m-app/UPDATE_EMAIL_PRIMARY_OTP',
          APP_UPDATE_EMAIL_SECONDARY_OTP: '@w3m-app/UPDATE_EMAIL_SECONDARY_OTP',
          APP_AWAIT_UPDATE_EMAIL: '@w3m-app/AWAIT_UPDATE_EMAIL',
          APP_SYNC_THEME: '@w3m-app/SYNC_THEME',
          APP_SYNC_DAPP_DATA: '@w3m-app/SYNC_DAPP_DATA',
          APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS: '@w3m-app/GET_SMART_ACCOUNT_ENABLED_NETWORKS',
          APP_INIT_SMART_ACCOUNT: '@w3m-app/INIT_SMART_ACCOUNT',
          APP_SET_PREFERRED_ACCOUNT: '@w3m-app/SET_PREFERRED_ACCOUNT',
          APP_CONNECT_FARCASTER: '@w3m-app/CONNECT_FARCASTER',
          APP_GET_FARCASTER_URI: '@w3m-app/GET_FARCASTER_URI',
          APP_RELOAD: '@w3m-app/RELOAD',
          FRAME_SWITCH_NETWORK_ERROR: '@w3m-frame/SWITCH_NETWORK_ERROR',
          FRAME_SWITCH_NETWORK_SUCCESS: '@w3m-frame/SWITCH_NETWORK_SUCCESS',
          FRAME_CONNECT_EMAIL_ERROR: '@w3m-frame/CONNECT_EMAIL_ERROR',
          FRAME_CONNECT_EMAIL_SUCCESS: '@w3m-frame/CONNECT_EMAIL_SUCCESS',
          FRAME_CONNECT_DEVICE_ERROR: '@w3m-frame/CONNECT_DEVICE_ERROR',
          FRAME_CONNECT_DEVICE_SUCCESS: '@w3m-frame/CONNECT_DEVICE_SUCCESS',
          FRAME_CONNECT_OTP_SUCCESS: '@w3m-frame/CONNECT_OTP_SUCCESS',
          FRAME_CONNECT_OTP_ERROR: '@w3m-frame/CONNECT_OTP_ERROR',
          FRAME_CONNECT_SOCIAL_SUCCESS: '@w3m-frame/CONNECT_SOCIAL_SUCCESS',
          FRAME_CONNECT_SOCIAL_ERROR: '@w3m-frame/CONNECT_SOCIAL_ERROR',
          FRAME_CONNECT_FARCASTER_SUCCESS: '@w3m-frame/CONNECT_FARCASTER_SUCCESS',
          FRAME_CONNECT_FARCASTER_ERROR: '@w3m-frame/CONNECT_FARCASTER_ERROR',
          FRAME_GET_FARCASTER_URI_SUCCESS: '@w3m-frame/GET_FARCASTER_URI_SUCCESS',
          FRAME_GET_FARCASTER_URI_ERROR: '@w3m-frame/GET_FARCASTER_URI_ERROR',
          FRAME_GET_SOCIAL_REDIRECT_URI_SUCCESS: '@w3m-frame/GET_SOCIAL_REDIRECT_URI_SUCCESS',
          FRAME_GET_SOCIAL_REDIRECT_URI_ERROR: '@w3m-frame/GET_SOCIAL_REDIRECT_URI_ERROR',
          FRAME_GET_USER_SUCCESS: '@w3m-frame/GET_USER_SUCCESS',
          FRAME_GET_USER_ERROR: '@w3m-frame/GET_USER_ERROR',
          FRAME_SIGN_OUT_SUCCESS: '@w3m-frame/SIGN_OUT_SUCCESS',
          FRAME_SIGN_OUT_ERROR: '@w3m-frame/SIGN_OUT_ERROR',
          FRAME_IS_CONNECTED_SUCCESS: '@w3m-frame/IS_CONNECTED_SUCCESS',
          FRAME_IS_CONNECTED_ERROR: '@w3m-frame/IS_CONNECTED_ERROR',
          FRAME_GET_CHAIN_ID_SUCCESS: '@w3m-frame/GET_CHAIN_ID_SUCCESS',
          FRAME_GET_CHAIN_ID_ERROR: '@w3m-frame/GET_CHAIN_ID_ERROR',
          FRAME_RPC_REQUEST_SUCCESS: '@w3m-frame/RPC_REQUEST_SUCCESS',
          FRAME_RPC_REQUEST_ERROR: '@w3m-frame/RPC_REQUEST_ERROR',
          FRAME_SESSION_UPDATE: '@w3m-frame/SESSION_UPDATE',
          FRAME_UPDATE_EMAIL_SUCCESS: '@w3m-frame/UPDATE_EMAIL_SUCCESS',
          FRAME_UPDATE_EMAIL_ERROR: '@w3m-frame/UPDATE_EMAIL_ERROR',
          FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS: '@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_SUCCESS',
          FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR: '@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_ERROR',
          FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS: '@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_SUCCESS',
          FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR: '@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_ERROR',
          FRAME_SYNC_THEME_SUCCESS: '@w3m-frame/SYNC_THEME_SUCCESS',
          FRAME_SYNC_THEME_ERROR: '@w3m-frame/SYNC_THEME_ERROR',
          FRAME_SYNC_DAPP_DATA_SUCCESS: '@w3m-frame/SYNC_DAPP_DATA_SUCCESS',
          FRAME_SYNC_DAPP_DATA_ERROR: '@w3m-frame/SYNC_DAPP_DATA_ERROR',
          FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS:
            '@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS',
          FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR:
            '@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR',
          FRAME_INIT_SMART_ACCOUNT_SUCCESS: '@w3m-frame/INIT_SMART_ACCOUNT_SUCCESS',
          FRAME_INIT_SMART_ACCOUNT_ERROR: '@w3m-frame/INIT_SMART_ACCOUNT_ERROR',
          FRAME_SET_PREFERRED_ACCOUNT_SUCCESS: '@w3m-frame/SET_PREFERRED_ACCOUNT_SUCCESS',
          FRAME_SET_PREFERRED_ACCOUNT_ERROR: '@w3m-frame/SET_PREFERRED_ACCOUNT_ERROR',
          FRAME_READY: '@w3m-frame/READY',
          FRAME_RELOAD_SUCCESS: '@w3m-frame/RELOAD_SUCCESS',
          FRAME_RELOAD_ERROR: '@w3m-frame/RELOAD_ERROR',
          RPC_RESPONSE_TYPE_ERROR: 'RPC_RESPONSE_ERROR',
          RPC_RESPONSE_TYPE_TX: 'RPC_RESPONSE_TRANSACTION_HASH',
          RPC_RESPONSE_TYPE_OBJECT: 'RPC_RESPONSE_OBJECT',
        },
        l = {
          SAFE_RPC_METHODS: [
            'eth_accounts',
            'eth_blockNumber',
            'eth_call',
            'eth_chainId',
            'eth_estimateGas',
            'eth_feeHistory',
            'eth_gasPrice',
            'eth_getAccount',
            'eth_getBalance',
            'eth_getBlockByHash',
            'eth_getBlockByNumber',
            'eth_getBlockReceipts',
            'eth_getBlockTransactionCountByHash',
            'eth_getBlockTransactionCountByNumber',
            'eth_getCode',
            'eth_getFilterChanges',
            'eth_getFilterLogs',
            'eth_getLogs',
            'eth_getProof',
            'eth_getStorageAt',
            'eth_getTransactionByBlockHashAndIndex',
            'eth_getTransactionByBlockNumberAndIndex',
            'eth_getTransactionByHash',
            'eth_getTransactionCount',
            'eth_getTransactionReceipt',
            'eth_getUncleCountByBlockHash',
            'eth_getUncleCountByBlockNumber',
            'eth_maxPriorityFeePerGas',
            'eth_newBlockFilter',
            'eth_newFilter',
            'eth_newPendingTransactionFilter',
            'eth_sendRawTransaction',
            'eth_syncing',
            'eth_uninstallFilter',
            'wallet_getCapabilities',
            'wallet_getCallsStatus',
            'eth_getUserOperationReceipt',
            'eth_estimateUserOperationGas',
            'eth_getUserOperationByHash',
            'eth_supportedEntryPoints',
            'wallet_getAssets',
          ],
          NOT_SAFE_RPC_METHODS: [
            'personal_sign',
            'eth_signTypedData_v4',
            'eth_sendTransaction',
            'solana_signMessage',
            'solana_signTransaction',
            'solana_signAllTransactions',
            'solana_signAndSendTransaction',
            'wallet_sendCalls',
            'wallet_grantPermissions',
            'wallet_revokePermissions',
            'eth_sendUserOperation',
          ],
          GET_CHAIN_ID: 'eth_chainId',
          RPC_METHOD_NOT_ALLOWED_MESSAGE: 'Requested RPC call is not allowed',
          RPC_METHOD_NOT_ALLOWED_UI_MESSAGE: 'Action not allowed',
          ACCOUNT_TYPES: { EOA: 'eoa', SMART_ACCOUNT: 'smartAccount' },
        };
    },
    39037: function (e, t, n) {
      'use strict';
      n.d(t, {
        $: function () {
          return s;
        },
      });
      let r = {
        transactionHash: /^0x(?:[A-Fa-f0-9]{64})$/u,
        signedMessage: /^0x(?:[a-fA-F0-9]{62,})$/u,
      };
      var i = n(41428),
        a = n(70437);
      let s = {
        checkIfAllowedToTriggerEmail() {
          let e = a.e.get(i.$0.LAST_EMAIL_LOGIN_TIME);
          if (e) {
            let t = Date.now() - Number(e);
            if (t < 3e4)
              throw Error(`Please try again after ${Math.ceil((3e4 - t) / 1e3)} seconds`);
          }
        },
        getTimeToNextEmailLogin() {
          let e = a.e.get(i.$0.LAST_EMAIL_LOGIN_TIME);
          if (e) {
            let t = Date.now() - Number(e);
            if (t < 3e4) return Math.ceil((3e4 - t) / 1e3);
          }
          return 0;
        },
        checkIfRequestExists: (e) =>
          i.y_.NOT_SAFE_RPC_METHODS.includes(e.method) || i.y_.SAFE_RPC_METHODS.includes(e.method),
        getResponseType: (e) =>
          'string' == typeof e && (e?.match(r.transactionHash) || e?.match(r.signedMessage))
            ? i.$0.RPC_RESPONSE_TYPE_TX
            : i.$0.RPC_RESPONSE_TYPE_OBJECT,
        checkIfRequestIsSafe: (e) => i.y_.SAFE_RPC_METHODS.includes(e.method),
        isClient: 'undefined' != typeof window,
      };
    },
    70437: function (e, t, n) {
      'use strict';
      n.d(t, {
        e: function () {
          return a;
        },
      });
      var r = n(41428),
        i = n(39037);
      let a = {
        set(e, t) {
          i.$.isClient && localStorage.setItem(`${r.$0.STORAGE_KEY}${e}`, t);
        },
        get: (e) => (i.$.isClient ? localStorage.getItem(`${r.$0.STORAGE_KEY}${e}`) : null),
        delete(e, t) {
          i.$.isClient &&
            (t ? localStorage.removeItem(e) : localStorage.removeItem(`${r.$0.STORAGE_KEY}${e}`));
        },
      };
    },
    58628: function (e, t, n) {
      'use strict';
      n.d(t, {
        sQ: function () {
          return Q.sQ;
        },
        cz: function () {
          return X;
        },
      });
      var r = n(14537),
        i = n(49786),
        a = n(29931),
        s = n(3230),
        o = n(17409),
        l = n(27837),
        u = n(49162),
        c = n(61564),
        d = n(82093),
        p = n(60725),
        h = n(97059),
        y = n(8924),
        f = n(44744),
        m = n(31507),
        g = n(10423),
        b = n(62692),
        w = n(5436),
        v = n(3138),
        T = n(94583),
        A = n(95759);
      let E = { eip155: void 0, solana: void 0, polkadot: void 0, bip122: void 0 },
        C = (0, T.sj)({ providers: { ...E }, providerIds: { ...E } }),
        _ = {
          state: C,
          subscribeKey: (e, t) => (0, A.VW)(C, e, t),
          subscribe: (e) =>
            (0, T.Ld)(C, () => {
              e(C);
            }),
          subscribeProviders: (e) => (0, T.Ld)(C.providers, () => e(C.providers)),
          setProvider(e, t) {
            t && (C.providers[e] = (0, T.iH)(t));
          },
          getProvider: (e) => C.providers[e],
          setProviderId(e, t) {
            t && (C.providerIds[e] = t);
          },
          getProviderId(e) {
            if (e) return C.providerIds[e];
          },
          reset() {
            (C.providers = { ...E }), (C.providerIds = { ...E });
          },
          resetChain(e) {
            (C.providers[e] = void 0), (C.providerIds[e] = void 0);
          },
        };
      var I = n(39037),
        S = n(41428),
        P = n(80487),
        O = n(26651);
      let N = {
        validateCaipAddress(e) {
          if (e.split(':')?.length !== 3) throw Error('Invalid CAIP Address');
          return e;
        },
        parseCaipAddress(e) {
          let t = e.split(':');
          if (3 !== t.length) throw Error(`Invalid CAIP-10 address: ${e}`);
          let [n, r, i] = t;
          if (!n || !r || !i) throw Error(`Invalid CAIP-10 address: ${e}`);
          return { chainNamespace: n, chainId: r, address: i };
        },
        parseCaipNetworkId(e) {
          let t = e.split(':');
          if (2 !== t.length) throw Error(`Invalid CAIP-2 network id: ${e}`);
          let [n, r] = t;
          if (!n || !r) throw Error(`Invalid CAIP-2 network id: ${e}`);
          return { chainNamespace: n, chainId: r };
        },
      };
      var x = n(48261),
        M = n(98583),
        k = n(26038),
        R = n(28119),
        D = n(94498),
        B = n(19165),
        U = n(88667);
      n(40810), n(22953);
      var L = n(39184),
        F = n(91527),
        j = n(9281),
        q = n(1030);
      let V = {
        createLogger(e, t = 'error') {
          let n = (0, q.jI)({ level: t }),
            { logger: r } = (0, q.Rt)({ opts: n });
          return (
            (r.error = (...t) => {
              for (let n of t)
                if (n instanceof Error) {
                  e(n, ...t);
                  return;
                }
              e(void 0, ...t);
            }),
            r
          );
        },
      };
      var $ = n(96169),
        z = n(84196),
        W = n(41291),
        H = n(31399),
        G = n(87419);
      class K extends W.q {
        setUniversalProvider(e) {
          this.addConnector(
            new H.z({
              provider: e,
              caipNetworks: this.getCaipNetworks(),
              namespace: this.namespace,
            })
          );
        }
        async connect(e) {
          return Promise.resolve({
            id: 'WALLET_CONNECT',
            type: 'WALLET_CONNECT',
            chainId: Number(e.chainId),
            provider: this.provider,
            address: '',
          });
        }
        async disconnect() {
          try {
            let e = this.getWalletConnectConnector();
            await e.disconnect();
          } catch (e) {
            console.warn('UniversalAdapter:disconnect - error', e);
          }
        }
        async getAccounts({ namespace: e }) {
          let t = this.provider;
          return Promise.resolve({
            accounts: (
              t?.session?.namespaces?.[e]?.accounts
                ?.map((e) => {
                  let [, , t] = e.split(':');
                  return t;
                })
                .filter((e, t, n) => n.indexOf(e) === t) || []
            ).map((t) => r.j.createAccount(e, t, 'bip122' === e ? 'payment' : 'eoa')),
          });
        }
        async syncConnectors() {
          return Promise.resolve();
        }
        async getBalance(e) {
          if (
            !(
              e.caipNetwork && u.bq.BALANCE_SUPPORTED_CHAINS.includes(e.caipNetwork?.chainNamespace)
            ) ||
            e.caipNetwork?.testnet
          )
            return { balance: '0.00', symbol: e.caipNetwork?.nativeCurrency.symbol || '' };
          if (
            p.AccountController.state.balanceLoading &&
            e.chainId === h.R.state.activeCaipNetwork?.id
          )
            return {
              balance: p.AccountController.state.balance || '0.00',
              symbol: p.AccountController.state.balanceSymbol || '',
            };
          let t = (await p.AccountController.fetchTokenBalance()).find(
            (t) =>
              t.chainId === `${e.caipNetwork?.chainNamespace}:${e.chainId}` &&
              t.symbol === e.caipNetwork?.nativeCurrency.symbol
          );
          return {
            balance: t?.quantity.numeric || '0.00',
            symbol: t?.symbol || e.caipNetwork?.nativeCurrency.symbol || '',
          };
        }
        async signMessage(e) {
          let { provider: t, message: n, address: r } = e;
          if (!t) throw Error('UniversalAdapter:signMessage - provider is undefined');
          return {
            signature:
              h.R.state.activeCaipNetwork?.chainNamespace === i.b.CHAIN.SOLANA
                ? (
                    await t.request(
                      {
                        method: 'solana_signMessage',
                        params: { message: $.Z.encode(new TextEncoder().encode(n)), pubkey: r },
                      },
                      h.R.state.activeCaipNetwork?.caipNetworkId
                    )
                  ).signature
                : await t.request(
                    { method: 'personal_sign', params: [n, r] },
                    h.R.state.activeCaipNetwork?.caipNetworkId
                  ),
          };
        }
        async estimateGas() {
          return Promise.resolve({ gas: BigInt(0) });
        }
        async getProfile() {
          return Promise.resolve({ profileImage: '', profileName: '' });
        }
        async sendTransaction() {
          return Promise.resolve({ hash: '' });
        }
        walletGetAssets(e) {
          return Promise.resolve({});
        }
        async writeContract() {
          return Promise.resolve({ hash: '' });
        }
        async getEnsAddress() {
          return Promise.resolve({ address: !1 });
        }
        parseUnits() {
          return 0n;
        }
        formatUnits() {
          return '0';
        }
        async getCapabilities() {
          return Promise.resolve({});
        }
        async grantPermissions() {
          return Promise.resolve({});
        }
        async revokePermissions() {
          return Promise.resolve('0x');
        }
        async syncConnection() {
          return Promise.resolve({
            id: 'WALLET_CONNECT',
            type: 'WALLET_CONNECT',
            chainId: 1,
            provider: this.provider,
            address: '',
          });
        }
        async switchNetwork(e) {
          let { caipNetwork: t } = e,
            n = this.getWalletConnectConnector();
          if (t.chainNamespace === i.b.CHAIN.EVM)
            try {
              await n.provider?.request({
                method: 'wallet_switchEthereumChain',
                params: [{ chainId: z.NC(t.id) }],
              });
            } catch (e) {
              if (
                e.code === G.T.ERROR_CODE_UNRECOGNIZED_CHAIN_ID ||
                e.code === G.T.ERROR_INVALID_CHAIN_ID ||
                e.code === G.T.ERROR_CODE_DEFAULT ||
                e?.data?.originalError?.code === G.T.ERROR_CODE_UNRECOGNIZED_CHAIN_ID
              )
                try {
                  await n.provider?.request({
                    method: 'wallet_addEthereumChain',
                    params: [
                      {
                        chainId: z.NC(t.id),
                        rpcUrls: [t?.rpcUrls.chainDefault?.http],
                        chainName: t.name,
                        nativeCurrency: t.nativeCurrency,
                        blockExplorerUrls: [t.blockExplorers?.default.url],
                      },
                    ],
                  });
                } catch (e) {
                  throw Error('Chain is not supported');
                }
            }
          n.provider.setDefaultChain(t.caipNetworkId);
        }
        getWalletConnectProvider() {
          let e = this.connectors.find((e) => 'WALLET_CONNECT' === e.type);
          return e?.provider;
        }
      }
      var Q = n(63289);
      class Y {
        constructor(e) {
          (this.chainNamespaces = []),
            (this.reportedAlertErrors = {}),
            (this.getCaipNetwork = (e, t) => {
              if (e) {
                let n = h.R.getNetworkData(e)?.requestedCaipNetworks?.find((e) => e.id === t);
                return n
                  ? n
                  : h.R.getNetworkData(e)?.caipNetwork ||
                      h.R.getRequestedCaipNetworks(e).filter((t) => t.chainNamespace === e)?.[0];
              }
              return h.R.state.activeCaipNetwork || this.defaultCaipNetwork;
            }),
            (this.getCaipNetworkId = () => {
              let e = this.getCaipNetwork();
              if (e) return e.id;
            }),
            (this.getCaipNetworks = (e) => h.R.getCaipNetworks(e)),
            (this.getActiveChainNamespace = () => h.R.state.activeChain),
            (this.setRequestedCaipNetworks = (e, t) => {
              h.R.setRequestedCaipNetworks(e, t);
            }),
            (this.getApprovedCaipNetworkIds = () => h.R.getAllApprovedCaipNetworkIds()),
            (this.getCaipAddress = (e) =>
              h.R.state.activeChain !== e && e
                ? h.R.getAccountProp('caipAddress', e)
                : h.R.state.activeCaipAddress),
            (this.setClientId = (e) => {
              M.L.setClientId(e);
            }),
            (this.getProvider = (e) => _.getProvider(e)),
            (this.getProviderType = (e) => _.getProviderId(e)),
            (this.getPreferredAccountType = (e) =>
              p.AccountController.state.preferredAccountTypes?.[e]),
            (this.setCaipAddress = (e, t) => {
              p.AccountController.setCaipAddress(e, t);
            }),
            (this.setBalance = (e, t, n) => {
              p.AccountController.setBalance(e, t, n);
            }),
            (this.setProfileName = (e, t) => {
              p.AccountController.setProfileName(e, t);
            }),
            (this.setProfileImage = (e, t) => {
              p.AccountController.setProfileImage(e, t);
            }),
            (this.setUser = (e, t) => {
              p.AccountController.setUser(e, t),
                y.OptionsController.state.enableEmbedded && k.I.close();
            }),
            (this.resetAccount = (e) => {
              p.AccountController.resetAccount(e);
            }),
            (this.setCaipNetwork = (e) => {
              h.R.setActiveCaipNetwork(e);
            }),
            (this.setCaipNetworkOfNamespace = (e, t) => {
              h.R.setChainNetworkData(t, { caipNetwork: e });
            }),
            (this.setAllAccounts = (e, t) => {
              p.AccountController.setAllAccounts(e, t),
                y.OptionsController.setHasMultipleAddresses(e?.length > 1);
            }),
            (this.setStatus = (e, t) => {
              p.AccountController.setStatus(e, t),
                s.ConnectorController.isConnected()
                  ? m.M.setConnectionStatus('connected')
                  : m.M.setConnectionStatus('disconnected');
            }),
            (this.getAddressByChainNamespace = (e) => h.R.getAccountProp('address', e)),
            (this.setConnectors = (e) => {
              let t = [...s.ConnectorController.state.allConnectors, ...e];
              s.ConnectorController.setConnectors(t);
            }),
            (this.fetchIdentity = (e) => M.L.fetchIdentity(e)),
            (this.getReownName = (e) => R.a.getNamesForAddress(e)),
            (this.getConnectors = () => s.ConnectorController.getConnectors()),
            (this.getConnectorImage = (e) => D.f.getConnectorImage(e)),
            (this.setConnectedWalletInfo = (e, t) => {
              let n = _.getProviderId(t),
                r = e ? { ...e, type: n } : void 0;
              p.AccountController.setConnectedWalletInfo(r, t);
            }),
            (this.getIsConnectedState = () => !!h.R.state.activeCaipAddress),
            (this.addAddressLabel = (e, t, n) => {
              p.AccountController.addAddressLabel(e, t, n);
            }),
            (this.removeAddressLabel = (e, t) => {
              p.AccountController.removeAddressLabel(e, t);
            }),
            (this.getAddress = (e) =>
              h.R.state.activeChain !== e && e
                ? h.R.getAccountProp('address', e)
                : p.AccountController.state.address),
            (this.setApprovedCaipNetworksData = (e) => h.R.setApprovedCaipNetworksData(e)),
            (this.resetNetwork = (e) => {
              h.R.resetNetwork(e);
            }),
            (this.addConnector = (e) => {
              s.ConnectorController.addConnector(e);
            }),
            (this.resetWcConnection = () => {
              o.ConnectionController.resetWcConnection();
            }),
            (this.setAddressExplorerUrl = (e, t) => {
              p.AccountController.setAddressExplorerUrl(e, t);
            }),
            (this.setSmartAccountDeployed = (e, t) => {
              p.AccountController.setSmartAccountDeployed(e, t);
            }),
            (this.setSmartAccountEnabledNetworks = (e, t) => {
              h.R.setSmartAccountEnabledNetworks(e, t);
            }),
            (this.setPreferredAccountType = (e, t) => {
              p.AccountController.setPreferredAccountType(e, t);
            }),
            (this.setEIP6963Enabled = (e) => {
              y.OptionsController.setEIP6963Enabled(e);
            }),
            (this.handleUnsafeRPCRequest = () => {
              this.isOpen()
                ? this.isTransactionStackEmpty() || this.redirect('ApproveTransaction')
                : this.open({ view: 'ApproveTransaction' });
            }),
            (this.options = e),
            (this.version = e.sdkVersion),
            (this.caipNetworks = this.extendCaipNetworks(e)),
            (this.chainNamespaces = this.getChainNamespacesSet(e.adapters, this.caipNetworks)),
            (this.defaultCaipNetwork = this.extendDefaultCaipNetwork(e)),
            (this.chainAdapters = this.createAdapters(e.adapters)),
            this.initialize(e);
        }
        getChainNamespacesSet(e, t) {
          let n = e?.map((e) => e.namespace).filter((e) => !!e);
          return n?.length ? [...new Set(n)] : [...new Set(t?.map((e) => e.chainNamespace))];
        }
        async initialize(e) {
          this.initControllers(e),
            await this.initChainAdapters(),
            await this.injectModalUi(),
            this.sendInitializeEvent(e),
            c.I.set({ initialized: !0 }),
            await this.syncExistingConnection();
        }
        sendInitializeEvent(e) {
          let { ...t } = e;
          delete t.adapters,
            delete t.universalProvider,
            l.X.sendEvent({
              type: 'track',
              event: 'INITIALIZE',
              properties: {
                ...t,
                networks: e.networks.map((e) => e.id),
                siweConfig: { options: e.siweConfig?.options || {} },
              },
            });
        }
        initControllers(e) {
          this.initializeOptionsController(e),
            this.initializeChainController(e),
            this.initializeThemeController(e),
            this.initializeConnectionController(e),
            this.initializeConnectorController();
        }
        initializeThemeController(e) {
          e.themeMode && f.ThemeController.setThemeMode(e.themeMode),
            e.themeVariables && f.ThemeController.setThemeVariables(e.themeVariables);
        }
        initializeChainController(e) {
          if (!this.connectionControllerClient || !this.networkControllerClient)
            throw Error('ConnectionControllerClient and NetworkControllerClient must be set');
          h.R.initialize(e.adapters ?? [], this.caipNetworks, {
            connectionControllerClient: this.connectionControllerClient,
            networkControllerClient: this.networkControllerClient,
          });
          let t = this.getDefaultNetwork();
          t && h.R.setActiveCaipNetwork(t);
        }
        initializeConnectionController(e) {
          o.ConnectionController.setWcBasic(e.basic ?? !1);
        }
        initializeConnectorController() {
          s.ConnectorController.initialize(this.chainNamespaces);
        }
        initializeOptionsController(e) {
          y.OptionsController.setDebug(!1 !== e.debug),
            y.OptionsController.setEnableWalletConnect(!1 !== e.enableWalletConnect),
            y.OptionsController.setEnableWalletGuide(!1 !== e.enableWalletGuide),
            y.OptionsController.setEnableWallets(!1 !== e.enableWallets),
            y.OptionsController.setEIP6963Enabled(!1 !== e.enableEIP6963),
            y.OptionsController.setEnableNetworkSwitch(!1 !== e.enableNetworkSwitch),
            y.OptionsController.setEnableAuthLogger(!1 !== e.enableAuthLogger),
            y.OptionsController.setCustomRpcUrls(e.customRpcUrls),
            y.OptionsController.setSdkVersion(e.sdkVersion),
            y.OptionsController.setProjectId(e.projectId),
            y.OptionsController.setEnableEmbedded(e.enableEmbedded),
            y.OptionsController.setAllWallets(e.allWallets),
            y.OptionsController.setIncludeWalletIds(e.includeWalletIds),
            y.OptionsController.setExcludeWalletIds(e.excludeWalletIds),
            y.OptionsController.setFeaturedWalletIds(e.featuredWalletIds),
            y.OptionsController.setTokens(e.tokens),
            y.OptionsController.setTermsConditionsUrl(e.termsConditionsUrl),
            y.OptionsController.setPrivacyPolicyUrl(e.privacyPolicyUrl),
            y.OptionsController.setCustomWallets(e.customWallets),
            y.OptionsController.setFeatures(e.features),
            y.OptionsController.setAllowUnsupportedChain(e.allowUnsupportedChain),
            y.OptionsController.setUniversalProviderConfigOverride(
              e.universalProviderConfigOverride
            ),
            y.OptionsController.setDefaultAccountTypes(e.defaultAccountTypes);
          let t = m.M.getPreferredAccountTypes(),
            n = { ...y.OptionsController.state.defaultAccountTypes, ...t };
          p.AccountController.setPreferredAccountTypes(n);
          let r = this.getDefaultMetaData();
          if (
            (!e.metadata && r && (e.metadata = r),
            y.OptionsController.setMetadata(e.metadata),
            y.OptionsController.setDisableAppend(e.disableAppend),
            y.OptionsController.setEnableEmbedded(e.enableEmbedded),
            y.OptionsController.setSIWX(e.siwx),
            !e.projectId)
          ) {
            g.AlertController.open(v.j.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, 'error');
            return;
          }
          if (e.adapters?.find((e) => e.namespace === i.b.CHAIN.EVM) && e.siweConfig) {
            if (e.siwx) throw Error('Cannot set both `siweConfig` and `siwx` options');
            y.OptionsController.setSIWX(e.siweConfig.mapToSIWX());
          }
        }
        getDefaultMetaData() {
          return 'undefined' != typeof window && 'undefined' != typeof document
            ? {
                name: document.getElementsByTagName('title')?.[0]?.textContent || '',
                description:
                  document.querySelector('meta[property="og:description"]')?.content || '',
                url: window.location.origin,
                icons: [document.querySelector('link[rel~="icon"]')?.href || ''],
              }
            : null;
        }
        setUnsupportedNetwork(e) {
          let t = this.getActiveChainNamespace();
          if (t) {
            let n = j.f.getUnsupportedNetwork(`${t}:${e}`);
            h.R.setActiveCaipNetwork(n);
          }
        }
        getDefaultNetwork() {
          return j.f.getCaipNetworkFromStorage(this.defaultCaipNetwork);
        }
        extendCaipNetwork(e, t) {
          return j.f.extendCaipNetwork(e, {
            customNetworkImageUrls: t.chainImages,
            projectId: t.projectId,
          });
        }
        extendCaipNetworks(e) {
          return j.f.extendCaipNetworks(e.networks, {
            customNetworkImageUrls: e.chainImages,
            customRpcUrls: e.customRpcUrls,
            projectId: e.projectId,
          });
        }
        extendDefaultCaipNetwork(e) {
          let t = e.networks.find((t) => t.id === e.defaultNetwork?.id);
          return t
            ? j.f.extendCaipNetwork(t, {
                customNetworkImageUrls: e.chainImages,
                customRpcUrls: e.customRpcUrls,
                projectId: e.projectId,
              })
            : void 0;
        }
        createClients() {
          (this.connectionControllerClient = {
            connectWalletConnect: async () => {
              let e = h.R.state.activeChain,
                t = this.getAdapter(e),
                n = this.getCaipNetwork(e)?.id;
              if (!t) throw Error('Adapter not found');
              let r = await t.connectWalletConnect(n);
              this.close(),
                this.setClientId(r?.clientId || null),
                m.M.setConnectedNamespaces([...h.R.state.chains.keys()]),
                this.chainNamespaces.forEach((e) => {
                  s.ConnectorController.setConnectorId(w.b.CONNECTOR_TYPE_WALLET_CONNECT, e);
                }),
                await this.syncWalletConnectAccount();
            },
            connectExternal: async ({
              id: e,
              info: t,
              type: n,
              provider: r,
              chain: i,
              caipNetwork: a,
            }) => {
              let s = h.R.state.activeChain,
                o = i || s,
                l = this.getAdapter(o);
              if (i && i !== s && !a) {
                let e = this.getCaipNetworks().find((e) => e.chainNamespace === i);
                e && this.setCaipNetwork(e);
              }
              if (!l) throw Error('Adapter not found');
              let u = this.getCaipNetwork(o),
                c = await l.connect({
                  id: e,
                  info: t,
                  type: n,
                  provider: r,
                  chainId: a?.id || u?.id,
                  rpcUrl: a?.rpcUrls?.default?.http?.[0] || u?.rpcUrls?.default?.http?.[0],
                });
              if (!c) return;
              m.M.addConnectedNamespace(o), this.syncProvider({ ...c, chainNamespace: o });
              let { accounts: d } = await l.getAccounts({ namespace: o, id: e });
              this.setAllAccounts(d, o), this.setStatus('connected', o);
            },
            reconnectExternal: async ({ id: e, info: t, type: n, provider: r }) => {
              let i = h.R.state.activeChain,
                a = this.getAdapter(i);
              a?.reconnect &&
                (await a?.reconnect({
                  id: e,
                  info: t,
                  type: n,
                  provider: r,
                  chainId: this.getCaipNetwork()?.id,
                }),
                m.M.addConnectedNamespace(i));
            },
            disconnect: async (e) => {
              let t = e || h.R.state.activeChain,
                n = this.getAdapter(t),
                r = _.getProvider(t),
                i = _.getProviderId(t);
              await n?.disconnect({ provider: r, providerType: i }),
                m.M.removeConnectedNamespace(t),
                _.resetChain(t),
                this.setUser(void 0, t),
                this.setStatus('disconnected', t);
            },
            checkInstalled: (e) =>
              e ? e.some((e) => !!window.ethereum?.[String(e)]) : !!window.ethereum,
            signMessage: async (e) => {
              let t = this.getAdapter(h.R.state.activeChain),
                n = await t?.signMessage({
                  message: e,
                  address: p.AccountController.state.address,
                  provider: _.getProvider(h.R.state.activeChain),
                });
              return n?.signature || '';
            },
            sendTransaction: async (e) => {
              if (e.chainNamespace === i.b.CHAIN.EVM) {
                let t = this.getAdapter(h.R.state.activeChain),
                  n = _.getProvider(h.R.state.activeChain),
                  r = await t?.sendTransaction({
                    ...e,
                    caipNetwork: this.getCaipNetwork(),
                    provider: n,
                  });
                return r?.hash || '';
              }
              return '';
            },
            estimateGas: async (e) => {
              if (e.chainNamespace === i.b.CHAIN.EVM) {
                let t = this.getAdapter(h.R.state.activeChain),
                  n = _.getProvider(h.R.state.activeChain),
                  r = this.getCaipNetwork();
                if (!r) throw Error('CaipNetwork is undefined');
                let i = await t?.estimateGas({ ...e, provider: n, caipNetwork: r });
                return i?.gas || 0n;
              }
              return 0n;
            },
            getEnsAvatar: async () => {
              let e = this.getAdapter(h.R.state.activeChain),
                t = await e?.getProfile({
                  address: p.AccountController.state.address,
                  chainId: Number(this.getCaipNetwork()?.id),
                });
              return t?.profileImage || !1;
            },
            getEnsAddress: async (e) => {
              let t = this.getAdapter(h.R.state.activeChain),
                n = this.getCaipNetwork();
              if (!n) return !1;
              let r = await t?.getEnsAddress({ name: e, caipNetwork: n });
              return r?.address || !1;
            },
            writeContract: async (e) => {
              let t = this.getAdapter(h.R.state.activeChain),
                n = this.getCaipNetwork(),
                r = this.getCaipAddress(),
                i = _.getProvider(h.R.state.activeChain);
              if (!n || !r) throw Error('CaipNetwork or CaipAddress is undefined');
              let a = await t?.writeContract({ ...e, caipNetwork: n, provider: i, caipAddress: r });
              return a?.hash;
            },
            parseUnits: (e, t) => {
              let n = this.getAdapter(h.R.state.activeChain);
              return n?.parseUnits({ value: e, decimals: t }) ?? 0n;
            },
            formatUnits: (e, t) => {
              let n = this.getAdapter(h.R.state.activeChain);
              return n?.formatUnits({ value: e, decimals: t }) ?? '0';
            },
            getCapabilities: async (e) => {
              let t = this.getAdapter(h.R.state.activeChain);
              return await t?.getCapabilities(e);
            },
            grantPermissions: async (e) => {
              let t = this.getAdapter(h.R.state.activeChain);
              return await t?.grantPermissions(e);
            },
            revokePermissions: async (e) => {
              let t = this.getAdapter(h.R.state.activeChain);
              return t?.revokePermissions ? await t.revokePermissions(e) : '0x';
            },
            walletGetAssets: async (e) => {
              let t = this.getAdapter(h.R.state.activeChain);
              return (await t?.walletGetAssets(e)) ?? {};
            },
          }),
            (this.networkControllerClient = {
              switchCaipNetwork: async (e) => await this.switchCaipNetwork(e),
              getApprovedCaipNetworksData: async () => this.getApprovedCaipNetworksData(),
            }),
            o.ConnectionController.setClient(this.connectionControllerClient);
        }
        getApprovedCaipNetworksData() {
          if (_.getProviderId(h.R.state.activeChain) === w.b.CONNECTOR_TYPE_WALLET_CONNECT) {
            let e = this.universalProvider?.session?.namespaces;
            return {
              supportsAllNetworks:
                this.universalProvider?.session?.peer?.metadata.name === 'MetaMask Wallet',
              approvedCaipNetworkIds: this.getChainsFromNamespaces(e),
            };
          }
          return { supportsAllNetworks: !0, approvedCaipNetworkIds: [] };
        }
        async switchCaipNetwork(e) {
          if (!e) return;
          let t = e.chainNamespace;
          if (this.getAddressByChainNamespace(e.chainNamespace)) {
            let n = _.getProvider(t),
              r = _.getProviderId(t);
            if (e.chainNamespace === h.R.state.activeChain) {
              let i = this.getAdapter(t);
              await i?.switchNetwork({ caipNetwork: e, provider: n, providerType: r });
            } else if ((this.setCaipNetwork(e), r === w.b.CONNECTOR_TYPE_WALLET_CONNECT))
              this.syncWalletConnectAccount();
            else {
              let n = this.getAddressByChainNamespace(t);
              n && this.syncAccount({ address: n, chainId: e.id, chainNamespace: t });
            }
          } else this.setCaipNetwork(e);
        }
        getChainsFromNamespaces(e = {}) {
          return Object.values(e).flatMap((e) =>
            Array.from(
              new Set([
                ...(e.chains || []),
                ...e.accounts.map((e) => {
                  let { chainId: t, chainNamespace: n } = N.parseCaipAddress(e);
                  return `${n}:${t}`;
                }),
              ])
            )
          );
        }
        createAdapters(e) {
          return (
            this.createClients(),
            this.chainNamespaces.reduce((t, n) => {
              let r = e?.find((e) => e.namespace === n);
              return (
                r
                  ? (r.construct({
                      namespace: n,
                      projectId: this.options?.projectId,
                      networks: this.getCaipNetworks(),
                    }),
                    (t[n] = r))
                  : (t[n] = new K({ namespace: n, networks: this.getCaipNetworks() })),
                t
              );
            }, {})
          );
        }
        async initChainAdapter(e) {
          this.onConnectors(e),
            this.listenAdapter(e),
            this.chainAdapters?.[e].syncConnectors(this.options, this),
            await this.createUniversalProviderForAdapter(e);
        }
        async initChainAdapters() {
          await Promise.all(
            this.chainNamespaces.map(async (e) => {
              await this.initChainAdapter(e);
            })
          );
        }
        onConnectors(e) {
          let t = this.getAdapter(e);
          t?.on('connectors', this.setConnectors.bind(this));
        }
        listenAdapter(e) {
          let t = this.getAdapter(e);
          if (!t) return;
          let n = m.M.getConnectionStatus();
          'connected' === n
            ? this.setStatus('connecting', e)
            : ('disconnected' === n && m.M.clearAddressCache(), this.setStatus(n, e)),
            t.on('switchNetwork', ({ address: t, chainId: n }) => {
              let r = this.getCaipNetworks().find((e) => e.id === n || e.caipNetworkId === n),
                i = h.R.state.activeChain === e,
                a = h.R.getAccountProp('address', e);
              if (r) {
                let n = i && t ? t : a;
                n && this.syncAccount({ address: n, chainId: r.id, chainNamespace: e });
              } else this.setUnsupportedNetwork(n);
            }),
            t.on('disconnect', this.disconnect.bind(this, e)),
            t.on('pendingTransactions', () => {
              let e = p.AccountController.state.address,
                t = h.R.state.activeCaipNetwork;
              e && t?.id && this.updateNativeBalance(e, t.id, t.chainNamespace);
            }),
            t.on('accountChanged', ({ address: t, chainId: n }) => {
              let r = h.R.state.activeChain === e;
              r && n
                ? this.syncAccount({ address: t, chainId: n, chainNamespace: e })
                : r && h.R.state.activeCaipNetwork?.id
                  ? this.syncAccount({
                      address: t,
                      chainId: h.R.state.activeCaipNetwork?.id,
                      chainNamespace: e,
                    })
                  : this.syncAccountInfo(t, n, e);
            });
        }
        async createUniversalProviderForAdapter(e) {
          await this.getUniversalProvider(),
            this.universalProvider &&
              this.chainAdapters?.[e]?.setUniversalProvider?.(this.universalProvider);
        }
        async syncExistingConnection() {
          await Promise.allSettled(
            this.chainNamespaces.map((e) => this.syncNamespaceConnection(e))
          );
        }
        async syncNamespaceConnection(e) {
          try {
            let t = s.ConnectorController.getConnectorId(e);
            switch ((this.setStatus('connecting', e), t)) {
              case i.b.CONNECTOR_ID.WALLET_CONNECT:
                await this.syncWalletConnectAccount();
                break;
              case i.b.CONNECTOR_ID.AUTH:
                break;
              default:
                await this.syncAdapterConnection(e);
            }
          } catch (t) {
            console.warn("AppKit couldn't sync existing connection", t),
              this.setStatus('disconnected', e);
          }
        }
        async syncAdapterConnection(e) {
          let t = this.getAdapter(e),
            n = s.ConnectorController.getConnectorId(e),
            i = this.getCaipNetwork(e),
            a = s.ConnectorController.getConnectors(e).find((e) => e.id === n);
          try {
            if (!t || !a) throw Error(`Adapter or connector not found for namespace ${e}`);
            if (!i?.id) throw Error('CaipNetwork not found');
            let n = await t?.syncConnection({
              namespace: e,
              id: a.id,
              chainId: i.id,
              rpcUrl: i?.rpcUrls?.default?.http?.[0],
            });
            if (n) {
              let i = await t?.getAccounts({ namespace: e, id: a.id });
              i && i.accounts.length > 0
                ? this.setAllAccounts(i.accounts, e)
                : this.setAllAccounts([r.j.createAccount(e, n.address, 'eoa')], e),
                this.syncProvider({ ...n, chainNamespace: e }),
                await this.syncAccount({ ...n, chainNamespace: e }),
                this.setStatus('connected', e);
            } else this.setStatus('disconnected', e);
          } catch (t) {
            this.setStatus('disconnected', e);
          }
        }
        async syncWalletConnectAccount() {
          let e = this.chainNamespaces.map(async (e) => {
            let t = this.getAdapter(e),
              n = this.universalProvider?.session?.namespaces?.[e]?.accounts || [],
              r = h.R.state.activeCaipNetwork?.id,
              a =
                n.find((e) => {
                  let { chainId: t } = N.parseCaipAddress(e);
                  return t === r?.toString();
                }) || n[0];
            if (a) {
              let n = N.validateCaipAddress(a),
                { chainId: r, address: o } = N.parseCaipAddress(n);
              if (
                (_.setProviderId(e, w.b.CONNECTOR_TYPE_WALLET_CONNECT),
                this.caipNetworks && h.R.state.activeCaipNetwork && t?.namespace !== i.b.CHAIN.EVM)
              ) {
                let n = t?.getWalletConnectProvider({
                  caipNetworks: this.getCaipNetworks(),
                  provider: this.universalProvider,
                  activeCaipNetwork: h.R.state.activeCaipNetwork,
                });
                _.setProvider(e, n);
              } else _.setProvider(e, this.universalProvider);
              s.ConnectorController.setConnectorId(i.b.CONNECTOR_ID.WALLET_CONNECT, e),
                m.M.addConnectedNamespace(e),
                this.syncWalletConnectAccounts(e),
                await this.syncAccount({ address: o, chainId: r, chainNamespace: e });
            } else this.setStatus('disconnected', e);
            await h.R.setApprovedCaipNetworksData(e);
          });
          await Promise.all(e);
        }
        syncWalletConnectAccounts(e) {
          let t = this.universalProvider?.session?.namespaces?.[e]?.accounts
            ?.map((e) => {
              let { address: t } = N.parseCaipAddress(e);
              return t;
            })
            .filter((e, t, n) => n.indexOf(e) === t);
          t &&
            this.setAllAccounts(
              t.map((t) => r.j.createAccount(e, t, 'bip122' === e ? 'payment' : 'eoa')),
              e
            );
        }
        syncProvider({ type: e, provider: t, id: n, chainNamespace: r }) {
          _.setProviderId(r, e), _.setProvider(r, t), s.ConnectorController.setConnectorId(n, r);
        }
        async syncAccount(e) {
          let t = e.chainNamespace === h.R.state.activeChain,
            n = h.R.getCaipNetworkByNamespace(e.chainNamespace, e.chainId),
            { address: r, chainId: a, chainNamespace: s } = e,
            { chainId: o } = m.M.getActiveNetworkProps(),
            l = a || o,
            u = h.R.state.activeCaipNetwork?.name === i.b.UNSUPPORTED_NETWORK_NAME,
            c = h.R.getNetworkProp('supportsAllNetworks', s);
          if ((this.setStatus('connected', s), (!u || c) && l)) {
            let e = this.getCaipNetworks().find((e) => e.id.toString() === l.toString()),
              a = this.getCaipNetworks().find((e) => e.chainNamespace === s);
            if (!c && !e && !a) {
              let t = this.getApprovedCaipNetworkIds() || [],
                n = t.find((e) => N.parseCaipNetworkId(e)?.chainId === l.toString()),
                r = t.find((e) => N.parseCaipNetworkId(e)?.chainNamespace === s);
              (e = this.getCaipNetworks().find((e) => e.caipNetworkId === n)),
                (a = this.getCaipNetworks().find(
                  (e) =>
                    e.caipNetworkId === r ||
                    ('deprecatedCaipNetworkId' in e && e.deprecatedCaipNetworkId === r)
                ));
            }
            let o = e || a;
            o?.chainNamespace === h.R.state.activeChain
              ? y.OptionsController.state.enableNetworkSwitch &&
                !y.OptionsController.state.allowUnsupportedChain &&
                h.R.state.activeCaipNetwork?.name === i.b.UNSUPPORTED_NETWORK_NAME
                ? h.R.showUnsupportedChainUI()
                : this.setCaipNetwork(o)
              : !t && n && this.setCaipNetworkOfNamespace(n, s),
              this.syncConnectedWalletInfo(s),
              b.g.isLowerCaseMatch(r, p.AccountController.state.address) ||
                this.syncAccountInfo(r, o?.id, s),
              t
                ? await this.syncBalance({ address: r, chainId: o?.id, chainNamespace: s })
                : await this.syncBalance({ address: r, chainId: n?.id, chainNamespace: s });
          }
        }
        async syncAccountInfo(e, t, n) {
          let r = this.getCaipAddress(n),
            i = t || r?.split(':')[1];
          if (!i) return;
          let a = `${n}:${i}:${e}`;
          this.setCaipAddress(a, n),
            await this.syncIdentity({ address: e, chainId: i, chainNamespace: n });
        }
        async syncReownName(e, t) {
          try {
            let n = await this.getReownName(e);
            if (n[0]) {
              let e = n[0];
              this.setProfileName(e.name, t);
            } else this.setProfileName(null, t);
          } catch {
            this.setProfileName(null, t);
          }
        }
        syncConnectedWalletInfo(e) {
          let t = s.ConnectorController.getConnectorId(e),
            n = _.getProviderId(e);
          if (n === w.b.CONNECTOR_TYPE_ANNOUNCED || n === w.b.CONNECTOR_TYPE_INJECTED) {
            if (t) {
              let n = this.getConnectors().find((e) => e.id === t);
              if (n) {
                let { info: t, name: r, imageUrl: i } = n,
                  a = i || this.getConnectorImage(n);
                this.setConnectedWalletInfo({ name: r, icon: a, ...t }, e);
              }
            }
          } else if (n === w.b.CONNECTOR_TYPE_WALLET_CONNECT) {
            let t = _.getProvider(e);
            t?.session &&
              this.setConnectedWalletInfo(
                {
                  ...t.session.peer.metadata,
                  name: t.session.peer.metadata.name,
                  icon: t.session.peer.metadata.icons?.[0],
                },
                e
              );
          } else if (t) {
            if (t === i.b.CONNECTOR_ID.COINBASE) {
              let t = this.getConnectors().find((e) => e.id === i.b.CONNECTOR_ID.COINBASE);
              this.setConnectedWalletInfo(
                { name: 'Coinbase Wallet', icon: this.getConnectorImage(t) },
                e
              );
            } else this.setConnectedWalletInfo({ name: t }, e);
          }
        }
        async syncBalance(e) {
          x.p
            .getNetworksByNamespace(this.getCaipNetworks(), e.chainNamespace)
            .find((t) => t.id.toString() === e.chainId?.toString()) &&
            e.chainId &&
            (await this.updateNativeBalance(e.address, e.chainId, e.chainNamespace));
        }
        async updateNativeBalance(e, t, n) {
          let r = this.getAdapter(n),
            i = h.R.getCaipNetworkByNamespace(n, t);
          if (r) {
            let a = await r.getBalance({
              address: e,
              chainId: t,
              caipNetwork: i,
              tokens: this.options.tokens,
            });
            this.setBalance(a.balance, a.symbol, n);
          }
        }
        async initializeUniversalAdapter() {
          let e = V.createLogger((e, ...t) => {
              e && this.handleAlertError(e), console.error(...t);
            }),
            t = {
              projectId: this.options?.projectId,
              metadata: {
                name: this.options?.metadata ? this.options?.metadata.name : '',
                description: this.options?.metadata ? this.options?.metadata.description : '',
                url: this.options?.metadata ? this.options?.metadata.url : '',
                icons: this.options?.metadata ? this.options?.metadata.icons : [''],
              },
              logger: e,
            };
          y.OptionsController.setManualWCControl(!!this.options?.manualWCControl),
            (this.universalProvider = this.options.universalProvider ?? (await O.Z.init(t))),
            this.listenWalletConnect();
        }
        listenWalletConnect() {
          this.universalProvider &&
            (this.universalProvider.on('display_uri', (e) => {
              o.ConnectionController.setUri(e);
            }),
            this.universalProvider.on('connect', o.ConnectionController.finalizeWcConnection),
            this.universalProvider.on('disconnect', () => {
              this.chainNamespaces.forEach((e) => {
                this.resetAccount(e);
              }),
                o.ConnectionController.resetWcConnection();
            }),
            this.universalProvider.on('chainChanged', (e) => {
              let t = this.getCaipNetworks().find((t) => t.id == e),
                n = this.getCaipNetwork();
              if (!t) {
                this.setUnsupportedNetwork(e);
                return;
              }
              n?.id !== t?.id && this.setCaipNetwork(t);
            }),
            this.universalProvider.on('session_event', (e) => {
              if (Q.sQ.isSessionEventData(e)) {
                let { name: t, data: n } = e.params.event;
                'accountsChanged' === t &&
                  Array.isArray(n) &&
                  r.j.isCaipAddress(n[0]) &&
                  this.syncAccount(N.parseCaipAddress(n[0]));
              }
            }));
        }
        createUniversalProvider() {
          return (
            !this.universalProviderInitPromise &&
              r.j.isClient() &&
              this.options?.projectId &&
              (this.universalProviderInitPromise = this.initializeUniversalAdapter()),
            this.universalProviderInitPromise
          );
        }
        async getUniversalProvider() {
          if (!this.universalProvider)
            try {
              await this.createUniversalProvider();
            } catch (e) {
              l.X.sendEvent({
                type: 'error',
                event: 'INTERNAL_SDK_ERROR',
                properties: {
                  errorType: 'UniversalProviderInitError',
                  errorMessage: e instanceof Error ? e.message : 'Unknown',
                  uncaught: !1,
                },
              }),
                console.error('AppKit:getUniversalProvider - Cannot create provider', e);
            }
          return this.universalProvider;
        }
        handleAlertError(e) {
          let [t, n] =
              Object.entries(v.j.UniversalProviderErrors).find(([, { message: t }]) =>
                e.message.includes(t)
              ) ?? [],
            { message: r, alertErrorKey: i } = n ?? {};
          if (t && r && !this.reportedAlertErrors[t]) {
            let e = v.j.ALERT_ERRORS[i];
            e && (g.AlertController.open(e, 'error'), (this.reportedAlertErrors[t] = !0));
          }
        }
        getAdapter(e) {
          if (e) return this.chainAdapters?.[e];
        }
        createAdapter(e) {
          if (!e) return;
          let t = e.namespace;
          t &&
            (this.createClients(),
            (e.namespace = t),
            e.construct({
              namespace: t,
              projectId: this.options?.projectId,
              networks: this.getCaipNetworks(),
            }),
            this.chainNamespaces.includes(t) || this.chainNamespaces.push(t),
            this.chainAdapters && (this.chainAdapters[t] = e));
        }
        async open(e) {
          return (await this.injectModalUi(),
          e?.uri && o.ConnectionController.setUri(e.uri),
          e?.arguments && e?.view === 'Swap')
            ? k.I.open({ ...e, data: { swap: e.arguments } })
            : k.I.open(e);
        }
        async close() {
          await this.injectModalUi(), k.I.close();
        }
        setLoading(e, t) {
          k.I.setLoading(e, t);
        }
        async disconnect(e) {
          await o.ConnectionController.disconnect(e);
        }
        getError() {
          return '';
        }
        getChainId() {
          return h.R.state.activeCaipNetwork?.id;
        }
        async switchNetwork(e) {
          let t = this.getCaipNetworks().find((t) => t.id === e.id);
          if (!t) {
            g.AlertController.open(v.j.ALERT_ERRORS.SWITCH_NETWORK_NOT_FOUND, 'error');
            return;
          }
          await h.R.switchActiveNetwork(t);
        }
        getWalletProvider() {
          return h.R.state.activeChain ? _.state.providers[h.R.state.activeChain] : null;
        }
        getWalletProviderType() {
          return _.getProviderId(h.R.state.activeChain);
        }
        subscribeProviders(e) {
          return _.subscribeProviders(e);
        }
        getThemeMode() {
          return f.ThemeController.state.themeMode;
        }
        getThemeVariables() {
          return f.ThemeController.state.themeVariables;
        }
        setThemeMode(e) {
          f.ThemeController.setThemeMode(e), (0, F.Hs)(f.ThemeController.state.themeMode);
        }
        setTermsConditionsUrl(e) {
          y.OptionsController.setTermsConditionsUrl(e);
        }
        setPrivacyPolicyUrl(e) {
          y.OptionsController.setPrivacyPolicyUrl(e);
        }
        setThemeVariables(e) {
          f.ThemeController.setThemeVariables(e), (0, F.R)(f.ThemeController.state.themeVariables);
        }
        subscribeTheme(e) {
          return f.ThemeController.subscribe(e);
        }
        getWalletInfo() {
          return p.AccountController.state.connectedWalletInfo;
        }
        getAccount(e) {
          let t = s.ConnectorController.getAuthConnector(e),
            n = h.R.getAccountData(e),
            i = h.R.state.activeChain;
          if (n)
            return {
              allAccounts: n.allAccounts,
              caipAddress: n.caipAddress,
              address: r.j.getPlainAddress(n.caipAddress),
              isConnected: !!n.caipAddress,
              status: n.status,
              embeddedWalletInfo: t
                ? {
                    user: n.user
                      ? { ...n.user, username: m.M.getConnectedSocialUsername() }
                      : void 0,
                    authProvider: n.socialProvider || 'email',
                    accountType: n.preferredAccountTypes?.[e || i],
                    isSmartAccountDeployed: !!n.smartAccountDeployed,
                  }
                : void 0,
            };
        }
        subscribeAccount(e, t) {
          let n = () => {
            let n = this.getAccount(t);
            n && e(n);
          };
          t ? h.R.subscribeChainProp('accountState', n, t) : h.R.subscribe(n),
            s.ConnectorController.subscribe(n);
        }
        subscribeNetwork(e) {
          return h.R.subscribe(({ activeCaipNetwork: t }) => {
            e({ caipNetwork: t, chainId: t?.id, caipNetworkId: t?.caipNetworkId });
          });
        }
        subscribeWalletInfo(e) {
          return p.AccountController.subscribeKey('connectedWalletInfo', e);
        }
        subscribeShouldUpdateToAddress(e) {
          p.AccountController.subscribeKey('shouldUpdateToAddress', e);
        }
        subscribeCaipNetworkChange(e) {
          h.R.subscribeKey('activeCaipNetwork', e);
        }
        getState() {
          return c.I.state;
        }
        subscribeState(e) {
          return c.I.subscribe(e);
        }
        showErrorMessage(e) {
          B.SnackController.showError(e);
        }
        showSuccessMessage(e) {
          B.SnackController.showSuccess(e);
        }
        getEvent() {
          return { ...l.X.state };
        }
        subscribeEvents(e) {
          return l.X.subscribe(e);
        }
        replace(e) {
          U.RouterController.replace(e);
        }
        redirect(e) {
          U.RouterController.push(e);
        }
        popTransactionStack(e) {
          U.RouterController.popTransactionStack(e);
        }
        isOpen() {
          return k.I.state.open;
        }
        isTransactionStackEmpty() {
          return 0 === U.RouterController.state.transactionStack.length;
        }
        isTransactionShouldReplaceView() {
          return U.RouterController.state.transactionStack[
            U.RouterController.state.transactionStack.length - 1
          ]?.replace;
        }
        static getInstance() {
          return this.instance;
        }
        updateFeatures(e) {
          y.OptionsController.setFeatures(e);
        }
        updateOptions(e) {
          let t = { ...(y.OptionsController.state || {}), ...e };
          y.OptionsController.setOptions(t);
        }
        setConnectMethodsOrder(e) {
          y.OptionsController.setConnectMethodsOrder(e);
        }
        setWalletFeaturesOrder(e) {
          y.OptionsController.setWalletFeaturesOrder(e);
        }
        setCollapseWallets(e) {
          y.OptionsController.setCollapseWallets(e);
        }
        setSocialsOrder(e) {
          y.OptionsController.setSocialsOrder(e);
        }
        getConnectMethodsOrder() {
          return L.J.getConnectOrderMethod(
            y.OptionsController.state.features,
            s.ConnectorController.getConnectors()
          );
        }
        addNetwork(e, t) {
          if (this.chainAdapters && !this.chainAdapters[e])
            throw Error(`Adapter for namespace ${e} doesn't exist`);
          let n = this.extendCaipNetwork(t, this.options);
          this.getCaipNetworks().find((e) => e.id === n.id) || h.R.addNetwork(n);
        }
        removeNetwork(e, t) {
          if (this.chainAdapters && !this.chainAdapters[e])
            throw Error(`Adapter for namespace ${e} doesn't exist`);
          this.getCaipNetworks().find((e) => e.id === t) && h.R.removeNetwork(e, t);
        }
      }
      let Z = !1;
      class J extends Y {
        setupAuthConnectorListeners(e) {
          e.onRpcRequest((t) => {
            I.$.checkIfRequestExists(t)
              ? I.$.checkIfRequestIsSafe(t) || this.handleUnsafeRPCRequest()
              : (this.open(),
                console.error(S.y_.RPC_METHOD_NOT_ALLOWED_MESSAGE, { method: t.method }),
                setTimeout(() => {
                  this.showErrorMessage(S.y_.RPC_METHOD_NOT_ALLOWED_UI_MESSAGE);
                }, 300),
                e.rejectRpcRequests());
          }),
            e.onRpcError(() => {
              this.isOpen() &&
                (this.isTransactionStackEmpty() ? this.close() : this.popTransactionStack(!0));
            }),
            e.onRpcSuccess((e, t) => {
              let n = I.$.checkIfRequestIsSafe(t),
                r = p.AccountController.state.address,
                i = h.R.state.activeCaipNetwork;
              !n &&
                (this.isTransactionStackEmpty() ? this.close() : this.popTransactionStack(),
                r && i?.id && this.updateNativeBalance(r, i.id, i.chainNamespace));
            }),
            e.onNotConnected(() => {
              let e = h.R.state.activeChain;
              s.ConnectorController.getConnectorId(e) === i.b.CONNECTOR_ID.AUTH &&
                (this.setCaipAddress(void 0, e), this.setLoading(!1, e));
            }),
            e.onConnect(async (t) => {
              let n = h.R.state.activeChain,
                a =
                  n === i.b.CHAIN.EVM
                    ? `eip155:${t.chainId}:${t.address}`
                    : `${t.chainId}:${t.address}`,
                s =
                  t.preferredAccountType ||
                  p.AccountController.state.preferredAccountTypes?.[n] ||
                  y.OptionsController.state.defaultAccountTypes[n];
              b.g.isLowerCaseMatch(t.address, p.AccountController.state.address) ||
                this.syncIdentity({ address: t.address, chainId: t.chainId, chainNamespace: n }),
                this.setCaipAddress(a, n),
                this.setUser({ ...(p.AccountController.state.user || {}), ...t }, n),
                this.setSmartAccountDeployed(!!t.smartAccountDeployed, n),
                this.setPreferredAccountType(s, n);
              let o = t.accounts?.map((e) =>
                r.j.createAccount(
                  n,
                  e.address,
                  e.type ||
                    p.AccountController.state.preferredAccountTypes?.[n] ||
                    y.OptionsController.state.defaultAccountTypes[n]
                )
              );
              this.setAllAccounts(
                o || [r.j.createAccount(n, t.address, t.preferredAccountType || s)],
                n
              ),
                await e.getSmartAccountEnabledNetworks(),
                this.setLoading(!1, n);
            }),
            e.onSocialConnected(({ userName: e }) => {
              this.setUser(
                { ...(p.AccountController.state.user || {}), username: e },
                h.R.state.activeChain
              );
            }),
            e.onGetSmartAccountEnabledNetworks((e) => {
              this.setSmartAccountEnabledNetworks(e, h.R.state.activeChain);
            }),
            e.onSetPreferredAccount(({ address: e, type: t }) => {
              e && this.setPreferredAccountType(t, h.R.state.activeChain);
            });
        }
        async syncAuthConnector(e, t) {
          let n = i.b.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(t);
          if (!n) return;
          this.setLoading(!0, t);
          let r = e.getLoginEmailUsed();
          this.setLoading(r, t), r && this.setStatus('connecting', t);
          let o = e.getEmail(),
            l = e.getUsername();
          this.setUser(
            { ...(p.AccountController.state?.user || {}), username: l, email: o },
            h.R.state.activeChain
          ),
            this.setupAuthConnectorListeners(e);
          let { isConnected: u } = await e.isConnected(),
            c = f.ThemeController.getSnapshot(),
            d = y.OptionsController.getSnapshot();
          e.syncDappData({
            metadata: d.metadata,
            sdkVersion: d.sdkVersion,
            projectId: d.projectId,
            sdkType: d.sdkType,
          }),
            e.syncTheme({
              themeMode: c.themeMode,
              themeVariables: c.themeVariables,
              w3mThemeVariables: (0, a.t)(c.themeVariables, c.themeMode),
            }),
            t &&
              n &&
              (u && this.connectionControllerClient?.connectExternal
                ? (await this.connectionControllerClient?.connectExternal({
                    id: i.b.CONNECTOR_ID.AUTH,
                    info: { name: i.b.CONNECTOR_ID.AUTH },
                    type: w.b.CONNECTOR_TYPE_AUTH,
                    provider: e,
                    chainId: h.R.state.activeCaipNetwork?.id,
                    chain: t,
                  }),
                  this.setStatus('connected', t))
                : s.ConnectorController.getConnectorId(t) === i.b.CONNECTOR_ID.AUTH &&
                  (this.setStatus('disconnected', t), m.M.removeConnectedNamespace(t))),
            this.setLoading(!1, t);
        }
        async checkExistingTelegramSocialConnection(e) {
          try {
            if (!r.j.isTelegram()) return;
            let t = m.M.getTelegramSocialProvider();
            if (!t || 'undefined' == typeof window || 'undefined' == typeof document) return;
            let n = new URL(window.location.href).searchParams.get('result_uri');
            if (!n) return;
            p.AccountController.setSocialProvider(t, e), await this.authProvider?.init();
            let i = s.ConnectorController.getAuthConnector();
            t &&
              i &&
              (this.setLoading(!0, e),
              await i.provider.connectSocial(n),
              await o.ConnectionController.connectExternal(i, i.chain),
              m.M.setConnectedSocialProvider(t),
              m.M.removeTelegramSocialProvider(),
              l.X.sendEvent({
                type: 'track',
                event: 'SOCIAL_LOGIN_SUCCESS',
                properties: { provider: t },
              }));
          } catch (t) {
            this.setLoading(!1, e), console.error('checkExistingSTelegramocialConnection error', t);
          }
          try {
            let e = new URL(window.location.href);
            e.searchParams.delete('result_uri'),
              window.history.replaceState({}, document.title, e.toString());
          } catch (e) {
            console.error('tma social login failed', e);
          }
        }
        createAuthProvider(e) {
          if (!i.b.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(e)) return;
          let t =
              this.options?.features?.email === void 0
                ? u.bq.DEFAULT_FEATURES.email
                : this.options?.features?.email,
            n = this.options?.features?.socials
              ? this.options?.features?.socials?.length > 0
              : u.bq.DEFAULT_FEATURES.socials;
          !this.authProvider &&
            this.options?.projectId &&
            (t || n) &&
            ((this.authProvider = P.D.getInstance({
              projectId: this.options.projectId,
              enableLogger: this.options.enableAuthLogger,
              chainId: this.getCaipNetwork(e)?.caipNetworkId,
              onTimeout: () => {
                g.AlertController.open(v.j.ALERT_ERRORS.SOCIALS_TIMEOUT, 'error');
              },
            })),
            c.I.subscribeOpen((e) => {
              !e && this.isTransactionStackEmpty() && this.authProvider?.rejectRpcRequests();
            }),
            e === i.b.CHAIN.EVM &&
              p.AccountController.state.preferredAccountTypes?.eip155 &&
              this.authProvider.setPreferredAccount(
                p.AccountController.state.preferredAccountTypes?.eip155
              ),
            this.syncAuthConnector(this.authProvider, e),
            this.checkExistingTelegramSocialConnection(e));
        }
        createAuthProviderForAdapter(e) {
          this.createAuthProvider(e),
            this.authProvider && this.chainAdapters?.[e]?.setAuthProvider?.(this.authProvider);
        }
        initControllers(e) {
          super.initControllers(e),
            this.options.excludeWalletIds &&
              d.ApiController.initializeExcludedWallets({ ids: this.options.excludeWalletIds });
        }
        async switchCaipNetwork(e) {
          if (!e) return;
          let t = h.R.state.activeChain,
            n = e.chainNamespace,
            r = this.getAddressByChainNamespace(e.chainNamespace);
          if (e.chainNamespace === h.R.state.activeChain && r) {
            let t = this.getAdapter(n),
              r = _.getProvider(n),
              i = _.getProviderId(n);
            await t?.switchNetwork({ caipNetwork: e, provider: r, providerType: i }),
              this.setCaipNetwork(e);
          } else {
            let a = _.getProviderId(t) === w.b.CONNECTOR_TYPE_AUTH,
              s = _.getProviderId(n),
              o = s === w.b.CONNECTOR_TYPE_AUTH,
              l = i.b.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(n);
            if ((a || o) && l)
              try {
                (h.R.state.activeChain = e.chainNamespace),
                  await this.connectionControllerClient?.connectExternal?.({
                    id: i.b.CONNECTOR_ID.AUTH,
                    provider: this.authProvider,
                    chain: n,
                    chainId: e.id,
                    type: w.b.CONNECTOR_TYPE_AUTH,
                    caipNetwork: e,
                  }),
                  this.setCaipNetwork(e);
              } catch (r) {
                let t = this.getAdapter(n);
                await t?.switchNetwork({
                  caipNetwork: e,
                  provider: this.authProvider,
                  providerType: s,
                });
              }
            else
              s === w.b.CONNECTOR_TYPE_WALLET_CONNECT
                ? (this.setCaipNetwork(e), this.syncWalletConnectAccount())
                : (this.setCaipNetwork(e),
                  r && this.syncAccount({ address: r, chainId: e.id, chainNamespace: n }));
          }
        }
        async initChainAdapter(e) {
          await super.initChainAdapter(e), this.createAuthProviderForAdapter(e);
        }
        async syncIdentity({ address: e, chainId: t, chainNamespace: n }) {
          let r = `${n}:${t}`,
            a = this.caipNetworks?.find((e) => e.caipNetworkId === r);
          if (n !== i.b.CHAIN.EVM || a?.testnet) {
            this.setProfileName(null, n), this.setProfileImage(null, n);
            return;
          }
          try {
            let { name: i, avatar: a } = await this.fetchIdentity({ address: e, caipNetworkId: r });
            if ((this.setProfileName(i, n), this.setProfileImage(a, n), !i)) {
              let r = this.getAdapter(n),
                i = await r?.getProfile({ address: e, chainId: Number(t) });
              i?.profileName
                ? (this.setProfileName(i.profileName, n),
                  i.profileImage && this.setProfileImage(i.profileImage, n))
                : (await this.syncReownName(e, n), this.setProfileImage(null, n));
            }
          } catch {
            await this.syncReownName(e, n), 1 !== t && this.setProfileImage(null, n);
          }
        }
        syncConnectedWalletInfo(e) {
          let t = _.getProviderId(e);
          if (t === w.b.CONNECTOR_TYPE_AUTH) {
            let n = this.authProvider;
            if (n) {
              let r = m.M.getConnectedSocialProvider() ?? 'email',
                i = n.getEmail() ?? n.getUsername();
              this.setConnectedWalletInfo({ name: t, identifier: i, social: r }, e);
            }
          } else super.syncConnectedWalletInfo(e);
        }
        async injectModalUi() {
          if (!Z && r.j.isClient()) {
            let e = { ...u.bq.DEFAULT_FEATURES, ...this.options.features },
              t = [];
            if (
              (e &&
                ((e.email || (e.socials && e.socials.length)) &&
                  t.push(Promise.all([n.e(1596), n.e(522), n.e(5541)]).then(n.bind(n, 35541))),
                e.email &&
                  t.push(Promise.all([n.e(1596), n.e(522), n.e(4340)]).then(n.bind(n, 44340))),
                e.socials &&
                  t.push(
                    Promise.all([n.e(1596), n.e(3239), n.e(7092), n.e(1148)]).then(n.bind(n, 67341))
                  ),
                e.swaps &&
                  t.push(
                    Promise.all([n.e(1596), n.e(522), n.e(9240), n.e(5018)]).then(n.bind(n, 25018))
                  ),
                e.send &&
                  t.push(
                    Promise.all([n.e(1596), n.e(522), n.e(9240), n.e(4776)]).then(n.bind(n, 64776))
                  ),
                e.receive &&
                  t.push(Promise.all([n.e(1596), n.e(3239), n.e(829)]).then(n.bind(n, 10829))),
                e.onramp &&
                  t.push(
                    Promise.all([n.e(1596), n.e(522), n.e(7092), n.e(2189), n.e(7253)]).then(
                      n.bind(n, 17253)
                    )
                  ),
                e.history &&
                  t.push(Promise.all([n.e(1596), n.e(7215), n.e(2980)]).then(n.bind(n, 20786)))),
              await Promise.all([
                ...t,
                Promise.all([
                  n.e(1596),
                  n.e(522),
                  n.e(3239),
                  n.e(7092),
                  n.e(2189),
                  n.e(7215),
                  n.e(5770),
                  n.e(2729),
                ]).then(n.bind(n, 62729)),
                Promise.all([n.e(1596), n.e(5770), n.e(187)]).then(n.bind(n, 59099)),
              ]),
              !document.querySelector('w3m-modal'))
            ) {
              let e = document.createElement('w3m-modal');
              y.OptionsController.state.disableAppend ||
                y.OptionsController.state.enableEmbedded ||
                document.body.insertAdjacentElement('beforeend', e);
            }
            Z = !0;
          }
        }
      }
      function X(e) {
        return new J({
          ...e,
          sdkVersion: r.j.generateSdkVersion(e.adapters ?? [], 'html', '1.7.3'),
        });
      }
    },
    41291: function (e, t, n) {
      'use strict';
      n.d(t, {
        q: function () {
          return l;
        },
      }),
        n(26651);
      var r = n(49786),
        i = n(97059),
        a = n(60725),
        s = n(23893),
        o = n(31399);
      class l {
        constructor(e) {
          (this.availableConnectors = []),
            (this.eventListeners = new Map()),
            (this.getCaipNetworks = (e) => i.R.getCaipNetworks(e)),
            e && this.construct(e);
        }
        construct(e) {
          (this.projectId = e.projectId),
            (this.namespace = e.namespace),
            (this.adapterType = e.adapterType);
        }
        get connectors() {
          return this.availableConnectors;
        }
        get networks() {
          return this.getCaipNetworks(this.namespace);
        }
        setAuthProvider(e) {
          this.addConnector({
            id: r.b.CONNECTOR_ID.AUTH,
            type: 'AUTH',
            name: r.b.CONNECTOR_NAMES.AUTH,
            provider: e,
            imageId: s.C.ConnectorImageIds[r.b.CONNECTOR_ID.AUTH],
            chain: this.namespace,
            chains: [],
          });
        }
        addConnector(...e) {
          let t = new Set();
          (this.availableConnectors = [...e, ...this.availableConnectors].filter(
            (e) => !t.has(e.id) && (t.add(e.id), !0)
          )),
            this.emit('connectors', this.availableConnectors);
        }
        setStatus(e, t) {
          a.AccountController.setStatus(e, t);
        }
        on(e, t) {
          this.eventListeners.has(e) || this.eventListeners.set(e, new Set()),
            this.eventListeners.get(e)?.add(t);
        }
        off(e, t) {
          let n = this.eventListeners.get(e);
          n && n.delete(t);
        }
        removeAllEventListeners() {
          this.eventListeners.forEach((e) => {
            e.clear();
          });
        }
        emit(e, t) {
          let n = this.eventListeners.get(e);
          n && n.forEach((e) => e(t));
        }
        async connectWalletConnect(e) {
          let t = this.getWalletConnectConnector();
          return { clientId: (await t.connectWalletConnect()).clientId };
        }
        async switchNetwork(e) {
          let { caipNetwork: t, providerType: n } = e;
          if (!e.provider) return;
          let r = 'provider' in e.provider ? e.provider.provider : e.provider;
          if ('WALLET_CONNECT' === n) {
            r.setDefaultChain(t.caipNetworkId);
            return;
          }
          if (r && 'AUTH' === n) {
            let e = a.AccountController.state.preferredAccountTypes?.[t.chainNamespace];
            await r.switchNetwork(t.caipNetworkId);
            let n = await r.getUser({ chainId: t.caipNetworkId, preferredAccountType: e });
            this.emit('switchNetwork', n);
          }
        }
        getWalletConnectConnector() {
          let e = this.connectors.find((e) => e instanceof o.z);
          if (!e) throw Error('WalletConnectConnector not found');
          return e;
        }
      }
    },
    80487: function (e, t, n) {
      'use strict';
      let r;
      n.d(t, {
        D: function () {
          return nT;
        },
      });
      var i,
        a,
        s,
        o,
        l,
        u,
        c,
        d = n(41428),
        p = n(39037);
      ((i = o || (o = {})).assertEqual = (e) => e),
        (i.assertIs = function (e) {}),
        (i.assertNever = function (e) {
          throw Error();
        }),
        (i.arrayToEnum = (e) => {
          let t = {};
          for (let n of e) t[n] = n;
          return t;
        }),
        (i.getValidEnumValues = (e) => {
          let t = i.objectKeys(e).filter((t) => 'number' != typeof e[e[t]]),
            n = {};
          for (let r of t) n[r] = e[r];
          return i.objectValues(n);
        }),
        (i.objectValues = (e) =>
          i.objectKeys(e).map(function (t) {
            return e[t];
          })),
        (i.objectKeys =
          'function' == typeof Object.keys
            ? (e) => Object.keys(e)
            : (e) => {
                let t = [];
                for (let n in e) Object.prototype.hasOwnProperty.call(e, n) && t.push(n);
                return t;
              }),
        (i.find = (e, t) => {
          for (let n of e) if (t(n)) return n;
        }),
        (i.isInteger =
          'function' == typeof Number.isInteger
            ? (e) => Number.isInteger(e)
            : (e) => 'number' == typeof e && isFinite(e) && Math.floor(e) === e),
        (i.joinValues = function (e, t = ' | ') {
          return e.map((e) => ('string' == typeof e ? `'${e}'` : e)).join(t);
        }),
        (i.jsonStringifyReplacer = (e, t) => ('bigint' == typeof t ? t.toString() : t)),
        ((l || (l = {})).mergeShapes = (e, t) => ({ ...e, ...t }));
      let h = o.arrayToEnum([
          'string',
          'nan',
          'number',
          'integer',
          'float',
          'boolean',
          'date',
          'bigint',
          'symbol',
          'function',
          'undefined',
          'null',
          'array',
          'object',
          'unknown',
          'promise',
          'void',
          'never',
          'map',
          'set',
        ]),
        y = (e) => {
          switch (typeof e) {
            case 'undefined':
              return h.undefined;
            case 'string':
              return h.string;
            case 'number':
              return isNaN(e) ? h.nan : h.number;
            case 'boolean':
              return h.boolean;
            case 'function':
              return h.function;
            case 'bigint':
              return h.bigint;
            case 'symbol':
              return h.symbol;
            case 'object':
              if (Array.isArray(e)) return h.array;
              if (null === e) return h.null;
              if (e.then && 'function' == typeof e.then && e.catch && 'function' == typeof e.catch)
                return h.promise;
              if ('undefined' != typeof Map && e instanceof Map) return h.map;
              if ('undefined' != typeof Set && e instanceof Set) return h.set;
              if ('undefined' != typeof Date && e instanceof Date) return h.date;
              return h.object;
            default:
              return h.unknown;
          }
        },
        f = o.arrayToEnum([
          'invalid_type',
          'invalid_literal',
          'custom',
          'invalid_union',
          'invalid_union_discriminator',
          'invalid_enum_value',
          'unrecognized_keys',
          'invalid_arguments',
          'invalid_return_type',
          'invalid_date',
          'invalid_string',
          'too_small',
          'too_big',
          'invalid_intersection_types',
          'not_multiple_of',
          'not_finite',
        ]);
      class m extends Error {
        constructor(e) {
          super(),
            (this.issues = []),
            (this.addIssue = (e) => {
              this.issues = [...this.issues, e];
            }),
            (this.addIssues = (e = []) => {
              this.issues = [...this.issues, ...e];
            });
          let t = new.target.prototype;
          Object.setPrototypeOf ? Object.setPrototypeOf(this, t) : (this.__proto__ = t),
            (this.name = 'ZodError'),
            (this.issues = e);
        }
        get errors() {
          return this.issues;
        }
        format(e) {
          let t =
              e ||
              function (e) {
                return e.message;
              },
            n = { _errors: [] },
            r = (e) => {
              for (let i of e.issues)
                if ('invalid_union' === i.code) i.unionErrors.map(r);
                else if ('invalid_return_type' === i.code) r(i.returnTypeError);
                else if ('invalid_arguments' === i.code) r(i.argumentsError);
                else if (0 === i.path.length) n._errors.push(t(i));
                else {
                  let e = n,
                    r = 0;
                  for (; r < i.path.length; ) {
                    let n = i.path[r];
                    r === i.path.length - 1
                      ? ((e[n] = e[n] || { _errors: [] }), e[n]._errors.push(t(i)))
                      : (e[n] = e[n] || { _errors: [] }),
                      (e = e[n]),
                      r++;
                  }
                }
            };
          return r(this), n;
        }
        toString() {
          return this.message;
        }
        get message() {
          return JSON.stringify(this.issues, o.jsonStringifyReplacer, 2);
        }
        get isEmpty() {
          return 0 === this.issues.length;
        }
        flatten(e = (e) => e.message) {
          let t = {},
            n = [];
          for (let r of this.issues)
            r.path.length > 0
              ? ((t[r.path[0]] = t[r.path[0]] || []), t[r.path[0]].push(e(r)))
              : n.push(e(r));
          return { formErrors: n, fieldErrors: t };
        }
        get formErrors() {
          return this.flatten();
        }
      }
      m.create = (e) => new m(e);
      let g = (e, t) => {
          let n;
          switch (e.code) {
            case f.invalid_type:
              n =
                e.received === h.undefined
                  ? 'Required'
                  : `Expected ${e.expected}, received ${e.received}`;
              break;
            case f.invalid_literal:
              n = `Invalid literal value, expected ${JSON.stringify(e.expected, o.jsonStringifyReplacer)}`;
              break;
            case f.unrecognized_keys:
              n = `Unrecognized key(s) in object: ${o.joinValues(e.keys, ', ')}`;
              break;
            case f.invalid_union:
              n = 'Invalid input';
              break;
            case f.invalid_union_discriminator:
              n = `Invalid discriminator value. Expected ${o.joinValues(e.options)}`;
              break;
            case f.invalid_enum_value:
              n = `Invalid enum value. Expected ${o.joinValues(e.options)}, received '${e.received}'`;
              break;
            case f.invalid_arguments:
              n = 'Invalid function arguments';
              break;
            case f.invalid_return_type:
              n = 'Invalid function return type';
              break;
            case f.invalid_date:
              n = 'Invalid date';
              break;
            case f.invalid_string:
              'object' == typeof e.validation
                ? 'includes' in e.validation
                  ? ((n = `Invalid input: must include "${e.validation.includes}"`),
                    'number' == typeof e.validation.position &&
                      (n = `${n} at one or more positions greater than or equal to ${e.validation.position}`))
                  : 'startsWith' in e.validation
                    ? (n = `Invalid input: must start with "${e.validation.startsWith}"`)
                    : 'endsWith' in e.validation
                      ? (n = `Invalid input: must end with "${e.validation.endsWith}"`)
                      : o.assertNever(e.validation)
                : (n = 'regex' !== e.validation ? `Invalid ${e.validation}` : 'Invalid');
              break;
            case f.too_small:
              n =
                'array' === e.type
                  ? `Array must contain ${e.exact ? 'exactly' : e.inclusive ? 'at least' : 'more than'} ${e.minimum} element(s)`
                  : 'string' === e.type
                    ? `String must contain ${e.exact ? 'exactly' : e.inclusive ? 'at least' : 'over'} ${e.minimum} character(s)`
                    : 'number' === e.type
                      ? `Number must be ${e.exact ? 'exactly equal to ' : e.inclusive ? 'greater than or equal to ' : 'greater than '}${e.minimum}`
                      : 'date' === e.type
                        ? `Date must be ${e.exact ? 'exactly equal to ' : e.inclusive ? 'greater than or equal to ' : 'greater than '}${new Date(Number(e.minimum))}`
                        : 'Invalid input';
              break;
            case f.too_big:
              n =
                'array' === e.type
                  ? `Array must contain ${e.exact ? 'exactly' : e.inclusive ? 'at most' : 'less than'} ${e.maximum} element(s)`
                  : 'string' === e.type
                    ? `String must contain ${e.exact ? 'exactly' : e.inclusive ? 'at most' : 'under'} ${e.maximum} character(s)`
                    : 'number' === e.type
                      ? `Number must be ${e.exact ? 'exactly' : e.inclusive ? 'less than or equal to' : 'less than'} ${e.maximum}`
                      : 'bigint' === e.type
                        ? `BigInt must be ${e.exact ? 'exactly' : e.inclusive ? 'less than or equal to' : 'less than'} ${e.maximum}`
                        : 'date' === e.type
                          ? `Date must be ${e.exact ? 'exactly' : e.inclusive ? 'smaller than or equal to' : 'smaller than'} ${new Date(Number(e.maximum))}`
                          : 'Invalid input';
              break;
            case f.custom:
              n = 'Invalid input';
              break;
            case f.invalid_intersection_types:
              n = 'Intersection results could not be merged';
              break;
            case f.not_multiple_of:
              n = `Number must be a multiple of ${e.multipleOf}`;
              break;
            case f.not_finite:
              n = 'Number must be finite';
              break;
            default:
              (n = t.defaultError), o.assertNever(e);
          }
          return { message: n };
        },
        b = g;
      function w() {
        return b;
      }
      let v = (e) => {
        let { data: t, path: n, errorMaps: r, issueData: i } = e,
          a = [...n, ...(i.path || [])],
          s = { ...i, path: a },
          o = '';
        for (let e of r
          .filter((e) => !!e)
          .slice()
          .reverse())
          o = e(s, { data: t, defaultError: o }).message;
        return { ...i, path: a, message: i.message || o };
      };
      function T(e, t) {
        let n = v({
          issueData: t,
          data: e.data,
          path: e.path,
          errorMaps: [e.common.contextualErrorMap, e.schemaErrorMap, w(), g].filter((e) => !!e),
        });
        e.common.issues.push(n);
      }
      class A {
        constructor() {
          this.value = 'valid';
        }
        dirty() {
          'valid' === this.value && (this.value = 'dirty');
        }
        abort() {
          'aborted' !== this.value && (this.value = 'aborted');
        }
        static mergeArray(e, t) {
          let n = [];
          for (let r of t) {
            if ('aborted' === r.status) return E;
            'dirty' === r.status && e.dirty(), n.push(r.value);
          }
          return { status: e.value, value: n };
        }
        static async mergeObjectAsync(e, t) {
          let n = [];
          for (let e of t) n.push({ key: await e.key, value: await e.value });
          return A.mergeObjectSync(e, n);
        }
        static mergeObjectSync(e, t) {
          let n = {};
          for (let r of t) {
            let { key: t, value: i } = r;
            if ('aborted' === t.status || 'aborted' === i.status) return E;
            'dirty' === t.status && e.dirty(),
              'dirty' === i.status && e.dirty(),
              '__proto__' !== t.value &&
                (void 0 !== i.value || r.alwaysSet) &&
                (n[t.value] = i.value);
          }
          return { status: e.value, value: n };
        }
      }
      let E = Object.freeze({ status: 'aborted' }),
        C = (e) => ({ status: 'dirty', value: e }),
        _ = (e) => ({ status: 'valid', value: e }),
        I = (e) => 'aborted' === e.status,
        S = (e) => 'dirty' === e.status,
        P = (e) => 'valid' === e.status,
        O = (e) => 'undefined' != typeof Promise && e instanceof Promise;
      ((a = u || (u = {})).errToObj = (e) => ('string' == typeof e ? { message: e } : e || {})),
        (a.toString = (e) => ('string' == typeof e ? e : null == e ? void 0 : e.message));
      class N {
        constructor(e, t, n, r) {
          (this._cachedPath = []),
            (this.parent = e),
            (this.data = t),
            (this._path = n),
            (this._key = r);
        }
        get path() {
          return (
            this._cachedPath.length ||
              (this._key instanceof Array
                ? this._cachedPath.push(...this._path, ...this._key)
                : this._cachedPath.push(...this._path, this._key)),
            this._cachedPath
          );
        }
      }
      let x = (e, t) => {
        if (P(t)) return { success: !0, data: t.value };
        if (!e.common.issues.length) throw Error('Validation failed but no issues detected.');
        return {
          success: !1,
          get error() {
            if (this._error) return this._error;
            let t = new m(e.common.issues);
            return (this._error = t), this._error;
          },
        };
      };
      function M(e) {
        if (!e) return {};
        let { errorMap: t, invalid_type_error: n, required_error: r, description: i } = e;
        if (t && (n || r))
          throw Error(
            'Can\'t use "invalid_type_error" or "required_error" in conjunction with custom error map.'
          );
        return t
          ? { errorMap: t, description: i }
          : {
              errorMap: (e, t) =>
                'invalid_type' !== e.code
                  ? { message: t.defaultError }
                  : void 0 === t.data
                    ? { message: null != r ? r : t.defaultError }
                    : { message: null != n ? n : t.defaultError },
              description: i,
            };
      }
      class k {
        constructor(e) {
          (this.spa = this.safeParseAsync),
            (this._def = e),
            (this.parse = this.parse.bind(this)),
            (this.safeParse = this.safeParse.bind(this)),
            (this.parseAsync = this.parseAsync.bind(this)),
            (this.safeParseAsync = this.safeParseAsync.bind(this)),
            (this.spa = this.spa.bind(this)),
            (this.refine = this.refine.bind(this)),
            (this.refinement = this.refinement.bind(this)),
            (this.superRefine = this.superRefine.bind(this)),
            (this.optional = this.optional.bind(this)),
            (this.nullable = this.nullable.bind(this)),
            (this.nullish = this.nullish.bind(this)),
            (this.array = this.array.bind(this)),
            (this.promise = this.promise.bind(this)),
            (this.or = this.or.bind(this)),
            (this.and = this.and.bind(this)),
            (this.transform = this.transform.bind(this)),
            (this.brand = this.brand.bind(this)),
            (this.default = this.default.bind(this)),
            (this.catch = this.catch.bind(this)),
            (this.describe = this.describe.bind(this)),
            (this.pipe = this.pipe.bind(this)),
            (this.readonly = this.readonly.bind(this)),
            (this.isNullable = this.isNullable.bind(this)),
            (this.isOptional = this.isOptional.bind(this));
        }
        get description() {
          return this._def.description;
        }
        _getType(e) {
          return y(e.data);
        }
        _getOrReturnCtx(e, t) {
          return (
            t || {
              common: e.parent.common,
              data: e.data,
              parsedType: y(e.data),
              schemaErrorMap: this._def.errorMap,
              path: e.path,
              parent: e.parent,
            }
          );
        }
        _processInputParams(e) {
          return {
            status: new A(),
            ctx: {
              common: e.parent.common,
              data: e.data,
              parsedType: y(e.data),
              schemaErrorMap: this._def.errorMap,
              path: e.path,
              parent: e.parent,
            },
          };
        }
        _parseSync(e) {
          let t = this._parse(e);
          if (O(t)) throw Error('Synchronous parse encountered promise.');
          return t;
        }
        _parseAsync(e) {
          return Promise.resolve(this._parse(e));
        }
        parse(e, t) {
          let n = this.safeParse(e, t);
          if (n.success) return n.data;
          throw n.error;
        }
        safeParse(e, t) {
          var n;
          let r = {
              common: {
                issues: [],
                async: null !== (n = null == t ? void 0 : t.async) && void 0 !== n && n,
                contextualErrorMap: null == t ? void 0 : t.errorMap,
              },
              path: (null == t ? void 0 : t.path) || [],
              schemaErrorMap: this._def.errorMap,
              parent: null,
              data: e,
              parsedType: y(e),
            },
            i = this._parseSync({ data: e, path: r.path, parent: r });
          return x(r, i);
        }
        async parseAsync(e, t) {
          let n = await this.safeParseAsync(e, t);
          if (n.success) return n.data;
          throw n.error;
        }
        async safeParseAsync(e, t) {
          let n = {
              common: {
                issues: [],
                contextualErrorMap: null == t ? void 0 : t.errorMap,
                async: !0,
              },
              path: (null == t ? void 0 : t.path) || [],
              schemaErrorMap: this._def.errorMap,
              parent: null,
              data: e,
              parsedType: y(e),
            },
            r = this._parse({ data: e, path: n.path, parent: n });
          return x(n, await (O(r) ? r : Promise.resolve(r)));
        }
        refine(e, t) {
          let n = (e) =>
            'string' == typeof t || void 0 === t
              ? { message: t }
              : 'function' == typeof t
                ? t(e)
                : t;
          return this._refinement((t, r) => {
            let i = e(t),
              a = () => r.addIssue({ code: f.custom, ...n(t) });
            return 'undefined' != typeof Promise && i instanceof Promise
              ? i.then((e) => !!e || (a(), !1))
              : !!i || (a(), !1);
          });
        }
        refinement(e, t) {
          return this._refinement(
            (n, r) => !!e(n) || (r.addIssue('function' == typeof t ? t(n, r) : t), !1)
          );
        }
        _refinement(e) {
          return new eg({
            schema: this,
            typeName: c.ZodEffects,
            effect: { type: 'refinement', refinement: e },
          });
        }
        superRefine(e) {
          return this._refinement(e);
        }
        optional() {
          return eb.create(this, this._def);
        }
        nullable() {
          return ew.create(this, this._def);
        }
        nullish() {
          return this.nullable().optional();
        }
        array() {
          return ee.create(this, this._def);
        }
        promise() {
          return em.create(this, this._def);
        }
        or(e) {
          return en.create([this, e], this._def);
        }
        and(e) {
          return ea.create(this, e, this._def);
        }
        transform(e) {
          return new eg({
            ...M(this._def),
            schema: this,
            typeName: c.ZodEffects,
            effect: { type: 'transform', transform: e },
          });
        }
        default(e) {
          return new ev({
            ...M(this._def),
            innerType: this,
            defaultValue: 'function' == typeof e ? e : () => e,
            typeName: c.ZodDefault,
          });
        }
        brand() {
          return new eC({ typeName: c.ZodBranded, type: this, ...M(this._def) });
        }
        catch(e) {
          return new eT({
            ...M(this._def),
            innerType: this,
            catchValue: 'function' == typeof e ? e : () => e,
            typeName: c.ZodCatch,
          });
        }
        describe(e) {
          return new this.constructor({ ...this._def, description: e });
        }
        pipe(e) {
          return e_.create(this, e);
        }
        readonly() {
          return eI.create(this);
        }
        isOptional() {
          return this.safeParse(void 0).success;
        }
        isNullable() {
          return this.safeParse(null).success;
        }
      }
      let R = /^c[^\s-]{8,}$/i,
        D = /^[a-z][a-z0-9]*$/,
        B = /^[0-9A-HJKMNP-TV-Z]{26}$/,
        U =
          /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
        L = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
        F =
          /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/,
        j =
          /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
        q = (e) =>
          e.precision
            ? e.offset
              ? RegExp(
                  `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`
                )
              : RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`)
            : 0 === e.precision
              ? e.offset
                ? RegExp('^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$')
                : RegExp('^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$')
              : e.offset
                ? RegExp(
                    '^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$'
                  )
                : RegExp('^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$');
      class V extends k {
        _parse(e) {
          let t;
          if ((this._def.coerce && (e.data = String(e.data)), this._getType(e) !== h.string)) {
            let t = this._getOrReturnCtx(e);
            return T(t, { code: f.invalid_type, expected: h.string, received: t.parsedType }), E;
          }
          let n = new A();
          for (let s of this._def.checks)
            if ('min' === s.kind)
              e.data.length < s.value &&
                (T((t = this._getOrReturnCtx(e, t)), {
                  code: f.too_small,
                  minimum: s.value,
                  type: 'string',
                  inclusive: !0,
                  exact: !1,
                  message: s.message,
                }),
                n.dirty());
            else if ('max' === s.kind)
              e.data.length > s.value &&
                (T((t = this._getOrReturnCtx(e, t)), {
                  code: f.too_big,
                  maximum: s.value,
                  type: 'string',
                  inclusive: !0,
                  exact: !1,
                  message: s.message,
                }),
                n.dirty());
            else if ('length' === s.kind) {
              let r = e.data.length > s.value,
                i = e.data.length < s.value;
              (r || i) &&
                ((t = this._getOrReturnCtx(e, t)),
                r
                  ? T(t, {
                      code: f.too_big,
                      maximum: s.value,
                      type: 'string',
                      inclusive: !0,
                      exact: !0,
                      message: s.message,
                    })
                  : i &&
                    T(t, {
                      code: f.too_small,
                      minimum: s.value,
                      type: 'string',
                      inclusive: !0,
                      exact: !0,
                      message: s.message,
                    }),
                n.dirty());
            } else if ('email' === s.kind)
              L.test(e.data) ||
                (T((t = this._getOrReturnCtx(e, t)), {
                  validation: 'email',
                  code: f.invalid_string,
                  message: s.message,
                }),
                n.dirty());
            else if ('emoji' === s.kind)
              r || (r = RegExp('^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$', 'u')),
                r.test(e.data) ||
                  (T((t = this._getOrReturnCtx(e, t)), {
                    validation: 'emoji',
                    code: f.invalid_string,
                    message: s.message,
                  }),
                  n.dirty());
            else if ('uuid' === s.kind)
              U.test(e.data) ||
                (T((t = this._getOrReturnCtx(e, t)), {
                  validation: 'uuid',
                  code: f.invalid_string,
                  message: s.message,
                }),
                n.dirty());
            else if ('cuid' === s.kind)
              R.test(e.data) ||
                (T((t = this._getOrReturnCtx(e, t)), {
                  validation: 'cuid',
                  code: f.invalid_string,
                  message: s.message,
                }),
                n.dirty());
            else if ('cuid2' === s.kind)
              D.test(e.data) ||
                (T((t = this._getOrReturnCtx(e, t)), {
                  validation: 'cuid2',
                  code: f.invalid_string,
                  message: s.message,
                }),
                n.dirty());
            else if ('ulid' === s.kind)
              B.test(e.data) ||
                (T((t = this._getOrReturnCtx(e, t)), {
                  validation: 'ulid',
                  code: f.invalid_string,
                  message: s.message,
                }),
                n.dirty());
            else if ('url' === s.kind)
              try {
                new URL(e.data);
              } catch (r) {
                T((t = this._getOrReturnCtx(e, t)), {
                  validation: 'url',
                  code: f.invalid_string,
                  message: s.message,
                }),
                  n.dirty();
              }
            else if ('regex' === s.kind)
              (s.regex.lastIndex = 0),
                s.regex.test(e.data) ||
                  (T((t = this._getOrReturnCtx(e, t)), {
                    validation: 'regex',
                    code: f.invalid_string,
                    message: s.message,
                  }),
                  n.dirty());
            else if ('trim' === s.kind) e.data = e.data.trim();
            else if ('includes' === s.kind)
              e.data.includes(s.value, s.position) ||
                (T((t = this._getOrReturnCtx(e, t)), {
                  code: f.invalid_string,
                  validation: { includes: s.value, position: s.position },
                  message: s.message,
                }),
                n.dirty());
            else if ('toLowerCase' === s.kind) e.data = e.data.toLowerCase();
            else if ('toUpperCase' === s.kind) e.data = e.data.toUpperCase();
            else if ('startsWith' === s.kind)
              e.data.startsWith(s.value) ||
                (T((t = this._getOrReturnCtx(e, t)), {
                  code: f.invalid_string,
                  validation: { startsWith: s.value },
                  message: s.message,
                }),
                n.dirty());
            else if ('endsWith' === s.kind)
              e.data.endsWith(s.value) ||
                (T((t = this._getOrReturnCtx(e, t)), {
                  code: f.invalid_string,
                  validation: { endsWith: s.value },
                  message: s.message,
                }),
                n.dirty());
            else if ('datetime' === s.kind)
              q(s).test(e.data) ||
                (T((t = this._getOrReturnCtx(e, t)), {
                  code: f.invalid_string,
                  validation: 'datetime',
                  message: s.message,
                }),
                n.dirty());
            else if ('ip' === s.kind) {
              var i, a;
              (i = e.data),
                (('v4' === (a = s.version) || !a) && F.test(i)) ||
                  (('v6' === a || !a) && j.test(i)) ||
                  (T((t = this._getOrReturnCtx(e, t)), {
                    validation: 'ip',
                    code: f.invalid_string,
                    message: s.message,
                  }),
                  n.dirty());
            } else o.assertNever(s);
          return { status: n.value, value: e.data };
        }
        _regex(e, t, n) {
          return this.refinement((t) => e.test(t), {
            validation: t,
            code: f.invalid_string,
            ...u.errToObj(n),
          });
        }
        _addCheck(e) {
          return new V({ ...this._def, checks: [...this._def.checks, e] });
        }
        email(e) {
          return this._addCheck({ kind: 'email', ...u.errToObj(e) });
        }
        url(e) {
          return this._addCheck({ kind: 'url', ...u.errToObj(e) });
        }
        emoji(e) {
          return this._addCheck({ kind: 'emoji', ...u.errToObj(e) });
        }
        uuid(e) {
          return this._addCheck({ kind: 'uuid', ...u.errToObj(e) });
        }
        cuid(e) {
          return this._addCheck({ kind: 'cuid', ...u.errToObj(e) });
        }
        cuid2(e) {
          return this._addCheck({ kind: 'cuid2', ...u.errToObj(e) });
        }
        ulid(e) {
          return this._addCheck({ kind: 'ulid', ...u.errToObj(e) });
        }
        ip(e) {
          return this._addCheck({ kind: 'ip', ...u.errToObj(e) });
        }
        datetime(e) {
          var t;
          return 'string' == typeof e
            ? this._addCheck({ kind: 'datetime', precision: null, offset: !1, message: e })
            : this._addCheck({
                kind: 'datetime',
                precision:
                  void 0 === (null == e ? void 0 : e.precision)
                    ? null
                    : null == e
                      ? void 0
                      : e.precision,
                offset: null !== (t = null == e ? void 0 : e.offset) && void 0 !== t && t,
                ...u.errToObj(null == e ? void 0 : e.message),
              });
        }
        regex(e, t) {
          return this._addCheck({ kind: 'regex', regex: e, ...u.errToObj(t) });
        }
        includes(e, t) {
          return this._addCheck({
            kind: 'includes',
            value: e,
            position: null == t ? void 0 : t.position,
            ...u.errToObj(null == t ? void 0 : t.message),
          });
        }
        startsWith(e, t) {
          return this._addCheck({ kind: 'startsWith', value: e, ...u.errToObj(t) });
        }
        endsWith(e, t) {
          return this._addCheck({ kind: 'endsWith', value: e, ...u.errToObj(t) });
        }
        min(e, t) {
          return this._addCheck({ kind: 'min', value: e, ...u.errToObj(t) });
        }
        max(e, t) {
          return this._addCheck({ kind: 'max', value: e, ...u.errToObj(t) });
        }
        length(e, t) {
          return this._addCheck({ kind: 'length', value: e, ...u.errToObj(t) });
        }
        nonempty(e) {
          return this.min(1, u.errToObj(e));
        }
        trim() {
          return new V({ ...this._def, checks: [...this._def.checks, { kind: 'trim' }] });
        }
        toLowerCase() {
          return new V({ ...this._def, checks: [...this._def.checks, { kind: 'toLowerCase' }] });
        }
        toUpperCase() {
          return new V({ ...this._def, checks: [...this._def.checks, { kind: 'toUpperCase' }] });
        }
        get isDatetime() {
          return !!this._def.checks.find((e) => 'datetime' === e.kind);
        }
        get isEmail() {
          return !!this._def.checks.find((e) => 'email' === e.kind);
        }
        get isURL() {
          return !!this._def.checks.find((e) => 'url' === e.kind);
        }
        get isEmoji() {
          return !!this._def.checks.find((e) => 'emoji' === e.kind);
        }
        get isUUID() {
          return !!this._def.checks.find((e) => 'uuid' === e.kind);
        }
        get isCUID() {
          return !!this._def.checks.find((e) => 'cuid' === e.kind);
        }
        get isCUID2() {
          return !!this._def.checks.find((e) => 'cuid2' === e.kind);
        }
        get isULID() {
          return !!this._def.checks.find((e) => 'ulid' === e.kind);
        }
        get isIP() {
          return !!this._def.checks.find((e) => 'ip' === e.kind);
        }
        get minLength() {
          let e = null;
          for (let t of this._def.checks)
            'min' === t.kind && (null === e || t.value > e) && (e = t.value);
          return e;
        }
        get maxLength() {
          let e = null;
          for (let t of this._def.checks)
            'max' === t.kind && (null === e || t.value < e) && (e = t.value);
          return e;
        }
      }
      V.create = (e) => {
        var t;
        return new V({
          checks: [],
          typeName: c.ZodString,
          coerce: null !== (t = null == e ? void 0 : e.coerce) && void 0 !== t && t,
          ...M(e),
        });
      };
      class $ extends k {
        constructor() {
          super(...arguments),
            (this.min = this.gte),
            (this.max = this.lte),
            (this.step = this.multipleOf);
        }
        _parse(e) {
          let t;
          if ((this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== h.number)) {
            let t = this._getOrReturnCtx(e);
            return T(t, { code: f.invalid_type, expected: h.number, received: t.parsedType }), E;
          }
          let n = new A();
          for (let r of this._def.checks)
            'int' === r.kind
              ? o.isInteger(e.data) ||
                (T((t = this._getOrReturnCtx(e, t)), {
                  code: f.invalid_type,
                  expected: 'integer',
                  received: 'float',
                  message: r.message,
                }),
                n.dirty())
              : 'min' === r.kind
                ? (r.inclusive ? e.data < r.value : e.data <= r.value) &&
                  (T((t = this._getOrReturnCtx(e, t)), {
                    code: f.too_small,
                    minimum: r.value,
                    type: 'number',
                    inclusive: r.inclusive,
                    exact: !1,
                    message: r.message,
                  }),
                  n.dirty())
                : 'max' === r.kind
                  ? (r.inclusive ? e.data > r.value : e.data >= r.value) &&
                    (T((t = this._getOrReturnCtx(e, t)), {
                      code: f.too_big,
                      maximum: r.value,
                      type: 'number',
                      inclusive: r.inclusive,
                      exact: !1,
                      message: r.message,
                    }),
                    n.dirty())
                  : 'multipleOf' === r.kind
                    ? 0 !==
                        (function (e, t) {
                          let n = (e.toString().split('.')[1] || '').length,
                            r = (t.toString().split('.')[1] || '').length,
                            i = n > r ? n : r;
                          return (
                            (parseInt(e.toFixed(i).replace('.', '')) %
                              parseInt(t.toFixed(i).replace('.', ''))) /
                            Math.pow(10, i)
                          );
                        })(e.data, r.value) &&
                      (T((t = this._getOrReturnCtx(e, t)), {
                        code: f.not_multiple_of,
                        multipleOf: r.value,
                        message: r.message,
                      }),
                      n.dirty())
                    : 'finite' === r.kind
                      ? Number.isFinite(e.data) ||
                        (T((t = this._getOrReturnCtx(e, t)), {
                          code: f.not_finite,
                          message: r.message,
                        }),
                        n.dirty())
                      : o.assertNever(r);
          return { status: n.value, value: e.data };
        }
        gte(e, t) {
          return this.setLimit('min', e, !0, u.toString(t));
        }
        gt(e, t) {
          return this.setLimit('min', e, !1, u.toString(t));
        }
        lte(e, t) {
          return this.setLimit('max', e, !0, u.toString(t));
        }
        lt(e, t) {
          return this.setLimit('max', e, !1, u.toString(t));
        }
        setLimit(e, t, n, r) {
          return new $({
            ...this._def,
            checks: [
              ...this._def.checks,
              { kind: e, value: t, inclusive: n, message: u.toString(r) },
            ],
          });
        }
        _addCheck(e) {
          return new $({ ...this._def, checks: [...this._def.checks, e] });
        }
        int(e) {
          return this._addCheck({ kind: 'int', message: u.toString(e) });
        }
        positive(e) {
          return this._addCheck({ kind: 'min', value: 0, inclusive: !1, message: u.toString(e) });
        }
        negative(e) {
          return this._addCheck({ kind: 'max', value: 0, inclusive: !1, message: u.toString(e) });
        }
        nonpositive(e) {
          return this._addCheck({ kind: 'max', value: 0, inclusive: !0, message: u.toString(e) });
        }
        nonnegative(e) {
          return this._addCheck({ kind: 'min', value: 0, inclusive: !0, message: u.toString(e) });
        }
        multipleOf(e, t) {
          return this._addCheck({ kind: 'multipleOf', value: e, message: u.toString(t) });
        }
        finite(e) {
          return this._addCheck({ kind: 'finite', message: u.toString(e) });
        }
        safe(e) {
          return this._addCheck({
            kind: 'min',
            inclusive: !0,
            value: Number.MIN_SAFE_INTEGER,
            message: u.toString(e),
          })._addCheck({
            kind: 'max',
            inclusive: !0,
            value: Number.MAX_SAFE_INTEGER,
            message: u.toString(e),
          });
        }
        get minValue() {
          let e = null;
          for (let t of this._def.checks)
            'min' === t.kind && (null === e || t.value > e) && (e = t.value);
          return e;
        }
        get maxValue() {
          let e = null;
          for (let t of this._def.checks)
            'max' === t.kind && (null === e || t.value < e) && (e = t.value);
          return e;
        }
        get isInt() {
          return !!this._def.checks.find(
            (e) => 'int' === e.kind || ('multipleOf' === e.kind && o.isInteger(e.value))
          );
        }
        get isFinite() {
          let e = null,
            t = null;
          for (let n of this._def.checks) {
            if ('finite' === n.kind || 'int' === n.kind || 'multipleOf' === n.kind) return !0;
            'min' === n.kind
              ? (null === t || n.value > t) && (t = n.value)
              : 'max' === n.kind && (null === e || n.value < e) && (e = n.value);
          }
          return Number.isFinite(t) && Number.isFinite(e);
        }
      }
      $.create = (e) =>
        new $({
          checks: [],
          typeName: c.ZodNumber,
          coerce: (null == e ? void 0 : e.coerce) || !1,
          ...M(e),
        });
      class z extends k {
        constructor() {
          super(...arguments), (this.min = this.gte), (this.max = this.lte);
        }
        _parse(e) {
          let t;
          if ((this._def.coerce && (e.data = BigInt(e.data)), this._getType(e) !== h.bigint)) {
            let t = this._getOrReturnCtx(e);
            return T(t, { code: f.invalid_type, expected: h.bigint, received: t.parsedType }), E;
          }
          let n = new A();
          for (let r of this._def.checks)
            'min' === r.kind
              ? (r.inclusive ? e.data < r.value : e.data <= r.value) &&
                (T((t = this._getOrReturnCtx(e, t)), {
                  code: f.too_small,
                  type: 'bigint',
                  minimum: r.value,
                  inclusive: r.inclusive,
                  message: r.message,
                }),
                n.dirty())
              : 'max' === r.kind
                ? (r.inclusive ? e.data > r.value : e.data >= r.value) &&
                  (T((t = this._getOrReturnCtx(e, t)), {
                    code: f.too_big,
                    type: 'bigint',
                    maximum: r.value,
                    inclusive: r.inclusive,
                    message: r.message,
                  }),
                  n.dirty())
                : 'multipleOf' === r.kind
                  ? e.data % r.value !== BigInt(0) &&
                    (T((t = this._getOrReturnCtx(e, t)), {
                      code: f.not_multiple_of,
                      multipleOf: r.value,
                      message: r.message,
                    }),
                    n.dirty())
                  : o.assertNever(r);
          return { status: n.value, value: e.data };
        }
        gte(e, t) {
          return this.setLimit('min', e, !0, u.toString(t));
        }
        gt(e, t) {
          return this.setLimit('min', e, !1, u.toString(t));
        }
        lte(e, t) {
          return this.setLimit('max', e, !0, u.toString(t));
        }
        lt(e, t) {
          return this.setLimit('max', e, !1, u.toString(t));
        }
        setLimit(e, t, n, r) {
          return new z({
            ...this._def,
            checks: [
              ...this._def.checks,
              { kind: e, value: t, inclusive: n, message: u.toString(r) },
            ],
          });
        }
        _addCheck(e) {
          return new z({ ...this._def, checks: [...this._def.checks, e] });
        }
        positive(e) {
          return this._addCheck({
            kind: 'min',
            value: BigInt(0),
            inclusive: !1,
            message: u.toString(e),
          });
        }
        negative(e) {
          return this._addCheck({
            kind: 'max',
            value: BigInt(0),
            inclusive: !1,
            message: u.toString(e),
          });
        }
        nonpositive(e) {
          return this._addCheck({
            kind: 'max',
            value: BigInt(0),
            inclusive: !0,
            message: u.toString(e),
          });
        }
        nonnegative(e) {
          return this._addCheck({
            kind: 'min',
            value: BigInt(0),
            inclusive: !0,
            message: u.toString(e),
          });
        }
        multipleOf(e, t) {
          return this._addCheck({ kind: 'multipleOf', value: e, message: u.toString(t) });
        }
        get minValue() {
          let e = null;
          for (let t of this._def.checks)
            'min' === t.kind && (null === e || t.value > e) && (e = t.value);
          return e;
        }
        get maxValue() {
          let e = null;
          for (let t of this._def.checks)
            'max' === t.kind && (null === e || t.value < e) && (e = t.value);
          return e;
        }
      }
      z.create = (e) => {
        var t;
        return new z({
          checks: [],
          typeName: c.ZodBigInt,
          coerce: null !== (t = null == e ? void 0 : e.coerce) && void 0 !== t && t,
          ...M(e),
        });
      };
      class W extends k {
        _parse(e) {
          if ((this._def.coerce && (e.data = !!e.data), this._getType(e) !== h.boolean)) {
            let t = this._getOrReturnCtx(e);
            return T(t, { code: f.invalid_type, expected: h.boolean, received: t.parsedType }), E;
          }
          return _(e.data);
        }
      }
      W.create = (e) =>
        new W({ typeName: c.ZodBoolean, coerce: (null == e ? void 0 : e.coerce) || !1, ...M(e) });
      class H extends k {
        _parse(e) {
          let t;
          if ((this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== h.date)) {
            let t = this._getOrReturnCtx(e);
            return T(t, { code: f.invalid_type, expected: h.date, received: t.parsedType }), E;
          }
          if (isNaN(e.data.getTime()))
            return T(this._getOrReturnCtx(e), { code: f.invalid_date }), E;
          let n = new A();
          for (let r of this._def.checks)
            'min' === r.kind
              ? e.data.getTime() < r.value &&
                (T((t = this._getOrReturnCtx(e, t)), {
                  code: f.too_small,
                  message: r.message,
                  inclusive: !0,
                  exact: !1,
                  minimum: r.value,
                  type: 'date',
                }),
                n.dirty())
              : 'max' === r.kind
                ? e.data.getTime() > r.value &&
                  (T((t = this._getOrReturnCtx(e, t)), {
                    code: f.too_big,
                    message: r.message,
                    inclusive: !0,
                    exact: !1,
                    maximum: r.value,
                    type: 'date',
                  }),
                  n.dirty())
                : o.assertNever(r);
          return { status: n.value, value: new Date(e.data.getTime()) };
        }
        _addCheck(e) {
          return new H({ ...this._def, checks: [...this._def.checks, e] });
        }
        min(e, t) {
          return this._addCheck({ kind: 'min', value: e.getTime(), message: u.toString(t) });
        }
        max(e, t) {
          return this._addCheck({ kind: 'max', value: e.getTime(), message: u.toString(t) });
        }
        get minDate() {
          let e = null;
          for (let t of this._def.checks)
            'min' === t.kind && (null === e || t.value > e) && (e = t.value);
          return null != e ? new Date(e) : null;
        }
        get maxDate() {
          let e = null;
          for (let t of this._def.checks)
            'max' === t.kind && (null === e || t.value < e) && (e = t.value);
          return null != e ? new Date(e) : null;
        }
      }
      H.create = (e) =>
        new H({
          checks: [],
          coerce: (null == e ? void 0 : e.coerce) || !1,
          typeName: c.ZodDate,
          ...M(e),
        });
      class G extends k {
        _parse(e) {
          if (this._getType(e) !== h.symbol) {
            let t = this._getOrReturnCtx(e);
            return T(t, { code: f.invalid_type, expected: h.symbol, received: t.parsedType }), E;
          }
          return _(e.data);
        }
      }
      G.create = (e) => new G({ typeName: c.ZodSymbol, ...M(e) });
      class K extends k {
        _parse(e) {
          if (this._getType(e) !== h.undefined) {
            let t = this._getOrReturnCtx(e);
            return T(t, { code: f.invalid_type, expected: h.undefined, received: t.parsedType }), E;
          }
          return _(e.data);
        }
      }
      K.create = (e) => new K({ typeName: c.ZodUndefined, ...M(e) });
      class Q extends k {
        _parse(e) {
          if (this._getType(e) !== h.null) {
            let t = this._getOrReturnCtx(e);
            return T(t, { code: f.invalid_type, expected: h.null, received: t.parsedType }), E;
          }
          return _(e.data);
        }
      }
      Q.create = (e) => new Q({ typeName: c.ZodNull, ...M(e) });
      class Y extends k {
        constructor() {
          super(...arguments), (this._any = !0);
        }
        _parse(e) {
          return _(e.data);
        }
      }
      Y.create = (e) => new Y({ typeName: c.ZodAny, ...M(e) });
      class Z extends k {
        constructor() {
          super(...arguments), (this._unknown = !0);
        }
        _parse(e) {
          return _(e.data);
        }
      }
      Z.create = (e) => new Z({ typeName: c.ZodUnknown, ...M(e) });
      class J extends k {
        _parse(e) {
          let t = this._getOrReturnCtx(e);
          return T(t, { code: f.invalid_type, expected: h.never, received: t.parsedType }), E;
        }
      }
      J.create = (e) => new J({ typeName: c.ZodNever, ...M(e) });
      class X extends k {
        _parse(e) {
          if (this._getType(e) !== h.undefined) {
            let t = this._getOrReturnCtx(e);
            return T(t, { code: f.invalid_type, expected: h.void, received: t.parsedType }), E;
          }
          return _(e.data);
        }
      }
      X.create = (e) => new X({ typeName: c.ZodVoid, ...M(e) });
      class ee extends k {
        _parse(e) {
          let { ctx: t, status: n } = this._processInputParams(e),
            r = this._def;
          if (t.parsedType !== h.array)
            return T(t, { code: f.invalid_type, expected: h.array, received: t.parsedType }), E;
          if (null !== r.exactLength) {
            let e = t.data.length > r.exactLength.value,
              i = t.data.length < r.exactLength.value;
            (e || i) &&
              (T(t, {
                code: e ? f.too_big : f.too_small,
                minimum: i ? r.exactLength.value : void 0,
                maximum: e ? r.exactLength.value : void 0,
                type: 'array',
                inclusive: !0,
                exact: !0,
                message: r.exactLength.message,
              }),
              n.dirty());
          }
          if (
            (null !== r.minLength &&
              t.data.length < r.minLength.value &&
              (T(t, {
                code: f.too_small,
                minimum: r.minLength.value,
                type: 'array',
                inclusive: !0,
                exact: !1,
                message: r.minLength.message,
              }),
              n.dirty()),
            null !== r.maxLength &&
              t.data.length > r.maxLength.value &&
              (T(t, {
                code: f.too_big,
                maximum: r.maxLength.value,
                type: 'array',
                inclusive: !0,
                exact: !1,
                message: r.maxLength.message,
              }),
              n.dirty()),
            t.common.async)
          )
            return Promise.all(
              [...t.data].map((e, n) => r.type._parseAsync(new N(t, e, t.path, n)))
            ).then((e) => A.mergeArray(n, e));
          let i = [...t.data].map((e, n) => r.type._parseSync(new N(t, e, t.path, n)));
          return A.mergeArray(n, i);
        }
        get element() {
          return this._def.type;
        }
        min(e, t) {
          return new ee({ ...this._def, minLength: { value: e, message: u.toString(t) } });
        }
        max(e, t) {
          return new ee({ ...this._def, maxLength: { value: e, message: u.toString(t) } });
        }
        length(e, t) {
          return new ee({ ...this._def, exactLength: { value: e, message: u.toString(t) } });
        }
        nonempty(e) {
          return this.min(1, e);
        }
      }
      ee.create = (e, t) =>
        new ee({
          type: e,
          minLength: null,
          maxLength: null,
          exactLength: null,
          typeName: c.ZodArray,
          ...M(t),
        });
      class et extends k {
        constructor() {
          super(...arguments),
            (this._cached = null),
            (this.nonstrict = this.passthrough),
            (this.augment = this.extend);
        }
        _getCached() {
          if (null !== this._cached) return this._cached;
          let e = this._def.shape(),
            t = o.objectKeys(e);
          return (this._cached = { shape: e, keys: t });
        }
        _parse(e) {
          if (this._getType(e) !== h.object) {
            let t = this._getOrReturnCtx(e);
            return T(t, { code: f.invalid_type, expected: h.object, received: t.parsedType }), E;
          }
          let { status: t, ctx: n } = this._processInputParams(e),
            { shape: r, keys: i } = this._getCached(),
            a = [];
          if (!(this._def.catchall instanceof J && 'strip' === this._def.unknownKeys))
            for (let e in n.data) i.includes(e) || a.push(e);
          let s = [];
          for (let e of i) {
            let t = r[e],
              i = n.data[e];
            s.push({
              key: { status: 'valid', value: e },
              value: t._parse(new N(n, i, n.path, e)),
              alwaysSet: e in n.data,
            });
          }
          if (this._def.catchall instanceof J) {
            let e = this._def.unknownKeys;
            if ('passthrough' === e)
              for (let e of a)
                s.push({
                  key: { status: 'valid', value: e },
                  value: { status: 'valid', value: n.data[e] },
                });
            else if ('strict' === e)
              a.length > 0 && (T(n, { code: f.unrecognized_keys, keys: a }), t.dirty());
            else if ('strip' === e);
            else throw Error('Internal ZodObject error: invalid unknownKeys value.');
          } else {
            let e = this._def.catchall;
            for (let t of a) {
              let r = n.data[t];
              s.push({
                key: { status: 'valid', value: t },
                value: e._parse(new N(n, r, n.path, t)),
                alwaysSet: t in n.data,
              });
            }
          }
          return n.common.async
            ? Promise.resolve()
                .then(async () => {
                  let e = [];
                  for (let t of s) {
                    let n = await t.key;
                    e.push({ key: n, value: await t.value, alwaysSet: t.alwaysSet });
                  }
                  return e;
                })
                .then((e) => A.mergeObjectSync(t, e))
            : A.mergeObjectSync(t, s);
        }
        get shape() {
          return this._def.shape();
        }
        strict(e) {
          return (
            u.errToObj,
            new et({
              ...this._def,
              unknownKeys: 'strict',
              ...(void 0 !== e
                ? {
                    errorMap: (t, n) => {
                      var r, i, a, s;
                      let o =
                        null !==
                          (a =
                            null === (i = (r = this._def).errorMap) || void 0 === i
                              ? void 0
                              : i.call(r, t, n).message) && void 0 !== a
                          ? a
                          : n.defaultError;
                      return 'unrecognized_keys' === t.code
                        ? { message: null !== (s = u.errToObj(e).message) && void 0 !== s ? s : o }
                        : { message: o };
                    },
                  }
                : {}),
            })
          );
        }
        strip() {
          return new et({ ...this._def, unknownKeys: 'strip' });
        }
        passthrough() {
          return new et({ ...this._def, unknownKeys: 'passthrough' });
        }
        extend(e) {
          return new et({ ...this._def, shape: () => ({ ...this._def.shape(), ...e }) });
        }
        merge(e) {
          return new et({
            unknownKeys: e._def.unknownKeys,
            catchall: e._def.catchall,
            shape: () => ({ ...this._def.shape(), ...e._def.shape() }),
            typeName: c.ZodObject,
          });
        }
        setKey(e, t) {
          return this.augment({ [e]: t });
        }
        catchall(e) {
          return new et({ ...this._def, catchall: e });
        }
        pick(e) {
          let t = {};
          return (
            o.objectKeys(e).forEach((n) => {
              e[n] && this.shape[n] && (t[n] = this.shape[n]);
            }),
            new et({ ...this._def, shape: () => t })
          );
        }
        omit(e) {
          let t = {};
          return (
            o.objectKeys(this.shape).forEach((n) => {
              e[n] || (t[n] = this.shape[n]);
            }),
            new et({ ...this._def, shape: () => t })
          );
        }
        deepPartial() {
          return (function e(t) {
            if (t instanceof et) {
              let n = {};
              for (let r in t.shape) {
                let i = t.shape[r];
                n[r] = eb.create(e(i));
              }
              return new et({ ...t._def, shape: () => n });
            }
            return t instanceof ee
              ? new ee({ ...t._def, type: e(t.element) })
              : t instanceof eb
                ? eb.create(e(t.unwrap()))
                : t instanceof ew
                  ? ew.create(e(t.unwrap()))
                  : t instanceof es
                    ? es.create(t.items.map((t) => e(t)))
                    : t;
          })(this);
        }
        partial(e) {
          let t = {};
          return (
            o.objectKeys(this.shape).forEach((n) => {
              let r = this.shape[n];
              e && !e[n] ? (t[n] = r) : (t[n] = r.optional());
            }),
            new et({ ...this._def, shape: () => t })
          );
        }
        required(e) {
          let t = {};
          return (
            o.objectKeys(this.shape).forEach((n) => {
              if (e && !e[n]) t[n] = this.shape[n];
              else {
                let e = this.shape[n];
                for (; e instanceof eb; ) e = e._def.innerType;
                t[n] = e;
              }
            }),
            new et({ ...this._def, shape: () => t })
          );
        }
        keyof() {
          return eh(o.objectKeys(this.shape));
        }
      }
      (et.create = (e, t) =>
        new et({
          shape: () => e,
          unknownKeys: 'strip',
          catchall: J.create(),
          typeName: c.ZodObject,
          ...M(t),
        })),
        (et.strictCreate = (e, t) =>
          new et({
            shape: () => e,
            unknownKeys: 'strict',
            catchall: J.create(),
            typeName: c.ZodObject,
            ...M(t),
          })),
        (et.lazycreate = (e, t) =>
          new et({
            shape: e,
            unknownKeys: 'strip',
            catchall: J.create(),
            typeName: c.ZodObject,
            ...M(t),
          }));
      class en extends k {
        _parse(e) {
          let { ctx: t } = this._processInputParams(e),
            n = this._def.options;
          if (t.common.async)
            return Promise.all(
              n.map(async (e) => {
                let n = { ...t, common: { ...t.common, issues: [] }, parent: null };
                return {
                  result: await e._parseAsync({ data: t.data, path: t.path, parent: n }),
                  ctx: n,
                };
              })
            ).then(function (e) {
              for (let t of e) if ('valid' === t.result.status) return t.result;
              for (let n of e)
                if ('dirty' === n.result.status)
                  return t.common.issues.push(...n.ctx.common.issues), n.result;
              let n = e.map((e) => new m(e.ctx.common.issues));
              return T(t, { code: f.invalid_union, unionErrors: n }), E;
            });
          {
            let e;
            let r = [];
            for (let i of n) {
              let n = { ...t, common: { ...t.common, issues: [] }, parent: null },
                a = i._parseSync({ data: t.data, path: t.path, parent: n });
              if ('valid' === a.status) return a;
              'dirty' !== a.status || e || (e = { result: a, ctx: n }),
                n.common.issues.length && r.push(n.common.issues);
            }
            if (e) return t.common.issues.push(...e.ctx.common.issues), e.result;
            let i = r.map((e) => new m(e));
            return T(t, { code: f.invalid_union, unionErrors: i }), E;
          }
        }
        get options() {
          return this._def.options;
        }
      }
      en.create = (e, t) => new en({ options: e, typeName: c.ZodUnion, ...M(t) });
      let er = (e) => {
        if (e instanceof ed) return er(e.schema);
        if (e instanceof eg) return er(e.innerType());
        if (e instanceof ep) return [e.value];
        if (e instanceof ey) return e.options;
        if (e instanceof ef) return Object.keys(e.enum);
        if (e instanceof ev) return er(e._def.innerType);
        if (e instanceof K) return [void 0];
        else if (e instanceof Q) return [null];
        else return null;
      };
      class ei extends k {
        _parse(e) {
          let { ctx: t } = this._processInputParams(e);
          if (t.parsedType !== h.object)
            return T(t, { code: f.invalid_type, expected: h.object, received: t.parsedType }), E;
          let n = this.discriminator,
            r = t.data[n],
            i = this.optionsMap.get(r);
          return i
            ? t.common.async
              ? i._parseAsync({ data: t.data, path: t.path, parent: t })
              : i._parseSync({ data: t.data, path: t.path, parent: t })
            : (T(t, {
                code: f.invalid_union_discriminator,
                options: Array.from(this.optionsMap.keys()),
                path: [n],
              }),
              E);
        }
        get discriminator() {
          return this._def.discriminator;
        }
        get options() {
          return this._def.options;
        }
        get optionsMap() {
          return this._def.optionsMap;
        }
        static create(e, t, n) {
          let r = new Map();
          for (let n of t) {
            let t = er(n.shape[e]);
            if (!t)
              throw Error(
                `A discriminator value for key \`${e}\` could not be extracted from all schema options`
              );
            for (let i of t) {
              if (r.has(i))
                throw Error(`Discriminator property ${String(e)} has duplicate value ${String(i)}`);
              r.set(i, n);
            }
          }
          return new ei({
            typeName: c.ZodDiscriminatedUnion,
            discriminator: e,
            options: t,
            optionsMap: r,
            ...M(n),
          });
        }
      }
      class ea extends k {
        _parse(e) {
          let { status: t, ctx: n } = this._processInputParams(e),
            r = (e, r) => {
              if (I(e) || I(r)) return E;
              let i = (function e(t, n) {
                let r = y(t),
                  i = y(n);
                if (t === n) return { valid: !0, data: t };
                if (r === h.object && i === h.object) {
                  let r = o.objectKeys(n),
                    i = o.objectKeys(t).filter((e) => -1 !== r.indexOf(e)),
                    a = { ...t, ...n };
                  for (let r of i) {
                    let i = e(t[r], n[r]);
                    if (!i.valid) return { valid: !1 };
                    a[r] = i.data;
                  }
                  return { valid: !0, data: a };
                }
                if (r === h.array && i === h.array) {
                  if (t.length !== n.length) return { valid: !1 };
                  let r = [];
                  for (let i = 0; i < t.length; i++) {
                    let a = e(t[i], n[i]);
                    if (!a.valid) return { valid: !1 };
                    r.push(a.data);
                  }
                  return { valid: !0, data: r };
                }
                return r === h.date && i === h.date && +t == +n
                  ? { valid: !0, data: t }
                  : { valid: !1 };
              })(e.value, r.value);
              return i.valid
                ? ((S(e) || S(r)) && t.dirty(), { status: t.value, value: i.data })
                : (T(n, { code: f.invalid_intersection_types }), E);
            };
          return n.common.async
            ? Promise.all([
                this._def.left._parseAsync({ data: n.data, path: n.path, parent: n }),
                this._def.right._parseAsync({ data: n.data, path: n.path, parent: n }),
              ]).then(([e, t]) => r(e, t))
            : r(
                this._def.left._parseSync({ data: n.data, path: n.path, parent: n }),
                this._def.right._parseSync({ data: n.data, path: n.path, parent: n })
              );
        }
      }
      ea.create = (e, t, n) => new ea({ left: e, right: t, typeName: c.ZodIntersection, ...M(n) });
      class es extends k {
        _parse(e) {
          let { status: t, ctx: n } = this._processInputParams(e);
          if (n.parsedType !== h.array)
            return T(n, { code: f.invalid_type, expected: h.array, received: n.parsedType }), E;
          if (n.data.length < this._def.items.length)
            return (
              T(n, {
                code: f.too_small,
                minimum: this._def.items.length,
                inclusive: !0,
                exact: !1,
                type: 'array',
              }),
              E
            );
          !this._def.rest &&
            n.data.length > this._def.items.length &&
            (T(n, {
              code: f.too_big,
              maximum: this._def.items.length,
              inclusive: !0,
              exact: !1,
              type: 'array',
            }),
            t.dirty());
          let r = [...n.data]
            .map((e, t) => {
              let r = this._def.items[t] || this._def.rest;
              return r ? r._parse(new N(n, e, n.path, t)) : null;
            })
            .filter((e) => !!e);
          return n.common.async
            ? Promise.all(r).then((e) => A.mergeArray(t, e))
            : A.mergeArray(t, r);
        }
        get items() {
          return this._def.items;
        }
        rest(e) {
          return new es({ ...this._def, rest: e });
        }
      }
      es.create = (e, t) => {
        if (!Array.isArray(e)) throw Error('You must pass an array of schemas to z.tuple([ ... ])');
        return new es({ items: e, typeName: c.ZodTuple, rest: null, ...M(t) });
      };
      class eo extends k {
        get keySchema() {
          return this._def.keyType;
        }
        get valueSchema() {
          return this._def.valueType;
        }
        _parse(e) {
          let { status: t, ctx: n } = this._processInputParams(e);
          if (n.parsedType !== h.object)
            return T(n, { code: f.invalid_type, expected: h.object, received: n.parsedType }), E;
          let r = [],
            i = this._def.keyType,
            a = this._def.valueType;
          for (let e in n.data)
            r.push({
              key: i._parse(new N(n, e, n.path, e)),
              value: a._parse(new N(n, n.data[e], n.path, e)),
            });
          return n.common.async ? A.mergeObjectAsync(t, r) : A.mergeObjectSync(t, r);
        }
        get element() {
          return this._def.valueType;
        }
        static create(e, t, n) {
          return new eo(
            t instanceof k
              ? { keyType: e, valueType: t, typeName: c.ZodRecord, ...M(n) }
              : { keyType: V.create(), valueType: e, typeName: c.ZodRecord, ...M(t) }
          );
        }
      }
      class el extends k {
        get keySchema() {
          return this._def.keyType;
        }
        get valueSchema() {
          return this._def.valueType;
        }
        _parse(e) {
          let { status: t, ctx: n } = this._processInputParams(e);
          if (n.parsedType !== h.map)
            return T(n, { code: f.invalid_type, expected: h.map, received: n.parsedType }), E;
          let r = this._def.keyType,
            i = this._def.valueType,
            a = [...n.data.entries()].map(([e, t], a) => ({
              key: r._parse(new N(n, e, n.path, [a, 'key'])),
              value: i._parse(new N(n, t, n.path, [a, 'value'])),
            }));
          if (n.common.async) {
            let e = new Map();
            return Promise.resolve().then(async () => {
              for (let n of a) {
                let r = await n.key,
                  i = await n.value;
                if ('aborted' === r.status || 'aborted' === i.status) return E;
                ('dirty' === r.status || 'dirty' === i.status) && t.dirty(),
                  e.set(r.value, i.value);
              }
              return { status: t.value, value: e };
            });
          }
          {
            let e = new Map();
            for (let n of a) {
              let r = n.key,
                i = n.value;
              if ('aborted' === r.status || 'aborted' === i.status) return E;
              ('dirty' === r.status || 'dirty' === i.status) && t.dirty(), e.set(r.value, i.value);
            }
            return { status: t.value, value: e };
          }
        }
      }
      el.create = (e, t, n) => new el({ valueType: t, keyType: e, typeName: c.ZodMap, ...M(n) });
      class eu extends k {
        _parse(e) {
          let { status: t, ctx: n } = this._processInputParams(e);
          if (n.parsedType !== h.set)
            return T(n, { code: f.invalid_type, expected: h.set, received: n.parsedType }), E;
          let r = this._def;
          null !== r.minSize &&
            n.data.size < r.minSize.value &&
            (T(n, {
              code: f.too_small,
              minimum: r.minSize.value,
              type: 'set',
              inclusive: !0,
              exact: !1,
              message: r.minSize.message,
            }),
            t.dirty()),
            null !== r.maxSize &&
              n.data.size > r.maxSize.value &&
              (T(n, {
                code: f.too_big,
                maximum: r.maxSize.value,
                type: 'set',
                inclusive: !0,
                exact: !1,
                message: r.maxSize.message,
              }),
              t.dirty());
          let i = this._def.valueType;
          function a(e) {
            let n = new Set();
            for (let r of e) {
              if ('aborted' === r.status) return E;
              'dirty' === r.status && t.dirty(), n.add(r.value);
            }
            return { status: t.value, value: n };
          }
          let s = [...n.data.values()].map((e, t) => i._parse(new N(n, e, n.path, t)));
          return n.common.async ? Promise.all(s).then((e) => a(e)) : a(s);
        }
        min(e, t) {
          return new eu({ ...this._def, minSize: { value: e, message: u.toString(t) } });
        }
        max(e, t) {
          return new eu({ ...this._def, maxSize: { value: e, message: u.toString(t) } });
        }
        size(e, t) {
          return this.min(e, t).max(e, t);
        }
        nonempty(e) {
          return this.min(1, e);
        }
      }
      eu.create = (e, t) =>
        new eu({ valueType: e, minSize: null, maxSize: null, typeName: c.ZodSet, ...M(t) });
      class ec extends k {
        constructor() {
          super(...arguments), (this.validate = this.implement);
        }
        _parse(e) {
          let { ctx: t } = this._processInputParams(e);
          if (t.parsedType !== h.function)
            return T(t, { code: f.invalid_type, expected: h.function, received: t.parsedType }), E;
          function n(e, n) {
            return v({
              data: e,
              path: t.path,
              errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, w(), g].filter((e) => !!e),
              issueData: { code: f.invalid_arguments, argumentsError: n },
            });
          }
          function r(e, n) {
            return v({
              data: e,
              path: t.path,
              errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, w(), g].filter((e) => !!e),
              issueData: { code: f.invalid_return_type, returnTypeError: n },
            });
          }
          let i = { errorMap: t.common.contextualErrorMap },
            a = t.data;
          if (this._def.returns instanceof em) {
            let e = this;
            return _(async function (...t) {
              let s = new m([]),
                o = await e._def.args.parseAsync(t, i).catch((e) => {
                  throw (s.addIssue(n(t, e)), s);
                }),
                l = await Reflect.apply(a, this, o);
              return await e._def.returns._def.type.parseAsync(l, i).catch((e) => {
                throw (s.addIssue(r(l, e)), s);
              });
            });
          }
          {
            let e = this;
            return _(function (...t) {
              let s = e._def.args.safeParse(t, i);
              if (!s.success) throw new m([n(t, s.error)]);
              let o = Reflect.apply(a, this, s.data),
                l = e._def.returns.safeParse(o, i);
              if (!l.success) throw new m([r(o, l.error)]);
              return l.data;
            });
          }
        }
        parameters() {
          return this._def.args;
        }
        returnType() {
          return this._def.returns;
        }
        args(...e) {
          return new ec({ ...this._def, args: es.create(e).rest(Z.create()) });
        }
        returns(e) {
          return new ec({ ...this._def, returns: e });
        }
        implement(e) {
          return this.parse(e);
        }
        strictImplement(e) {
          return this.parse(e);
        }
        static create(e, t, n) {
          return new ec({
            args: e || es.create([]).rest(Z.create()),
            returns: t || Z.create(),
            typeName: c.ZodFunction,
            ...M(n),
          });
        }
      }
      class ed extends k {
        get schema() {
          return this._def.getter();
        }
        _parse(e) {
          let { ctx: t } = this._processInputParams(e);
          return this._def.getter()._parse({ data: t.data, path: t.path, parent: t });
        }
      }
      ed.create = (e, t) => new ed({ getter: e, typeName: c.ZodLazy, ...M(t) });
      class ep extends k {
        _parse(e) {
          if (e.data !== this._def.value) {
            let t = this._getOrReturnCtx(e);
            return (
              T(t, { received: t.data, code: f.invalid_literal, expected: this._def.value }), E
            );
          }
          return { status: 'valid', value: e.data };
        }
        get value() {
          return this._def.value;
        }
      }
      function eh(e, t) {
        return new ey({ values: e, typeName: c.ZodEnum, ...M(t) });
      }
      ep.create = (e, t) => new ep({ value: e, typeName: c.ZodLiteral, ...M(t) });
      class ey extends k {
        _parse(e) {
          if ('string' != typeof e.data) {
            let t = this._getOrReturnCtx(e),
              n = this._def.values;
            return (
              T(t, { expected: o.joinValues(n), received: t.parsedType, code: f.invalid_type }), E
            );
          }
          if (-1 === this._def.values.indexOf(e.data)) {
            let t = this._getOrReturnCtx(e),
              n = this._def.values;
            return T(t, { received: t.data, code: f.invalid_enum_value, options: n }), E;
          }
          return _(e.data);
        }
        get options() {
          return this._def.values;
        }
        get enum() {
          let e = {};
          for (let t of this._def.values) e[t] = t;
          return e;
        }
        get Values() {
          let e = {};
          for (let t of this._def.values) e[t] = t;
          return e;
        }
        get Enum() {
          let e = {};
          for (let t of this._def.values) e[t] = t;
          return e;
        }
        extract(e) {
          return ey.create(e);
        }
        exclude(e) {
          return ey.create(this.options.filter((t) => !e.includes(t)));
        }
      }
      ey.create = eh;
      class ef extends k {
        _parse(e) {
          let t = o.getValidEnumValues(this._def.values),
            n = this._getOrReturnCtx(e);
          if (n.parsedType !== h.string && n.parsedType !== h.number) {
            let e = o.objectValues(t);
            return (
              T(n, { expected: o.joinValues(e), received: n.parsedType, code: f.invalid_type }), E
            );
          }
          if (-1 === t.indexOf(e.data)) {
            let e = o.objectValues(t);
            return T(n, { received: n.data, code: f.invalid_enum_value, options: e }), E;
          }
          return _(e.data);
        }
        get enum() {
          return this._def.values;
        }
      }
      ef.create = (e, t) => new ef({ values: e, typeName: c.ZodNativeEnum, ...M(t) });
      class em extends k {
        unwrap() {
          return this._def.type;
        }
        _parse(e) {
          let { ctx: t } = this._processInputParams(e);
          return t.parsedType !== h.promise && !1 === t.common.async
            ? (T(t, { code: f.invalid_type, expected: h.promise, received: t.parsedType }), E)
            : _(
                (t.parsedType === h.promise ? t.data : Promise.resolve(t.data)).then((e) =>
                  this._def.type.parseAsync(e, {
                    path: t.path,
                    errorMap: t.common.contextualErrorMap,
                  })
                )
              );
        }
      }
      em.create = (e, t) => new em({ type: e, typeName: c.ZodPromise, ...M(t) });
      class eg extends k {
        innerType() {
          return this._def.schema;
        }
        sourceType() {
          return this._def.schema._def.typeName === c.ZodEffects
            ? this._def.schema.sourceType()
            : this._def.schema;
        }
        _parse(e) {
          let { status: t, ctx: n } = this._processInputParams(e),
            r = this._def.effect || null,
            i = {
              addIssue: (e) => {
                T(n, e), e.fatal ? t.abort() : t.dirty();
              },
              get path() {
                return n.path;
              },
            };
          if (((i.addIssue = i.addIssue.bind(i)), 'preprocess' === r.type)) {
            let e = r.transform(n.data, i);
            return n.common.issues.length
              ? { status: 'dirty', value: n.data }
              : n.common.async
                ? Promise.resolve(e).then((e) =>
                    this._def.schema._parseAsync({ data: e, path: n.path, parent: n })
                  )
                : this._def.schema._parseSync({ data: e, path: n.path, parent: n });
          }
          if ('refinement' === r.type) {
            let e = (e) => {
              let t = r.refinement(e, i);
              if (n.common.async) return Promise.resolve(t);
              if (t instanceof Promise)
                throw Error(
                  'Async refinement encountered during synchronous parse operation. Use .parseAsync instead.'
                );
              return e;
            };
            if (!1 !== n.common.async)
              return this._def.schema
                ._parseAsync({ data: n.data, path: n.path, parent: n })
                .then((n) =>
                  'aborted' === n.status
                    ? E
                    : ('dirty' === n.status && t.dirty(),
                      e(n.value).then(() => ({ status: t.value, value: n.value })))
                );
            {
              let r = this._def.schema._parseSync({ data: n.data, path: n.path, parent: n });
              return 'aborted' === r.status
                ? E
                : ('dirty' === r.status && t.dirty(),
                  e(r.value),
                  { status: t.value, value: r.value });
            }
          }
          if ('transform' === r.type) {
            if (!1 !== n.common.async)
              return this._def.schema
                ._parseAsync({ data: n.data, path: n.path, parent: n })
                .then((e) =>
                  P(e)
                    ? Promise.resolve(r.transform(e.value, i)).then((e) => ({
                        status: t.value,
                        value: e,
                      }))
                    : e
                );
            {
              let e = this._def.schema._parseSync({ data: n.data, path: n.path, parent: n });
              if (!P(e)) return e;
              let a = r.transform(e.value, i);
              if (a instanceof Promise)
                throw Error(
                  'Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.'
                );
              return { status: t.value, value: a };
            }
          }
          o.assertNever(r);
        }
      }
      (eg.create = (e, t, n) => new eg({ schema: e, typeName: c.ZodEffects, effect: t, ...M(n) })),
        (eg.createWithPreprocess = (e, t, n) =>
          new eg({
            schema: t,
            effect: { type: 'preprocess', transform: e },
            typeName: c.ZodEffects,
            ...M(n),
          }));
      class eb extends k {
        _parse(e) {
          return this._getType(e) === h.undefined ? _(void 0) : this._def.innerType._parse(e);
        }
        unwrap() {
          return this._def.innerType;
        }
      }
      eb.create = (e, t) => new eb({ innerType: e, typeName: c.ZodOptional, ...M(t) });
      class ew extends k {
        _parse(e) {
          return this._getType(e) === h.null ? _(null) : this._def.innerType._parse(e);
        }
        unwrap() {
          return this._def.innerType;
        }
      }
      ew.create = (e, t) => new ew({ innerType: e, typeName: c.ZodNullable, ...M(t) });
      class ev extends k {
        _parse(e) {
          let { ctx: t } = this._processInputParams(e),
            n = t.data;
          return (
            t.parsedType === h.undefined && (n = this._def.defaultValue()),
            this._def.innerType._parse({ data: n, path: t.path, parent: t })
          );
        }
        removeDefault() {
          return this._def.innerType;
        }
      }
      ev.create = (e, t) =>
        new ev({
          innerType: e,
          typeName: c.ZodDefault,
          defaultValue: 'function' == typeof t.default ? t.default : () => t.default,
          ...M(t),
        });
      class eT extends k {
        _parse(e) {
          let { ctx: t } = this._processInputParams(e),
            n = { ...t, common: { ...t.common, issues: [] } },
            r = this._def.innerType._parse({ data: n.data, path: n.path, parent: { ...n } });
          return O(r)
            ? r.then((e) => ({
                status: 'valid',
                value:
                  'valid' === e.status
                    ? e.value
                    : this._def.catchValue({
                        get error() {
                          return new m(n.common.issues);
                        },
                        input: n.data,
                      }),
              }))
            : {
                status: 'valid',
                value:
                  'valid' === r.status
                    ? r.value
                    : this._def.catchValue({
                        get error() {
                          return new m(n.common.issues);
                        },
                        input: n.data,
                      }),
              };
        }
        removeCatch() {
          return this._def.innerType;
        }
      }
      eT.create = (e, t) =>
        new eT({
          innerType: e,
          typeName: c.ZodCatch,
          catchValue: 'function' == typeof t.catch ? t.catch : () => t.catch,
          ...M(t),
        });
      class eA extends k {
        _parse(e) {
          if (this._getType(e) !== h.nan) {
            let t = this._getOrReturnCtx(e);
            return T(t, { code: f.invalid_type, expected: h.nan, received: t.parsedType }), E;
          }
          return { status: 'valid', value: e.data };
        }
      }
      eA.create = (e) => new eA({ typeName: c.ZodNaN, ...M(e) });
      let eE = Symbol('zod_brand');
      class eC extends k {
        _parse(e) {
          let { ctx: t } = this._processInputParams(e),
            n = t.data;
          return this._def.type._parse({ data: n, path: t.path, parent: t });
        }
        unwrap() {
          return this._def.type;
        }
      }
      class e_ extends k {
        _parse(e) {
          let { status: t, ctx: n } = this._processInputParams(e);
          if (n.common.async)
            return (async () => {
              let e = await this._def.in._parseAsync({ data: n.data, path: n.path, parent: n });
              return 'aborted' === e.status
                ? E
                : 'dirty' === e.status
                  ? (t.dirty(), C(e.value))
                  : this._def.out._parseAsync({ data: e.value, path: n.path, parent: n });
            })();
          {
            let e = this._def.in._parseSync({ data: n.data, path: n.path, parent: n });
            return 'aborted' === e.status
              ? E
              : 'dirty' === e.status
                ? (t.dirty(), { status: 'dirty', value: e.value })
                : this._def.out._parseSync({ data: e.value, path: n.path, parent: n });
          }
        }
        static create(e, t) {
          return new e_({ in: e, out: t, typeName: c.ZodPipeline });
        }
      }
      class eI extends k {
        _parse(e) {
          let t = this._def.innerType._parse(e);
          return P(t) && (t.value = Object.freeze(t.value)), t;
        }
      }
      eI.create = (e, t) => new eI({ innerType: e, typeName: c.ZodReadonly, ...M(t) });
      let eS = (e, t = {}, n) =>
          e
            ? Y.create().superRefine((r, i) => {
                var a, s;
                if (!e(r)) {
                  let e = 'function' == typeof t ? t(r) : 'string' == typeof t ? { message: t } : t,
                    o =
                      null === (s = null !== (a = e.fatal) && void 0 !== a ? a : n) ||
                      void 0 === s ||
                      s;
                  i.addIssue({
                    code: 'custom',
                    ...('string' == typeof e ? { message: e } : e),
                    fatal: o,
                  });
                }
              })
            : Y.create(),
        eP = { object: et.lazycreate };
      ((s = c || (c = {})).ZodString = 'ZodString'),
        (s.ZodNumber = 'ZodNumber'),
        (s.ZodNaN = 'ZodNaN'),
        (s.ZodBigInt = 'ZodBigInt'),
        (s.ZodBoolean = 'ZodBoolean'),
        (s.ZodDate = 'ZodDate'),
        (s.ZodSymbol = 'ZodSymbol'),
        (s.ZodUndefined = 'ZodUndefined'),
        (s.ZodNull = 'ZodNull'),
        (s.ZodAny = 'ZodAny'),
        (s.ZodUnknown = 'ZodUnknown'),
        (s.ZodNever = 'ZodNever'),
        (s.ZodVoid = 'ZodVoid'),
        (s.ZodArray = 'ZodArray'),
        (s.ZodObject = 'ZodObject'),
        (s.ZodUnion = 'ZodUnion'),
        (s.ZodDiscriminatedUnion = 'ZodDiscriminatedUnion'),
        (s.ZodIntersection = 'ZodIntersection'),
        (s.ZodTuple = 'ZodTuple'),
        (s.ZodRecord = 'ZodRecord'),
        (s.ZodMap = 'ZodMap'),
        (s.ZodSet = 'ZodSet'),
        (s.ZodFunction = 'ZodFunction'),
        (s.ZodLazy = 'ZodLazy'),
        (s.ZodLiteral = 'ZodLiteral'),
        (s.ZodEnum = 'ZodEnum'),
        (s.ZodEffects = 'ZodEffects'),
        (s.ZodNativeEnum = 'ZodNativeEnum'),
        (s.ZodOptional = 'ZodOptional'),
        (s.ZodNullable = 'ZodNullable'),
        (s.ZodDefault = 'ZodDefault'),
        (s.ZodCatch = 'ZodCatch'),
        (s.ZodPromise = 'ZodPromise'),
        (s.ZodBranded = 'ZodBranded'),
        (s.ZodPipeline = 'ZodPipeline'),
        (s.ZodReadonly = 'ZodReadonly');
      let eO = V.create,
        eN = $.create,
        ex = eA.create,
        eM = z.create,
        ek = W.create,
        eR = H.create,
        eD = G.create,
        eB = K.create,
        eU = Q.create,
        eL = Y.create,
        eF = Z.create,
        ej = J.create,
        eq = X.create,
        eV = ee.create,
        e$ = et.create,
        ez = et.strictCreate,
        eW = en.create,
        eH = ei.create,
        eG = ea.create,
        eK = es.create,
        eQ = eo.create,
        eY = el.create,
        eZ = eu.create,
        eJ = ec.create,
        eX = ed.create,
        e0 = ep.create,
        e1 = ey.create,
        e2 = ef.create,
        e6 = em.create,
        e5 = eg.create,
        e8 = eb.create,
        e3 = ew.create,
        e4 = eg.createWithPreprocess,
        e9 = e_.create;
      var e7 = Object.freeze({
        __proto__: null,
        defaultErrorMap: g,
        setErrorMap: function (e) {
          b = e;
        },
        getErrorMap: w,
        makeIssue: v,
        EMPTY_PATH: [],
        addIssueToContext: T,
        ParseStatus: A,
        INVALID: E,
        DIRTY: C,
        OK: _,
        isAborted: I,
        isDirty: S,
        isValid: P,
        isAsync: O,
        get util() {
          return o;
        },
        get objectUtil() {
          return l;
        },
        ZodParsedType: h,
        getParsedType: y,
        ZodType: k,
        ZodString: V,
        ZodNumber: $,
        ZodBigInt: z,
        ZodBoolean: W,
        ZodDate: H,
        ZodSymbol: G,
        ZodUndefined: K,
        ZodNull: Q,
        ZodAny: Y,
        ZodUnknown: Z,
        ZodNever: J,
        ZodVoid: X,
        ZodArray: ee,
        ZodObject: et,
        ZodUnion: en,
        ZodDiscriminatedUnion: ei,
        ZodIntersection: ea,
        ZodTuple: es,
        ZodRecord: eo,
        ZodMap: el,
        ZodSet: eu,
        ZodFunction: ec,
        ZodLazy: ed,
        ZodLiteral: ep,
        ZodEnum: ey,
        ZodNativeEnum: ef,
        ZodPromise: em,
        ZodEffects: eg,
        ZodTransformer: eg,
        ZodOptional: eb,
        ZodNullable: ew,
        ZodDefault: ev,
        ZodCatch: eT,
        ZodNaN: eA,
        BRAND: eE,
        ZodBranded: eC,
        ZodPipeline: e_,
        ZodReadonly: eI,
        custom: eS,
        Schema: k,
        ZodSchema: k,
        late: eP,
        get ZodFirstPartyTypeKind() {
          return c;
        },
        coerce: {
          string: (e) => V.create({ ...e, coerce: !0 }),
          number: (e) => $.create({ ...e, coerce: !0 }),
          boolean: (e) => W.create({ ...e, coerce: !0 }),
          bigint: (e) => z.create({ ...e, coerce: !0 }),
          date: (e) => H.create({ ...e, coerce: !0 }),
        },
        any: eL,
        array: eV,
        bigint: eM,
        boolean: ek,
        date: eR,
        discriminatedUnion: eH,
        effect: e5,
        enum: e1,
        function: eJ,
        instanceof: (e, t = { message: `Input not instance of ${e.name}` }) =>
          eS((t) => t instanceof e, t),
        intersection: eG,
        lazy: eX,
        literal: e0,
        map: eY,
        nan: ex,
        nativeEnum: e2,
        never: ej,
        null: eU,
        nullable: e3,
        number: eN,
        object: e$,
        oboolean: () => ek().optional(),
        onumber: () => eN().optional(),
        optional: e8,
        ostring: () => eO().optional(),
        pipeline: e9,
        preprocess: e4,
        promise: e6,
        record: eQ,
        set: eZ,
        strictObject: ez,
        string: eO,
        symbol: eD,
        transformer: e5,
        tuple: eK,
        undefined: eB,
        union: eW,
        unknown: eF,
        void: eq,
        NEVER: E,
        ZodIssueCode: f,
        quotelessJson: (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, '$1:'),
        ZodError: m,
      });
      let te = e7.object({ message: e7.string() });
      function tt(e) {
        return e7.literal(d.$0[e]);
      }
      e7.object({
        accessList: e7.array(e7.string()),
        blockHash: e7.string().nullable(),
        blockNumber: e7.string().nullable(),
        chainId: e7.string().or(e7.number()),
        from: e7.string(),
        gas: e7.string(),
        hash: e7.string(),
        input: e7.string().nullable(),
        maxFeePerGas: e7.string(),
        maxPriorityFeePerGas: e7.string(),
        nonce: e7.string(),
        r: e7.string(),
        s: e7.string(),
        to: e7.string(),
        transactionIndex: e7.string().nullable(),
        type: e7.string(),
        v: e7.string(),
        value: e7.string(),
      });
      let tn = e7.object({ chainId: e7.string().or(e7.number()) }),
        tr = e7.object({ email: e7.string().email() }),
        ti = e7.object({ otp: e7.string() }),
        ta = e7.object({ uri: e7.string() }),
        ts = e7.object({
          chainId: e7.optional(e7.string().or(e7.number())),
          preferredAccountType: e7.optional(e7.string()),
        }),
        to = e7.object({
          provider: e7.enum(['google', 'github', 'apple', 'facebook', 'x', 'discord']),
        }),
        tl = e7.object({ email: e7.string().email() }),
        tu = e7.object({ otp: e7.string() }),
        tc = e7.object({ otp: e7.string() }),
        td = e7.object({
          themeMode: e7.optional(e7.enum(['light', 'dark'])),
          themeVariables: e7.optional(e7.record(e7.string(), e7.string().or(e7.number()))),
          w3mThemeVariables: e7.optional(e7.record(e7.string(), e7.string())),
        }),
        tp = e7.object({
          metadata: e7
            .object({
              name: e7.string(),
              description: e7.string(),
              url: e7.string(),
              icons: e7.array(e7.string()),
            })
            .optional(),
          sdkVersion: e7.string().optional(),
          sdkType: e7.string().optional(),
          projectId: e7.string(),
        }),
        th = e7.object({ type: e7.string() }),
        ty = e7.object({ action: e7.enum(['VERIFY_DEVICE', 'VERIFY_OTP', 'CONNECT']) }),
        tf = e7.object({ url: e7.string() }),
        tm = e7.object({ userName: e7.string() }),
        tg = e7.object({
          email: e7.string().optional().nullable(),
          address: e7.string(),
          chainId: e7.string().or(e7.number()),
          accounts: e7
            .array(
              e7.object({
                address: e7.string(),
                type: e7.enum([d.y_.ACCOUNT_TYPES.EOA, d.y_.ACCOUNT_TYPES.SMART_ACCOUNT]),
              })
            )
            .optional(),
          userName: e7.string().optional().nullable(),
        }),
        tb = e7.object({ action: e7.enum(['VERIFY_PRIMARY_OTP', 'VERIFY_SECONDARY_OTP']) }),
        tw = e7.object({
          email: e7.string().email().optional().nullable(),
          address: e7.string(),
          chainId: e7.string().or(e7.number()),
          smartAccountDeployed: e7.optional(e7.boolean()),
          accounts: e7
            .array(
              e7.object({
                address: e7.string(),
                type: e7.enum([d.y_.ACCOUNT_TYPES.EOA, d.y_.ACCOUNT_TYPES.SMART_ACCOUNT]),
              })
            )
            .optional(),
          preferredAccountType: e7.optional(e7.string()),
        }),
        tv = e7.object({ uri: e7.string() }),
        tT = e7.object({ isConnected: e7.boolean() }),
        tA = e7.object({ chainId: e7.string().or(e7.number()) }),
        tE = e7.object({ chainId: e7.string().or(e7.number()) }),
        tC = e7.object({ newEmail: e7.string().email() }),
        t_ = e7.object({ smartAccountEnabledNetworks: e7.array(e7.number()) });
      e7.object({ address: e7.string(), isDeployed: e7.boolean() });
      let tI = e7.object({ version: e7.string().optional() }),
        tS = e7.object({ type: e7.string(), address: e7.string() }),
        tP = e7.any(),
        tO = e7.object({ method: e7.literal('eth_accounts') }),
        tN = e7.object({ method: e7.literal('eth_blockNumber') }),
        tx = e7.object({ method: e7.literal('eth_call'), params: e7.array(e7.any()) }),
        tM = e7.object({ method: e7.literal('eth_chainId') }),
        tk = e7.object({ method: e7.literal('eth_estimateGas'), params: e7.array(e7.any()) }),
        tR = e7.object({ method: e7.literal('eth_feeHistory'), params: e7.array(e7.any()) }),
        tD = e7.object({ method: e7.literal('eth_gasPrice') }),
        tB = e7.object({ method: e7.literal('eth_getAccount'), params: e7.array(e7.any()) }),
        tU = e7.object({ method: e7.literal('eth_getBalance'), params: e7.array(e7.any()) }),
        tL = e7.object({ method: e7.literal('eth_getBlockByHash'), params: e7.array(e7.any()) }),
        tF = e7.object({ method: e7.literal('eth_getBlockByNumber'), params: e7.array(e7.any()) }),
        tj = e7.object({ method: e7.literal('eth_getBlockReceipts'), params: e7.array(e7.any()) }),
        tq = e7.object({
          method: e7.literal('eth_getBlockTransactionCountByHash'),
          params: e7.array(e7.any()),
        }),
        tV = e7.object({
          method: e7.literal('eth_getBlockTransactionCountByNumber'),
          params: e7.array(e7.any()),
        }),
        t$ = e7.object({ method: e7.literal('eth_getCode'), params: e7.array(e7.any()) }),
        tz = e7.object({ method: e7.literal('eth_getFilterChanges'), params: e7.array(e7.any()) }),
        tW = e7.object({ method: e7.literal('eth_getFilterLogs'), params: e7.array(e7.any()) }),
        tH = e7.object({ method: e7.literal('eth_getLogs'), params: e7.array(e7.any()) }),
        tG = e7.object({ method: e7.literal('eth_getProof'), params: e7.array(e7.any()) }),
        tK = e7.object({ method: e7.literal('eth_getStorageAt'), params: e7.array(e7.any()) }),
        tQ = e7.object({
          method: e7.literal('eth_getTransactionByBlockHashAndIndex'),
          params: e7.array(e7.any()),
        }),
        tY = e7.object({
          method: e7.literal('eth_getTransactionByBlockNumberAndIndex'),
          params: e7.array(e7.any()),
        }),
        tZ = e7.object({
          method: e7.literal('eth_getTransactionByHash'),
          params: e7.array(e7.any()),
        }),
        tJ = e7.object({
          method: e7.literal('eth_getTransactionCount'),
          params: e7.array(e7.any()),
        }),
        tX = e7.object({
          method: e7.literal('eth_getTransactionReceipt'),
          params: e7.array(e7.any()),
        }),
        t0 = e7.object({
          method: e7.literal('eth_getUncleCountByBlockHash'),
          params: e7.array(e7.any()),
        }),
        t1 = e7.object({
          method: e7.literal('eth_getUncleCountByBlockNumber'),
          params: e7.array(e7.any()),
        }),
        t2 = e7.object({ method: e7.literal('eth_maxPriorityFeePerGas') }),
        t6 = e7.object({ method: e7.literal('eth_newBlockFilter') }),
        t5 = e7.object({ method: e7.literal('eth_newFilter'), params: e7.array(e7.any()) }),
        t8 = e7.object({ method: e7.literal('eth_newPendingTransactionFilter') }),
        t3 = e7.object({
          method: e7.literal('eth_sendRawTransaction'),
          params: e7.array(e7.any()),
        }),
        t4 = e7.object({ method: e7.literal('eth_syncing'), params: e7.array(e7.any()) }),
        t9 = e7.object({ method: e7.literal('eth_uninstallFilter'), params: e7.array(e7.any()) }),
        t7 = e7.object({ method: e7.literal('personal_sign'), params: e7.array(e7.any()) }),
        ne = e7.object({ method: e7.literal('eth_signTypedData_v4'), params: e7.array(e7.any()) }),
        nt = e7.object({ method: e7.literal('eth_sendTransaction'), params: e7.array(e7.any()) }),
        nn = e7.object({
          method: e7.literal('solana_signMessage'),
          params: e7.object({ message: e7.string(), pubkey: e7.string() }),
        }),
        nr = e7.object({
          method: e7.literal('solana_signTransaction'),
          params: e7.object({ transaction: e7.string() }),
        }),
        ni = e7.object({
          method: e7.literal('solana_signAllTransactions'),
          params: e7.object({ transactions: e7.array(e7.string()) }),
        }),
        na = e7.object({
          method: e7.literal('solana_signAndSendTransaction'),
          params: e7.object({
            transaction: e7.string(),
            options: e7
              .object({
                skipPreflight: e7.boolean().optional(),
                preflightCommitment: e7
                  .enum([
                    'processed',
                    'confirmed',
                    'finalized',
                    'recent',
                    'single',
                    'singleGossip',
                    'root',
                    'max',
                  ])
                  .optional(),
                maxRetries: e7.number().optional(),
                minContextSlot: e7.number().optional(),
              })
              .optional(),
          }),
        }),
        ns = e7.object({
          method: e7.literal('wallet_sendCalls'),
          params: e7.array(
            e7.object({
              chainId: e7.string().or(e7.number()).optional(),
              from: e7.string().optional(),
              version: e7.string().optional(),
              capabilities: e7.any().optional(),
              calls: e7.array(
                e7.object({
                  to: e7.string().startsWith('0x'),
                  data: e7.string().startsWith('0x').optional(),
                  value: e7.string().optional(),
                })
              ),
            })
          ),
        }),
        no = e7.object({
          method: e7.literal('wallet_getCallsStatus'),
          params: e7.array(e7.string()),
        }),
        nl = e7.object({ method: e7.literal('wallet_getCapabilities') }),
        nu = e7.object({
          method: e7.literal('wallet_grantPermissions'),
          params: e7.array(e7.any()),
        }),
        nc = e7.object({ method: e7.literal('wallet_revokePermissions'), params: e7.any() }),
        nd = e7.object({ method: e7.literal('wallet_getAssets'), params: e7.any() }),
        np = e7.object({ token: e7.string() }),
        nh = e7.object({ id: e7.string().optional() }),
        ny = {
          appEvent: nh
            .extend({ type: tt('APP_SWITCH_NETWORK'), payload: tn })
            .or(nh.extend({ type: tt('APP_CONNECT_EMAIL'), payload: tr }))
            .or(nh.extend({ type: tt('APP_CONNECT_DEVICE') }))
            .or(nh.extend({ type: tt('APP_CONNECT_OTP'), payload: ti }))
            .or(nh.extend({ type: tt('APP_CONNECT_SOCIAL'), payload: ta }))
            .or(nh.extend({ type: tt('APP_GET_FARCASTER_URI') }))
            .or(nh.extend({ type: tt('APP_CONNECT_FARCASTER') }))
            .or(nh.extend({ type: tt('APP_GET_USER'), payload: e7.optional(ts) }))
            .or(nh.extend({ type: tt('APP_GET_SOCIAL_REDIRECT_URI'), payload: to }))
            .or(nh.extend({ type: tt('APP_SIGN_OUT') }))
            .or(nh.extend({ type: tt('APP_IS_CONNECTED'), payload: e7.optional(np) }))
            .or(nh.extend({ type: tt('APP_GET_CHAIN_ID') }))
            .or(nh.extend({ type: tt('APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS') }))
            .or(nh.extend({ type: tt('APP_INIT_SMART_ACCOUNT') }))
            .or(nh.extend({ type: tt('APP_SET_PREFERRED_ACCOUNT'), payload: th }))
            .or(
              nh.extend({
                type: tt('APP_RPC_REQUEST'),
                payload: t7
                  .or(nd)
                  .or(tO)
                  .or(tN)
                  .or(tx)
                  .or(tM)
                  .or(tk)
                  .or(tR)
                  .or(tD)
                  .or(tB)
                  .or(tU)
                  .or(tL)
                  .or(tF)
                  .or(tj)
                  .or(tq)
                  .or(tV)
                  .or(t$)
                  .or(tz)
                  .or(tW)
                  .or(tH)
                  .or(tG)
                  .or(tK)
                  .or(tQ)
                  .or(tY)
                  .or(tZ)
                  .or(tJ)
                  .or(tX)
                  .or(t0)
                  .or(t1)
                  .or(t2)
                  .or(t6)
                  .or(t5)
                  .or(t8)
                  .or(t3)
                  .or(t4)
                  .or(t9)
                  .or(t7)
                  .or(ne)
                  .or(nt)
                  .or(nn)
                  .or(nr)
                  .or(ni)
                  .or(na)
                  .or(no)
                  .or(ns)
                  .or(nl)
                  .or(nu)
                  .or(nc),
              })
            )
            .or(nh.extend({ type: tt('APP_UPDATE_EMAIL'), payload: tl }))
            .or(nh.extend({ type: tt('APP_UPDATE_EMAIL_PRIMARY_OTP'), payload: tu }))
            .or(nh.extend({ type: tt('APP_UPDATE_EMAIL_SECONDARY_OTP'), payload: tc }))
            .or(nh.extend({ type: tt('APP_SYNC_THEME'), payload: td }))
            .or(nh.extend({ type: tt('APP_SYNC_DAPP_DATA'), payload: tp }))
            .or(nh.extend({ type: tt('APP_RELOAD') })),
          frameEvent: nh
            .extend({ type: tt('FRAME_SWITCH_NETWORK_ERROR'), payload: te })
            .or(nh.extend({ type: tt('FRAME_SWITCH_NETWORK_SUCCESS'), payload: tE }))
            .or(nh.extend({ type: tt('FRAME_CONNECT_EMAIL_SUCCESS'), payload: ty }))
            .or(nh.extend({ type: tt('FRAME_CONNECT_EMAIL_ERROR'), payload: te }))
            .or(nh.extend({ type: tt('FRAME_GET_FARCASTER_URI_SUCCESS'), payload: tf }))
            .or(nh.extend({ type: tt('FRAME_GET_FARCASTER_URI_ERROR'), payload: te }))
            .or(nh.extend({ type: tt('FRAME_CONNECT_FARCASTER_SUCCESS'), payload: tm }))
            .or(nh.extend({ type: tt('FRAME_CONNECT_FARCASTER_ERROR'), payload: te }))
            .or(nh.extend({ type: tt('FRAME_CONNECT_OTP_ERROR'), payload: te }))
            .or(nh.extend({ type: tt('FRAME_CONNECT_OTP_SUCCESS') }))
            .or(nh.extend({ type: tt('FRAME_CONNECT_DEVICE_ERROR'), payload: te }))
            .or(nh.extend({ type: tt('FRAME_CONNECT_DEVICE_SUCCESS') }))
            .or(nh.extend({ type: tt('FRAME_CONNECT_SOCIAL_SUCCESS'), payload: tg }))
            .or(nh.extend({ type: tt('FRAME_CONNECT_SOCIAL_ERROR'), payload: te }))
            .or(nh.extend({ type: tt('FRAME_GET_USER_ERROR'), payload: te }))
            .or(nh.extend({ type: tt('FRAME_GET_USER_SUCCESS'), payload: tw }))
            .or(nh.extend({ type: tt('FRAME_GET_SOCIAL_REDIRECT_URI_ERROR'), payload: te }))
            .or(nh.extend({ type: tt('FRAME_GET_SOCIAL_REDIRECT_URI_SUCCESS'), payload: tv }))
            .or(nh.extend({ type: tt('FRAME_SIGN_OUT_ERROR'), payload: te }))
            .or(nh.extend({ type: tt('FRAME_SIGN_OUT_SUCCESS') }))
            .or(nh.extend({ type: tt('FRAME_IS_CONNECTED_ERROR'), payload: te }))
            .or(nh.extend({ type: tt('FRAME_IS_CONNECTED_SUCCESS'), payload: tT }))
            .or(nh.extend({ type: tt('FRAME_GET_CHAIN_ID_ERROR'), payload: te }))
            .or(nh.extend({ type: tt('FRAME_GET_CHAIN_ID_SUCCESS'), payload: tA }))
            .or(nh.extend({ type: tt('FRAME_RPC_REQUEST_ERROR'), payload: te }))
            .or(nh.extend({ type: tt('FRAME_RPC_REQUEST_SUCCESS'), payload: tP }))
            .or(nh.extend({ type: tt('FRAME_SESSION_UPDATE'), payload: np }))
            .or(nh.extend({ type: tt('FRAME_UPDATE_EMAIL_ERROR'), payload: te }))
            .or(nh.extend({ type: tt('FRAME_UPDATE_EMAIL_SUCCESS'), payload: tb }))
            .or(nh.extend({ type: tt('FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR'), payload: te }))
            .or(nh.extend({ type: tt('FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS') }))
            .or(nh.extend({ type: tt('FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR'), payload: te }))
            .or(nh.extend({ type: tt('FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS'), payload: tC }))
            .or(nh.extend({ type: tt('FRAME_SYNC_THEME_ERROR'), payload: te }))
            .or(nh.extend({ type: tt('FRAME_SYNC_THEME_SUCCESS') }))
            .or(nh.extend({ type: tt('FRAME_SYNC_DAPP_DATA_ERROR'), payload: te }))
            .or(nh.extend({ type: tt('FRAME_SYNC_DAPP_DATA_SUCCESS') }))
            .or(
              nh.extend({
                type: tt('FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS'),
                payload: t_,
              })
            )
            .or(
              nh.extend({ type: tt('FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR'), payload: te })
            )
            .or(nh.extend({ type: tt('FRAME_INIT_SMART_ACCOUNT_ERROR'), payload: te }))
            .or(nh.extend({ type: tt('FRAME_SET_PREFERRED_ACCOUNT_SUCCESS'), payload: tS }))
            .or(nh.extend({ type: tt('FRAME_SET_PREFERRED_ACCOUNT_ERROR'), payload: te }))
            .or(nh.extend({ type: tt('FRAME_READY'), payload: tI }))
            .or(nh.extend({ type: tt('FRAME_RELOAD_ERROR'), payload: te }))
            .or(nh.extend({ type: tt('FRAME_RELOAD_SUCCESS') })),
        };
      function nf(e, t = {}) {
        return 'string' == typeof t?.type && t?.type?.includes(e);
      }
      class nm {
        constructor({
          projectId: e,
          isAppClient: t = !1,
          chainId: n = 'eip155:1',
          enableLogger: r = !0,
        }) {
          if (
            ((this.iframe = null),
            (this.rpcUrl = 'https://rpc.walletconnect.org'),
            (this.initFrame = () => {
              let e = document.getElementById('w3m-iframe');
              this.iframe && !e && document.body.appendChild(this.iframe);
            }),
            (this.events = {
              registerFrameEventHandler: (e, t, n) => {
                function r({ data: n }) {
                  if (!nf(d.$0.FRAME_EVENT_KEY, n)) return;
                  let i = ny.frameEvent.parse(n);
                  i.id === e && (t(i), window.removeEventListener('message', r));
                }
                p.$.isClient &&
                  (window.addEventListener('message', r),
                  n.addEventListener('abort', () => {
                    window.removeEventListener('message', r);
                  }));
              },
              onFrameEvent: (e) => {
                p.$.isClient &&
                  window.addEventListener('message', ({ data: t }) => {
                    nf(d.$0.FRAME_EVENT_KEY, t) && e(ny.frameEvent.parse(t));
                  });
              },
              onAppEvent: (e) => {
                p.$.isClient &&
                  window.addEventListener('message', ({ data: t }) => {
                    nf(d.$0.APP_EVENT_KEY, t) && e(ny.appEvent.parse(t));
                  });
              },
              postAppEvent: (e) => {
                if (p.$.isClient) {
                  if (!this.iframe?.contentWindow) throw Error('W3mFrame: iframe is not set');
                  ny.appEvent.parse(e), this.iframe.contentWindow.postMessage(e, '*');
                }
              },
              postFrameEvent: (e) => {
                if (p.$.isClient) {
                  if (!parent) throw Error('W3mFrame: parent is not set');
                  ny.frameEvent.parse(e), parent.postMessage(e, '*');
                }
              },
            }),
            (this.projectId = e),
            (this.frameLoadPromise = new Promise((e, t) => {
              this.frameLoadPromiseResolver = { resolve: e, reject: t };
            })),
            t &&
              ((this.frameLoadPromise = new Promise((e, t) => {
                this.frameLoadPromiseResolver = { resolve: e, reject: t };
              })),
              p.$.isClient))
          ) {
            let t = document.createElement('iframe');
            (t.id = 'w3m-iframe'),
              (t.src = `${d.Dr}?projectId=${e}&chainId=${n}&version=${d.zN}&enableLogger=${r}`),
              (t.name = 'w3m-secure-iframe'),
              (t.style.position = 'fixed'),
              (t.style.zIndex = '999999'),
              (t.style.display = 'none'),
              (t.style.animationDelay = '0s, 50ms'),
              (t.style.borderBottomLeftRadius = 'clamp(0px, var(--wui-border-radius-l), 44px)'),
              (t.style.borderBottomRightRadius = 'clamp(0px, var(--wui-border-radius-l), 44px)'),
              (this.iframe = t),
              (this.iframe.onerror = () => {
                this.frameLoadPromiseResolver?.reject('Unable to load email login dependency');
              }),
              this.events.onFrameEvent((e) => {
                '@w3m-frame/READY' === e.type && this.frameLoadPromiseResolver?.resolve(void 0);
              });
          }
        }
        get networks() {
          return Object.assign(
            {},
            ...[
              'eip155:1',
              'eip155:5',
              'eip155:11155111',
              'eip155:10',
              'eip155:420',
              'eip155:42161',
              'eip155:421613',
              'eip155:137',
              'eip155:80001',
              'eip155:42220',
              'eip155:1313161554',
              'eip155:1313161555',
              'eip155:56',
              'eip155:97',
              'eip155:43114',
              'eip155:43113',
              'eip155:324',
              'eip155:280',
              'eip155:100',
              'eip155:8453',
              'eip155:84531',
              'eip155:84532',
              'eip155:7777777',
              'eip155:999',
              'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',
              'solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z',
              'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1',
            ].map((e) => ({
              [e]: {
                rpcUrl: `${this.rpcUrl}/v1/?chainId=${e}&projectId=${this.projectId}`,
                chainId: e,
              },
            }))
          );
        }
      }
      var ng = n(1030);
      class nb {
        constructor(e) {
          let t = (0, ng.jI)({ level: d.jd }),
            { logger: n, chunkLoggerController: r } = (0, ng.Rt)({ opts: t });
          (this.logger = (0, ng.Ep)(n, this.constructor.name)),
            (this.chunkLoggerController = r),
            'undefined' != typeof window &&
              this.chunkLoggerController?.downloadLogsBlobInBrowser &&
              (window.downloadAppKitLogsBlob || (window.downloadAppKitLogsBlob = {}),
              (window.downloadAppKitLogsBlob.sdk = () => {
                this.chunkLoggerController?.downloadLogsBlobInBrowser &&
                  this.chunkLoggerController.downloadLogsBlobInBrowser({ projectId: e });
              }));
        }
      }
      var nw = n(70437);
      class nv {
        constructor({ projectId: e, chainId: t, enableLogger: n = !0, onTimeout: r }) {
          (this.openRpcRequests = []),
            n && (this.w3mLogger = new nb(e)),
            (this.w3mFrame = new nm({
              projectId: e,
              isAppClient: !0,
              chainId: t,
              enableLogger: n,
            })),
            (this.onTimeout = r),
            this.getLoginEmailUsed() && this.w3mFrame.initFrame(),
            (this.initPromise = new Promise((e) => {
              this.w3mFrame.events.onFrameEvent(async (t) => {
                t.type === d.$0.FRAME_READY &&
                  ((this.initPromise = void 0),
                  await new Promise((e) => {
                    setTimeout(e, 500);
                  }),
                  e());
              });
            }));
        }
        async init() {
          this.w3mFrame.initFrame(), this.initPromise && (await this.initPromise);
        }
        getLoginEmailUsed() {
          return !!nw.e.get(d.$0.EMAIL_LOGIN_USED_KEY);
        }
        getEmail() {
          return nw.e.get(d.$0.EMAIL);
        }
        getUsername() {
          return nw.e.get(d.$0.SOCIAL_USERNAME);
        }
        async reload() {
          try {
            this.w3mFrame.initFrame(), await this.appEvent({ type: d.$0.APP_RELOAD });
          } catch (e) {
            throw (this.w3mLogger?.logger.error({ error: e }, 'Error reloading iframe'), e);
          }
        }
        async connectEmail(e) {
          try {
            p.$.checkIfAllowedToTriggerEmail(), this.w3mFrame.initFrame();
            let t = await this.appEvent({ type: d.$0.APP_CONNECT_EMAIL, payload: e });
            return this.setNewLastEmailLoginTime(), t;
          } catch (e) {
            throw (this.w3mLogger?.logger.error({ error: e }, 'Error connecting email'), e);
          }
        }
        async connectDevice() {
          try {
            return this.appEvent({ type: d.$0.APP_CONNECT_DEVICE });
          } catch (e) {
            throw (this.w3mLogger?.logger.error({ error: e }, 'Error connecting device'), e);
          }
        }
        async connectOtp(e) {
          try {
            return this.appEvent({ type: d.$0.APP_CONNECT_OTP, payload: e });
          } catch (e) {
            throw (this.w3mLogger?.logger.error({ error: e }, 'Error connecting otp'), e);
          }
        }
        async isConnected() {
          try {
            if (!this.getLoginEmailUsed()) return { isConnected: !1 };
            let e = await this.appEvent({ type: d.$0.APP_IS_CONNECTED });
            return e?.isConnected || this.deleteAuthLoginCache(), e;
          } catch (e) {
            throw (
              (this.deleteAuthLoginCache(),
              this.w3mLogger?.logger.error({ error: e }, 'Error checking connection'),
              e)
            );
          }
        }
        async getChainId() {
          try {
            let e = await this.appEvent({ type: d.$0.APP_GET_CHAIN_ID });
            return this.setLastUsedChainId(e.chainId), e;
          } catch (e) {
            throw (this.w3mLogger?.logger.error({ error: e }, 'Error getting chain id'), e);
          }
        }
        async getSocialRedirectUri(e) {
          try {
            return (
              this.w3mFrame.initFrame(),
              this.appEvent({ type: d.$0.APP_GET_SOCIAL_REDIRECT_URI, payload: e })
            );
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error({ error: e }, 'Error getting social redirect uri'), e)
            );
          }
        }
        async updateEmail(e) {
          try {
            let t = await this.appEvent({ type: d.$0.APP_UPDATE_EMAIL, payload: e });
            return this.setNewLastEmailLoginTime(), t;
          } catch (e) {
            throw (this.w3mLogger?.logger.error({ error: e }, 'Error updating email'), e);
          }
        }
        async updateEmailPrimaryOtp(e) {
          try {
            return this.appEvent({ type: d.$0.APP_UPDATE_EMAIL_PRIMARY_OTP, payload: e });
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error({ error: e }, 'Error updating email primary otp'), e)
            );
          }
        }
        async updateEmailSecondaryOtp(e) {
          try {
            let t = await this.appEvent({ type: d.$0.APP_UPDATE_EMAIL_SECONDARY_OTP, payload: e });
            return this.setLoginSuccess(t.newEmail), t;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error({ error: e }, 'Error updating email secondary otp'), e)
            );
          }
        }
        async syncTheme(e) {
          try {
            return this.appEvent({ type: d.$0.APP_SYNC_THEME, payload: e });
          } catch (e) {
            throw (this.w3mLogger?.logger.error({ error: e }, 'Error syncing theme'), e);
          }
        }
        async syncDappData(e) {
          try {
            return this.appEvent({ type: d.$0.APP_SYNC_DAPP_DATA, payload: e });
          } catch (e) {
            throw (this.w3mLogger?.logger.error({ error: e }, 'Error syncing dapp data'), e);
          }
        }
        async getSmartAccountEnabledNetworks() {
          try {
            let e = await this.appEvent({ type: d.$0.APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS });
            return this.persistSmartAccountEnabledNetworks(e.smartAccountEnabledNetworks), e;
          } catch (e) {
            throw (
              (this.persistSmartAccountEnabledNetworks([]),
              this.w3mLogger?.logger.error(
                { error: e },
                'Error getting smart account enabled networks'
              ),
              e)
            );
          }
        }
        async setPreferredAccount(e) {
          try {
            return this.appEvent({ type: d.$0.APP_SET_PREFERRED_ACCOUNT, payload: { type: e } });
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error({ error: e }, 'Error setting preferred account'), e)
            );
          }
        }
        async connect(e) {
          try {
            let t = e?.chainId || this.getLastUsedChainId() || 1,
              n = await this.getUser({ chainId: t, preferredAccountType: e?.preferredAccountType });
            return (
              this.setLoginSuccess(n.email), this.setLastUsedChainId(n.chainId), (this.user = n), n
            );
          } catch (e) {
            throw (this.w3mLogger?.logger.error({ error: e }, 'Error connecting'), e);
          }
        }
        async getUser(e) {
          try {
            let t = e?.chainId || this.getLastUsedChainId() || 1,
              n = await this.appEvent({ type: d.$0.APP_GET_USER, payload: { ...e, chainId: t } });
            return (this.user = n), n;
          } catch (e) {
            throw (this.w3mLogger?.logger.error({ error: e }, 'Error connecting'), e);
          }
        }
        async connectSocial(e) {
          try {
            this.w3mFrame.initFrame();
            let t = await this.appEvent({ type: d.$0.APP_CONNECT_SOCIAL, payload: { uri: e } });
            return t.userName && this.setSocialLoginSuccess(t.userName), t;
          } catch (e) {
            throw (this.w3mLogger?.logger.error({ error: e }, 'Error connecting social'), e);
          }
        }
        async getFarcasterUri() {
          try {
            return (
              this.w3mFrame.initFrame(), await this.appEvent({ type: d.$0.APP_GET_FARCASTER_URI })
            );
          } catch (e) {
            throw (this.w3mLogger?.logger.error({ error: e }, 'Error getting farcaster uri'), e);
          }
        }
        async connectFarcaster() {
          try {
            let e = await this.appEvent({ type: d.$0.APP_CONNECT_FARCASTER });
            return e.userName && this.setSocialLoginSuccess(e.userName), e;
          } catch (e) {
            throw (this.w3mLogger?.logger.error({ error: e }, 'Error connecting farcaster'), e);
          }
        }
        async switchNetwork(e) {
          try {
            let t = await this.appEvent({ type: d.$0.APP_SWITCH_NETWORK, payload: { chainId: e } });
            return this.setLastUsedChainId(t.chainId), t;
          } catch (e) {
            throw (this.w3mLogger?.logger.error({ error: e }, 'Error switching network'), e);
          }
        }
        async disconnect() {
          try {
            let e = await this.appEvent({ type: d.$0.APP_SIGN_OUT });
            return this.deleteAuthLoginCache(), e;
          } catch (e) {
            throw (this.w3mLogger?.logger.error({ error: e }, 'Error disconnecting'), e);
          }
        }
        async request(e) {
          try {
            if (d.y_.GET_CHAIN_ID === e.method) return this.getLastUsedChainId();
            this.rpcRequestHandler?.(e);
            let t = await this.appEvent({ type: d.$0.APP_RPC_REQUEST, payload: e });
            return this.rpcSuccessHandler?.(t, e), t;
          } catch (t) {
            throw (
              (this.rpcErrorHandler?.(t, e),
              this.w3mLogger?.logger.error({ error: t }, 'Error requesting'),
              t)
            );
          }
        }
        onRpcRequest(e) {
          this.rpcRequestHandler = e;
        }
        onRpcSuccess(e) {
          this.rpcSuccessHandler = e;
        }
        onRpcError(e) {
          this.rpcErrorHandler = e;
        }
        onIsConnected(e) {
          this.w3mFrame.events.onFrameEvent((t) => {
            t.type === d.$0.FRAME_IS_CONNECTED_SUCCESS && t.payload.isConnected && e();
          });
        }
        onNotConnected(e) {
          this.w3mFrame.events.onFrameEvent((t) => {
            t.type === d.$0.FRAME_IS_CONNECTED_ERROR && e(),
              t.type !== d.$0.FRAME_IS_CONNECTED_SUCCESS || t.payload.isConnected || e();
          });
        }
        onConnect(e) {
          this.w3mFrame.events.onFrameEvent((t) => {
            t.type === d.$0.FRAME_GET_USER_SUCCESS && e(t.payload);
          });
        }
        onSocialConnected(e) {
          this.w3mFrame.events.onFrameEvent((t) => {
            t.type === d.$0.FRAME_CONNECT_SOCIAL_SUCCESS && e(t.payload);
          });
        }
        async getCapabilities() {
          try {
            return (await this.request({ method: 'wallet_getCapabilities' })) || {};
          } catch {
            return {};
          }
        }
        onSetPreferredAccount(e) {
          this.w3mFrame.events.onFrameEvent((t) => {
            t.type === d.$0.FRAME_SET_PREFERRED_ACCOUNT_SUCCESS
              ? e(t.payload)
              : t.type === d.$0.FRAME_SET_PREFERRED_ACCOUNT_ERROR &&
                e({ type: d.y_.ACCOUNT_TYPES.EOA });
          });
        }
        onGetSmartAccountEnabledNetworks(e) {
          this.w3mFrame.events.onFrameEvent((t) => {
            t.type === d.$0.FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS
              ? e(t.payload.smartAccountEnabledNetworks)
              : t.type === d.$0.FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR && e([]);
          });
        }
        getAvailableChainIds() {
          return Object.keys(this.w3mFrame.networks);
        }
        rejectRpcRequests() {
          try {
            this.openRpcRequests.forEach(({ abortController: e, method: t }) => {
              d.y_.SAFE_RPC_METHODS.includes(t) || e.abort();
            }),
              (this.openRpcRequests = []);
          } catch (e) {
            this.w3mLogger?.logger.error({ error: e }, 'Error aborting RPC request');
          }
        }
        async appEvent(e) {
          let t;
          function n(e) {
            return e.replace('@w3m-app/', '');
          }
          await this.w3mFrame.frameLoadPromise;
          let r = new AbortController(),
            i = n(e.type);
          return (
            [
              d.$0.APP_CONNECT_EMAIL,
              d.$0.APP_CONNECT_DEVICE,
              d.$0.APP_CONNECT_OTP,
              d.$0.APP_CONNECT_SOCIAL,
              d.$0.APP_GET_SOCIAL_REDIRECT_URI,
            ]
              .map(n)
              .includes(i) &&
              (t = setTimeout(() => {
                this.onTimeout?.(), r.abort();
              }, 3e4)),
            new Promise((n, a) => {
              let s = Math.random().toString(36).substring(7);
              this.w3mLogger?.logger.info?.({ event: e, id: s }, 'Sending app event'),
                this.w3mFrame.events.postAppEvent({ ...e, id: s }),
                'RPC_REQUEST' === i &&
                  (this.openRpcRequests = [
                    ...this.openRpcRequests,
                    { ...e.payload, abortController: r },
                  ]),
                r.signal.addEventListener('abort', () => {
                  'RPC_REQUEST' === i
                    ? a(Error('Request was aborted'))
                    : 'GET_FARCASTER_URI' !== i && a(Error('Something went wrong'));
                }),
                this.w3mFrame.events.registerFrameEventHandler(
                  s,
                  (e) => {
                    var r;
                    return (
                      (r = this.w3mLogger),
                      void (
                        e.id === s &&
                        (r?.logger.info?.({ framEvent: e, id: s }, 'Received frame response'),
                        e.type === `@w3m-frame/${i}_SUCCESS`
                          ? (t && clearTimeout(t), 'payload' in e && n(e.payload), n(void 0))
                          : e.type === `@w3m-frame/${i}_ERROR` &&
                            (t && clearTimeout(t),
                            'payload' in e && a(Error(e.payload?.message || 'An error occurred')),
                            a(Error('An error occurred'))))
                      )
                    );
                  },
                  r.signal
                );
            })
          );
        }
        setNewLastEmailLoginTime() {
          nw.e.set(d.$0.LAST_EMAIL_LOGIN_TIME, Date.now().toString());
        }
        setSocialLoginSuccess(e) {
          nw.e.set(d.$0.SOCIAL_USERNAME, e);
        }
        setLoginSuccess(e) {
          e && nw.e.set(d.$0.EMAIL, e),
            nw.e.set(d.$0.EMAIL_LOGIN_USED_KEY, 'true'),
            nw.e.delete(d.$0.LAST_EMAIL_LOGIN_TIME);
        }
        deleteAuthLoginCache() {
          nw.e.delete(d.$0.EMAIL_LOGIN_USED_KEY),
            nw.e.delete(d.$0.EMAIL),
            nw.e.delete(d.$0.LAST_USED_CHAIN_KEY),
            nw.e.delete(d.$0.SOCIAL_USERNAME);
        }
        setLastUsedChainId(e) {
          e && nw.e.set(d.$0.LAST_USED_CHAIN_KEY, String(e));
        }
        getLastUsedChainId() {
          let e = nw.e.get(d.$0.LAST_USED_CHAIN_KEY) ?? void 0,
            t = Number(e);
          return isNaN(t) ? e : t;
        }
        persistSmartAccountEnabledNetworks(e) {
          nw.e.set(d.$0.SMART_ACCOUNT_ENABLED_NETWORKS, e.join(','));
        }
      }
      class nT {
        constructor() {}
        static getInstance({ projectId: e, chainId: t, enableLogger: n, onTimeout: r }) {
          return (
            nT.instance ||
              (nT.instance = new nv({ projectId: e, chainId: t, enableLogger: n, onTimeout: r })),
            nT.instance
          );
        }
      }
    },
    31399: function (e, t, n) {
      'use strict';
      n.d(t, {
        z: function () {
          return u;
        },
      }),
        n(26651);
      var r = n(49786),
        i = n(97059),
        a = n(8924),
        s = n(60824),
        o = n(23893),
        l = n(63289);
      class u {
        constructor({ provider: e, namespace: t }) {
          (this.id = r.b.CONNECTOR_ID.WALLET_CONNECT),
            (this.name = o.C.ConnectorNamesMap[r.b.CONNECTOR_ID.WALLET_CONNECT]),
            (this.type = 'WALLET_CONNECT'),
            (this.imageId = o.C.ConnectorImageIds[r.b.CONNECTOR_ID.WALLET_CONNECT]),
            (this.getCaipNetworks = i.R.getCaipNetworks.bind(i.R)),
            (this.caipNetworks = this.getCaipNetworks()),
            (this.provider = e),
            (this.chain = t);
        }
        get chains() {
          return this.getCaipNetworks();
        }
        async connectWalletConnect() {
          if (!(await this.authenticate())) {
            let e = this.getCaipNetworks(),
              t = a.OptionsController.state.universalProviderConfigOverride,
              n = l.sQ.createNamespaces(e, t);
            await this.provider.connect({ optionalNamespaces: n });
          }
          return {
            clientId: await this.provider.client.core.crypto.getClientId(),
            session: this.provider.session,
          };
        }
        async disconnect() {
          await this.provider.disconnect();
        }
        async authenticate() {
          let e = this.chains.map((e) => e.caipNetworkId);
          return s.w.universalProviderAuthenticate({
            universalProvider: this.provider,
            chains: e,
            methods: c,
          });
        }
      }
      let c = [
        'eth_accounts',
        'eth_requestAccounts',
        'eth_sendRawTransaction',
        'eth_sign',
        'eth_signTransaction',
        'eth_signTypedData',
        'eth_signTypedData_v3',
        'eth_signTypedData_v4',
        'eth_sendTransaction',
        'personal_sign',
        'wallet_switchEthereumChain',
        'wallet_addEthereumChain',
        'wallet_getPermissions',
        'wallet_requestPermissions',
        'wallet_registerOnboarding',
        'wallet_watchAsset',
        'wallet_scanQRCode',
        'wallet_getCallsStatus',
        'wallet_sendCalls',
        'wallet_getCapabilities',
        'wallet_grantPermissions',
        'wallet_revokePermissions',
        'wallet_getAssets',
      ];
    },
    87419: function (e, t, n) {
      'use strict';
      n.d(t, {
        T: function () {
          return r;
        },
      });
      let r = {
        ERROR_CODE_UNRECOGNIZED_CHAIN_ID: 4902,
        ERROR_CODE_DEFAULT: 5e3,
        ERROR_INVALID_CHAIN_ID: 32603,
      };
    },
    63289: function (e, t, n) {
      'use strict';
      n.d(t, {
        sQ: function () {
          return l;
        },
      }),
        n(87419);
      var r = n(28119);
      function i(e) {
        return { formatters: void 0, fees: void 0, serializers: void 0, ...e };
      }
      let a = i({
          id: '5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',
          name: 'Solana',
          network: 'solana-mainnet',
          nativeCurrency: { name: 'Solana', symbol: 'SOL', decimals: 9 },
          rpcUrls: { default: { http: ['https://rpc.walletconnect.org/v1'] } },
          blockExplorers: { default: { name: 'Solscan', url: 'https://solscan.io' } },
          testnet: !1,
          chainNamespace: 'solana',
          caipNetworkId: 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',
          deprecatedCaipNetworkId: 'solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ',
        }),
        s = i({
          id: 'EtWTRABZaYq6iMfeYKouRu166VU2xqa1',
          name: 'Solana Devnet',
          network: 'solana-devnet',
          nativeCurrency: { name: 'Solana', symbol: 'SOL', decimals: 9 },
          rpcUrls: { default: { http: ['https://rpc.walletconnect.org/v1'] } },
          blockExplorers: { default: { name: 'Solscan', url: 'https://solscan.io' } },
          testnet: !0,
          chainNamespace: 'solana',
          caipNetworkId: 'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1',
          deprecatedCaipNetworkId: 'solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K',
        });
      i({
        id: '4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z',
        name: 'Solana Testnet',
        network: 'solana-testnet',
        nativeCurrency: { name: 'Solana', symbol: 'SOL', decimals: 9 },
        rpcUrls: { default: { http: ['https://rpc.walletconnect.org/v1'] } },
        blockExplorers: { default: { name: 'Solscan', url: 'https://solscan.io' } },
        testnet: !0,
        chainNamespace: 'solana',
        caipNetworkId: 'solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z',
      }),
        i({
          id: '000000000019d6689c085ae165831e93',
          caipNetworkId: 'bip122:000000000019d6689c085ae165831e93',
          chainNamespace: 'bip122',
          name: 'Bitcoin',
          nativeCurrency: { name: 'Bitcoin', symbol: 'BTC', decimals: 8 },
          rpcUrls: { default: { http: ['https://rpc.walletconnect.org/v1'] } },
        }),
        i({
          id: '000000000933ea01ad0ee984209779ba',
          caipNetworkId: 'bip122:000000000933ea01ad0ee984209779ba',
          chainNamespace: 'bip122',
          name: 'Bitcoin Testnet',
          nativeCurrency: { name: 'Bitcoin', symbol: 'BTC', decimals: 8 },
          rpcUrls: { default: { http: ['https://rpc.walletconnect.org/v1'] } },
          testnet: !0,
        });
      let o = {
          solana: [
            'solana_signMessage',
            'solana_signTransaction',
            'solana_requestAccounts',
            'solana_getAccounts',
            'solana_signAllTransactions',
            'solana_signAndSendTransaction',
          ],
          eip155: [
            'eth_accounts',
            'eth_requestAccounts',
            'eth_sendRawTransaction',
            'eth_sign',
            'eth_signTransaction',
            'eth_signTypedData',
            'eth_signTypedData_v3',
            'eth_signTypedData_v4',
            'eth_sendTransaction',
            'personal_sign',
            'wallet_switchEthereumChain',
            'wallet_addEthereumChain',
            'wallet_getPermissions',
            'wallet_requestPermissions',
            'wallet_registerOnboarding',
            'wallet_watchAsset',
            'wallet_scanQRCode',
            'wallet_getCallsStatus',
            'wallet_showCallsStatus',
            'wallet_sendCalls',
            'wallet_getCapabilities',
            'wallet_grantPermissions',
            'wallet_revokePermissions',
            'wallet_getAssets',
          ],
          bip122: ['sendTransfer', 'signMessage', 'signPsbt', 'getAccountAddresses'],
        },
        l = {
          getMethodsByChainNamespace: (e) => o[e] || [],
          createDefaultNamespace(e) {
            return {
              methods: this.getMethodsByChainNamespace(e),
              events: ['accountsChanged', 'chainChanged'],
              chains: [],
              rpcMap: {},
            };
          },
          applyNamespaceOverrides(e, t) {
            if (!t) return { ...e };
            let n = { ...e },
              r = new Set();
            if (
              (t.methods && Object.keys(t.methods).forEach((e) => r.add(e)),
              t.chains && Object.keys(t.chains).forEach((e) => r.add(e)),
              t.events && Object.keys(t.events).forEach((e) => r.add(e)),
              t.rpcMap &&
                Object.keys(t.rpcMap).forEach((e) => {
                  let [t] = e.split(':');
                  t && r.add(t);
                }),
              r.forEach((e) => {
                n[e] || (n[e] = this.createDefaultNamespace(e));
              }),
              t.methods &&
                Object.entries(t.methods).forEach(([e, t]) => {
                  n[e] && (n[e].methods = t);
                }),
              t.chains &&
                Object.entries(t.chains).forEach(([e, t]) => {
                  n[e] && (n[e].chains = t);
                }),
              t.events &&
                Object.entries(t.events).forEach(([e, t]) => {
                  n[e] && (n[e].events = t);
                }),
              t.rpcMap)
            ) {
              let e = new Set();
              Object.entries(t.rpcMap).forEach(([t, r]) => {
                let [i, a] = t.split(':');
                i &&
                  a &&
                  n[i] &&
                  (n[i].rpcMap || (n[i].rpcMap = {}),
                  e.has(i) || ((n[i].rpcMap = {}), e.add(i)),
                  (n[i].rpcMap[a] = r));
              });
            }
            return n;
          },
          createNamespaces(e, t) {
            let n = e.reduce((e, t) => {
              let { id: n, chainNamespace: r, rpcUrls: i } = t,
                o = i.default.http[0];
              e[r] || (e[r] = this.createDefaultNamespace(r));
              let l = `${r}:${n}`,
                u = e[r];
              switch ((u.chains.push(l), l)) {
                case a.caipNetworkId:
                  u.chains.push(a.deprecatedCaipNetworkId);
                  break;
                case s.caipNetworkId:
                  u.chains.push(s.deprecatedCaipNetworkId);
              }
              return u?.rpcMap && o && (u.rpcMap[n] = o), e;
            }, {});
            return this.applyNamespaceOverrides(n, t);
          },
          resolveReownName: async (e) => {
            let t = await r.a.resolveName(e),
              n = Object.values(t?.addresses) || [];
            return n[0]?.address || !1;
          },
          getChainsFromNamespaces: (e = {}) =>
            Object.values(e).flatMap((e) =>
              Array.from(
                new Set([
                  ...(e.chains || []),
                  ...e.accounts.map((e) => {
                    let [t, n] = e.split(':');
                    return `${t}:${n}`;
                  }),
                ])
              )
            ),
          isSessionEventData: (e) =>
            'object' == typeof e &&
            null !== e &&
            'id' in e &&
            'topic' in e &&
            'params' in e &&
            'object' == typeof e.params &&
            null !== e.params &&
            'chainId' in e.params &&
            'event' in e.params &&
            'object' == typeof e.params.event &&
            null !== e.params.event,
        };
    },
    52251: function (e, t, n) {
      'use strict';
      n.d(t, {
        j: function () {
          return a;
        },
      });
      var r = n(52634),
        i = n(53063),
        a = new (class extends r.l {
          #e;
          #t;
          #n;
          constructor() {
            super(),
              (this.#n = (e) => {
                if (!i.sk && window.addEventListener) {
                  let t = () => e();
                  return (
                    window.addEventListener('visibilitychange', t, !1),
                    () => {
                      window.removeEventListener('visibilitychange', t);
                    }
                  );
                }
              });
          }
          onSubscribe() {
            this.#t || this.setEventListener(this.#n);
          }
          onUnsubscribe() {
            this.hasListeners() || (this.#t?.(), (this.#t = void 0));
          }
          setEventListener(e) {
            (this.#n = e),
              this.#t?.(),
              (this.#t = e((e) => {
                'boolean' == typeof e ? this.setFocused(e) : this.onFocus();
              }));
          }
          setFocused(e) {
            this.#e !== e && ((this.#e = e), this.onFocus());
          }
          onFocus() {
            let e = this.isFocused();
            this.listeners.forEach((t) => {
              t(e);
            });
          }
          isFocused() {
            return 'boolean' == typeof this.#e
              ? this.#e
              : globalThis.document?.visibilityState !== 'hidden';
          }
        })();
    },
    306: function (e, t, n) {
      'use strict';
      n.d(t, {
        Gm: function () {
          return i;
        },
        Qy: function () {
          return o;
        },
        ZF: function () {
          return l;
        },
      });
      var r = n(53063);
      function i(e) {
        return {
          onFetch: (t, n) => {
            let i = t.options,
              o = t.fetchOptions?.meta?.fetchMore?.direction,
              l = t.state.data?.pages || [],
              u = t.state.data?.pageParams || [],
              c = { pages: [], pageParams: [] },
              d = 0,
              p = async () => {
                let n = !1,
                  p = (e) => {
                    Object.defineProperty(e, 'signal', {
                      enumerable: !0,
                      get: () => (
                        t.signal.aborted
                          ? (n = !0)
                          : t.signal.addEventListener('abort', () => {
                              n = !0;
                            }),
                        t.signal
                      ),
                    });
                  },
                  h = (0, r.cG)(t.options, t.fetchOptions),
                  y = async (e, i, a) => {
                    if (n) return Promise.reject();
                    if (null == i && e.pages.length) return Promise.resolve(e);
                    let s = {
                      client: t.client,
                      queryKey: t.queryKey,
                      pageParam: i,
                      direction: a ? 'backward' : 'forward',
                      meta: t.options.meta,
                    };
                    p(s);
                    let o = await h(s),
                      { maxPages: l } = t.options,
                      u = a ? r.Ht : r.VX;
                    return { pages: u(e.pages, o, l), pageParams: u(e.pageParams, i, l) };
                  };
                if (o && l.length) {
                  let e = 'backward' === o,
                    t = { pages: l, pageParams: u },
                    n = (e ? s : a)(i, t);
                  c = await y(t, n, e);
                } else {
                  let t = e ?? l.length;
                  do {
                    let e = 0 === d ? (u[0] ?? i.initialPageParam) : a(i, c);
                    if (d > 0 && null == e) break;
                    (c = await y(c, e)), d++;
                  } while (d < t);
                }
                return c;
              };
            t.options.persister
              ? (t.fetchFn = () =>
                  t.options.persister?.(
                    p,
                    {
                      client: t.client,
                      queryKey: t.queryKey,
                      meta: t.options.meta,
                      signal: t.signal,
                    },
                    n
                  ))
              : (t.fetchFn = p);
          },
        };
      }
      function a(e, { pages: t, pageParams: n }) {
        let r = t.length - 1;
        return t.length > 0 ? e.getNextPageParam(t[r], t, n[r], n) : void 0;
      }
      function s(e, { pages: t, pageParams: n }) {
        return t.length > 0 ? e.getPreviousPageParam?.(t[0], t, n[0], n) : void 0;
      }
      function o(e, t) {
        return !!t && null != a(e, t);
      }
      function l(e, t) {
        return !!t && !!e.getPreviousPageParam && null != s(e, t);
      }
    },
    41997: function (e, t, n) {
      'use strict';
      n.d(t, {
        R: function () {
          return o;
        },
        m: function () {
          return s;
        },
      });
      var r = n(59542),
        i = n(64908),
        a = n(25526),
        s = class extends i.F {
          #r;
          #i;
          #a;
          constructor(e) {
            super(),
              (this.mutationId = e.mutationId),
              (this.#i = e.mutationCache),
              (this.#r = []),
              (this.state = e.state || o()),
              this.setOptions(e.options),
              this.scheduleGc();
          }
          setOptions(e) {
            (this.options = e), this.updateGcTime(this.options.gcTime);
          }
          get meta() {
            return this.options.meta;
          }
          addObserver(e) {
            this.#r.includes(e) ||
              (this.#r.push(e),
              this.clearGcTimeout(),
              this.#i.notify({ type: 'observerAdded', mutation: this, observer: e }));
          }
          removeObserver(e) {
            (this.#r = this.#r.filter((t) => t !== e)),
              this.scheduleGc(),
              this.#i.notify({ type: 'observerRemoved', mutation: this, observer: e });
          }
          optionalRemove() {
            this.#r.length ||
              ('pending' === this.state.status ? this.scheduleGc() : this.#i.remove(this));
          }
          continue() {
            return this.#a?.continue() ?? this.execute(this.state.variables);
          }
          async execute(e) {
            let t = () => {
              this.#s({ type: 'continue' });
            };
            this.#a = (0, a.Mz)({
              fn: () =>
                this.options.mutationFn
                  ? this.options.mutationFn(e)
                  : Promise.reject(Error('No mutationFn found')),
              onFail: (e, t) => {
                this.#s({ type: 'failed', failureCount: e, error: t });
              },
              onPause: () => {
                this.#s({ type: 'pause' });
              },
              onContinue: t,
              retry: this.options.retry ?? 0,
              retryDelay: this.options.retryDelay,
              networkMode: this.options.networkMode,
              canRun: () => this.#i.canRun(this),
            });
            let n = 'pending' === this.state.status,
              r = !this.#a.canStart();
            try {
              if (n) t();
              else {
                this.#s({ type: 'pending', variables: e, isPaused: r }),
                  await this.#i.config.onMutate?.(e, this);
                let t = await this.options.onMutate?.(e);
                t !== this.state.context &&
                  this.#s({ type: 'pending', context: t, variables: e, isPaused: r });
              }
              let i = await this.#a.start();
              return (
                await this.#i.config.onSuccess?.(i, e, this.state.context, this),
                await this.options.onSuccess?.(i, e, this.state.context),
                await this.#i.config.onSettled?.(
                  i,
                  null,
                  this.state.variables,
                  this.state.context,
                  this
                ),
                await this.options.onSettled?.(i, null, e, this.state.context),
                this.#s({ type: 'success', data: i }),
                i
              );
            } catch (t) {
              try {
                throw (
                  (await this.#i.config.onError?.(t, e, this.state.context, this),
                  await this.options.onError?.(t, e, this.state.context),
                  await this.#i.config.onSettled?.(
                    void 0,
                    t,
                    this.state.variables,
                    this.state.context,
                    this
                  ),
                  await this.options.onSettled?.(void 0, t, e, this.state.context),
                  t)
                );
              } finally {
                this.#s({ type: 'error', error: t });
              }
            } finally {
              this.#i.runNext(this);
            }
          }
          #s(e) {
            (this.state = ((t) => {
              switch (e.type) {
                case 'failed':
                  return { ...t, failureCount: e.failureCount, failureReason: e.error };
                case 'pause':
                  return { ...t, isPaused: !0 };
                case 'continue':
                  return { ...t, isPaused: !1 };
                case 'pending':
                  return {
                    ...t,
                    context: e.context,
                    data: void 0,
                    failureCount: 0,
                    failureReason: null,
                    error: null,
                    isPaused: e.isPaused,
                    status: 'pending',
                    variables: e.variables,
                    submittedAt: Date.now(),
                  };
                case 'success':
                  return {
                    ...t,
                    data: e.data,
                    failureCount: 0,
                    failureReason: null,
                    error: null,
                    status: 'success',
                    isPaused: !1,
                  };
                case 'error':
                  return {
                    ...t,
                    data: void 0,
                    error: e.error,
                    failureCount: t.failureCount + 1,
                    failureReason: e.error,
                    isPaused: !1,
                    status: 'error',
                  };
              }
            })(this.state)),
              r.Vr.batch(() => {
                this.#r.forEach((t) => {
                  t.onMutationUpdate(e);
                }),
                  this.#i.notify({ mutation: this, type: 'updated', action: e });
              });
          }
        };
      function o() {
        return {
          context: void 0,
          data: void 0,
          error: null,
          failureCount: 0,
          failureReason: null,
          isPaused: !1,
          status: 'idle',
          variables: void 0,
          submittedAt: 0,
        };
      }
    },
    59542: function (e, t, n) {
      'use strict';
      n.d(t, {
        Vr: function () {
          return i;
        },
      });
      var r = (e) => setTimeout(e, 0),
        i = (function () {
          let e = [],
            t = 0,
            n = (e) => {
              e();
            },
            i = (e) => {
              e();
            },
            a = r,
            s = (r) => {
              t
                ? e.push(r)
                : a(() => {
                    n(r);
                  });
            },
            o = () => {
              let t = e;
              (e = []),
                t.length &&
                  a(() => {
                    i(() => {
                      t.forEach((e) => {
                        n(e);
                      });
                    });
                  });
            };
          return {
            batch: (e) => {
              let n;
              t++;
              try {
                n = e();
              } finally {
                --t || o();
              }
              return n;
            },
            batchCalls:
              (e) =>
              (...t) => {
                s(() => {
                  e(...t);
                });
              },
            schedule: s,
            setNotifyFunction: (e) => {
              n = e;
            },
            setBatchNotifyFunction: (e) => {
              i = e;
            },
            setScheduler: (e) => {
              a = e;
            },
          };
        })();
    },
    946: function (e, t, n) {
      'use strict';
      n.d(t, {
        N: function () {
          return a;
        },
      });
      var r = n(52634),
        i = n(53063),
        a = new (class extends r.l {
          #o = !0;
          #t;
          #n;
          constructor() {
            super(),
              (this.#n = (e) => {
                if (!i.sk && window.addEventListener) {
                  let t = () => e(!0),
                    n = () => e(!1);
                  return (
                    window.addEventListener('online', t, !1),
                    window.addEventListener('offline', n, !1),
                    () => {
                      window.removeEventListener('online', t),
                        window.removeEventListener('offline', n);
                    }
                  );
                }
              });
          }
          onSubscribe() {
            this.#t || this.setEventListener(this.#n);
          }
          onUnsubscribe() {
            this.hasListeners() || (this.#t?.(), (this.#t = void 0));
          }
          setEventListener(e) {
            (this.#n = e), this.#t?.(), (this.#t = e(this.setOnline.bind(this)));
          }
          setOnline(e) {
            this.#o !== e &&
              ((this.#o = e),
              this.listeners.forEach((t) => {
                t(e);
              }));
          }
          isOnline() {
            return this.#o;
          }
        })();
    },
    26385: function (e, t, n) {
      'use strict';
      n.d(t, {
        A: function () {
          return o;
        },
        z: function () {
          return l;
        },
      });
      var r = n(53063),
        i = n(59542),
        a = n(25526),
        s = n(64908),
        o = class extends s.F {
          #l;
          #u;
          #c;
          #d;
          #a;
          #p;
          #h;
          constructor(e) {
            super(),
              (this.#h = !1),
              (this.#p = e.defaultOptions),
              this.setOptions(e.options),
              (this.observers = []),
              (this.#d = e.client),
              (this.#c = this.#d.getQueryCache()),
              (this.queryKey = e.queryKey),
              (this.queryHash = e.queryHash),
              (this.#l = (function (e) {
                let t = 'function' == typeof e.initialData ? e.initialData() : e.initialData,
                  n = void 0 !== t,
                  r = n
                    ? 'function' == typeof e.initialDataUpdatedAt
                      ? e.initialDataUpdatedAt()
                      : e.initialDataUpdatedAt
                    : 0;
                return {
                  data: t,
                  dataUpdateCount: 0,
                  dataUpdatedAt: n ? (r ?? Date.now()) : 0,
                  error: null,
                  errorUpdateCount: 0,
                  errorUpdatedAt: 0,
                  fetchFailureCount: 0,
                  fetchFailureReason: null,
                  fetchMeta: null,
                  isInvalidated: !1,
                  status: n ? 'success' : 'pending',
                  fetchStatus: 'idle',
                };
              })(this.options)),
              (this.state = e.state ?? this.#l),
              this.scheduleGc();
          }
          get meta() {
            return this.options.meta;
          }
          get promise() {
            return this.#a?.promise;
          }
          setOptions(e) {
            (this.options = { ...this.#p, ...e }), this.updateGcTime(this.options.gcTime);
          }
          optionalRemove() {
            this.observers.length || 'idle' !== this.state.fetchStatus || this.#c.remove(this);
          }
          setData(e, t) {
            let n = (0, r.oE)(this.state.data, e, this.options);
            return (
              this.#s({ data: n, type: 'success', dataUpdatedAt: t?.updatedAt, manual: t?.manual }),
              n
            );
          }
          setState(e, t) {
            this.#s({ type: 'setState', state: e, setStateOptions: t });
          }
          cancel(e) {
            let t = this.#a?.promise;
            return this.#a?.cancel(e), t ? t.then(r.ZT).catch(r.ZT) : Promise.resolve();
          }
          destroy() {
            super.destroy(), this.cancel({ silent: !0 });
          }
          reset() {
            this.destroy(), this.setState(this.#l);
          }
          isActive() {
            return this.observers.some((e) => !1 !== (0, r.Nc)(e.options.enabled, this));
          }
          isDisabled() {
            return this.getObserversCount() > 0
              ? !this.isActive()
              : this.options.queryFn === r.CN ||
                  this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
          }
          isStale() {
            return (
              !!this.state.isInvalidated ||
              (this.getObserversCount() > 0
                ? this.observers.some((e) => e.getCurrentResult().isStale)
                : void 0 === this.state.data)
            );
          }
          isStaleByTime(e = 0) {
            return (
              this.state.isInvalidated ||
              void 0 === this.state.data ||
              !(0, r.Kp)(this.state.dataUpdatedAt, e)
            );
          }
          onFocus() {
            let e = this.observers.find((e) => e.shouldFetchOnWindowFocus());
            e?.refetch({ cancelRefetch: !1 }), this.#a?.continue();
          }
          onOnline() {
            let e = this.observers.find((e) => e.shouldFetchOnReconnect());
            e?.refetch({ cancelRefetch: !1 }), this.#a?.continue();
          }
          addObserver(e) {
            this.observers.includes(e) ||
              (this.observers.push(e),
              this.clearGcTimeout(),
              this.#c.notify({ type: 'observerAdded', query: this, observer: e }));
          }
          removeObserver(e) {
            this.observers.includes(e) &&
              ((this.observers = this.observers.filter((t) => t !== e)),
              this.observers.length ||
                (this.#a && (this.#h ? this.#a.cancel({ revert: !0 }) : this.#a.cancelRetry()),
                this.scheduleGc()),
              this.#c.notify({ type: 'observerRemoved', query: this, observer: e }));
          }
          getObserversCount() {
            return this.observers.length;
          }
          invalidate() {
            this.state.isInvalidated || this.#s({ type: 'invalidate' });
          }
          fetch(e, t) {
            if ('idle' !== this.state.fetchStatus) {
              if (void 0 !== this.state.data && t?.cancelRefetch) this.cancel({ silent: !0 });
              else if (this.#a) return this.#a.continueRetry(), this.#a.promise;
            }
            if ((e && this.setOptions(e), !this.options.queryFn)) {
              let e = this.observers.find((e) => e.options.queryFn);
              e && this.setOptions(e.options);
            }
            let n = new AbortController(),
              i = (e) => {
                Object.defineProperty(e, 'signal', {
                  enumerable: !0,
                  get: () => ((this.#h = !0), n.signal),
                });
              },
              s = {
                fetchOptions: t,
                options: this.options,
                queryKey: this.queryKey,
                client: this.#d,
                state: this.state,
                fetchFn: () => {
                  let e = (0, r.cG)(this.options, t),
                    n = { client: this.#d, queryKey: this.queryKey, meta: this.meta };
                  return (i(n), (this.#h = !1), this.options.persister)
                    ? this.options.persister(e, n, this)
                    : e(n);
                },
              };
            i(s),
              this.options.behavior?.onFetch(s, this),
              (this.#u = this.state),
              ('idle' === this.state.fetchStatus ||
                this.state.fetchMeta !== s.fetchOptions?.meta) &&
                this.#s({ type: 'fetch', meta: s.fetchOptions?.meta });
            let o = (e) => {
              ((0, a.DV)(e) && e.silent) || this.#s({ type: 'error', error: e }),
                (0, a.DV)(e) ||
                  (this.#c.config.onError?.(e, this),
                  this.#c.config.onSettled?.(this.state.data, e, this)),
                this.scheduleGc();
            };
            return (
              (this.#a = (0, a.Mz)({
                initialPromise: t?.initialPromise,
                fn: s.fetchFn,
                abort: n.abort.bind(n),
                onSuccess: (e) => {
                  if (void 0 === e) {
                    o(Error(`${this.queryHash} data is undefined`));
                    return;
                  }
                  try {
                    this.setData(e);
                  } catch (e) {
                    o(e);
                    return;
                  }
                  this.#c.config.onSuccess?.(e, this),
                    this.#c.config.onSettled?.(e, this.state.error, this),
                    this.scheduleGc();
                },
                onError: o,
                onFail: (e, t) => {
                  this.#s({ type: 'failed', failureCount: e, error: t });
                },
                onPause: () => {
                  this.#s({ type: 'pause' });
                },
                onContinue: () => {
                  this.#s({ type: 'continue' });
                },
                retry: s.options.retry,
                retryDelay: s.options.retryDelay,
                networkMode: s.options.networkMode,
                canRun: () => !0,
              })),
              this.#a.start()
            );
          }
          #s(e) {
            (this.state = ((t) => {
              switch (e.type) {
                case 'failed':
                  return { ...t, fetchFailureCount: e.failureCount, fetchFailureReason: e.error };
                case 'pause':
                  return { ...t, fetchStatus: 'paused' };
                case 'continue':
                  return { ...t, fetchStatus: 'fetching' };
                case 'fetch':
                  return { ...t, ...l(t.data, this.options), fetchMeta: e.meta ?? null };
                case 'success':
                  return {
                    ...t,
                    data: e.data,
                    dataUpdateCount: t.dataUpdateCount + 1,
                    dataUpdatedAt: e.dataUpdatedAt ?? Date.now(),
                    error: null,
                    isInvalidated: !1,
                    status: 'success',
                    ...(!e.manual && {
                      fetchStatus: 'idle',
                      fetchFailureCount: 0,
                      fetchFailureReason: null,
                    }),
                  };
                case 'error':
                  let n = e.error;
                  if ((0, a.DV)(n) && n.revert && this.#u)
                    return { ...this.#u, fetchStatus: 'idle' };
                  return {
                    ...t,
                    error: n,
                    errorUpdateCount: t.errorUpdateCount + 1,
                    errorUpdatedAt: Date.now(),
                    fetchFailureCount: t.fetchFailureCount + 1,
                    fetchFailureReason: n,
                    fetchStatus: 'idle',
                    status: 'error',
                  };
                case 'invalidate':
                  return { ...t, isInvalidated: !0 };
                case 'setState':
                  return { ...t, ...e.state };
              }
            })(this.state)),
              i.Vr.batch(() => {
                this.observers.forEach((e) => {
                  e.onQueryUpdate();
                }),
                  this.#c.notify({ query: this, type: 'updated', action: e });
              });
          }
        };
      function l(e, t) {
        return {
          fetchFailureCount: 0,
          fetchFailureReason: null,
          fetchStatus: (0, a.Kw)(t.networkMode) ? 'fetching' : 'paused',
          ...(void 0 === e && { error: null, status: 'pending' }),
        };
      }
    },
    5168: function (e, t, n) {
      'use strict';
      n.d(t, {
        S: function () {
          return y;
        },
      });
      var r = n(53063),
        i = n(26385),
        a = n(59542),
        s = n(52634),
        o = class extends s.l {
          constructor(e = {}) {
            super(), (this.config = e), (this.#y = new Map());
          }
          #y;
          build(e, t, n) {
            let a = t.queryKey,
              s = t.queryHash ?? (0, r.Rm)(a, t),
              o = this.get(s);
            return (
              o ||
                ((o = new i.A({
                  client: e,
                  queryKey: a,
                  queryHash: s,
                  options: e.defaultQueryOptions(t),
                  state: n,
                  defaultOptions: e.getQueryDefaults(a),
                })),
                this.add(o)),
              o
            );
          }
          add(e) {
            this.#y.has(e.queryHash) ||
              (this.#y.set(e.queryHash, e), this.notify({ type: 'added', query: e }));
          }
          remove(e) {
            let t = this.#y.get(e.queryHash);
            t &&
              (e.destroy(),
              t === e && this.#y.delete(e.queryHash),
              this.notify({ type: 'removed', query: e }));
          }
          clear() {
            a.Vr.batch(() => {
              this.getAll().forEach((e) => {
                this.remove(e);
              });
            });
          }
          get(e) {
            return this.#y.get(e);
          }
          getAll() {
            return [...this.#y.values()];
          }
          find(e) {
            let t = { exact: !0, ...e };
            return this.getAll().find((e) => (0, r._x)(t, e));
          }
          findAll(e = {}) {
            let t = this.getAll();
            return Object.keys(e).length > 0 ? t.filter((t) => (0, r._x)(e, t)) : t;
          }
          notify(e) {
            a.Vr.batch(() => {
              this.listeners.forEach((t) => {
                t(e);
              });
            });
          }
          onFocus() {
            a.Vr.batch(() => {
              this.getAll().forEach((e) => {
                e.onFocus();
              });
            });
          }
          onOnline() {
            a.Vr.batch(() => {
              this.getAll().forEach((e) => {
                e.onOnline();
              });
            });
          }
        },
        l = n(41997),
        u = class extends s.l {
          constructor(e = {}) {
            super(), (this.config = e), (this.#f = new Set()), (this.#m = new Map()), (this.#g = 0);
          }
          #f;
          #m;
          #g;
          build(e, t, n) {
            let r = new l.m({
              mutationCache: this,
              mutationId: ++this.#g,
              options: e.defaultMutationOptions(t),
              state: n,
            });
            return this.add(r), r;
          }
          add(e) {
            this.#f.add(e);
            let t = c(e);
            if ('string' == typeof t) {
              let n = this.#m.get(t);
              n ? n.push(e) : this.#m.set(t, [e]);
            }
            this.notify({ type: 'added', mutation: e });
          }
          remove(e) {
            if (this.#f.delete(e)) {
              let t = c(e);
              if ('string' == typeof t) {
                let n = this.#m.get(t);
                if (n) {
                  if (n.length > 1) {
                    let t = n.indexOf(e);
                    -1 !== t && n.splice(t, 1);
                  } else n[0] === e && this.#m.delete(t);
                }
              }
            }
            this.notify({ type: 'removed', mutation: e });
          }
          canRun(e) {
            let t = c(e);
            if ('string' != typeof t) return !0;
            {
              let n = this.#m.get(t),
                r = n?.find((e) => 'pending' === e.state.status);
              return !r || r === e;
            }
          }
          runNext(e) {
            let t = c(e);
            if ('string' != typeof t) return Promise.resolve();
            {
              let n = this.#m.get(t)?.find((t) => t !== e && t.state.isPaused);
              return n?.continue() ?? Promise.resolve();
            }
          }
          clear() {
            a.Vr.batch(() => {
              this.#f.forEach((e) => {
                this.notify({ type: 'removed', mutation: e });
              }),
                this.#f.clear(),
                this.#m.clear();
            });
          }
          getAll() {
            return Array.from(this.#f);
          }
          find(e) {
            let t = { exact: !0, ...e };
            return this.getAll().find((e) => (0, r.X7)(t, e));
          }
          findAll(e = {}) {
            return this.getAll().filter((t) => (0, r.X7)(e, t));
          }
          notify(e) {
            a.Vr.batch(() => {
              this.listeners.forEach((t) => {
                t(e);
              });
            });
          }
          resumePausedMutations() {
            let e = this.getAll().filter((e) => e.state.isPaused);
            return a.Vr.batch(() => Promise.all(e.map((e) => e.continue().catch(r.ZT))));
          }
        };
      function c(e) {
        return e.options.scope?.id;
      }
      var d = n(52251),
        p = n(946),
        h = n(306),
        y = class {
          #b;
          #i;
          #p;
          #w;
          #v;
          #T;
          #A;
          #E;
          constructor(e = {}) {
            (this.#b = e.queryCache || new o()),
              (this.#i = e.mutationCache || new u()),
              (this.#p = e.defaultOptions || {}),
              (this.#w = new Map()),
              (this.#v = new Map()),
              (this.#T = 0);
          }
          mount() {
            this.#T++,
              1 === this.#T &&
                ((this.#A = d.j.subscribe(async (e) => {
                  e && (await this.resumePausedMutations(), this.#b.onFocus());
                })),
                (this.#E = p.N.subscribe(async (e) => {
                  e && (await this.resumePausedMutations(), this.#b.onOnline());
                })));
          }
          unmount() {
            this.#T--,
              0 === this.#T && (this.#A?.(), (this.#A = void 0), this.#E?.(), (this.#E = void 0));
          }
          isFetching(e) {
            return this.#b.findAll({ ...e, fetchStatus: 'fetching' }).length;
          }
          isMutating(e) {
            return this.#i.findAll({ ...e, status: 'pending' }).length;
          }
          getQueryData(e) {
            let t = this.defaultQueryOptions({ queryKey: e });
            return this.#b.get(t.queryHash)?.state.data;
          }
          ensureQueryData(e) {
            let t = this.defaultQueryOptions(e),
              n = this.#b.build(this, t),
              i = n.state.data;
            return void 0 === i
              ? this.fetchQuery(e)
              : (e.revalidateIfStale &&
                  n.isStaleByTime((0, r.KC)(t.staleTime, n)) &&
                  this.prefetchQuery(t),
                Promise.resolve(i));
          }
          getQueriesData(e) {
            return this.#b.findAll(e).map(({ queryKey: e, state: t }) => [e, t.data]);
          }
          setQueryData(e, t, n) {
            let i = this.defaultQueryOptions({ queryKey: e }),
              a = this.#b.get(i.queryHash),
              s = a?.state.data,
              o = (0, r.SE)(t, s);
            if (void 0 !== o) return this.#b.build(this, i).setData(o, { ...n, manual: !0 });
          }
          setQueriesData(e, t, n) {
            return a.Vr.batch(() =>
              this.#b.findAll(e).map(({ queryKey: e }) => [e, this.setQueryData(e, t, n)])
            );
          }
          getQueryState(e) {
            let t = this.defaultQueryOptions({ queryKey: e });
            return this.#b.get(t.queryHash)?.state;
          }
          removeQueries(e) {
            let t = this.#b;
            a.Vr.batch(() => {
              t.findAll(e).forEach((e) => {
                t.remove(e);
              });
            });
          }
          resetQueries(e, t) {
            let n = this.#b;
            return a.Vr.batch(
              () => (
                n.findAll(e).forEach((e) => {
                  e.reset();
                }),
                this.refetchQueries({ type: 'active', ...e }, t)
              )
            );
          }
          cancelQueries(e, t = {}) {
            let n = { revert: !0, ...t };
            return Promise.all(a.Vr.batch(() => this.#b.findAll(e).map((e) => e.cancel(n))))
              .then(r.ZT)
              .catch(r.ZT);
          }
          invalidateQueries(e, t = {}) {
            return a.Vr.batch(() =>
              (this.#b.findAll(e).forEach((e) => {
                e.invalidate();
              }),
              e?.refetchType === 'none')
                ? Promise.resolve()
                : this.refetchQueries({ ...e, type: e?.refetchType ?? e?.type ?? 'active' }, t)
            );
          }
          refetchQueries(e, t = {}) {
            let n = { ...t, cancelRefetch: t.cancelRefetch ?? !0 };
            return Promise.all(
              a.Vr.batch(() =>
                this.#b
                  .findAll(e)
                  .filter((e) => !e.isDisabled())
                  .map((e) => {
                    let t = e.fetch(void 0, n);
                    return (
                      n.throwOnError || (t = t.catch(r.ZT)),
                      'paused' === e.state.fetchStatus ? Promise.resolve() : t
                    );
                  })
              )
            ).then(r.ZT);
          }
          fetchQuery(e) {
            let t = this.defaultQueryOptions(e);
            void 0 === t.retry && (t.retry = !1);
            let n = this.#b.build(this, t);
            return n.isStaleByTime((0, r.KC)(t.staleTime, n))
              ? n.fetch(t)
              : Promise.resolve(n.state.data);
          }
          prefetchQuery(e) {
            return this.fetchQuery(e).then(r.ZT).catch(r.ZT);
          }
          fetchInfiniteQuery(e) {
            return (e.behavior = (0, h.Gm)(e.pages)), this.fetchQuery(e);
          }
          prefetchInfiniteQuery(e) {
            return this.fetchInfiniteQuery(e).then(r.ZT).catch(r.ZT);
          }
          ensureInfiniteQueryData(e) {
            return (e.behavior = (0, h.Gm)(e.pages)), this.ensureQueryData(e);
          }
          resumePausedMutations() {
            return p.N.isOnline() ? this.#i.resumePausedMutations() : Promise.resolve();
          }
          getQueryCache() {
            return this.#b;
          }
          getMutationCache() {
            return this.#i;
          }
          getDefaultOptions() {
            return this.#p;
          }
          setDefaultOptions(e) {
            this.#p = e;
          }
          setQueryDefaults(e, t) {
            this.#w.set((0, r.Ym)(e), { queryKey: e, defaultOptions: t });
          }
          getQueryDefaults(e) {
            let t = [...this.#w.values()],
              n = {};
            return (
              t.forEach((t) => {
                (0, r.to)(e, t.queryKey) && Object.assign(n, t.defaultOptions);
              }),
              n
            );
          }
          setMutationDefaults(e, t) {
            this.#v.set((0, r.Ym)(e), { mutationKey: e, defaultOptions: t });
          }
          getMutationDefaults(e) {
            let t = [...this.#v.values()],
              n = {};
            return (
              t.forEach((t) => {
                (0, r.to)(e, t.mutationKey) && Object.assign(n, t.defaultOptions);
              }),
              n
            );
          }
          defaultQueryOptions(e) {
            if (e._defaulted) return e;
            let t = {
              ...this.#p.queries,
              ...this.getQueryDefaults(e.queryKey),
              ...e,
              _defaulted: !0,
            };
            return (
              t.queryHash || (t.queryHash = (0, r.Rm)(t.queryKey, t)),
              void 0 === t.refetchOnReconnect &&
                (t.refetchOnReconnect = 'always' !== t.networkMode),
              void 0 === t.throwOnError && (t.throwOnError = !!t.suspense),
              !t.networkMode && t.persister && (t.networkMode = 'offlineFirst'),
              t.queryFn === r.CN && (t.enabled = !1),
              t
            );
          }
          defaultMutationOptions(e) {
            return e?._defaulted
              ? e
              : {
                  ...this.#p.mutations,
                  ...(e?.mutationKey && this.getMutationDefaults(e.mutationKey)),
                  ...e,
                  _defaulted: !0,
                };
          }
          clear() {
            this.#b.clear(), this.#i.clear();
          }
        };
    },
    41426: function (e, t, n) {
      'use strict';
      n.d(t, {
        z: function () {
          return u;
        },
      });
      var r = n(52251),
        i = n(59542),
        a = n(26385),
        s = n(52634),
        o = n(84342),
        l = n(53063),
        u = class extends s.l {
          constructor(e, t) {
            super(),
              (this.options = t),
              (this.#d = e),
              (this.#C = null),
              (this.#_ = (0, o.O)()),
              this.options.experimental_prefetchInRender ||
                this.#_.reject(Error('experimental_prefetchInRender feature flag is not enabled')),
              this.bindMethods(),
              this.setOptions(t);
          }
          #d;
          #I = void 0;
          #S = void 0;
          #P = void 0;
          #O;
          #N;
          #_;
          #C;
          #x;
          #M;
          #k;
          #R;
          #D;
          #B;
          #U = new Set();
          bindMethods() {
            this.refetch = this.refetch.bind(this);
          }
          onSubscribe() {
            1 === this.listeners.size &&
              (this.#I.addObserver(this),
              c(this.#I, this.options) ? this.#L() : this.updateResult(),
              this.#F());
          }
          onUnsubscribe() {
            this.hasListeners() || this.destroy();
          }
          shouldFetchOnReconnect() {
            return d(this.#I, this.options, this.options.refetchOnReconnect);
          }
          shouldFetchOnWindowFocus() {
            return d(this.#I, this.options, this.options.refetchOnWindowFocus);
          }
          destroy() {
            (this.listeners = new Set()), this.#j(), this.#q(), this.#I.removeObserver(this);
          }
          setOptions(e) {
            let t = this.options,
              n = this.#I;
            if (
              ((this.options = this.#d.defaultQueryOptions(e)),
              void 0 !== this.options.enabled &&
                'boolean' != typeof this.options.enabled &&
                'function' != typeof this.options.enabled &&
                'boolean' != typeof (0, l.Nc)(this.options.enabled, this.#I))
            )
              throw Error('Expected enabled to be a boolean or a callback that returns a boolean');
            this.#V(),
              this.#I.setOptions(this.options),
              t._defaulted &&
                !(0, l.VS)(this.options, t) &&
                this.#d
                  .getQueryCache()
                  .notify({ type: 'observerOptionsUpdated', query: this.#I, observer: this });
            let r = this.hasListeners();
            r && p(this.#I, n, this.options, t) && this.#L(),
              this.updateResult(),
              r &&
                (this.#I !== n ||
                  (0, l.Nc)(this.options.enabled, this.#I) !== (0, l.Nc)(t.enabled, this.#I) ||
                  (0, l.KC)(this.options.staleTime, this.#I) !== (0, l.KC)(t.staleTime, this.#I)) &&
                this.#$();
            let i = this.#z();
            r &&
              (this.#I !== n ||
                (0, l.Nc)(this.options.enabled, this.#I) !== (0, l.Nc)(t.enabled, this.#I) ||
                i !== this.#B) &&
              this.#W(i);
          }
          getOptimisticResult(e) {
            let t = this.#d.getQueryCache().build(this.#d, e),
              n = this.createResult(t, e);
            return (
              (0, l.VS)(this.getCurrentResult(), n) ||
                ((this.#P = n), (this.#N = this.options), (this.#O = this.#I.state)),
              n
            );
          }
          getCurrentResult() {
            return this.#P;
          }
          trackResult(e, t) {
            return new Proxy(e, { get: (e, n) => (this.trackProp(n), t?.(n), Reflect.get(e, n)) });
          }
          trackProp(e) {
            this.#U.add(e);
          }
          getCurrentQuery() {
            return this.#I;
          }
          refetch({ ...e } = {}) {
            return this.fetch({ ...e });
          }
          fetchOptimistic(e) {
            let t = this.#d.defaultQueryOptions(e),
              n = this.#d.getQueryCache().build(this.#d, t);
            return n.fetch().then(() => this.createResult(n, t));
          }
          fetch(e) {
            return this.#L({ ...e, cancelRefetch: e.cancelRefetch ?? !0 }).then(
              () => (this.updateResult(), this.#P)
            );
          }
          #L(e) {
            this.#V();
            let t = this.#I.fetch(this.options, e);
            return e?.throwOnError || (t = t.catch(l.ZT)), t;
          }
          #$() {
            this.#j();
            let e = (0, l.KC)(this.options.staleTime, this.#I);
            if (l.sk || this.#P.isStale || !(0, l.PN)(e)) return;
            let t = (0, l.Kp)(this.#P.dataUpdatedAt, e);
            this.#R = setTimeout(() => {
              this.#P.isStale || this.updateResult();
            }, t + 1);
          }
          #z() {
            return (
              ('function' == typeof this.options.refetchInterval
                ? this.options.refetchInterval(this.#I)
                : this.options.refetchInterval) ?? !1
            );
          }
          #W(e) {
            this.#q(),
              (this.#B = e),
              !l.sk &&
                !1 !== (0, l.Nc)(this.options.enabled, this.#I) &&
                (0, l.PN)(this.#B) &&
                0 !== this.#B &&
                (this.#D = setInterval(() => {
                  (this.options.refetchIntervalInBackground || r.j.isFocused()) && this.#L();
                }, this.#B));
          }
          #F() {
            this.#$(), this.#W(this.#z());
          }
          #j() {
            this.#R && (clearTimeout(this.#R), (this.#R = void 0));
          }
          #q() {
            this.#D && (clearInterval(this.#D), (this.#D = void 0));
          }
          createResult(e, t) {
            let n;
            let r = this.#I,
              i = this.options,
              s = this.#P,
              u = this.#O,
              d = this.#N,
              y = e !== r ? e.state : this.#S,
              { state: f } = e,
              m = { ...f },
              g = !1;
            if (t._optimisticResults) {
              let n = this.hasListeners(),
                s = !n && c(e, t),
                o = n && p(e, r, t, i);
              (s || o) && (m = { ...m, ...(0, a.z)(f.data, e.options) }),
                'isRestoring' === t._optimisticResults && (m.fetchStatus = 'idle');
            }
            let { error: b, errorUpdatedAt: w, status: v } = m;
            n = m.data;
            let T = !1;
            if (void 0 !== t.placeholderData && void 0 === n && 'pending' === v) {
              let e;
              s?.isPlaceholderData && t.placeholderData === d?.placeholderData
                ? ((e = s.data), (T = !0))
                : (e =
                    'function' == typeof t.placeholderData
                      ? t.placeholderData(this.#k?.state.data, this.#k)
                      : t.placeholderData),
                void 0 !== e && ((v = 'success'), (n = (0, l.oE)(s?.data, e, t)), (g = !0));
            }
            if (t.select && void 0 !== n && !T) {
              if (s && n === u?.data && t.select === this.#x) n = this.#M;
              else
                try {
                  (this.#x = t.select),
                    (n = t.select(n)),
                    (n = (0, l.oE)(s?.data, n, t)),
                    (this.#M = n),
                    (this.#C = null);
                } catch (e) {
                  this.#C = e;
                }
            }
            this.#C && ((b = this.#C), (n = this.#M), (w = Date.now()), (v = 'error'));
            let A = 'fetching' === m.fetchStatus,
              E = 'pending' === v,
              C = 'error' === v,
              _ = E && A,
              I = void 0 !== n,
              S = {
                status: v,
                fetchStatus: m.fetchStatus,
                isPending: E,
                isSuccess: 'success' === v,
                isError: C,
                isInitialLoading: _,
                isLoading: _,
                data: n,
                dataUpdatedAt: m.dataUpdatedAt,
                error: b,
                errorUpdatedAt: w,
                failureCount: m.fetchFailureCount,
                failureReason: m.fetchFailureReason,
                errorUpdateCount: m.errorUpdateCount,
                isFetched: m.dataUpdateCount > 0 || m.errorUpdateCount > 0,
                isFetchedAfterMount:
                  m.dataUpdateCount > y.dataUpdateCount || m.errorUpdateCount > y.errorUpdateCount,
                isFetching: A,
                isRefetching: A && !E,
                isLoadingError: C && !I,
                isPaused: 'paused' === m.fetchStatus,
                isPlaceholderData: g,
                isRefetchError: C && I,
                isStale: h(e, t),
                refetch: this.refetch,
                promise: this.#_,
              };
            if (this.options.experimental_prefetchInRender) {
              let t = (e) => {
                  'error' === S.status ? e.reject(S.error) : void 0 !== S.data && e.resolve(S.data);
                },
                n = () => {
                  t((this.#_ = S.promise = (0, o.O)()));
                },
                i = this.#_;
              switch (i.status) {
                case 'pending':
                  e.queryHash === r.queryHash && t(i);
                  break;
                case 'fulfilled':
                  ('error' === S.status || S.data !== i.value) && n();
                  break;
                case 'rejected':
                  ('error' !== S.status || S.error !== i.reason) && n();
              }
            }
            return S;
          }
          updateResult() {
            let e = this.#P,
              t = this.createResult(this.#I, this.options);
            (this.#O = this.#I.state),
              (this.#N = this.options),
              void 0 !== this.#O.data && (this.#k = this.#I),
              (0, l.VS)(t, e) ||
                ((this.#P = t),
                this.#H({
                  listeners: (() => {
                    if (!e) return !0;
                    let { notifyOnChangeProps: t } = this.options,
                      n = 'function' == typeof t ? t() : t;
                    if ('all' === n || (!n && !this.#U.size)) return !0;
                    let r = new Set(n ?? this.#U);
                    return (
                      this.options.throwOnError && r.add('error'),
                      Object.keys(this.#P).some((t) => this.#P[t] !== e[t] && r.has(t))
                    );
                  })(),
                }));
          }
          #V() {
            let e = this.#d.getQueryCache().build(this.#d, this.options);
            if (e === this.#I) return;
            let t = this.#I;
            (this.#I = e),
              (this.#S = e.state),
              this.hasListeners() && (t?.removeObserver(this), e.addObserver(this));
          }
          onQueryUpdate() {
            this.updateResult(), this.hasListeners() && this.#F();
          }
          #H(e) {
            i.Vr.batch(() => {
              e.listeners &&
                this.listeners.forEach((e) => {
                  e(this.#P);
                }),
                this.#d.getQueryCache().notify({ query: this.#I, type: 'observerResultsUpdated' });
            });
          }
        };
      function c(e, t) {
        return (
          (!1 !== (0, l.Nc)(t.enabled, e) &&
            void 0 === e.state.data &&
            !('error' === e.state.status && !1 === t.retryOnMount)) ||
          (void 0 !== e.state.data && d(e, t, t.refetchOnMount))
        );
      }
      function d(e, t, n) {
        if (!1 !== (0, l.Nc)(t.enabled, e)) {
          let r = 'function' == typeof n ? n(e) : n;
          return 'always' === r || (!1 !== r && h(e, t));
        }
        return !1;
      }
      function p(e, t, n, r) {
        return (
          (e !== t || !1 === (0, l.Nc)(r.enabled, e)) &&
          (!n.suspense || 'error' !== e.state.status) &&
          h(e, n)
        );
      }
      function h(e, t) {
        return !1 !== (0, l.Nc)(t.enabled, e) && e.isStaleByTime((0, l.KC)(t.staleTime, e));
      }
    },
    64908: function (e, t, n) {
      'use strict';
      n.d(t, {
        F: function () {
          return i;
        },
      });
      var r = n(53063),
        i = class {
          #G;
          destroy() {
            this.clearGcTimeout();
          }
          scheduleGc() {
            this.clearGcTimeout(),
              (0, r.PN)(this.gcTime) &&
                (this.#G = setTimeout(() => {
                  this.optionalRemove();
                }, this.gcTime));
          }
          updateGcTime(e) {
            this.gcTime = Math.max(this.gcTime || 0, e ?? (r.sk ? 1 / 0 : 3e5));
          }
          clearGcTimeout() {
            this.#G && (clearTimeout(this.#G), (this.#G = void 0));
          }
        };
    },
    25526: function (e, t, n) {
      'use strict';
      n.d(t, {
        DV: function () {
          return c;
        },
        Kw: function () {
          return l;
        },
        Mz: function () {
          return d;
        },
      });
      var r = n(52251),
        i = n(946),
        a = n(84342),
        s = n(53063);
      function o(e) {
        return Math.min(1e3 * 2 ** e, 3e4);
      }
      function l(e) {
        return (e ?? 'online') !== 'online' || i.N.isOnline();
      }
      var u = class extends Error {
        constructor(e) {
          super('CancelledError'), (this.revert = e?.revert), (this.silent = e?.silent);
        }
      };
      function c(e) {
        return e instanceof u;
      }
      function d(e) {
        let t,
          n = !1,
          c = 0,
          d = !1,
          p = (0, a.O)(),
          h = () => r.j.isFocused() && ('always' === e.networkMode || i.N.isOnline()) && e.canRun(),
          y = () => l(e.networkMode) && e.canRun(),
          f = (n) => {
            d || ((d = !0), e.onSuccess?.(n), t?.(), p.resolve(n));
          },
          m = (n) => {
            d || ((d = !0), e.onError?.(n), t?.(), p.reject(n));
          },
          g = () =>
            new Promise((n) => {
              (t = (e) => {
                (d || h()) && n(e);
              }),
                e.onPause?.();
            }).then(() => {
              (t = void 0), d || e.onContinue?.();
            }),
          b = () => {
            let t;
            if (d) return;
            let r = 0 === c ? e.initialPromise : void 0;
            try {
              t = r ?? e.fn();
            } catch (e) {
              t = Promise.reject(e);
            }
            Promise.resolve(t)
              .then(f)
              .catch((t) => {
                if (d) return;
                let r = e.retry ?? (s.sk ? 0 : 3),
                  i = e.retryDelay ?? o,
                  a = 'function' == typeof i ? i(c, t) : i,
                  l =
                    !0 === r ||
                    ('number' == typeof r && c < r) ||
                    ('function' == typeof r && r(c, t));
                if (n || !l) {
                  m(t);
                  return;
                }
                c++,
                  e.onFail?.(c, t),
                  (0, s._v)(a)
                    .then(() => (h() ? void 0 : g()))
                    .then(() => {
                      n ? m(t) : b();
                    });
              });
          };
        return {
          promise: p,
          cancel: (t) => {
            d || (m(new u(t)), e.abort?.());
          },
          continue: () => (t?.(), p),
          cancelRetry: () => {
            n = !0;
          },
          continueRetry: () => {
            n = !1;
          },
          canStart: y,
          start: () => (y() ? b() : g().then(b), p),
        };
      }
    },
    52634: function (e, t, n) {
      'use strict';
      n.d(t, {
        l: function () {
          return r;
        },
      });
      var r = class {
        constructor() {
          (this.listeners = new Set()), (this.subscribe = this.subscribe.bind(this));
        }
        subscribe(e) {
          return (
            this.listeners.add(e),
            this.onSubscribe(),
            () => {
              this.listeners.delete(e), this.onUnsubscribe();
            }
          );
        }
        hasListeners() {
          return this.listeners.size > 0;
        }
        onSubscribe() {}
        onUnsubscribe() {}
      };
    },
    84342: function (e, t, n) {
      'use strict';
      function r() {
        let e, t;
        let n = new Promise((n, r) => {
          (e = n), (t = r);
        });
        function r(e) {
          Object.assign(n, e), delete n.resolve, delete n.reject;
        }
        return (
          (n.status = 'pending'),
          n.catch(() => {}),
          (n.resolve = (t) => {
            r({ status: 'fulfilled', value: t }), e(t);
          }),
          (n.reject = (e) => {
            r({ status: 'rejected', reason: e }), t(e);
          }),
          n
        );
      }
      n.d(t, {
        O: function () {
          return r;
        },
      });
    },
    53063: function (e, t, n) {
      'use strict';
      n.d(t, {
        CN: function () {
          return C;
        },
        Ht: function () {
          return E;
        },
        KC: function () {
          return l;
        },
        Kp: function () {
          return o;
        },
        Nc: function () {
          return u;
        },
        PN: function () {
          return s;
        },
        Q$: function () {
          return f;
        },
        Rm: function () {
          return p;
        },
        SE: function () {
          return a;
        },
        VS: function () {
          return m;
        },
        VX: function () {
          return A;
        },
        X7: function () {
          return d;
        },
        Ym: function () {
          return h;
        },
        ZT: function () {
          return i;
        },
        _v: function () {
          return v;
        },
        _x: function () {
          return c;
        },
        cG: function () {
          return _;
        },
        oE: function () {
          return T;
        },
        sk: function () {
          return r;
        },
        to: function () {
          return y;
        },
      });
      var r = 'undefined' == typeof window || 'Deno' in globalThis;
      function i() {}
      function a(e, t) {
        return 'function' == typeof e ? e(t) : e;
      }
      function s(e) {
        return 'number' == typeof e && e >= 0 && e !== 1 / 0;
      }
      function o(e, t) {
        return Math.max(e + (t || 0) - Date.now(), 0);
      }
      function l(e, t) {
        return 'function' == typeof e ? e(t) : e;
      }
      function u(e, t) {
        return 'function' == typeof e ? e(t) : e;
      }
      function c(e, t) {
        let { type: n = 'all', exact: r, fetchStatus: i, predicate: a, queryKey: s, stale: o } = e;
        if (s) {
          if (r) {
            if (t.queryHash !== p(s, t.options)) return !1;
          } else if (!y(t.queryKey, s)) return !1;
        }
        if ('all' !== n) {
          let e = t.isActive();
          if (('active' === n && !e) || ('inactive' === n && e)) return !1;
        }
        return (
          ('boolean' != typeof o || t.isStale() === o) &&
          (!i || i === t.state.fetchStatus) &&
          (!a || !!a(t))
        );
      }
      function d(e, t) {
        let { exact: n, status: r, predicate: i, mutationKey: a } = e;
        if (a) {
          if (!t.options.mutationKey) return !1;
          if (n) {
            if (h(t.options.mutationKey) !== h(a)) return !1;
          } else if (!y(t.options.mutationKey, a)) return !1;
        }
        return (!r || t.state.status === r) && (!i || !!i(t));
      }
      function p(e, t) {
        return (t?.queryKeyHashFn || h)(e);
      }
      function h(e) {
        return JSON.stringify(e, (e, t) =>
          b(t)
            ? Object.keys(t)
                .sort()
                .reduce((e, n) => ((e[n] = t[n]), e), {})
            : t
        );
      }
      function y(e, t) {
        return (
          e === t ||
          (typeof e == typeof t &&
            !!e &&
            !!t &&
            'object' == typeof e &&
            'object' == typeof t &&
            Object.keys(t).every((n) => y(e[n], t[n])))
        );
      }
      function f(e, t) {
        if (e === t) return e;
        let n = g(e) && g(t);
        if (n || (b(e) && b(t))) {
          let r = n ? e : Object.keys(e),
            i = r.length,
            a = n ? t : Object.keys(t),
            s = a.length,
            o = n ? [] : {},
            l = 0;
          for (let i = 0; i < s; i++) {
            let s = n ? i : a[i];
            ((!n && r.includes(s)) || n) && void 0 === e[s] && void 0 === t[s]
              ? ((o[s] = void 0), l++)
              : ((o[s] = f(e[s], t[s])), o[s] === e[s] && void 0 !== e[s] && l++);
          }
          return i === s && l === i ? e : o;
        }
        return t;
      }
      function m(e, t) {
        if (!t || Object.keys(e).length !== Object.keys(t).length) return !1;
        for (let n in e) if (e[n] !== t[n]) return !1;
        return !0;
      }
      function g(e) {
        return Array.isArray(e) && e.length === Object.keys(e).length;
      }
      function b(e) {
        if (!w(e)) return !1;
        let t = e.constructor;
        if (void 0 === t) return !0;
        let n = t.prototype;
        return (
          !!(w(n) && n.hasOwnProperty('isPrototypeOf')) &&
          Object.getPrototypeOf(e) === Object.prototype
        );
      }
      function w(e) {
        return '[object Object]' === Object.prototype.toString.call(e);
      }
      function v(e) {
        return new Promise((t) => {
          setTimeout(t, e);
        });
      }
      function T(e, t, n) {
        return 'function' == typeof n.structuralSharing
          ? n.structuralSharing(e, t)
          : !1 !== n.structuralSharing
            ? f(e, t)
            : t;
      }
      function A(e, t, n = 0) {
        let r = [...e, t];
        return n && r.length > n ? r.slice(1) : r;
      }
      function E(e, t, n = 0) {
        let r = [t, ...e];
        return n && r.length > n ? r.slice(0, -1) : r;
      }
      var C = Symbol();
      function _(e, t) {
        return !e.queryFn && t?.initialPromise
          ? () => t.initialPromise
          : e.queryFn && e.queryFn !== C
            ? e.queryFn
            : () => Promise.reject(Error(`Missing queryFn: '${e.queryHash}'`));
      }
    },
    25513: function (e, t, n) {
      'use strict';
      n.d(t, {
        NL: function () {
          return s;
        },
        aH: function () {
          return o;
        },
      });
      var r = n(58258),
        i = n(50256),
        a = r.createContext(void 0),
        s = (e) => {
          let t = r.useContext(a);
          if (e) return e;
          if (!t) throw Error('No QueryClient set, use QueryClientProvider to set one');
          return t;
        },
        o = (e) => {
          let { client: t, children: n } = e;
          return (
            r.useEffect(
              () => (
                t.mount(),
                () => {
                  t.unmount();
                }
              ),
              [t]
            ),
            (0, i.jsx)(a.Provider, { value: t, children: n })
          );
        };
    },
    13035: function (e, t, n) {
      'use strict';
      let r;
      n.d(t, {
        _: function () {
          return s;
        },
      });
      var i = n(58258);
      n(50256);
      var a = i.createContext(
          ((r = !1),
          {
            clearReset: () => {
              r = !1;
            },
            reset: () => {
              r = !0;
            },
            isReset: () => r,
          })
        ),
        s = () => i.useContext(a);
    },
    31946: function (e, t, n) {
      'use strict';
      n.d(t, {
        JN: function () {
          return s;
        },
        KJ: function () {
          return o;
        },
        pf: function () {
          return a;
        },
      });
      var r = n(58258),
        i = n(15539),
        a = (e, t) => {
          (e.suspense || e.throwOnError || e.experimental_prefetchInRender) &&
            !t.isReset() &&
            (e.retryOnMount = !1);
        },
        s = (e) => {
          r.useEffect(() => {
            e.clearReset();
          }, [e]);
        },
        o = (e) => {
          let { result: t, errorResetBoundary: n, throwOnError: r, query: a, suspense: s } = e;
          return (
            t.isError &&
            !n.isReset() &&
            !t.isFetching &&
            a &&
            ((s && void 0 === t.data) || (0, i.L)(r, [t.error, a]))
          );
        };
    },
    25893: function (e, t, n) {
      'use strict';
      n.d(t, {
        S: function () {
          return a;
        },
      });
      var r = n(58258),
        i = r.createContext(!1),
        a = () => r.useContext(i);
      i.Provider;
    },
    10299: function (e, t, n) {
      'use strict';
      n.d(t, {
        A8: function () {
          return r;
        },
        SB: function () {
          return a;
        },
        Z$: function () {
          return i;
        },
        j8: function () {
          return s;
        },
      });
      var r = (e) => {
          let t = e.staleTime;
          e.suspense &&
            ((e.staleTime =
              'function' == typeof t ? (...e) => Math.max(t(...e), 1e3) : Math.max(t ?? 1e3, 1e3)),
            'number' == typeof e.gcTime && (e.gcTime = Math.max(e.gcTime, 1e3)));
        },
        i = (e, t) => e.isLoading && e.isFetching && !t,
        a = (e, t) => e?.suspense && t.isPending,
        s = (e, t, n) =>
          t.fetchOptimistic(e).catch(() => {
            n.clearReset();
          });
    },
    1769: function (e, t, n) {
      'use strict';
      n.d(t, {
        r: function () {
          return p;
        },
      });
      var r = n(58258),
        i = n(59542),
        a = n(53063),
        s = n(25513),
        o = n(13035),
        l = n(31946),
        u = n(25893),
        c = n(10299),
        d = n(15539);
      function p(e, t, n) {
        var p, h, y, f, m;
        let g = (0, s.NL)(n),
          b = (0, u.S)(),
          w = (0, o._)(),
          v = g.defaultQueryOptions(e);
        null === (h = g.getDefaultOptions().queries) ||
          void 0 === h ||
          null === (p = h._experimental_beforeQuery) ||
          void 0 === p ||
          p.call(h, v),
          (v._optimisticResults = b ? 'isRestoring' : 'optimistic'),
          (0, c.A8)(v),
          (0, l.pf)(v, w),
          (0, l.JN)(w);
        let T = !g.getQueryCache().get(v.queryHash),
          [A] = r.useState(() => new t(g, v)),
          E = A.getOptimisticResult(v),
          C = !b && !1 !== e.subscribed;
        if (
          (r.useSyncExternalStore(
            r.useCallback(
              (e) => {
                let t = C ? A.subscribe(i.Vr.batchCalls(e)) : d.Z;
                return A.updateResult(), t;
              },
              [A, C]
            ),
            () => A.getCurrentResult(),
            () => A.getCurrentResult()
          ),
          r.useEffect(() => {
            A.setOptions(v);
          }, [v, A]),
          (0, c.SB)(v, E))
        )
          throw (0, c.j8)(v, A, w);
        if (
          (0, l.KJ)({
            result: E,
            errorResetBoundary: w,
            throwOnError: v.throwOnError,
            query: g.getQueryCache().get(v.queryHash),
            suspense: v.suspense,
          })
        )
          throw E.error;
        if (
          (null === (f = g.getDefaultOptions().queries) ||
            void 0 === f ||
            null === (y = f._experimental_afterQuery) ||
            void 0 === y ||
            y.call(f, v, E),
          v.experimental_prefetchInRender && !a.sk && (0, c.Z$)(E, b))
        ) {
          let e = T
            ? (0, c.j8)(v, A, w)
            : null === (m = g.getQueryCache().get(v.queryHash)) || void 0 === m
              ? void 0
              : m.promise;
          null == e ||
            e.catch(d.Z).finally(() => {
              A.updateResult();
            });
        }
        return v.notifyOnChangeProps ? E : A.trackResult(E);
      }
    },
    97844: function (e, t, n) {
      'use strict';
      n.d(t, {
        D: function () {
          return d;
        },
      });
      var r = n(58258),
        i = n(41997),
        a = n(59542),
        s = n(52634),
        o = n(53063),
        l = class extends s.l {
          #d;
          #P = void 0;
          #K;
          #Q;
          constructor(e, t) {
            super(), (this.#d = e), this.setOptions(t), this.bindMethods(), this.#Y();
          }
          bindMethods() {
            (this.mutate = this.mutate.bind(this)), (this.reset = this.reset.bind(this));
          }
          setOptions(e) {
            let t = this.options;
            (this.options = this.#d.defaultMutationOptions(e)),
              (0, o.VS)(this.options, t) ||
                this.#d
                  .getMutationCache()
                  .notify({ type: 'observerOptionsUpdated', mutation: this.#K, observer: this }),
              t?.mutationKey &&
              this.options.mutationKey &&
              (0, o.Ym)(t.mutationKey) !== (0, o.Ym)(this.options.mutationKey)
                ? this.reset()
                : this.#K?.state.status === 'pending' && this.#K.setOptions(this.options);
          }
          onUnsubscribe() {
            this.hasListeners() || this.#K?.removeObserver(this);
          }
          onMutationUpdate(e) {
            this.#Y(), this.#H(e);
          }
          getCurrentResult() {
            return this.#P;
          }
          reset() {
            this.#K?.removeObserver(this), (this.#K = void 0), this.#Y(), this.#H();
          }
          mutate(e, t) {
            return (
              (this.#Q = t),
              this.#K?.removeObserver(this),
              (this.#K = this.#d.getMutationCache().build(this.#d, this.options)),
              this.#K.addObserver(this),
              this.#K.execute(e)
            );
          }
          #Y() {
            let e = this.#K?.state ?? (0, i.R)();
            this.#P = {
              ...e,
              isPending: 'pending' === e.status,
              isSuccess: 'success' === e.status,
              isError: 'error' === e.status,
              isIdle: 'idle' === e.status,
              mutate: this.mutate,
              reset: this.reset,
            };
          }
          #H(e) {
            a.Vr.batch(() => {
              if (this.#Q && this.hasListeners()) {
                let t = this.#P.variables,
                  n = this.#P.context;
                e?.type === 'success'
                  ? (this.#Q.onSuccess?.(e.data, t, n), this.#Q.onSettled?.(e.data, null, t, n))
                  : e?.type === 'error' &&
                    (this.#Q.onError?.(e.error, t, n), this.#Q.onSettled?.(void 0, e.error, t, n));
              }
              this.listeners.forEach((e) => {
                e(this.#P);
              });
            });
          }
        },
        u = n(25513),
        c = n(15539);
      function d(e, t) {
        let n = (0, u.NL)(t),
          [i] = r.useState(() => new l(n, e));
        r.useEffect(() => {
          i.setOptions(e);
        }, [i, e]);
        let s = r.useSyncExternalStore(
            r.useCallback((e) => i.subscribe(a.Vr.batchCalls(e)), [i]),
            () => i.getCurrentResult(),
            () => i.getCurrentResult()
          ),
          o = r.useCallback(
            (e, t) => {
              i.mutate(e, t).catch(c.Z);
            },
            [i]
          );
        if (s.error && (0, c.L)(i.options.throwOnError, [s.error])) throw s.error;
        return { ...s, mutate: o, mutateAsync: s.mutate };
      }
    },
    30785: function (e, t, n) {
      'use strict';
      n.d(t, {
        h: function () {
          return m;
        },
      });
      var r = n(58258),
        i = n(59542),
        a = n(41426),
        s = n(52634),
        o = n(53063);
      function l(e, t) {
        return e.filter((e) => !t.includes(e));
      }
      var u = class extends s.l {
          #d;
          #Z;
          #y;
          #J;
          #r;
          #X;
          #ee;
          #et;
          #en = [];
          constructor(e, t, n) {
            super(),
              (this.#d = e),
              (this.#J = n),
              (this.#y = []),
              (this.#r = []),
              (this.#Z = []),
              this.setQueries(t);
          }
          onSubscribe() {
            1 === this.listeners.size &&
              this.#r.forEach((e) => {
                e.subscribe((t) => {
                  this.#er(e, t);
                });
              });
          }
          onUnsubscribe() {
            this.listeners.size || this.destroy();
          }
          destroy() {
            (this.listeners = new Set()),
              this.#r.forEach((e) => {
                e.destroy();
              });
          }
          setQueries(e, t) {
            (this.#y = e),
              (this.#J = t),
              i.Vr.batch(() => {
                let e = this.#r,
                  t = this.#ei(this.#y);
                (this.#en = t), t.forEach((e) => e.observer.setOptions(e.defaultedQueryOptions));
                let n = t.map((e) => e.observer),
                  r = n.map((e) => e.getCurrentResult()),
                  i = n.some((t, n) => t !== e[n]);
                (e.length !== n.length || i) &&
                  ((this.#r = n),
                  (this.#Z = r),
                  this.hasListeners() &&
                    (l(e, n).forEach((e) => {
                      e.destroy();
                    }),
                    l(n, e).forEach((e) => {
                      e.subscribe((t) => {
                        this.#er(e, t);
                      });
                    }),
                    this.#H()));
              });
          }
          getCurrentResult() {
            return this.#Z;
          }
          getQueries() {
            return this.#r.map((e) => e.getCurrentQuery());
          }
          getObservers() {
            return this.#r;
          }
          getOptimisticResult(e, t) {
            let n = this.#ei(e),
              r = n.map((e) => e.observer.getOptimisticResult(e.defaultedQueryOptions));
            return [r, (e) => this.#ea(e ?? r, t), () => this.#es(r, n)];
          }
          #es(e, t) {
            return t.map((n, r) => {
              let i = e[r];
              return n.defaultedQueryOptions.notifyOnChangeProps
                ? i
                : n.observer.trackResult(i, (e) => {
                    t.forEach((t) => {
                      t.observer.trackProp(e);
                    });
                  });
            });
          }
          #ea(e, t) {
            return t
              ? ((this.#X && this.#Z === this.#et && t === this.#ee) ||
                  ((this.#ee = t), (this.#et = this.#Z), (this.#X = (0, o.Q$)(this.#X, t(e)))),
                this.#X)
              : e;
          }
          #ei(e) {
            let t = new Map(this.#r.map((e) => [e.options.queryHash, e])),
              n = [];
            return (
              e.forEach((e) => {
                let r = this.#d.defaultQueryOptions(e),
                  i = t.get(r.queryHash);
                i
                  ? n.push({ defaultedQueryOptions: r, observer: i })
                  : n.push({ defaultedQueryOptions: r, observer: new a.z(this.#d, r) });
              }),
              n
            );
          }
          #er(e, t) {
            let n = this.#r.indexOf(e);
            -1 !== n &&
              ((this.#Z = (function (e, t, n) {
                let r = e.slice(0);
                return (r[t] = n), r;
              })(this.#Z, n, t)),
              this.#H());
          }
          #H() {
            if (this.hasListeners()) {
              let e = this.#X,
                t = this.#es(this.#Z, this.#en);
              e !== this.#ea(t, this.#J?.combine) &&
                i.Vr.batch(() => {
                  this.listeners.forEach((e) => {
                    e(this.#Z);
                  });
                });
            }
          }
        },
        c = n(25513),
        d = n(25893),
        p = n(13035),
        h = n(31946),
        y = n(10299),
        f = n(15539);
      function m(e, t) {
        let { queries: n, ...s } = e,
          o = (0, c.NL)(t),
          l = (0, d.S)(),
          m = (0, p._)(),
          g = r.useMemo(
            () =>
              n.map((e) => {
                let t = o.defaultQueryOptions(e);
                return (t._optimisticResults = l ? 'isRestoring' : 'optimistic'), t;
              }),
            [n, o, l]
          );
        g.forEach((e) => {
          (0, y.A8)(e), (0, h.pf)(e, m);
        }),
          (0, h.JN)(m);
        let [b] = r.useState(() => new u(o, g, s)),
          [w, v, T] = b.getOptimisticResult(g, s.combine),
          A = !l && !1 !== s.subscribed;
        r.useSyncExternalStore(
          r.useCallback((e) => (A ? b.subscribe(i.Vr.batchCalls(e)) : f.Z), [b, A]),
          () => b.getCurrentResult(),
          () => b.getCurrentResult()
        ),
          r.useEffect(() => {
            b.setQueries(g, s);
          }, [g, s, b]);
        let E = w.some((e, t) => (0, y.SB)(g[t], e))
          ? w.flatMap((e, t) => {
              let n = g[t];
              if (n) {
                let t = new a.z(o, n);
                if ((0, y.SB)(n, e)) return (0, y.j8)(n, t, m);
                (0, y.Z$)(e, l) && (0, y.j8)(n, t, m);
              }
              return [];
            })
          : [];
        if (E.length > 0) throw Promise.all(E);
        let C = w.find((e, t) => {
          let n = g[t];
          return (
            n &&
            (0, h.KJ)({
              result: e,
              errorResetBoundary: m,
              throwOnError: n.throwOnError,
              query: o.getQueryCache().get(n.queryHash),
              suspense: n.suspense,
            })
          );
        });
        if (null == C ? void 0 : C.error) throw C.error;
        return v(T());
      }
    },
    10943: function (e, t, n) {
      'use strict';
      n.d(t, {
        a: function () {
          return a;
        },
      });
      var r = n(41426),
        i = n(1769);
      function a(e, t) {
        return (0, i.r)(e, r.z, t);
      }
    },
    15539: function (e, t, n) {
      'use strict';
      function r(e, t) {
        return 'function' == typeof e ? e(...t) : !!e;
      }
      function i() {}
      n.d(t, {
        L: function () {
          return r;
        },
        Z: function () {
          return i;
        },
      });
    },
    56458: function (e, t, n) {
      'use strict';
      n.d(t, {
        T: function () {
          return o;
        },
      });
      var r = n(43485),
        i = n(77406),
        a = n(28346),
        s = n(30390);
      function o(e = {}) {
        let t, l;
        let { shimDisconnect: u = !1 } = e;
        return (0, r.K)((r) => ({
          id: 'safe',
          name: 'Safe',
          type: o.type,
          async connect() {
            let e = await this.getProvider();
            if (!e) throw new i.M();
            let t = await this.getAccounts(),
              n = await this.getChainId();
            return (
              l || ((l = this.onDisconnect.bind(this)), e.on('disconnect', l)),
              u && (await r.storage?.removeItem('safe.disconnected')),
              { accounts: t, chainId: n }
            );
          },
          async disconnect() {
            let e = await this.getProvider();
            if (!e) throw new i.M();
            l && (e.removeListener('disconnect', l), (l = void 0)),
              u && (await r.storage?.setItem('safe.disconnected', !0));
          },
          async getAccounts() {
            let e = await this.getProvider();
            if (!e) throw new i.M();
            return (await e.request({ method: 'eth_accounts' })).map(a.K);
          },
          async getProvider() {
            if ('undefined' != typeof window && window?.parent !== window) {
              if (!t) {
                let { default: r } = await Promise.all([n.e(7287), n.e(6929)]).then(
                    n.bind(n, 36929)
                  ),
                  i = new r(e),
                  a = await (0, s.F)(() => i.safe.getInfo(), {
                    timeout: e.unstable_getInfoTimeout ?? 10,
                  });
                if (!a) throw Error('Could not load Safe information');
                t = new (await (async () => {
                  let e = await Promise.all([n.e(7287), n.e(388)]).then(n.t.bind(n, 20388, 19));
                  return 'function' != typeof e.SafeAppProvider &&
                    'function' == typeof e.default.SafeAppProvider
                    ? e.default.SafeAppProvider
                    : e.SafeAppProvider;
                })())(a, i);
              }
              return t;
            }
          },
          async getChainId() {
            let e = await this.getProvider();
            if (!e) throw new i.M();
            return Number(e.chainId);
          },
          async isAuthorized() {
            try {
              if (u && (await r.storage?.getItem('safe.disconnected'))) return !1;
              return !!(await this.getAccounts()).length;
            } catch {
              return !1;
            }
          },
          onAccountsChanged() {},
          onChainChanged() {},
          onDisconnect() {
            r.emitter.emit('disconnect');
          },
        }));
      }
      o.type = 'safe';
    },
    75496: function (e, t, n) {
      'use strict';
      n.d(t, {
        $: function () {
          return i;
        },
      });
      var r = n(88396);
      async function i(e, t) {
        let n;
        if (
          (n =
            'function' == typeof t.connector
              ? e._internal.connectors.setup(t.connector)
              : t.connector).uid === e.state.current
        )
          throw new r.wi();
        try {
          e.setState((e) => ({ ...e, status: 'connecting' })),
            n.emitter.emit('message', { type: 'connecting' });
          let { connector: r, ...i } = t,
            a = await n.connect(i),
            s = a.accounts;
          return (
            n.emitter.off('connect', e._internal.events.connect),
            n.emitter.on('change', e._internal.events.change),
            n.emitter.on('disconnect', e._internal.events.disconnect),
            await e.storage?.setItem('recentConnectorId', n.id),
            e.setState((e) => ({
              ...e,
              connections: new Map(e.connections).set(n.uid, {
                accounts: s,
                chainId: a.chainId,
                connector: n,
              }),
              current: n.uid,
              status: 'connected',
            })),
            { accounts: s, chainId: a.chainId }
          );
        } catch (t) {
          throw (
            (e.setState((e) => ({ ...e, status: e.current ? 'connected' : 'disconnected' })), t)
          );
        }
      }
    },
    25964: function (e, t, n) {
      'use strict';
      async function r(e, t = {}) {
        let n;
        if (t.connector) n = t.connector;
        else {
          let { connections: t, current: r } = e.state,
            i = t.get(r);
          n = i?.connector;
        }
        let r = e.state.connections;
        n &&
          (await n.disconnect(),
          n.emitter.off('change', e._internal.events.change),
          n.emitter.off('disconnect', e._internal.events.disconnect),
          n.emitter.on('connect', e._internal.events.connect),
          r.delete(n.uid)),
          e.setState((e) => {
            if (0 === r.size)
              return { ...e, connections: new Map(), current: null, status: 'disconnected' };
            let t = r.values().next().value;
            return { ...e, connections: new Map(r), current: t.connector.uid };
          });
        {
          let t = e.state.current;
          if (!t) return;
          let n = e.state.connections.get(t)?.connector;
          if (!n) return;
          await e.storage?.setItem('recentConnectorId', n.id);
        }
      }
      n.d(t, {
        z: function () {
          return r;
        },
      });
    },
    65036: function (e, t, n) {
      'use strict';
      n.d(t, {
        Q: function () {
          return s;
        },
      });
      var r = n(18452),
        i = n(28180),
        a = n(52171);
      async function s(e, t) {
        let n;
        let { chainId: s, connector: o, ...l } = t;
        n = t.account
          ? t.account
          : (await (0, a.e)(e, { account: t.account, chainId: s, connector: o })).account;
        let u = e.getClient({ chainId: s });
        return (0, i.s)(u, r.Q, 'estimateGas')({ ...l, account: n });
      }
    },
    80827: function (e, t, n) {
      'use strict';
      function r(e) {
        let t = e.state.current,
          n = e.state.connections.get(t),
          r = n?.accounts,
          i = r?.[0],
          a = e.chains.find((e) => e.id === n?.chainId),
          s = e.state.status;
        switch (s) {
          case 'connected':
            return {
              address: i,
              addresses: r,
              chain: a,
              chainId: n?.chainId,
              connector: n?.connector,
              isConnected: !0,
              isConnecting: !1,
              isDisconnected: !1,
              isReconnecting: !1,
              status: s,
            };
          case 'reconnecting':
            return {
              address: i,
              addresses: r,
              chain: a,
              chainId: n?.chainId,
              connector: n?.connector,
              isConnected: !!i,
              isConnecting: !1,
              isDisconnected: !1,
              isReconnecting: !0,
              status: s,
            };
          case 'connecting':
            return {
              address: i,
              addresses: r,
              chain: a,
              chainId: n?.chainId,
              connector: n?.connector,
              isConnected: !1,
              isConnecting: !0,
              isDisconnected: !1,
              isReconnecting: !1,
              status: s,
            };
          case 'disconnected':
            return {
              address: void 0,
              addresses: void 0,
              chain: void 0,
              chainId: void 0,
              connector: void 0,
              isConnected: !1,
              isConnecting: !1,
              isDisconnected: !0,
              isReconnecting: !1,
              status: s,
            };
        }
      }
      n.d(t, {
        D: function () {
          return r;
        },
      });
    },
    14886: function (e, t, n) {
      'use strict';
      n.d(t, {
        s: function () {
          return c;
        },
      });
      var r = n(79e3),
        i = n(97032),
        a = n(28213),
        s = n(66460),
        o = n(28180),
        l = n(6537),
        u = n(6629);
      async function c(e, t) {
        let {
          address: n,
          blockNumber: u,
          blockTag: c,
          chainId: p,
          token: h,
          unit: y = 'ether',
        } = t;
        if (h)
          try {
            return await d(e, {
              balanceAddress: n,
              chainId: p,
              symbolType: 'string',
              tokenAddress: h,
            });
          } catch (t) {
            if ('ContractFunctionExecutionError' === t.name) {
              let t = await d(e, {
                  balanceAddress: n,
                  chainId: p,
                  symbolType: 'bytes32',
                  tokenAddress: h,
                }),
                a = (0, r.rR)((0, i.f)(t.symbol, { dir: 'right' }));
              return { ...t, symbol: a };
            }
            throw t;
          }
        let f = e.getClient({ chainId: p }),
          m = (0, o.s)(f, s.s, 'getBalance'),
          g = await m(u ? { address: n, blockNumber: u } : { address: n, blockTag: c }),
          b = e.chains.find((e) => e.id === p) ?? f.chain;
        return {
          decimals: b.nativeCurrency.decimals,
          formatted: (0, a.b)(g, (0, l.W)(y)),
          symbol: b.nativeCurrency.symbol,
          value: g,
        };
      }
      async function d(e, t) {
        let { balanceAddress: n, chainId: r, symbolType: i, tokenAddress: s, unit: o } = t,
          c = {
            abi: [
              {
                type: 'function',
                name: 'balanceOf',
                stateMutability: 'view',
                inputs: [{ type: 'address' }],
                outputs: [{ type: 'uint256' }],
              },
              {
                type: 'function',
                name: 'decimals',
                stateMutability: 'view',
                inputs: [],
                outputs: [{ type: 'uint8' }],
              },
              {
                type: 'function',
                name: 'symbol',
                stateMutability: 'view',
                inputs: [],
                outputs: [{ type: i }],
              },
            ],
            address: s,
          },
          [d, p, h] = await (0, u.J)(e, {
            allowFailure: !1,
            contracts: [
              { ...c, functionName: 'balanceOf', args: [n], chainId: r },
              { ...c, functionName: 'decimals', chainId: r },
              { ...c, functionName: 'symbol', chainId: r },
            ],
          }),
          y = (0, a.b)(d ?? '0', (0, l.W)(o ?? p));
        return { decimals: p, formatted: y, symbol: h, value: d };
      }
    },
    33873: function (e, t, n) {
      'use strict';
      n.d(t, {
        E: function () {
          return a;
        },
      });
      var r = n(18548);
      let i = [];
      function a(e) {
        let t = [...e.state.connections.values()];
        return 'reconnecting' === e.state.status || (0, r.v)(i, t) ? i : ((i = t), t);
      }
    },
    52171: function (e, t, n) {
      'use strict';
      n.d(t, {
        e: function () {
          return l;
        },
      });
      var r = n(18059),
        i = n(15077),
        a = n(65099),
        s = n(28346),
        o = n(88396);
      async function l(e, t = {}) {
        let n;
        if (t.connector) {
          let { connector: r } = t;
          if ('reconnecting' === e.state.status && !r.getAccounts && !r.getChainId)
            throw new o.$S({ connector: r });
          let [i, a] = await Promise.all([
            r.getAccounts().catch((e) => {
              if (null === t.account) return [];
              throw e;
            }),
            r.getChainId(),
          ]);
          n = { accounts: i, chainId: a, connector: r };
        } else n = e.state.connections.get(e.state.current);
        if (!n) throw new o.aH();
        let l = t.chainId ?? n.chainId,
          u = await n.connector.getChainId();
        if (u !== n.chainId) throw new o.XZ({ connectionChainId: n.chainId, connectorChainId: u });
        let c = n.connector;
        if (c.getClient) return c.getClient({ chainId: l });
        let d = (0, a.T)(t.account ?? n.accounts[0]);
        if (
          (d && (d.address = (0, s.K)(d.address)),
          t.account && !n.accounts.some((e) => e.toLowerCase() === d.address.toLowerCase()))
        )
          throw new o.JK({ address: d.address, connector: c });
        let p = e.chains.find((e) => e.id === l),
          h = await n.connector.getProvider({ chainId: l });
        return (0, r.e)({
          account: d,
          chain: p,
          name: 'Connector Client',
          transport: (e) =>
            (function (e, t = {}) {
              let { key: n = 'custom', methods: r, name: a = 'Custom Provider', retryDelay: s } = t;
              return ({ retryCount: o }) =>
                (0, i.q)({
                  key: n,
                  methods: r,
                  name: a,
                  request: e.request.bind(e),
                  retryCount: t.retryCount ?? o,
                  retryDelay: s,
                  type: 'custom',
                });
            })(h)({ ...e, retryCount: 0 }),
        });
      }
    },
    9905: function (e, t, n) {
      'use strict';
      n.d(t, {
        O: function () {
          return a;
        },
      });
      var r = n(13742),
        i = n(28180);
      function a(e, t) {
        let { chainId: n, ...a } = t,
          s = e.getClient({ chainId: n });
        return (0, i.s)(s, r.O, 'getEnsAddress')(a);
      }
    },
    65110: function (e, t, n) {
      'use strict';
      n.d(t, {
        r: function () {
          return a;
        },
      });
      var r = n(87428),
        i = n(28180);
      function a(e, t) {
        let { chainId: n, ...a } = t,
          s = e.getClient({ chainId: n });
        return (0, i.s)(s, r.r, 'getEnsAvatar')(a);
      }
    },
    96238: function (e, t, n) {
      'use strict';
      n.d(t, {
        w: function () {
          return a;
        },
      });
      var r = n(33737),
        i = n(28180);
      function a(e, t) {
        let { chainId: n, ...a } = t,
          s = e.getClient({ chainId: n });
        return (0, i.s)(s, r.w, 'getEnsName')(a);
      }
    },
    95705: function (e, t, n) {
      'use strict';
      n.d(t, {
        Z: function () {
          return s;
        },
      });
      var r = n(90936),
        i = n(28180),
        a = n(80827);
      async function s(e, t) {
        let { account: n, chainId: s, ...o } = t,
          l = n ?? (0, a.D)(e).address,
          u = e.getClient({ chainId: s });
        return (0, i.s)(
          u,
          r.ZE,
          'prepareTransactionRequest'
        )({ ...o, ...(l ? { account: l } : {}) });
      }
    },
    83765: function (e, t, n) {
      'use strict';
      n.d(t, {
        L: function () {
          return a;
        },
      });
      var r = n(86705),
        i = n(28180);
      function a(e, t) {
        let { chainId: n, ...a } = t,
          s = e.getClient({ chainId: n });
        return (0, i.s)(s, r.L, 'readContract')(a);
      }
    },
    6629: function (e, t, n) {
      'use strict';
      n.d(t, {
        J: function () {
          return l;
        },
      });
      var r = n(54484),
        i = n(88052),
        a = n(28180);
      async function s(e, t) {
        let { allowFailure: n = !0, chainId: r, contracts: s, ...o } = t,
          l = e.getClient({ chainId: r });
        return (0, a.s)(l, i.A, 'multicall')({ allowFailure: n, contracts: s, ...o });
      }
      var o = n(83765);
      async function l(e, t) {
        let { allowFailure: n = !0, blockNumber: i, blockTag: a, ...l } = t,
          u = t.contracts;
        try {
          let t = {};
          for (let [n, r] of u.entries()) {
            let i = r.chainId ?? e.state.chainId;
            t[i] || (t[i] = []), t[i]?.push({ contract: r, index: n });
          }
          let r = (
              await Promise.all(
                Object.entries(t).map(([t, r]) =>
                  s(e, {
                    ...l,
                    allowFailure: n,
                    blockNumber: i,
                    blockTag: a,
                    chainId: Number.parseInt(t),
                    contracts: r.map(({ contract: e }) => e),
                  })
                )
              )
            ).flat(),
            o = Object.values(t).flatMap((e) => e.map(({ index: e }) => e));
          return r.reduce((e, t, n) => (e && (e[o[n]] = t), e), []);
        } catch (s) {
          if (s instanceof r.uq) throw s;
          let t = () => u.map((t) => (0, o.L)(e, { ...t, blockNumber: i, blockTag: a }));
          if (n)
            return (await Promise.allSettled(t())).map((e) =>
              'fulfilled' === e.status
                ? { result: e.value, status: 'success' }
                : { error: e.reason, result: void 0, status: 'failure' }
            );
          return await Promise.all(t());
        }
      }
    },
    28297: function (e, t, n) {
      'use strict';
      n.d(t, {
        G: function () {
          return i;
        },
      });
      let r = !1;
      async function i(e, t = {}) {
        let n;
        if (r) return [];
        (r = !0), e.setState((e) => ({ ...e, status: e.current ? 'reconnecting' : 'connecting' }));
        let i = [];
        if (t.connectors?.length)
          for (let n of t.connectors) {
            let t;
            (t = 'function' == typeof n ? e._internal.connectors.setup(n) : n), i.push(t);
          }
        else i.push(...e.connectors);
        try {
          n = await e.storage?.getItem('recentConnectorId');
        } catch {}
        let a = {};
        for (let [, t] of e.state.connections) a[t.connector.id] = 1;
        n && (a[n] = 0);
        let s =
            Object.keys(a).length > 0
              ? [...i].sort((e, t) => (a[e.id] ?? 10) - (a[t.id] ?? 10))
              : i,
          o = !1,
          l = [],
          u = [];
        for (let t of s) {
          let n = await t.getProvider().catch(() => void 0);
          if (!n || u.some((e) => e === n) || !(await t.isAuthorized())) continue;
          let r = await t.connect({ isReconnecting: !0 }).catch(() => null);
          r &&
            (t.emitter.off('connect', e._internal.events.connect),
            t.emitter.on('change', e._internal.events.change),
            t.emitter.on('disconnect', e._internal.events.disconnect),
            e.setState((e) => {
              let n = new Map(o ? e.connections : new Map()).set(t.uid, {
                accounts: r.accounts,
                chainId: r.chainId,
                connector: t,
              });
              return { ...e, current: o ? e.current : t.uid, connections: n };
            }),
            l.push({ accounts: r.accounts, chainId: r.chainId, connector: t }),
            u.push(n),
            (o = !0));
        }
        return (
          ('reconnecting' === e.state.status || 'connecting' === e.state.status) &&
            (o
              ? e.setState((e) => ({ ...e, status: 'connected' }))
              : e.setState((e) => ({
                  ...e,
                  connections: new Map(),
                  current: null,
                  status: 'disconnected',
                }))),
          (r = !1),
          l
        );
      }
    },
    87933: function (e, t, n) {
      'use strict';
      n.d(t, {
        T: function () {
          return s;
        },
      });
      var r = n(88362),
        i = n(28180),
        a = n(52171);
      async function s(e, t) {
        let n;
        let { account: s, chainId: o, connector: l, ...u } = t;
        n =
          'object' == typeof s && s?.type === 'local'
            ? e.getClient({ chainId: o })
            : await (0, a.e)(e, { account: s ?? void 0, chainId: o, connector: l });
        let c = (0, i.s)(n, r.T, 'sendTransaction');
        return await c({
          ...u,
          ...(s ? { account: s } : {}),
          chain: o ? { id: o } : null,
          gas: u.gas ?? void 0,
        });
      }
    },
    83847: function (e, t, n) {
      'use strict';
      n.d(t, {
        l: function () {
          return s;
        },
      });
      var r = n(38657),
        i = n(28180),
        a = n(52171);
      async function s(e, t) {
        let n;
        let { account: s, connector: o, ...l } = t;
        return (
          (n =
            'object' == typeof s && 'local' === s.type
              ? e.getClient()
              : await (0, a.e)(e, { account: s, connector: o })),
          (0, i.s)(n, r.l, 'signMessage')({ ...l, ...(s ? { account: s } : {}) })
        );
      }
    },
    63230: function (e, t, n) {
      'use strict';
      n.d(t, {
        c: function () {
          return a;
        },
      });
      var r = n(88396),
        i = n(77406);
      async function a(e, t) {
        let { addEthereumChainParameter: n, chainId: a } = t,
          s = e.state.connections.get(t.connector?.uid ?? e.state.current);
        if (s) {
          let e = s.connector;
          if (!e.switchChain) throw new i.O({ connector: e });
          return await e.switchChain({ addEthereumChainParameter: n, chainId: a });
        }
        let o = e.chains.find((e) => e.id === a);
        if (!o) throw new r.X4();
        return e.setState((e) => ({ ...e, chainId: a })), o;
      }
    },
    48894: function (e, t, n) {
      'use strict';
      n.d(t, {
        e: function () {
          return l;
        },
      });
      var r = n(79e3),
        i = n(5712),
        a = n(11662),
        s = n(69183),
        o = n(28180);
      async function l(e, t) {
        let { chainId: n, timeout: l = 0, ...u } = t,
          c = e.getClient({ chainId: n }),
          d = (0, o.s)(c, i.e, 'waitForTransactionReceipt'),
          p = await d({ ...u, timeout: l });
        if ('reverted' === p.status) {
          let e = (0, o.s)(c, a.f, 'getTransaction'),
            t = await e({ hash: p.transactionHash }),
            n = (0, o.s)(c, s.R, 'call'),
            i = await n({
              ...t,
              data: t.input,
              gasPrice: 'eip1559' !== t.type ? t.gasPrice : void 0,
              maxFeePerGas: 'eip1559' === t.type ? t.maxFeePerGas : void 0,
              maxPriorityFeePerGas: 'eip1559' === t.type ? t.maxPriorityFeePerGas : void 0,
            });
          throw Error(i?.data ? (0, r.rR)(`0x${i.data.substring(138)}`) : 'unknown reason');
        }
        return { ...p, chainId: c.chain.id };
      }
    },
    5333: function (e, t, n) {
      'use strict';
      n.d(t, {
        u: function () {
          return a;
        },
      });
      var r = n(18548),
        i = n(80827);
      function a(e, t) {
        let { onChange: n } = t;
        return e.subscribe(() => (0, i.D)(e), n, {
          equalityFn(e, t) {
            let { connector: n, ...i } = e,
              { connector: a, ...s } = t;
            return (0, r.v)(i, s) && n?.id === a?.id && n?.uid === a?.uid;
          },
        });
      }
    },
    33022: function (e, t, n) {
      'use strict';
      function r(e, t) {
        let { onChange: n } = t;
        return e._internal.connectors.subscribe((e, t) => {
          n(Object.values(e), t);
        });
      }
      n.d(t, {
        f: function () {
          return r;
        },
      });
    },
    37737: function (e, t, n) {
      'use strict';
      n.d(t, {
        O: function () {
          return a;
        },
      });
      var r = n(15921),
        i = n(28180);
      function a(e, t) {
        let n, a;
        let { syncConnectedChain: s = e._internal.syncConnectedChain, ...o } = t,
          l = (t) => {
            n && n();
            let a = e.getClient({ chainId: t });
            return (n = (0, i.s)(a, r.O, 'watchPendingTransactions')(o));
          },
          u = l(t.chainId);
        return (
          s &&
            !t.chainId &&
            (a = e.subscribe(
              ({ chainId: e }) => e,
              async (e) => l(e)
            )),
          () => {
            u?.(), a?.();
          }
        );
      }
    },
    25342: function (e, t, n) {
      'use strict';
      n.d(t, {
        n: function () {
          return s;
        },
      });
      var r = n(68404),
        i = n(28180),
        a = n(52171);
      async function s(e, t) {
        let n;
        let { account: s, chainId: o, connector: l, ...u } = t;
        n =
          'object' == typeof s && s?.type === 'local'
            ? e.getClient({ chainId: o })
            : await (0, a.e)(e, { account: s ?? void 0, chainId: o, connector: l });
        let c = (0, i.s)(n, r.n, 'writeContract');
        return await c({ ...u, ...(s ? { account: s } : {}), chain: o ? { id: o } : null });
      }
    },
    43485: function (e, t, n) {
      'use strict';
      function r(e) {
        return e;
      }
      n.d(t, {
        K: function () {
          return r;
        },
      });
    },
    88496: function (e, t, n) {
      'use strict';
      n.d(t, {
        L: function () {
          return d;
        },
      });
      var r = n(28346),
        i = n(18292),
        a = n(30390),
        s = n(74118),
        o = n(84196),
        l = n(88396),
        u = n(77406),
        c = n(43485);
      function d(e = {}) {
        let t, n, y, f;
        let { shimDisconnect: m = !0, unstable_shimAsyncInject: g } = e;
        function b() {
          let t = e.target;
          if ('function' == typeof t) {
            let e = t();
            if (e) return e;
          }
          return 'object' == typeof t
            ? t
            : 'string' == typeof t
              ? {
                  ...(p[t] ?? {
                    id: t,
                    name: `${t[0].toUpperCase()}${t.slice(1)}`,
                    provider: `is${t[0].toUpperCase()}${t.slice(1)}`,
                  }),
                }
              : { id: 'injected', name: 'Injected', provider: (e) => e?.ethereum };
        }
        return (0, c.K)((c) => ({
          get icon() {
            return b().icon;
          },
          get id() {
            return b().id;
          },
          get name() {
            return b().name;
          },
          get supportsSimulation() {
            return !0;
          },
          type: d.type,
          async setup() {
            let n = await this.getProvider();
            n?.on &&
              e.target &&
              (y || ((y = this.onConnect.bind(this)), n.on('connect', y)),
              t || ((t = this.onAccountsChanged.bind(this)), n.on('accountsChanged', t)));
          },
          async connect({ chainId: a, isReconnecting: s } = {}) {
            let o = await this.getProvider();
            if (!o) throw new u.M();
            let l = [];
            if (s) l = await this.getAccounts().catch(() => []);
            else if (m)
              try {
                let e = await o.request({
                  method: 'wallet_requestPermissions',
                  params: [{ eth_accounts: {} }],
                });
                (l = e[0]?.caveats?.[0]?.value?.map((e) => r.K(e))).length > 0 &&
                  (l = await this.getAccounts());
              } catch (e) {
                if (e.code === i.ab.code) throw new i.ab(e);
                if (e.code === i.pT.code) throw e;
              }
            try {
              l?.length ||
                s ||
                (l = (await o.request({ method: 'eth_requestAccounts' })).map((e) => (0, r.K)(e))),
                y && (o.removeListener('connect', y), (y = void 0)),
                t || ((t = this.onAccountsChanged.bind(this)), o.on('accountsChanged', t)),
                n || ((n = this.onChainChanged.bind(this)), o.on('chainChanged', n)),
                f || ((f = this.onDisconnect.bind(this)), o.on('disconnect', f));
              let u = await this.getChainId();
              if (a && u !== a) {
                let e = await this.switchChain({ chainId: a }).catch((e) => {
                  if (e.code === i.ab.code) throw e;
                  return { id: u };
                });
                u = e?.id ?? u;
              }
              return (
                m && (await c.storage?.removeItem(`${this.id}.disconnected`)),
                e.target || (await c.storage?.setItem('injected.connected', !0)),
                { accounts: l, chainId: u }
              );
            } catch (e) {
              if (e.code === i.ab.code) throw new i.ab(e);
              if (e.code === i.pT.code) throw new i.pT(e);
              throw e;
            }
          },
          async disconnect() {
            let t = await this.getProvider();
            if (!t) throw new u.M();
            n && (t.removeListener('chainChanged', n), (n = void 0)),
              f && (t.removeListener('disconnect', f), (f = void 0)),
              y || ((y = this.onConnect.bind(this)), t.on('connect', y));
            try {
              await (0, a.F)(
                () =>
                  t.request({ method: 'wallet_revokePermissions', params: [{ eth_accounts: {} }] }),
                { timeout: 100 }
              );
            } catch {}
            m && (await c.storage?.setItem(`${this.id}.disconnected`, !0)),
              e.target || (await c.storage?.removeItem('injected.connected'));
          },
          async getAccounts() {
            let e = await this.getProvider();
            if (!e) throw new u.M();
            return (await e.request({ method: 'eth_accounts' })).map((e) => (0, r.K)(e));
          },
          async getChainId() {
            let e = await this.getProvider();
            if (!e) throw new u.M();
            return Number(await e.request({ method: 'eth_chainId' }));
          },
          async getProvider() {
            let e;
            if ('undefined' == typeof window) return;
            let t = b();
            return (
              (e =
                'function' == typeof t.provider
                  ? t.provider(window)
                  : 'string' == typeof t.provider
                    ? h(window, t.provider)
                    : t.provider) &&
                !e.removeListener &&
                ('off' in e && 'function' == typeof e.off
                  ? (e.removeListener = e.off)
                  : (e.removeListener = () => {})),
              e
            );
          },
          async isAuthorized() {
            try {
              if (
                (m && (await c.storage?.getItem(`${this.id}.disconnected`))) ||
                (!e.target && !(await c.storage?.getItem('injected.connected')))
              )
                return !1;
              if (!(await this.getProvider())) {
                if (void 0 !== g && !1 !== g) {
                  let e = async () => (
                      'undefined' != typeof window &&
                        window.removeEventListener('ethereum#initialized', e),
                      !!(await this.getProvider())
                    ),
                    t = 'number' == typeof g ? g : 1e3;
                  if (
                    await Promise.race([
                      ...('undefined' != typeof window
                        ? [
                            new Promise((t) =>
                              window.addEventListener('ethereum#initialized', () => t(e()), {
                                once: !0,
                              })
                            ),
                          ]
                        : []),
                      new Promise((n) => setTimeout(() => n(e()), t)),
                    ])
                  )
                    return !0;
                }
                throw new u.M();
              }
              return !!(await (0, s.J)(() => this.getAccounts())).length;
            } catch {
              return !1;
            }
          },
          async switchChain({ addEthereumChainParameter: e, chainId: t }) {
            let n = await this.getProvider();
            if (!n) throw new u.M();
            let r = c.chains.find((e) => e.id === t);
            if (!r) throw new i.x3(new l.X4());
            let a = new Promise((e) => {
              let n = (r) => {
                'chainId' in r && r.chainId === t && (c.emitter.off('change', n), e());
              };
              c.emitter.on('change', n);
            });
            try {
              return (
                await Promise.all([
                  n
                    .request({
                      method: 'wallet_switchEthereumChain',
                      params: [{ chainId: (0, o.eC)(t) }],
                    })
                    .then(async () => {
                      (await this.getChainId()) === t && c.emitter.emit('change', { chainId: t });
                    }),
                  a,
                ]),
                r
              );
            } catch (s) {
              if (4902 === s.code || s?.data?.originalError?.code === 4902)
                try {
                  let s, l;
                  let { default: u, ...d } = r.blockExplorers ?? {};
                  e?.blockExplorerUrls
                    ? (s = e.blockExplorerUrls)
                    : u && (s = [u.url, ...Object.values(d).map((e) => e.url)]),
                    (l = e?.rpcUrls?.length ? e.rpcUrls : [r.rpcUrls.default?.http[0] ?? '']);
                  let p = {
                    blockExplorerUrls: s,
                    chainId: (0, o.eC)(t),
                    chainName: e?.chainName ?? r.name,
                    iconUrls: e?.iconUrls,
                    nativeCurrency: e?.nativeCurrency ?? r.nativeCurrency,
                    rpcUrls: l,
                  };
                  return (
                    await Promise.all([
                      n
                        .request({ method: 'wallet_addEthereumChain', params: [p] })
                        .then(async () => {
                          if ((await this.getChainId()) === t)
                            c.emitter.emit('change', { chainId: t });
                          else throw new i.ab(Error('User rejected switch after adding network.'));
                        }),
                      a,
                    ]),
                    r
                  );
                } catch (e) {
                  throw new i.ab(e);
                }
              if (s.code === i.ab.code) throw new i.ab(s);
              throw new i.x3(s);
            }
          },
          async onAccountsChanged(e) {
            if (0 === e.length) this.onDisconnect();
            else if (c.emitter.listenerCount('connect')) {
              let e = (await this.getChainId()).toString();
              this.onConnect({ chainId: e }),
                m && (await c.storage?.removeItem(`${this.id}.disconnected`));
            } else c.emitter.emit('change', { accounts: e.map((e) => (0, r.K)(e)) });
          },
          onChainChanged(e) {
            let t = Number(e);
            c.emitter.emit('change', { chainId: t });
          },
          async onConnect(e) {
            let r = await this.getAccounts();
            if (0 === r.length) return;
            let i = Number(e.chainId);
            c.emitter.emit('connect', { accounts: r, chainId: i });
            let a = await this.getProvider();
            a &&
              (y && (a.removeListener('connect', y), (y = void 0)),
              t || ((t = this.onAccountsChanged.bind(this)), a.on('accountsChanged', t)),
              n || ((n = this.onChainChanged.bind(this)), a.on('chainChanged', n)),
              f || ((f = this.onDisconnect.bind(this)), a.on('disconnect', f)));
          },
          async onDisconnect(e) {
            let t = await this.getProvider();
            (e && 1013 === e.code && t && (await this.getAccounts()).length) ||
              (c.emitter.emit('disconnect'),
              t &&
                (n && (t.removeListener('chainChanged', n), (n = void 0)),
                f && (t.removeListener('disconnect', f), (f = void 0)),
                y || ((y = this.onConnect.bind(this)), t.on('connect', y))));
          },
        }));
      }
      d.type = 'injected';
      let p = {
        coinbaseWallet: {
          id: 'coinbaseWallet',
          name: 'Coinbase Wallet',
          provider: (e) =>
            e?.coinbaseWalletExtension ? e.coinbaseWalletExtension : h(e, 'isCoinbaseWallet'),
        },
        metaMask: {
          id: 'metaMask',
          name: 'MetaMask',
          provider: (e) =>
            h(e, (e) => {
              if (!e.isMetaMask || (e.isBraveWallet && !e._events && !e._state)) return !1;
              for (let t of [
                'isApexWallet',
                'isAvalanche',
                'isBitKeep',
                'isBlockWallet',
                'isKuCoinWallet',
                'isMathWallet',
                'isOkxWallet',
                'isOKExWallet',
                'isOneInchIOSWallet',
                'isOneInchAndroidWallet',
                'isOpera',
                'isPhantom',
                'isPortal',
                'isRabby',
                'isTokenPocket',
                'isTokenary',
                'isUniswapWallet',
                'isZerion',
              ])
                if (e[t]) return !1;
              return !0;
            }),
        },
        phantom: {
          id: 'phantom',
          name: 'Phantom',
          provider: (e) => (e?.phantom?.ethereum ? e.phantom?.ethereum : h(e, 'isPhantom')),
        },
      };
      function h(e, t) {
        function n(e) {
          return 'function' == typeof t ? t(e) : 'string' != typeof t || e[t];
        }
        let r = e.ethereum;
        return r?.providers ? r.providers.find((e) => n(e)) : r && n(r) ? r : void 0;
      }
    },
    34725: function (e, t, n) {
      'use strict';
      n.d(t, {
        o6: function () {
          return o;
        },
        ns: function () {
          return u;
        },
      });
      var r = n(98673);
      function i(e, t) {
        return e.slice(0, t).join('.') || '.';
      }
      function a(e, t) {
        let { length: n } = e;
        for (let r = 0; r < n; ++r) if (e[r] === t) return r + 1;
        return 0;
      }
      function s(e, t, n, r) {
        return JSON.stringify(
          e,
          (function (e, t) {
            let n = 'function' == typeof e,
              r = 'function' == typeof t,
              s = [],
              o = [];
            return function (l, u) {
              if ('object' == typeof u) {
                if (s.length) {
                  let e = a(s, this);
                  0 === e ? (s[s.length] = this) : (s.splice(e), o.splice(e)), (o[o.length] = l);
                  let n = a(s, u);
                  if (0 !== n) return r ? t.call(this, l, u, i(o, n)) : `[ref=${i(o, n)}]`;
                } else (s[0] = u), (o[0] = l);
              }
              return n ? e.call(this, l, u) : u;
            };
          })((e, n) => {
            let r = n;
            return (
              'bigint' == typeof r && (r = { __type: 'bigint', value: n.toString() }),
              r instanceof Map && (r = { __type: 'Map', value: Array.from(n.entries()) }),
              t?.(e, r) ?? r
            );
          }, r),
          n ?? void 0
        );
      }
      function o(e) {
        let { deserialize: t = r.v, key: n = 'wagmi', serialize: i = s, storage: a = l } = e;
        function o(e) {
          return e instanceof Promise ? e.then((e) => e).catch(() => null) : e;
        }
        return {
          ...a,
          key: n,
          async getItem(e, r) {
            let i = a.getItem(`${n}.${e}`),
              s = await o(i);
            return s ? (t(s) ?? null) : (r ?? null);
          },
          async setItem(e, t) {
            let r = `${n}.${e}`;
            null === t ? await o(a.removeItem(r)) : await o(a.setItem(r, i(t)));
          },
          async removeItem(e) {
            await o(a.removeItem(`${n}.${e}`));
          },
        };
      }
      let l = { getItem: () => null, setItem: () => {}, removeItem: () => {} };
      function u() {
        let e = 'undefined' != typeof window && window.localStorage ? window.localStorage : l;
        return {
          getItem: (t) => e.getItem(t),
          removeItem(t) {
            e.removeItem(t);
          },
          setItem(t, n) {
            try {
              e.setItem(t, n);
            } catch {}
          },
        };
      }
    },
    75271: function (e, t, n) {
      'use strict';
      n.d(t, {
        G: function () {
          return l;
        },
      });
      var r,
        i,
        a = n(98291);
      let s = () => `@wagmi/core@${a.i}`;
      var o = function (e, t, n, r) {
        if ('a' === n && !r) throw TypeError('Private accessor was defined without a getter');
        if ('function' == typeof t ? e !== t || !r : !t.has(e))
          throw TypeError(
            'Cannot read private member from an object whose class did not declare it'
          );
        return 'm' === n ? r : 'a' === n ? r.call(e) : r ? r.value : t.get(e);
      };
      class l extends Error {
        get docsBaseUrl() {
          return 'https://wagmi.sh/core';
        }
        get version() {
          return s();
        }
        constructor(e, t = {}) {
          super(),
            r.add(this),
            Object.defineProperty(this, 'details', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, 'docsPath', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, 'metaMessages', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, 'shortMessage', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, 'name', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: 'WagmiCoreError',
            });
          let n =
              t.cause instanceof l
                ? t.cause.details
                : t.cause?.message
                  ? t.cause.message
                  : t.details,
            i = (t.cause instanceof l && t.cause.docsPath) || t.docsPath;
          (this.message = [
            e || 'An error occurred.',
            '',
            ...(t.metaMessages ? [...t.metaMessages, ''] : []),
            ...(i
              ? [`Docs: ${this.docsBaseUrl}${i}.html${t.docsSlug ? `#${t.docsSlug}` : ''}`]
              : []),
            ...(n ? [`Details: ${n}`] : []),
            `Version: ${this.version}`,
          ].join('\n')),
            t.cause && (this.cause = t.cause),
            (this.details = n),
            (this.docsPath = i),
            (this.metaMessages = t.metaMessages),
            (this.shortMessage = e);
        }
        walk(e) {
          return o(this, r, 'm', i).call(this, this, e);
        }
      }
      (r = new WeakSet()),
        (i = function e(t, n) {
          return n?.(t) ? t : t.cause ? o(this, r, 'm', e).call(this, t.cause, n) : t;
        });
    },
    88396: function (e, t, n) {
      'use strict';
      n.d(t, {
        $S: function () {
          return u;
        },
        JK: function () {
          return o;
        },
        X4: function () {
          return i;
        },
        XZ: function () {
          return l;
        },
        aH: function () {
          return s;
        },
        wi: function () {
          return a;
        },
      });
      var r = n(75271);
      class i extends r.G {
        constructor() {
          super('Chain not configured.'),
            Object.defineProperty(this, 'name', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: 'ChainNotConfiguredError',
            });
        }
      }
      class a extends r.G {
        constructor() {
          super('Connector already connected.'),
            Object.defineProperty(this, 'name', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: 'ConnectorAlreadyConnectedError',
            });
        }
      }
      class s extends r.G {
        constructor() {
          super('Connector not connected.'),
            Object.defineProperty(this, 'name', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: 'ConnectorNotConnectedError',
            });
        }
      }
      class o extends r.G {
        constructor({ address: e, connector: t }) {
          super(`Account "${e}" not found for connector "${t.name}".`),
            Object.defineProperty(this, 'name', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: 'ConnectorAccountNotFoundError',
            });
        }
      }
      class l extends r.G {
        constructor({ connectionChainId: e, connectorChainId: t }) {
          super(
            `The current chain of the connector (id: ${t}) does not match the connection's chain (id: ${e}).`,
            { metaMessages: [`Current Chain ID:  ${t}`, `Expected Chain ID: ${e}`] }
          ),
            Object.defineProperty(this, 'name', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: 'ConnectorChainMismatchError',
            });
        }
      }
      class u extends r.G {
        constructor({ connector: e }) {
          super(`Connector "${e.name}" unavailable while reconnecting.`, {
            details:
              'During the reconnection step, the only connector methods guaranteed to be available are: `id`, `name`, `type`, `uid`. All other methods are not guaranteed to be available until reconnection completes and connectors are fully restored. This error commonly occurs for connectors that asynchronously inject after reconnection has already started.',
          }),
            Object.defineProperty(this, 'name', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: 'ConnectorUnavailableReconnectingError',
            });
        }
      }
    },
    77406: function (e, t, n) {
      'use strict';
      n.d(t, {
        M: function () {
          return i;
        },
        O: function () {
          return a;
        },
      });
      var r = n(75271);
      class i extends r.G {
        constructor() {
          super('Provider not found.'),
            Object.defineProperty(this, 'name', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: 'ProviderNotFoundError',
            });
        }
      }
      class a extends r.G {
        constructor({ connector: e }) {
          super(`"${e.name}" does not support programmatic chain switching.`),
            Object.defineProperty(this, 'name', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: 'SwitchChainNotSupportedError',
            });
        }
      }
    },
    24755: function (e, t, n) {
      'use strict';
      n.d(t, {
        OP: function () {
          return o;
        },
        if: function () {
          return i;
        },
        kq: function () {
          return a;
        },
      });
      var r = n(53063);
      function i(e, t) {
        return (0, r.Q$)(e, t);
      }
      function a(e) {
        return JSON.stringify(e, (e, t) =>
          !(function (e) {
            if (!s(e)) return !1;
            let t = e.constructor;
            if (void 0 === t) return !0;
            let n = t.prototype;
            return !!(s(n) && n.hasOwnProperty('isPrototypeOf'));
          })(t)
            ? 'bigint' == typeof t
              ? t.toString()
              : t
            : Object.keys(t)
                .sort()
                .reduce((e, n) => ((e[n] = t[n]), e), {})
        );
      }
      function s(e) {
        return '[object Object]' === Object.prototype.toString.call(e);
      }
      function o(e) {
        let {
          _defaulted: t,
          behavior: n,
          gcTime: r,
          initialData: i,
          initialDataUpdatedAt: a,
          maxPages: s,
          meta: o,
          networkMode: l,
          queryFn: u,
          queryHash: c,
          queryKey: d,
          queryKeyHashFn: p,
          retry: h,
          retryDelay: y,
          structuralSharing: f,
          getPreviousPageParam: m,
          getNextPageParam: g,
          initialPageParam: b,
          _optimisticResults: w,
          enabled: v,
          notifyOnChangeProps: T,
          placeholderData: A,
          refetchInterval: E,
          refetchIntervalInBackground: C,
          refetchOnMount: _,
          refetchOnReconnect: I,
          refetchOnWindowFocus: S,
          retryOnMount: P,
          select: O,
          staleTime: N,
          suspense: x,
          throwOnError: M,
          config: k,
          connector: R,
          query: D,
          ...B
        } = e;
        return B;
      }
    },
    76018: function (e, t, n) {
      'use strict';
      n.d(t, {
        H: function () {
          return l;
        },
      });
      var r = n(18292),
        i = n(79e3),
        a = n(74118),
        s = n(30390),
        o = n(15077);
      function l(e, t = {}) {
        let { type: n } = e,
          { key: l = 'connector', name: u = 'Connector', retryDelay: c } = t;
        return (e) => {
          let { chain: d, connectors: p } = e,
            h = t.retryCount ?? e.retryCount,
            y = async ({ method: e, params: t }) => {
              let o = p?.getState().find((e) => e.type === n);
              if (!o)
                throw new r.u5(
                  Error(
                    `Could not find connector of type "${n}" in \`connectors\` passed to \`createConfig\`.`
                  )
                );
              let l = await o.getProvider({ chainId: d?.id });
              if (!l) throw new r.u5(Error('Provider is disconnected.'));
              let u = (0, i.ly)(
                await (0, a.J)(() =>
                  (0, s.F)(() => l.request({ method: 'eth_chainId' }), { timeout: 100 })
                )
              );
              if (d && u !== d.id)
                throw new r.I0(
                  Error(
                    `The current chain of the connector (id: ${u}) does not match the target chain for the request (id: ${d.id}  ${d.name}).`
                  )
                );
              return l.request({ method: e, params: t });
            };
          return (0, o.q)({
            key: l,
            name: u,
            request: y,
            retryCount: h,
            retryDelay: c,
            type: 'connector',
          });
        };
      }
    },
    388: function (e, t, n) {
      'use strict';
      n.d(t, {
        t: function () {
          return i;
        },
      });
      var r = n(22791);
      function i(e, t) {
        return (0, r.tv)(e, t);
      }
    },
    7327: function (e, t, n) {
      'use strict';
      n.d(t, {
        Dr: function () {
          return i;
        },
        jx: function () {
          return a;
        },
      });
      var r = n(98673);
      let i = {
        getItem: (e) => ('undefined' == typeof window ? null : (s(document.cookie, e) ?? null)),
        setItem(e, t) {
          'undefined' != typeof window && (document.cookie = `${e}=${t};path=/;samesite=Lax`);
        },
        removeItem(e) {
          'undefined' != typeof window && (document.cookie = `${e}=;max-age=-1;path=/`);
        },
      };
      function a(e, t) {
        if (!t) return;
        let n = s(t, `${e.storage?.key}.store`);
        if (n) return (0, r.v)(n).state;
      }
      function s(e, t) {
        let n = e.split('; ').find((e) => e.startsWith(`${t}=`));
        if (n) return n.substring(t.length + 1);
      }
    },
    18548: function (e, t, n) {
      'use strict';
      n.d(t, {
        v: function () {
          return function e(t, n) {
            if (t === n) return !0;
            if (t && n && 'object' == typeof t && 'object' == typeof n) {
              let r, i;
              if (t.constructor !== n.constructor) return !1;
              if (Array.isArray(t) && Array.isArray(n)) {
                if ((r = t.length) !== n.length) return !1;
                for (i = r; 0 != i--; ) if (!e(t[i], n[i])) return !1;
                return !0;
              }
              if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
              if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
              let a = Object.keys(t);
              if ((r = a.length) !== Object.keys(n).length) return !1;
              for (i = r; 0 != i--; ) if (!Object.prototype.hasOwnProperty.call(n, a[i])) return !1;
              for (i = r; 0 != i--; ) {
                let r = a[i];
                if (r && !e(t[r], n[r])) return !1;
              }
              return !0;
            }
            return t != t && n != n;
          };
        },
      });
    },
    98673: function (e, t, n) {
      'use strict';
      function r(e, t) {
        return JSON.parse(e, (e, n) => {
          let r = n;
          return (
            r?.__type === 'bigint' && (r = BigInt(r.value)),
            r?.__type === 'Map' && (r = new Map(r.value)),
            t?.(e, r) ?? r
          );
        });
      }
      n.d(t, {
        v: function () {
          return r;
        },
      });
    },
    28180: function (e, t, n) {
      'use strict';
      function r(e, t, n) {
        let r = e[t.name];
        if ('function' == typeof r) return r;
        let i = e[n];
        return 'function' == typeof i ? i : (n) => t(e, n);
      }
      n.d(t, {
        s: function () {
          return r;
        },
      });
    },
    6537: function (e, t, n) {
      'use strict';
      n.d(t, {
        W: function () {
          return i;
        },
      });
      var r = n(37457);
      function i(e) {
        return 'number' == typeof e ? e : 'wei' === e ? 0 : Math.abs(r.Bd[e]);
      }
    },
    98291: function (e, t, n) {
      'use strict';
      n.d(t, {
        i: function () {
          return r;
        },
      });
      let r = '2.17.0';
    },
    27305: function (e, t, n) {
      'use strict';
      function r() {}
      n.d(t, {
        e: function () {
          return i;
        },
      });
      class i {
        constructor(e = 1 / 0, t = r) {
          (this.max = e),
            (this.dispose = t),
            (this.map = new Map()),
            (this.newest = null),
            (this.oldest = null);
        }
        has(e) {
          return this.map.has(e);
        }
        get(e) {
          let t = this.getNode(e);
          return t && t.value;
        }
        get size() {
          return this.map.size;
        }
        getNode(e) {
          let t = this.map.get(e);
          if (t && t !== this.newest) {
            let { older: e, newer: n } = t;
            n && (n.older = e),
              e && (e.newer = n),
              (t.older = this.newest),
              (t.older.newer = t),
              (t.newer = null),
              (this.newest = t),
              t === this.oldest && (this.oldest = n);
          }
          return t;
        }
        set(e, t) {
          let n = this.getNode(e);
          return n
            ? (n.value = t)
            : ((n = { key: e, value: t, newer: null, older: this.newest }),
              this.newest && (this.newest.newer = n),
              (this.newest = n),
              (this.oldest = this.oldest || n),
              this.map.set(e, n),
              n.value);
        }
        clean() {
          for (; this.oldest && this.map.size > this.max; ) this.delete(this.oldest.key);
        }
        delete(e) {
          let t = this.map.get(e);
          return (
            !!t &&
            (t === this.newest && (this.newest = t.older),
            t === this.oldest && (this.oldest = t.newer),
            t.newer && (t.newer.older = t.older),
            t.older && (t.older.newer = t.newer),
            this.map.delete(e),
            this.dispose(t.value, e),
            !0)
          );
        }
      }
    },
    37811: function (e, t, n) {
      'use strict';
      function r() {}
      n.d(t, {
        k: function () {
          return o;
        },
      });
      let i =
          'undefined' != typeof WeakRef
            ? WeakRef
            : function (e) {
                return { deref: () => e };
              },
        a = 'undefined' != typeof WeakMap ? WeakMap : Map,
        s =
          'undefined' != typeof FinalizationRegistry
            ? FinalizationRegistry
            : function () {
                return { register: r, unregister: r };
              };
      class o {
        constructor(e = 1 / 0, t = r) {
          (this.max = e),
            (this.dispose = t),
            (this.map = new a()),
            (this.newest = null),
            (this.oldest = null),
            (this.unfinalizedNodes = new Set()),
            (this.finalizationScheduled = !1),
            (this.size = 0),
            (this.finalize = () => {
              let e = this.unfinalizedNodes.values();
              for (let t = 0; t < 10024; t++) {
                let t = e.next().value;
                if (!t) break;
                this.unfinalizedNodes.delete(t);
                let n = t.key;
                delete t.key, (t.keyRef = new i(n)), this.registry.register(n, t, t);
              }
              this.unfinalizedNodes.size > 0
                ? queueMicrotask(this.finalize)
                : (this.finalizationScheduled = !1);
            }),
            (this.registry = new s(this.deleteNode.bind(this)));
        }
        has(e) {
          return this.map.has(e);
        }
        get(e) {
          let t = this.getNode(e);
          return t && t.value;
        }
        getNode(e) {
          let t = this.map.get(e);
          if (t && t !== this.newest) {
            let { older: e, newer: n } = t;
            n && (n.older = e),
              e && (e.newer = n),
              (t.older = this.newest),
              (t.older.newer = t),
              (t.newer = null),
              (this.newest = t),
              t === this.oldest && (this.oldest = n);
          }
          return t;
        }
        set(e, t) {
          let n = this.getNode(e);
          return n
            ? (n.value = t)
            : ((n = { key: e, value: t, newer: null, older: this.newest }),
              this.newest && (this.newest.newer = n),
              (this.newest = n),
              (this.oldest = this.oldest || n),
              this.scheduleFinalization(n),
              this.map.set(e, n),
              this.size++,
              n.value);
        }
        clean() {
          for (; this.oldest && this.size > this.max; ) this.deleteNode(this.oldest);
        }
        deleteNode(e) {
          e === this.newest && (this.newest = e.older),
            e === this.oldest && (this.oldest = e.newer),
            e.newer && (e.newer.older = e.older),
            e.older && (e.older.newer = e.newer),
            this.size--;
          let t = e.key || (e.keyRef && e.keyRef.deref());
          this.dispose(e.value, t),
            e.keyRef ? this.registry.unregister(e) : this.unfinalizedNodes.delete(e),
            t && this.map.delete(t);
        }
        delete(e) {
          let t = this.map.get(e);
          return !!t && (this.deleteNode(t), !0);
        }
        scheduleFinalization(e) {
          this.unfinalizedNodes.add(e),
            this.finalizationScheduled ||
              ((this.finalizationScheduled = !0), queueMicrotask(this.finalize));
        }
      }
    },
    84539: function (e, t, n) {
      'use strict';
      n.d(t, {
        D: function () {
          return o;
        },
      });
      let { toString: r, hasOwnProperty: i } = Object.prototype,
        a = Function.prototype.toString,
        s = new Map();
      function o(e, t) {
        try {
          return (function e(t, n) {
            if (t === n) return !0;
            let s = r.call(t);
            if (s !== r.call(n)) return !1;
            switch (s) {
              case '[object Array]':
                if (t.length !== n.length) break;
              case '[object Object]': {
                if (d(t, n)) return !0;
                let r = l(t),
                  a = l(n),
                  s = r.length;
                if (s !== a.length) return !1;
                for (let e = 0; e < s; ++e) if (!i.call(n, r[e])) return !1;
                for (let i = 0; i < s; ++i) {
                  let a = r[i];
                  if (!e(t[a], n[a])) return !1;
                }
                return !0;
              }
              case '[object Error]':
                return t.name === n.name && t.message === n.message;
              case '[object Number]':
                if (t != t) return n != n;
              case '[object Boolean]':
              case '[object Date]':
                return +t == +n;
              case '[object RegExp]':
              case '[object String]':
                return t == `${n}`;
              case '[object Map]':
              case '[object Set]': {
                if (t.size !== n.size) return !1;
                if (d(t, n)) return !0;
                let r = t.entries(),
                  i = '[object Map]' === s;
                for (;;) {
                  let t = r.next();
                  if (t.done) break;
                  let [a, s] = t.value;
                  if (!n.has(a) || (i && !e(s, n.get(a)))) return !1;
                }
                return !0;
              }
              case '[object Uint16Array]':
              case '[object Uint8Array]':
              case '[object Uint32Array]':
              case '[object Int32Array]':
              case '[object Int8Array]':
              case '[object Int16Array]':
              case '[object ArrayBuffer]':
                (t = new Uint8Array(t)), (n = new Uint8Array(n));
              case '[object DataView]': {
                let e = t.byteLength;
                if (e === n.byteLength) for (; e-- && t[e] === n[e]; );
                return -1 === e;
              }
              case '[object AsyncFunction]':
              case '[object GeneratorFunction]':
              case '[object AsyncGeneratorFunction]':
              case '[object Function]': {
                let e = a.call(t);
                if (e !== a.call(n)) return !1;
                return !(function (e, t) {
                  let n = e.length - t.length;
                  return n >= 0 && e.indexOf(t, n) === n;
                })(e, c);
              }
            }
            return !1;
          })(e, t);
        } finally {
          s.clear();
        }
      }
      function l(e) {
        return Object.keys(e).filter(u, e);
      }
      function u(e) {
        return void 0 !== this[e];
      }
      t.Z = o;
      let c = '{ [native code] }';
      function d(e, t) {
        let n = s.get(e);
        if (n) {
          if (n.has(t)) return !0;
        } else s.set(e, (n = new Set()));
        return n.add(t), !1;
      }
    },
    68944: function (e, t, n) {
      'use strict';
      n.d(t, {
        B: function () {
          return o;
        },
      });
      let r = () => Object.create(null),
        { forEach: i, slice: a } = Array.prototype,
        { hasOwnProperty: s } = Object.prototype;
      class o {
        constructor(e = !0, t = r) {
          (this.weakness = e), (this.makeData = t);
        }
        lookup() {
          return this.lookupArray(arguments);
        }
        lookupArray(e) {
          let t = this;
          return (
            i.call(e, (e) => (t = t.getChildTrie(e))),
            s.call(t, 'data') ? t.data : (t.data = this.makeData(a.call(e)))
          );
        }
        peek() {
          return this.peekArray(arguments);
        }
        peekArray(e) {
          let t = this;
          for (let n = 0, r = e.length; t && n < r; ++n) {
            let r = t.mapFor(e[n], !1);
            t = r && r.get(e[n]);
          }
          return t && t.data;
        }
        remove() {
          return this.removeArray(arguments);
        }
        removeArray(e) {
          let t;
          if (e.length) {
            let n = e[0],
              r = this.mapFor(n, !1),
              i = r && r.get(n);
            !i ||
              ((t = i.removeArray(a.call(e, 1))),
              i.data || i.weak || (i.strong && i.strong.size) || r.delete(n));
          } else (t = this.data), delete this.data;
          return t;
        }
        getChildTrie(e) {
          let t = this.mapFor(e, !0),
            n = t.get(e);
          return n || t.set(e, (n = new o(this.weakness, this.makeData))), n;
        }
        mapFor(e, t) {
          return this.weakness &&
            (function (e) {
              switch (typeof e) {
                case 'object':
                  if (null === e) break;
                case 'function':
                  return !0;
              }
              return !1;
            })(e)
            ? this.weak || (t ? (this.weak = new WeakMap()) : void 0)
            : this.strong || (t ? (this.strong = new Map()) : void 0);
        }
      }
    },
    63632: function (e, t, n) {
      'use strict';
      n.d(t, {
        G: function () {
          return r;
        },
      });
      class r extends Error {
        constructor(e, t = {}) {
          let n =
              t.cause instanceof r
                ? t.cause.details
                : t.cause?.message
                  ? t.cause.message
                  : t.details,
            i = (t.cause instanceof r && t.cause.docsPath) || t.docsPath;
          super(
            [
              e || 'An error occurred.',
              '',
              ...(t.metaMessages ? [...t.metaMessages, ''] : []),
              ...(i ? [`Docs: https://abitype.dev${i}`] : []),
              ...(n ? [`Details: ${n}`] : []),
              'Version: abitype@1.0.8',
            ].join('\n')
          ),
            Object.defineProperty(this, 'details', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, 'docsPath', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, 'metaMessages', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, 'shortMessage', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, 'name', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: 'AbiTypeError',
            }),
            t.cause && (this.cause = t.cause),
            (this.details = n),
            (this.docsPath = i),
            (this.metaMessages = t.metaMessages),
            (this.shortMessage = e);
        }
      }
    },
    68915: function (e, t, n) {
      'use strict';
      n.d(t, {
        F: function () {
          return a;
        },
        Hk: function () {
          return s;
        },
        a_: function () {
          return i;
        },
      });
      var r = n(63632);
      class i extends r.G {
        constructor({ signature: e }) {
          super('Failed to parse ABI item.', {
            details: `parseAbiItem(${JSON.stringify(e, null, 2)})`,
            docsPath: '/api/human#parseabiitem-1',
          }),
            Object.defineProperty(this, 'name', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: 'InvalidAbiItemError',
            });
        }
      }
      class a extends r.G {
        constructor({ type: e }) {
          super('Unknown type.', {
            metaMessages: [
              `Type "${e}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`,
            ],
          }),
            Object.defineProperty(this, 'name', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: 'UnknownTypeError',
            });
        }
      }
      class s extends r.G {
        constructor({ type: e }) {
          super('Unknown type.', { metaMessages: [`Type "${e}" is not a valid ABI type.`] }),
            Object.defineProperty(this, 'name', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: 'UnknownSolidityTypeError',
            });
        }
      }
    },
    50545: function (e, t, n) {
      'use strict';
      n.d(t, {
        TT: function () {
          return a;
        },
        _D: function () {
          return o;
        },
        aZ: function () {
          return l;
        },
        jO: function () {
          return i;
        },
        zL: function () {
          return s;
        },
      });
      var r = n(63632);
      class i extends r.G {
        constructor({ param: e }) {
          super('Invalid ABI parameter.', { details: e }),
            Object.defineProperty(this, 'name', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: 'InvalidParameterError',
            });
        }
      }
      class a extends r.G {
        constructor({ param: e, name: t }) {
          super('Invalid ABI parameter.', {
            details: e,
            metaMessages: [
              `"${t}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`,
            ],
          }),
            Object.defineProperty(this, 'name', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: 'SolidityProtectedKeywordError',
            });
        }
      }
      class s extends r.G {
        constructor({ param: e, type: t, modifier: n }) {
          super('Invalid ABI parameter.', {
            details: e,
            metaMessages: [`Modifier "${n}" not allowed${t ? ` in "${t}" type` : ''}.`],
          }),
            Object.defineProperty(this, 'name', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: 'InvalidModifierError',
            });
        }
      }
      class o extends r.G {
        constructor({ param: e, type: t, modifier: n }) {
          super('Invalid ABI parameter.', {
            details: e,
            metaMessages: [
              `Modifier "${n}" not allowed${t ? ` in "${t}" type` : ''}.`,
              `Data location can only be specified for array, struct, or mapping types, but "${n}" was given.`,
            ],
          }),
            Object.defineProperty(this, 'name', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: 'InvalidFunctionModifierError',
            });
        }
      }
      class l extends r.G {
        constructor({ abiParameter: e }) {
          super('Invalid ABI parameter.', {
            details: JSON.stringify(e, null, 2),
            metaMessages: ['ABI parameter type is invalid.'],
          }),
            Object.defineProperty(this, 'name', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: 'InvalidAbiTypeParameterError',
            });
        }
      }
    },
    1461: function (e, t, n) {
      'use strict';
      n.d(t, {
        H6: function () {
          return s;
        },
        Vs: function () {
          return a;
        },
        wn: function () {
          return i;
        },
      });
      var r = n(63632);
      class i extends r.G {
        constructor({ signature: e, type: t }) {
          super(`Invalid ${t} signature.`, { details: e }),
            Object.defineProperty(this, 'name', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: 'InvalidSignatureError',
            });
        }
      }
      class a extends r.G {
        constructor({ signature: e }) {
          super('Unknown signature.', { details: e }),
            Object.defineProperty(this, 'name', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: 'UnknownSignatureError',
            });
        }
      }
      class s extends r.G {
        constructor({ signature: e }) {
          super('Invalid struct signature.', {
            details: e,
            metaMessages: ['No properties exist.'],
          }),
            Object.defineProperty(this, 'name', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: 'InvalidStructSignatureError',
            });
        }
      }
    },
    56606: function (e, t, n) {
      'use strict';
      n.d(t, {
        t: function () {
          return i;
        },
      });
      var r = n(24056);
      function i(e) {
        return 'function' === e.type
          ? `function ${e.name}(${(0, r.P)(e.inputs)})${e.stateMutability && 'nonpayable' !== e.stateMutability ? ` ${e.stateMutability}` : ''}${e.outputs?.length ? ` returns (${(0, r.P)(e.outputs)})` : ''}`
          : 'event' === e.type
            ? `event ${e.name}(${(0, r.P)(e.inputs)})`
            : 'error' === e.type
              ? `error ${e.name}(${(0, r.P)(e.inputs)})`
              : 'constructor' === e.type
                ? `constructor(${(0, r.P)(e.inputs)})${'payable' === e.stateMutability ? ' payable' : ''}`
                : 'fallback' === e.type
                  ? `fallback() external${'payable' === e.stateMutability ? ' payable' : ''}`
                  : 'receive() external payable';
      }
    },
    24056: function (e, t, n) {
      'use strict';
      n.d(t, {
        P: function () {
          return a;
        },
      });
      var r = n(42689);
      let i = /^tuple(?<array>(\[(\d*)\])*)$/;
      function a(e) {
        let t = '',
          n = e.length;
        for (let a = 0; a < n; a++)
          (t += (function e(t) {
            let n = t.type;
            if (i.test(t.type) && 'components' in t) {
              n = '(';
              let a = t.components.length;
              for (let r = 0; r < a; r++) (n += e(t.components[r])), r < a - 1 && (n += ', ');
              let s = (0, r.Zw)(i, t.type);
              return (n += `)${s?.array ?? ''}`), e({ ...t, type: n });
            }
            return ('indexed' in t && t.indexed && (n = `${n} indexed`), t.name)
              ? `${n} ${t.name}`
              : n;
          })(e[a])),
            a !== n - 1 && (t += ', ');
        return t;
      }
    },
    86183: function (e, t, n) {
      'use strict';
      n.d(t, {
        Dt: function () {
          return _;
        },
        EC: function () {
          return v;
        },
        N0: function () {
          return y;
        },
        PI: function () {
          return b;
        },
        QM: function () {
          return E;
        },
        SA: function () {
          return s;
        },
        Wg: function () {
          return C;
        },
        _c: function () {
          return a;
        },
        a4: function () {
          return g;
        },
        c3: function () {
          return l;
        },
        g1: function () {
          return f;
        },
        l$: function () {
          return p;
        },
        qm: function () {
          return T;
        },
        rh: function () {
          return d;
        },
        wA: function () {
          return u;
        },
      });
      var r = n(42689);
      let i = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
      function a(e) {
        return i.test(e);
      }
      function s(e) {
        return (0, r.Zw)(i, e);
      }
      let o = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
      function l(e) {
        return o.test(e);
      }
      function u(e) {
        return (0, r.Zw)(o, e);
      }
      let c =
        /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
      function d(e) {
        return c.test(e);
      }
      function p(e) {
        return (0, r.Zw)(c, e);
      }
      let h = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
      function y(e) {
        return h.test(e);
      }
      function f(e) {
        return (0, r.Zw)(h, e);
      }
      let m = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
      function g(e) {
        return m.test(e);
      }
      function b(e) {
        return (0, r.Zw)(m, e);
      }
      let w = /^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/;
      function v(e) {
        return w.test(e);
      }
      function T(e) {
        return (0, r.Zw)(w, e);
      }
      let A = /^receive\(\) external payable$/;
      function E(e) {
        return A.test(e);
      }
      let C = new Set(['indexed']),
        _ = new Set(['calldata', 'memory', 'storage']);
    },
    24347: function (e, t, n) {
      'use strict';
      n.d(t, {
        D: function () {
          return d;
        },
      });
      var r = n(42689),
        i = n(68915),
        a = n(50545),
        s = n(1461),
        o = n(63632);
      class l extends o.G {
        constructor({ type: e }) {
          super('Circular reference detected.', {
            metaMessages: [`Struct "${e}" is a circular reference.`],
          }),
            Object.defineProperty(this, 'name', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: 'CircularReferenceError',
            });
        }
      }
      var u = n(86183),
        c = n(11813);
      function d(e) {
        let t = {},
          n = e.length;
        for (let r = 0; r < n; r++) {
          let n = e[r];
          if (!(0, u.N0)(n)) continue;
          let i = (0, u.g1)(n);
          if (!i) throw new s.wn({ signature: n, type: 'struct' });
          let a = i.properties.split(';'),
            o = [],
            l = a.length;
          for (let e = 0; e < l; e++) {
            let t = a[e].trim();
            if (!t) continue;
            let n = (0, c.C$)(t, { type: 'struct' });
            o.push(n);
          }
          if (!o.length) throw new s.H6({ signature: n });
          t[i.name] = o;
        }
        let o = {},
          d = Object.entries(t),
          h = d.length;
        for (let e = 0; e < h; e++) {
          let [n, s] = d[e];
          o[n] = (function e(t, n, s = new Set()) {
            let o = [],
              u = t.length;
            for (let d = 0; d < u; d++) {
              let u = t[d];
              if (r.cN.test(u.type)) o.push(u);
              else {
                let t = (0, r.Zw)(p, u.type);
                if (!t?.type) throw new a.aZ({ abiParameter: u });
                let { array: d, type: h } = t;
                if (h in n) {
                  if (s.has(h)) throw new l({ type: h });
                  o.push({
                    ...u,
                    type: `tuple${d ?? ''}`,
                    components: e(n[h] ?? [], n, new Set([...s, h])),
                  });
                } else if ((0, c.uN)(h)) o.push(u);
                else throw new i.F({ type: h });
              }
            }
            return o;
          })(s, t);
        }
        return o;
      }
      let p = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
    },
    11813: function (e, t, n) {
      'use strict';
      n.d(t, {
        uN: function () {
          return g;
        },
        C$: function () {
          return f;
        },
        cK: function () {
          return d;
        },
      });
      var r = n(42689),
        i = n(68915),
        a = n(50545),
        s = n(1461),
        o = n(63632);
      class l extends o.G {
        constructor({ current: e, depth: t }) {
          super('Unbalanced parentheses.', {
            metaMessages: [
              `"${e.trim()}" has too many ${t > 0 ? 'opening' : 'closing'} parentheses.`,
            ],
            details: `Depth "${t}"`,
          }),
            Object.defineProperty(this, 'name', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: 'InvalidParenthesisError',
            });
        }
      }
      let u = new Map([
        ['address', { type: 'address' }],
        ['bool', { type: 'bool' }],
        ['bytes', { type: 'bytes' }],
        ['bytes32', { type: 'bytes32' }],
        ['int', { type: 'int256' }],
        ['int256', { type: 'int256' }],
        ['string', { type: 'string' }],
        ['uint', { type: 'uint256' }],
        ['uint8', { type: 'uint8' }],
        ['uint16', { type: 'uint16' }],
        ['uint24', { type: 'uint24' }],
        ['uint32', { type: 'uint32' }],
        ['uint64', { type: 'uint64' }],
        ['uint96', { type: 'uint96' }],
        ['uint112', { type: 'uint112' }],
        ['uint160', { type: 'uint160' }],
        ['uint192', { type: 'uint192' }],
        ['uint256', { type: 'uint256' }],
        ['address owner', { type: 'address', name: 'owner' }],
        ['address to', { type: 'address', name: 'to' }],
        ['bool approved', { type: 'bool', name: 'approved' }],
        ['bytes _data', { type: 'bytes', name: '_data' }],
        ['bytes data', { type: 'bytes', name: 'data' }],
        ['bytes signature', { type: 'bytes', name: 'signature' }],
        ['bytes32 hash', { type: 'bytes32', name: 'hash' }],
        ['bytes32 r', { type: 'bytes32', name: 'r' }],
        ['bytes32 root', { type: 'bytes32', name: 'root' }],
        ['bytes32 s', { type: 'bytes32', name: 's' }],
        ['string name', { type: 'string', name: 'name' }],
        ['string symbol', { type: 'string', name: 'symbol' }],
        ['string tokenURI', { type: 'string', name: 'tokenURI' }],
        ['uint tokenId', { type: 'uint256', name: 'tokenId' }],
        ['uint8 v', { type: 'uint8', name: 'v' }],
        ['uint256 balance', { type: 'uint256', name: 'balance' }],
        ['uint256 tokenId', { type: 'uint256', name: 'tokenId' }],
        ['uint256 value', { type: 'uint256', name: 'value' }],
        ['event:address indexed from', { type: 'address', name: 'from', indexed: !0 }],
        ['event:address indexed to', { type: 'address', name: 'to', indexed: !0 }],
        ['event:uint indexed tokenId', { type: 'uint256', name: 'tokenId', indexed: !0 }],
        ['event:uint256 indexed tokenId', { type: 'uint256', name: 'tokenId', indexed: !0 }],
      ]);
      var c = n(86183);
      function d(e, t = {}) {
        if ((0, c.rh)(e))
          return (function (e, t = {}) {
            let n = (0, c.l$)(e);
            if (!n) throw new s.wn({ signature: e, type: 'function' });
            let r = m(n.parameters),
              i = [],
              a = r.length;
            for (let e = 0; e < a; e++)
              i.push(f(r[e], { modifiers: c.Dt, structs: t, type: 'function' }));
            let o = [];
            if (n.returns) {
              let e = m(n.returns),
                r = e.length;
              for (let n = 0; n < r; n++)
                o.push(f(e[n], { modifiers: c.Dt, structs: t, type: 'function' }));
            }
            return {
              name: n.name,
              type: 'function',
              stateMutability: n.stateMutability ?? 'nonpayable',
              inputs: i,
              outputs: o,
            };
          })(e, t);
        if ((0, c.c3)(e))
          return (function (e, t = {}) {
            let n = (0, c.wA)(e);
            if (!n) throw new s.wn({ signature: e, type: 'event' });
            let r = m(n.parameters),
              i = [],
              a = r.length;
            for (let e = 0; e < a; e++)
              i.push(f(r[e], { modifiers: c.Wg, structs: t, type: 'event' }));
            return { name: n.name, type: 'event', inputs: i };
          })(e, t);
        if ((0, c._c)(e))
          return (function (e, t = {}) {
            let n = (0, c.SA)(e);
            if (!n) throw new s.wn({ signature: e, type: 'error' });
            let r = m(n.parameters),
              i = [],
              a = r.length;
            for (let e = 0; e < a; e++) i.push(f(r[e], { structs: t, type: 'error' }));
            return { name: n.name, type: 'error', inputs: i };
          })(e, t);
        if ((0, c.a4)(e))
          return (function (e, t = {}) {
            let n = (0, c.PI)(e);
            if (!n) throw new s.wn({ signature: e, type: 'constructor' });
            let r = m(n.parameters),
              i = [],
              a = r.length;
            for (let e = 0; e < a; e++) i.push(f(r[e], { structs: t, type: 'constructor' }));
            return {
              type: 'constructor',
              stateMutability: n.stateMutability ?? 'nonpayable',
              inputs: i,
            };
          })(e, t);
        if ((0, c.EC)(e))
          return (function (e) {
            let t = (0, c.qm)(e);
            if (!t) throw new s.wn({ signature: e, type: 'fallback' });
            return { type: 'fallback', stateMutability: t.stateMutability ?? 'nonpayable' };
          })(e);
        if ((0, c.QM)(e)) return { type: 'receive', stateMutability: 'payable' };
        throw new s.Vs({ signature: e });
      }
      let p =
          /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/,
        h =
          /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/,
        y = /^u?int$/;
      function f(e, t) {
        var n, s;
        let o;
        let l = (function (e, t, n) {
          let r = '';
          if (n)
            for (let e of Object.entries(n)) {
              if (!e) continue;
              let t = '';
              for (let n of e[1]) t += `[${n.type}${n.name ? `:${n.name}` : ''}]`;
              r += `(${e[0]}{${t}})`;
            }
          return t ? `${t}:${e}${r}` : e;
        })(e, t?.type, t?.structs);
        if (u.has(l)) return u.get(l);
        let d = r.cN.test(e),
          w = (0, r.Zw)(d ? h : p, e);
        if (!w) throw new a.jO({ param: e });
        if (
          w.name &&
          ('address' === (n = w.name) ||
            'bool' === n ||
            'function' === n ||
            'string' === n ||
            'tuple' === n ||
            r.eL.test(n) ||
            r.lh.test(n) ||
            b.test(n))
        )
          throw new a.TT({ param: e, name: w.name });
        let v = w.name ? { name: w.name } : {},
          T = 'indexed' === w.modifier ? { indexed: !0 } : {},
          A = t?.structs ?? {},
          E = {};
        if (d) {
          o = 'tuple';
          let e = m(w.type),
            t = [],
            n = e.length;
          for (let r = 0; r < n; r++) t.push(f(e[r], { structs: A }));
          E = { components: t };
        } else if (w.type in A) (o = 'tuple'), (E = { components: A[w.type] });
        else if (y.test(w.type)) o = `${w.type}256`;
        else if (((o = w.type), t?.type !== 'struct' && !g(o))) throw new i.Hk({ type: o });
        if (w.modifier) {
          if (!t?.modifiers?.has?.(w.modifier))
            throw new a.zL({ param: e, type: t?.type, modifier: w.modifier });
          if (
            c.Dt.has(w.modifier) &&
            ((s = o), !w.array && 'bytes' !== s && 'string' !== s && 'tuple' !== s)
          )
            throw new a._D({ param: e, type: t?.type, modifier: w.modifier });
        }
        let C = { type: `${o}${w.array ?? ''}`, ...v, ...T, ...E };
        return u.set(l, C), C;
      }
      function m(e, t = [], n = '', r = 0) {
        let i = e.trim().length;
        for (let a = 0; a < i; a++) {
          let i = e[a],
            s = e.slice(a + 1);
          switch (i) {
            case ',':
              return 0 === r ? m(s, [...t, n.trim()]) : m(s, t, `${n}${i}`, r);
            case '(':
              return m(s, t, `${n}${i}`, r + 1);
            case ')':
              return m(s, t, `${n}${i}`, r - 1);
            default:
              return m(s, t, `${n}${i}`, r);
          }
        }
        if ('' === n) return t;
        if (0 !== r) throw new l({ current: n, depth: r });
        return t.push(n.trim()), t;
      }
      function g(e) {
        return (
          'address' === e ||
          'bool' === e ||
          'function' === e ||
          'string' === e ||
          r.eL.test(e) ||
          r.lh.test(e)
        );
      }
      let b =
        /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
    },
    42689: function (e, t, n) {
      'use strict';
      function r(e, t) {
        let n = e.exec(t);
        return n?.groups;
      }
      n.d(t, {
        Zw: function () {
          return r;
        },
        cN: function () {
          return s;
        },
        eL: function () {
          return i;
        },
        lh: function () {
          return a;
        },
      });
      let i = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,
        a =
          /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/,
        s = /^\(.+?\).*?$/;
    },
    96169: function (e, t, n) {
      'use strict';
      n.d(t, {
        Z: function () {
          return r;
        },
      });
      var r = (function (e) {
        if (e.length >= 255) throw TypeError('Alphabet too long');
        let t = new Uint8Array(256);
        for (let e = 0; e < t.length; e++) t[e] = 255;
        for (let n = 0; n < e.length; n++) {
          let r = e.charAt(n),
            i = r.charCodeAt(0);
          if (255 !== t[i]) throw TypeError(r + ' is ambiguous');
          t[i] = n;
        }
        let n = e.length,
          r = e.charAt(0),
          i = Math.log(n) / Math.log(256),
          a = Math.log(256) / Math.log(n);
        function s(e) {
          if ('string' != typeof e) throw TypeError('Expected String');
          if (0 === e.length) return new Uint8Array();
          let a = 0,
            s = 0,
            o = 0;
          for (; e[a] === r; ) s++, a++;
          let l = ((e.length - a) * i + 1) >>> 0,
            u = new Uint8Array(l);
          for (; a < e.length; ) {
            let r = e.charCodeAt(a);
            if (r > 255) return;
            let i = t[r];
            if (255 === i) return;
            let s = 0;
            for (let e = l - 1; (0 !== i || s < o) && -1 !== e; e--, s++)
              (i += (n * u[e]) >>> 0), (u[e] = i % 256 >>> 0), (i = (i / 256) >>> 0);
            if (0 !== i) throw Error('Non-zero carry');
            (o = s), a++;
          }
          let c = l - o;
          for (; c !== l && 0 === u[c]; ) c++;
          let d = new Uint8Array(s + (l - c)),
            p = s;
          for (; c !== l; ) d[p++] = u[c++];
          return d;
        }
        return {
          encode: function (t) {
            if (
              (t instanceof Uint8Array ||
                (ArrayBuffer.isView(t)
                  ? (t = new Uint8Array(t.buffer, t.byteOffset, t.byteLength))
                  : Array.isArray(t) && (t = Uint8Array.from(t))),
              !(t instanceof Uint8Array))
            )
              throw TypeError('Expected Uint8Array');
            if (0 === t.length) return '';
            let i = 0,
              s = 0,
              o = 0,
              l = t.length;
            for (; o !== l && 0 === t[o]; ) o++, i++;
            let u = ((l - o) * a + 1) >>> 0,
              c = new Uint8Array(u);
            for (; o !== l; ) {
              let e = t[o],
                r = 0;
              for (let t = u - 1; (0 !== e || r < s) && -1 !== t; t--, r++)
                (e += (256 * c[t]) >>> 0), (c[t] = e % n >>> 0), (e = (e / n) >>> 0);
              if (0 !== e) throw Error('Non-zero carry');
              (s = r), o++;
            }
            let d = u - s;
            for (; d !== u && 0 === c[d]; ) d++;
            let p = r.repeat(i);
            for (; d < u; ++d) p += e.charAt(c[d]);
            return p;
          },
          decodeUnsafe: s,
          decode: function (e) {
            let t = s(e);
            if (t) return t;
            throw Error('Non-base' + n + ' character');
          },
        };
      })('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');
    },
    66467: function (e, t, n) {
      'use strict';
      n.d(t, {
        v: function () {
          return r;
        },
      });
      var r = n(47869);
    },
    89304: function (e, t, n) {
      'use strict';
      function r(e, t) {
        if (!e) throw Error(t);
      }
      n.d(t, {
        a: function () {
          return r;
        },
      });
    },
    14208: function (e, t, n) {
      'use strict';
      function r(e) {
        return (function e(t, n) {
          switch (typeof t) {
            case 'string':
              return JSON.stringify(t);
            case 'function':
              return t.name ? `[function ${t.name}]` : '[function]';
            case 'object':
              return (function (t, n) {
                if (null === t) return 'null';
                if (n.includes(t)) return '[Circular]';
                let r = [...n, t];
                if ('function' == typeof t.toJSON) {
                  let n = t.toJSON();
                  if (n !== t) return 'string' == typeof n ? n : e(n, r);
                } else if (Array.isArray(t))
                  return (function (t, n) {
                    if (0 === t.length) return '[]';
                    if (n.length > 2) return '[Array]';
                    let r = Math.min(10, t.length),
                      i = t.length - r,
                      a = [];
                    for (let i = 0; i < r; ++i) a.push(e(t[i], n));
                    return (
                      1 === i ? a.push('... 1 more item') : i > 1 && a.push(`... ${i} more items`),
                      '[' + a.join(', ') + ']'
                    );
                  })(t, r);
                return (function (t, n) {
                  let r = Object.entries(t);
                  return 0 === r.length
                    ? '{}'
                    : n.length > 2
                      ? '[' +
                        (function (e) {
                          let t = Object.prototype.toString
                            .call(e)
                            .replace(/^\[object /, '')
                            .replace(/]$/, '');
                          if ('Object' === t && 'function' == typeof e.constructor) {
                            let t = e.constructor.name;
                            if ('string' == typeof t && '' !== t) return t;
                          }
                          return t;
                        })(t) +
                        ']'
                      : '{ ' + r.map(([t, r]) => t + ': ' + e(r, n)).join(', ') + ' }';
                })(t, r);
              })(t, n);
            default:
              return String(t);
          }
        })(e, []);
      }
      n.d(t, {
        X: function () {
          return r;
        },
      });
    },
    57564: function (e, t, n) {
      'use strict';
      var r, i;
      n.d(t, {
        UG: function () {
          return u;
        },
        WU: function () {
          return s;
        },
        Ye: function () {
          return a;
        },
        h8: function () {
          return o;
        },
        ku: function () {
          return r;
        },
      });
      class a {
        constructor(e, t, n) {
          (this.start = e.start),
            (this.end = t.end),
            (this.startToken = e),
            (this.endToken = t),
            (this.source = n);
        }
        get [Symbol.toStringTag]() {
          return 'Location';
        }
        toJSON() {
          return { start: this.start, end: this.end };
        }
      }
      class s {
        constructor(e, t, n, r, i, a) {
          (this.kind = e),
            (this.start = t),
            (this.end = n),
            (this.line = r),
            (this.column = i),
            (this.value = a),
            (this.prev = null),
            (this.next = null);
        }
        get [Symbol.toStringTag]() {
          return 'Token';
        }
        toJSON() {
          return { kind: this.kind, value: this.value, line: this.line, column: this.column };
        }
      }
      let o = {
          Name: [],
          Document: ['definitions'],
          OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],
          VariableDefinition: ['variable', 'type', 'defaultValue', 'directives'],
          Variable: ['name'],
          SelectionSet: ['selections'],
          Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],
          Argument: ['name', 'value'],
          FragmentSpread: ['name', 'directives'],
          InlineFragment: ['typeCondition', 'directives', 'selectionSet'],
          FragmentDefinition: [
            'name',
            'variableDefinitions',
            'typeCondition',
            'directives',
            'selectionSet',
          ],
          IntValue: [],
          FloatValue: [],
          StringValue: [],
          BooleanValue: [],
          NullValue: [],
          EnumValue: [],
          ListValue: ['values'],
          ObjectValue: ['fields'],
          ObjectField: ['name', 'value'],
          Directive: ['name', 'arguments'],
          NamedType: ['name'],
          ListType: ['type'],
          NonNullType: ['type'],
          SchemaDefinition: ['description', 'directives', 'operationTypes'],
          OperationTypeDefinition: ['type'],
          ScalarTypeDefinition: ['description', 'name', 'directives'],
          ObjectTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],
          FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],
          InputValueDefinition: ['description', 'name', 'type', 'defaultValue', 'directives'],
          InterfaceTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],
          UnionTypeDefinition: ['description', 'name', 'directives', 'types'],
          EnumTypeDefinition: ['description', 'name', 'directives', 'values'],
          EnumValueDefinition: ['description', 'name', 'directives'],
          InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],
          DirectiveDefinition: ['description', 'name', 'arguments', 'locations'],
          SchemaExtension: ['directives', 'operationTypes'],
          ScalarTypeExtension: ['name', 'directives'],
          ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],
          InterfaceTypeExtension: ['name', 'interfaces', 'directives', 'fields'],
          UnionTypeExtension: ['name', 'directives', 'types'],
          EnumTypeExtension: ['name', 'directives', 'values'],
          InputObjectTypeExtension: ['name', 'directives', 'fields'],
        },
        l = new Set(Object.keys(o));
      function u(e) {
        let t = null == e ? void 0 : e.kind;
        return 'string' == typeof t && l.has(t);
      }
      ((i = r || (r = {})).QUERY = 'query'),
        (i.MUTATION = 'mutation'),
        (i.SUBSCRIPTION = 'subscription');
    },
    67728: function (e, t, n) {
      'use strict';
      n.d(t, {
        LZ: function () {
          return a;
        },
        wv: function () {
          return i;
        },
      });
      var r = n(3069);
      function i(e) {
        var t, n;
        let i = Number.MAX_SAFE_INTEGER,
          a = null,
          s = -1;
        for (let t = 0; t < e.length; ++t) {
          let o = e[t],
            l = (function (e) {
              let t = 0;
              for (; t < e.length && (0, r.FD)(e.charCodeAt(t)); ) ++t;
              return t;
            })(o);
          l !== o.length &&
            ((a = null !== (n = a) && void 0 !== n ? n : t), (s = t), 0 !== t && l < i && (i = l));
        }
        return e
          .map((e, t) => (0 === t ? e : e.slice(i)))
          .slice(null !== (t = a) && void 0 !== t ? t : 0, s + 1);
      }
      function a(e, t) {
        let n = e.replace(/"""/g, '\\"""'),
          i = n.split(/\r\n|[\n\r]/g),
          a = 1 === i.length,
          s = i.length > 1 && i.slice(1).every((e) => 0 === e.length || (0, r.FD)(e.charCodeAt(0))),
          o = n.endsWith('\\"""'),
          l = e.endsWith('"') && !o,
          u = e.endsWith('\\'),
          c = l || u,
          d = !(null != t && t.minimize) && (!a || e.length > 70 || c || s || o),
          p = '',
          h = a && (0, r.FD)(e.charCodeAt(0));
        return (
          ((d && !h) || s) && (p += '\n'), (p += n), (d || c) && (p += '\n'), '"""' + p + '"""'
        );
      }
    },
    3069: function (e, t, n) {
      'use strict';
      function r(e) {
        return 9 === e || 32 === e;
      }
      function i(e) {
        return e >= 48 && e <= 57;
      }
      function a(e) {
        return (e >= 97 && e <= 122) || (e >= 65 && e <= 90);
      }
      function s(e) {
        return a(e) || 95 === e;
      }
      function o(e) {
        return a(e) || i(e) || 95 === e;
      }
      n.d(t, {
        FD: function () {
          return r;
        },
        HQ: function () {
          return o;
        },
        LQ: function () {
          return s;
        },
        X1: function () {
          return i;
        },
      });
    },
    60832: function (e, t, n) {
      'use strict';
      var r, i;
      n.d(t, {
        h: function () {
          return r;
        },
      }),
        ((i = r || (r = {})).NAME = 'Name'),
        (i.DOCUMENT = 'Document'),
        (i.OPERATION_DEFINITION = 'OperationDefinition'),
        (i.VARIABLE_DEFINITION = 'VariableDefinition'),
        (i.SELECTION_SET = 'SelectionSet'),
        (i.FIELD = 'Field'),
        (i.ARGUMENT = 'Argument'),
        (i.FRAGMENT_SPREAD = 'FragmentSpread'),
        (i.INLINE_FRAGMENT = 'InlineFragment'),
        (i.FRAGMENT_DEFINITION = 'FragmentDefinition'),
        (i.VARIABLE = 'Variable'),
        (i.INT = 'IntValue'),
        (i.FLOAT = 'FloatValue'),
        (i.STRING = 'StringValue'),
        (i.BOOLEAN = 'BooleanValue'),
        (i.NULL = 'NullValue'),
        (i.ENUM = 'EnumValue'),
        (i.LIST = 'ListValue'),
        (i.OBJECT = 'ObjectValue'),
        (i.OBJECT_FIELD = 'ObjectField'),
        (i.DIRECTIVE = 'Directive'),
        (i.NAMED_TYPE = 'NamedType'),
        (i.LIST_TYPE = 'ListType'),
        (i.NON_NULL_TYPE = 'NonNullType'),
        (i.SCHEMA_DEFINITION = 'SchemaDefinition'),
        (i.OPERATION_TYPE_DEFINITION = 'OperationTypeDefinition'),
        (i.SCALAR_TYPE_DEFINITION = 'ScalarTypeDefinition'),
        (i.OBJECT_TYPE_DEFINITION = 'ObjectTypeDefinition'),
        (i.FIELD_DEFINITION = 'FieldDefinition'),
        (i.INPUT_VALUE_DEFINITION = 'InputValueDefinition'),
        (i.INTERFACE_TYPE_DEFINITION = 'InterfaceTypeDefinition'),
        (i.UNION_TYPE_DEFINITION = 'UnionTypeDefinition'),
        (i.ENUM_TYPE_DEFINITION = 'EnumTypeDefinition'),
        (i.ENUM_VALUE_DEFINITION = 'EnumValueDefinition'),
        (i.INPUT_OBJECT_TYPE_DEFINITION = 'InputObjectTypeDefinition'),
        (i.DIRECTIVE_DEFINITION = 'DirectiveDefinition'),
        (i.SCHEMA_EXTENSION = 'SchemaExtension'),
        (i.SCALAR_TYPE_EXTENSION = 'ScalarTypeExtension'),
        (i.OBJECT_TYPE_EXTENSION = 'ObjectTypeExtension'),
        (i.INTERFACE_TYPE_EXTENSION = 'InterfaceTypeExtension'),
        (i.UNION_TYPE_EXTENSION = 'UnionTypeExtension'),
        (i.ENUM_TYPE_EXTENSION = 'EnumTypeExtension'),
        (i.INPUT_OBJECT_TYPE_EXTENSION = 'InputObjectTypeExtension');
    },
    31836: function (e, t, n) {
      'use strict';
      n.d(t, {
        $_: function () {
          return o;
        },
        Vn: function () {
          return l;
        },
      });
      var r = n(89304),
        i = n(14208),
        a = n(57564),
        s = n(60832);
      let o = Object.freeze({});
      function l(e, t, n = a.h8) {
        let l, u, c;
        let d = new Map();
        for (let e of Object.values(s.h))
          d.set(
            e,
            (function (e, t) {
              let n = e[t];
              return 'object' == typeof n
                ? n
                : 'function' == typeof n
                  ? { enter: n, leave: void 0 }
                  : { enter: e.enter, leave: e.leave };
            })(t, e)
          );
        let p = Array.isArray(e),
          h = [e],
          y = -1,
          f = [],
          m = e,
          g = [],
          b = [];
        do {
          var w, v, T;
          let e;
          let s = ++y === h.length,
            A = s && 0 !== f.length;
          if (s) {
            if (((u = 0 === b.length ? void 0 : g[g.length - 1]), (m = c), (c = b.pop()), A)) {
              if (p) {
                m = m.slice();
                let e = 0;
                for (let [t, n] of f) {
                  let r = t - e;
                  null === n ? (m.splice(r, 1), e++) : (m[r] = n);
                }
              } else for (let [e, t] of ((m = { ...m }), f)) m[e] = t;
            }
            (y = l.index), (h = l.keys), (f = l.edits), (p = l.inArray), (l = l.prev);
          } else if (c) {
            if (null == (m = c[(u = p ? y : h[y])])) continue;
            g.push(u);
          }
          if (!Array.isArray(m)) {
            (0, a.UG)(m) || (0, r.a)(!1, `Invalid AST Node: ${(0, i.X)(m)}.`);
            let n = s
              ? null === (w = d.get(m.kind)) || void 0 === w
                ? void 0
                : w.leave
              : null === (v = d.get(m.kind)) || void 0 === v
                ? void 0
                : v.enter;
            if ((e = null == n ? void 0 : n.call(t, m, u, c, g, b)) === o) break;
            if (!1 === e) {
              if (!s) {
                g.pop();
                continue;
              }
            } else if (void 0 !== e && (f.push([u, e]), !s)) {
              if ((0, a.UG)(e)) m = e;
              else {
                g.pop();
                continue;
              }
            }
          }
          void 0 === e && A && f.push([u, m]),
            s
              ? g.pop()
              : ((l = { inArray: p, index: y, keys: h, edits: f, prev: l }),
                (h = (p = Array.isArray(m))
                  ? m
                  : null !== (T = n[m.kind]) && void 0 !== T
                    ? T
                    : []),
                (y = -1),
                (f = []),
                c && b.push(c),
                (c = m));
        } while (void 0 !== l);
        return 0 !== f.length ? f[f.length - 1][1] : e;
      }
    },
    30587: function (e, t, n) {
      'use strict';
      n.d(t, {
        Jb: function () {
          return I;
        },
        Ld: function () {
          return S;
        },
        YP: function () {
          return _;
        },
        _$LH: function () {
          return q;
        },
        dy: function () {
          return C;
        },
        sY: function () {
          return $;
        },
      });
      let r = globalThis,
        i = r.trustedTypes,
        a = i ? i.createPolicy('lit-html', { createHTML: (e) => e }) : void 0,
        s = '$lit$',
        o = `lit$${Math.random().toFixed(9).slice(2)}$`,
        l = '?' + o,
        u = `<${l}>`,
        c = document,
        d = () => c.createComment(''),
        p = (e) => null === e || ('object' != typeof e && 'function' != typeof e),
        h = Array.isArray,
        y = (e) => h(e) || 'function' == typeof e?.[Symbol.iterator],
        f = '[ 	\n\f\r]',
        m = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,
        g = /-->/g,
        b = />/g,
        w = RegExp(
          `>|${f}(?:([^\\s"'>=/]+)(${f}*=${f}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`,
          'g'
        ),
        v = /'/g,
        T = /"/g,
        A = /^(?:script|style|textarea|title)$/i,
        E =
          (e) =>
          (t, ...n) => ({ _$litType$: e, strings: t, values: n }),
        C = E(1),
        _ = E(2),
        I = (E(3), Symbol.for('lit-noChange')),
        S = Symbol.for('lit-nothing'),
        P = new WeakMap(),
        O = c.createTreeWalker(c, 129);
      function N(e, t) {
        if (!h(e) || !e.hasOwnProperty('raw')) throw Error('invalid template strings array');
        return void 0 !== a ? a.createHTML(t) : t;
      }
      let x = (e, t) => {
        let n = e.length - 1,
          r = [],
          i,
          a = 2 === t ? '<svg>' : 3 === t ? '<math>' : '',
          l = m;
        for (let t = 0; t < n; t++) {
          let n = e[t],
            c,
            d,
            p = -1,
            h = 0;
          for (; h < n.length && ((l.lastIndex = h), null !== (d = l.exec(n))); )
            (h = l.lastIndex),
              l === m
                ? '!--' === d[1]
                  ? (l = g)
                  : void 0 !== d[1]
                    ? (l = b)
                    : void 0 !== d[2]
                      ? (A.test(d[2]) && (i = RegExp('</' + d[2], 'g')), (l = w))
                      : void 0 !== d[3] && (l = w)
                : l === w
                  ? '>' === d[0]
                    ? ((l = i ?? m), (p = -1))
                    : void 0 === d[1]
                      ? (p = -2)
                      : ((p = l.lastIndex - d[2].length),
                        (c = d[1]),
                        (l = void 0 === d[3] ? w : '"' === d[3] ? T : v))
                  : l === T || l === v
                    ? (l = w)
                    : l === g || l === b
                      ? (l = m)
                      : ((l = w), (i = void 0));
          let y = l === w && e[t + 1].startsWith('/>') ? ' ' : '';
          a +=
            l === m
              ? n + u
              : p >= 0
                ? (r.push(c), n.slice(0, p) + s + n.slice(p) + o + y)
                : n + o + (-2 === p ? t : y);
        }
        return [N(e, a + (e[n] || '<?>') + (2 === t ? '</svg>' : 3 === t ? '</math>' : '')), r];
      };
      class M {
        constructor({ strings: e, _$litType$: t }, n) {
          let r;
          this.parts = [];
          let a = 0,
            u = 0,
            c = e.length - 1,
            p = this.parts,
            [h, y] = x(e, t);
          if (
            ((this.el = M.createElement(h, n)),
            (O.currentNode = this.el.content),
            2 === t || 3 === t)
          ) {
            let e = this.el.content.firstChild;
            e.replaceWith(...e.childNodes);
          }
          for (; null !== (r = O.nextNode()) && p.length < c; ) {
            if (1 === r.nodeType) {
              if (r.hasAttributes())
                for (let e of r.getAttributeNames())
                  if (e.endsWith(s)) {
                    let t = y[u++],
                      n = r.getAttribute(e).split(o),
                      i = /([.?@])?(.*)/.exec(t);
                    p.push({
                      type: 1,
                      index: a,
                      name: i[2],
                      strings: n,
                      ctor: '.' === i[1] ? U : '?' === i[1] ? L : '@' === i[1] ? F : B,
                    }),
                      r.removeAttribute(e);
                  } else e.startsWith(o) && (p.push({ type: 6, index: a }), r.removeAttribute(e));
              if (A.test(r.tagName)) {
                let e = r.textContent.split(o),
                  t = e.length - 1;
                if (t > 0) {
                  r.textContent = i ? i.emptyScript : '';
                  for (let n = 0; n < t; n++)
                    r.append(e[n], d()), O.nextNode(), p.push({ type: 2, index: ++a });
                  r.append(e[t], d());
                }
              }
            } else if (8 === r.nodeType) {
              if (r.data === l) p.push({ type: 2, index: a });
              else {
                let e = -1;
                for (; -1 !== (e = r.data.indexOf(o, e + 1)); )
                  p.push({ type: 7, index: a }), (e += o.length - 1);
              }
            }
            a++;
          }
        }
        static createElement(e, t) {
          let n = c.createElement('template');
          return (n.innerHTML = e), n;
        }
      }
      function k(e, t, n = e, r) {
        if (t === I) return t;
        let i = void 0 !== r ? n._$Co?.[r] : n._$Cl,
          a = p(t) ? void 0 : t._$litDirective$;
        return (
          i?.constructor !== a &&
            (i?._$AO?.(!1),
            void 0 === a ? (i = void 0) : (i = new a(e))._$AT(e, n, r),
            void 0 !== r ? ((n._$Co ??= [])[r] = i) : (n._$Cl = i)),
          void 0 !== i && (t = k(e, i._$AS(e, t.values), i, r)),
          t
        );
      }
      class R {
        constructor(e, t) {
          (this._$AV = []), (this._$AN = void 0), (this._$AD = e), (this._$AM = t);
        }
        get parentNode() {
          return this._$AM.parentNode;
        }
        get _$AU() {
          return this._$AM._$AU;
        }
        u(e) {
          let {
              el: { content: t },
              parts: n,
            } = this._$AD,
            r = (e?.creationScope ?? c).importNode(t, !0);
          O.currentNode = r;
          let i = O.nextNode(),
            a = 0,
            s = 0,
            o = n[0];
          for (; void 0 !== o; ) {
            if (a === o.index) {
              let t;
              2 === o.type
                ? (t = new D(i, i.nextSibling, this, e))
                : 1 === o.type
                  ? (t = new o.ctor(i, o.name, o.strings, this, e))
                  : 6 === o.type && (t = new j(i, this, e)),
                this._$AV.push(t),
                (o = n[++s]);
            }
            a !== o?.index && ((i = O.nextNode()), a++);
          }
          return (O.currentNode = c), r;
        }
        p(e) {
          let t = 0;
          for (let n of this._$AV)
            void 0 !== n &&
              (void 0 !== n.strings
                ? (n._$AI(e, n, t), (t += n.strings.length - 2))
                : n._$AI(e[t])),
              t++;
        }
      }
      class D {
        get _$AU() {
          return this._$AM?._$AU ?? this._$Cv;
        }
        constructor(e, t, n, r) {
          (this.type = 2),
            (this._$AH = S),
            (this._$AN = void 0),
            (this._$AA = e),
            (this._$AB = t),
            (this._$AM = n),
            (this.options = r),
            (this._$Cv = r?.isConnected ?? !0);
        }
        get parentNode() {
          let e = this._$AA.parentNode,
            t = this._$AM;
          return void 0 !== t && 11 === e?.nodeType && (e = t.parentNode), e;
        }
        get startNode() {
          return this._$AA;
        }
        get endNode() {
          return this._$AB;
        }
        _$AI(e, t = this) {
          p((e = k(this, e, t)))
            ? e === S || null == e || '' === e
              ? (this._$AH !== S && this._$AR(), (this._$AH = S))
              : e !== this._$AH && e !== I && this._(e)
            : void 0 !== e._$litType$
              ? this.$(e)
              : void 0 !== e.nodeType
                ? this.T(e)
                : y(e)
                  ? this.k(e)
                  : this._(e);
        }
        O(e) {
          return this._$AA.parentNode.insertBefore(e, this._$AB);
        }
        T(e) {
          this._$AH !== e && (this._$AR(), (this._$AH = this.O(e)));
        }
        _(e) {
          this._$AH !== S && p(this._$AH)
            ? (this._$AA.nextSibling.data = e)
            : this.T(c.createTextNode(e)),
            (this._$AH = e);
        }
        $(e) {
          let { values: t, _$litType$: n } = e,
            r =
              'number' == typeof n
                ? this._$AC(e)
                : (void 0 === n.el && (n.el = M.createElement(N(n.h, n.h[0]), this.options)), n);
          if (this._$AH?._$AD === r) this._$AH.p(t);
          else {
            let e = new R(r, this),
              n = e.u(this.options);
            e.p(t), this.T(n), (this._$AH = e);
          }
        }
        _$AC(e) {
          let t = P.get(e.strings);
          return void 0 === t && P.set(e.strings, (t = new M(e))), t;
        }
        k(e) {
          h(this._$AH) || ((this._$AH = []), this._$AR());
          let t = this._$AH,
            n,
            r = 0;
          for (let i of e)
            r === t.length
              ? t.push((n = new D(this.O(d()), this.O(d()), this, this.options)))
              : (n = t[r]),
              n._$AI(i),
              r++;
          r < t.length && (this._$AR(n && n._$AB.nextSibling, r), (t.length = r));
        }
        _$AR(e = this._$AA.nextSibling, t) {
          for (this._$AP?.(!1, !0, t); e && e !== this._$AB; ) {
            let t = e.nextSibling;
            e.remove(), (e = t);
          }
        }
        setConnected(e) {
          void 0 === this._$AM && ((this._$Cv = e), this._$AP?.(e));
        }
      }
      class B {
        get tagName() {
          return this.element.tagName;
        }
        get _$AU() {
          return this._$AM._$AU;
        }
        constructor(e, t, n, r, i) {
          (this.type = 1),
            (this._$AH = S),
            (this._$AN = void 0),
            (this.element = e),
            (this.name = t),
            (this._$AM = r),
            (this.options = i),
            n.length > 2 || '' !== n[0] || '' !== n[1]
              ? ((this._$AH = Array(n.length - 1).fill(new String())), (this.strings = n))
              : (this._$AH = S);
        }
        _$AI(e, t = this, n, r) {
          let i = this.strings,
            a = !1;
          if (void 0 === i)
            (a = !p((e = k(this, e, t, 0))) || (e !== this._$AH && e !== I)) && (this._$AH = e);
          else {
            let r, s;
            let o = e;
            for (e = i[0], r = 0; r < i.length - 1; r++)
              (s = k(this, o[n + r], t, r)) === I && (s = this._$AH[r]),
                (a ||= !p(s) || s !== this._$AH[r]),
                s === S ? (e = S) : e !== S && (e += (s ?? '') + i[r + 1]),
                (this._$AH[r] = s);
          }
          a && !r && this.j(e);
        }
        j(e) {
          e === S
            ? this.element.removeAttribute(this.name)
            : this.element.setAttribute(this.name, e ?? '');
        }
      }
      class U extends B {
        constructor() {
          super(...arguments), (this.type = 3);
        }
        j(e) {
          this.element[this.name] = e === S ? void 0 : e;
        }
      }
      class L extends B {
        constructor() {
          super(...arguments), (this.type = 4);
        }
        j(e) {
          this.element.toggleAttribute(this.name, !!e && e !== S);
        }
      }
      class F extends B {
        constructor(e, t, n, r, i) {
          super(e, t, n, r, i), (this.type = 5);
        }
        _$AI(e, t = this) {
          if ((e = k(this, e, t, 0) ?? S) === I) return;
          let n = this._$AH,
            r =
              (e === S && n !== S) ||
              e.capture !== n.capture ||
              e.once !== n.once ||
              e.passive !== n.passive,
            i = e !== S && (n === S || r);
          r && this.element.removeEventListener(this.name, this, n),
            i && this.element.addEventListener(this.name, this, e),
            (this._$AH = e);
        }
        handleEvent(e) {
          'function' == typeof this._$AH
            ? this._$AH.call(this.options?.host ?? this.element, e)
            : this._$AH.handleEvent(e);
        }
      }
      class j {
        constructor(e, t, n) {
          (this.element = e),
            (this.type = 6),
            (this._$AN = void 0),
            (this._$AM = t),
            (this.options = n);
        }
        get _$AU() {
          return this._$AM._$AU;
        }
        _$AI(e) {
          k(this, e);
        }
      }
      let q = {
          M: s,
          P: o,
          A: l,
          C: 1,
          L: x,
          R: R,
          D: y,
          V: k,
          I: D,
          H: B,
          N: L,
          U: F,
          B: U,
          F: j,
        },
        V = r.litHtmlPolyfillSupport;
      V?.(M, D), (r.litHtmlVersions ??= []).push('3.3.0');
      let $ = (e, t, n) => {
        let r = n?.renderBefore ?? t,
          i = r._$litPart$;
        if (void 0 === i) {
          let e = n?.renderBefore ?? null;
          r._$litPart$ = i = new D(t.insertBefore(d(), e), e, void 0, n ?? {});
        }
        return i._$AI(e), i;
      };
    },
    98670: function (e, t, n) {
      'use strict';
      n.d(t, {
        oi: function () {
          return s;
        },
        iv: function () {
          return r.iv;
        },
        dy: function () {
          return i.dy;
        },
        YP: function () {
          return i.YP;
        },
        $m: function () {
          return r.$m;
        },
      });
      var r = n(36007),
        i = n(30587);
      let a = globalThis;
      class s extends r.fl {
        constructor() {
          super(...arguments), (this.renderOptions = { host: this }), (this._$Do = void 0);
        }
        createRenderRoot() {
          let e = super.createRenderRoot();
          return (this.renderOptions.renderBefore ??= e.firstChild), e;
        }
        update(e) {
          let t = this.render();
          this.hasUpdated || (this.renderOptions.isConnected = this.isConnected),
            super.update(e),
            (this._$Do = (0, i.sY)(t, this.renderRoot, this.renderOptions));
        }
        connectedCallback() {
          super.connectedCallback(), this._$Do?.setConnected(!0);
        }
        disconnectedCallback() {
          super.disconnectedCallback(), this._$Do?.setConnected(!1);
        }
        render() {
          return i.Jb;
        }
      }
      (s._$litElement$ = !0), (s.finalized = !0), a.litElementHydrateSupport?.({ LitElement: s });
      let o = a.litElementPolyfillSupport;
      o?.({ LitElement: s }), (a.litElementVersions ??= []).push('4.2.0');
    },
    26897: function (e, t) {
      'use strict';
      t.Z = function (e) {
        var t = null == e ? 0 : e.length;
        return t ? e[t - 1] : void 0;
      };
    },
    88197: function (e, t, n) {
      'use strict';
      let r;
      n.d(t, {
        g7: function () {
          return p;
        },
        dP: function () {
          return R;
        },
        re: function () {
          return U;
        },
      });
      var i = n(68944),
        a = n(27305);
      let s = null,
        o = {},
        l = 1;
      function u(e) {
        try {
          return e();
        } catch (e) {}
      }
      let c = '@wry/context:Slot',
        d = u(() => globalThis) || u(() => global) || Object.create(null),
        p =
          d[c] ||
          Array[c] ||
          (function (e) {
            try {
              Object.defineProperty(d, c, {
                value: e,
                enumerable: !1,
                writable: !1,
                configurable: !0,
              });
            } finally {
              return e;
            }
          })(
            class {
              constructor() {
                this.id = ['slot', l++, Date.now(), Math.random().toString(36).slice(2)].join(':');
              }
              hasValue() {
                for (let e = s; e; e = e.parent)
                  if (this.id in e.slots) {
                    let t = e.slots[this.id];
                    if (t === o) break;
                    return e !== s && (s.slots[this.id] = t), !0;
                  }
                return s && (s.slots[this.id] = o), !1;
              }
              getValue() {
                if (this.hasValue()) return s.slots[this.id];
              }
              withValue(e, t, n, r) {
                let i = { __proto__: null, [this.id]: e },
                  a = s;
                s = { parent: a, slots: i };
                try {
                  return t.apply(r, n);
                } finally {
                  s = a;
                }
              }
              static bind(e) {
                let t = s;
                return function () {
                  let n = s;
                  try {
                    return (s = t), e.apply(this, arguments);
                  } finally {
                    s = n;
                  }
                };
              }
              static noContext(e, t, n) {
                if (!s) return e.apply(n, t);
                {
                  let r = s;
                  try {
                    return (s = null), e.apply(n, t);
                  } finally {
                    s = r;
                  }
                }
              }
            }
          ),
        { bind: h, noContext: y } = p,
        f = new p(),
        { hasOwnProperty: m } = Object.prototype,
        g =
          Array.from ||
          function (e) {
            let t = [];
            return e.forEach((e) => t.push(e)), t;
          };
      function b(e) {
        let { unsubscribe: t } = e;
        'function' == typeof t && ((e.unsubscribe = void 0), t());
      }
      let w = [];
      function v(e, t) {
        if (!e) throw Error(t || 'assertion failure');
      }
      function T(e, t) {
        let n = e.length;
        return n > 0 && n === t.length && e[n - 1] === t[n - 1];
      }
      function A(e) {
        switch (e.length) {
          case 0:
            throw Error('unknown value');
          case 1:
            return e[0];
          case 2:
            throw e[1];
        }
      }
      class E {
        constructor(e) {
          (this.fn = e),
            (this.parents = new Set()),
            (this.childValues = new Map()),
            (this.dirtyChildren = null),
            (this.dirty = !0),
            (this.recomputing = !1),
            (this.value = []),
            (this.deps = null),
            ++E.count;
        }
        peek() {
          if (1 === this.value.length && !I(this)) return C(this), this.value[0];
        }
        recompute(e) {
          var t;
          return (
            v(!this.recomputing, 'already recomputing'),
            C(this),
            I(this) &&
              (x(this),
              f.withValue(this, _, [this, e]),
              (function (e, t) {
                if ('function' == typeof e.subscribe)
                  try {
                    b(e), (e.unsubscribe = e.subscribe.apply(null, t));
                  } catch (t) {
                    return e.setDirty(), !1;
                  }
                return !0;
              })(this, e) && ((this.dirty = !1), I(this) || ((t = this), S(t, O)))),
            A(this.value)
          );
        }
        setDirty() {
          this.dirty || ((this.dirty = !0), S(this, P), b(this));
        }
        dispose() {
          this.setDirty(),
            x(this),
            S(this, (e, t) => {
              e.setDirty(), M(e, this);
            });
        }
        forget() {
          this.dispose();
        }
        dependOn(e) {
          e.add(this), this.deps || (this.deps = w.pop() || new Set()), this.deps.add(e);
        }
        forgetDeps() {
          this.deps &&
            (g(this.deps).forEach((e) => e.delete(this)),
            this.deps.clear(),
            w.push(this.deps),
            (this.deps = null));
        }
      }
      function C(e) {
        let t = f.getValue();
        if (t)
          return (
            e.parents.add(t),
            t.childValues.has(e) || t.childValues.set(e, []),
            I(e) ? P(t, e) : O(t, e),
            t
          );
      }
      function _(e, t) {
        let n;
        e.recomputing = !0;
        let { normalizeResult: r } = e;
        r && 1 === e.value.length && (n = e.value.slice(0)), (e.value.length = 0);
        try {
          if (((e.value[0] = e.fn.apply(null, t)), r && n && !T(n, e.value)))
            try {
              e.value[0] = r(e.value[0], n[0]);
            } catch (e) {}
        } catch (t) {
          e.value[1] = t;
        }
        e.recomputing = !1;
      }
      function I(e) {
        return e.dirty || !!(e.dirtyChildren && e.dirtyChildren.size);
      }
      function S(e, t) {
        let n = e.parents.size;
        if (n) {
          let r = g(e.parents);
          for (let i = 0; i < n; ++i) t(r[i], e);
        }
      }
      function P(e, t) {
        v(e.childValues.has(t)), v(I(t));
        let n = !I(e);
        if (e.dirtyChildren) {
          if (e.dirtyChildren.has(t)) return;
        } else e.dirtyChildren = w.pop() || new Set();
        e.dirtyChildren.add(t), n && S(e, P);
      }
      function O(e, t) {
        v(e.childValues.has(t)), v(!I(t));
        let n = e.childValues.get(t);
        0 === n.length ? e.childValues.set(t, t.value.slice(0)) : T(n, t.value) || e.setDirty(),
          N(e, t),
          I(e) || S(e, O);
      }
      function N(e, t) {
        let n = e.dirtyChildren;
        n && (n.delete(t), 0 === n.size && (w.length < 100 && w.push(n), (e.dirtyChildren = null)));
      }
      function x(e) {
        e.childValues.size > 0 &&
          e.childValues.forEach((t, n) => {
            M(e, n);
          }),
          e.forgetDeps(),
          v(null === e.dirtyChildren);
      }
      function M(e, t) {
        t.parents.delete(e), e.childValues.delete(t), N(e, t);
      }
      E.count = 0;
      let k = { setDirty: !0, dispose: !0, forget: !0 };
      function R(e) {
        let t = new Map(),
          n = e && e.subscribe;
        function r(e) {
          let r = f.getValue();
          if (r) {
            let i = t.get(e);
            i || t.set(e, (i = new Set())),
              r.dependOn(i),
              'function' == typeof n && (b(i), (i.unsubscribe = n(e)));
          }
        }
        return (
          (r.dirty = function (e, n) {
            let r = t.get(e);
            if (r) {
              let i = n && m.call(k, n) ? n : 'setDirty';
              g(r).forEach((e) => e[i]()), t.delete(e), b(r);
            }
          }),
          r
        );
      }
      function D(...e) {
        return (r || (r = new i.B('function' == typeof WeakMap))).lookupArray(e);
      }
      let B = new Set();
      function U(
        e,
        {
          max: t = 65536,
          keyArgs: n,
          makeCacheKey: r = D,
          normalizeResult: i,
          subscribe: s,
          cache: o = a.e,
        } = Object.create(null)
      ) {
        let l = 'function' == typeof o ? new o(t, (e) => e.dispose()) : o,
          u = function () {
            let t = r.apply(null, n ? n.apply(null, arguments) : arguments);
            if (void 0 === t) return e.apply(null, arguments);
            let a = l.get(t);
            a ||
              (l.set(t, (a = new E(e))),
              (a.normalizeResult = i),
              (a.subscribe = s),
              (a.forget = () => l.delete(t)));
            let o = a.recompute(Array.prototype.slice.call(arguments));
            return (
              l.set(t, a), B.add(l), f.hasValue() || (B.forEach((e) => e.clean()), B.clear()), o
            );
          };
        function c(e) {
          let t = e && l.get(e);
          t && t.setDirty();
        }
        function d(e) {
          let t = e && l.get(e);
          if (t) return t.peek();
        }
        function p(e) {
          return !!e && l.delete(e);
        }
        return (
          Object.defineProperty(u, 'size', { get: () => l.size, configurable: !1, enumerable: !1 }),
          Object.freeze(
            (u.options = {
              max: t,
              keyArgs: n,
              makeCacheKey: r,
              normalizeResult: i,
              subscribe: s,
              cache: l,
            })
          ),
          (u.dirtyKey = c),
          (u.dirty = function () {
            c(r.apply(null, arguments));
          }),
          (u.peekKey = d),
          (u.peek = function () {
            return d(r.apply(null, arguments));
          }),
          (u.forgetKey = p),
          (u.forget = function () {
            return p(r.apply(null, arguments));
          }),
          (u.makeCacheKey = r),
          (u.getKey = n
            ? function () {
                return r.apply(null, n.apply(null, arguments));
              }
            : r),
          Object.freeze(u)
        );
      }
    },
    94583: function (e, t, n) {
      'use strict';
      n.d(t, {
        sj: function () {
          return h;
        },
        iH: function () {
          return m;
        },
        CO: function () {
          return f;
        },
        Ld: function () {
          return y;
        },
      }),
        Symbol();
      let r = Symbol(),
        i = Object.getPrototypeOf,
        a = new WeakMap(),
        s = (e) =>
          e && (a.has(e) ? a.get(e) : i(e) === Object.prototype || i(e) === Array.prototype),
        o = (e) => (s(e) && e[r]) || null,
        l = (e, t = !0) => {
          a.set(e, t);
        },
        u = (e) => 'object' == typeof e && null !== e,
        c = new WeakMap(),
        d = new WeakSet(),
        [p] = ((
          e = Object.is,
          t = (e, t) => new Proxy(e, t),
          n = (e) =>
            u(e) &&
            !d.has(e) &&
            (Array.isArray(e) || !(Symbol.iterator in e)) &&
            !(e instanceof WeakMap) &&
            !(e instanceof WeakSet) &&
            !(e instanceof Error) &&
            !(e instanceof Number) &&
            !(e instanceof Date) &&
            !(e instanceof String) &&
            !(e instanceof RegExp) &&
            !(e instanceof ArrayBuffer),
          r = (e) => {
            switch (e.status) {
              case 'fulfilled':
                return e.value;
              case 'rejected':
                throw e.reason;
              default:
                throw e;
            }
          },
          i = new WeakMap(),
          a = (e, t, n = r) => {
            let s = i.get(e);
            if ((null == s ? void 0 : s[0]) === t) return s[1];
            let o = Array.isArray(e) ? [] : Object.create(Object.getPrototypeOf(e));
            return (
              l(o, !0),
              i.set(e, [t, o]),
              Reflect.ownKeys(e).forEach((t) => {
                if (Object.getOwnPropertyDescriptor(o, t)) return;
                let r = Reflect.get(e, t),
                  { enumerable: i } = Reflect.getOwnPropertyDescriptor(e, t),
                  s = { value: r, enumerable: i, configurable: !0 };
                if (d.has(r)) l(r, !1);
                else if (r instanceof Promise) delete s.value, (s.get = () => n(r));
                else if (c.has(r)) {
                  let [e, t] = c.get(r);
                  s.value = a(e, t(), n);
                }
                Object.defineProperty(o, t, s);
              }),
              Object.preventExtensions(o)
            );
          },
          s = new WeakMap(),
          p = [1, 1],
          h = (r) => {
            if (!u(r)) throw Error('object required');
            let i = s.get(r);
            if (i) return i;
            let l = p[0],
              y = new Set(),
              f = (e, t = ++p[0]) => {
                l !== t && ((l = t), y.forEach((n) => n(e, t)));
              },
              m = p[1],
              g = (e = ++p[1]) => (
                m === e ||
                  y.size ||
                  ((m = e),
                  w.forEach(([t]) => {
                    let n = t[1](e);
                    n > l && (l = n);
                  })),
                l
              ),
              b = (e) => (t, n) => {
                let r = [...t];
                (r[1] = [e, ...r[1]]), f(r, n);
              },
              w = new Map(),
              v = (e, t) => {
                if (w.has(e)) throw Error('prop listener already exists');
                if (y.size) {
                  let n = t[3](b(e));
                  w.set(e, [t, n]);
                } else w.set(e, [t]);
              },
              T = (e) => {
                var t;
                let n = w.get(e);
                n && (w.delete(e), null == (t = n[1]) || t.call(n));
              },
              A = (e) => {
                y.add(e),
                  1 === y.size &&
                    w.forEach(([e, t], n) => {
                      if (t) throw Error('remove already exists');
                      let r = e[3](b(n));
                      w.set(n, [e, r]);
                    });
                let t = () => {
                  y.delete(e),
                    0 === y.size &&
                      w.forEach(([e, t], n) => {
                        t && (t(), w.set(n, [e]));
                      });
                };
                return t;
              },
              E = Array.isArray(r) ? [] : Object.create(Object.getPrototypeOf(r)),
              C = {
                deleteProperty(e, t) {
                  let n = Reflect.get(e, t);
                  T(t);
                  let r = Reflect.deleteProperty(e, t);
                  return r && f(['delete', [t], n]), r;
                },
                set(t, r, i, a) {
                  let l = Reflect.has(t, r),
                    p = Reflect.get(t, r, a);
                  if (l && (e(p, i) || (s.has(i) && e(p, s.get(i))))) return !0;
                  T(r), u(i) && (i = o(i) || i);
                  let y = i;
                  if (i instanceof Promise)
                    i.then((e) => {
                      (i.status = 'fulfilled'), (i.value = e), f(['resolve', [r], e]);
                    }).catch((e) => {
                      (i.status = 'rejected'), (i.reason = e), f(['reject', [r], e]);
                    });
                  else {
                    !c.has(i) && n(i) && (y = h(i));
                    let e = !d.has(y) && c.get(y);
                    e && v(r, e);
                  }
                  return Reflect.set(t, r, y, a), f(['set', [r], i, p]), !0;
                },
              },
              _ = t(E, C);
            s.set(r, _);
            let I = [E, g, a, A];
            return (
              c.set(_, I),
              Reflect.ownKeys(r).forEach((e) => {
                let t = Object.getOwnPropertyDescriptor(r, e);
                'value' in t && ((_[e] = r[e]), delete t.value, delete t.writable),
                  Object.defineProperty(E, e, t);
              }),
              _
            );
          }
        ) => [h, c, d, e, t, n, r, i, a, s, p])();
      function h(e = {}) {
        return p(e);
      }
      function y(e, t, n) {
        let r;
        let i = c.get(e);
        i || console.warn('Please use proxy object');
        let a = [],
          s = i[3],
          o = !1,
          l = s((e) => {
            if ((a.push(e), n)) {
              t(a.splice(0));
              return;
            }
            r ||
              (r = Promise.resolve().then(() => {
                (r = void 0), o && t(a.splice(0));
              }));
          });
        return (
          (o = !0),
          () => {
            (o = !1), l();
          }
        );
      }
      function f(e, t) {
        let n = c.get(e);
        n || console.warn('Please use proxy object');
        let [r, i, a] = n;
        return a(r, i(), t);
      }
      function m(e) {
        return d.add(e), e;
      }
    },
    95759: function (e, t, n) {
      'use strict';
      n.d(t, {
        VW: function () {
          return i;
        },
        Yr: function () {
          return a;
        },
      });
      var r = n(94583);
      function i(e, t, n, i) {
        let a = e[t];
        return (0, r.Ld)(
          e,
          () => {
            let r = e[t];
            Object.is(a, r) || n((a = r));
          },
          i
        );
      }
      function a(e) {
        let t = (0, r.sj)({
          data: Array.from(e || []),
          has(e) {
            return this.data.some((t) => t[0] === e);
          },
          set(e, t) {
            let n = this.data.find((t) => t[0] === e);
            return n ? (n[1] = t) : this.data.push([e, t]), this;
          },
          get(e) {
            var t;
            return null == (t = this.data.find((t) => t[0] === e)) ? void 0 : t[1];
          },
          delete(e) {
            let t = this.data.findIndex((t) => t[0] === e);
            return -1 !== t && (this.data.splice(t, 1), !0);
          },
          clear() {
            this.data.splice(0);
          },
          get size() {
            return this.data.length;
          },
          toJSON() {
            return new Map(this.data);
          },
          forEach(e) {
            this.data.forEach((t) => {
              e(t[1], t[0], this);
            });
          },
          keys() {
            return this.data.map((e) => e[0]).values();
          },
          values() {
            return this.data.map((e) => e[1]).values();
          },
          entries() {
            return new Map(this.data).entries();
          },
          get [Symbol.toStringTag]() {
            return 'Map';
          },
          [Symbol.iterator]() {
            return this.entries();
          },
        });
        return (
          Object.defineProperties(t, {
            data: { enumerable: !1 },
            size: { enumerable: !1 },
            toJSON: { enumerable: !1 },
          }),
          Object.seal(t),
          t
        );
      }
      Symbol();
    },
    65099: function (e, t, n) {
      'use strict';
      function r(e) {
        return 'string' == typeof e ? { address: e, type: 'json-rpc' } : e;
      }
      n.d(t, {
        T: function () {
          return r;
        },
      });
    },
    13742: function (e, t, n) {
      'use strict';
      n.d(t, {
        O: function () {
          return f;
        },
      });
      var r = n(59370),
        i = n(29629),
        a = n(392),
        s = n(53064),
        o = n(97032),
        l = n(84196),
        u = n(52716),
        c = n(56123),
        d = n(70148),
        p = n(68132),
        h = n(61896),
        y = n(86705);
      async function f(e, t) {
        let { blockNumber: n, blockTag: f, coinType: m, name: g, gatewayUrls: b, strict: w } = t,
          { chain: v } = e,
          T = (() => {
            if (t.universalResolverAddress) return t.universalResolverAddress;
            if (!v)
              throw Error('client chain not configured. universalResolverAddress is required.');
            return (0, s.L)({ blockNumber: n, chain: v, contract: 'ensUniversalResolver' });
          })(),
          A = v?.ensTlds;
        if (A && !A.some((e) => g.endsWith(e))) return null;
        try {
          let t = (0, a.R)({
              abi: r.X$,
              functionName: 'addr',
              ...(null != m ? { args: [(0, d.V)(g), BigInt(m)] } : { args: [(0, d.V)(g)] }),
            }),
            s = {
              address: T,
              abi: r.k3,
              functionName: 'resolve',
              args: [(0, l.NC)((0, p.T)(g)), t, b ?? [c.M]],
              blockNumber: n,
              blockTag: f,
            },
            u = (0, h.s)(e, y.L, 'readContract'),
            w = await u(s);
          if ('0x' === w[0]) return null;
          let v = (0, i.k)({
            abi: r.X$,
            args: null != m ? [(0, d.V)(g), BigInt(m)] : void 0,
            functionName: 'addr',
            data: w[0],
          });
          if ('0x' === v || '0x00' === (0, o.f)(v)) return null;
          return v;
        } catch (e) {
          if (w) throw e;
          if ((0, u.c)(e, 'resolve')) return null;
          throw e;
        }
      }
    },
    87428: function (e, t, n) {
      'use strict';
      n.d(t, {
        r: function () {
          return C;
        },
      });
      var r = n(86705),
        i = n(88154);
      class a extends i.G {
        constructor({ data: e }) {
          super(
            'Unable to extract image from metadata. The metadata may be malformed or invalid.',
            {
              metaMessages: [
                '- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.',
                '',
                `Provided data: ${JSON.stringify(e)}`,
              ],
              name: 'EnsAvatarInvalidMetadataError',
            }
          );
        }
      }
      class s extends i.G {
        constructor({ reason: e }) {
          super(`ENS NFT avatar URI is invalid. ${e}`, { name: 'EnsAvatarInvalidNftUriError' });
        }
      }
      class o extends i.G {
        constructor({ uri: e }) {
          super(
            `Unable to resolve ENS avatar URI "${e}". The URI may be malformed, invalid, or does not respond with a valid image.`,
            { name: 'EnsAvatarUriResolutionError' }
          );
        }
      }
      class l extends i.G {
        constructor({ namespace: e }) {
          super(
            `ENS NFT avatar namespace "${e}" is not supported. Must be "erc721" or "erc1155".`,
            { name: 'EnsAvatarUnsupportedNamespaceError' }
          );
        }
      }
      let u =
          /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/,
        c =
          /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/,
        d = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/,
        p = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
      async function h(e) {
        try {
          let t = await fetch(e, { method: 'HEAD' });
          if (200 === t.status) {
            let e = t.headers.get('content-type');
            return e?.startsWith('image/');
          }
          return !1;
        } catch (t) {
          if (
            ('object' == typeof t && void 0 !== t.response) ||
            !globalThis.hasOwnProperty('Image')
          )
            return !1;
          return new Promise((t) => {
            let n = new Image();
            (n.onload = () => {
              t(!0);
            }),
              (n.onerror = () => {
                t(!1);
              }),
              (n.src = e);
          });
        }
      }
      function y(e, t) {
        return e ? (e.endsWith('/') ? e.slice(0, -1) : e) : t;
      }
      function f({ uri: e, gatewayUrls: t }) {
        let n = d.test(e);
        if (n) return { uri: e, isOnChain: !0, isEncoded: n };
        let r = y(t?.ipfs, 'https://ipfs.io'),
          i = y(t?.arweave, 'https://arweave.net'),
          a = e.match(u),
          { protocol: s, subpath: l, target: h, subtarget: f = '' } = a?.groups || {},
          m = 'ipns:/' === s || 'ipns/' === l,
          g = 'ipfs:/' === s || 'ipfs/' === l || c.test(e);
        if (e.startsWith('http') && !m && !g) {
          let n = e;
          return (
            t?.arweave && (n = e.replace(/https:\/\/arweave.net/g, t?.arweave)),
            { uri: n, isOnChain: !1, isEncoded: !1 }
          );
        }
        if ((m || g) && h)
          return { uri: `${r}/${m ? 'ipns' : 'ipfs'}/${h}${f}`, isOnChain: !1, isEncoded: !1 };
        if ('ar:/' === s && h) return { uri: `${i}/${h}${f || ''}`, isOnChain: !1, isEncoded: !1 };
        let b = e.replace(p, '');
        if (
          (b.startsWith('<svg') && (b = `data:image/svg+xml;base64,${btoa(b)}`),
          b.startsWith('data:') || b.startsWith('{'))
        )
          return { uri: b, isOnChain: !0, isEncoded: !1 };
        throw new o({ uri: e });
      }
      function m(e) {
        if (
          'object' != typeof e ||
          (!('image' in e) && !('image_url' in e) && !('image_data' in e))
        )
          throw new a({ data: e });
        return e.image || e.image_url || e.image_data;
      }
      async function g({ gatewayUrls: e, uri: t }) {
        try {
          let n = await fetch(t).then((e) => e.json());
          return await b({ gatewayUrls: e, uri: m(n) });
        } catch {
          throw new o({ uri: t });
        }
      }
      async function b({ gatewayUrls: e, uri: t }) {
        let { uri: n, isOnChain: r } = f({ uri: t, gatewayUrls: e });
        if (r || (await h(n))) return n;
        throw new o({ uri: t });
      }
      async function w(e, { nft: t }) {
        if ('erc721' === t.namespace)
          return (0, r.L)(e, {
            address: t.contractAddress,
            abi: [
              {
                name: 'tokenURI',
                type: 'function',
                stateMutability: 'view',
                inputs: [{ name: 'tokenId', type: 'uint256' }],
                outputs: [{ name: '', type: 'string' }],
              },
            ],
            functionName: 'tokenURI',
            args: [BigInt(t.tokenID)],
          });
        if ('erc1155' === t.namespace)
          return (0, r.L)(e, {
            address: t.contractAddress,
            abi: [
              {
                name: 'uri',
                type: 'function',
                stateMutability: 'view',
                inputs: [{ name: '_id', type: 'uint256' }],
                outputs: [{ name: '', type: 'string' }],
              },
            ],
            functionName: 'uri',
            args: [BigInt(t.tokenID)],
          });
        throw new l({ namespace: t.namespace });
      }
      async function v(e, { gatewayUrls: t, record: n }) {
        return /eip155:/i.test(n)
          ? T(e, { gatewayUrls: t, record: n })
          : b({ uri: n, gatewayUrls: t });
      }
      async function T(e, { gatewayUrls: t, record: n }) {
        let r = (function (e) {
            let t = e;
            t.startsWith('did:nft:') && (t = t.replace('did:nft:', '').replace(/_/g, '/'));
            let [n, r, i] = t.split('/'),
              [a, o] = n.split(':'),
              [l, u] = r.split(':');
            if (!a || 'eip155' !== a.toLowerCase())
              throw new s({ reason: 'Only EIP-155 supported' });
            if (!o) throw new s({ reason: 'Chain ID not found' });
            if (!u) throw new s({ reason: 'Contract address not found' });
            if (!i) throw new s({ reason: 'Token ID not found' });
            if (!l) throw new s({ reason: 'ERC namespace not found' });
            return {
              chainID: Number.parseInt(o),
              namespace: l.toLowerCase(),
              contractAddress: u,
              tokenID: i,
            };
          })(n),
          {
            uri: i,
            isOnChain: a,
            isEncoded: o,
          } = f({ uri: await w(e, { nft: r }), gatewayUrls: t });
        if (a && (i.includes('data:application/json;base64,') || i.startsWith('{')))
          return b({
            uri: m(JSON.parse(o ? atob(i.replace('data:application/json;base64,', '')) : i)),
            gatewayUrls: t,
          });
        let l = r.tokenID;
        return (
          'erc1155' === r.namespace && (l = l.replace('0x', '').padStart(64, '0')),
          g({ gatewayUrls: t, uri: i.replace(/(?:0x)?{id}/, l) })
        );
      }
      var A = n(61896),
        E = n(66855);
      async function C(
        e,
        {
          blockNumber: t,
          blockTag: n,
          assetGatewayUrls: r,
          name: i,
          gatewayUrls: a,
          strict: s,
          universalResolverAddress: o,
        }
      ) {
        let l = await (0, A.s)(
          e,
          E.g,
          'getEnsText'
        )({
          blockNumber: t,
          blockTag: n,
          key: 'avatar',
          name: i,
          universalResolverAddress: o,
          gatewayUrls: a,
          strict: s,
        });
        if (!l) return null;
        try {
          return await v(e, { record: l, gatewayUrls: r });
        } catch {
          return null;
        }
      }
    },
    33737: function (e, t, n) {
      'use strict';
      n.d(t, {
        w: function () {
          return c;
        },
      });
      var r = n(59370),
        i = n(53064),
        a = n(84196),
        s = n(52716),
        o = n(68132),
        l = n(61896),
        u = n(86705);
      async function c(
        e,
        {
          address: t,
          blockNumber: n,
          blockTag: c,
          gatewayUrls: d,
          strict: p,
          universalResolverAddress: h,
        }
      ) {
        let y = h;
        if (!y) {
          if (!e.chain)
            throw Error('client chain not configured. universalResolverAddress is required.');
          y = (0, i.L)({ blockNumber: n, chain: e.chain, contract: 'ensUniversalResolver' });
        }
        let f = `${t.toLowerCase().substring(2)}.addr.reverse`;
        try {
          let i = {
              address: y,
              abi: r.du,
              functionName: 'reverse',
              args: [(0, a.NC)((0, o.T)(f))],
              blockNumber: n,
              blockTag: c,
            },
            s = (0, l.s)(e, u.L, 'readContract'),
            [p, h] = d ? await s({ ...i, args: [...i.args, d] }) : await s(i);
          if (t.toLowerCase() !== h.toLowerCase()) return null;
          return p;
        } catch (e) {
          if (p) throw e;
          if ((0, s.c)(e, 'reverse')) return null;
          throw e;
        }
      }
    },
    66855: function (e, t, n) {
      'use strict';
      n.d(t, {
        g: function () {
          return y;
        },
      });
      var r = n(59370),
        i = n(29629),
        a = n(392),
        s = n(53064),
        o = n(84196),
        l = n(52716),
        u = n(56123),
        c = n(70148),
        d = n(68132),
        p = n(61896),
        h = n(86705);
      async function y(e, t) {
        let { blockNumber: n, blockTag: y, key: f, name: m, gatewayUrls: g, strict: b } = t,
          { chain: w } = e,
          v = (() => {
            if (t.universalResolverAddress) return t.universalResolverAddress;
            if (!w)
              throw Error('client chain not configured. universalResolverAddress is required.');
            return (0, s.L)({ blockNumber: n, chain: w, contract: 'ensUniversalResolver' });
          })(),
          T = w?.ensTlds;
        if (T && !T.some((e) => m.endsWith(e))) return null;
        try {
          let t = {
              address: v,
              abi: r.k3,
              functionName: 'resolve',
              args: [
                (0, o.NC)((0, d.T)(m)),
                (0, a.R)({ abi: r.nZ, functionName: 'text', args: [(0, c.V)(m), f] }),
                g ?? [u.M],
              ],
              blockNumber: n,
              blockTag: y,
            },
            s = (0, p.s)(e, h.L, 'readContract'),
            l = await s(t);
          if ('0x' === l[0]) return null;
          let b = (0, i.k)({ abi: r.nZ, functionName: 'text', data: l[0] });
          return '' === b ? null : b;
        } catch (e) {
          if (b) throw e;
          if ((0, l.c)(e, 'resolve')) return null;
          throw e;
        }
      }
    },
    69183: function (e, t, n) {
      'use strict';
      n.d(t, {
        R: function () {
          return C;
        },
      });
      var r = n(86183),
        i = n(24347),
        a = n(11813);
      function s(e) {
        let t = (0, i.D)(e),
          n = [],
          s = e.length;
        for (let i = 0; i < s; i++) {
          let s = e[i];
          (0, r.N0)(s) || n.push((0, a.cK)(s, t));
        }
        return n;
      }
      var o = n(65099),
        l = n(59370),
        u = n(67273),
        c = n(88154),
        d = n(65772),
        p = n(54484),
        h = n(29629),
        y = n(43231),
        f = n(392),
        m = n(53064),
        g = n(84196),
        b = n(91045),
        w = n(44542),
        v = n(40740),
        T = n(42002),
        A = n(87335),
        E = n(26677);
      async function C(e, t) {
        let {
            account: r = e.account,
            batch: i = !!e.batch?.multicall,
            blockNumber: a,
            blockTag: l = 'latest',
            accessList: h,
            blobs: f,
            code: m,
            data: T,
            factory: C,
            factoryData: I,
            gas: S,
            gasPrice: P,
            maxFeePerBlobGas: O,
            maxFeePerGas: N,
            maxPriorityFeePerGas: x,
            nonce: M,
            to: k,
            value: R,
            stateOverride: D,
            ...B
          } = t,
          U = r ? (0, o.T)(r) : void 0;
        if (m && (C || I))
          throw new c.G('Cannot provide both `code` & `factory`/`factoryData` as parameters.');
        if (m && k) throw new c.G('Cannot provide both `code` & `to` as parameters.');
        let L = m && T,
          F = C && I && k && T,
          j = L || F,
          q = L
            ? (function (e) {
                let { code: t, data: n } = e;
                return (0, y.w)({
                  abi: s(['constructor(bytes, bytes)']),
                  bytecode: u.NO,
                  args: [t, n],
                });
              })({ code: m, data: T })
            : F
              ? (function (e) {
                  let { data: t, factory: n, factoryData: r, to: i } = e;
                  return (0, y.w)({
                    abi: s(['constructor(address, bytes, address, bytes)']),
                    bytecode: u.pG,
                    args: [i, t, n, r],
                  });
                })({ data: T, factory: C, factoryData: I, to: k })
              : T;
        try {
          (0, E.F)(t);
          let n = (a ? (0, g.eC)(a) : void 0) || l,
            r = (0, A.mF)(D),
            s = e.chain?.formatters?.transactionRequest?.format,
            o = (s || v.tG)({
              ...(0, w.K)(B, { format: s }),
              from: U?.address,
              accessList: h,
              blobs: f,
              data: q,
              gas: S,
              gasPrice: P,
              maxFeePerBlobGas: O,
              maxFeePerGas: N,
              maxPriorityFeePerGas: x,
              nonce: M,
              to: j ? void 0 : k,
              value: R,
            });
          if (
            i &&
            (function ({ request: e }) {
              let { data: t, to: n, ...r } = e;
              return (
                !(!t || t.startsWith('0x82ad56cb')) &&
                !!n &&
                !(Object.values(r).filter((e) => void 0 !== e).length > 0)
              );
            })({ request: o }) &&
            !r
          )
            try {
              return await _(e, { ...o, blockNumber: a, blockTag: l });
            } catch (e) {
              if (!(e instanceof d.pZ) && !(e instanceof d.mm)) throw e;
            }
          let u = await e.request({ method: 'eth_call', params: r ? [o, n, r] : [o, n] });
          if ('0x' === u) return { data: void 0 };
          return { data: u };
        } catch (s) {
          let r = (function (e) {
              if (!(e instanceof c.G)) return;
              let t = e.walk();
              return 'object' == typeof t?.data ? t.data?.data : t.data;
            })(s),
            { offchainLookup: i, offchainLookupSignature: a } = await n
              .e(1682)
              .then(n.bind(n, 1682));
          if (!1 !== e.ccipRead && r?.slice(0, 10) === a && k)
            return { data: await i(e, { data: r, to: k }) };
          if (j && r?.slice(0, 10) === '0x101bb98d') throw new p.Mo({ factory: C });
          throw (0, b.P)(s, { ...t, account: U, chain: e.chain });
        }
      }
      async function _(e, t) {
        let { batchSize: n = 1024, wait: r = 0 } =
            'object' == typeof e.batch?.multicall ? e.batch.multicall : {},
          { blockNumber: i, blockTag: a = 'latest', data: s, multicallAddress: o, to: u } = t,
          c = o;
        if (!c) {
          if (!e.chain) throw new d.pZ();
          c = (0, m.L)({ blockNumber: i, chain: e.chain, contract: 'multicall3' });
        }
        let y = (i ? (0, g.eC)(i) : void 0) || a,
          { schedule: b } = (0, T.S)({
            id: `${e.uid}.${y}`,
            wait: r,
            shouldSplitBatch: (e) => e.reduce((e, { data: t }) => e + (t.length - 2), 0) > 2 * n,
            fn: async (t) => {
              let n = t.map((e) => ({ allowFailure: !0, callData: e.data, target: e.to })),
                r = (0, f.R)({ abi: l.F8, args: [n], functionName: 'aggregate3' }),
                i = await e.request({ method: 'eth_call', params: [{ data: r, to: c }, y] });
              return (0, h.k)({
                abi: l.F8,
                args: [n],
                functionName: 'aggregate3',
                data: i || '0x',
              });
            },
          }),
          [{ returnData: w, success: v }] = await b({ data: s, to: u });
        if (!v) throw new p.VQ({ data: w });
        return '0x' === w ? { data: void 0 } : { data: w };
      }
    },
    68802: function (e, t, n) {
      'use strict';
      n.d(t, {
        W: function () {
          return i;
        },
      });
      var r = n(39751);
      async function i(e) {
        let t = (0, r.g)(e, { method: 'eth_newPendingTransactionFilter' }),
          n = await e.request({ method: 'eth_newPendingTransactionFilter' });
        return { id: n, request: t(n), type: 'transaction' };
      }
    },
    59501: function (e, t, n) {
      'use strict';
      n.d(t, {
        C: function () {
          return u;
        },
        X: function () {
          return l;
        },
      });
      var r = n(54646),
        i = n(61896),
        a = n(95729),
        s = n(51541),
        o = n(15363);
      async function l(e, t) {
        return u(e, t);
      }
      async function u(e, t) {
        let { block: n, chain: l = e.chain, request: u, type: c = 'eip1559' } = t || {},
          d = await (async () =>
            'function' == typeof l?.fees?.baseFeeMultiplier
              ? l.fees.baseFeeMultiplier({ block: n, client: e, request: u })
              : (l?.fees?.baseFeeMultiplier ?? 1.2))();
        if (d < 1) throw new r.Fz();
        let p = 10 ** (d.toString().split('.')[1]?.length ?? 0),
          h = (e) => (e * BigInt(Math.ceil(d * p))) / BigInt(p),
          y = n || (await (0, i.s)(e, s.Q, 'getBlock')({}));
        if ('function' == typeof l?.fees?.estimateFeesPerGas) {
          let t = await l.fees.estimateFeesPerGas({
            block: n,
            client: e,
            multiply: h,
            request: u,
            type: c,
          });
          if (null !== t) return t;
        }
        if ('eip1559' === c) {
          if ('bigint' != typeof y.baseFeePerGas) throw new r.e5();
          let t =
              'bigint' == typeof u?.maxPriorityFeePerGas
                ? u.maxPriorityFeePerGas
                : await (0, a.h)(e, { block: y, chain: l, request: u }),
            n = h(y.baseFeePerGas);
          return { maxFeePerGas: u?.maxFeePerGas ?? n + t, maxPriorityFeePerGas: t };
        }
        return { gasPrice: u?.gasPrice ?? h(await (0, i.s)(e, o.o, 'getGasPrice')({})) };
      }
    },
    18452: function (e, t, n) {
      'use strict';
      n.d(t, {
        Q: function () {
          return w;
        },
      });
      var r = n(65099),
        i = n(88154),
        a = n(6465),
        s = n(84196),
        o = n(28888),
        l = n(4046),
        u = n(29408);
      class c extends i.G {
        constructor(
          e,
          {
            account: t,
            docsPath: n,
            chain: r,
            data: i,
            gas: a,
            gasPrice: s,
            maxFeePerGas: c,
            maxPriorityFeePerGas: d,
            nonce: p,
            to: h,
            value: y,
          }
        ) {
          super(e.shortMessage, {
            cause: e,
            docsPath: n,
            metaMessages: [
              ...(e.metaMessages ? [...e.metaMessages, ' '] : []),
              'Estimate Gas Arguments:',
              (0, u.xr)({
                from: t?.address,
                to: h,
                value: void 0 !== y && `${(0, o.d)(y)} ${r?.nativeCurrency?.symbol || 'ETH'}`,
                data: i,
                gas: a,
                gasPrice: void 0 !== s && `${(0, l.o)(s)} gwei`,
                maxFeePerGas: void 0 !== c && `${(0, l.o)(c)} gwei`,
                maxPriorityFeePerGas: void 0 !== d && `${(0, l.o)(d)} gwei`,
                nonce: p,
              }),
            ].filter(Boolean),
            name: 'EstimateGasExecutionError',
          }),
            Object.defineProperty(this, 'cause', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.cause = e);
        }
      }
      var d = n(65264),
        p = n(90988),
        h = n(44542),
        y = n(40740),
        f = n(87335),
        m = n(26677),
        g = n(90936),
        b = n(66460);
      async function w(e, t) {
        let { account: n = e.account } = t,
          o = n ? (0, r.T)(n) : void 0;
        try {
          let {
              accessList: n,
              authorizationList: r,
              blobs: u,
              blobVersionedHashes: c,
              blockNumber: d,
              blockTag: p,
              data: w,
              gas: v,
              gasPrice: T,
              maxFeePerBlobGas: A,
              maxFeePerGas: E,
              maxPriorityFeePerGas: C,
              nonce: _,
              value: I,
              stateOverride: S,
              ...P
            } = await (0, g.ZE)(e, {
              ...t,
              parameters: o?.type === 'local' ? void 0 : ['blobVersionedHashes'],
            }),
            O = (d ? (0, s.eC)(d) : void 0) || p,
            N = (0, f.mF)(S),
            x = await (async () =>
              P.to
                ? P.to
                : r && r.length > 0
                  ? await (0, a.z)({ authorization: r[0] }).catch(() => {
                      throw new i.G('`to` is required. Could not infer from `authorizationList`');
                    })
                  : void 0)();
          (0, m.F)(t);
          let M = e.chain?.formatters?.transactionRequest?.format,
            k = (M || y.tG)({
              ...(0, h.K)(P, { format: M }),
              from: o?.address,
              accessList: n,
              authorizationList: r,
              blobs: u,
              blobVersionedHashes: c,
              data: w,
              gas: v,
              gasPrice: T,
              maxFeePerBlobGas: A,
              maxFeePerGas: E,
              maxPriorityFeePerGas: C,
              nonce: _,
              to: x,
              value: I,
            });
          function l(t) {
            let { block: n, request: r, rpcStateOverride: i } = t;
            return e.request({
              method: 'eth_estimateGas',
              params: i ? [r, n ?? 'latest', i] : n ? [r, n] : [r],
            });
          }
          let R = BigInt(await l({ block: O, request: k, rpcStateOverride: N }));
          if (r) {
            let t = await (0, b.s)(e, { address: k.from }),
              n = await Promise.all(
                r.map(async (e) => {
                  let { address: n } = e,
                    r = await l({
                      block: O,
                      request: {
                        authorizationList: void 0,
                        data: w,
                        from: o?.address,
                        to: n,
                        value: (0, s.eC)(t),
                      },
                      rpcStateOverride: N,
                    }).catch(() => 100000n);
                  return 2n * BigInt(r);
                })
              );
            R += n.reduce((e, t) => e + t, 0n);
          }
          return R;
        } catch (n) {
          throw (function (e, { docsPath: t, ...n }) {
            return new c(
              (() => {
                let t = (0, p.k)(e, n);
                return t instanceof d.cj ? e : t;
              })(),
              { docsPath: t, ...n }
            );
          })(n, { ...t, account: o, chain: e.chain });
        }
      }
    },
    95729: function (e, t, n) {
      'use strict';
      n.d(t, {
        _: function () {
          return l;
        },
        h: function () {
          return u;
        },
      });
      var r = n(54646),
        i = n(79e3),
        a = n(61896),
        s = n(51541),
        o = n(15363);
      async function l(e, t) {
        return u(e, t);
      }
      async function u(e, t) {
        let { block: n, chain: l = e.chain, request: u } = t || {};
        try {
          let t = l?.fees?.maxPriorityFeePerGas ?? l?.fees?.defaultPriorityFee;
          if ('function' == typeof t) {
            let r = n || (await (0, a.s)(e, s.Q, 'getBlock')({})),
              i = await t({ block: r, client: e, request: u });
            if (null === i) throw Error();
            return i;
          }
          if (void 0 !== t) return t;
          let r = await e.request({ method: 'eth_maxPriorityFeePerGas' });
          return (0, i.y_)(r);
        } catch {
          let [t, i] = await Promise.all([
            n ? Promise.resolve(n) : (0, a.s)(e, s.Q, 'getBlock')({}),
            (0, a.s)(e, o.o, 'getGasPrice')({}),
          ]);
          if ('bigint' != typeof t.baseFeePerGas) throw new r.e5();
          let l = i - t.baseFeePerGas;
          if (l < 0n) return 0n;
          return l;
        }
      }
    },
    66460: function (e, t, n) {
      'use strict';
      n.d(t, {
        s: function () {
          return i;
        },
      });
      var r = n(84196);
      async function i(e, { address: t, blockNumber: n, blockTag: i = 'latest' }) {
        let a = n ? (0, r.eC)(n) : void 0;
        return BigInt(await e.request({ method: 'eth_getBalance', params: [t, a || i] }));
      }
    },
    51541: function (e, t, n) {
      'use strict';
      n.d(t, {
        Q: function () {
          return s;
        },
      });
      var r = n(58427),
        i = n(84196),
        a = n(34029);
      async function s(
        e,
        { blockHash: t, blockNumber: n, blockTag: s, includeTransactions: o } = {}
      ) {
        let l = o ?? !1,
          u = void 0 !== n ? (0, i.eC)(n) : void 0,
          c = null;
        if (
          !(c = t
            ? await e.request({ method: 'eth_getBlockByHash', params: [t, l] }, { dedupe: !0 })
            : await e.request(
                { method: 'eth_getBlockByNumber', params: [u || (s ?? 'latest'), l] },
                { dedupe: !!u }
              ))
        )
          throw new r.f({ blockHash: t, blockNumber: n });
        return (e.chain?.formatters?.block?.format || a.Z)(c);
      }
    },
    20168: function (e, t, n) {
      'use strict';
      n.d(t, {
        z: function () {
          return o;
        },
      });
      let r = new Map(),
        i = new Map();
      async function a(e, { cacheKey: t, cacheTime: n = Number.POSITIVE_INFINITY }) {
        let a = (function (e) {
            let t = (e, t) => ({
                clear: () => t.delete(e),
                get: () => t.get(e),
                set: (n) => t.set(e, n),
              }),
              n = t(e, r),
              a = t(e, i);
            return {
              clear: () => {
                n.clear(), a.clear();
              },
              promise: n,
              response: a,
            };
          })(t),
          s = a.response.get();
        if (s && n > 0 && new Date().getTime() - s.created.getTime() < n) return s.data;
        let o = a.promise.get();
        o || ((o = e()), a.promise.set(o));
        try {
          let e = await o;
          return a.response.set({ created: new Date(), data: e }), e;
        } finally {
          a.promise.clear();
        }
      }
      let s = (e) => `blockNumber.${e}`;
      async function o(e, { cacheTime: t = e.cacheTime } = {}) {
        return BigInt(
          await a(() => e.request({ method: 'eth_blockNumber' }), {
            cacheKey: s(e.uid),
            cacheTime: t,
          })
        );
      }
    },
    80218: function (e, t, n) {
      'use strict';
      n.d(t, {
        L: function () {
          return i;
        },
      });
      var r = n(79e3);
      async function i(e) {
        let t = await e.request({ method: 'eth_chainId' }, { dedupe: !0 });
        return (0, r.ly)(t);
      }
    },
    91326: function (e, t, n) {
      'use strict';
      n.d(t, {
        C: function () {
          return i;
        },
      });
      var r = n(84196);
      async function i(e, { address: t, blockNumber: n, blockTag: i = 'latest' }) {
        let a = void 0 !== n ? (0, r.eC)(n) : void 0,
          s = await e.request({ method: 'eth_getCode', params: [t, a || i] }, { dedupe: !!a });
        if ('0x' !== s) return s;
      }
    },
    35395: function (e, t, n) {
      'use strict';
      n.d(t, {
        K: function () {
          return a;
        },
      });
      var r = n(49346),
        i = n(39713);
      async function a(e, { filter: t }) {
        let n = 'strict' in t && t.strict,
          a = await t.request({ method: 'eth_getFilterChanges', params: [t.id] });
        if ('string' == typeof a[0]) return a;
        let s = a.map((e) => (0, i.U)(e));
        return 'abi' in t && t.abi ? (0, r.h)({ abi: t.abi, logs: s, strict: n }) : s;
      }
    },
    15363: function (e, t, n) {
      'use strict';
      async function r(e) {
        return BigInt(await e.request({ method: 'eth_gasPrice' }));
      }
      n.d(t, {
        o: function () {
          return r;
        },
      });
    },
    11662: function (e, t, n) {
      'use strict';
      n.d(t, {
        f: function () {
          return s;
        },
      });
      var r = n(29408),
        i = n(84196),
        a = n(81908);
      async function s(e, { blockHash: t, blockNumber: n, blockTag: s, hash: o, index: l }) {
        let u = s || 'latest',
          c = void 0 !== n ? (0, i.eC)(n) : void 0,
          d = null;
        if (
          (o
            ? (d = await e.request(
                { method: 'eth_getTransactionByHash', params: [o] },
                { dedupe: !0 }
              ))
            : t
              ? (d = await e.request(
                  { method: 'eth_getTransactionByBlockHashAndIndex', params: [t, (0, i.eC)(l)] },
                  { dedupe: !0 }
                ))
              : (c || u) &&
                (d = await e.request(
                  {
                    method: 'eth_getTransactionByBlockNumberAndIndex',
                    params: [c || u, (0, i.eC)(l)],
                  },
                  { dedupe: !!c }
                )),
          !d)
        )
          throw new r.Bh({ blockHash: t, blockNumber: n, blockTag: u, hash: o, index: l });
        return (e.chain?.formatters?.transaction?.format || a.Tr)(d);
      }
    },
    9185: function (e, t, n) {
      'use strict';
      n.d(t, {
        K: function () {
          return a;
        },
      });
      var r = n(79e3),
        i = n(84196);
      async function a(e, { address: t, blockTag: n = 'latest', blockNumber: a }) {
        let s = await e.request(
          { method: 'eth_getTransactionCount', params: [t, a ? (0, i.eC)(a) : n] },
          { dedupe: !!a }
        );
        return (0, r.ly)(s);
      }
    },
    34940: function (e, t, n) {
      'use strict';
      n.d(t, {
        a: function () {
          return a;
        },
      });
      var r = n(29408),
        i = n(30774);
      async function a(e, { hash: t }) {
        let n = await e.request(
          { method: 'eth_getTransactionReceipt', params: [t] },
          { dedupe: !0 }
        );
        if (!n) throw new r.Yb({ hash: t });
        return (e.chain?.formatters?.transactionReceipt?.format || i.fA)(n);
      }
    },
    88052: function (e, t, n) {
      'use strict';
      n.d(t, {
        A: function () {
          return h;
        },
      });
      var r = n(59370),
        i = n(57585),
        a = n(88154),
        s = n(54484),
        o = n(29629),
        l = n(392),
        u = n(53064),
        c = n(54494),
        d = n(61896),
        p = n(86705);
      async function h(e, t) {
        let {
            allowFailure: n = !0,
            batchSize: h,
            blockNumber: y,
            blockTag: f,
            multicallAddress: m,
            stateOverride: g,
          } = t,
          b = t.contracts,
          w = h ?? (('object' == typeof e.batch?.multicall && e.batch.multicall.batchSize) || 1024),
          v = m;
        if (!v) {
          if (!e.chain) throw Error('client chain not configured. multicallAddress is required.');
          v = (0, u.L)({ blockNumber: y, chain: e.chain, contract: 'multicall3' });
        }
        let T = [[]],
          A = 0,
          E = 0;
        for (let e = 0; e < b.length; e++) {
          let { abi: t, address: r, args: i, functionName: a } = b[e];
          try {
            let e = (0, l.R)({ abi: t, args: i, functionName: a });
            (E += (e.length - 2) / 2),
              w > 0 && E > w && T[A].length > 0 && (A++, (E = (e.length - 2) / 2), (T[A] = [])),
              (T[A] = [...T[A], { allowFailure: !0, callData: e, target: r }]);
          } catch (s) {
            let e = (0, c.S)(s, {
              abi: t,
              address: r,
              args: i,
              docsPath: '/docs/contract/multicall',
              functionName: a,
            });
            if (!n) throw e;
            T[A] = [...T[A], { allowFailure: !0, callData: '0x', target: r }];
          }
        }
        let C = await Promise.allSettled(
            T.map((t) =>
              (0, d.s)(
                e,
                p.L,
                'readContract'
              )({
                abi: r.F8,
                address: v,
                args: [t],
                blockNumber: y,
                blockTag: f,
                functionName: 'aggregate3',
                stateOverride: g,
              })
            )
          ),
          _ = [];
        for (let e = 0; e < C.length; e++) {
          let t = C[e];
          if ('rejected' === t.status) {
            if (!n) throw t.reason;
            for (let n = 0; n < T[e].length; n++)
              _.push({ status: 'failure', error: t.reason, result: void 0 });
            continue;
          }
          let r = t.value;
          for (let t = 0; t < r.length; t++) {
            let { returnData: a, success: l } = r[t],
              { callData: u } = T[e][t],
              { abi: d, address: p, functionName: h, args: y } = b[_.length];
            try {
              if ('0x' === u) throw new i.wb();
              if (!l) throw new s.VQ({ data: a });
              let e = (0, o.k)({ abi: d, args: y, data: a, functionName: h });
              _.push(n ? { result: e, status: 'success' } : e);
            } catch (t) {
              let e = (0, c.S)(t, {
                abi: d,
                address: p,
                args: y,
                docsPath: '/docs/contract/multicall',
                functionName: h,
              });
              if (!n) throw e;
              _.push({ error: e, result: void 0, status: 'failure' });
            }
          }
        }
        if (_.length !== b.length) throw new a.G('multicall results mismatch');
        return _;
      }
    },
    86705: function (e, t, n) {
      'use strict';
      n.d(t, {
        L: function () {
          return l;
        },
      });
      var r = n(29629),
        i = n(392),
        a = n(54494),
        s = n(61896),
        o = n(69183);
      async function l(e, t) {
        let { abi: n, address: l, args: u, functionName: c, ...d } = t,
          p = (0, i.R)({ abi: n, args: u, functionName: c });
        try {
          let { data: t } = await (0, s.s)(e, o.R, 'call')({ ...d, data: p, to: l });
          return (0, r.k)({ abi: n, args: u, functionName: c, data: t || '0x' });
        } catch (e) {
          throw (0, a.S)(e, {
            abi: n,
            address: l,
            args: u,
            docsPath: '/docs/contract/readContract',
            functionName: c,
          });
        }
      }
    },
    41340: function (e, t, n) {
      'use strict';
      async function r(e, { filter: t }) {
        return t.request({ method: 'eth_uninstallFilter', params: [t.id] });
      }
      n.d(t, {
        W: function () {
          return r;
        },
      });
    },
    5712: function (e, t, n) {
      'use strict';
      n.d(t, {
        e: function () {
          return y;
        },
      });
      var r = n(58427),
        i = n(29408),
        a = n(61896),
        s = n(54658),
        o = n(4846),
        l = n(74118),
        u = n(97352),
        c = n(51541),
        d = n(11662),
        p = n(34940),
        h = n(7566);
      async function y(
        e,
        {
          confirmations: t = 1,
          hash: n,
          onReplaced: y,
          pollingInterval: f = e.pollingInterval,
          retryCount: m = 6,
          retryDelay: g = ({ count: e }) => 200 * ~~(1 << e),
          timeout: b = 18e4,
        }
      ) {
        let w, v, T;
        let A = (0, u.P)(['waitForTransactionReceipt', e.uid, n]),
          E = !1,
          { promise: C, resolve: _, reject: I } = (0, o.n)(),
          S = b ? setTimeout(() => I(new i.mc({ hash: n })), b) : void 0,
          P = (0, s.N7)(A, { onReplaced: y, resolve: _, reject: I }, (s) => {
            let o = (0, a.s)(
              e,
              h.q,
              'watchBlockNumber'
            )({
              emitMissed: !0,
              emitOnBegin: !0,
              poll: !0,
              pollingInterval: f,
              async onBlockNumber(u) {
                let h = (e) => {
                    clearTimeout(S), o(), e(), P();
                  },
                  y = u;
                if (!E)
                  try {
                    if (T) {
                      if (t > 1 && (!T.blockNumber || y - T.blockNumber + 1n < t)) return;
                      h(() => s.resolve(T));
                      return;
                    }
                    if (
                      (w ||
                        ((E = !0),
                        await (0, l.J)(
                          async () => {
                            (w = await (0, a.s)(e, d.f, 'getTransaction')({ hash: n }))
                              .blockNumber && (y = w.blockNumber);
                          },
                          { delay: g, retryCount: m }
                        ),
                        (E = !1)),
                      (T = await (0, a.s)(e, p.a, 'getTransactionReceipt')({ hash: n })),
                      t > 1 && (!T.blockNumber || y - T.blockNumber + 1n < t))
                    )
                      return;
                    h(() => s.resolve(T));
                  } catch (n) {
                    if (n instanceof i.Bh || n instanceof i.Yb) {
                      if (!w) {
                        E = !1;
                        return;
                      }
                      try {
                        (v = w), (E = !0);
                        let n = await (0, l.J)(
                          () =>
                            (0, a.s)(
                              e,
                              c.Q,
                              'getBlock'
                            )({ blockNumber: y, includeTransactions: !0 }),
                          {
                            delay: g,
                            retryCount: m,
                            shouldRetry: ({ error: e }) => e instanceof r.f,
                          }
                        );
                        E = !1;
                        let i = n.transactions.find(
                          ({ from: e, nonce: t }) => e === v.from && t === v.nonce
                        );
                        if (
                          !i ||
                          ((T = await (0, a.s)(e, p.a, 'getTransactionReceipt')({ hash: i.hash })),
                          t > 1 && (!T.blockNumber || y - T.blockNumber + 1n < t))
                        )
                          return;
                        let o = 'replaced';
                        i.to === v.to && i.value === v.value && i.input === v.input
                          ? (o = 'repriced')
                          : i.from === i.to && 0n === i.value && (o = 'cancelled'),
                          h(() => {
                            s.onReplaced?.({
                              reason: o,
                              replacedTransaction: v,
                              transaction: i,
                              transactionReceipt: T,
                            }),
                              s.resolve(T);
                          });
                      } catch (e) {
                        h(() => s.reject(e));
                      }
                    } else h(() => s.reject(n));
                  }
              },
            });
          });
        return C;
      }
    },
    7566: function (e, t, n) {
      'use strict';
      n.d(t, {
        q: function () {
          return u;
        },
      });
      var r = n(79e3),
        i = n(61896),
        a = n(54658),
        s = n(45437),
        o = n(97352),
        l = n(20168);
      function u(
        e,
        {
          emitOnBegin: t = !1,
          emitMissed: n = !1,
          onBlockNumber: u,
          onError: c,
          poll: d,
          pollingInterval: p = e.pollingInterval,
        }
      ) {
        let h;
        return (
          void 0 !== d
            ? d
            : 'webSocket' !== e.transport.type &&
              ('fallback' !== e.transport.type ||
                'webSocket' !== e.transport.transports[0].config.type)
        )
          ? (() => {
              let r = (0, o.P)(['watchBlockNumber', e.uid, t, n, p]);
              return (0, a.N7)(r, { onBlockNumber: u, onError: c }, (r) =>
                (0, s.$)(
                  async () => {
                    try {
                      let t = await (0, i.s)(e, l.z, 'getBlockNumber')({ cacheTime: 0 });
                      if (h) {
                        if (t === h) return;
                        if (t - h > 1 && n)
                          for (let e = h + 1n; e < t; e++) r.onBlockNumber(e, h), (h = e);
                      }
                      (!h || t > h) && (r.onBlockNumber(t, h), (h = t));
                    } catch (e) {
                      r.onError?.(e);
                    }
                  },
                  { emitOnBegin: t, interval: p }
                )
              );
            })()
          : (() => {
              let i = (0, o.P)(['watchBlockNumber', e.uid, t, n]);
              return (0, a.N7)(i, { onBlockNumber: u, onError: c }, (t) => {
                let n = !0,
                  i = () => (n = !1);
                return (
                  (async () => {
                    try {
                      let a = (() => {
                          if ('fallback' === e.transport.type) {
                            let t = e.transport.transports.find(
                              (e) => 'webSocket' === e.config.type
                            );
                            return t ? t.value : e.transport;
                          }
                          return e.transport;
                        })(),
                        { unsubscribe: s } = await a.subscribe({
                          params: ['newHeads'],
                          onData(e) {
                            if (!n) return;
                            let i = (0, r.y_)(e.result?.number);
                            t.onBlockNumber(i, h), (h = i);
                          },
                          onError(e) {
                            t.onError?.(e);
                          },
                        });
                      (i = s), n || i();
                    } catch (e) {
                      c?.(e);
                    }
                  })(),
                  () => i()
                );
              });
            })();
      }
    },
    81767: function (e, t, n) {
      'use strict';
      n.d(t, {
        p: function () {
          return l;
        },
      });
      var r = n(61896),
        i = n(54658),
        a = n(45437),
        s = n(97352),
        o = n(51541);
      function l(
        e,
        {
          blockTag: t = 'latest',
          emitMissed: n = !1,
          emitOnBegin: l = !1,
          onBlock: u,
          onError: c,
          includeTransactions: d,
          poll: p,
          pollingInterval: h = e.pollingInterval,
        }
      ) {
        let y, f, m, g;
        let b =
            void 0 !== p
              ? p
              : 'webSocket' !== e.transport.type &&
                ('fallback' !== e.transport.type ||
                  'webSocket' !== e.transport.transports[0].config.type),
          w = d ?? !1;
        return b
          ? (() => {
              let d = (0, s.P)(['watchBlocks', e.uid, t, n, l, w, h]);
              return (0, i.N7)(d, { onBlock: u, onError: c }, (i) =>
                (0, a.$)(
                  async () => {
                    try {
                      let a = await (0, r.s)(
                        e,
                        o.Q,
                        'getBlock'
                      )({ blockTag: t, includeTransactions: w });
                      if (a.number && y?.number) {
                        if (a.number === y.number) return;
                        if (a.number - y.number > 1 && n)
                          for (let t = y?.number + 1n; t < a.number; t++) {
                            let n = await (0, r.s)(
                              e,
                              o.Q,
                              'getBlock'
                            )({ blockNumber: t, includeTransactions: w });
                            i.onBlock(n, y), (y = n);
                          }
                      }
                      (!y?.number ||
                        ('pending' === t && !a?.number) ||
                        (a.number && a.number > y.number)) &&
                        (i.onBlock(a, y), (y = a));
                    } catch (e) {
                      i.onError?.(e);
                    }
                  },
                  { emitOnBegin: l, interval: h }
                )
              );
            })()
          : ((f = !0),
            (m = !0),
            (g = () => (f = !1)),
            (async () => {
              try {
                l &&
                  (0, r.s)(
                    e,
                    o.Q,
                    'getBlock'
                  )({ blockTag: t, includeTransactions: w }).then((e) => {
                    f && m && (u(e, void 0), (m = !1));
                  });
                let n = (() => {
                    if ('fallback' === e.transport.type) {
                      let t = e.transport.transports.find((e) => 'webSocket' === e.config.type);
                      return t ? t.value : e.transport;
                    }
                    return e.transport;
                  })(),
                  { unsubscribe: i } = await n.subscribe({
                    params: ['newHeads'],
                    async onData(t) {
                      if (!f) return;
                      let n = await (0, r.s)(
                        e,
                        o.Q,
                        'getBlock'
                      )({ blockNumber: t.blockNumber, includeTransactions: w }).catch(() => {});
                      f && (u(n, y), (m = !1), (y = n));
                    },
                    onError(e) {
                      c?.(e);
                    },
                  });
                (g = i), f || g();
              } catch (e) {
                c?.(e);
              }
            })(),
            () => g());
      }
    },
    15921: function (e, t, n) {
      'use strict';
      n.d(t, {
        O: function () {
          return c;
        },
      });
      var r = n(61896),
        i = n(54658),
        a = n(45437),
        s = n(97352),
        o = n(68802),
        l = n(35395),
        u = n(41340);
      function c(
        e,
        {
          batch: t = !0,
          onError: n,
          onTransactions: c,
          poll: d,
          pollingInterval: p = e.pollingInterval,
        }
      ) {
        let h, y;
        return (void 0 !== d ? d : 'webSocket' !== e.transport.type)
          ? (() => {
              let d = (0, s.P)(['watchPendingTransactions', e.uid, t, p]);
              return (0, i.N7)(d, { onTransactions: c, onError: n }, (n) => {
                let i;
                let s = (0, a.$)(
                  async () => {
                    try {
                      if (!i)
                        try {
                          i = await (0, r.s)(e, o.W, 'createPendingTransactionFilter')({});
                          return;
                        } catch (e) {
                          throw (s(), e);
                        }
                      let a = await (0, r.s)(e, l.K, 'getFilterChanges')({ filter: i });
                      if (0 === a.length) return;
                      if (t) n.onTransactions(a);
                      else for (let e of a) n.onTransactions([e]);
                    } catch (e) {
                      n.onError?.(e);
                    }
                  },
                  { emitOnBegin: !0, interval: p }
                );
                return async () => {
                  i && (await (0, r.s)(e, u.W, 'uninstallFilter')({ filter: i })), s();
                };
              });
            })()
          : ((h = !0),
            (y = () => (h = !1)),
            (async () => {
              try {
                let { unsubscribe: t } = await e.transport.subscribe({
                  params: ['newPendingTransactions'],
                  onData(e) {
                    if (!h) return;
                    let t = e.result;
                    c([t]);
                  },
                  onError(e) {
                    n?.(e);
                  },
                });
                (y = t), h || y();
              } catch (e) {
                n?.(e);
              }
            })(),
            () => y());
      }
    },
    90936: function (e, t, n) {
      'use strict';
      n.d(t, {
        QZ: function () {
          return g;
        },
        ZE: function () {
          return w;
        },
      });
      var r = n(65099),
        i = n(59501),
        a = n(18452),
        s = n(51541),
        o = n(9185),
        l = n(54646),
        u = n(31071),
        c = n(48459),
        d = n(41495),
        p = n(87865),
        h = n(61896),
        y = n(26677),
        f = n(4451),
        m = n(80218);
      let g = ['blobVersionedHashes', 'chainId', 'fees', 'gas', 'nonce', 'type'],
        b = new Map();
      async function w(e, t) {
        let n, w;
        let {
            account: v = e.account,
            blobs: T,
            chain: A,
            gas: E,
            kzg: C,
            nonce: _,
            nonceManager: I,
            parameters: S = g,
            type: P,
          } = t,
          O = v ? (0, r.T)(v) : v,
          N = { ...t, ...(O ? { from: O?.address } : {}) };
        async function x() {
          return n || (n = await (0, h.s)(e, s.Q, 'getBlock')({ blockTag: 'latest' }));
        }
        async function M() {
          return (
            w ||
            (A
              ? A.id
              : void 0 !== t.chainId
                ? t.chainId
                : (w = await (0, h.s)(e, m.L, 'getChainId')({})))
          );
        }
        if (S.includes('nonce') && void 0 === _ && O) {
          if (I) {
            let t = await M();
            N.nonce = await I.consume({ address: O.address, chainId: t, client: e });
          } else
            N.nonce = await (0, h.s)(
              e,
              o.K,
              'getTransactionCount'
            )({ address: O.address, blockTag: 'pending' });
        }
        if ((S.includes('blobVersionedHashes') || S.includes('sidecars')) && T && C) {
          let e = (0, u.P)({ blobs: T, kzg: C });
          if (S.includes('blobVersionedHashes')) {
            let t = (0, d.C)({ commitments: e, to: 'hex' });
            N.blobVersionedHashes = t;
          }
          if (S.includes('sidecars')) {
            let t = (0, c.y)({ blobs: T, commitments: e, kzg: C }),
              n = (0, p.j)({ blobs: T, commitments: e, proofs: t, to: 'hex' });
            N.sidecars = n;
          }
        }
        if (
          (S.includes('chainId') && (N.chainId = await M()),
          (S.includes('fees') || S.includes('type')) && void 0 === P)
        )
          try {
            N.type = (0, f.l)(N);
          } catch {
            let t = b.get(e.uid);
            if (void 0 === t) {
              let n = await x();
              (t = 'bigint' == typeof n?.baseFeePerGas), b.set(e.uid, t);
            }
            N.type = t ? 'eip1559' : 'legacy';
          }
        if (S.includes('fees')) {
          if ('legacy' !== N.type && 'eip2930' !== N.type) {
            if (void 0 === N.maxFeePerGas || void 0 === N.maxPriorityFeePerGas) {
              let n = await x(),
                { maxFeePerGas: r, maxPriorityFeePerGas: a } = await (0, i.C)(e, {
                  block: n,
                  chain: A,
                  request: N,
                });
              if (void 0 === t.maxPriorityFeePerGas && t.maxFeePerGas && t.maxFeePerGas < a)
                throw new l.ld({ maxPriorityFeePerGas: a });
              (N.maxPriorityFeePerGas = a), (N.maxFeePerGas = r);
            }
          } else {
            if (void 0 !== t.maxFeePerGas || void 0 !== t.maxPriorityFeePerGas) throw new l.e5();
            if (void 0 === t.gasPrice) {
              let t = await x(),
                { gasPrice: n } = await (0, i.C)(e, {
                  block: t,
                  chain: A,
                  request: N,
                  type: 'legacy',
                });
              N.gasPrice = n;
            }
          }
        }
        return (
          S.includes('gas') &&
            void 0 === E &&
            (N.gas = await (0, h.s)(
              e,
              a.Q,
              'estimateGas'
            )({ ...N, account: O ? { address: O.address, type: 'json-rpc' } : O })),
          (0, y.F)(N),
          delete N.parameters,
          N
        );
      }
    },
    53125: function (e, t, n) {
      'use strict';
      async function r(e, { serializedTransaction: t }) {
        return e.request({ method: 'eth_sendRawTransaction', params: [t] }, { retryCount: 0 });
      }
      n.d(t, {
        p: function () {
          return r;
        },
      });
    },
    88362: function (e, t, n) {
      'use strict';
      n.d(t, {
        T: function () {
          return b;
        },
      });
      var r = n(65099),
        i = n(91560),
        a = n(88154),
        s = n(6465),
        o = n(37520),
        l = n(25655),
        u = n(44542),
        c = n(40740),
        d = n(61896),
        p = n(10579),
        h = n(26677),
        y = n(80218),
        f = n(90936),
        m = n(53125);
      let g = new p.k(128);
      async function b(e, t) {
        let {
          account: n = e.account,
          chain: p = e.chain,
          accessList: b,
          authorizationList: w,
          blobs: v,
          data: T,
          gas: A,
          gasPrice: E,
          maxFeePerBlobGas: C,
          maxFeePerGas: _,
          maxPriorityFeePerGas: I,
          nonce: S,
          value: P,
          ...O
        } = t;
        if (void 0 === n) throw new i.o({ docsPath: '/docs/actions/wallet/sendTransaction' });
        let N = n ? (0, r.T)(n) : null;
        try {
          (0, h.F)(t);
          let n = await (async () =>
            t.to
              ? t.to
              : null !== t.to && w && w.length > 0
                ? await (0, s.z)({ authorization: w[0] }).catch(() => {
                    throw new a.G('`to` is required. Could not infer from `authorizationList`.');
                  })
                : void 0)();
          if (N?.type === 'json-rpc' || null === N) {
            let t;
            null !== p &&
              ((t = await (0, d.s)(e, y.L, 'getChainId')({})),
              (0, o.q)({ currentChainId: t, chain: p }));
            let r = e.chain?.formatters?.transactionRequest?.format,
              i = (r || c.tG)({
                ...(0, u.K)(O, { format: r }),
                accessList: b,
                authorizationList: w,
                blobs: v,
                chainId: t,
                data: T,
                from: N?.address,
                gas: A,
                gasPrice: E,
                maxFeePerBlobGas: C,
                maxFeePerGas: _,
                maxPriorityFeePerGas: I,
                nonce: S,
                to: n,
                value: P,
              }),
              a = g.get(e.uid);
            try {
              return await e.request(
                { method: a ? 'wallet_sendTransaction' : 'eth_sendTransaction', params: [i] },
                { retryCount: 0 }
              );
            } catch (t) {
              if (!1 === a) throw t;
              if (
                'InvalidInputRpcError' === t.name ||
                'InvalidParamsRpcError' === t.name ||
                'MethodNotFoundRpcError' === t.name ||
                'MethodNotSupportedRpcError' === t.name
              )
                return await e
                  .request({ method: 'wallet_sendTransaction', params: [i] }, { retryCount: 0 })
                  .then((t) => (g.set(e.uid, !0), t))
                  .catch((n) => {
                    if (
                      'MethodNotFoundRpcError' === n.name ||
                      'MethodNotSupportedRpcError' === n.name
                    )
                      throw (g.set(e.uid, !1), t);
                    throw n;
                  });
              throw t;
            }
          }
          if (N?.type === 'local') {
            let t = await (0, d.s)(
                e,
                f.ZE,
                'prepareTransactionRequest'
              )({
                account: N,
                accessList: b,
                authorizationList: w,
                blobs: v,
                chain: p,
                data: T,
                gas: A,
                gasPrice: E,
                maxFeePerBlobGas: C,
                maxFeePerGas: _,
                maxPriorityFeePerGas: I,
                nonce: S,
                nonceManager: N.nonceManager,
                parameters: [...f.QZ, 'sidecars'],
                value: P,
                ...O,
                to: n,
              }),
              r = p?.serializers?.transaction,
              i = await N.signTransaction(t, { serializer: r });
            return await (0, d.s)(e, m.p, 'sendRawTransaction')({ serializedTransaction: i });
          }
          if (N?.type === 'smart')
            throw new i.Y({
              metaMessages: ['Consider using the `sendUserOperation` Action instead.'],
              docsPath: '/docs/actions/bundler/sendUserOperation',
              type: 'smart',
            });
          throw new i.Y({ docsPath: '/docs/actions/wallet/sendTransaction', type: N?.type });
        } catch (e) {
          if (e instanceof i.Y) throw e;
          throw (0, l.$)(e, { ...t, account: N, chain: t.chain || void 0 });
        }
      }
    },
    38657: function (e, t, n) {
      'use strict';
      n.d(t, {
        l: function () {
          return s;
        },
      });
      var r = n(65099),
        i = n(91560),
        a = n(84196);
      async function s(e, { account: t = e.account, message: n }) {
        if (!t) throw new i.o({ docsPath: '/docs/actions/wallet/signMessage' });
        let s = (0, r.T)(t);
        if (s.signMessage) return s.signMessage({ message: n });
        let o =
          'string' == typeof n
            ? (0, a.$G)(n)
            : n.raw instanceof Uint8Array
              ? (0, a.NC)(n.raw)
              : n.raw;
        return e.request({ method: 'personal_sign', params: [o, s.address] }, { retryCount: 0 });
      }
    },
    68404: function (e, t, n) {
      'use strict';
      n.d(t, {
        n: function () {
          return u;
        },
      });
      var r = n(65099),
        i = n(91560),
        a = n(392),
        s = n(54494),
        o = n(61896),
        l = n(88362);
      async function u(e, t) {
        let {
          abi: n,
          account: u = e.account,
          address: c,
          args: d,
          dataSuffix: p,
          functionName: h,
          ...y
        } = t;
        if (void 0 === u) throw new i.o({ docsPath: '/docs/contract/writeContract' });
        let f = u ? (0, r.T)(u) : null,
          m = (0, a.R)({ abi: n, args: d, functionName: h });
        try {
          return await (0, o.s)(
            e,
            l.T,
            'sendTransaction'
          )({ data: `${m}${p ? p.replace('0x', '') : ''}`, to: c, account: f, ...y });
        } catch (e) {
          throw (0, s.S)(e, {
            abi: n,
            address: c,
            args: d,
            docsPath: '/docs/contract/writeContract',
            functionName: h,
            sender: f?.address,
          });
        }
      }
    },
    18059: function (e, t, n) {
      'use strict';
      n.d(t, {
        e: function () {
          return a;
        },
      });
      var r = n(65099),
        i = n(31267);
      function a(e) {
        let {
            batch: t,
            cacheTime: n = e.pollingInterval ?? 4e3,
            ccipRead: a,
            key: s = 'base',
            name: o = 'Base Client',
            pollingInterval: l = 4e3,
            type: u = 'base',
          } = e,
          c = e.chain,
          d = e.account ? (0, r.T)(e.account) : void 0,
          { config: p, request: h, value: y } = e.transport({ chain: c, pollingInterval: l }),
          f = {
            account: d,
            batch: t,
            cacheTime: n,
            ccipRead: a,
            chain: c,
            key: s,
            name: o,
            pollingInterval: l,
            request: h,
            transport: { ...p, ...y },
            type: u,
            uid: (0, i.h)(),
          };
        return Object.assign(f, {
          extend: (function e(t) {
            return (n) => {
              let r = n(t);
              for (let e in f) delete r[e];
              let i = { ...t, ...r };
              return Object.assign(i, { extend: e(i) });
            };
          })(f),
        });
      }
    },
    15077: function (e, t, n) {
      'use strict';
      n.d(t, {
        q: function () {
          return d;
        },
      });
      var r = n(88154),
        i = n(40002),
        a = n(18292),
        s = n(84196);
      let o = new (n(10579).k)(8192);
      var l = n(74118),
        u = n(97352),
        c = n(31267);
      function d(
        {
          key: e,
          methods: t,
          name: n,
          request: d,
          retryCount: p = 3,
          retryDelay: h = 150,
          timeout: y,
          type: f,
        },
        m
      ) {
        return {
          config: {
            key: e,
            methods: t,
            name: n,
            request: d,
            retryCount: p,
            retryDelay: h,
            timeout: y,
            type: f,
          },
          request: (function (e, t = {}) {
            return async (n, c = {}) => {
              let {
                  dedupe: d = !1,
                  methods: p,
                  retryDelay: h = 150,
                  retryCount: y = 3,
                  uid: f,
                } = { ...t, ...c },
                { method: m } = n;
              if (p?.exclude?.includes(m) || (p?.include && !p.include.includes(m)))
                throw new a.gS(Error('method not supported'), { method: m });
              let g = d ? (0, s.$G)(`${f}.${(0, u.P)(n)}`) : void 0;
              return (function (e, { enabled: t = !0, id: n }) {
                if (!t || !n) return e();
                if (o.get(n)) return o.get(n);
                let r = e().finally(() => o.delete(n));
                return o.set(n, r), r;
              })(
                () =>
                  (0, l.J)(
                    async () => {
                      try {
                        return await e(n);
                      } catch (e) {
                        switch (e.code) {
                          case a.s7.code:
                            throw new a.s7(e);
                          case a.B.code:
                            throw new a.B(e);
                          case a.LX.code:
                            throw new a.LX(e, { method: n.method });
                          case a.nY.code:
                            throw new a.nY(e);
                          case a.XS.code:
                            throw new a.XS(e);
                          case a.yR.code:
                            throw new a.yR(e);
                          case a.Og.code:
                            throw new a.Og(e);
                          case a.pT.code:
                            throw new a.pT(e);
                          case a.KB.code:
                            throw new a.KB(e);
                          case a.gS.code:
                            throw new a.gS(e, { method: n.method });
                          case a.Pv.code:
                            throw new a.Pv(e);
                          case a.GD.code:
                            throw new a.GD(e);
                          case a.ab.code:
                            throw new a.ab(e);
                          case a.PE.code:
                            throw new a.PE(e);
                          case a.Ts.code:
                            throw new a.Ts(e);
                          case a.u5.code:
                            throw new a.u5(e);
                          case a.I0.code:
                            throw new a.I0(e);
                          case a.x3.code:
                            throw new a.x3(e);
                          case a.vl.code:
                            throw new a.vl(e);
                          case a.Uu.code:
                            throw new a.Uu(e);
                          case a.Nt.code:
                            throw new a.Nt(e);
                          case a.EJ.code:
                            throw new a.EJ(e);
                          case a.fl.code:
                            throw new a.fl(e);
                          case a.NO.code:
                            throw new a.NO(e);
                          case a.r0.code:
                            throw new a.r0(e);
                          case 5e3:
                            throw new a.ab(e);
                          default:
                            if (e instanceof r.G) throw e;
                            throw new a.ir(e);
                        }
                      }
                    },
                    {
                      delay: ({ count: e, error: t }) => {
                        if (t && t instanceof i.Gg) {
                          let e = t?.headers?.get('Retry-After');
                          if (e?.match(/\d/)) return 1e3 * Number.parseInt(e);
                        }
                        return ~~(1 << e) * h;
                      },
                      retryCount: y,
                      shouldRetry: ({ error: e }) =>
                        'code' in e && 'number' == typeof e.code
                          ? -1 === e.code || e.code === a.Pv.code || e.code === a.XS.code
                          : !(e instanceof i.Gg) ||
                            !e.status ||
                            403 === e.status ||
                            408 === e.status ||
                            413 === e.status ||
                            429 === e.status ||
                            500 === e.status ||
                            502 === e.status ||
                            503 === e.status ||
                            504 === e.status,
                    }
                  ),
                { enabled: d, id: g }
              );
            };
          })(d, { methods: t, retryCount: p, retryDelay: h, uid: (0, c.h)() }),
          value: m,
        };
      }
    },
    22791: function (e, t, n) {
      'use strict';
      n.d(t, {
        tv: function () {
          return o;
        },
      });
      var r = n(65264),
        i = n(18292),
        a = n(85533),
        s = n(15077);
      function o(e, t = {}) {
        let {
          key: n = 'fallback',
          name: r = 'Fallback',
          rank: i = !1,
          shouldThrow: o = l,
          retryCount: u,
          retryDelay: c,
        } = t;
        return ({ chain: t, pollingInterval: l = 4e3, timeout: d, ...p }) => {
          let h = e,
            y = () => {},
            f = (0, s.q)(
              {
                key: n,
                name: r,
                async request({ method: e, params: n }) {
                  let r;
                  let i = async (a = 0) => {
                    let s = h[a]({ ...p, chain: t, retryCount: 0, timeout: d });
                    try {
                      let t = await s.request({ method: e, params: n });
                      return (
                        y({ method: e, params: n, response: t, transport: s, status: 'success' }), t
                      );
                    } catch (l) {
                      if (
                        (y({ error: l, method: e, params: n, transport: s, status: 'error' }),
                        o(l) ||
                          a === h.length - 1 ||
                          !(r ??= h.slice(a + 1).some((n) => {
                            let { include: r, exclude: i } = n({ chain: t }).config.methods || {};
                            return r ? r.includes(e) : !i || !i.includes(e);
                          })))
                      )
                        throw l;
                      return i(a + 1);
                    }
                  };
                  return i();
                },
                retryCount: u,
                retryDelay: c,
                type: 'fallback',
              },
              {
                onResponse: (e) => (y = e),
                transports: h.map((e) => e({ chain: t, retryCount: 0 })),
              }
            );
          if (i) {
            let e = 'object' == typeof i ? i : {};
            !(function ({
              chain: e,
              interval: t = 4e3,
              onTransports: n,
              ping: r,
              sampleCount: i = 10,
              timeout: s = 1e3,
              transports: o,
              weights: l = {},
            }) {
              let { stability: u = 0.7, latency: c = 0.3 } = l,
                d = [],
                p = async () => {
                  let l = await Promise.all(
                    o.map(async (t) => {
                      let n, i;
                      let a = t({ chain: e, retryCount: 0, timeout: s }),
                        o = Date.now();
                      try {
                        await (r ? r({ transport: a }) : a.request({ method: 'net_listening' })),
                          (i = 1);
                      } catch {
                        i = 0;
                      } finally {
                        n = Date.now();
                      }
                      return { latency: n - o, success: i };
                    })
                  );
                  d.push(l), d.length > i && d.shift();
                  let h = Math.max(...d.map((e) => Math.max(...e.map(({ latency: e }) => e))));
                  n(
                    o
                      .map((e, t) => {
                        let n = d.map((e) => e[t].latency),
                          r = n.reduce((e, t) => e + t, 0) / n.length,
                          i = d.map((e) => e[t].success),
                          a = i.reduce((e, t) => e + t, 0) / i.length;
                        return 0 === a ? [0, t] : [c * (1 - r / h) + u * a, t];
                      })
                      .sort((e, t) => t[0] - e[0])
                      .map(([, e]) => o[e])
                  ),
                    await (0, a.D)(t),
                    p();
                };
              p();
            })({
              chain: t,
              interval: e.interval ?? l,
              onTransports: (e) => (h = e),
              ping: e.ping,
              sampleCount: e.sampleCount,
              timeout: e.timeout,
              transports: h,
              weights: e.weights,
            });
          }
          return f;
        };
      }
      function l(e) {
        return !!(
          'code' in e &&
          'number' == typeof e.code &&
          (e.code === i.KB.code ||
            e.code === i.ab.code ||
            r.M_.nodeMessage.test(e.message) ||
            5e3 === e.code)
        );
      }
    },
    32224: function (e, t, n) {
      'use strict';
      n.d(t, {
        d: function () {
          return d;
        },
      });
      var r = n(40002),
        i = n(88154);
      class a extends i.G {
        constructor() {
          super(
            'No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.',
            { docsPath: '/docs/clients/intro', name: 'UrlRequiredError' }
          );
        }
      }
      var s = n(42002),
        o = n(30390),
        l = n(97352);
      let u = {
        current: 0,
        take() {
          return this.current++;
        },
        reset() {
          this.current = 0;
        },
      };
      var c = n(15077);
      function d(e, t = {}) {
        let {
          batch: n,
          fetchOptions: i,
          key: d = 'http',
          methods: p,
          name: h = 'HTTP JSON-RPC',
          onFetchRequest: y,
          onFetchResponse: f,
          retryDelay: m,
          raw: g,
        } = t;
        return ({ chain: b, retryCount: w, timeout: v }) => {
          let { batchSize: T = 1e3, wait: A = 0 } = 'object' == typeof n ? n : {},
            E = t.retryCount ?? w,
            C = v ?? t.timeout ?? 1e4,
            _ = e || b?.rpcUrls.default.http[0];
          if (!_) throw new a();
          let I = (function (e, t = {}) {
            return {
              async request(n) {
                let {
                    body: i,
                    onRequest: a = t.onRequest,
                    onResponse: s = t.onResponse,
                    timeout: c = t.timeout ?? 1e4,
                  } = n,
                  d = { ...(t.fetchOptions ?? {}), ...(n.fetchOptions ?? {}) },
                  { headers: p, method: h, signal: y } = d;
                try {
                  let t;
                  let n = await (0, o.F)(
                    async ({ signal: t }) => {
                      let n = {
                          ...d,
                          body: Array.isArray(i)
                            ? (0, l.P)(
                                i.map((e) => ({ jsonrpc: '2.0', id: e.id ?? u.take(), ...e }))
                              )
                            : (0, l.P)({ jsonrpc: '2.0', id: i.id ?? u.take(), ...i }),
                          headers: { 'Content-Type': 'application/json', ...p },
                          method: h || 'POST',
                          signal: y || (c > 0 ? t : null),
                        },
                        r = new Request(e, n),
                        s = (await a?.(r, n)) ?? { ...n, url: e };
                      return await fetch(s.url ?? e, s);
                    },
                    { errorInstance: new r.W5({ body: i, url: e }), timeout: c, signal: !0 }
                  );
                  if (
                    (s && (await s(n)),
                    n.headers.get('Content-Type')?.startsWith('application/json'))
                  )
                    t = await n.json();
                  else {
                    t = await n.text();
                    try {
                      t = JSON.parse(t || '{}');
                    } catch (e) {
                      if (n.ok) throw e;
                      t = { error: t };
                    }
                  }
                  if (!n.ok)
                    throw new r.Gg({
                      body: i,
                      details: (0, l.P)(t.error) || n.statusText,
                      headers: n.headers,
                      status: n.status,
                      url: e,
                    });
                  return t;
                } catch (t) {
                  if (t instanceof r.Gg || t instanceof r.W5) throw t;
                  throw new r.Gg({ body: i, cause: t, url: e });
                }
              },
            };
          })(_, { fetchOptions: i, onRequest: y, onResponse: f, timeout: C });
          return (0, c.q)(
            {
              key: d,
              methods: p,
              name: h,
              async request({ method: e, params: t }) {
                let i = { method: e, params: t },
                  { schedule: a } = (0, s.S)({
                    id: _,
                    wait: A,
                    shouldSplitBatch: (e) => e.length > T,
                    fn: (e) => I.request({ body: e }),
                    sort: (e, t) => e.id - t.id,
                  }),
                  o = async (e) => (n ? a(e) : [await I.request({ body: e })]),
                  [{ error: l, result: u }] = await o(i);
                if (g) return { error: l, result: u };
                if (l) throw new r.bs({ body: i, error: l, url: _ });
                return u;
              },
              retryCount: E,
              retryDelay: m,
              timeout: C,
              type: 'http',
            },
            { fetchOptions: i, url: _ }
          );
        };
      }
    },
    59370: function (e, t, n) {
      'use strict';
      n.d(t, {
        $o: function () {
          return c;
        },
        F8: function () {
          return r;
        },
        Wo: function () {
          return d;
        },
        X$: function () {
          return u;
        },
        Yi: function () {
          return i;
        },
        du: function () {
          return o;
        },
        k3: function () {
          return s;
        },
        nZ: function () {
          return l;
        },
      });
      let r = [
          {
            inputs: [
              {
                components: [
                  { name: 'target', type: 'address' },
                  { name: 'allowFailure', type: 'bool' },
                  { name: 'callData', type: 'bytes' },
                ],
                name: 'calls',
                type: 'tuple[]',
              },
            ],
            name: 'aggregate3',
            outputs: [
              {
                components: [
                  { name: 'success', type: 'bool' },
                  { name: 'returnData', type: 'bytes' },
                ],
                name: 'returnData',
                type: 'tuple[]',
              },
            ],
            stateMutability: 'view',
            type: 'function',
          },
        ],
        i = [
          {
            name: 'query',
            type: 'function',
            stateMutability: 'view',
            inputs: [
              {
                type: 'tuple[]',
                name: 'queries',
                components: [
                  { type: 'address', name: 'sender' },
                  { type: 'string[]', name: 'urls' },
                  { type: 'bytes', name: 'data' },
                ],
              },
            ],
            outputs: [
              { type: 'bool[]', name: 'failures' },
              { type: 'bytes[]', name: 'responses' },
            ],
          },
          {
            name: 'HttpError',
            type: 'error',
            inputs: [
              { type: 'uint16', name: 'status' },
              { type: 'string', name: 'message' },
            ],
          },
        ],
        a = [
          { inputs: [], name: 'ResolverNotFound', type: 'error' },
          { inputs: [], name: 'ResolverWildcardNotSupported', type: 'error' },
          { inputs: [], name: 'ResolverNotContract', type: 'error' },
          { inputs: [{ name: 'returnData', type: 'bytes' }], name: 'ResolverError', type: 'error' },
          {
            inputs: [
              {
                components: [
                  { name: 'status', type: 'uint16' },
                  { name: 'message', type: 'string' },
                ],
                name: 'errors',
                type: 'tuple[]',
              },
            ],
            name: 'HttpError',
            type: 'error',
          },
        ],
        s = [
          ...a,
          {
            name: 'resolve',
            type: 'function',
            stateMutability: 'view',
            inputs: [
              { name: 'name', type: 'bytes' },
              { name: 'data', type: 'bytes' },
            ],
            outputs: [
              { name: '', type: 'bytes' },
              { name: 'address', type: 'address' },
            ],
          },
          {
            name: 'resolve',
            type: 'function',
            stateMutability: 'view',
            inputs: [
              { name: 'name', type: 'bytes' },
              { name: 'data', type: 'bytes' },
              { name: 'gateways', type: 'string[]' },
            ],
            outputs: [
              { name: '', type: 'bytes' },
              { name: 'address', type: 'address' },
            ],
          },
        ],
        o = [
          ...a,
          {
            name: 'reverse',
            type: 'function',
            stateMutability: 'view',
            inputs: [{ type: 'bytes', name: 'reverseName' }],
            outputs: [
              { type: 'string', name: 'resolvedName' },
              { type: 'address', name: 'resolvedAddress' },
              { type: 'address', name: 'reverseResolver' },
              { type: 'address', name: 'resolver' },
            ],
          },
          {
            name: 'reverse',
            type: 'function',
            stateMutability: 'view',
            inputs: [
              { type: 'bytes', name: 'reverseName' },
              { type: 'string[]', name: 'gateways' },
            ],
            outputs: [
              { type: 'string', name: 'resolvedName' },
              { type: 'address', name: 'resolvedAddress' },
              { type: 'address', name: 'reverseResolver' },
              { type: 'address', name: 'resolver' },
            ],
          },
        ],
        l = [
          {
            name: 'text',
            type: 'function',
            stateMutability: 'view',
            inputs: [
              { name: 'name', type: 'bytes32' },
              { name: 'key', type: 'string' },
            ],
            outputs: [{ name: '', type: 'string' }],
          },
        ],
        u = [
          {
            name: 'addr',
            type: 'function',
            stateMutability: 'view',
            inputs: [{ name: 'name', type: 'bytes32' }],
            outputs: [{ name: '', type: 'address' }],
          },
          {
            name: 'addr',
            type: 'function',
            stateMutability: 'view',
            inputs: [
              { name: 'name', type: 'bytes32' },
              { name: 'coinType', type: 'uint256' },
            ],
            outputs: [{ name: '', type: 'bytes' }],
          },
        ],
        c = [
          {
            inputs: [
              { name: '_signer', type: 'address' },
              { name: '_hash', type: 'bytes32' },
              { name: '_signature', type: 'bytes' },
            ],
            stateMutability: 'nonpayable',
            type: 'constructor',
          },
          {
            inputs: [
              { name: '_signer', type: 'address' },
              { name: '_hash', type: 'bytes32' },
              { name: '_signature', type: 'bytes' },
            ],
            outputs: [{ type: 'bool' }],
            stateMutability: 'nonpayable',
            type: 'function',
            name: 'isValidSig',
          },
        ],
        d = [
          {
            type: 'event',
            name: 'Approval',
            inputs: [
              { indexed: !0, name: 'owner', type: 'address' },
              { indexed: !0, name: 'spender', type: 'address' },
              { indexed: !1, name: 'value', type: 'uint256' },
            ],
          },
          {
            type: 'event',
            name: 'Transfer',
            inputs: [
              { indexed: !0, name: 'from', type: 'address' },
              { indexed: !0, name: 'to', type: 'address' },
              { indexed: !1, name: 'value', type: 'uint256' },
            ],
          },
          {
            type: 'function',
            name: 'allowance',
            stateMutability: 'view',
            inputs: [
              { name: 'owner', type: 'address' },
              { name: 'spender', type: 'address' },
            ],
            outputs: [{ type: 'uint256' }],
          },
          {
            type: 'function',
            name: 'approve',
            stateMutability: 'nonpayable',
            inputs: [
              { name: 'spender', type: 'address' },
              { name: 'amount', type: 'uint256' },
            ],
            outputs: [{ type: 'bool' }],
          },
          {
            type: 'function',
            name: 'balanceOf',
            stateMutability: 'view',
            inputs: [{ name: 'account', type: 'address' }],
            outputs: [{ type: 'uint256' }],
          },
          {
            type: 'function',
            name: 'decimals',
            stateMutability: 'view',
            inputs: [],
            outputs: [{ type: 'uint8' }],
          },
          {
            type: 'function',
            name: 'name',
            stateMutability: 'view',
            inputs: [],
            outputs: [{ type: 'string' }],
          },
          {
            type: 'function',
            name: 'symbol',
            stateMutability: 'view',
            inputs: [],
            outputs: [{ type: 'string' }],
          },
          {
            type: 'function',
            name: 'totalSupply',
            stateMutability: 'view',
            inputs: [],
            outputs: [{ type: 'uint256' }],
          },
          {
            type: 'function',
            name: 'transfer',
            stateMutability: 'nonpayable',
            inputs: [
              { name: 'recipient', type: 'address' },
              { name: 'amount', type: 'uint256' },
            ],
            outputs: [{ type: 'bool' }],
          },
          {
            type: 'function',
            name: 'transferFrom',
            stateMutability: 'nonpayable',
            inputs: [
              { name: 'sender', type: 'address' },
              { name: 'recipient', type: 'address' },
              { name: 'amount', type: 'uint256' },
            ],
            outputs: [{ type: 'bool' }],
          },
        ];
    },
    67273: function (e, t, n) {
      'use strict';
      n.d(t, {
        NO: function () {
          return r;
        },
        ST: function () {
          return a;
        },
        pG: function () {
          return i;
        },
      });
      let r =
          '0x608060405234801561001057600080fd5b5060405161018e38038061018e83398101604081905261002f91610124565b6000808351602085016000f59050803b61004857600080fd5b6000808351602085016000855af16040513d6000823e81610067573d81fd5b3d81f35b634e487b7160e01b600052604160045260246000fd5b600082601f83011261009257600080fd5b81516001600160401b038111156100ab576100ab61006b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156100d9576100d961006b565b6040528181528382016020018510156100f157600080fd5b60005b82811015610110576020818601810151838301820152016100f4565b506000918101602001919091529392505050565b6000806040838503121561013757600080fd5b82516001600160401b0381111561014d57600080fd5b61015985828601610081565b602085015190935090506001600160401b0381111561017757600080fd5b61018385828601610081565b915050925092905056fe',
        i =
          '0x608060405234801561001057600080fd5b506040516102c03803806102c083398101604081905261002f916101e6565b836001600160a01b03163b6000036100e457600080836001600160a01b03168360405161005c9190610270565b6000604051808303816000865af19150503d8060008114610099576040519150601f19603f3d011682016040523d82523d6000602084013e61009e565b606091505b50915091508115806100b857506001600160a01b0386163b155b156100e1578060405163101bb98d60e01b81526004016100d8919061028c565b60405180910390fd5b50505b6000808451602086016000885af16040513d6000823e81610103573d81fd5b3d81f35b80516001600160a01b038116811461011e57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561015457818101518382015260200161013c565b50506000910152565b600082601f83011261016e57600080fd5b81516001600160401b0381111561018757610187610123565b604051601f8201601f19908116603f011681016001600160401b03811182821017156101b5576101b5610123565b6040528181528382016020018510156101cd57600080fd5b6101de826020830160208701610139565b949350505050565b600080600080608085870312156101fc57600080fd5b61020585610107565b60208601519094506001600160401b0381111561022157600080fd5b61022d8782880161015d565b93505061023c60408601610107565b60608601519092506001600160401b0381111561025857600080fd5b6102648782880161015d565b91505092959194509250565b60008251610282818460208701610139565b9190910192915050565b60208152600082518060208401526102ab816040850160208701610139565b601f01601f1916919091016040019291505056fe',
        a =
          '0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572';
    },
    58395: function (e, t, n) {
      'use strict';
      n.d(t, {
        $: function () {
          return r;
        },
        Up: function () {
          return i;
        },
        hZ: function () {
          return a;
        },
      });
      let r = {
          1: 'An `assert` condition failed.',
          17: 'Arithmetic operation resulted in underflow or overflow.',
          18: 'Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).',
          33: 'Attempted to convert to an invalid type.',
          34: 'Attempted to access a storage byte array that is incorrectly encoded.',
          49: 'Performed `.pop()` on an empty array',
          50: 'Array index is out of bounds.',
          65: 'Allocated too much memory or created an array which is too large.',
          81: 'Attempted to call a zero-initialized variable of internal function type.',
        },
        i = { inputs: [{ name: 'message', type: 'string' }], name: 'Error', type: 'error' },
        a = { inputs: [{ name: 'reason', type: 'uint256' }], name: 'Panic', type: 'error' };
    },
    57585: function (e, t, n) {
      'use strict';
      n.d(t, {
        CI: function () {
          return S;
        },
        FM: function () {
          return m;
        },
        Gy: function () {
          return _;
        },
        KY: function () {
          return E;
        },
        M4: function () {
          return d;
        },
        MS: function () {
          return y;
        },
        MX: function () {
          return v;
        },
        Mi: function () {
          return N;
        },
        S4: function () {
          return A;
        },
        SM: function () {
          return C;
        },
        Zh: function () {
          return h;
        },
        cO: function () {
          return o;
        },
        dh: function () {
          return I;
        },
        eF: function () {
          return T;
        },
        fM: function () {
          return s;
        },
        fs: function () {
          return p;
        },
        gr: function () {
          return c;
        },
        hn: function () {
          return P;
        },
        lC: function () {
          return g;
        },
        mv: function () {
          return b;
        },
        wM: function () {
          return O;
        },
        wb: function () {
          return u;
        },
        xB: function () {
          return l;
        },
        xL: function () {
          return w;
        },
        yP: function () {
          return f;
        },
      });
      var r = n(60478),
        i = n(88155),
        a = n(88154);
      class s extends a.G {
        constructor({ docsPath: e }) {
          super(
            'A constructor was not found on the ABI.\nMake sure you are using the correct ABI and that the constructor exists on it.',
            { docsPath: e, name: 'AbiConstructorNotFoundError' }
          );
        }
      }
      class o extends a.G {
        constructor({ docsPath: e }) {
          super(
            'Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.\nMake sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.',
            { docsPath: e, name: 'AbiConstructorParamsNotFoundError' }
          );
        }
      }
      class l extends a.G {
        constructor({ data: e, params: t, size: n }) {
          super(`Data size of ${n} bytes is too small for given parameters.`, {
            metaMessages: [
              `Params: (${(0, r.h)(t, { includeName: !0 })})`,
              `Data:   ${e} (${n} bytes)`,
            ],
            name: 'AbiDecodingDataSizeTooSmallError',
          }),
            Object.defineProperty(this, 'data', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, 'params', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, 'size', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.data = e),
            (this.params = t),
            (this.size = n);
        }
      }
      class u extends a.G {
        constructor() {
          super('Cannot decode zero data ("0x") with ABI parameters.', {
            name: 'AbiDecodingZeroDataError',
          });
        }
      }
      class c extends a.G {
        constructor({ expectedLength: e, givenLength: t, type: n }) {
          super(
            `ABI encoding array length mismatch for type ${n}.
Expected length: ${e}
Given length: ${t}`,
            { name: 'AbiEncodingArrayLengthMismatchError' }
          );
        }
      }
      class d extends a.G {
        constructor({ expectedSize: e, value: t }) {
          super(
            `Size of bytes "${t}" (bytes${(0, i.d)(t)}) does not match expected size (bytes${e}).`,
            { name: 'AbiEncodingBytesSizeMismatchError' }
          );
        }
      }
      class p extends a.G {
        constructor({ expectedLength: e, givenLength: t }) {
          super(
            `ABI encoding params/values length mismatch.
Expected length (params): ${e}
Given length (values): ${t}`,
            { name: 'AbiEncodingLengthMismatchError' }
          );
        }
      }
      class h extends a.G {
        constructor(e, { docsPath: t }) {
          super(
            `Arguments (\`args\`) were provided to "${e}", but "${e}" on the ABI does not contain any parameters (\`inputs\`).
Cannot encode error result without knowing what the parameter types are.
Make sure you are using the correct ABI and that the inputs exist on it.`,
            { docsPath: t, name: 'AbiErrorInputsNotFoundError' }
          );
        }
      }
      class y extends a.G {
        constructor(e, { docsPath: t } = {}) {
          super(
            `Error ${e ? `"${e}" ` : ''}not found on ABI.
Make sure you are using the correct ABI and that the error exists on it.`,
            { docsPath: t, name: 'AbiErrorNotFoundError' }
          );
        }
      }
      class f extends a.G {
        constructor(e, { docsPath: t }) {
          super(
            `Encoded error signature "${e}" not found on ABI.
Make sure you are using the correct ABI and that the error exists on it.
You can look up the decoded signature here: https://openchain.xyz/signatures?query=${e}.`,
            { docsPath: t, name: 'AbiErrorSignatureNotFoundError' }
          ),
            Object.defineProperty(this, 'signature', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.signature = e);
        }
      }
      class m extends a.G {
        constructor({ docsPath: e }) {
          super('Cannot extract event signature from empty topics.', {
            docsPath: e,
            name: 'AbiEventSignatureEmptyTopicsError',
          });
        }
      }
      class g extends a.G {
        constructor(e, { docsPath: t }) {
          super(
            `Encoded event signature "${e}" not found on ABI.
Make sure you are using the correct ABI and that the event exists on it.
You can look up the signature here: https://openchain.xyz/signatures?query=${e}.`,
            { docsPath: t, name: 'AbiEventSignatureNotFoundError' }
          );
        }
      }
      class b extends a.G {
        constructor(e, { docsPath: t } = {}) {
          super(
            `Event ${e ? `"${e}" ` : ''}not found on ABI.
Make sure you are using the correct ABI and that the event exists on it.`,
            { docsPath: t, name: 'AbiEventNotFoundError' }
          );
        }
      }
      class w extends a.G {
        constructor(e, { docsPath: t } = {}) {
          super(
            `Function ${e ? `"${e}" ` : ''}not found on ABI.
Make sure you are using the correct ABI and that the function exists on it.`,
            { docsPath: t, name: 'AbiFunctionNotFoundError' }
          );
        }
      }
      class v extends a.G {
        constructor(e, { docsPath: t }) {
          super(
            `Function "${e}" does not contain any \`outputs\` on ABI.
Cannot decode function result without knowing what the parameter types are.
Make sure you are using the correct ABI and that the function exists on it.`,
            { docsPath: t, name: 'AbiFunctionOutputsNotFoundError' }
          );
        }
      }
      class T extends a.G {
        constructor(e, { docsPath: t }) {
          super(
            `Encoded function signature "${e}" not found on ABI.
Make sure you are using the correct ABI and that the function exists on it.
You can look up the signature here: https://openchain.xyz/signatures?query=${e}.`,
            { docsPath: t, name: 'AbiFunctionSignatureNotFoundError' }
          );
        }
      }
      class A extends a.G {
        constructor(e, t) {
          super('Found ambiguous types in overloaded ABI items.', {
            metaMessages: [
              `\`${e.type}\` in \`${(0, r.t)(e.abiItem)}\`, and`,
              `\`${t.type}\` in \`${(0, r.t)(t.abiItem)}\``,
              '',
              'These types encode differently and cannot be distinguished at runtime.',
              'Remove one of the ambiguous items in the ABI.',
            ],
            name: 'AbiItemAmbiguityError',
          });
        }
      }
      class E extends a.G {
        constructor({ expectedSize: e, givenSize: t }) {
          super(`Expected bytes${e}, got bytes${t}.`, { name: 'BytesSizeMismatchError' });
        }
      }
      class C extends a.G {
        constructor({ abiItem: e, data: t, params: n, size: i }) {
          super(`Data size of ${i} bytes is too small for non-indexed event parameters.`, {
            metaMessages: [
              `Params: (${(0, r.h)(n, { includeName: !0 })})`,
              `Data:   ${t} (${i} bytes)`,
            ],
            name: 'DecodeLogDataMismatch',
          }),
            Object.defineProperty(this, 'abiItem', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, 'data', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, 'params', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, 'size', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.abiItem = e),
            (this.data = t),
            (this.params = n),
            (this.size = i);
        }
      }
      class _ extends a.G {
        constructor({ abiItem: e, param: t }) {
          super(
            `Expected a topic for indexed event parameter${t.name ? ` "${t.name}"` : ''} on event "${(0, r.t)(e, { includeName: !0 })}".`,
            { name: 'DecodeLogTopicsMismatch' }
          ),
            Object.defineProperty(this, 'abiItem', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.abiItem = e);
        }
      }
      class I extends a.G {
        constructor(e, { docsPath: t }) {
          super(
            `Type "${e}" is not a valid encoding type.
Please provide a valid ABI type.`,
            { docsPath: t, name: 'InvalidAbiEncodingType' }
          );
        }
      }
      class S extends a.G {
        constructor(e, { docsPath: t }) {
          super(
            `Type "${e}" is not a valid decoding type.
Please provide a valid ABI type.`,
            { docsPath: t, name: 'InvalidAbiDecodingType' }
          );
        }
      }
      class P extends a.G {
        constructor(e) {
          super(`Value "${e}" is not a valid array.`, { name: 'InvalidArrayError' });
        }
      }
      class O extends a.G {
        constructor(e) {
          super(
            `"${e}" is not a valid definition type.
Valid types: "function", "event", "error"`,
            { name: 'InvalidDefinitionTypeError' }
          );
        }
      }
      class N extends a.G {
        constructor(e) {
          super(`Type "${e}" is not supported for packed encoding.`, {
            name: 'UnsupportedPackedAbiType',
          });
        }
      }
    },
    91560: function (e, t, n) {
      'use strict';
      n.d(t, {
        Y: function () {
          return a;
        },
        o: function () {
          return i;
        },
      });
      var r = n(88154);
      class i extends r.G {
        constructor({ docsPath: e } = {}) {
          super(
            'Could not find an Account to execute with this Action.\nPlease provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client.',
            { docsPath: e, docsSlug: 'account', name: 'AccountNotFoundError' }
          );
        }
      }
      class a extends r.G {
        constructor({ docsPath: e, metaMessages: t, type: n }) {
          super(`Account type "${n}" is not supported.`, {
            docsPath: e,
            metaMessages: t,
            name: 'AccountTypeNotSupportedError',
          });
        }
      }
    },
    58427: function (e, t, n) {
      'use strict';
      n.d(t, {
        f: function () {
          return i;
        },
      });
      var r = n(88154);
      class i extends r.G {
        constructor({ blockHash: e, blockNumber: t }) {
          let n = 'Block';
          e && (n = `Block at hash "${e}"`),
            t && (n = `Block at number "${t}"`),
            super(`${n} could not be found.`, { name: 'BlockNotFoundError' });
        }
      }
    },
    54484: function (e, t, n) {
      'use strict';
      n.d(t, {
        cg: function () {
          return g;
        },
        uq: function () {
          return b;
        },
        Lu: function () {
          return w;
        },
        Dk: function () {
          return v;
        },
        Mo: function () {
          return T;
        },
        VQ: function () {
          return A;
        },
      });
      var r = n(65099),
        i = n(58395),
        a = n(85514),
        s = n(60478),
        o = n(97352);
      function l({ abiItem: e, args: t, includeFunctionName: n = !0, includeName: r = !1 }) {
        if ('name' in e && 'inputs' in e && e.inputs)
          return `${n ? e.name : ''}(${e.inputs.map((e, n) => `${r && e.name ? `${e.name}: ` : ''}${'object' == typeof t[n] ? (0, o.P)(t[n]) : t[n]}`).join(', ')})`;
      }
      var u = n(35417),
        c = n(28888),
        d = n(4046),
        p = n(57585),
        h = n(88154),
        y = n(99523),
        f = n(29408),
        m = n(92284);
      class g extends h.G {
        constructor(
          e,
          {
            account: t,
            docsPath: n,
            chain: i,
            data: a,
            gas: s,
            gasPrice: o,
            maxFeePerGas: l,
            maxPriorityFeePerGas: u,
            nonce: p,
            to: h,
            value: m,
            stateOverride: g,
          }
        ) {
          let b = t ? (0, r.T)(t) : void 0,
            w = (0, f.xr)({
              from: b?.address,
              to: h,
              value: void 0 !== m && `${(0, c.d)(m)} ${i?.nativeCurrency?.symbol || 'ETH'}`,
              data: a,
              gas: s,
              gasPrice: void 0 !== o && `${(0, d.o)(o)} gwei`,
              maxFeePerGas: void 0 !== l && `${(0, d.o)(l)} gwei`,
              maxPriorityFeePerGas: void 0 !== u && `${(0, d.o)(u)} gwei`,
              nonce: p,
            });
          g &&
            (w += `
${(0, y.Bj)(g)}`),
            super(e.shortMessage, {
              cause: e,
              docsPath: n,
              metaMessages: [
                ...(e.metaMessages ? [...e.metaMessages, ' '] : []),
                'Raw Call Arguments:',
                w,
              ].filter(Boolean),
              name: 'CallExecutionError',
            }),
            Object.defineProperty(this, 'cause', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.cause = e);
        }
      }
      class b extends h.G {
        constructor(
          e,
          { abi: t, args: n, contractAddress: r, docsPath: i, functionName: a, sender: o }
        ) {
          let c = (0, u.mE)({ abi: t, args: n, name: a }),
            d = c ? l({ abiItem: c, args: n, includeFunctionName: !1, includeName: !1 }) : void 0,
            p = c ? (0, s.t)(c, { includeName: !0 }) : void 0,
            h = (0, f.xr)({
              address: r && (0, m.C)(r),
              function: p,
              args:
                d &&
                '()' !== d &&
                `${[...Array(a?.length ?? 0).keys()].map(() => ' ').join('')}${d}`,
              sender: o,
            });
          super(
            e.shortMessage ||
              `An unknown error occurred while executing the contract function "${a}".`,
            {
              cause: e,
              docsPath: i,
              metaMessages: [
                ...(e.metaMessages ? [...e.metaMessages, ' '] : []),
                h && 'Contract Call:',
                h,
              ].filter(Boolean),
              name: 'ContractFunctionExecutionError',
            }
          ),
            Object.defineProperty(this, 'abi', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, 'args', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, 'cause', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, 'contractAddress', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, 'formattedArgs', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, 'functionName', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, 'sender', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.abi = t),
            (this.args = n),
            (this.cause = e),
            (this.contractAddress = r),
            (this.functionName = a),
            (this.sender = o);
        }
      }
      class w extends h.G {
        constructor({ abi: e, data: t, functionName: n, message: r }) {
          let o, u, c, d, h;
          if (t && '0x' !== t)
            try {
              let { abiItem: n, errorName: r, args: o } = (h = (0, a.p)({ abi: e, data: t }));
              if ('Error' === r) c = o[0];
              else if ('Panic' === r) {
                let [e] = o;
                c = i.$[e];
              } else {
                let e = n ? (0, s.t)(n, { includeName: !0 }) : void 0,
                  t =
                    n && o
                      ? l({ abiItem: n, args: o, includeFunctionName: !1, includeName: !1 })
                      : void 0;
                u = [
                  e ? `Error: ${e}` : '',
                  t && '()' !== t
                    ? `       ${[...Array(r?.length ?? 0).keys()].map(() => ' ').join('')}${t}`
                    : '',
                ];
              }
            } catch (e) {
              o = e;
            }
          else r && (c = r);
          o instanceof p.yP &&
            ((d = o.signature),
            (u = [
              `Unable to decode signature "${d}" as it was not found on the provided ABI.`,
              'Make sure you are using the correct ABI and that the error exists on it.',
              `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${d}.`,
            ])),
            super(
              (c && 'execution reverted' !== c) || d
                ? [
                    `The contract function "${n}" reverted with the following ${d ? 'signature' : 'reason'}:`,
                    c || d,
                  ].join('\n')
                : `The contract function "${n}" reverted.`,
              { cause: o, metaMessages: u, name: 'ContractFunctionRevertedError' }
            ),
            Object.defineProperty(this, 'data', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, 'raw', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, 'reason', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, 'signature', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.data = h),
            (this.raw = t),
            (this.reason = c),
            (this.signature = d);
        }
      }
      class v extends h.G {
        constructor({ functionName: e }) {
          super(`The contract function "${e}" returned no data ("0x").`, {
            metaMessages: [
              'This could be due to any of the following:',
              `  - The contract does not have the function "${e}",`,
              '  - The parameters passed to the contract function may be invalid, or',
              '  - The address is not a contract.',
            ],
            name: 'ContractFunctionZeroDataError',
          });
        }
      }
      class T extends h.G {
        constructor({ factory: e }) {
          super(
            `Deployment for counterfactual contract call failed${e ? ` for factory "${e}".` : ''}`,
            {
              metaMessages: [
                'Please ensure:',
                '- The `factory` is a valid contract deployment factory (ie. Create2 Factory, ERC-4337 Factory, etc).',
                '- The `factoryData` is a valid encoded function call for contract deployment function on the factory.',
              ],
              name: 'CounterfactualDeploymentFailedError',
            }
          );
        }
      }
      class A extends h.G {
        constructor({ data: e, message: t }) {
          super(t || '', { name: 'RawContractError' }),
            Object.defineProperty(this, 'code', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: 3,
            }),
            Object.defineProperty(this, 'data', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.data = e);
        }
      }
    },
    54646: function (e, t, n) {
      'use strict';
      n.d(t, {
        Fz: function () {
          return a;
        },
        e5: function () {
          return s;
        },
        ld: function () {
          return o;
        },
      });
      var r = n(4046),
        i = n(88154);
      class a extends i.G {
        constructor() {
          super('`baseFeeMultiplier` must be greater than 1.', { name: 'BaseFeeScalarError' });
        }
      }
      class s extends i.G {
        constructor() {
          super('Chain does not support EIP-1559 fees.', { name: 'Eip1559FeesNotSupportedError' });
        }
      }
      class o extends i.G {
        constructor({ maxPriorityFeePerGas: e }) {
          super(
            `\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${(0, r.o)(e)} gwei).`,
            { name: 'MaxFeePerGasTooLowError' }
          );
        }
      }
    },
    40002: function (e, t, n) {
      'use strict';
      n.d(t, {
        Gg: function () {
          return s;
        },
        W5: function () {
          return l;
        },
        bs: function () {
          return o;
        },
      });
      var r = n(97352),
        i = n(88154),
        a = n(92284);
      class s extends i.G {
        constructor({ body: e, cause: t, details: n, headers: i, status: s, url: o }) {
          super('HTTP request failed.', {
            cause: t,
            details: n,
            metaMessages: [
              s && `Status: ${s}`,
              `URL: ${(0, a.G)(o)}`,
              e && `Request body: ${(0, r.P)(e)}`,
            ].filter(Boolean),
            name: 'HttpRequestError',
          }),
            Object.defineProperty(this, 'body', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, 'headers', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, 'status', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, 'url', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.body = e),
            (this.headers = i),
            (this.status = s),
            (this.url = o);
        }
      }
      class o extends i.G {
        constructor({ body: e, error: t, url: n }) {
          super('RPC Request failed.', {
            cause: t,
            details: t.message,
            metaMessages: [`URL: ${(0, a.G)(n)}`, `Request body: ${(0, r.P)(e)}`],
            name: 'RpcRequestError',
          }),
            Object.defineProperty(this, 'code', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, 'data', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.code = t.code),
            (this.data = t.data);
        }
      }
      class l extends i.G {
        constructor({ body: e, url: t }) {
          super('The request took too long to respond.', {
            details: 'The request timed out.',
            metaMessages: [`URL: ${(0, a.G)(t)}`, `Request body: ${(0, r.P)(e)}`],
            name: 'TimeoutError',
          });
        }
      }
    },
    18292: function (e, t, n) {
      'use strict';
      n.d(t, {
        B: function () {
          return l;
        },
        EJ: function () {
          return P;
        },
        GD: function () {
          return b;
        },
        I0: function () {
          return E;
        },
        KB: function () {
          return f;
        },
        LX: function () {
          return u;
        },
        NO: function () {
          return N;
        },
        Nt: function () {
          return S;
        },
        Og: function () {
          return h;
        },
        PE: function () {
          return v;
        },
        Pv: function () {
          return g;
        },
        Ts: function () {
          return T;
        },
        Uu: function () {
          return I;
        },
        XS: function () {
          return d;
        },
        ab: function () {
          return w;
        },
        fl: function () {
          return O;
        },
        gS: function () {
          return m;
        },
        ir: function () {
          return M;
        },
        nY: function () {
          return c;
        },
        pT: function () {
          return y;
        },
        r0: function () {
          return x;
        },
        s7: function () {
          return o;
        },
        u5: function () {
          return A;
        },
        vl: function () {
          return _;
        },
        x3: function () {
          return C;
        },
        yR: function () {
          return p;
        },
      });
      var r = n(88154),
        i = n(40002);
      class a extends r.G {
        constructor(e, { code: t, docsPath: n, metaMessages: r, name: a, shortMessage: s }) {
          super(s, {
            cause: e,
            docsPath: n,
            metaMessages: r || e?.metaMessages,
            name: a || 'RpcError',
          }),
            Object.defineProperty(this, 'code', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.name = a || e.name),
            (this.code = e instanceof i.bs ? e.code : (t ?? -1));
        }
      }
      class s extends a {
        constructor(e, t) {
          super(e, t),
            Object.defineProperty(this, 'data', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.data = t.data);
        }
      }
      class o extends a {
        constructor(e) {
          super(e, {
            code: o.code,
            name: 'ParseRpcError',
            shortMessage:
              'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.',
          });
        }
      }
      Object.defineProperty(o, 'code', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32700,
      });
      class l extends a {
        constructor(e) {
          super(e, {
            code: l.code,
            name: 'InvalidRequestRpcError',
            shortMessage: 'JSON is not a valid request object.',
          });
        }
      }
      Object.defineProperty(l, 'code', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32600,
      });
      class u extends a {
        constructor(e, { method: t } = {}) {
          super(e, {
            code: u.code,
            name: 'MethodNotFoundRpcError',
            shortMessage: `The method${t ? ` "${t}"` : ''} does not exist / is not available.`,
          });
        }
      }
      Object.defineProperty(u, 'code', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32601,
      });
      class c extends a {
        constructor(e) {
          super(e, {
            code: c.code,
            name: 'InvalidParamsRpcError',
            shortMessage:
              'Invalid parameters were provided to the RPC method.\nDouble check you have provided the correct parameters.',
          });
        }
      }
      Object.defineProperty(c, 'code', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32602,
      });
      class d extends a {
        constructor(e) {
          super(e, {
            code: d.code,
            name: 'InternalRpcError',
            shortMessage: 'An internal error was received.',
          });
        }
      }
      Object.defineProperty(d, 'code', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32603,
      });
      class p extends a {
        constructor(e) {
          super(e, {
            code: p.code,
            name: 'InvalidInputRpcError',
            shortMessage:
              'Missing or invalid parameters.\nDouble check you have provided the correct parameters.',
          });
        }
      }
      Object.defineProperty(p, 'code', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32e3,
      });
      class h extends a {
        constructor(e) {
          super(e, {
            code: h.code,
            name: 'ResourceNotFoundRpcError',
            shortMessage: 'Requested resource not found.',
          }),
            Object.defineProperty(this, 'name', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: 'ResourceNotFoundRpcError',
            });
        }
      }
      Object.defineProperty(h, 'code', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32001,
      });
      class y extends a {
        constructor(e) {
          super(e, {
            code: y.code,
            name: 'ResourceUnavailableRpcError',
            shortMessage: 'Requested resource not available.',
          });
        }
      }
      Object.defineProperty(y, 'code', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32002,
      });
      class f extends a {
        constructor(e) {
          super(e, {
            code: f.code,
            name: 'TransactionRejectedRpcError',
            shortMessage: 'Transaction creation failed.',
          });
        }
      }
      Object.defineProperty(f, 'code', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32003,
      });
      class m extends a {
        constructor(e, { method: t } = {}) {
          super(e, {
            code: m.code,
            name: 'MethodNotSupportedRpcError',
            shortMessage: `Method${t ? ` "${t}"` : ''} is not supported.`,
          });
        }
      }
      Object.defineProperty(m, 'code', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32004,
      });
      class g extends a {
        constructor(e) {
          super(e, {
            code: g.code,
            name: 'LimitExceededRpcError',
            shortMessage: 'Request exceeds defined limit.',
          });
        }
      }
      Object.defineProperty(g, 'code', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32005,
      });
      class b extends a {
        constructor(e) {
          super(e, {
            code: b.code,
            name: 'JsonRpcVersionUnsupportedError',
            shortMessage: 'Version of JSON-RPC protocol is not supported.',
          });
        }
      }
      Object.defineProperty(b, 'code', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32006,
      });
      class w extends s {
        constructor(e) {
          super(e, {
            code: w.code,
            name: 'UserRejectedRequestError',
            shortMessage: 'User rejected the request.',
          });
        }
      }
      Object.defineProperty(w, 'code', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4001,
      });
      class v extends s {
        constructor(e) {
          super(e, {
            code: v.code,
            name: 'UnauthorizedProviderError',
            shortMessage:
              'The requested method and/or account has not been authorized by the user.',
          });
        }
      }
      Object.defineProperty(v, 'code', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4100,
      });
      class T extends s {
        constructor(e, { method: t } = {}) {
          super(e, {
            code: T.code,
            name: 'UnsupportedProviderMethodError',
            shortMessage: `The Provider does not support the requested method${t ? ` " ${t}"` : ''}.`,
          });
        }
      }
      Object.defineProperty(T, 'code', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4200,
      });
      class A extends s {
        constructor(e) {
          super(e, {
            code: A.code,
            name: 'ProviderDisconnectedError',
            shortMessage: 'The Provider is disconnected from all chains.',
          });
        }
      }
      Object.defineProperty(A, 'code', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4900,
      });
      class E extends s {
        constructor(e) {
          super(e, {
            code: E.code,
            name: 'ChainDisconnectedError',
            shortMessage: 'The Provider is not connected to the requested chain.',
          });
        }
      }
      Object.defineProperty(E, 'code', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4901,
      });
      class C extends s {
        constructor(e) {
          super(e, {
            code: C.code,
            name: 'SwitchChainError',
            shortMessage: 'An error occurred when attempting to switch chain.',
          });
        }
      }
      Object.defineProperty(C, 'code', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4902,
      });
      class _ extends s {
        constructor(e) {
          super(e, {
            code: _.code,
            name: 'UnsupportedNonOptionalCapabilityError',
            shortMessage:
              'This Wallet does not support a capability that was not marked as optional.',
          });
        }
      }
      Object.defineProperty(_, 'code', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 5700,
      });
      class I extends s {
        constructor(e) {
          super(e, {
            code: I.code,
            name: 'UnsupportedChainIdError',
            shortMessage: 'This Wallet does not support the requested chain ID.',
          });
        }
      }
      Object.defineProperty(I, 'code', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 5710,
      });
      class S extends s {
        constructor(e) {
          super(e, {
            code: S.code,
            name: 'DuplicateIdError',
            shortMessage: 'There is already a bundle submitted with this ID.',
          });
        }
      }
      Object.defineProperty(S, 'code', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 5720,
      });
      class P extends s {
        constructor(e) {
          super(e, {
            code: P.code,
            name: 'UnknownBundleIdError',
            shortMessage: 'This bundle id is unknown / has not been submitted',
          });
        }
      }
      Object.defineProperty(P, 'code', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 5730,
      });
      class O extends s {
        constructor(e) {
          super(e, {
            code: O.code,
            name: 'BundleTooLargeError',
            shortMessage: 'The call bundle is too large for the Wallet to process.',
          });
        }
      }
      Object.defineProperty(O, 'code', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 5740,
      });
      class N extends s {
        constructor(e) {
          super(e, {
            code: N.code,
            name: 'AtomicReadyWalletRejectedUpgradeError',
            shortMessage:
              'The Wallet can support atomicity after an upgrade, but the user rejected the upgrade.',
          });
        }
      }
      Object.defineProperty(N, 'code', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 5750,
      });
      class x extends s {
        constructor(e) {
          super(e, {
            code: x.code,
            name: 'AtomicityNotSupportedError',
            shortMessage:
              'The wallet does not support atomic execution but the request requires it.',
          });
        }
      }
      Object.defineProperty(x, 'code', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 5760,
      });
      class M extends a {
        constructor(e) {
          super(e, { name: 'UnknownRpcError', shortMessage: 'An unknown RPC error occurred.' });
        }
      }
    },
    99523: function (e, t, n) {
      'use strict';
      n.d(t, {
        Bj: function () {
          return o;
        },
        Nc: function () {
          return i;
        },
        Z8: function () {
          return a;
        },
      });
      var r = n(88154);
      class i extends r.G {
        constructor({ address: e }) {
          super(`State for account "${e}" is set multiple times.`, {
            name: 'AccountStateConflictError',
          });
        }
      }
      class a extends r.G {
        constructor() {
          super('state and stateDiff are set on the same account.', {
            name: 'StateAssignmentConflictError',
          });
        }
      }
      function s(e) {
        return e.reduce(
          (e, { slot: t, value: n }) => `${e}        ${t}: ${n}
`,
          ''
        );
      }
      function o(e) {
        return e
          .reduce((e, { address: t, ...n }) => {
            let r = `${e}    ${t}:
`;
            return (
              n.nonce &&
                (r += `      nonce: ${n.nonce}
`),
              n.balance &&
                (r += `      balance: ${n.balance}
`),
              n.code &&
                (r += `      code: ${n.code}
`),
              n.state && (r += '      state:\n' + s(n.state)),
              n.stateDiff && (r += '      stateDiff:\n' + s(n.stateDiff)),
              r
            );
          }, '  State Override:\n')
          .slice(0, -1);
      }
    },
    92284: function (e, t, n) {
      'use strict';
      n.d(t, {
        C: function () {
          return r;
        },
        G: function () {
          return i;
        },
      });
      let r = (e) => e,
        i = (e) => e;
    },
    87083: function (e, t, n) {
      'use strict';
      n.d(t, {
        r: function () {
          return f;
        },
      });
      var r = n(57585),
        i = n(28346),
        a = n(49147),
        s = n(88155),
        o = n(32982),
        l = n(97032),
        u = n(29620),
        c = n(79e3),
        d = n(84196);
      function p(e, t = {}) {
        void 0 !== t.size && (0, c.Yf)(e, { size: t.size });
        let n = (0, d.ci)(e, t);
        return (0, c.ly)(n, t);
      }
      var h = n(2220),
        y = n(9691);
      function f(e, t) {
        let n = 'string' == typeof t ? (0, h.nr)(t) : t,
          f = (0, a.q)(n);
        if (0 === (0, s.d)(n) && e.length > 0) throw new r.wb();
        if ((0, s.d)(t) && 32 > (0, s.d)(t))
          throw new r.xB({
            data: 'string' == typeof t ? t : (0, d.ci)(t),
            params: e,
            size: (0, s.d)(t),
          });
        let g = 0,
          b = [];
        for (let t = 0; t < e.length; ++t) {
          let n = e[t];
          f.setPosition(g);
          let [a, s] = (function e(t, n, { staticPosition: a }) {
            let s = (0, y.S)(n.type);
            if (s) {
              let [r, i] = s;
              return (function (t, n, { length: r, staticPosition: i }) {
                if (!r) {
                  let r = i + p(t.readBytes(32)),
                    a = r + 32;
                  t.setPosition(r);
                  let s = p(t.readBytes(32)),
                    o = m(n),
                    l = 0,
                    u = [];
                  for (let r = 0; r < s; ++r) {
                    t.setPosition(a + (o ? 32 * r : l));
                    let [i, s] = e(t, n, { staticPosition: a });
                    (l += s), u.push(i);
                  }
                  return t.setPosition(i + 32), [u, 32];
                }
                if (m(n)) {
                  let a = i + p(t.readBytes(32)),
                    s = [];
                  for (let i = 0; i < r; ++i) {
                    t.setPosition(a + 32 * i);
                    let [r] = e(t, n, { staticPosition: a });
                    s.push(r);
                  }
                  return t.setPosition(i + 32), [s, 32];
                }
                let a = 0,
                  s = [];
                for (let o = 0; o < r; ++o) {
                  let [r, o] = e(t, n, { staticPosition: i + a });
                  (a += o), s.push(r);
                }
                return [s, a];
              })(t, { ...n, type: i }, { length: r, staticPosition: a });
            }
            if ('tuple' === n.type)
              return (function (t, n, { staticPosition: r }) {
                let i = 0 === n.components.length || n.components.some(({ name: e }) => !e),
                  a = i ? [] : {},
                  s = 0;
                if (m(n)) {
                  let o = r + p(t.readBytes(32));
                  for (let r = 0; r < n.components.length; ++r) {
                    let l = n.components[r];
                    t.setPosition(o + s);
                    let [u, c] = e(t, l, { staticPosition: o });
                    (s += c), (a[i ? r : l?.name] = u);
                  }
                  return t.setPosition(r + 32), [a, 32];
                }
                for (let o = 0; o < n.components.length; ++o) {
                  let l = n.components[o],
                    [u, c] = e(t, l, { staticPosition: r });
                  (a[i ? o : l?.name] = u), (s += c);
                }
                return [a, s];
              })(t, n, { staticPosition: a });
            if ('address' === n.type)
              return (function (e) {
                let t = e.readBytes(32);
                return [(0, i.x)((0, d.ci)((0, o.T4)(t, -20))), 32];
              })(t);
            if ('bool' === n.type)
              return [
                (function (e, t = {}) {
                  let n = e;
                  if (
                    (void 0 !== t.size && ((0, c.Yf)(n, { size: t.size }), (n = (0, l.f)(n))),
                    n.length > 1 || n[0] > 1)
                  )
                    throw new u.yr(n);
                  return !!n[0];
                })(t.readBytes(32), { size: 32 }),
                32,
              ];
            if (n.type.startsWith('bytes'))
              return (function (e, t, { staticPosition: n }) {
                let [r, i] = t.type.split('bytes');
                if (!i) {
                  let t = p(e.readBytes(32));
                  e.setPosition(n + t);
                  let r = p(e.readBytes(32));
                  if (0 === r) return e.setPosition(n + 32), ['0x', 32];
                  let i = e.readBytes(r);
                  return e.setPosition(n + 32), [(0, d.ci)(i), 32];
                }
                return [(0, d.ci)(e.readBytes(Number.parseInt(i), 32)), 32];
              })(t, n, { staticPosition: a });
            if (n.type.startsWith('uint') || n.type.startsWith('int'))
              return (function (e, t) {
                let n = t.type.startsWith('int'),
                  r = Number.parseInt(t.type.split('int')[1] || '256'),
                  i = e.readBytes(32);
                return [
                  r > 48
                    ? (function (e, t = {}) {
                        void 0 !== t.size && (0, c.Yf)(e, { size: t.size });
                        let n = (0, d.ci)(e, t);
                        return (0, c.y_)(n, t);
                      })(i, { signed: n })
                    : p(i, { signed: n }),
                  32,
                ];
              })(t, n);
            if ('string' === n.type)
              return (function (e, { staticPosition: t }) {
                let n = p(e.readBytes(32));
                e.setPosition(t + n);
                let r = p(e.readBytes(32));
                if (0 === r) return e.setPosition(t + 32), ['', 32];
                let i = e.readBytes(r, 32),
                  a = (function (e, t = {}) {
                    let n = e;
                    return (
                      void 0 !== t.size &&
                        ((0, c.Yf)(n, { size: t.size }), (n = (0, l.f)(n, { dir: 'right' }))),
                      new TextDecoder().decode(n)
                    );
                  })((0, l.f)(i));
                return e.setPosition(t + 32), [a, 32];
              })(t, { staticPosition: a });
            throw new r.CI(n.type, { docsPath: '/docs/contract/decodeAbiParameters' });
          })(f, n, { staticPosition: 0 });
          (g += s), b.push(a);
        }
        return b;
      }
      function m(e) {
        let { type: t } = e;
        if ('string' === t || 'bytes' === t || t.endsWith('[]')) return !0;
        if ('tuple' === t) return e.components?.some(m);
        let n = (0, y.S)(e.type);
        return !!(n && m({ ...e, type: n[1] }));
      }
    },
    85514: function (e, t, n) {
      'use strict';
      n.d(t, {
        p: function () {
          return u;
        },
      });
      var r = n(58395),
        i = n(57585),
        a = n(32982),
        s = n(95962),
        o = n(87083),
        l = n(60478);
      function u(e) {
        let { abi: t, data: n } = e,
          u = (0, a.tP)(n, 0, 4);
        if ('0x' === u) throw new i.wb();
        let c = [...(t || []), r.Up, r.hZ].find(
          (e) => 'error' === e.type && u === (0, s.C)((0, l.t)(e))
        );
        if (!c) throw new i.yP(u, { docsPath: '/docs/contract/decodeErrorResult' });
        return {
          abiItem: c,
          args:
            'inputs' in c && c.inputs && c.inputs.length > 0
              ? (0, o.r)(c.inputs, (0, a.tP)(n, 4))
              : void 0,
          errorName: c.name,
        };
      }
    },
    19209: function (e, t, n) {
      'use strict';
      n.d(t, {
        F: function () {
          return c;
        },
      });
      var r = n(57585),
        i = n(88155),
        a = n(35481),
        s = n(41249),
        o = n(87083),
        l = n(60478);
      let u = '/docs/contract/decodeEventLog';
      function c(e) {
        let { abi: t, data: n, strict: c, topics: d } = e,
          p = c ?? !0,
          [h, ...y] = d;
        if (!h) throw new r.FM({ docsPath: u });
        let f =
          1 === t.length ? t[0] : t.find((e) => 'event' === e.type && h === (0, a.n)((0, l.t)(e)));
        if (!(f && 'name' in f) || 'event' !== f.type) throw new r.lC(h, { docsPath: u });
        let { name: m, inputs: g } = f,
          b = g?.some((e) => !('name' in e && e.name)),
          w = b ? [] : {},
          v = g.filter((e) => 'indexed' in e && e.indexed);
        for (let e = 0; e < v.length; e++) {
          let t = v[e],
            n = y[e];
          if (!n) throw new r.Gy({ abiItem: f, param: t });
          w[b ? e : t.name || e] = (function ({ param: e, value: t }) {
            return 'string' === e.type ||
              'bytes' === e.type ||
              'tuple' === e.type ||
              e.type.match(/^(.*)\[(\d+)?\]$/)
              ? t
              : ((0, o.r)([e], t) || [])[0];
          })({ param: t, value: n });
        }
        let T = g.filter((e) => !('indexed' in e && e.indexed));
        if (T.length > 0) {
          if (n && '0x' !== n)
            try {
              let e = (0, o.r)(T, n);
              if (e) {
                if (b) w = [...w, ...e];
                else for (let t = 0; t < T.length; t++) w[T[t].name] = e[t];
              }
            } catch (e) {
              if (p) {
                if (e instanceof r.xB || e instanceof s.lQ)
                  throw new r.SM({ abiItem: f, data: n, params: T, size: (0, i.d)(n) });
                throw e;
              }
            }
          else if (p) throw new r.SM({ abiItem: f, data: '0x', params: T, size: 0 });
        }
        return { eventName: m, args: Object.values(w).length > 0 ? w : void 0 };
      }
    },
    29629: function (e, t, n) {
      'use strict';
      n.d(t, {
        k: function () {
          return o;
        },
      });
      var r = n(57585),
        i = n(87083),
        a = n(35417);
      let s = '/docs/contract/decodeFunctionResult';
      function o(e) {
        let { abi: t, args: n, functionName: o, data: l } = e,
          u = t[0];
        if (o) {
          let e = (0, a.mE)({ abi: t, args: n, name: o });
          if (!e) throw new r.xL(o, { docsPath: s });
          u = e;
        }
        if ('function' !== u.type) throw new r.xL(void 0, { docsPath: s });
        if (!u.outputs) throw new r.MX(u.name, { docsPath: s });
        let c = (0, i.r)(u.outputs, l);
        return c && c.length > 1 ? c : c && 1 === c.length ? c[0] : void 0;
      }
    },
    9691: function (e, t, n) {
      'use strict';
      n.d(t, {
        E: function () {
          return y;
        },
        S: function () {
          return m;
        },
      });
      var r = n(57585),
        i = n(37039),
        a = n(88154),
        s = n(29620),
        o = n(77102),
        l = n(63171),
        u = n(11676),
        c = n(88155),
        d = n(32982),
        p = n(84196),
        h = n(69349);
      function y(e, t) {
        if (e.length !== t.length)
          throw new r.fs({ expectedLength: e.length, givenLength: t.length });
        let n = f(
          (function ({ params: e, values: t }) {
            let n = [];
            for (let y = 0; y < e.length; y++)
              n.push(
                (function e({ param: t, value: n }) {
                  let y = m(t.type);
                  if (y) {
                    let [i, a] = y;
                    return (function (t, { length: n, param: i }) {
                      let a = null === n;
                      if (!Array.isArray(t)) throw new r.hn(t);
                      if (!a && t.length !== n)
                        throw new r.gr({
                          expectedLength: n,
                          givenLength: t.length,
                          type: `${i.type}[${n}]`,
                        });
                      let s = !1,
                        o = [];
                      for (let n = 0; n < t.length; n++) {
                        let r = e({ param: i, value: t[n] });
                        r.dynamic && (s = !0), o.push(r);
                      }
                      if (a || s) {
                        let e = f(o);
                        if (a) {
                          let t = (0, p.eC)(o.length, { size: 32 });
                          return { dynamic: !0, encoded: o.length > 0 ? (0, l.zo)([t, e]) : t };
                        }
                        if (s) return { dynamic: !0, encoded: e };
                      }
                      return { dynamic: !1, encoded: (0, l.zo)(o.map(({ encoded: e }) => e)) };
                    })(n, { length: i, param: { ...t, type: a } });
                  }
                  if ('tuple' === t.type)
                    return (function (t, { param: n }) {
                      let r = !1,
                        i = [];
                      for (let a = 0; a < n.components.length; a++) {
                        let s = n.components[a],
                          o = Array.isArray(t) ? a : s.name,
                          l = e({ param: s, value: t[o] });
                        i.push(l), l.dynamic && (r = !0);
                      }
                      return {
                        dynamic: r,
                        encoded: r ? f(i) : (0, l.zo)(i.map(({ encoded: e }) => e)),
                      };
                    })(n, { param: t });
                  if ('address' === t.type)
                    return (function (e) {
                      if (!(0, o.U)(e)) throw new i.b({ address: e });
                      return { dynamic: !1, encoded: (0, u.gc)(e.toLowerCase()) };
                    })(n);
                  if ('bool' === t.type)
                    return (function (e) {
                      if ('boolean' != typeof e)
                        throw new a.G(
                          `Invalid boolean value: "${e}" (type: ${typeof e}). Expected: \`true\` or \`false\`.`
                        );
                      return { dynamic: !1, encoded: (0, u.gc)((0, p.C4)(e)) };
                    })(n);
                  if (t.type.startsWith('uint') || t.type.startsWith('int')) {
                    let e = t.type.startsWith('int'),
                      [, , r = '256'] = h.lh.exec(t.type) ?? [];
                    return (function (e, { signed: t, size: n = 256 }) {
                      if ('number' == typeof n) {
                        let r = 2n ** (BigInt(n) - (t ? 1n : 0n)) - 1n,
                          i = t ? -r - 1n : 0n;
                        if (e > r || e < i)
                          throw new s.J5({
                            max: r.toString(),
                            min: i.toString(),
                            signed: t,
                            size: n / 8,
                            value: e.toString(),
                          });
                      }
                      return { dynamic: !1, encoded: (0, p.eC)(e, { size: 32, signed: t }) };
                    })(n, { signed: e, size: Number(r) });
                  }
                  if (t.type.startsWith('bytes'))
                    return (function (e, { param: t }) {
                      let [, n] = t.type.split('bytes'),
                        i = (0, c.d)(e);
                      if (!n) {
                        let t = e;
                        return (
                          i % 32 != 0 &&
                            (t = (0, u.gc)(t, {
                              dir: 'right',
                              size: 32 * Math.ceil((e.length - 2) / 2 / 32),
                            })),
                          {
                            dynamic: !0,
                            encoded: (0, l.zo)([(0, u.gc)((0, p.eC)(i, { size: 32 })), t]),
                          }
                        );
                      }
                      if (i !== Number.parseInt(n))
                        throw new r.M4({ expectedSize: Number.parseInt(n), value: e });
                      return { dynamic: !1, encoded: (0, u.gc)(e, { dir: 'right' }) };
                    })(n, { param: t });
                  if ('string' === t.type)
                    return (function (e) {
                      let t = (0, p.$G)(e),
                        n = Math.ceil((0, c.d)(t) / 32),
                        r = [];
                      for (let e = 0; e < n; e++)
                        r.push((0, u.gc)((0, d.tP)(t, 32 * e, (e + 1) * 32), { dir: 'right' }));
                      return {
                        dynamic: !0,
                        encoded: (0, l.zo)([(0, u.gc)((0, p.eC)((0, c.d)(t), { size: 32 })), ...r]),
                      };
                    })(n);
                  throw new r.dh(t.type, { docsPath: '/docs/contract/encodeAbiParameters' });
                })({ param: e[y], value: t[y] })
              );
            return n;
          })({ params: e, values: t })
        );
        return 0 === n.length ? '0x' : n;
      }
      function f(e) {
        let t = 0;
        for (let n = 0; n < e.length; n++) {
          let { dynamic: r, encoded: i } = e[n];
          r ? (t += 32) : (t += (0, c.d)(i));
        }
        let n = [],
          r = [],
          i = 0;
        for (let a = 0; a < e.length; a++) {
          let { dynamic: s, encoded: o } = e[a];
          s ? (n.push((0, p.eC)(t + i, { size: 32 })), r.push(o), (i += (0, c.d)(o))) : n.push(o);
        }
        return (0, l.zo)([...n, ...r]);
      }
      function m(e) {
        let t = e.match(/^(.*)\[(\d+)?\]$/);
        return t ? [t[2] ? Number(t[2]) : null, t[1]] : void 0;
      }
    },
    43231: function (e, t, n) {
      'use strict';
      n.d(t, {
        w: function () {
          return o;
        },
      });
      var r = n(57585),
        i = n(63171),
        a = n(9691);
      let s = '/docs/contract/encodeDeployData';
      function o(e) {
        let { abi: t, args: n, bytecode: o } = e;
        if (!n || 0 === n.length) return o;
        let l = t.find((e) => 'type' in e && 'constructor' === e.type);
        if (!l) throw new r.fM({ docsPath: s });
        if (!('inputs' in l) || !l.inputs || 0 === l.inputs.length) throw new r.cO({ docsPath: s });
        let u = (0, a.E)(l.inputs, n);
        return (0, i.SM)([o, u]);
      }
    },
    392: function (e, t, n) {
      'use strict';
      n.d(t, {
        R: function () {
          return c;
        },
      });
      var r = n(63171),
        i = n(9691),
        a = n(57585),
        s = n(95962),
        o = n(60478),
        l = n(35417);
      let u = '/docs/contract/encodeFunctionData';
      function c(e) {
        let { args: t } = e,
          { abi: n, functionName: c } =
            1 === e.abi.length && e.functionName?.startsWith('0x')
              ? e
              : (function (e) {
                  let { abi: t, args: n, functionName: r } = e,
                    i = t[0];
                  if (r) {
                    let e = (0, l.mE)({ abi: t, args: n, name: r });
                    if (!e) throw new a.xL(r, { docsPath: u });
                    i = e;
                  }
                  if ('function' !== i.type) throw new a.xL(void 0, { docsPath: u });
                  return { abi: [i], functionName: (0, s.C)((0, o.t)(i)) };
                })(e),
          d = n[0],
          p = 'inputs' in d && d.inputs ? (0, i.E)(d.inputs, t ?? []) : void 0;
        return (0, r.SM)([c, p ?? '0x']);
      }
    },
    60478: function (e, t, n) {
      'use strict';
      n.d(t, {
        h: function () {
          return a;
        },
        t: function () {
          return i;
        },
      });
      var r = n(57585);
      function i(e, { includeName: t = !1 } = {}) {
        if ('function' !== e.type && 'event' !== e.type && 'error' !== e.type)
          throw new r.wM(e.type);
        return `${e.name}(${a(e.inputs, { includeName: t })})`;
      }
      function a(e, { includeName: t = !1 } = {}) {
        return e
          ? e
              .map((e) =>
                (function (e, { includeName: t }) {
                  return e.type.startsWith('tuple')
                    ? `(${a(e.components, { includeName: t })})${e.type.slice(5)}`
                    : e.type + (t && e.name ? ` ${e.name}` : '');
                })(e, { includeName: t })
              )
              .join(t ? ', ' : ',')
          : '';
      }
    },
    35417: function (e, t, n) {
      'use strict';
      n.d(t, {
        mE: function () {
          return l;
        },
      });
      var r = n(57585),
        i = n(75963),
        a = n(77102),
        s = n(35481),
        o = n(95962);
      function l(e) {
        let t;
        let { abi: n, args: l = [], name: u } = e,
          c = (0, i.v)(u, { strict: !1 }),
          d = n.filter((e) =>
            c
              ? 'function' === e.type
                ? (0, o.C)(e) === u
                : 'event' === e.type && (0, s.n)(e) === u
              : 'name' in e && e.name === u
          );
        if (0 !== d.length) {
          if (1 === d.length) return d[0];
          for (let e of d)
            if ('inputs' in e) {
              if (!l || 0 === l.length) {
                if (!e.inputs || 0 === e.inputs.length) return e;
                continue;
              }
              if (
                e.inputs &&
                0 !== e.inputs.length &&
                e.inputs.length === l.length &&
                l.every((t, n) => {
                  let r = 'inputs' in e && e.inputs[n];
                  return (
                    !!r &&
                    (function e(t, n) {
                      let r = typeof t,
                        i = n.type;
                      switch (i) {
                        case 'address':
                          return (0, a.U)(t, { strict: !1 });
                        case 'bool':
                          return 'boolean' === r;
                        case 'function':
                        case 'string':
                          return 'string' === r;
                        default:
                          if ('tuple' === i && 'components' in n)
                            return Object.values(n.components).every((n, r) =>
                              e(Object.values(t)[r], n)
                            );
                          if (
                            /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(
                              i
                            )
                          )
                            return 'number' === r || 'bigint' === r;
                          if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(i))
                            return 'string' === r || t instanceof Uint8Array;
                          if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(i))
                            return (
                              Array.isArray(t) &&
                              t.every((t) =>
                                e(t, { ...n, type: i.replace(/(\[[0-9]{0,}\])$/, '') })
                              )
                            );
                          return !1;
                      }
                    })(t, r)
                  );
                })
              ) {
                if (t && 'inputs' in t && t.inputs) {
                  let n = (function e(t, n, r) {
                    for (let i in t) {
                      let s = t[i],
                        o = n[i];
                      if (
                        'tuple' === s.type &&
                        'tuple' === o.type &&
                        'components' in s &&
                        'components' in o
                      )
                        return e(s.components, o.components, r[i]);
                      let l = [s.type, o.type];
                      if (
                        (l.includes('address') && l.includes('bytes20')) ||
                        (((l.includes('address') && l.includes('string')) ||
                          (l.includes('address') && l.includes('bytes'))) &&
                          (0, a.U)(r[i], { strict: !1 }))
                      )
                        return l;
                    }
                  })(e.inputs, t.inputs, l);
                  if (n) throw new r.S4({ abiItem: e, type: n[0] }, { abiItem: t, type: n[1] });
                }
                t = e;
              }
            }
          return t || d[0];
        }
      }
    },
    49346: function (e, t, n) {
      'use strict';
      n.d(t, {
        h: function () {
          return u;
        },
      });
      var r = n(57585),
        i = n(8152),
        a = n(2220),
        s = n(47824),
        o = n(35481),
        l = n(19209);
      function u(e) {
        let { abi: t, args: n, logs: u, strict: c = !0 } = e,
          d = (() => {
            if (e.eventName) return Array.isArray(e.eventName) ? e.eventName : [e.eventName];
          })();
        return u
          .map((e) => {
            try {
              let r = t.find((t) => 'event' === t.type && e.topics[0] === (0, o.n)(t));
              if (!r) return null;
              let u = (0, l.F)({ ...e, abi: [r], strict: c });
              if (
                (d && !d.includes(u.eventName)) ||
                !(function (e) {
                  let { args: t, inputs: n, matchArgs: r } = e;
                  if (!r) return !0;
                  if (!t) return !1;
                  function o(e, t, n) {
                    try {
                      if ('address' === e.type) return (0, i.E)(t, n);
                      if ('string' === e.type || 'bytes' === e.type)
                        return (0, s.w)((0, a.O0)(t)) === n;
                      return t === n;
                    } catch {
                      return !1;
                    }
                  }
                  return Array.isArray(t) && Array.isArray(r)
                    ? r.every((e, r) => {
                        if (null == e) return !0;
                        let i = n[r];
                        return !!i && (Array.isArray(e) ? e : [e]).some((e) => o(i, e, t[r]));
                      })
                    : !(
                        'object' != typeof t ||
                        Array.isArray(t) ||
                        'object' != typeof r ||
                        Array.isArray(r)
                      ) &&
                        Object.entries(r).every(([e, r]) => {
                          if (null == r) return !0;
                          let i = n.find((t) => t.name === e);
                          return !!i && (Array.isArray(r) ? r : [r]).some((n) => o(i, n, t[e]));
                        });
                })({ args: u.args, inputs: r.inputs, matchArgs: n })
              )
                return null;
              return { ...u, ...e };
            } catch (i) {
              let t, n;
              if (i instanceof r.lC) return null;
              if (i instanceof r.SM || i instanceof r.Gy) {
                if (c) return null;
                (t = i.abiItem.name), (n = i.abiItem.inputs?.some((e) => !('name' in e && e.name)));
              }
              return { ...e, args: n ? [] : {}, eventName: t };
            }
          })
          .filter(Boolean);
      }
    },
    8152: function (e, t, n) {
      'use strict';
      n.d(t, {
        E: function () {
          return a;
        },
      });
      var r = n(37039),
        i = n(77102);
      function a(e, t) {
        if (!(0, i.U)(e, { strict: !1 })) throw new r.b({ address: e });
        if (!(0, i.U)(t, { strict: !1 })) throw new r.b({ address: t });
        return e.toLowerCase() === t.toLowerCase();
      }
    },
    6465: function (e, t, n) {
      'use strict';
      n.d(t, {
        z: function () {
          return u;
        },
      });
      var r = n(45793),
        i = n(63171),
        a = n(2220),
        s = n(84196),
        o = n(88401),
        l = n(47824);
      async function u(e) {
        let { authorization: t, signature: n } = e;
        return (0, r.R)({
          hash: (function (e) {
            let { chainId: t, nonce: n, to: r } = e,
              u = e.contractAddress ?? e.address,
              c = (0, l.w)(
                (0, i.SM)([
                  '0x05',
                  (0, o.LV)([t ? (0, s.eC)(t) : '0x', u, n ? (0, s.eC)(n) : '0x']),
                ])
              );
            return 'bytes' === r ? (0, a.nr)(c) : c;
          })(t),
          signature: n ?? t,
        });
      }
    },
    37520: function (e, t, n) {
      'use strict';
      n.d(t, {
        q: function () {
          return i;
        },
      });
      var r = n(65772);
      function i({ chain: e, currentChainId: t }) {
        if (!e) throw new r.Bk();
        if (t !== e.id) throw new r.Yl({ chain: e, currentChainId: t });
      }
    },
    53064: function (e, t, n) {
      'use strict';
      n.d(t, {
        L: function () {
          return i;
        },
      });
      var r = n(65772);
      function i({ blockNumber: e, chain: t, contract: n }) {
        let i = t?.contracts?.[n];
        if (!i) throw new r.mm({ chain: t, contract: { name: n } });
        if (e && i.blockCreated && i.blockCreated > e)
          throw new r.mm({
            blockNumber: e,
            chain: t,
            contract: { name: n, blockCreated: i.blockCreated },
          });
        return i.address;
      }
    },
    8282: function (e, t, n) {
      'use strict';
      n.d(t, {
        i: function () {
          return i;
        },
      });
      var r = n(75963);
      function i(e) {
        if (66 !== e.length || 0 !== e.indexOf('[') || 65 !== e.indexOf(']')) return null;
        let t = `0x${e.slice(1, 65)}`;
        return (0, r.v)(t) ? t : null;
      }
    },
    52716: function (e, t, n) {
      'use strict';
      n.d(t, {
        c: function () {
          return s;
        },
      });
      var r = n(58395),
        i = n(88154),
        a = n(54484);
      function s(e, t) {
        if (!(e instanceof i.G)) return !1;
        let n = e.walk((e) => e instanceof a.Lu);
        return (
          n instanceof a.Lu &&
          (!!(
            n.data?.errorName === 'ResolverNotFound' ||
            n.data?.errorName === 'ResolverWildcardNotSupported' ||
            n.data?.errorName === 'ResolverNotContract' ||
            n.data?.errorName === 'ResolverError' ||
            n.data?.errorName === 'HttpError' ||
            n.reason?.includes('Wildcard on non-extended resolvers is not supported')
          ) ||
            ('reverse' === t && n.reason === r.$[50]))
        );
      }
    },
    56123: function (e, t, n) {
      'use strict';
      n.d(t, {
        w: function () {
          return g;
        },
        M: function () {
          return m;
        },
      });
      var r = n(59370),
        i = n(58395),
        a = n(57585),
        s = n(32982),
        o = n(95962),
        l = n(87083),
        u = n(60478),
        c = n(63171),
        d = n(9691),
        p = n(35417);
      let h = '/docs/contract/encodeErrorResult';
      function y(e) {
        let { abi: t, errorName: n, args: r } = e,
          i = t[0];
        if (n) {
          let e = (0, p.mE)({ abi: t, args: r, name: n });
          if (!e) throw new a.MS(n, { docsPath: h });
          i = e;
        }
        if ('error' !== i.type) throw new a.MS(void 0, { docsPath: h });
        let s = (0, u.t)(i),
          l = (0, o.C)(s),
          y = '0x';
        if (r && r.length > 0) {
          if (!i.inputs) throw new a.Zh(i.name, { docsPath: h });
          y = (0, d.E)(i.inputs, r);
        }
        return (0, c.SM)([l, y]);
      }
      let f = '/docs/contract/encodeFunctionResult',
        m = 'x-batch-gateway:true';
      async function g(e) {
        let { data: t, ccipRequest: n } = e,
          {
            args: [c],
          } = (function (e) {
            let { abi: t, data: n } = e,
              r = (0, s.tP)(n, 0, 4),
              i = t.find((e) => 'function' === e.type && r === (0, o.C)((0, u.t)(e)));
            if (!i) throw new a.eF(r, { docsPath: '/docs/contract/decodeFunctionData' });
            return {
              functionName: i.name,
              args:
                'inputs' in i && i.inputs && i.inputs.length > 0
                  ? (0, l.r)(i.inputs, (0, s.tP)(n, 4))
                  : void 0,
            };
          })({ abi: r.Yi, data: t }),
          h = [],
          m = [];
        return (
          await Promise.all(
            c.map(async (e, t) => {
              try {
                (m[t] = await n(e)), (h[t] = !1);
              } catch (e) {
                (h[t] = !0),
                  (m[t] =
                    'HttpRequestError' === e.name && e.status
                      ? y({ abi: r.Yi, errorName: 'HttpError', args: [e.status, e.shortMessage] })
                      : y({
                          abi: [i.Up],
                          errorName: 'Error',
                          args: ['shortMessage' in e ? e.shortMessage : e.message],
                        }));
              }
            })
          ),
          (function (e) {
            let { abi: t, functionName: n, result: r } = e,
              i = t[0];
            if (n) {
              let e = (0, p.mE)({ abi: t, name: n });
              if (!e) throw new a.xL(n, { docsPath: f });
              i = e;
            }
            if ('function' !== i.type) throw new a.xL(void 0, { docsPath: f });
            if (!i.outputs) throw new a.MX(i.name, { docsPath: f });
            let s = (() => {
              if (0 === i.outputs.length) return [];
              if (1 === i.outputs.length) return [r];
              if (Array.isArray(r)) return r;
              throw new a.hn(r);
            })();
            return (0, d.E)(i.outputs, s);
          })({ abi: r.Yi, functionName: 'query', result: [h, m] })
        );
      }
    },
    70148: function (e, t, n) {
      'use strict';
      n.d(t, {
        V: function () {
          return l;
        },
      });
      var r = n(63171),
        i = n(2220),
        a = n(84196),
        s = n(47824),
        o = n(8282);
      function l(e) {
        let t = new Uint8Array(32).fill(0);
        if (!e) return (0, a.ci)(t);
        let n = e.split('.');
        for (let e = n.length - 1; e >= 0; e -= 1) {
          let a = (0, o.i)(n[e]),
            l = a ? (0, i.O0)(a) : (0, s.w)((0, i.qX)(n[e]), 'bytes');
          t = (0, s.w)((0, r.zo)([t, l]), 'bytes');
        }
        return (0, a.ci)(t);
      }
    },
    34814: function (e, t, n) {
      'use strict';
      let r, i, a, s, o, l, u, c, d, p, h, y, f, m, g;
      n.d(t, {
        F: function () {
          return W;
        },
      });
      let b = new Map([
        [8217, 'apostrophe'],
        [8260, 'fraction slash'],
        [12539, 'middle dot'],
      ]);
      function w(e) {
        var t;
        let n;
        return (
          (t = (function (e) {
            let t = 0;
            function n() {
              return (e[t++] << 8) | e[t++];
            }
            let r = n(),
              i = 1,
              a = [0, 1];
            for (let e = 1; e < r; e++) a.push((i += n()));
            let s = n(),
              o = t;
            t += s;
            let l = 0,
              u = 0;
            function c() {
              return 0 == l && ((u = (u << 8) | e[t++]), (l = 8)), (u >> --l) & 1;
            }
            let d = 2147483648 - 1,
              p = 0;
            for (let e = 0; e < 31; e++) p = (p << 1) | c();
            let h = [],
              y = 0,
              f = 2147483648;
            for (;;) {
              let e = Math.floor(((p - y + 1) * i - 1) / f),
                t = 0,
                n = r;
              for (; n - t > 1; ) {
                let r = (t + n) >>> 1;
                e < a[r] ? (n = r) : (t = r);
              }
              if (0 == t) break;
              h.push(t);
              let s = y + Math.floor((f * a[t]) / i),
                o = y + Math.floor((f * a[t + 1]) / i) - 1;
              for (; ((s ^ o) & 1073741824) == 0; )
                (p = ((p << 1) & d) | c()), (s = (s << 1) & d), (o = ((o << 1) & d) | 1);
              for (; s & ~o & 536870912; )
                (p = (1073741824 & p) | ((p << 1) & (d >>> 1)) | c()),
                  (s = (s << 1) ^ 1073741824),
                  (o = ((1073741824 ^ o) << 1) | 1073741825);
              (y = s), (f = 1 + o - s);
            }
            let m = r - 4;
            return h.map((t) => {
              switch (t - m) {
                case 3:
                  return m + 65792 + ((e[o++] << 16) | (e[o++] << 8) | e[o++]);
                case 2:
                  return m + 256 + ((e[o++] << 8) | e[o++]);
                case 1:
                  return m + e[o++];
                default:
                  return t - 1;
              }
            });
          })(
            (function (e) {
              let t = [];
              [...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'].forEach(
                (e, n) => (t[e.charCodeAt(0)] = n)
              );
              let n = e.length,
                r = new Uint8Array((6 * n) >> 3);
              for (let i = 0, a = 0, s = 0, o = 0; i < n; i++)
                (o = (o << 6) | t[e.charCodeAt(i)]), (s += 6) >= 8 && (r[a++] = o >> (s -= 8));
              return r;
            })(e)
          )),
          (n = 0),
          () => t[n++]
        );
      }
      function v(e, t = 0) {
        let n = [];
        for (;;) {
          let r = e(),
            i = e();
          if (!i) break;
          t += r;
          for (let e = 0; e < i; e++) n.push(t + e);
          t += i + 1;
        }
        return n;
      }
      function T(e) {
        return E(() => {
          let t = v(e);
          if (t.length) return t;
        });
      }
      function A(e) {
        let t = [];
        for (;;) {
          let n = e();
          if (0 == n) break;
          t.push(
            (function (e, t) {
              let n = 1 + t(),
                r = t(),
                i = E(t);
              return C(i.length, 1 + e, t).flatMap((e, t) => {
                let [a, ...s] = e;
                return Array(i[t])
                  .fill()
                  .map((e, t) => {
                    let i = t * r;
                    return [a + t * n, s.map((e) => e + i)];
                  });
              });
            })(n, e)
          );
        }
        for (;;) {
          let n = e() - 1;
          if (n < 0) break;
          t.push(C(1 + e(), 1 + n, e).map((e) => [e[0], e.slice(1)]));
        }
        return t.flat();
      }
      function E(e) {
        let t = [];
        for (;;) {
          let n = e(t.length);
          if (!n) break;
          t.push(n);
        }
        return t;
      }
      function C(e, t, n) {
        let r = Array(e)
          .fill()
          .map(() => []);
        for (let i = 0; i < t; i++)
          (function (e, t) {
            let n = Array(e);
            for (let i = 0, a = 0; i < e; i++) {
              var r;
              n[i] = a += 1 & (r = t()) ? ~r >> 1 : r >> 1;
            }
            return n;
          })(e, n).forEach((e, t) => r[t].push(e));
        return r;
      }
      function _(e) {
        return `{${e.toString(16).toUpperCase().padStart(2, '0')}}`;
      }
      function I(e) {
        let t = e.length;
        if (t < 4096) return String.fromCodePoint(...e);
        let n = [];
        for (let r = 0; r < t; ) n.push(String.fromCodePoint(...e.slice(r, (r += 4096))));
        return n.join('');
      }
      function S(e, t) {
        let n = e.length,
          r = n - t.length;
        for (let i = 0; 0 == r && i < n; i++) r = e[i] - t[i];
        return r;
      }
      function P(e) {
        return (e >> 24) & 255;
      }
      function O(e) {
        return 16777215 & e;
      }
      function N(e) {
        return e >= 44032 && e < 55204;
      }
      function x(e) {
        r ||
          (function () {
            let e = w(
              'AEUDVgHLCGMATwDUADIAdAAhADQAFAAtABQAIQAPACcADQASAAoAGAAJABIACQARAAUACwAFAAwABQAQAAMABwAEAAoABQAJAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACwANAA0AAwAKAAkABAAdAAYAZwDTAeYDMwCxCl8B8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgPi89uj00MsvBXxEPAGPCDwBnQKoEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiC+AZ4EWRJJFbEu7QDQLARtEbgECxDwAb/RyAk1AV4nD2cEQQKTAzsAGpobWgAahAGPCrysdy0OAKwAfFIcBAQFUmoA/PtZADkBIadVj2UMUgx5Il4ANQC9vAITAdQZWxDzALN9AhsZVwIcGSkCBAgXOhG7AqMZ4M7+1M0UAPDNAWsC+mcJDe8AAQA99zkEXLICyQozAo6lAobcP5JvjQLFzwKD9gU/OD8FEQCtEQL6bW+nAKUEvzjDHsuRyUvOFHcacUz5AqIFRSE2kzsBEQCuaQL5DQTlcgO6twSpTiUgCwIFCAUXBHQEqQV6swAVxUlmTmsCwjqsP/wKJQmXb793UgZBEBsnpRD3DDMBtQE7De1L2ATxBjsEyR99GRkPzZWcCKUt3QztJuMuoYBaI/UqgwXtS/Q83QtNUWgPWQtlCeM6Y4FOAyEBDSKLCt0NOQhtEPMKyWsN5RFFBzkD1UmaAKUHAQsRHTUVtSYQYqwLCTl3Bvsa9guPJq8TKXr8BdMaIQZNASka/wDPLueFsFoxXBxPXwYDCyUjxxSoUCANJUC3eEgaGwcVJakCkUNwSodRNh6TIfY8PQ1mLhNRfAf1PAUZTwuBPJ5Gq0UOEdI+jT1IIklMLAQ1fywvJ4sJzw+FDLl8cgFZCSEJsQxxEzERFzfFCDkHGS2XJCcVCCFGlWCaBPefA/MT0QMLBT8JQQcTA7UcLRMuFSkFDYEk1wLzNtUuswKPVoABFwXLDyUf3xBQR+AO6QibAmUDgyXrAC0VIQAXIpsIQ2MAX4/YUwUuywjHamwjdANnFOdhEXMHkQ5XB6ccMxW/HOFwyF4Lhggoo68JWwF1CZkBXwTjCAk1W4ygIEFnU4tYGJsgYUE/XfwCMQxlFZ9EvYd4AosPaxIbATUBcwc5DQECdxHtEWsQlQjrhgQ1tTP4OiUETyGDIBEKJwNPbM4LJyb5DPhpAaMSYgMMND137merYLYkF/0HGTLFQWAh8QuST80MnBrBGEJULhnkB78D8xrzJ+pBVwX/A6MDEzpNM+4EvQtpCIsJPwBJDqMXB9cYagpxjNABMYsBt5kDV5GDAm+PBjcHCwBnC4cFeeUAHQKnCKMABQDPA1cAOQKtB50AGQCFQQE9AycvASHlAo8DkwgxywGVLwHzKQQbwwwVAPc3bkoCw7ECgGpmogXdWAKOAkk1AU0lBAVOR1EDr3HhANsASwYT30cBFatKyxrjQwHfbysAxwD7AAU1BwVBAc0B820AtwFfCzEJorO1AU3pKQCDABVrAdcCiQDdADUAf/EBUwBNBVn5BdMCT0kBETEYK1dhAbsDHwEzAQ0AeQbLjaXJBx8EbQfTAhAbFeEC7y4HtQEDIt8TzULFAr3eVaFgAmSBAmJCW02vWzcgAqH3AmiYAmYJAp+EOBsLAmY7AmYmBG4EfwN/EwN+kjkGOXcXOYI6IyMCbB0CMjY4CgJtxwJtru+KM2dFKwFnAN4A4QBKBQeYDI0A/gvCAA21AncvAnaiPwJ5S0MCeLodXNtFrkbXAnw/AnrIAn0JAnzwBVkFIEgASH1jJAKBbQKAAAKABQJ/rklYSlsVF0rMAtEBAtDMSycDiE8Dh+ZExZEyAvKhXQMDA65LzkwtJQPPTUxNrwKLPwKK2MEbBx1DZwW3Ao43Ao5cQJeBAo7ZAo5ceFG0UzUKUtRUhQKT+wKTDADpABxVHlWvVdAGLBsplYYy4XhmRTs5ApefAu+yWCGoAFklApaPApZ8nACpWaxaCYFNADsClrUClk5cRFzRApnLAplkXMpdBxkCnJs5wjqdApwWAp+bAp64igAdDzEqDwKd8QKekgC1PWE0Ye8CntMCoG4BqQKenx8Cnk6lY8hkJyUrAievAiZ+AqD7AqBMAqLdAqHEAqYvAqXOAqf/AH0Cp/JofGixAANJahxq0QKs4wKsrgKtZwKtAgJXHQJV3AKx4dcDH05slwKyvQ0CsugXbOBtY21IXwMlzQK2XDs/bpADKUUCuF4CuUcVArkqd3A2cOECvRkCu9pwlgMyEQK+iHICAzNxAr4acyJzTwLDywLDBHOCdEs1RXTgAzynAzyaAz2/AsV8AsZHAsYQiQLIaVECyEQCyU8CyS4CZJ0C3dJ4eWF4rnklS9ADGKNnAgJh9BnzlSR7C16SXrsRAs9rAs9sL0tT0vMTnwDGrQLPcwEp6gNOEn5LBQLcJwLbigLSTwNSXANTXwEBA1WMgIk/AMsW7WBFghyC04LOg40C2scC2d6EEIRJpzwDhqUALwNkDoZxWfkAVQLfZQLeuHN3AuIv7RQB8zAnAfSbAfLShwLr8wLpcHkC6vkC6uQA+UcBuQLuiQLrnJaqlwMC7j8DheCYeXDgcaEC8wMAaQOOFpmTAvcTA5FuA5KHAveYAvnZAvhmmhyaq7s3mx4DnYMC/voBGwA5nxyfswMFjQOmagOm2QDRxQMGaqGIogUJAwxJAtQAPwMA4UEXUwER8wNrB5dnBQCTLSu3r73bAYmZFH8RBDkB+ykFIQ6dCZ8Akv0TtRQrxQL3LScApQC3BbmOkRc/xqdtQS4UJo0uAUMBgPwBtSYAdQMOBG0ALAIWDKEAAAoCPQJqA90DfgSRASBFBSF8CgAFAEQAEwA2EgJ3AQAF1QNr7wrFAgD3Cp8nv7G35QGRIUFCAekUfxE0wIkABAAbAFoCRQKEiwAGOlM6lI1tALg6jzrQAI04wTrcAKUA6ADLATqBOjs5/Dn5O3aJOls7nok6bzkYAVYBMwFsBS81XTWeNa01ZjV1NbY1xTWCNZE10jXhNZ41rTXuNf01sjXBNgI2ETXGNdU2FjYnNd417TYuNj02LjUtITY6Nj02PDbJNwgEkDxXNjg23TcgNw82yiA3iTcwCgSwPGc2JDcZN2w6jTchQtRDB0LgQwscDw8JmyhtKFFVBgDpfwDpsAD+mxQ91wLpNSMArQC9BbeOkRdLxptzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgELgEaJZkC7aMAoQCjBcGOmxdNxrsBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUHqSvAj5Gqwr7YrMUACT9AN3rlr3JG9m8w9lIAXltp/v8kfWaIaaR9OwpAES/I3ZVamDXSgB/UsOgAG6D0tq+5CIqE15FiAhV3yA2VhCQ7tj+m6xXaF53FIfGi/IAZIskMGAi2MU7MDVJNCbMzERyHZi+osdPtnFVbvq653O8rwaCy4IAf9OOok65AqJUtUriUfYsGPPVbe6jm0s9lbKlPCUKjdkHsFsEhvX4kT39ZCtAAbwQdn/h4TpO5hTByWAmr5n+Wuwhdegv6bmvX4LyOes3z2+cuHv2JFYwVMNuq2gzn8YHTjlUQd39osyWei4NKl3LAdfxlO876hh5ENp/cOvpuI9bF55guEthLLPOXjD4dktTH04P5TvZrWTM0e4+BHJxj7MLApXIFOs0sWKhNkG8iwuM5wR83my6V3wW06abhDzTXYfOr/ZpFXgXzmv4d12FFyP00/dPGbIVGV5ao8UufGzUwp/IHx6v/wDWJr9iaoCulhWwlZ7A8q/NMoD12+mBdNRgJYnThRLtMx1Bgwttn8/4Qn2CDfOSup9GVXEvA21ILgp0owHYxNOkpwLWz0G7K+WREIDjIzUzSn8I99CuJSmSpPyH0Ke6/NERYiNx+3dncSebPnOUnnWD61AhJ1n/tSLZmU5wYO5GfgzyAYJm6VL91LxZ8hL1lfximQxIDMRhIecQZBmeE5R0XlrpvwplVrJwpa8BBCdp93GPP9lyBeZ2zkRr920CR3cYbKpKHfogvm0nV7XdDz6EbjzlxADCMjSLXuXpIpyuizy39yY+I+H9rmpoIF3YwEjlH9MgGgWcCNTjHEWMqAbprn2Ox7rOHupaVE3lNyg3nt5XaZID6Y+uml5Ja+aOPu+BI+DZbiJVfaspUadakWUX6TA4dETkIqdJJHYnU4Z4yKpt5y8rVIahoMUf8A8kWtAQNCTbjp71gx3/zVdqNz1Sutkw0gFIMVm2BF4Xdv/0olw+NaDIR9Bb3DPweZA2K/cw+/b+AwyWl9ZOP67A9nexmeTNjfdzPGf9J6E6BMPKa5lJh+qNsdUz3HBUevU71eQFCqOcxiIYhacAhh/8PX0J5DdSViZ6WazDDx7cukJNpMfEkYLJ5Ao4vLoVd3d25Pg4qaVa2p2D2L3WvYPJ5Yf/A/MSxptjlgXL/KJtP2U0cRv2I09ATAiWCJYuRwiapeKFsqmi18yMMulDp3HdcIldq+7jkwsJUOHLHCzzzBw5XFvL0CAmo1ub456z7zb7shk3KPGCLZzr47oT1k/j06XNnJvG3Udv6XrP+wsqTBlZ5MaNPt9FOs/4Bt/ja/vbVhTNpBFl9Gq7MqINvGlWKOAwQzwOZy+EzSdjAqKJVV2YcskTuM94aIK+kc/AZaXiZLPREUDpkXIV947IFfj+85TrqPqLfkGcxgboMQjosf+az+odLNXdyp1mDNGsqSdK/pJ2Ca04mt/4d6s1X+lncOEYaGBBeW4pApGcjf7/XJCFbj3N3mFb+BtlIcw8ZiDKoClFX9Rf0bxCqtLpicObKJzBVVHr/6u4siH2hK75RNv7w9GfTbhJOQBYiFUZAByY4rn37tZBHT//kqKsNi3ryL9AqXJRzqiMIJMhILjoi/i8LVEsbu+Ih9bsyW16sgQqjYLO0qda6KaCPKj3DQcu6CfV5lKtjS3ZCdqLAZkOey9MR+QutJBGiz/r15GVD6rCVwJR4UUKC4GNJkfDf00OMW8aQtLSAGLXV8MIi9mbbl/qQEpxCm2L5hutFX4ekeLH4QgBWUFKs/2VVMKy46WtFE6AbwgmYm/Z0yHk5veDIrcl2HpVqb/rSE0PC9EbDzJEWqeaPhh7vF369Umq2kSiB3s5rBI6c/7N9bkRu4h2n+/h5nSwy+7n+/I+6oXQVANo2Jb5zDwtiBPf1ySCzHdT6yJShMzqSRZfnykX49CaFaxhoVF4PBhEuECJ1PrFYSpmHuyYsl14DTAV9ZxRms1XiR/kBrjhZjidOt0UNe+GSml7XNgpVw8YsUTmZXLTK+6iYnyW/wYR1W4UXwOi14xpFROHb6HcZzksgF5DbL2AFXzKNwHU2adjdAY+KCyM/cwRTBkkq/a227NI0q6DR2MkMCRu620t79bGcYUmACtqN3mk/0uNwd3JSXHqE1kzf6Yyj0W2083JNDRnIXDlgBxJ6uf58NN1f6FQiRCWB4egF8QDx74AixV8oTyw7PluIjr3/rj/WzgwPSq4xPojaF7V0xqG2u5ti2L1h6yYHv73Isrukr0kURDIEjClBsBx7kdcXUxaYMS0syT3ymLzDzslNDWQOT1Tao1YNmJHARUenhCkmV9tqCPGI5GqZaRpkiPxyjoncWjyOHYGqvbvRX+Bn1pn7EhRNXa1lqJPmoeN5VqdqIDPhEVhFsyG0d4iQEIYX0wZUbY2XbZWYlpZ/l66IrDDY0q1C1YzBDpHC4h05YqHQLqS9anyl22JQ6lEvjvdBwMHfE7z0luCXD34/rFeDa2TmSeEAykSpYO5j1G/nsgpR3qn0qaQEmLjnnLfcz+veoYqPnRqmRGwCJ6FJ3Gm/Z1/aVX5PSb03MMnjAf41ww54sD5k8FrkfBP+K0b1MrYpapWjtpZfve2HVf4ickX3LKSOhu7qI1Vd4c1kNrn2ajy1t4y93JhV4fnWCKq7OmFpcr7FjdJCXPTql0Drr14Ho3Z87+GPQ4Z/DcTiGqtvZxlRYi8cNuhXABveZIwNl/BX1huhVLaFax5OqypUrQRyb9OE3SSkPlDdy5uo5XGg2EIGEjLY1MO5cr1ibfiFWV7zspcTgkBKkwo5jPyAin04LqizZXb2tDRgwKJjGx4cVk3ngAQixwcxjYAg2Q7vmUR/hpwInMdw7OhC2qyf41vTPkudQAORS0DdLtOGQxb4fH2VYGsvJCkeWPeUwtf1/tuIhzXEThoCZzzSJqqjUtbaPI3ntHm3T5uf849hGUA0zU8ni5W+EEn3/0Y6oUhQFw9z0aGjkljBbAlFXc0y82G2wkd7VdgWa5KTgJJNjNwZMfmdnUIUn1JU5LiWX5UZEZbVlKSN76mlmjUR2ku+fucTNlO4IAAahnLjBhlvQNR9pe9swGBgq0YR7P3VCyI/seYwQ4QBzy9X+HPePgoF8WfKaJ4MBOhLCGHae6Z8xkNXwni9QAKvTNtVA56x8YJflZ/VvONRSlsSLmiSyNMnTjTaE1ko81zkzGEnVwEhjCzlwIqpxmpDAqwsEmtpdr3xpc7i/ZX3f2TzT3M0FdxIEQvO1jgmmiN+D1YpMduAzEhBtj2OBkMN/rv6p7Th4pSH6f5aH3aTvwFTl7EOSgGASI7ttyMehzpm4AVyK+bFEaFg9gnZsSUPpsbAe/0RFhrH+EXZ12Z7thf4dzN1+Sn+G8QrDA1VKaN4IFxD1rQz9Xq9Coii9S9/hPbTGjyBwFH3H1UdQuz5KsgPDEHua4/kPg2Gp/IIItsaLWBqiT9XH45MiQxSosGJ56H/0F2cjcCFd72l1665RNHURdC3lspI77esfJsl+rXXabkAy7vxDXG/XGGcKpwiKDPFfvMEgjkAHil4Za1F36RnyxxvdIAzvgfH8knukYDck07tc++DP4TdWeI7HXuq5Yl6VVFrUQtf64/dkXewlKZSHQo6YvCSpREB0GDrz+Ys2GfO8nw2SwrYwaf88AifzlPvP17bf1mI3AuccJvAjZIpBmqvharKFAebEjVKfGAwpQjWoXlm9LROsq9bCk1UeQ3CJxJqprzssS/Q04JeS1ReCCubL3J7sx86spkP4eNpp95UF+8K748icIs8vdILFklk9skQqi1So6cx3X906pvy1vz+KipTJ8fiVJxsV5MmT0XwA'
            );
            for (let [t, n] of ((r = new Map(
              T(e).flatMap((e, t) => e.map((e) => [e, (t + 1) << 24]))
            )),
            (i = new Set(v(e))),
            (a = new Map()),
            (s = new Map()),
            A(e))) {
              if (!i.has(t) && 2 == n.length) {
                let [e, r] = n,
                  i = s.get(e);
                i || ((i = new Map()), s.set(e, i)), i.set(r, t);
              }
              a.set(t, n.reverse());
            }
          })();
        let t = [],
          n = [],
          o = !1;
        function l(e) {
          let n = r.get(e);
          n && ((o = !0), (e |= n)), t.push(e);
        }
        for (let r of e)
          for (;;) {
            if (r < 128) t.push(r);
            else if (N(r)) {
              let e = r - 44032,
                t = (e / 588) | 0,
                n = ((e % 588) / 28) | 0,
                i = e % 28;
              l(4352 + t), l(4449 + n), i > 0 && l(4519 + i);
            } else {
              let e = a.get(r);
              e ? n.push(...e) : l(r);
            }
            if (!n.length) break;
            r = n.pop();
          }
        if (o && t.length > 1) {
          let e = P(t[0]);
          for (let n = 1; n < t.length; n++) {
            let r = P(t[n]);
            if (0 == r || e <= r) {
              e = r;
              continue;
            }
            let i = n - 1;
            for (;;) {
              let n = t[i + 1];
              if (((t[i + 1] = t[i]), (t[i] = n), !i || (e = P(t[--i])) <= r)) break;
            }
            e = P(t[n]);
          }
        }
        return t;
      }
      function M(e) {
        return (function (e) {
          let t = [],
            n = [],
            r = -1,
            i = 0;
          for (let a of e) {
            let e = P(a),
              o = O(a);
            if (-1 == r) 0 == e ? (r = o) : t.push(o);
            else if (i > 0 && i >= e)
              0 == e ? (t.push(r, ...n), (n.length = 0), (r = o)) : n.push(o), (i = e);
            else {
              let a = (function (e, t) {
                if (e >= 4352 && e < 4371 && t >= 4449 && t < 4470)
                  return 44032 + (e - 4352) * 588 + (t - 4449) * 28;
                if (N(e) && t > 4519 && t < 4547 && (e - 44032) % 28 == 0) return e + (t - 4519);
                {
                  let n = s.get(e);
                  return n && (n = n.get(t)) ? n : -1;
                }
              })(r, o);
              a >= 0 ? (r = a) : 0 == i && 0 == e ? (t.push(r), (r = o)) : (n.push(o), (i = e));
            }
          }
          return r >= 0 && t.push(r, ...n), t;
        })(x(e));
      }
      let k = (e) => Array.from(e);
      function R(e, t) {
        return e.P.has(t) || e.Q.has(t);
      }
      class D extends Array {
        get is_emoji() {
          return !0;
        }
      }
      function B() {
        let e, t;
        if (o) return;
        let n = w(
            'AEkU4AngDVgB0QKRAQYBOwDqATEAnwDbAIUApABsAOAAbwCRAEYAiQBPAHYAPgA+ACsANwAlAGMAHwAvACsAJQAWAC8AGwAiACIALwAUACsAEQAiAAsAGwARABcAGAA6ACkALAAsADUAFgAsABEAHQAhAA8AGwAdABUAFgAZAA0ADQAXABAAGQAUABIEqgYJAR4UFjfDBdMAsQCuPwFnAKUBA10jAK5/Ly8vLwE/pwUJ6/0HPwbkMQVXBVgAPSs5APa2EQbIwQuUCkEDyJ4zAsUKLwKOoQKG2D+Ob4kCxcsCg/IBH98JAPKtAUECLY0KP48A4wDiChUAF9S5yAwLPZ0EG3cA/QI5GL0P6wkGKekFBIFnDRsHLQCrAGmR76WcfwBbBpMjBukAGwA7DJMAWxVbqfu75wzbIM8IuykDsRQ7APcta6MAoX0YABcEJdcWAR0AuRnNBPoJIEw3CZcJiB4bVllM44NCABMADAAVAA5rVAAhAA4AR+4V2D3zOVjKleYuChAdX01YPewAEwAMABUADmsgXECXAMPrABsAOQzFABsVW6n7Adq4HB0FWwXiAtCfAsSwCkwcpGUUcxptTPUAuw1nAuEACy00iRfJkQKBewETGwC9DWcC4QALLQFIUCWRTAoDLfsFMgnXaRetAddDAEkrEncCMRYhAusnuTdrADnhAfUlAMcOy7UBG2OBALEFAAUAitNJBRvDHwcXAKgn0QGhKy0DmwBnAQoZPu03dAQYFwCqAccCIQDTKxJzOvNQsAWQOncnNUgF+icFWQVYr7gFaTtdQhI6WEGXe5NmX6H4CxMDxQcl8XcjBKNLAlNTAnUbqycBj6OlNVsDRRcEg2EJANEGqz8vIwcpAjldAGsBYR9xAIMdGQCVAUm3ACdpFwGvxQM3LSFDUwFvWQZlAmUA8UkXAykBBQBJQQCrAF0AcwArtQYH8+8ZjX8ACSEAKQCzG0cB0QHbBwsxl3iB6AAKABEANAA9ADgzd3nTwBBfEFwBTQlMbDoVCwKsD6YL5REVDNEqy9PYADSpB+sDUwfrA1MDUwfrB+sDUwfrA1MDUwNTA1McCvAa08AQXw9IBG0FjgWLBNYIgyZJEYEHKAjSVA10HhxHA0UA/CMlSRw7kzMLJUJMDE0DB/w2QmynfTgDRzGrVPWQogPLMk85bAEecRKgACoPcxw1tU5+ekdxoApLT661f0liTmcCvjqoP/gKIQmTb7t3TgY9EBcnoRDzDC8BsQE3DelL1ATtBjcExR95GRUPyZWYCKEt2QzpJt8unYBWI/EqfwXpS/A82QtJUWQPVQthCd86X4FKAx0BCSKHCtkNNQhpEO8KxWcN4RFBBzUD0UmWAKEG/QsNHTEVsSYMYqgLBTlzBvca8guLJqsTJXr4Bc8aHQZJASUa+wDLLuOFrFotXBhPWwX/CyEjwxSkUBwNIUCzeEQaFwcRJaUCjUNsSoNRMh6PIfI8OQ1iLg9ReAfxPAEZSwt9PJpGp0UKEc4+iT1EIkVMKAQxeywrJ4cJyw+BDLV8bgFVCR0JrQxtEy0REzfBCDUHFSmXICcRCB1GkWCWBPObA+8TzQMHBTsJPQcPA7EcKRMqFSUFCYEg0wLvNtEurwKLVnwBEwXHDyEf2xBMR9wO5QiXAmEDfyXnACkVHQATIpcIP18AW4/UUwEuxwjDamgjcANjFONdEW8HjQ5TB6McLxW7HN1wxF4HhgQon6sJVwFxCZUBWwTfCAU1V4ycID1nT4tUGJcgXUE7XfgCLQxhFZtEuYd0AocPZxIXATEBbwc1DP0CcxHpEWcQkQjnhgA1sTP0OiEESyF/IA0KIwNLbMoLIyb1DPRlAZ8SXgMINDl36menYLIgF/kHFTLBQVwh7QuOT8kMmBq9GD5UKhngB7sD7xrvJ+ZBUwX7A58POkkz6gS5C2UIhwk7AEUOnxMH0xhmCm2MzAEthwGzlQNTjX8Ca4sGMwcHAGMHgwV14QAZAqMInwABAMsDUwA1AqkHmQAVAIE9ATkDIysBHeECiwOPCC3HAZErAe8lBBe/DBEA8zNuRgLDrQKAZmaeBdlUAooCRTEBSSEEAUpDTQOrbd0A1wBHBg/bQwERp0bHFt8/AdtrJwDDAPcAATEHAT0ByQHvaQCzAVsLLQmer7EBSeUlAH8AEWcB0wKFANkAMQB77QFPAEkFVfUFzwJLRQENLRQnU10BtwMbAS8BCQB1BseJocUDGwRpB88CEBcV3QLvKgexAyLbE8lCwQK92lEAMhIKNAq1CrQfX/NcLwItbj1MAAofpD7DP0oFTTtPO1Q7TztUO087VDtPO1Q7TztUA5O73rveCmhfQWHnDKIN0ETEOkUT12BNYC4TxC2zFL0VyiVSGTkauCcBJeBVBQ8ALc9mLAgoNHEXuAA7KWSDPWOCHiwKRxzjU41U9C0XAK1LnjOrDagbEUQ8BUN16WImFgoKHgJkfQJiPldJq1c3HAKh8wJolAJmBQKfgDgXBwJmNwJmIgRqBHsDfw8Dfo45AjlzEzl+Oh8fAmwZAjIyOAYCbcMCbarrhi9jQScBYwDaAN0ARgEHlAyJAPoHvgAJsQJ3KwJ2njsCeUc/Ani2GVjXRapG0wJ8OwJ6xAJ9BQJ87AVVBRxH/Eh5XyAAJxFJVEpXERNKyALQ/QLQyEsjA4hLA4fiRMGRLgLynVz/AwOqS8pMKSHLTUhNqwKLOwKK1L0XAxk/YwGzAo4zAo5YPJN9Ao7VAo5YdFGwUzEGUtBUgQKT9wKTCADlABhVGlWrVcwCLBcpkYIy3XhiRTc1ApebAu+uWB2kAFUhApaLApZ4mAClWahaBX1JADcClrEClkpcQFzNApnHAplgXMZdAxUCnJc5vjqZApwSAp+XAp60hgAZCy0mCwKd7QKejgCxOWEwYesCns8CoGoBpQKemxsCnkqhY8RkIyEnAierAiZ6AqD3AqBIAqLZAqHAAqYrAqXKAqf7AHkCp+5oeGit/0VqGGrNAqzfAqyqAq1jAqz+AlcZAlXYArHd0wMfSmyTArK5CQKy5BNs3G1fbURbAyXJArZYNztujAMpQQK4WgK5QxECuSZzcDJw3QK9FQK71nCSAzINAr6Ecf4DM20CvhZzHnNLAsPHAsMAc350RzFBdNwDPKMDPJYDPbsCxXgCxkMCxgyFAshlTQLIQALJSwLJKgJkmQLdznh1XXiqeSFLzAMYn2b+AmHwGe+VIHsHXo5etw0Cz2cCz2grR0/O7w+bAMKpAs9vASXmA04OfkcBAtwjAtuGAtJLA1JYA1NbAP0DVYiAhTvHEulcQYIYgs+CyoOJAtrDAtnahAyERac4A4ahACsDZAqGbVX1AFEC32EC3rRvcwLiK+0QAfMsIwH0lwHyzoMC6+8C6Wx1Aur1AurgAPVDAbUC7oUC65iWppb/Au47A4XcmHVw3HGdAvL/AGUDjhKZjwL3DwORagOSgwL3lAL51QL4YpoYmqe3M5saA51/Av72ARcANZ8Yn68DBYkDpmYDptUAzcEDBmahhKIBBQMMRQELARsHaQZdtWMBALcEZ7sNhx6vCQATcTUAHwMvEkkDhXsBXyMdAIzrAB0A5p8Dm40IswYbn8EApwURu+kdPT4WeAVoNz5AK0IhQrRfcRFfvACWxQUyAJBMGZu5OyZgMhG6zw4vGMYYicn2BVcFWAVXBVgFYwVYBVcFWAVXBVgFVwVYBVcFWEYVCNeFZwICAgpkXukrBMkDsQYvu7sAuwSnuwDnQCkWsgVGPmk+cEI/QrZfdTdf6ABYETOrAIz+zGvL/KbnRno9JiMEKxYnNjV+bd9qwfEZwixpAWvXbjAXBV8FasnBybgIz0lbAAAACnxefYu+ADM/gQADFtEG5a0jBQCMwwsDAQ0A5WUdPSQfSkKxQrxBOCNfJ2A2JzgjCcE9CkQ/Qz54PoE+cD5xAolCvElCO1/LTk9qTQosa1QvagtuH1/gMzobCWebCmIjKzwdJkKrQrwrzAHL/F/JDh8uCQgJIn6d32o6LUoXyavJrAllwcvMCmBBXw/lEKMRAJONHUVCJRupbTnOOAozP0M+cEI/HAcKHUxHbFssLVrhvBIKfe0dK0I/HF0ISgkOM1RDQjcEO0OcLAqBGy1CPxv1CFMiIxgwMQAFj2HwXgpxZMlgC2AtI25DYBk5AhseYLMGAmsQZU5gTREBZOdgFWCVYH1gs2BLYJFoFhcGtQ7cVam8WgtDFqsBuyvNwQIfFQAcAx4BeQJsLzCVUoABigq4RxoA5CN0jgrKDaZN6gGbAoecTwVAXwD39wkANBZXDAulDCQfuq9HAE8MNAAVE58rggh6AtILS2URGwDYTgZ1BAoeWgAxALa4AZonCxZvqyQ4nxkBWwGGCfwD2e0PBqoGSga5AB3LValaCbthE4kLLT8OuwG7ASICR1ooKCggHh8hLBImBiEMjQBUAm5XkEmVAW4fD3FHAdN1D85RIBmpsE3qBxEFTF8A9/cKAHoGJGwKKwulODAtx69WDQsAX7wLAGNAlQh6AOpN7yIbvwAxALa4AZonLTsOzgKQGHtQu1jIdHKO16WbDvWZFT0b7AEpEFwSBg8bAccJOhCTBRArDDYLABEAs84BAgCkAOEAmIIABWtXLwAUAFsbxi5sdioNwRACOyQz0+EcHgsbfQJ7Ls6hHATBCqrxbAA3OS0Opge7CQAQOi7OERkAfavaHA+7GkcczaF3HgE9Kl8cAuugCAHCAULz5B9lAb4Jtwz6CDwKPgAFwAs9AksNuwi8DTwKvC7OoSoJPA67BZgBG2sKD4sa4QHDARELuxY7AKALOxC7BBige9wAO2sMPAACpgm8BRvQ9QUBvgH6bsoGewAHuwG7D00RErwBAQDqAQAAdBVbBhbLFPxvF7sYOwAuuwLrDlaouwAeuwJVICp/AAG7AALjAAg7FTwVuwAbuwG9KOClWw6/xAD0AGj7L7ZtvgNIo7vIqDsDAbuVJ0sAAlsACrsEAOfdGbsIGnsIoQUK/3AA37unuxjbGruji3lyBvupm4MAErsGGwsBvAAAhgBtuwYAC7unOwEaO7oIoZzKAbsL7QfAqTsA4XsBvwAA5QAVuwAG+wAJuwBpiwAauwAOuwIYu45pFfsAAVsADmsALkseAAa7ABe7CCEADUoBwgC3ryYBwAAAtAAOmwG+J+QAsloAHBsBv/7hCqEABcYLFRXbAAebAEK7AQIAabsAC3sAHbsACLsJoQAFygBunxnVAJEIIQAFygABOwAH2wAdmwghAAaaAAl7ABsrAG0bAOa7gAAIWwAUuwkhAAbKAOOLAAk7C6EOxPtfAAc7AG6cQEgARwADOwAJrQM3AAcbABl7Abv/Aab7AAobAAo7AAn7p+sGuwAJGwADCwAQOwAAFDsAEWsAD4sADesADbsAGQsGFhsAFTsAbpsWswG7ALoAEzsDAGkrCgDhSwACOwAEUgAXewUbAAbQABi7AAv7AF+7AGv7AOSLAbsAF3YBvAABcguhAAVKHgF7KFIAOUUA/gcNDHIAKCpwAaQFCF4BvF4jDAkHb0tsXyqJHzwUYi02A6EKtAHYABYC0QNuAXZyR1IUIQNPAhU+ASwGA3NGvHtSekAAKQAxAfsAUwrbAHuQLAErAHblDREyRgFKAFcFAAFQAQeKzAB4OwQgpQBaANYVAJVoNx+LAM1rsQDP1BYIwnVzGxhWHQnRAYiQqyJTU01IEjzCifkAfxw3QCkr4BGXTwByASksMClCGQ8DMFUE98XuAEtl3ABqAnECPxF6Osd4LjXVBgUAEBsdCggMKgQfHSlOU04IuboAChLNACYAARoAhgCJAI41AO4AtADgAJ08ALsAqwCmAKEA8gCfANMAnADrAQwBBwDAAHkAWgDLAM0BBwDXAOsAiACiATUA4wDYANUDAQcqM9TU1NS2wNzN0M5DMhcBTQFXL0cBVQFkAWMBVgFHS0NFaA0BThUHCAMyNgwHACINJCYpLDg6Oj09PT4/DkAeUVFRUVNTUlMpVFVXVlYcXWFhYGJhI2ZocG9ycnJycnJ0dHR0dHR0dHR0dHZ2d3Z1WwBA7ABFAJYAdAAuAGLyAIoAUwBTADMCc+kAh//y8gBgAI/sAJsASwBeAGD5+aoAgQCBAGUAUgCtAB4AsgB/AjwCPwD4AOMA+gD6AOQA+wDlAOUA5ADiACkCdwFNATwBOgFQAToBOgE6ATUBNAE0ATQBGAFUDwArCAAATRcKFgMVFg4AigCSAKIASwBkGAItAHAAaQCRAxIDJCoDHkE+RykAiwJLAMMCUwKgALoCkgKSApICkgKSApIChwKSApICkgKSApICkgKRApEClAKcApMCkgKSApACkAKQApACjgKRAnEB0AKTApsCkgKSApEWeQsA+gUDpwJdAjYXAVAQNQLeEQorEwFKNxNNkQF3pDwBZVkA/wM9RwEAAJMpHhiPagApYABpAC4AiQOUzIvwroRaBborDsIRAZ3VdCoLBCMxbAEzWmwBsgDdfoB/foB+gYKCfoOGhH6FiIaAh4KIgol+in6LfoyKjX6Ofo+CkH6RfpJ+k36Ug5WIloKXftoC2WzhAtdsAIJsJGygAINsbARCBD8EQQREBEIESARFBEAERgRIBEcEQwRFBEgAlmZsAKMDh2wAtGYBBWwAyVFsbADPbAIMbAD2WmwA9gEZAPYA9AD0APUA9AN8XmzUhCNlvwD2APQA9AD1APQcbGwAiVpsAPYAiQEZAPYAiQLsAPYAiQN8XmzUhCNlvxxsAPdabAEZAPYA9gD0APQA9QD0APcA9AD0APUA9AN8XmzUhCNlvxxsbACJWmwBGQD2AIkA9gCJAuwA9gCJA3xebNSEI2W/HGwCQwE2bAJKATlsAkvBbGwCV2xsA54C7AOeA54DnwOfA58DnwN8XmzUhCNlvxxsbACJWmwBGQOeAIkDngCJAuwDngCJA3xebNSEI2W/HGwEN2wAiQQ4AIkGjTFtIC9s1m4DJmwA/QDGWgJsbABVWv4UMgJsbACJAmwAVAEAuV5sAmxebGwAiV5sAmxebD3YAEls1gJsbEZFNiJ9FGVAe8xvEZKvxVfKZszAVTBzYBH2d1iyUXEHH7twNw7eZF5JJRHI5EgaRr5D20/3dfONrFLSq5qSrrgd2CEUq722WBQ/LzpA+bx1oREI5xy4BDSZNun0ZWORUJqInZSyMaioyvfSI0l5uFDzbWaQ28/zdB0hwR4OQZ0/jn9ALSLNikjFYGfqR389qtFlhD3a6KdIh97rhZYpywuLc7o8ql5/X8KCbPU3L/QlmCowhRXhsGDvg6wUNprA9bM/49uxlAj7ZVy3ouEY/BgFXBNyK0TLrSjZWeJm/T4nz6QGLT3cJNtWRZVZTvIdtaxMMJRHgig9+S11LjBh7Inr06ykoch1U097Rw0hvgmOrydQyaWcEQDg0RavuMuT0zYabUZl1e33HNSK1oNUCS03eh+9C2EvF3fq9h+XBaAMFuoWeZf+mfZgL4HzyiKDIUtfNU4oFu0aE9qt3VA3U4D3fOSrAcYVnjG3cSkp1vhXZnp3JQm4JknKdBitO2NVnGCYQwU3YMWHWB87NEd+4AHuOKI8BSIH92reW0pfs+kWCTJxDCbRjFv8Cfc4/DSBYJScJYTeAEgg9wTEvcwd/QuHRHqGzAQ4fXf5FUI1lPrO+fvEcPl4JInM1z9AtBT2bL4QYEREe7KiSnnxTwtmAFjn8lqT3mND8qTktX2F16Ae9cakqJ6/pEQsHURqyqWlRMCzKXRKfCHT7sYHWx9/T/ugYTFY6iVN3Btm58ATJR5alYZybKMWojwOw3HbFn23NFyeLl7+Er82RchyYuBoGQ3j7SAWNxiYvp5U+Fq/DEzB9cG5DlJWsqkosRze92OVlCtQEYo1S1lF72Z8xWc4ld/+fFcfTEDTFb9d8tJGQ75dpJEvcWyGmGBiTbiWDdGOcw93Dmxq5ISUrmasygONfHLvhgo83HQZenbdBtSzBkvYrCEQ/xEDMhMZsN6gqplx5jGG9mSQLhM81UEdEeJ59sdNJDAFy/gPyJoKlwPZgB/MkC/kICLiCB8va+nCdO2ry4aDfkmPFpF/H/SGQ3LJ6aAv9dtJ8DniHtLOckZix0BVb0iR5V3LAp521LBSIi6AtV7r2ZB/hQEvAw54EFNOQcFnl1xGUIc67tqK1INNwD2n/RbwgzO9h45LM6VMuN8V1ZNIQ6t+Xy3lTqyVCD5kqLy/t3/b8MLbgDg8JIWDkSZ+LrGhhr+gYpH+pr1TnCUnZPjpUdw6bSL6MWVXoDDciQDWECwU2e6VEpfrcOBbrSOijqGkEIoJPbpmeJLkcwbvA0yWIixQVjo0HnYh7fji+Dfdq1mtV1lG2Zz9R7eFMHS+FK7nybutu2fwzDpFldO2pZBshsHJWaltn3PWOoGJpCT2jE8EHOuC6FkejNWcfsWCqNqMLP9xTwcWArj2EiiI7D+EaDi7/2cqHL1gPiF6C/J7aUo7RQqogPZ11WqbyP97nsoMxPOC78wZMF7B1Y0g7JNXJV/nN1m4xx8hbqWz07KSaqr5hE4icB326DMR/vUKX9LoNjle/ZWtbUhrTAcsdgrLlG5Ne8aiR0bS/2ZhpNOVVxavWIZsEM/rd68EB4vjbbD13NkMK1qvMk74vGbSkL7ULO0sZ9R6APSCo6KH+Xn98wEdw1bCPAnDTaBsD6sidAGN58uiH4a3ovG1KyZAu2XtyGgF/vgWKGxw9R1lfAVcfuYE71DHuxtTzfGZnHaDpDGWmfEq0N4GawE7yIkaoz8jcmVmzJe1ydM8q0p08YIxFcY1YcqQc1djWBEoNETDFcgk5waRftEJasPREkrV++N/TOKkERF1fCLrXS8DFGYGRBeECMQRNEs0ES3FzUtXCcNxpYEM3Uei6XodZruXUIRnn+UXf2b/r7n1vQutoi6WoIbW7svDNWBbUWcDUc7F9SJK3bvSy9KIqhgyJHoW2Kpvv0J4ob14HFXGWWVsYXJzjwxS+SADShTgCRjhoDgjAYRGxwJ1Vonw+cpnCKhz8NQPrb0SFxHIRbmG95Q2hlC4mDxvPBRbkFa60cvWakd7f0kVBxxktzZ9agPJEWyA63RSHYVqt8cPrs2uFJ3rS3k9ETGKn5+A6F9IOrdZHfT1biEyUJKEvwzuscwshGCBJvd16TrefW03xVnJf4xvs72PdxrMidjJO8EiWyN/VWyB3fv9kc34YIuZTFtXGo9DuG3H1Uka5FgBMwDPEvRcSabi3WakNQkXFecJlFk6buLVk5YHpuKWTw6oF632FPPSVIVl5hgUAeHhj0t/sw/PEEvThLQDDFE34eCg/rLOyXT3r+L98oRKrlTO0MdALYQ3rRQqC7d822dJPGxF1K4J2TtfPSMFaCAg0n0NGk9yiaKKOJD1v2aBX9HUOIawjjfvwCmjHZJTR62R9c9x33JnBjWrN4QYEOmehy0oZMP9XM9Zyi6TYoe07PaLceRXcCWZiY/imRUWW6+mci7+wMxSdwMdbXckXtvhJH8sc4iQcTwm7yp+3f7CaesTTQB2qkgeXh+wFiSMXfMlH7Yil0OoZ2QTtRLTip2O0cLZ4SstqWHZ6H+8A2kZXhpm0kPbL9dUanTOvziqIUh6Ambwa3WrCb2eWbuCN3L1hgWUmjRC3JoL3dBhR3imSQI8xuCMfsszlji7cSShNSYdqCXPxEVwbqO9i5B6hf93YI7aeyI8jxgcVXK0I/klbvhSXjkjOIwZgPdVwmsFW7HGPLUAvDRuKm+itybRg7c8+Yqqjg824Qf+/NxsBSUNAK9KCoJpauFqK0XQULrWYj4FnxeKDuvr54iokpi+D57e6Y1zxRJJdsHnDR3JyraCUufHBRTKODWBVzthjm4k3/Hv+Q990XDVR+KW+TcJX045LW86EKhz/97aqj89A8ZvTk1//tczosU90loIPVaHuWegJU3wP//7XHcO7c0yQM2jM/IhQKrf8hiObHWiWDZManF8Uf/HzbmDfC2wT//aiZ4hGTv/xzgKwdb1sD6cGEkceow0s3b89/zg+3plyRm0HlZi886j5wUwFhdHiDTaBidZRo5cx/tMeLyguOATbzq17ydhzbrpxunuHx6lbFGiO97gsd4dk//7iCIo+Ew+hG2so5kvv+ITG4c1fzHPtu1Xn5QfUnqY3/uByVmB7gmnE/E+5zdm+6nDmoews5fr+NzThdSHzK4bBQOL9c4O8OI0xLSqjJ4lbniLJg1aFpQRLwaSMZmpkC9e/j6FOVrTQ6a/a4alGgfrl2ZL1sbHUQ3DOI7ntq9diHFfm3t1mul3rdJEJCHnlW/hlQntipMrpeMs7fUr6wK370D7VbXH0DUHzdYfRg/6Z11Ult1sffJS+heHbco15Sxy3+rDnPesqH1lajk0yu02hPUvEUqvcUXWXL7Ad0wNGMx5gOle4XJxq/r/YY0xdco2wRSEGwcT7YADlBrHc9ZbvzOL0QwyWCWWChB9Obg800v7tyBWaNvdwz+fL7Ph9i2irEeJkRgOzeEDw+JiD/V93vH9FgMEoFIJMoIuogmicZohf94SBuPn6hXaV9jP4VVVA/bu+Wg8S88GLtmEPSNRLdtlXx2XL/nuM8nKkhnlnjaropiKKLIH94pLIASci0pDBfj9Hi5BfaTSXQg5+PMjQX91Ktk4MOqK1K99l4BRPv5+vNovGZ3IxQv8ICvjV4/diThpoaM8uvd3D9d/DE477w3yAbW3IDm2i73pZ9aEj38JqS6h/s8/xgmUIVcuq2JTgefAyuoafzQxAuRASeg3NtG3ach/JEkyuX+JDt2PnDZTShUhyHHG3ttBg/6lhAchGjLJBtopj4e01MlCp2yqQRTr4sBBXru+lKaoanwYX8y2aWCJiR3KnhCOkYVFSvsO0oDRujUFOEptiNDTYrJoUbvOyvl4AhC9h3wORiTXK1MrpMfnvdnndnR/HRVSusMBgIxwrLdn3vq1VcncPiD0SquTx/kNmxeFyCT4uXVUd9AL+rSGmuq7OOCzDKeVPjiNWVaoP5KOFqYq5Xcuf/xW9S+u9eIq9GAtZWtQlgkRecjRtvG1NR4WXXpn+pwsTBTIy079Ikg8rSef1aVapIFcXCd6C2wHVjLXR+N0tw4Taw6x6H90BFRgNrtlq2up6hHKuV3inM5RJaQWZHd84e6RsKkk9po3dk9by54tpPw7cBkFas/G+GbHwuG+AwP55BZyXILTHCIVrPpXHEaUPYfL6nphJP1Rc10xG4UaCeY4IHCwuur8xmSQDgY4aVwhzWhjbtSHG8JO6P2i2nC9/0Bfx0zk6dYQq3aw7k5vIObD7SEKrxhz0fQ0+YTOfHW23CBNeZci1qNsUDhoeqmfyP6PvjoEjHk8QbrFyQVZPHVWijnb8YCM65iYNoEbvnchStZ/9cKg5Vd45j8KnB6UjzXl/bkyZx7VoD47ocUUi117WwgySSb4rXgLJ52Mv5XJbp3I+uBP81BUvOjy4Cacgi+GWWlC/8dwgqwiojjUBDnEOxyRyowwLQfytFra1OZS4XvRYr4uoamAfG3I/p2bA7G90yqKThH8Ke00Tqd+3l3dmJpaCZelBMYjGqNLVa3SM4+LQeL56gY6Bymy2LQPVOxjWfj5tq4o74swcxhyGJPynkS5xAjOXZP1/FAYcBT3u6qLoIkEfErwo4gozmyI1YCvM0oyI3ghjGPQSsof2sKUhq91WsKy9cYWN+4A2v4pG/Mxpdc6w6kI/HX7Xb0TuihmsiOy2wQIsrZbUmr3OBSUo6oDJNgQp+YqYkgTgYcWZDgawJw3DFfdzT//PhVUidgB2qa8uw/j9ToHBAS33iT8YLhhAfyXG0bQUFp7QmH7oQ3i6Flf4OTZLvJdh8pfuflmWu2ohm5pTiSg1pl3vq9uluTJwqXfh1hqy8e2iHoD+Y35gCIViTo6VOtK5dD8HYClucJucXASzwe2kPj4S4eYQtmkYHagXhAzp/F541xE8YFYqSPszDuz3soWzHy0p3E2jwZNQaIcGU9FNQwQxeDw0ZlK9dxXrj9IUHGUPTOyib8CqXmbZ7Ex54bn1rLx3qqAavu/gh6XjV0GmN1p+yyMK9HN5uYEvxgbAk43tsheREhyI+Q5WLIneKTGPmYiM/lxOp8fvqHy8YgXK0TlMiX0tliLI2JtfmWZP8eVV732sdYm+pcWzDzEmKLJZyeelyaZKkjPnnUO9keDwtgiLnmd5+t+Sr5y8brRnlvxcWEWfCqIALQYHvaXx6jTg4dAlye469uGwwOZVZCILLfGjaMg4LUCNMTtMSp1aC2y/3wR2t1v3w/iNBRQ+bNbtDqL2NAr7K4rUcyqbSpNrXZgAWXvjxBBtfYLK1uRYt3q2pfXJOAL0HtWcEwJLddOSJKV1SwvcvEuzg/4MPnA8MIUJOLqm3qI6wFyN99Ck6zYaV/zGSAzF/PGsaNa4vPLe5QnyuqVUnVQ6xELA6gbe53aGgeke+R/ycb2LJVyc7BhuzI90zA+c6wUDTb7NH//gdDSl2u/aW7lRJm8m1fLtPxcNuEM5JbkOCZKPM88HUsLRoC1pmKKlvWyeAXuxILbu0snpSxf8N+RgtLUSe5n2gdjOjoSTaN7mMZ7bF+cWk/MS8mFD4pcyl5UN7CbpFZH2a+Pm1VAnUTVfbw8qrmz1G9m5aKmRzY1SMhhPrlCn2t4uNUXNA3IFe6NOjSC1DEaAFZAfDlEkQCsbNhsZPj6NQPDSB3tLiTo0ZYoEbIeEIaKtU3Wk60rEszawTFuyHVd365LA/c/uarABN5M5rGq/dqTG3Ilye/5EKiYisisuzqNaZjmWv0z9TORc0CKbaTea214oNM9u2sXUZub/eqM3Pi/PjRSyQiOSwPWif2asTgu6hS6fb5UGosCWxdedMqdViIUUSSdIJx+qQ4KShfTT39VAWZbi+mB+iKICNwpt6cflY57Rcbs6d1kA26Iru73cuxYVlSvuJdcR5VfDYZRk8X0AXePROyw3Le6LaUdmTLzYsoNhhgQpd67xVNiHgk3pakmndeIAtTC4DCXy9oS6eU4CWxDdVmY53pKNbdAKmQsP37lrJZC6iDXMELGKcHjNuuZgcDyY8W/yv6ha3DX7OWm/35fpvhw55oitf4V+GULlcPWYyGGuVBdro19c8u0RDddDun40W7G5cSIzHLh/qZxb59R+EPY+wZ2XerkUim92hhXpKyW6WtAh6zQS97DrPyjCvKi3pCw96LeKynOpyjtsMQc2RmI/20zFOZcSa2AK++PoRcT6zeJyxlBZ7kk5mhqXGkLlM2hFKc+/T544xXP0Ua38Q6xdPTLTeG1PHnLMaOvksUQMrEFTB/lizCirmFQL8zYVU+OTeYQEFaITsBSMMYexS9HkajO2gGIf2micvntCZJsZQEwIH3/4JGJQGflBuH5rNXmnRRYXDQs3ZoEQoMtYDr1kFKUS/siiQSUxcTH9XYeBZiKDDFQoExREO9dddKQLO3BwMHvymCSTFyY+vxn3D27NDx6OlU092D5EDUwilttqVHpjJQDUceJYCLsK2swfXeNUVrBJT/w/sk+7si8rPtiMFis+oxvGdGQxirMBID700T39mULuNHzOyN+xBfcFACZcyngF1aSpv0JPkNUrAZTqfplv509cGXFUiEEm5dZb+OsP/blizqdK45/dSsIrufYTrCPY2lgJD6k6QljTfXVlHfYKSq+MsagyUcaMintyr95bD8kdTAeYNLNsMmo/Wdd8a2nStBP49ARIjqqpUHWY4q4mvO5Cq/CgCP+4/B+5zutGwX5pssgVLr1+fIM7WWLfiUQDk4c6ZdHZOWv5hG3g2dgQ5NXnpIY+BWwJpaouf25bXnjDzbHnQNofH/c6m+dEAS9Gs2h7pFRPKOBDnqswZ8KZjhId1ytHUTs533KwBoSiImoxKQUgZ7z6pA9QB3sZ8Cq0vwutJTTkfbX8AzCpm2cFXx/P22niUMHauU8IGc+78R6TsutoonoqFuoNA3l80t387YHMoL5KGAT1JO4zmx+vJ0LbLHlicHraSVYvJjnO9p++qnWgKw9OwFVVUagvZuf9qfiuum+hIicxP1q4zDnzkHsCNriLxBpxY9N+UOmqzdY1MunLMDgkMyi3uvnN3UBXJeZ8YLs5xr8QrOhimYoKuGBebZHAiBIkViv3DG8k2oNpp5OIgX6ulqaRN8V62QUPjn5tl1kPXhT9bcd8qIm8gi4or/FGbvQ6pgGSHmnayrugmf5E0upGxPRf/3xOtitGMaHLKJVm5zhglmVfI91o0yxhJZVS/5wQ8zfxK8Ylw0WmHXoGfRkoBRx9Hsnl/6sgTjAVwpmNuSeZtBwlX4qB8Bh8lxjqBDIuFGJ4I1wxN0XRlAAslzqMKwQfyA7OkuivCXfv+i+3XmhcBFM2n4jdT+NyUmBnQJPV3F2sZfKvJhUlXzSosFR4VevVVcOkFnnjdiRWc0TeSYxj41sJGYMbZTeLI3GvyZ8/gAAudQ1+4oFX+enX5V49MczGCYVBuoC4kHjp7ZVxj+clBwPr9k+v05SsezQK3enxLs1Nt/N7c7AImVUysjGou4iOohHo83Zs9/MI/OWB+OyXzOBD93NbApGHXrv8CVRHp2bwH+xB55cfNrdqFD35HSMx4iVmtzYAmSCIV8kXsHoq3DIb93riTWbubnjxbBW5zConVtbxLRStXHkIyAByaozME952Gc9aAdAbBpZSVCH88Uwb/4bPTVOVl+WoMYD7JIvK8VcMrJ8zHV4bbG0Dg7Kx17A4ej/ZcZ2Z5pVuVLUH1E/AccUTKm81SE+LQ6STTUDscUk0x2OWIbEORhg69tdoTGNkA1RfkGIRZHr5mCXOpLC55WWzCZoGPFUVtZRHwh0nq039CDdjEPo+JyaxSQAvDgR6Iqvxy0frrtEG1A385N81l05SSzN+IDm9bypF9m92EUqblnauZ5sjc37wRykOdl7w4o8WMgQsjii3EE/aJYDfHs1cH6DNBEujjcCc8qAefYFyIAURDcDnzun5UmkbBQsU4eu/W8I9nBE0qJKTdg2hwjq0+XV7a3TJ7R+alvJZCRia9lJ+grNB9dbrOmWEvUotMjvDhq4wV/kq4fvIBkzUGpDeYH74rne8uU3dgoNZdR9pUL6q9YDNRfOiF6Dyk+SYXQIghTjm9qR4tBHh0gnmF/9q3Qv22EzaLhSvDlDOxMrrCNRmLCl1jApzLrBCPn2mjn5zqK7OYK7VxOfQ5GfBfoPdyQwqFEgCVHkJ9oTnagRM3R0+rsuN5jQv9icCav/p1WqiEXSzCdLd/WEA6z6dDP7tPqPbeDYKAkVcz1lLGbFOC9b7cBd3MV0Ve8dZ89oR7OnxGS7uVpSry8banVZwpJg+nkH1jRBYa2BvBMY2xITH9ERXCjHzdZxs+ipdXP2DY7X+eWiBhtT2L0RRGTLPeazn5tpl4tu8iE2rWig731iuJDRbCHHy+g/Mb9+miAyVqfIpXT/iZeOxOxODO0hEpLM78I1+G2Z45yi3lS1K3m4WMQ559Lp4UML5vZUjYGJuxl+OPpUH5klpyBujkjprhei0TmUik10gjvNUp8mDkWlNKikmYspaVTqewbnOzJrmz8FLIpsT67EJLHIIfeDcWEfiP+DJrZ1jfxpoAb2abeMqLx+9RuZGzQoYtYVGgAWwEM9Kek2vPIeBNAKD6ao7nw6sgvfeLZPoXkbYO/tStHJdKzk+WFSFEU2NcALJAEP6S8pcnqqBBt57dwTrzQNCIdk2SocK4dLRbD/pu/VryKnm65ZYXiJCfHJk3mx9MRSl+nSK6OqEBSoGjz0/LADddwF/HqcfK3K3O+6YUGQcmj8pZL4PhZ6KrGkb8B38FmDvvLd3XQXbvS/FQmrXFTvJNkaN/FGo83KuS43BK1UfVnIqigGkCoP5fBda2MwAGTGNKX9K9t4Bx83pMFc5KSORmWKv+8VoVggWxoaBz3/9IBh6RwLd1tebwy89xvE5z6EEpXpDfrXWfRsMs6+ekUHH6idVosno55+xQ8Zqzelh0bxtJTgCcH3Z3/Cxlx9eNIS4JIFKOAVrDqbrXRszmY55a5+niJGHtkO3b6mnIDxLa1WXc7BAe33mt2KyM4Fbc3R6/WVTQN8QhlqAtave2WsQTqzWeSlKuGUVIJRqtObpv294rS0kDN1RKzdstZTXJebR2HlzsQ4P3NbMHUqFZMZw+/IKXnh4t+lY8qocp/B1oMszR03EFs3bPeND8QkItMvllObeCz3SZAjqZrobmLcrpFyQV7mwBjg3C3C8/bc5goQhv8j/IXMLGnt4mF7tybRDG5G0polxoUScQkPvmnga2/K+aapKeqSL0BTmo1Cm5g+booNOtdyKva2KoefRURaBk7113QKo3y+WTuFKtgETIK8HRluYS9DvlcciCDvnG8UaJRfZE2siZsiTHvRmN80xkUIInHeRZl5Re/+ATL6VhKFi8CZ/n/jbFV6T5pZ+Uoppvsi3qjacVFOJgWWfdlwVHKPW/TJO3na9hRM9bS2yo2rEsC6IBzRReVO6IesJU7PItzOamr+ROFfwGZmZ7ue8HNxAgLJKb7P3p8dMqk6Be5PJaT/5Rdc1deYVihWH9cjVKc9uz5EnfHqxLUkOO8iJUENBNVf5LyNy8zjLu/78k5WNTywiPfYeX3CPk7yc6CI3lum/CEZwfUaNpcI3KsPqfn2lmz3kd/acQjKA1ebkJaiuLD+epQ/Fc1llHXXMzofWzz/Kd29SNmOhcjMWw1jq1g3YfrXZ9rzXDYW4ZttfgfMi6oCUtBs0PkMVuxmq5lxEoCaSXPSqCJJ7MlKdRDidVt0AFlxk5cTdX++sBF2+E35mjwfm8ERVxH0FvuAQtsfA4V2G0TKTUxeyRGVjd/u6F1SvuAiU2/WaQjcNCU4Ep7VunXCYSbZj3U3wzu/LWM5MPlYuyQ3FOOCD/zt7K295hY2JhwF+ODDIZ676vGQFKveEQYkWj7lkK7rVmD7MhU0Y/tF8EcTTpo4/yqOufbd/zWIpMajnbDuWK2vn6OPPtz2rc9MIBNlPd8tt+yf+7SC4wqEPbozKMCwY5Bygx4JmoIEDsixWRDcdHd6S3/dZMHXOJAAv7+NIstl00crgSqHZKAEe4g3G4dzIV51EeZB01r7p8GNlfUnG/GjZgNGsqXZdYMBVtAtFNv3hJWPve4GvqZ2XxuiNkHTz5kxWgr0PjQdJlVywJ9Zf2ZvqeeTbolKtvK54re2Lq5BoyzfsRtvDfyao3kmyFzDQ88nM+qx83w74RDlkngtYiArI05Epre3GgBeSlMig0pE6RGQaFznKkGeb0SozLCyiOtxh7hgwZlbKbClzUUfC8ntMiHUOZE375RhTy9c4DA+oMLkUDkztSybZbdmP1xpaIbjUpPAHBq3cIq+CBFzbMlMMCCkUQ6d9LGV6GYCsYiEWZIy3nBnuxOYXeU4YTGDSin9e4/pCjPtQSHlg5LMEvIlF0ElthqrF129iK2RPBEWd3XWOl3SWV5uz5VUyZYp5kEFmz7QfP/B1W1BBzQ2iTGbSVT79lUHzcGXz3PJceSgz4uknETUwo0xffpr2KUvZF0i/r2sL3IFIClYx8CbIZE6Qt7MDJbOPB3xMScwaOcWG66IJfCnDkb0D2Mb+PHzX+oiCbxeTIogtyN+s2NJirNACk/OACSOTtV6vscwbzW4M168xqaI+RzR47S1nlV/rOoZnid87n/Ima2XYa3un3BuGAisNjb8eLMT9OnMtazQROFCuO1HiZXaOc0oUDbNC4eKLToOx8DzVhMgGA8XIAQ2x3b6I0uEyLssQjJX3QphcUMx4KsMgJ+72km4N2aqkBF2coKmUEt1eqIMGn+5txMT4kYVGd3ALO+y9Z4PP3d3l48JQK8s9ZZ/Qx/+NBKgBEJFlQ32psoJiihGO7FSYM5L81q72kaAYcilEFMG+ZK1BcMqELkflyCV7v8JEXLO4Rf/oZYNZHZVjJhfL6fnpP9Tio3Euue5uS7FMkfGOeRCTrBZ06Caev7tgufeTrX34Ur/Vvc+b8ksiIShNJtuF9WmYxOZ4xg8y6zTdy3KAB2y5kYkcRnXsptWwAFyKZ2I/QGySNeoQLkINUMloC+5L3WuMMx297Q1xUYLKqZ9XHavaobo6QQv4auMm+i84IhxRpPt9nUmcav9NcjCcP+TcMmxsQZ/F3mgeoA0fQgwvTsyXuuTaM3Sqtv2jaaajmaFQpK9W6uIbeqwvSDo34ZrY6elDUHwSCjHRRmlwmyy+eOra64Ssq0XSXYljMHtKY+FShcMkHsEUY/4Bw63dJ6KpwDaxmthlDdbdE+TvYF3v33cGSKqO+1H1pKYhJMvZD5ckQcHyNF8zrtiR5b0ko6NPGoRexUZTYP6VbUdn3zzxGBOi8Z0OqHjGqYxRXwN3mYi0GYEEZYq+Q3QvdKcEHILLLj8S+VFepSfErtmfZCdvxbfIifFSpEzKi+7VJsLMT+zEFeyp1OdwRC1VZrfTLIyR7xTPUcZFYPD9qI7D70uTb4hdpqPXsJIRNYbZtNwch1OI3trh3u2ScoQyM9POnInsUa+OovcwkUP1UfIzPb95n4BaF2ev57NHAej0+BVMF9/Cj9663HN2/JN3SQgslL914bKfiTTDFAz9PlQEL/dSv1H8xl3mtWxh1McFO9EJXlRDaKQDsyKO4vOJW90NFE6yw2tjbc2GeF95sbs0I9enAa6QwQVf/kJQhAD2BzUDKggOyjy1TEhED6sfk+418lQy3c/uj8aw8UEzZ6hIMCd8RohAkumMtIj9m73l2yPWoGHVTPaywkC7Yj9tBM1NxMgcrDwRtk4RO2WHT7Ql5kQCKdJj6kNuOTeyEBYBjLMhGz+O5/YGa84HEiTYEpZ6fFzy26GG2hWtTyteuYrhSyG56BjsT/wQeLRytpTY3D7sIMqZnJ9z1FDrfyjFlGl2TNw9BQysbaxOuwYYZs/7I6BANgkqCknWZC7/BBXvaeKwAmC959I+G39BUE9bExkNlbRoFRyEtNzv+NJ91FuisG3JCS6uYBeRnfv8AkAfKTeg9EYamqnsGfAV7d0f9DghHEQ5IsPGDIUhgoSj7obM4Bu5uhQ3/CYEDTHc92AsFvDK4XGrwUeGBWBHPlS+f4x+CxmmHz2sAGmSFNt65kwZC64mnaoWlu2310laYn8r62AqsR5dfjyK18MEdurdagldzfJtjFXlZs7St4QhdPiye6TPh2/ZAQLU/Fip5s7TDEM16KtRWrK9hmxnQ7bmfa/+7pa10Z8WDPK3NuJ+NN/RAbQ5vHx2uX0Lm7/w7cAEH/hvZA+mt7J7zGw7YtQYwnNN6dpgwkGjjrS3yQoeoYt1EnczmtmJfQZWzUlP3Hlg9Wzlr9IH23q3thGth+QNEANFettxKfskkGOlLk8AqoKJwDqOxAa6UzAx07plSSyNBJSGco9zjnC5gGbDoKvsMDuBR6bGRlGzJ+hFsGa/Izt78aI+WZ6dJlZKp4pGISuv9rV0sAS0MWEwCmfauO7oQZMiakHU35LBxiyJoOMddhUWgcZuC8r4Ksvn75TTcQXLJ7kWtYhGuGqPd9dZuFjBWQHNwosXY5snbHFQq72CvHXhIg+shQxycuLOuWYErwCLZeF24b7F78pO7xw4X6lIAR02hUOf5087Rl0nOaeb6CK4i/KA/EZv76ftOWZtjwxslNr0E/u8rWUmnf3amfg6UZmBAluuoj3Dd7UV+9IAJ6iYcDfSJlgmIImohjfIUMJ27z+opj50Ak9af2LCNrWrBJvMovA1OeNO+MF/MwZvnaCxTgG7Cw4QfSPF6AYCGFt21M8PySZFeV3t2Rqqs5JMzMYzGRgq4o+UaKRgBf9GHi/9X9HXA3wxkCsd/UhnHSh2zUVDiraio/6nP4y3XJqs8ABfALAtCYU7DHPMPRjgcM6Ad/HiSXDAbOdSMkvGZPAkHs8wuQTy6X2Ov/JFvcPuKfV3/r9Q28'
          ),
          r = () => v(n),
          i = () => new Set(r()),
          a = (e, t) => t.forEach((t) => e.add(t));
        (o = new Map(A(n))),
          (l = i()),
          (u = r()),
          (c = new Set(r().map((e) => u[e]))),
          (u = new Set(u)),
          (d = i()),
          i();
        let s = T(n),
          b = n(),
          C = () => {
            let e = new Set();
            return r().forEach((t) => a(e, s[t])), a(e, r()), e;
          };
        (p = E((e) => {
          let t = E(n).map((e) => e + 96);
          if (t.length) {
            let r = e >= b;
            return (
              (t[0] -= 32),
              (t = I(t)),
              r && (t = `Restricted[${t}]`),
              { N: t, P: C(), Q: C(), M: !n(), R: r }
            );
          }
        })),
          (h = i()),
          (y = new Map());
        let _ = r()
          .concat(k(h))
          .sort((e, t) => e - t);
        for (let { V: e, M: t } of (_.forEach((e, t) => {
          let r = n(),
            i = (_[t] = r ? _[t - r] : { V: [], M: new Map() });
          i.V.push(e), h.has(e) || y.set(e, i);
        }),
        new Set(y.values()))) {
          let n = [];
          for (let t of e) {
            let e = p.filter((e) => R(e, t)),
              r = n.find(({ G: t }) => e.some((e) => t.has(e)));
            r || ((r = { G: new Set(), V: [] }), n.push(r)), r.V.push(t), a(r.G, e);
          }
          let r = n.flatMap((e) => k(e.G));
          for (let { G: e, V: i } of n) {
            let n = new Set(r.filter((t) => !e.has(t)));
            for (let e of i) t.set(e, n);
          }
        }
        f = new Set();
        let P = new Set(),
          N = (e) => (f.has(e) ? P.add(e) : f.add(e));
        for (let e of p) {
          for (let t of e.P) N(t);
          for (let t of e.Q) N(t);
        }
        for (let e of f) y.has(e) || P.has(e) || y.set(e, 1);
        for (let r of (a(f, x(f).map(O)),
        (m = ((e = []),
        (t = v(n)),
        (function t({ S: n, B: r }, i, a) {
          if (!(4 & n) || a !== i[i.length - 1])
            for (let s of (2 & n && (a = i[i.length - 1]), 1 & n && e.push(i), r))
              for (let e of s.Q) t(s, [...i, e], a);
        })(
          (function e(r) {
            return {
              S: n(),
              B: E(() => {
                let r = v(n).map((e) => t[e]);
                if (r.length) return e(r);
              }),
              Q: r,
            };
          })([]),
          []
        ),
        e)
          .map((e) => D.from(e))
          .sort(S)),
        (g = new Map()),
        m)) {
          let e = [g];
          for (let t of r) {
            let n = e.map((e) => {
              let n = e.get(t);
              return n || ((n = new Map()), e.set(t, n)), n;
            });
            65039 === t ? e.push(...n) : (e = n);
          }
          for (let t of e) t.V = r;
        }
      }
      function U(e) {
        return (j(e) ? '' : `${L(F([e]))} `) + _(e);
      }
      function L(e) {
        return `"${e}"\u200E`;
      }
      function F(e, t = 1 / 0, n = _) {
        var r;
        let i = [];
        (r = e[0]),
          B(),
          u.has(r) && i.push(''),
          e.length > t && ((t >>= 1), (e = [...e.slice(0, t), 8230, ...e.slice(-t)]));
        let a = 0,
          s = e.length;
        for (let t = 0; t < s; t++) {
          let r = e[t];
          j(r) && (i.push(I(e.slice(a, t))), i.push(n(r)), (a = t + 1));
        }
        return i.push(I(e.slice(a, s))), i.join('');
      }
      function j(e) {
        return B(), d.has(e);
      }
      function q(e) {
        return Error(`disallowed character: ${U(e)}`);
      }
      function V(e, t) {
        let n = U(t),
          r = p.find((e) => e.P.has(t));
        return r && (n = `${r.N} ${n}`), Error(`illegal mixture: ${e.N} + ${n}`);
      }
      function $(e) {
        return Error(`illegal placement: ${e}`);
      }
      function z(e) {
        return e.filter((e) => 65039 != e);
      }
      function W(e) {
        var t;
        return (t = (function (e, t, n) {
          if (!e) return [];
          B();
          let r = 0;
          return e.split('.').map((e) => {
            let i = (function (e) {
                let t = [];
                for (let n = 0, r = e.length; n < r; ) {
                  let r = e.codePointAt(n);
                  (n += r < 65536 ? 1 : 2), t.push(r);
                }
                return t;
              })(e),
              a = { input: i, offset: r };
            r += i.length + 1;
            try {
              let e,
                r = (a.tokens = (function (e, t, n) {
                  let r = [],
                    i = [];
                  for (e = e.slice().reverse(); e.length; ) {
                    let a = (function (e, t) {
                      let n,
                        r = g,
                        i = e.length;
                      for (; i && (r = r.get(e[--i])); ) {
                        let { V: t } = r;
                        t && ((n = t), (e.length = i));
                      }
                      return n;
                    })(e);
                    if (a) i.length && (r.push(t(i)), (i = [])), r.push(n(a));
                    else {
                      let t = e.pop();
                      if (f.has(t)) i.push(t);
                      else {
                        let e = o.get(t);
                        if (e) i.push(...e);
                        else if (!l.has(t)) throw q(t);
                      }
                    }
                  }
                  return i.length && r.push(t(i)), r;
                })(i, t, n)),
                s = r.length;
              if (!s) throw Error('empty label');
              let d = (a.output = r.flat());
              if (
                (!(function (e) {
                  for (let t = e.lastIndexOf(95); t > 0; )
                    if (95 !== e[--t]) throw Error('underscore allowed only at start');
                })(d),
                !(a.emoji = s > 1 || r[0].is_emoji) && d.every((e) => e < 128))
              )
                !(function (e) {
                  if (e.length >= 4 && 45 == e[2] && 45 == e[3])
                    throw Error(`invalid label extension: "${I(e.slice(0, 4))}"`);
                })(d),
                  (e = 'ASCII');
              else {
                let t = r.flatMap((e) => (e.is_emoji ? [] : e));
                if (t.length) {
                  if (u.has(d[0])) throw $('leading combining mark');
                  for (let e = 1; e < s; e++) {
                    let t = r[e];
                    if (!t.is_emoji && u.has(t[0]))
                      throw $(`emoji + combining mark: "${I(r[e - 1])} + ${F([t[0]])}"`);
                  }
                  !(function (e) {
                    let t = e[0],
                      n = b.get(t);
                    if (n) throw $(`leading ${n}`);
                    let r = e.length,
                      i = -1;
                    for (let a = 1; a < r; a++) {
                      t = e[a];
                      let r = b.get(t);
                      if (r) {
                        if (i == a) throw $(`${n} + ${r}`);
                        (i = a + 1), (n = r);
                      }
                    }
                    if (i == r) throw $(`trailing ${n}`);
                  })(d);
                  let n = k(new Set(t)),
                    [i] = (function (e) {
                      let t = p;
                      for (let n of e) {
                        let e = t.filter((e) => R(e, n));
                        if (!e.length) {
                          if (p.some((e) => R(e, n))) throw V(t[0], n);
                          throw q(n);
                        }
                        if (((t = e), 1 == e.length)) break;
                      }
                      return t;
                    })(n);
                  (function (e, t) {
                    for (let n of t) if (!R(e, n)) throw V(e, n);
                    if (e.M) {
                      let e = x(t).map(O);
                      for (let t = 1, n = e.length; t < n; t++)
                        if (c.has(e[t])) {
                          let r = t + 1;
                          for (let i; r < n && c.has((i = e[r])); r++)
                            for (let n = t; n < r; n++)
                              if (e[n] == i) throw Error(`duplicate non-spacing marks: ${U(i)}`);
                          if (r - t > 4)
                            throw Error(
                              `excessive non-spacing marks: ${L(F(e.slice(t - 1, r)))} (${r - t}/4)`
                            );
                          t = r;
                        }
                    }
                  })(i, t),
                    (function (e, t) {
                      let n;
                      let r = [];
                      for (let e of t) {
                        let t = y.get(e);
                        if (1 === t) return;
                        if (t) {
                          let r = t.M.get(e);
                          if (!(n = n ? n.filter((e) => r.has(e)) : k(r)).length) return;
                        } else r.push(e);
                      }
                      if (n) {
                        for (let t of n)
                          if (r.every((e) => R(t, e)))
                            throw Error(`whole-script confusable: ${e.N}/${t.N}`);
                      }
                    })(i, n),
                    (e = i.N);
                } else e = 'Emoji';
              }
              a.type = e;
            } catch (e) {
              a.error = e;
            }
            return a;
          });
        })(e, M, z))
          .map(({ input: e, error: n, output: r }) => {
            if (n) {
              let r = n.message;
              throw Error(1 == t.length ? r : `Invalid label ${L(F(e, 63))}: ${r}`);
            }
            return I(r);
          })
          .join('.');
      }
    },
    68132: function (e, t, n) {
      'use strict';
      n.d(t, {
        T: function () {
          return o;
        },
      });
      var r = n(2220),
        i = n(84196),
        a = n(47824),
        s = n(8282);
      function o(e) {
        let t = e.replace(/^\.|\.$/gm, '');
        if (0 === t.length) return new Uint8Array(1);
        let n = new Uint8Array((0, r.qX)(t).byteLength + 2),
          o = 0,
          l = t.split('.');
        for (let e = 0; e < l.length; e++) {
          let t = (0, r.qX)(l[e]);
          if (t.byteLength > 255) {
            var u;
            t = (0, r.qX)(
              ((u = (function (e) {
                let t = new Uint8Array(32).fill(0);
                return e ? (0, s.i)(e) || (0, a.w)((0, r.qX)(e)) : (0, i.ci)(t);
              })(l[e])),
              `[${u.slice(2)}]`)
            );
          }
          (n[o] = t.length), n.set(t, o + 1), (o += t.length + 1);
        }
        return n.byteLength !== o + 1 ? n.slice(0, o + 1) : n;
      }
    },
    91045: function (e, t, n) {
      'use strict';
      n.d(t, {
        P: function () {
          return s;
        },
      });
      var r = n(54484),
        i = n(65264),
        a = n(90988);
      function s(e, { docsPath: t, ...n }) {
        let s = (() => {
          let t = (0, a.k)(e, n);
          return t instanceof i.cj ? e : t;
        })();
        return new r.cg(s, { docsPath: t, ...n });
      }
    },
    54494: function (e, t, n) {
      'use strict';
      n.d(t, {
        S: function () {
          return l;
        },
      });
      var r = n(57585),
        i = n(88154),
        a = n(54484),
        s = n(40002),
        o = n(18292);
      function l(e, { abi: t, address: n, args: l, docsPath: u, functionName: c, sender: d }) {
        let p =
            e instanceof a.VQ ? e : e instanceof i.G ? e.walk((e) => 'data' in e) || e.walk() : {},
          { code: h, data: y, details: f, message: m, shortMessage: g } = p,
          b =
            e instanceof r.wb
              ? new a.Dk({ functionName: c })
              : [3, o.XS.code].includes(h) && (y || f || m || g)
                ? new a.Lu({
                    abi: t,
                    data: 'object' == typeof y ? y.data : y,
                    functionName: c,
                    message: p instanceof s.bs ? f : (g ?? m),
                  })
                : e;
        return new a.uq(b, {
          abi: t,
          args: l,
          contractAddress: n,
          docsPath: u,
          functionName: c,
          sender: d,
        });
      }
    },
    90988: function (e, t, n) {
      'use strict';
      n.d(t, {
        k: function () {
          return a;
        },
      });
      var r = n(88154),
        i = n(65264);
      function a(e, t) {
        let n = (e.details || '').toLowerCase(),
          a = e instanceof r.G ? e.walk((e) => e?.code === i.M_.code) : e;
        return a instanceof r.G
          ? new i.M_({ cause: e, message: a.details })
          : i.M_.nodeMessage.test(n)
            ? new i.M_({ cause: e, message: e.details })
            : i.Hh.nodeMessage.test(n)
              ? new i.Hh({ cause: e, maxFeePerGas: t?.maxFeePerGas })
              : i.G$.nodeMessage.test(n)
                ? new i.G$({ cause: e, maxFeePerGas: t?.maxFeePerGas })
                : i.ZI.nodeMessage.test(n)
                  ? new i.ZI({ cause: e, nonce: t?.nonce })
                  : i.vU.nodeMessage.test(n)
                    ? new i.vU({ cause: e, nonce: t?.nonce })
                    : i.se.nodeMessage.test(n)
                      ? new i.se({ cause: e, nonce: t?.nonce })
                      : i.C_.nodeMessage.test(n)
                        ? new i.C_({ cause: e })
                        : i.WF.nodeMessage.test(n)
                          ? new i.WF({ cause: e, gas: t?.gas })
                          : i.dR.nodeMessage.test(n)
                            ? new i.dR({ cause: e, gas: t?.gas })
                            : i.pZ.nodeMessage.test(n)
                              ? new i.pZ({ cause: e })
                              : i.cs.nodeMessage.test(n)
                                ? new i.cs({
                                    cause: e,
                                    maxFeePerGas: t?.maxFeePerGas,
                                    maxPriorityFeePerGas: t?.maxPriorityFeePerGas,
                                  })
                                : new i.cj({ cause: e });
      }
    },
    25655: function (e, t, n) {
      'use strict';
      n.d(t, {
        $: function () {
          return s;
        },
      });
      var r = n(65264),
        i = n(29408),
        a = n(90988);
      function s(e, { docsPath: t, ...n }) {
        let s = (() => {
          let t = (0, a.k)(e, n);
          return t instanceof r.cj ? e : t;
        })();
        return new i.mk(s, { docsPath: t, ...n });
      }
    },
    39751: function (e, t, n) {
      'use strict';
      function r(e, { method: t }) {
        let n = {};
        return (
          'fallback' === e.transport.type &&
            e.transport.onResponse?.(({ method: e, response: r, status: i, transport: a }) => {
              'success' === i && t === e && (n[r] = a.request);
            }),
          (t) => n[t] || e.request
        );
      }
      n.d(t, {
        g: function () {
          return r;
        },
      });
    },
    44542: function (e, t, n) {
      'use strict';
      function r(e, { format: t }) {
        if (!t) return {};
        let n = {};
        return (
          !(function t(r) {
            for (let i of Object.keys(r))
              i in e && (n[i] = e[i]),
                r[i] && 'object' == typeof r[i] && !Array.isArray(r[i]) && t(r[i]);
          })(t(e || {})),
          n
        );
      }
      n.d(t, {
        K: function () {
          return r;
        },
      });
    },
    40740: function (e, t, n) {
      'use strict';
      n.d(t, {
        tG: function () {
          return a;
        },
      });
      var r = n(84196);
      let i = { legacy: '0x0', eip2930: '0x1', eip1559: '0x2', eip4844: '0x3', eip7702: '0x4' };
      function a(e) {
        let t = {};
        return (
          void 0 !== e.authorizationList &&
            (t.authorizationList = e.authorizationList.map((e) => ({
              address: e.address,
              r: e.r ? (0, r.eC)(BigInt(e.r)) : e.r,
              s: e.s ? (0, r.eC)(BigInt(e.s)) : e.s,
              chainId: (0, r.eC)(e.chainId),
              nonce: (0, r.eC)(e.nonce),
              ...(void 0 !== e.yParity ? { yParity: (0, r.eC)(e.yParity) } : {}),
              ...(void 0 !== e.v && void 0 === e.yParity ? { v: (0, r.eC)(e.v) } : {}),
            }))),
          void 0 !== e.accessList && (t.accessList = e.accessList),
          void 0 !== e.blobVersionedHashes && (t.blobVersionedHashes = e.blobVersionedHashes),
          void 0 !== e.blobs &&
            ('string' != typeof e.blobs[0]
              ? (t.blobs = e.blobs.map((e) => (0, r.ci)(e)))
              : (t.blobs = e.blobs)),
          void 0 !== e.data && (t.data = e.data),
          void 0 !== e.from && (t.from = e.from),
          void 0 !== e.gas && (t.gas = (0, r.eC)(e.gas)),
          void 0 !== e.gasPrice && (t.gasPrice = (0, r.eC)(e.gasPrice)),
          void 0 !== e.maxFeePerBlobGas && (t.maxFeePerBlobGas = (0, r.eC)(e.maxFeePerBlobGas)),
          void 0 !== e.maxFeePerGas && (t.maxFeePerGas = (0, r.eC)(e.maxFeePerGas)),
          void 0 !== e.maxPriorityFeePerGas &&
            (t.maxPriorityFeePerGas = (0, r.eC)(e.maxPriorityFeePerGas)),
          void 0 !== e.nonce && (t.nonce = (0, r.eC)(e.nonce)),
          void 0 !== e.to && (t.to = e.to),
          void 0 !== e.type && (t.type = i[e.type]),
          void 0 !== e.value && (t.value = (0, r.eC)(e.value)),
          t
        );
      }
    },
    61896: function (e, t, n) {
      'use strict';
      function r(e, t, n) {
        let r = e[t.name];
        if ('function' == typeof r) return r;
        let i = e[n];
        return 'function' == typeof i ? i : (n) => t(e, n);
      }
      n.d(t, {
        s: function () {
          return r;
        },
      });
    },
    35481: function (e, t, n) {
      'use strict';
      n.d(t, {
        n: function () {
          return r;
        },
      });
      let r = n(89882).r;
    },
    95962: function (e, t, n) {
      'use strict';
      n.d(t, {
        C: function () {
          return a;
        },
      });
      var r = n(32982),
        i = n(89882);
      let a = (e) => (0, r.tP)((0, i.r)(e), 0, 4);
    },
    89882: function (e, t, n) {
      'use strict';
      n.d(t, {
        r: function () {
          return u;
        },
      });
      var r = n(2220),
        i = n(47824);
      let a = (e) => (0, i.w)((0, r.O0)(e));
      var s = n(56606),
        o = n(88154);
      let l = (e) =>
        (function (e) {
          let t = !0,
            n = '',
            r = 0,
            i = '',
            a = !1;
          for (let s = 0; s < e.length; s++) {
            let o = e[s];
            if ((['(', ')', ','].includes(o) && (t = !0), '(' === o && r++, ')' === o && r--, t)) {
              if (0 === r) {
                if (' ' === o && ['event', 'function', ''].includes(i)) i = '';
                else if (((i += o), ')' === o)) {
                  a = !0;
                  break;
                }
                continue;
              }
              if (' ' === o) {
                ',' !== e[s - 1] && ',' !== n && ',(' !== n && ((n = ''), (t = !1));
                continue;
              }
              (i += o), (n += o);
            }
          }
          if (!a) throw new o.G('Unable to normalize signature.');
          return i;
        })('string' == typeof e ? e : (0, s.t)(e));
      function u(e) {
        return a(l(e));
      }
    },
    54658: function (e, t, n) {
      'use strict';
      n.d(t, {
        N7: function () {
          return s;
        },
      });
      let r = new Map(),
        i = new Map(),
        a = 0;
      function s(e, t, n) {
        let s = ++a,
          o = () => r.get(e) || [],
          l = () => {
            let t = o();
            r.set(
              e,
              t.filter((e) => e.id !== s)
            );
          },
          u = () => {
            let t = o();
            if (!t.some((e) => e.id === s)) return;
            let n = i.get(e);
            1 === t.length && n && n(), l();
          },
          c = o();
        if ((r.set(e, [...c, { id: s, fns: t }]), c && c.length > 0)) return u;
        let d = {};
        for (let e in t)
          d[e] = (...t) => {
            let n = o();
            if (0 !== n.length) for (let r of n) r.fns[e]?.(...t);
          };
        let p = n(d);
        return 'function' == typeof p && i.set(e, p), u;
      }
    },
    45437: function (e, t, n) {
      'use strict';
      n.d(t, {
        $: function () {
          return i;
        },
      });
      var r = n(85533);
      function i(e, { emitOnBegin: t, initialWaitTime: n, interval: i }) {
        let a = !0,
          s = () => (a = !1);
        return (
          (async () => {
            let o;
            t && (o = await e({ unpoll: s }));
            let l = (await n?.(o)) ?? i;
            await (0, r.D)(l);
            let u = async () => {
              a && (await e({ unpoll: s }), await (0, r.D)(i), u());
            };
            u();
          })(),
          s
        );
      }
    },
    42002: function (e, t, n) {
      'use strict';
      n.d(t, {
        S: function () {
          return a;
        },
      });
      var r = n(4846);
      let i = new Map();
      function a({ fn: e, id: t, shouldSplitBatch: n, wait: a = 0, sort: s }) {
        let o = async () => {
            let t = c();
            l();
            let n = t.map(({ args: e }) => e);
            0 !== n.length &&
              e(n)
                .then((e) => {
                  s && Array.isArray(e) && e.sort(s);
                  for (let n = 0; n < t.length; n++) {
                    let { resolve: r } = t[n];
                    r?.([e[n], e]);
                  }
                })
                .catch((e) => {
                  for (let n = 0; n < t.length; n++) {
                    let { reject: r } = t[n];
                    r?.(e);
                  }
                });
          },
          l = () => i.delete(t),
          u = () => c().map(({ args: e }) => e),
          c = () => i.get(t) || [],
          d = (e) => i.set(t, [...c(), e]);
        return {
          flush: l,
          async schedule(e) {
            let { promise: t, resolve: i, reject: s } = (0, r.n)();
            return (
              (n?.([...u(), e]) && o(), c().length > 0)
                ? d({ args: e, resolve: i, reject: s })
                : (d({ args: e, resolve: i, reject: s }), setTimeout(o, a)),
              t
            );
          },
        };
      }
    },
    4846: function (e, t, n) {
      'use strict';
      function r() {
        let e = () => void 0,
          t = () => void 0;
        return {
          promise: new Promise((n, r) => {
            (e = n), (t = r);
          }),
          resolve: e,
          reject: t,
        };
      }
      n.d(t, {
        n: function () {
          return r;
        },
      });
    },
    74118: function (e, t, n) {
      'use strict';
      n.d(t, {
        J: function () {
          return i;
        },
      });
      var r = n(85533);
      function i(e, { delay: t = 100, retryCount: n = 2, shouldRetry: i = () => !0 } = {}) {
        return new Promise((a, s) => {
          let o = async ({ count: l = 0 } = {}) => {
            let u = async ({ error: e }) => {
              let n = 'function' == typeof t ? t({ count: l, error: e }) : t;
              n && (await (0, r.D)(n)), o({ count: l + 1 });
            };
            try {
              let t = await e();
              a(t);
            } catch (e) {
              if (l < n && (await i({ count: l, error: e }))) return u({ error: e });
              s(e);
            }
          };
          o();
        });
      }
    },
    30390: function (e, t, n) {
      'use strict';
      function r(e, { errorInstance: t = Error('timed out'), timeout: n, signal: r }) {
        return new Promise((i, a) => {
          (async () => {
            let s;
            try {
              let o = new AbortController();
              n > 0 &&
                (s = setTimeout(() => {
                  r ? o.abort() : a(t);
                }, n)),
                i(await e({ signal: o?.signal || null }));
            } catch (e) {
              e?.name === 'AbortError' && a(t), a(e);
            } finally {
              clearTimeout(s);
            }
          })();
        });
      }
      n.d(t, {
        F: function () {
          return r;
        },
      });
    },
    69349: function (e, t, n) {
      'use strict';
      n.d(t, {
        Ow: function () {
          return r;
        },
        eL: function () {
          return i;
        },
        lh: function () {
          return a;
        },
      });
      let r = /^(.*)\[([0-9]*)\]$/,
        i = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,
        a =
          /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
    },
    45793: function (e, t, n) {
      'use strict';
      n.d(t, {
        R: function () {
          return d;
        },
      });
      var r = n(28346),
        i = n(47824),
        a = n(75963),
        s = n(88155),
        o = n(79e3),
        l = n(84196);
      async function u({ hash: e, signature: t }) {
        let r = (0, a.v)(e) ? e : (0, l.NC)(e),
          { secp256k1: i } = await n.e(4516).then(n.bind(n, 14516)),
          u = (() => {
            if ('object' == typeof t && 'r' in t && 's' in t) {
              let { r: e, s: n, v: r, yParity: a } = t,
                s = c(Number(a ?? r));
              return new i.Signature((0, o.y_)(e), (0, o.y_)(n)).addRecoveryBit(s);
            }
            let e = (0, a.v)(t) ? t : (0, l.NC)(t);
            if (65 !== (0, s.d)(e)) throw Error('invalid signature length');
            let n = c((0, o.ly)(`0x${e.slice(130)}`));
            return i.Signature.fromCompact(e.substring(2, 130)).addRecoveryBit(n);
          })()
            .recoverPublicKey(r.substring(2))
            .toHex(!1);
        return `0x${u}`;
      }
      function c(e) {
        if (0 === e || 1 === e) return e;
        if (27 === e) return 0;
        if (28 === e) return 1;
        throw Error('Invalid yParityOrV value');
      }
      async function d({ hash: e, signature: t }) {
        return (function (e) {
          let t = (0, i.w)(`0x${e.substring(4)}`).substring(26);
          return (0, r.x)(`0x${t}`);
        })(await u({ hash: e, signature: t }));
      }
    },
    87335: function (e, t, n) {
      'use strict';
      n.d(t, {
        mF: function () {
          return u;
        },
      });
      var r = n(37039),
        i = n(88828),
        a = n(99523),
        s = n(77102),
        o = n(84196);
      function l(e) {
        if (e && 0 !== e.length)
          return e.reduce((e, { slot: t, value: n }) => {
            if (66 !== t.length) throw new i.W_({ size: t.length, targetSize: 66, type: 'hex' });
            if (66 !== n.length) throw new i.W_({ size: n.length, targetSize: 66, type: 'hex' });
            return (e[t] = n), e;
          }, {});
      }
      function u(e) {
        if (!e) return;
        let t = {};
        for (let { address: n, ...i } of e) {
          if (!(0, s.U)(n, { strict: !1 })) throw new r.b({ address: n });
          if (t[n]) throw new a.Nc({ address: n });
          t[n] = (function (e) {
            let { balance: t, nonce: n, state: r, stateDiff: i, code: s } = e,
              u = {};
            if (
              (void 0 !== s && (u.code = s),
              void 0 !== t && (u.balance = (0, o.eC)(t)),
              void 0 !== n && (u.nonce = (0, o.eC)(n)),
              void 0 !== r && (u.state = l(r)),
              void 0 !== i)
            ) {
              if (u.state) throw new a.Z8();
              u.stateDiff = l(i);
            }
            return u;
          })(i);
        }
        return t;
      }
    },
    97352: function (e, t, n) {
      'use strict';
      n.d(t, {
        P: function () {
          return r;
        },
      });
      let r = (e, t, n) =>
        JSON.stringify(
          e,
          (e, n) => {
            let r = 'bigint' == typeof n ? n.toString() : n;
            return 'function' == typeof t ? t(e, r) : r;
          },
          n
        );
    },
    26677: function (e, t, n) {
      'use strict';
      n.d(t, {
        F: function () {
          return u;
        },
      });
      var r = n(65099),
        i = n(68612),
        a = n(37039),
        s = n(65264),
        o = n(29408),
        l = n(77102);
      function u(e) {
        let { account: t, gasPrice: n, maxFeePerGas: u, maxPriorityFeePerGas: c, to: d } = e,
          p = t ? (0, r.T)(t) : void 0;
        if (p && !(0, l.U)(p.address)) throw new a.b({ address: p.address });
        if (d && !(0, l.U)(d)) throw new a.b({ address: d });
        if (void 0 !== n && (void 0 !== u || void 0 !== c)) throw new o.xY();
        if (u && u > i.zL) throw new s.Hh({ maxFeePerGas: u });
        if (c && u && c > u) throw new s.cs({ maxFeePerGas: u, maxPriorityFeePerGas: c });
      }
    },
    31267: function (e, t, n) {
      'use strict';
      let r;
      n.d(t, {
        h: function () {
          return a;
        },
      });
      let i = 256;
      function a(e = 11) {
        if (!r || i + e > 512) {
          (r = ''), (i = 0);
          for (let e = 0; e < 256; e++)
            r += ((256 + 256 * Math.random()) | 0).toString(16).substring(1);
        }
        return r.substring(i, i++ + e);
      }
    },
    85533: function (e, t, n) {
      'use strict';
      async function r(e) {
        return new Promise((t) => setTimeout(t, e));
      }
      n.d(t, {
        D: function () {
          return r;
        },
      });
    },
    92529: function (e, t, n) {
      'use strict';
      n.d(t, {
        WagmiContext: function () {
          return a;
        },
        WagmiProvider: function () {
          return s;
        },
      });
      var r = n(58258),
        i = n(59002);
      let a = (0, r.createContext)(void 0);
      function s(e) {
        let { children: t, config: n } = e;
        return (0, r.createElement)(
          i.Hydrate,
          e,
          (0, r.createElement)(a.Provider, { value: n }, t)
        );
      }
    },
    66911: function (e, t, n) {
      'use strict';
      n.d(t, {
        useAccount: function () {
          return c;
        },
      });
      var r = n(5333),
        i = n(80827),
        a = n(81082),
        s = n(18548),
        o = n(58258),
        l = n(96261);
      let u = (e) => 'object' == typeof e && !Array.isArray(e);
      function c() {
        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
          t = (0, a.useConfig)(e);
        return (function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t,
            r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : s.v,
            i = (0, o.useRef)([]),
            a = (0, l.useSyncExternalStoreWithSelector)(
              e,
              t,
              n,
              (e) => e,
              (e, t) => {
                if (u(e) && u(t) && i.current.length) {
                  for (let n of i.current) if (!r(e[n], t[n])) return !1;
                  return !0;
                }
                return r(e, t);
              }
            );
          return (0, o.useMemo)(() => {
            if (u(a)) {
              let e = { ...a },
                t = {};
              for (let [n, r] of Object.entries(e))
                t = {
                  ...t,
                  [n]: {
                    configurable: !1,
                    enumerable: !0,
                    get: () => (i.current.includes(n) || i.current.push(n), r),
                  },
                };
              return Object.defineProperties(e, t), e;
            }
            return a;
          }, [a]);
        })(
          (e) => (0, r.u)(t, { onChange: e }),
          () => (0, i.D)(t)
        );
      }
    },
    94282: function (e, t, n) {
      'use strict';
      n.d(t, {
        useBlock: function () {
          return p;
        },
      });
      var r = n(25513),
        i = n(51541),
        a = n(28180);
      async function s(e, t = {}) {
        let { chainId: n, ...r } = t,
          s = e.getClient({ chainId: n }),
          o = (0, a.s)(s, i.Q, 'getBlock');
        return { ...(await o(r)), chainId: s.chain.id };
      }
      var o = n(24755),
        l = n(87967),
        u = n(65386),
        c = n(81082),
        d = n(16282);
      function p() {
        var e, t;
        let n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
          { query: i = {}, watch: a } = n,
          p = (0, c.useConfig)(n),
          h = (0, r.NL)(),
          y = (0, u.useChainId)({ config: p }),
          f = null !== (e = n.chainId) && void 0 !== e ? e : y,
          m = (function (e, t = {}) {
            return {
              async queryFn({ queryKey: t }) {
                let { scopeKey: n, ...r } = t[1];
                return (await s(e, r)) ?? null;
              },
              queryKey: (function (e = {}) {
                return ['block', (0, o.OP)(e)];
              })(t),
            };
          })(p, { ...n, chainId: f }),
          g = !!(null === (t = i.enabled) || void 0 === t || t);
        return (
          (0, d.useWatchBlocks)({
            ...{ config: n.config, chainId: n.chainId, ...('object' == typeof a ? a : {}) },
            enabled: !!(g && ('object' == typeof a ? a.enabled : a)),
            onBlock(e) {
              h.setQueryData(m.queryKey, e);
            },
          }),
          (0, l.aM)({ ...i, ...m, enabled: g })
        );
      }
    },
    99e3: function (e, t, n) {
      'use strict';
      n.d(t, {
        useBytecode: function () {
          return c;
        },
      });
      var r = n(91326),
        i = n(28180);
      async function a(e, t) {
        let { chainId: n, ...a } = t,
          s = e.getClient({ chainId: n });
        return (0, i.s)(s, r.C, 'getBytecode')(a);
      }
      var s = n(24755),
        o = n(87967),
        l = n(65386),
        u = n(81082);
      function c() {
        var e, t;
        let n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
          { address: r, query: i = {} } = n,
          c = (0, u.useConfig)(n),
          d = (0, l.useChainId)({ config: c }),
          p = (function (e, t = {}) {
            return {
              async queryFn({ queryKey: t }) {
                let { address: n, scopeKey: r, ...i } = t[1];
                if (!n) throw Error('address is required');
                return (await a(e, { ...i, address: n })) ?? null;
              },
              queryKey: ['getBytecode', (0, s.OP)(t)],
            };
          })(c, { ...n, chainId: null !== (e = n.chainId) && void 0 !== e ? e : d }),
          h = !!(r && (null === (t = i.enabled) || void 0 === t || t));
        return (0, o.aM)({ ...i, ...p, enabled: h });
      }
    },
    65386: function (e, t, n) {
      'use strict';
      function r(e) {
        return e.state.chainId;
      }
      n.d(t, {
        useChainId: function () {
          return s;
        },
      });
      var i = n(58258),
        a = n(81082);
      function s() {
        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
          t = (0, a.useConfig)(e);
        return (0, i.useSyncExternalStore)(
          (e) =>
            (function (e, t) {
              let { onChange: n } = t;
              return e.subscribe((e) => e.chainId, n);
            })(t, { onChange: e }),
          () => r(t),
          () => r(t)
        );
      }
    },
    7887: function (e, t, n) {
      'use strict';
      n.d(t, {
        useChains: function () {
          return l;
        },
      });
      var r = n(18548);
      let i = [];
      function a(e) {
        let t = e.chains;
        return (0, r.v)(i, t) ? i : ((i = t), t);
      }
      var s = n(58258),
        o = n(81082);
      function l() {
        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
          t = (0, o.useConfig)(e);
        return (0, s.useSyncExternalStore)(
          (e) =>
            (function (e, t) {
              let { onChange: n } = t;
              return e._internal.chains.subscribe((e, t) => {
                n(e, t);
              });
            })(t, { onChange: e }),
          () => a(t),
          () => a(t)
        );
      }
    },
    81082: function (e, t, n) {
      'use strict';
      n.d(t, {
        useConfig: function () {
          return u;
        },
      });
      var r = n(58258),
        i = n(92529),
        a = n(75271);
      let s = () => 'wagmi@2.15.1';
      class o extends a.G {
        constructor() {
          super(...arguments),
            Object.defineProperty(this, 'name', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: 'WagmiError',
            });
        }
        get docsBaseUrl() {
          return 'https://wagmi.sh/react';
        }
        get version() {
          return s();
        }
      }
      class l extends o {
        constructor() {
          super('`useConfig` must be used within `WagmiProvider`.', {
            docsPath: '/api/WagmiProvider',
          }),
            Object.defineProperty(this, 'name', {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: 'WagmiProviderNotFoundError',
            });
        }
      }
      function u() {
        var e;
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
          n = null !== (e = t.config) && void 0 !== e ? e : (0, r.useContext)(i.WagmiContext);
        if (!n) throw new l();
        return n;
      }
    },
    70911: function (e, t, n) {
      'use strict';
      n.d(t, {
        useEnsAvatar: function () {
          return l;
        },
      });
      var r = n(65110),
        i = n(24755),
        a = n(87967),
        s = n(65386),
        o = n(81082);
      function l() {
        var e, t;
        let n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
          { name: l, query: u = {} } = n,
          c = (0, o.useConfig)(n),
          d = (0, s.useChainId)({ config: c }),
          p = (function (e, t = {}) {
            return {
              async queryFn({ queryKey: t }) {
                let { name: n, scopeKey: i, ...a } = t[1];
                if (!n) throw Error('name is required');
                return (0, r.r)(e, { ...a, name: n });
              },
              queryKey: (function (e = {}) {
                return ['ensAvatar', (0, i.OP)(e)];
              })(t),
            };
          })(c, { ...n, chainId: null !== (e = n.chainId) && void 0 !== e ? e : d }),
          h = !!(l && (null === (t = u.enabled) || void 0 === t || t));
        return (0, a.aM)({ ...u, ...p, enabled: h });
      }
    },
    24505: function (e, t, n) {
      'use strict';
      n.d(t, {
        useEnsName: function () {
          return l;
        },
      });
      var r = n(96238),
        i = n(24755),
        a = n(87967),
        s = n(65386),
        o = n(81082);
      function l() {
        var e, t;
        let n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
          { address: l, query: u = {} } = n,
          c = (0, o.useConfig)(n),
          d = (0, s.useChainId)({ config: c }),
          p = (function (e, t = {}) {
            return {
              async queryFn({ queryKey: t }) {
                let { address: n, scopeKey: i, ...a } = t[1];
                if (!n) throw Error('address is required');
                return (0, r.w)(e, { ...a, address: n });
              },
              queryKey: (function (e = {}) {
                return ['ensName', (0, i.OP)(e)];
              })(t),
            };
          })(c, { ...n, chainId: null !== (e = n.chainId) && void 0 !== e ? e : d }),
          h = !!(l && (null === (t = u.enabled) || void 0 === t || t));
        return (0, a.aM)({ ...u, ...p, enabled: h });
      }
    },
    50964: function (e, t, n) {
      'use strict';
      n.d(t, {
        useReadContract: function () {
          return l;
        },
      });
      var r = n(83765),
        i = n(24755),
        a = n(87967),
        s = n(65386),
        o = n(81082);
      function l() {
        var e, t, n;
        let l = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
          { abi: u, address: c, functionName: d, query: p = {} } = l,
          h = l.code,
          y = (0, o.useConfig)(l),
          f = (0, s.useChainId)({ config: y }),
          m = (function (e, t = {}) {
            return {
              async queryFn({ queryKey: n }) {
                let i = t.abi;
                if (!i) throw Error('abi is required');
                let { functionName: a, scopeKey: s, ...o } = n[1],
                  l = (() => {
                    let e = n[1];
                    if (e.address) return { address: e.address };
                    if (e.code) return { code: e.code };
                    throw Error('address or code is required');
                  })();
                if (!a) throw Error('functionName is required');
                return (0, r.L)(e, { abi: i, functionName: a, args: o.args, ...l, ...o });
              },
              queryKey: (function (e = {}) {
                let { abi: t, ...n } = e;
                return ['readContract', (0, i.OP)(n)];
              })(t),
            };
          })(y, { ...l, chainId: null !== (e = l.chainId) && void 0 !== e ? e : f }),
          g = !!((c || h) && u && d && (null === (t = p.enabled) || void 0 === t || t));
        return (0, a.aM)({
          ...p,
          ...m,
          enabled: g,
          structuralSharing: null !== (n = p.structuralSharing) && void 0 !== n ? n : i.if,
        });
      }
    },
    22490: function (e, t, n) {
      'use strict';
      n.d(t, {
        useSwitchChain: function () {
          return o;
        },
      });
      var r = n(97844),
        i = n(63230),
        a = n(7887),
        s = n(81082);
      function o() {
        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
          { mutation: t } = e,
          n = (0, s.useConfig)(e),
          {
            mutate: o,
            mutateAsync: l,
            ...u
          } = (0, r.D)({ ...t, mutationFn: (e) => (0, i.c)(n, e), mutationKey: ['switchChain'] });
        return {
          ...u,
          chains: (0, a.useChains)({ config: n }),
          switchChain: o,
          switchChainAsync: l,
        };
      }
    },
    16282: function (e, t, n) {
      'use strict';
      n.d(t, {
        useWatchBlocks: function () {
          return l;
        },
      });
      var r = n(81767),
        i = n(28180),
        a = n(58258),
        s = n(65386),
        o = n(81082);
      function l() {
        var e;
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
          { enabled: n = !0, onBlock: l, config: u, ...c } = t,
          d = (0, o.useConfig)(t),
          p = (0, s.useChainId)({ config: d }),
          h = null !== (e = t.chainId) && void 0 !== e ? e : p;
        (0, a.useEffect)(() => {
          if (n && l)
            return (function (e, t) {
              let n, a;
              let { syncConnectedChain: s = e._internal.syncConnectedChain, ...o } = t,
                l = (t) => {
                  n && n();
                  let a = e.getClient({ chainId: t });
                  return (n = (0, i.s)(a, r.p, 'watchBlocks')(o));
                },
                u = l(t.chainId);
              return (
                s &&
                  !t.chainId &&
                  (a = e.subscribe(
                    ({ chainId: e }) => e,
                    async (e) => l(e)
                  )),
                () => {
                  u?.(), a?.();
                }
              );
            })(d, { ...c, chainId: h, onBlock: l });
        }, [
          h,
          d,
          n,
          l,
          c.blockTag,
          c.emitMissed,
          c.emitOnBegin,
          c.includeTransactions,
          c.onError,
          c.poll,
          c.pollingInterval,
          c.syncConnectedChain,
        ]);
      }
    },
    59002: function (e, t, n) {
      'use strict';
      n.d(t, {
        Hydrate: function () {
          return a;
        },
      });
      var r = n(28297),
        i = n(58258);
      function a(e) {
        let { children: t, config: n, initialState: a, reconnectOnMount: s = !0 } = e,
          { onMount: o } = (function (e, t) {
            let { initialState: n, reconnectOnMount: i } = t;
            return (
              n &&
                !e._internal.store.persist.hasHydrated() &&
                e.setState({
                  ...n,
                  chainId: e.chains.some((e) => e.id === n.chainId) ? n.chainId : e.chains[0].id,
                  connections: i ? n.connections : new Map(),
                  status: i ? 'reconnecting' : 'disconnected',
                }),
              {
                async onMount() {
                  e._internal.ssr &&
                    (await e._internal.store.persist.rehydrate(),
                    e._internal.mipd &&
                      e._internal.connectors.setState((t) => {
                        let n = new Set();
                        for (let e of t ?? [])
                          if (e.rdns)
                            for (let t of Array.isArray(e.rdns) ? e.rdns : [e.rdns]) n.add(t);
                        let r = [];
                        for (let t of e._internal.mipd?.getProviders() ?? []) {
                          if (n.has(t.info.rdns)) continue;
                          let i = e._internal.connectors.providerDetailToConnector(t),
                            a = e._internal.connectors.setup(i);
                          r.push(a);
                        }
                        return [...t, ...r];
                      })),
                    i
                      ? (0, r.G)(e)
                      : e.storage && e.setState((e) => ({ ...e, connections: new Map() }));
                },
              }
            );
          })(n, { initialState: a, reconnectOnMount: s });
        n._internal.ssr || o();
        let l = (0, i.useRef)(!0);
        return (
          (0, i.useEffect)(() => {
            if (l.current && n._internal.ssr)
              return (
                o(),
                () => {
                  l.current = !1;
                }
              );
          }, []),
          t
        );
      }
    },
    87967: function (e, t, n) {
      'use strict';
      n.d(t, {
        NS: function () {
          return c;
        },
        aM: function () {
          return u;
        },
      });
      var r = n(10943),
        i = n(41426),
        a = n(306),
        s = class extends i.z {
          constructor(e, t) {
            super(e, t);
          }
          bindMethods() {
            super.bindMethods(),
              (this.fetchNextPage = this.fetchNextPage.bind(this)),
              (this.fetchPreviousPage = this.fetchPreviousPage.bind(this));
          }
          setOptions(e) {
            super.setOptions({ ...e, behavior: (0, a.Gm)() });
          }
          getOptimisticResult(e) {
            return (e.behavior = (0, a.Gm)()), super.getOptimisticResult(e);
          }
          fetchNextPage(e) {
            return this.fetch({ ...e, meta: { fetchMore: { direction: 'forward' } } });
          }
          fetchPreviousPage(e) {
            return this.fetch({ ...e, meta: { fetchMore: { direction: 'backward' } } });
          }
          createResult(e, t) {
            let { state: n } = e,
              r = super.createResult(e, t),
              { isFetching: i, isRefetching: s, isError: o, isRefetchError: l } = r,
              u = n.fetchMeta?.fetchMore?.direction,
              c = o && 'forward' === u,
              d = i && 'forward' === u,
              p = o && 'backward' === u,
              h = i && 'backward' === u;
            return {
              ...r,
              fetchNextPage: this.fetchNextPage,
              fetchPreviousPage: this.fetchPreviousPage,
              hasNextPage: (0, a.Qy)(t, n.data),
              hasPreviousPage: (0, a.ZF)(t, n.data),
              isFetchNextPageError: c,
              isFetchingNextPage: d,
              isFetchPreviousPageError: p,
              isFetchingPreviousPage: h,
              isRefetchError: l && !c && !p,
              isRefetching: s && !d && !h,
            };
          }
        },
        o = n(1769),
        l = n(24755);
      function u(e) {
        let t = (0, r.a)({ ...e, queryKeyHashFn: l.kq });
        return (t.queryKey = e.queryKey), t;
      }
      function c(e) {
        var t;
        let n = ((t = { ...e, queryKeyHashFn: l.kq }), (0, o.r)(t, s, void 0));
        return (n.queryKey = e.queryKey), n;
      }
    },
    17085: function (e, t, n) {
      'use strict';
      function r(e, t) {
        (null == t || t > e.length) && (t = e.length);
        for (var n = 0, r = Array(t); n < t; n++) r[n] = e[n];
        return r;
      }
      function i(e, t) {
        for (var n = 0; n < t.length; n++) {
          var r = t[n];
          (r.enumerable = r.enumerable || !1),
            (r.configurable = !0),
            'value' in r && (r.writable = !0),
            Object.defineProperty(e, r.key, r);
        }
      }
      function a(e, t, n) {
        return (
          t && i(e.prototype, t),
          n && i(e, n),
          Object.defineProperty(e, 'prototype', { writable: !1 }),
          e
        );
      }
      n.d(t, {
        y: function () {
          return A;
        },
      });
      var s = function () {
          return 'function' == typeof Symbol;
        },
        o = function (e) {
          return s() && !!Symbol[e];
        },
        l = function (e) {
          return o(e) ? Symbol[e] : '@@' + e;
        };
      s() && !o('observable') && (Symbol.observable = Symbol('observable'));
      var u = l('iterator'),
        c = l('observable'),
        d = l('species');
      function p(e, t) {
        var n = e[t];
        if (null != n) {
          if ('function' != typeof n) throw TypeError(n + ' is not a function');
          return n;
        }
      }
      function h(e) {
        var t = e.constructor;
        return void 0 !== t && null === (t = t[d]) && (t = void 0), void 0 !== t ? t : A;
      }
      function y(e) {
        y.log
          ? y.log(e)
          : setTimeout(function () {
              throw e;
            });
      }
      function f(e) {
        Promise.resolve().then(function () {
          try {
            e();
          } catch (e) {
            y(e);
          }
        });
      }
      function m(e) {
        var t = e._cleanup;
        if (void 0 !== t) {
          if (((e._cleanup = void 0), !t)) return;
          try {
            if ('function' == typeof t) t();
            else {
              var n = p(t, 'unsubscribe');
              n && n.call(t);
            }
          } catch (e) {
            y(e);
          }
        }
      }
      function g(e) {
        (e._observer = void 0), (e._queue = void 0), (e._state = 'closed');
      }
      function b(e, t, n) {
        e._state = 'running';
        var r = e._observer;
        try {
          var i = p(r, t);
          switch (t) {
            case 'next':
              i && i.call(r, n);
              break;
            case 'error':
              if ((g(e), i)) i.call(r, n);
              else throw n;
              break;
            case 'complete':
              g(e), i && i.call(r);
          }
        } catch (e) {
          y(e);
        }
        'closed' === e._state ? m(e) : 'running' === e._state && (e._state = 'ready');
      }
      function w(e, t, n) {
        if ('closed' !== e._state) {
          if ('buffering' === e._state) {
            e._queue.push({ type: t, value: n });
            return;
          }
          if ('ready' !== e._state) {
            (e._state = 'buffering'),
              (e._queue = [{ type: t, value: n }]),
              f(function () {
                return (function (e) {
                  var t = e._queue;
                  if (t) {
                    (e._queue = void 0), (e._state = 'ready');
                    for (
                      var n = 0;
                      n < t.length && (b(e, t[n].type, t[n].value), 'closed' !== e._state);
                      ++n
                    );
                  }
                })(e);
              });
            return;
          }
          b(e, t, n);
        }
      }
      var v = (function () {
          function e(e, t) {
            (this._cleanup = void 0),
              (this._observer = e),
              (this._queue = void 0),
              (this._state = 'initializing');
            var n = new T(this);
            try {
              this._cleanup = t.call(void 0, n);
            } catch (e) {
              n.error(e);
            }
            'initializing' === this._state && (this._state = 'ready');
          }
          return (
            (e.prototype.unsubscribe = function () {
              'closed' !== this._state && (g(this), m(this));
            }),
            a(e, [
              {
                key: 'closed',
                get: function () {
                  return 'closed' === this._state;
                },
              },
            ]),
            e
          );
        })(),
        T = (function () {
          function e(e) {
            this._subscription = e;
          }
          var t = e.prototype;
          return (
            (t.next = function (e) {
              w(this._subscription, 'next', e);
            }),
            (t.error = function (e) {
              w(this._subscription, 'error', e);
            }),
            (t.complete = function () {
              w(this._subscription, 'complete');
            }),
            a(e, [
              {
                key: 'closed',
                get: function () {
                  return 'closed' === this._subscription._state;
                },
              },
            ]),
            e
          );
        })(),
        A = (function () {
          function e(t) {
            if (!(this instanceof e)) throw TypeError('Observable cannot be called as a function');
            if ('function' != typeof t)
              throw TypeError('Observable initializer must be a function');
            this._subscriber = t;
          }
          var t = e.prototype;
          return (
            (t.subscribe = function (e) {
              return (
                ('object' != typeof e || null === e) &&
                  (e = { next: e, error: arguments[1], complete: arguments[2] }),
                new v(e, this._subscriber)
              );
            }),
            (t.forEach = function (e) {
              var t = this;
              return new Promise(function (n, r) {
                if ('function' != typeof e) {
                  r(TypeError(e + ' is not a function'));
                  return;
                }
                function i() {
                  a.unsubscribe(), n();
                }
                var a = t.subscribe({
                  next: function (t) {
                    try {
                      e(t, i);
                    } catch (e) {
                      r(e), a.unsubscribe();
                    }
                  },
                  error: r,
                  complete: n,
                });
              });
            }),
            (t.map = function (e) {
              var t = this;
              if ('function' != typeof e) throw TypeError(e + ' is not a function');
              return new (h(this))(function (n) {
                return t.subscribe({
                  next: function (t) {
                    try {
                      t = e(t);
                    } catch (e) {
                      return n.error(e);
                    }
                    n.next(t);
                  },
                  error: function (e) {
                    n.error(e);
                  },
                  complete: function () {
                    n.complete();
                  },
                });
              });
            }),
            (t.filter = function (e) {
              var t = this;
              if ('function' != typeof e) throw TypeError(e + ' is not a function');
              return new (h(this))(function (n) {
                return t.subscribe({
                  next: function (t) {
                    try {
                      if (!e(t)) return;
                    } catch (e) {
                      return n.error(e);
                    }
                    n.next(t);
                  },
                  error: function (e) {
                    n.error(e);
                  },
                  complete: function () {
                    n.complete();
                  },
                });
              });
            }),
            (t.reduce = function (e) {
              var t = this;
              if ('function' != typeof e) throw TypeError(e + ' is not a function');
              var n = h(this),
                r = arguments.length > 1,
                i = !1,
                a = arguments[1],
                s = a;
              return new n(function (n) {
                return t.subscribe({
                  next: function (t) {
                    var a = !i;
                    if (((i = !0), !a || r))
                      try {
                        s = e(s, t);
                      } catch (e) {
                        return n.error(e);
                      }
                    else s = t;
                  },
                  error: function (e) {
                    n.error(e);
                  },
                  complete: function () {
                    if (!i && !r) return n.error(TypeError('Cannot reduce an empty sequence'));
                    n.next(s), n.complete();
                  },
                });
              });
            }),
            (t.concat = function () {
              for (var e = this, t = arguments.length, n = Array(t), r = 0; r < t; r++)
                n[r] = arguments[r];
              var i = h(this);
              return new i(function (t) {
                var r,
                  a = 0;
                return (
                  (function e(s) {
                    r = s.subscribe({
                      next: function (e) {
                        t.next(e);
                      },
                      error: function (e) {
                        t.error(e);
                      },
                      complete: function () {
                        a === n.length ? ((r = void 0), t.complete()) : e(i.from(n[a++]));
                      },
                    });
                  })(e),
                  function () {
                    r && (r.unsubscribe(), (r = void 0));
                  }
                );
              });
            }),
            (t.flatMap = function (e) {
              var t = this;
              if ('function' != typeof e) throw TypeError(e + ' is not a function');
              var n = h(this);
              return new n(function (r) {
                var i = [],
                  a = t.subscribe({
                    next: function (t) {
                      if (e)
                        try {
                          t = e(t);
                        } catch (e) {
                          return r.error(e);
                        }
                      var a = n.from(t).subscribe({
                        next: function (e) {
                          r.next(e);
                        },
                        error: function (e) {
                          r.error(e);
                        },
                        complete: function () {
                          var e = i.indexOf(a);
                          e >= 0 && i.splice(e, 1), s();
                        },
                      });
                      i.push(a);
                    },
                    error: function (e) {
                      r.error(e);
                    },
                    complete: function () {
                      s();
                    },
                  });
                function s() {
                  a.closed && 0 === i.length && r.complete();
                }
                return function () {
                  i.forEach(function (e) {
                    return e.unsubscribe();
                  }),
                    a.unsubscribe();
                };
              });
            }),
            (t[c] = function () {
              return this;
            }),
            (e.from = function (t) {
              var n = 'function' == typeof this ? this : e;
              if (null == t) throw TypeError(t + ' is not an object');
              var i = p(t, c);
              if (i) {
                var a = i.call(t);
                if (Object(a) !== a) throw TypeError(a + ' is not an object');
                return a instanceof A && a.constructor === n
                  ? a
                  : new n(function (e) {
                      return a.subscribe(e);
                    });
              }
              if (o('iterator') && (i = p(t, u)))
                return new n(function (e) {
                  f(function () {
                    if (!e.closed) {
                      for (
                        var n,
                          a = (function (e, t) {
                            var n =
                              ('undefined' != typeof Symbol && e[Symbol.iterator]) ||
                              e['@@iterator'];
                            if (n) return (n = n.call(e)).next.bind(n);
                            if (
                              Array.isArray(e) ||
                              (n = (function (e, t) {
                                if (e) {
                                  if ('string' == typeof e) return r(e, void 0);
                                  var n = Object.prototype.toString.call(e).slice(8, -1);
                                  if (
                                    ('Object' === n && e.constructor && (n = e.constructor.name),
                                    'Map' === n || 'Set' === n)
                                  )
                                    return Array.from(e);
                                  if (
                                    'Arguments' === n ||
                                    /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                                  )
                                    return r(e, void 0);
                                }
                              })(e))
                            ) {
                              n && (e = n);
                              var i = 0;
                              return function () {
                                return i >= e.length ? { done: !0 } : { done: !1, value: e[i++] };
                              };
                            }
                            throw TypeError(
                              'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
                            );
                          })(i.call(t));
                        !(n = a()).done;

                      ) {
                        var s = n.value;
                        if ((e.next(s), e.closed)) return;
                      }
                      e.complete();
                    }
                  });
                });
              if (Array.isArray(t))
                return new n(function (e) {
                  f(function () {
                    if (!e.closed) {
                      for (var n = 0; n < t.length; ++n) if ((e.next(t[n]), e.closed)) return;
                      e.complete();
                    }
                  });
                });
              throw TypeError(t + ' is not observable');
            }),
            (e.of = function () {
              for (var t = arguments.length, n = Array(t), r = 0; r < t; r++) n[r] = arguments[r];
              return new ('function' == typeof this ? this : e)(function (e) {
                f(function () {
                  if (!e.closed) {
                    for (var t = 0; t < n.length; ++t) if ((e.next(n[t]), e.closed)) return;
                    e.complete();
                  }
                });
              });
            }),
            a(e, null, [
              {
                key: d,
                get: function () {
                  return this;
                },
              },
            ]),
            e
          );
        })();
      s() &&
        Object.defineProperty(A, Symbol('extensions'), {
          value: { symbol: c, hostReportError: y },
          configurable: !0,
        });
    },
  },
]);
