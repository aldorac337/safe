import {
  k as t,
  B as e,
  Q as s,
  L as i,
  a as h,
  D as a,
  l as r,
  c,
  i as l,
} from './rsa-plugins-common.min.js';
let n = (function (t) {
  return (
    (t[(t.ASAP = 1)] = 'ASAP'),
    (t[(t.RESCHEDULE = 2)] = 'RESCHEDULE'),
    (t[(t.ABANDON = 3)] = 'ABANDON'),
    t
  );
})({});
const o = {
  setTimeout: (t, e) => globalThis.setTimeout(t, e),
  clearTimeout: (t) => globalThis.clearTimeout(t),
  Date: globalThis.Date,
  clockLateFactor: 2,
};
class u {
  constructor() {
    (this.tasks = {}), (this.nextId = 1), (this.clock = o);
  }
  now() {
    return +new this.clock.Date();
  }
  run(t, e, s) {
    const i = (this.nextId + 1).toString();
    return (this.tasks[i] = this.clock.setTimeout(this.handle(i, t, e, s || n.ASAP), e)), i;
  }
  handle(t, e, s, i) {
    const h = this.now();
    return () => {
      delete this.tasks[t];
      const a = h + s * (this.clock.clockLateFactor || 2),
        r = this.now();
      if (!(i >= n.RESCHEDULE && a < r)) return e();
      i === n.RESCHEDULE && this.run(e, s, i);
    };
  }
  cancel(t) {
    this.tasks[t] && (this.clock.clearTimeout(this.tasks[t]), delete this.tasks[t]);
  }
  cancelAll() {
    Object.values(this.tasks).forEach(this.clock.clearTimeout), (this.tasks = {});
  }
}
const m = 1 / 0,
  d = 1 / 0,
  g = 524288,
  E = 'Batch',
  b = 'Single',
  y = (t, e) => t.time - e.time,
  S = 'RetryQueue';
class f {
  constructor(t, h, a, r, c = i, l, n) {
    var o;
    (this.storeManager = r),
      (this.logger = l),
      (this.name = t),
      (this.id = e()),
      (this.processQueueCb = a),
      (this.batchSizeCalcCb = n),
      (this.maxItems = h.maxItems || d),
      (this.maxAttempts = h.maxAttempts || m),
      (this.batch = { enabled: !1 }),
      this.configureBatchMode(h),
      (this.backoff = {
        minRetryDelay: h.minRetryDelay || 1e3,
        maxRetryDelay: h.maxRetryDelay || 3e4,
        factor: h.backoffFactor || 2,
        jitter: h.backoffJitter || 0,
      });
    let g = Math.max(null !== (o = h.timerScaleFactor) && void 0 !== o ? o : 1, 1);
    (g = Math.min(g, 10)),
      (this.timeouts = {
        ackTimer: Math.round(1e3 * g),
        reclaimTimer: Math.round(3e3 * g),
        reclaimTimeout: Math.round(1e4 * g),
        reclaimWait: Math.round(500 * g),
      }),
      (this.schedule = new u()),
      (this.processId = '0'),
      (this.store = this.storeManager.setStore({
        id: this.id,
        name: this.name,
        validKeys: s,
        type: c,
      })),
      this.setDefaultQueueEntries(),
      (this.ack = this.ack.bind(this)),
      (this.checkReclaim = this.checkReclaim.bind(this)),
      (this.processHead = this.processHead.bind(this)),
      (this.flushBatch = this.flushBatch.bind(this)),
      (this.isPageAccessible = !0),
      this.flushBatchOnPageLeave(),
      (this.scheduleTimeoutActive = !1);
  }
  setDefaultQueueEntries() {
    this.setStorageEntry(s.IN_PROGRESS, {}),
      this.setStorageEntry(s.QUEUE, []),
      this.setStorageEntry(s.BATCH_QUEUE, []);
  }
  configureBatchMode(t) {
    if (((this.batchingInProgress = !1), !h(t.batch))) return;
    const e = t.batch;
    var s, i, a;
    ((this.batch.enabled = !0 === e.enabled), this.batch.enabled) &&
      ((this.batch.maxSize = Math.min(null !== (s = e.maxSize) && void 0 !== s ? s : g, g)),
      (this.batch.maxItems = null !== (i = e.maxItems) && void 0 !== i ? i : 100),
      (this.batch.flushInterval = null !== (a = e.flushInterval) && void 0 !== a ? a : 6e4));
  }
  flushBatchOnPageLeave() {
    this.batch.enabled && a(this.flushBatch);
  }
  getStorageEntry(t) {
    return this.store.get(t);
  }
  setStorageEntry(t, e) {
    r(e) ? this.store.remove(t) : this.store.set(t, e);
  }
  stop() {
    this.schedule.cancelAll(), (this.scheduleTimeoutActive = !1);
  }
  start() {
    this.scheduleTimeoutActive && this.stop(),
      (this.scheduleTimeoutActive = !0),
      this.scheduleFlushBatch(),
      this.ack(),
      this.checkReclaim(),
      this.processHead();
  }
  scheduleFlushBatch() {
    var t;
    this.batch.enabled &&
      null !== (t = this.batch) &&
      void 0 !== t &&
      t.flushInterval &&
      (this.flushBatchTaskId && this.schedule.cancel(this.flushBatchTaskId),
      (this.flushBatchTaskId = this.schedule.run(
        this.flushBatch,
        this.batch.flushInterval,
        n.ASAP
      )));
  }
  flushBatch(t = !0) {
    if (!this.batchingInProgress) {
      var e;
      (this.isPageAccessible = t), (this.batchingInProgress = !0);
      let i = null !== (e = this.getStorageEntry(s.BATCH_QUEUE)) && void 0 !== e ? e : [];
      if (i.length > 0) {
        i = i.slice(-i.length);
        const t = this.genQueueItem(
          i.map((t) => t.item),
          E
        );
        this.setStorageEntry(s.BATCH_QUEUE, []), this.pushToMainQueue(t);
      }
      (this.batchingInProgress = !1), this.scheduleFlushBatch();
    }
  }
  shouldRetry(t, e) {
    return e <= this.maxAttempts;
  }
  getDelay(t) {
    let e = this.backoff.minRetryDelay * this.backoff.factor ** t;
    if (this.backoff.jitter) {
      const t = Math.random(),
        s = Math.floor(t * this.backoff.jitter * e);
      Math.floor(10 * t) < 5 ? (e -= s) : (e += s);
    }
    return Number(Math.min(e, this.backoff.maxRetryDelay).toPrecision(1));
  }
  enqueue(t) {
    let e;
    (e = this.batch.enabled && t.type === b ? this.handleNewItemForBatch(t) : t),
      e && this.pushToMainQueue(e);
  }
  handleNewItemForBatch(t) {
    var e;
    let i,
      h = null !== (e = this.getStorageEntry(s.BATCH_QUEUE)) && void 0 !== e ? e : [];
    if (this.batchingInProgress) h.push(t);
    else {
      (this.batchingInProgress = !0), (h = h.slice(-h.length)), h.push(t);
      const e = this.getBatchDispatchInfo(h);
      if (e.criteriaMet || e.criteriaExceeded) {
        let s;
        e.criteriaExceeded
          ? ((s = h.slice(0, h.length - 1).map((t) => t.item)), (h = [t]))
          : ((s = h.map((t) => t.item)), (h = [])),
          s.length > 0 && (i = this.genQueueItem(s, E)),
          this.scheduleFlushBatch();
      }
      this.batchingInProgress = !1;
    }
    return this.setStorageEntry(s.BATCH_QUEUE, h), i;
  }
  pushToMainQueue(t) {
    var e;
    let i = null !== (e = this.getStorageEntry(s.QUEUE)) && void 0 !== e ? e : [];
    (i = i.slice(-(this.maxItems - 1))),
      i.push(t),
      (i = i.sort(y)),
      this.setStorageEntry(s.QUEUE, i),
      this.scheduleTimeoutActive && this.processHead();
  }
  addItem(t) {
    this.enqueue(this.genQueueItem(t));
  }
  genQueueItem(t, s = b) {
    return { item: t, attemptNumber: 0, time: this.schedule.now(), id: e(), type: s };
  }
  requeue(t, s) {
    const { attemptNumber: i, item: h, type: a, id: r } = t,
      c = i + 1;
    this.shouldRetry(h, c) &&
      this.enqueue({
        item: h,
        attemptNumber: c,
        time: this.schedule.now() + this.getDelay(c),
        id: null != r ? r : e(),
        type: a,
      });
  }
  getBatchDispatchInfo(t) {
    var e, s;
    let i = !1,
      h = !1;
    const a = null === (e = this.batch) || void 0 === e ? void 0 : e.maxItems;
    if ((c(a) && ((i = t.length === a), (h = t.length > a)), i || h))
      return { criteriaMet: i, criteriaExceeded: h };
    let r = !1,
      l = !1;
    const n = null === (s = this.batch) || void 0 === s ? void 0 : s.maxSize;
    if (c(n) && c(this.batchSizeCalcCb)) {
      const e = this.batchSizeCalcCb(t.map((t) => t.item));
      (r = e === n), (l = e > n);
    }
    return { criteriaMet: r, criteriaExceeded: l };
  }
  processHead() {
    var i, h, a;
    this.schedule.cancel(this.processId);
    let r = null !== (i = this.getStorageEntry(s.QUEUE)) && void 0 !== i ? i : [];
    const c = this.schedule.now(),
      l = [],
      o = (t, e) => (i, h) => {
        var a;
        const r = null !== (a = this.getStorageEntry(s.IN_PROGRESS)) && void 0 !== a ? a : {};
        delete r[e], this.setStorageEntry(s.IN_PROGRESS, r), i && this.requeue(t, i);
      },
      u = (t, e) => {
        l.push({ item: t.item, done: o(t, e), attemptNumber: t.attemptNumber });
      };
    let m = null !== (h = this.getStorageEntry(s.IN_PROGRESS)) && void 0 !== h ? h : {};
    this.isPageAccessible || (m = {});
    let d = Object.keys(m).length;
    for (; r.length > 0 && r[0].time <= c && d++ < this.maxItems; ) {
      const t = r.shift();
      if (t) {
        const s = e();
        this.isPageAccessible &&
          (m[s] = {
            item: t.item,
            attemptNumber: t.attemptNumber,
            time: this.schedule.now(),
            type: t.type,
          }),
          u(t, s);
      }
    }
    if (
      (this.setStorageEntry(s.QUEUE, r),
      this.setStorageEntry(s.IN_PROGRESS, m),
      l.forEach((e) => {
        try {
          const t = this.shouldRetry(e.item, e.attemptNumber + 1);
          this.processQueueCb(e.item, e.done, e.attemptNumber, this.maxAttempts, t);
        } catch (e) {
          var s;
          null === (s = this.logger) ||
            void 0 === s ||
            s.error(`${S}${t}Process function threw an error.`, e);
        }
      }),
      (r = null !== (a = this.getStorageEntry(s.QUEUE)) && void 0 !== a ? a : []),
      this.schedule.cancel(this.processId),
      r.length > 0)
    ) {
      const t = r[0].time - c;
      this.processId = this.schedule.run(this.processHead, t, n.ASAP);
    }
  }
  ack() {
    this.setStorageEntry(s.ACK, this.schedule.now()),
      null != this.reclaimStartVal &&
        ((this.reclaimStartVal = null), this.setStorageEntry(s.RECLAIM_START, null)),
      null != this.reclaimEndVal &&
        ((this.reclaimEndVal = null), this.setStorageEntry(s.RECLAIM_END, null)),
      this.schedule.run(this.ack, this.timeouts.ackTimer, n.ASAP);
  }
  reclaim(t) {
    var h, a, r, c;
    const l = this.storeManager.setStore({ id: t, name: this.name, validKeys: s, type: i }),
      n = { queue: null !== (h = this.getStorageEntry(s.QUEUE)) && void 0 !== h ? h : [] },
      o = {
        inProgress: null !== (a = l.get(s.IN_PROGRESS)) && void 0 !== a ? a : {},
        batchQueue: null !== (r = l.get(s.BATCH_QUEUE)) && void 0 !== r ? r : [],
        queue: null !== (c = l.get(s.QUEUE)) && void 0 !== c ? c : [],
      },
      u = [],
      m = (t, s) => {
        const i = (t) => {
          var i;
          const h = null !== (i = t.id) && void 0 !== i ? i : e();
          if (u.includes(h));
          else {
            var a;
            const e = Array.isArray(t.item) ? E : b;
            n.queue.push({
              item: t.item,
              attemptNumber: t.attemptNumber + s,
              time: this.schedule.now(),
              id: h,
              type: null !== (a = t.type) && void 0 !== a ? a : e,
            }),
              u.push(h);
          }
        };
        Array.isArray(t) ? t.forEach(i) : t && Object.values(t).forEach(i);
      };
    m(o.queue, 0),
      this.batch.enabled
        ? o.batchQueue.forEach((t) => {
            var s, i;
            const h = null !== (s = t.id) && void 0 !== s ? s : e();
            (t.type = null !== (i = t.type) && void 0 !== i ? i : b),
              (t.time = this.schedule.now()),
              u.includes(h) || (this.enqueue(t), u.push(h));
          })
        : m(o.batchQueue, 0),
      m(o.inProgress, 1),
      (n.queue = n.queue.sort(y)),
      this.setStorageEntry(s.QUEUE, n.queue),
      this.clearQueueEntries(l, 1),
      this.processHead();
  }
  clearQueueEntries(t, e) {
    this.removeStorageEntry(t, 0, e);
  }
  removeStorageEntry(e, i, h, a = 1) {
    const r = Object.keys(s),
      c = s[r[i]];
    globalThis.setTimeout(() => {
      try {
        e.remove(c), i + 1 < r.length && this.removeStorageEntry(e, i + 1, h);
      } catch (l) {
        const n = 'NS_ERROR_STORAGE_BUSY';
        var s;
        if ((l.name === n || l.code === n || 2153971713 === l.code) && a < 2)
          this.removeStorageEntry(e, i, h + 40, a + 1);
        else
          null === (s = this.logger) ||
            void 0 === s ||
            s.error(
              ((e, s, i) => `${e}${t}Failed to remove local storage entry "${s}" (attempt: ${i}.`)(
                S,
                c,
                a
              ),
              l
            );
        2 === a && i + 1 < r.length && this.removeStorageEntry(e, i + 1, h);
      }
    }, h);
  }
  checkReclaim() {
    const t = (t) => () => {
        t.get(s.RECLAIM_END) === this.id &&
          t.get(s.RECLAIM_START) === this.id &&
          this.reclaim(t.id);
      },
      e = (e) => () => {
        e.get(s.RECLAIM_START) === this.id &&
          (e.set(s.RECLAIM_END, this.id),
          this.schedule.run(t(e), this.timeouts.reclaimWait, n.ABANDON));
      },
      h = (t) => {
        t.set(s.RECLAIM_START, this.id),
          t.set(s.ACK, this.schedule.now()),
          this.schedule.run(e(t), this.timeouts.reclaimWait, n.ABANDON);
      };
    ((t) => {
      const e = [],
        h = this.store.getOriginalEngine();
      let a = [];
      if (l(h.keys)) a = h.keys();
      else
        for (let t = 0; t < h.length; t++) {
          const e = h.key(t);
          e && a.push(e);
        }
      return (
        a.forEach((h) => {
          const a = h ? h.split('.') : [];
          a.length >= 3 &&
            a[0] === t &&
            a[1] !== this.id &&
            a[2] === s.ACK &&
            e.push(this.storeManager.setStore({ id: a[1], name: t, validKeys: s, type: i }));
        }),
        e
      );
    })(this.name).forEach((t) => {
      this.schedule.now() - t.get(s.ACK) < this.timeouts.reclaimTimeout || h(t);
    }),
      this.schedule.run(this.checkReclaim, this.timeouts.reclaimTimer, n.RESCHEDULE);
  }
  clear() {
    this.schedule.cancelAll(), this.setDefaultQueueEntries();
  }
}
export { f as R };
//# sourceMappingURL=rsa-plugins-RetryQueue.min.js.map
