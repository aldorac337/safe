const __vite__mapDeps = (
  i,
  m = __vite__mapDeps,
  d = m.f ||
    (m.f = [
      'assets/phantomRpc-C42kJpAs.js',
      'assets/phantomUiDeps-B7Pij32n.js',
      'assets/lodash-aFjP5OGs.js',
      'assets/chainSolana-DAiUp22G.js',
      'assets/metaplex-81r3lICz.js',
      'assets/react-6iN9_IA6.js',
      'assets/phantomUi-BUKCyHFp.js',
      'assets/phantomUi-D1Ruostj.css',
      'assets/metaplexMplTokenMetadata-D0B0pvkO.js',
      'assets/chainEthereum-DlaaxYpw.js',
      'assets/chainBitcoin-BZQ6OAUy.js',
      'assets/metaplexUmi-DveWNDhv.js',
      'assets/analytics-Bl1TDnTV.js',
      'assets/browser-polyfill--SpK_K58.js',
    ])
) => i.map((i) => d[i]);
var jj = Object.defineProperty;
var ox = (e) => {
  throw TypeError(e);
};
var Lj = (e, t, n) =>
  t in e ? jj(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (e[t] = n);
var ae = (e, t, n) => Lj(e, typeof t != 'symbol' ? t + '' : t, n),
  ax = (e, t, n) => t.has(e) || ox('Cannot ' + n);
var oe = (e, t, n) => (ax(e, t, 'read from private field'), n ? n.call(e) : t.get(e)),
  Vt = (e, t, n) =>
    t.has(e)
      ? ox('Cannot add the same private member more than once')
      : t instanceof WeakSet
        ? t.add(e)
        : t.set(e, n),
  Ft = (e, t, n, r) => (ax(e, t, 'write to private field'), r ? r.call(e, n) : t.set(e, n), n);
import {
  h as cS,
  A as Ul,
  V as fd,
  P as sA,
  l as Uj,
  j as P,
  m as $j,
  g as Fj,
  B as zj,
  S as gy,
  n as Kj,
  D as ww,
  a as yr,
  t as Le,
  T as Vj,
  L as cx,
  f as Wj,
  o as Hj,
  M as Gj,
  F as ye,
  p as uo,
  q as qj,
  r as Yj,
  s as iP,
  u as je,
  v as Zj,
  w as Jj,
  x as on,
  y as ra,
  z as Fi,
  I as Xj,
  C as $p,
  E as Qj,
  G as sP,
  H as e9,
  R as t9,
  J as n9,
  K as Lg,
  N as r9,
  O as i9,
  Q as s9,
  U as yy,
  W as oP,
  X as aP,
  Y as ux,
  Z as cP,
  $ as o9,
  a0 as a9,
} from './phantomUi-BUKCyHFp.js';
import { a as c9, r as W, R as Kn } from './react-6iN9_IA6.js';
import {
  z as g,
  i as qr,
  B as uP,
  b as u9,
  t as l9,
  d as lP,
  u as Ct,
  Z as oA,
  T as dP,
} from './phantomUiDeps-B7Pij32n.js';
import {
  A as lx,
  B as dx,
  E as fx,
  H as hx,
  P as px,
  S as Js,
  a as Ml,
  C as Lu,
  b as ze,
  c as Uu,
  t as we,
  d as de,
  e as et,
  N as mt,
  D as ke,
  f as Yl,
  g as G,
  h as bs,
  i as $l,
  M as vw,
  j as fP,
  k as hP,
  l as pP,
  m as qt,
  n as $u,
  Z as aA,
  o as yb,
  p as d9,
  q as bb,
  r as f9,
  s as mb,
  u as gP,
  v as h9,
  w as re,
  F as ce,
  x as Ie,
  y as cA,
  z as p9,
  G as Qt,
  I as ms,
  J as by,
  K as Vi,
  L as eo,
  O as uA,
  Q as g9,
  R as y9,
  T as b9,
  U as m9,
  V,
  W as my,
  X as yP,
  Y as gx,
  _ as w9,
  $ as io,
  a0 as gi,
  a1 as v9,
  a2 as _9,
  a3 as S9,
  a4 as mr,
  a5 as bP,
  a6 as wy,
  a7 as vy,
  a8 as E9,
  a9 as A9,
  aa as I9,
  ab as mP,
  ac as wP,
  ad as uS,
  ae as vP,
  af as T9,
  ag as x9,
  ah as Es,
  ai as _P,
  aj as k9,
  ak as lA,
  al as lo,
  am as Fu,
  an as C9,
  ao as P9,
  ap as M9,
  aq as yx,
  ar as SP,
  as as O9,
  at as B9,
  au as D9,
  av as R9,
  aw as EP,
  ax as bx,
  ay as AP,
  az as fa,
  aA as IP,
  aB as TP,
  aC as N9,
  aD as j9,
  aE as L9,
  aF as mx,
  aG as xP,
  aH as _y,
  aI as Pr,
  aJ as U9,
  aK as dA,
  aL as $9,
  aM as F9,
  aN as ha,
  aO as z9,
  aP as kP,
  aQ as wb,
  aR as CP,
  aS as PP,
  aT as K9,
  aU as V9,
  aV as MP,
  aW as OP,
  aX as ss,
  aY as BP,
  aZ as ba,
  a_ as wx,
  a$ as W9,
  b0 as H9,
  b1 as G9,
  b2 as q9,
  b3 as Y9,
  b4 as Z9,
  b5 as J9,
  b6 as X9,
  b7 as Q9,
  b8 as eL,
  b9 as DP,
  ba as Yi,
  bb as tL,
  bc as nL,
  bd as rL,
  be as iL,
  bf as vx,
  bg as sL,
  bh as oL,
  bi as _x,
  bj as aL,
  bk as Sx,
  bl as cL,
  bm as uL,
  bn as lL,
} from './phantomRpc-C42kJpAs.js';
import {
  h as he,
  B as z,
  S as lS,
  ar as dL,
  J as or,
  as as _c,
  $ as fL,
  at as _w,
  au as hL,
  av as RP,
  r as pL,
  f as gL,
  g as Sy,
  n as ir,
  s as De,
  i as Ne,
  j as ai,
  u as wt,
  k as ur,
  o as Ha,
  l as hd,
  q as fA,
  m as pe,
  v as rn,
  x as ue,
  z as Ae,
  A as Ee,
  y as Q,
  C as He,
  E as NP,
  F as Or,
  D as so,
  H as xi,
  I as jP,
  b as Xt,
  K as Ex,
  p as hA,
  w as pd,
  L as yL,
  G as me,
  P as bL,
  t as mL,
  a as LP,
  N as pA,
  R as wL,
  O as vL,
  Q as _L,
  T as SL,
  U as EL,
  V as te,
  W as kt,
  aw as Ze,
  ax as AL,
  a6 as hu,
  a5 as IL,
  Y as TL,
  _ as UP,
  a4 as vb,
  e as xL,
  a2 as gA,
  a0 as kL,
  ay as CL,
} from './metaplex-81r3lICz.js';
import {
  p as PL,
  P as nr,
  C as Sw,
  t as ML,
  V as OL,
  T as BL,
  u as DL,
  v as RL,
  q as NL,
  n as _b,
} from './chainSolana-DAiUp22G.js';
import {
  h as jL,
  a as LL,
  S as Ax,
  T as dS,
  v as yA,
  p as Ix,
  c as UL,
  d as $L,
  O as FL,
  s as bi,
  N as zL,
  b as Ey,
  t as $P,
  e as Tx,
  f as KL,
  g as VL,
  i as WL,
  j as bA,
} from './chainBitcoin-BZQ6OAUy.js';
import {
  l as FP,
  o as Ar,
  n as $s,
  b as HL,
  W as GL,
  C as xx,
  V as qL,
  s as YL,
  q as ZL,
  u as kx,
} from './chainEthereum-DlaaxYpw.js';
import { c as m, g as Sc, a as Sb } from './lodash-aFjP5OGs.js';
import { _ as mA, R as zP, y as JL } from './analytics-Bl1TDnTV.js';
import { B as fe, r as Rt } from './metaplexMplTokenMetadata-D0B0pvkO.js';
import { u as wA, a as KP, c as XL, b as QL, S as eU, d as tU } from './stackRouter-DXpkt1Ae.js';
import { S as nU, T as Eb } from './chainSui-B9XQrNne.js';
import './metaplexUmi-DveWNDhv.js';
import './metaplexMplCore-DwupZZ2Y.js';
(function () {
  const t = document.createElement('link').relList;
  if (t && t.supports && t.supports('modulepreload')) return;
  for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i);
  new MutationObserver((i) => {
    for (const s of i)
      if (s.type === 'childList')
        for (const o of s.addedNodes) o.tagName === 'LINK' && o.rel === 'modulepreload' && r(o);
  }).observe(document, { childList: !0, subtree: !0 });
  function n(i) {
    const s = {};
    return (
      i.integrity && (s.integrity = i.integrity),
      i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy),
      i.crossOrigin === 'use-credentials'
        ? (s.credentials = 'include')
        : i.crossOrigin === 'anonymous'
          ? (s.credentials = 'omit')
          : (s.credentials = 'same-origin'),
      s
    );
  }
  function r(i) {
    if (i.ep) return;
    i.ep = !0;
    const s = n(i);
    fetch(i.href, s);
  }
})();
var VP,
  Cx = c9;
(VP = Cx.createRoot), Cx.hydrateRoot;
const zu = {},
  rU = {
    ...zu,
    defaultExplorer: 'arbiscan',
    getExplorerUrl: function (e) {
      let t;
      switch (e) {
        case lx.Sepolia:
          t = 'sepolia.';
          break;
        case lx.Mainnet:
        default:
          t = '';
      }
      return {
        arbiscan: (n, r) => {
          const i = Array.isArray(r) ? r.join('/') : r,
            s = { transaction: 'tx', address: 'address', token: 'token', nft: 'nft' }[n];
          return `https://${t}arbiscan.io/${s}/${i}`;
        },
      };
    },
  },
  iU = {
    ...zu,
    defaultExplorer: 'basescan',
    getExplorerUrl: function (e) {
      let t;
      switch (e) {
        case dx.Sepolia:
          t = 'sepolia.';
          break;
        case dx.Mainnet:
        default:
          t = '';
      }
      return {
        basescan: (n, r) => {
          const i = Array.isArray(r) ? r.join('/') : r,
            s = { transaction: 'tx', address: 'address', token: 'token', nft: 'nft' }[n];
          return `https://${t}basescan.org/${s}/${i}`;
        },
      };
    },
  },
  sU = {
    getExplorerUrl: function () {
      return {
        mempool: (e, t) =>
          `https://mempool.space/${{ transaction: 'tx', address: 'address' }[e]}/${t}`,
      };
    },
    defaultExplorer: 'mempool',
  },
  oU = {
    ...zu,
    getExplorerUrl(e) {
      let t;
      switch (e) {
        case fx.Sepolia:
          t = 'sepolia.';
          break;
        case fx.Mainnet:
        default:
          t = '';
      }
      return {
        etherscan: (n, r) => {
          const i = Array.isArray(r) ? r.join('/') : r,
            s = { transaction: 'tx', address: 'address', token: 'token', nft: 'nft' }[n];
          return `https://${t}etherscan.io/${s}/${i}`;
        },
      };
    },
    defaultExplorer: 'etherscan',
  },
  aU = {
    ...zu,
    defaultExplorer: 'hyperliquid',
    getExplorerUrl: function (e) {
      let t;
      switch (e) {
        case hx.Testnet:
          t = 'app.hyperliquid-testnet.xyz';
          break;
        case hx.Mainnet:
        default:
          t = 'app.hyperliquid.xyz';
      }
      return {
        hyperliquid: (n, r) => {
          const i = Array.isArray(r) ? r.join('/') : r,
            s = { transaction: 'tx', address: 'address' }[n];
          return `https://${t}/explorer/${s}/${i}`;
        },
      };
    },
  },
  cU = {
    ...zu,
    getExplorerUrl: function () {
      return {
        monadexplorer: (e, t) => {
          const n = Array.isArray(t) ? t.join('/') : t;
          return `https://testnet.monadexplorer.com/${{ transaction: 'tx', address: 'address', token: 'token', nft: 'nft' }[e]}/${n}`;
        },
      };
    },
    defaultExplorer: 'monadexplorer',
    betaTagOverride: 'Testnet',
  },
  uU = {
    ...zu,
    getExplorerUrl: function (e) {
      let t;
      switch (e) {
        case px.Amoy:
          t = 'amoy.';
          break;
        case px.Mainnet:
        default:
          t = '';
      }
      return {
        polygonscan: (n, r) => {
          const i = Array.isArray(r) ? r.join('/') : r,
            s = { transaction: 'tx', address: 'address', token: 'token', nft: 'nft' }[n];
          return `https://${t}polygonscan.com/${s}/${i}`;
        },
      };
    },
    defaultExplorer: 'polygonscan',
  },
  lU = {
    getExplorerUrl: function (e) {
      let t;
      switch (e) {
        case Js.Devnet:
          t = 'devnet';
          break;
        case Js.Testnet:
          t = 'testnet';
          break;
        case Js.Mainnet:
          t = 'mainnet-beta';
          break;
        case Js.Localnet:
          t = 'mainnet-beta';
          break;
      }
      let n = '';
      return (
        ['devnet', 'testnet'].includes(t) && (n = `?cluster=${t}`),
        {
          'solana-beach': (r, i) => `https://solanabeach.io/${r}/${i}${n}`,
          solscan: (r, i) =>
            `https://solscan.io/${{ transaction: 'tx', address: 'account' }[r]}/${i}${n}`,
          'solana-explorer': (r, i) => `https://explorer.solana.com/${r}/${i}${n}`,
          'solana-fm': (r, i) => {
            const s = {
              'mainnet-beta': 'mainnet-qn1',
              testnet: 'testnet-solana',
              devnet: 'devnet-solana',
              localhost: 'localhost',
            }[t];
            return `https://solana.fm/${{ transaction: 'tx', address: 'address' }[r]}/${i}?cluster=${s}`;
          },
          xray: (r, i) =>
            `https://xray.helius.xyz/${{ transaction: 'tx', address: 'token' }[r]}/${i}${n}`,
        }
      );
    },
    defaultExplorer: 'solscan',
  },
  dU = {
    getExplorerUrl: function (e) {
      return {
        suiscan: (t, n) => {
          let r;
          switch (e) {
            case Ml.Testnet:
              r = 'testnet';
              break;
            case Ml.Mainnet:
              r = 'mainnet';
              break;
          }
          const i = { transaction: 'tx', address: 'account', token: 'coin', nft: 'object' }[t];
          return `https://suiscan.xyz/${r}/${i}/${n}`;
        },
        suivision: (t, n) => {
          let r;
          switch (e) {
            case Ml.Testnet:
              r = 'testnet.';
              break;
            case Ml.Mainnet:
              r = '';
              break;
          }
          const i = { transaction: 'txblock', address: 'account', token: 'coin', nft: 'object' }[t];
          return `https://${r}suivision.xyz/${i}/${n}`;
        },
      };
    },
    defaultExplorer: 'suivision',
  },
  fU = new Lu({
    [ze.Solana]: lU,
    [ze.Ethereum]: oU,
    [ze.Polygon]: uU,
    [ze.Monad]: cU,
    [ze.Base]: iU,
    [ze.Arbitrum]: rU,
    [ze.Bitcoin]: sU,
    [ze.Sui]: dU,
    [ze.Hypercore]: aU,
  }),
  fS = Uu(fU),
  hU = () => {
    const e = {};
    return (
      de.getAllNetworkIDs().forEach((t) => {
        const n = fS.get(t).defaultExplorer;
        n && (e[t] = n);
      }),
      e
    );
  },
  Px = { version: 1, explorers: hU() };
we({ minutes: 15 });
const WP = [
  { value: 'en', displayValue: 'English', isLocale: !1 },
  { value: 'es', displayValue: 'Español', isLocale: !1 },
  { value: 'de', displayValue: 'Deutsch', isLocale: !1 },
  { value: 'fr', displayValue: 'Français', isLocale: !1 },
  { value: 'it', displayValue: 'Italiano', isLocale: !1 },
  { value: 'zh-CN', displayValue: '中文(简体)', isLocale: !0 },
  { value: 'zh-TW', displayValue: '中文(繁體)', isLocale: !0 },
  { value: 'bn', displayValue: 'বাংলা', isLocale: !1 },
  { value: 'ja', displayValue: '日本', isLocale: !1 },
  { value: 'ko', displayValue: '한국어', isLocale: !1 },
  { value: 'ru', displayValue: 'Pусский', isLocale: !1 },
  { value: 'hi', displayValue: 'हिंदी', isLocale: !1 },
  { value: 'id', displayValue: 'Indonesia', isLocale: !1 },
  { value: 'ms', displayValue: 'Melayu', isLocale: !1 },
  { value: 'th', displayValue: 'ไทย', isLocale: !1 },
  { value: 'vi', displayValue: 'Tiếng Việt', isLocale: !1 },
  { value: 'pt', displayValue: 'Português', isLocale: !1 },
  { value: 'tr', displayValue: 'Türkçe', isLocale: !1 },
  { value: 'fil', displayValue: 'Filipino', isLocale: !1 },
  { value: 'my', displayValue: 'မြန်မာဘာသာ', isLocale: !1 },
  { value: 'am', displayValue: 'አማርኛ', isLocale: !1 },
  { value: 'ar', displayValue: 'العربية', isLocale: !1 },
  { value: 'gu', displayValue: 'ગુજરાતી', isLocale: !1 },
  { value: 'ha', displayValue: 'Hausa', isLocale: !1 },
  { value: 'ig', displayValue: 'Ásụ̀sụ́ Ìgbò', isLocale: !1 },
  { value: 'pa', displayValue: 'ਪੰਜਾਬੀ', isLocale: !1 },
  { value: 'sw', displayValue: 'Kiswahili', isLocale: !1 },
  { value: 'ta', displayValue: 'தமிழ்', isLocale: !1 },
  { value: 'te', displayValue: 'తెలుగు', isLocale: !1 },
  { value: 'yo', displayValue: 'Èdè Yorùbá', isLocale: !1 },
];
et.UserExplorerPreferenceV2;
var vA = ((e) => (
  (e.ApiEnvironment = 'apiEnvironment'),
  (e.EmojiSkinTone = 'emojiSkinTone'),
  (e.IsAnalyticsOptedOut = 'isAnalyticsOptedOut'),
  (e.SolanaActionsEnabled = 'solanaActionsEnabled'),
  (e.ShowWalletShortcuts = 'showWalletShortcuts'),
  (e.SelectedCurrency = 'selectedCurrency'),
  (e.SavedAddresses = 'savedAddresses'),
  (e.RecentAddressesBrowser = 'recentAddresses'),
  (e.RecentAddressesMobile = 'recentAddressesV2'),
  e
))(vA || {});
vA.IsAnalyticsOptedOut;
var _A = ((e) => (
  (e.Image = 'image'),
  (e.Emoji = 'emoji'),
  (e.ReadOnlyDefault = 'read-only-default'),
  (e.Default = 'default'),
  e
))(_A || {});
const pU = g.object({
  type: g.nativeEnum(_A),
  imageUrl: g.string().optional(),
  unicode: g.string().optional(),
});
var HP = ((e) => ((e.Ledger = 'ledger'), e))(HP || {}),
  GP = ((e) => ((e.BLE = 'ble'), e))(GP || {});
const gU = g.object({
    version: g.literal(1),
    connectionType: g.nativeEnum(GP),
    deviceType: g.nativeEnum(HP),
    id: g.string().min(1),
    name: g.string().optional(),
    model: g.string().optional(),
  }),
  yU = g.object({ value: g.number(), timestamp: g.number() });
g.object({
  name: g.string(),
  icon: pU.optional(),
  connectedDevices: gU.array().optional(),
  balance: yU.optional(),
});
_A.Default;
const qP = mt.Solana.Devnet,
  YP = mt.Ethereum.Sepolia,
  bU = mt.Sui.Testnet;
function ZP(e) {
  return { version: 1, setting: { [G.Solana]: qP, [G.EVM]: YP, ...(e ? { [G.Sui]: bU } : {}) } };
}
function Ku(e) {
  return e.map((t) => Yl[t].defaultDerivationPathType);
}
ke.Bip44RootSolana + '',
  ke.Bip44RootEthereum,
  ke.Bip44ChangeSolana + '',
  ke.Bip44Ethereum,
  ke.Bip44Solana + '',
  ke.Bip44EthereumSecondary,
  ke.DeprecatedSolana + '',
  ke.Bip44EthereumTertiary,
  ke.Bip44RootEthereum + '',
  ke.Bip44Ethereum + '',
  ke.Bip44EthereumSecondary + '',
  ke.Bip44EthereumTertiary + '',
  ke.BitcoinTaproot + '',
  ke.BitcoinNativeSegwit + '',
  ke.BitcoinNestedSegwit + '',
  ke.BitcoinLegacy + '',
  ke.Bip44Sui + '';
const Ab = {
    [ke.Bip44RootSolana]: -1,
    [ke.Bip44RootEthereum]: -1,
    [ke.BitcoinTaproot]: 0,
    [ke.BitcoinNativeSegwit]: 0,
    [ke.BitcoinNestedSegwit]: 0,
    [ke.BitcoinLegacy]: 0,
    [ke.Bip44ChangeSolana]: 0,
    [ke.Bip44Ethereum]: 0,
    [ke.Bip44Solana]: 1,
    [ke.Bip44EthereumSecondary]: 1,
    [ke.DeprecatedSolana]: 2,
    [ke.Bip44EthereumTertiary]: 2,
    [ke.Bip44Sui]: 0,
  },
  Mx = (e, t) => {
    const n = bs(e, t);
    switch (n) {
      case G.BitcoinTaproot:
      case G.BitcoinNativeSegwit:
      case G.BitcoinNestedSegwit:
      case G.BitcoinLegacy:
        return Yl.getDisplayName(n);
      default:
        return;
    }
  },
  mU = {
    badge: (e, t, n) => (t.filter($l).length <= 1 ? '' : (Mx(e, n) ?? '')),
    showAddressTypeExplainer: (e) => e.filter($l).length > 1,
    addressTooltipNetworkName: (e, t, n) =>
      n.filter($l).length >= 2 ? (Mx(e, t) ?? de.getChainName(e)) : de.getChainName(e),
  },
  wU = {
    badge: (e, t) => {
      switch (e) {
        case vw.Devnet:
        case vw.Testnet:
          return de.getNetworkDefinition(e).shortName;
        case vw.Mainnet:
          return;
      }
    },
    networkNameOverride: () => 'Monad',
  },
  vU = new Lu({
    [ze.Solana]: {},
    [ze.Ethereum]: {},
    [ze.Polygon]: {},
    [ze.Base]: {},
    [ze.Arbitrum]: {},
    [ze.Monad]: wU,
    [ze.Bitcoin]: mU,
    [ze.Sui]: {},
    [ze.Hypercore]: {},
  });
Uu(vU);
g.string().regex(
  /^(root-derivation-path-group|(recommended|secondary|tertiary)-group:index-[0-9]+)$/,
  { message: 'Invalid derivation path group.' }
);
var ee = ((e) => (
  (e.Seed = 'seed'),
  (e.PrivateKey = 'privateKey'),
  (e.Ledger = 'ledger'),
  (e.SeedVault = 'seedVault'),
  (e.ReadOnly = 'readOnly'),
  (e.Seedless = 'seedless'),
  e
))(ee || {});
g.object({
  derivationIndex: g.number(),
  addresses: g.array(g.object({ pathType: g.union([fP, hP]), value: g.string() })),
  publicKeys: g.array(g.object({ pathType: pP, value: g.string() })),
});
class Ay extends Error {
  constructor() {
    super(...arguments);
    ae(this, 'message', 'No account exists in storage for identifier');
  }
}
class Ib extends Error {
  constructor() {
    super(...arguments);
    ae(this, 'message', 'No account exists in storage for identifier');
  }
}
class hS extends Error {
  constructor() {
    super(...arguments);
    ae(this, 'message', 'Address type not found or incompatible with account');
  }
}
class _U extends Error {
  constructor() {
    super(...arguments);
    ae(this, 'message', 'Hardware wallet account does not have known secr*ts');
  }
}
class SU extends Error {
  constructor() {
    super(...arguments);
    ae(this, 'message', 'Read only account does not have known secr*ts');
  }
}
class EU extends Error {
  constructor() {
    super(...arguments);
    ae(this, 'message', 'Invalid configuration for read only account');
  }
}
class JP extends Error {
  constructor() {
    super(...arguments);
    ae(this, 'message', 'Seed already exists in storage');
  }
}
class SA extends Error {
  constructor() {
    super(...arguments);
    ae(this, 'message', 'No seed exists in storage for identifier');
  }
}
class AU extends Error {
  constructor() {
    super(...arguments);
    ae(this, 'message', 'The derivation index is missing or invalid');
  }
}
class IU extends Error {
  constructor() {
    super(...arguments);
    ae(this, 'message', 'Private key already exists in storage');
  }
}
class XP extends Error {
  constructor() {
    super(...arguments);
    ae(this, 'message', 'No private key exists in storage for identifier');
  }
}
class Iy extends Error {
  constructor(n, r) {
    super();
    ae(this, 'message');
    this.message = `Account of type ${n} found in Vault, while trying to add ${r} account`;
  }
}
class TU extends Error {
  constructor() {
    super(...arguments);
    ae(this, 'message', 'Vault already stores a seedless account');
  }
}
const xU = g.union([g.literal('unonboarded'), g.literal('unable-to-load-accounts')]),
  kU = g.union([
    g.literal('invalid-identifier'),
    g.literal('fetch-integrity-storage-error'),
    g.literal('fetch-entropy-storage-error'),
    g.literal('fetch-pk-storage-error'),
    g.literal('invalid-entropy'),
    g.literal('invalid-entropy-bip-39'),
    g.literal('invalid-checksum-bits'),
    g.literal('invalid-entropy-bits'),
    g.literal('invalid-checksum'),
    g.literal('invalid-entropy-length-less-than-twelve'),
    g.literal('invalid-entropy-length-more-than-twenty-four'),
    g.literal('invalid-entropy-length-wrong-word'),
    g.literal('invalid-pk-address-type'),
    g.literal('invalid-pk-identifier'),
    g.literal('invalid-pk'),
    g.literal('internal-error'),
  ]),
  CU = g.literal('safely-onboarded');
g.union([
  g.object({ status: xU, isOnboarded: g.literal(!1), reonboardingNeeded: g.literal(!1) }),
  g.object({ status: kU, isOnboarded: g.literal(!0), reonboardingNeeded: g.literal(!0) }),
  g.object({ status: CU, isOnboarded: g.literal(!0), reonboardingNeeded: g.literal(!1) }),
]);
const PU = (e, t, n, r) => {
    const i = [];
    for (const s of t) {
      const o = de.getChainID(s);
      if (r.includes(o))
        for (const a of de[o].addressTypes) {
          if (!n.includes(a)) continue;
          const c = e.chains[a];
          if (c)
            switch (c.chainType) {
              case G.EVM:
              case G.Solana: {
                i.push({ networkID: s, addressType: a, address: c.address });
                break;
              }
              case G.BitcoinTaproot:
              case G.BitcoinNativeSegwit:
              case G.BitcoinNestedSegwit:
              case G.BitcoinLegacy: {
                i.push({
                  networkID: s,
                  addressType: a,
                  publicKey: c.publicKey,
                  address: c.addresses[s],
                });
                break;
              }
              case G.Sui: {
                i.push({
                  networkID: s,
                  addressType: a,
                  publicKey: c.publicKey,
                  address: c.address,
                });
                break;
              }
              default:
                qt();
            }
        }
    }
    return i;
  },
  MU = (e, t, n, r) => {
    const i = [];
    for (const s of t) {
      const o = de.getChainID(s);
      if (r.includes(o))
        for (const a of de[o].addressTypes) {
          if (!n.includes(a)) continue;
          const c = e.chains[a];
          if (c)
            switch (c.chainType) {
              case G.EVM:
              case G.Solana: {
                i.push({ networkID: s, addressType: a, address: c.address });
                break;
              }
              case G.BitcoinTaproot:
              case G.BitcoinNativeSegwit:
              case G.BitcoinNestedSegwit:
              case G.BitcoinLegacy: {
                i.push({
                  networkID: s,
                  addressType: a,
                  publicKey: c.publicKey,
                  address: c.addresses[s],
                });
                break;
              }
              case G.Sui: {
                i.push({
                  networkID: s,
                  addressType: a,
                  publicKey: c.publicKey,
                  address: c.address,
                });
                break;
              }
              default:
                qt();
            }
        }
    }
    return i;
  },
  OU = (e, t, n, r) => {
    const i = [];
    for (const s of t) {
      const o = de.getChainID(s);
      if (r.includes(o))
        for (const a of de[o].addressTypes)
          n.includes(a) &&
            e.chainType === a &&
            i.push({ networkID: s, addressType: a, address: e.address });
    }
    return i;
  },
  BU = (e, t, n, r) => {
    const i = [];
    for (const s of t) {
      const o = de.getChainID(s);
      if (r.includes(o)) {
        for (const a of de[o].addressTypes)
          if (n.includes(a) && e.chainType === a)
            switch (e.chainType) {
              case G.EVM:
              case G.Solana: {
                i.push({ networkID: s, addressType: a, address: e.address });
                break;
              }
              case G.BitcoinTaproot:
              case G.BitcoinNativeSegwit:
              case G.BitcoinNestedSegwit:
              case G.BitcoinLegacy: {
                i.push({
                  networkID: s,
                  addressType: a,
                  publicKey: e.publicKey,
                  address: e.addresses[s],
                });
                break;
              }
              case G.Sui: {
                i.push({
                  networkID: s,
                  addressType: a,
                  publicKey: e.publicKey,
                  address: e.address,
                });
                break;
              }
              default:
                qt();
            }
      }
    }
    return i;
  },
  DU = (e, t, n, r) => {
    const i = [];
    for (const s of t) {
      const o = de.getChainID(s);
      if (r.includes(o)) {
        for (const a of de[o].addressTypes)
          if (n.includes(a))
            for (const [c, u] of Object.entries(e.addresses))
              c === a && i.push({ networkID: s, addressType: a, address: u });
      }
    }
    return i;
  },
  RU = (e, t, n, r, i, s) => {
    let o;
    switch (
      (s ? (o = Object.values(i.setting)) : (o = t),
      (o = o.sort((a, c) => de.compareNetworkID(a, c))),
      e.type)
    ) {
      case ee.Seedless:
      case ee.Seed:
        return PU(e, o, n, r);
      case ee.Ledger:
        return MU(e, o, n, r);
      case ee.SeedVault:
        return OU(e, o, n, r);
      case ee.PrivateKey:
        return BU(e, o, n, r);
      case ee.ReadOnly:
        return DU(e, o, n, r);
    }
  },
  QP = 'Trying to find a selected account, but there no accounts in the vault.',
  eM = 'Missing ChainAvailability.';
var Ja = ((e) => (
  (e.TermsHaveBeenAcknowledgedLastSeenVersion = 'termsHaveBeenAcknowledgedLastSeenVersion'),
  (e.NetworkSetting = 'networkSetting'),
  (e.DeveloperMode = 'developerMode'),
  (e.SelectedAccount = '.phantom-labs.account.selectedAccount'),
  (e.AccountsMetadata = '.phantom-labs.account.accountMetadata'),
  (e.MigratedWithInvalidChecksum = '.phantom-labs.account.migratedWithInvalidChecksum'),
  (e.AccountMetas = 'accountMetas'),
  e
))(Ja || {});
async function NU(e) {
  try {
    const t = await e.get('.phantom-labs.account.selectedAccount');
    return (t == null ? void 0 : t.version) === 2 ? t.identifier : null;
  } catch {
    throw jU;
  }
}
const jU = new Error('Failed to get selected account identifier');
async function tM(e, t) {
  try {
    const n = { version: 2, identifier: t };
    return await e.set('.phantom-labs.account.selectedAccount', n);
  } catch {
    throw LU;
  }
}
const LU = new Error('Failed to set selected account identifier'),
  UU = async (e, t) => {
    if (e.length === 0) throw new Error(QP);
    const n = await NU(t),
      r = e.find((i) => i.identifier === n);
    return r || (await tM(t, e[0].identifier), e[0]);
  },
  $U = (e) => {
    switch (e) {
      case ke.BitcoinTaproot:
      case ke.BitcoinNativeSegwit:
      case ke.BitcoinNestedSegwit:
      case ke.BitcoinLegacy:
      case ke.Bip44ChangeSolana:
      case ke.Bip44Ethereum:
        return !0;
      case ke.Bip44Solana:
      case ke.DeprecatedSolana:
      case ke.Bip44RootSolana:
      case ke.Bip44RootEthereum:
      case ke.Bip44EthereumSecondary:
      case ke.Bip44EthereumTertiary:
      case ke.Bip44Sui:
        return !1;
    }
  },
  Ty = (e, t = 5) => {
    const n = e.length,
      r = e.startsWith('0x') ? t + 2 : t;
    return `${e.substring(0, r)}...${e.substring(n - t, n)}`;
  },
  FU = (e) => {
    const t = e.toString();
    return Ty(t);
  };
let pS = null;
function zU(e) {
  pS = e;
}
async function KU() {
  if (!pS)
    throw new Error(
      'No fetch bearer token function registered. Register one with registerFetchBearerToken().'
    );
  return await pS();
}
function VU(...e) {
  const t = new AbortController();
  for (const n of e) {
    const r = n instanceof AbortController ? n.signal : n;
    if (r != null && r.aborted) return t.abort(r.reason), t.signal;
    r == null ||
      r.addEventListener(
        'abort',
        () => {
          t.abort(r.reason);
        },
        { once: !0 }
      );
  }
  return t.signal;
}
const WU = 2 * 60 * 1e3,
  HU = [];
function GU(e, t) {
  const { fetchTimeout: n, retryDelays: r, ...i } = t || {},
    s = (t == null ? void 0 : t.fetchTimeout) ?? WU,
    o = (t == null ? void 0 : t.retryDelays) ?? HU;
  let a = 0,
    c = 0;
  return new Promise((u, l) => {
    function d() {
      a++, (c = Date.now());
      let p = !0;
      const b = new AbortController(),
        w = fetch(e, { ...i, signal: VU(...(i.signal ? [i.signal, b.signal] : [b.signal])) }),
        A = setTimeout(() => {
          b.abort(),
            (p = !1),
            h(a)
              ? f()
              : l(
                  new Error(
                    `fetchWithTimeoutAndRetry(): Failed to get response from server due to timeout of ${s} ms, tried ${a} times.`
                  )
                );
        }, s);
      w.then((_) => {
        clearTimeout(A),
          p && (_.status >= 200 && _.status < 300 ? u(_) : h(a, _.status) ? f() : u(_));
      }).catch((_) => {
        clearTimeout(A), h(a) ? f() : l(_);
      });
    }
    function f() {
      const p = o[a - 1],
        b = c + p;
      setTimeout(d, Math.max(b - Date.now(), 0));
    }
    function h(p, b) {
      const w = b ? b >= 400 && b <= 499 : !1;
      return p <= o.length && !w;
    }
    d();
  });
}
const Ew = (e = {}, t = {}) => {
    const n = new Headers(e),
      r = new Headers(t);
    for (const [i, s] of r.entries()) s === void 0 || s === 'undefined' ? n.delete(i) : n.set(i, s);
    return n;
  },
  qU = [
    86, 120, 48, 81, 89, 86, 110, 49, 100, 114, 111, 113, 49, 70, 56, 84, 77, 115, 80, 81, 66, 75,
    72, 51, 90, 83, 110, 100, 110, 116, 68, 88, 107, 118, 83, 53, 102, 80, 114, 89, 111, 88, 85, 75,
    57, 43, 67, 57, 97, 103, 74, 113, 68, 76, 112, 112, 100, 48, 102, 101, 80, 122, 83, 111, 108,
    113, 75, 90, 56, 114, 66, 70, 119, 87, 84, 104, 98, 57, 110, 119, 43, 79, 70, 51, 51, 65, 61,
    61,
  ],
  YU = [
    87, 67, 49, 81, 97, 71, 70, 117, 100, 71, 57, 116, 81, 88, 86, 48, 97, 70, 82, 118, 97, 50, 86,
    117,
  ],
  ZU = [87, 67, 49, 81, 97, 71, 70, 117, 100, 71, 57, 116, 84, 109, 57, 117, 89, 50, 85, 61];
function JU(e) {
  const t = new URL(e);
  return t.pathname + t.search;
}
function XU(e, t) {
  const n = JU(e),
    r = JSON.stringify(Math.floor(Date.now() / 1e3)),
    i = n + r,
    s = jL(LL, he.from(String.fromCharCode(...qU)), he.from(i)),
    o = new Headers(t);
  return (
    o.set(
      he.from(String.fromCharCode(...YU), 'base64').toString(),
      encodeURIComponent(he.from(s).toString('base64'))
    ),
    o.set(he.from(String.fromCharCode(...ZU), 'base64').toString(), r),
    o
  );
}
class Ol extends Error {
  constructor(n, r) {
    super(n);
    ae(this, 'response');
    this.response = r;
  }
}
const QU = {
    'Content-Type': 'application/json',
    'X-Phantom-Version': fd,
    'X-Phantom-Platform': sA,
  },
  Bc = async (e) => {
    let t, n;
    try {
      n = await e.clone().blob();
    } catch {}
    try {
      t = await e.clone().json();
    } catch {}
    const { status: r, statusText: i } = e;
    return { blob: n, data: t, status: r, statusText: i };
  };
class Ls {
  constructor(t = {}) {
    ae(this, 'config');
    ae(this, 'fetch', async (t, n = {}) => {
      try {
        if (typeof t == 'function') {
          const c = cS() === Ul.Production ? 'prod' : 'staging';
          t = t({ apiEnv: c });
        }
        let r = '';
        this.config.withApiEnvironment === 'prod'
          ? (r = Ul.Production)
          : this.config.withApiEnvironment === 'staging'
            ? (r = Ul.Staging)
            : this.config.withApiEnvironment === 'default'
              ? (r = cS())
              : this.config.withApiEnvironment === 'custom' &&
                this.config.customApiEnv &&
                (r = this.config.customApiEnv);
        const i = new URL(`${r}${t}`);
        n != null && n.params && (i.search = new URLSearchParams(n.params).toString());
        const s = n;
        (n.headers = Ew(this.config.headers, n.headers)),
          (n.headers = n.headers),
          this.config.withClientAuth && (n.headers = XU(i.toString(), n.headers));
        let o = this.config.validateStatus;
        if (
          (n != null && n.validateStatus && (o = n == null ? void 0 : n.validateStatus),
          s.body && typeof s.body != 'string' && (s.body = JSON.stringify(s.body)),
          this.config.timeoutMs && (s.fetchTimeout = this.config.timeoutMs),
          this.config.numRetries &&
            (s.retryDelays = Array(this.config.numRetries).fill(
              this.config.delayBetweenEachRetryMs
            )),
          this.config.fetchBearerToken)
        ) {
          const c = await KU();
          if (c) s.headers = Ew(s.headers, { authorization: `Bearer ${c}` });
          else throw new Ol('Unable to get bearer token. Full auth is required.');
        }
        const a = await GU(i.toString(), s);
        if (o && !a.ok) throw new Ol(`Request failed with status code ${a.status}`, await Bc(a));
        return a;
      } catch (r) {
        throw r instanceof Ol
          ? r
          : new Ol(r == null ? void 0 : r.message, r == null ? void 0 : r.response);
      }
    });
    this.config = {
      withClientAuth: !0,
      numRetries: 0,
      delayBetweenEachRetryMs: 0,
      timeoutMs: null,
      validateStatus: !1,
      headers: QU,
      withApiEnvironment: 'none',
      fetchBearerToken: !1,
      ...t,
    };
  }
  auth(t) {
    return new Ls({ ...this.config, withClientAuth: t });
  }
  bearer(t) {
    return typeof t == 'string' && t
      ? this.headers({ authorization: `Bearer ${t}` })
      : typeof t == 'boolean' && t
        ? new Ls({ ...this.config, fetchBearerToken: !0 })
        : this;
  }
  headers(t, n) {
    const r = (n == null ? void 0 : n.mergeHeaders) === !1 ? t : Ew(this.config.headers, t);
    return new Ls({ ...this.config, headers: r });
  }
  timeout(t) {
    return new Ls({ ...this.config, timeoutMs: t });
  }
  retry(t, n) {
    return new Ls({ ...this.config, numRetries: t, delayBetweenEachRetryMs: n });
  }
  validateStatus(t) {
    return new Ls({ ...this.config, validateStatus: t });
  }
  api(t = 'default', n) {
    return new Ls({
      ...this.config,
      withApiEnvironment: t,
      customApiEnv: t === 'custom' ? n : void 0,
    });
  }
  async get(t, n = {}) {
    n.method = 'GET';
    const r = await this.fetch(t, n);
    return Bc(r);
  }
  async post(t, n, r = {}) {
    r.method = 'POST';
    const i = await this.fetch(t, { ...r, body: n });
    return Bc(i);
  }
  async put(t, n, r = {}) {
    r.method = 'PUT';
    const i = await this.fetch(t, { ...r, body: n });
    return Bc(i);
  }
  async patch(t, n, r = {}) {
    r.method = 'PATCH';
    const i = await this.fetch(t, { ...r, body: n });
    return Bc(i);
  }
  async delete(t, n, r = {}) {
    r.method = 'DELETE';
    const i = await this.fetch(t, { ...r, body: n });
    return Bc(i);
  }
}
const Ge = new Ls();
function e$(e) {
  if (e === void 0) throw new Error('rpcUrl undefined');
  return async (t, n) => {
    const r = { jsonrpc: '2.0', id: +new Date(), method: t, params: n },
      s = (await Ge.post(e, r)).data;
    if ('error' in s) throw new Error(JSON.stringify(s.error));
    return s.result;
  };
}
async function t$(e, t = {}) {
  return Ge.fetch(e, t);
}
function tr(e) {
  return e.status > 199 && e.status < 400;
}
function nM(e) {
  return e instanceof Ol;
}
const gd = (e, t) =>
    t ? `/user/v1/users/${e}/wallet-accounts/${t}` : `/user/v1/users/${e}/wallet-accounts`,
  Tb = (e) => `/user/v1/users/${e}/profile`,
  rM = (e) => `/user/v1/profiles/${e}`,
  n$ = () => '/user/v1/profiles/creation-check',
  r$ = (e) => `/v1/actors-search?query=${encodeURIComponent(e)}`,
  i$ = ['seed', 'seedless', 'privateKey'],
  iM = 10,
  s$ = 500,
  Fp = { seedless: 1, seed: 2, privateKey: 3 },
  zp = '@phantom/users',
  xy = {
    checkUsernameAvailability(e) {
      return ['user', `${zp}:check-username-availability`, { username: e }];
    },
    userProfile() {
      return ['user', `${zp}:user-profile`];
    },
    userProfileAttributeEffect(e) {
      return ['user', `${zp}:user-profile-attribute-effect`, { username: e }];
    },
    userSyncedAccounts() {
      return ['user', `${zp}:user-synced-accounts`];
    },
  },
  sM = async (e) => {
    await e.invalidateQueries({ queryKey: xy.userSyncedAccounts() });
  };
var EA = ((e) => (
  (e.PUBLIC = 'public'),
  (e.PRIVATE = 'private'),
  (e.INVISIBLE = 'invisible'),
  (e.HIDDEN = 'hidden'),
  e
))(EA || {});
Object.values(EA);
const o$ = g.string().brand('ProfileId'),
  oM = g.object({
    id: o$,
    username: g.string(),
    icon: g.string().nullish(),
    addresses: g.record(g.string(), g.string()),
    privacyState: g.nativeEnum(EA).optional().default('public'),
    biography: g.string().nullish(),
    phantomJoinDate: g.string().nullish(),
  }),
  aM = g.string().url().brand('ActorId'),
  a$ = g.object({
    id: g.string().optional(),
    orderedItems: aM.array(),
    next: g.string().optional(),
  }),
  Ox = g.object({
    id: g.string().url(),
    current: a$.optional(),
    totalItems: g.number().optional(),
  }),
  Bx = g.object({ type: g.string(), value: g.string().optional(), name: g.string().optional() }),
  c$ = g.object({ id: g.string().url().optional(), name: g.string().optional(), type: g.string() }),
  u$ = g
    .object({
      id: aM,
      name: g.string(),
      preferredUsername: g.string(),
      manuallyApprovesFollowers: g.boolean(),
      followers: g.union([Ox, g.string().url()]),
      following: g.union([Ox, g.string().url()]),
      icon: c$.nullish(),
      attachment: g.union([Bx, g.array(Bx)]).optional(),
      summary: g.string().nullish(),
      published: g.string().nullish(),
    })
    .transform((e) => {
      const { attachment: t, ...n } = e,
        r = {};
      let i = !1,
        s = !1,
        o = !1,
        a = !1,
        c = !1;
      if (t) {
        const u = Array.isArray(t) ? t : [t];
        for (const l of u)
          if (!(!l.name || !l.value)) {
            if (l.name.endsWith(':address')) {
              const d = $u.safeParse(l.name.replace(':address', ''));
              if (d.success) {
                const f = d.data;
                r[f] = l.value;
              }
            }
            l.name === 'requesting' && (i = l.value === 'true'),
              l.name === 'requestedBy' && (s = l.value === 'true'),
              l.name === 'blocking' && (o = l.value === 'true'),
              l.name === 'following' && (a = l.value === 'true'),
              l.name === 'followedBy' && (c = l.value === 'true');
          }
      }
      return {
        ...n,
        addresses: r,
        isSentFollowRequestPending: i,
        hasPendingFollowRequest: s,
        isBlocking: o,
        isFollowing: a,
        isFollowedBy: c,
      };
    }),
  l$ = g.object({ actors: u$.array() }),
  d$ = { Image: 'image', Emoji: 'emoji', ReadOnlyDefault: 'read-only-default', Default: 'default' };
g.object({
  type: g.nativeEnum(d$),
  imageUrl: g.string().optional(),
  unicode: g.string().optional(),
});
const cM = g.object({ error: g.object({ message: g.string() }) }),
  Dx = async (e) => {
    const t = await Ge.api().get(rM(e)),
      n = oM.safeParse(t.data);
    return n.success ? n.data : null;
  },
  f$ = g.string().regex(/^https?:\/\/.+$/),
  h$ = g.string(),
  xb = g.literal('privateKey'),
  p$ = g.object({ networkId: aA, publicKey: yb, address: d9, pathType: hP.or(xb) }),
  g$ = g.object({ networkId: bb, publicKey: yb, address: f9, pathType: fP.or(xb) }),
  y$ = g.object({ networkId: mb, publicKey: yb, address: g.string(), pathType: pP.or(xb) }),
  b$ = g.object({ networkId: gP, publicKey: yb, address: g.string(), pathType: h9.or(xb) }),
  m$ = g.union([p$, g$, y$, b$]),
  uM = g.object({
    accountHash: g.string(),
    accountOrigin: g
      .string()
      .regex(/^(seed|privateKey|seedless):(.+)/)
      .catch('readOnly'),
    name: g.string().nullish().default(null).catch(null),
    icon: g.union([f$, h$]).nullish().default(null).catch(null),
    derivationIndex: g.number().nullish().default(null).catch(null),
    addresses: g.array(m$).min(1),
  }),
  w$ = uM.and(g.object({ id: g.string() })),
  AA = g.object({ walletAccounts: g.array(w$) });
g.record(g.string(), uM);
const ky = (e) => {
    var t;
    for (const n of i$)
      if (((t = e.accountOrigin) == null ? void 0 : t.split(':')[0]) === n) return n;
    return null;
  },
  pu = (e) => {
    var t, n, r;
    return (r =
      (n = (t = e.accountOrigin) == null ? void 0 : t.replace('seed:', '')) == null
        ? void 0
        : n.replace('privateKey:', '')) == null
      ? void 0
      : r.replace('seedless:', '');
  },
  v$ = (e = []) =>
    e.sort((t, n) => {
      const r = ky(t),
        i = ky(n);
      if (r === null && i === null) return 0;
      if (r === null) return 1;
      if (i === null) return -1;
      if (Fp[r] - Fp[i] !== 0) return Fp[r] - Fp[i];
      const s = pu(t),
        o = pu(n);
      if (s === null && o === null) return 0;
      if (s === null) return 1;
      if (o === null) return -1;
      const a = s.localeCompare(o);
      return a !== 0
        ? a
        : t.derivationIndex === null && n.derivationIndex === null
          ? 0
          : t.derivationIndex === null
            ? 1
            : n.derivationIndex === null
              ? -1
              : t.derivationIndex - n.derivationIndex;
    }),
  _$ = (e) => ({
    getUsernameAvailability: (t) => S$(t),
    getUserProfile: () => E$(e),
    getUserProfileByUsername: (t) => Dx(t),
    getUserProfileByUsernameOrUserProfileId: (t) => Dx(t),
    searchForActor: (t, n, r) => B$(t, n),
    setUserProfile: ({ username: t, addresses: n, icon: r, signedMessages: i, privacyState: s }) =>
      A$(e, { username: t, addresses: n, signedMessages: i, icon: r, privacyState: s }),
    patchUserProfile: (t) => I$(e, t),
    deleteUserProfile: () => T$(e),
    isEligibleToClaim: (t) => x$(t),
    getSyncedAccounts: () => IA(e),
    downloadSyncedAccounts: () => k$(e),
    uploadSyncedAccounts: (t) => C$(e, t),
    uploadSyncedAccount: (t) => P$(e, t),
    deleteSyncedAccounts: () => M$(e),
    deleteSyncedAccount: (t) => O$(e, t),
  }),
  S$ = async (e) => {
    switch ((await Ge.api().get(rM(e))).status) {
      case 200:
        return !1;
      case 403:
        return !1;
      case 404:
        return !0;
      default:
        throw new Error('Failed to check for username availability.');
    }
  },
  E$ = async ({ authRepository: e }) => {
    const t = await e.getUser();
    if (!t) throw new Error('User is not logged in, unable to get user profile.');
    const { userID: n, accessToken: r } = t,
      i = await Ge.api().bearer(r).get(Tb(n)),
      s = oM.safeParse(i.data);
    return s.success ? s.data : null;
  },
  A$ = async (
    { authRepository: e },
    { username: t, addresses: n, icon: r, signedMessages: i, privacyState: s }
  ) => {
    const o = await e.getUser();
    if (!o) throw new Error('User is not logged in, unable to claim username.');
    const { userID: a, accessToken: c } = o,
      u = await Ge.api()
        .bearer(c)
        .post(Tb(a), { username: t, signedMessages: i, icon: r, addresses: n, privacyState: s });
    if (u.status === 201) return;
    const l = cM.safeParse(u.data);
    throw l.success ? new Error(l.data.error.message) : new Error('Unknown error');
  },
  I$ = async (
    { authRepository: e },
    { username: t, addresses: n, icon: r, privacyState: i, biography: s }
  ) => {
    const o = await e.getUser();
    if (!o) throw new Error('User is not logged in, unable to claim username.');
    const { userID: a, accessToken: c } = o,
      u = await Ge.api()
        .bearer(c)
        .patch(Tb(a), { username: t, addresses: n, icon: r, privacyState: i, biography: s });
    if (u.status === 200) return;
    re.captureMessage(
      `Failed to patch user profile: ${u.status} ${JSON.stringify(u.data)}`,
      ce.Auth
    );
    const l = cM.safeParse(u.data);
    throw l.success ? new Error(l.data.error.message) : new Error('Unknown error');
  },
  T$ = async ({ authRepository: e }) => {
    const t = await e.getUser();
    if (!t) throw new Error('User is not logged in, unable to sync down accounts.');
    const { userID: n, accessToken: r } = t,
      i = await Ge.api().bearer(r).delete(Tb(n));
    return 200 <= i.status && i.status < 300;
  },
  x$ = async (e) => {
    try {
      return (await Ge.api().post(n$(), { addresses: e })).status === 200;
    } catch {
      return !1;
    }
  },
  IA = async ({ authRepository: e }) => {
    const t = await e.getUser();
    if (!t) throw new Error('User is not logged in, unable to sync down accounts.');
    const { userID: n, accessToken: r } = t,
      i = await Ge.api().bearer(r).get(gd(n)),
      s = AA.safeParse(i.data);
    if (!s.success)
      throw new Error(
        'Unable to get synced accounts: unable to parse GET /wallet-accounts response.'
      );
    return { walletAccounts: v$(s.data.walletAccounts) };
  },
  k$ = async (e) => {
    const { walletAccounts: t } = await IA(e),
      n = t.reduce((r, i) => ((r[i.accountHash] = i), r), {});
    return await e.claimUsernameSigner.storeSyncedAccounts(n), !0;
  },
  lM = (e, t, n) => Ge.api().bearer(e).post(gd(t), n),
  C$ = async (e, t) => {
    const { authRepository: n, claimUsernameSigner: r, queryClient: i } = e,
      s = await n.getUser();
    if (!s)
      return (
        re.addBreadcrumb(ce.Auth, 'User is not logged in, unable to sync up accounts.', Ie.Info), !1
      );
    try {
      let o = t;
      o ||
        (re.addBreadcrumb(ce.Auth, 'Uploading all currently synced accounts...', Ie.Info),
        (o = [
          ...(await IA(e)).walletAccounts.reduce((h, p) => (h.add(p.accountHash), h), new Set()),
        ]));
      const a = await r.getBatchAccountMetadata(o),
        { userID: c, accessToken: u } = s,
        l = cA(Object.values(a), iM);
      for (const d of l) await Promise.all(d.map((f) => lM(u, c, f))), await p9(s$);
      return (
        await sM(i),
        re.addBreadcrumb(
          ce.Auth,
          `✅ Uploaded synced accounts: ${t ? (t == null ? void 0 : t.join(' ')) : 'all currently synced accounts'}`,
          Ie.Info
        ),
        !0
      );
    } catch (o) {
      throw (
        (re.addBreadcrumb(
          ce.Auth,
          `Unable to sync up accounts: ${t ? (t == null ? void 0 : t.join(' ')) : 'all currently synced accounts'}`,
          Ie.Info
        ),
        re.captureError(o, ce.Auth),
        o)
      );
    }
  },
  P$ = async ({ authRepository: e, claimUsernameSigner: t, queryClient: n }, r) => {
    const i = await e.getUser();
    if (!i)
      return (
        re.addBreadcrumb(
          ce.Auth,
          `User is not logged in, unable to sync up account: ${r}`,
          Ie.Info
        ),
        !1
      );
    try {
      re.addBreadcrumb(ce.Auth, `Syncing account... : ${r}`, Ie.Info);
      const s = await t.getAccountMetadata(r),
        { userID: o, accessToken: a } = i;
      return (
        await lM(a, o, s),
        await sM(n),
        re.addBreadcrumb(ce.Auth, `✅ Synced account: ${r}`, Ie.Info),
        !0
      );
    } catch (s) {
      throw (
        (re.addBreadcrumb(ce.Auth, `Unable to sync up account: ${r}`, Ie.Info),
        re.captureError(s, ce.Auth),
        s)
      );
    }
  },
  dM = (e, t, n) => Ge.api().bearer(e).delete(gd(t, n.id), n),
  M$ = async ({ authRepository: e }) => {
    const t = await e.getUser();
    if (!t) throw new Error('User is not logged in, unable to delete all synced accounts.');
    const { userID: n, accessToken: r } = t,
      i = await Ge.api().bearer(r).get(gd(n)),
      s = AA.safeParse(i.data);
    if (!s.success)
      throw new Error(
        'Unable to delete all synced accounts => unable to parse GET /wallet-accounts response.'
      );
    const o = cA(s.data.walletAccounts, iM);
    for (const a of o) await Promise.all(a.map((c) => dM(r, n, c)));
    return !0;
  },
  O$ = async ({ authRepository: e }, t) => {
    const n = await e.getUser();
    if (!n) throw new Error(`User is not logged in, unable to remove synced account: ${t}`);
    const { userID: r, accessToken: i } = n,
      s = await Ge.api().bearer(i).get(gd(r)),
      o = AA.safeParse(s.data);
    if (!o.success)
      throw new Error(
        `Unable to delete synced account [${t}] => unable to parse GET /wallet-accounts response`
      );
    const a = o.data.walletAccounts.find((c) => c.accountHash === t);
    if (!a)
      return (
        re.addBreadcrumb(
          ce.Auth,
          `Calling deleteSyncedAccount on account that is not synced to begin with: ${t}`,
          Ie.Info
        ),
        !1
      );
    try {
      await dM(i, r, a);
    } catch (c) {
      throw (
        (re.addBreadcrumb(ce.Auth, `Unable to delete synced account: ${t}`, Ie.Info),
        re.captureError(c, ce.Auth),
        c)
      );
    }
    return !0;
  },
  B$ = async (e, t, n) => {
    re.addBreadcrumb(ce.Network, 'User is searching for actors.', Ie.Info, { query: e });
    const r = await Ge.api().bearer(t).get(r$(e)),
      i = l$.safeParse(r.data);
    return i.success ? { actors: i.data.actors } : { actors: [] };
  };
xy.userProfile()[1], xy.userSyncedAccounts()[1];
const fM = 'https://phantom.app',
  hM = 'https://api.phantom.app/oauth2/auth',
  Aw = { prod: 'https://auth.phantom.app', staging: 'https://staging-auth.phantom.app' },
  D$ = '/login/start',
  R$ = '/oauth2/token',
  N$ = we({ minutes: 60 }) - we({ minutes: 15 }),
  yd = '/v1/authentication-keys',
  ki = (e) =>
    z.from(e).toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, ''),
  j$ = 'https://time.phantom.app/utc',
  L$ = g.number().int().positive();
async function U$() {
  let e;
  try {
    const t = await Ge.get(j$);
    if (t.status !== 200) throw new Error('Failed to fetch time from server');
    e = L$.parse(t.data);
  } catch {
    e = Date.now();
  }
  return Math.floor(e / 1e3);
}
const $$ = 60,
  F$ = () => Math.floor(Date.now() / 1e3);
async function TA(e = !0) {
  const t = { alg: 'ES256', type: 'JWT' },
    n = e ? await U$() : F$(),
    r = { iss: fM, aud: hM, nbf: n, exp: n + $$, iat: n };
  return { header: t, payload: r };
}
function xA(e) {
  const t = ki(he.from(JSON.stringify(e.header))),
    n = ki(he.from(JSON.stringify(e.payload)));
  return [t, n, e.signature].join('.');
}
const z$ = g.object({ alg: g.string(), type: g.string(), kid: g.string() }),
  K$ = g.object({
    sub: g.string(),
    iss: g.string(),
    aud: g.string(),
    nbf: g.number(),
    exp: g.number(),
    iat: g.number(),
  }),
  V$ = g.object({ header: z$, payload: K$, signature: g.string() }),
  W$ = g.object({ alg: g.string(), type: g.string() }),
  H$ = g.object({
    iss: g.string(),
    aud: g.string(),
    nbf: g.number(),
    exp: g.number(),
    iat: g.number(),
  }),
  G$ = g.object({ header: W$, payload: H$ }),
  q$ = g.object({
    id_token: g.string(),
    access_token: g.string(),
    refresh_token: g.string(),
    scope: g.string(),
    token_type: g.string(),
    expires_in: g.number().gte(0),
  });
g.object({ redirectTo: g.string() });
const Y$ = g.object({
    at_hash: g.string(),
    aud: g.array(g.string()),
    auth_time: g.number(),
    exp: g.number(),
    iat: g.number(),
    iss: g.string(),
    jti: g.string(),
    rat: g.number(),
    sid: g.string(),
    sub: g.string(),
    email: g.string().optional(),
  }),
  pM = g.object({
    authenticationKeys: g
      .array(
        g.object({
          createdAt: g.string().datetime().nullish().default(null),
          updatedAt: g.string().datetime().nullish().default(null),
          id: g.string().uuid(),
          publicKey: g.string(),
          userId: g.string().uuid(),
        })
      )
      .optional(),
  });
var Yo = ((e) => (
    (e.User = 'user'),
    (e.UserID = 'userID'),
    (e.AccessToken = 'accessToken'),
    (e.Email = 'email'),
    (e.LoggedOut = 'loggedOut'),
    e
  ))(Yo || {}),
  oa = {},
  bd = {},
  li = {},
  kb = {};
kb.byteLength = X$;
kb.toByteArray = eF;
kb.fromByteArray = rF;
var ds = [],
  ri = [],
  Z$ = typeof Uint8Array < 'u' ? Uint8Array : Array,
  Iw = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var Dc = 0, J$ = Iw.length; Dc < J$; ++Dc) (ds[Dc] = Iw[Dc]), (ri[Iw.charCodeAt(Dc)] = Dc);
ri[45] = 62;
ri[95] = 63;
function gM(e) {
  var t = e.length;
  if (t % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4');
  var n = e.indexOf('=');
  n === -1 && (n = t);
  var r = n === t ? 0 : 4 - (n % 4);
  return [n, r];
}
function X$(e) {
  var t = gM(e),
    n = t[0],
    r = t[1];
  return ((n + r) * 3) / 4 - r;
}
function Q$(e, t, n) {
  return ((t + n) * 3) / 4 - n;
}
function eF(e) {
  var t,
    n = gM(e),
    r = n[0],
    i = n[1],
    s = new Z$(Q$(e, r, i)),
    o = 0,
    a = i > 0 ? r - 4 : r,
    c;
  for (c = 0; c < a; c += 4)
    (t =
      (ri[e.charCodeAt(c)] << 18) |
      (ri[e.charCodeAt(c + 1)] << 12) |
      (ri[e.charCodeAt(c + 2)] << 6) |
      ri[e.charCodeAt(c + 3)]),
      (s[o++] = (t >> 16) & 255),
      (s[o++] = (t >> 8) & 255),
      (s[o++] = t & 255);
  return (
    i === 2 &&
      ((t = (ri[e.charCodeAt(c)] << 2) | (ri[e.charCodeAt(c + 1)] >> 4)), (s[o++] = t & 255)),
    i === 1 &&
      ((t =
        (ri[e.charCodeAt(c)] << 10) |
        (ri[e.charCodeAt(c + 1)] << 4) |
        (ri[e.charCodeAt(c + 2)] >> 2)),
      (s[o++] = (t >> 8) & 255),
      (s[o++] = t & 255)),
    s
  );
}
function tF(e) {
  return ds[(e >> 18) & 63] + ds[(e >> 12) & 63] + ds[(e >> 6) & 63] + ds[e & 63];
}
function nF(e, t, n) {
  for (var r, i = [], s = t; s < n; s += 3)
    (r = ((e[s] << 16) & 16711680) + ((e[s + 1] << 8) & 65280) + (e[s + 2] & 255)), i.push(tF(r));
  return i.join('');
}
function rF(e) {
  for (var t, n = e.length, r = n % 3, i = [], s = 16383, o = 0, a = n - r; o < a; o += s)
    i.push(nF(e, o, o + s > a ? a : o + s));
  return (
    r === 1
      ? ((t = e[n - 1]), i.push(ds[t >> 2] + ds[(t << 4) & 63] + '=='))
      : r === 2 &&
        ((t = (e[n - 2] << 8) + e[n - 1]),
        i.push(ds[t >> 10] + ds[(t >> 4) & 63] + ds[(t << 2) & 63] + '=')),
    i.join('')
  );
}
var ma = {};
Object.defineProperty(ma, '__esModule', { value: !0 });
ma.AppAuthError = void 0;
var iF = (function () {
  function e(t, n) {
    (this.message = t), (this.extras = n);
  }
  return e;
})();
ma.AppAuthError = iF;
Object.defineProperty(li, '__esModule', { value: !0 });
li.DefaultCrypto = li.textEncodeLite = li.urlSafe = li.bufferToString = void 0;
var sF = kb,
  Rx = ma,
  yM = typeof window < 'u' && !!window.crypto,
  oF = yM && !!window.crypto.subtle,
  gS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
function bM(e) {
  for (var t = [], n = 0; n < e.byteLength; n += 1) {
    var r = e[n] % gS.length;
    t.push(gS[r]);
  }
  return t.join('');
}
li.bufferToString = bM;
function mM(e) {
  var t = sF.fromByteArray(new Uint8Array(e));
  return t.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
}
li.urlSafe = mM;
function wM(e) {
  for (var t = new ArrayBuffer(e.length), n = new Uint8Array(t), r = 0; r < e.length; r++)
    n[r] = e.charCodeAt(r);
  return n;
}
li.textEncodeLite = wM;
var aF = (function () {
  function e() {}
  return (
    (e.prototype.generateRandom = function (t) {
      var n = new Uint8Array(t);
      if (yM) window.crypto.getRandomValues(n);
      else for (var r = 0; r < t; r += 1) n[r] = (Math.random() * gS.length) | 0;
      return bM(n);
    }),
    (e.prototype.deriveChallenge = function (t) {
      return t.length < 43 || t.length > 128
        ? Promise.reject(new Rx.AppAuthError('Invalid code length.'))
        : oF
          ? new Promise(function (n, r) {
              crypto.subtle.digest('SHA-256', wM(t)).then(
                function (i) {
                  return n(mM(new Uint8Array(i)));
                },
                function (i) {
                  return r(i);
                }
              );
            })
          : Promise.reject(new Rx.AppAuthError('window.crypto.subtle is unavailable.'));
    }),
    e
  );
})();
li.DefaultCrypto = aF;
var oo = {},
  kA = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.IS_PROFILE = e.IS_LOG = e.setFlag = e.Flags = void 0),
    (e.Flags = { IS_LOG: !0, IS_PROFILE: !1 });
  function t(n, r) {
    e.Flags[n] = r;
  }
  (e.setFlag = t), (e.IS_LOG = e.Flags.IS_LOG), (e.IS_PROFILE = e.Flags.IS_PROFILE);
})(kA);
var yS =
  (m && m.__spreadArray) ||
  function (e, t, n) {
    if (n || arguments.length === 2)
      for (var r = 0, i = t.length, s; r < i; r++)
        (s || !(r in t)) && (s || (s = Array.prototype.slice.call(t, 0, r)), (s[r] = t[r]));
    return e.concat(s || Array.prototype.slice.call(t));
  };
Object.defineProperty(oo, '__esModule', { value: !0 });
oo.profile = oo.log = void 0;
var vM = kA;
function bS(e) {
  for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
  if (vM.Flags.IS_LOG) {
    var r = t ? t.length : 0;
    r > 0 ? console.log.apply(console, yS([e], t, !1)) : console.log(e);
  }
}
oo.log = bS;
var cF = typeof window < 'u' && !!window.performance && !!console.profile;
function uF(e, t, n) {
  return vM.Flags.IS_PROFILE ? lF(e, t, n) : n;
}
oo.profile = uF;
function lF(e, t, n) {
  var r = n.value,
    i = r.name;
  return (
    i || (i = 'anonymous function'),
    cF
      ? (n.value = function (s) {
          console.profile(i);
          var o = window.performance.now(),
            a = r.call.apply(r, yS([this || window], s, !1)),
            c = window.performance.now() - o;
          return console.log(''.concat(i, ' took ').concat(c, ' ms')), console.profileEnd(), a;
        })
      : (n.value = function (s) {
          bS('Profile start '.concat(i));
          var o = Date.now(),
            a = r.call.apply(r, yS([this || window], s, !1)),
            c = Date.now() - o;
          return bS('Profile end '.concat(i, ' took ').concat(c, ' ms.')), a;
        }),
    n
  );
}
Object.defineProperty(bd, '__esModule', { value: !0 });
bd.AuthorizationRequest = void 0;
var dF = li,
  fF = oo,
  hF = 10,
  pF = function (e) {
    return e.generateRandom(hF);
  },
  gF = (function () {
    function e(t, n, r) {
      n === void 0 && (n = new dF.DefaultCrypto()),
        r === void 0 && (r = !0),
        (this.crypto = n),
        (this.usePkce = r),
        (this.clientId = t.client_id),
        (this.redirectUri = t.redirect_uri),
        (this.scope = t.scope),
        (this.responseType = t.response_type || e.RESPONSE_TYPE_CODE),
        (this.state = t.state || pF(n)),
        (this.extras = t.extras),
        (this.internal = t.internal);
    }
    return (
      (e.prototype.setupCodeVerifier = function () {
        var t = this;
        if (this.usePkce) {
          var n = this.crypto.generateRandom(128),
            r = this.crypto.deriveChallenge(n).catch(function (i) {
              (0, fF.log)('Unable to generate PKCE challenge. Not using PKCE', i);
            });
          return r.then(function (i) {
            i &&
              ((t.internal = t.internal || {}),
              (t.internal.code_verifier = n),
              (t.extras = t.extras || {}),
              (t.extras.code_challenge = i),
              (t.extras.code_challenge_method = 'S256'));
          });
        } else return Promise.resolve();
      }),
      (e.prototype.toJson = function () {
        var t = this;
        return this.setupCodeVerifier().then(function () {
          return {
            response_type: t.responseType,
            client_id: t.clientId,
            redirect_uri: t.redirectUri,
            scope: t.scope,
            state: t.state,
            extras: t.extras,
            internal: t.internal,
          };
        });
      }),
      (e.RESPONSE_TYPE_TOKEN = 'token'),
      (e.RESPONSE_TYPE_CODE = 'code'),
      e
    );
  })();
bd.AuthorizationRequest = gF;
var CA = {},
  Cb = {};
Object.defineProperty(Cb, '__esModule', { value: !0 });
Cb.requireValidUrl = void 0;
var yF = ma;
function bF(e) {
  try {
    return new URL(e), e;
  } catch {
    throw new yF.AppAuthError('Invalid input url '.concat(e));
  }
}
Cb.requireValidUrl = bF;
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.AuthorizationRequestHandler = e.BUILT_IN_PARAMETERS = e.AuthorizationNotifier = void 0);
  var t = oo,
    n = Cb,
    r = (function () {
      function s() {
        this.listener = null;
      }
      return (
        (s.prototype.setAuthorizationListener = function (o) {
          this.listener = o;
        }),
        (s.prototype.onAuthorizationComplete = function (o, a, c) {
          this.listener && this.listener(o, a, c);
        }),
        s
      );
    })();
  (e.AuthorizationNotifier = r),
    (e.BUILT_IN_PARAMETERS = ['redirect_uri', 'client_id', 'response_type', 'state', 'scope']);
  var i = (function () {
    function s(o, a) {
      (this.utils = o), (this.crypto = a), (this.notifier = null);
    }
    return (
      (s.prototype.buildRequestUrl = function (o, a) {
        var c = {
          redirect_uri: a.redirectUri,
          client_id: a.clientId,
          response_type: a.responseType,
          state: a.state,
          scope: a.scope,
        };
        if (a.extras)
          for (var u in a.extras)
            a.extras.hasOwnProperty(u) &&
              e.BUILT_IN_PARAMETERS.indexOf(u) < 0 &&
              (c[u] = a.extras[u]);
        var l = this.utils.stringify(c),
          d = (0, n.requireValidUrl)(o.authorizationEndpoint),
          f = ''.concat(d, '?').concat(l);
        return f;
      }),
      (s.prototype.completeAuthorizationRequestIfPossible = function () {
        var o = this;
        return (
          (0, t.log)('Checking to see if there is an authorization response to be delivered.'),
          this.notifier ||
            (0, t.log)(`Notifier is not present on AuthorizationRequest handler.
          No delivery of result will be possible`),
          this.completeAuthorizationRequest().then(function (a) {
            a || (0, t.log)('No result is available yet.'),
              a && o.notifier && o.notifier.onAuthorizationComplete(a.request, a.response, a.error);
          })
        );
      }),
      (s.prototype.setAuthorizationNotifier = function (o) {
        return (this.notifier = o), this;
      }),
      s
    );
  })();
  e.AuthorizationRequestHandler = i;
})(CA);
var Xa = {};
Object.defineProperty(Xa, '__esModule', { value: !0 });
Xa.AuthorizationError = Xa.AuthorizationResponse = void 0;
var mF = (function () {
  function e(t) {
    (this.code = t.code), (this.state = t.state);
  }
  return (
    (e.prototype.toJson = function () {
      return { code: this.code, state: this.state };
    }),
    e
  );
})();
Xa.AuthorizationResponse = mF;
var wF = (function () {
  function e(t) {
    (this.error = t.error),
      (this.errorDescription = t.error_description),
      (this.errorUri = t.error_uri),
      (this.state = t.state);
  }
  return (
    (e.prototype.toJson = function () {
      return {
        error: this.error,
        error_description: this.errorDescription,
        error_uri: this.errorUri,
        state: this.state,
      };
    }),
    e
  );
})();
Xa.AuthorizationError = wF;
var Pb = {},
  di = {},
  PA =
    (m && m.__extends) ||
    (function () {
      var e = function (t, n) {
        return (
          (e =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (r, i) {
                r.__proto__ = i;
              }) ||
            function (r, i) {
              for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (r[s] = i[s]);
            }),
          e(t, n)
        );
      };
      return function (t, n) {
        if (typeof n != 'function' && n !== null)
          throw new TypeError('Class extends value ' + String(n) + ' is not a constructor or null');
        e(t, n);
        function r() {
          this.constructor = t;
        }
        t.prototype = n === null ? Object.create(n) : ((r.prototype = n.prototype), new r());
      };
    })();
Object.defineProperty(di, '__esModule', { value: !0 });
di.TestRequestor = di.FetchRequestor = di.JQueryRequestor = di.Requestor = void 0;
var mS = ma,
  Mb = (function () {
    function e() {}
    return e;
  })();
di.Requestor = Mb;
var vF = (function (e) {
  PA(t, e);
  function t() {
    return (e !== null && e.apply(this, arguments)) || this;
  }
  return (
    (t.prototype.xhr = function (n) {
      var r = $.ajax(n);
      return new Promise(function (i, s) {
        r.then(
          function (o, a, c) {
            i(o);
          },
          function (o, a, c) {
            s(new mS.AppAuthError(c));
          }
        );
      });
    }),
    t
  );
})(Mb);
di.JQueryRequestor = vF;
var _F = (function (e) {
  PA(t, e);
  function t() {
    return (e !== null && e.apply(this, arguments)) || this;
  }
  return (
    (t.prototype.xhr = function (n) {
      if (!n.url) return Promise.reject(new mS.AppAuthError('A URL must be provided.'));
      var r = new URL(n.url),
        i = {};
      if (((i.method = n.method), (i.mode = 'cors'), n.data))
        if (n.method && n.method.toUpperCase() === 'POST') i.body = n.data;
        else {
          var s = new URLSearchParams(n.data);
          s.forEach(function (c, u) {
            r.searchParams.append(u, c);
          });
        }
      if (((i.headers = {}), n.headers))
        for (var o in n.headers) n.headers.hasOwnProperty(o) && (i.headers[o] = n.headers[o]);
      var a = n.dataType && n.dataType.toLowerCase() === 'json';
      return (
        a && (i.headers.Accept = 'application/json, text/javascript, */*; q=0.01'),
        fetch(r.toString(), i).then(function (c) {
          if (c.status >= 200 && c.status < 300) {
            var u = c.headers.get('content-type');
            return a || (u && u.indexOf('application/json') !== -1) ? c.json() : c.text();
          } else return Promise.reject(new mS.AppAuthError(c.status.toString(), c.statusText));
        })
      );
    }),
    t
  );
})(Mb);
di.FetchRequestor = _F;
var SF = (function (e) {
  PA(t, e);
  function t(n) {
    var r = e.call(this) || this;
    return (r.promise = n), r;
  }
  return (
    (t.prototype.xhr = function (n) {
      return this.promise;
    }),
    t
  );
})(Mb);
di.TestRequestor = SF;
Object.defineProperty(Pb, '__esModule', { value: !0 });
Pb.AuthorizationServiceConfiguration = void 0;
var EF = di,
  AF = '.well-known',
  IF = 'openid-configuration',
  TF = (function () {
    function e(t) {
      (this.authorizationEndpoint = t.authorization_endpoint),
        (this.tokenEndpoint = t.token_endpoint),
        (this.revocationEndpoint = t.revocation_endpoint),
        (this.userInfoEndpoint = t.userinfo_endpoint),
        (this.endSessionEndpoint = t.end_session_endpoint);
    }
    return (
      (e.prototype.toJson = function () {
        return {
          authorization_endpoint: this.authorizationEndpoint,
          token_endpoint: this.tokenEndpoint,
          revocation_endpoint: this.revocationEndpoint,
          end_session_endpoint: this.endSessionEndpoint,
          userinfo_endpoint: this.userInfoEndpoint,
        };
      }),
      (e.fetchFromIssuer = function (t, n) {
        var r = ''.concat(t, '/').concat(AF, '/').concat(IF),
          i = n || new EF.JQueryRequestor();
        return i.xhr({ url: r, dataType: 'json', method: 'GET' }).then(function (s) {
          return new e(s);
        });
      }),
      e
    );
  })();
Pb.AuthorizationServiceConfiguration = TF;
var Vu = {};
Object.defineProperty(Vu, '__esModule', { value: !0 });
Vu.BasicQueryStringUtils = void 0;
var xF = (function () {
  function e() {}
  return (
    (e.prototype.parse = function (t, n) {
      return n ? this.parseQueryString(t.hash) : this.parseQueryString(t.search);
    }),
    (e.prototype.parseQueryString = function (t) {
      var n = {};
      t = t.trim().replace(/^(\?|#|&)/, '');
      for (var r = t.split('&'), i = 0; i < r.length; i += 1) {
        var s = r[i],
          o = s.split('=');
        if (o.length >= 2) {
          var a = decodeURIComponent(o.shift()),
            c = o.length > 0 ? o.join('=') : null;
          c && (n[a] = decodeURIComponent(c));
        }
      }
      return n;
    }),
    (e.prototype.stringify = function (t) {
      var n = [];
      for (var r in t)
        t.hasOwnProperty(r) &&
          t[r] &&
          n.push(''.concat(encodeURIComponent(r), '=').concat(encodeURIComponent(t[r])));
      return n.join('&');
    }),
    e
  );
})();
Vu.BasicQueryStringUtils = xF;
var Ob = {},
  Qa = {},
  kF =
    (m && m.__extends) ||
    (function () {
      var e = function (t, n) {
        return (
          (e =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (r, i) {
                r.__proto__ = i;
              }) ||
            function (r, i) {
              for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (r[s] = i[s]);
            }),
          e(t, n)
        );
      };
      return function (t, n) {
        if (typeof n != 'function' && n !== null)
          throw new TypeError('Class extends value ' + String(n) + ' is not a constructor or null');
        e(t, n);
        function r() {
          this.constructor = t;
        }
        t.prototype = n === null ? Object.create(n) : ((r.prototype = n.prototype), new r());
      };
    })();
Object.defineProperty(Qa, '__esModule', { value: !0 });
Qa.LocalStorageBackend = Qa.StorageBackend = void 0;
var _M = (function () {
  function e() {}
  return e;
})();
Qa.StorageBackend = _M;
var CF = (function (e) {
  kF(t, e);
  function t(n) {
    var r = e.call(this) || this;
    return (r.storage = n || window.localStorage), r;
  }
  return (
    (t.prototype.getItem = function (n) {
      var r = this;
      return new Promise(function (i, s) {
        var o = r.storage.getItem(n);
        i(o || null);
      });
    }),
    (t.prototype.removeItem = function (n) {
      var r = this;
      return new Promise(function (i, s) {
        r.storage.removeItem(n), i();
      });
    }),
    (t.prototype.clear = function () {
      var n = this;
      return new Promise(function (r, i) {
        n.storage.clear(), r();
      });
    }),
    (t.prototype.setItem = function (n, r) {
      var i = this;
      return new Promise(function (s, o) {
        i.storage.setItem(n, r), s();
      });
    }),
    t
  );
})(_M);
Qa.LocalStorageBackend = CF;
var PF =
  (m && m.__extends) ||
  (function () {
    var e = function (t, n) {
      return (
        (e =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (r, i) {
              r.__proto__ = i;
            }) ||
          function (r, i) {
            for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (r[s] = i[s]);
          }),
        e(t, n)
      );
    };
    return function (t, n) {
      if (typeof n != 'function' && n !== null)
        throw new TypeError('Class extends value ' + String(n) + ' is not a constructor or null');
      e(t, n);
      function r() {
        this.constructor = t;
      }
      t.prototype = n === null ? Object.create(n) : ((r.prototype = n.prototype), new r());
    };
  })();
Object.defineProperty(Ob, '__esModule', { value: !0 });
Ob.RedirectRequestHandler = void 0;
var MF = bd,
  OF = CA,
  Nx = Xa,
  BF = li,
  Kp = oo,
  DF = Vu,
  RF = Qa,
  Tw = function (e) {
    return ''.concat(e, '_appauth_authorization_request');
  },
  jx = function (e) {
    return ''.concat(e, '_appauth_authorization_service_configuration');
  },
  xw = 'appauth_current_authorization_request',
  NF = (function (e) {
    PF(t, e);
    function t(n, r, i, s) {
      n === void 0 && (n = new RF.LocalStorageBackend()),
        r === void 0 && (r = new DF.BasicQueryStringUtils()),
        i === void 0 && (i = window.location),
        s === void 0 && (s = new BF.DefaultCrypto());
      var o = e.call(this, r, s) || this;
      return (o.storageBackend = n), (o.locationLike = i), o;
    }
    return (
      (t.prototype.performAuthorizationRequest = function (n, r) {
        var i = this,
          s = this.crypto.generateRandom(10),
          o = Promise.all([
            this.storageBackend.setItem(xw, s),
            r.toJson().then(function (a) {
              return i.storageBackend.setItem(Tw(s), JSON.stringify(a));
            }),
            this.storageBackend.setItem(jx(s), JSON.stringify(n.toJson())),
          ]);
        o.then(function () {
          var a = i.buildRequestUrl(n, r);
          (0, Kp.log)('Making a request to ', r, a), i.locationLike.assign(a);
        });
      }),
      (t.prototype.completeAuthorizationRequest = function () {
        var n = this;
        return this.storageBackend.getItem(xw).then(function (r) {
          return r
            ? n.storageBackend
                .getItem(Tw(r))
                .then(function (i) {
                  return JSON.parse(i);
                })
                .then(function (i) {
                  return new MF.AuthorizationRequest(i);
                })
                .then(function (i) {
                  var s = ''.concat(n.locationLike.origin).concat(n.locationLike.pathname),
                    o = n.utils.parse(n.locationLike, !0),
                    a = o.state,
                    c = o.code,
                    u = o.error;
                  (0, Kp.log)('Potential authorization request ', s, o, a, c, u);
                  var l = a === i.state,
                    d = null,
                    f = null;
                  if (l) {
                    if (u) {
                      var h = o.error_uri,
                        p = o.error_description;
                      f = new Nx.AuthorizationError({
                        error: u,
                        error_description: p,
                        error_uri: h,
                        state: a,
                      });
                    } else d = new Nx.AuthorizationResponse({ code: c, state: a });
                    return Promise.all([
                      n.storageBackend.removeItem(xw),
                      n.storageBackend.removeItem(Tw(r)),
                      n.storageBackend.removeItem(jx(r)),
                    ]).then(function () {
                      return (
                        (0, Kp.log)('Delivering authorization response'),
                        { request: i, response: d, error: f }
                      );
                    });
                  } else
                    return (
                      (0, Kp.log)('Mismatched request (state and request_uri) dont match.'),
                      Promise.resolve(null)
                    );
                })
            : null;
        });
      }),
      t
    );
  })(OF.AuthorizationRequestHandler);
Ob.RedirectRequestHandler = NF;
var Bb = {};
Object.defineProperty(Bb, '__esModule', { value: !0 });
Bb.RevokeTokenRequest = void 0;
var jF = (function () {
  function e(t) {
    (this.token = t.token),
      (this.tokenTypeHint = t.token_type_hint),
      (this.clientId = t.client_id),
      (this.clientSecret = t.client_secret);
  }
  return (
    (e.prototype.toJson = function () {
      var t = { token: this.token };
      return (
        this.tokenTypeHint && (t.token_type_hint = this.tokenTypeHint),
        this.clientId && (t.client_id = this.clientId),
        this.clientSecret && (t.client_secret = this.clientSecret),
        t
      );
    }),
    (e.prototype.toStringMap = function () {
      var t = this.toJson();
      return t;
    }),
    e
  );
})();
Bb.RevokeTokenRequest = jF;
var aa = {};
Object.defineProperty(aa, '__esModule', { value: !0 });
aa.TokenRequest = aa.GRANT_TYPE_REFRESH_TOKEN = aa.GRANT_TYPE_AUTHORIZATION_CODE = void 0;
aa.GRANT_TYPE_AUTHORIZATION_CODE = 'authorization_code';
aa.GRANT_TYPE_REFRESH_TOKEN = 'refresh_token';
var LF = (function () {
  function e(t) {
    (this.clientId = t.client_id),
      (this.redirectUri = t.redirect_uri),
      (this.grantType = t.grant_type),
      (this.code = t.code),
      (this.refreshToken = t.refresh_token),
      (this.extras = t.extras);
  }
  return (
    (e.prototype.toJson = function () {
      return {
        grant_type: this.grantType,
        code: this.code,
        refresh_token: this.refreshToken,
        redirect_uri: this.redirectUri,
        client_id: this.clientId,
        extras: this.extras,
      };
    }),
    (e.prototype.toStringMap = function () {
      var t = {
        grant_type: this.grantType,
        client_id: this.clientId,
        redirect_uri: this.redirectUri,
      };
      if (
        (this.code && (t.code = this.code),
        this.refreshToken && (t.refresh_token = this.refreshToken),
        this.extras)
      )
        for (var n in this.extras)
          this.extras.hasOwnProperty(n) && !t.hasOwnProperty(n) && (t[n] = this.extras[n]);
      return t;
    }),
    e
  );
})();
aa.TokenRequest = LF;
var Db = {},
  MA = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.TokenError = e.TokenResponse = e.nowInSeconds = void 0);
  var t = 10 * 60 * -1,
    n = function () {
      return Math.round(new Date().getTime() / 1e3);
    };
  e.nowInSeconds = n;
  var r = (function () {
    function s(o) {
      (this.accessToken = o.access_token),
        (this.tokenType = o.token_type || 'bearer'),
        o.expires_in && (this.expiresIn = parseInt(o.expires_in, 10)),
        (this.refreshToken = o.refresh_token),
        (this.scope = o.scope),
        (this.idToken = o.id_token),
        (this.issuedAt = o.issued_at || (0, e.nowInSeconds)());
    }
    return (
      (s.prototype.toJson = function () {
        var o;
        return {
          access_token: this.accessToken,
          id_token: this.idToken,
          refresh_token: this.refreshToken,
          scope: this.scope,
          token_type: this.tokenType,
          issued_at: this.issuedAt,
          expires_in: (o = this.expiresIn) === null || o === void 0 ? void 0 : o.toString(),
        };
      }),
      (s.prototype.isValid = function (o) {
        if ((o === void 0 && (o = t), this.expiresIn)) {
          var a = (0, e.nowInSeconds)();
          return a < this.issuedAt + this.expiresIn + o;
        } else return !0;
      }),
      s
    );
  })();
  e.TokenResponse = r;
  var i = (function () {
    function s(o) {
      (this.error = o.error),
        (this.errorDescription = o.error_description),
        (this.errorUri = o.error_uri);
    }
    return (
      (s.prototype.toJson = function () {
        return {
          error: this.error,
          error_description: this.errorDescription,
          error_uri: this.errorUri,
        };
      }),
      s
    );
  })();
  e.TokenError = i;
})(MA);
Object.defineProperty(Db, '__esModule', { value: !0 });
Db.BaseTokenRequestHandler = void 0;
var UF = ma,
  $F = Vu,
  Lx = MA,
  FF = di,
  zF = (function () {
    function e(t, n) {
      t === void 0 && (t = new FF.JQueryRequestor()),
        n === void 0 && (n = new $F.BasicQueryStringUtils()),
        (this.requestor = t),
        (this.utils = n);
    }
    return (
      (e.prototype.isTokenResponse = function (t) {
        return t.error === void 0;
      }),
      (e.prototype.performRevokeTokenRequest = function (t, n) {
        var r = this.requestor.xhr({
          url: t.revocationEndpoint,
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          data: this.utils.stringify(n.toStringMap()),
        });
        return r.then(function (i) {
          return !0;
        });
      }),
      (e.prototype.performTokenRequest = function (t, n) {
        var r = this,
          i = this.requestor.xhr({
            url: t.tokenEndpoint,
            method: 'POST',
            dataType: 'json',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            data: this.utils.stringify(n.toStringMap()),
          });
        return i.then(function (s) {
          return r.isTokenResponse(s)
            ? new Lx.TokenResponse(s)
            : Promise.reject(new UF.AppAuthError(s.error, new Lx.TokenError(s)));
        });
      }),
      e
    );
  })();
Db.BaseTokenRequestHandler = zF;
var SM = {};
Object.defineProperty(SM, '__esModule', { value: !0 });
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (r, i, s, o) {
            o === void 0 && (o = s);
            var a = Object.getOwnPropertyDescriptor(i, s);
            (!a || ('get' in a ? !i.__esModule : a.writable || a.configurable)) &&
              (a = {
                enumerable: !0,
                get: function () {
                  return i[s];
                },
              }),
              Object.defineProperty(r, o, a);
          }
        : function (r, i, s, o) {
            o === void 0 && (o = s), (r[o] = i[s]);
          }),
    n =
      (m && m.__exportStar) ||
      function (r, i) {
        for (var s in r)
          s !== 'default' && !Object.prototype.hasOwnProperty.call(i, s) && t(i, r, s);
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    n(bd, e),
    n(CA, e),
    n(Xa, e),
    n(Pb, e),
    n(li, e),
    n(ma, e),
    n(kA, e),
    n(oo, e),
    n(Vu, e),
    n(Ob, e),
    n(Bb, e),
    n(Qa, e),
    n(aa, e),
    n(Db, e),
    n(MA, e),
    n(SM, e),
    n(di, e);
})(oa);
function wS(e) {
  if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`);
}
function KF(e) {
  if (typeof e != 'boolean') throw new Error(`Expected boolean, not ${e}`);
}
function EM(e, ...t) {
  if (!(e instanceof Uint8Array)) throw new TypeError('Expected Uint8Array');
  if (t.length > 0 && !t.includes(e.length))
    throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function VF(e) {
  if (typeof e != 'function' || typeof e.create != 'function')
    throw new Error('Hash should be wrapped by utils.wrapConstructor');
  wS(e.outputLen), wS(e.blockLen);
}
function WF(e, t = !0) {
  if (e.destroyed) throw new Error('Hash instance has been destroyed');
  if (t && e.finished) throw new Error('Hash#digest() has already been called');
}
function HF(e, t) {
  EM(e);
  const n = t.outputLen;
  if (e.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`);
}
const kw = { number: wS, bool: KF, bytes: EM, hash: VF, exists: WF, output: HF };
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Cw = (e) =>
    new DataView(e.buffer, e.byteOffset, e.byteLength),
  Zi = (e, t) => (e << (32 - t)) | (e >>> t),
  GF = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!GF) throw new Error('Non little-endian hardware is not supported');
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, '0'));
function qF(e) {
  if (typeof e != 'string') throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function AM(e) {
  if ((typeof e == 'string' && (e = qF(e)), !(e instanceof Uint8Array)))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
  return e;
}
let YF = class {
  clone() {
    return this._cloneInto();
  }
};
function IM(e) {
  const t = (r) => e().update(AM(r)).digest(),
    n = e();
  return (t.outputLen = n.outputLen), (t.blockLen = n.blockLen), (t.create = () => e()), t;
}
function ZF(e, t, n, r) {
  if (typeof e.setBigUint64 == 'function') return e.setBigUint64(t, n, r);
  const i = BigInt(32),
    s = BigInt(4294967295),
    o = Number((n >> i) & s),
    a = Number(n & s),
    c = r ? 4 : 0,
    u = r ? 0 : 4;
  e.setUint32(t + c, o, r), e.setUint32(t + u, a, r);
}
let JF = class extends YF {
  constructor(t, n, r, i) {
    super(),
      (this.blockLen = t),
      (this.outputLen = n),
      (this.padOffset = r),
      (this.isLE = i),
      (this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.buffer = new Uint8Array(t)),
      (this.view = Cw(this.buffer));
  }
  update(t) {
    kw.exists(this);
    const { view: n, buffer: r, blockLen: i } = this;
    t = AM(t);
    const s = t.length;
    for (let o = 0; o < s; ) {
      const a = Math.min(i - this.pos, s - o);
      if (a === i) {
        const c = Cw(t);
        for (; i <= s - o; o += i) this.process(c, o);
        continue;
      }
      r.set(t.subarray(o, o + a), this.pos),
        (this.pos += a),
        (o += a),
        this.pos === i && (this.process(n, 0), (this.pos = 0));
    }
    return (this.length += t.length), this.roundClean(), this;
  }
  digestInto(t) {
    kw.exists(this), kw.output(t, this), (this.finished = !0);
    const { buffer: n, view: r, blockLen: i, isLE: s } = this;
    let { pos: o } = this;
    (n[o++] = 128),
      this.buffer.subarray(o).fill(0),
      this.padOffset > i - o && (this.process(r, 0), (o = 0));
    for (let d = o; d < i; d++) n[d] = 0;
    ZF(r, i - 8, BigInt(this.length * 8), s), this.process(r, 0);
    const a = Cw(t),
      c = this.outputLen;
    if (c % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
    const u = c / 4,
      l = this.get();
    if (u > l.length) throw new Error('_sha2: outputLen bigger than state');
    for (let d = 0; d < u; d++) a.setUint32(4 * d, l[d], s);
  }
  digest() {
    const { buffer: t, outputLen: n } = this;
    this.digestInto(t);
    const r = t.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: n, buffer: r, length: i, finished: s, destroyed: o, pos: a } = this;
    return (
      (t.length = i), (t.pos = a), (t.finished = s), (t.destroyed = o), i % n && t.buffer.set(r), t
    );
  }
};
const XF = (e, t, n) => (e & t) ^ (~e & n),
  QF = (e, t, n) => (e & t) ^ (e & n) ^ (t & n),
  ez = new Uint32Array([
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221,
    3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580,
    3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895,
    666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037,
    2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
    1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298,
  ]),
  go = new Uint32Array([
    1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225,
  ]),
  yo = new Uint32Array(64);
let TM = class extends JF {
    constructor() {
      super(64, 32, 8, !1),
        (this.A = go[0] | 0),
        (this.B = go[1] | 0),
        (this.C = go[2] | 0),
        (this.D = go[3] | 0),
        (this.E = go[4] | 0),
        (this.F = go[5] | 0),
        (this.G = go[6] | 0),
        (this.H = go[7] | 0);
    }
    get() {
      const { A: t, B: n, C: r, D: i, E: s, F: o, G: a, H: c } = this;
      return [t, n, r, i, s, o, a, c];
    }
    set(t, n, r, i, s, o, a, c) {
      (this.A = t | 0),
        (this.B = n | 0),
        (this.C = r | 0),
        (this.D = i | 0),
        (this.E = s | 0),
        (this.F = o | 0),
        (this.G = a | 0),
        (this.H = c | 0);
    }
    process(t, n) {
      for (let d = 0; d < 16; d++, n += 4) yo[d] = t.getUint32(n, !1);
      for (let d = 16; d < 64; d++) {
        const f = yo[d - 15],
          h = yo[d - 2],
          p = Zi(f, 7) ^ Zi(f, 18) ^ (f >>> 3),
          b = Zi(h, 17) ^ Zi(h, 19) ^ (h >>> 10);
        yo[d] = (b + yo[d - 7] + p + yo[d - 16]) | 0;
      }
      let { A: r, B: i, C: s, D: o, E: a, F: c, G: u, H: l } = this;
      for (let d = 0; d < 64; d++) {
        const f = Zi(a, 6) ^ Zi(a, 11) ^ Zi(a, 25),
          h = (l + f + XF(a, c, u) + ez[d] + yo[d]) | 0,
          b = ((Zi(r, 2) ^ Zi(r, 13) ^ Zi(r, 22)) + QF(r, i, s)) | 0;
        (l = u), (u = c), (c = a), (a = (o + h) | 0), (o = s), (s = i), (i = r), (r = (h + b) | 0);
      }
      (r = (r + this.A) | 0),
        (i = (i + this.B) | 0),
        (s = (s + this.C) | 0),
        (o = (o + this.D) | 0),
        (a = (a + this.E) | 0),
        (c = (c + this.F) | 0),
        (u = (u + this.G) | 0),
        (l = (l + this.H) | 0),
        this.set(r, i, s, o, a, c, u, l);
    }
    roundClean() {
      yo.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
    }
  },
  tz = class extends TM {
    constructor() {
      super(),
        (this.A = -1056596264),
        (this.B = 914150663),
        (this.C = 812702999),
        (this.D = -150054599),
        (this.E = -4191439),
        (this.F = 1750603025),
        (this.G = 1694076839),
        (this.H = -1090891868),
        (this.outputLen = 28);
    }
  };
const nz = IM(() => new TM());
IM(() => new tz());
const rz = {
  generateRandom: (e) => {
    const t = FP.randomBytes(e);
    return oa.bufferToString(t);
  },
  async deriveChallenge(e) {
    const t = nz(oa.textEncodeLite(e));
    return oa.urlSafe(t);
  },
};
var iz = {};
const wa = () => {
    const e = cS();
    return e === Ul.Staging
      ? Aw.staging
      : e === Ul.Production
        ? Aw.prod
        : iz.BASE_AUTH_ENDPOINT || Aw.staging;
  },
  sz = () => `${wa()}${D$}`,
  OA = () => `${wa()}${R$}`,
  xM = new oa.BasicQueryStringUtils();
async function Pw(e, t) {
  const { url: n, codeVerifier: r } = await kM(e.getClientID(), e.redirectURL, t),
    i = t.type === 'email',
    s = await e.fetchAuthorizationCode(e.redirectURL, n, i);
  return await BA({
    grantType: 'authorization_code',
    clientID: e.getClientID(),
    redirectURI: e.redirectURL,
    tokenEndpoint: OA(),
    code: s,
    codeVerifier: r,
  });
}
async function kM(e, t, n) {
  var w, A, _;
  const r = sz();
  let i;
  const s = ['openid', 'offline_access', 'user', 'incognito', 'seedless'];
  let o;
  switch (n.type) {
    case 'key': {
      i = { type: 'key', jwt: xA(n.clientJWT) };
      break;
    }
    case 'email': {
      (i = { type: 'email', provider: n.provider, existingAccessToken: n.existingAccessToken }),
        (o = n.prompt),
        s.push('email');
      break;
    }
    case 'session': {
      i = { type: 'session', existingAccessToken: n.existingAccessToken };
      break;
    }
  }
  const c = await new oa.AuthorizationRequest(
    { client_id: e, redirect_uri: t, scope: s.join(' '), response_type: 'code' },
    rz
  ).toJson();
  let u;
  switch (i.type) {
    case 'key':
      u = `jwt:${ki(z.from(i.jwt, 'utf8'))}`;
      break;
    case 'email':
      (u = `sso:${i.provider}`), i.existingAccessToken && (u = `${u}:${i.existingAccessToken}`);
      break;
    case 'session':
      u = `session:${i.existingAccessToken}`;
      break;
  }
  const l = {
    redirect_uri: c.redirect_uri,
    client_id: c.client_id,
    response_type: c.response_type,
    state: c.state ?? '',
    scope: c.scope,
    login_hint: u,
  };
  o && (l.prompt = o);
  const d = (w = c.extras) == null ? void 0 : w.code_challenge,
    f = (A = c.extras) == null ? void 0 : A.code_challenge_method,
    h = (_ = c.internal) == null ? void 0 : _.code_verifier;
  if ((d && f && ((l.code_challenge = d), (l.code_challenge_method = f)), !d || !f || !h))
    throw new Error('Missing code challenge or code verifier for PKCE.');
  const p = xM.stringify(l);
  return { url: `${r}?${p}`, codeVerifier: h };
}
async function BA(e) {
  const { grantType: t, tokenEndpoint: n, clientID: r, redirectURI: i } = e;
  let s;
  t === 'authorization_code'
    ? (s = new oa.TokenRequest({
        client_id: r,
        redirect_uri: i,
        grant_type: t,
        code: e.code,
        extras: { code_verifier: e.codeVerifier },
      }))
    : (s = new oa.TokenRequest({
        client_id: r,
        redirect_uri: i,
        grant_type: t,
        refresh_token: e.refreshToken,
      }));
  const o = await Ge.headers(
    { 'Content-Type': 'application/x-www-form-urlencoded' },
    { mergeHeaders: !1 }
  )
    .auth(Uj())
    .post(n, xM.stringify(s.toStringMap()));
  oz(o, t);
  const a = q$.safeParse(o.data);
  if (!a.success) throw new Error('Invalid OAuth2Token response.');
  const { data: c } = a;
  return {
    idToken: c.id_token,
    accessToken: c.access_token,
    refreshToken: c.refresh_token,
    scope: c.scope,
    tokenType: c.token_type,
    expiresAt: Date.now() + c.expires_in * 1e3,
  };
}
async function CM(e, t) {
  return await BA({
    clientID: e.getClientID(),
    redirectURI: e.redirectURL,
    grantType: 'refresh_token',
    tokenEndpoint: OA(),
    refreshToken: t,
  });
}
function oz(e, t) {
  if ([401, 400].includes(e.status)) {
    let n = '';
    if (e.status === 401)
      switch (((n = 'Token Request Unauthorized (401): '), t)) {
        case 'authorization_code':
          n += 'Authorization code is expired or invalid.';
          break;
        case 'refresh_token':
          n += 'Refresh token is expired or invalid.';
          break;
        default:
          n += `Unknown grant type [${t}]. `;
      }
    if (e.status === 400)
      switch (((n = 'Bad Token Request (400): '), t)) {
        case 'authorization_code':
          n =
            'for [authorization_code]. Possible causes: 1. The authorization code is expired or invalid. 2. Redirect URI mismatch. 3. Code verifier mismatch (if using PKCE).';
          break;
        case 'refresh_token':
          n =
            'for [refresh_token]. Possible causes: 1. The refresh token is expired, invalid, or revoked. 2. Client ID mismatch. 3. Missing or malformed refresh token in the request.';
          break;
        default:
          n = `for unknown grant type [${t}]. Check the payload and OAuth provider documentation.`;
      }
    throw new Error(n);
  }
}
class PM {
  constructor() {
    ae(this, 'subscribers', {});
  }
  subscribe(t, n) {
    return (
      this.subscribers[t] || (this.subscribers[t] = []),
      this.subscribers[t].push(n),
      () => {
        this.subscribers[t].splice(this.subscribers[t].indexOf(n), 1);
      }
    );
  }
  emitEvent(t, ...n) {
    (this.subscribers[t] ?? []).forEach((i) => i(...n));
  }
}
class az extends PM {
  emit(t) {
    t &&
      (this.emitEvent(Yo.User, t),
      this.emitEvent(Yo.UserID, t.userID),
      this.emitEvent(Yo.AccessToken, t.accessToken),
      t.email && this.emitEvent(Yo.Email, t.email));
  }
  emitLoggedOut() {
    this.emitEvent(Yo.LoggedOut);
  }
}
function md(e, t = 'expected value not found') {
  if (e == null) throw new Error(t);
  return e;
}
const MM = async (e, t) => {
    const n = wa(),
      r = md(e.signer, 'Signer is required for key-based auth.'),
      i = await r.getAuthenticationPublicKey(t),
      s = await TA(e.isServerTimeEnabled()),
      o = await r.sign(s, t),
      a = await Ge.get(`${n}${yd}`, { params: { token: xA(o) } });
    if (!tr(a)) throw new Error('Failed to get authentication keys: response is not okay');
    const c = a.data;
    return (pM.parse(c).authenticationKeys ?? []).some((d) => d.publicKey === i);
  },
  cz = async (e) => {
    try {
      const t = await Ge.headers(
        { 'Content-Type': 'application/x-www-form-urlencoded' },
        { mergeHeaders: !1 }
      )
        .bearer(e)
        .get(`${wa()}/userinfo`);
      return tr(t);
    } catch {
      return !1;
    }
  },
  OM = '.phantom.auth',
  gu = `${OM}.tokens`,
  uz = `${OM}.authentication-factors`,
  lz = (e) => z.from(e.replace('-', '+').replace('_', '/').replace(/=+$/, ''), 'base64'),
  Cy = (e) => {
    const t = e.idToken.split('.');
    if (t.length !== 3)
      throw new Error('Malformed ID token. Expected 3 period-delimited parts to ID token.');
    let n;
    try {
      const r = lz(t[1]).toString('utf-8'),
        i = JSON.parse(r);
      n = Y$.parse(i);
    } catch {
      throw new Error('Unable to parse ID token payload.');
    }
    return { accessToken: e.accessToken, userID: n.sub, email: n.email };
  },
  Ux = '@phantom/auth',
  Rb = { user: ['auth', `${Ux}:user`], authFactors: ['auth', `${Ux}:user-auth-factors`] },
  BM = async (e, t, n) => {
    const { storage: r, authConfig: i } = e;
    let s;
    const { type: o } = n;
    switch (o) {
      case 'key': {
        const c = md(e.signer, 'Signer is required for key-based auth.'),
          u = await TA(e.isServerTimeEnabled()),
          l = await c.sign(u, n.secretIdentifier);
        s = await Pw(i, { type: o, clientJWT: l });
        break;
      }
      case 'email': {
        s = await Pw(i, { type: o, prompt: n.prompt, provider: n.provider });
        break;
      }
      case 'session': {
        s = await Pw(i, { type: o, existingAccessToken: n.accessToken });
        break;
      }
    }
    await r.set(gu, s);
    const a = Cy(s);
    return await e.queryClient.setQueryData(Rb.user, a), t.emit(a), a;
  },
  DM = { queryKey: Rb.user, gcTime: N$, staleTime: we({ minutes: 5 }) },
  wd = async (e, t) => await e.queryClient.fetchQuery({ ...DM, queryFn: () => RM(e, t) }),
  dz = (e, t) =>
    Qt({
      ...DM,
      queryFn: async () => {
        const n = await RM(e, t);
        if (!n) throw new Error('Unable to log in.');
        return n;
      },
      retryOnMount: !1,
    }),
  RM = async (e, t) => {
    const n = async () => {
      const r = await fz(e);
      return r || (e.signer ? await hz(e, t) : null);
    };
    return e.runExclusive(async () => {
      const r = await n();
      return t.emit(r), r;
    });
  };
async function fz({ storage: e, authConfig: t }) {
  const n = await e.get(gu);
  if (!n) return null;
  if (await cz(n.accessToken)) return Cy(n);
  if (n.refreshToken)
    try {
      const r = await CM(t, n.refreshToken);
      return await e.set(gu, r), Cy(r);
    } catch (r) {
      return (
        re.addBreadcrumb('Error refreshing auth token.', ce.Auth, Ie.Error),
        re.captureError(r, ce.Auth),
        null
      );
    }
  return null;
}
async function hz(e, t) {
  const r = await md(
    e.signer,
    'Unable to log in with key-based auth. Signer is not available.'
  ).getAllSecretIdentifiers();
  if (r.length === 0)
    return (
      re.addBreadcrumb(
        'Unable to log in with key-based auth. Vault is not yet onboarded or has no secrets that can perform key-based auth.',
        ce.Auth,
        Ie.Info
      ),
      null
    );
  let i;
  try {
    for (const s of r)
      if (await MM(e, s)) {
        i = s;
        break;
      }
  } catch (s) {
    throw (
      (re.addBreadcrumb(
        'Unable to log in with key-based auth. Error checking auth factors.',
        ce.Auth,
        Ie.Error
      ),
      s)
    );
  }
  if (!i)
    return (
      re.addBreadcrumb(
        'Unable to log in with key-based auth. No auth factor found for login.',
        ce.Auth,
        Ie.Info
      ),
      null
    );
  try {
    return await BM(e, t, { type: 'key', secretIdentifier: i });
  } catch (s) {
    throw (
      (re.addBreadcrumb(
        'Unable to log in with key-based auth. Error performing auth.',
        ce.Auth,
        Ie.Error
      ),
      s)
    );
  }
}
const NM = (e) => {
    const t = new az(),
      n = {
        getUser: () => wd(e, t),
        useUser: () => dz(e, t),
        refreshTokens: () => pz(e),
        logIn: (r) => BM(e, t, r),
        isExistingAuthFactor: (r) => MM(e, r),
        getAuthenticationKeys: () => gz(e, t),
        getLocalAuthenticationPublicKeys: () => yz(e),
        addAuthFactor: (r) => bz(e, t, r),
        deleteAuthFactor: (r) => mz(e, t, r),
        deleteAllAuthFactors: () => wz(e, t),
        subscribe: (r, i) => t.subscribe(r, i),
        logOut: () => vz(e, t),
      };
    return (
      zU(async () => {
        const r = await n.getUser();
        return (r == null ? void 0 : r.accessToken) ?? null;
      }),
      n
    );
  },
  pz = async (e) => {
    const t = await e.storage.get(gu);
    if (!t) return !1;
    const n = await CM(e.authConfig, t.refreshToken);
    return await e.storage.set(gu, n), await e.queryClient.setQueryData(Rb.user, Cy(n)), !0;
  },
  gz = async (e, t) => ({ authenticationPublicKeys: (await jM(e, t)).map((r) => r.publicKey) }),
  jM = async (e, t) => {
    const n = wa(),
      r = await wd(e, t);
    if (!r) throw new Error('User not authenticated.');
    const { data: i } = await Ge.bearer(r.accessToken).get(`${n}${yd}`),
      s = pM.safeParse(i);
    if (!s.success) throw new Error('Unable to parse auth factors response.');
    return s.data.authenticationKeys ?? [];
  },
  yz = async (e) => {
    try {
      const t = md(e.signer, 'Signer is required for key-based auth.'),
        n = await t.getAllSecretIdentifiers(),
        r = {};
      for (const i of n) r[i] = await t.getAuthenticationPublicKey(i);
      return r;
    } catch {
      return {};
    }
  },
  bz = async (e, t, { secretIdentifier: n }) => {
    const r = wa(),
      i = md(e.signer, 'Signer is required for key-based auth.'),
      s = await wd(e, t);
    if (!s) throw new Error('User not authenticated.');
    const o = await TA(e.isServerTimeEnabled()),
      a = await i.sign(o, n);
    await Ge.bearer(s.accessToken).post(`${r}${yd}`, { jwt: xA(a) });
  },
  mz = async (e, t, { authenticationPublicKey: n }) => {
    const r = wa(),
      i = await wd(e, t);
    if (!i) throw new Error('User not authenticated.');
    await Ge.bearer(i.accessToken).delete(`${r}${yd}/${encodeURIComponent(n)}`);
  },
  wz = async (e, t) => {
    const n = wa(),
      r = e.storage,
      i = await wd(e, t);
    if (!i) throw new Error('User not authenticated.');
    const s = await jM(e, t);
    await Promise.all(s.map((o) => Ge.bearer(i.accessToken).delete(`${n}${yd}/${o.id}`))),
      await r.remove(uz);
  },
  vz = async ({ storage: e }, t) => {
    await e.remove(gu), t.emitLoggedOut();
  },
  _z = (e, t) => {
    const n = new URL(t);
    if (!n.toString().startsWith(e))
      throw new Error(
        'Unexpected redirectURL. RedirectURL from auth flow must match local redirect URL.'
      );
    const r = n.searchParams.get('code');
    if (!r) throw new Error('No authorization code');
    return r;
  },
  Sz = (e, t) => {
    const n = new URL(t);
    if (!n.toString().startsWith(e))
      throw new Error(
        'Unexpected redirectURL. RedirectURL from auth flow must match local redirect URL.'
      );
    const r = n.searchParams.get('error'),
      i = n.searchParams.get('error_description');
    if (r) throw new Error(`${r}: ${i}`, { cause: r });
    return !1;
  },
  LM = W.createContext(null);
function Ez({ children: e, authRepository: t }) {
  return P.jsx(LM.Provider, { value: t, children: e });
}
function Az() {
  const e = W.useContext(LM);
  if (!e) throw new Error('useAuthRepository must be used within an AuthProvider');
  return e;
}
function Iz() {
  return Az().useUser();
}
const UM = () => {
    const { data: e } = Iz();
    return !!e;
  },
  Tz = async (e) => {
    await e.invalidateQueries({ queryKey: Rb.user });
  },
  $M = W.createContext(null);
function xz({ children: e, analytics: t }) {
  return P.jsx($M.Provider, { value: t, children: e });
}
function Un() {
  const e = W.useContext($M);
  if (!e) throw new Error('useAnalytics must be used within a AnalyticsProvider');
  return e;
}
const FM = W.createContext(null);
function kz({ children: e, userRepository: t, claimUsernameSigner: n }) {
  return P.jsx(FM.Provider, { value: { userRepository: t, claimUsernameSigner: n }, children: e });
}
function Cz() {
  const e = W.useContext(FM);
  if (!e) throw new Error('useUserContext must be used within a UserProvider');
  return e;
}
function zM() {
  return Cz().userRepository;
}
we({ days: 1 });
we({ minutes: 1 });
const Pz = we({ days: 1 }),
  Mz = we({ minutes: 1 }),
  Oz = (e) => {
    const t = zM(),
      n = UM();
    return Qt({
      enabled: n,
      queryKey: xy.userSyncedAccounts(),
      queryFn: async () => (await t.getSyncedAccounts()).walletAccounts,
      gcTime: Pz,
      staleTime: Mz,
      select: e,
    });
  };
function Ci(e) {
  for (var t = arguments.length, n = Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  throw Error(
    '[Immer] minified error nr: ' +
      e +
      (n.length
        ? ' ' +
          n
            .map(function (i) {
              return "'" + i + "'";
            })
            .join(',')
        : '') +
      '. Find the full error at: https://bit.ly/3cXEKWf'
  );
}
function yu(e) {
  return !!e && !!e[Yr];
}
function ec(e) {
  return (
    !!e &&
    ((function (t) {
      if (!t || typeof t != 'object') return !1;
      var n = Object.getPrototypeOf(t);
      if (n === null) return !0;
      var r = Object.hasOwnProperty.call(n, 'constructor') && n.constructor;
      return r === Object || (typeof r == 'function' && Function.toString.call(r) === $z);
    })(e) ||
      Array.isArray(e) ||
      !!e[Gx] ||
      !!e.constructor[Gx] ||
      DA(e) ||
      RA(e))
  );
}
function Zl(e, t, n) {
  n === void 0 && (n = !1),
    Wu(e) === 0
      ? (n ? Object.keys : $A)(e).forEach(function (r) {
          (n && typeof r == 'symbol') || t(r, e[r], e);
        })
      : e.forEach(function (r, i) {
          return t(i, r, e);
        });
}
function Wu(e) {
  var t = e[Yr];
  return t ? (t.i > 3 ? t.i - 4 : t.i) : Array.isArray(e) ? 1 : DA(e) ? 2 : RA(e) ? 3 : 0;
}
function vS(e, t) {
  return Wu(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function Bz(e, t) {
  return Wu(e) === 2 ? e.get(t) : e[t];
}
function KM(e, t, n) {
  var r = Wu(e);
  r === 2 ? e.set(t, n) : r === 3 ? (e.delete(t), e.add(n)) : (e[t] = n);
}
function Dz(e, t) {
  return e === t ? e !== 0 || 1 / e == 1 / t : e != e && t != t;
}
function DA(e) {
  return Lz && e instanceof Map;
}
function RA(e) {
  return Uz && e instanceof Set;
}
function Ca(e) {
  return e.o || e.t;
}
function NA(e) {
  if (Array.isArray(e)) return Array.prototype.slice.call(e);
  var t = Fz(e);
  delete t[Yr];
  for (var n = $A(t), r = 0; r < n.length; r++) {
    var i = n[r],
      s = t[i];
    s.writable === !1 && ((s.writable = !0), (s.configurable = !0)),
      (s.get || s.set) &&
        (t[i] = { configurable: !0, writable: !0, enumerable: s.enumerable, value: e[i] });
  }
  return Object.create(Object.getPrototypeOf(e), t);
}
function jA(e, t) {
  return (
    t === void 0 && (t = !1),
    LA(e) ||
      yu(e) ||
      !ec(e) ||
      (Wu(e) > 1 && (e.set = e.add = e.clear = e.delete = Rz),
      Object.freeze(e),
      t &&
        Zl(
          e,
          function (n, r) {
            return jA(r, !0);
          },
          !0
        )),
    e
  );
}
function Rz() {
  Ci(2);
}
function LA(e) {
  return e == null || typeof e != 'object' || Object.isFrozen(e);
}
function ps(e) {
  var t = zz[e];
  return t || Ci(18, e), t;
}
function $x() {
  return Jl;
}
function Mw(e, t) {
  t && (ps('Patches'), (e.u = []), (e.s = []), (e.v = t));
}
function Py(e) {
  _S(e), e.p.forEach(Nz), (e.p = null);
}
function _S(e) {
  e === Jl && (Jl = e.l);
}
function Fx(e) {
  return (Jl = { p: [], l: Jl, h: e, m: !0, _: 0 });
}
function Nz(e) {
  var t = e[Yr];
  t.i === 0 || t.i === 1 ? t.j() : (t.O = !0);
}
function Ow(e, t) {
  t._ = t.p.length;
  var n = t.p[0],
    r = e !== void 0 && e !== n;
  return (
    t.h.g || ps('ES5').S(t, e, r),
    r
      ? (n[Yr].P && (Py(t), Ci(4)),
        ec(e) && ((e = My(t, e)), t.l || Oy(t, e)),
        t.u && ps('Patches').M(n[Yr].t, e, t.u, t.s))
      : (e = My(t, n, [])),
    Py(t),
    t.u && t.v(t.u, t.s),
    e !== VM ? e : void 0
  );
}
function My(e, t, n) {
  if (LA(t)) return t;
  var r = t[Yr];
  if (!r)
    return (
      Zl(
        t,
        function (s, o) {
          return zx(e, r, t, s, o, n);
        },
        !0
      ),
      t
    );
  if (r.A !== e) return t;
  if (!r.P) return Oy(e, r.t, !0), r.t;
  if (!r.I) {
    (r.I = !0), r.A._--;
    var i = r.i === 4 || r.i === 5 ? (r.o = NA(r.k)) : r.o;
    Zl(r.i === 3 ? new Set(i) : i, function (s, o) {
      return zx(e, r, i, s, o, n);
    }),
      Oy(e, i, !1),
      n && e.u && ps('Patches').R(r, n, e.u, e.s);
  }
  return r.o;
}
function zx(e, t, n, r, i, s) {
  if (yu(i)) {
    var o = My(e, i, s && t && t.i !== 3 && !vS(t.D, r) ? s.concat(r) : void 0);
    if ((KM(n, r, o), !yu(o))) return;
    e.m = !1;
  }
  if (ec(i) && !LA(i)) {
    if (!e.h.F && e._ < 1) return;
    My(e, i), (t && t.A.l) || Oy(e, i);
  }
}
function Oy(e, t, n) {
  n === void 0 && (n = !1), e.h.F && e.m && jA(t, n);
}
function Bw(e, t) {
  var n = e[Yr];
  return (n ? Ca(n) : e)[t];
}
function Kx(e, t) {
  if (t in e)
    for (var n = Object.getPrototypeOf(e); n; ) {
      var r = Object.getOwnPropertyDescriptor(n, t);
      if (r) return r;
      n = Object.getPrototypeOf(n);
    }
}
function SS(e) {
  e.P || ((e.P = !0), e.l && SS(e.l));
}
function Dw(e) {
  e.o || (e.o = NA(e.t));
}
function ES(e, t, n) {
  var r = DA(t)
    ? ps('MapSet').N(t, n)
    : RA(t)
      ? ps('MapSet').T(t, n)
      : e.g
        ? (function (i, s) {
            var o = Array.isArray(i),
              a = {
                i: o ? 1 : 0,
                A: s ? s.A : $x(),
                P: !1,
                I: !1,
                D: {},
                l: s,
                t: i,
                k: null,
                o: null,
                j: null,
                C: !1,
              },
              c = a,
              u = AS;
            o && ((c = [a]), (u = Bl));
            var l = Proxy.revocable(c, u),
              d = l.revoke,
              f = l.proxy;
            return (a.k = f), (a.j = d), f;
          })(t, n)
        : ps('ES5').J(t, n);
  return (n ? n.A : $x()).p.push(r), r;
}
function jz(e) {
  return (
    yu(e) || Ci(22, e),
    (function t(n) {
      if (!ec(n)) return n;
      var r,
        i = n[Yr],
        s = Wu(n);
      if (i) {
        if (!i.P && (i.i < 4 || !ps('ES5').K(i))) return i.t;
        (i.I = !0), (r = Vx(n, s)), (i.I = !1);
      } else r = Vx(n, s);
      return (
        Zl(r, function (o, a) {
          (i && Bz(i.t, o) === a) || KM(r, o, t(a));
        }),
        s === 3 ? new Set(r) : r
      );
    })(e)
  );
}
function Vx(e, t) {
  switch (t) {
    case 2:
      return new Map(e);
    case 3:
      return Array.from(e);
  }
  return NA(e);
}
var Wx,
  Jl,
  UA = typeof Symbol < 'u' && typeof Symbol('x') == 'symbol',
  Lz = typeof Map < 'u',
  Uz = typeof Set < 'u',
  Hx = typeof Proxy < 'u' && Proxy.revocable !== void 0 && typeof Reflect < 'u',
  VM = UA ? Symbol.for('immer-nothing') : (((Wx = {})['immer-nothing'] = !0), Wx),
  Gx = UA ? Symbol.for('immer-draftable') : '__$immer_draftable',
  Yr = UA ? Symbol.for('immer-state') : '__$immer_state',
  $z = '' + Object.prototype.constructor,
  $A =
    typeof Reflect < 'u' && Reflect.ownKeys
      ? Reflect.ownKeys
      : Object.getOwnPropertySymbols !== void 0
        ? function (e) {
            return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
          }
        : Object.getOwnPropertyNames,
  Fz =
    Object.getOwnPropertyDescriptors ||
    function (e) {
      var t = {};
      return (
        $A(e).forEach(function (n) {
          t[n] = Object.getOwnPropertyDescriptor(e, n);
        }),
        t
      );
    },
  zz = {},
  AS = {
    get: function (e, t) {
      if (t === Yr) return e;
      var n = Ca(e);
      if (!vS(n, t))
        return (function (i, s, o) {
          var a,
            c = Kx(s, o);
          return c
            ? 'value' in c
              ? c.value
              : (a = c.get) === null || a === void 0
                ? void 0
                : a.call(i.k)
            : void 0;
        })(e, n, t);
      var r = n[t];
      return e.I || !ec(r) ? r : r === Bw(e.t, t) ? (Dw(e), (e.o[t] = ES(e.A.h, r, e))) : r;
    },
    has: function (e, t) {
      return t in Ca(e);
    },
    ownKeys: function (e) {
      return Reflect.ownKeys(Ca(e));
    },
    set: function (e, t, n) {
      var r = Kx(Ca(e), t);
      if (r != null && r.set) return r.set.call(e.k, n), !0;
      if (!e.P) {
        var i = Bw(Ca(e), t),
          s = i == null ? void 0 : i[Yr];
        if (s && s.t === n) return (e.o[t] = n), (e.D[t] = !1), !0;
        if (Dz(n, i) && (n !== void 0 || vS(e.t, t))) return !0;
        Dw(e), SS(e);
      }
      return (
        (e.o[t] === n && typeof n != 'number' && (n !== void 0 || t in e.o)) ||
        ((e.o[t] = n), (e.D[t] = !0), !0)
      );
    },
    deleteProperty: function (e, t) {
      return (
        Bw(e.t, t) !== void 0 || t in e.t ? ((e.D[t] = !1), Dw(e), SS(e)) : delete e.D[t],
        e.o && delete e.o[t],
        !0
      );
    },
    getOwnPropertyDescriptor: function (e, t) {
      var n = Ca(e),
        r = Reflect.getOwnPropertyDescriptor(n, t);
      return (
        r && {
          writable: !0,
          configurable: e.i !== 1 || t !== 'length',
          enumerable: r.enumerable,
          value: n[t],
        }
      );
    },
    defineProperty: function () {
      Ci(11);
    },
    getPrototypeOf: function (e) {
      return Object.getPrototypeOf(e.t);
    },
    setPrototypeOf: function () {
      Ci(12);
    },
  },
  Bl = {};
Zl(AS, function (e, t) {
  Bl[e] = function () {
    return (arguments[0] = arguments[0][0]), t.apply(this, arguments);
  };
}),
  (Bl.deleteProperty = function (e, t) {
    return Bl.set.call(this, e, t, void 0);
  }),
  (Bl.set = function (e, t, n) {
    return AS.set.call(this, e[0], t, n, e[0]);
  });
var Kz = (function () {
    function e(n) {
      var r = this;
      (this.g = Hx),
        (this.F = !0),
        (this.produce = function (i, s, o) {
          if (typeof i == 'function' && typeof s != 'function') {
            var a = s;
            s = i;
            var c = r;
            return function (b) {
              var w = this;
              b === void 0 && (b = a);
              for (var A = arguments.length, _ = Array(A > 1 ? A - 1 : 0), x = 1; x < A; x++)
                _[x - 1] = arguments[x];
              return c.produce(b, function (k) {
                var j;
                return (j = s).call.apply(j, [w, k].concat(_));
              });
            };
          }
          var u;
          if (
            (typeof s != 'function' && Ci(6),
            o !== void 0 && typeof o != 'function' && Ci(7),
            ec(i))
          ) {
            var l = Fx(r),
              d = ES(r, i, void 0),
              f = !0;
            try {
              (u = s(d)), (f = !1);
            } finally {
              f ? Py(l) : _S(l);
            }
            return typeof Promise < 'u' && u instanceof Promise
              ? u.then(
                  function (b) {
                    return Mw(l, o), Ow(b, l);
                  },
                  function (b) {
                    throw (Py(l), b);
                  }
                )
              : (Mw(l, o), Ow(u, l));
          }
          if (!i || typeof i != 'object') {
            if (((u = s(i)) === void 0 && (u = i), u === VM && (u = void 0), r.F && jA(u, !0), o)) {
              var h = [],
                p = [];
              ps('Patches').M(i, u, h, p), o(h, p);
            }
            return u;
          }
          Ci(21, i);
        }),
        (this.produceWithPatches = function (i, s) {
          if (typeof i == 'function')
            return function (u) {
              for (var l = arguments.length, d = Array(l > 1 ? l - 1 : 0), f = 1; f < l; f++)
                d[f - 1] = arguments[f];
              return r.produceWithPatches(u, function (h) {
                return i.apply(void 0, [h].concat(d));
              });
            };
          var o,
            a,
            c = r.produce(i, s, function (u, l) {
              (o = u), (a = l);
            });
          return typeof Promise < 'u' && c instanceof Promise
            ? c.then(function (u) {
                return [u, o, a];
              })
            : [c, o, a];
        }),
        typeof (n == null ? void 0 : n.useProxies) == 'boolean' && this.setUseProxies(n.useProxies),
        typeof (n == null ? void 0 : n.autoFreeze) == 'boolean' && this.setAutoFreeze(n.autoFreeze);
    }
    var t = e.prototype;
    return (
      (t.createDraft = function (n) {
        ec(n) || Ci(8), yu(n) && (n = jz(n));
        var r = Fx(this),
          i = ES(this, n, void 0);
        return (i[Yr].C = !0), _S(r), i;
      }),
      (t.finishDraft = function (n, r) {
        var i = n && n[Yr],
          s = i.A;
        return Mw(s, r), Ow(void 0, s);
      }),
      (t.setAutoFreeze = function (n) {
        this.F = n;
      }),
      (t.setUseProxies = function (n) {
        n && !Hx && Ci(20), (this.g = n);
      }),
      (t.applyPatches = function (n, r) {
        var i;
        for (i = r.length - 1; i >= 0; i--) {
          var s = r[i];
          if (s.path.length === 0 && s.op === 'replace') {
            n = s.value;
            break;
          }
        }
        i > -1 && (r = r.slice(i + 1));
        var o = ps('Patches').$;
        return yu(n)
          ? o(n, r)
          : this.produce(n, function (a) {
              return o(a, r);
            });
      }),
      e
    );
  })(),
  Zr = new Kz(),
  Vz = Zr.produce;
Zr.produceWithPatches.bind(Zr);
Zr.setAutoFreeze.bind(Zr);
Zr.setUseProxies.bind(Zr);
Zr.applyPatches.bind(Zr);
Zr.createDraft.bind(Zr);
Zr.finishDraft.bind(Zr);
const Wz = new Error('Failed to add user account metadata to storage');
async function Hz(e, t) {
  try {
    let n = await e.get(Ja.AccountsMetadata);
    n
      ? (n.accounts = Vz(n.accounts, (r) => {
          for (const [i, s] of Object.entries(t))
            r[i] || (r[i] = { name: '' }),
              (r[i].name = s.name),
              (r[i].icon = s.icon ?? r[i].icon),
              (r[i].balance = s.balance ?? r[i].balance),
              (r[i].connectedDevices = s.connectedDevices ?? r[i].connectedDevices);
        }))
      : (n = { version: 1, accounts: { ...t } }),
      await e.set(Ja.AccountsMetadata, n);
  } catch {
    throw Wz;
  }
}
async function Gz(e) {
  const t = await e.get(Ja.AccountsMetadata);
  return t ? t.accounts : {};
}
const qz = async (e) => {
  const t = await e.get(Ja.NetworkSetting),
    n = await ms.isFeatureEnabledAsync('enable-sui-testnet');
  if (!t) return ZP(n);
  const r = Yz(t, n);
  return Zz(e, r);
};
function Yz(e, t) {
  const n = { ...e, setting: { ...e.setting } };
  return (
    t && !n.setting[G.Sui]
      ? (n.setting[G.Sui] = ZP(t).setting[G.Sui])
      : !t && n.setting[G.Sui] && delete n.setting[G.Sui],
    n
  );
}
const Zz = async (e, t) => {
    let n = !1;
    Jz(t) && (n = !0);
    const r = t.setting[G.Solana];
    r && de.isMainnetNetworkID(r) && ((t.setting[G.Solana] = qP), (n = !0));
    const i = t.setting[G.EVM];
    return (
      i && de.isMainnetNetworkID(i) && ((t.setting[G.EVM] = YP), (n = !0)),
      n && (await e.set(Ja.NetworkSetting, t)),
      t
    );
  },
  Jz = (e) => {
    let t = !1;
    const n = e.setting[G.EVM];
    return (
      n &&
        (n.toString() === 'eip155:5' && ((e.setting[G.EVM] = mt.Ethereum.Sepolia), (t = !0)),
        n.toString() === 'eip155:80001' && ((e.setting[G.EVM] = mt.Polygon.Amoy), (t = !0))),
      t
    );
  },
  Xz = async (e, t, n) => {
    const r = await e.fetchAllAccounts();
    if (r.length === 0) return [];
    const i = t.get(Ja.DeveloperMode),
      s = qz(t),
      o = Gz(t),
      [a, c, u] = await Promise.all([i, s, o]);
    return r.map((l) => {
      let d = u[l.identifier];
      d || (d = { name: qr.t('onboardingImportAccountsAccountName', { walletIndex: '' }) });
      const f = {
        name: d.name,
        icon: d.icon,
        identifier: l.identifier,
        addresses: RU(
          l,
          n.enabledMainnetOnlyNetworkIDs,
          n.enabledAddressTypes,
          n.enabledChainIDs,
          c,
          (a == null ? void 0 : a.isDeveloperMode) ?? !1
        ),
      };
      return l.type === ee.Seed
        ? { ...f, type: ee.Seed, seedIdentifier: l.seedIdentifier, isReadOnly: !1 }
        : l.type === ee.Seedless
          ? { ...f, type: ee.Seedless, seedIdentifier: l.seedIdentifier, isReadOnly: !1 }
          : l.type === ee.ReadOnly
            ? { ...f, type: ee.ReadOnly, isReadOnly: !0 }
            : l.type === ee.PrivateKey
              ? {
                  ...f,
                  privateKeyIdentifier: l.privateKeyIdentifier,
                  type: ee.PrivateKey,
                  isReadOnly: !1,
                }
              : { ...f, type: l.type, isReadOnly: !1 };
    });
  };
function fl(e, t) {
  return typeof e == 'string' ? e === t : e.length === t.length && e.every((n, r) => n === t[r]);
}
var Qz = $j,
  eK = 1,
  tK = 4;
function nK(e) {
  return Qz(e, eK | tK);
}
var rK = nK;
const By = Sc(rK);
function iK(e) {
  return (
    (e = By(e)),
    e.accounts.forEach((t) => {
      var n;
      switch (t.type) {
        case ee.PrivateKey: {
          t.version === 1 && Dy(t.publicKey) && (t.publicKey = new Uint8Array(z.from(t.publicKey)));
          break;
        }
        case ee.ReadOnly:
          break;
        case ee.Ledger:
        case ee.Seed:
        case ee.Seedless:
          for (const r of Object.keys(t.chains))
            if (t.version === 1 && Dy((n = t.chains[r]) == null ? void 0 : n.publicKey)) {
              const i = t.chains[r];
              i && (i.publicKey = new Uint8Array(z.from(i.publicKey)));
            }
          break;
        case ee.SeedVault:
          break;
        default:
          qt();
      }
    }),
    e
  );
}
function sK(e) {
  return (
    (e = By(e)),
    e.accounts.forEach((t) => {
      var n, r;
      switch (t.type) {
        case ee.PrivateKey: {
          t.version === 1 &&
            t.publicKey instanceof Uint8Array &&
            (t.publicKey = z.from(t.publicKey).toJSON());
          break;
        }
        case ee.ReadOnly:
          break;
        case ee.Ledger:
        case ee.Seed:
        case ee.Seedless:
          for (const i of Object.keys(t.chains))
            t.version === 1 &&
              ((n = t.chains[i]) == null ? void 0 : n.publicKey) instanceof Uint8Array &&
              (t.chains[i].publicKey = z
                .from((r = t.chains[i]) == null ? void 0 : r.publicKey)
                .toJSON());
          break;
        case ee.SeedVault:
          break;
        default:
          qt();
      }
    }),
    e
  );
}
function Dy(e) {
  return (
    !!e &&
    typeof e == 'object' &&
    by('type', e) &&
    typeof e.type == 'string' &&
    by('data', e) &&
    Array.isArray(e.data) &&
    e.data.every((t) => !Number.isNaN(parseInt(t)))
  );
}
const As = '.phantom-labs.vault',
  FA = `${As}.accounts`,
  Hu = `${As}.secrets`,
  Nb = (e) => `${As}.privateKey.${e}`,
  jb = (e) => `${As}.seed.${e}`,
  Lb = (e) => `${As}.seedless.${e}`,
  Ry = `${As}.integrityCheck`;
async function vr(e) {
  const t = await YM(e);
  return (t == null ? void 0 : t.accounts) ?? [];
}
async function oK(e) {
  const t = await Is(e),
    n = new Set(t.seedIdentifiers),
    r = await vr(e);
  for (const s of r) s.type === ee.Seed && n.add(s.seedIdentifier);
  const i = [];
  for (const s of n) i.push({ identifier: s });
  return i;
}
async function WM(e) {
  const t = await Is(e),
    n = new Set(t.seedlessIdentifiers),
    r = await vr(e);
  for (const s of r) s.type === ee.Seedless && n.add(s.seedIdentifier);
  const i = [];
  for (const s of n) i.push({ identifier: s });
  return i;
}
async function Is(e) {
  const t = await e.generalStorage.get(Hu);
  return {
    privateKeyIdentifiers: (t == null ? void 0 : t.privateKeyIdentifiers) ?? [],
    seedIdentifiers: (t == null ? void 0 : t.seedIdentifiers) ?? [],
    seedlessIdentifiers: (t == null ? void 0 : t.seedlessIdentifiers) ?? [],
  };
}
async function aK(e, t) {
  const n = jb(t);
  let r = await e.secretsStorage.getSecureValue(n);
  if (r === null) {
    const i = Lb(t);
    r = await e.secretsStorage.getSecureValue(i);
  }
  if (r == null) throw new SA();
  return (
    Dy(r.entropy)
      ? (r.entropy = new Uint8Array(z.from(r.entropy)))
      : (r.entropy = new Uint8Array(Object.values(r.entropy))),
    r
  );
}
async function Ub(e, t) {
  const n = Nb(t),
    r = await e.secretsStorage.getSecureValue(n);
  if (r == null) throw new XP();
  return (
    Dy(r.privateKey)
      ? (r.privateKey = new Uint8Array(z.from(r.privateKey)))
      : (r.privateKey = new Uint8Array(Object.values(r.privateKey))),
    r
  );
}
async function va(e, t, n = !0) {
  let r = await YM(e);
  if (!r) r = { version: 1, accounts: [t] };
  else {
    let i = r.accounts;
    const s = hK(i, t);
    if (s.length > 0) {
      if (!n) throw new Iy(s[0].type, t.type);
      const o = Yx(t.type);
      for (const c of s) if (Yx(c.type) >= o) throw new Iy(c.type, t.type);
      const a = s.map((c) => c.identifier);
      return (
        (i = i.filter((c) => !a.includes(c.identifier))), i.push(t), await tc(e, i), await HM(e)
      );
    } else i.push(t);
    r.accounts = i;
  }
  return tc(e, r.accounts);
}
async function tc(e, t) {
  const n = { version: 1, accounts: t };
  return e.generalStorage.set(FA, sK(n));
}
async function cK(e, t) {
  const n = Nb(t.identifier);
  await e.secretsStorage.setSecureValue(n, t), await yK(e, t.identifier);
}
async function uK(e, t) {
  const n = jb(t.identifier);
  await e.secretsStorage.setSecureValue(n, t), await pK(e, t.identifier);
}
async function lK(e, t) {
  const n = Lb(t.identifier);
  await e.secretsStorage.setSecureValue(n, t), await gK(e, t.identifier);
}
async function HM(e) {
  const t = await vr(e),
    n = new Set(),
    r = new Set();
  for (const a of t)
    switch (a.type) {
      case ee.Seed:
      case ee.Seedless:
        n.add(a.seedIdentifier);
        break;
      case ee.PrivateKey:
        r.add(a.privateKeyIdentifier);
        break;
      case ee.Ledger:
      case ee.ReadOnly:
      case ee.SeedVault:
        break;
      default:
        qt();
    }
  const i = await Is(e),
    s = {
      seedIdentifiers: i.seedIdentifiers.filter((a) => n.has(a)),
      seedlessIdentifiers: i.seedlessIdentifiers.filter((a) => n.has(a)),
      privateKeyIdentifiers: i.privateKeyIdentifiers.filter((a) => r.has(a)),
    },
    o = {
      seedIdentifiers: i.seedIdentifiers.filter((a) => !n.has(a)),
      seedlessIdentifiers: i.seedlessIdentifiers.filter((a) => !n.has(a)),
      privateKeyIdentifiers: i.privateKeyIdentifiers.filter((a) => !r.has(a)),
    };
  await e.generalStorage.set(Hu, { version: 1, ...s }),
    await e.secretsStorage.removeSecureValue([
      ...o.seedIdentifiers.map((a) => jb(a)),
      ...o.seedlessIdentifiers.map((a) => Lb(a)),
      ...o.privateKeyIdentifiers.map((a) => Nb(a)),
    ]);
}
async function GM(e, t) {
  t ? await e.secretsStorage.setSecureValue(Ry, t) : await e.secretsStorage.removeSecureValue(Ry);
}
async function qM(e) {
  return e.secretsStorage.getSecureValue(Ry);
}
async function dK(e) {
  await e.generalStorage.remove(FA);
  const t = await Is(e),
    n = t.privateKeyIdentifiers.map((s) => Nb(s)),
    r = t.seedIdentifiers.map((s) => jb(s)),
    i = t.seedlessIdentifiers.map((s) => Lb(s));
  await e.secretsStorage.removeSecureValue([...n, ...i, ...r]),
    await e.generalStorage.remove(Hu),
    await e.secretsStorage.removeSecureValue(Ry),
    await e.secureCache.clear();
}
async function YM(e) {
  let t = await e.generalStorage.get(FA);
  return t ? ((t = iK(t)), (t = await fK(e, t)), t) : null;
}
async function fK(e, t) {
  let n = !1;
  return (
    t.accounts.forEach((r) => {
      switch (r.type) {
        case ee.PrivateKey: {
          n = qx(r) || n;
          break;
        }
        case ee.ReadOnly:
          break;
        case ee.Ledger:
        case ee.Seed:
        case ee.Seedless:
          Object.values(r.chains).forEach((i) => {
            n = qx(i) || n;
          });
          break;
        case ee.SeedVault:
          break;
        default:
          qt();
      }
    }),
    n && (await tc(e, t.accounts)),
    t
  );
}
function qx(e) {
  let t = !1;
  switch (e.chainType) {
    case G.BitcoinTaproot:
    case G.BitcoinNativeSegwit:
    case G.BitcoinNestedSegwit:
    case G.BitcoinLegacy: {
      Object.values(Vi).forEach((n) => {
        if (e.addresses && e.addresses[n]) return;
        const r = eo({ publicKey: e.publicKey, addressType: e.chainType, networkID: n });
        (e.addresses = { ...e.addresses, [n]: r }), (t = !0);
      });
      break;
    }
  }
  return t;
}
function hK(e, t) {
  const n = [],
    r = [];
  switch (t.type) {
    case ee.Seed:
    case ee.Seedless:
    case ee.Ledger: {
      Object.values(t.chains).forEach((s) => {
        switch (s.chainType) {
          case G.EVM:
          case G.Solana: {
            r.push(s.publicKey);
            break;
          }
          case G.BitcoinTaproot:
          case G.BitcoinNativeSegwit:
          case G.BitcoinNestedSegwit:
          case G.BitcoinLegacy: {
            n.push(s.publicKey);
            break;
          }
          case G.Sui: {
            r.push(s.address);
            break;
          }
          default:
            qt();
        }
      });
      break;
    }
    case ee.ReadOnly: {
      Object.values(t.addresses).forEach((s) => {
        r.push(s);
      });
      break;
    }
    case ee.PrivateKey: {
      switch (t.chainType) {
        case G.EVM:
        case G.Solana: {
          r.push(t.publicKey);
          break;
        }
        case G.BitcoinTaproot:
        case G.BitcoinNativeSegwit:
        case G.BitcoinNestedSegwit:
        case G.BitcoinLegacy: {
          n.push(t.publicKey);
          break;
        }
        case G.Sui: {
          r.push(t.address);
          break;
        }
        default:
          qt();
      }
      break;
    }
    case ee.SeedVault: {
      r.push(t.publicKey);
      break;
    }
    default:
      ((s) => {
        throw new Error('unknown account type');
      })();
  }
  const i = [];
  for (const s of e) {
    let o;
    switch (s.type) {
      case ee.Seed:
      case ee.Seedless:
      case ee.Ledger: {
        o = Object.values(s.chains).some((a) => {
          switch (a.chainType) {
            case G.EVM:
            case G.Solana:
              return !!r.find((c) => fl(c, a.publicKey));
            case G.BitcoinTaproot:
            case G.BitcoinNativeSegwit:
            case G.BitcoinNestedSegwit:
            case G.BitcoinLegacy:
            case G.Sui:
              return !!n.find((c) => fl(c, a.publicKey));
            default:
              qt();
          }
        });
        break;
      }
      case ee.ReadOnly: {
        o = Object.values(s.addresses).some((a) => !!r.find((c) => fl(c, a)));
        break;
      }
      case ee.PrivateKey: {
        o = !!r.find((a) => fl(a, s.publicKey));
        break;
      }
      case ee.SeedVault: {
        o = !!r.find((a) => fl(a, s.publicKey));
        break;
      }
      default:
        ((a) => {
          throw new Error('unknown account type');
        })();
    }
    o && i.push(s);
  }
  return i;
}
async function pK(e, t) {
  const n = await Is(e);
  return (
    (n.seedIdentifiers = [...new Set([...n.seedIdentifiers, t])]),
    e.generalStorage.set(Hu, { version: 1, ...n })
  );
}
async function gK(e, t) {
  const n = await Is(e);
  return (
    (n.seedlessIdentifiers = [...new Set([...n.seedlessIdentifiers, t])]),
    e.generalStorage.set(Hu, { version: 1, ...n })
  );
}
async function yK(e, t) {
  const n = await Is(e);
  return (
    (n.privateKeyIdentifiers = [...new Set([...n.privateKeyIdentifiers, t])]),
    e.generalStorage.set(Hu, { version: 1, ...n })
  );
}
function Yx(e) {
  switch (e) {
    case ee.ReadOnly:
      return 1;
    case ee.PrivateKey:
      return 2;
    case ee.Seedless:
    case ee.Seed:
      return 3;
    case ee.Ledger:
      return 4;
    case ee.SeedVault:
      return 5;
    default:
      return 0;
  }
}
const bK = g.array(
    g.object({
      address: g.string(),
      signingIndexes: g.array(g.number()),
      sigHash: g.number().optional(),
      isScriptSpend: g.boolean().optional(),
    })
  ),
  mK = g.object({
    chainType: uA,
    signingType: g.literal('transaction'),
    message: g.string().min(1),
    inputsToSign: bK.optional(),
    finalize: g.boolean(),
  }),
  wK = g.object({
    chainType: uA,
    signingType: g.literal('message'),
    message: g.instanceof(Uint8Array),
  }),
  vK = mK.or(wK),
  _K = g.object({
    chainType: g.literal(G.Sui),
    signingType: g.literal('transaction'),
    transaction: g.instanceof(Uint8Array),
  }),
  SK = g.object({
    chainType: g.literal(G.Sui),
    signingType: g.literal('personalMessage'),
    message: g.instanceof(Uint8Array),
  }),
  EK = _K.or(SK),
  AK = g.object({
    chainType: g.literal(G.Solana),
    signingType: g.literal('transaction'),
    message: g.union([g.string().min(1), g.instanceof(Uint8Array)]),
  }),
  IK = g.object({
    chainType: g.literal(G.Solana),
    signingType: g.literal('message'),
    message: g.string().min(1),
  }),
  ZM = AK.or(IK),
  TK = g.object({
    chainType: g.literal(G.EVM),
    signingType: g.literal('transaction'),
    message: g.string().min(1),
  }),
  JM = g.object({
    chainType: g.literal(G.EVM),
    signingType: g.literal('message'),
    message: g.string().min(1),
  }),
  XM = g.object({
    chainType: g.literal(G.EVM),
    signingType: g.literal('typedData'),
    version: g.literal(1),
    data: g9,
  }),
  QM = g.object({
    chainType: g.literal(G.EVM),
    signingType: g.literal('typedData'),
    version: g.literal(3),
    data: y9,
  }),
  e6 = g.object({
    chainType: g.literal(G.EVM),
    signingType: g.literal('typedData'),
    version: g.literal(4),
    data: b9,
  }),
  xK = TK.or(JM).or(XM).or(QM).or(e6),
  kK = g.object({ isJWT: g.literal(!0), data: G$ }),
  CK = g.object({ isCash: g.literal(!0), data: ZM }),
  PK = JM.extend({ isAgentWallet: g.literal(!0) }),
  MK = XM.extend({ isAgentWallet: g.literal(!0) }),
  OK = QM.extend({ isAgentWallet: g.literal(!0) }),
  BK = e6.extend({ isAgentWallet: g.literal(!0) }),
  DK = g.union([PK, MK, OK, BK]),
  RK = g.object({ status: g.literal('success'), signature: g.string() }),
  t6 = g.object({ status: g.literal('success'), signature: g.string() }),
  NK = g.object({
    status: g.literal('success'),
    signature: g.string(),
    message: g.instanceof(Uint8Array).optional(),
  }),
  jK = g.object({ status: g.literal('success'), signature: g.string() }),
  LK = g.object({ status: g.literal('success'), signature: g.string(), signedJWT: V$.optional() }),
  UK = t6,
  $K = ZM.or(xK).or(vK).or(EK).or(kK).or(DK).or(CK);
var at = ((e) => (
  (e.InvalidInput = 'invalidInput'),
  (e.InvalidAccountId = 'invalidAccountId'),
  (e.InvalidAddressType = 'invalidAddressType'),
  (e.InvalidMessageEncoding = 'invalidMessageEncoding'),
  (e.InvalidDerivationPath = 'invalidDerivationPath'),
  (e.LedgerAppNotOpen = 'ledgerAppNotOpen'),
  (e.LedgerNotConnected = 'ledgerNotConnected'),
  (e.LedgerNeedPermission = 'ledgerNeedPermission'),
  (e.LedgerRejectAction = 'ledgerRejectAction'),
  (e.LedgerUnknownSignError = 'ledgerUnknownSignError'),
  (e.UnsupportedOperation = 'unsupportedOperation'),
  (e.InternalError = 'internalError'),
  (e.ExpiredTokenError = 'expiredToken'),
  (e.BeforeIATError = 'beforeTimeOfIssuance'),
  (e.InvalidClaimError = 'invalidClaim'),
  e
))(at || {});
const FK = g.object({ status: g.literal('error'), type: g.nativeEnum(at), message: g.string() });
g.union([LK, UK, NK, RK, t6, jK, FK]);
var Kr = ((e) => ((e.KeyPair = 'keyPair'), (e.Ledger = 'ledger'), (e.SeedVault = 'seedVault'), e))(
  Kr || {}
);
const zK = {
    [at.InvalidInput]: { message: 'Invalid input' },
    [at.InvalidAccountId]: { message: 'Invalid account identifier.' },
    [at.InvalidAddressType]: { message: 'Invalid chain type.' },
    [at.InvalidMessageEncoding]: { message: 'Invalid message encoding.' },
    [at.InvalidDerivationPath]: { message: 'Invalid derivation path.' },
    [at.LedgerAppNotOpen]: { message: 'Ledger App not open.' },
    [at.LedgerNotConnected]: { message: 'Ledger not connected.' },
    [at.LedgerNeedPermission]: { message: 'Need permission to connect to Ledger.' },
    [at.LedgerRejectAction]: { message: 'Ledger user rejected action.' },
    [at.LedgerUnknownSignError]: { message: 'Ledger unknown sign error.' },
    [at.UnsupportedOperation]: { message: 'Unsupported operation.' },
    [at.InternalError]: { message: 'Internal error.' },
    [at.ExpiredTokenError]: { message: 'Token is expired' },
    [at.BeforeIATError]: { message: 'Received token before issuance time' },
    [at.InvalidClaimError]: { message: 'Claim is invalid' },
  },
  an = (e, t) => ({ status: 'error', type: e, message: t ?? zK[e].message }),
  KK = () => ({
    type: Kr.KeyPair,
    sign: (e, t) => {
      try {
        switch (t.signingType) {
          case 'typedData': {
            switch (t.version) {
              case 1: {
                const n = he.from(e.privateKey.slice()),
                  r = Ar.SignTypedDataVersion.V1,
                  { data: i } = t,
                  s = Ar.signTypedData({ privateKey: n, version: r, data: i });
                return n.fill(0), Promise.resolve({ status: 'success', signature: s });
              }
              case 3: {
                const n = he.from(e.privateKey.slice()),
                  r = Ar.SignTypedDataVersion.V3,
                  i = t.data,
                  s = Ar.signTypedData({ privateKey: n, version: r, data: i });
                return n.fill(0), Promise.resolve({ status: 'success', signature: s });
              }
              case 4: {
                const n = he.from(e.privateKey.slice()),
                  r = Ar.SignTypedDataVersion.V4,
                  i = t.data,
                  s = Ar.signTypedData({ privateKey: n, version: r, data: i });
                return n.fill(0), Promise.resolve({ status: 'success', signature: s });
              }
            }
            break;
          }
          case 'message': {
            const n = t.message,
              r = he.from(e.privateKey);
            try {
              const i = Ar.personalSign({ privateKey: r, data: n });
              return Promise.resolve({ status: 'success', signature: i });
            } finally {
              r.fill(0);
            }
          }
        }
      } catch (n) {
        return console.error(n), Promise.resolve(an(at.InvalidMessageEncoding));
      }
    },
  }),
  Zx = {
    node: void 0,
    web: typeof globalThis == 'object' && 'crypto' in globalThis ? globalThis.crypto : void 0,
  };
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Ug = (e) =>
    new DataView(e.buffer, e.byteOffset, e.byteLength),
  Ji = (e, t) => (e << (32 - t)) | (e >>> t),
  VK = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!VK) throw new Error('Non little-endian hardware is not supported');
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, '0'));
function WK(e) {
  if (typeof e != 'string') throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function Xl(e) {
  if ((typeof e == 'string' && (e = WK(e)), !(e instanceof Uint8Array)))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
  return e;
}
let n6 = class {
  clone() {
    return this._cloneInto();
  }
};
const HK = (e) =>
  Object.prototype.toString.call(e) === '[object Object]' && e.constructor === Object;
function GK(e, t) {
  if (t !== void 0 && (typeof t != 'object' || !HK(t)))
    throw new TypeError('Options should be object or undefined');
  return Object.assign(e, t);
}
function r6(e) {
  const t = (r) => e().update(Xl(r)).digest(),
    n = e();
  return (t.outputLen = n.outputLen), (t.blockLen = n.blockLen), (t.create = () => e()), t;
}
function $g(e = 32) {
  if (Zx.web) return Zx.web.getRandomValues(new Uint8Array(e));
  throw new Error("The environment doesn't have randomBytes function");
}
const qK = (e) => (e.length === 32 ? e : e.slice(1, 33));
function YK(e) {
  return he.concat([yA.encode(e.byteLength), e]);
}
function ZK(e) {
  const { sha256: t } = bi.crypto,
    r = t(he.from('BIP0322-signed-message'));
  return t(he.concat([r, r, he.from(e)])).toString('hex');
}
const JK = (e, t) => {
    switch (e) {
      case G.BitcoinTaproot:
        return dL.getPublicKey(t);
      case G.BitcoinNestedSegwit:
        return lS(t, !0);
      case G.BitcoinNativeSegwit:
        return lS(t, !0);
      default:
        throw new Error('Unsupported Address Type');
    }
  },
  XK = (e, t) => {
    const n = zL;
    switch (e) {
      case G.BitcoinTaproot:
        return $L(t, void 0, n);
      case G.BitcoinNativeSegwit:
        return Ix(t, n);
      case G.BitcoinNestedSegwit: {
        const r = Ix(t, n);
        return UL(r, n);
      }
      default:
        throw new Error('Unsupported Address Type');
    }
  };
function QK(e, t, n, r) {
  const i = dS.fromPSBT(n, { allowUnknownInputs: !0 });
  try {
    t.forEach((s) => {
      const o = bs(Vi.Mainnet, s.address),
        a = e[o];
      if (!a) throw new Error('missing private key for (' + o + ')');
      const { publicKey: c, privateKey: u } = a;
      s.signingIndexes.forEach((l) => {
        var h;
        const d = i.getInput(l),
          f = ((h = d.witnessUtxo) == null ? void 0 : h.script) && FL.decode(d.witnessUtxo.script);
        if (
          (!s.isScriptSpend &&
            !d.tapInternalKey &&
            (f == null ? void 0 : f.type) === 'tr' &&
            i.updateInput(l, { tapInternalKey: qK(he.from(c)) }),
          s.sigHash)
        )
          try {
            i.signIdx(u, l, [s.sigHash], $g(32));
          } catch {
            i.signIdx(u, l, void 0, $g(32));
          }
        else i.signIdx(u, l, void 0, $g(32));
        if (r)
          try {
            i.finalizeIdx(l);
          } catch {}
      });
    });
  } catch (s) {
    throw (console.error(s), new Error(`Error signing PSBT ${s.toString()}`));
  }
  return Promise.resolve(i.toPSBT(0));
}
const Vp = () => ({
    type: Kr.KeyPair,
    sign: async (e, t) => {
      var n, r, i;
      try {
        switch (t.signingType) {
          case 'message': {
            const s = t.chainType,
              o = he.from(t.message).toString('utf8'),
              a = (n = e[t.chainType]) == null ? void 0 : n.privateKey;
            if (!a) throw new Error('missing private key for (' + t.chainType + ')');
            const c = he.from(a).toString('hex'),
              u = JK(s, c),
              l = XK(s, u),
              d = he.from(
                '0000000000000000000000000000000000000000000000000000000000000000',
                'hex'
              ),
              f = 0,
              h = 4294967295,
              p = 0,
              b = Ax.encode(['OP_0', he.from(ZK(o), 'hex')]),
              w = new dS({ allowUnknownOutputs: !0, version: f });
            w.addOutput({ amount: BigInt(0), script: l.script }),
              w.addInput({ txid: d, index: h, sequence: p, finalScriptSig: b });
            const A = new dS({ allowUnknownOutputs: !0, version: f });
            A.addInput({
              txid: w.id,
              index: 0,
              sequence: p,
              tapInternalKey: s === G.BitcoinTaproot ? u : void 0,
              witnessUtxo: { script: l.script, amount: BigInt(0) },
              redeemScript: l.redeemScript,
            }),
              A.addOutput({ script: Ax.encode(['RETURN']), amount: BigInt(0) }),
              A.sign(he.from(c, 'hex'), void 0, $g(32)),
              A.finalize();
            let _ = null;
            const x = A.getInput(0);
            if ((r = x.finalScriptWitness) != null && r.length) {
              const k = yA.encode((i = x.finalScriptWitness) == null ? void 0 : i.length);
              _ = he.concat([k, ...x.finalScriptWitness.map((j) => YK(j))]);
            } else throw new Error('couldnt produce a signature');
            return { status: 'success', signature: _.toString('hex'), message: A.toBytes() };
          }
          case 'transaction': {
            const s = await QK(
              e,
              t.inputsToSign ?? [],
              he.from(t.message ?? '', 'hex'),
              t.finalize ?? !1
            );
            return { status: 'success', signature: he.from(s).toString('hex') };
          }
        }
      } catch {
        return an(at.InternalError);
      }
    },
  }),
  eV = () => ({
    type: Kr.KeyPair,
    sign: (e, t) => {
      const n = t.data;
      if (n.chainType !== G.Solana) return Promise.resolve(an(at.InvalidAddressType));
      let r;
      try {
        typeof n.message == 'string'
          ? n.signingType === 'transaction'
            ? (r = or.decode(n.message))
            : (r = z.from(n.message, 'utf8'))
          : (r = n.message);
      } catch {
        return Promise.resolve(an(at.InvalidMessageEncoding));
      }
      const i = or.encode($s.sign.detached(r, e.privateKey));
      return Promise.resolve({ status: 'success', signature: i });
    },
  }),
  tV = () => ({
    type: Kr.KeyPair,
    sign: (e, t) => {
      try {
        switch (t.signingType) {
          case 'typedData': {
            switch (t.version) {
              case 1: {
                const n = he.from(e.privateKey.slice()),
                  r = Ar.SignTypedDataVersion.V1,
                  { data: i } = t,
                  s = Ar.signTypedData({ privateKey: n, version: r, data: i });
                return n.fill(0), Promise.resolve({ status: 'success', signature: s });
              }
              case 3: {
                const n = he.from(e.privateKey.slice()),
                  r = Ar.SignTypedDataVersion.V3,
                  i = t.data,
                  s = Ar.signTypedData({ privateKey: n, version: r, data: i });
                return n.fill(0), Promise.resolve({ status: 'success', signature: s });
              }
              case 4: {
                const n = he.from(e.privateKey.slice()),
                  r = Ar.SignTypedDataVersion.V4,
                  i = t.data,
                  s = Ar.signTypedData({ privateKey: n, version: r, data: i });
                return n.fill(0), Promise.resolve({ status: 'success', signature: s });
              }
            }
            break;
          }
          case 'message': {
            const n = t.message,
              r = Ar.personalSign({ privateKey: he.from(e.privateKey), data: n });
            return Promise.resolve({ status: 'success', signature: r });
          }
          case 'transaction': {
            const n = he.from(t.message.replace('0x', ''), 'hex'),
              r = new HL(e.privateKey),
              i = `0x${_c.keccak256(n)}`,
              s = PL(r.signDigest(i));
            return Promise.resolve({ status: 'success', signature: s });
          }
        }
      } catch (n) {
        return console.error(n), Promise.resolve(an(at.InvalidMessageEncoding));
      }
    },
  });
function Jx(e) {
  if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`);
}
function nV(e) {
  return (
    e instanceof Uint8Array ||
    (e != null && typeof e == 'object' && e.constructor.name === 'Uint8Array')
  );
}
function i6(e, ...t) {
  if (!nV(e)) throw new Error('Expected Uint8Array');
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function rV(e) {
  if (typeof e != 'function' || typeof e.create != 'function')
    throw new Error('Hash should be wrapped by utils.wrapConstructor');
  Jx(e.outputLen), Jx(e.blockLen);
}
function Ny(e, t = !0) {
  if (e.destroyed) throw new Error('Hash instance has been destroyed');
  if (t && e.finished) throw new Error('Hash#digest() has already been called');
}
function iV(e, t) {
  i6(e);
  const n = t.outputLen;
  if (e.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`);
}
const Rw = typeof globalThis == 'object' && 'crypto' in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function s6(e) {
  return (
    e instanceof Uint8Array ||
    (e != null && typeof e == 'object' && e.constructor.name === 'Uint8Array')
  );
}
const Nw = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength),
  Xi = (e, t) => (e << (32 - t)) | (e >>> t),
  sV = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!sV) throw new Error('Non little-endian hardware is not supported');
function oV(e) {
  if (typeof e != 'string') throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function zA(e) {
  if ((typeof e == 'string' && (e = oV(e)), !s6(e)))
    throw new Error(`expected Uint8Array, got ${typeof e}`);
  return e;
}
function aV(...e) {
  let t = 0;
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    if (!s6(i)) throw new Error('Uint8Array expected');
    t += i.length;
  }
  const n = new Uint8Array(t);
  for (let r = 0, i = 0; r < e.length; r++) {
    const s = e[r];
    n.set(s, i), (i += s.length);
  }
  return n;
}
let o6 = class {
  clone() {
    return this._cloneInto();
  }
};
function cV(e) {
  const t = (r) => e().update(zA(r)).digest(),
    n = e();
  return (t.outputLen = n.outputLen), (t.blockLen = n.blockLen), (t.create = () => e()), t;
}
function uV(e = 32) {
  if (Rw && typeof Rw.getRandomValues == 'function') return Rw.getRandomValues(new Uint8Array(e));
  throw new Error('crypto.getRandomValues must be defined');
}
let a6 = class extends o6 {
  constructor(t, n) {
    super(), (this.finished = !1), (this.destroyed = !1), rV(t);
    const r = zA(n);
    if (((this.iHash = t.create()), typeof this.iHash.update != 'function'))
      throw new Error('Expected instance of class which extends utils.Hash');
    (this.blockLen = this.iHash.blockLen), (this.outputLen = this.iHash.outputLen);
    const i = this.blockLen,
      s = new Uint8Array(i);
    s.set(r.length > i ? t.create().update(r).digest() : r);
    for (let o = 0; o < s.length; o++) s[o] ^= 54;
    this.iHash.update(s), (this.oHash = t.create());
    for (let o = 0; o < s.length; o++) s[o] ^= 106;
    this.oHash.update(s), s.fill(0);
  }
  update(t) {
    return Ny(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    Ny(this),
      i6(t, this.outputLen),
      (this.finished = !0),
      this.iHash.digestInto(t),
      this.oHash.update(t),
      this.oHash.digestInto(t),
      this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n, iHash: r, finished: i, destroyed: s, blockLen: o, outputLen: a } = this;
    return (
      (t = t),
      (t.finished = i),
      (t.destroyed = s),
      (t.blockLen = o),
      (t.outputLen = a),
      (t.oHash = n._cloneInto(t.oHash)),
      (t.iHash = r._cloneInto(t.iHash)),
      t
    );
  }
  destroy() {
    (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
  }
};
const c6 = (e, t, n) => new a6(e, t).update(n).digest();
c6.create = (e, t) => new a6(e, t);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const u6 = BigInt(0),
  $b = BigInt(1),
  lV = BigInt(2);
function ws(e) {
  return (
    e instanceof Uint8Array ||
    (e != null && typeof e == 'object' && e.constructor.name === 'Uint8Array')
  );
}
const dV = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, '0'));
function bu(e) {
  if (!ws(e)) throw new Error('Uint8Array expected');
  let t = '';
  for (let n = 0; n < e.length; n++) t += dV[e[n]];
  return t;
}
function l6(e) {
  const t = e.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
function KA(e) {
  if (typeof e != 'string') throw new Error('hex string expected, got ' + typeof e);
  return BigInt(e === '' ? '0' : `0x${e}`);
}
const Ps = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function Xx(e) {
  if (e >= Ps._0 && e <= Ps._9) return e - Ps._0;
  if (e >= Ps._A && e <= Ps._F) return e - (Ps._A - 10);
  if (e >= Ps._a && e <= Ps._f) return e - (Ps._a - 10);
}
function mu(e) {
  if (typeof e != 'string') throw new Error('hex string expected, got ' + typeof e);
  const t = e.length,
    n = t / 2;
  if (t % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + t);
  const r = new Uint8Array(n);
  for (let i = 0, s = 0; i < n; i++, s += 2) {
    const o = Xx(e.charCodeAt(s)),
      a = Xx(e.charCodeAt(s + 1));
    if (o === void 0 || a === void 0) {
      const c = e[s] + e[s + 1];
      throw new Error('hex string expected, got non-hex character "' + c + '" at index ' + s);
    }
    r[i] = o * 16 + a;
  }
  return r;
}
function Ga(e) {
  return KA(bu(e));
}
function VA(e) {
  if (!ws(e)) throw new Error('Uint8Array expected');
  return KA(bu(Uint8Array.from(e).reverse()));
}
function wu(e, t) {
  return mu(e.toString(16).padStart(t * 2, '0'));
}
function WA(e, t) {
  return wu(e, t).reverse();
}
function fV(e) {
  return mu(l6(e));
}
function Ei(e, t, n) {
  let r;
  if (typeof t == 'string')
    try {
      r = mu(t);
    } catch (s) {
      throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${s}`);
    }
  else if (ws(t)) r = Uint8Array.from(t);
  else throw new Error(`${e} must be hex string or Uint8Array`);
  const i = r.length;
  if (typeof n == 'number' && i !== n) throw new Error(`${e} expected ${n} bytes, got ${i}`);
  return r;
}
function Ql(...e) {
  let t = 0;
  for (let i = 0; i < e.length; i++) {
    const s = e[i];
    if (!ws(s)) throw new Error('Uint8Array expected');
    t += s.length;
  }
  let n = new Uint8Array(t),
    r = 0;
  for (let i = 0; i < e.length; i++) {
    const s = e[i];
    n.set(s, r), (r += s.length);
  }
  return n;
}
function hV(e, t) {
  if (e.length !== t.length) return !1;
  let n = 0;
  for (let r = 0; r < e.length; r++) n |= e[r] ^ t[r];
  return n === 0;
}
function pV(e) {
  if (typeof e != 'string') throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function gV(e) {
  let t;
  for (t = 0; e > u6; e >>= $b, t += 1);
  return t;
}
function yV(e, t) {
  return (e >> BigInt(t)) & $b;
}
const bV = (e, t, n) => e | ((n ? $b : u6) << BigInt(t)),
  HA = (e) => (lV << BigInt(e - 1)) - $b,
  jw = (e) => new Uint8Array(e),
  Qx = (e) => Uint8Array.from(e);
function d6(e, t, n) {
  if (typeof e != 'number' || e < 2) throw new Error('hashLen must be a number');
  if (typeof t != 'number' || t < 2) throw new Error('qByteLen must be a number');
  if (typeof n != 'function') throw new Error('hmacFn must be a function');
  let r = jw(e),
    i = jw(e),
    s = 0;
  const o = () => {
      r.fill(1), i.fill(0), (s = 0);
    },
    a = (...d) => n(i, r, ...d),
    c = (d = jw()) => {
      (i = a(Qx([0]), d)), (r = a()), d.length !== 0 && ((i = a(Qx([1]), d)), (r = a()));
    },
    u = () => {
      if (s++ >= 1e3) throw new Error('drbg: tried 1000 values');
      let d = 0;
      const f = [];
      for (; d < t; ) {
        r = a();
        const h = r.slice();
        f.push(h), (d += r.length);
      }
      return Ql(...f);
    };
  return (d, f) => {
    o(), c(d);
    let h;
    for (; !(h = f(u())); ) c();
    return o(), h;
  };
}
const mV = {
  bigint: (e) => typeof e == 'bigint',
  function: (e) => typeof e == 'function',
  boolean: (e) => typeof e == 'boolean',
  string: (e) => typeof e == 'string',
  stringOrUint8Array: (e) => typeof e == 'string' || ws(e),
  isSafeInteger: (e) => Number.isSafeInteger(e),
  array: (e) => Array.isArray(e),
  field: (e, t) => t.Fp.isValid(e),
  hash: (e) => typeof e == 'function' && Number.isSafeInteger(e.outputLen),
};
function vd(e, t, n = {}) {
  const r = (i, s, o) => {
    const a = mV[s];
    if (typeof a != 'function') throw new Error(`Invalid validator "${s}", expected function`);
    const c = e[i];
    if (!(o && c === void 0) && !a(c, e))
      throw new Error(`Invalid param ${String(i)}=${c} (${typeof c}), expected ${s}`);
  };
  for (const [i, s] of Object.entries(t)) r(i, s, !1);
  for (const [i, s] of Object.entries(n)) r(i, s, !0);
  return e;
}
const wV = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      bitGet: yV,
      bitLen: gV,
      bitMask: HA,
      bitSet: bV,
      bytesToHex: bu,
      bytesToNumberBE: Ga,
      bytesToNumberLE: VA,
      concatBytes: Ql,
      createHmacDrbg: d6,
      ensureBytes: Ei,
      equalBytes: hV,
      hexToBytes: mu,
      hexToNumber: KA,
      isBytes: ws,
      numberToBytesBE: wu,
      numberToBytesLE: WA,
      numberToHexUnpadded: l6,
      numberToVarBytesBE: fV,
      utf8ToBytes: pV,
      validateObject: vd,
    },
    Symbol.toStringTag,
    { value: 'Module' }
  )
);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const zn = BigInt(0),
  un = BigInt(1),
  Oa = BigInt(2),
  vV = BigInt(3),
  IS = BigInt(4),
  ek = BigInt(5),
  tk = BigInt(8);
BigInt(9);
BigInt(16);
function Ir(e, t) {
  const n = e % t;
  return n >= zn ? n : t + n;
}
function _V(e, t, n) {
  if (n <= zn || t < zn) throw new Error('Expected power/modulo > 0');
  if (n === un) return zn;
  let r = un;
  for (; t > zn; ) t & un && (r = (r * e) % n), (e = (e * e) % n), (t >>= un);
  return r;
}
function Qr(e, t, n) {
  let r = e;
  for (; t-- > zn; ) (r *= r), (r %= n);
  return r;
}
function TS(e, t) {
  if (e === zn || t <= zn)
    throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
  let n = Ir(e, t),
    r = t,
    i = zn,
    s = un;
  for (; n !== zn; ) {
    const a = r / n,
      c = r % n,
      u = i - s * a;
    (r = n), (n = c), (i = s), (s = u);
  }
  if (r !== un) throw new Error('invert: does not exist');
  return Ir(i, t);
}
function SV(e) {
  const t = (e - un) / Oa;
  let n, r, i;
  for (n = e - un, r = 0; n % Oa === zn; n /= Oa, r++);
  for (i = Oa; i < e && _V(i, t, e) !== e - un; i++);
  if (r === 1) {
    const o = (e + un) / IS;
    return function (c, u) {
      const l = c.pow(u, o);
      if (!c.eql(c.sqr(l), u)) throw new Error('Cannot find square root');
      return l;
    };
  }
  const s = (n + un) / Oa;
  return function (a, c) {
    if (a.pow(c, t) === a.neg(a.ONE)) throw new Error('Cannot find square root');
    let u = r,
      l = a.pow(a.mul(a.ONE, i), n),
      d = a.pow(c, s),
      f = a.pow(c, n);
    for (; !a.eql(f, a.ONE); ) {
      if (a.eql(f, a.ZERO)) return a.ZERO;
      let h = 1;
      for (let b = a.sqr(f); h < u && !a.eql(b, a.ONE); h++) b = a.sqr(b);
      const p = a.pow(l, un << BigInt(u - h - 1));
      (l = a.sqr(p)), (d = a.mul(d, p)), (f = a.mul(f, l)), (u = h);
    }
    return d;
  };
}
function EV(e) {
  if (e % IS === vV) {
    const t = (e + un) / IS;
    return function (r, i) {
      const s = r.pow(i, t);
      if (!r.eql(r.sqr(s), i)) throw new Error('Cannot find square root');
      return s;
    };
  }
  if (e % tk === ek) {
    const t = (e - ek) / tk;
    return function (r, i) {
      const s = r.mul(i, Oa),
        o = r.pow(s, t),
        a = r.mul(i, o),
        c = r.mul(r.mul(a, Oa), o),
        u = r.mul(a, r.sub(c, r.ONE));
      if (!r.eql(r.sqr(u), i)) throw new Error('Cannot find square root');
      return u;
    };
  }
  return SV(e);
}
const AV = [
  'create',
  'isValid',
  'is0',
  'neg',
  'inv',
  'sqrt',
  'sqr',
  'eql',
  'add',
  'sub',
  'mul',
  'pow',
  'div',
  'addN',
  'subN',
  'mulN',
  'sqrN',
];
function IV(e) {
  const t = { ORDER: 'bigint', MASK: 'bigint', BYTES: 'isSafeInteger', BITS: 'isSafeInteger' },
    n = AV.reduce((r, i) => ((r[i] = 'function'), r), t);
  return vd(e, n);
}
function TV(e, t, n) {
  if (n < zn) throw new Error('Expected power > 0');
  if (n === zn) return e.ONE;
  if (n === un) return t;
  let r = e.ONE,
    i = t;
  for (; n > zn; ) n & un && (r = e.mul(r, i)), (i = e.sqr(i)), (n >>= un);
  return r;
}
function xV(e, t) {
  const n = new Array(t.length),
    r = t.reduce((s, o, a) => (e.is0(o) ? s : ((n[a] = s), e.mul(s, o))), e.ONE),
    i = e.inv(r);
  return t.reduceRight((s, o, a) => (e.is0(o) ? s : ((n[a] = e.mul(s, n[a])), e.mul(s, o))), i), n;
}
function f6(e, t) {
  const n = t !== void 0 ? t : e.toString(2).length,
    r = Math.ceil(n / 8);
  return { nBitLength: n, nByteLength: r };
}
function h6(e, t, n = !1, r = {}) {
  if (e <= zn) throw new Error(`Expected Field ORDER > 0, got ${e}`);
  const { nBitLength: i, nByteLength: s } = f6(e, t);
  if (s > 2048) throw new Error('Field lengths over 2048 bytes are not supported');
  const o = EV(e),
    a = Object.freeze({
      ORDER: e,
      BITS: i,
      BYTES: s,
      MASK: HA(i),
      ZERO: zn,
      ONE: un,
      create: (c) => Ir(c, e),
      isValid: (c) => {
        if (typeof c != 'bigint')
          throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);
        return zn <= c && c < e;
      },
      is0: (c) => c === zn,
      isOdd: (c) => (c & un) === un,
      neg: (c) => Ir(-c, e),
      eql: (c, u) => c === u,
      sqr: (c) => Ir(c * c, e),
      add: (c, u) => Ir(c + u, e),
      sub: (c, u) => Ir(c - u, e),
      mul: (c, u) => Ir(c * u, e),
      pow: (c, u) => TV(a, c, u),
      div: (c, u) => Ir(c * TS(u, e), e),
      sqrN: (c) => c * c,
      addN: (c, u) => c + u,
      subN: (c, u) => c - u,
      mulN: (c, u) => c * u,
      inv: (c) => TS(c, e),
      sqrt: r.sqrt || ((c) => o(a, c)),
      invertBatch: (c) => xV(a, c),
      cmov: (c, u, l) => (l ? u : c),
      toBytes: (c) => (n ? WA(c, s) : wu(c, s)),
      fromBytes: (c) => {
        if (c.length !== s) throw new Error(`Fp.fromBytes: expected ${s}, got ${c.length}`);
        return n ? VA(c) : Ga(c);
      },
    });
  return Object.freeze(a);
}
function p6(e) {
  if (typeof e != 'bigint') throw new Error('field order must be bigint');
  const t = e.toString(2).length;
  return Math.ceil(t / 8);
}
function g6(e) {
  const t = p6(e);
  return t + Math.ceil(t / 2);
}
function y6(e, t, n = !1) {
  const r = e.length,
    i = p6(t),
    s = g6(t);
  if (r < 16 || r < s || r > 1024) throw new Error(`expected ${s}-1024 bytes of input, got ${r}`);
  const o = n ? Ga(e) : VA(e),
    a = Ir(o, t - un) + un;
  return n ? WA(a, i) : wu(a, i);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const kV = BigInt(0),
  Lw = BigInt(1);
function CV(e, t) {
  const n = (i, s) => {
      const o = s.negate();
      return i ? o : s;
    },
    r = (i) => {
      const s = Math.ceil(t / i) + 1,
        o = 2 ** (i - 1);
      return { windows: s, windowSize: o };
    };
  return {
    constTimeNegate: n,
    unsafeLadder(i, s) {
      let o = e.ZERO,
        a = i;
      for (; s > kV; ) s & Lw && (o = o.add(a)), (a = a.double()), (s >>= Lw);
      return o;
    },
    precomputeWindow(i, s) {
      const { windows: o, windowSize: a } = r(s),
        c = [];
      let u = i,
        l = u;
      for (let d = 0; d < o; d++) {
        (l = u), c.push(l);
        for (let f = 1; f < a; f++) (l = l.add(u)), c.push(l);
        u = l.double();
      }
      return c;
    },
    wNAF(i, s, o) {
      const { windows: a, windowSize: c } = r(i);
      let u = e.ZERO,
        l = e.BASE;
      const d = BigInt(2 ** i - 1),
        f = 2 ** i,
        h = BigInt(i);
      for (let p = 0; p < a; p++) {
        const b = p * c;
        let w = Number(o & d);
        (o >>= h), w > c && ((w -= f), (o += Lw));
        const A = b,
          _ = b + Math.abs(w) - 1,
          x = p % 2 !== 0,
          k = w < 0;
        w === 0 ? (l = l.add(n(x, s[A]))) : (u = u.add(n(k, s[_])));
      }
      return { p: u, f: l };
    },
    wNAFCached(i, s, o, a) {
      const c = i._WINDOW_SIZE || 1;
      let u = s.get(i);
      return (
        u || ((u = this.precomputeWindow(i, c)), c !== 1 && s.set(i, a(u))), this.wNAF(c, u, o)
      );
    },
  };
}
function b6(e) {
  return (
    IV(e.Fp),
    vd(
      e,
      { n: 'bigint', h: 'bigint', Gx: 'field', Gy: 'field' },
      { nBitLength: 'isSafeInteger', nByteLength: 'isSafeInteger' }
    ),
    Object.freeze({ ...f6(e.n, e.nBitLength), ...e, p: e.Fp.ORDER })
  );
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function PV(e) {
  const t = b6(e);
  vd(
    t,
    { a: 'field', b: 'field' },
    {
      allowedPrivateKeyLengths: 'array',
      wrapPrivateKey: 'boolean',
      isTorsionFree: 'function',
      clearCofactor: 'function',
      allowInfinityPoint: 'boolean',
      fromBytes: 'function',
      toBytes: 'function',
    }
  );
  const { endo: n, Fp: r, a: i } = t;
  if (n) {
    if (!r.eql(i, r.ZERO))
      throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');
    if (typeof n != 'object' || typeof n.beta != 'bigint' || typeof n.splitScalar != 'function')
      throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');
  }
  return Object.freeze({ ...t });
}
const { bytesToNumberBE: MV, hexToBytes: OV } = wV,
  Ua = {
    Err: class extends Error {
      constructor(t = '') {
        super(t);
      }
    },
    _parseInt(e) {
      const { Err: t } = Ua;
      if (e.length < 2 || e[0] !== 2) throw new t('Invalid signature integer tag');
      const n = e[1],
        r = e.subarray(2, n + 2);
      if (!n || r.length !== n) throw new t('Invalid signature integer: wrong length');
      if (r[0] & 128) throw new t('Invalid signature integer: negative');
      if (r[0] === 0 && !(r[1] & 128))
        throw new t('Invalid signature integer: unnecessary leading zero');
      return { d: MV(r), l: e.subarray(n + 2) };
    },
    toSig(e) {
      const { Err: t } = Ua,
        n = typeof e == 'string' ? OV(e) : e;
      if (!ws(n)) throw new Error('ui8a expected');
      let r = n.length;
      if (r < 2 || n[0] != 48) throw new t('Invalid signature tag');
      if (n[1] !== r - 2) throw new t('Invalid signature: incorrect length');
      const { d: i, l: s } = Ua._parseInt(n.subarray(2)),
        { d: o, l: a } = Ua._parseInt(s);
      if (a.length) throw new t('Invalid signature: left bytes after parsing');
      return { r: i, s: o };
    },
    hexFromSig(e) {
      const t = (u) => (Number.parseInt(u[0], 16) & 8 ? '00' + u : u),
        n = (u) => {
          const l = u.toString(16);
          return l.length & 1 ? `0${l}` : l;
        },
        r = t(n(e.s)),
        i = t(n(e.r)),
        s = r.length / 2,
        o = i.length / 2,
        a = n(s),
        c = n(o);
      return `30${n(o + s + 4)}02${c}${i}02${a}${r}`;
    },
  },
  Hs = BigInt(0),
  ii = BigInt(1);
BigInt(2);
const nk = BigInt(3);
BigInt(4);
function BV(e) {
  const t = PV(e),
    { Fp: n } = t,
    r =
      t.toBytes ||
      ((p, b, w) => {
        const A = b.toAffine();
        return Ql(Uint8Array.from([4]), n.toBytes(A.x), n.toBytes(A.y));
      }),
    i =
      t.fromBytes ||
      ((p) => {
        const b = p.subarray(1),
          w = n.fromBytes(b.subarray(0, n.BYTES)),
          A = n.fromBytes(b.subarray(n.BYTES, 2 * n.BYTES));
        return { x: w, y: A };
      });
  function s(p) {
    const { a: b, b: w } = t,
      A = n.sqr(p),
      _ = n.mul(A, p);
    return n.add(n.add(_, n.mul(p, b)), w);
  }
  if (!n.eql(n.sqr(t.Gy), s(t.Gx))) throw new Error('bad generator point: equation left != right');
  function o(p) {
    return typeof p == 'bigint' && Hs < p && p < t.n;
  }
  function a(p) {
    if (!o(p)) throw new Error('Expected valid bigint: 0 < bigint < curve.n');
  }
  function c(p) {
    const { allowedPrivateKeyLengths: b, nByteLength: w, wrapPrivateKey: A, n: _ } = t;
    if (b && typeof p != 'bigint') {
      if ((ws(p) && (p = bu(p)), typeof p != 'string' || !b.includes(p.length)))
        throw new Error('Invalid key');
      p = p.padStart(w * 2, '0');
    }
    let x;
    try {
      x = typeof p == 'bigint' ? p : Ga(Ei('private key', p, w));
    } catch {
      throw new Error(`private key must be ${w} bytes, hex or bigint, not ${typeof p}`);
    }
    return A && (x = Ir(x, _)), a(x), x;
  }
  const u = new Map();
  function l(p) {
    if (!(p instanceof d)) throw new Error('ProjectivePoint expected');
  }
  class d {
    constructor(b, w, A) {
      if (((this.px = b), (this.py = w), (this.pz = A), b == null || !n.isValid(b)))
        throw new Error('x required');
      if (w == null || !n.isValid(w)) throw new Error('y required');
      if (A == null || !n.isValid(A)) throw new Error('z required');
    }
    static fromAffine(b) {
      const { x: w, y: A } = b || {};
      if (!b || !n.isValid(w) || !n.isValid(A)) throw new Error('invalid affine point');
      if (b instanceof d) throw new Error('projective point not allowed');
      const _ = (x) => n.eql(x, n.ZERO);
      return _(w) && _(A) ? d.ZERO : new d(w, A, n.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(b) {
      const w = n.invertBatch(b.map((A) => A.pz));
      return b.map((A, _) => A.toAffine(w[_])).map(d.fromAffine);
    }
    static fromHex(b) {
      const w = d.fromAffine(i(Ei('pointHex', b)));
      return w.assertValidity(), w;
    }
    static fromPrivateKey(b) {
      return d.BASE.multiply(c(b));
    }
    _setWindowSize(b) {
      (this._WINDOW_SIZE = b), u.delete(this);
    }
    assertValidity() {
      if (this.is0()) {
        if (t.allowInfinityPoint && !n.is0(this.py)) return;
        throw new Error('bad point: ZERO');
      }
      const { x: b, y: w } = this.toAffine();
      if (!n.isValid(b) || !n.isValid(w)) throw new Error('bad point: x or y not FE');
      const A = n.sqr(w),
        _ = s(b);
      if (!n.eql(A, _)) throw new Error('bad point: equation left != right');
      if (!this.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');
    }
    hasEvenY() {
      const { y: b } = this.toAffine();
      if (n.isOdd) return !n.isOdd(b);
      throw new Error("Field doesn't support isOdd");
    }
    equals(b) {
      l(b);
      const { px: w, py: A, pz: _ } = this,
        { px: x, py: k, pz: j } = b,
        F = n.eql(n.mul(w, j), n.mul(x, _)),
        K = n.eql(n.mul(A, j), n.mul(k, _));
      return F && K;
    }
    negate() {
      return new d(this.px, n.neg(this.py), this.pz);
    }
    double() {
      const { a: b, b: w } = t,
        A = n.mul(w, nk),
        { px: _, py: x, pz: k } = this;
      let j = n.ZERO,
        F = n.ZERO,
        K = n.ZERO,
        D = n.mul(_, _),
        C = n.mul(x, x),
        B = n.mul(k, k),
        E = n.mul(_, x);
      return (
        (E = n.add(E, E)),
        (K = n.mul(_, k)),
        (K = n.add(K, K)),
        (j = n.mul(b, K)),
        (F = n.mul(A, B)),
        (F = n.add(j, F)),
        (j = n.sub(C, F)),
        (F = n.add(C, F)),
        (F = n.mul(j, F)),
        (j = n.mul(E, j)),
        (K = n.mul(A, K)),
        (B = n.mul(b, B)),
        (E = n.sub(D, B)),
        (E = n.mul(b, E)),
        (E = n.add(E, K)),
        (K = n.add(D, D)),
        (D = n.add(K, D)),
        (D = n.add(D, B)),
        (D = n.mul(D, E)),
        (F = n.add(F, D)),
        (B = n.mul(x, k)),
        (B = n.add(B, B)),
        (D = n.mul(B, E)),
        (j = n.sub(j, D)),
        (K = n.mul(B, C)),
        (K = n.add(K, K)),
        (K = n.add(K, K)),
        new d(j, F, K)
      );
    }
    add(b) {
      l(b);
      const { px: w, py: A, pz: _ } = this,
        { px: x, py: k, pz: j } = b;
      let F = n.ZERO,
        K = n.ZERO,
        D = n.ZERO;
      const C = t.a,
        B = n.mul(t.b, nk);
      let E = n.mul(w, x),
        y = n.mul(A, k),
        v = n.mul(_, j),
        S = n.add(w, A),
        T = n.add(x, k);
      (S = n.mul(S, T)), (T = n.add(E, y)), (S = n.sub(S, T)), (T = n.add(w, _));
      let M = n.add(x, j);
      return (
        (T = n.mul(T, M)),
        (M = n.add(E, v)),
        (T = n.sub(T, M)),
        (M = n.add(A, _)),
        (F = n.add(k, j)),
        (M = n.mul(M, F)),
        (F = n.add(y, v)),
        (M = n.sub(M, F)),
        (D = n.mul(C, T)),
        (F = n.mul(B, v)),
        (D = n.add(F, D)),
        (F = n.sub(y, D)),
        (D = n.add(y, D)),
        (K = n.mul(F, D)),
        (y = n.add(E, E)),
        (y = n.add(y, E)),
        (v = n.mul(C, v)),
        (T = n.mul(B, T)),
        (y = n.add(y, v)),
        (v = n.sub(E, v)),
        (v = n.mul(C, v)),
        (T = n.add(T, v)),
        (E = n.mul(y, T)),
        (K = n.add(K, E)),
        (E = n.mul(M, T)),
        (F = n.mul(S, F)),
        (F = n.sub(F, E)),
        (E = n.mul(S, y)),
        (D = n.mul(M, D)),
        (D = n.add(D, E)),
        new d(F, K, D)
      );
    }
    subtract(b) {
      return this.add(b.negate());
    }
    is0() {
      return this.equals(d.ZERO);
    }
    wNAF(b) {
      return h.wNAFCached(this, u, b, (w) => {
        const A = n.invertBatch(w.map((_) => _.pz));
        return w.map((_, x) => _.toAffine(A[x])).map(d.fromAffine);
      });
    }
    multiplyUnsafe(b) {
      const w = d.ZERO;
      if (b === Hs) return w;
      if ((a(b), b === ii)) return this;
      const { endo: A } = t;
      if (!A) return h.unsafeLadder(this, b);
      let { k1neg: _, k1: x, k2neg: k, k2: j } = A.splitScalar(b),
        F = w,
        K = w,
        D = this;
      for (; x > Hs || j > Hs; )
        x & ii && (F = F.add(D)),
          j & ii && (K = K.add(D)),
          (D = D.double()),
          (x >>= ii),
          (j >>= ii);
      return (
        _ && (F = F.negate()),
        k && (K = K.negate()),
        (K = new d(n.mul(K.px, A.beta), K.py, K.pz)),
        F.add(K)
      );
    }
    multiply(b) {
      a(b);
      let w = b,
        A,
        _;
      const { endo: x } = t;
      if (x) {
        const { k1neg: k, k1: j, k2neg: F, k2: K } = x.splitScalar(w);
        let { p: D, f: C } = this.wNAF(j),
          { p: B, f: E } = this.wNAF(K);
        (D = h.constTimeNegate(k, D)),
          (B = h.constTimeNegate(F, B)),
          (B = new d(n.mul(B.px, x.beta), B.py, B.pz)),
          (A = D.add(B)),
          (_ = C.add(E));
      } else {
        const { p: k, f: j } = this.wNAF(w);
        (A = k), (_ = j);
      }
      return d.normalizeZ([A, _])[0];
    }
    multiplyAndAddUnsafe(b, w, A) {
      const _ = d.BASE,
        x = (j, F) => (F === Hs || F === ii || !j.equals(_) ? j.multiplyUnsafe(F) : j.multiply(F)),
        k = x(this, w).add(x(b, A));
      return k.is0() ? void 0 : k;
    }
    toAffine(b) {
      const { px: w, py: A, pz: _ } = this,
        x = this.is0();
      b == null && (b = x ? n.ONE : n.inv(_));
      const k = n.mul(w, b),
        j = n.mul(A, b),
        F = n.mul(_, b);
      if (x) return { x: n.ZERO, y: n.ZERO };
      if (!n.eql(F, n.ONE)) throw new Error('invZ was invalid');
      return { x: k, y: j };
    }
    isTorsionFree() {
      const { h: b, isTorsionFree: w } = t;
      if (b === ii) return !0;
      if (w) return w(d, this);
      throw new Error('isTorsionFree() has not been declared for the elliptic curve');
    }
    clearCofactor() {
      const { h: b, clearCofactor: w } = t;
      return b === ii ? this : w ? w(d, this) : this.multiplyUnsafe(t.h);
    }
    toRawBytes(b = !0) {
      return this.assertValidity(), r(d, this, b);
    }
    toHex(b = !0) {
      return bu(this.toRawBytes(b));
    }
  }
  (d.BASE = new d(t.Gx, t.Gy, n.ONE)), (d.ZERO = new d(n.ZERO, n.ONE, n.ZERO));
  const f = t.nBitLength,
    h = CV(d, t.endo ? Math.ceil(f / 2) : f);
  return {
    CURVE: t,
    ProjectivePoint: d,
    normPrivateKeyToScalar: c,
    weierstrassEquation: s,
    isWithinCurveOrder: o,
  };
}
function DV(e) {
  const t = b6(e);
  return (
    vd(
      t,
      { hash: 'hash', hmac: 'function', randomBytes: 'function' },
      { bits2int: 'function', bits2int_modN: 'function', lowS: 'boolean' }
    ),
    Object.freeze({ lowS: !0, ...t })
  );
}
function RV(e) {
  const t = DV(e),
    { Fp: n, n: r } = t,
    i = n.BYTES + 1,
    s = 2 * n.BYTES + 1;
  function o(T) {
    return Hs < T && T < n.ORDER;
  }
  function a(T) {
    return Ir(T, r);
  }
  function c(T) {
    return TS(T, r);
  }
  const {
      ProjectivePoint: u,
      normPrivateKeyToScalar: l,
      weierstrassEquation: d,
      isWithinCurveOrder: f,
    } = BV({
      ...t,
      toBytes(T, M, R) {
        const L = M.toAffine(),
          O = n.toBytes(L.x),
          I = Ql;
        return R
          ? I(Uint8Array.from([M.hasEvenY() ? 2 : 3]), O)
          : I(Uint8Array.from([4]), O, n.toBytes(L.y));
      },
      fromBytes(T) {
        const M = T.length,
          R = T[0],
          L = T.subarray(1);
        if (M === i && (R === 2 || R === 3)) {
          const O = Ga(L);
          if (!o(O)) throw new Error('Point is not on curve');
          const I = d(O);
          let U = n.sqrt(I);
          const H = (U & ii) === ii;
          return ((R & 1) === 1) !== H && (U = n.neg(U)), { x: O, y: U };
        } else if (M === s && R === 4) {
          const O = n.fromBytes(L.subarray(0, n.BYTES)),
            I = n.fromBytes(L.subarray(n.BYTES, 2 * n.BYTES));
          return { x: O, y: I };
        } else
          throw new Error(
            `Point of length ${M} was invalid. Expected ${i} compressed bytes or ${s} uncompressed bytes`
          );
      },
    }),
    h = (T) => bu(wu(T, t.nByteLength));
  function p(T) {
    const M = r >> ii;
    return T > M;
  }
  function b(T) {
    return p(T) ? a(-T) : T;
  }
  const w = (T, M, R) => Ga(T.slice(M, R));
  class A {
    constructor(M, R, L) {
      (this.r = M), (this.s = R), (this.recovery = L), this.assertValidity();
    }
    static fromCompact(M) {
      const R = t.nByteLength;
      return (M = Ei('compactSignature', M, R * 2)), new A(w(M, 0, R), w(M, R, 2 * R));
    }
    static fromDER(M) {
      const { r: R, s: L } = Ua.toSig(Ei('DER', M));
      return new A(R, L);
    }
    assertValidity() {
      if (!f(this.r)) throw new Error('r must be 0 < r < CURVE.n');
      if (!f(this.s)) throw new Error('s must be 0 < s < CURVE.n');
    }
    addRecoveryBit(M) {
      return new A(this.r, this.s, M);
    }
    recoverPublicKey(M) {
      const { r: R, s: L, recovery: O } = this,
        I = K(Ei('msgHash', M));
      if (O == null || ![0, 1, 2, 3].includes(O)) throw new Error('recovery id invalid');
      const U = O === 2 || O === 3 ? R + t.n : R;
      if (U >= n.ORDER) throw new Error('recovery id 2 or 3 invalid');
      const H = O & 1 ? '03' : '02',
        X = u.fromHex(H + h(U)),
        J = c(U),
        ie = a(-I * J),
        Z = a(L * J),
        be = u.BASE.multiplyAndAddUnsafe(X, ie, Z);
      if (!be) throw new Error('point at infinify');
      return be.assertValidity(), be;
    }
    hasHighS() {
      return p(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new A(this.r, a(-this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return mu(this.toDERHex());
    }
    toDERHex() {
      return Ua.hexFromSig({ r: this.r, s: this.s });
    }
    toCompactRawBytes() {
      return mu(this.toCompactHex());
    }
    toCompactHex() {
      return h(this.r) + h(this.s);
    }
  }
  const _ = {
    isValidPrivateKey(T) {
      try {
        return l(T), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: l,
    randomPrivateKey: () => {
      const T = g6(t.n);
      return y6(t.randomBytes(T), t.n);
    },
    precompute(T = 8, M = u.BASE) {
      return M._setWindowSize(T), M.multiply(BigInt(3)), M;
    },
  };
  function x(T, M = !0) {
    return u.fromPrivateKey(T).toRawBytes(M);
  }
  function k(T) {
    const M = ws(T),
      R = typeof T == 'string',
      L = (M || R) && T.length;
    return M ? L === i || L === s : R ? L === 2 * i || L === 2 * s : T instanceof u;
  }
  function j(T, M, R = !0) {
    if (k(T)) throw new Error('first arg must be private key');
    if (!k(M)) throw new Error('second arg must be public key');
    return u.fromHex(M).multiply(l(T)).toRawBytes(R);
  }
  const F =
      t.bits2int ||
      function (T) {
        const M = Ga(T),
          R = T.length * 8 - t.nBitLength;
        return R > 0 ? M >> BigInt(R) : M;
      },
    K =
      t.bits2int_modN ||
      function (T) {
        return a(F(T));
      },
    D = HA(t.nBitLength);
  function C(T) {
    if (typeof T != 'bigint') throw new Error('bigint expected');
    if (!(Hs <= T && T < D)) throw new Error(`bigint expected < 2^${t.nBitLength}`);
    return wu(T, t.nByteLength);
  }
  function B(T, M, R = E) {
    if (['recovered', 'canonical'].some((Oe) => Oe in R))
      throw new Error('sign() legacy options not supported');
    const { hash: L, randomBytes: O } = t;
    let { lowS: I, prehash: U, extraEntropy: H } = R;
    I == null && (I = !0), (T = Ei('msgHash', T)), U && (T = Ei('prehashed msgHash', L(T)));
    const X = K(T),
      J = l(M),
      ie = [C(J), C(X)];
    if (H != null) {
      const Oe = H === !0 ? O(n.BYTES) : H;
      ie.push(Ei('extraEntropy', Oe));
    }
    const Z = Ql(...ie),
      be = X;
    function le(Oe) {
      const Re = F(Oe);
      if (!f(Re)) return;
      const ht = c(Re),
        xe = u.BASE.multiply(Re).toAffine(),
        We = a(xe.x);
      if (We === Hs) return;
      const Yt = a(ht * a(be + We * J));
      if (Yt === Hs) return;
      let Fe = (xe.x === We ? 0 : 2) | Number(xe.y & ii),
        nt = Yt;
      return I && p(Yt) && ((nt = b(Yt)), (Fe ^= 1)), new A(We, nt, Fe);
    }
    return { seed: Z, k2sig: le };
  }
  const E = { lowS: t.lowS, prehash: !1 },
    y = { lowS: t.lowS, prehash: !1 };
  function v(T, M, R = E) {
    const { seed: L, k2sig: O } = B(T, M, R),
      I = t;
    return d6(I.hash.outputLen, I.nByteLength, I.hmac)(L, O);
  }
  u.BASE._setWindowSize(8);
  function S(T, M, R, L = y) {
    var xe;
    const O = T;
    if (((M = Ei('msgHash', M)), (R = Ei('publicKey', R)), 'strict' in L))
      throw new Error('options.strict was renamed to lowS');
    const { lowS: I, prehash: U } = L;
    let H, X;
    try {
      if (typeof O == 'string' || ws(O))
        try {
          H = A.fromDER(O);
        } catch (We) {
          if (!(We instanceof Ua.Err)) throw We;
          H = A.fromCompact(O);
        }
      else if (typeof O == 'object' && typeof O.r == 'bigint' && typeof O.s == 'bigint') {
        const { r: We, s: Yt } = O;
        H = new A(We, Yt);
      } else throw new Error('PARSE');
      X = u.fromHex(R);
    } catch (We) {
      if (We.message === 'PARSE')
        throw new Error('signature must be Signature instance, Uint8Array or hex string');
      return !1;
    }
    if (I && H.hasHighS()) return !1;
    U && (M = t.hash(M));
    const { r: J, s: ie } = H,
      Z = K(M),
      be = c(ie),
      le = a(Z * be),
      Oe = a(J * be),
      Re = (xe = u.BASE.multiplyAndAddUnsafe(X, le, Oe)) == null ? void 0 : xe.toAffine();
    return Re ? a(Re.x) === J : !1;
  }
  return {
    CURVE: t,
    getPublicKey: x,
    getSharedSecret: j,
    sign: v,
    verify: S,
    ProjectivePoint: u,
    Signature: A,
    utils: _,
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function NV(e) {
  return { hash: e, hmac: (t, ...n) => c6(e, t, aV(...n)), randomBytes: uV };
}
function m6(e, t) {
  const n = (r) => RV({ ...e, ...NV(r) });
  return Object.freeze({ ...n(t), create: n });
}
function jV(e, t, n, r) {
  if (typeof e.setBigUint64 == 'function') return e.setBigUint64(t, n, r);
  const i = BigInt(32),
    s = BigInt(4294967295),
    o = Number((n >> i) & s),
    a = Number(n & s),
    c = r ? 4 : 0,
    u = r ? 0 : 4;
  e.setUint32(t + c, o, r), e.setUint32(t + u, a, r);
}
let LV = class extends o6 {
  constructor(t, n, r, i) {
    super(),
      (this.blockLen = t),
      (this.outputLen = n),
      (this.padOffset = r),
      (this.isLE = i),
      (this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.buffer = new Uint8Array(t)),
      (this.view = Nw(this.buffer));
  }
  update(t) {
    Ny(this);
    const { view: n, buffer: r, blockLen: i } = this;
    t = zA(t);
    const s = t.length;
    for (let o = 0; o < s; ) {
      const a = Math.min(i - this.pos, s - o);
      if (a === i) {
        const c = Nw(t);
        for (; i <= s - o; o += i) this.process(c, o);
        continue;
      }
      r.set(t.subarray(o, o + a), this.pos),
        (this.pos += a),
        (o += a),
        this.pos === i && (this.process(n, 0), (this.pos = 0));
    }
    return (this.length += t.length), this.roundClean(), this;
  }
  digestInto(t) {
    Ny(this), iV(t, this), (this.finished = !0);
    const { buffer: n, view: r, blockLen: i, isLE: s } = this;
    let { pos: o } = this;
    (n[o++] = 128),
      this.buffer.subarray(o).fill(0),
      this.padOffset > i - o && (this.process(r, 0), (o = 0));
    for (let d = o; d < i; d++) n[d] = 0;
    jV(r, i - 8, BigInt(this.length * 8), s), this.process(r, 0);
    const a = Nw(t),
      c = this.outputLen;
    if (c % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
    const u = c / 4,
      l = this.get();
    if (u > l.length) throw new Error('_sha2: outputLen bigger than state');
    for (let d = 0; d < u; d++) a.setUint32(4 * d, l[d], s);
  }
  digest() {
    const { buffer: t, outputLen: n } = this;
    this.digestInto(t);
    const r = t.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: n, buffer: r, length: i, finished: s, destroyed: o, pos: a } = this;
    return (
      (t.length = i), (t.pos = a), (t.finished = s), (t.destroyed = o), i % n && t.buffer.set(r), t
    );
  }
};
const UV = (e, t, n) => (e & t) ^ (~e & n),
  $V = (e, t, n) => (e & t) ^ (e & n) ^ (t & n),
  FV = new Uint32Array([
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221,
    3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580,
    3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895,
    666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037,
    2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
    1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298,
  ]),
  bo = new Uint32Array([
    1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225,
  ]),
  mo = new Uint32Array(64);
let zV = class extends LV {
  constructor() {
    super(64, 32, 8, !1),
      (this.A = bo[0] | 0),
      (this.B = bo[1] | 0),
      (this.C = bo[2] | 0),
      (this.D = bo[3] | 0),
      (this.E = bo[4] | 0),
      (this.F = bo[5] | 0),
      (this.G = bo[6] | 0),
      (this.H = bo[7] | 0);
  }
  get() {
    const { A: t, B: n, C: r, D: i, E: s, F: o, G: a, H: c } = this;
    return [t, n, r, i, s, o, a, c];
  }
  set(t, n, r, i, s, o, a, c) {
    (this.A = t | 0),
      (this.B = n | 0),
      (this.C = r | 0),
      (this.D = i | 0),
      (this.E = s | 0),
      (this.F = o | 0),
      (this.G = a | 0),
      (this.H = c | 0);
  }
  process(t, n) {
    for (let d = 0; d < 16; d++, n += 4) mo[d] = t.getUint32(n, !1);
    for (let d = 16; d < 64; d++) {
      const f = mo[d - 15],
        h = mo[d - 2],
        p = Xi(f, 7) ^ Xi(f, 18) ^ (f >>> 3),
        b = Xi(h, 17) ^ Xi(h, 19) ^ (h >>> 10);
      mo[d] = (b + mo[d - 7] + p + mo[d - 16]) | 0;
    }
    let { A: r, B: i, C: s, D: o, E: a, F: c, G: u, H: l } = this;
    for (let d = 0; d < 64; d++) {
      const f = Xi(a, 6) ^ Xi(a, 11) ^ Xi(a, 25),
        h = (l + f + UV(a, c, u) + FV[d] + mo[d]) | 0,
        b = ((Xi(r, 2) ^ Xi(r, 13) ^ Xi(r, 22)) + $V(r, i, s)) | 0;
      (l = u), (u = c), (c = a), (a = (o + h) | 0), (o = s), (s = i), (i = r), (r = (h + b) | 0);
    }
    (r = (r + this.A) | 0),
      (i = (i + this.B) | 0),
      (s = (s + this.C) | 0),
      (o = (o + this.D) | 0),
      (a = (a + this.E) | 0),
      (c = (c + this.F) | 0),
      (u = (u + this.G) | 0),
      (l = (l + this.H) | 0),
      this.set(r, i, s, o, a, c, u, l);
  }
  roundClean() {
    mo.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
const w6 = cV(() => new zV());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const v6 = h6(
    BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff')
  ),
  KV = v6.create(BigInt('-3')),
  VV = BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b'),
  xS = m6(
    {
      a: KV,
      b: VV,
      Fp: v6,
      n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),
      Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),
      Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),
      h: BigInt(1),
      lowS: !1,
    },
    w6
  ),
  WV = () => ({
    type: Kr.KeyPair,
    sign: (e, t) => {
      if (!t.isJWT) return Promise.resolve(an(at.InvalidAddressType));
      if (t.data.payload.iss !== fM || t.data.payload.aud !== hM)
        return Promise.resolve(an(at.InvalidClaimError));
      const n = { ...t.data.header, kid: ki(he.from(e.publicKey)) },
        r = { ...t.data.payload, sub: ki(he.from(e.publicKey)) },
        i = ki(he.from(JSON.stringify(n))) + '.' + ki(he.from(JSON.stringify(r))),
        o = xS.sign(he.from(i).toString('hex'), e.privateKey, { prehash: !0 }).toCompactRawBytes(),
        a = ki(he.from(o)),
        c = { header: n, payload: r, signature: a };
      return Promise.resolve({ status: 'success', signature: a, signedJWT: c });
    },
  }),
  HV = () => ({
    type: Kr.KeyPair,
    sign: (e, t) => {
      if (t.chainType !== G.Solana) return Promise.resolve(an(at.InvalidAddressType));
      let n;
      try {
        typeof t.message == 'string'
          ? t.signingType === 'transaction'
            ? (n = or.decode(t.message))
            : (n = he.from(t.message, 'utf8'))
          : (n = t.message);
      } catch {
        return Promise.resolve(an(at.InvalidMessageEncoding));
      }
      const r = or.encode($s.sign.detached(n, e.privateKey));
      return Promise.resolve({ status: 'success', signature: r });
    },
  });
function Fl(e) {
  if (!Number.isSafeInteger(e) || e < 0) throw new Error(`positive integer expected, not ${e}`);
}
function GV(e) {
  return (
    e instanceof Uint8Array ||
    (e != null && typeof e == 'object' && e.constructor.name === 'Uint8Array')
  );
}
function Fb(e, ...t) {
  if (!GV(e)) throw new Error('Uint8Array expected');
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`);
}
function qV(e) {
  if (typeof e != 'function' || typeof e.create != 'function')
    throw new Error('Hash should be wrapped by utils.wrapConstructor');
  Fl(e.outputLen), Fl(e.blockLen);
}
function vu(e, t = !0) {
  if (e.destroyed) throw new Error('Hash instance has been destroyed');
  if (t && e.finished) throw new Error('Hash#digest() has already been called');
}
function _6(e, t) {
  Fb(e);
  const n = t.outputLen;
  if (e.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`);
}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const jy = (e) =>
    new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)),
  Uw = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength),
  Pa = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68,
  S6 = (e) =>
    ((e << 24) & 4278190080) | ((e << 8) & 16711680) | ((e >>> 8) & 65280) | ((e >>> 24) & 255),
  Ns = Pa ? (e) => e : (e) => S6(e);
function Rc(e) {
  for (let t = 0; t < e.length; t++) e[t] = S6(e[t]);
}
const YV = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, '0'));
function E6(e) {
  Fb(e);
  let t = '';
  for (let n = 0; n < e.length; n++) t += YV[e[n]];
  return t;
}
const Ms = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function rk(e) {
  if (e >= Ms._0 && e <= Ms._9) return e - Ms._0;
  if (e >= Ms._A && e <= Ms._F) return e - (Ms._A - 10);
  if (e >= Ms._a && e <= Ms._f) return e - (Ms._a - 10);
}
function ZV(e) {
  if (typeof e != 'string') throw new Error('hex string expected, got ' + typeof e);
  const t = e.length,
    n = t / 2;
  if (t % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + t);
  const r = new Uint8Array(n);
  for (let i = 0, s = 0; i < n; i++, s += 2) {
    const o = rk(e.charCodeAt(s)),
      a = rk(e.charCodeAt(s + 1));
    if (o === void 0 || a === void 0) {
      const c = e[s] + e[s + 1];
      throw new Error('hex string expected, got non-hex character "' + c + '" at index ' + s);
    }
    r[i] = o * 16 + a;
  }
  return r;
}
function JV(e) {
  if (typeof e != 'string') throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function ca(e) {
  return typeof e == 'string' && (e = JV(e)), Fb(e), e;
}
let GA = class {
  clone() {
    return this._cloneInto();
  }
};
function XV(e) {
  const t = (r) => e().update(ca(r)).digest(),
    n = e();
  return (t.outputLen = n.outputLen), (t.blockLen = n.blockLen), (t.create = () => e()), t;
}
function QV(e) {
  const t = (r, i) => e(i).update(ca(r)).digest(),
    n = e({});
  return (t.outputLen = n.outputLen), (t.blockLen = n.blockLen), (t.create = (r) => e(r)), t;
}
const eW = new Uint8Array([
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11,
  7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6,
  5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8,
  3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14,
  12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10,
  2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,
  14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,
]);
class tW extends GA {
  constructor(t, n, r = {}, i, s, o) {
    if (
      (super(),
      (this.blockLen = t),
      (this.outputLen = n),
      (this.length = 0),
      (this.pos = 0),
      (this.finished = !1),
      (this.destroyed = !1),
      Fl(t),
      Fl(n),
      Fl(i),
      n < 0 || n > i)
    )
      throw new Error('outputLen bigger than keyLen');
    if (r.key !== void 0 && (r.key.length < 1 || r.key.length > i))
      throw new Error(`key must be up 1..${i} byte long or undefined`);
    if (r.salt !== void 0 && r.salt.length !== s)
      throw new Error(`salt must be ${s} byte long or undefined`);
    if (r.personalization !== void 0 && r.personalization.length !== o)
      throw new Error(`personalization must be ${o} byte long or undefined`);
    this.buffer32 = jy((this.buffer = new Uint8Array(t)));
  }
  update(t) {
    vu(this);
    const { blockLen: n, buffer: r, buffer32: i } = this;
    t = ca(t);
    const s = t.length,
      o = t.byteOffset,
      a = t.buffer;
    for (let c = 0; c < s; ) {
      this.pos === n && (Pa || Rc(i), this.compress(i, 0, !1), Pa || Rc(i), (this.pos = 0));
      const u = Math.min(n - this.pos, s - c),
        l = o + c;
      if (u === n && !(l % 4) && c + u < s) {
        const d = new Uint32Array(a, l, Math.floor((s - c) / 4));
        Pa || Rc(d);
        for (let f = 0; c + n < s; f += i.length, c += n)
          (this.length += n), this.compress(d, f, !1);
        Pa || Rc(d);
        continue;
      }
      r.set(t.subarray(c, c + u), this.pos), (this.pos += u), (this.length += u), (c += u);
    }
    return this;
  }
  digestInto(t) {
    vu(this), _6(t, this);
    const { pos: n, buffer32: r } = this;
    (this.finished = !0),
      this.buffer.subarray(n).fill(0),
      Pa || Rc(r),
      this.compress(r, 0, !0),
      Pa || Rc(r);
    const i = jy(t);
    this.get().forEach((s, o) => (i[o] = Ns(s)));
  }
  digest() {
    const { buffer: t, outputLen: n } = this;
    this.digestInto(t);
    const r = t.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(t) {
    const { buffer: n, length: r, finished: i, destroyed: s, outputLen: o, pos: a } = this;
    return (
      t || (t = new this.constructor({ dkLen: o })),
      t.set(...this.get()),
      (t.length = r),
      (t.finished = i),
      (t.destroyed = s),
      (t.outputLen = o),
      t.buffer.set(n),
      (t.pos = a),
      t
    );
  }
}
const Wp = BigInt(2 ** 32 - 1),
  kS = BigInt(32);
function A6(e, t = !1) {
  return t
    ? { h: Number(e & Wp), l: Number((e >> kS) & Wp) }
    : { h: Number((e >> kS) & Wp) | 0, l: Number(e & Wp) | 0 };
}
function nW(e, t = !1) {
  let n = new Uint32Array(e.length),
    r = new Uint32Array(e.length);
  for (let i = 0; i < e.length; i++) {
    const { h: s, l: o } = A6(e[i], t);
    [n[i], r[i]] = [s, o];
  }
  return [n, r];
}
const rW = (e, t) => (BigInt(e >>> 0) << kS) | BigInt(t >>> 0),
  iW = (e, t, n) => e >>> n,
  sW = (e, t, n) => (e << (32 - n)) | (t >>> n),
  oW = (e, t, n) => (e >>> n) | (t << (32 - n)),
  aW = (e, t, n) => (e << (32 - n)) | (t >>> n),
  cW = (e, t, n) => (e << (64 - n)) | (t >>> (n - 32)),
  uW = (e, t, n) => (e >>> (n - 32)) | (t << (64 - n)),
  lW = (e, t) => t,
  dW = (e, t) => e,
  fW = (e, t, n) => (e << n) | (t >>> (32 - n)),
  hW = (e, t, n) => (t << n) | (e >>> (32 - n)),
  pW = (e, t, n) => (t << (n - 32)) | (e >>> (64 - n)),
  gW = (e, t, n) => (e << (n - 32)) | (t >>> (64 - n));
function yW(e, t, n, r) {
  const i = (t >>> 0) + (r >>> 0);
  return { h: (e + n + ((i / 2 ** 32) | 0)) | 0, l: i | 0 };
}
const bW = (e, t, n) => (e >>> 0) + (t >>> 0) + (n >>> 0),
  mW = (e, t, n, r) => (t + n + r + ((e / 2 ** 32) | 0)) | 0,
  wW = (e, t, n, r) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0),
  vW = (e, t, n, r, i) => (t + n + r + i + ((e / 2 ** 32) | 0)) | 0,
  _W = (e, t, n, r, i) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0) + (i >>> 0),
  SW = (e, t, n, r, i, s) => (t + n + r + i + s + ((e / 2 ** 32) | 0)) | 0,
  Ke = {
    fromBig: A6,
    split: nW,
    toBig: rW,
    shrSH: iW,
    shrSL: sW,
    rotrSH: oW,
    rotrSL: aW,
    rotrBH: cW,
    rotrBL: uW,
    rotr32H: lW,
    rotr32L: dW,
    rotlSH: fW,
    rotlSL: hW,
    rotlBH: pW,
    rotlBL: gW,
    add: yW,
    add3L: bW,
    add3H: mW,
    add4L: wW,
    add4H: vW,
    add5H: SW,
    add5L: _W,
  },
  jn = new Uint32Array([
    4089235720, 1779033703, 2227873595, 3144134277, 4271175723, 1013904242, 1595750129, 2773480762,
    2917565137, 1359893119, 725511199, 2600822924, 4215389547, 528734635, 327033209, 1541459225,
  ]),
  Se = new Uint32Array(32);
function wo(e, t, n, r, i, s) {
  const o = i[s],
    a = i[s + 1];
  let c = Se[2 * e],
    u = Se[2 * e + 1],
    l = Se[2 * t],
    d = Se[2 * t + 1],
    f = Se[2 * n],
    h = Se[2 * n + 1],
    p = Se[2 * r],
    b = Se[2 * r + 1],
    w = Ke.add3L(c, l, o);
  (u = Ke.add3H(w, u, d, a)),
    (c = w | 0),
    ({ Dh: b, Dl: p } = { Dh: b ^ u, Dl: p ^ c }),
    ({ Dh: b, Dl: p } = { Dh: Ke.rotr32H(b, p), Dl: Ke.rotr32L(b, p) }),
    ({ h, l: f } = Ke.add(h, f, b, p)),
    ({ Bh: d, Bl: l } = { Bh: d ^ h, Bl: l ^ f }),
    ({ Bh: d, Bl: l } = { Bh: Ke.rotrSH(d, l, 24), Bl: Ke.rotrSL(d, l, 24) }),
    (Se[2 * e] = c),
    (Se[2 * e + 1] = u),
    (Se[2 * t] = l),
    (Se[2 * t + 1] = d),
    (Se[2 * n] = f),
    (Se[2 * n + 1] = h),
    (Se[2 * r] = p),
    (Se[2 * r + 1] = b);
}
function vo(e, t, n, r, i, s) {
  const o = i[s],
    a = i[s + 1];
  let c = Se[2 * e],
    u = Se[2 * e + 1],
    l = Se[2 * t],
    d = Se[2 * t + 1],
    f = Se[2 * n],
    h = Se[2 * n + 1],
    p = Se[2 * r],
    b = Se[2 * r + 1],
    w = Ke.add3L(c, l, o);
  (u = Ke.add3H(w, u, d, a)),
    (c = w | 0),
    ({ Dh: b, Dl: p } = { Dh: b ^ u, Dl: p ^ c }),
    ({ Dh: b, Dl: p } = { Dh: Ke.rotrSH(b, p, 16), Dl: Ke.rotrSL(b, p, 16) }),
    ({ h, l: f } = Ke.add(h, f, b, p)),
    ({ Bh: d, Bl: l } = { Bh: d ^ h, Bl: l ^ f }),
    ({ Bh: d, Bl: l } = { Bh: Ke.rotrBH(d, l, 63), Bl: Ke.rotrBL(d, l, 63) }),
    (Se[2 * e] = c),
    (Se[2 * e + 1] = u),
    (Se[2 * t] = l),
    (Se[2 * t + 1] = d),
    (Se[2 * n] = f),
    (Se[2 * n + 1] = h),
    (Se[2 * r] = p),
    (Se[2 * r + 1] = b);
}
class EW extends tW {
  constructor(t = {}) {
    super(128, t.dkLen === void 0 ? 64 : t.dkLen, t, 64, 16, 16),
      (this.v0l = jn[0] | 0),
      (this.v0h = jn[1] | 0),
      (this.v1l = jn[2] | 0),
      (this.v1h = jn[3] | 0),
      (this.v2l = jn[4] | 0),
      (this.v2h = jn[5] | 0),
      (this.v3l = jn[6] | 0),
      (this.v3h = jn[7] | 0),
      (this.v4l = jn[8] | 0),
      (this.v4h = jn[9] | 0),
      (this.v5l = jn[10] | 0),
      (this.v5h = jn[11] | 0),
      (this.v6l = jn[12] | 0),
      (this.v6h = jn[13] | 0),
      (this.v7l = jn[14] | 0),
      (this.v7h = jn[15] | 0);
    const n = t.key ? t.key.length : 0;
    if (((this.v0l ^= this.outputLen | (n << 8) | 65536 | (1 << 24)), t.salt)) {
      const r = jy(ca(t.salt));
      (this.v4l ^= Ns(r[0])),
        (this.v4h ^= Ns(r[1])),
        (this.v5l ^= Ns(r[2])),
        (this.v5h ^= Ns(r[3]));
    }
    if (t.personalization) {
      const r = jy(ca(t.personalization));
      (this.v6l ^= Ns(r[0])),
        (this.v6h ^= Ns(r[1])),
        (this.v7l ^= Ns(r[2])),
        (this.v7h ^= Ns(r[3]));
    }
    if (t.key) {
      const r = new Uint8Array(this.blockLen);
      r.set(ca(t.key)), this.update(r);
    }
  }
  get() {
    let {
      v0l: t,
      v0h: n,
      v1l: r,
      v1h: i,
      v2l: s,
      v2h: o,
      v3l: a,
      v3h: c,
      v4l: u,
      v4h: l,
      v5l: d,
      v5h: f,
      v6l: h,
      v6h: p,
      v7l: b,
      v7h: w,
    } = this;
    return [t, n, r, i, s, o, a, c, u, l, d, f, h, p, b, w];
  }
  set(t, n, r, i, s, o, a, c, u, l, d, f, h, p, b, w) {
    (this.v0l = t | 0),
      (this.v0h = n | 0),
      (this.v1l = r | 0),
      (this.v1h = i | 0),
      (this.v2l = s | 0),
      (this.v2h = o | 0),
      (this.v3l = a | 0),
      (this.v3h = c | 0),
      (this.v4l = u | 0),
      (this.v4h = l | 0),
      (this.v5l = d | 0),
      (this.v5h = f | 0),
      (this.v6l = h | 0),
      (this.v6h = p | 0),
      (this.v7l = b | 0),
      (this.v7h = w | 0);
  }
  compress(t, n, r) {
    this.get().forEach((c, u) => (Se[u] = c)), Se.set(jn, 16);
    let { h: i, l: s } = Ke.fromBig(BigInt(this.length));
    (Se[24] = jn[8] ^ s), (Se[25] = jn[9] ^ i), r && ((Se[28] = ~Se[28]), (Se[29] = ~Se[29]));
    let o = 0;
    const a = eW;
    for (let c = 0; c < 12; c++)
      wo(0, 4, 8, 12, t, n + 2 * a[o++]),
        vo(0, 4, 8, 12, t, n + 2 * a[o++]),
        wo(1, 5, 9, 13, t, n + 2 * a[o++]),
        vo(1, 5, 9, 13, t, n + 2 * a[o++]),
        wo(2, 6, 10, 14, t, n + 2 * a[o++]),
        vo(2, 6, 10, 14, t, n + 2 * a[o++]),
        wo(3, 7, 11, 15, t, n + 2 * a[o++]),
        vo(3, 7, 11, 15, t, n + 2 * a[o++]),
        wo(0, 5, 10, 15, t, n + 2 * a[o++]),
        vo(0, 5, 10, 15, t, n + 2 * a[o++]),
        wo(1, 6, 11, 12, t, n + 2 * a[o++]),
        vo(1, 6, 11, 12, t, n + 2 * a[o++]),
        wo(2, 7, 8, 13, t, n + 2 * a[o++]),
        vo(2, 7, 8, 13, t, n + 2 * a[o++]),
        wo(3, 4, 9, 14, t, n + 2 * a[o++]),
        vo(3, 4, 9, 14, t, n + 2 * a[o++]);
    (this.v0l ^= Se[0] ^ Se[16]),
      (this.v0h ^= Se[1] ^ Se[17]),
      (this.v1l ^= Se[2] ^ Se[18]),
      (this.v1h ^= Se[3] ^ Se[19]),
      (this.v2l ^= Se[4] ^ Se[20]),
      (this.v2h ^= Se[5] ^ Se[21]),
      (this.v3l ^= Se[6] ^ Se[22]),
      (this.v3h ^= Se[7] ^ Se[23]),
      (this.v4l ^= Se[8] ^ Se[24]),
      (this.v4h ^= Se[9] ^ Se[25]),
      (this.v5l ^= Se[10] ^ Se[26]),
      (this.v5h ^= Se[11] ^ Se[27]),
      (this.v6l ^= Se[12] ^ Se[28]),
      (this.v6h ^= Se[13] ^ Se[29]),
      (this.v7l ^= Se[14] ^ Se[30]),
      (this.v7h ^= Se[15] ^ Se[31]),
      Se.fill(0);
  }
  destroy() {
    (this.destroyed = !0),
      this.buffer32.fill(0),
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const Ly = QV((e) => new EW(e)),
  _d = 32;
function AW(e) {
  return IW(e) && TW(e) === _d;
}
function Xc(e, t = !1) {
  let n = e.toLowerCase();
  return !t && n.startsWith('0x') && (n = n.slice(2)), `0x${n.padStart(_d * 2, '0')}`;
}
function IW(e) {
  return /^(0x|0X)?[a-fA-F0-9]+$/.test(e) && e.length % 2 === 0;
}
function TW(e) {
  return /^(0x|0X)/.test(e) ? (e.length - 2) / 2 : e.length / 2;
}
const xW = /^vector<(.+)>$/,
  kW = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;
class Zo {
  static parseFromStr(t, n = !1) {
    if (t === 'address') return { address: null };
    if (t === 'bool') return { bool: null };
    if (t === 'u8') return { u8: null };
    if (t === 'u16') return { u16: null };
    if (t === 'u32') return { u32: null };
    if (t === 'u64') return { u64: null };
    if (t === 'u128') return { u128: null };
    if (t === 'u256') return { u256: null };
    if (t === 'signer') return { signer: null };
    const r = t.match(xW);
    if (r) return { vector: Zo.parseFromStr(r[1], n) };
    const i = t.match(kW);
    if (i)
      return {
        struct: {
          address: n ? Xc(i[1]) : i[1],
          module: i[2],
          name: i[3],
          typeParams: i[5] === void 0 ? [] : Zo.parseStructTypeArgs(i[5], n),
        },
      };
    throw new Error(`Encountered unexpected token when parsing type args for ${t}`);
  }
  static parseStructTypeArgs(t, n = !1) {
    return m9(t).map((r) => Zo.parseFromStr(r, n));
  }
  static tagToString(t) {
    if ('bool' in t) return 'bool';
    if ('u8' in t) return 'u8';
    if ('u16' in t) return 'u16';
    if ('u32' in t) return 'u32';
    if ('u64' in t) return 'u64';
    if ('u128' in t) return 'u128';
    if ('u256' in t) return 'u256';
    if ('address' in t) return 'address';
    if ('signer' in t) return 'signer';
    if ('vector' in t) return `vector<${Zo.tagToString(t.vector)}>`;
    if ('struct' in t) {
      const n = t.struct,
        r = n.typeParams.map(Zo.tagToString).join(', ');
      return `${n.address}::${n.module}::${n.name}${r ? `<${r}>` : ''}`;
    }
    throw new Error('Invalid TypeTag');
  }
}
function CW(e) {
  return V.u64({ name: 'unsafe_u64', ...e }).transform({
    input: (t) => t,
    output: (t) => Number(t),
  });
}
function PW(e) {
  return V.enum('Option', { None: null, Some: e });
}
const sn = V.bytes(_d).transform({
    validate: (e) => {
      const t = typeof e == 'string' ? e : my(e);
      if (!t || !AW(Xc(t))) throw new Error(`Invalid Sui address ${t}`);
    },
    input: (e) => (typeof e == 'string' ? yP(Xc(e)) : e),
    output: (e) => Xc(my(e)),
  }),
  Pi = V.vector(V.u8()).transform({
    name: 'ObjectDigest',
    input: (e) => gx(e),
    output: (e) => w9(new Uint8Array(e)),
    validate: (e) => {
      if (gx(e).length !== 32) throw new Error('ObjectDigest must be 32 bytes');
    },
  }),
  si = V.struct('SuiObjectRef', { objectId: sn, version: V.u64(), digest: Pi }),
  I6 = V.struct('SharedObjectRef', {
    objectId: sn,
    initialSharedVersion: V.u64(),
    mutable: V.bool(),
  }),
  T6 = V.enum('ObjectArg', { ImmOrOwnedObject: si, SharedObject: I6, Receiving: si }),
  x6 = V.enum('CallArg', {
    Pure: V.struct('Pure', {
      bytes: V.vector(V.u8()).transform({
        input: (e) => (typeof e == 'string' ? io(e) : e),
        output: (e) => gi(new Uint8Array(e)),
      }),
    }),
    Object: T6,
  }),
  qA = V.enum('TypeTag', {
    bool: null,
    u8: null,
    u64: null,
    u128: null,
    address: null,
    signer: null,
    vector: V.lazy(() => qA),
    struct: V.lazy(() => B6),
    u16: null,
    u32: null,
    u256: null,
  }),
  YA = qA.transform({
    input: (e) => (typeof e == 'string' ? Zo.parseFromStr(e, !0) : e),
    output: (e) => Zo.tagToString(e),
  }),
  os = V.enum('Argument', {
    GasCoin: null,
    Input: V.u16(),
    Result: V.u16(),
    NestedResult: V.tuple([V.u16(), V.u16()]),
  }),
  k6 = V.struct('ProgrammableMoveCall', {
    package: sn,
    module: V.string(),
    function: V.string(),
    typeArguments: V.vector(YA),
    arguments: V.vector(os),
  }),
  C6 = V.enum('Command', {
    MoveCall: k6,
    TransferObjects: V.struct('TransferObjects', { objects: V.vector(os), address: os }),
    SplitCoins: V.struct('SplitCoins', { coin: os, amounts: V.vector(os) }),
    MergeCoins: V.struct('MergeCoins', { destination: os, sources: V.vector(os) }),
    Publish: V.struct('Publish', {
      modules: V.vector(
        V.vector(V.u8()).transform({
          input: (e) => (typeof e == 'string' ? io(e) : e),
          output: (e) => gi(new Uint8Array(e)),
        })
      ),
      dependencies: V.vector(sn),
    }),
    MakeMoveVec: V.struct('MakeMoveVec', {
      type: PW(YA).transform({
        input: (e) => (e === null ? { None: !0 } : { Some: e }),
        output: (e) => e.Some ?? null,
      }),
      elements: V.vector(os),
    }),
    Upgrade: V.struct('Upgrade', {
      modules: V.vector(
        V.vector(V.u8()).transform({
          input: (e) => (typeof e == 'string' ? io(e) : e),
          output: (e) => gi(new Uint8Array(e)),
        })
      ),
      dependencies: V.vector(sn),
      package: sn,
      ticket: os,
    }),
  }),
  P6 = V.struct('ProgrammableTransaction', { inputs: V.vector(x6), commands: V.vector(C6) }),
  M6 = V.enum('TransactionKind', {
    ProgrammableTransaction: P6,
    ChangeEpoch: null,
    Genesis: null,
    ConsensusCommitPrologue: null,
  }),
  O6 = V.enum('TransactionExpiration', { None: null, Epoch: CW() }),
  B6 = V.struct('StructTag', {
    address: sn,
    module: V.string(),
    name: V.string(),
    typeParams: V.vector(qA),
  }),
  D6 = V.struct('GasData', { payment: V.vector(si), owner: sn, price: V.u64(), budget: V.u64() }),
  R6 = V.struct('TransactionDataV1', { kind: M6, sender: sn, gasData: D6, expiration: O6 }),
  N6 = V.enum('TransactionData', { V1: R6 }),
  j6 = V.enum('IntentScope', {
    TransactionData: null,
    TransactionEffects: null,
    CheckpointSummary: null,
    PersonalMessage: null,
  }),
  L6 = V.enum('IntentVersion', { V0: null }),
  U6 = V.enum('AppId', { Sui: null }),
  $6 = V.struct('Intent', { scope: j6, version: L6, appId: U6 });
function F6(e) {
  return V.struct(`IntentMessage<${e.name}>`, { intent: $6, value: e });
}
const z6 = V.enum('CompressedSignature', {
    ED25519: V.fixedArray(64, V.u8()),
    Secp256k1: V.fixedArray(64, V.u8()),
    Secp256r1: V.fixedArray(64, V.u8()),
    ZkLogin: V.vector(V.u8()),
  }),
  K6 = V.enum('PublicKey', {
    ED25519: V.fixedArray(32, V.u8()),
    Secp256k1: V.fixedArray(33, V.u8()),
    Secp256r1: V.fixedArray(33, V.u8()),
    ZkLogin: V.vector(V.u8()),
  }),
  V6 = V.struct('MultiSigPkMap', { pubKey: K6, weight: V.u8() }),
  W6 = V.struct('MultiSigPublicKey', { pk_map: V.vector(V6), threshold: V.u16() }),
  MW = V.struct('MultiSig', { sigs: V.vector(z6), bitmap: V.u16(), multisig_pk: W6 }),
  OW = V.vector(V.u8()).transform({
    input: (e) => (typeof e == 'string' ? io(e) : e),
    output: (e) => gi(new Uint8Array(e)),
  }),
  H6 = V.struct('SenderSignedTransaction', { intentMessage: F6(N6), txSignatures: V.vector(OW) }),
  BW = V.vector(H6, { name: 'SenderSignedData' }),
  DW = V.enum('PackageUpgradeError', {
    UnableToFetchPackage: V.struct('UnableToFetchPackage', { packageId: sn }),
    NotAPackage: V.struct('NotAPackage', { objectId: sn }),
    IncompatibleUpgrade: null,
    DigestDoesNotMatch: V.struct('DigestDoesNotMatch', { digest: V.vector(V.u8()) }),
    UnknownUpgradePolicy: V.struct('UnknownUpgradePolicy', { policy: V.u8() }),
    PackageIDDoesNotMatch: V.struct('PackageIDDoesNotMatch', { packageId: sn, ticketId: sn }),
  }),
  RW = V.struct('ModuleId', { address: sn, name: V.string() }),
  ik = V.struct('MoveLocation', {
    module: RW,
    function: V.u16(),
    instruction: V.u16(),
    functionName: V.option(V.string()),
  }),
  NW = V.enum('CommandArgumentError', {
    TypeMismatch: null,
    InvalidBCSBytes: null,
    InvalidUsageOfPureArg: null,
    InvalidArgumentToPrivateEntryFunction: null,
    IndexOutOfBounds: V.struct('IndexOutOfBounds', { idx: V.u16() }),
    SecondaryIndexOutOfBounds: V.struct('SecondaryIndexOutOfBounds', {
      resultIdx: V.u16(),
      secondaryIdx: V.u16(),
    }),
    InvalidResultArity: V.struct('InvalidResultArity', { resultIdx: V.u16() }),
    InvalidGasCoinUsage: null,
    InvalidValueUsage: null,
    InvalidObjectByValue: null,
    InvalidObjectByMutRef: null,
    SharedObjectOperationNotAllowed: null,
  }),
  jW = V.enum('TypeArgumentError', { TypeNotFound: null, ConstraintNotSatisfied: null }),
  LW = V.enum('ExecutionFailureStatus', {
    InsufficientGas: null,
    InvalidGasObject: null,
    InvariantViolation: null,
    FeatureNotYetSupported: null,
    MoveObjectTooBig: V.struct('MoveObjectTooBig', { objectSize: V.u64(), maxObjectSize: V.u64() }),
    MovePackageTooBig: V.struct('MovePackageTooBig', {
      objectSize: V.u64(),
      maxObjectSize: V.u64(),
    }),
    CircularObjectOwnership: V.struct('CircularObjectOwnership', { object: sn }),
    InsufficientCoinBalance: null,
    CoinBalanceOverflow: null,
    PublishErrorNonZeroAddress: null,
    SuiMoveVerificationError: null,
    MovePrimitiveRuntimeError: V.option(ik),
    MoveAbort: V.tuple([ik, V.u64()]),
    VMVerificationOrDeserializationError: null,
    VMInvariantViolation: null,
    FunctionNotFound: null,
    ArityMismatch: null,
    TypeArityMismatch: null,
    NonEntryFunctionInvoked: null,
    CommandArgumentError: V.struct('CommandArgumentError', { argIdx: V.u16(), kind: NW }),
    TypeArgumentError: V.struct('TypeArgumentError', { argumentIdx: V.u16(), kind: jW }),
    UnusedValueWithoutDrop: V.struct('UnusedValueWithoutDrop', {
      resultIdx: V.u16(),
      secondaryIdx: V.u16(),
    }),
    InvalidPublicFunctionReturnType: V.struct('InvalidPublicFunctionReturnType', { idx: V.u16() }),
    InvalidTransferObject: null,
    EffectsTooLarge: V.struct('EffectsTooLarge', { currentSize: V.u64(), maxSize: V.u64() }),
    PublishUpgradeMissingDependency: null,
    PublishUpgradeDependencyDowngrade: null,
    PackageUpgradeError: V.struct('PackageUpgradeError', { upgradeError: DW }),
    WrittenObjectsTooLarge: V.struct('WrittenObjectsTooLarge', {
      currentSize: V.u64(),
      maxSize: V.u64(),
    }),
    CertificateDenied: null,
    SuiMoveVerificationTimedout: null,
    SharedObjectOperationNotAllowed: null,
    InputObjectDeleted: null,
    ExecutionCancelledDueToSharedObjectCongestion: V.struct(
      'ExecutionCancelledDueToSharedObjectCongestion',
      { congestedObjects: V.vector(sn) }
    ),
    AddressDeniedForCoin: V.struct('AddressDeniedForCoin', { address: sn, coinType: V.string() }),
    CoinTypeGlobalPause: V.struct('CoinTypeGlobalPause', { coinType: V.string() }),
    ExecutionCancelledDueToRandomnessUnavailable: null,
  }),
  G6 = V.enum('ExecutionStatus', {
    Success: null,
    Failed: V.struct('ExecutionFailed', { error: LW, command: V.option(V.u64()) }),
  }),
  q6 = V.struct('GasCostSummary', {
    computationCost: V.u64(),
    storageCost: V.u64(),
    storageRebate: V.u64(),
    nonRefundableStorageFee: V.u64(),
  }),
  Gc = V.enum('Owner', {
    AddressOwner: sn,
    ObjectOwner: sn,
    Shared: V.struct('Shared', { initialSharedVersion: V.u64() }),
    Immutable: null,
  }),
  UW = V.struct('TransactionEffectsV1', {
    status: G6,
    executedEpoch: V.u64(),
    gasUsed: q6,
    modifiedAtVersions: V.vector(V.tuple([sn, V.u64()])),
    sharedObjects: V.vector(si),
    transactionDigest: Pi,
    created: V.vector(V.tuple([si, Gc])),
    mutated: V.vector(V.tuple([si, Gc])),
    unwrapped: V.vector(V.tuple([si, Gc])),
    deleted: V.vector(si),
    unwrappedThenDeleted: V.vector(si),
    wrapped: V.vector(si),
    gasObject: V.tuple([si, Gc]),
    eventsDigest: V.option(Pi),
    dependencies: V.vector(Pi),
  }),
  ZA = V.tuple([V.u64(), Pi]),
  $W = V.enum('ObjectIn', { NotExist: null, Exist: V.tuple([ZA, Gc]) }),
  FW = V.enum('ObjectOut', { NotExist: null, ObjectWrite: V.tuple([Pi, Gc]), PackageWrite: ZA }),
  zW = V.enum('IDOperation', { None: null, Created: null, Deleted: null }),
  KW = V.struct('EffectsObjectChange', { inputState: $W, outputState: FW, idOperation: zW }),
  VW = V.enum('UnchangedSharedKind', {
    ReadOnlyRoot: ZA,
    MutateDeleted: V.u64(),
    ReadDeleted: V.u64(),
    Cancelled: V.u64(),
    PerEpochConfig: null,
  }),
  WW = V.struct('TransactionEffectsV2', {
    status: G6,
    executedEpoch: V.u64(),
    gasUsed: q6,
    transactionDigest: Pi,
    gasObjectIndex: V.option(V.u32()),
    eventsDigest: V.option(Pi),
    dependencies: V.vector(Pi),
    lamportVersion: V.u64(),
    changedObjects: V.vector(V.tuple([sn, KW])),
    unchangedSharedObjects: V.vector(V.tuple([sn, VW])),
    auxDataDigest: V.option(Pi),
  }),
  HW = V.enum('TransactionEffects', { V1: UW, V2: WW }),
  Qc = {
    ...V,
    U8: V.u8(),
    U16: V.u16(),
    U32: V.u32(),
    U64: V.u64(),
    U128: V.u128(),
    U256: V.u256(),
    ULEB128: V.uleb128(),
    Bool: V.bool(),
    String: V.string(),
    Address: sn,
    AppId: U6,
    Argument: os,
    CallArg: x6,
    CompressedSignature: z6,
    GasData: D6,
    Intent: $6,
    IntentMessage: F6,
    IntentScope: j6,
    IntentVersion: L6,
    MultiSig: MW,
    MultiSigPkMap: V6,
    MultiSigPublicKey: W6,
    ObjectArg: T6,
    ObjectDigest: Pi,
    ProgrammableMoveCall: k6,
    ProgrammableTransaction: P6,
    PublicKey: K6,
    SenderSignedData: BW,
    SenderSignedTransaction: H6,
    SharedObjectRef: I6,
    StructTag: B6,
    SuiObjectRef: si,
    Command: C6,
    TransactionData: N6,
    TransactionDataV1: R6,
    TransactionExpiration: O6,
    TransactionKind: M6,
    TypeTag: YA,
    TransactionEffects: HW,
  };
function Y6(e, t) {
  return Qc.IntentMessage(Qc.fixedArray(t.length, Qc.u8()))
    .serialize({
      intent: { scope: { [e]: !0 }, version: { V0: !0 }, appId: { Sui: !0 } },
      value: t,
    })
    .toBytes();
}
const Sd = { ED25519: 0, Secp256k1: 1, Secp256r1: 2, MultiSig: 3, ZkLogin: 5 },
  GW = { ED25519: 32, Secp256k1: 33, Secp256r1: 33 },
  Z6 = { 0: 'ED25519', 1: 'Secp256k1', 2: 'Secp256r1', 3: 'MultiSig', 5: 'ZkLogin' };
function J6(e, t) {
  if (e === t) return !0;
  if (e.length !== t.length) return !1;
  for (let n = 0; n < e.length; n++) if (e[n] !== t[n]) return !1;
  return !0;
}
let X6 = class {
  equals(t) {
    return J6(this.toRawBytes(), t.toRawBytes());
  }
  toBase64() {
    return gi(this.toRawBytes());
  }
  toString() {
    throw new Error(
      '`toString` is not implemented on public keys. Use `toBase64()` or `toRawBytes()` instead.'
    );
  }
  toSuiPublicKey() {
    const t = this.toSuiBytes();
    return gi(t);
  }
  verifyWithIntent(t, n, r) {
    const i = Y6(r, t),
      s = Ly(i, { dkLen: 32 });
    return this.verify(s, n);
  }
  verifyPersonalMessage(t, n) {
    return this.verifyWithIntent(Qc.vector(Qc.u8()).serialize(t).toBytes(), n, 'PersonalMessage');
  }
  verifyTransaction(t, n) {
    return this.verifyWithIntent(t, n, 'TransactionData');
  }
  toSuiBytes() {
    const t = this.toRawBytes(),
      n = new Uint8Array(t.length + 1);
    return n.set([this.flag()]), n.set(t, 1), n;
  }
  toSuiAddress() {
    return Xc(E6(Ly(this.toSuiBytes(), { dkLen: 32 })).slice(0, _d * 2));
  }
};
var Q6 = (e) => {
    throw TypeError(e);
  },
  eO = (e, t, n) => t.has(e) || Q6('Cannot ' + n),
  Hp = (e, t, n) => (eO(e, t, 'read from private field'), n ? n.call(e) : t.get(e)),
  Gp = (e, t, n) =>
    t.has(e)
      ? Q6('Cannot add the same private member more than once')
      : t instanceof WeakSet
        ? t.add(e)
        : t.set(e, n),
  qp = (e, t, n, r) => (eO(e, t, 'write to private field'), r ? r.call(e, n) : t.set(e, n), n),
  Fg,
  zg,
  Kg,
  Vg;
class qW extends Error {}
class YW {
  constructor({ url: t, fetch: n = fetch, headers: r = {}, queries: i = {} }) {
    Gp(this, Fg),
      Gp(this, zg),
      Gp(this, Kg),
      Gp(this, Vg),
      qp(this, Fg, t),
      qp(this, zg, i),
      qp(this, Kg, r),
      qp(this, Vg, (...s) => n(...s));
  }
  async query(t) {
    const n = await Hp(this, Vg).call(this, Hp(this, Fg), {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...Hp(this, Kg) },
      body: JSON.stringify({
        query: typeof t.query == 'string' ? String(t.query) : v9(t.query),
        variables: t.variables,
        extensions: t.extensions,
        operationName: t.operationName,
      }),
    });
    if (!n.ok) throw new qW(`GraphQL request failed: ${n.statusText} (${n.status})`);
    return await n.json();
  }
  async execute(t, n) {
    return this.query({ ...n, query: Hp(this, zg)[t] });
  }
}
Fg = new WeakMap();
zg = new WeakMap();
Kg = new WeakMap();
Vg = new WeakMap();
const ZW = _9();
function JW(e) {
  if (e.length !== 1) throw new Error('Invalid base64Url character: ' + e);
  const n = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'.indexOf(e);
  if (n === -1) throw new Error('Invalid base64Url character: ' + e);
  const r = n.toString(2).padStart(6, '0');
  return Array.from(r).map(Number);
}
function XW(e) {
  let t = [];
  for (let n = 0; n < e.length; n++) {
    const r = e.charAt(n),
      i = JW(r);
    t = t.concat(i);
  }
  return t;
}
function QW(e, t) {
  if (e.length < 2) throw new Error(`Input (s = ${e}) is not tightly packed because s.length < 2`);
  let n = XW(e);
  const r = t % 4;
  if (r !== 0)
    if (r === 1) n = n.slice(2);
    else if (r === 2) n = n.slice(4);
    else throw new Error(`Input (s = ${e}) is not tightly packed because i%4 = 3 (i = ${t}))`);
  const i = (t + e.length - 1) % 4;
  if (i !== 3)
    if (i === 2) n = n.slice(0, n.length - 2);
    else if (i === 1) n = n.slice(0, n.length - 4);
    else
      throw new Error(
        `Input (s = ${e}) is not tightly packed because (i + s.length - 1)%4 = 0 (i = ${t}))`
      );
  if (n.length % 8 !== 0) throw new Error('We should never reach here...');
  const s = new Uint8Array(Math.floor(n.length / 8));
  let o = 0;
  for (let a = 0; a < n.length; a += 8) {
    const c = n.slice(a, a + 8),
      u = parseInt(c.join(''), 2);
    s[o++] = u;
  }
  return new TextDecoder().decode(s);
}
function eH(e) {
  if (!(e.slice(-1) === '}' || e.slice(-1) === ',')) throw new Error('Invalid claim');
  const t = JSON.parse('{' + e.slice(0, -1) + '}');
  if (Object.keys(t).length !== 1) throw new Error('Invalid claim');
  const n = Object.keys(t)[0];
  return [n, t[n]];
}
function tH(e, t) {
  const n = QW(e.value, e.indexMod4),
    [r, i] = eH(n);
  if (r !== t) throw new Error(`Invalid field name: found ${r} expected ${t}`);
  return i;
}
const nH = V.struct('ZkLoginSignature', {
  inputs: V.struct('ZkLoginSignatureInputs', {
    proofPoints: V.struct('ZkLoginSignatureInputsProofPoints', {
      a: V.vector(V.string()),
      b: V.vector(V.vector(V.string())),
      c: V.vector(V.string()),
    }),
    issBase64Details: V.struct('ZkLoginSignatureInputsClaim', {
      value: V.string(),
      indexMod4: V.u8(),
    }),
    headerBase64: V.string(),
    addressSeed: V.string(),
  }),
  maxEpoch: V.u64(),
  userSignature: V.vector(V.u8()),
});
function rH(e) {
  return nH.parse(typeof e == 'string' ? io(e) : e);
}
function iH(e) {
  for (let t = 0; t < e.length; t++) if (e[t] !== 0) return t;
  return -1;
}
function JA(e, t) {
  const n = e.toString(16);
  return ZV(n.padStart(t * 2, '0').slice(-t * 2));
}
function tO(e, t) {
  const n = JA(e, t),
    r = iH(n);
  return r === -1 ? new Uint8Array([0]) : n.slice(r);
}
var nO = (e) => {
    throw TypeError(e);
  },
  rO = (e, t, n) => t.has(e) || nO('Cannot ' + n),
  Os = (e, t, n) => (rO(e, t, 'read from private field'), n ? n.call(e) : t.get(e)),
  $w = (e, t, n) =>
    t.has(e)
      ? nO('Cannot add the same private member more than once')
      : t instanceof WeakSet
        ? t.add(e)
        : t.set(e, n),
  Nc = (e, t, n, r) => (rO(e, t, 'write to private field'), r ? r.call(e, n) : t.set(e, n), n),
  _i,
  Dl,
  Rl;
const sH = class CS extends X6 {
  constructor(t, { client: n } = {}) {
    super(),
      $w(this, _i),
      $w(this, Dl),
      $w(this, Rl),
      Nc(this, Dl, n),
      typeof t == 'string'
        ? Nc(this, _i, io(t))
        : t instanceof Uint8Array
          ? Nc(this, _i, t)
          : Nc(this, _i, Uint8Array.from(t)),
      Nc(this, Rl, Os(this, _i).length !== Os(this, _i)[0] + 1 + 32),
      Os(this, Rl) && Nc(this, _i, sk(Os(this, _i)));
  }
  equals(t) {
    return super.equals(t);
  }
  toSuiAddress() {
    if (Os(this, Rl)) {
      const t = sk(Os(this, _i), !0),
        n = new Uint8Array(t.length + 1);
      return (n[0] = this.flag()), n.set(t, 1), Xc(E6(Ly(n, { dkLen: 32 })).slice(0, _d * 2));
    }
    return super.toSuiAddress();
  }
  toRawBytes() {
    return Os(this, _i);
  }
  flag() {
    return Sd.ZkLogin;
  }
  async verify(t, n) {
    throw Error('does not support');
  }
  verifyPersonalMessage(t, n) {
    const r = PS(n),
      i = new CS(r.publicKey).toSuiAddress();
    return ok({
      address: i,
      bytes: gi(t),
      signature: r.serializedSignature,
      intentScope: 'PERSONAL_MESSAGE',
      client: Os(this, Dl),
    });
  }
  verifyTransaction(t, n) {
    const r = PS(n),
      i = new CS(r.publicKey).toSuiAddress();
    return ok({
      address: i,
      bytes: gi(t),
      signature: r.serializedSignature,
      intentScope: 'TRANSACTION_DATA',
      client: Os(this, Dl),
    });
  }
};
_i = new WeakMap();
Dl = new WeakMap();
Rl = new WeakMap();
let oH = sH;
function aH(e, t, n) {
  const r = n != null && n.legacyAddress ? tO(e, 32) : JA(e, 32),
    i = new TextEncoder().encode(t),
    s = new Uint8Array(1 + i.length + r.length);
  return s.set([i.length], 0), s.set(i, 1), s.set(r, 1 + i.length), new oH(s, n);
}
const cH = ZW(`
	query Zklogin(
		$bytes: Base64!
		$signature: Base64!
		$intentScope: ZkLoginIntentScope!
		$author: SuiAddress!
	) {
		verifyZkloginSignature(
			bytes: $bytes
			signature: $signature
			intentScope: $intentScope
			author: $author
		) {
			success
			errors
		}
	}
`);
function sk(e, t = !1) {
  const n = e[0] + 1,
    r = BigInt(`0x${my(e.slice(n))}`),
    i = t ? tO(r, 32) : JA(r, 32),
    s = new Uint8Array(n + i.length);
  return s.set(e.slice(0, n), 0), s.set(i, n), s;
}
async function ok({
  address: e,
  bytes: t,
  signature: n,
  intentScope: r,
  client: i = new YW({ url: 'https://sui-mainnet.mystenlabs.com/graphql' }),
}) {
  var o, a;
  const s = await i.query({
    query: cH,
    variables: { bytes: t, signature: n, intentScope: r, author: e },
  });
  return (
    ((o = s.data) == null ? void 0 : o.verifyZkloginSignature.success) === !0 &&
    ((a = s.data) == null ? void 0 : a.verifyZkloginSignature.errors.length) === 0
  );
}
function PS(e) {
  const t = typeof e == 'string' ? io(e) : e;
  if (t[0] !== Sd.ZkLogin) throw new Error('Invalid signature scheme');
  const n = t.slice(1),
    { inputs: r, maxEpoch: i, userSignature: s } = rH(n),
    { issBase64Details: o, addressSeed: a } = r,
    c = tH(o, 'iss'),
    u = aH(BigInt(a), c);
  return {
    serializedSignature: gi(t),
    signatureScheme: 'ZkLogin',
    zkLogin: { inputs: r, maxEpoch: i, userSignature: s, iss: c, addressSeed: BigInt(a) },
    signature: t,
    publicKey: u.toRawBytes(),
  };
}
function uH({ signature: e, signatureScheme: t, publicKey: n }) {
  if (!n) throw new Error('`publicKey` is required');
  const r = n.toRawBytes(),
    i = new Uint8Array(1 + e.length + r.length);
  return i.set([Sd[t]]), i.set(e, 1), i.set(r, 1 + e.length), gi(i);
}
function lH(e) {
  const t = io(e),
    n = Z6[t[0]];
  switch (n) {
    case 'MultiSig':
      const r = Qc.MultiSig.parse(t.slice(1));
      return { serializedSignature: e, signatureScheme: n, multisig: r, bytes: t };
    case 'ZkLogin':
      return PS(e);
    case 'ED25519':
    case 'Secp256k1':
    case 'Secp256r1':
      const i = GW[n],
        s = t.slice(1, t.length - i),
        o = t.slice(1 + s.length);
      return { serializedSignature: e, signatureScheme: n, signature: s, publicKey: o, bytes: t };
    default:
      throw new Error('Unsupported signature scheme');
  }
}
const Wg = 32,
  iO = 'suiprivkey';
let dH = class {
    async signWithIntent(t, n) {
      const r = Y6(n, t),
        i = Ly(r, { dkLen: 32 });
      return {
        signature: uH({
          signature: await this.sign(i),
          signatureScheme: this.getKeyScheme(),
          publicKey: this.getPublicKey(),
        }),
        bytes: gi(t),
      };
    }
    async signTransaction(t) {
      return this.signWithIntent(t, 'TransactionData');
    }
    async signPersonalMessage(t) {
      const { signature: n } = await this.signWithIntent(
        V.vector(V.u8()).serialize(t).toBytes(),
        'PersonalMessage'
      );
      return { bytes: gi(t), signature: n };
    }
    toSuiAddress() {
      return this.getPublicKey().toSuiAddress();
    }
  },
  fH = class extends dH {};
function hH(e) {
  const { prefix: t, words: n } = Ey.decode(e);
  if (t !== iO) throw new Error('invalid private key prefix');
  const r = new Uint8Array(Ey.fromWords(n)),
    i = r.slice(1);
  return { schema: Z6[r[0]], secretKey: i };
}
function pH(e, t) {
  if (e.length !== Wg) throw new Error('Invalid bytes length');
  const n = Sd[t],
    r = new Uint8Array(e.length + 1);
  return r.set([n]), r.set(e, 1), Ey.encode(iO, Ey.toWords(r));
}
function ak(e) {
  return !!new RegExp("^m\\/44'\\/784'\\/[0-9]+'\\/[0-9]+'\\/[0-9]+'+$").test(e);
}
function gH(e) {
  return S9(e, '');
}
function yH(e) {
  return my(gH(e));
}
let sO = class extends GA {
  constructor(t, n) {
    super(), (this.finished = !1), (this.destroyed = !1), qV(t);
    const r = ca(n);
    if (((this.iHash = t.create()), typeof this.iHash.update != 'function'))
      throw new Error('Expected instance of class which extends utils.Hash');
    (this.blockLen = this.iHash.blockLen), (this.outputLen = this.iHash.outputLen);
    const i = this.blockLen,
      s = new Uint8Array(i);
    s.set(r.length > i ? t.create().update(r).digest() : r);
    for (let o = 0; o < s.length; o++) s[o] ^= 54;
    this.iHash.update(s), (this.oHash = t.create());
    for (let o = 0; o < s.length; o++) s[o] ^= 106;
    this.oHash.update(s), s.fill(0);
  }
  update(t) {
    return vu(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    vu(this),
      Fb(t, this.outputLen),
      (this.finished = !0),
      this.iHash.digestInto(t),
      this.oHash.update(t),
      this.oHash.digestInto(t),
      this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n, iHash: r, finished: i, destroyed: s, blockLen: o, outputLen: a } = this;
    return (
      (t = t),
      (t.finished = i),
      (t.destroyed = s),
      (t.blockLen = o),
      (t.outputLen = a),
      (t.oHash = n._cloneInto(t.oHash)),
      (t.iHash = r._cloneInto(t.iHash)),
      t
    );
  }
  destroy() {
    (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
  }
};
const XA = (e, t, n) => new sO(e, t).update(n).digest();
XA.create = (e, t) => new sO(e, t);
function bH(e, t, n, r) {
  if (typeof e.setBigUint64 == 'function') return e.setBigUint64(t, n, r);
  const i = BigInt(32),
    s = BigInt(4294967295),
    o = Number((n >> i) & s),
    a = Number(n & s),
    c = r ? 4 : 0,
    u = r ? 0 : 4;
  e.setUint32(t + c, o, r), e.setUint32(t + u, a, r);
}
class mH extends GA {
  constructor(t, n, r, i) {
    super(),
      (this.blockLen = t),
      (this.outputLen = n),
      (this.padOffset = r),
      (this.isLE = i),
      (this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.buffer = new Uint8Array(t)),
      (this.view = Uw(this.buffer));
  }
  update(t) {
    vu(this);
    const { view: n, buffer: r, blockLen: i } = this;
    t = ca(t);
    const s = t.length;
    for (let o = 0; o < s; ) {
      const a = Math.min(i - this.pos, s - o);
      if (a === i) {
        const c = Uw(t);
        for (; i <= s - o; o += i) this.process(c, o);
        continue;
      }
      r.set(t.subarray(o, o + a), this.pos),
        (this.pos += a),
        (o += a),
        this.pos === i && (this.process(n, 0), (this.pos = 0));
    }
    return (this.length += t.length), this.roundClean(), this;
  }
  digestInto(t) {
    vu(this), _6(t, this), (this.finished = !0);
    const { buffer: n, view: r, blockLen: i, isLE: s } = this;
    let { pos: o } = this;
    (n[o++] = 128),
      this.buffer.subarray(o).fill(0),
      this.padOffset > i - o && (this.process(r, 0), (o = 0));
    for (let d = o; d < i; d++) n[d] = 0;
    bH(r, i - 8, BigInt(this.length * 8), s), this.process(r, 0);
    const a = Uw(t),
      c = this.outputLen;
    if (c % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
    const u = c / 4,
      l = this.get();
    if (u > l.length) throw new Error('_sha2: outputLen bigger than state');
    for (let d = 0; d < u; d++) a.setUint32(4 * d, l[d], s);
  }
  digest() {
    const { buffer: t, outputLen: n } = this;
    this.digestInto(t);
    const r = t.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: n, buffer: r, length: i, finished: s, destroyed: o, pos: a } = this;
    return (
      (t.length = i), (t.pos = a), (t.finished = s), (t.destroyed = o), i % n && t.buffer.set(r), t
    );
  }
}
const [wH, vH] = Ke.split(
    [
      '0x428a2f98d728ae22',
      '0x7137449123ef65cd',
      '0xb5c0fbcfec4d3b2f',
      '0xe9b5dba58189dbbc',
      '0x3956c25bf348b538',
      '0x59f111f1b605d019',
      '0x923f82a4af194f9b',
      '0xab1c5ed5da6d8118',
      '0xd807aa98a3030242',
      '0x12835b0145706fbe',
      '0x243185be4ee4b28c',
      '0x550c7dc3d5ffb4e2',
      '0x72be5d74f27b896f',
      '0x80deb1fe3b1696b1',
      '0x9bdc06a725c71235',
      '0xc19bf174cf692694',
      '0xe49b69c19ef14ad2',
      '0xefbe4786384f25e3',
      '0x0fc19dc68b8cd5b5',
      '0x240ca1cc77ac9c65',
      '0x2de92c6f592b0275',
      '0x4a7484aa6ea6e483',
      '0x5cb0a9dcbd41fbd4',
      '0x76f988da831153b5',
      '0x983e5152ee66dfab',
      '0xa831c66d2db43210',
      '0xb00327c898fb213f',
      '0xbf597fc7beef0ee4',
      '0xc6e00bf33da88fc2',
      '0xd5a79147930aa725',
      '0x06ca6351e003826f',
      '0x142929670a0e6e70',
      '0x27b70a8546d22ffc',
      '0x2e1b21385c26c926',
      '0x4d2c6dfc5ac42aed',
      '0x53380d139d95b3df',
      '0x650a73548baf63de',
      '0x766a0abb3c77b2a8',
      '0x81c2c92e47edaee6',
      '0x92722c851482353b',
      '0xa2bfe8a14cf10364',
      '0xa81a664bbc423001',
      '0xc24b8b70d0f89791',
      '0xc76c51a30654be30',
      '0xd192e819d6ef5218',
      '0xd69906245565a910',
      '0xf40e35855771202a',
      '0x106aa07032bbd1b8',
      '0x19a4c116b8d2d0c8',
      '0x1e376c085141ab53',
      '0x2748774cdf8eeb99',
      '0x34b0bcb5e19b48a8',
      '0x391c0cb3c5c95a63',
      '0x4ed8aa4ae3418acb',
      '0x5b9cca4f7763e373',
      '0x682e6ff3d6b2b8a3',
      '0x748f82ee5defb2fc',
      '0x78a5636f43172f60',
      '0x84c87814a1f0ab72',
      '0x8cc702081a6439ec',
      '0x90befffa23631e28',
      '0xa4506cebde82bde9',
      '0xbef9a3f7b2c67915',
      '0xc67178f2e372532b',
      '0xca273eceea26619c',
      '0xd186b8c721c0c207',
      '0xeada7dd6cde0eb1e',
      '0xf57d4f7fee6ed178',
      '0x06f067aa72176fba',
      '0x0a637dc5a2c898a6',
      '0x113f9804bef90dae',
      '0x1b710b35131c471b',
      '0x28db77f523047d84',
      '0x32caab7b40c72493',
      '0x3c9ebe0a15c9bebc',
      '0x431d67c49c100d4c',
      '0x4cc5d4becb3e42b6',
      '0x597f299cfc657e2a',
      '0x5fcb6fab3ad6faec',
      '0x6c44198c4a475817',
    ].map((e) => BigInt(e))
  ),
  _o = new Uint32Array(80),
  So = new Uint32Array(80);
let _H = class extends mH {
  constructor() {
    super(128, 64, 16, !1),
      (this.Ah = 1779033703),
      (this.Al = -205731576),
      (this.Bh = -1150833019),
      (this.Bl = -2067093701),
      (this.Ch = 1013904242),
      (this.Cl = -23791573),
      (this.Dh = -1521486534),
      (this.Dl = 1595750129),
      (this.Eh = 1359893119),
      (this.El = -1377402159),
      (this.Fh = -1694144372),
      (this.Fl = 725511199),
      (this.Gh = 528734635),
      (this.Gl = -79577749),
      (this.Hh = 1541459225),
      (this.Hl = 327033209);
  }
  get() {
    const {
      Ah: t,
      Al: n,
      Bh: r,
      Bl: i,
      Ch: s,
      Cl: o,
      Dh: a,
      Dl: c,
      Eh: u,
      El: l,
      Fh: d,
      Fl: f,
      Gh: h,
      Gl: p,
      Hh: b,
      Hl: w,
    } = this;
    return [t, n, r, i, s, o, a, c, u, l, d, f, h, p, b, w];
  }
  set(t, n, r, i, s, o, a, c, u, l, d, f, h, p, b, w) {
    (this.Ah = t | 0),
      (this.Al = n | 0),
      (this.Bh = r | 0),
      (this.Bl = i | 0),
      (this.Ch = s | 0),
      (this.Cl = o | 0),
      (this.Dh = a | 0),
      (this.Dl = c | 0),
      (this.Eh = u | 0),
      (this.El = l | 0),
      (this.Fh = d | 0),
      (this.Fl = f | 0),
      (this.Gh = h | 0),
      (this.Gl = p | 0),
      (this.Hh = b | 0),
      (this.Hl = w | 0);
  }
  process(t, n) {
    for (let x = 0; x < 16; x++, n += 4) (_o[x] = t.getUint32(n)), (So[x] = t.getUint32((n += 4)));
    for (let x = 16; x < 80; x++) {
      const k = _o[x - 15] | 0,
        j = So[x - 15] | 0,
        F = Ke.rotrSH(k, j, 1) ^ Ke.rotrSH(k, j, 8) ^ Ke.shrSH(k, j, 7),
        K = Ke.rotrSL(k, j, 1) ^ Ke.rotrSL(k, j, 8) ^ Ke.shrSL(k, j, 7),
        D = _o[x - 2] | 0,
        C = So[x - 2] | 0,
        B = Ke.rotrSH(D, C, 19) ^ Ke.rotrBH(D, C, 61) ^ Ke.shrSH(D, C, 6),
        E = Ke.rotrSL(D, C, 19) ^ Ke.rotrBL(D, C, 61) ^ Ke.shrSL(D, C, 6),
        y = Ke.add4L(K, E, So[x - 7], So[x - 16]),
        v = Ke.add4H(y, F, B, _o[x - 7], _o[x - 16]);
      (_o[x] = v | 0), (So[x] = y | 0);
    }
    let {
      Ah: r,
      Al: i,
      Bh: s,
      Bl: o,
      Ch: a,
      Cl: c,
      Dh: u,
      Dl: l,
      Eh: d,
      El: f,
      Fh: h,
      Fl: p,
      Gh: b,
      Gl: w,
      Hh: A,
      Hl: _,
    } = this;
    for (let x = 0; x < 80; x++) {
      const k = Ke.rotrSH(d, f, 14) ^ Ke.rotrSH(d, f, 18) ^ Ke.rotrBH(d, f, 41),
        j = Ke.rotrSL(d, f, 14) ^ Ke.rotrSL(d, f, 18) ^ Ke.rotrBL(d, f, 41),
        F = (d & h) ^ (~d & b),
        K = (f & p) ^ (~f & w),
        D = Ke.add5L(_, j, K, vH[x], So[x]),
        C = Ke.add5H(D, A, k, F, wH[x], _o[x]),
        B = D | 0,
        E = Ke.rotrSH(r, i, 28) ^ Ke.rotrBH(r, i, 34) ^ Ke.rotrBH(r, i, 39),
        y = Ke.rotrSL(r, i, 28) ^ Ke.rotrBL(r, i, 34) ^ Ke.rotrBL(r, i, 39),
        v = (r & s) ^ (r & a) ^ (s & a),
        S = (i & o) ^ (i & c) ^ (o & c);
      (A = b | 0),
        (_ = w | 0),
        (b = h | 0),
        (w = p | 0),
        (h = d | 0),
        (p = f | 0),
        ({ h: d, l: f } = Ke.add(u | 0, l | 0, C | 0, B | 0)),
        (u = a | 0),
        (l = c | 0),
        (a = s | 0),
        (c = o | 0),
        (s = r | 0),
        (o = i | 0);
      const T = Ke.add3L(B, y, S);
      (r = Ke.add3H(T, C, E, v)), (i = T | 0);
    }
    ({ h: r, l: i } = Ke.add(this.Ah | 0, this.Al | 0, r | 0, i | 0)),
      ({ h: s, l: o } = Ke.add(this.Bh | 0, this.Bl | 0, s | 0, o | 0)),
      ({ h: a, l: c } = Ke.add(this.Ch | 0, this.Cl | 0, a | 0, c | 0)),
      ({ h: u, l } = Ke.add(this.Dh | 0, this.Dl | 0, u | 0, l | 0)),
      ({ h: d, l: f } = Ke.add(this.Eh | 0, this.El | 0, d | 0, f | 0)),
      ({ h, l: p } = Ke.add(this.Fh | 0, this.Fl | 0, h | 0, p | 0)),
      ({ h: b, l: w } = Ke.add(this.Gh | 0, this.Gl | 0, b | 0, w | 0)),
      ({ h: A, l: _ } = Ke.add(this.Hh | 0, this.Hl | 0, A | 0, _ | 0)),
      this.set(r, i, s, o, a, c, u, l, d, f, h, p, b, w, A, _);
  }
  roundClean() {
    _o.fill(0), So.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
const oO = XV(() => new _H()),
  SH = 'ed25519 seed',
  EH = 2147483648,
  AH = new RegExp("^m(\\/[0-9]+')+$"),
  aO = (e) => e.replace("'", ''),
  IH = (e) => {
    const n = XA.create(oO, SH).update(yP(e)).digest(),
      r = n.slice(0, 32),
      i = n.slice(32);
    return { key: r, chainCode: i };
  },
  TH = ({ key: e, chainCode: t }, n) => {
    const r = new ArrayBuffer(4);
    new DataView(r).setUint32(0, n);
    const s = new Uint8Array(1 + e.length + r.byteLength);
    s.set(new Uint8Array(1).fill(0)),
      s.set(e, 1),
      s.set(new Uint8Array(r, 0, r.byteLength), e.length + 1);
    const o = XA.create(oO, t).update(s).digest(),
      a = o.slice(0, 32),
      c = o.slice(32);
    return { key: a, chainCode: c };
  },
  xH = (e) => (AH.test(e) ? !e.split('/').slice(1).map(aO).some(isNaN) : !1),
  ck = (e, t, n = EH) => {
    if (!xH(e)) throw new Error('Invalid derivation path');
    const { key: r, chainCode: i } = IH(t);
    return e
      .split('/')
      .slice(1)
      .map(aO)
      .map((o) => parseInt(o, 10))
      .reduce((o, a) => TH(o, a + n), { key: r, chainCode: i });
  },
  MS = 32;
class cO extends X6 {
  constructor(t) {
    if (
      (super(),
      typeof t == 'string'
        ? (this.data = io(t))
        : t instanceof Uint8Array
          ? (this.data = t)
          : (this.data = Uint8Array.from(t)),
      this.data.length !== MS)
    )
      throw new Error(`Invalid public key input. Expected ${MS} bytes, got ${this.data.length}`);
  }
  equals(t) {
    return super.equals(t);
  }
  toRawBytes() {
    return this.data;
  }
  flag() {
    return Sd.ED25519;
  }
  async verify(t, n) {
    let r;
    if (typeof n == 'string') {
      const i = lH(n);
      if (i.signatureScheme !== 'ED25519') throw new Error('Invalid signature scheme');
      if (!J6(this.toRawBytes(), i.publicKey))
        throw new Error('Signature does not match public key');
      r = i.signature;
    } else r = n;
    return $s.sign.detached.verify(t, r, this.toRawBytes());
  }
}
cO.SIZE = MS;
const uk = "m/44'/784'/0'/0'/0'";
class qc extends fH {
  constructor(t) {
    super(), t ? (this.keypair = t) : (this.keypair = $s.sign.keyPair());
  }
  getKeyScheme() {
    return 'ED25519';
  }
  static generate() {
    return new qc($s.sign.keyPair());
  }
  static fromSecretKey(t, n) {
    if (typeof t == 'string') {
      const s = hH(t);
      if (s.schema !== 'ED25519') throw new Error(`Expected a ED25519 keypair, got ${s.schema}`);
      return this.fromSecretKey(s.secretKey, n);
    }
    const r = t.length;
    if (r !== Wg) throw new Error(`Wrong secretKey size. Expected ${Wg} bytes, got ${r}.`);
    const i = $s.sign.keyPair.fromSeed(t);
    if (!n || !n.skipValidation) {
      const o = new TextEncoder().encode('sui validation'),
        a = $s.sign.detached(o, i.secretKey);
      if (!$s.sign.detached.verify(o, a, i.publicKey))
        throw new Error('provided secretKey is invalid');
    }
    return new qc(i);
  }
  getPublicKey() {
    return new cO(this.keypair.publicKey);
  }
  getSecretKey() {
    return pH(this.keypair.secretKey.slice(0, Wg), this.getKeyScheme());
  }
  async sign(t) {
    return $s.sign.detached(t, this.keypair.secretKey);
  }
  static deriveKeypair(t, n) {
    if ((n == null && (n = uk), !ak(n))) throw new Error('Invalid derivation path');
    const { key: r } = ck(n, yH(t));
    return qc.fromSecretKey(r);
  }
  static deriveKeypairFromSeed(t, n) {
    if ((n == null && (n = uk), !ak(n))) throw new Error('Invalid derivation path');
    const { key: r } = ck(n, t);
    return qc.fromSecretKey(r);
  }
}
const kH = () => ({
  type: Kr.KeyPair,
  sign: async (e, t) => {
    const n = qc.fromSecretKey(e.privateKey);
    try {
      let r;
      switch (t.signingType) {
        case 'personalMessage': {
          r = await n.signPersonalMessage(t.message);
          break;
        }
        case 'transaction': {
          r = await n.signTransaction(t.transaction);
          break;
        }
      }
      return Promise.resolve({ status: 'success', signature: r.signature });
    } catch (r) {
      return console.error(r), Promise.resolve(an(at.InvalidMessageEncoding));
    }
  },
});
var Lr;
class CH {
  constructor(t) {
    Vt(this, Lr);
    Ft(this, Lr, t);
  }
  async signWithKeypair(t, n) {
    if ('isJWT' in n) return oe(this, Lr).keyPair.JWT.sign(t, n);
    if ('isAgentWallet' in n) return oe(this, Lr).keyPair.Agent.sign(t, n);
    if ('isCash' in n) return oe(this, Lr).keyPair.Cash.sign(t, n);
    const r = n.chainType;
    switch (r) {
      case G.BitcoinTaproot:
      case G.BitcoinNativeSegwit:
      case G.BitcoinNestedSegwit:
      case G.BitcoinLegacy:
        return oe(this, Lr).keyPair[r].sign(t, n);
      case G.EVM:
        return oe(this, Lr).keyPair[r].sign(t, n);
      case G.Solana:
        return oe(this, Lr).keyPair[r].sign(t, n);
      case G.Sui:
        return oe(this, Lr).keyPair[r].sign(t, n);
    }
  }
  async signWithHardware(t, n, r) {
    return oe(this, Lr).ledger.sign(t, n, r);
  }
  async signWithSolanaSeedVault(t, n, r) {
    return oe(this, Lr).seedVault.sign(t, n, r);
  }
}
Lr = new WeakMap();
const PH = (e) => ({
    getSeed: (t) => MH(e, t),
    setSeed: (t, n) => OH(e, t, n),
    getClientJWTSigner: (t, n) => BH(e, t, n),
    setClientJWTSigner: (t, n, r) => DH(e, t, n, r),
    removeSeeds: (t) => lk(e, t),
    removeClientJWTKeypairs: (t) => dk(e, t),
    clear: async () => {
      await lk(e, 'all'), await dk(e, 'all');
    },
  }),
  pa = `${As}.cache.secrets`,
  QA = (e) => `${As}.cache.seed.${e}`,
  eI = (e) => `${As}.cache.client-jwt.${e}`,
  MH = async ({ isEnabled: e, secretsStorage: t }, n) => {
    if (!e()) return null;
    const r = QA(n);
    let i = null;
    try {
      i = await t.getSecureValue(r);
    } catch {}
    if (!i) return null;
    const { bytes: s, encoding: o } = i.seed;
    return new Uint8Array(z.from(s, o));
  },
  OH = async ({ isEnabled: e, generalStorage: t, secretsStorage: n }, r, i) => {
    if (!e()) return;
    const s = QA(r);
    await n.setSecureValue(s, {
      version: 1,
      identifier: r,
      seed: { bytes: z.from(i).toString('base64'), encoding: 'base64' },
    });
    let o = await t.get(pa);
    if (!o) o = { version: 1, seedIdentifiers: [r], clientJWTKeypairIdentifiers: [] };
    else {
      const a = new Set(o.seedIdentifiers);
      a.add(r), (o.seedIdentifiers = Array.from(a));
    }
    await t.set(pa, o);
  },
  lk = async ({ generalStorage: e, secretsStorage: t }, n) => {
    const r = await e.get(pa);
    if (!r) return;
    const i = n === 'all' ? r.seedIdentifiers : n,
      s = new Set(i),
      o = r.seedIdentifiers.filter((a) => s.has(a));
    await t.removeSecureValue(o.map(QA)),
      await e.set(pa, {
        version: 1,
        seedIdentifiers: r.seedIdentifiers.filter((a) => !s.has(a)),
        clientJWTKeypairIdentifiers: r.clientJWTKeypairIdentifiers ?? [],
      });
  },
  BH = async ({ isEnabled: e, secretsStorage: t }, n, r) => {
    if (!e()) return null;
    const i = eI(n);
    let s = null;
    try {
      s = await t.getSecureValue(i);
    } catch {}
    if (!s || !s.keyPairs[r]) return null;
    const o = s.keyPairs[r],
      a = new Uint8Array(z.from(o.p256pubkey.bytes, o.p256pubkey.encoding)),
      c = new Uint8Array(z.from(o.p256privkey.bytes, o.p256privkey.encoding));
    return { p256pubkey: a, p256privkey: c };
  },
  DH = async ({ isEnabled: e, generalStorage: t, secretsStorage: n }, r, i, s) => {
    if (!e()) return;
    const o = eI(r),
      a = (await n.getSecureValue(o)) ?? { version: 1, identifier: r, keyPairs: {} };
    (a.keyPairs[i] = {
      p256pubkey: { bytes: ki(z.from(s.p256pubkey)), encoding: 'base64' },
      p256privkey: { bytes: ki(z.from(s.p256privkey)), encoding: 'base64' },
    }),
      await n.setSecureValue(o, a);
    let c = await t.get(pa);
    if (!c) c = { version: 1, seedIdentifiers: [], clientJWTKeypairIdentifiers: [r] };
    else {
      const u = new Set(c.clientJWTKeypairIdentifiers ?? []);
      u.add(r), (c.clientJWTKeypairIdentifiers = Array.from(u));
    }
    await t.set(pa, c);
  },
  dk = async ({ generalStorage: e, secretsStorage: t }, n) => {
    const r = await e.get(pa);
    if (!r || !r.clientJWTKeypairIdentifiers || r.clientJWTKeypairIdentifiers.length === 0) return;
    const i = n === 'all' ? r.clientJWTKeypairIdentifiers : n,
      s = new Set(i);
    await t.removeSecureValue(i.map(eI)),
      await e.set(pa, {
        version: 1,
        seedIdentifiers: r.seedIdentifiers,
        clientJWTKeypairIdentifiers: r.clientJWTKeypairIdentifiers.filter((o) => !s.has(o)),
      });
  },
  eu = (e, t) => {
    if (!e) throw new Error(t);
  };
function uO(e) {
  eu(e >= 128, 'Invalid entropy length'),
    eu(e <= 256, 'Invalid entropy length'),
    eu(e % 32 === 0, 'Invalid entropy length');
}
async function RH(e, t) {
  return await e((t * 4) / 3);
}
async function NH(e, t) {
  const n = t.length * 8;
  uO(n);
  const r = n / 32,
    i = await e(t),
    [s] = i;
  return s.toString(2).padStart(8, '0').slice(0, r);
}
function jH(e, t) {
  const n = e.length * 8;
  return (
    uO(n),
    eu(t.length === n / 32, 'Invalid checksum length'),
    Array.from(e)
      .map((r) => r.toString(2).padStart(8, '0'))
      .concat(t)
      .join('')
  );
}
function LH(e, t) {
  var n;
  return (
    eu(t.length === 2048, 'The wordlist should contain exactly 2048 words'),
    eu(t.every(Boolean), 'Wordlist cannot contain falsy entries'),
    ((n = e.match(/(.{1,11})/g)) == null ? void 0 : n.map((r) => t[parseInt(r, 2)])) ?? []
  );
}
async function UH(e) {
  const t = await RH(e.randomValues, e.sentenceLength),
    n = await NH(e.sha256, t),
    r = jH(t, n),
    i = LH(r, e.wordlist);
  return z.from(i.join(' '));
}
async function $H(e) {
  const t = new Uint8Array(
    Array.from('mnemonic' + (e.passphrase ?? '')).map((n) => n.charCodeAt(0))
  );
  return e.pbkdf2(e.mnemonic, t, 2048, 64, 'sha512');
}
function OS(e) {
  if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`);
}
function FH(e) {
  if (typeof e != 'boolean') throw new Error(`Expected boolean, not ${e}`);
}
function lO(e, ...t) {
  if (!(e instanceof Uint8Array)) throw new TypeError('Expected Uint8Array');
  if (t.length > 0 && !t.includes(e.length))
    throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function zH(e) {
  if (typeof e != 'function' || typeof e.create != 'function')
    throw new Error('Hash should be wrapped by utils.wrapConstructor');
  OS(e.outputLen), OS(e.blockLen);
}
function KH(e, t = !0) {
  if (e.destroyed) throw new Error('Hash instance has been destroyed');
  if (t && e.finished) throw new Error('Hash#digest() has already been called');
}
function VH(e, t) {
  lO(e);
  const n = t.outputLen;
  if (e.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`);
}
const Mi = { number: OS, bool: FH, bytes: lO, hash: zH, exists: KH, output: VH };
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Hg = (e) =>
    new DataView(e.buffer, e.byteOffset, e.byteLength),
  Qi = (e, t) => (e << (32 - t)) | (e >>> t),
  WH = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!WH) throw new Error('Non little-endian hardware is not supported');
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, '0'));
function HH(e) {
  if (typeof e != 'string') throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function ed(e) {
  if ((typeof e == 'string' && (e = HH(e)), !(e instanceof Uint8Array)))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
  return e;
}
let dO = class {
  clone() {
    return this._cloneInto();
  }
};
const GH = (e) =>
  Object.prototype.toString.call(e) === '[object Object]' && e.constructor === Object;
function qH(e, t) {
  if (t !== void 0 && (typeof t != 'object' || !GH(t)))
    throw new TypeError('Options should be object or undefined');
  return Object.assign(e, t);
}
function Gu(e) {
  const t = (r) => e().update(ed(r)).digest(),
    n = e();
  return (t.outputLen = n.outputLen), (t.blockLen = n.blockLen), (t.create = () => e()), t;
}
let fO = class extends dO {
  constructor(t, n) {
    super(), (this.finished = !1), (this.destroyed = !1), Mi.hash(t);
    const r = ed(n);
    if (((this.iHash = t.create()), typeof this.iHash.update != 'function'))
      throw new TypeError('Expected instance of class which extends utils.Hash');
    (this.blockLen = this.iHash.blockLen), (this.outputLen = this.iHash.outputLen);
    const i = this.blockLen,
      s = new Uint8Array(i);
    s.set(r.length > i ? t.create().update(r).digest() : r);
    for (let o = 0; o < s.length; o++) s[o] ^= 54;
    this.iHash.update(s), (this.oHash = t.create());
    for (let o = 0; o < s.length; o++) s[o] ^= 106;
    this.oHash.update(s), s.fill(0);
  }
  update(t) {
    return Mi.exists(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    Mi.exists(this),
      Mi.bytes(t, this.outputLen),
      (this.finished = !0),
      this.iHash.digestInto(t),
      this.oHash.update(t),
      this.oHash.digestInto(t),
      this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n, iHash: r, finished: i, destroyed: s, blockLen: o, outputLen: a } = this;
    return (
      (t = t),
      (t.finished = i),
      (t.destroyed = s),
      (t.blockLen = o),
      (t.outputLen = a),
      (t.oHash = n._cloneInto(t.oHash)),
      (t.iHash = r._cloneInto(t.iHash)),
      t
    );
  }
  destroy() {
    (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
  }
};
const hO = (e, t, n) => new fO(e, t).update(n).digest();
hO.create = (e, t) => new fO(e, t);
function YH(e, t, n, r) {
  Mi.hash(e);
  const i = qH({ dkLen: 32, asyncTick: 10 }, r),
    { c: s, dkLen: o, asyncTick: a } = i;
  if ((Mi.number(s), Mi.number(o), Mi.number(a), s < 1))
    throw new Error('PBKDF2: iterations (c) should be >= 1');
  const c = ed(t),
    u = ed(n),
    l = new Uint8Array(o),
    d = hO.create(e, c),
    f = d._cloneInto().update(u);
  return { c: s, dkLen: o, asyncTick: a, DK: l, PRF: d, PRFSalt: f };
}
function ZH(e, t, n, r, i) {
  return e.destroy(), t.destroy(), r && r.destroy(), i.fill(0), n;
}
function JH(e, t, n, r) {
  const { c: i, dkLen: s, DK: o, PRF: a, PRFSalt: c } = YH(e, t, n, r);
  let u;
  const l = new Uint8Array(4),
    d = Hg(l),
    f = new Uint8Array(a.outputLen);
  for (let h = 1, p = 0; p < s; h++, p += a.outputLen) {
    const b = o.subarray(p, p + a.outputLen);
    d.setInt32(0, h, !1),
      (u = c._cloneInto(u)).update(l).digestInto(f),
      b.set(f.subarray(0, b.length));
    for (let w = 1; w < i; w++) {
      a._cloneInto(u).update(f).digestInto(f);
      for (let A = 0; A < b.length; A++) b[A] ^= f[A];
    }
  }
  return ZH(a, c, o, u, f);
}
function XH(e, t, n, r) {
  if (typeof e.setBigUint64 == 'function') return e.setBigUint64(t, n, r);
  const i = BigInt(32),
    s = BigInt(4294967295),
    o = Number((n >> i) & s),
    a = Number(n & s),
    c = r ? 4 : 0,
    u = r ? 0 : 4;
  e.setUint32(t + c, o, r), e.setUint32(t + u, a, r);
}
let pO = class extends dO {
  constructor(t, n, r, i) {
    super(),
      (this.blockLen = t),
      (this.outputLen = n),
      (this.padOffset = r),
      (this.isLE = i),
      (this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.buffer = new Uint8Array(t)),
      (this.view = Hg(this.buffer));
  }
  update(t) {
    Mi.exists(this);
    const { view: n, buffer: r, blockLen: i } = this;
    t = ed(t);
    const s = t.length;
    for (let o = 0; o < s; ) {
      const a = Math.min(i - this.pos, s - o);
      if (a === i) {
        const c = Hg(t);
        for (; i <= s - o; o += i) this.process(c, o);
        continue;
      }
      r.set(t.subarray(o, o + a), this.pos),
        (this.pos += a),
        (o += a),
        this.pos === i && (this.process(n, 0), (this.pos = 0));
    }
    return (this.length += t.length), this.roundClean(), this;
  }
  digestInto(t) {
    Mi.exists(this), Mi.output(t, this), (this.finished = !0);
    const { buffer: n, view: r, blockLen: i, isLE: s } = this;
    let { pos: o } = this;
    (n[o++] = 128),
      this.buffer.subarray(o).fill(0),
      this.padOffset > i - o && (this.process(r, 0), (o = 0));
    for (let d = o; d < i; d++) n[d] = 0;
    XH(r, i - 8, BigInt(this.length * 8), s), this.process(r, 0);
    const a = Hg(t),
      c = this.outputLen;
    if (c % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
    const u = c / 4,
      l = this.get();
    if (u > l.length) throw new Error('_sha2: outputLen bigger than state');
    for (let d = 0; d < u; d++) a.setUint32(4 * d, l[d], s);
  }
  digest() {
    const { buffer: t, outputLen: n } = this;
    this.digestInto(t);
    const r = t.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: n, buffer: r, length: i, finished: s, destroyed: o, pos: a } = this;
    return (
      (t.length = i), (t.pos = a), (t.finished = s), (t.destroyed = o), i % n && t.buffer.set(r), t
    );
  }
};
const QH = (e, t, n) => (e & t) ^ (~e & n),
  eG = (e, t, n) => (e & t) ^ (e & n) ^ (t & n),
  tG = new Uint32Array([
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221,
    3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580,
    3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895,
    666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037,
    2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
    1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298,
  ]),
  Eo = new Uint32Array([
    1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225,
  ]),
  Ao = new Uint32Array(64);
let gO = class extends pO {
    constructor() {
      super(64, 32, 8, !1),
        (this.A = Eo[0] | 0),
        (this.B = Eo[1] | 0),
        (this.C = Eo[2] | 0),
        (this.D = Eo[3] | 0),
        (this.E = Eo[4] | 0),
        (this.F = Eo[5] | 0),
        (this.G = Eo[6] | 0),
        (this.H = Eo[7] | 0);
    }
    get() {
      const { A: t, B: n, C: r, D: i, E: s, F: o, G: a, H: c } = this;
      return [t, n, r, i, s, o, a, c];
    }
    set(t, n, r, i, s, o, a, c) {
      (this.A = t | 0),
        (this.B = n | 0),
        (this.C = r | 0),
        (this.D = i | 0),
        (this.E = s | 0),
        (this.F = o | 0),
        (this.G = a | 0),
        (this.H = c | 0);
    }
    process(t, n) {
      for (let d = 0; d < 16; d++, n += 4) Ao[d] = t.getUint32(n, !1);
      for (let d = 16; d < 64; d++) {
        const f = Ao[d - 15],
          h = Ao[d - 2],
          p = Qi(f, 7) ^ Qi(f, 18) ^ (f >>> 3),
          b = Qi(h, 17) ^ Qi(h, 19) ^ (h >>> 10);
        Ao[d] = (b + Ao[d - 7] + p + Ao[d - 16]) | 0;
      }
      let { A: r, B: i, C: s, D: o, E: a, F: c, G: u, H: l } = this;
      for (let d = 0; d < 64; d++) {
        const f = Qi(a, 6) ^ Qi(a, 11) ^ Qi(a, 25),
          h = (l + f + QH(a, c, u) + tG[d] + Ao[d]) | 0,
          b = ((Qi(r, 2) ^ Qi(r, 13) ^ Qi(r, 22)) + eG(r, i, s)) | 0;
        (l = u), (u = c), (c = a), (a = (o + h) | 0), (o = s), (s = i), (i = r), (r = (h + b) | 0);
      }
      (r = (r + this.A) | 0),
        (i = (i + this.B) | 0),
        (s = (s + this.C) | 0),
        (o = (o + this.D) | 0),
        (a = (a + this.E) | 0),
        (c = (c + this.F) | 0),
        (u = (u + this.G) | 0),
        (l = (l + this.H) | 0),
        this.set(r, i, s, o, a, c, u, l);
    }
    roundClean() {
      Ao.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
    }
  },
  nG = class extends gO {
    constructor() {
      super(),
        (this.A = -1056596264),
        (this.B = 914150663),
        (this.C = 812702999),
        (this.D = -150054599),
        (this.E = -4191439),
        (this.F = 1750603025),
        (this.G = 1694076839),
        (this.H = -1090891868),
        (this.outputLen = 28);
    }
  };
const tI = Gu(() => new gO());
Gu(() => new nG());
const Yp = BigInt(2 ** 32 - 1),
  BS = BigInt(32);
function yO(e, t = !1) {
  return t
    ? { h: Number(e & Yp), l: Number((e >> BS) & Yp) }
    : { h: Number((e >> BS) & Yp) | 0, l: Number(e & Yp) | 0 };
}
function rG(e, t = !1) {
  let n = new Uint32Array(e.length),
    r = new Uint32Array(e.length);
  for (let i = 0; i < e.length; i++) {
    const { h: s, l: o } = yO(e[i], t);
    [n[i], r[i]] = [s, o];
  }
  return [n, r];
}
const iG = (e, t) => (BigInt(e >>> 0) << BS) | BigInt(t >>> 0),
  sG = (e, t, n) => e >>> n,
  oG = (e, t, n) => (e << (32 - n)) | (t >>> n),
  aG = (e, t, n) => (e >>> n) | (t << (32 - n)),
  cG = (e, t, n) => (e << (32 - n)) | (t >>> n),
  uG = (e, t, n) => (e << (64 - n)) | (t >>> (n - 32)),
  lG = (e, t, n) => (e >>> (n - 32)) | (t << (64 - n)),
  dG = (e, t) => t,
  fG = (e, t) => e,
  hG = (e, t, n) => (e << n) | (t >>> (32 - n)),
  pG = (e, t, n) => (t << n) | (e >>> (32 - n)),
  gG = (e, t, n) => (t << (n - 32)) | (e >>> (64 - n)),
  yG = (e, t, n) => (e << (n - 32)) | (t >>> (64 - n));
function bG(e, t, n, r) {
  const i = (t >>> 0) + (r >>> 0);
  return { h: (e + n + ((i / 2 ** 32) | 0)) | 0, l: i | 0 };
}
const mG = (e, t, n) => (e >>> 0) + (t >>> 0) + (n >>> 0),
  wG = (e, t, n, r) => (t + n + r + ((e / 2 ** 32) | 0)) | 0,
  vG = (e, t, n, r) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0),
  _G = (e, t, n, r, i) => (t + n + r + i + ((e / 2 ** 32) | 0)) | 0,
  SG = (e, t, n, r, i) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0) + (i >>> 0),
  EG = (e, t, n, r, i, s) => (t + n + r + i + s + ((e / 2 ** 32) | 0)) | 0,
  it = {
    fromBig: yO,
    split: rG,
    toBig: iG,
    shrSH: sG,
    shrSL: oG,
    rotrSH: aG,
    rotrSL: cG,
    rotrBH: uG,
    rotrBL: lG,
    rotr32H: dG,
    rotr32L: fG,
    rotlSH: hG,
    rotlSL: pG,
    rotlBH: gG,
    rotlBL: yG,
    add: bG,
    add3L: mG,
    add3H: wG,
    add4L: vG,
    add4H: _G,
    add5H: EG,
    add5L: SG,
  },
  [AG, IG] = it.split(
    [
      '0x428a2f98d728ae22',
      '0x7137449123ef65cd',
      '0xb5c0fbcfec4d3b2f',
      '0xe9b5dba58189dbbc',
      '0x3956c25bf348b538',
      '0x59f111f1b605d019',
      '0x923f82a4af194f9b',
      '0xab1c5ed5da6d8118',
      '0xd807aa98a3030242',
      '0x12835b0145706fbe',
      '0x243185be4ee4b28c',
      '0x550c7dc3d5ffb4e2',
      '0x72be5d74f27b896f',
      '0x80deb1fe3b1696b1',
      '0x9bdc06a725c71235',
      '0xc19bf174cf692694',
      '0xe49b69c19ef14ad2',
      '0xefbe4786384f25e3',
      '0x0fc19dc68b8cd5b5',
      '0x240ca1cc77ac9c65',
      '0x2de92c6f592b0275',
      '0x4a7484aa6ea6e483',
      '0x5cb0a9dcbd41fbd4',
      '0x76f988da831153b5',
      '0x983e5152ee66dfab',
      '0xa831c66d2db43210',
      '0xb00327c898fb213f',
      '0xbf597fc7beef0ee4',
      '0xc6e00bf33da88fc2',
      '0xd5a79147930aa725',
      '0x06ca6351e003826f',
      '0x142929670a0e6e70',
      '0x27b70a8546d22ffc',
      '0x2e1b21385c26c926',
      '0x4d2c6dfc5ac42aed',
      '0x53380d139d95b3df',
      '0x650a73548baf63de',
      '0x766a0abb3c77b2a8',
      '0x81c2c92e47edaee6',
      '0x92722c851482353b',
      '0xa2bfe8a14cf10364',
      '0xa81a664bbc423001',
      '0xc24b8b70d0f89791',
      '0xc76c51a30654be30',
      '0xd192e819d6ef5218',
      '0xd69906245565a910',
      '0xf40e35855771202a',
      '0x106aa07032bbd1b8',
      '0x19a4c116b8d2d0c8',
      '0x1e376c085141ab53',
      '0x2748774cdf8eeb99',
      '0x34b0bcb5e19b48a8',
      '0x391c0cb3c5c95a63',
      '0x4ed8aa4ae3418acb',
      '0x5b9cca4f7763e373',
      '0x682e6ff3d6b2b8a3',
      '0x748f82ee5defb2fc',
      '0x78a5636f43172f60',
      '0x84c87814a1f0ab72',
      '0x8cc702081a6439ec',
      '0x90befffa23631e28',
      '0xa4506cebde82bde9',
      '0xbef9a3f7b2c67915',
      '0xc67178f2e372532b',
      '0xca273eceea26619c',
      '0xd186b8c721c0c207',
      '0xeada7dd6cde0eb1e',
      '0xf57d4f7fee6ed178',
      '0x06f067aa72176fba',
      '0x0a637dc5a2c898a6',
      '0x113f9804bef90dae',
      '0x1b710b35131c471b',
      '0x28db77f523047d84',
      '0x32caab7b40c72493',
      '0x3c9ebe0a15c9bebc',
      '0x431d67c49c100d4c',
      '0x4cc5d4becb3e42b6',
      '0x597f299cfc657e2a',
      '0x5fcb6fab3ad6faec',
      '0x6c44198c4a475817',
    ].map((e) => BigInt(e))
  ),
  Io = new Uint32Array(80),
  To = new Uint32Array(80);
let zb = class extends pO {
    constructor() {
      super(128, 64, 16, !1),
        (this.Ah = 1779033703),
        (this.Al = -205731576),
        (this.Bh = -1150833019),
        (this.Bl = -2067093701),
        (this.Ch = 1013904242),
        (this.Cl = -23791573),
        (this.Dh = -1521486534),
        (this.Dl = 1595750129),
        (this.Eh = 1359893119),
        (this.El = -1377402159),
        (this.Fh = -1694144372),
        (this.Fl = 725511199),
        (this.Gh = 528734635),
        (this.Gl = -79577749),
        (this.Hh = 1541459225),
        (this.Hl = 327033209);
    }
    get() {
      const {
        Ah: t,
        Al: n,
        Bh: r,
        Bl: i,
        Ch: s,
        Cl: o,
        Dh: a,
        Dl: c,
        Eh: u,
        El: l,
        Fh: d,
        Fl: f,
        Gh: h,
        Gl: p,
        Hh: b,
        Hl: w,
      } = this;
      return [t, n, r, i, s, o, a, c, u, l, d, f, h, p, b, w];
    }
    set(t, n, r, i, s, o, a, c, u, l, d, f, h, p, b, w) {
      (this.Ah = t | 0),
        (this.Al = n | 0),
        (this.Bh = r | 0),
        (this.Bl = i | 0),
        (this.Ch = s | 0),
        (this.Cl = o | 0),
        (this.Dh = a | 0),
        (this.Dl = c | 0),
        (this.Eh = u | 0),
        (this.El = l | 0),
        (this.Fh = d | 0),
        (this.Fl = f | 0),
        (this.Gh = h | 0),
        (this.Gl = p | 0),
        (this.Hh = b | 0),
        (this.Hl = w | 0);
    }
    process(t, n) {
      for (let x = 0; x < 16; x++, n += 4)
        (Io[x] = t.getUint32(n)), (To[x] = t.getUint32((n += 4)));
      for (let x = 16; x < 80; x++) {
        const k = Io[x - 15] | 0,
          j = To[x - 15] | 0,
          F = it.rotrSH(k, j, 1) ^ it.rotrSH(k, j, 8) ^ it.shrSH(k, j, 7),
          K = it.rotrSL(k, j, 1) ^ it.rotrSL(k, j, 8) ^ it.shrSL(k, j, 7),
          D = Io[x - 2] | 0,
          C = To[x - 2] | 0,
          B = it.rotrSH(D, C, 19) ^ it.rotrBH(D, C, 61) ^ it.shrSH(D, C, 6),
          E = it.rotrSL(D, C, 19) ^ it.rotrBL(D, C, 61) ^ it.shrSL(D, C, 6),
          y = it.add4L(K, E, To[x - 7], To[x - 16]),
          v = it.add4H(y, F, B, Io[x - 7], Io[x - 16]);
        (Io[x] = v | 0), (To[x] = y | 0);
      }
      let {
        Ah: r,
        Al: i,
        Bh: s,
        Bl: o,
        Ch: a,
        Cl: c,
        Dh: u,
        Dl: l,
        Eh: d,
        El: f,
        Fh: h,
        Fl: p,
        Gh: b,
        Gl: w,
        Hh: A,
        Hl: _,
      } = this;
      for (let x = 0; x < 80; x++) {
        const k = it.rotrSH(d, f, 14) ^ it.rotrSH(d, f, 18) ^ it.rotrBH(d, f, 41),
          j = it.rotrSL(d, f, 14) ^ it.rotrSL(d, f, 18) ^ it.rotrBL(d, f, 41),
          F = (d & h) ^ (~d & b),
          K = (f & p) ^ (~f & w),
          D = it.add5L(_, j, K, IG[x], To[x]),
          C = it.add5H(D, A, k, F, AG[x], Io[x]),
          B = D | 0,
          E = it.rotrSH(r, i, 28) ^ it.rotrBH(r, i, 34) ^ it.rotrBH(r, i, 39),
          y = it.rotrSL(r, i, 28) ^ it.rotrBL(r, i, 34) ^ it.rotrBL(r, i, 39),
          v = (r & s) ^ (r & a) ^ (s & a),
          S = (i & o) ^ (i & c) ^ (o & c);
        (A = b | 0),
          (_ = w | 0),
          (b = h | 0),
          (w = p | 0),
          (h = d | 0),
          (p = f | 0),
          ({ h: d, l: f } = it.add(u | 0, l | 0, C | 0, B | 0)),
          (u = a | 0),
          (l = c | 0),
          (a = s | 0),
          (c = o | 0),
          (s = r | 0),
          (o = i | 0);
        const T = it.add3L(B, y, S);
        (r = it.add3H(T, C, E, v)), (i = T | 0);
      }
      ({ h: r, l: i } = it.add(this.Ah | 0, this.Al | 0, r | 0, i | 0)),
        ({ h: s, l: o } = it.add(this.Bh | 0, this.Bl | 0, s | 0, o | 0)),
        ({ h: a, l: c } = it.add(this.Ch | 0, this.Cl | 0, a | 0, c | 0)),
        ({ h: u, l } = it.add(this.Dh | 0, this.Dl | 0, u | 0, l | 0)),
        ({ h: d, l: f } = it.add(this.Eh | 0, this.El | 0, d | 0, f | 0)),
        ({ h, l: p } = it.add(this.Fh | 0, this.Fl | 0, h | 0, p | 0)),
        ({ h: b, l: w } = it.add(this.Gh | 0, this.Gl | 0, b | 0, w | 0)),
        ({ h: A, l: _ } = it.add(this.Hh | 0, this.Hl | 0, A | 0, _ | 0)),
        this.set(r, i, s, o, a, c, u, l, d, f, h, p, b, w, A, _);
    }
    roundClean() {
      Io.fill(0), To.fill(0);
    }
    destroy() {
      this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  },
  TG = class extends zb {
    constructor() {
      super(),
        (this.Ah = -1942145080),
        (this.Al = 424955298),
        (this.Bh = 1944164710),
        (this.Bl = -1982016298),
        (this.Ch = 502970286),
        (this.Cl = 855612546),
        (this.Dh = 1738396948),
        (this.Dl = 1479516111),
        (this.Eh = 258812777),
        (this.El = 2077511080),
        (this.Fh = 2011393907),
        (this.Fl = 79989058),
        (this.Gh = 1067287976),
        (this.Gl = 1780299464),
        (this.Hh = 286451373),
        (this.Hl = -1848208735),
        (this.outputLen = 28);
    }
  },
  xG = class extends zb {
    constructor() {
      super(),
        (this.Ah = 573645204),
        (this.Al = -64227540),
        (this.Bh = -1621794909),
        (this.Bl = -934517566),
        (this.Ch = 596883563),
        (this.Cl = 1867755857),
        (this.Dh = -1774684391),
        (this.Dl = 1497426621),
        (this.Eh = -1775747358),
        (this.El = -1467023389),
        (this.Fh = -1101128155),
        (this.Fl = 1401305490),
        (this.Gh = 721525244),
        (this.Gl = 746961066),
        (this.Hh = 246885852),
        (this.Hl = -2117784414),
        (this.outputLen = 32);
    }
  },
  kG = class extends zb {
    constructor() {
      super(),
        (this.Ah = -876896931),
        (this.Al = -1056596264),
        (this.Bh = 1654270250),
        (this.Bl = 914150663),
        (this.Ch = -1856437926),
        (this.Cl = 812702999),
        (this.Dh = 355462360),
        (this.Dl = -150054599),
        (this.Eh = 1731405415),
        (this.El = -4191439),
        (this.Fh = -1900787065),
        (this.Fl = 1750603025),
        (this.Gh = -619958771),
        (this.Gl = 1694076839),
        (this.Hh = 1203062813),
        (this.Hl = -1090891868),
        (this.outputLen = 48);
    }
  };
const CG = Gu(() => new zb());
Gu(() => new TG());
Gu(() => new xG());
Gu(() => new kG());
const Kb = [
  'abandon',
  'ability',
  'able',
  'about',
  'above',
  'absent',
  'absorb',
  'abstract',
  'absurd',
  'abuse',
  'access',
  'accident',
  'account',
  'accuse',
  'achieve',
  'acid',
  'acoustic',
  'acquire',
  'across',
  'act',
  'action',
  'actor',
  'actress',
  'actual',
  'adapt',
  'add',
  'addict',
  'address',
  'adjust',
  'admit',
  'adult',
  'advance',
  'advice',
  'aerobic',
  'affair',
  'afford',
  'afraid',
  'again',
  'age',
  'agent',
  'agree',
  'ahead',
  'aim',
  'air',
  'airport',
  'aisle',
  'alarm',
  'album',
  'alcohol',
  'alert',
  'alien',
  'all',
  'alley',
  'allow',
  'almost',
  'alone',
  'alpha',
  'already',
  'also',
  'alter',
  'always',
  'amateur',
  'amazing',
  'among',
  'amount',
  'amused',
  'analyst',
  'anchor',
  'ancient',
  'anger',
  'angle',
  'angry',
  'animal',
  'ankle',
  'announce',
  'annual',
  'another',
  'answer',
  'antenna',
  'antique',
  'anxiety',
  'any',
  'apart',
  'apology',
  'appear',
  'apple',
  'approve',
  'april',
  'arch',
  'arctic',
  'area',
  'arena',
  'argue',
  'arm',
  'armed',
  'armor',
  'army',
  'around',
  'arrange',
  'arrest',
  'arrive',
  'arrow',
  'art',
  'artefact',
  'artist',
  'artwork',
  'ask',
  'aspect',
  'assault',
  'asset',
  'assist',
  'assume',
  'asthma',
  'athlete',
  'atom',
  'attack',
  'attend',
  'attitude',
  'attract',
  'auction',
  'audit',
  'august',
  'aunt',
  'author',
  'auto',
  'autumn',
  'average',
  'avocado',
  'avoid',
  'awake',
  'aware',
  'away',
  'awesome',
  'awful',
  'awkward',
  'axis',
  'baby',
  'bachelor',
  'bacon',
  'badge',
  'bag',
  'balance',
  'balcony',
  'ball',
  'bamboo',
  'banana',
  'banner',
  'bar',
  'barely',
  'bargain',
  'barrel',
  'base',
  'basic',
  'basket',
  'battle',
  'beach',
  'bean',
  'beauty',
  'because',
  'become',
  'beef',
  'before',
  'begin',
  'behave',
  'behind',
  'believe',
  'below',
  'belt',
  'bench',
  'benefit',
  'best',
  'betray',
  'better',
  'between',
  'beyond',
  'bicycle',
  'bid',
  'bike',
  'bind',
  'biology',
  'bird',
  'birth',
  'bitter',
  'black',
  'blade',
  'blame',
  'blanket',
  'blast',
  'bleak',
  'bless',
  'blind',
  'blood',
  'blossom',
  'blouse',
  'blue',
  'blur',
  'blush',
  'board',
  'boat',
  'body',
  'boil',
  'bomb',
  'bone',
  'bonus',
  'book',
  'boost',
  'border',
  'boring',
  'borrow',
  'boss',
  'bottom',
  'bounce',
  'box',
  'boy',
  'bracket',
  'brain',
  'brand',
  'brass',
  'brave',
  'bread',
  'breeze',
  'brick',
  'bridge',
  'brief',
  'bright',
  'bring',
  'brisk',
  'broccoli',
  'broken',
  'bronze',
  'broom',
  'brother',
  'brown',
  'brush',
  'bubble',
  'buddy',
  'budget',
  'buffalo',
  'build',
  'bulb',
  'bulk',
  'bullet',
  'bundle',
  'bunker',
  'burden',
  'burger',
  'burst',
  'bus',
  'business',
  'busy',
  'butter',
  'buyer',
  'buzz',
  'cabbage',
  'cabin',
  'cable',
  'cactus',
  'cage',
  'cake',
  'call',
  'calm',
  'camera',
  'camp',
  'can',
  'canal',
  'cancel',
  'candy',
  'cannon',
  'canoe',
  'canvas',
  'canyon',
  'capable',
  'capital',
  'captain',
  'car',
  'carbon',
  'card',
  'cargo',
  'carpet',
  'carry',
  'cart',
  'case',
  'cash',
  'casino',
  'castle',
  'casual',
  'cat',
  'catalog',
  'catch',
  'category',
  'cattle',
  'caught',
  'cause',
  'caution',
  'cave',
  'ceiling',
  'celery',
  'cement',
  'census',
  'century',
  'cereal',
  'certain',
  'chair',
  'chalk',
  'champion',
  'change',
  'chaos',
  'chapter',
  'charge',
  'chase',
  'chat',
  'cheap',
  'check',
  'cheese',
  'chef',
  'cherry',
  'chest',
  'chicken',
  'chief',
  'child',
  'chimney',
  'choice',
  'choose',
  'chronic',
  'chuckle',
  'chunk',
  'churn',
  'cigar',
  'cinnamon',
  'circle',
  'citizen',
  'city',
  'civil',
  'claim',
  'clap',
  'clarify',
  'claw',
  'clay',
  'clean',
  'clerk',
  'clever',
  'click',
  'client',
  'cliff',
  'climb',
  'clinic',
  'clip',
  'clock',
  'clog',
  'close',
  'cloth',
  'cloud',
  'clown',
  'club',
  'clump',
  'cluster',
  'clutch',
  'coach',
  'coast',
  'coconut',
  'code',
  'coffee',
  'coil',
  'coin',
  'collect',
  'color',
  'column',
  'combine',
  'come',
  'comfort',
  'comic',
  'common',
  'company',
  'concert',
  'conduct',
  'confirm',
  'congress',
  'connect',
  'consider',
  'control',
  'convince',
  'cook',
  'cool',
  'copper',
  'copy',
  'coral',
  'core',
  'corn',
  'correct',
  'cost',
  'cotton',
  'couch',
  'country',
  'couple',
  'course',
  'cousin',
  'cover',
  'coyote',
  'crack',
  'cradle',
  'craft',
  'cram',
  'crane',
  'crash',
  'crater',
  'crawl',
  'crazy',
  'cream',
  'credit',
  'creek',
  'crew',
  'cricket',
  'crime',
  'crisp',
  'critic',
  'crop',
  'cross',
  'crouch',
  'crowd',
  'crucial',
  'cruel',
  'cruise',
  'crumble',
  'crunch',
  'crush',
  'cry',
  'crystal',
  'cube',
  'culture',
  'cup',
  'cupboard',
  'curious',
  'current',
  'curtain',
  'curve',
  'cushion',
  'custom',
  'cute',
  'cycle',
  'dad',
  'damage',
  'damp',
  'dance',
  'danger',
  'daring',
  'dash',
  'daughter',
  'dawn',
  'day',
  'deal',
  'debate',
  'debris',
  'decade',
  'december',
  'decide',
  'decline',
  'decorate',
  'decrease',
  'deer',
  'defense',
  'define',
  'defy',
  'degree',
  'delay',
  'deliver',
  'demand',
  'demise',
  'denial',
  'dentist',
  'deny',
  'depart',
  'depend',
  'deposit',
  'depth',
  'deputy',
  'derive',
  'describe',
  'desert',
  'design',
  'desk',
  'despair',
  'destroy',
  'detail',
  'detect',
  'develop',
  'device',
  'devote',
  'diagram',
  'dial',
  'diamond',
  'diary',
  'dice',
  'diesel',
  'diet',
  'differ',
  'digital',
  'dignity',
  'dilemma',
  'dinner',
  'dinosaur',
  'direct',
  'dirt',
  'disagree',
  'discover',
  'disease',
  'dish',
  'dismiss',
  'disorder',
  'display',
  'distance',
  'divert',
  'divide',
  'divorce',
  'dizzy',
  'doctor',
  'document',
  'dog',
  'doll',
  'dolphin',
  'domain',
  'donate',
  'donkey',
  'donor',
  'door',
  'dose',
  'double',
  'dove',
  'draft',
  'dragon',
  'drama',
  'drastic',
  'draw',
  'dream',
  'dress',
  'drift',
  'drill',
  'drink',
  'drip',
  'drive',
  'drop',
  'drum',
  'dry',
  'duck',
  'dumb',
  'dune',
  'during',
  'dust',
  'dutch',
  'duty',
  'dwarf',
  'dynamic',
  'eager',
  'eagle',
  'early',
  'earn',
  'earth',
  'easily',
  'east',
  'easy',
  'echo',
  'ecology',
  'economy',
  'edge',
  'edit',
  'educate',
  'effort',
  'egg',
  'eight',
  'either',
  'elbow',
  'elder',
  'electric',
  'elegant',
  'element',
  'elephant',
  'elevator',
  'elite',
  'else',
  'embark',
  'embody',
  'embrace',
  'emerge',
  'emotion',
  'employ',
  'empower',
  'empty',
  'enable',
  'enact',
  'end',
  'endless',
  'endorse',
  'enemy',
  'energy',
  'enforce',
  'engage',
  'engine',
  'enhance',
  'enjoy',
  'enlist',
  'enough',
  'enrich',
  'enroll',
  'ensure',
  'enter',
  'entire',
  'entry',
  'envelope',
  'episode',
  'equal',
  'equip',
  'era',
  'erase',
  'erode',
  'erosion',
  'error',
  'erupt',
  'escape',
  'essay',
  'essence',
  'estate',
  'eternal',
  'ethics',
  'evidence',
  'evil',
  'evoke',
  'evolve',
  'exact',
  'example',
  'excess',
  'exchange',
  'excite',
  'exclude',
  'excuse',
  'execute',
  'exercise',
  'exhaust',
  'exhibit',
  'exile',
  'exist',
  'exit',
  'exotic',
  'expand',
  'expect',
  'expire',
  'explain',
  'expose',
  'express',
  'extend',
  'extra',
  'eye',
  'eyebrow',
  'fabric',
  'face',
  'faculty',
  'fade',
  'faint',
  'faith',
  'fall',
  'false',
  'fame',
  'family',
  'famous',
  'fan',
  'fancy',
  'fantasy',
  'farm',
  'fashion',
  'fat',
  'fatal',
  'father',
  'fatigue',
  'fault',
  'favorite',
  'feature',
  'february',
  'federal',
  'fee',
  'feed',
  'feel',
  'female',
  'fence',
  'festival',
  'fetch',
  'fever',
  'few',
  'fiber',
  'fiction',
  'field',
  'figure',
  'file',
  'film',
  'filter',
  'final',
  'find',
  'fine',
  'finger',
  'finish',
  'fire',
  'firm',
  'first',
  'fiscal',
  'fish',
  'fit',
  'fitness',
  'fix',
  'flag',
  'flame',
  'flash',
  'flat',
  'flavor',
  'flee',
  'flight',
  'flip',
  'float',
  'flock',
  'floor',
  'flower',
  'fluid',
  'flush',
  'fly',
  'foam',
  'focus',
  'fog',
  'foil',
  'fold',
  'follow',
  'food',
  'foot',
  'force',
  'forest',
  'forget',
  'fork',
  'fortune',
  'forum',
  'forward',
  'fossil',
  'foster',
  'found',
  'fox',
  'fragile',
  'frame',
  'frequent',
  'fresh',
  'friend',
  'fringe',
  'frog',
  'front',
  'frost',
  'frown',
  'frozen',
  'fruit',
  'fuel',
  'fun',
  'funny',
  'furnace',
  'fury',
  'future',
  'gadget',
  'gain',
  'galaxy',
  'gallery',
  'game',
  'gap',
  'garage',
  'garbage',
  'garden',
  'garlic',
  'garment',
  'gas',
  'gasp',
  'gate',
  'gather',
  'gauge',
  'gaze',
  'general',
  'genius',
  'genre',
  'gentle',
  'genuine',
  'gesture',
  'ghost',
  'giant',
  'gift',
  'giggle',
  'ginger',
  'giraffe',
  'girl',
  'give',
  'glad',
  'glance',
  'glare',
  'glass',
  'glide',
  'glimpse',
  'globe',
  'gloom',
  'glory',
  'glove',
  'glow',
  'glue',
  'goat',
  'goddess',
  'gold',
  'good',
  'goose',
  'gorilla',
  'gospel',
  'gossip',
  'govern',
  'gown',
  'grab',
  'grace',
  'grain',
  'grant',
  'grape',
  'grass',
  'gravity',
  'great',
  'green',
  'grid',
  'grief',
  'grit',
  'grocery',
  'group',
  'grow',
  'grunt',
  'guard',
  'guess',
  'guide',
  'guilt',
  'guitar',
  'gun',
  'gym',
  'habit',
  'hair',
  'half',
  'hammer',
  'hamster',
  'hand',
  'happy',
  'harbor',
  'hard',
  'harsh',
  'harvest',
  'hat',
  'have',
  'hawk',
  'hazard',
  'head',
  'health',
  'heart',
  'heavy',
  'hedgehog',
  'height',
  'hello',
  'helmet',
  'help',
  'hen',
  'hero',
  'hidden',
  'high',
  'hill',
  'hint',
  'hip',
  'hire',
  'history',
  'hobby',
  'hockey',
  'hold',
  'hole',
  'holiday',
  'hollow',
  'home',
  'honey',
  'hood',
  'hope',
  'horn',
  'horror',
  'horse',
  'hospital',
  'host',
  'hotel',
  'hour',
  'hover',
  'hub',
  'huge',
  'human',
  'humble',
  'humor',
  'hundred',
  'hungry',
  'hunt',
  'hurdle',
  'hurry',
  'hurt',
  'husband',
  'hybrid',
  'ice',
  'icon',
  'idea',
  'identify',
  'idle',
  'ignore',
  'ill',
  'illegal',
  'illness',
  'image',
  'imitate',
  'immense',
  'immune',
  'impact',
  'impose',
  'improve',
  'impulse',
  'inch',
  'include',
  'income',
  'increase',
  'index',
  'indicate',
  'indoor',
  'industry',
  'infant',
  'inflict',
  'inform',
  'inhale',
  'inherit',
  'initial',
  'inject',
  'injury',
  'inmate',
  'inner',
  'innocent',
  'input',
  'inquiry',
  'insane',
  'insect',
  'inside',
  'inspire',
  'install',
  'intact',
  'interest',
  'into',
  'invest',
  'invite',
  'involve',
  'iron',
  'island',
  'isolate',
  'issue',
  'item',
  'ivory',
  'jacket',
  'jaguar',
  'jar',
  'jazz',
  'jealous',
  'jeans',
  'jelly',
  'jewel',
  'job',
  'join',
  'joke',
  'journey',
  'joy',
  'judge',
  'juice',
  'jump',
  'jungle',
  'junior',
  'junk',
  'just',
  'kangaroo',
  'keen',
  'keep',
  'ketchup',
  'key',
  'kick',
  'kid',
  'kidney',
  'kind',
  'kingdom',
  'kiss',
  'kit',
  'kitchen',
  'kite',
  'kitten',
  'kiwi',
  'knee',
  'knife',
  'knock',
  'know',
  'lab',
  'label',
  'labor',
  'ladder',
  'lady',
  'lake',
  'lamp',
  'language',
  'laptop',
  'large',
  'later',
  'latin',
  'laugh',
  'laundry',
  'lava',
  'law',
  'lawn',
  'lawsuit',
  'layer',
  'lazy',
  'leader',
  'leaf',
  'learn',
  'leave',
  'lecture',
  'left',
  'leg',
  'legal',
  'legend',
  'leisure',
  'lemon',
  'lend',
  'length',
  'lens',
  'leopard',
  'lesson',
  'letter',
  'level',
  'liar',
  'liberty',
  'library',
  'license',
  'life',
  'lift',
  'light',
  'like',
  'limb',
  'limit',
  'link',
  'lion',
  'liquid',
  'list',
  'little',
  'live',
  'lizard',
  'load',
  'loan',
  'lobster',
  'local',
  'lock',
  'logic',
  'lonely',
  'long',
  'loop',
  'lottery',
  'loud',
  'lounge',
  'love',
  'loyal',
  'lucky',
  'luggage',
  'lumber',
  'lunar',
  'lunch',
  'luxury',
  'lyrics',
  'machine',
  'mad',
  'magic',
  'magnet',
  'maid',
  'mail',
  'main',
  'major',
  'make',
  'mammal',
  'man',
  'manage',
  'mandate',
  'mango',
  'mansion',
  'manual',
  'maple',
  'marble',
  'march',
  'margin',
  'marine',
  'market',
  'marriage',
  'mask',
  'mass',
  'master',
  'match',
  'material',
  'math',
  'matrix',
  'matter',
  'maximum',
  'maze',
  'meadow',
  'mean',
  'measure',
  'meat',
  'mechanic',
  'medal',
  'media',
  'melody',
  'melt',
  'member',
  'memory',
  'mention',
  'menu',
  'mercy',
  'merge',
  'merit',
  'merry',
  'mesh',
  'message',
  'metal',
  'method',
  'middle',
  'midnight',
  'milk',
  'million',
  'mimic',
  'mind',
  'minimum',
  'minor',
  'minute',
  'miracle',
  'mirror',
  'misery',
  'miss',
  'mistake',
  'mix',
  'mixed',
  'mixture',
  'mobile',
  'model',
  'modify',
  'mom',
  'moment',
  'monitor',
  'monkey',
  'monster',
  'month',
  'moon',
  'moral',
  'more',
  'morning',
  'mosquito',
  'mother',
  'motion',
  'motor',
  'mountain',
  'mouse',
  'move',
  'movie',
  'much',
  'muffin',
  'mule',
  'multiply',
  'muscle',
  'museum',
  'mushroom',
  'music',
  'must',
  'mutual',
  'myself',
  'mystery',
  'myth',
  'naive',
  'name',
  'napkin',
  'narrow',
  'nasty',
  'nation',
  'nature',
  'near',
  'neck',
  'need',
  'negative',
  'neglect',
  'neither',
  'nephew',
  'nerve',
  'nest',
  'net',
  'network',
  'neutral',
  'never',
  'news',
  'next',
  'nice',
  'night',
  'noble',
  'noise',
  'nominee',
  'noodle',
  'normal',
  'north',
  'nose',
  'notable',
  'note',
  'nothing',
  'notice',
  'novel',
  'now',
  'nuclear',
  'number',
  'nurse',
  'nut',
  'oak',
  'obey',
  'object',
  'oblige',
  'obscure',
  'observe',
  'obtain',
  'obvious',
  'occur',
  'ocean',
  'october',
  'odor',
  'off',
  'offer',
  'office',
  'often',
  'oil',
  'okay',
  'old',
  'olive',
  'olympic',
  'omit',
  'once',
  'one',
  'onion',
  'online',
  'only',
  'open',
  'opera',
  'opinion',
  'oppose',
  'option',
  'orange',
  'orbit',
  'orchard',
  'order',
  'ordinary',
  'organ',
  'orient',
  'original',
  'orphan',
  'ostrich',
  'other',
  'outdoor',
  'outer',
  'output',
  'outside',
  'oval',
  'oven',
  'over',
  'own',
  'owner',
  'oxygen',
  'oyster',
  'ozone',
  'pact',
  'paddle',
  'page',
  'pair',
  'palace',
  'palm',
  'panda',
  'panel',
  'panic',
  'panther',
  'paper',
  'parade',
  'parent',
  'park',
  'parrot',
  'party',
  'pass',
  'patch',
  'path',
  'patient',
  'patrol',
  'pattern',
  'pause',
  'pave',
  'payment',
  'peace',
  'peanut',
  'pear',
  'peasant',
  'pelican',
  'pen',
  'penalty',
  'pencil',
  'people',
  'pepper',
  'perfect',
  'permit',
  'person',
  'pet',
  'phone',
  'photo',
  'phrase',
  'physical',
  'piano',
  'picnic',
  'picture',
  'piece',
  'pig',
  'pigeon',
  'pill',
  'pilot',
  'pink',
  'pioneer',
  'pipe',
  'pistol',
  'pitch',
  'pizza',
  'place',
  'planet',
  'plastic',
  'plate',
  'play',
  'please',
  'pledge',
  'pluck',
  'plug',
  'plunge',
  'poem',
  'poet',
  'point',
  'polar',
  'pole',
  'police',
  'pond',
  'pony',
  'pool',
  'popular',
  'portion',
  'position',
  'possible',
  'post',
  'potato',
  'pottery',
  'poverty',
  'powder',
  'power',
  'practice',
  'praise',
  'predict',
  'prefer',
  'prepare',
  'present',
  'pretty',
  'prevent',
  'price',
  'pride',
  'primary',
  'print',
  'priority',
  'prison',
  'private',
  'prize',
  'problem',
  'process',
  'produce',
  'profit',
  'program',
  'project',
  'promote',
  'proof',
  'property',
  'prosper',
  'protect',
  'proud',
  'provide',
  'public',
  'pudding',
  'pull',
  'pulp',
  'pulse',
  'pumpkin',
  'punch',
  'pupil',
  'puppy',
  'purchase',
  'purity',
  'purpose',
  'purse',
  'push',
  'put',
  'puzzle',
  'pyramid',
  'quality',
  'quantum',
  'quarter',
  'question',
  'quick',
  'quit',
  'quiz',
  'quote',
  'rabbit',
  'raccoon',
  'race',
  'rack',
  'radar',
  'radio',
  'rail',
  'rain',
  'raise',
  'rally',
  'ramp',
  'ranch',
  'random',
  'range',
  'rapid',
  'rare',
  'rate',
  'rather',
  'raven',
  'raw',
  'razor',
  'ready',
  'real',
  'reason',
  'rebel',
  'rebuild',
  'recall',
  'receive',
  'recipe',
  'record',
  'recycle',
  'reduce',
  'reflect',
  'reform',
  'refuse',
  'region',
  'regret',
  'regular',
  'reject',
  'relax',
  'release',
  'relief',
  'rely',
  'remain',
  'remember',
  'remind',
  'remove',
  'render',
  'renew',
  'rent',
  'reopen',
  'repair',
  'repeat',
  'replace',
  'report',
  'require',
  'rescue',
  'resemble',
  'resist',
  'resource',
  'response',
  'result',
  'retire',
  'retreat',
  'return',
  'reunion',
  'reveal',
  'review',
  'reward',
  'rhythm',
  'rib',
  'ribbon',
  'rice',
  'rich',
  'ride',
  'ridge',
  'rifle',
  'right',
  'rigid',
  'ring',
  'riot',
  'ripple',
  'risk',
  'ritual',
  'rival',
  'river',
  'road',
  'roast',
  'robot',
  'robust',
  'rocket',
  'romance',
  'roof',
  'rookie',
  'room',
  'rose',
  'rotate',
  'rough',
  'round',
  'route',
  'royal',
  'rubber',
  'rude',
  'rug',
  'rule',
  'run',
  'runway',
  'rural',
  'sad',
  'saddle',
  'sadness',
  'safe',
  'sail',
  'salad',
  'salmon',
  'salon',
  'salt',
  'salute',
  'same',
  'sample',
  'sand',
  'satisfy',
  'satoshi',
  'sauce',
  'sausage',
  'save',
  'say',
  'scale',
  'scan',
  'scare',
  'scatter',
  'scene',
  'scheme',
  'school',
  'science',
  'scissors',
  'scorpion',
  'scout',
  'scrap',
  'screen',
  'script',
  'scrub',
  'sea',
  'search',
  'season',
  'seat',
  'second',
  'secret',
  'section',
  'security',
  'seed',
  'seek',
  'segment',
  'select',
  'sell',
  'seminar',
  'senior',
  'sense',
  'sentence',
  'series',
  'service',
  'session',
  'settle',
  'setup',
  'seven',
  'shadow',
  'shaft',
  'shallow',
  'share',
  'shed',
  'shell',
  'sheriff',
  'shield',
  'shift',
  'shine',
  'ship',
  'shiver',
  'shock',
  'shoe',
  'shoot',
  'shop',
  'short',
  'shoulder',
  'shove',
  'shrimp',
  'shrug',
  'shuffle',
  'shy',
  'sibling',
  'sick',
  'side',
  'siege',
  'sight',
  'sign',
  'silent',
  'silk',
  'silly',
  'silver',
  'similar',
  'simple',
  'since',
  'sing',
  'siren',
  'sister',
  'situate',
  'six',
  'size',
  'skate',
  'sketch',
  'ski',
  'skill',
  'skin',
  'skirt',
  'skull',
  'slab',
  'slam',
  'sleep',
  'slender',
  'slice',
  'slide',
  'slight',
  'slim',
  'slogan',
  'slot',
  'slow',
  'slush',
  'small',
  'smart',
  'smile',
  'smoke',
  'smooth',
  'snack',
  'snake',
  'snap',
  'sniff',
  'snow',
  'soap',
  'soccer',
  'social',
  'sock',
  'soda',
  'soft',
  'solar',
  'soldier',
  'solid',
  'solution',
  'solve',
  'someone',
  'song',
  'soon',
  'sorry',
  'sort',
  'soul',
  'sound',
  'soup',
  'source',
  'south',
  'space',
  'spare',
  'spatial',
  'spawn',
  'speak',
  'special',
  'speed',
  'spell',
  'spend',
  'sphere',
  'spice',
  'spider',
  'spike',
  'spin',
  'spirit',
  'split',
  'spoil',
  'sponsor',
  'spoon',
  'sport',
  'spot',
  'spray',
  'spread',
  'spring',
  'spy',
  'square',
  'squeeze',
  'squirrel',
  'stable',
  'stadium',
  'staff',
  'stage',
  'stairs',
  'stamp',
  'stand',
  'start',
  'state',
  'stay',
  'steak',
  'steel',
  'stem',
  'step',
  'stereo',
  'stick',
  'still',
  'sting',
  'stock',
  'stomach',
  'stone',
  'stool',
  'story',
  'stove',
  'strategy',
  'street',
  'strike',
  'strong',
  'struggle',
  'student',
  'stuff',
  'stumble',
  'style',
  'subject',
  'submit',
  'subway',
  'success',
  'such',
  'sudden',
  'suffer',
  'sugar',
  'suggest',
  'suit',
  'summer',
  'sun',
  'sunny',
  'sunset',
  'super',
  'supply',
  'supreme',
  'sure',
  'surface',
  'surge',
  'surprise',
  'surround',
  'survey',
  'suspect',
  'sustain',
  'swallow',
  'swamp',
  'swap',
  'swarm',
  'swear',
  'sweet',
  'swift',
  'swim',
  'swing',
  'switch',
  'sword',
  'symbol',
  'symptom',
  'syrup',
  'system',
  'table',
  'tackle',
  'tag',
  'tail',
  'talent',
  'talk',
  'tank',
  'tape',
  'target',
  'task',
  'taste',
  'tattoo',
  'taxi',
  'teach',
  'team',
  'tell',
  'ten',
  'tenant',
  'tennis',
  'tent',
  'term',
  'test',
  'text',
  'thank',
  'that',
  'theme',
  'then',
  'theory',
  'there',
  'they',
  'thing',
  'this',
  'thought',
  'three',
  'thrive',
  'throw',
  'thumb',
  'thunder',
  'ticket',
  'tide',
  'tiger',
  'tilt',
  'timber',
  'time',
  'tiny',
  'tip',
  'tired',
  'tissue',
  'title',
  'toast',
  'tobacco',
  'today',
  'toddler',
  'toe',
  'together',
  'toilet',
  'token',
  'tomato',
  'tomorrow',
  'tone',
  'tongue',
  'tonight',
  'tool',
  'tooth',
  'top',
  'topic',
  'topple',
  'torch',
  'tornado',
  'tortoise',
  'toss',
  'total',
  'tourist',
  'toward',
  'tower',
  'town',
  'toy',
  'track',
  'trade',
  'traffic',
  'tragic',
  'train',
  'transfer',
  'trap',
  'trash',
  'travel',
  'tray',
  'treat',
  'tree',
  'trend',
  'trial',
  'tribe',
  'trick',
  'trigger',
  'trim',
  'trip',
  'trophy',
  'trouble',
  'truck',
  'true',
  'truly',
  'trumpet',
  'trust',
  'truth',
  'try',
  'tube',
  'tuition',
  'tumble',
  'tuna',
  'tunnel',
  'turkey',
  'turn',
  'turtle',
  'twelve',
  'twenty',
  'twice',
  'twin',
  'twist',
  'two',
  'type',
  'typical',
  'ugly',
  'umbrella',
  'unable',
  'unaware',
  'uncle',
  'uncover',
  'under',
  'undo',
  'unfair',
  'unfold',
  'unhappy',
  'uniform',
  'unique',
  'unit',
  'universe',
  'unknown',
  'unlock',
  'until',
  'unusual',
  'unveil',
  'update',
  'upgrade',
  'uphold',
  'upon',
  'upper',
  'upset',
  'urban',
  'urge',
  'usage',
  'use',
  'used',
  'useful',
  'useless',
  'usual',
  'utility',
  'vacant',
  'vacuum',
  'vague',
  'valid',
  'valley',
  'valve',
  'van',
  'vanish',
  'vapor',
  'various',
  'vast',
  'vault',
  'vehicle',
  'velvet',
  'vendor',
  'venture',
  'venue',
  'verb',
  'verify',
  'version',
  'very',
  'vessel',
  'veteran',
  'viable',
  'vibrant',
  'vicious',
  'victory',
  'video',
  'view',
  'village',
  'vintage',
  'violin',
  'virtual',
  'virus',
  'visa',
  'visit',
  'visual',
  'vital',
  'vivid',
  'vocal',
  'voice',
  'void',
  'volcano',
  'volume',
  'vote',
  'voyage',
  'wage',
  'wagon',
  'wait',
  'walk',
  'wall',
  'walnut',
  'want',
  'warfare',
  'warm',
  'warrior',
  'wash',
  'wasp',
  'waste',
  'water',
  'wave',
  'way',
  'wealth',
  'weapon',
  'wear',
  'weasel',
  'weather',
  'web',
  'wedding',
  'weekend',
  'weird',
  'welcome',
  'west',
  'wet',
  'whale',
  'what',
  'wheat',
  'wheel',
  'when',
  'where',
  'whip',
  'whisper',
  'wide',
  'width',
  'wife',
  'wild',
  'will',
  'win',
  'window',
  'wine',
  'wing',
  'wink',
  'winner',
  'winter',
  'wire',
  'wisdom',
  'wise',
  'wish',
  'witness',
  'wolf',
  'woman',
  'wonder',
  'wood',
  'wool',
  'word',
  'work',
  'world',
  'worry',
  'worth',
  'wrap',
  'wreck',
  'wrestle',
  'wrist',
  'write',
  'wrong',
  'yard',
  'year',
  'yellow',
  'you',
  'young',
  'youth',
  'zebra',
  'zero',
  'zone',
  'zoo',
];
new Set(Kb);
const PG = (e, t, n, r, i) => {
    let s;
    switch (i) {
      case 'rmd160':
      case 'md5':
      case 'sha':
        throw new Error(`${i} is unsupported by noble`);
      case 'ripemd160':
      case 'sha1':
      case 'sha224':
      case 'sha384':
        throw new Error(`${i} is supported by noble, but we don't need it for bip39`);
      case 'sha256':
        s = tI;
        break;
      case 'sha512':
        s = CG;
        break;
    }
    return JH(s, e, t, { c: n, dkLen: r });
  },
  bO = (e, t, n) => {
    for (; e.length < n; ) e = t + e;
    return e;
  },
  mO = (e) => e.map((t) => bO(t.toString(2), '0', 8)).join(''),
  wO = (e) => parseInt(e, 2),
  vO = (e) => {
    const n = (e.length * 8) / 32,
      r = tI(e);
    return mO(Array.from(r)).slice(0, n);
  },
  MG = (e) => OG(e, !1),
  OG = (e, t = !1) => {
    var f;
    const n = e.toString().split(' ');
    if (n.length < 12) throw new Error('LessThanTwelve');
    if (n.length !== 12 && n.length !== 24) throw new Error('ExactlyTwelveOrTwentyFour');
    const r = [],
      i = [];
    for (const h of n) {
      const p = Kb.indexOf(h);
      p === -1 ? r.push(h) : i.push(bO(p.toString(2), '0', 11));
    }
    const s = i.join('');
    if (r.length > 0) throw new Error(`WrongWord:${r.join(', ')}`);
    const o = Math.floor(s.length / 33) * 32,
      a = s.slice(0, o),
      c = s.slice(o),
      u = (f = a.match(/(.{1,8})/g)) == null ? void 0 : f.map(wO);
    if (!u) throw new Error('InvalidEntropy');
    if (u.length < 16) throw new Error('InvalidEntropy');
    if (u.length > 32) throw new Error('InvalidEntropy');
    if (u.length % 4 !== 0) throw new Error('InvalidEntropy');
    const l = he.from(u);
    if (t) return l;
    if (vO(l) !== c) throw new Error('InvalidChecksum');
    return l;
  },
  BG = async (e) => {
    const t = Kb;
    if (e.length < 16) throw new Error('LessThanTwelve');
    if (e.length > 32) throw new Error('MoreThanTwentyFour');
    if (e.length % 4 !== 0) throw new Error('WrongWord');
    let n, r;
    try {
      n = mO(Array.from(e));
    } catch {
      throw new Error('InvalidEntropyBits');
    }
    try {
      r = vO(e);
    } catch {
      throw new Error('InvalidChecksumBits');
    }
    const s = (n + r).match(/(.{1,11})/g);
    if (!s) throw new Error('InvalidChecksum');
    const o = s.map((u) => {
        const l = wO(u);
        return t[l];
      }),
      a = he.from(o.join(' '));
    return { seed: await $H({ mnemonic: a, pbkdf2: PG }), mnemonic: a };
  },
  DG = async () =>
    await UH({
      sentenceLength: 12,
      wordlist: Kb,
      randomValues: (e) => Promise.resolve(FP.randomBytes(e)),
      sha256: tI,
    });
async function Vb(e, t) {
  const n = await aK(e, t);
  if (!n) throw new SA();
  const r = mr.from(n.entropy);
  return n.entropy.fill(0), r;
}
async function Ts(e, t) {
  let n;
  const r = await e.secureCache.getSeed(t);
  if (r) n = r;
  else {
    const s = await Vb(e, t),
      { seed: o } = await s.foldAsync(BG);
    (n = o), await e.secureCache.setSeed(t, n);
  }
  const i = mr.from(n);
  return n.fill(0), i;
}
function Wb(e) {
  return e.fold(_c.keccak256);
}
function Hb(e, t, n) {
  const r = Ab[n];
  return _c.keccak256(`${e}:${t}:${r}`);
}
function Ed(e, t, n, r) {
  const i = {};
  for (const s of r) {
    const { publicKey: o } = e.keypairGenerator.generateKeypairFromSeed(t, n, s),
      a = Yl.getAddressType(s);
    switch (s) {
      case ke.BitcoinTaproot:
      case ke.BitcoinNativeSegwit:
      case ke.BitcoinNestedSegwit:
      case ke.BitcoinLegacy: {
        i[a] = {
          chainType: a,
          pathType: s,
          publicKey: o,
          addresses: Object.values(Vi).reduce(
            (c, u) => ({ ...c, [u]: eo({ publicKey: o, addressType: a, networkID: u }) }),
            {}
          ),
        };
        break;
      }
      case ke.Bip44RootEthereum:
      case ke.Bip44Ethereum:
      case ke.Bip44EthereumSecondary:
      case ke.Bip44EthereumTertiary:
      case ke.Bip44RootSolana:
      case ke.Bip44ChangeSolana:
      case ke.Bip44Solana:
      case ke.DeprecatedSolana: {
        i[a] = { chainType: a, pathType: s, publicKey: eo({ publicKey: o, addressType: a }) };
        break;
      }
      case ke.Bip44Sui: {
        i[a] = {
          chainType: a,
          pathType: s,
          publicKey: o,
          address: eo({ publicKey: o, addressType: a }),
        };
        break;
      }
      default:
        qt();
    }
  }
  return i;
}
async function RG(e, t) {
  const n = new Set(),
    r = await vr(e);
  for (const s of r)
    s.type === ee.Seed &&
      s.seedIdentifier === t &&
      Ab[Object.values(s.chains)[0].pathType] === 0 &&
      n.add(s.derivationIndex);
  let i = 0;
  for (let s = 0; s <= n.size; s++)
    if (!n.has(s)) {
      i = s;
      break;
    }
  return _O(e, t, i);
}
async function _O(e, t, n) {
  try {
    return await NG(e, t, n);
  } catch (r) {
    if (r instanceof Iy) return await _O(e, t, n + 1);
    throw r;
  }
}
async function NG(e, t, n) {
  const r = await Ts(e, t),
    i = (await e.fetchChainAvailability()).enabledAddressTypes,
    s = Ku(i),
    o = await Hb(t, n, s[0]),
    a = {
      version: 1,
      type: ee.Seed,
      identifier: o,
      seedIdentifier: t,
      derivationIndex: n,
      chains: Ed(e, r, n, s),
    };
  return await va(e, a, !1), a;
}
var nI = {},
  _u = {},
  Su = {};
Object.defineProperty(Su, '__esModule', { value: !0 });
Su.testnet = Su.bitcoin = void 0;
Su.bitcoin = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: 'bc',
  bip32: { public: 76067358, private: 76066276 },
  pubKeyHash: 0,
  scriptHash: 5,
  wif: 128,
};
Su.testnet = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: 'tb',
  bip32: { public: 70617039, private: 70615956 },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239,
};
var SO = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.maybe = e.Boolean = e.Array = e.Buffer256bit = e.Network = e.typeforce = void 0),
    (e.typeforce = $P),
    (e.Network = e.typeforce.compile({
      messagePrefix: e.typeforce.oneOf(e.typeforce.Buffer, e.typeforce.String),
      bip32: { public: e.typeforce.UInt32, private: e.typeforce.UInt32 },
      pubKeyHash: e.typeforce.UInt8,
      scriptHash: e.typeforce.UInt8,
      wif: e.typeforce.UInt8,
    })),
    (e.Buffer256bit = e.typeforce.BufferN(32)),
    (e.Array = e.typeforce.Array),
    (e.Boolean = e.typeforce.Boolean),
    (e.maybe = e.typeforce.maybe);
})(SO);
var Gb = {};
Object.defineProperty(Gb, '__esModule', { value: !0 });
Gb.testEcc = void 0;
const Ve = (e) => z.from(e, 'hex');
function jG(e) {
  Wt(e.isPoint(Ve('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'))),
    Wt(!e.isPoint(Ve('030000000000000000000000000000000000000000000000000000000000000005'))),
    Wt(e.isPrivate(Ve('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'))),
    Wt(e.isPrivate(Ve('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140'))),
    Wt(!e.isPrivate(Ve('0000000000000000000000000000000000000000000000000000000000000000'))),
    Wt(!e.isPrivate(Ve('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'))),
    Wt(!e.isPrivate(Ve('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142'))),
    Wt(
      z
        .from(
          e.privateAdd(
            Ve('0000000000000000000000000000000000000000000000000000000000000001'),
            Ve('0000000000000000000000000000000000000000000000000000000000000000')
          )
        )
        .equals(Ve('0000000000000000000000000000000000000000000000000000000000000001'))
    ),
    Wt(
      e.privateAdd(
        Ve('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e'),
        Ve('0000000000000000000000000000000000000000000000000000000000000003')
      ) === null
    ),
    Wt(
      z
        .from(
          e.privateAdd(
            Ve('e211078564db65c3ce7704f08262b1f38f1ef412ad15b5ac2d76657a63b2c500'),
            Ve('b51fbb69051255d1becbd683de5848242a89c229348dd72896a87ada94ae8665')
          )
        )
        .equals(Ve('9730c2ee69edbb958d42db7460bafa18fef9d955325aec99044c81c8282b0a24'))
    ),
    Wt(
      z
        .from(
          e.privateNegate(Ve('0000000000000000000000000000000000000000000000000000000000000001'))
        )
        .equals(Ve('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140'))
    ),
    Wt(
      z
        .from(
          e.privateNegate(Ve('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e'))
        )
        .equals(Ve('0000000000000000000000000000000000000000000000000000000000000003'))
    ),
    Wt(
      z
        .from(
          e.privateNegate(Ve('b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af'))
        )
        .equals(Ve('4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792'))
    ),
    Wt(
      z
        .from(
          e.pointCompress(
            Ve(
              '0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8'
            ),
            !0
          )
        )
        .equals(Ve('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'))
    ),
    Wt(
      z
        .from(
          e.pointCompress(
            Ve(
              '0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8'
            ),
            !1
          )
        )
        .equals(
          Ve(
            '0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8'
          )
        )
    ),
    Wt(
      z
        .from(
          e.pointCompress(
            Ve('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
            !0
          )
        )
        .equals(Ve('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'))
    ),
    Wt(
      z
        .from(
          e.pointCompress(
            Ve('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
            !1
          )
        )
        .equals(
          Ve(
            '0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8'
          )
        )
    ),
    Wt(
      z
        .from(
          e.pointFromScalar(Ve('b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af'))
        )
        .equals(Ve('02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99'))
    ),
    Wt(
      e.xOnlyPointAddTweak(
        Ve('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
        Ve('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')
      ) === null
    );
  let t = e.xOnlyPointAddTweak(
    Ve('1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b'),
    Ve('a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac')
  );
  Wt(
    z
      .from(t.xOnlyPubkey)
      .equals(Ve('e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf')) &&
      t.parity === 1
  ),
    (t = e.xOnlyPointAddTweak(
      Ve('2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991'),
      Ve('823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47')
    )),
    Wt(
      z
        .from(t.xOnlyPubkey)
        .equals(Ve('9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c')) &&
        t.parity === 0
    ),
    Wt(
      z
        .from(
          e.sign(
            Ve('5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed'),
            Ve('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')
          )
        )
        .equals(
          Ve(
            '54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5'
          )
        )
    ),
    Wt(
      e.verify(
        Ve('5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed'),
        Ve('0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
        Ve(
          '54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5'
        )
      )
    ),
    e.signSchnorr &&
      Wt(
        z
          .from(
            e.signSchnorr(
              Ve('7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c'),
              Ve('c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9'),
              Ve('c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906')
            )
          )
          .equals(
            Ve(
              '5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7'
            )
          )
      ),
    e.verifySchnorr &&
      Wt(
        e.verifySchnorr(
          Ve('7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c'),
          Ve('dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8'),
          Ve(
            '5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7'
          )
        )
      );
}
Gb.testEcc = jG;
function Wt(e) {
  if (!e) throw new Error('ecc library invalid');
}
Object.defineProperty(_u, '__esModule', { value: !0 });
_u.ECPairFactory = _u.networks = void 0;
const DS = Su;
_u.networks = DS;
const pr = SO,
  LG = fL(),
  fk = bP,
  UG = Gb,
  Fw = pr.typeforce.maybe(
    pr.typeforce.compile({ compressed: pr.maybe(pr.Boolean), network: pr.maybe(pr.Network) })
  ),
  $G = (e) => (e.length === 32 ? e : e.slice(1, 33));
function FG(e) {
  (0, UG.testEcc)(e);
  function t(a) {
    return e.isPoint(a);
  }
  function n(a, c) {
    if ((pr.typeforce(pr.Buffer256bit, a), !e.isPrivate(a)))
      throw new TypeError('Private key not in range [1, n)');
    return pr.typeforce(Fw, c), new o(a, void 0, c);
  }
  function r(a, c) {
    return pr.typeforce(e.isPoint, a), pr.typeforce(Fw, c), new o(void 0, a, c);
  }
  function i(a, c) {
    const u = fk.decode(a),
      l = u.version;
    if (pr.Array(c)) {
      if (((c = c.filter((d) => l === d.wif).pop()), !c))
        throw new Error('Unknown network version');
    } else if (((c = c || DS.bitcoin), l !== c.wif)) throw new Error('Invalid network version');
    return n(u.privateKey, { compressed: u.compressed, network: c });
  }
  function s(a) {
    pr.typeforce(Fw, a), a === void 0 && (a = {});
    const c = a.rng || LG;
    let u;
    do (u = c(32)), pr.typeforce(pr.Buffer256bit, u);
    while (!e.isPrivate(u));
    return n(u, a);
  }
  class o {
    constructor(c, u, l) {
      ae(this, '__D');
      ae(this, '__Q');
      ae(this, 'compressed');
      ae(this, 'network');
      ae(this, 'lowR');
      (this.__D = c),
        (this.__Q = u),
        (this.lowR = !1),
        l === void 0 && (l = {}),
        (this.compressed = l.compressed === void 0 ? !0 : l.compressed),
        (this.network = l.network || DS.bitcoin),
        u !== void 0 && (this.__Q = z.from(e.pointCompress(u, this.compressed)));
    }
    get privateKey() {
      return this.__D;
    }
    get publicKey() {
      if (!this.__Q) {
        const c = e.pointFromScalar(this.__D, this.compressed);
        this.__Q = z.from(c);
      }
      return this.__Q;
    }
    toWIF() {
      if (!this.__D) throw new Error('Missing private key');
      return fk.encode(this.network.wif, this.__D, this.compressed);
    }
    tweak(c) {
      return this.privateKey ? this.tweakFromPrivateKey(c) : this.tweakFromPublicKey(c);
    }
    sign(c, u) {
      if (!this.__D) throw new Error('Missing private key');
      if ((u === void 0 && (u = this.lowR), u === !1)) return z.from(e.sign(c, this.__D));
      {
        let l = e.sign(c, this.__D);
        const d = z.alloc(32, 0);
        let f = 0;
        for (; l[0] > 127; ) f++, d.writeUIntLE(f, 0, 6), (l = e.sign(c, this.__D, d));
        return z.from(l);
      }
    }
    signSchnorr(c) {
      if (!this.privateKey) throw new Error('Missing private key');
      if (!e.signSchnorr) throw new Error('signSchnorr not supported by ecc library');
      return z.from(e.signSchnorr(c, this.privateKey));
    }
    verify(c, u) {
      return e.verify(c, this.publicKey, u);
    }
    verifySchnorr(c, u) {
      if (!e.verifySchnorr) throw new Error('verifySchnorr not supported by ecc library');
      return e.verifySchnorr(c, this.publicKey.subarray(1, 33), u);
    }
    tweakFromPublicKey(c) {
      const u = $G(this.publicKey),
        l = e.xOnlyPointAddTweak(u, c);
      if (!l || l.xOnlyPubkey === null) throw new Error('Cannot tweak public key!');
      const d = z.from([l.parity === 0 ? 2 : 3]);
      return r(z.concat([d, l.xOnlyPubkey]), {
        network: this.network,
        compressed: this.compressed,
      });
    }
    tweakFromPrivateKey(c) {
      const l =
          this.publicKey[0] === 3 || (this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1)
            ? e.privateNegate(this.privateKey)
            : this.privateKey,
        d = e.privateAdd(l, c);
      if (!d) throw new Error('Invalid tweaked private key!');
      return n(z.from(d), { network: this.network, compressed: this.compressed });
    }
  }
  return { isPoint: t, fromPrivateKey: n, fromPublicKey: r, fromWIF: i, makeRandom: s };
}
_u.ECPairFactory = FG;
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.networks = e.ECPairFactory = e.default = void 0);
  var t = _u;
  Object.defineProperty(e, 'default', {
    enumerable: !0,
    get: function () {
      return t.ECPairFactory;
    },
  }),
    Object.defineProperty(e, 'ECPairFactory', {
      enumerable: !0,
      get: function () {
        return t.ECPairFactory;
      },
    }),
    Object.defineProperty(e, 'networks', {
      enumerable: !0,
      get: function () {
        return t.networks;
      },
    });
})(nI);
function zG(e, t, n) {
  const r = Ab[n];
  return _c.keccak256(`${e}:${t}:${r}`);
}
async function KG(e, t, n) {
  var i, s;
  const r = [];
  for (const o of n) {
    if (o.addresses.length === 0 && o.publicKeys.length === 0)
      throw new Error(
        'Must have at least 1 address or public key in account to add Ledger account.'
      );
    const a =
        ((i = o.addresses[0]) == null ? void 0 : i.pathType) ||
        ((s = o.publicKeys[0]) == null ? void 0 : s.pathType),
      c = zG(t, o.derivationIndex, a);
    bi.initEccLib(Tx);
    const u = nI.ECPairFactory(Tx),
      l = {
        ...o.addresses.reduce((f, h) => {
          const p = Yl.getAddressType(h.pathType);
          switch (p) {
            case G.EVM:
            case G.Solana: {
              f[p] = { chainType: p, pathType: h.pathType, publicKey: h.value };
              break;
            }
            case G.BitcoinTaproot:
            case G.BitcoinNativeSegwit:
            case G.BitcoinNestedSegwit:
            case G.BitcoinLegacy:
              throw new Error('Bitcoin accounts should be using public key not computed addresses');
            case G.Sui:
              throw new wy('add ledger account');
            default:
              qt();
          }
          return f;
        }, {}),
        ...o.publicKeys.reduce((f, h) => {
          const p = Yl.getAddressType(h.pathType);
          switch (p) {
            case G.EVM:
            case G.Solana:
              throw new Error(
                'EVM or Solana accounts should be using addreses directly, not public keys'
              );
            case G.BitcoinTaproot:
            case G.BitcoinNativeSegwit:
            case G.BitcoinNestedSegwit:
            case G.BitcoinLegacy: {
              const b = u.fromPublicKey(z.from(h.value, 'hex')),
                w = new Uint8Array(b.publicKey);
              f[p] = {
                chainType: p,
                pathType: h.pathType,
                publicKey: w,
                addresses: Object.values(Vi).reduce(
                  (A, _) => ({ ...A, [_]: eo({ publicKey: w, addressType: p, networkID: _ }) }),
                  {}
                ),
              };
              break;
            }
            case G.Sui:
              throw new wy('add ledger account');
            default:
              qt();
          }
          return f;
        }, {}),
      },
      d = {
        version: 1,
        type: ee.Ledger,
        identifier: c,
        ledgerGroupIdentifier: t,
        derivationIndex: o.derivationIndex,
        chains: l,
      };
    r.push(d), await va(e, d);
  }
  return r;
}
function VG(e) {
  return _c.keccak256(e);
}
async function WG(e, t, n, r) {
  const i = await e.keypairGenerator.generateKeypairFromPrivateKey(n, t),
    s = await Is(e),
    o = VG(i.publicKey);
  if (((s == null ? void 0 : s.privateKeyIdentifiers) ?? []).includes(o)) throw new IU();
  const u = { version: 1, identifier: o, name: r, chainType: t, privateKey: z.from(i.privateKey) },
    l = o;
  let d;
  switch (t) {
    case G.EVM:
    case G.Solana: {
      d = {
        version: 1,
        type: ee.PrivateKey,
        identifier: l,
        privateKeyIdentifier: o,
        publicKey: eo({ publicKey: i.publicKey, addressType: t }),
        chainType: t,
      };
      break;
    }
    case G.BitcoinTaproot:
    case G.BitcoinNativeSegwit:
    case G.BitcoinNestedSegwit:
    case G.BitcoinLegacy: {
      d = {
        version: 1,
        type: ee.PrivateKey,
        identifier: l,
        privateKeyIdentifier: o,
        publicKey: i.publicKey,
        addresses: Object.values(Vi).reduce(
          (f, h) => ({ ...f, [h]: eo({ publicKey: i.publicKey, addressType: t, networkID: h }) }),
          {}
        ),
        chainType: t,
      };
      break;
    }
    case G.Sui: {
      d = {
        version: 1,
        type: ee.PrivateKey,
        identifier: l,
        privateKeyIdentifier: o,
        publicKey: i.publicKey,
        address: eo({ publicKey: i.publicKey, addressType: t }),
        chainType: t,
      };
      break;
    }
    default:
      qt();
  }
  if (!d) throw new Error('unable to create a private key account based on the address type');
  return await va(e, d), await cK(e, u), d;
}
function HG(e) {
  return _c.keccak256(e);
}
async function GG(e, t) {
  const n = Object.values(t).find(Boolean);
  if (!n) throw new EU();
  const r = HG(n),
    i = { version: 1, type: ee.ReadOnly, identifier: r, addresses: t };
  return await va(e, i), i;
}
async function qG(e, t) {
  const n = new Set(),
    r = await vr(e);
  for (const s of r)
    s.type === ee.Seedless &&
      s.seedIdentifier === t &&
      Ab[Object.values(s.chains)[0].pathType] === 0 &&
      n.add(s.derivationIndex);
  let i = 0;
  for (let s = 0; s <= n.size; s++)
    if (!n.has(s)) {
      i = s;
      break;
    }
  return EO(e, t, i);
}
async function EO(e, t, n) {
  try {
    return await YG(e, t, n);
  } catch (r) {
    if (r instanceof Iy) return await EO(e, t, n + 1);
    throw r;
  }
}
async function YG(e, t, n) {
  const r = await Ts(e, t),
    i = (await e.fetchChainAvailability()).enabledAddressTypes,
    s = Ku(i),
    o = await Hb(t, n, s[0]),
    a = {
      version: 1,
      type: ee.Seedless,
      identifier: o,
      seedIdentifier: t,
      derivationIndex: n,
      chains: Ed(e, r, n, s),
    };
  return await va(e, a, !1), a;
}
async function rI(e, t) {
  const n = await Is(e),
    r = Wb(t),
    i = (n == null ? void 0 : n.seedIdentifiers) ?? [],
    s = (n == null ? void 0 : n.seedlessIdentifiers) ?? [];
  return i.concat(s).includes(r);
}
async function AO(e, t, n, r) {
  if ((await WM(e)).length > 0) throw new TU();
  if (r.length === 0) throw new AU();
  if (await rI(e, t)) throw new JP();
  const o = Wb(t),
    a = t.fold((l) => ({ version: 1, identifier: o, name: n, entropy: new Uint8Array(l) }));
  await lK(e, a);
  const c = [],
    u = await Ts(e, o);
  for (const l of r) {
    const d = Hb(o, l.derivationIndex, l.derivationPathTypes[0]),
      f = Ed(e, u, l.derivationIndex, l.derivationPathTypes),
      h = {
        version: 1,
        type: ee.Seedless,
        identifier: d,
        seedIdentifier: o,
        derivationIndex: l.derivationIndex,
        chains: f,
      };
    await va(e, h), c.push(h);
  }
  return c;
}
async function ZG(e, t, n) {
  const r = (await e.fetchChainAvailability()).enabledAddressTypes,
    i = 0,
    s = Ku(r);
  return (await AO(e, t, n, [{ name: n, derivationIndex: i, derivationPathTypes: s }]))[0];
}
async function IO(e, t, n, r, i = !1) {
  const s = await rI(e, t);
  if (!i && s) throw new JP();
  const o = Wb(t),
    a = t.fold((l) => ({ version: 1, identifier: o, name: n, entropy: new Uint8Array(l) }));
  await uK(e, a);
  const c = [],
    u = await Ts(e, o);
  for (const l of r) {
    const d = await Hb(o, l.derivationIndex, l.derivationPathTypes[0]),
      f = Ed(e, u, l.derivationIndex, l.derivationPathTypes),
      h = {
        version: 1,
        type: ee.Seed,
        identifier: d,
        seedIdentifier: o,
        derivationIndex: l.derivationIndex,
        chains: f,
      };
    await va(e, h), c.push(h);
  }
  return c;
}
async function JG(e, t, n) {
  const r = (await e.fetchChainAvailability()).enabledAddressTypes,
    i = 0,
    s = Ku(r);
  return (await IO(e, t, n, [{ name: n, derivationIndex: i, derivationPathTypes: s }]))[0];
}
function XG(e) {
  return _c.keccak256(e);
}
async function QG(e, t) {
  const n = [];
  for (const { publicKey: r, derivationPath: i, authToken: s } of t) {
    const o = XG(r),
      a = {
        version: 1,
        type: ee.SeedVault,
        identifier: o,
        derivationPath: i,
        authToken: s,
        publicKey: r,
        chainType: G.Solana,
      };
    n.push(a), await va(e, a);
  }
  return n;
}
async function TO(e, t, n) {
  var s;
  const i = (await vr(e)).find((o) => o.identifier === t);
  if (!i) throw new Ay();
  switch (i.type) {
    case ee.Seed:
    case ee.Seedless: {
      const o = (s = i.chains[n]) == null ? void 0 : s.pathType;
      if (!o) throw new hS();
      const a = await Ts(e, i.seedIdentifier),
        c = e.keypairGenerator.generateKeypairFromSeed(a, i.derivationIndex, o);
      return mr.from(c.privateKey);
    }
    case ee.PrivateKey: {
      const o = await Ub(e, i.privateKeyIdentifier);
      if (o.chainType !== n) throw new hS();
      const a = e.keypairGenerator.generateKeypairFromPrivateKey(mr.from(o.privateKey), n);
      return mr.from(a.privateKey);
    }
    case ee.Ledger:
    case ee.SeedVault:
      throw new _U();
    case ee.ReadOnly:
      throw new SU();
    default:
      ((o) => {
        throw new Error('invalid account type');
      })();
  }
}
function RS(e) {
  if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`);
}
function eq(e) {
  if (typeof e != 'boolean') throw new Error(`Expected boolean, not ${e}`);
}
function xO(e, ...t) {
  if (!(e instanceof Uint8Array)) throw new TypeError('Expected Uint8Array');
  if (t.length > 0 && !t.includes(e.length))
    throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function tq(e) {
  if (typeof e != 'function' || typeof e.create != 'function')
    throw new Error('Hash should be wrapped by utils.wrapConstructor');
  RS(e.outputLen), RS(e.blockLen);
}
function nq(e, t = !0) {
  if (e.destroyed) throw new Error('Hash instance has been destroyed');
  if (t && e.finished) throw new Error('Hash#digest() has already been called');
}
function rq(e, t) {
  xO(e);
  const n = t.outputLen;
  if (e.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`);
}
const Oi = { number: RS, bool: eq, bytes: xO, hash: tq, exists: nq, output: rq };
let kO = class extends n6 {
  constructor(t, n) {
    super(), (this.finished = !1), (this.destroyed = !1), Oi.hash(t);
    const r = Xl(n);
    if (((this.iHash = t.create()), typeof this.iHash.update != 'function'))
      throw new TypeError('Expected instance of class which extends utils.Hash');
    (this.blockLen = this.iHash.blockLen), (this.outputLen = this.iHash.outputLen);
    const i = this.blockLen,
      s = new Uint8Array(i);
    s.set(r.length > i ? t.create().update(r).digest() : r);
    for (let o = 0; o < s.length; o++) s[o] ^= 54;
    this.iHash.update(s), (this.oHash = t.create());
    for (let o = 0; o < s.length; o++) s[o] ^= 106;
    this.oHash.update(s), s.fill(0);
  }
  update(t) {
    return Oi.exists(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    Oi.exists(this),
      Oi.bytes(t, this.outputLen),
      (this.finished = !0),
      this.iHash.digestInto(t),
      this.oHash.update(t),
      this.oHash.digestInto(t),
      this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n, iHash: r, finished: i, destroyed: s, blockLen: o, outputLen: a } = this;
    return (
      (t = t),
      (t.finished = i),
      (t.destroyed = s),
      (t.blockLen = o),
      (t.outputLen = a),
      (t.oHash = n._cloneInto(t.oHash)),
      (t.iHash = r._cloneInto(t.iHash)),
      t
    );
  }
  destroy() {
    (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
  }
};
const CO = (e, t, n) => new kO(e, t).update(n).digest();
CO.create = (e, t) => new kO(e, t);
function iq(e, t, n, r) {
  Oi.hash(e);
  const i = GK({ dkLen: 32, asyncTick: 10 }, r),
    { c: s, dkLen: o, asyncTick: a } = i;
  if ((Oi.number(s), Oi.number(o), Oi.number(a), s < 1))
    throw new Error('PBKDF2: iterations (c) should be >= 1');
  const c = Xl(t),
    u = Xl(n),
    l = new Uint8Array(o),
    d = CO.create(e, c),
    f = d._cloneInto().update(u);
  return { c: s, dkLen: o, asyncTick: a, DK: l, PRF: d, PRFSalt: f };
}
function sq(e, t, n, r, i) {
  return e.destroy(), t.destroy(), r && r.destroy(), i.fill(0), n;
}
function oq(e, t, n, r) {
  const { c: i, dkLen: s, DK: o, PRF: a, PRFSalt: c } = iq(e, t, n, r);
  let u;
  const l = new Uint8Array(4),
    d = Ug(l),
    f = new Uint8Array(a.outputLen);
  for (let h = 1, p = 0; p < s; h++, p += a.outputLen) {
    const b = o.subarray(p, p + a.outputLen);
    d.setInt32(0, h, !1),
      (u = c._cloneInto(u)).update(l).digestInto(f),
      b.set(f.subarray(0, b.length));
    for (let w = 1; w < i; w++) {
      a._cloneInto(u).update(f).digestInto(f);
      for (let A = 0; A < b.length; A++) b[A] ^= f[A];
    }
  }
  return sq(a, c, o, u, f);
}
function aq(e, t, n, r) {
  if (typeof e.setBigUint64 == 'function') return e.setBigUint64(t, n, r);
  const i = BigInt(32),
    s = BigInt(4294967295),
    o = Number((n >> i) & s),
    a = Number(n & s),
    c = r ? 4 : 0,
    u = r ? 0 : 4;
  e.setUint32(t + c, o, r), e.setUint32(t + u, a, r);
}
let cq = class extends n6 {
  constructor(t, n, r, i) {
    super(),
      (this.blockLen = t),
      (this.outputLen = n),
      (this.padOffset = r),
      (this.isLE = i),
      (this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.buffer = new Uint8Array(t)),
      (this.view = Ug(this.buffer));
  }
  update(t) {
    Oi.exists(this);
    const { view: n, buffer: r, blockLen: i } = this;
    t = Xl(t);
    const s = t.length;
    for (let o = 0; o < s; ) {
      const a = Math.min(i - this.pos, s - o);
      if (a === i) {
        const c = Ug(t);
        for (; i <= s - o; o += i) this.process(c, o);
        continue;
      }
      r.set(t.subarray(o, o + a), this.pos),
        (this.pos += a),
        (o += a),
        this.pos === i && (this.process(n, 0), (this.pos = 0));
    }
    return (this.length += t.length), this.roundClean(), this;
  }
  digestInto(t) {
    Oi.exists(this), Oi.output(t, this), (this.finished = !0);
    const { buffer: n, view: r, blockLen: i, isLE: s } = this;
    let { pos: o } = this;
    (n[o++] = 128),
      this.buffer.subarray(o).fill(0),
      this.padOffset > i - o && (this.process(r, 0), (o = 0));
    for (let d = o; d < i; d++) n[d] = 0;
    aq(r, i - 8, BigInt(this.length * 8), s), this.process(r, 0);
    const a = Ug(t),
      c = this.outputLen;
    if (c % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
    const u = c / 4,
      l = this.get();
    if (u > l.length) throw new Error('_sha2: outputLen bigger than state');
    for (let d = 0; d < u; d++) a.setUint32(4 * d, l[d], s);
  }
  digest() {
    const { buffer: t, outputLen: n } = this;
    this.digestInto(t);
    const r = t.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: n, buffer: r, length: i, finished: s, destroyed: o, pos: a } = this;
    return (
      (t.length = i), (t.pos = a), (t.finished = s), (t.destroyed = o), i % n && t.buffer.set(r), t
    );
  }
};
const uq = (e, t, n) => (e & t) ^ (~e & n),
  lq = (e, t, n) => (e & t) ^ (e & n) ^ (t & n),
  dq = new Uint32Array([
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221,
    3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580,
    3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895,
    666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037,
    2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
    1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298,
  ]),
  xo = new Uint32Array([
    1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225,
  ]),
  ko = new Uint32Array(64);
let PO = class extends cq {
    constructor() {
      super(64, 32, 8, !1),
        (this.A = xo[0] | 0),
        (this.B = xo[1] | 0),
        (this.C = xo[2] | 0),
        (this.D = xo[3] | 0),
        (this.E = xo[4] | 0),
        (this.F = xo[5] | 0),
        (this.G = xo[6] | 0),
        (this.H = xo[7] | 0);
    }
    get() {
      const { A: t, B: n, C: r, D: i, E: s, F: o, G: a, H: c } = this;
      return [t, n, r, i, s, o, a, c];
    }
    set(t, n, r, i, s, o, a, c) {
      (this.A = t | 0),
        (this.B = n | 0),
        (this.C = r | 0),
        (this.D = i | 0),
        (this.E = s | 0),
        (this.F = o | 0),
        (this.G = a | 0),
        (this.H = c | 0);
    }
    process(t, n) {
      for (let d = 0; d < 16; d++, n += 4) ko[d] = t.getUint32(n, !1);
      for (let d = 16; d < 64; d++) {
        const f = ko[d - 15],
          h = ko[d - 2],
          p = Ji(f, 7) ^ Ji(f, 18) ^ (f >>> 3),
          b = Ji(h, 17) ^ Ji(h, 19) ^ (h >>> 10);
        ko[d] = (b + ko[d - 7] + p + ko[d - 16]) | 0;
      }
      let { A: r, B: i, C: s, D: o, E: a, F: c, G: u, H: l } = this;
      for (let d = 0; d < 64; d++) {
        const f = Ji(a, 6) ^ Ji(a, 11) ^ Ji(a, 25),
          h = (l + f + uq(a, c, u) + dq[d] + ko[d]) | 0,
          b = ((Ji(r, 2) ^ Ji(r, 13) ^ Ji(r, 22)) + lq(r, i, s)) | 0;
        (l = u), (u = c), (c = a), (a = (o + h) | 0), (o = s), (s = i), (i = r), (r = (h + b) | 0);
      }
      (r = (r + this.A) | 0),
        (i = (i + this.B) | 0),
        (s = (s + this.C) | 0),
        (o = (o + this.D) | 0),
        (a = (a + this.E) | 0),
        (c = (c + this.F) | 0),
        (u = (u + this.G) | 0),
        (l = (l + this.H) | 0),
        this.set(r, i, s, o, a, c, u, l);
    }
    roundClean() {
      ko.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
    }
  },
  fq = class extends PO {
    constructor() {
      super(),
        (this.A = -1056596264),
        (this.B = 914150663),
        (this.C = 812702999),
        (this.D = -150054599),
        (this.E = -4191439),
        (this.F = 1750603025),
        (this.G = 1694076839),
        (this.H = -1090891868),
        (this.outputLen = 28);
    }
  };
const hk = r6(() => new PO());
r6(() => new fq());
const iI = new Error('Unknown error'),
  zw = new Error('Invalid entropy length'),
  Gg = new Error('Invalid mn*monic sentence length'),
  hq = new Error('Invalid checksum'),
  pq = new RangeError('Invalid mn*monic word'),
  pk = new RangeError('Invalid wordlist'),
  MO = new RangeError('Invalid wordlist index'),
  hi = (e, t) => {
    if (!e) throw t;
  };
function tu(e) {
  hi(e >= 128, zw), hi(e <= 256, zw), hi(e % 32 === 0, zw);
}
function qb(e) {
  hi(e >= 12, Gg), hi(e <= 24, Gg), hi(e % 3 === 0, Gg);
}
function qg(e) {
  hi(e.length === 2048, pk),
    hi(
      e.every((t) => typeof t == 'string'),
      pk
    );
}
function gq(e, t) {
  return qb(e), t((e * 4) / 3);
}
async function OO(e, t) {
  const n = e.length * 8;
  tu(n);
  const r = n / 32,
    i = await t(e),
    [s] = i,
    o = 8 - r,
    a = ((s >>> o) << o) >>> 0,
    c = new Uint8Array(e.length + 1);
  return c.set(e, 0), (c[c.length - 1] = a), c;
}
function BO(e) {
  const t = (e.length - 1) * 8;
  tu(t);
  const n = t / 32,
    r = (t + n) / 11,
    i = new ArrayBuffer(r * 4),
    s = new DataView(i);
  let o = 0,
    a = 0,
    c = 0;
  for (const u of e)
    if (((c += 8), (a |= u << (32 - c)), (a >>>= 0), c >= 11)) {
      const l = a >>> 21;
      hi(l >= 0 && l <= 2047, MO),
        s.setUint32(o * 4, l, !0),
        o++,
        (a <<= 11),
        (a >>>= 0),
        (c -= 11);
    }
  return hi(o === r, Gg), new Uint32Array(i);
}
function yq(e) {
  const t = e.length;
  qb(t);
  const n = 11,
    r = e.length * n,
    i = new ArrayBuffer(Math.ceil(r / 8)),
    s = new DataView(i),
    o = new DataView(e.buffer),
    a = e.length;
  let c = 0,
    u = 0,
    l = 0,
    d = 8;
  for (let f = 0; f < a; f++) {
    const h = o.getUint32(f * 4, !0);
    hi(h < 2048, MO);
    let p = n;
    for (; p > 0; ) {
      const b = 32 - p,
        w = p >= d ? d : p;
      (c |= (h >> (32 - b - w)) & ((1 << w) - 1)),
        (u += w),
        (c <<= d - w),
        (c >>>= 0),
        (p -= w),
        (d -= w),
        d <= 0 && (d = 8),
        u % 8 === 0 && (s.setUint8(l, c), l++, (c = 0));
    }
  }
  return a % 8 !== 0 && s.setUint8(l, c), new Uint8Array(i);
}
function bq(e) {
  qb(e.length);
  const t = yq(e),
    n = t.slice(0, t.length - 1);
  return t.fill(0), n;
}
async function Yg(e, t) {
  const n = e.length * 8;
  tu(n);
  const r = await OO(e, t),
    i = BO(r);
  return r.fill(0), i;
}
function mq(e, t) {
  qg(t);
  const n = new Set(t),
    r = new Uint32Array(24);
  let i = 0,
    s = '';
  for (let a = 0; a < e.length; a++) {
    const c = e[a],
      u = c === 32,
      l = a === e.length - 1;
    if ((l && (s += String.fromCharCode(c)), u || l)) {
      hi(n.has(s), pq);
      let d = 0;
      for (const f of t) {
        if (s === f) break;
        d++;
      }
      (r[i++] = d), (s = '');
    } else s += String.fromCharCode(c);
  }
  qb(i);
  const o = r.slice(0, i);
  return r.fill(0), o;
}
async function Zg(e, t, n) {
  const r = await Yg(e, n),
    i = new Uint8Array(r.reduce((o, a) => o + t[a].length + 1, -1));
  let s = 0;
  for (const o of r) {
    s > 0 && (i[s++] = 32);
    const a = t[o];
    for (const c of a) i[s++] = c.charCodeAt(0);
  }
  return r.fill(0), i;
}
const Kw = Uint8Array.of(109, 110, 101, 109, 111, 110, 105, 99);
async function Jg(e, t, n, r, i) {
  const s = await Zg(e, n, r),
    o = new Uint8Array(Kw.length + t.length);
  o.set(Kw, 0), o.set(t, Kw.length);
  const a = await i(s, o, 2048, 64, 'sha512');
  return o.fill(0), s.fill(0), a;
}
const DO = [
  'abandon',
  'ability',
  'able',
  'about',
  'above',
  'absent',
  'absorb',
  'abstract',
  'absurd',
  'abuse',
  'access',
  'accident',
  'account',
  'accuse',
  'achieve',
  'acid',
  'acoustic',
  'acquire',
  'across',
  'act',
  'action',
  'actor',
  'actress',
  'actual',
  'adapt',
  'add',
  'addict',
  'address',
  'adjust',
  'admit',
  'adult',
  'advance',
  'advice',
  'aerobic',
  'affair',
  'afford',
  'afraid',
  'again',
  'age',
  'agent',
  'agree',
  'ahead',
  'aim',
  'air',
  'airport',
  'aisle',
  'alarm',
  'album',
  'alcohol',
  'alert',
  'alien',
  'all',
  'alley',
  'allow',
  'almost',
  'alone',
  'alpha',
  'already',
  'also',
  'alter',
  'always',
  'amateur',
  'amazing',
  'among',
  'amount',
  'amused',
  'analyst',
  'anchor',
  'ancient',
  'anger',
  'angle',
  'angry',
  'animal',
  'ankle',
  'announce',
  'annual',
  'another',
  'answer',
  'antenna',
  'antique',
  'anxiety',
  'any',
  'apart',
  'apology',
  'appear',
  'apple',
  'approve',
  'april',
  'arch',
  'arctic',
  'area',
  'arena',
  'argue',
  'arm',
  'armed',
  'armor',
  'army',
  'around',
  'arrange',
  'arrest',
  'arrive',
  'arrow',
  'art',
  'artefact',
  'artist',
  'artwork',
  'ask',
  'aspect',
  'assault',
  'asset',
  'assist',
  'assume',
  'asthma',
  'athlete',
  'atom',
  'attack',
  'attend',
  'attitude',
  'attract',
  'auction',
  'audit',
  'august',
  'aunt',
  'author',
  'auto',
  'autumn',
  'average',
  'avocado',
  'avoid',
  'awake',
  'aware',
  'away',
  'awesome',
  'awful',
  'awkward',
  'axis',
  'baby',
  'bachelor',
  'bacon',
  'badge',
  'bag',
  'balance',
  'balcony',
  'ball',
  'bamboo',
  'banana',
  'banner',
  'bar',
  'barely',
  'bargain',
  'barrel',
  'base',
  'basic',
  'basket',
  'battle',
  'beach',
  'bean',
  'beauty',
  'because',
  'become',
  'beef',
  'before',
  'begin',
  'behave',
  'behind',
  'believe',
  'below',
  'belt',
  'bench',
  'benefit',
  'best',
  'betray',
  'better',
  'between',
  'beyond',
  'bicycle',
  'bid',
  'bike',
  'bind',
  'biology',
  'bird',
  'birth',
  'bitter',
  'black',
  'blade',
  'blame',
  'blanket',
  'blast',
  'bleak',
  'bless',
  'blind',
  'blood',
  'blossom',
  'blouse',
  'blue',
  'blur',
  'blush',
  'board',
  'boat',
  'body',
  'boil',
  'bomb',
  'bone',
  'bonus',
  'book',
  'boost',
  'border',
  'boring',
  'borrow',
  'boss',
  'bottom',
  'bounce',
  'box',
  'boy',
  'bracket',
  'brain',
  'brand',
  'brass',
  'brave',
  'bread',
  'breeze',
  'brick',
  'bridge',
  'brief',
  'bright',
  'bring',
  'brisk',
  'broccoli',
  'broken',
  'bronze',
  'broom',
  'brother',
  'brown',
  'brush',
  'bubble',
  'buddy',
  'budget',
  'buffalo',
  'build',
  'bulb',
  'bulk',
  'bullet',
  'bundle',
  'bunker',
  'burden',
  'burger',
  'burst',
  'bus',
  'business',
  'busy',
  'butter',
  'buyer',
  'buzz',
  'cabbage',
  'cabin',
  'cable',
  'cactus',
  'cage',
  'cake',
  'call',
  'calm',
  'camera',
  'camp',
  'can',
  'canal',
  'cancel',
  'candy',
  'cannon',
  'canoe',
  'canvas',
  'canyon',
  'capable',
  'capital',
  'captain',
  'car',
  'carbon',
  'card',
  'cargo',
  'carpet',
  'carry',
  'cart',
  'case',
  'cash',
  'casino',
  'castle',
  'casual',
  'cat',
  'catalog',
  'catch',
  'category',
  'cattle',
  'caught',
  'cause',
  'caution',
  'cave',
  'ceiling',
  'celery',
  'cement',
  'census',
  'century',
  'cereal',
  'certain',
  'chair',
  'chalk',
  'champion',
  'change',
  'chaos',
  'chapter',
  'charge',
  'chase',
  'chat',
  'cheap',
  'check',
  'cheese',
  'chef',
  'cherry',
  'chest',
  'chicken',
  'chief',
  'child',
  'chimney',
  'choice',
  'choose',
  'chronic',
  'chuckle',
  'chunk',
  'churn',
  'cigar',
  'cinnamon',
  'circle',
  'citizen',
  'city',
  'civil',
  'claim',
  'clap',
  'clarify',
  'claw',
  'clay',
  'clean',
  'clerk',
  'clever',
  'click',
  'client',
  'cliff',
  'climb',
  'clinic',
  'clip',
  'clock',
  'clog',
  'close',
  'cloth',
  'cloud',
  'clown',
  'club',
  'clump',
  'cluster',
  'clutch',
  'coach',
  'coast',
  'coconut',
  'code',
  'coffee',
  'coil',
  'coin',
  'collect',
  'color',
  'column',
  'combine',
  'come',
  'comfort',
  'comic',
  'common',
  'company',
  'concert',
  'conduct',
  'confirm',
  'congress',
  'connect',
  'consider',
  'control',
  'convince',
  'cook',
  'cool',
  'copper',
  'copy',
  'coral',
  'core',
  'corn',
  'correct',
  'cost',
  'cotton',
  'couch',
  'country',
  'couple',
  'course',
  'cousin',
  'cover',
  'coyote',
  'crack',
  'cradle',
  'craft',
  'cram',
  'crane',
  'crash',
  'crater',
  'crawl',
  'crazy',
  'cream',
  'credit',
  'creek',
  'crew',
  'cricket',
  'crime',
  'crisp',
  'critic',
  'crop',
  'cross',
  'crouch',
  'crowd',
  'crucial',
  'cruel',
  'cruise',
  'crumble',
  'crunch',
  'crush',
  'cry',
  'crystal',
  'cube',
  'culture',
  'cup',
  'cupboard',
  'curious',
  'current',
  'curtain',
  'curve',
  'cushion',
  'custom',
  'cute',
  'cycle',
  'dad',
  'damage',
  'damp',
  'dance',
  'danger',
  'daring',
  'dash',
  'daughter',
  'dawn',
  'day',
  'deal',
  'debate',
  'debris',
  'decade',
  'december',
  'decide',
  'decline',
  'decorate',
  'decrease',
  'deer',
  'defense',
  'define',
  'defy',
  'degree',
  'delay',
  'deliver',
  'demand',
  'demise',
  'denial',
  'dentist',
  'deny',
  'depart',
  'depend',
  'deposit',
  'depth',
  'deputy',
  'derive',
  'describe',
  'desert',
  'design',
  'desk',
  'despair',
  'destroy',
  'detail',
  'detect',
  'develop',
  'device',
  'devote',
  'diagram',
  'dial',
  'diamond',
  'diary',
  'dice',
  'diesel',
  'diet',
  'differ',
  'digital',
  'dignity',
  'dilemma',
  'dinner',
  'dinosaur',
  'direct',
  'dirt',
  'disagree',
  'discover',
  'disease',
  'dish',
  'dismiss',
  'disorder',
  'display',
  'distance',
  'divert',
  'divide',
  'divorce',
  'dizzy',
  'doctor',
  'document',
  'dog',
  'doll',
  'dolphin',
  'domain',
  'donate',
  'donkey',
  'donor',
  'door',
  'dose',
  'double',
  'dove',
  'draft',
  'dragon',
  'drama',
  'drastic',
  'draw',
  'dream',
  'dress',
  'drift',
  'drill',
  'drink',
  'drip',
  'drive',
  'drop',
  'drum',
  'dry',
  'duck',
  'dumb',
  'dune',
  'during',
  'dust',
  'dutch',
  'duty',
  'dwarf',
  'dynamic',
  'eager',
  'eagle',
  'early',
  'earn',
  'earth',
  'easily',
  'east',
  'easy',
  'echo',
  'ecology',
  'economy',
  'edge',
  'edit',
  'educate',
  'effort',
  'egg',
  'eight',
  'either',
  'elbow',
  'elder',
  'electric',
  'elegant',
  'element',
  'elephant',
  'elevator',
  'elite',
  'else',
  'embark',
  'embody',
  'embrace',
  'emerge',
  'emotion',
  'employ',
  'empower',
  'empty',
  'enable',
  'enact',
  'end',
  'endless',
  'endorse',
  'enemy',
  'energy',
  'enforce',
  'engage',
  'engine',
  'enhance',
  'enjoy',
  'enlist',
  'enough',
  'enrich',
  'enroll',
  'ensure',
  'enter',
  'entire',
  'entry',
  'envelope',
  'episode',
  'equal',
  'equip',
  'era',
  'erase',
  'erode',
  'erosion',
  'error',
  'erupt',
  'escape',
  'essay',
  'essence',
  'estate',
  'eternal',
  'ethics',
  'evidence',
  'evil',
  'evoke',
  'evolve',
  'exact',
  'example',
  'excess',
  'exchange',
  'excite',
  'exclude',
  'excuse',
  'execute',
  'exercise',
  'exhaust',
  'exhibit',
  'exile',
  'exist',
  'exit',
  'exotic',
  'expand',
  'expect',
  'expire',
  'explain',
  'expose',
  'express',
  'extend',
  'extra',
  'eye',
  'eyebrow',
  'fabric',
  'face',
  'faculty',
  'fade',
  'faint',
  'faith',
  'fall',
  'false',
  'fame',
  'family',
  'famous',
  'fan',
  'fancy',
  'fantasy',
  'farm',
  'fashion',
  'fat',
  'fatal',
  'father',
  'fatigue',
  'fault',
  'favorite',
  'feature',
  'february',
  'federal',
  'fee',
  'feed',
  'feel',
  'female',
  'fence',
  'festival',
  'fetch',
  'fever',
  'few',
  'fiber',
  'fiction',
  'field',
  'figure',
  'file',
  'film',
  'filter',
  'final',
  'find',
  'fine',
  'finger',
  'finish',
  'fire',
  'firm',
  'first',
  'fiscal',
  'fish',
  'fit',
  'fitness',
  'fix',
  'flag',
  'flame',
  'flash',
  'flat',
  'flavor',
  'flee',
  'flight',
  'flip',
  'float',
  'flock',
  'floor',
  'flower',
  'fluid',
  'flush',
  'fly',
  'foam',
  'focus',
  'fog',
  'foil',
  'fold',
  'follow',
  'food',
  'foot',
  'force',
  'forest',
  'forget',
  'fork',
  'fortune',
  'forum',
  'forward',
  'fossil',
  'foster',
  'found',
  'fox',
  'fragile',
  'frame',
  'frequent',
  'fresh',
  'friend',
  'fringe',
  'frog',
  'front',
  'frost',
  'frown',
  'frozen',
  'fruit',
  'fuel',
  'fun',
  'funny',
  'furnace',
  'fury',
  'future',
  'gadget',
  'gain',
  'galaxy',
  'gallery',
  'game',
  'gap',
  'garage',
  'garbage',
  'garden',
  'garlic',
  'garment',
  'gas',
  'gasp',
  'gate',
  'gather',
  'gauge',
  'gaze',
  'general',
  'genius',
  'genre',
  'gentle',
  'genuine',
  'gesture',
  'ghost',
  'giant',
  'gift',
  'giggle',
  'ginger',
  'giraffe',
  'girl',
  'give',
  'glad',
  'glance',
  'glare',
  'glass',
  'glide',
  'glimpse',
  'globe',
  'gloom',
  'glory',
  'glove',
  'glow',
  'glue',
  'goat',
  'goddess',
  'gold',
  'good',
  'goose',
  'gorilla',
  'gospel',
  'gossip',
  'govern',
  'gown',
  'grab',
  'grace',
  'grain',
  'grant',
  'grape',
  'grass',
  'gravity',
  'great',
  'green',
  'grid',
  'grief',
  'grit',
  'grocery',
  'group',
  'grow',
  'grunt',
  'guard',
  'guess',
  'guide',
  'guilt',
  'guitar',
  'gun',
  'gym',
  'habit',
  'hair',
  'half',
  'hammer',
  'hamster',
  'hand',
  'happy',
  'harbor',
  'hard',
  'harsh',
  'harvest',
  'hat',
  'have',
  'hawk',
  'hazard',
  'head',
  'health',
  'heart',
  'heavy',
  'hedgehog',
  'height',
  'hello',
  'helmet',
  'help',
  'hen',
  'hero',
  'hidden',
  'high',
  'hill',
  'hint',
  'hip',
  'hire',
  'history',
  'hobby',
  'hockey',
  'hold',
  'hole',
  'holiday',
  'hollow',
  'home',
  'honey',
  'hood',
  'hope',
  'horn',
  'horror',
  'horse',
  'hospital',
  'host',
  'hotel',
  'hour',
  'hover',
  'hub',
  'huge',
  'human',
  'humble',
  'humor',
  'hundred',
  'hungry',
  'hunt',
  'hurdle',
  'hurry',
  'hurt',
  'husband',
  'hybrid',
  'ice',
  'icon',
  'idea',
  'identify',
  'idle',
  'ignore',
  'ill',
  'illegal',
  'illness',
  'image',
  'imitate',
  'immense',
  'immune',
  'impact',
  'impose',
  'improve',
  'impulse',
  'inch',
  'include',
  'income',
  'increase',
  'index',
  'indicate',
  'indoor',
  'industry',
  'infant',
  'inflict',
  'inform',
  'inhale',
  'inherit',
  'initial',
  'inject',
  'injury',
  'inmate',
  'inner',
  'innocent',
  'input',
  'inquiry',
  'insane',
  'insect',
  'inside',
  'inspire',
  'install',
  'intact',
  'interest',
  'into',
  'invest',
  'invite',
  'involve',
  'iron',
  'island',
  'isolate',
  'issue',
  'item',
  'ivory',
  'jacket',
  'jaguar',
  'jar',
  'jazz',
  'jealous',
  'jeans',
  'jelly',
  'jewel',
  'job',
  'join',
  'joke',
  'journey',
  'joy',
  'judge',
  'juice',
  'jump',
  'jungle',
  'junior',
  'junk',
  'just',
  'kangaroo',
  'keen',
  'keep',
  'ketchup',
  'key',
  'kick',
  'kid',
  'kidney',
  'kind',
  'kingdom',
  'kiss',
  'kit',
  'kitchen',
  'kite',
  'kitten',
  'kiwi',
  'knee',
  'knife',
  'knock',
  'know',
  'lab',
  'label',
  'labor',
  'ladder',
  'lady',
  'lake',
  'lamp',
  'language',
  'laptop',
  'large',
  'later',
  'latin',
  'laugh',
  'laundry',
  'lava',
  'law',
  'lawn',
  'lawsuit',
  'layer',
  'lazy',
  'leader',
  'leaf',
  'learn',
  'leave',
  'lecture',
  'left',
  'leg',
  'legal',
  'legend',
  'leisure',
  'lemon',
  'lend',
  'length',
  'lens',
  'leopard',
  'lesson',
  'letter',
  'level',
  'liar',
  'liberty',
  'library',
  'license',
  'life',
  'lift',
  'light',
  'like',
  'limb',
  'limit',
  'link',
  'lion',
  'liquid',
  'list',
  'little',
  'live',
  'lizard',
  'load',
  'loan',
  'lobster',
  'local',
  'lock',
  'logic',
  'lonely',
  'long',
  'loop',
  'lottery',
  'loud',
  'lounge',
  'love',
  'loyal',
  'lucky',
  'luggage',
  'lumber',
  'lunar',
  'lunch',
  'luxury',
  'lyrics',
  'machine',
  'mad',
  'magic',
  'magnet',
  'maid',
  'mail',
  'main',
  'major',
  'make',
  'mammal',
  'man',
  'manage',
  'mandate',
  'mango',
  'mansion',
  'manual',
  'maple',
  'marble',
  'march',
  'margin',
  'marine',
  'market',
  'marriage',
  'mask',
  'mass',
  'master',
  'match',
  'material',
  'math',
  'matrix',
  'matter',
  'maximum',
  'maze',
  'meadow',
  'mean',
  'measure',
  'meat',
  'mechanic',
  'medal',
  'media',
  'melody',
  'melt',
  'member',
  'memory',
  'mention',
  'menu',
  'mercy',
  'merge',
  'merit',
  'merry',
  'mesh',
  'message',
  'metal',
  'method',
  'middle',
  'midnight',
  'milk',
  'million',
  'mimic',
  'mind',
  'minimum',
  'minor',
  'minute',
  'miracle',
  'mirror',
  'misery',
  'miss',
  'mistake',
  'mix',
  'mixed',
  'mixture',
  'mobile',
  'model',
  'modify',
  'mom',
  'moment',
  'monitor',
  'monkey',
  'monster',
  'month',
  'moon',
  'moral',
  'more',
  'morning',
  'mosquito',
  'mother',
  'motion',
  'motor',
  'mountain',
  'mouse',
  'move',
  'movie',
  'much',
  'muffin',
  'mule',
  'multiply',
  'muscle',
  'museum',
  'mushroom',
  'music',
  'must',
  'mutual',
  'myself',
  'mystery',
  'myth',
  'naive',
  'name',
  'napkin',
  'narrow',
  'nasty',
  'nation',
  'nature',
  'near',
  'neck',
  'need',
  'negative',
  'neglect',
  'neither',
  'nephew',
  'nerve',
  'nest',
  'net',
  'network',
  'neutral',
  'never',
  'news',
  'next',
  'nice',
  'night',
  'noble',
  'noise',
  'nominee',
  'noodle',
  'normal',
  'north',
  'nose',
  'notable',
  'note',
  'nothing',
  'notice',
  'novel',
  'now',
  'nuclear',
  'number',
  'nurse',
  'nut',
  'oak',
  'obey',
  'object',
  'oblige',
  'obscure',
  'observe',
  'obtain',
  'obvious',
  'occur',
  'ocean',
  'october',
  'odor',
  'off',
  'offer',
  'office',
  'often',
  'oil',
  'okay',
  'old',
  'olive',
  'olympic',
  'omit',
  'once',
  'one',
  'onion',
  'online',
  'only',
  'open',
  'opera',
  'opinion',
  'oppose',
  'option',
  'orange',
  'orbit',
  'orchard',
  'order',
  'ordinary',
  'organ',
  'orient',
  'original',
  'orphan',
  'ostrich',
  'other',
  'outdoor',
  'outer',
  'output',
  'outside',
  'oval',
  'oven',
  'over',
  'own',
  'owner',
  'oxygen',
  'oyster',
  'ozone',
  'pact',
  'paddle',
  'page',
  'pair',
  'palace',
  'palm',
  'panda',
  'panel',
  'panic',
  'panther',
  'paper',
  'parade',
  'parent',
  'park',
  'parrot',
  'party',
  'pass',
  'patch',
  'path',
  'patient',
  'patrol',
  'pattern',
  'pause',
  'pave',
  'payment',
  'peace',
  'peanut',
  'pear',
  'peasant',
  'pelican',
  'pen',
  'penalty',
  'pencil',
  'people',
  'pepper',
  'perfect',
  'permit',
  'person',
  'pet',
  'phone',
  'photo',
  'phrase',
  'physical',
  'piano',
  'picnic',
  'picture',
  'piece',
  'pig',
  'pigeon',
  'pill',
  'pilot',
  'pink',
  'pioneer',
  'pipe',
  'pistol',
  'pitch',
  'pizza',
  'place',
  'planet',
  'plastic',
  'plate',
  'play',
  'please',
  'pledge',
  'pluck',
  'plug',
  'plunge',
  'poem',
  'poet',
  'point',
  'polar',
  'pole',
  'police',
  'pond',
  'pony',
  'pool',
  'popular',
  'portion',
  'position',
  'possible',
  'post',
  'potato',
  'pottery',
  'poverty',
  'powder',
  'power',
  'practice',
  'praise',
  'predict',
  'prefer',
  'prepare',
  'present',
  'pretty',
  'prevent',
  'price',
  'pride',
  'primary',
  'print',
  'priority',
  'prison',
  'private',
  'prize',
  'problem',
  'process',
  'produce',
  'profit',
  'program',
  'project',
  'promote',
  'proof',
  'property',
  'prosper',
  'protect',
  'proud',
  'provide',
  'public',
  'pudding',
  'pull',
  'pulp',
  'pulse',
  'pumpkin',
  'punch',
  'pupil',
  'puppy',
  'purchase',
  'purity',
  'purpose',
  'purse',
  'push',
  'put',
  'puzzle',
  'pyramid',
  'quality',
  'quantum',
  'quarter',
  'question',
  'quick',
  'quit',
  'quiz',
  'quote',
  'rabbit',
  'raccoon',
  'race',
  'rack',
  'radar',
  'radio',
  'rail',
  'rain',
  'raise',
  'rally',
  'ramp',
  'ranch',
  'random',
  'range',
  'rapid',
  'rare',
  'rate',
  'rather',
  'raven',
  'raw',
  'razor',
  'ready',
  'real',
  'reason',
  'rebel',
  'rebuild',
  'recall',
  'receive',
  'recipe',
  'record',
  'recycle',
  'reduce',
  'reflect',
  'reform',
  'refuse',
  'region',
  'regret',
  'regular',
  'reject',
  'relax',
  'release',
  'relief',
  'rely',
  'remain',
  'remember',
  'remind',
  'remove',
  'render',
  'renew',
  'rent',
  'reopen',
  'repair',
  'repeat',
  'replace',
  'report',
  'require',
  'rescue',
  'resemble',
  'resist',
  'resource',
  'response',
  'result',
  'retire',
  'retreat',
  'return',
  'reunion',
  'reveal',
  'review',
  'reward',
  'rhythm',
  'rib',
  'ribbon',
  'rice',
  'rich',
  'ride',
  'ridge',
  'rifle',
  'right',
  'rigid',
  'ring',
  'riot',
  'ripple',
  'risk',
  'ritual',
  'rival',
  'river',
  'road',
  'roast',
  'robot',
  'robust',
  'rocket',
  'romance',
  'roof',
  'rookie',
  'room',
  'rose',
  'rotate',
  'rough',
  'round',
  'route',
  'royal',
  'rubber',
  'rude',
  'rug',
  'rule',
  'run',
  'runway',
  'rural',
  'sad',
  'saddle',
  'sadness',
  'safe',
  'sail',
  'salad',
  'salmon',
  'salon',
  'salt',
  'salute',
  'same',
  'sample',
  'sand',
  'satisfy',
  'satoshi',
  'sauce',
  'sausage',
  'save',
  'say',
  'scale',
  'scan',
  'scare',
  'scatter',
  'scene',
  'scheme',
  'school',
  'science',
  'scissors',
  'scorpion',
  'scout',
  'scrap',
  'screen',
  'script',
  'scrub',
  'sea',
  'search',
  'season',
  'seat',
  'second',
  'secret',
  'section',
  'security',
  'seed',
  'seek',
  'segment',
  'select',
  'sell',
  'seminar',
  'senior',
  'sense',
  'sentence',
  'series',
  'service',
  'session',
  'settle',
  'setup',
  'seven',
  'shadow',
  'shaft',
  'shallow',
  'share',
  'shed',
  'shell',
  'sheriff',
  'shield',
  'shift',
  'shine',
  'ship',
  'shiver',
  'shock',
  'shoe',
  'shoot',
  'shop',
  'short',
  'shoulder',
  'shove',
  'shrimp',
  'shrug',
  'shuffle',
  'shy',
  'sibling',
  'sick',
  'side',
  'siege',
  'sight',
  'sign',
  'silent',
  'silk',
  'silly',
  'silver',
  'similar',
  'simple',
  'since',
  'sing',
  'siren',
  'sister',
  'situate',
  'six',
  'size',
  'skate',
  'sketch',
  'ski',
  'skill',
  'skin',
  'skirt',
  'skull',
  'slab',
  'slam',
  'sleep',
  'slender',
  'slice',
  'slide',
  'slight',
  'slim',
  'slogan',
  'slot',
  'slow',
  'slush',
  'small',
  'smart',
  'smile',
  'smoke',
  'smooth',
  'snack',
  'snake',
  'snap',
  'sniff',
  'snow',
  'soap',
  'soccer',
  'social',
  'sock',
  'soda',
  'soft',
  'solar',
  'soldier',
  'solid',
  'solution',
  'solve',
  'someone',
  'song',
  'soon',
  'sorry',
  'sort',
  'soul',
  'sound',
  'soup',
  'source',
  'south',
  'space',
  'spare',
  'spatial',
  'spawn',
  'speak',
  'special',
  'speed',
  'spell',
  'spend',
  'sphere',
  'spice',
  'spider',
  'spike',
  'spin',
  'spirit',
  'split',
  'spoil',
  'sponsor',
  'spoon',
  'sport',
  'spot',
  'spray',
  'spread',
  'spring',
  'spy',
  'square',
  'squeeze',
  'squirrel',
  'stable',
  'stadium',
  'staff',
  'stage',
  'stairs',
  'stamp',
  'stand',
  'start',
  'state',
  'stay',
  'steak',
  'steel',
  'stem',
  'step',
  'stereo',
  'stick',
  'still',
  'sting',
  'stock',
  'stomach',
  'stone',
  'stool',
  'story',
  'stove',
  'strategy',
  'street',
  'strike',
  'strong',
  'struggle',
  'student',
  'stuff',
  'stumble',
  'style',
  'subject',
  'submit',
  'subway',
  'success',
  'such',
  'sudden',
  'suffer',
  'sugar',
  'suggest',
  'suit',
  'summer',
  'sun',
  'sunny',
  'sunset',
  'super',
  'supply',
  'supreme',
  'sure',
  'surface',
  'surge',
  'surprise',
  'surround',
  'survey',
  'suspect',
  'sustain',
  'swallow',
  'swamp',
  'swap',
  'swarm',
  'swear',
  'sweet',
  'swift',
  'swim',
  'swing',
  'switch',
  'sword',
  'symbol',
  'symptom',
  'syrup',
  'system',
  'table',
  'tackle',
  'tag',
  'tail',
  'talent',
  'talk',
  'tank',
  'tape',
  'target',
  'task',
  'taste',
  'tattoo',
  'taxi',
  'teach',
  'team',
  'tell',
  'ten',
  'tenant',
  'tennis',
  'tent',
  'term',
  'test',
  'text',
  'thank',
  'that',
  'theme',
  'then',
  'theory',
  'there',
  'they',
  'thing',
  'this',
  'thought',
  'three',
  'thrive',
  'throw',
  'thumb',
  'thunder',
  'ticket',
  'tide',
  'tiger',
  'tilt',
  'timber',
  'time',
  'tiny',
  'tip',
  'tired',
  'tissue',
  'title',
  'toast',
  'tobacco',
  'today',
  'toddler',
  'toe',
  'together',
  'toilet',
  'token',
  'tomato',
  'tomorrow',
  'tone',
  'tongue',
  'tonight',
  'tool',
  'tooth',
  'top',
  'topic',
  'topple',
  'torch',
  'tornado',
  'tortoise',
  'toss',
  'total',
  'tourist',
  'toward',
  'tower',
  'town',
  'toy',
  'track',
  'trade',
  'traffic',
  'tragic',
  'train',
  'transfer',
  'trap',
  'trash',
  'travel',
  'tray',
  'treat',
  'tree',
  'trend',
  'trial',
  'tribe',
  'trick',
  'trigger',
  'trim',
  'trip',
  'trophy',
  'trouble',
  'truck',
  'true',
  'truly',
  'trumpet',
  'trust',
  'truth',
  'try',
  'tube',
  'tuition',
  'tumble',
  'tuna',
  'tunnel',
  'turkey',
  'turn',
  'turtle',
  'twelve',
  'twenty',
  'twice',
  'twin',
  'twist',
  'two',
  'type',
  'typical',
  'ugly',
  'umbrella',
  'unable',
  'unaware',
  'uncle',
  'uncover',
  'under',
  'undo',
  'unfair',
  'unfold',
  'unhappy',
  'uniform',
  'unique',
  'unit',
  'universe',
  'unknown',
  'unlock',
  'until',
  'unusual',
  'unveil',
  'update',
  'upgrade',
  'uphold',
  'upon',
  'upper',
  'upset',
  'urban',
  'urge',
  'usage',
  'use',
  'used',
  'useful',
  'useless',
  'usual',
  'utility',
  'vacant',
  'vacuum',
  'vague',
  'valid',
  'valley',
  'valve',
  'van',
  'vanish',
  'vapor',
  'various',
  'vast',
  'vault',
  'vehicle',
  'velvet',
  'vendor',
  'venture',
  'venue',
  'verb',
  'verify',
  'version',
  'very',
  'vessel',
  'veteran',
  'viable',
  'vibrant',
  'vicious',
  'victory',
  'video',
  'view',
  'village',
  'vintage',
  'violin',
  'virtual',
  'virus',
  'visa',
  'visit',
  'visual',
  'vital',
  'vivid',
  'vocal',
  'voice',
  'void',
  'volcano',
  'volume',
  'vote',
  'voyage',
  'wage',
  'wagon',
  'wait',
  'walk',
  'wall',
  'walnut',
  'want',
  'warfare',
  'warm',
  'warrior',
  'wash',
  'wasp',
  'waste',
  'water',
  'wave',
  'way',
  'wealth',
  'weapon',
  'wear',
  'weasel',
  'weather',
  'web',
  'wedding',
  'weekend',
  'weird',
  'welcome',
  'west',
  'wet',
  'whale',
  'what',
  'wheat',
  'wheel',
  'when',
  'where',
  'whip',
  'whisper',
  'wide',
  'width',
  'wife',
  'wild',
  'will',
  'win',
  'window',
  'wine',
  'wing',
  'wink',
  'winner',
  'winter',
  'wire',
  'wisdom',
  'wise',
  'wish',
  'witness',
  'wolf',
  'woman',
  'wonder',
  'wood',
  'wool',
  'word',
  'work',
  'world',
  'worry',
  'worth',
  'wrap',
  'wreck',
  'wrestle',
  'wrist',
  'write',
  'wrong',
  'yard',
  'year',
  'yellow',
  'you',
  'young',
  'youth',
  'zebra',
  'zero',
  'zone',
  'zoo',
];
async function Vw(e) {
  switch (e) {
    case 'english':
      return DO;
  }
}
function Ww(e) {
  return (t) => new e(t);
}
function Hw(e, t) {
  return async (n) => {
    let r = null,
      i = null,
      s = null,
      o = null,
      a = null;
    try {
      (i = bq(n)), (s = await OO(i, t)), (o = BO(s));
      const c = n[n.length - 1],
        u = o[o.length - 1];
      if (c !== u) throw hq;
      a = e.fromEntropy(i);
    } catch (c) {
      c instanceof Error ? (r = c) : (console.error(c), (r = iI));
    } finally {
      if ((i == null || i.fill(0), s == null || s.fill(0), o == null || o.fill(0), r)) throw r;
      return a;
    }
  };
}
function Gw(e, t) {
  return async (n) => {
    let r = null,
      i = null,
      s = null;
    try {
      (i = mq(n, t)), (s = await e.fromIndexes(i));
    } catch (o) {
      o instanceof Error ? (r = o) : (console.error(o), (r = iI));
    } finally {
      if ((i == null || i.fill(0), r)) throw r;
      return s;
    }
  };
}
function qw(e, t) {
  return (n) => {
    let r = null,
      i = null,
      s = null;
    try {
      (i = gq(n, t)), (s = e.fromEntropy(i));
    } catch (o) {
      o instanceof Error ? (r = o) : (console.error(o), (r = iI));
    } finally {
      if ((i == null || i.fill(0), r)) throw r;
      return s;
    }
  };
}
class gk {
  static async webCrypto(t) {
    var o, a;
    const n = typeof t == 'string' ? await Vw(t) : t;
    qg(n);
    const r = (c) => crypto.getRandomValues(new Uint8Array(c)),
      i = async (c) => new Uint8Array(await crypto.subtle.digest('SHA-256', c)),
      s = async (c, u, l, d, f) => {
        const h = 'SHA-' + f.substring(3),
          p = await crypto.subtle.importKey('raw', c, 'PBKDF2', !1, ['deriveBits']),
          b = await crypto.subtle.deriveBits(
            { name: 'PBKDF2', salt: u, iterations: l, hash: h },
            p,
            d * 8
          );
        return new Uint8Array(b);
      };
    return (
      (o = class {
        constructor(u) {
          Vt(this, a);
          ae(this, 'deriveSeed', (u = new Uint8Array()) => Jg(oe(this, a), u, n, i, s));
          ae(this, 'getEntropy', () => oe(this, a).slice());
          ae(this, 'getIndexes', () => Yg(oe(this, a), i));
          ae(this, 'getMnemonic', () => Zg(oe(this, a), n, i));
          ae(this, 'getSentenceLength', () => {
            const u = oe(this, a).length * 8,
              l = u / 32;
            return (u + l) / 11;
          });
          tu(u.length * 8), Ft(this, a, u.slice());
        }
      }),
      (a = new WeakMap()),
      ae(o, 'fromEntropy', Ww(o)),
      ae(o, 'fromIndexes', Hw(o, i)),
      ae(o, 'fromMnemonic', Gw(o, n)),
      ae(o, 'fromSentenceLength', qw(o, r)),
      ae(o, 'wordlist', n),
      o
    );
  }
  static async nodeCrypto(t) {
    var o, a;
    const n = typeof t == 'string' ? await Vw(t) : t;
    qg(n);
    const r = (c) => new Uint8Array(_w.randomBytes(c).buffer),
      i = (c) => new Uint8Array(_w.createHash('sha256').update(c).digest().buffer),
      s = (...c) =>
        new Promise((u, l) => {
          _w.pbkdf2(...c, (d, f) => {
            if (d) return l(d);
            u(new Uint8Array(f.buffer));
          });
        });
    return (
      (o = class {
        constructor(u) {
          Vt(this, a);
          ae(this, 'deriveSeed', (u = new Uint8Array()) => Jg(oe(this, a), u, n, i, s));
          ae(this, 'getEntropy', () => oe(this, a).slice());
          ae(this, 'getIndexes', () => Yg(oe(this, a), i));
          ae(this, 'getMnemonic', () => Zg(oe(this, a), n, i));
          ae(this, 'getSentenceLength', () => {
            const u = oe(this, a).length * 8,
              l = u / 32;
            return (u + l) / 11;
          });
          tu(u.length * 8), Ft(this, a, u.slice());
        }
      }),
      (a = new WeakMap()),
      ae(o, 'fromEntropy', Ww(o)),
      ae(o, 'fromIndexes', Hw(o, i)),
      ae(o, 'fromMnemonic', Gw(o, n)),
      ae(o, 'fromSentenceLength', qw(o, r)),
      ae(o, 'wordlist', n),
      o
    );
  }
  static async customCrypto(t, n) {
    var a, c;
    const r = typeof t == 'string' ? await Vw(t) : t;
    qg(r);
    const { random: i, sha256: s, pbkdf2: o } = n;
    return (
      (a = class {
        constructor(l) {
          Vt(this, c);
          ae(this, 'deriveSeed', (l = new Uint8Array()) => Jg(oe(this, c), l, r, s, o));
          ae(this, 'getEntropy', () => oe(this, c).slice());
          ae(this, 'getIndexes', () => Yg(oe(this, c), s));
          ae(this, 'getMnemonic', () => Zg(oe(this, c), r, s));
          ae(this, 'getSentenceLength', () => {
            const l = oe(this, c).length * 8,
              d = l / 32;
            return (l + d) / 11;
          });
          tu(l.length * 8), Ft(this, c, l.slice());
        }
      }),
      (c = new WeakMap()),
      ae(a, 'fromEntropy', Ww(a)),
      ae(a, 'fromIndexes', Hw(a, s)),
      ae(a, 'fromMnemonic', Gw(a, r)),
      ae(a, 'fromSentenceLength', qw(a, i)),
      ae(a, 'wordlist', r),
      a
    );
  }
}
async function wq(e, t) {
  let n;
  const r = await e.secureCache.getSeed(t);
  if (r) n = r;
  else {
    const s = await Vb(e, t);
    try {
      n = await s.foldAsync(async (a) =>
        Jg(a, new Uint8Array(), DO, hk, (c, u, l, d) => oq(hk, c, u, { c: l, dkLen: d }))
      );
    } catch {
      throw new Error('InvalidEntropyBip39');
    }
    await e.secureCache.setSeed(t, n);
  }
  const i = mr.from(n);
  return n.fill(0), i;
}
const vq = new SA(),
  _q = new hS(),
  Sq = new XP(),
  Bt = {
    unableToLoadAccounts: {
      status: 'unable-to-load-accounts',
      isOnboarded: !1,
      reonboardingNeeded: !1,
    },
    unonboarded: { status: 'unonboarded', isOnboarded: !1, reonboardingNeeded: !1 },
    invalidIdentifier: { status: 'invalid-identifier', isOnboarded: !0, reonboardingNeeded: !0 },
    fetchIntegrityStorageError: {
      status: 'fetch-integrity-storage-error',
      isOnboarded: !0,
      reonboardingNeeded: !0,
    },
    fetchEntropyStorageError: {
      status: 'fetch-entropy-storage-error',
      isOnboarded: !0,
      reonboardingNeeded: !0,
    },
    fetchPkStorageError: {
      status: 'fetch-pk-storage-error',
      isOnboarded: !0,
      reonboardingNeeded: !0,
    },
    invalidEntropy: { status: 'invalid-entropy', isOnboarded: !0, reonboardingNeeded: !0 },
    invalidEntropyBip39: {
      status: 'invalid-entropy-bip-39',
      isOnboarded: !0,
      reonboardingNeeded: !0,
    },
    invalidChecksumBits: {
      status: 'invalid-checksum-bits',
      isOnboarded: !0,
      reonboardingNeeded: !0,
    },
    invalidEntropyBits: { status: 'invalid-entropy-bits', isOnboarded: !0, reonboardingNeeded: !0 },
    invalidChecksum: { status: 'invalid-checksum', isOnboarded: !0, reonboardingNeeded: !0 },
    invalidEntropyLengthLessThanTwelve: {
      status: 'invalid-entropy-length-less-than-twelve',
      isOnboarded: !0,
      reonboardingNeeded: !0,
    },
    invalidEntropyLengthMoreThanTwentyFour: {
      status: 'invalid-entropy-length-more-than-twenty-four',
      isOnboarded: !0,
      reonboardingNeeded: !0,
    },
    invalidEntropyLengthWrongWord: {
      status: 'invalid-entropy-length-wrong-word',
      isOnboarded: !0,
      reonboardingNeeded: !0,
    },
    invalidPkAddressType: {
      status: 'invalid-pk-address-type',
      isOnboarded: !0,
      reonboardingNeeded: !0,
    },
    invalidPkIdentifier: {
      status: 'invalid-pk-identifier',
      isOnboarded: !0,
      reonboardingNeeded: !0,
    },
    invalidPk: { status: 'invalid-pk', isOnboarded: !0, reonboardingNeeded: !0 },
    internalError: { status: 'internal-error', isOnboarded: !0, reonboardingNeeded: !0 },
    safelyOnboarded: { status: 'safely-onboarded', isOnboarded: !0, reonboardingNeeded: !1 },
  };
async function Eq(e, t = !1, n = !1) {
  let r;
  try {
    if (((r = await vr(e)), r.length === 0)) return Bt.unonboarded;
  } catch {
    return Bt.unableToLoadAccounts;
  }
  return t ? Aq(e, r, n) : RO(e, r);
}
const Aq = async (e, t, n) => {
    const r = await RO(e, t);
    if (r.status !== 'safely-onboarded') return r;
    try {
      const a = await qM(e);
      if ((a == null ? void 0 : a.version) === 3 && a != null && a.isSafelyOnboarded)
        return Bt.safelyOnboarded;
    } catch {
      return Bt.fetchIntegrityStorageError;
    }
    const i = await bk(e, t, ee.Seed, n),
      s = await bk(e, t, ee.Seedless, n),
      o = await Tq(e, t);
    return i.status !== 'safely-onboarded'
      ? i
      : s.status !== 'safely-onboarded'
        ? s
        : o.status !== 'safely-onboarded'
          ? o
          : (await GM(e, { version: 3, isSafelyOnboarded: !0, lastCheckedTimestamp: Date.now() }),
            Bt.safelyOnboarded);
  },
  RO = async (e, t) => {
    try {
      const i = await qM(e);
      if (i != null && i.isSafelyOnboarded) return Bt.safelyOnboarded;
    } catch {
      return Bt.fetchIntegrityStorageError;
    }
    const n = await yk(e, t, ee.Seed),
      r = await yk(e, t, ee.Seedless);
    return n.status !== 'safely-onboarded'
      ? n
      : r.status !== 'safely-onboarded'
        ? r
        : (await GM(e, { version: 1, isSafelyOnboarded: !0, lastCheckedTimestamp: Date.now() }),
          Bt.safelyOnboarded);
  },
  yk = async (e, t, n) => {
    const r = new Set();
    for (const i of t) i.type === n && r.add(i.seedIdentifier);
    for (const i of r)
      try {
        await Vb(e, i);
      } catch (s) {
        if (s instanceof Error) {
          if (s.message === vq.message) return Bt.invalidIdentifier;
          if (s.message.match(/ExpoSecureStorage/)) return Bt.fetchEntropyStorageError;
        }
        return Bt.internalError;
      }
    return Bt.safelyOnboarded;
  },
  Iq = (e) => {
    if (!(e instanceof Error)) return Bt.invalidEntropy;
    const t = [
      [/ExpoSecureStorage/, Bt.fetchEntropyStorageError],
      [/InvalidEntropyBip39/, Bt.invalidEntropyBip39],
      [/LessThanTwelve/, Bt.invalidEntropyLengthLessThanTwelve],
      [/MoreThanTwentyFour/, Bt.invalidEntropyLengthMoreThanTwentyFour],
      [/WrongWord/, Bt.invalidEntropyLengthWrongWord],
      [/InvalidChecksumBits/, Bt.invalidChecksumBits],
      [/InvalidEntropyBits/, Bt.invalidEntropyBits],
      [/InvalidChecksum/, Bt.invalidChecksum],
    ];
    for (const [n, r] of t) if (e.message.match(n)) return r;
    return Bt.invalidEntropy;
  },
  bk = async (e, t, n, r) => {
    const i = new Set();
    for (const s of t) s.type === n && i.add(s.seedIdentifier);
    for (const s of i)
      try {
        r ? await wq(e, s) : await Ts(e, s);
      } catch (o) {
        return Iq(o);
      }
    return Bt.safelyOnboarded;
  },
  Tq = async (e, t) => {
    for (const n of t)
      if (n.type === ee.PrivateKey)
        try {
          await TO(e, n.identifier, n.chainType);
        } catch (r) {
          if (r instanceof Error) {
            if (r.message === _q.message) return Bt.invalidPkAddressType;
            if (r.message === Sq.message) return Bt.invalidPkIdentifier;
            if (r.message.match(/ExpoSecureStorage/)) return Bt.fetchPkStorageError;
          }
          return Bt.invalidPk;
        }
    return Bt.safelyOnboarded;
  };
async function xq(e) {
  const t = (await e.fetchChainAvailability()).enabledAddressTypes;
  let n = !1;
  const r = await vr(e);
  if (r.length === 0) return n;
  const i = new Map();
  for (const s of r) {
    if (s.type !== ee.Seed && s.type !== ee.Seedless) continue;
    const o = i.get(s.seedIdentifier);
    o ? o.push(s) : i.set(s.seedIdentifier, [s]);
  }
  for (const [s, o] of i) {
    let a;
    for (const c of o)
      if (!(c.chains && !$U(Object.values(c.chains)[0].pathType)))
        for (const u of t) {
          if (c.chains[u]) continue;
          a || (a = await Ts(e, s));
          const d = Ku([u]),
            f = Ed(e, a, c.derivationIndex, d);
          (c.chains = { ...c.chains, ...f }), (n = !0);
        }
  }
  return n && (await tc(e, r)), n;
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const NO = BigInt(
    '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'
  ),
  mk = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),
  kq = BigInt(1),
  NS = BigInt(2),
  wk = (e, t) => (e + t / NS) / t;
function Cq(e) {
  const t = NO,
    n = BigInt(3),
    r = BigInt(6),
    i = BigInt(11),
    s = BigInt(22),
    o = BigInt(23),
    a = BigInt(44),
    c = BigInt(88),
    u = (e * e * e) % t,
    l = (u * u * e) % t,
    d = (Qr(l, n, t) * l) % t,
    f = (Qr(d, n, t) * l) % t,
    h = (Qr(f, NS, t) * u) % t,
    p = (Qr(h, i, t) * h) % t,
    b = (Qr(p, s, t) * p) % t,
    w = (Qr(b, a, t) * b) % t,
    A = (Qr(w, c, t) * w) % t,
    _ = (Qr(A, a, t) * b) % t,
    x = (Qr(_, n, t) * l) % t,
    k = (Qr(x, o, t) * p) % t,
    j = (Qr(k, r, t) * u) % t,
    F = Qr(j, NS, t);
  if (!jS.eql(jS.sqr(F), e)) throw new Error('Cannot find square root');
  return F;
}
const jS = h6(NO, void 0, void 0, { sqrt: Cq }),
  LS = m6(
    {
      a: BigInt(0),
      b: BigInt(7),
      Fp: jS,
      n: mk,
      Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),
      Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),
      h: BigInt(1),
      lowS: !0,
      endo: {
        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
        splitScalar: (e) => {
          const t = mk,
            n = BigInt('0x3086d221a7d46bcde86c90e49284eb15'),
            r = -kq * BigInt('0xe4437ed6010e88286f547fa90abfe4c3'),
            i = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'),
            s = n,
            o = BigInt('0x100000000000000000000000000000000'),
            a = wk(s * e, t),
            c = wk(-r * e, t);
          let u = Ir(e - a * n - c * i, t),
            l = Ir(-a * r - c * s, t);
          const d = u > o,
            f = l > o;
          if ((d && (u = t - u), f && (l = t - l), u > o || l > o))
            throw new Error('splitScalar: Endomorphism failed, k=' + e);
          return { k1neg: d, k1: u, k2neg: f, k2: l };
        },
      },
    },
    w6
  );
BigInt(0);
LS.ProjectivePoint;
async function Pq() {
  const e = LS.utils.randomPrivateKey();
  return { publicKey: LS.getPublicKey(e), privateKey: e };
}
const jO = (e) => `${As}.perps.agent.keypair.${e}`,
  LO = async (e, t, n = !1) => {
    const r = await Mq(e, t);
    if (r && !n) return r;
    const i = await Pq();
    return await Oq(e, i, t), i;
  },
  Mq = async (e, t) => {
    const n = jO(t);
    let r = null;
    try {
      r = await e.secretsStorage.getSecureValue(n);
    } catch {}
    if (!r) return null;
    const i = r.keyPair,
      s = new Uint8Array(z.from(i.publicKey.bytes, i.publicKey.encoding)),
      o = new Uint8Array(z.from(i.privateKey.bytes, i.privateKey.encoding));
    return { publicKey: s, privateKey: o };
  },
  Oq = async (e, t, n) => {
    const r = jO(n),
      i = {
        publicKey: { bytes: z.from(t.publicKey).toString('base64'), encoding: 'base64' },
        privateKey: { bytes: z.from(t.privateKey).toString('base64'), encoding: 'base64' },
      },
      s = { version: 1, identifier: n, keyPair: i };
    await e.secretsStorage.setSecureValue(r, s);
  },
  Bq = async (e, t, n = !1) => {
    const { publicKey: r } = await LO(e, t, n);
    return eo({ publicKey: r, addressType: G.EVM });
  },
  Yw = "m/23001'/0'";
async function UO(e, t) {
  let n;
  switch (t.type) {
    case ee.Seedless:
    case ee.Seed:
      n = t.seedIdentifier;
      break;
    case ee.PrivateKey:
      n = t.privateKeyIdentifier;
      break;
  }
  const r = await e.secureCache.getClientJWTSigner(n, Yw);
  if (r) return { publicKey: r.p256pubkey, privateKey: r.p256privkey };
  let i;
  switch (t.type) {
    case ee.Seedless:
    case ee.Seed: {
      i = (await Ts(e, t.seedIdentifier)).fold((o) => new vy(o));
      break;
    }
    case ee.PrivateKey: {
      const s = await Ub(e, t.privateKeyIdentifier);
      i = new vy(s.privateKey);
      break;
    }
  }
  try {
    const s = i.derivePath({ ellipticCurve: 'ed25519', derivationPath: Yw, bytesInPrivateKey: 64 }),
      o = y6(s.secretKey, xS.CURVE.n),
      a = xS.getPublicKey(o);
    return (
      await e.secureCache.setClientJWTSigner(n, Yw, { p256pubkey: a, p256privkey: o }),
      { publicKey: a, privateKey: o }
    );
  } finally {
    i.cleanup();
  }
}
const Dq = (e) => e.type === ee.Seed || e.type === ee.Seedless || e.type === ee.PrivateKey,
  Rq = async (e, t) => {
    const n = await vr(e);
    if (n.length === 0) throw new Error('No accounts, unable to get authentication public key.');
    const i = n
      .filter(Dq)
      .find((a) =>
        a.type === ee.PrivateKey ? a.privateKeyIdentifier === t : a.seedIdentifier === t
      );
    if (!i)
      throw new Error('Unable to derive authentication public key for given secret identifier.');
    const s = await UO(e, i);
    return ki(z.from(s.publicKey));
  },
  Nq = "m/24001'/0'",
  $O = async (e) => {
    const t = await vr(e);
    if (t.length === 0) throw new Error('No accounts, unable to derive cash key.');
    const n = t[0];
    let r;
    switch (n.type) {
      case ee.Seed:
      case ee.Seedless: {
        r = (await Ts(e, n.seedIdentifier)).fold((s) => new vy(s));
        break;
      }
      case ee.PrivateKey: {
        const i = await Ub(e, n.privateKeyIdentifier);
        r = new vy(i.privateKey);
        break;
      }
      default:
        throw new Error(`Account type ${n.type} is not supported, unable to derive cash key.`);
    }
    try {
      const i = r.derivePath({
        ellipticCurve: 'ed25519',
        derivationPath: Nq,
        bytesInPrivateKey: 64,
      });
      return { publicKey: i.publicKey, privateKey: i.secretKey };
    } finally {
      r.cleanup();
    }
  },
  jq = async (e) => {
    const { publicKey: t } = await $O(e);
    return or.encode(t);
  };
async function Lq(e, t) {
  const n = await vr(e);
  if (n.length === 0) throw new Ay();
  const r = n.filter((i) => i.identifier !== t);
  await tc(e, r), await HM(e);
}
async function Uq(e, t, n) {
  const r = await vr(e);
  if (n < 0 || n >= r.length) throw new Ay();
  const i = r.map((o) => o.identifier).indexOf(t);
  if (i < 0) throw new Ay();
  if (i === n) return;
  const s = r[i];
  r.splice(i, 1), r.splice(n, 0, s), await tc(e, r);
}
async function Zp(e, t, n) {
  var s;
  const r = (s = t.chains[n]) == null ? void 0 : s.pathType;
  if (!r)
    return an(
      at.InvalidAddressType,
      `Seed Account does not contain a chain address for the chain type ${n}.`
    );
  const i = await Ts(e, t.seedIdentifier);
  return e.keypairGenerator.generateKeypairFromSeed(i, t.derivationIndex, r);
}
async function $q(e, t, n) {
  const r = await vr(e),
    i = r.find((s) => s.identifier === t);
  if (!i)
    return an(
      at.InvalidAccountId,
      `Vault (${r.length} account(s) found) does not contain an account for the given identifier: ${t}`
    );
  if ('isAgentWallet' in n)
    switch (i.type) {
      case ee.Seedless:
      case ee.Seed:
      case ee.PrivateKey: {
        const s = await LO(e, i.identifier);
        return e.vaultSigner.signWithKeypair(s, n);
      }
      default:
        return an(at.UnsupportedOperation, 'Invalid signingAccount type provided for paramType');
    }
  if ('isJWT' in n)
    switch (i.type) {
      case ee.Seedless:
      case ee.Seed:
      case ee.PrivateKey: {
        const s = await UO(e, i);
        return e.vaultSigner.signWithKeypair(s, n);
      }
      default:
        return an(at.UnsupportedOperation, 'Invalid signingAccount type provided for paramType');
    }
  if ('isCash' in n)
    switch (i.type) {
      case ee.Seedless:
      case ee.Seed:
      case ee.PrivateKey: {
        const s = await $O(e);
        return e.vaultSigner.signWithKeypair(s, n);
      }
      default:
        return an(at.UnsupportedOperation, 'Invalid signingAccount type provided for paramType');
    }
  switch (i.type) {
    case ee.Seedless:
    case ee.Seed: {
      switch (n.chainType) {
        case G.BitcoinTaproot:
        case G.BitcoinNativeSegwit:
        case G.BitcoinNestedSegwit:
        case G.BitcoinLegacy: {
          const { enabledAddressTypes: s } = await e.fetchChainAvailability(),
            o = {},
            a = Object.keys(i.chains)
              .filter((c) => uA.safeParse(c).success)
              .filter((c) => s.includes(c));
          for (const c of a) {
            const u = await Zp(e, i, c);
            if ('status' in u && u.status === 'error') return u;
            o[c] = u;
          }
          return e.vaultSigner.signWithKeypair(o, n);
        }
        case G.EVM: {
          const s = await Zp(e, i, n.chainType);
          return 'status' in s && s.status === 'error' ? s : e.vaultSigner.signWithKeypair(s, n);
        }
        case G.Solana: {
          const s = await Zp(e, i, n.chainType);
          return 'status' in s && s.status === 'error' ? s : e.vaultSigner.signWithKeypair(s, n);
        }
        case G.Sui: {
          const s = await Zp(e, i, n.chainType);
          return 'status' in s && s.status === 'error' ? s : e.vaultSigner.signWithKeypair(s, n);
        }
      }
      break;
    }
    case ee.PrivateKey: {
      const s = await Ub(e, i.privateKeyIdentifier);
      if (s.chainType !== n.chainType)
        return an(
          at.InvalidAddressType,
          `Private Key account from accountID is a different chain type from params. Expected ${s.chainType}, got ${n.chainType}`
        );
      const o = e.keypairGenerator.generateKeypairFromPrivateKey(
        mr.from(s.privateKey),
        n.chainType
      );
      switch (n.chainType) {
        case G.BitcoinTaproot:
        case G.BitcoinNativeSegwit:
        case G.BitcoinNestedSegwit:
        case G.BitcoinLegacy:
          return e.vaultSigner.signWithKeypair({ [n.chainType]: o }, n);
        case G.EVM:
          return e.vaultSigner.signWithKeypair(o, n);
        case G.Solana:
          return e.vaultSigner.signWithKeypair(o, n);
        case G.Sui:
          return e.vaultSigner.signWithKeypair(o, n);
      }
      break;
    }
    case ee.Ledger: {
      const s = i.chains[n.chainType];
      if (!s)
        return an(
          at.InvalidAddressType,
          `Ledger Account does not contain a chain address for the chain type ${n.chainType}.`
        );
      const o = E9.safeParse({ pathType: s.pathType, index: i.derivationIndex });
      if (!o.success)
        return an(
          at.InvalidDerivationPath,
          'Unsupported Derivation Path. Ledger account derivation path type is incompatible with ChainType in signing params.'
        );
      const a = A9(o.data);
      return e.vaultSigner.signWithHardware(t, a, n);
    }
    case ee.SeedVault: {
      const { authToken: s, derivationPath: o, chainType: a } = i;
      return a !== n.chainType
        ? an(
            at.InvalidAddressType,
            `Solana Seed Vault account from accountID is a different chain type from params. Expected ${a}, got ${n.chainType}`
          )
        : e.vaultSigner.signWithSolanaSeedVault(s, o, n);
    }
    case ee.ReadOnly:
      return an(at.UnsupportedOperation, 'Read Only Accounts cannot sign transactions.');
    default:
      ((s) => {
        throw new Error('invalid account type');
      })();
  }
}
function Fq(e) {
  switch (e.type) {
    case ee.Seed:
      return Xg(e);
    case ee.Seedless:
      return Qg(e);
    case ee.PrivateKey:
      return zO(e);
    case ee.Ledger:
      return FO(e);
    case ee.SeedVault:
      return KO(e);
    case ee.ReadOnly:
      return e;
  }
}
function FO(e) {
  const { chains: t, version: n, ...r } = e,
    i = {};
  for (const s of Object.keys(t)) {
    const o = t[s];
    if (!o) continue;
    let a;
    switch (o.chainType) {
      case G.Solana:
      case G.EVM: {
        const { publicKey: c, ...u } = o;
        a = { ...u, address: c };
        break;
      }
      case G.BitcoinTaproot:
      case G.BitcoinNativeSegwit:
      case G.BitcoinNestedSegwit:
      case G.BitcoinLegacy: {
        const { addresses: c, ...u } = o,
          l = Object.values(Vi).reduce((d, f) => {
            const h = c ? c[f] : void 0;
            if (!h) throw new Ib();
            return { ...d, [f]: h };
          }, {});
        a = { ...u, addresses: l };
        break;
      }
      case G.Sui: {
        a = o;
        break;
      }
    }
    i[s] = a;
  }
  return { ...r, chains: i };
}
function zO(e) {
  switch (e.chainType) {
    case G.Solana:
    case G.EVM: {
      const { publicKey: t, version: n, ...r } = e;
      return { ...r, address: t };
    }
    case G.BitcoinTaproot:
    case G.BitcoinNativeSegwit:
    case G.BitcoinNestedSegwit:
    case G.BitcoinLegacy: {
      const { addresses: t, version: n, ...r } = e,
        i = Object.values(Vi).reduce((s, o) => {
          const a = t ? t[o] : void 0;
          if (!a) throw new Ib();
          return { ...s, [o]: a };
        }, {});
      return { ...r, addresses: i };
    }
    case G.Sui:
      return e;
  }
}
function KO(e) {
  const { publicKey: t, version: n, ...r } = e;
  return { ...r, address: t };
}
function Xg(e) {
  const { chains: t, version: n, ...r } = e,
    i = {};
  for (const s of Object.keys(t)) {
    const o = t[s];
    if (!o) continue;
    let a;
    switch (o.chainType) {
      case G.Solana:
      case G.EVM: {
        const { publicKey: c, ...u } = o;
        a = { ...u, address: c };
        break;
      }
      case G.BitcoinTaproot:
      case G.BitcoinNativeSegwit:
      case G.BitcoinNestedSegwit:
      case G.BitcoinLegacy: {
        const { addresses: c, ...u } = o,
          l = Object.values(Vi).reduce((d, f) => {
            const h = c ? c[f] : void 0;
            if (!h) throw new Ib();
            return { ...d, [f]: h };
          }, {});
        a = { ...u, addresses: l };
        break;
      }
      case G.Sui: {
        a = o;
        break;
      }
    }
    i[s] = a;
  }
  return { ...r, chains: i };
}
function Qg(e) {
  const { chains: t, version: n, ...r } = e,
    i = {};
  for (const s of Object.keys(t)) {
    const o = t[s];
    if (!o) continue;
    let a;
    switch (o.chainType) {
      case G.Solana:
      case G.EVM: {
        const { publicKey: c, ...u } = o;
        a = { ...u, address: c };
        break;
      }
      case G.BitcoinTaproot:
      case G.BitcoinNativeSegwit:
      case G.BitcoinNestedSegwit:
      case G.BitcoinLegacy: {
        const { addresses: c, ...u } = o,
          l = Object.values(Vi).reduce((d, f) => {
            const h = c ? c[f] : void 0;
            if (!h) throw new Ib();
            return { ...d, [f]: h };
          }, {});
        a = { ...u, addresses: l };
        break;
      }
      case G.Sui:
        a = o;
    }
    i[s] = a;
  }
  return { ...r, chains: i };
}
const zq = new Set(Object.values(ee)),
  vk = (e) => e !== null && zq.has(e),
  Kq = (e) => {},
  Zw = (e, t) => {
    const n = t === ee.Seed ? 'se*d' : 'se*dless';
    if (e.derivationIndex === null || e.derivationIndex < 0)
      return (
        re.addBreadcrumb(
          ce.Auth,
          `Invalid derivation index for ${n} account: ${e.derivationIndex}`,
          Ie.Error
        ),
        null
      );
    const r = e.addresses.reduce((s, o) => {
      if (o.pathType === 'privateKey')
        return (
          re.addBreadcrumb(
            ce.Auth,
            `Invalid path type when converting synced account to ${n} account: ${o.pathType}`,
            Ie.Error
          ),
          s
        );
      const a = I9(o.pathType);
      switch (o.pathType) {
        case ke.BitcoinTaproot:
        case ke.BitcoinNativeSegwit:
        case ke.BitcoinNestedSegwit:
        case ke.BitcoinLegacy:
          $l(a)
            ? (s[a] = {
                chainType: a,
                publicKey: z.from(o.publicKey.replace('0x', ''), 'hex'),
                addresses: { [Vi.Mainnet]: o.address },
                pathType: o.pathType,
              })
            : re.addBreadcrumb(
                ce.Auth,
                `Invalid address type used when converting synced account to ${n} account.`,
                Ie.Error,
                { addressType: a, pathType: o.pathType }
              );
          break;
        case ke.Bip44RootSolana:
        case ke.Bip44Solana:
        case ke.Bip44ChangeSolana:
        case ke.DeprecatedSolana:
          a === G.Solana
            ? (s[a] = {
                chainType: a,
                publicKey: or.encode(z.from(o.publicKey.replace('0x', ''), 'hex')),
                pathType: o.pathType,
              })
            : re.addBreadcrumb(
                ce.Auth,
                `Invalid address type used when converting synced account to ${n} account.`,
                Ie.Error,
                { addressType: a, pathType: o.pathType }
              );
          break;
        case ke.Bip44RootEthereum:
        case ke.Bip44Ethereum:
        case ke.Bip44EthereumSecondary:
        case ke.Bip44EthereumTertiary:
          a === G.EVM
            ? (s[a] = { chainType: a, publicKey: o.address, pathType: o.pathType })
            : re.addBreadcrumb(
                ce.Auth,
                `Invalid address type used when converting synced account to ${n} account.`,
                Ie.Error,
                { addressType: a, pathType: o.pathType }
              );
          break;
        case ke.Bip44Sui:
          a === G.Sui
            ? (s[a] = {
                chainType: a,
                publicKey: mP(o.publicKey),
                address: o.address,
                pathType: o.pathType,
              })
            : re.addBreadcrumb(
                ce.Auth,
                `Invalid address type used when converting synced account to ${n} account.`,
                Ie.Error,
                { addressType: a, pathType: o.pathType }
              );
          break;
        default:
          Kq(o.pathType);
      }
      return s;
    }, {});
    if (Object.entries(r).length === 0)
      return (
        re.captureError(
          new Error(`Unable to convert synced account to ${n} account. No addresses found.`),
          ce.Auth
        ),
        null
      );
    const i = pu(e);
    return i
      ? {
          version: 1,
          type: t,
          identifier: e.accountHash,
          seedIdentifier: i,
          derivationIndex: e.derivationIndex,
          chains: r,
        }
      : (re.captureError(
          new Error(`Unable to convert synced account to ${n} account. Missing account origin.`),
          ce.Auth
        ),
        null);
  },
  _k = (e) => {
    const t = pu(e);
    if (!t)
      return (
        re.captureError(
          new Error('Unable to convert synced account to pk account. Missing account origin.'),
          ce.Auth
        ),
        null
      );
    const n = e.addresses[0];
    if (!n)
      return (
        re.captureError(
          new Error('Unable to convert synced account to pk account. No address.'),
          ce.Auth
        ),
        null
      );
    let r;
    try {
      r = bs(n.networkId, n.address);
    } catch {
      return (
        re.captureError(
          new Error(
            'Unable to convert synced account to pk account. Unable to determine address type.'
          ),
          ce.Auth
        ),
        null
      );
    }
    return $l(r)
      ? {
          version: 1,
          type: ee.PrivateKey,
          identifier: e.accountHash,
          privateKeyIdentifier: t,
          publicKey: z.from(n.publicKey.replace('0x', ''), 'hex'),
          addresses: { [Vi.Mainnet]: n.address },
          chainType: r,
        }
      : r === G.Solana
        ? {
            version: 1,
            type: ee.PrivateKey,
            identifier: e.accountHash,
            privateKeyIdentifier: t,
            publicKey: or.encode(z.from(n.publicKey.replace('0x', ''), 'hex')),
            chainType: r,
          }
        : r === G.EVM
          ? {
              version: 1,
              type: ee.PrivateKey,
              identifier: e.accountHash,
              privateKeyIdentifier: t,
              publicKey: n.address,
              chainType: r,
            }
          : r === G.Sui
            ? {
                version: 1,
                type: ee.PrivateKey,
                identifier: e.accountHash,
                privateKeyIdentifier: t,
                publicKey: mP(n.publicKey),
                address: n.address,
                chainType: r,
              }
            : (qt(), null);
  },
  Vq = async (e, t) => {
    const n = await vr(e),
      r = await Is(e),
      i = new Set(r.seedIdentifiers),
      s = new Set(r.seedlessIdentifiers),
      o = new Set(r.privateKeyIdentifiers);
    for (let c = 0; c < n.length; ++c) {
      const u = n[c],
        l = t[u.identifier];
      if ((delete t[u.identifier], !l || u.type !== ee.ReadOnly)) continue;
      const d = ky(l),
        f = pu(l);
      if (!vk(d) || !f) continue;
      let h = null;
      switch (d) {
        case ee.Seed:
        case ee.Seedless:
          try {
            (i.has(f) || s.has(f)) && (h = Zw(l, d));
          } catch {}
          break;
        case ee.PrivateKey:
          try {
            o.has(f) && (h = _k(l));
          } catch {}
          break;
      }
      h && (n[c] = h);
    }
    const a = [...n];
    for (const c of Object.values(t)) {
      if (c.addresses.length === 0) continue;
      const u = ky(c),
        l = pu(c);
      if (!(!vk(u) || !l))
        switch (u) {
          case ee.Seed:
            if (i.has(l)) {
              const d = Zw(c, u);
              d && a.push(d);
            }
            break;
          case ee.Seedless:
            if (s.has(l)) {
              const d = Zw(c, u);
              d && a.push(d);
            }
            break;
          case ee.PrivateKey:
            if (o.has(l)) {
              const d = _k(c);
              d && a.push(d);
            }
            break;
        }
    }
    return await tc(e, a), !1;
  };
function Wq(e) {
  return {
    addSeedWithDefaultAccount: (t, n) => JG(e, t, n).then(Xg),
    addAccountForExistingSeed: (t) => RG(e, t).then(Xg),
    addSeedWithMultipleAccounts: (t, n, r, i) => IO(e, t, n, r, i).then((s) => s.map(Xg)),
    addPrivateKeyAccount: (t, n, r) => WG(e, t, n, r).then(zO),
    addLedgerAccounts: (t, n) => KG(e, t, n).then((r) => r.map(FO)),
    addSolanaSeedVaultAccounts: (t) => QG(e, t).then((n) => n.map(KO)),
    addReadonlyAccount: (t) => GG(e, t),
    deriveAddresses: () => xq(e),
    removeAccount: (t) => Lq(e, t),
    reorderAccount: (t, n) => Uq(e, t, n),
    exportEntropy: (t) => Vb(e, t),
    exportPrivateKey: (t, n) => TO(e, t, n),
    fetchAllAccounts: () => vr(e).then((t) => t.map(Fq)),
    fetchAllSeedMetas: () => oK(e),
    fetchAllSeedlessMetas: () => WM(e),
    sign: (t, n) => $q(e, t, n),
    isExistingSeed: (t) => rI(e, t),
    checkVaultIntegrity: (t) => Eq(e, t),
    clearVault: () => dK(e),
    addSeedlessWithMultipleAccounts: (t, n, r) => AO(e, t, n, r).then((i) => i.map(Qg)),
    addSeedlessWithDefaultAccount: (t, n) => ZG(e, t, n).then(Qg),
    addAccountForExistingSeedless: (t) => qG(e, t).then(Qg),
    getAuthenticationPublicKey: (t) => Rq(e, t),
    getCashAddress: () => jq(e),
    getAgentAddress: (t, n) => Bq(e, t, n),
    syncAccounts: (t) => Vq(e, t),
  };
}
const Hq = () => wP(Un, (e) => new Gq(e))();
var Xo;
class Gq {
  constructor(t) {
    Vt(this, Xo);
    ae(this, 'identifyAccount', async (t, n, r) => {
      const i = !!n.addresses.find((f) => de.isSolanaNetworkID(f.networkID)),
        s = !!n.addresses.find((f) => de.isEthereumNetworkID(f.networkID)),
        o = !!n.addresses.find((f) => de.isBitcoinNetworkID(f.networkID)),
        a = !!n.addresses.find((f) => de.isSuiNetworkID(f.networkID)),
        c = { hasSolanaAddress: i, hasEthereumAddress: s, hasBitcoinAddress: o, hasSuiAddress: a },
        u = r.enabledChainIDs.map((f) => de[f].name).join(', '),
        l = new Set(),
        d = new Set();
      for (const f of t)
        switch (f.type) {
          case ee.Seed:
          case ee.Seedless:
            l.add(f.seedIdentifier);
            break;
          case ee.ReadOnly:
            break;
          case ee.PrivateKey:
          case ee.Ledger:
          case ee.SeedVault:
            d.add(f.identifier);
            break;
          default:
            qt();
            break;
        }
      switch (n.type) {
        case ee.Seed:
        case ee.Seedless:
          oe(this, Xo).identify(n.identifier, {
            ...c,
            accountType: n.type,
            rootID: n.seedIdentifier,
            rootIds: Array.from(l),
            accountIds: Array.from(d),
            isReadOnly: !1,
            enabledChains: u,
          });
          break;
        case ee.ReadOnly:
          oe(this, Xo).identify(n.identifier, {
            ...c,
            accountType: n.type,
            isReadOnly: !0,
            enabledChains: u,
          });
          break;
        case ee.PrivateKey:
        case ee.Ledger:
        case ee.SeedVault:
          oe(this, Xo).identify(n.identifier, {
            ...c,
            accountType: n.type,
            rootIds: Array.from(l),
            accountIds: Array.from(d),
            isReadOnly: !1,
            enabledChains: u,
          });
          break;
        default:
          qt();
      }
    });
    ae(this, 'onAppSessionStart', (t) => {
      const n = new Map();
      for (const r of t) {
        if (r.type === ee.ReadOnly) continue;
        const { addresses: i, identifier: s } = r;
        for (const o of i) {
          const a = de.getChainName(o.networkID),
            c = { type: r.type, accountId: s, id: o.address };
          if (!n.get(a)) n.set(a, [c]);
          else {
            const u = n.get(a) ?? [];
            n.set(a, [...u, c]);
          }
        }
      }
      oe(this, Xo).capture('appSessionStart', { data: { ids: Object.fromEntries(n) } });
    });
    Ft(this, Xo, t);
  }
}
Xo = new WeakMap();
const VO = ({ networkID: e, endpoint: t, param: n, explorerType: r }) => {
    const s = fS.get(e).getExplorerUrl(e)[r ?? fS.get(e).defaultExplorer];
    return s ? s(t, n) : '';
  },
  qq = () => {
    const e = [];
    return (
      WP.forEach((t) => {
        e.push(t.value), t.isLocale && e.push(t.value.substr(0, 2));
      }),
      [...new Set(e)]
    );
  },
  Yq = (e, t) =>
    e.substr(0, 3) === 'fil'
      ? t === 'fil'
      : e.substr(0, 2) === 'zh'
        ? e === 'zh-TW'
          ? t === 'zh-TW'
          : t === 'zh-CN'
        : t === e.substr(0, 2),
  WO = (e) => {
    var t;
    return (t = WP.find((n) => Yq(e, n.value))) == null ? void 0 : t.value;
  },
  Rr = '@phantom/settings',
  Zq = {
    emojiSkinTone() {
      return [`${Rr}:emoji-skin-tone`];
    },
    isAnalyticsOptedOut() {
      return [`${Rr}:is-analytics-opted-out`];
    },
    solanaActionsEnabled() {
      return [`${Rr}:solana-actions-enabled`];
    },
    showWalletShortcuts() {
      return [`${Rr}:show-wallet-shortcuts`];
    },
    preferredExplorers() {
      return [`${Rr}:preferred-explorers`];
    },
    recentAddresses() {
      return [`${Rr}:recent-addresses`];
    },
    savedAddresses() {
      return [`${Rr}:saved-addresses`];
    },
    trustedApps() {
      return [`${Rr}:trusted-apps`];
    },
    metaMaskOverride() {
      return [`${Rr}:metamask-override`];
    },
    autoConfirm(e, t) {
      return [Rr, 'auto-confirm', e, t];
    },
    allAutoConfirm(e) {
      return [Rr, 'auto-confirm', e];
    },
    webViewDebugging() {
      return [`${Rr}:enable-webview-debugging:v1`];
    },
    selectedCurrency() {
      return [`${Rr}:selected-currency`];
    },
  };
et.UserTrustedApps;
const Jq = 7200,
  Xq = g.object({
    networks: g.record($u, g.boolean()),
    sessionStartTime: g.number().optional(),
    maxSessionDuration: g.literal(Jq),
  });
g.record(g.string(), Xq);
var Sk = {};
const Qq = Sk.RUDDERSTACK_DATAPLANE ?? Sk.VITE_RUDDERSTACK_DATAPLANE ?? 'https://data.phantom.app';
var HO = { exports: {} };
(function (e) {
  (function (t, n) {
    e.exports ? (e.exports = n()) : (t.log = n());
  })(m, function () {
    var t = function () {},
      n = 'undefined',
      r =
        typeof window !== n &&
        typeof window.navigator !== n &&
        /Trident\/|MSIE /.test(window.navigator.userAgent),
      i = ['trace', 'debug', 'info', 'warn', 'error'],
      s = {},
      o = null;
    function a(b, w) {
      var A = b[w];
      if (typeof A.bind == 'function') return A.bind(b);
      try {
        return Function.prototype.bind.call(A, b);
      } catch {
        return function () {
          return Function.prototype.apply.apply(A, [b, arguments]);
        };
      }
    }
    function c() {
      console.log &&
        (console.log.apply
          ? console.log.apply(console, arguments)
          : Function.prototype.apply.apply(console.log, [console, arguments])),
        console.trace && console.trace();
    }
    function u(b) {
      return (
        b === 'debug' && (b = 'log'),
        typeof console === n
          ? !1
          : b === 'trace' && r
            ? c
            : console[b] !== void 0
              ? a(console, b)
              : console.log !== void 0
                ? a(console, 'log')
                : t
      );
    }
    function l() {
      for (var b = this.getLevel(), w = 0; w < i.length; w++) {
        var A = i[w];
        this[A] = w < b ? t : this.methodFactory(A, b, this.name);
      }
      if (((this.log = this.debug), typeof console === n && b < this.levels.SILENT))
        return 'No console available for logging';
    }
    function d(b) {
      return function () {
        typeof console !== n && (l.call(this), this[b].apply(this, arguments));
      };
    }
    function f(b, w, A) {
      return u(b) || d.apply(this, arguments);
    }
    function h(b, w) {
      var A = this,
        _,
        x,
        k,
        j = 'loglevel';
      typeof b == 'string' ? (j += ':' + b) : typeof b == 'symbol' && (j = void 0);
      function F(E) {
        var y = (i[E] || 'silent').toUpperCase();
        if (!(typeof window === n || !j)) {
          try {
            window.localStorage[j] = y;
            return;
          } catch {}
          try {
            window.document.cookie = encodeURIComponent(j) + '=' + y + ';';
          } catch {}
        }
      }
      function K() {
        var E;
        if (!(typeof window === n || !j)) {
          try {
            E = window.localStorage[j];
          } catch {}
          if (typeof E === n)
            try {
              var y = window.document.cookie,
                v = encodeURIComponent(j),
                S = y.indexOf(v + '=');
              S !== -1 && (E = /^([^;]+)/.exec(y.slice(S + v.length + 1))[1]);
            } catch {}
          return A.levels[E] === void 0 && (E = void 0), E;
        }
      }
      function D() {
        if (!(typeof window === n || !j)) {
          try {
            window.localStorage.removeItem(j);
          } catch {}
          try {
            window.document.cookie =
              encodeURIComponent(j) + '=; expires=Thu, 01 Jan 1970 00:00:00 UTC';
          } catch {}
        }
      }
      function C(E) {
        var y = E;
        if (
          (typeof y == 'string' &&
            A.levels[y.toUpperCase()] !== void 0 &&
            (y = A.levels[y.toUpperCase()]),
          typeof y == 'number' && y >= 0 && y <= A.levels.SILENT)
        )
          return y;
        throw new TypeError('log.setLevel() called with invalid level: ' + E);
      }
      (A.name = b),
        (A.levels = { TRACE: 0, DEBUG: 1, INFO: 2, WARN: 3, ERROR: 4, SILENT: 5 }),
        (A.methodFactory = w || f),
        (A.getLevel = function () {
          return k ?? x ?? _;
        }),
        (A.setLevel = function (E, y) {
          return (k = C(E)), y !== !1 && F(k), l.call(A);
        }),
        (A.setDefaultLevel = function (E) {
          (x = C(E)), K() || A.setLevel(E, !1);
        }),
        (A.resetLevel = function () {
          (k = null), D(), l.call(A);
        }),
        (A.enableAll = function (E) {
          A.setLevel(A.levels.TRACE, E);
        }),
        (A.disableAll = function (E) {
          A.setLevel(A.levels.SILENT, E);
        }),
        (A.rebuild = function () {
          if ((o !== A && (_ = C(o.getLevel())), l.call(A), o === A))
            for (var E in s) s[E].rebuild();
        }),
        (_ = C(o ? o.getLevel() : 'WARN'));
      var B = K();
      B != null && (k = C(B)), l.call(A);
    }
    (o = new h()),
      (o.getLogger = function (w) {
        if ((typeof w != 'symbol' && typeof w != 'string') || w === '')
          throw new TypeError('You must supply a name when creating a logger.');
        var A = s[w];
        return A || (A = s[w] = new h(w, o.methodFactory)), A;
      });
    var p = typeof window !== n ? window.log : void 0;
    return (
      (o.noConflict = function () {
        return typeof window !== n && window.log === o && (window.log = p), o;
      }),
      (o.getLoggers = function () {
        return s;
      }),
      (o.default = o),
      o
    );
  });
})(HO);
var eY = HO.exports;
const js = Sc(eY);
var tY = nY;
function nY(e) {
  var t, n, r;
  if (e) {
    if (Array.isArray(e)) {
      for (t = [], n = e.length, r = 0; r < n; r++) {
        var i = e[r];
        i != null && t.push(i);
      }
      return t;
    }
    if (typeof e == 'object') {
      t = {};
      var s = Object.keys(e);
      for (n = s.length, r = 0; r < n; r++) {
        var o = s[r],
          a = e[o];
        a != null && (t[o] = a);
      }
      return t;
    }
  }
}
const rY = g.object({
    chainType: g.union([g.literal('bip122_p2wpkh'), g.literal('bip122_p2tr')]),
    chainName: g.literal('bitcoin'),
    networkId: g.union([g.literal('128'), g.literal('239')]),
  }),
  iY = g.object({
    chainType: g.literal('eip155'),
    chainName: g.literal('ethereum'),
    networkId: g.union([g.literal('1'), g.literal('5'), g.literal('11155111')]),
  }),
  sY = g.object({
    chainType: g.literal('eip155'),
    chainName: g.literal('polygon'),
    networkId: g.union([g.literal('137'), g.literal('80002')]),
  }),
  oY = g.object({
    chainType: g.literal('eip155'),
    chainName: g.literal('base'),
    networkId: g.union([g.literal('8453'), g.literal('84532')]),
  }),
  aY = g.object({
    chainType: g.literal('eip155'),
    chainName: g.literal('arbitrum'),
    networkId: g.union([g.literal('42161'), g.literal('421614')]),
  }),
  cY = g.object({
    chainType: g.literal('eip155'),
    chainName: g.literal('monad'),
    networkId: g.union([g.literal('143'), g.literal('10143'), g.literal('41454')]),
  }),
  uY = g.object({
    chainType: g.literal('solana'),
    chainName: g.literal('solana'),
    networkId: g.union([
      g.literal('mainnet'),
      g.literal('testnet'),
      g.literal('devnet'),
      g.literal('localnet'),
    ]),
  }),
  lY = g.object({
    chainType: g.literal('sui'),
    chainName: g.literal('sui'),
    networkId: g.union([g.literal('mainnet'), g.literal('testnet')]),
  }),
  dY = g.union([rY, iY, oY, aY, cY, sY, uY, lY]);
var fY = {};
const hY = () => (document == null ? void 0 : document.referrer) || '$direct',
  pY = () =>
    ['t', 'y', '1', 'true', 'yes'].some((e) => {
      var t;
      return ((t = fY.DISABLE_ANALYTICS) == null ? void 0 : t.toLowerCase()) === e;
    }) ?? !1;
function GO(e) {
  var i;
  if (!e) return;
  let t = e.data ?? {},
    n = ((i = e.data) == null ? void 0 : i.asset) ?? {};
  try {
    (t = JSON.parse(JSON.stringify(t))), (n = JSON.parse(JSON.stringify(n)));
  } catch (s) {
    js.error('Failed to parse analytics payload', s);
    return;
  }
  const r = {
    ...t,
    ...(e.action ? { action: e.action } : {}),
    ...(n && typeof n == 'object' ? n : {}),
    ...(e.type ? { type: e.type } : {}),
  };
  if ('chainID' in r && !('chainType' in r) && !('chainName' in r) && !('networkId' in r)) {
    const s = $u.safeParse(r.chainID);
    s.success && Object.assign(r, gY(s.data));
  }
  return tY(r);
}
function gY(e) {
  const t = de.getChainDefinition(e);
  return dY.parse({
    chainType: t.addressTypes[0],
    chainName: t.id,
    networkId: t.networks[e].value.toString(),
  });
}
const yY = [
    'enable-blocklist-metrics',
    'enable-blocklist-blowfish-logonly',
    'enable-force-upgrade',
  ],
  Co = '[Analytics Log]';
class bY {
  constructor(t) {
    ae(this, 'storage');
    ae(this, 'rudderClient');
    this.storage = t;
  }
  async capture(t, n) {
    js.debug(Co, 'Capture Event:', t, GO(n));
  }
  async getFeatureFlags() {
    const {
        ENABLED_FLAGS: t,
        featureFlags: n,
        getFeatureFlagOverrides: r,
      } = await mA(
        async () => {
          const {
            ENABLED_FLAGS: c,
            featureFlags: u,
            getFeatureFlagOverrides: l,
          } = await import('./phantomRpc-C42kJpAs.js').then((d) => d.bo);
          return { ENABLED_FLAGS: c, featureFlags: u, getFeatureFlagOverrides: l };
        },
        __vite__mapDeps([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])
      ),
      i = n.filter((c) => !c.startsWith('kill') && !yY.includes(c)),
      s = Object.fromEntries(i.map((c) => [c, !0])),
      o = await r(this.storage),
      a = Object.fromEntries(t.map((c) => [c, !0]));
    return { ...s, ...a, ...o };
  }
  async addUserProperties(t) {
    js.debug(Co, 'User Properties:', JSON.stringify(t));
  }
  async identify(t, n) {
    js.debug(Co, 'Identify, accountID:', t, ' traits:', n);
  }
  async getDeviceId() {
    return 'mock-device-id';
  }
  setDeviceId(t) {
    js.debug(Co, `SetDeviceId: ${t}`);
  }
  async setAnalyticsOptedOut(t) {
    js.debug(Co, `SetAnalyticsOptedOut: ${t}`);
  }
  async setDisplayLanguage(t) {
    js.debug(Co, `SetDisplayLanguage: ${t}`);
  }
  screen(t, n) {
    js.debug(Co, `Screen: ${t}`, n);
  }
  page(t, n, r, i) {
    js.debug(Co, `Page: ${t}`, n, r, i);
  }
}
const mY = () => Qq,
  qO = ({ storage: e, rudderStackKey: t, createAnalytics: n }) => {
    if (!t) throw new Error('RUDDERSTACK_KEY_[*] env variables required.');
    const r = mY();
    if (!r) throw new Error('[*]_RUDDERSTACK_DATAPLANE env variables required.');
    return pY() ? new bY(e) : n(t, r);
  };
async function Po() {}
const YO = () => ({
  capture: Po,
  getFeatureFlags: async () => ({}),
  addUserProperties: Po,
  identify: Po,
  getDeviceId: async () => '',
  setDeviceId: Po,
  setAnalyticsOptedOut: Po,
  setDisplayLanguage: Po,
  screen: Po,
  page: Po,
  rudderClient: {},
});
var Qo, cu, Ii;
class ZO {
  constructor(t) {
    ae(this, 'rudderClient');
    Vt(this, Qo, null);
    Vt(this, cu, !1);
    Vt(this, Ii, {
      platform: 'browser-embedded',
      appVersion: fd,
      displayLanguage: qr.language,
      embeddedDappOrigin: '',
    });
    this.rudderClient = t;
  }
  identifyOnClientIfNeeded() {
    !oe(this, cu) &&
      oe(this, Qo) &&
      (this.rudderClient.identify(oe(this, Qo), oe(this, Ii)), Ft(this, cu, !0));
  }
  async capture(t, n) {
    (await this.getAnalyticsOptedOut()) ||
      (await this.identifyOnClientIfNeeded(),
      this.rudderClient.track(
        t,
        { ...GO(n) },
        { context: { referrer: uS(hY()), initialReferrer: null, traits: oe(this, Ii) } }
      ));
  }
  async getFeatureFlags() {
    return ms.getFeatureFlags();
  }
  async addUserProperties(t) {
    (await this.getAnalyticsOptedOut()) ||
      (Ft(this, Ii, { ...oe(this, Ii), ...t }),
      oe(this, Qo) && (await this.identify(oe(this, Qo), {})));
  }
  async identify(t, n = {}) {
    (await this.getAnalyticsOptedOut()) ||
      (Ft(this, Qo, t),
      Ft(this, Ii, { ...oe(this, Ii), ...n }),
      n != null &&
        n.embeddedDappOrigin &&
        ((n.embeddedDappOrigin = uS(n.embeddedDappOrigin)),
        (oe(this, Ii).embeddedDappOrigin = n.embeddedDappOrigin ?? '')),
      Ft(this, cu, !1));
  }
  getDeviceId() {
    return Promise.resolve(this.rudderClient.getAnonymousId() ?? '');
  }
  setDeviceId(t) {
    return this.rudderClient.setAnonymousId(t), Promise.resolve();
  }
  async setAnalyticsOptedOut(t) {
    return Promise.resolve();
  }
  setDisplayLanguage(t) {
    return (oe(this, Ii).displayLanguage = t), Promise.resolve();
  }
  screen(t, n) {}
  page(t, n, r, i) {
    this.rudderClient.page(t, n || 'unknown', r, i);
  }
  async getAnalyticsOptedOut() {
    return Promise.resolve(!1);
  }
}
(Qo = new WeakMap()), (cu = new WeakMap()), (Ii = new WeakMap());
const JO = 'cc94b84a-50e8-4aae-8296-ac417de90524';
let Jt = {};
const XO = () => {
    var n, r, i;
    const e = (r = (n = globalThis.chrome) == null ? void 0 : n.storage) == null ? void 0 : r.local,
      t = (i = globalThis.window) == null ? void 0 : i.localStorage;
    return e || t;
  },
  wY = async () => {
    if (typeof document > 'u') return !1;
    const e = document.createElement('div');
    (e.style.display = 'none'), document.body.appendChild(e);
    const t = getComputedStyle(e).getPropertyValue('--arc-palette-title');
    return document.body.removeChild(e), await XO().set({ isArcBrowser: !!t }), !!t;
  },
  QO = async () => {
    var e;
    return (e = await XO().get('isArcBrowser')) == null ? void 0 : e.isArcBrowser;
  },
  vY = async () => {
    var n;
    const e = await ((n = navigator.userAgentData) == null
      ? void 0
      : n.getHighEntropyValues(['platform', 'platformVersion', 'brands']));
    if (!e) return;
    Jt = { ...(await AY(e.brands)), platform: e.platform, platformVersion: e.platformVersion };
  },
  _Y = async (e) => {
    var t, n;
    if (e.includes('Chrome/'))
      e.includes('Edg/')
        ? ((Jt.name = 'Microsoft Edge'), (Jt.version = e.split('Edg/')[1].split(' ')[0]))
        : e.includes('OPR/')
          ? ((Jt.name = 'Opera'), (Jt.version = e.split('OPR/')[1].split(' ')[0]))
          : ((t = navigator.brave) != null && t.isBrave()
              ? (Jt.name = 'Brave')
              : (Jt.name = 'Chrome'),
            (Jt.version = e.split('Chrome/')[1].split(' ')[0]));
    else if (e.includes('Firefox/'))
      (Jt.name = 'Firefox'), (Jt.version = e.split('Firefox/')[1].split(' ')[0]);
    else if (e.includes('Safari/') && !e.includes('Chrome/'))
      (Jt.name = 'Safari'), (Jt.version = e.split('Version/')[1].split(' ')[0]);
    else {
      const r = /(?:Mozilla|Opera|AppleWebKit)\/[\d.]+\s+\(.*?\)\s+(?!Version)([^/]+)\/([^ ]+)/,
        i = e.match(r);
      i && ((Jt.name = i[1]), (Jt.version = i[2]));
    }
    (n = Jt.name) != null && n.match(/Chrome/) && (Jt.name = (await QO()) ? 'Arc' : 'Chrome');
  },
  SY = (e) => {
    const t = [
      { name: 'Windows', pattern: /Windows NT ([0-9._]+)/ },
      { name: 'Mac OS', pattern: /Mac OS X ([0-9._]+)/ },
      { name: 'Linux', pattern: /Linux/ },
      { name: 'Chrome OS', pattern: /CrOS/ },
    ];
    for (const n of t) {
      const r = e.match(n.pattern);
      r && ((Jt.platform = n.name), (Jt.platformVersion = r[1]));
    }
    Jt.platform || ((Jt.platform = 'Unknown'), (Jt.platformVersion = 'Unknown'));
  },
  EY = async () => {
    const e = navigator.userAgent;
    await _Y(e), SY(e);
  },
  AY = async (e) => {
    if (!e || !e.length) return;
    let t;
    for (const n of e)
      if (!(n.brand.includes('Not') || n.brand.includes('Chromium'))) {
        t = { name: n.brand, version: n.version };
        break;
      }
    if (!(t != null && t.name)) {
      const n = e.find((r) => r.brand === 'Chromium');
      n
        ? (t = { name: (await QO()) ? 'Arc' : 'Chromium', version: n.version })
        : (t = { name: e[0].brand, version: e[0].version });
    }
    return t;
  },
  IY = async () => {
    try {
      await wY();
    } catch {}
    await vY(), (Jt != null && Jt.name) || (await EY());
  };
var uu, ea;
const hb = class hb {
  constructor() {
    Vt(this, ea, new hL.EventEmitter());
  }
  static getInstance() {
    return oe(this, uu) || Ft(this, uu, new hb()), oe(this, uu);
  }
  async get(t) {
    try {
      const n = window.localStorage.getItem(t);
      if (n == null) return Promise.resolve(null);
      const r = JSON.parse(n);
      return Promise.resolve(r.expiry ? r.value : r);
    } catch (n) {
      const r = `[WindowLocalStorage.get] Error getting key (${t}): ${n}`;
      throw new Error(r);
    }
  }
  async getAll(t = []) {
    try {
      const n = t.reduce((r, i) => {
        const s = window.localStorage.getItem(i);
        return s == null ? (r[i] = null) : (r[i] = JSON.parse(s)), r;
      }, {});
      return Promise.resolve(n);
    } catch (n) {
      const r = `[WindowLocalStorage.getAll] Error getting key(s) (${t}): ${n}`;
      throw new Error(r);
    }
  }
  async remove(t) {
    try {
      let n;
      Array.isArray(t) ? (n = t) : (n = [t]);
      for (const r of n) window.localStorage.removeItem(r);
      return Promise.resolve();
    } catch (n) {
      const r = `[WindowLocalStorage.remove] Error removing key(s) (${t}): ${n}`;
      throw new Error(r);
    }
  }
  async set(t, n) {
    try {
      return (
        window.localStorage.setItem(t, JSON.stringify(n)),
        oe(this, ea).emit('storageChanged', t),
        Promise.resolve()
      );
    } catch (r) {
      const i = `[WindowLocalStorage.set] Error setting key (${t}): ${r}`;
      throw new Error(i);
    }
  }
  async setAll(t) {
    try {
      for (const [n, r] of Object.entries(t)) window.localStorage.setItem(n, JSON.stringify(r));
      for (const n of Object.keys(t)) oe(this, ea).emit('storageChanged', n);
      return Promise.resolve();
    } catch (n) {
      const i = `[WindowLocalStorage.setAll] Error setting keys (${Object.keys(t)}): ${n}`;
      throw new Error(i);
    }
  }
  async clear() {
    try {
      const t = [];
      for (const n in localStorage) t.push(n);
      window.localStorage.clear();
      for (const n of t) oe(this, ea).emit('storageChanged', n);
      return Promise.resolve();
    } catch (t) {
      const n = `[WindowLocalStorage.clear] Error clearing storage: ${t}`;
      throw new Error(n);
    }
  }
  subscribe(t) {
    const n = (r) => void t(r);
    return (
      oe(this, ea).addListener('storageChanged', n),
      () => {
        oe(this, ea).removeListener('storageChanged', n);
      }
    );
  }
  async update(t, n) {
    try {
      await navigator.locks.request(`storage.${t}`, async (r) => {
        const i = await this.get(t),
          s = await n(i);
        await this.set(t, s);
      });
    } catch (r) {
      const i = `[WindowLocalStorage.update] Error updating key (${t}): ${r}`;
      throw new Error(i);
    }
  }
};
(uu = new WeakMap()), (ea = new WeakMap()), Vt(hb, uu);
let nc = hb;
const Xn = nc.getInstance();
let e4 = 'http://localhost:5173',
  t4 = 'http://localhost:5173/callback',
  Yb = 'http://localhost:5174/callback',
  n4 = /^http:\/\/localhost:\d+$/,
  r4 = '890b519a-206c-4fab-8083-5dbc32ba8a95',
  Zb = 'df6ac779-1434-421a-888a-780656f070df';
(e4 = 'https://embedded-wallet.phantom.app'),
  (t4 = 'https://embedded-wallet.phantom.app/callback'),
  (Yb = 'https://embedded-wallet-signer.phantom.app/callback'),
  (n4 = /^https:\/\/(?:[a-zA-Z0-9-]+\.)?phantom\.app$/),
  (r4 = 'c1cb1aea-b7fc-4350-bab9-73c8589ba3e2'),
  (Zb = '0df9faea-67dd-4cd6-bb68-9a3c46c3d145');
const TY = 360,
  US = '.phantom.auth.login.codeVerifier',
  i4 = '.phantom.auth.login.dappURL',
  Ec = new vP({
    defaultOptions: {
      mutations: { retry: !1, networkMode: 'offlineFirst' },
      queries: {
        retry: !1,
        staleTime: 1 / 0,
        gcTime: 1 / 0,
        refetchOnWindowFocus: !1,
        networkMode: 'offlineFirst',
      },
    },
  }),
  xY = T9({ underlyingStorage: nc.getInstance(), throttleMs: 1e3, enableDebugLogs: Fj() }),
  kY = { shouldDehydrateQuery: () => !1 },
  CY = (e) =>
    P.jsx(x9, {
      client: Ec,
      persistOptions: { persister: xY, dehydrateOptions: kY, buster: PY, maxAge: 1 / 0 },
      children: e.children,
    }),
  PY = '25.2.0',
  MY = {
    getClientID: () => Zb,
    redirectURL: Yb,
    fetchAuthorizationCode: async (e, t, n) => {
      if (n === !0) throw new Error('interactive auth is not supported in signer iframe.');
      const i = (await fetch(t)).url;
      if (!Sz(e, i)) return _z(e, i);
    },
  },
  OY = {
    storage: Xn,
    authConfig: MY,
    queryClient: Ec,
    runExclusive: async (e) => window.navigator.locks.request('AUTH_LOCK', e),
    isServerTimeEnabled: () => !ms.isFeatureEnabled('kill-frontend-server-time'),
  },
  Ad = NM(OY),
  BY = ({ children: e }) => P.jsx(Ez, { authRepository: Ad, children: e }),
  DY = (e, t) => {
    const n = new zP();
    n.load(e, t, { configUrl: `${t}/sourceConfig` });
    try {
      return new ZO(n);
    } catch {
      return console.error('Failed to initialize rudderstack.'), YO();
    }
  },
  rc = qO({ storage: Xn, rudderStackKey: JO, createAnalytics: DY });
Ad.subscribe(Yo.UserID, (e) => {
  re.addBreadcrumb(ce.Generic, `Auth userID: ${e}`, Ie.Info),
    rc.addUserProperties({ authUserId: e });
});
const RY = new uP(null, {
  loadPath: (e) => {
    const t = e[0];
    return t.substring(0, 3) === 'fil'
      ? `/locales/${t.substring(0, 3)}/translation.json`
      : t.substring(0, 2) === 'zh'
        ? t === 'zh-CN' || t === 'zh-TW'
          ? `/locales/${t}/translation.json`
          : '/locales/zh-CN/translation.json'
        : `/locales/${t.substring(0, 2)}/translation.json`;
  },
  parse: (e) => JSON.parse(e),
});
qr.use(uP)
  .use(zj)
  .use(u9)
  .use(RY)
  .init({
    supportedLngs: qq(),
    fallbackLng: 'en',
    nonExplicitSupportedLngs: !0,
    debug: !1,
    returnNull: !1,
    detection: {
      order: [
        'querystring',
        'localStorage',
        'cookie',
        'sessionStorage',
        'navigator',
        'htmlTag',
        'path',
        'subdomain',
      ],
      caches: ['localStorage'],
    },
    react: { useSuspense: !1 },
    interpolation: { escapeValue: !1 },
  });
qr.on('initialized', () => {
  rc.setDisplayLanguage(qr.language);
});
const NY = '/currency_exchange/v1/rates',
  jY = async () => {
    const e = await Ge.api().get(`${NY}?from=USD&currencies=${Object.keys(gy).join(',')}`);
    if (!tr(e)) throw new Error('Failed to fetch exchange rates');
    return await e.data;
  },
  LY = we({ hours: 2 }),
  UY = (e) =>
    Qt({
      queryKey: Kj.currencyExchangeRates(),
      queryFn: jY,
      enabled: !!e,
      staleTime: LY,
      select(t) {
        return e ? (t == null ? void 0 : t.rates[e]) : 1;
      },
    });
g.enum(['ALWAYS_ASK', 'USE_PHANTOM', 'USE_METAMASK']);
function s4(e) {
  const t = Es(),
    n = Zq.preferredExplorers();
  return Qt({
    queryKey: n,
    queryFn: async () => {
      const i = await t.get(et.UserExplorerPreferenceV2);
      return i ? { version: i.version, explorers: { ...Px.explorers, ...i.explorers } } : Px;
    },
    select: e,
  });
}
g.boolean();
const hr = '@phantom/accounts',
  o4 = `${hr}:account-identifier`,
  a4 = `${hr}:selected-account`,
  $S = `${hr}:all-accounts`,
  c4 = `${hr}:all-seeds`,
  $Y = `${hr}:all-secrets`,
  Jb = {
    accountBalance(e) {
      return [`${hr}:account-balance`, { identifier: e }];
    },
    allAccountBalances() {
      return [`${hr}:all-account-balances`];
    },
    allAccounts(e) {
      const t = e
        ? {
            chainAvailability: {
              enabledChainIDs: e.enabledChainIDs,
              enabledAddressTypes: e.enabledAddressTypes,
            },
          }
        : {};
      return [$S, { chainAvailabilityQueryObject: t }];
    },
    allSeeds(e) {
      return [c4, e];
    },
    allSecretIdentifiers() {
      return [$Y];
    },
    developerMode() {
      return [`${hr}:developer-mode`];
    },
    accountIdentifier(e) {
      return [o4, { identifier: e }];
    },
    selectedAccount(e) {
      const t = e
        ? {
            chainAvailability: {
              enabledChainIDs: e.enabledChainIDs,
              enabledAddressTypes: e.enabledAddressTypes,
            },
          }
        : {};
      return [a4, t];
    },
    selectedAccountIdentifier() {
      return [`${hr}:selected-account-identifier`];
    },
    selectedNetworkSetting(e) {
      return [`${hr}:selected-network-setting`, { isSuiTestnetEnabled: e }];
    },
    trustedApps() {
      return [`${hr}:trusted-apps`];
    },
    migratedWithInvalidChecksum() {
      return [`${hr}:migrated-with-invalid-checksum`];
    },
    syncUserAccounts() {
      return [`${hr}:sync-user-accounts`];
    },
    accountsEligibleToClaim(e, t, n) {
      return [
        `${hr}:are-accounts-eligible-to-claim`,
        { username: e, selectedAccountIdentifier: t, solanaAddresses: n },
      ];
    },
    patchProfileAddresses(e) {
      return [`${hr}:patch-profile-addresses`, e];
    },
  },
  sI = () => {
    const e = Es(),
      {
        data: [t, n],
        isLoading: r,
      } = _P(['enable-monad', 'enable-arbitrum']);
    return Qt({
      enabled: !r,
      queryKey: k9.chainAvailability({ isMonadEnabled: t, isArbitrumEnabled: n }),
      queryFn: () => lA(e, t, n),
    });
  },
  u4 = W.createContext(null);
function FY({ children: e, vault: t }) {
  return P.jsx(u4.Provider, { value: t, children: e });
}
function zY() {
  const e = W.useContext(u4);
  if (!e) throw new Error('useVaultProxy must be used within a VaultProxyProvider');
  return e;
}
const l4 = de.getAllChainIDs().filter((e) => de.isChainDefaultEnabled(e, !1)),
  KY = l4.map((e) => de.getMainnetNetworkID(e));
KY.flatMap((e) => de.getAddressTypes(e));
const VY = () => {
    var e;
    return ((e = sI().data) == null ? void 0 : e.enabledChainIDs) ?? l4;
  },
  WY = () => VY().length === 1;
function oI(e) {
  const { isSuccess: t, data: n } = sI(),
    r = zY(),
    i = Jb.allAccounts(n),
    s = Es();
  return Qt({
    enabled: t,
    queryKey: i,
    queryFn: async () => {
      if (!n) throw new Error(eM);
      const a = await Xz(r, s, n);
      return (
        re.addBreadcrumb(
          ce.Account,
          `Finished fetching all accounts. Num accounts: ${a.length}`,
          Ie.Info
        ),
        a
      );
    },
    select: e,
  });
}
const HY = () => {
    const { isSuccess: e, isFetching: t, data: n = [] } = oI(),
      r = e && !t && !!n.length;
    return r ? { enabled: r, accounts: n } : { enabled: r };
  },
  GY = async (e) => {
    await e.invalidateQueries({ queryKey: [c4] }),
      await e.invalidateQueries({ queryKey: [$S], predicate: (t) => t.queryKey[0] === $S }),
      await e.invalidateQueries({ queryKey: [o4] }),
      await d4(e);
  },
  d4 = async (e) => {
    await e.invalidateQueries({
      predicate: (t) => typeof t.queryKey[0] == 'string' && t.queryKey[0] === a4,
    }),
      await e.invalidateQueries({ queryKey: Jb.selectedAccountIdentifier() });
  };
function f4() {
  const e = Es(),
    t = lo();
  return Fu({
    mutationFn: async ({ metadataBatch: s }) => {
      re.addBreadcrumb(
        ce.Account,
        `Adding Account Metadata Batch: ${Object.entries(s).length} entries`,
        Ie.Info
      ),
        await Hz(e, s);
    },
    onSuccess: async () => {
      await GY(t);
    },
    onError: (s) => {
      re.captureError(s, ce.Account);
    },
  });
}
const qY = (e) => {
  if (e) {
    switch (e.type) {
      case ee.Seed:
      case ee.Seedless:
        return e.seedIdentifier;
      case ee.PrivateKey:
      case ee.Ledger:
      case ee.SeedVault:
      case ee.ReadOnly:
        return;
    }
    qt();
  }
};
function Xb({ select: e, updateESPUserProperties: t } = {}) {
  const n = W.useMemo(() => ms.isFeatureEnabled('frontend-enable-esp-user-properties-update'), []),
    { isSuccess: r, data: i } = sI(),
    s = HY(),
    o = s.enabled && r,
    a = C9(),
    c = Es(),
    u = Hq(),
    l = Jb.selectedAccount(i);
  return Qt({
    queryKey: l,
    queryFn: async () => {
      try {
        if (!i) throw new Error(eM);
        if (!s.enabled) throw new Error(QP);
        const f = await UU(s.accounts, c);
        if (
          (re.addBreadcrumb(
            ce.Account,
            `Finished fetching selected account: ${f.identifier}`,
            Ie.Info
          ),
          n && t)
        ) {
          const h = f.addresses.map((p) => p.address) ?? [];
          Promise.all(h.map((p) => t(p, qr.language)));
        }
        return (
          ms.setSubjectAttributes({ rootID: qY(f) }), a(), u.identifyAccount(s.accounts, f, i), f
        );
      } catch (f) {
        throw (f instanceof Error && re.captureError(f, ce.Account), f);
      }
    },
    enabled: o,
    select: e,
  });
}
function h4() {
  const e = Es(),
    t = Un(),
    n = lo();
  return Fu({
    mutationFn: async ({ identifier: o }) => (
      await tM(e, o), t.capture('changeAccount', { data: { identifier: o } }), o
    ),
    onSuccess: (o) => {
      d4(n), n.setQueryData(Jb.selectedAccountIdentifier(), o);
    },
    onError: (o) => re.captureError(o, ce.Account),
  });
}
Kn.createContext(null);
const p4 = (e) => {
  const t = W.useMemo(() => {
    if (e) {
      if (YY(e)) return (r) => r.address === e.address && r.networkID === e.networkID;
      if (de.isNetworkID(e)) return (r) => r.networkID === e;
      if (P9(e)) return (r) => r.addressType === e;
      throw new Error(`Unrecognized filter type: ${e}`);
    } else return () => !1;
  }, [e]);
  return Xb({
    select: (r) => {
      const i = r.addresses.filter(t);
      if (i.length > 1) throw new Error(`Multiple addresses match filter: ${e}`);
      return i[0];
    },
  });
};
function YY(e) {
  return (
    typeof e == 'object' &&
    'address' in e &&
    (typeof e.address == 'string' || e.address === void 0) &&
    'networkID' in e
  );
}
function ZY(e) {
  let t;
  const n = new Set(),
    r = (u, l) => {
      const d = typeof u == 'function' ? u(t) : u;
      if (d !== t) {
        const f = t;
        (t = l ? d : Object.assign({}, t, d)), n.forEach((h) => h(t, f));
      }
    },
    i = () => t,
    s = (u, l = i, d = Object.is) => {
      console.warn('[DEPRECATED] Please use `subscribeWithSelector` middleware');
      let f = l(t);
      function h() {
        const p = l(t);
        if (!d(f, p)) {
          const b = f;
          u((f = p), b);
        }
      }
      return n.add(h), () => n.delete(h);
    },
    c = {
      setState: r,
      getState: i,
      subscribe: (u, l, d) => (l || d ? s(u, l, d) : (n.add(u), () => n.delete(u))),
      destroy: () => n.clear(),
    };
  return (t = e(r, i, c)), c;
}
const JY =
    typeof window > 'u' ||
    !window.navigator ||
    /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
  Ek = JY ? W.useEffect : W.useLayoutEffect;
function qu(e) {
  const t = typeof e == 'function' ? ZY(e) : e,
    n = (r = t.getState, i = Object.is) => {
      const [, s] = W.useReducer((w) => w + 1, 0),
        o = t.getState(),
        a = W.useRef(o),
        c = W.useRef(r),
        u = W.useRef(i),
        l = W.useRef(!1),
        d = W.useRef();
      d.current === void 0 && (d.current = r(o));
      let f,
        h = !1;
      (a.current !== o || c.current !== r || u.current !== i || l.current) &&
        ((f = r(o)), (h = !i(d.current, f))),
        Ek(() => {
          h && (d.current = f), (a.current = o), (c.current = r), (u.current = i), (l.current = !1);
        });
      const p = W.useRef(o);
      Ek(() => {
        const w = () => {
            try {
              const _ = t.getState(),
                x = c.current(_);
              u.current(d.current, x) || ((a.current = _), (d.current = x), s());
            } catch {
              (l.current = !0), s();
            }
          },
          A = t.subscribe(w);
        return t.getState() !== p.current && w(), A;
      }, []);
      const b = h ? f : d.current;
      return W.useDebugValue(b), b;
    };
  return (
    Object.assign(n, t),
    (n[Symbol.iterator] = function () {
      console.warn('[useStore, api] = create() is deprecated and will be removed in v4');
      const r = [n, t];
      return {
        next() {
          const i = r.length <= 0;
          return { value: r.shift(), done: i };
        },
      };
    }),
    n
  );
}
const XY = { editableAccountMetadata: void 0, setEditableAccountMetadata: () => {} };
qu((e) => ({
  ...XY,
  setEditableAccountMetadata: (t) => {
    e({ editableAccountMetadata: t });
  },
}));
const Ak = {
  username: '',
  available: null,
  icon: null,
  secretIdentifiers: [],
  accountIdentifiersToSync: [],
  addresses: {},
};
qu((e, t) => ({
  ...Ak,
  setUsername: (n) => e({ username: n }),
  setAvailable: (n) => e({ available: n }),
  setIcon: (n) => e({ icon: n }),
  addSecretIdentifier: (n) => {
    const r = [...t().secretIdentifiers];
    r.includes(n) || r.push(n), e({ secretIdentifiers: r });
  },
  removeSecretIdentifier: (n) => {
    e({ secretIdentifiers: t().secretIdentifiers.filter((r) => r !== n) });
  },
  addAccountIdentifierToSync: (n) => {
    const r = [...t().accountIdentifiersToSync];
    r.includes(n) || r.push(n), e({ accountIdentifiersToSync: r });
  },
  removeAccountIdentifierToSync: (n) => {
    e({ accountIdentifiersToSync: t().accountIdentifiersToSync.filter((r) => r !== n) });
  },
  clearAccountIdentifiersToSync: () => e({ accountIdentifiersToSync: [] }),
  setAccountIdentifiersToSync: (n) => e({ accountIdentifiersToSync: n }),
  addAddress: (n, r) => {
    const i = { ...t().addresses };
    (i[n] = r), e({ addresses: i });
  },
  removeAddress: (n, r) => {
    const i = { ...t().addresses };
    i[n] === r && delete i[n], e({ addresses: i });
  },
  clearAddresses: () => {
    e({ addresses: {} });
  },
  reset: () => {
    e(Ak);
  },
}));
G.BitcoinNativeSegwit, G.BitcoinTaproot, G.BitcoinNestedSegwit, G.BitcoinLegacy;
const QY = [
    'emojiSkinTone',
    'isAnalyticsOptedOut',
    'solanaActionsEnabled',
    'showWalletShortcuts',
    'selectedCurrency',
    'lockTimerMs',
    'reportedFeedTokens',
    'customGasControls',
    'dAppBrowserBookmarks',
    'RecentlyViewedSearchItems',
    'userRecentAddresses',
    'userSavedAddresses',
    'userTrustedApps',
    'userWhitelistedSubdomains',
    'userWhitelistedOrigins',
    'slippageTolerance',
    'priorityFee',
    'tipAmount',
    'lastSubmittedPairsV2',
    'lastSelectedTokens',
    'slippageSettings',
    'hasViewedAutoSlippageOptIn',
    'priorityFeeSettings',
    'tipSettings',
    'accountIdToHiddenMints',
    'accountIdToCollectibleVisibilitySettings',
  ],
  Jw = (e, t) => `/user/v1/users/${e}/wallet-storage${t ? `/${encodeURIComponent(t)}` : ''}`,
  eZ = async (e, t) => {
    e &&
      typeof e == 'object' &&
      !Array.isArray(e) &&
      e !== null &&
      (re.addBreadcrumb(
        ce.Storage,
        `⏳ Synced data found in cloud: ${JSON.stringify(e)}`,
        Ie.Debug
      ),
      await Promise.all(
        Object.entries(e).map(([n, r]) => {
          if (QY.includes(n) && r) return t.set(n, r);
          re.addBreadcrumb(ce.Storage, `☣️ Incompatible Synced data found: ${n}`, Ie.Debug);
        })
      )
        .then(() => {
          re.addBreadcrumb(ce.Storage, `✅ Synced data to disk: ${JSON.stringify(e)}`, Ie.Debug);
        })
        .catch((n) => {
          re.addBreadcrumb(
            ce.Storage,
            `❌ Failed to sync data to disk => Data: ${JSON.stringify(e)} => Error: ${n}`,
            Ie.Debug
          );
        }));
  };
var lu, ta, Ti, sr;
const pb = class pb {
  constructor(t) {
    Vt(this, ta, !1);
    Vt(this, Ti);
    Vt(this, sr, null);
    Ft(this, Ti, t);
  }
  static getInstance(t) {
    return oe(this, lu) || Ft(this, lu, new pb(t)), oe(this, lu);
  }
  initialize({ user: t, processor: n }) {
    (oe(this, ta) && oe(this, sr) && oe(this, sr).userID === t.userID) ||
      (Ft(this, sr, t), Ft(this, ta, !0), this.syncFromCloud({ processor: n }));
  }
  setUser(t) {
    Ft(this, sr, t);
  }
  async syncFromCloud({ key: t, processor: n = eZ }) {
    if (!(!oe(this, ta) || !oe(this, sr)))
      try {
        const r = Jw(oe(this, sr).userID, t),
          i = await Ge.api().bearer(oe(this, sr).accessToken).get(r);
        tr(i)
          ? await n(i.data, oe(this, Ti))
          : re.addBreadcrumb(
              ce.Storage,
              `❌ Failed to sync from cloud: ${JSON.stringify(i)}`,
              Ie.Debug
            );
      } catch (r) {
        re.addBreadcrumb(
          ce.Storage,
          `❌ Failed to sync from cloud: ${JSON.stringify(r)}`,
          Ie.Debug
        );
      }
  }
  async syncToCloud(t, n) {
    if (!(!oe(this, ta) || !oe(this, sr)))
      try {
        const r = Jw(oe(this, sr).userID, t),
          i = await Ge.api().bearer(oe(this, sr).accessToken).put(r, { value: n });
        tr(i)
          ? re.addBreadcrumb(
              ce.Storage,
              `✅ Synced to cloud: ${t} => ${JSON.stringify(n)}`,
              Ie.Debug
            )
          : re.addBreadcrumb(
              ce.Storage,
              `❌ Failed to sync to cloud: ${t} => ${JSON.stringify(n)} => Error: ${JSON.stringify(i)}`,
              Ie.Debug
            );
      } catch (r) {
        re.addBreadcrumb(ce.Storage, `❌ Failed to sync to cloud: ${JSON.stringify(r)}`, Ie.Debug);
      }
  }
  async get(t, n) {
    return await this.syncFromCloud({ key: t, processor: n }), oe(this, Ti).get(t);
  }
  async getAll(t, n) {
    return await this.syncFromCloud({ processor: n }), oe(this, Ti).getAll(t);
  }
  async remove(t) {
    if (Array.isArray(t))
      throw new Error(
        `[SyncedStorage.remove] Error removing keys (${t}): Batch removal not implemented`
      );
    if ((await oe(this, Ti).remove(t), !(!oe(this, ta) || !oe(this, sr))))
      try {
        const n = Jw(oe(this, sr).userID, t);
        await Ge.api().bearer(oe(this, sr).accessToken).delete(n);
      } catch (n) {
        re.addBreadcrumb(
          ce.Storage,
          `❌ Failed to remove from cloud: ${JSON.stringify(n)}`,
          Ie.Debug
        );
      }
  }
  async set(t, n) {
    await oe(this, Ti).set(t, n), await this.syncToCloud(t, n);
  }
  async setAll(t) {
    throw new Error(
      `[SyncedStorage.setAll] Error setting keys(s) (${Object.keys(t)}): Method not implemented`
    );
  }
  subscribe(t) {
    return oe(this, Ti).subscribe(t);
  }
  async update(t, n) {
    await oe(this, Ti).update(t, n);
    const r = await this.get(t);
    await this.syncToCloud(t, r);
  }
};
(lu = new WeakMap()), (ta = new WeakMap()), (Ti = new WeakMap()), (sr = new WeakMap()), Vt(pb, lu);
let FS = pb;
const tZ = M9(null);
function nZ() {
  const e = yx(tZ),
    t = yx(SP);
  if (!t)
    throw new Error(
      'useSyncedStorage must be used within a ContextProvider with StorageContext set'
    );
  return e || t;
}
const Ik = new WeakMap(),
  rZ = () => {
    const e = B9(),
      t = nZ();
    if (t instanceof FS) {
      let n = Ik.get(t);
      return n === void 0 && ((n = new D9(t)), Ik.set(t, n)), n;
    }
    return e;
  },
  iZ = O9((e) => rZ().get(e)),
  sZ = gy.USD.value,
  oZ = () => {
    const { value: e, ...t } = iZ(vA.SelectedCurrency),
      n = e ?? sZ;
    return { ...t, result: n, data: n };
  },
  g4 = W.createContext(null),
  aZ = ({ children: e }) => {
    const { data: t } = oZ(),
      { data: n, isLoading: r } = UY(t),
      i = t && n ? gy[t].languageCode : ww.languageCode,
      s = t || ww.value,
      o = t && n ? gy[t].symbol : ww.symbol,
      a = W.useCallback(
        (d, f) => Intl.NumberFormat(i, { style: 'currency', currency: s, ...f }).format(d),
        [s, i]
      ),
      c = W.useCallback((d) => (!t || !n ? Number(d) : fe(d).div(fe(n)).toNumber()), [t, n]),
      u = W.useCallback(
        (d, f) => {
          if (!t || !n) return Number(d);
          const h = fe(d).times(fe(n));
          return f === void 0 ? h.toNumber() : h.decimalPlaces(f).toNumber();
        },
        [t, n]
      ),
      l = {
        isLoading: r,
        currencyLocale: i,
        currencySymbol: o,
        currencyCode: s,
        toUsd: c,
        fromUsd: u,
        formatLocalizedPrice: a,
      };
    return P.jsx(g4.Provider, { value: l, children: e });
  },
  y4 = () => {
    const e = W.useContext(g4);
    if (!e) throw new Error('useLocalizedCurrency must be used within a LocalizedCurrencyProvider');
    return e;
  },
  cZ = nc.getInstance();
var gr = ((e) => (
  (e.NAN = 'NAN'),
  (e.DATE = 'DATE'),
  (e.UINT8ARRAY = 'UINT8ARRAY'),
  (e.BIGINT = 'BIGINT'),
  (e.URL = 'URL'),
  e
))(gr || {});
const uZ = {
    canSerialize: (e) => typeof e == 'number' && Number.isNaN(e),
    serialize: (e) => ({ ['$' + gr.NAN]: 1 }),
    deserialize: (e) => NaN,
  },
  lZ = {
    canSerialize: (e) => e instanceof Date,
    serialize: (e) => ({ [`$${gr.DATE}`]: e.valueOf() }),
    deserialize: (e) => new Date(e[`$${gr.DATE}`]),
  },
  dZ = {
    canSerialize: (e) => e instanceof Uint8Array,
    serialize: (e) => ({ [`$${gr.UINT8ARRAY}`]: Array.from(e) }),
    deserialize: (e) => Uint8Array.from(e[`$${gr.UINT8ARRAY}`]),
  },
  fZ = {
    canSerialize: (e) => typeof e == 'bigint',
    serialize: (e) => ({ [`$${gr.BIGINT}`]: e.toString() }),
    deserialize: (e) => BigInt(e[`$${gr.BIGINT}`]),
  },
  hZ = {
    canSerialize: (e) => e instanceof URL,
    serialize: (e) => ({ [`$${gr.URL}`]: e.href }),
    deserialize: (e) => new URL(e[`$${gr.URL}`]),
  },
  zS = { [gr.NAN]: uZ, [gr.DATE]: lZ, [gr.UINT8ARRAY]: dZ, [gr.BIGINT]: fZ, [gr.URL]: hZ },
  pZ = function (e) {
    const t = this[e];
    for (const n of Object.values(zS)) if (n.canSerialize(t)) return n.serialize(t);
    return t;
  },
  gZ = (e, t) => {
    if (t && typeof t == 'object' && Object.keys(t)[0]) {
      const n = Object.keys(t)[0].slice(1);
      if (n in zS) return zS[n].deserialize(t);
    }
    return t;
  },
  yZ = (e) => JSON.stringify(e, pZ),
  bZ = (e) => JSON.parse(e, gZ);
var ld, dd, Va, Wa, du;
class mZ {
  constructor(t, n, r) {
    Vt(this, ld);
    Vt(this, dd);
    Vt(this, Va, []);
    Vt(this, Wa, []);
    Vt(this, du);
    Ft(this, ld, t), Ft(this, dd, n);
    const i = r ?? new RegExp(`^${n}$`);
    Ft(this, du, (s) => {
      if (i.test(s.origin))
        try {
          const o = bZ(s.data);
          'jsonrpc' in o && o.jsonrpc === '2.0' && oe(this, Va).forEach((a) => a(o));
        } catch {}
    });
  }
  async start() {
    return window.addEventListener('message', oe(this, du)), Promise.resolve();
  }
  async close() {
    return (
      window.removeEventListener('message', oe(this, du)),
      oe(this, Wa).forEach((t) => t()),
      Promise.resolve()
    );
  }
  postMessage(t) {
    oe(this, ld).call(this).postMessage(yZ(t), oe(this, dd));
  }
  onMessage(t) {
    return (
      oe(this, Va).push(t),
      () => {
        Ft(
          this,
          Va,
          oe(this, Va).filter((n) => n !== t)
        );
      }
    );
  }
  onClose(t) {
    return (
      oe(this, Wa).push(t),
      () => {
        Ft(
          this,
          Wa,
          oe(this, Wa).filter((n) => n !== t)
        );
      }
    );
  }
}
(ld = new WeakMap()),
  (dd = new WeakMap()),
  (Va = new WeakMap()),
  (Wa = new WeakMap()),
  (du = new WeakMap());
function wZ() {
  let e, t;
  return {
    promise: new Promise((r, i) => {
      (e = r), (t = i);
    }),
    resolve: e,
    reject: t,
  };
}
W.createContext(null);
W.createContext(null);
var ci = ((e) => (
  (e.authorizeSigner = 'authorizeSigner'),
  (e.fetchAllAccounts = 'fetchAllAccounts'),
  (e.checkVaultIntegrity = 'checkVaultIntegrity'),
  (e.sign = 'sign'),
  (e.logOut = 'logOut'),
  (e.recoverAccount = 'recoverAccount'),
  (e.userApprove = 'userApprove'),
  (e.abort = 'abort'),
  e
))(ci || {});
g.nativeEnum(ci);
const vZ = ['recoverAccount', 'userApprove'];
var fr, fu, gb, Ws;
class _Z {
  constructor(t, n, r, i) {
    Vt(this, fr);
    Vt(this, fu);
    Vt(this, gb, (t) => {
      if (t.method === 'abort') {
        this.currentMessage &&
          ((this.currentMessage = null),
          (this.currentResponse = null),
          oe(this, Ws).forEach((n) => n()));
        return;
      }
      if (vZ.includes(t.method)) {
        if (this.currentMessage) {
          this.currentMessage.id !== t.id &&
            oe(this, fr).postMessage({
              jsonrpc: '2.0',
              id: t.id,
              error: { code: -32e3, message: 'Another request is already in progress' },
            });
          return;
        }
        (this.currentMessage = t),
          (this.currentResponse = wZ()),
          oe(this, Ws).forEach((n) => n()),
          this.currentResponse.promise.then((n) => {
            (this.currentMessage = null),
              (this.currentResponse = null),
              oe(this, Ws).forEach((r) => r()),
              oe(this, fr).postMessage(n);
          });
      } else
        t.method === 'authorizeSigner'
          ? oe(this, fu)
              .call(this, t)
              .then((n) => {
                if ('result' in n) {
                  if (n.result === 'authorization-started') return;
                  if (n.result === 'authorized') {
                    oe(this, fr).postMessage({ jsonrpc: '2.0', id: null, result: 'authorized' });
                    return;
                  }
                }
                oe(this, fr).postMessage({ jsonrpc: '2.0', id: t.id, ...n });
              })
          : oe(this, fu)
              .call(this, t)
              .then((n) => {
                oe(this, fr).postMessage({ jsonrpc: '2.0', id: t.id, ...n });
              });
    });
    Vt(this, Ws, []);
    ae(this, 'currentMessage', null);
    ae(this, 'currentResponse', null);
    ae(
      this,
      'subscribe',
      (t) => (
        oe(this, Ws).push(t),
        () => {
          Ft(
            this,
            Ws,
            oe(this, Ws).filter((n) => n !== t)
          );
        }
      )
    );
    Ft(this, fr, new mZ(t, r, i)), Ft(this, fu, n), oe(this, fr).onMessage(oe(this, gb));
  }
  async start() {
    await oe(this, fr).start(),
      await oe(this, fr).postMessage({ jsonrpc: '2.0', id: null, result: 'ready' });
  }
  async authorizeSuccess() {
    await oe(this, fr).postMessage({ jsonrpc: '2.0', id: null, result: 'authorized' });
  }
  async authorizeFailed() {
    await oe(this, fr).postMessage({ jsonrpc: '2.0', id: null, result: 'authorization-failed' });
  }
  async close() {
    await oe(this, fr).close();
  }
}
(fr = new WeakMap()), (fu = new WeakMap()), (gb = new WeakMap()), (Ws = new WeakMap());
const b4 = W.createContext(null),
  m4 = () => {
    const e = W.useContext(b4);
    if (!e) throw new Error('JsonRpcSender not provided');
    return e;
  },
  SZ = (e) => P.jsx(b4.Provider, { value: e.receiver, children: e.children }),
  EZ = () => {
    const e = m4();
    return W.useSyncExternalStore(e.subscribe, () => e.currentMessage);
  },
  w4 = () => {
    const e = m4();
    return W.useCallback(
      (t) => {
        if (!e.currentResponse || !e.currentMessage) throw new Error('No current response');
        const n = e.currentMessage.id;
        e.currentResponse.resolve({ jsonrpc: '2.0', id: n, ...t });
      },
      [e]
    );
  };
let AZ = { data: '' },
  IZ = (e) =>
    typeof window == 'object'
      ? (
          (e ? e.querySelector('#_goober') : window._goober) ||
          Object.assign((e || document.head).appendChild(document.createElement('style')), {
            innerHTML: ' ',
            id: '_goober',
          })
        ).firstChild
      : e || AZ,
  TZ = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g,
  xZ = /\/\*[^]*?\*\/|  +/g,
  Tk = /\n+/g,
  Jo = (e, t) => {
    let n = '',
      r = '',
      i = '';
    for (let s in e) {
      let o = e[s];
      s[0] == '@'
        ? s[1] == 'i'
          ? (n = s + ' ' + o + ';')
          : (r += s[1] == 'f' ? Jo(o, s) : s + '{' + Jo(o, s[1] == 'k' ? '' : t) + '}')
        : typeof o == 'object'
          ? (r += Jo(
              o,
              t
                ? t.replace(/([^,])+/g, (a) =>
                    s.replace(/(^:.*)|([^,])+/g, (c) =>
                      /&/.test(c) ? c.replace(/&/g, a) : a ? a + ' ' + c : c
                    )
                  )
                : s
            ))
          : o != null &&
            ((s = /^--/.test(s) ? s : s.replace(/[A-Z]/g, '-$&').toLowerCase()),
            (i += Jo.p ? Jo.p(s, o) : s + ':' + o + ';'));
    }
    return n + (t && i ? t + '{' + i + '}' : i) + r;
  },
  Bs = {},
  v4 = (e) => {
    if (typeof e == 'object') {
      let t = '';
      for (let n in e) t += n + v4(e[n]);
      return t;
    }
    return e;
  },
  kZ = (e, t, n, r, i) => {
    let s = v4(e),
      o =
        Bs[s] ||
        (Bs[s] = ((c) => {
          let u = 0,
            l = 11;
          for (; u < c.length; ) l = (101 * l + c.charCodeAt(u++)) >>> 0;
          return 'go' + l;
        })(s));
    if (!Bs[o]) {
      let c =
        s !== e
          ? e
          : ((u) => {
              let l,
                d,
                f = [{}];
              for (; (l = TZ.exec(u.replace(xZ, ''))); )
                l[4]
                  ? f.shift()
                  : l[3]
                    ? ((d = l[3].replace(Tk, ' ').trim()), f.unshift((f[0][d] = f[0][d] || {})))
                    : (f[0][l[1]] = l[2].replace(Tk, ' ').trim());
              return f[0];
            })(e);
      Bs[o] = Jo(i ? { ['@keyframes ' + o]: c } : c, n ? '' : '.' + o);
    }
    let a = n && Bs.g ? Bs.g : null;
    return (
      n && (Bs.g = Bs[o]),
      ((c, u, l, d) => {
        d
          ? (u.data = u.data.replace(d, c))
          : u.data.indexOf(c) === -1 && (u.data = l ? c + u.data : u.data + c);
      })(Bs[o], t, r, a),
      o
    );
  },
  CZ = (e, t, n) =>
    e.reduce((r, i, s) => {
      let o = t[s];
      if (o && o.call) {
        let a = o(n),
          c = (a && a.props && a.props.className) || (/^go/.test(a) && a);
        o = c
          ? '.' + c
          : a && typeof a == 'object'
            ? a.props
              ? ''
              : Jo(a, '')
            : a === !1
              ? ''
              : a;
      }
      return r + i + (o ?? '');
    }, '');
function Id(e) {
  let t = this || {},
    n = e.call ? e(t.p) : e;
  return kZ(
    n.unshift
      ? n.raw
        ? CZ(n, [].slice.call(arguments, 1), t.p)
        : n.reduce((r, i) => Object.assign(r, i && i.call ? i(t.p) : i), {})
      : n,
    IZ(t.target),
    t.g,
    t.o,
    t.k
  );
}
let _4, KS, VS;
Id.bind({ g: 1 });
let Rn = Id.bind({ k: 1 });
function S4(e, t, n, r) {
  (Jo.p = t), (_4 = e), (KS = n), (VS = r);
}
function lr(e, t) {
  let n = this || {};
  return function () {
    let r = arguments;
    function i(s, o) {
      let a = Object.assign({}, s),
        c = a.className || i.className;
      (n.p = Object.assign({ theme: KS && KS() }, a)),
        (n.o = / *go\d+/.test(c)),
        (a.className = Id.apply(n, r) + (c ? ' ' + c : '')),
        t && (a.ref = o);
      let u = e;
      return e[0] && ((u = a.as || e), delete a.as), VS && u[0] && VS(a), _4(u, a);
    }
    return t ? t(i) : i;
  };
}
var PZ = (e) => typeof e == 'function',
  td = (e, t) => (PZ(e) ? e(t) : e),
  MZ = (() => {
    let e = 0;
    return () => (++e).toString();
  })(),
  E4 = (() => {
    let e;
    return () => {
      if (e === void 0 && typeof window < 'u') {
        let t = matchMedia('(prefers-reduced-motion: reduce)');
        e = !t || t.matches;
      }
      return e;
    };
  })(),
  OZ = 20,
  ey = new Map(),
  BZ = 1e3,
  xk = (e) => {
    if (ey.has(e)) return;
    let t = setTimeout(() => {
      ey.delete(e), Ac({ type: 4, toastId: e });
    }, BZ);
    ey.set(e, t);
  },
  DZ = (e) => {
    let t = ey.get(e);
    t && clearTimeout(t);
  },
  WS = (e, t) => {
    switch (t.type) {
      case 0:
        return { ...e, toasts: [t.toast, ...e.toasts].slice(0, OZ) };
      case 1:
        return (
          t.toast.id && DZ(t.toast.id),
          { ...e, toasts: e.toasts.map((s) => (s.id === t.toast.id ? { ...s, ...t.toast } : s)) }
        );
      case 2:
        let { toast: n } = t;
        return e.toasts.find((s) => s.id === n.id)
          ? WS(e, { type: 1, toast: n })
          : WS(e, { type: 0, toast: n });
      case 3:
        let { toastId: r } = t;
        return (
          r
            ? xk(r)
            : e.toasts.forEach((s) => {
                xk(s.id);
              }),
          {
            ...e,
            toasts: e.toasts.map((s) => (s.id === r || r === void 0 ? { ...s, visible: !1 } : s)),
          }
        );
      case 4:
        return t.toastId === void 0
          ? { ...e, toasts: [] }
          : { ...e, toasts: e.toasts.filter((s) => s.id !== t.toastId) };
      case 5:
        return { ...e, pausedAt: t.time };
      case 6:
        let i = t.time - (e.pausedAt || 0);
        return {
          ...e,
          pausedAt: void 0,
          toasts: e.toasts.map((s) => ({ ...s, pauseDuration: s.pauseDuration + i })),
        };
    }
  },
  ty = [],
  ny = { toasts: [], pausedAt: void 0 },
  Ac = (e) => {
    (ny = WS(ny, e)),
      ty.forEach((t) => {
        t(ny);
      });
  },
  RZ = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 },
  NZ = (e = {}) => {
    let [t, n] = W.useState(ny);
    W.useEffect(
      () => (
        ty.push(n),
        () => {
          let i = ty.indexOf(n);
          i > -1 && ty.splice(i, 1);
        }
      ),
      [t]
    );
    let r = t.toasts.map((i) => {
      var s, o;
      return {
        ...e,
        ...e[i.type],
        ...i,
        duration:
          i.duration ||
          ((s = e[i.type]) == null ? void 0 : s.duration) ||
          (e == null ? void 0 : e.duration) ||
          RZ[i.type],
        style: { ...e.style, ...((o = e[i.type]) == null ? void 0 : o.style), ...i.style },
      };
    });
    return { ...t, toasts: r };
  },
  jZ = (e, t = 'blank', n) => ({
    createdAt: Date.now(),
    visible: !0,
    type: t,
    ariaProps: { role: 'status', 'aria-live': 'polite' },
    message: e,
    pauseDuration: 0,
    ...n,
    id: (n == null ? void 0 : n.id) || MZ(),
  }),
  Td = (e) => (t, n) => {
    let r = jZ(t, e, n);
    return Ac({ type: 2, toast: r }), r.id;
  },
  Hr = (e, t) => Td('blank')(e, t);
Hr.error = Td('error');
Hr.success = Td('success');
Hr.loading = Td('loading');
Hr.custom = Td('custom');
Hr.dismiss = (e) => {
  Ac({ type: 3, toastId: e });
};
Hr.remove = (e) => Ac({ type: 4, toastId: e });
Hr.promise = (e, t, n) => {
  let r = Hr.loading(t.loading, { ...n, ...(n == null ? void 0 : n.loading) });
  return (
    e
      .then(
        (i) => (
          Hr.success(td(t.success, i), { id: r, ...n, ...(n == null ? void 0 : n.success) }), i
        )
      )
      .catch((i) => {
        Hr.error(td(t.error, i), { id: r, ...n, ...(n == null ? void 0 : n.error) });
      }),
    e
  );
};
var LZ = (e, t) => {
    Ac({ type: 1, toast: { id: e, height: t } });
  },
  UZ = () => {
    Ac({ type: 5, time: Date.now() });
  },
  $Z = (e) => {
    let { toasts: t, pausedAt: n } = NZ(e);
    W.useEffect(() => {
      if (n) return;
      let s = Date.now(),
        o = t.map((a) => {
          if (a.duration === 1 / 0) return;
          let c = (a.duration || 0) + a.pauseDuration - (s - a.createdAt);
          if (c < 0) {
            a.visible && Hr.dismiss(a.id);
            return;
          }
          return setTimeout(() => Hr.dismiss(a.id), c);
        });
      return () => {
        o.forEach((a) => a && clearTimeout(a));
      };
    }, [t, n]);
    let r = W.useCallback(() => {
        n && Ac({ type: 6, time: Date.now() });
      }, [n]),
      i = W.useCallback(
        (s, o) => {
          let { reverseOrder: a = !1, gutter: c = 8, defaultPosition: u } = o || {},
            l = t.filter((h) => (h.position || u) === (s.position || u) && h.height),
            d = l.findIndex((h) => h.id === s.id),
            f = l.filter((h, p) => p < d && h.visible).length;
          return l
            .filter((h) => h.visible)
            .slice(...(a ? [f + 1] : [0, f]))
            .reduce((h, p) => h + (p.height || 0) + c, 0);
        },
        [t]
      );
    return {
      toasts: t,
      handlers: { updateHeight: LZ, startPause: UZ, endPause: r, calculateOffset: i },
    };
  },
  FZ = Rn`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`,
  zZ = Rn`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`,
  KZ = Rn`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`,
  VZ = lr('div')`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || '#ff4b4b'};
  position: relative;
  transform: rotate(45deg);

  animation: ${FZ} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${zZ} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || '#fff'};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${KZ} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`,
  WZ = Rn`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`,
  HZ = lr('div')`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || '#e0e0e0'};
  border-right-color: ${(e) => e.primary || '#616161'};
  animation: ${WZ} 1s linear infinite;
`,
  GZ = Rn`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`,
  qZ = Rn`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`,
  YZ = lr('div')`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || '#61d345'};
  position: relative;
  transform: rotate(45deg);

  animation: ${GZ} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${qZ} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || '#fff'};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`,
  ZZ = lr('div')`
  position: absolute;
`,
  JZ = lr('div')`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`,
  XZ = Rn`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`,
  QZ = lr('div')`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${XZ} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`,
  eJ = ({ toast: e }) => {
    let { icon: t, type: n, iconTheme: r } = e;
    return t !== void 0
      ? typeof t == 'string'
        ? W.createElement(QZ, null, t)
        : t
      : n === 'blank'
        ? null
        : W.createElement(
            JZ,
            null,
            W.createElement(HZ, { ...r }),
            n !== 'loading' &&
              W.createElement(
                ZZ,
                null,
                n === 'error' ? W.createElement(VZ, { ...r }) : W.createElement(YZ, { ...r })
              )
          );
  },
  tJ = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`,
  nJ = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`,
  rJ = '0%{opacity:0;} 100%{opacity:1;}',
  iJ = '0%{opacity:1;} 100%{opacity:0;}',
  sJ = lr('div')`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`,
  oJ = lr('div')`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`,
  aJ = (e, t) => {
    let n = e.includes('top') ? 1 : -1,
      [r, i] = E4() ? [rJ, iJ] : [tJ(n), nJ(n)];
    return {
      animation: t
        ? `${Rn(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards`
        : `${Rn(i)} 0.4s forwards cubic-bezier(.06,.71,.55,1)`,
    };
  },
  cJ = W.memo(({ toast: e, position: t, style: n, children: r }) => {
    let i = e.height ? aJ(e.position || t || 'top-center', e.visible) : { opacity: 0 },
      s = W.createElement(eJ, { toast: e }),
      o = W.createElement(oJ, { ...e.ariaProps }, td(e.message, e));
    return W.createElement(
      sJ,
      { className: e.className, style: { ...i, ...n, ...e.style } },
      typeof r == 'function' ? r({ icon: s, message: o }) : W.createElement(W.Fragment, null, s, o)
    );
  });
S4(W.createElement);
var uJ = ({ id: e, className: t, style: n, onHeightUpdate: r, children: i }) => {
    let s = W.useCallback(
      (o) => {
        if (o) {
          let a = () => {
            let c = o.getBoundingClientRect().height;
            r(e, c);
          };
          a(),
            new MutationObserver(a).observe(o, { subtree: !0, childList: !0, characterData: !0 });
        }
      },
      [e, r]
    );
    return W.createElement('div', { ref: s, className: t, style: n }, i);
  },
  lJ = (e, t) => {
    let n = e.includes('top'),
      r = n ? { top: 0 } : { bottom: 0 },
      i = e.includes('center')
        ? { justifyContent: 'center' }
        : e.includes('right')
          ? { justifyContent: 'flex-end' }
          : {};
    return {
      left: 0,
      right: 0,
      display: 'flex',
      position: 'absolute',
      transition: E4() ? void 0 : 'all 230ms cubic-bezier(.21,1.02,.73,1)',
      transform: `translateY(${t * (n ? 1 : -1)}px)`,
      ...r,
      ...i,
    };
  },
  dJ = Id`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`,
  Jp = 16,
  fJ = ({
    reverseOrder: e,
    position: t = 'top-center',
    toastOptions: n,
    gutter: r,
    children: i,
    containerStyle: s,
    containerClassName: o,
  }) => {
    let { toasts: a, handlers: c } = $Z(n);
    return W.createElement(
      'div',
      {
        style: {
          position: 'fixed',
          zIndex: 9999,
          top: Jp,
          left: Jp,
          right: Jp,
          bottom: Jp,
          pointerEvents: 'none',
          ...s,
        },
        className: o,
        onMouseEnter: c.startPause,
        onMouseLeave: c.endPause,
      },
      a.map((u) => {
        let l = u.position || t,
          d = c.calculateOffset(u, { reverseOrder: e, gutter: r, defaultPosition: t }),
          f = lJ(l, d);
        return W.createElement(
          uJ,
          {
            id: u.id,
            key: u.id,
            onHeightUpdate: c.updateHeight,
            className: u.visible ? dJ : '',
            style: f,
          },
          u.type === 'custom'
            ? td(u.message, u)
            : i
              ? i(u)
              : W.createElement(cJ, { toast: u, position: l })
        );
      })
    );
  },
  hJ = Hr;
const pJ = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.8); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`,
  gJ = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -20}%,-1px) scale(.8); opacity:0;}
`,
  yJ = '0%{opacity:0;} 100%{opacity:1;}',
  bJ = '0%{opacity:1;} 100%{opacity:0;}',
  mJ = (() => {
    let e;
    return () => {
      if (e === void 0 && typeof window < 'u') {
        const t = matchMedia('(prefers-reduced-motion: reduce)');
        e = !t || t.matches;
      }
      return e;
    };
  })(),
  wJ = (e, t) => {
    const [r, i] = mJ() ? [yJ, bJ] : [pJ(-1), gJ(-1)];
    return {
      animation: t
        ? `${Rn(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards`
        : `${Rn(i)} 0.25s forwards cubic-bezier(.06,.71,.55,1)`,
    };
  },
  vJ = yr({ width: '100%' }),
  _J = Kn.memo(() =>
    P.jsx(fJ, {
      containerStyle: { bottom: Le.paddingScreen },
      toastOptions: { position: 'bottom-center', duration: 3e3 },
      children: (e) => {
        const t = e.height ? wJ(e.position || 'bottom-center', e.visible) : { opacity: 0 };
        return P.jsx('div', {
          className: vJ,
          style: { ...t, maxWidth: TY },
          children: P.jsx(Vj, {
            children: String(td(e.message, e)),
            type: e.type === 'success' || e.type === 'error' ? e.type : 'success',
            onClose: () => hJ.dismiss(e.id),
          }),
        });
      },
    })
  ),
  SJ = g.tuple([g.string()]),
  EJ = g.tuple([g.object({ accountIdentifier: g.string(), vaultSignerParams: $K })]),
  AJ = g.discriminatedUnion('method', [
    g.object({ method: g.literal('authorizeSigner') }),
    g.object({ method: g.literal('fetchAllAccounts') }),
    g.object({ method: g.literal('checkVaultIntegrity') }),
    g.object({ method: g.literal('sign') }),
    g.object({ method: g.literal('recoverAccount') }),
    g.object({ method: g.literal('userApprove'), params: g.any() }),
    g.object({ method: g.literal('cancel') }),
  ]);
var IJ = '_148454u0',
  kk = { exports: {} };
(function (e, t) {
  var n = typeof globalThis < 'u' ? globalThis : m,
    r = (function () {
      function s() {
        (this.fetch = !1), (this.DOMException = n.DOMException);
      }
      return (s.prototype = n), new s();
    })();
  (function (s) {
    (function (o) {
      var a = {
        searchParams: 'URLSearchParams' in s,
        iterable: 'Symbol' in s && 'iterator' in Symbol,
        blob:
          'FileReader' in s &&
          'Blob' in s &&
          (function () {
            try {
              return new Blob(), !0;
            } catch {
              return !1;
            }
          })(),
        formData: 'FormData' in s,
        arrayBuffer: 'ArrayBuffer' in s,
      };
      function c(S) {
        return S && DataView.prototype.isPrototypeOf(S);
      }
      if (a.arrayBuffer)
        var u = [
            '[object Int8Array]',
            '[object Uint8Array]',
            '[object Uint8ClampedArray]',
            '[object Int16Array]',
            '[object Uint16Array]',
            '[object Int32Array]',
            '[object Uint32Array]',
            '[object Float32Array]',
            '[object Float64Array]',
          ],
          l =
            ArrayBuffer.isView ||
            function (S) {
              return S && u.indexOf(Object.prototype.toString.call(S)) > -1;
            };
      function d(S) {
        if ((typeof S != 'string' && (S = String(S)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(S)))
          throw new TypeError('Invalid character in header field name');
        return S.toLowerCase();
      }
      function f(S) {
        return typeof S != 'string' && (S = String(S)), S;
      }
      function h(S) {
        var T = {
          next: function () {
            var M = S.shift();
            return { done: M === void 0, value: M };
          },
        };
        return (
          a.iterable &&
            (T[Symbol.iterator] = function () {
              return T;
            }),
          T
        );
      }
      function p(S) {
        (this.map = {}),
          S instanceof p
            ? S.forEach(function (T, M) {
                this.append(M, T);
              }, this)
            : Array.isArray(S)
              ? S.forEach(function (T) {
                  this.append(T[0], T[1]);
                }, this)
              : S &&
                Object.getOwnPropertyNames(S).forEach(function (T) {
                  this.append(T, S[T]);
                }, this);
      }
      (p.prototype.append = function (S, T) {
        (S = d(S)), (T = f(T));
        var M = this.map[S];
        this.map[S] = M ? M + ', ' + T : T;
      }),
        (p.prototype.delete = function (S) {
          delete this.map[d(S)];
        }),
        (p.prototype.get = function (S) {
          return (S = d(S)), this.has(S) ? this.map[S] : null;
        }),
        (p.prototype.has = function (S) {
          return this.map.hasOwnProperty(d(S));
        }),
        (p.prototype.set = function (S, T) {
          this.map[d(S)] = f(T);
        }),
        (p.prototype.forEach = function (S, T) {
          for (var M in this.map) this.map.hasOwnProperty(M) && S.call(T, this.map[M], M, this);
        }),
        (p.prototype.keys = function () {
          var S = [];
          return (
            this.forEach(function (T, M) {
              S.push(M);
            }),
            h(S)
          );
        }),
        (p.prototype.values = function () {
          var S = [];
          return (
            this.forEach(function (T) {
              S.push(T);
            }),
            h(S)
          );
        }),
        (p.prototype.entries = function () {
          var S = [];
          return (
            this.forEach(function (T, M) {
              S.push([M, T]);
            }),
            h(S)
          );
        }),
        a.iterable && (p.prototype[Symbol.iterator] = p.prototype.entries);
      function b(S) {
        if (S.bodyUsed) return Promise.reject(new TypeError('Already read'));
        S.bodyUsed = !0;
      }
      function w(S) {
        return new Promise(function (T, M) {
          (S.onload = function () {
            T(S.result);
          }),
            (S.onerror = function () {
              M(S.error);
            });
        });
      }
      function A(S) {
        var T = new FileReader(),
          M = w(T);
        return T.readAsArrayBuffer(S), M;
      }
      function _(S) {
        var T = new FileReader(),
          M = w(T);
        return T.readAsText(S), M;
      }
      function x(S) {
        for (var T = new Uint8Array(S), M = new Array(T.length), R = 0; R < T.length; R++)
          M[R] = String.fromCharCode(T[R]);
        return M.join('');
      }
      function k(S) {
        if (S.slice) return S.slice(0);
        var T = new Uint8Array(S.byteLength);
        return T.set(new Uint8Array(S)), T.buffer;
      }
      function j() {
        return (
          (this.bodyUsed = !1),
          (this._initBody = function (S) {
            (this._bodyInit = S),
              S
                ? typeof S == 'string'
                  ? (this._bodyText = S)
                  : a.blob && Blob.prototype.isPrototypeOf(S)
                    ? (this._bodyBlob = S)
                    : a.formData && FormData.prototype.isPrototypeOf(S)
                      ? (this._bodyFormData = S)
                      : a.searchParams && URLSearchParams.prototype.isPrototypeOf(S)
                        ? (this._bodyText = S.toString())
                        : a.arrayBuffer && a.blob && c(S)
                          ? ((this._bodyArrayBuffer = k(S.buffer)),
                            (this._bodyInit = new Blob([this._bodyArrayBuffer])))
                          : a.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(S) || l(S))
                            ? (this._bodyArrayBuffer = k(S))
                            : (this._bodyText = S = Object.prototype.toString.call(S))
                : (this._bodyText = ''),
              this.headers.get('content-type') ||
                (typeof S == 'string'
                  ? this.headers.set('content-type', 'text/plain;charset=UTF-8')
                  : this._bodyBlob && this._bodyBlob.type
                    ? this.headers.set('content-type', this._bodyBlob.type)
                    : a.searchParams &&
                      URLSearchParams.prototype.isPrototypeOf(S) &&
                      this.headers.set(
                        'content-type',
                        'application/x-www-form-urlencoded;charset=UTF-8'
                      ));
          }),
          a.blob &&
            ((this.blob = function () {
              var S = b(this);
              if (S) return S;
              if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
              if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              if (this._bodyFormData) throw new Error('could not read FormData body as blob');
              return Promise.resolve(new Blob([this._bodyText]));
            }),
            (this.arrayBuffer = function () {
              return this._bodyArrayBuffer
                ? b(this) || Promise.resolve(this._bodyArrayBuffer)
                : this.blob().then(A);
            })),
          (this.text = function () {
            var S = b(this);
            if (S) return S;
            if (this._bodyBlob) return _(this._bodyBlob);
            if (this._bodyArrayBuffer) return Promise.resolve(x(this._bodyArrayBuffer));
            if (this._bodyFormData) throw new Error('could not read FormData body as text');
            return Promise.resolve(this._bodyText);
          }),
          a.formData &&
            (this.formData = function () {
              return this.text().then(C);
            }),
          (this.json = function () {
            return this.text().then(JSON.parse);
          }),
          this
        );
      }
      var F = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];
      function K(S) {
        var T = S.toUpperCase();
        return F.indexOf(T) > -1 ? T : S;
      }
      function D(S, T) {
        T = T || {};
        var M = T.body;
        if (S instanceof D) {
          if (S.bodyUsed) throw new TypeError('Already read');
          (this.url = S.url),
            (this.credentials = S.credentials),
            T.headers || (this.headers = new p(S.headers)),
            (this.method = S.method),
            (this.mode = S.mode),
            (this.signal = S.signal),
            !M && S._bodyInit != null && ((M = S._bodyInit), (S.bodyUsed = !0));
        } else this.url = String(S);
        if (
          ((this.credentials = T.credentials || this.credentials || 'same-origin'),
          (T.headers || !this.headers) && (this.headers = new p(T.headers)),
          (this.method = K(T.method || this.method || 'GET')),
          (this.mode = T.mode || this.mode || null),
          (this.signal = T.signal || this.signal),
          (this.referrer = null),
          (this.method === 'GET' || this.method === 'HEAD') && M)
        )
          throw new TypeError('Body not allowed for GET or HEAD requests');
        this._initBody(M);
      }
      D.prototype.clone = function () {
        return new D(this, { body: this._bodyInit });
      };
      function C(S) {
        var T = new FormData();
        return (
          S.trim()
            .split('&')
            .forEach(function (M) {
              if (M) {
                var R = M.split('='),
                  L = R.shift().replace(/\+/g, ' '),
                  O = R.join('=').replace(/\+/g, ' ');
                T.append(decodeURIComponent(L), decodeURIComponent(O));
              }
            }),
          T
        );
      }
      function B(S) {
        var T = new p(),
          M = S.replace(/\r?\n[\t ]+/g, ' ');
        return (
          M.split(/\r?\n/).forEach(function (R) {
            var L = R.split(':'),
              O = L.shift().trim();
            if (O) {
              var I = L.join(':').trim();
              T.append(O, I);
            }
          }),
          T
        );
      }
      j.call(D.prototype);
      function E(S, T) {
        T || (T = {}),
          (this.type = 'default'),
          (this.status = T.status === void 0 ? 200 : T.status),
          (this.ok = this.status >= 200 && this.status < 300),
          (this.statusText = 'statusText' in T ? T.statusText : 'OK'),
          (this.headers = new p(T.headers)),
          (this.url = T.url || ''),
          this._initBody(S);
      }
      j.call(E.prototype),
        (E.prototype.clone = function () {
          return new E(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new p(this.headers),
            url: this.url,
          });
        }),
        (E.error = function () {
          var S = new E(null, { status: 0, statusText: '' });
          return (S.type = 'error'), S;
        });
      var y = [301, 302, 303, 307, 308];
      (E.redirect = function (S, T) {
        if (y.indexOf(T) === -1) throw new RangeError('Invalid status code');
        return new E(null, { status: T, headers: { location: S } });
      }),
        (o.DOMException = s.DOMException);
      try {
        new o.DOMException();
      } catch {
        (o.DOMException = function (T, M) {
          (this.message = T), (this.name = M);
          var R = Error(T);
          this.stack = R.stack;
        }),
          (o.DOMException.prototype = Object.create(Error.prototype)),
          (o.DOMException.prototype.constructor = o.DOMException);
      }
      function v(S, T) {
        return new Promise(function (M, R) {
          var L = new D(S, T);
          if (L.signal && L.signal.aborted) return R(new o.DOMException('Aborted', 'AbortError'));
          var O = new XMLHttpRequest();
          function I() {
            O.abort();
          }
          (O.onload = function () {
            var U = {
              status: O.status,
              statusText: O.statusText,
              headers: B(O.getAllResponseHeaders() || ''),
            };
            U.url = 'responseURL' in O ? O.responseURL : U.headers.get('X-Request-URL');
            var H = 'response' in O ? O.response : O.responseText;
            M(new E(H, U));
          }),
            (O.onerror = function () {
              R(new TypeError('Network request failed'));
            }),
            (O.ontimeout = function () {
              R(new TypeError('Network request failed'));
            }),
            (O.onabort = function () {
              R(new o.DOMException('Aborted', 'AbortError'));
            }),
            O.open(L.method, L.url, !0),
            L.credentials === 'include'
              ? (O.withCredentials = !0)
              : L.credentials === 'omit' && (O.withCredentials = !1),
            'responseType' in O && a.blob && (O.responseType = 'blob'),
            L.headers.forEach(function (U, H) {
              O.setRequestHeader(H, U);
            }),
            L.signal &&
              (L.signal.addEventListener('abort', I),
              (O.onreadystatechange = function () {
                O.readyState === 4 && L.signal.removeEventListener('abort', I);
              })),
            O.send(typeof L._bodyInit > 'u' ? null : L._bodyInit);
        });
      }
      return (
        (v.polyfill = !0),
        s.fetch || ((s.fetch = v), (s.Headers = p), (s.Request = D), (s.Response = E)),
        (o.Headers = p),
        (o.Request = D),
        (o.Response = E),
        (o.fetch = v),
        Object.defineProperty(o, '__esModule', { value: !0 }),
        o
      );
    })({});
  })(r),
    (r.fetch.ponyfill = !0),
    delete r.fetch.polyfill;
  var i = r;
  (t = i.fetch),
    (t.default = i.fetch),
    (t.fetch = i.fetch),
    (t.Headers = i.Headers),
    (t.Request = i.Request),
    (t.Response = i.Response),
    (e.exports = t);
})(kk, kk.exports);
var A4 = { exports: {} },
  I4 = { exports: {} };
(function () {
  var e = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
    t = {
      rotl: function (n, r) {
        return (n << r) | (n >>> (32 - r));
      },
      rotr: function (n, r) {
        return (n << (32 - r)) | (n >>> r);
      },
      endian: function (n) {
        if (n.constructor == Number)
          return (t.rotl(n, 8) & 16711935) | (t.rotl(n, 24) & 4278255360);
        for (var r = 0; r < n.length; r++) n[r] = t.endian(n[r]);
        return n;
      },
      randomBytes: function (n) {
        for (var r = []; n > 0; n--) r.push(Math.floor(Math.random() * 256));
        return r;
      },
      bytesToWords: function (n) {
        for (var r = [], i = 0, s = 0; i < n.length; i++, s += 8)
          r[s >>> 5] |= n[i] << (24 - (s % 32));
        return r;
      },
      wordsToBytes: function (n) {
        for (var r = [], i = 0; i < n.length * 32; i += 8)
          r.push((n[i >>> 5] >>> (24 - (i % 32))) & 255);
        return r;
      },
      bytesToHex: function (n) {
        for (var r = [], i = 0; i < n.length; i++)
          r.push((n[i] >>> 4).toString(16)), r.push((n[i] & 15).toString(16));
        return r.join('');
      },
      hexToBytes: function (n) {
        for (var r = [], i = 0; i < n.length; i += 2) r.push(parseInt(n.substr(i, 2), 16));
        return r;
      },
      bytesToBase64: function (n) {
        for (var r = [], i = 0; i < n.length; i += 3)
          for (var s = (n[i] << 16) | (n[i + 1] << 8) | n[i + 2], o = 0; o < 4; o++)
            i * 8 + o * 6 <= n.length * 8
              ? r.push(e.charAt((s >>> (6 * (3 - o))) & 63))
              : r.push('=');
        return r.join('');
      },
      base64ToBytes: function (n) {
        n = n.replace(/[^A-Z0-9+\/]/gi, '');
        for (var r = [], i = 0, s = 0; i < n.length; s = ++i % 4)
          s != 0 &&
            r.push(
              ((e.indexOf(n.charAt(i - 1)) & (Math.pow(2, -2 * s + 8) - 1)) << (s * 2)) |
                (e.indexOf(n.charAt(i)) >>> (6 - s * 2))
            );
        return r;
      },
    };
  I4.exports = t;
})();
var TJ = I4.exports,
  HS = {
    utf8: {
      stringToBytes: function (e) {
        return HS.bin.stringToBytes(unescape(encodeURIComponent(e)));
      },
      bytesToString: function (e) {
        return decodeURIComponent(escape(HS.bin.bytesToString(e)));
      },
    },
    bin: {
      stringToBytes: function (e) {
        for (var t = [], n = 0; n < e.length; n++) t.push(e.charCodeAt(n) & 255);
        return t;
      },
      bytesToString: function (e) {
        for (var t = [], n = 0; n < e.length; n++) t.push(String.fromCharCode(e[n]));
        return t.join('');
      },
    },
  },
  Ck = HS;
(function () {
  var e = TJ,
    t = Ck.utf8,
    n = Ck.bin,
    r = function (s) {
      s.constructor == String
        ? (s = t.stringToBytes(s))
        : typeof z < 'u' && typeof z.isBuffer == 'function' && z.isBuffer(s)
          ? (s = Array.prototype.slice.call(s, 0))
          : Array.isArray(s) || (s = s.toString());
      var o = e.bytesToWords(s),
        a = s.length * 8,
        c = [],
        u = 1732584193,
        l = -271733879,
        d = -1732584194,
        f = 271733878,
        h = -1009589776;
      (o[a >> 5] |= 128 << (24 - (a % 32))), (o[(((a + 64) >>> 9) << 4) + 15] = a);
      for (var p = 0; p < o.length; p += 16) {
        for (var b = u, w = l, A = d, _ = f, x = h, k = 0; k < 80; k++) {
          if (k < 16) c[k] = o[p + k];
          else {
            var j = c[k - 3] ^ c[k - 8] ^ c[k - 14] ^ c[k - 16];
            c[k] = (j << 1) | (j >>> 31);
          }
          var F =
            ((u << 5) | (u >>> 27)) +
            h +
            (c[k] >>> 0) +
            (k < 20
              ? ((l & d) | (~l & f)) + 1518500249
              : k < 40
                ? (l ^ d ^ f) + 1859775393
                : k < 60
                  ? ((l & d) | (l & f) | (d & f)) - 1894007588
                  : (l ^ d ^ f) - 899497514);
          (h = f), (f = d), (d = (l << 30) | (l >>> 2)), (l = u), (u = F);
        }
        (u += b), (l += w), (d += A), (f += _), (h += x);
      }
      return [u, l, d, f, h];
    },
    i = function (s, o) {
      var a = e.wordsToBytes(r(s));
      return o && o.asBytes ? a : o && o.asString ? n.bytesToString(a) : e.bytesToHex(a);
    };
  (i._blocksize = 16), (i._digestsize = 20), (A4.exports = i);
})();
var xJ = A4.exports;
const kJ = Sc(xJ);
var nd = ((e) => ((e.BLOCK = 'BLOCK'), (e.NONE = 'NONE'), e))(nd || {});
function CJ(e, t) {
  for (let n = 0; n < e.k; n++) {
    const r = kJ(`${e.salt}_${t}_${n}`, { asBytes: !0 }),
      s = he.from(r).subarray(0, 4).readUInt32BE(0) % e.bits,
      o = Math.floor(s / 24),
      a = he.from(e.bitVector.slice(o * 4, o * 4 + 4), 'base64'),
      c = s % 24,
      u = Math.floor(c / 8),
      l = c % 8;
    if (!(a[u] & (1 << (7 - l)))) return !1;
  }
  return !0;
}
function T4(e, t, n, r) {
  const s = new URL(r).hostname.toLowerCase().split('.');
  for (let o = 0; o < s.length - 1; o++) {
    const a = s.slice(o).join('.');
    if (t.includes(a) || (CJ(e, a) && !n.includes(a))) return 'BLOCK';
  }
  return 'NONE';
}
const PJ = '@phantom-labs/blocklist',
  MJ = '0.13.0',
  OJ = 'index.js',
  BJ = 'index.d.ts',
  DJ = 'git@github.com:phantom-labs/blocklist.git',
  RJ = 'Jordan Leigh <AlwaysBCoding@gmail.com>',
  NJ = 'MIT',
  jJ = { build: 'node build.js' },
  LJ = { 'js-yaml': '^4.1.0', sha3: '^2.1.4' },
  UJ = {
    name: PJ,
    version: MJ,
    main: OJ,
    types: BJ,
    repository: DJ,
    author: RJ,
    license: NJ,
    scripts: jJ,
    dependencies: LJ,
  },
  $J = [
    'phantomweb.app',
    'aurory.app',
    'solvision.io',
    'staratlas.art',
    'starsatlas.com',
    'sollet.cc',
    'raydlum.io',
    'aurorynft.com',
    'sneks.gg',
    'solletweb.io',
    'i-sollet.com',
    'fancyfrenchienft.art',
    'solanawebwallet.online',
    'phahtom.com',
    'server-syncwallet.com',
    'staratias.app',
    'raydium.network',
    'grapesnetwork.me',
    'staratias.art',
    'soistarter.org',
    'audius-nft.top',
    'aurory.me',
    'degenapes.app',
    'phantom-app.online',
    'phantomwallet.net',
    'dapps-node.com',
    'phantom-app.link',
    'solanaoutage.com',
    'walletconnectdapps.net',
    'staratlas.cx',
    'web-phantom.app',
    '0120tt.com',
  ],
  FJ = [],
  zJ = [],
  KJ = '830ea1c9a833213eabc17990adf053081f503b1203ca9a2c711db7199e657293',
  VJ = { blocklist: $J, whitelist: FJ, fuzzylist: zJ, contentHash: KJ },
  { version: WJ } = UJ,
  HJ = VJ,
  GJ = () => WJ,
  qJ = () => HJ;
var YJ = GJ,
  ZJ = qJ,
  Uy = { exports: {} };
const Fs = new Uint32Array(65536),
  JJ = (e, t) => {
    const n = e.length,
      r = t.length,
      i = 1 << (n - 1);
    let s = -1,
      o = 0,
      a = n,
      c = n;
    for (; c--; ) Fs[e.charCodeAt(c)] |= 1 << c;
    for (c = 0; c < r; c++) {
      let u = Fs[t.charCodeAt(c)];
      const l = u | o;
      (u |= ((u & s) + s) ^ s),
        (o |= ~(u | s)),
        (s &= u),
        o & i && a++,
        s & i && a--,
        (o = (o << 1) | 1),
        (s = (s << 1) | ~(l | o)),
        (o &= l);
    }
    for (c = n; c--; ) Fs[e.charCodeAt(c)] = 0;
    return a;
  },
  XJ = (e, t) => {
    const n = t.length,
      r = e.length,
      i = [],
      s = [],
      o = Math.ceil(n / 32),
      a = Math.ceil(r / 32);
    for (let p = 0; p < o; p++) (s[p] = -1), (i[p] = 0);
    let c = 0;
    for (; c < a - 1; c++) {
      let p = 0,
        b = -1;
      const w = c * 32,
        A = Math.min(32, r) + w;
      for (let _ = w; _ < A; _++) Fs[e.charCodeAt(_)] |= 1 << _;
      for (let _ = 0; _ < n; _++) {
        const x = Fs[t.charCodeAt(_)],
          k = (s[(_ / 32) | 0] >>> _) & 1,
          j = (i[(_ / 32) | 0] >>> _) & 1,
          F = x | p,
          K = ((((x | j) & b) + b) ^ b) | x | j;
        let D = p | ~(K | b),
          C = b & K;
        (D >>> 31) ^ k && (s[(_ / 32) | 0] ^= 1 << _),
          (C >>> 31) ^ j && (i[(_ / 32) | 0] ^= 1 << _),
          (D = (D << 1) | k),
          (C = (C << 1) | j),
          (b = C | ~(F | D)),
          (p = D & F);
      }
      for (let _ = w; _ < A; _++) Fs[e.charCodeAt(_)] = 0;
    }
    let u = 0,
      l = -1;
    const d = c * 32,
      f = Math.min(32, r - d) + d;
    for (let p = d; p < f; p++) Fs[e.charCodeAt(p)] |= 1 << p;
    let h = r;
    for (let p = 0; p < n; p++) {
      const b = Fs[t.charCodeAt(p)],
        w = (s[(p / 32) | 0] >>> p) & 1,
        A = (i[(p / 32) | 0] >>> p) & 1,
        _ = b | u,
        x = ((((b | A) & l) + l) ^ l) | b | A;
      let k = u | ~(x | l),
        j = l & x;
      (h += (k >>> (r - 1)) & 1),
        (h -= (j >>> (r - 1)) & 1),
        (k >>> 31) ^ w && (s[(p / 32) | 0] ^= 1 << p),
        (j >>> 31) ^ A && (i[(p / 32) | 0] ^= 1 << p),
        (k = (k << 1) | w),
        (j = (j << 1) | A),
        (l = j | ~(_ | k)),
        (u = k & _);
    }
    for (let p = d; p < f; p++) Fs[e.charCodeAt(p)] = 0;
    return h;
  },
  x4 = (e, t) => {
    if (e.length < t.length) {
      const n = t;
      (t = e), (e = n);
    }
    return t.length === 0 ? e.length : e.length <= 32 ? JJ(e, t) : XJ(e, t);
  },
  QJ = (e, t) => {
    let n = 1 / 0,
      r = 0;
    for (let i = 0; i < t.length; i++) {
      const s = x4(e, t[i]);
      s < n && ((n = s), (r = i));
    }
    return t[r];
  },
  eX = Object.freeze(
    Object.defineProperty({ __proto__: null, closest: QJ, distance: x4 }, Symbol.toStringTag, {
      value: 'Module',
    })
  ),
  tX = Sb(eX);
Uy.exports;
(function (e, t) {
  (function () {
    var n;
    try {
      n =
        typeof Intl < 'u' && typeof Intl.Collator < 'u'
          ? Intl.Collator('generic', { sensitivity: 'base' })
          : null;
    } catch {
      console.log("Collator could not be initialized and wouldn't be used");
    }
    var r = tX,
      i = [],
      s = [],
      o = {
        get: function (a, c, u) {
          var l = u && n && u.useCollator;
          if (l) {
            var d = a.length,
              f = c.length;
            if (d === 0) return f;
            if (f === 0) return d;
            var h, p, b, w, A;
            for (b = 0; b < f; ++b) (i[b] = b), (s[b] = c.charCodeAt(b));
            i[f] = f;
            var _;
            for (b = 0; b < d; ++b) {
              for (p = b + 1, w = 0; w < f; ++w)
                (h = p),
                  (_ = n.compare(a.charAt(b), String.fromCharCode(s[w])) === 0),
                  (p = i[w] + (_ ? 0 : 1)),
                  (A = h + 1),
                  p > A && (p = A),
                  (A = i[w + 1] + 1),
                  p > A && (p = A),
                  (i[w] = h);
              i[w] = p;
            }
            return p;
          }
          return r.distance(a, c);
        },
      };
    e !== null && e.exports === t
      ? (e.exports = o)
      : typeof globalThis < 'u' &&
          typeof globalThis.postMessage == 'function' &&
          typeof globalThis.importScripts == 'function'
        ? (globalThis.Levenshtein = o)
        : typeof window < 'u' && window !== null && (window.Levenshtein = o);
  })();
})(Uy, Uy.exports);
var nX = Uy.exports;
const rX = Sc(nX),
  iX = 'https://blocklist.phantom.app/multichain.json',
  k4 = 'https://blowfish-blocklist-proxy.phantom.app',
  C4 = (e = 3) => ({ retry: e, retryDelay: (t) => Math.min(1e3 * 2 ** t, 3e4) }),
  $y = {
    SLIPPAGE_EXCEEDED: 'SLIPPAGE_EXCEEDED',
    INSUFFICIENT_FUNDS: 'INSUFFICIENT_FUNDS',
    INSUFFICIENT_GAS: 'INSUFFICIENT_GAS',
    UNKNOWN_ERROR: 'UNKNOWN_ERROR',
    SIMULATION_FAILED: 'SIMULATION_FAILED',
    TRANSACTION_EXPIRED: 'TRANSACTION_EXPIRED',
    ACCOUNT_FROZEN: 'ACCOUNT_FROZEN',
    SIMULATION_TIMEOUT: 'SIMULATION_TIMEOUT',
    STALE_QUOTE: 'STALE_QUOTE',
  };
var Qb = ((e) => (
  (e[(e.info = 5)] = 'info'),
  (e[(e.error = 4)] = 'error'),
  (e[(e.criticalError = 3)] = 'criticalError'),
  (e[(e.alert = 2)] = 'alert'),
  (e[(e.criticalAlert = 1)] = 'criticalAlert'),
  e
))(Qb || {});
function P4(e) {
  return {
    1: '1-critical-alert',
    2: '2-alert',
    3: '3-critical-error',
    4: '4-error',
    5: '5-information',
  }[e];
}
const sX = 3,
  GS = 6e5,
  oX = 6e4;
g.object({
  type: g.union([
    g.literal('all'),
    g.literal('blocklist'),
    g.literal('whitelist'),
    g.literal('error'),
    g.literal('fuzzy'),
    g.literal('blowfishBloomFilter'),
  ]),
  result: g.boolean(),
  source: g.optional(g.string()),
  match: g.string().optional(),
  isSubdomainDomainWhitelisted: g.boolean().optional(),
});
g.object({ localHash: g.any(), cursor: g.any() });
const qS = g.object({
    bitVector: g.string(),
    k: g.number(),
    hash: g.string(),
    bits: g.number(),
    salt: g.string(),
  }),
  M4 = g.union([
    g.object({
      bloomFilter: qS,
      bloomFilterHash: g.string(),
      recentlyAdded: g.array(g.string()),
      recentlyRemoved: g.array(g.string()),
      nextCursor: g.string(),
    }),
    g.object({
      bloomFilter: qS.optional(),
      bloomFilterHash: g.optional(g.string()),
      recentlyAdded: g.array(g.string()),
      recentlyRemoved: g.array(g.string()),
      nextCursor: g.string(),
    }),
  ]),
  O4 = g.object({ bloomFilter: qS, lastUpdated: g.number() }).nullish(),
  B4 = g
    .object({
      recentlyAdded: g.array(g.string()),
      recentlyRemoved: g.array(g.string()),
      lastUpdated: g.number().optional(),
    })
    .nullish();
class Xw {
  constructor(t, n, r, i) {
    ae(this, 'blocklist');
    ae(this, 'whitelist');
    ae(this, 'fuzzylist');
    ae(this, 'tolerance');
    (this.blocklist = Qw(t)),
      (this.whitelist = Qw(n)),
      (this.fuzzylist = Qw(r)),
      (this.tolerance = i || sX);
  }
  check(t, n) {
    if (!t) return { type: 'all', result: !1, isSubdomainDomainWhitelisted: !1 };
    const r = aI(t),
      i = YS(r);
    if (cX(i, this.whitelist)) {
      const c = new URL(t).hostname;
      if (ev(YS(c), this.blocklist)) {
        const l = { type: 'blocklist', result: !0, source: c, isSubdomainDomainWhitelisted: !0 };
        return n.capture('blockedDomain', { data: l }), l;
      } else return { type: 'whitelist', result: !1, source: c, isSubdomainDomainWhitelisted: !0 };
    }
    if (ev(i, this.whitelist))
      return { type: 'whitelist', result: !1, source: r, isSubdomainDomainWhitelisted: !1 };
    if (ev(i, this.blocklist)) {
      const c = { type: 'blocklist', result: !0, source: r, isSubdomainDomainWhitelisted: !1 };
      return n.capture('blockedDomain', { data: c }), c;
    }
    if (this.tolerance > 0) {
      let c = Pk(i);
      c = c.replace('www.', '');
      const u = this.fuzzylist.find((l) => {
        const d = Pk(l);
        return rX.get(c, d) <= this.tolerance;
      });
      if (u)
        return {
          type: 'fuzzy',
          result: !0,
          match: aX(u),
          source: r,
          isSubdomainDomainWhitelisted: !1,
        };
    }
    return { type: 'all', result: !1, source: r, isSubdomainDomainWhitelisted: !1 };
  }
}
const aI = (e) => {
    const t = new URL(e).hostname.split('.');
    return t
      .slice(0)
      .slice(-(t.length === 4 ? 3 : 2))
      .join('.');
  },
  Qw = (e) => e.map(YS),
  YS = (e) => e.split('.').reverse(),
  aX = (e) => e.slice().reverse().join('.'),
  Pk = (e) => e.slice(1).reverse().join('.'),
  ev = (e, t) => t.some((n) => (n.length > e.length ? !1 : n.every((r, i) => e[i] === r))),
  cX = (e, t) => t.some((n) => n[0] === e[0] && n[1] === e[1] && n[2] === '*'),
  uX = async (e) => {
    const t = ZJ(),
      n = await e.get(et.CachedBlocklistDiff);
    let r = null;
    try {
      r = JSON.parse(`${n}`);
    } catch (i) {
      re.captureError(
        new Error(`Error parsing blocklist diff: ${i == null ? void 0 : i.message}`),
        ce.Generic
      );
    }
    if (r && r.expiresAt && r.expiresAt > Date.now())
      return new Xw(
        t.blocklist.concat(r.blocklist),
        t.whitelist.concat(r.whitelist),
        t.fuzzylist.concat(r.fuzzylist)
      );
    {
      const i = {},
        s = YJ();
      r && (i.lastContentHash = `${r.contentHash}`), s && (i.localBlocklistVersion = `${s}`);
      const o = await Ge.headers(i).get(iX);
      if (o.status === 200) {
        const a = o.data;
        return (
          (a.expiresAt = Date.now() + GS),
          e.set(et.CachedBlocklistDiff, JSON.stringify(a)),
          new Xw(
            t.blocklist.concat(a.blocklist),
            t.whitelist.concat(a.whitelist),
            t.fuzzylist.concat(a.fuzzylist)
          )
        );
      } else {
        if (o.status === 304)
          return (
            (r.expiresAt = Date.now() + GS),
            e.set(et.CachedBlocklistDiff, JSON.stringify(r)),
            new Xw(
              t.blocklist.concat(r.blocklist),
              t.whitelist.concat(r.whitelist),
              t.fuzzylist.concat(r.fuzzylist)
            )
          );
        throw new Error('Invalid response from blocklist');
      }
    }
  },
  lX = async (e, t, n) => {
    let r, i;
    try {
      const o = await R9(t.getFeatureFlags(), 1e3);
      (r = !!o['kill-blowfish-blocklist-cursor']), (i = !!o['kill-previous-blocklist']);
    } catch {
      (r = !1), (i = !1);
    }
    let s;
    try {
      if (i) return r ? Ok(n, e, t) : Mk(n, e, t);
      {
        s = await uX(e);
        const o = s.check(n, t);
        return o.type === 'all' ? (r ? Ok(n, e, t) : Mk(n, e, t)) : o;
      }
    } catch {
      return { result: !1, type: 'error', isSubdomainDomainWhitelisted: !1 };
    }
  },
  Mk = async (e, t, n) => {
    if (!e) return { type: 'all', result: !1, isSubdomainDomainWhitelisted: !1 };
    const r = aI(e),
      i = await t.getAll([
        et.CachedBloomFilter,
        et.CachedBloomFilterHash,
        et.CachedScanDataRecents,
        et.CachedScanDataCursor,
      ]),
      s = i[et.CachedBloomFilter] ?? null,
      o = i[et.CachedBloomFilterHash] ?? null,
      a = i[et.CachedScanDataCursor] ?? null,
      c = i[et.CachedScanDataRecents] ?? null;
    let u = null,
      l = { recentlyAdded: [], recentlyRemoved: [], lastUpdated: 0 },
      d = null;
    if (s) {
      const h = O4.safeParse(s);
      h.success ? (u = h.data) : await tv(t);
    }
    if (c) {
      const h = B4.safeParse(c);
      h.success ? (l = h.data) : await tv(t);
    }
    if (a) {
      const p = g.string().safeParse(a);
      p.success ? (d = p.data) : await tv(t);
    }
    if (!l || l.lastUpdated == null || Date.now() > l.lastUpdated + oX) {
      const h = { localHash: o, cursor: d },
        p = await Ge.post(k4, h);
      if (p.status !== 200) return { result: !1, type: 'error', isSubdomainDomainWhitelisted: !1 };
      const b = p.data;
      let w;
      const A = M4.safeParse(b);
      if (A.success) w = A.data;
      else return { result: !1, type: 'error', isSubdomainDomainWhitelisted: !1 };
      let _ = [],
        x = [];
      const k = typeof o == 'string' && w.bloomFilterHash ? o !== w.bloomFilterHash : !1;
      l != null && !k && ((_ = l.recentlyAdded), (x = l.recentlyRemoved)),
        (_ = _.concat(w.recentlyAdded)),
        (x = x.concat(w.recentlyRemoved)),
        (_ = _.filter((F) => w.recentlyRemoved.indexOf(F) < 0)),
        (x = x.filter((F) => w.recentlyAdded.indexOf(F) < 0));
      const j = { recentlyAdded: _, recentlyRemoved: x, lastUpdated: Date.now() };
      if (
        (await t.set(et.CachedScanDataRecents, j),
        (l = j),
        w.nextCursor !== d && (await t.set(et.CachedScanDataCursor, w.nextCursor)),
        w.bloomFilter != null)
      ) {
        const F = { bloomFilter: w.bloomFilter, lastUpdated: Date.now() };
        await Promise.all([
          t.set(et.CachedBloomFilter, F),
          t.set(et.CachedBloomFilterHash, w.bloomFilterHash),
        ]),
          (u = F);
      }
    }
    if (!u) return { type: 'all', result: !1, isSubdomainDomainWhitelisted: !1 };
    const f = T4(u.bloomFilter, l.recentlyAdded, l.recentlyRemoved, e);
    if (f === nd.BLOCK) {
      const h = { result: !0, source: r, type: 'blowfishBloomFilter' };
      return n.capture('blockedDomain', { data: h }), h;
    } else if (f === nd.NONE) return { result: !1, type: 'all', isSubdomainDomainWhitelisted: !1 };
    return { result: !1, type: 'error', isSubdomainDomainWhitelisted: !1 };
  };
async function tv(e) {
  await e.remove([
    et.CachedBloomFilter,
    et.CachedBloomFilterHash,
    et.CachedScanDataRecents,
    et.CachedScanDataCursor,
  ]);
}
const Ok = async (e, t, n) => {
    if (!e) return { type: 'all', result: !1, isSubdomainDomainWhitelisted: !1 };
    const r = aI(e),
      i = await t.getAll([
        et.CachedBloomFilter,
        et.CachedBloomFilterHash,
        et.CachedScanDataRecents,
      ]),
      s = i[et.CachedBloomFilter] ?? null,
      o = i[et.CachedBloomFilterHash] ?? null,
      a = i[et.CachedScanDataRecents] ?? null;
    let c = null,
      u = { recentlyAdded: [], recentlyRemoved: [], lastUpdated: 0 };
    if (s) {
      const d = O4.safeParse(s);
      d.success
        ? (c = d.data)
        : await t.remove([
            et.CachedBloomFilter,
            et.CachedBloomFilterHash,
            et.CachedScanDataRecents,
          ]);
    }
    if (a) {
      const d = B4.safeParse(a);
      d.success
        ? (u = d.data)
        : await t.remove([
            et.CachedBloomFilter,
            et.CachedBloomFilterHash,
            et.CachedScanDataRecents,
          ]);
    }
    if (!u || u.lastUpdated == null || Date.now() > u.lastUpdated + GS) {
      const d = { localHash: o },
        f = await Ge.post(k4, d);
      if (f.status !== 200) return { result: !1, type: 'error', isSubdomainDomainWhitelisted: !1 };
      const h = f.data;
      let p;
      const b = M4.safeParse(h);
      if (b.success) p = b.data;
      else return { result: !1, type: 'error', isSubdomainDomainWhitelisted: !1 };
      const w = {
        recentlyAdded: p.recentlyAdded,
        recentlyRemoved: p.recentlyRemoved,
        lastUpdated: Date.now(),
      };
      if ((await t.set(et.CachedScanDataRecents, w), (u = w), p.bloomFilter != null)) {
        const A = { bloomFilter: p.bloomFilter, lastUpdated: Date.now() };
        await Promise.all([
          t.set(et.CachedBloomFilter, A),
          t.set(et.CachedBloomFilterHash, p.bloomFilterHash),
        ]),
          (c = A);
      }
    }
    if (!c) return { type: 'all', result: !1, isSubdomainDomainWhitelisted: !1 };
    const l = T4(c.bloomFilter, u.recentlyAdded, u.recentlyRemoved, e);
    if (l === nd.BLOCK) {
      const d = { result: !0, source: r, type: 'blowfishBloomFilter' };
      return n.capture('blockedDomain', { data: d }), d;
    } else if (l === nd.NONE) return { result: !1, type: 'all', isSubdomainDomainWhitelisted: !1 };
    return { result: !1, type: 'error', isSubdomainDomainWhitelisted: !1 };
  },
  dX = (e) => {
    const t = Es(),
      n = Un(),
      { data: r, isPending: i } = Qt({
        gcTime: 0,
        queryKey: ['originIsBlocklisted', e],
        queryFn: async () => {
          const { result: s } = await lX(t, n, e);
          return s;
        },
      });
    return e === void 0
      ? { isLoading: !1, originIsBlocklisted: !1 }
      : { isLoading: i, originIsBlocklisted: r ?? !1 };
  };
var na;
class D4 {
  constructor(t) {
    Vt(this, na);
    ae(this, 'onScannedMessageByUser', (t) => {
      oe(this, na).capture('simulation', {
        data: { simulation: { ...t, type: 'message', status: 'success' } },
      });
    });
    ae(this, 'onFailedScannedMessageByUser', (t) => {
      oe(this, na).capture('simulation', {
        data: { simulation: { ...t, type: 'message', status: 'error' } },
      });
    });
    ae(this, 'onScannedTransactionByUser', (t) => {
      oe(this, na).capture('simulation', {
        data: { simulation: { ...t, type: 'transaction', status: 'success' } },
      });
    });
    ae(this, 'onFailedScannedTransactionByUser', (t) => {
      oe(this, na).capture('simulation', {
        data: { simulation: { ...t, type: 'transaction', status: 'error' } },
      });
    });
    Ft(this, na, t);
  }
}
na = new WeakMap();
const en = '@phantom/transactions',
  fo = {
    customGasControls() {
      return [`${en}:custom-gas-controls`];
    },
    gasEstimation(e, t, n, r) {
      return [
        `${en}:gas-estimation`,
        { networkID: e, multichainTransaction: t, transactionSpeed: n, additionalCosts: r },
      ];
    },
    solanaGasEstimation(e) {
      return [`${en}:solana-gas-estimation`, e || {}];
    },
    solanaComputeUnitPrice(e) {
      return [`${en}:compute-unit-price`, e || {}];
    },
    gasEstimationPrice(e, t) {
      return [`${en}:gas-estimation-price`, e ? { networkID: e } : {}, t || {}];
    },
    gasEstimationTimeToMine(e, t, n) {
      return [
        `${en}:gas-estimation-time-to-mine`,
        { networkID: e, maxFeePerGas: t, maxPriorityFeePerGas: n },
      ];
    },
    resolveDomainName(e, t) {
      return [`${en}:resolve-domain-name`, { name: e }, { networkID: t }];
    },
    waitForTransactionConfirmation(e) {
      return [`${en}:wait-for-transaction-confirmation`, e ? { transactionReceipt: e } : {}];
    },
    pendingTransactions(e) {
      return [`${en}:pending-transactions`, { accounts: e }];
    },
    pendingTransactionById(e) {
      return [`${en}:pending-transaction`, e];
    },
    transactionSpeedsToUnitCost(e) {
      return [`${en}:transaction-speeds-to-cost`, { networkID: e }];
    },
    evmGasEstimationFallback(e) {
      return [`${en}:evm-gas-estimation-fallback`, { networkID: e }];
    },
    erc20GasLimitEstimate(e, t) {
      return [`${en}:evm-erc20-gas-limit-estimation`, { networkID: e, args: t }];
    },
    erc721GasLimitEstimate(e, t) {
      return [`${en}:evm-erc721-gas-limit-estimation`, { networkID: e, args: t }];
    },
    erc1155GasLimitEstimate(e, t) {
      return [`${en}:evm-erc1155-gas-limit-estimation`, { networkID: e, args: t }];
    },
    nativeEvmGasLimit(e, t) {
      return [`${en}:native-evm-gas-limit`, { networkID: e, address: t }];
    },
    timestamps() {
      return [`${en}:timestamps`];
    },
    gasLimit(e) {
      return [`${en}:gas-limit`, { args: e }];
    },
    gasLimitByTransaction(e) {
      return [`${en}:gas-limit-by-transaction`, { multichainTransaction: e }];
    },
    transactionUnitAmount(e) {
      return [`${en}:network-unit-by-transaction`, { multichainTransaction: e }];
    },
    utxoState(e) {
      return [`${en}:utxo-state`, { address: e }];
    },
    transactionAdditionalCosts(e) {
      return [`${en}:additional-costs`, { transaction: e }];
    },
    suiTransaction(e) {
      return [`${en}:sui-transaction`, e];
    },
  };
g.object({ chainId: $u, address: g.string() });
var R4 = ((e) => (
  (e.TokenSend = 'TokenSend'),
  (e.Stake = 'Stake'),
  (e.Swap = 'Swap'),
  (e.DappInteraction = 'DappInteraction'),
  (e.Other = 'Other'),
  e
))(R4 || {});
g.object({
  accounts: g.array(g.string()),
  chainId: g.enum([mt.Solana.Mainnet]),
  transactionType: g.nativeEnum(R4).optional(),
  computeUnitLimit: g.number().optional(),
  getBounds: g.boolean().optional(),
});
const N4 = g.object({ networkID: aA });
N4.extend({
  senderAddress: EP,
  type: g.literal('transferNativeSolana'),
  destination: g.string(),
  amount: g.union([g.instanceof(fe), g.string()]),
  references: g.array(g.string()).optional(),
  memo: g.string().optional(),
  computeUnitPrice: g.union([g.number(), g.undefined()]),
});
g.object({ compressed: g.boolean(), merkleTree: g.string(), leafIndex: g.number() });
const fX = N4.extend({
  type: g.literal('transferSPLToken'),
  senderAddress: EP,
  mint: g.string(),
  amount: g.union([g.instanceof(fe), g.string()]),
  memo: g.string().optional(),
});
fX.extend({
  destination: g.string(),
  senderAccount: g.string(),
  decimals: g.number(),
  references: g.array(g.string()).optional(),
  programId: g.string(),
  transferHookProgramId: g.union([g.string(), g.undefined(), g.null()]),
});
g.object({ networkID: aA, id: g.string() });
g.object({
  executable: g.literal(!1),
  lamports: g.number(),
  owner: g.instanceof(nr),
  rentEpoch: g.number(),
  data: g.object({
    program: g.literal('spl-token'),
    space: g.number(),
    parsed: g.object({
      type: g.literal('account'),
      info: g.object({
        isNative: g.boolean(),
        mint: g.string(),
        owner: g.string(),
        state: g.string(),
        tokenAmount: g.object({
          amount: g.string(),
          decimals: g.number(),
          uiAmount: g.number(),
          uiAmountString: g.string(),
        }),
      }),
    }),
  }),
});
g.object({ txID: g.string(), psbtHex: g.string(), confirmations: g.number() });
g.object({ digest: g.string() });
g.object({ displayName: g.string(), logoURI: g.string() });
var er = ((e) => ((e.fast = 'fast'), (e.standard = 'standard'), (e.slow = 'slow'), e))(er || {});
g.object({
  networkID: bb,
  gasLimit: g.instanceof(fe),
  maxFeePerGas: g.instanceof(fe),
  maxPriorityFeePerGas: g.instanceof(fe),
  l1Fee: g.instanceof(fe).optional(),
});
g.object({
  networkID: mb,
  virtualBytes: g.instanceof(fe),
  btcPerKilobyte: g.instanceof(fe),
  additionalCosts: g.instanceof(fe),
});
g.object({ networkID: bb, id: g.string() });
g.object({ txID: g.string(), psbtHex: g.string() });
g.object({ networkID: mb, id: g.string() });
g.object({ digest: g.string() });
g.object({ networkID: gP, id: g.string() });
var ao = ((e) => ((e.History = 'history'), (e.Home = 'home'), e))(ao || {});
g.union([g.literal('UNSET'), g.literal('ECONOMICAL'), g.literal('CONSERVATIVE')]);
function hX(e) {
  return {
    getRawTransaction: (n) => t('getrawtransaction', [n, 2]),
    sendRawTransaction: (n) => t('sendrawtransaction', [n]),
    estimateSmartFee: (n, r) => t('estimatesmartfee', [n, r ?? 'CONSERVATIVE']),
  };
  async function t(n, r) {
    const i = await Ge.headers({ 'Content-type': 'application/json' }).post(e, {
      method: n,
      params: r,
    });
    if ('error' in i.data && i.data.error)
      throw new Error('bitcoin rpc error:' + JSON.stringify(i.data.error));
    return i.data.result;
  }
}
const pX = [
    'eth_blockNumber',
    'eth_call',
    'eth_cancelPrivateTransaction',
    'eth_estimateGas',
    'eth_feeHistory',
    'eth_gasPrice',
    'eth_getBalance',
    'eth_getBlockByHash',
    'eth_getBlockByNumber',
    'eth_getBlockReceipts',
    'eth_getBlockTransactionCountByHash',
    'eth_getBlockTransactionCountByNumber',
    'eth_getCode',
    'eth_getFilterChanges',
    'eth_getFilterLogs',
    'eth_getLogs',
    'eth_getProof',
    'eth_getStorageAt',
    'eth_getTransactionByBlockHashAndIndex',
    'eth_getTransactionByBlockNumberAndIndex',
    'eth_getTransactionByHash',
    'eth_getTransactionCount',
    'eth_getTransactionReceipt',
    'eth_getUncleByBlockHashAndIndex',
    'eth_getUncleByBlockNumberAndIndex',
    'eth_getUncleCountByBlockHash',
    'eth_getUncleCountByBlockNumber',
    'eth_maxPriorityFeePerGas',
    'eth_newBlockFilter',
    'eth_newFilter',
    'eth_newPendingTransactionFilter',
    'eth_protocolVersion',
    'eth_sendPrivateTransaction',
    'eth_sendRawTransaction',
    'eth_syncing',
    'eth_uninstallFilter',
    'net_listening',
    'net_version',
    'web3_clientVersion',
    'web3_sha3',
  ],
  cI = pX.reduce(
    (e, t) => ({
      ...e,
      [t]: async (n, r) => {
        let i;
        const s = JSON.stringify({
          jsonrpc: '2.0',
          id: 1,
          method: t,
          params: bx[t].params.parse(r),
        });
        try {
          return (
            (i = (
              await Ge.headers({
                Accept: 'application/json',
                'Content-type': 'application/json',
              }).post(n, s)
            ).data),
            bx[t].response.parse(i)
          );
        } catch (o) {
          throw (console.error('RPC request failed', n, t, r, i), o);
        }
      },
    }),
    {}
  ),
  gX = new Error('Missing baseFeePerGas in eth_getBlockByNumber.'),
  uI = (e) => {
    const t = de.getRpcProxyUrl(e);
    if (!t) throw Error(`No RPC URL found for chainID ${e}`);
    return t;
  },
  yX = (e) => {
    const t = de.getEVMNetworkIDValue(e),
      n = de.getRpcProxyUrl(e);
    return new GL(e$(n), t);
  },
  bX = 2,
  mX = async (e) => {
    const t = uI(e),
      n = await cI.eth_getBlockByNumber(t, ['latest', !1]);
    if ('error' in n) throw new Error(`[${n.error.code}] ${n.error.message}`);
    if (!n.result.baseFeePerGas) throw gX;
    return new fe(n.result.baseFeePerGas, 16).multipliedBy(bX).integerValue(fe.ROUND_DOWN);
  },
  wX = async (e) => {
    const t = uI(e),
      n = await cI.eth_maxPriorityFeePerGas(t, []);
    if ('error' in n) throw new Error(`[${n.error.code}] ${n.error.message}`);
    return new fe(n.result, 16);
  },
  vX = 'https://gas-price-oracle.phantom.app',
  _X = g.object({ maxFeePerGas: g.string(), maxPriorityFeePerGas: g.string() }),
  nv = g.record(g.string(), _X),
  SX = g.object({
    gasPriceSources: g.object({
      recommended: g.object({ priceEstimates: nv }),
      blocknative: g.object({ priceEstimates: nv }).optional(),
      etherscan: g.object({ priceEstimates: nv }).optional(),
    }),
  });
class j4 extends Error {
  constructor() {
    super(...arguments);
    ae(this, 'message', 'Gas price oracle does not support this network');
  }
}
const EX = async (e) => {
    if (!de.isMainnetNetworkID(e)) throw new j4();
    const t = `${vX}/?chainId=${e}`,
      r = (await Ge.headers({ 'Content-Type': 'application/json' }).get(t)).data;
    try {
      const i = SX.parse(r),
        s = Object.keys(i.gasPriceSources.recommended.priceEstimates),
        o = {};
      return (
        s.forEach((a) => {
          o[a] = {
            maxFeePerGas: new fe(i.gasPriceSources.recommended.priceEstimates[a].maxFeePerGas),
            maxPriorityFeePerGas: new fe(
              i.gasPriceSources.recommended.priceEstimates[a].maxPriorityFeePerGas
            ),
          };
        }),
        o
      );
    } catch (i) {
      throw new Error(`Ethereum Price oracle response: ${JSON.stringify(r)}, ${i}`, { cause: i });
    }
  },
  Bk = new fe(30 * 1e9),
  AX = async (e) => {
    const t = await mX(e),
      n = await wX(e);
    let r = t.plus(n);
    return (
      r.lt(Bk) && de.isPolygonNetworkID(e) && (r = Bk), { maxFeePerGas: r, maxPriorityFeePerGas: n }
    );
  },
  IX = async (e, t = !0) => {
    if (de.isEVMNetworkID(e))
      try {
        return await EX(e);
      } catch (n) {
        if (!t) throw n;
        const r = await AX(e);
        return { [er.fast]: r, [er.standard]: r, [er.slow]: r };
      }
    else throw new Error(`Estimating gas price for chainId:${e} is not supported.`);
  },
  TX = new fe(0),
  xX = new fe(1e-4),
  kX = new fe(0.01),
  Xp = (e) => {
    if (e.isEqualTo(TX)) return '$0';
    if (e.isLessThan(xX)) return '< $0.0001';
    const t = AP(e.toNumber());
    return e.isLessThan(kX) ? t.format('$0,0.0000') : t.format('$0,0.00');
  },
  CX = 1.1,
  PX = (e) => e.times(CX).toFixed(0);
new nr('11111111111111111111111111111111');
new nr('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');
new nr('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');
const MX = 'noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV';
new nr(MX);
const OX = 'cmtDvXumGCrqC1Age74AVPhSRVXJMd8PJS91L8KbNCK';
new nr(OX);
new nr('auth9SigNpDKz4sJJ1DfCTuZrZNSAgh9sFD3rboVmgg');
new nr('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s');
const BX = 'BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY';
new nr(BX);
function DX(e) {
  if (e.length >= 255) throw new TypeError('Alphabet too long');
  for (var t = new Uint8Array(256), n = 0; n < t.length; n++) t[n] = 255;
  for (var r = 0; r < e.length; r++) {
    var i = e.charAt(r),
      s = i.charCodeAt(0);
    if (t[s] !== 255) throw new TypeError(i + ' is ambiguous');
    t[s] = r;
  }
  var o = e.length,
    a = e.charAt(0),
    c = Math.log(o) / Math.log(256),
    u = Math.log(256) / Math.log(o);
  function l(h) {
    if (
      (h instanceof Uint8Array ||
        (ArrayBuffer.isView(h)
          ? (h = new Uint8Array(h.buffer, h.byteOffset, h.byteLength))
          : Array.isArray(h) && (h = Uint8Array.from(h))),
      !(h instanceof Uint8Array))
    )
      throw new TypeError('Expected Uint8Array');
    if (h.length === 0) return '';
    for (var p = 0, b = 0, w = 0, A = h.length; w !== A && h[w] === 0; ) w++, p++;
    for (var _ = ((A - w) * u + 1) >>> 0, x = new Uint8Array(_); w !== A; ) {
      for (var k = h[w], j = 0, F = _ - 1; (k !== 0 || j < b) && F !== -1; F--, j++)
        (k += (256 * x[F]) >>> 0), (x[F] = k % o >>> 0), (k = (k / o) >>> 0);
      if (k !== 0) throw new Error('Non-zero carry');
      (b = j), w++;
    }
    for (var K = _ - b; K !== _ && x[K] === 0; ) K++;
    for (var D = a.repeat(p); K < _; ++K) D += e.charAt(x[K]);
    return D;
  }
  function d(h) {
    if (typeof h != 'string') throw new TypeError('Expected String');
    if (h.length === 0) return new Uint8Array();
    for (var p = 0, b = 0, w = 0; h[p] === a; ) b++, p++;
    for (var A = ((h.length - p) * c + 1) >>> 0, _ = new Uint8Array(A); h[p]; ) {
      var x = t[h.charCodeAt(p)];
      if (x === 255) return;
      for (var k = 0, j = A - 1; (x !== 0 || k < w) && j !== -1; j--, k++)
        (x += (o * _[j]) >>> 0), (_[j] = x % 256 >>> 0), (x = (x / 256) >>> 0);
      if (x !== 0) throw new Error('Non-zero carry');
      (w = k), p++;
    }
    for (var F = A - w; F !== A && _[F] === 0; ) F++;
    for (var K = new Uint8Array(b + (A - F)), D = b; F !== A; ) K[D++] = _[F++];
    return K;
  }
  function f(h) {
    var p = d(h);
    if (p) return p;
    throw new Error('Non-base' + o + ' character');
  }
  return { encode: l, decodeUnsafe: d, decode: f };
}
var RX = DX;
const NX = RX,
  jX = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
NX(jX);
var LX = {},
  em = {},
  rv = {};
function ZS(e) {
  if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`);
}
function UX(e) {
  if (typeof e != 'boolean') throw new Error(`Expected boolean, not ${e}`);
}
function L4(e, ...t) {
  if (!(e instanceof Uint8Array)) throw new TypeError('Expected Uint8Array');
  if (t.length > 0 && !t.includes(e.length))
    throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function $X(e) {
  if (typeof e != 'function' || typeof e.create != 'function')
    throw new Error('Hash should be wrapped by utils.wrapConstructor');
  ZS(e.outputLen), ZS(e.blockLen);
}
function FX(e, t = !0) {
  if (e.destroyed) throw new Error('Hash instance has been destroyed');
  if (t && e.finished) throw new Error('Hash#digest() has already been called');
}
function zX(e, t) {
  L4(e);
  const n = t.outputLen;
  if (e.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`);
}
const zr = { number: ZS, bool: UX, bytes: L4, hash: $X, exists: FX, output: zX };
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const KX = (e) =>
    new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)),
  iv = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength),
  es = (e, t) => (e << (32 - t)) | (e >>> t),
  VX = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!VX) throw new Error('Non little-endian hardware is not supported');
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, '0'));
function WX(e) {
  if (typeof e != 'string') throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function xd(e) {
  if ((typeof e == 'string' && (e = WX(e)), !(e instanceof Uint8Array)))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
  return e;
}
let lI = class {
  clone() {
    return this._cloneInto();
  }
};
function Ic(e) {
  const t = (r) => e().update(xd(r)).digest(),
    n = e();
  return (t.outputLen = n.outputLen), (t.blockLen = n.blockLen), (t.create = () => e()), t;
}
function HX(e) {
  const t = (r, i) => e(i).update(xd(r)).digest(),
    n = e({});
  return (t.outputLen = n.outputLen), (t.blockLen = n.blockLen), (t.create = (r) => e(r)), t;
}
function GX(e, t, n, r) {
  if (typeof e.setBigUint64 == 'function') return e.setBigUint64(t, n, r);
  const i = BigInt(32),
    s = BigInt(4294967295),
    o = Number((n >> i) & s),
    a = Number(n & s),
    c = r ? 4 : 0,
    u = r ? 0 : 4;
  e.setUint32(t + c, o, r), e.setUint32(t + u, a, r);
}
let U4 = class extends lI {
  constructor(t, n, r, i) {
    super(),
      (this.blockLen = t),
      (this.outputLen = n),
      (this.padOffset = r),
      (this.isLE = i),
      (this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.buffer = new Uint8Array(t)),
      (this.view = iv(this.buffer));
  }
  update(t) {
    zr.exists(this);
    const { view: n, buffer: r, blockLen: i } = this;
    t = xd(t);
    const s = t.length;
    for (let o = 0; o < s; ) {
      const a = Math.min(i - this.pos, s - o);
      if (a === i) {
        const c = iv(t);
        for (; i <= s - o; o += i) this.process(c, o);
        continue;
      }
      r.set(t.subarray(o, o + a), this.pos),
        (this.pos += a),
        (o += a),
        this.pos === i && (this.process(n, 0), (this.pos = 0));
    }
    return (this.length += t.length), this.roundClean(), this;
  }
  digestInto(t) {
    zr.exists(this), zr.output(t, this), (this.finished = !0);
    const { buffer: n, view: r, blockLen: i, isLE: s } = this;
    let { pos: o } = this;
    (n[o++] = 128),
      this.buffer.subarray(o).fill(0),
      this.padOffset > i - o && (this.process(r, 0), (o = 0));
    for (let d = o; d < i; d++) n[d] = 0;
    GX(r, i - 8, BigInt(this.length * 8), s), this.process(r, 0);
    const a = iv(t),
      c = this.outputLen;
    if (c % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
    const u = c / 4,
      l = this.get();
    if (u > l.length) throw new Error('_sha2: outputLen bigger than state');
    for (let d = 0; d < u; d++) a.setUint32(4 * d, l[d], s);
  }
  digest() {
    const { buffer: t, outputLen: n } = this;
    this.digestInto(t);
    const r = t.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: n, buffer: r, length: i, finished: s, destroyed: o, pos: a } = this;
    return (
      (t.length = i), (t.pos = a), (t.finished = s), (t.destroyed = o), i % n && t.buffer.set(r), t
    );
  }
};
const Qp = BigInt(2 ** 32 - 1),
  JS = BigInt(32);
function $4(e, t = !1) {
  return t
    ? { h: Number(e & Qp), l: Number((e >> JS) & Qp) }
    : { h: Number((e >> JS) & Qp) | 0, l: Number(e & Qp) | 0 };
}
function qX(e, t = !1) {
  let n = new Uint32Array(e.length),
    r = new Uint32Array(e.length);
  for (let i = 0; i < e.length; i++) {
    const { h: s, l: o } = $4(e[i], t);
    [n[i], r[i]] = [s, o];
  }
  return [n, r];
}
const YX = (e, t) => (BigInt(e >>> 0) << JS) | BigInt(t >>> 0),
  ZX = (e, t, n) => e >>> n,
  JX = (e, t, n) => (e << (32 - n)) | (t >>> n),
  XX = (e, t, n) => (e >>> n) | (t << (32 - n)),
  QX = (e, t, n) => (e << (32 - n)) | (t >>> n),
  eQ = (e, t, n) => (e << (64 - n)) | (t >>> (n - 32)),
  tQ = (e, t, n) => (e >>> (n - 32)) | (t << (64 - n)),
  nQ = (e, t) => t,
  rQ = (e, t) => e,
  iQ = (e, t, n) => (e << n) | (t >>> (32 - n)),
  sQ = (e, t, n) => (t << n) | (e >>> (32 - n)),
  oQ = (e, t, n) => (t << (n - 32)) | (e >>> (64 - n)),
  aQ = (e, t, n) => (e << (n - 32)) | (t >>> (64 - n));
function cQ(e, t, n, r) {
  const i = (t >>> 0) + (r >>> 0);
  return { h: (e + n + ((i / 2 ** 32) | 0)) | 0, l: i | 0 };
}
const uQ = (e, t, n) => (e >>> 0) + (t >>> 0) + (n >>> 0),
  lQ = (e, t, n, r) => (t + n + r + ((e / 2 ** 32) | 0)) | 0,
  dQ = (e, t, n, r) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0),
  fQ = (e, t, n, r, i) => (t + n + r + i + ((e / 2 ** 32) | 0)) | 0,
  hQ = (e, t, n, r, i) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0) + (i >>> 0),
  pQ = (e, t, n, r, i, s) => (t + n + r + i + s + ((e / 2 ** 32) | 0)) | 0,
  Je = {
    fromBig: $4,
    split: qX,
    toBig: YX,
    shrSH: ZX,
    shrSL: JX,
    rotrSH: XX,
    rotrSL: QX,
    rotrBH: eQ,
    rotrBL: tQ,
    rotr32H: nQ,
    rotr32L: rQ,
    rotlSH: iQ,
    rotlSL: sQ,
    rotlBH: oQ,
    rotlBL: aQ,
    add: cQ,
    add3L: uQ,
    add3H: lQ,
    add4L: dQ,
    add4H: fQ,
    add5H: pQ,
    add5L: hQ,
  },
  [gQ, yQ] = Je.split(
    [
      '0x428a2f98d728ae22',
      '0x7137449123ef65cd',
      '0xb5c0fbcfec4d3b2f',
      '0xe9b5dba58189dbbc',
      '0x3956c25bf348b538',
      '0x59f111f1b605d019',
      '0x923f82a4af194f9b',
      '0xab1c5ed5da6d8118',
      '0xd807aa98a3030242',
      '0x12835b0145706fbe',
      '0x243185be4ee4b28c',
      '0x550c7dc3d5ffb4e2',
      '0x72be5d74f27b896f',
      '0x80deb1fe3b1696b1',
      '0x9bdc06a725c71235',
      '0xc19bf174cf692694',
      '0xe49b69c19ef14ad2',
      '0xefbe4786384f25e3',
      '0x0fc19dc68b8cd5b5',
      '0x240ca1cc77ac9c65',
      '0x2de92c6f592b0275',
      '0x4a7484aa6ea6e483',
      '0x5cb0a9dcbd41fbd4',
      '0x76f988da831153b5',
      '0x983e5152ee66dfab',
      '0xa831c66d2db43210',
      '0xb00327c898fb213f',
      '0xbf597fc7beef0ee4',
      '0xc6e00bf33da88fc2',
      '0xd5a79147930aa725',
      '0x06ca6351e003826f',
      '0x142929670a0e6e70',
      '0x27b70a8546d22ffc',
      '0x2e1b21385c26c926',
      '0x4d2c6dfc5ac42aed',
      '0x53380d139d95b3df',
      '0x650a73548baf63de',
      '0x766a0abb3c77b2a8',
      '0x81c2c92e47edaee6',
      '0x92722c851482353b',
      '0xa2bfe8a14cf10364',
      '0xa81a664bbc423001',
      '0xc24b8b70d0f89791',
      '0xc76c51a30654be30',
      '0xd192e819d6ef5218',
      '0xd69906245565a910',
      '0xf40e35855771202a',
      '0x106aa07032bbd1b8',
      '0x19a4c116b8d2d0c8',
      '0x1e376c085141ab53',
      '0x2748774cdf8eeb99',
      '0x34b0bcb5e19b48a8',
      '0x391c0cb3c5c95a63',
      '0x4ed8aa4ae3418acb',
      '0x5b9cca4f7763e373',
      '0x682e6ff3d6b2b8a3',
      '0x748f82ee5defb2fc',
      '0x78a5636f43172f60',
      '0x84c87814a1f0ab72',
      '0x8cc702081a6439ec',
      '0x90befffa23631e28',
      '0xa4506cebde82bde9',
      '0xbef9a3f7b2c67915',
      '0xc67178f2e372532b',
      '0xca273eceea26619c',
      '0xd186b8c721c0c207',
      '0xeada7dd6cde0eb1e',
      '0xf57d4f7fee6ed178',
      '0x06f067aa72176fba',
      '0x0a637dc5a2c898a6',
      '0x113f9804bef90dae',
      '0x1b710b35131c471b',
      '0x28db77f523047d84',
      '0x32caab7b40c72493',
      '0x3c9ebe0a15c9bebc',
      '0x431d67c49c100d4c',
      '0x4cc5d4becb3e42b6',
      '0x597f299cfc657e2a',
      '0x5fcb6fab3ad6faec',
      '0x6c44198c4a475817',
    ].map((e) => BigInt(e))
  ),
  Mo = new Uint32Array(80),
  Oo = new Uint32Array(80);
let tm = class extends U4 {
    constructor() {
      super(128, 64, 16, !1),
        (this.Ah = 1779033703),
        (this.Al = -205731576),
        (this.Bh = -1150833019),
        (this.Bl = -2067093701),
        (this.Ch = 1013904242),
        (this.Cl = -23791573),
        (this.Dh = -1521486534),
        (this.Dl = 1595750129),
        (this.Eh = 1359893119),
        (this.El = -1377402159),
        (this.Fh = -1694144372),
        (this.Fl = 725511199),
        (this.Gh = 528734635),
        (this.Gl = -79577749),
        (this.Hh = 1541459225),
        (this.Hl = 327033209);
    }
    get() {
      const {
        Ah: t,
        Al: n,
        Bh: r,
        Bl: i,
        Ch: s,
        Cl: o,
        Dh: a,
        Dl: c,
        Eh: u,
        El: l,
        Fh: d,
        Fl: f,
        Gh: h,
        Gl: p,
        Hh: b,
        Hl: w,
      } = this;
      return [t, n, r, i, s, o, a, c, u, l, d, f, h, p, b, w];
    }
    set(t, n, r, i, s, o, a, c, u, l, d, f, h, p, b, w) {
      (this.Ah = t | 0),
        (this.Al = n | 0),
        (this.Bh = r | 0),
        (this.Bl = i | 0),
        (this.Ch = s | 0),
        (this.Cl = o | 0),
        (this.Dh = a | 0),
        (this.Dl = c | 0),
        (this.Eh = u | 0),
        (this.El = l | 0),
        (this.Fh = d | 0),
        (this.Fl = f | 0),
        (this.Gh = h | 0),
        (this.Gl = p | 0),
        (this.Hh = b | 0),
        (this.Hl = w | 0);
    }
    process(t, n) {
      for (let x = 0; x < 16; x++, n += 4)
        (Mo[x] = t.getUint32(n)), (Oo[x] = t.getUint32((n += 4)));
      for (let x = 16; x < 80; x++) {
        const k = Mo[x - 15] | 0,
          j = Oo[x - 15] | 0,
          F = Je.rotrSH(k, j, 1) ^ Je.rotrSH(k, j, 8) ^ Je.shrSH(k, j, 7),
          K = Je.rotrSL(k, j, 1) ^ Je.rotrSL(k, j, 8) ^ Je.shrSL(k, j, 7),
          D = Mo[x - 2] | 0,
          C = Oo[x - 2] | 0,
          B = Je.rotrSH(D, C, 19) ^ Je.rotrBH(D, C, 61) ^ Je.shrSH(D, C, 6),
          E = Je.rotrSL(D, C, 19) ^ Je.rotrBL(D, C, 61) ^ Je.shrSL(D, C, 6),
          y = Je.add4L(K, E, Oo[x - 7], Oo[x - 16]),
          v = Je.add4H(y, F, B, Mo[x - 7], Mo[x - 16]);
        (Mo[x] = v | 0), (Oo[x] = y | 0);
      }
      let {
        Ah: r,
        Al: i,
        Bh: s,
        Bl: o,
        Ch: a,
        Cl: c,
        Dh: u,
        Dl: l,
        Eh: d,
        El: f,
        Fh: h,
        Fl: p,
        Gh: b,
        Gl: w,
        Hh: A,
        Hl: _,
      } = this;
      for (let x = 0; x < 80; x++) {
        const k = Je.rotrSH(d, f, 14) ^ Je.rotrSH(d, f, 18) ^ Je.rotrBH(d, f, 41),
          j = Je.rotrSL(d, f, 14) ^ Je.rotrSL(d, f, 18) ^ Je.rotrBL(d, f, 41),
          F = (d & h) ^ (~d & b),
          K = (f & p) ^ (~f & w),
          D = Je.add5L(_, j, K, yQ[x], Oo[x]),
          C = Je.add5H(D, A, k, F, gQ[x], Mo[x]),
          B = D | 0,
          E = Je.rotrSH(r, i, 28) ^ Je.rotrBH(r, i, 34) ^ Je.rotrBH(r, i, 39),
          y = Je.rotrSL(r, i, 28) ^ Je.rotrBL(r, i, 34) ^ Je.rotrBL(r, i, 39),
          v = (r & s) ^ (r & a) ^ (s & a),
          S = (i & o) ^ (i & c) ^ (o & c);
        (A = b | 0),
          (_ = w | 0),
          (b = h | 0),
          (w = p | 0),
          (h = d | 0),
          (p = f | 0),
          ({ h: d, l: f } = Je.add(u | 0, l | 0, C | 0, B | 0)),
          (u = a | 0),
          (l = c | 0),
          (a = s | 0),
          (c = o | 0),
          (s = r | 0),
          (o = i | 0);
        const T = Je.add3L(B, y, S);
        (r = Je.add3H(T, C, E, v)), (i = T | 0);
      }
      ({ h: r, l: i } = Je.add(this.Ah | 0, this.Al | 0, r | 0, i | 0)),
        ({ h: s, l: o } = Je.add(this.Bh | 0, this.Bl | 0, s | 0, o | 0)),
        ({ h: a, l: c } = Je.add(this.Ch | 0, this.Cl | 0, a | 0, c | 0)),
        ({ h: u, l } = Je.add(this.Dh | 0, this.Dl | 0, u | 0, l | 0)),
        ({ h: d, l: f } = Je.add(this.Eh | 0, this.El | 0, d | 0, f | 0)),
        ({ h, l: p } = Je.add(this.Fh | 0, this.Fl | 0, h | 0, p | 0)),
        ({ h: b, l: w } = Je.add(this.Gh | 0, this.Gl | 0, b | 0, w | 0)),
        ({ h: A, l: _ } = Je.add(this.Hh | 0, this.Hl | 0, A | 0, _ | 0)),
        this.set(r, i, s, o, a, c, u, l, d, f, h, p, b, w, A, _);
    }
    roundClean() {
      Mo.fill(0), Oo.fill(0);
    }
    destroy() {
      this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  },
  bQ = class extends tm {
    constructor() {
      super(),
        (this.Ah = -1942145080),
        (this.Al = 424955298),
        (this.Bh = 1944164710),
        (this.Bl = -1982016298),
        (this.Ch = 502970286),
        (this.Cl = 855612546),
        (this.Dh = 1738396948),
        (this.Dl = 1479516111),
        (this.Eh = 258812777),
        (this.El = 2077511080),
        (this.Fh = 2011393907),
        (this.Fl = 79989058),
        (this.Gh = 1067287976),
        (this.Gl = 1780299464),
        (this.Hh = 286451373),
        (this.Hl = -1848208735),
        (this.outputLen = 28);
    }
  },
  mQ = class extends tm {
    constructor() {
      super(),
        (this.Ah = 573645204),
        (this.Al = -64227540),
        (this.Bh = -1621794909),
        (this.Bl = -934517566),
        (this.Ch = 596883563),
        (this.Cl = 1867755857),
        (this.Dh = -1774684391),
        (this.Dl = 1497426621),
        (this.Eh = -1775747358),
        (this.El = -1467023389),
        (this.Fh = -1101128155),
        (this.Fl = 1401305490),
        (this.Gh = 721525244),
        (this.Gl = 746961066),
        (this.Hh = 246885852),
        (this.Hl = -2117784414),
        (this.outputLen = 32);
    }
  },
  wQ = class extends tm {
    constructor() {
      super(),
        (this.Ah = -876896931),
        (this.Al = -1056596264),
        (this.Bh = 1654270250),
        (this.Bl = 914150663),
        (this.Ch = -1856437926),
        (this.Cl = 812702999),
        (this.Dh = 355462360),
        (this.Dl = -150054599),
        (this.Eh = 1731405415),
        (this.El = -4191439),
        (this.Fh = -1900787065),
        (this.Fl = 1750603025),
        (this.Gh = -619958771),
        (this.Gl = 1694076839),
        (this.Hh = 1203062813),
        (this.Hl = -1090891868),
        (this.outputLen = 48);
    }
  };
const vQ = Ic(() => new tm());
Ic(() => new bQ());
Ic(() => new mQ());
Ic(() => new wQ());
var _Q = RP,
  SQ = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz',
  EQ = _Q(SQ);
const Jn = Sc(EQ),
  AQ = (e, t, n) => (e & t) ^ (~e & n),
  IQ = (e, t, n) => (e & t) ^ (e & n) ^ (t & n),
  TQ = new Uint32Array([
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221,
    3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580,
    3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895,
    666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037,
    2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
    1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298,
  ]),
  Bo = new Uint32Array([
    1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225,
  ]),
  Do = new Uint32Array(64);
let F4 = class extends U4 {
    constructor() {
      super(64, 32, 8, !1),
        (this.A = Bo[0] | 0),
        (this.B = Bo[1] | 0),
        (this.C = Bo[2] | 0),
        (this.D = Bo[3] | 0),
        (this.E = Bo[4] | 0),
        (this.F = Bo[5] | 0),
        (this.G = Bo[6] | 0),
        (this.H = Bo[7] | 0);
    }
    get() {
      const { A: t, B: n, C: r, D: i, E: s, F: o, G: a, H: c } = this;
      return [t, n, r, i, s, o, a, c];
    }
    set(t, n, r, i, s, o, a, c) {
      (this.A = t | 0),
        (this.B = n | 0),
        (this.C = r | 0),
        (this.D = i | 0),
        (this.E = s | 0),
        (this.F = o | 0),
        (this.G = a | 0),
        (this.H = c | 0);
    }
    process(t, n) {
      for (let d = 0; d < 16; d++, n += 4) Do[d] = t.getUint32(n, !1);
      for (let d = 16; d < 64; d++) {
        const f = Do[d - 15],
          h = Do[d - 2],
          p = es(f, 7) ^ es(f, 18) ^ (f >>> 3),
          b = es(h, 17) ^ es(h, 19) ^ (h >>> 10);
        Do[d] = (b + Do[d - 7] + p + Do[d - 16]) | 0;
      }
      let { A: r, B: i, C: s, D: o, E: a, F: c, G: u, H: l } = this;
      for (let d = 0; d < 64; d++) {
        const f = es(a, 6) ^ es(a, 11) ^ es(a, 25),
          h = (l + f + AQ(a, c, u) + TQ[d] + Do[d]) | 0,
          b = ((es(r, 2) ^ es(r, 13) ^ es(r, 22)) + IQ(r, i, s)) | 0;
        (l = u), (u = c), (c = a), (a = (o + h) | 0), (o = s), (s = i), (i = r), (r = (h + b) | 0);
      }
      (r = (r + this.A) | 0),
        (i = (i + this.B) | 0),
        (s = (s + this.C) | 0),
        (o = (o + this.D) | 0),
        (a = (a + this.E) | 0),
        (c = (c + this.F) | 0),
        (u = (u + this.G) | 0),
        (l = (l + this.H) | 0),
        this.set(r, i, s, o, a, c, u, l);
    }
    roundClean() {
      Do.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
    }
  },
  xQ = class extends F4 {
    constructor() {
      super(),
        (this.A = -1056596264),
        (this.B = 914150663),
        (this.C = 812702999),
        (this.D = -150054599),
        (this.E = -4191439),
        (this.F = 1750603025),
        (this.G = 1694076839),
        (this.H = -1090891868),
        (this.outputLen = 28);
    }
  };
const XS = Ic(() => new F4());
Ic(() => new xQ());
var Zn = {},
  kQ = RP,
  CQ = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz',
  PQ = kQ(CQ),
  MQ =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n),
            Object.defineProperty(e, r, {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            });
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  OQ =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  xs =
    (m && m.__decorate) ||
    function (e, t, n, r) {
      var i = arguments.length,
        s = i < 3 ? t : r === null ? (r = Object.getOwnPropertyDescriptor(t, n)) : r,
        o;
      if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function')
        s = Reflect.decorate(e, t, n, r);
      else
        for (var a = e.length - 1; a >= 0; a--)
          (o = e[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(t, n, s) : o(t, n)) || s);
      return i > 3 && s && Object.defineProperty(t, n, s), s;
    },
  BQ =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e) n !== 'default' && Object.hasOwnProperty.call(e, n) && MQ(t, e, n);
      return OQ(t, e), t;
    },
  z4 =
    (m && m.__importDefault) ||
    function (e) {
      return e && e.__esModule ? e : { default: e };
    };
Object.defineProperty(Zn, '__esModule', { value: !0 });
var K4 =
  (Zn.deserializeUnchecked =
  Y4 =
  Zn.deserialize =
  q4 =
  Zn.serialize =
  Zn.BinaryReader =
  Zn.BinaryWriter =
  Zn.BorshError =
  Zn.baseDecode =
  Zn.baseEncode =
    void 0);
const ia = z4(pL()),
  V4 = z4(PQ),
  DQ = BQ(gL),
  RQ = typeof TextDecoder != 'function' ? DQ.TextDecoder : TextDecoder,
  NQ = new RQ('utf-8', { fatal: !0 });
function jQ(e) {
  return typeof e == 'string' && (e = z.from(e, 'utf8')), V4.default.encode(z.from(e));
}
Zn.baseEncode = jQ;
function LQ(e) {
  return z.from(V4.default.decode(e));
}
Zn.baseDecode = LQ;
const sv = 1024;
class br extends Error {
  constructor(t) {
    super(t), (this.fieldPath = []), (this.originalMessage = t);
  }
  addToFieldPath(t) {
    this.fieldPath.splice(0, 0, t),
      (this.message = this.originalMessage + ': ' + this.fieldPath.join('.'));
  }
}
Zn.BorshError = br;
class W4 {
  constructor() {
    (this.buf = z.alloc(sv)), (this.length = 0);
  }
  maybeResize() {
    this.buf.length < 16 + this.length && (this.buf = z.concat([this.buf, z.alloc(sv)]));
  }
  writeU8(t) {
    this.maybeResize(), this.buf.writeUInt8(t, this.length), (this.length += 1);
  }
  writeU16(t) {
    this.maybeResize(), this.buf.writeUInt16LE(t, this.length), (this.length += 2);
  }
  writeU32(t) {
    this.maybeResize(), this.buf.writeUInt32LE(t, this.length), (this.length += 4);
  }
  writeU64(t) {
    this.maybeResize(), this.writeBuffer(z.from(new ia.default(t).toArray('le', 8)));
  }
  writeU128(t) {
    this.maybeResize(), this.writeBuffer(z.from(new ia.default(t).toArray('le', 16)));
  }
  writeU256(t) {
    this.maybeResize(), this.writeBuffer(z.from(new ia.default(t).toArray('le', 32)));
  }
  writeU512(t) {
    this.maybeResize(), this.writeBuffer(z.from(new ia.default(t).toArray('le', 64)));
  }
  writeBuffer(t) {
    (this.buf = z.concat([z.from(this.buf.subarray(0, this.length)), t, z.alloc(sv)])),
      (this.length += t.length);
  }
  writeString(t) {
    this.maybeResize();
    const n = z.from(t, 'utf8');
    this.writeU32(n.length), this.writeBuffer(n);
  }
  writeFixedArray(t) {
    this.writeBuffer(z.from(t));
  }
  writeArray(t, n) {
    this.maybeResize(), this.writeU32(t.length);
    for (const r of t) this.maybeResize(), n(r);
  }
  toArray() {
    return this.buf.subarray(0, this.length);
  }
}
Zn.BinaryWriter = W4;
function ks(e, t, n) {
  const r = n.value;
  n.value = function (...i) {
    try {
      return r.apply(this, i);
    } catch (s) {
      if (s instanceof RangeError) {
        const o = s.code;
        if (['ERR_BUFFER_OUT_OF_BOUNDS', 'ERR_OUT_OF_RANGE'].indexOf(o) >= 0)
          throw new br('Reached the end of buffer when deserializing');
      }
      throw s;
    }
  };
}
class Jr {
  constructor(t) {
    (this.buf = t), (this.offset = 0);
  }
  readU8() {
    const t = this.buf.readUInt8(this.offset);
    return (this.offset += 1), t;
  }
  readU16() {
    const t = this.buf.readUInt16LE(this.offset);
    return (this.offset += 2), t;
  }
  readU32() {
    const t = this.buf.readUInt32LE(this.offset);
    return (this.offset += 4), t;
  }
  readU64() {
    const t = this.readBuffer(8);
    return new ia.default(t, 'le');
  }
  readU128() {
    const t = this.readBuffer(16);
    return new ia.default(t, 'le');
  }
  readU256() {
    const t = this.readBuffer(32);
    return new ia.default(t, 'le');
  }
  readU512() {
    const t = this.readBuffer(64);
    return new ia.default(t, 'le');
  }
  readBuffer(t) {
    if (this.offset + t > this.buf.length)
      throw new br(`Expected buffer length ${t} isn't within bounds`);
    const n = this.buf.slice(this.offset, this.offset + t);
    return (this.offset += t), n;
  }
  readString() {
    const t = this.readU32(),
      n = this.readBuffer(t);
    try {
      return NQ.decode(n);
    } catch (r) {
      throw new br(`Error decoding UTF-8 string: ${r}`);
    }
  }
  readFixedArray(t) {
    return new Uint8Array(this.readBuffer(t));
  }
  readArray(t) {
    const n = this.readU32(),
      r = Array();
    for (let i = 0; i < n; ++i) r.push(t());
    return r;
  }
}
xs([ks], Jr.prototype, 'readU8', null);
xs([ks], Jr.prototype, 'readU16', null);
xs([ks], Jr.prototype, 'readU32', null);
xs([ks], Jr.prototype, 'readU64', null);
xs([ks], Jr.prototype, 'readU128', null);
xs([ks], Jr.prototype, 'readU256', null);
xs([ks], Jr.prototype, 'readU512', null);
xs([ks], Jr.prototype, 'readString', null);
xs([ks], Jr.prototype, 'readFixedArray', null);
xs([ks], Jr.prototype, 'readArray', null);
Zn.BinaryReader = Jr;
function H4(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}
function Ba(e, t, n, r, i) {
  try {
    if (typeof r == 'string') i[`write${H4(r)}`](n);
    else if (r instanceof Array)
      if (typeof r[0] == 'number') {
        if (n.length !== r[0])
          throw new br(`Expecting byte array of length ${r[0]}, but got ${n.length} bytes`);
        i.writeFixedArray(n);
      } else if (r.length === 2 && typeof r[1] == 'number') {
        if (n.length !== r[1])
          throw new br(`Expecting byte array of length ${r[1]}, but got ${n.length} bytes`);
        for (let s = 0; s < r[1]; s++) Ba(e, null, n[s], r[0], i);
      } else
        i.writeArray(n, (s) => {
          Ba(e, t, s, r[0], i);
        });
    else if (r.kind !== void 0)
      switch (r.kind) {
        case 'option': {
          n == null ? i.writeU8(0) : (i.writeU8(1), Ba(e, t, n, r.type, i));
          break;
        }
        case 'map': {
          i.writeU32(n.size),
            n.forEach((s, o) => {
              Ba(e, t, o, r.key, i), Ba(e, t, s, r.value, i);
            });
          break;
        }
        default:
          throw new br(`FieldType ${r} unrecognized`);
      }
    else G4(e, n, i);
  } catch (s) {
    throw (s instanceof br && s.addToFieldPath(t), s);
  }
}
function G4(e, t, n) {
  if (typeof t.borshSerialize == 'function') {
    t.borshSerialize(n);
    return;
  }
  const r = e.get(t.constructor);
  if (!r) throw new br(`Class ${t.constructor.name} is missing in schema`);
  if (r.kind === 'struct')
    r.fields.map(([i, s]) => {
      Ba(e, i, t[i], s, n);
    });
  else if (r.kind === 'enum') {
    const i = t[r.field];
    for (let s = 0; s < r.values.length; ++s) {
      const [o, a] = r.values[s];
      if (o === i) {
        n.writeU8(s), Ba(e, o, t[o], a, n);
        break;
      }
    }
  } else throw new br(`Unexpected schema kind: ${r.kind} for ${t.constructor.name}`);
}
function UQ(e, t, n = W4) {
  const r = new n();
  return G4(e, t, r), r.toArray();
}
var q4 = (Zn.serialize = UQ);
function Da(e, t, n, r) {
  try {
    if (typeof n == 'string') return r[`read${H4(n)}`]();
    if (n instanceof Array) {
      if (typeof n[0] == 'number') return r.readFixedArray(n[0]);
      if (typeof n[1] == 'number') {
        const i = [];
        for (let s = 0; s < n[1]; s++) i.push(Da(e, null, n[0], r));
        return i;
      } else return r.readArray(() => Da(e, t, n[0], r));
    }
    if (n.kind === 'option') return r.readU8() ? Da(e, t, n.type, r) : void 0;
    if (n.kind === 'map') {
      let i = new Map();
      const s = r.readU32();
      for (let o = 0; o < s; o++) {
        const a = Da(e, t, n.key, r),
          c = Da(e, t, n.value, r);
        i.set(a, c);
      }
      return i;
    }
    return dI(e, n, r);
  } catch (i) {
    throw (i instanceof br && i.addToFieldPath(t), i);
  }
}
function dI(e, t, n) {
  if (typeof t.borshDeserialize == 'function') return t.borshDeserialize(n);
  const r = e.get(t);
  if (!r) throw new br(`Class ${t.name} is missing in schema`);
  if (r.kind === 'struct') {
    const i = {};
    for (const [s, o] of e.get(t).fields) i[s] = Da(e, s, o, n);
    return new t(i);
  }
  if (r.kind === 'enum') {
    const i = n.readU8();
    if (i >= r.values.length) throw new br(`Enum index: ${i} is out of range`);
    const [s, o] = r.values[i],
      a = Da(e, s, o, n);
    return new t({ [s]: a });
  }
  throw new br(`Unexpected schema kind: ${r.kind} for ${t.constructor.name}`);
}
function $Q(e, t, n, r = Jr) {
  const i = new r(n),
    s = dI(e, t, i);
  if (i.offset < n.length)
    throw new br(`Unexpected ${n.length - i.offset} bytes after deserialized data`);
  return s;
}
var Y4 = (Zn.deserialize = $Q);
function FQ(e, t, n, r = Jr) {
  const i = new r(n);
  return dI(e, t, i);
}
K4 = Zn.deserializeUnchecked = FQ;
const [Z4, J4, X4] = [[], [], []],
  zQ = BigInt(0),
  hl = BigInt(1),
  KQ = BigInt(2),
  VQ = BigInt(7),
  WQ = BigInt(256),
  HQ = BigInt(113);
for (let e = 0, t = hl, n = 1, r = 0; e < 24; e++) {
  ([n, r] = [r, (2 * n + 3 * r) % 5]),
    Z4.push(2 * (5 * r + n)),
    J4.push((((e + 1) * (e + 2)) / 2) % 64);
  let i = zQ;
  for (let s = 0; s < 7; s++)
    (t = ((t << hl) ^ ((t >> VQ) * HQ)) % WQ), t & KQ && (i ^= hl << ((hl << BigInt(s)) - hl));
  X4.push(i);
}
const [GQ, qQ] = Je.split(X4, !0),
  Dk = (e, t, n) => (n > 32 ? Je.rotlBH(e, t, n) : Je.rotlSH(e, t, n)),
  Rk = (e, t, n) => (n > 32 ? Je.rotlBL(e, t, n) : Je.rotlSL(e, t, n));
function YQ(e, t = 24) {
  const n = new Uint32Array(10);
  for (let r = 24 - t; r < 24; r++) {
    for (let o = 0; o < 10; o++) n[o] = e[o] ^ e[o + 10] ^ e[o + 20] ^ e[o + 30] ^ e[o + 40];
    for (let o = 0; o < 10; o += 2) {
      const a = (o + 8) % 10,
        c = (o + 2) % 10,
        u = n[c],
        l = n[c + 1],
        d = Dk(u, l, 1) ^ n[a],
        f = Rk(u, l, 1) ^ n[a + 1];
      for (let h = 0; h < 50; h += 10) (e[o + h] ^= d), (e[o + h + 1] ^= f);
    }
    let i = e[2],
      s = e[3];
    for (let o = 0; o < 24; o++) {
      const a = J4[o],
        c = Dk(i, s, a),
        u = Rk(i, s, a),
        l = Z4[o];
      (i = e[l]), (s = e[l + 1]), (e[l] = c), (e[l + 1] = u);
    }
    for (let o = 0; o < 50; o += 10) {
      for (let a = 0; a < 10; a++) n[a] = e[o + a];
      for (let a = 0; a < 10; a++) e[o + a] ^= ~n[(a + 2) % 10] & n[(a + 4) % 10];
    }
    (e[0] ^= GQ[r]), (e[1] ^= qQ[r]);
  }
  n.fill(0);
}
class nm extends lI {
  constructor(t, n, r, i = !1, s = 24) {
    if (
      (super(),
      (this.blockLen = t),
      (this.suffix = n),
      (this.outputLen = r),
      (this.enableXOF = i),
      (this.rounds = s),
      (this.pos = 0),
      (this.posOut = 0),
      (this.finished = !1),
      (this.destroyed = !1),
      zr.number(r),
      0 >= this.blockLen || this.blockLen >= 200)
    )
      throw new Error('Sha3 supports only keccak-f1600 function');
    (this.state = new Uint8Array(200)), (this.state32 = KX(this.state));
  }
  keccak() {
    YQ(this.state32, this.rounds), (this.posOut = 0), (this.pos = 0);
  }
  update(t) {
    zr.exists(this);
    const { blockLen: n, state: r } = this;
    t = xd(t);
    const i = t.length;
    for (let s = 0; s < i; ) {
      const o = Math.min(n - this.pos, i - s);
      for (let a = 0; a < o; a++) r[this.pos++] ^= t[s++];
      this.pos === n && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = !0;
    const { state: t, suffix: n, pos: r, blockLen: i } = this;
    (t[r] ^= n), n & 128 && r === i - 1 && this.keccak(), (t[i - 1] ^= 128), this.keccak();
  }
  writeInto(t) {
    zr.exists(this, !1), zr.bytes(t), this.finish();
    const n = this.state,
      { blockLen: r } = this;
    for (let i = 0, s = t.length; i < s; ) {
      this.posOut >= r && this.keccak();
      const o = Math.min(r - this.posOut, s - i);
      t.set(n.subarray(this.posOut, this.posOut + o), i), (this.posOut += o), (i += o);
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF) throw new Error('XOF is not possible for this instance');
    return this.writeInto(t);
  }
  xof(t) {
    return zr.number(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if ((zr.output(t, this), this.finished)) throw new Error('digest() was already called');
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    (this.destroyed = !0), this.state.fill(0);
  }
  _cloneInto(t) {
    const { blockLen: n, suffix: r, outputLen: i, rounds: s, enableXOF: o } = this;
    return (
      t || (t = new nm(n, r, i, o, s)),
      t.state32.set(this.state32),
      (t.pos = this.pos),
      (t.posOut = this.posOut),
      (t.finished = this.finished),
      (t.rounds = s),
      (t.suffix = r),
      (t.outputLen = i),
      (t.enableXOF = o),
      (t.destroyed = this.destroyed),
      t
    );
  }
}
const _a = (e, t, n) => Ic(() => new nm(t, e, n));
_a(6, 144, 224 / 8);
_a(6, 136, 256 / 8);
_a(6, 104, 384 / 8);
_a(6, 72, 512 / 8);
_a(1, 144, 224 / 8);
const Nk = _a(1, 136, 256 / 8);
_a(1, 104, 384 / 8);
_a(1, 72, 512 / 8);
const Q4 = (e, t, n) => HX((r = {}) => new nm(t, e, r.dkLen === void 0 ? n : r.dkLen, !0));
Q4(31, 168, 128 / 8);
Q4(31, 136, 256 / 8);
class eB extends lI {
  constructor(t, n) {
    super(), (this.finished = !1), (this.destroyed = !1), zr.hash(t);
    const r = xd(n);
    if (((this.iHash = t.create()), typeof this.iHash.update != 'function'))
      throw new TypeError('Expected instance of class which extends utils.Hash');
    (this.blockLen = this.iHash.blockLen), (this.outputLen = this.iHash.outputLen);
    const i = this.blockLen,
      s = new Uint8Array(i);
    s.set(r.length > i ? t.create().update(r).digest() : r);
    for (let o = 0; o < s.length; o++) s[o] ^= 54;
    this.iHash.update(s), (this.oHash = t.create());
    for (let o = 0; o < s.length; o++) s[o] ^= 106;
    this.oHash.update(s), s.fill(0);
  }
  update(t) {
    return zr.exists(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    zr.exists(this),
      zr.bytes(t, this.outputLen),
      (this.finished = !0),
      this.iHash.digestInto(t),
      this.oHash.update(t),
      this.oHash.digestInto(t),
      this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n, iHash: r, finished: i, destroyed: s, blockLen: o, outputLen: a } = this;
    return (
      (t = t),
      (t.finished = i),
      (t.destroyed = s),
      (t.blockLen = o),
      (t.outputLen = a),
      (t.oHash = n._cloneInto(t.oHash)),
      (t.iHash = r._cloneInto(t.iHash)),
      t
    );
  }
  destroy() {
    (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
  }
}
const tB = (e, t, n) => new eB(e, t).update(n).digest();
tB.create = (e, t) => new eB(e, t);
Sy.sha512Sync = (...e) => vQ(Sy.concatBytes(...e));
const ZQ = Sy.randomPrivateKey,
  jk = () => {
    const e = Sy.randomPrivateKey(),
      t = Fy(e),
      n = new Uint8Array(64);
    return n.set(e), n.set(t, 32), { publicKey: t, secretKey: n };
  },
  Fy = pA.getPublicKey;
function Lk(e) {
  try {
    return bL.fromHex(e, !0), !0;
  } catch {
    return !1;
  }
}
const fI = (e, t) => pA.sign(e, t.slice(0, 32)),
  JQ = pA.verify,
  ot = (e) =>
    he.isBuffer(e)
      ? e
      : e instanceof Uint8Array
        ? he.from(e.buffer, e.byteOffset, e.byteLength)
        : he.from(e);
class hI {
  constructor(t) {
    Object.assign(this, t);
  }
  encode() {
    return he.from(q4(zl, this));
  }
  static decode(t) {
    return Y4(zl, this, t);
  }
  static decodeUnchecked(t) {
    return K4(zl, this, t);
  }
}
class XQ extends hI {
  constructor(t) {
    if ((super(t), (this.enum = ''), Object.keys(t).length !== 1))
      throw new Error('Enum can only take single value');
    Object.keys(t).map((n) => {
      this.enum = n;
    });
  }
}
const zl = new Map();
let nB;
const rB = 32,
  Gr = 32;
function QQ(e) {
  return e._bn !== void 0;
}
let Uk = 1;
nB = Symbol.toStringTag;
class ge extends hI {
  constructor(t) {
    if ((super({}), (this._bn = void 0), QQ(t))) this._bn = t._bn;
    else {
      if (typeof t == 'string') {
        const n = Jn.decode(t);
        if (n.length != Gr) throw new Error('Invalid public key input');
        this._bn = new Ex(n);
      } else this._bn = new Ex(t);
      if (this._bn.byteLength() > Gr) throw new Error('Invalid public key input');
    }
  }
  static unique() {
    const t = new ge(Uk);
    return (Uk += 1), new ge(t.toBuffer());
  }
  equals(t) {
    return this._bn.eq(t._bn);
  }
  toBase58() {
    return Jn.encode(this.toBytes());
  }
  toJSON() {
    return this.toBase58();
  }
  toBytes() {
    const t = this.toBuffer();
    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  }
  toBuffer() {
    const t = this._bn.toArrayLike(he);
    if (t.length === Gr) return t;
    const n = he.alloc(32);
    return t.copy(n, 32 - t.length), n;
  }
  get [nB]() {
    return `PublicKey(${this.toString()})`;
  }
  toString() {
    return this.toBase58();
  }
  static async createWithSeed(t, n, r) {
    const i = he.concat([t.toBuffer(), he.from(n), r.toBuffer()]),
      s = XS(i);
    return new ge(s);
  }
  static createProgramAddressSync(t, n) {
    let r = he.alloc(0);
    t.forEach(function (s) {
      if (s.length > rB) throw new TypeError('Max seed length exceeded');
      r = he.concat([r, ot(s)]);
    }),
      (r = he.concat([r, n.toBuffer(), he.from('ProgramDerivedAddress')]));
    const i = XS(r);
    if (Lk(i)) throw new Error('Invalid seeds, address must fall off the curve');
    return new ge(i);
  }
  static async createProgramAddress(t, n) {
    return this.createProgramAddressSync(t, n);
  }
  static findProgramAddressSync(t, n) {
    let r = 255,
      i;
    for (; r != 0; ) {
      try {
        const s = t.concat(he.from([r]));
        i = this.createProgramAddressSync(s, n);
      } catch (s) {
        if (s instanceof TypeError) throw s;
        r--;
        continue;
      }
      return [i, r];
    }
    throw new Error('Unable to find a viable program address nonce');
  }
  static async findProgramAddress(t, n) {
    return this.findProgramAddressSync(t, n);
  }
  static isOnCurve(t) {
    const n = new ge(t);
    return Lk(n.toBytes());
  }
}
ge.default = new ge('11111111111111111111111111111111');
zl.set(ge, { kind: 'struct', fields: [['_bn', 'u256']] });
class eee {
  constructor(t) {
    if (((this._publicKey = void 0), (this._secretKey = void 0), t)) {
      const n = ot(t);
      if (t.length !== 64) throw new Error('bad secret key size');
      (this._publicKey = n.slice(32, 64)), (this._secretKey = n.slice(0, 32));
    } else (this._secretKey = ot(ZQ())), (this._publicKey = ot(Fy(this._secretKey)));
  }
  get publicKey() {
    return new ge(this._publicKey);
  }
  get secretKey() {
    return he.concat([this._secretKey, this._publicKey], 64);
  }
}
const tee = new ge('BPFLoader1111111111111111111111111111111111'),
  ua = 1232,
  rm = 127,
  Eu = 64;
class pI extends Error {
  constructor(t) {
    super(`Signature ${t} has expired: block height exceeded.`),
      (this.signature = void 0),
      (this.signature = t);
  }
}
Object.defineProperty(pI.prototype, 'name', {
  value: 'TransactionExpiredBlockheightExceededError',
});
class gI extends Error {
  constructor(t, n) {
    super(
      `Transaction was not confirmed in ${n.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${t} using the Solana Explorer or CLI tools.`
    ),
      (this.signature = void 0),
      (this.signature = t);
  }
}
Object.defineProperty(gI.prototype, 'name', { value: 'TransactionExpiredTimeoutError' });
class Yc extends Error {
  constructor(t) {
    super(`Signature ${t} has expired: the nonce is no longer valid.`),
      (this.signature = void 0),
      (this.signature = t);
  }
}
Object.defineProperty(Yc.prototype, 'name', { value: 'TransactionExpiredNonceInvalidError' });
class rd {
  constructor(t, n) {
    (this.staticAccountKeys = void 0),
      (this.accountKeysFromLookups = void 0),
      (this.staticAccountKeys = t),
      (this.accountKeysFromLookups = n);
  }
  keySegments() {
    const t = [this.staticAccountKeys];
    return (
      this.accountKeysFromLookups &&
        (t.push(this.accountKeysFromLookups.writable),
        t.push(this.accountKeysFromLookups.readonly)),
      t
    );
  }
  get(t) {
    for (const n of this.keySegments()) {
      if (t < n.length) return n[t];
      t -= n.length;
    }
  }
  get length() {
    return this.keySegments().flat().length;
  }
  compileInstructions(t) {
    if (this.length > 256) throw new Error('Account index overflow encountered during compilation');
    const r = new Map();
    this.keySegments()
      .flat()
      .forEach((s, o) => {
        r.set(s.toBase58(), o);
      });
    const i = (s) => {
      const o = r.get(s.toBase58());
      if (o === void 0)
        throw new Error('Encountered an unknown instruction account key during compilation');
      return o;
    };
    return t.map((s) => ({
      programIdIndex: i(s.programId),
      accountKeyIndexes: s.keys.map((o) => i(o.pubkey)),
      data: s.data,
    }));
  }
}
const dt = (e = 'publicKey') => Xt(32, e),
  nee = (e = 'signature') => Xt(64, e),
  $a = (e = 'string') => {
    const t = De([Ne('length'), Ne('lengthPadding'), Xt(Ha(Ne(), -8), 'chars')], e),
      n = t.decode.bind(t),
      r = t.encode.bind(t),
      i = t;
    return (
      (i.decode = (s, o) => n(s, o).chars.toString()),
      (i.encode = (s, o, a) => {
        const c = { chars: he.from(s, 'utf8') };
        return r(c, o, a);
      }),
      (i.alloc = (s) => Ne().span + Ne().span + he.from(s, 'utf8').length),
      i
    );
  },
  ree = (e = 'authorized') => De([dt('staker'), dt('withdrawer')], e),
  iee = (e = 'lockup') => De([ai('unixTimestamp'), ai('epoch'), dt('custodian')], e),
  see = (e = 'voteInit') =>
    De([dt('nodePubkey'), dt('authorizedVoter'), dt('authorizedWithdrawer'), wt('commission')], e),
  oee = (e = 'voteAuthorizeWithSeedArgs') =>
    De(
      [
        Ne('voteAuthorizationType'),
        dt('currentAuthorityDerivedKeyOwnerPubkey'),
        $a('currentAuthorityDerivedKeySeed'),
        dt('newAuthorized'),
      ],
      e
    );
function iB(e, t) {
  const n = (i) => {
    if (i.span >= 0) return i.span;
    if (typeof i.alloc == 'function') return i.alloc(t[i.property]);
    if ('count' in i && 'elementLayout' in i) {
      const s = t[i.property];
      if (Array.isArray(s)) return s.length * n(i.elementLayout);
    } else if ('fields' in i) return iB({ layout: i }, t[i.property]);
    return 0;
  };
  let r = 0;
  return (
    e.layout.fields.forEach((i) => {
      r += n(i);
    }),
    r
  );
}
function Tr(e) {
  let t = 0,
    n = 0;
  for (;;) {
    let r = e.shift();
    if (((t |= (r & 127) << (n * 7)), (n += 1), !(r & 128))) break;
  }
  return t;
}
function $r(e, t) {
  let n = t;
  for (;;) {
    let r = n & 127;
    if (((n >>= 7), n == 0)) {
      e.push(r);
      break;
    } else (r |= 128), e.push(r);
  }
}
function It(e, t) {
  if (!e) throw new Error(t || 'Assertion failed');
}
class im {
  constructor(t, n) {
    (this.payer = void 0), (this.keyMetaMap = void 0), (this.payer = t), (this.keyMetaMap = n);
  }
  static compile(t, n) {
    const r = new Map(),
      i = (o) => {
        const a = o.toBase58();
        let c = r.get(a);
        return (
          c === void 0 && ((c = { isSigner: !1, isWritable: !1, isInvoked: !1 }), r.set(a, c)), c
        );
      },
      s = i(n);
    (s.isSigner = !0), (s.isWritable = !0);
    for (const o of t) {
      i(o.programId).isInvoked = !0;
      for (const a of o.keys) {
        const c = i(a.pubkey);
        c.isSigner || (c.isSigner = a.isSigner), c.isWritable || (c.isWritable = a.isWritable);
      }
    }
    return new im(n, r);
  }
  getMessageComponents() {
    const t = [...this.keyMetaMap.entries()];
    It(t.length <= 256, 'Max static account keys length exceeded');
    const n = t.filter(([, c]) => c.isSigner && c.isWritable),
      r = t.filter(([, c]) => c.isSigner && !c.isWritable),
      i = t.filter(([, c]) => !c.isSigner && c.isWritable),
      s = t.filter(([, c]) => !c.isSigner && !c.isWritable),
      o = {
        numRequiredSignatures: n.length + r.length,
        numReadonlySignedAccounts: r.length,
        numReadonlyUnsignedAccounts: s.length,
      };
    {
      It(n.length > 0, 'Expected at least one writable signer key');
      const [c] = n[0];
      It(c === this.payer.toBase58(), 'Expected first writable signer key to be the fee payer');
    }
    const a = [
      ...n.map(([c]) => new ge(c)),
      ...r.map(([c]) => new ge(c)),
      ...i.map(([c]) => new ge(c)),
      ...s.map(([c]) => new ge(c)),
    ];
    return [o, a];
  }
  extractTableLookup(t) {
    const [n, r] = this.drainKeysFoundInLookupTable(
        t.state.addresses,
        (o) => !o.isSigner && !o.isInvoked && o.isWritable
      ),
      [i, s] = this.drainKeysFoundInLookupTable(
        t.state.addresses,
        (o) => !o.isSigner && !o.isInvoked && !o.isWritable
      );
    if (!(n.length === 0 && i.length === 0))
      return [
        { accountKey: t.key, writableIndexes: n, readonlyIndexes: i },
        { writable: r, readonly: s },
      ];
  }
  drainKeysFoundInLookupTable(t, n) {
    const r = new Array(),
      i = new Array();
    for (const [s, o] of this.keyMetaMap.entries())
      if (n(o)) {
        const a = new ge(s),
          c = t.findIndex((u) => u.equals(a));
        c >= 0 &&
          (It(c < 256, 'Max lookup table index exceeded'),
          r.push(c),
          i.push(a),
          this.keyMetaMap.delete(s));
      }
    return [r, i];
  }
}
class zi {
  constructor(t) {
    (this.header = void 0),
      (this.accountKeys = void 0),
      (this.recentBlockhash = void 0),
      (this.instructions = void 0),
      (this.indexToProgramIds = new Map()),
      (this.header = t.header),
      (this.accountKeys = t.accountKeys.map((n) => new ge(n))),
      (this.recentBlockhash = t.recentBlockhash),
      (this.instructions = t.instructions),
      this.instructions.forEach((n) =>
        this.indexToProgramIds.set(n.programIdIndex, this.accountKeys[n.programIdIndex])
      );
  }
  get version() {
    return 'legacy';
  }
  get staticAccountKeys() {
    return this.accountKeys;
  }
  get compiledInstructions() {
    return this.instructions.map((t) => ({
      programIdIndex: t.programIdIndex,
      accountKeyIndexes: t.accounts,
      data: Jn.decode(t.data),
    }));
  }
  get addressTableLookups() {
    return [];
  }
  getAccountKeys() {
    return new rd(this.staticAccountKeys);
  }
  static compile(t) {
    const n = im.compile(t.instructions, t.payerKey),
      [r, i] = n.getMessageComponents(),
      o = new rd(i)
        .compileInstructions(t.instructions)
        .map((a) => ({
          programIdIndex: a.programIdIndex,
          accounts: a.accountKeyIndexes,
          data: Jn.encode(a.data),
        }));
    return new zi({
      header: r,
      accountKeys: i,
      recentBlockhash: t.recentBlockhash,
      instructions: o,
    });
  }
  isAccountSigner(t) {
    return t < this.header.numRequiredSignatures;
  }
  isAccountWritable(t) {
    const n = this.header.numRequiredSignatures;
    if (t >= this.header.numRequiredSignatures) {
      const r = t - n,
        s = this.accountKeys.length - n - this.header.numReadonlyUnsignedAccounts;
      return r < s;
    } else {
      const r = n - this.header.numReadonlySignedAccounts;
      return t < r;
    }
  }
  isProgramId(t) {
    return this.indexToProgramIds.has(t);
  }
  programIds() {
    return [...this.indexToProgramIds.values()];
  }
  nonProgramIds() {
    return this.accountKeys.filter((t, n) => !this.isProgramId(n));
  }
  serialize() {
    const t = this.accountKeys.length;
    let n = [];
    $r(n, t);
    const r = this.instructions.map((d) => {
      const { accounts: f, programIdIndex: h } = d,
        p = Array.from(Jn.decode(d.data));
      let b = [];
      $r(b, f.length);
      let w = [];
      return (
        $r(w, p.length),
        {
          programIdIndex: h,
          keyIndicesCount: he.from(b),
          keyIndices: f,
          dataLength: he.from(w),
          data: p,
        }
      );
    });
    let i = [];
    $r(i, r.length);
    let s = he.alloc(ua);
    he.from(i).copy(s);
    let o = i.length;
    r.forEach((d) => {
      const h = De([
        wt('programIdIndex'),
        Xt(d.keyIndicesCount.length, 'keyIndicesCount'),
        ur(wt('keyIndex'), d.keyIndices.length, 'keyIndices'),
        Xt(d.dataLength.length, 'dataLength'),
        ur(wt('userdatum'), d.data.length, 'data'),
      ]).encode(d, s, o);
      o += h;
    }),
      (s = s.slice(0, o));
    const a = De([
        Xt(1, 'numRequiredSignatures'),
        Xt(1, 'numReadonlySignedAccounts'),
        Xt(1, 'numReadonlyUnsignedAccounts'),
        Xt(n.length, 'keyCount'),
        ur(dt('key'), t, 'keys'),
        dt('recentBlockhash'),
      ]),
      c = {
        numRequiredSignatures: he.from([this.header.numRequiredSignatures]),
        numReadonlySignedAccounts: he.from([this.header.numReadonlySignedAccounts]),
        numReadonlyUnsignedAccounts: he.from([this.header.numReadonlyUnsignedAccounts]),
        keyCount: he.from(n),
        keys: this.accountKeys.map((d) => ot(d.toBytes())),
        recentBlockhash: Jn.decode(this.recentBlockhash),
      };
    let u = he.alloc(2048);
    const l = a.encode(c, u);
    return s.copy(u, l), u.slice(0, l + s.length);
  }
  static from(t) {
    let n = [...t];
    const r = n.shift();
    if (r !== (r & rm))
      throw new Error(
        'Versioned messages must be deserialized with VersionedMessage.deserialize()'
      );
    const i = n.shift(),
      s = n.shift(),
      o = Tr(n);
    let a = [];
    for (let f = 0; f < o; f++) {
      const h = n.slice(0, Gr);
      (n = n.slice(Gr)), a.push(new ge(he.from(h)));
    }
    const c = n.slice(0, Gr);
    n = n.slice(Gr);
    const u = Tr(n);
    let l = [];
    for (let f = 0; f < u; f++) {
      const h = n.shift(),
        p = Tr(n),
        b = n.slice(0, p);
      n = n.slice(p);
      const w = Tr(n),
        A = n.slice(0, w),
        _ = Jn.encode(he.from(A));
      (n = n.slice(w)), l.push({ programIdIndex: h, accounts: b, data: _ });
    }
    const d = {
      header: {
        numRequiredSignatures: r,
        numReadonlySignedAccounts: i,
        numReadonlyUnsignedAccounts: s,
      },
      recentBlockhash: Jn.encode(he.from(c)),
      accountKeys: a,
      instructions: l,
    };
    return new zi(d);
  }
}
class ic {
  constructor(t) {
    (this.header = void 0),
      (this.staticAccountKeys = void 0),
      (this.recentBlockhash = void 0),
      (this.compiledInstructions = void 0),
      (this.addressTableLookups = void 0),
      (this.header = t.header),
      (this.staticAccountKeys = t.staticAccountKeys),
      (this.recentBlockhash = t.recentBlockhash),
      (this.compiledInstructions = t.compiledInstructions),
      (this.addressTableLookups = t.addressTableLookups);
  }
  get version() {
    return 0;
  }
  get numAccountKeysFromLookups() {
    let t = 0;
    for (const n of this.addressTableLookups)
      t += n.readonlyIndexes.length + n.writableIndexes.length;
    return t;
  }
  getAccountKeys(t) {
    let n;
    if (t && 'accountKeysFromLookups' in t && t.accountKeysFromLookups) {
      if (
        this.numAccountKeysFromLookups !=
        t.accountKeysFromLookups.writable.length + t.accountKeysFromLookups.readonly.length
      )
        throw new Error(
          'Failed to get account keys because of a mismatch in the number of account keys from lookups'
        );
      n = t.accountKeysFromLookups;
    } else if (t && 'addressLookupTableAccounts' in t && t.addressLookupTableAccounts)
      n = this.resolveAddressTableLookups(t.addressLookupTableAccounts);
    else if (this.addressTableLookups.length > 0)
      throw new Error('Failed to get account keys because address table lookups were not resolved');
    return new rd(this.staticAccountKeys, n);
  }
  isAccountSigner(t) {
    return t < this.header.numRequiredSignatures;
  }
  isAccountWritable(t) {
    const n = this.header.numRequiredSignatures,
      r = this.staticAccountKeys.length;
    if (t >= r) {
      const i = t - r,
        s = this.addressTableLookups.reduce((o, a) => o + a.writableIndexes.length, 0);
      return i < s;
    } else if (t >= this.header.numRequiredSignatures) {
      const i = t - n,
        o = r - n - this.header.numReadonlyUnsignedAccounts;
      return i < o;
    } else {
      const i = n - this.header.numReadonlySignedAccounts;
      return t < i;
    }
  }
  resolveAddressTableLookups(t) {
    const n = { writable: [], readonly: [] };
    for (const r of this.addressTableLookups) {
      const i = t.find((s) => s.key.equals(r.accountKey));
      if (!i)
        throw new Error(
          `Failed to find address lookup table account for table key ${r.accountKey.toBase58()}`
        );
      for (const s of r.writableIndexes)
        if (s < i.state.addresses.length) n.writable.push(i.state.addresses[s]);
        else
          throw new Error(
            `Failed to find address for index ${s} in address lookup table ${r.accountKey.toBase58()}`
          );
      for (const s of r.readonlyIndexes)
        if (s < i.state.addresses.length) n.readonly.push(i.state.addresses[s]);
        else
          throw new Error(
            `Failed to find address for index ${s} in address lookup table ${r.accountKey.toBase58()}`
          );
    }
    return n;
  }
  static compile(t) {
    const n = im.compile(t.instructions, t.payerKey),
      r = new Array(),
      i = { writable: new Array(), readonly: new Array() },
      s = t.addressLookupTableAccounts || [];
    for (const l of s) {
      const d = n.extractTableLookup(l);
      if (d !== void 0) {
        const [f, { writable: h, readonly: p }] = d;
        r.push(f), i.writable.push(...h), i.readonly.push(...p);
      }
    }
    const [o, a] = n.getMessageComponents(),
      u = new rd(a, i).compileInstructions(t.instructions);
    return new ic({
      header: o,
      staticAccountKeys: a,
      recentBlockhash: t.recentBlockhash,
      compiledInstructions: u,
      addressTableLookups: r,
    });
  }
  serialize() {
    const t = Array();
    $r(t, this.staticAccountKeys.length);
    const n = this.serializeInstructions(),
      r = Array();
    $r(r, this.compiledInstructions.length);
    const i = this.serializeAddressTableLookups(),
      s = Array();
    $r(s, this.addressTableLookups.length);
    const o = De([
        wt('prefix'),
        De(
          [
            wt('numRequiredSignatures'),
            wt('numReadonlySignedAccounts'),
            wt('numReadonlyUnsignedAccounts'),
          ],
          'header'
        ),
        Xt(t.length, 'staticAccountKeysLength'),
        ur(dt(), this.staticAccountKeys.length, 'staticAccountKeys'),
        dt('recentBlockhash'),
        Xt(r.length, 'instructionsLength'),
        Xt(n.length, 'serializedInstructions'),
        Xt(s.length, 'addressTableLookupsLength'),
        Xt(i.length, 'serializedAddressTableLookups'),
      ]),
      a = new Uint8Array(ua),
      u = o.encode(
        {
          prefix: 128,
          header: this.header,
          staticAccountKeysLength: new Uint8Array(t),
          staticAccountKeys: this.staticAccountKeys.map((l) => l.toBytes()),
          recentBlockhash: Jn.decode(this.recentBlockhash),
          instructionsLength: new Uint8Array(r),
          serializedInstructions: n,
          addressTableLookupsLength: new Uint8Array(s),
          serializedAddressTableLookups: i,
        },
        a
      );
    return a.slice(0, u);
  }
  serializeInstructions() {
    let t = 0;
    const n = new Uint8Array(ua);
    for (const r of this.compiledInstructions) {
      const i = Array();
      $r(i, r.accountKeyIndexes.length);
      const s = Array();
      $r(s, r.data.length);
      const o = De([
        wt('programIdIndex'),
        Xt(i.length, 'encodedAccountKeyIndexesLength'),
        ur(wt(), r.accountKeyIndexes.length, 'accountKeyIndexes'),
        Xt(s.length, 'encodedDataLength'),
        Xt(r.data.length, 'data'),
      ]);
      t += o.encode(
        {
          programIdIndex: r.programIdIndex,
          encodedAccountKeyIndexesLength: new Uint8Array(i),
          accountKeyIndexes: r.accountKeyIndexes,
          encodedDataLength: new Uint8Array(s),
          data: r.data,
        },
        n,
        t
      );
    }
    return n.slice(0, t);
  }
  serializeAddressTableLookups() {
    let t = 0;
    const n = new Uint8Array(ua);
    for (const r of this.addressTableLookups) {
      const i = Array();
      $r(i, r.writableIndexes.length);
      const s = Array();
      $r(s, r.readonlyIndexes.length);
      const o = De([
        dt('accountKey'),
        Xt(i.length, 'encodedWritableIndexesLength'),
        ur(wt(), r.writableIndexes.length, 'writableIndexes'),
        Xt(s.length, 'encodedReadonlyIndexesLength'),
        ur(wt(), r.readonlyIndexes.length, 'readonlyIndexes'),
      ]);
      t += o.encode(
        {
          accountKey: r.accountKey.toBytes(),
          encodedWritableIndexesLength: new Uint8Array(i),
          writableIndexes: r.writableIndexes,
          encodedReadonlyIndexesLength: new Uint8Array(s),
          readonlyIndexes: r.readonlyIndexes,
        },
        n,
        t
      );
    }
    return n.slice(0, t);
  }
  static deserialize(t) {
    let n = [...t];
    const r = n.shift(),
      i = r & rm;
    It(r !== i, 'Expected versioned message but received legacy message');
    const s = i;
    It(s === 0, `Expected versioned message with version 0 but found version ${s}`);
    const o = {
        numRequiredSignatures: n.shift(),
        numReadonlySignedAccounts: n.shift(),
        numReadonlyUnsignedAccounts: n.shift(),
      },
      a = [],
      c = Tr(n);
    for (let p = 0; p < c; p++) a.push(new ge(n.splice(0, Gr)));
    const u = Jn.encode(n.splice(0, Gr)),
      l = Tr(n),
      d = [];
    for (let p = 0; p < l; p++) {
      const b = n.shift(),
        w = Tr(n),
        A = n.splice(0, w),
        _ = Tr(n),
        x = new Uint8Array(n.splice(0, _));
      d.push({ programIdIndex: b, accountKeyIndexes: A, data: x });
    }
    const f = Tr(n),
      h = [];
    for (let p = 0; p < f; p++) {
      const b = new ge(n.splice(0, Gr)),
        w = Tr(n),
        A = n.splice(0, w),
        _ = Tr(n),
        x = n.splice(0, _);
      h.push({ accountKey: b, writableIndexes: A, readonlyIndexes: x });
    }
    return new ic({
      header: o,
      staticAccountKeys: a,
      recentBlockhash: u,
      compiledInstructions: d,
      addressTableLookups: h,
    });
  }
}
const yI = {
  deserializeMessageVersion(e) {
    const t = e[0],
      n = t & rm;
    return n === t ? 'legacy' : n;
  },
  deserialize: (e) => {
    const t = yI.deserializeMessageVersion(e);
    if (t === 'legacy') return zi.from(e);
    if (t === 0) return ic.deserialize(e);
    throw new Error(`Transaction message version ${t} deserialization is not supported`);
  },
};
let Ai;
(function (e) {
  (e[(e.BLOCKHEIGHT_EXCEEDED = 0)] = 'BLOCKHEIGHT_EXCEEDED'),
    (e[(e.PROCESSED = 1)] = 'PROCESSED'),
    (e[(e.TIMED_OUT = 2)] = 'TIMED_OUT'),
    (e[(e.NONCE_INVALID = 3)] = 'NONCE_INVALID');
})(Ai || (Ai = {}));
const aee = he.alloc(Eu).fill(0);
class Lt {
  constructor(t) {
    (this.keys = void 0),
      (this.programId = void 0),
      (this.data = he.alloc(0)),
      (this.programId = t.programId),
      (this.keys = t.keys),
      t.data && (this.data = t.data);
  }
  toJSON() {
    return {
      keys: this.keys.map(({ pubkey: t, isSigner: n, isWritable: r }) => ({
        pubkey: t.toJSON(),
        isSigner: n,
        isWritable: r,
      })),
      programId: this.programId.toJSON(),
      data: [...this.data],
    };
  }
}
let jt = class QS {
  get signature() {
    return this.signatures.length > 0 ? this.signatures[0].signature : null;
  }
  constructor(t) {
    if (
      ((this.signatures = []),
      (this.feePayer = void 0),
      (this.instructions = []),
      (this.recentBlockhash = void 0),
      (this.lastValidBlockHeight = void 0),
      (this.nonceInfo = void 0),
      (this.minNonceContextSlot = void 0),
      (this._message = void 0),
      (this._json = void 0),
      !!t)
    )
      if (
        (t.feePayer && (this.feePayer = t.feePayer),
        t.signatures && (this.signatures = t.signatures),
        Object.prototype.hasOwnProperty.call(t, 'nonceInfo'))
      ) {
        const { minContextSlot: n, nonceInfo: r } = t;
        (this.minNonceContextSlot = n), (this.nonceInfo = r);
      } else if (Object.prototype.hasOwnProperty.call(t, 'lastValidBlockHeight')) {
        const { blockhash: n, lastValidBlockHeight: r } = t;
        (this.recentBlockhash = n), (this.lastValidBlockHeight = r);
      } else {
        const { recentBlockhash: n, nonceInfo: r } = t;
        r && (this.nonceInfo = r), (this.recentBlockhash = n);
      }
  }
  toJSON() {
    return {
      recentBlockhash: this.recentBlockhash || null,
      feePayer: this.feePayer ? this.feePayer.toJSON() : null,
      nonceInfo: this.nonceInfo
        ? {
            nonce: this.nonceInfo.nonce,
            nonceInstruction: this.nonceInfo.nonceInstruction.toJSON(),
          }
        : null,
      instructions: this.instructions.map((t) => t.toJSON()),
      signers: this.signatures.map(({ publicKey: t }) => t.toJSON()),
    };
  }
  add(...t) {
    if (t.length === 0) throw new Error('No instructions');
    return (
      t.forEach((n) => {
        'instructions' in n
          ? (this.instructions = this.instructions.concat(n.instructions))
          : 'data' in n && 'programId' in n && 'keys' in n
            ? this.instructions.push(n)
            : this.instructions.push(new Lt(n));
      }),
      this
    );
  }
  compileMessage() {
    if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json))
      return this._message;
    let t, n;
    if (
      (this.nonceInfo
        ? ((t = this.nonceInfo.nonce),
          this.instructions[0] != this.nonceInfo.nonceInstruction
            ? (n = [this.nonceInfo.nonceInstruction, ...this.instructions])
            : (n = this.instructions))
        : ((t = this.recentBlockhash), (n = this.instructions)),
      !t)
    )
      throw new Error('Transaction recentBlockhash required');
    n.length < 1 && console.warn('No instructions provided');
    let r;
    if (this.feePayer) r = this.feePayer;
    else if (this.signatures.length > 0 && this.signatures[0].publicKey)
      r = this.signatures[0].publicKey;
    else throw new Error('Transaction fee payer required');
    for (let b = 0; b < n.length; b++)
      if (n[b].programId === void 0)
        throw new Error(`Transaction instruction index ${b} has undefined program id`);
    const i = [],
      s = [];
    n.forEach((b) => {
      b.keys.forEach((A) => {
        s.push({ ...A });
      });
      const w = b.programId.toString();
      i.includes(w) || i.push(w);
    }),
      i.forEach((b) => {
        s.push({ pubkey: new ge(b), isSigner: !1, isWritable: !1 });
      });
    const o = [];
    s.forEach((b) => {
      const w = b.pubkey.toString(),
        A = o.findIndex((_) => _.pubkey.toString() === w);
      A > -1
        ? ((o[A].isWritable = o[A].isWritable || b.isWritable),
          (o[A].isSigner = o[A].isSigner || b.isSigner))
        : o.push(b);
    }),
      o.sort(function (b, w) {
        return b.isSigner !== w.isSigner
          ? b.isSigner
            ? -1
            : 1
          : b.isWritable !== w.isWritable
            ? b.isWritable
              ? -1
              : 1
            : b.pubkey.toBase58().localeCompare(w.pubkey.toBase58());
      });
    const a = o.findIndex((b) => b.pubkey.equals(r));
    if (a > -1) {
      const [b] = o.splice(a, 1);
      (b.isSigner = !0), (b.isWritable = !0), o.unshift(b);
    } else o.unshift({ pubkey: r, isSigner: !0, isWritable: !0 });
    for (const b of this.signatures) {
      const w = o.findIndex((A) => A.pubkey.equals(b.publicKey));
      if (w > -1)
        o[w].isSigner ||
          ((o[w].isSigner = !0),
          console.warn(
            'Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release.'
          ));
      else throw new Error(`unknown signer: ${b.publicKey.toString()}`);
    }
    let c = 0,
      u = 0,
      l = 0;
    const d = [],
      f = [];
    o.forEach(({ pubkey: b, isSigner: w, isWritable: A }) => {
      w ? (d.push(b.toString()), (c += 1), A || (u += 1)) : (f.push(b.toString()), A || (l += 1));
    });
    const h = d.concat(f),
      p = n.map((b) => {
        const { data: w, programId: A } = b;
        return {
          programIdIndex: h.indexOf(A.toString()),
          accounts: b.keys.map((_) => h.indexOf(_.pubkey.toString())),
          data: Jn.encode(w),
        };
      });
    return (
      p.forEach((b) => {
        It(b.programIdIndex >= 0), b.accounts.forEach((w) => It(w >= 0));
      }),
      new zi({
        header: {
          numRequiredSignatures: c,
          numReadonlySignedAccounts: u,
          numReadonlyUnsignedAccounts: l,
        },
        accountKeys: h,
        recentBlockhash: t,
        instructions: p,
      })
    );
  }
  _compile() {
    const t = this.compileMessage(),
      n = t.accountKeys.slice(0, t.header.numRequiredSignatures);
    return (
      (this.signatures.length === n.length &&
        this.signatures.every((i, s) => n[s].equals(i.publicKey))) ||
        (this.signatures = n.map((r) => ({ signature: null, publicKey: r }))),
      t
    );
  }
  serializeMessage() {
    return this._compile().serialize();
  }
  async getEstimatedFee(t) {
    return (await t.getFeeForMessage(this.compileMessage())).value;
  }
  setSigners(...t) {
    if (t.length === 0) throw new Error('No signers');
    const n = new Set();
    this.signatures = t
      .filter((r) => {
        const i = r.toString();
        return n.has(i) ? !1 : (n.add(i), !0);
      })
      .map((r) => ({ signature: null, publicKey: r }));
  }
  sign(...t) {
    if (t.length === 0) throw new Error('No signers');
    const n = new Set(),
      r = [];
    for (const s of t) {
      const o = s.publicKey.toString();
      n.has(o) || (n.add(o), r.push(s));
    }
    this.signatures = r.map((s) => ({ signature: null, publicKey: s.publicKey }));
    const i = this._compile();
    this._partialSign(i, ...r);
  }
  partialSign(...t) {
    if (t.length === 0) throw new Error('No signers');
    const n = new Set(),
      r = [];
    for (const s of t) {
      const o = s.publicKey.toString();
      n.has(o) || (n.add(o), r.push(s));
    }
    const i = this._compile();
    this._partialSign(i, ...r);
  }
  _partialSign(t, ...n) {
    const r = t.serialize();
    n.forEach((i) => {
      const s = fI(r, i.secretKey);
      this._addSignature(i.publicKey, ot(s));
    });
  }
  addSignature(t, n) {
    this._compile(), this._addSignature(t, n);
  }
  _addSignature(t, n) {
    It(n.length === 64);
    const r = this.signatures.findIndex((i) => t.equals(i.publicKey));
    if (r < 0) throw new Error(`unknown signer: ${t.toString()}`);
    this.signatures[r].signature = he.from(n);
  }
  verifySignatures(t) {
    return this._verifySignatures(this.serializeMessage(), t === void 0 ? !0 : t);
  }
  _verifySignatures(t, n) {
    for (const { signature: r, publicKey: i } of this.signatures)
      if (r === null) {
        if (n) return !1;
      } else if (!JQ(r, t, i.toBytes())) return !1;
    return !0;
  }
  serialize(t) {
    const { requireAllSignatures: n, verifySignatures: r } = Object.assign(
        { requireAllSignatures: !0, verifySignatures: !0 },
        t
      ),
      i = this.serializeMessage();
    if (r && !this._verifySignatures(i, n)) throw new Error('Signature verification failed');
    return this._serialize(i);
  }
  _serialize(t) {
    const { signatures: n } = this,
      r = [];
    $r(r, n.length);
    const i = r.length + n.length * 64 + t.length,
      s = he.alloc(i);
    return (
      It(n.length < 256),
      he.from(r).copy(s, 0),
      n.forEach(({ signature: o }, a) => {
        o !== null &&
          (It(o.length === 64, 'signature has invalid length'),
          he.from(o).copy(s, r.length + a * 64));
      }),
      t.copy(s, r.length + n.length * 64),
      It(s.length <= ua, `Transaction too large: ${s.length} > ${ua}`),
      s
    );
  }
  get keys() {
    return It(this.instructions.length === 1), this.instructions[0].keys.map((t) => t.pubkey);
  }
  get programId() {
    return It(this.instructions.length === 1), this.instructions[0].programId;
  }
  get data() {
    return It(this.instructions.length === 1), this.instructions[0].data;
  }
  static from(t) {
    let n = [...t];
    const r = Tr(n);
    let i = [];
    for (let s = 0; s < r; s++) {
      const o = n.slice(0, Eu);
      (n = n.slice(Eu)), i.push(Jn.encode(he.from(o)));
    }
    return QS.populate(zi.from(n), i);
  }
  static populate(t, n = []) {
    const r = new QS();
    return (
      (r.recentBlockhash = t.recentBlockhash),
      t.header.numRequiredSignatures > 0 && (r.feePayer = t.accountKeys[0]),
      n.forEach((i, s) => {
        const o = {
          signature: i == Jn.encode(aee) ? null : Jn.decode(i),
          publicKey: t.accountKeys[s],
        };
        r.signatures.push(o);
      }),
      t.instructions.forEach((i) => {
        const s = i.accounts.map((o) => {
          const a = t.accountKeys[o];
          return {
            pubkey: a,
            isSigner:
              r.signatures.some((c) => c.publicKey.toString() === a.toString()) ||
              t.isAccountSigner(o),
            isWritable: t.isAccountWritable(o),
          };
        });
        r.instructions.push(
          new Lt({ keys: s, programId: t.accountKeys[i.programIdIndex], data: Jn.decode(i.data) })
        );
      }),
      (r._message = t),
      (r._json = r.toJSON()),
      r
    );
  }
};
class bI {
  constructor(t) {
    (this.payerKey = void 0),
      (this.instructions = void 0),
      (this.recentBlockhash = void 0),
      (this.payerKey = t.payerKey),
      (this.instructions = t.instructions),
      (this.recentBlockhash = t.recentBlockhash);
  }
  static decompile(t, n) {
    const { header: r, compiledInstructions: i, recentBlockhash: s } = t,
      {
        numRequiredSignatures: o,
        numReadonlySignedAccounts: a,
        numReadonlyUnsignedAccounts: c,
      } = r,
      u = o - a;
    It(u > 0, 'Message header is invalid');
    const l = t.staticAccountKeys.length - o - c;
    It(l >= 0, 'Message header is invalid');
    const d = t.getAccountKeys(n),
      f = d.get(0);
    if (f === void 0)
      throw new Error('Failed to decompile message because no account keys were found');
    const h = [];
    for (const p of i) {
      const b = [];
      for (const A of p.accountKeyIndexes) {
        const _ = d.get(A);
        if (_ === void 0) throw new Error(`Failed to find key for account key index ${A}`);
        const x = A < o;
        let k;
        x
          ? (k = A < u)
          : A < d.staticAccountKeys.length
            ? (k = A - o < l)
            : (k = A - d.staticAccountKeys.length < d.accountKeysFromLookups.writable.length),
          b.push({ pubkey: _, isSigner: A < r.numRequiredSignatures, isWritable: k });
      }
      const w = d.get(p.programIdIndex);
      if (w === void 0)
        throw new Error(`Failed to find program id for program id index ${p.programIdIndex}`);
      h.push(new Lt({ programId: w, data: ot(p.data), keys: b }));
    }
    return new bI({ payerKey: f, instructions: h, recentBlockhash: s });
  }
  compileToLegacyMessage() {
    return zi.compile({
      payerKey: this.payerKey,
      recentBlockhash: this.recentBlockhash,
      instructions: this.instructions,
    });
  }
  compileToV0Message(t) {
    return ic.compile({
      payerKey: this.payerKey,
      recentBlockhash: this.recentBlockhash,
      instructions: this.instructions,
      addressLookupTableAccounts: t,
    });
  }
}
class mI {
  get version() {
    return this.message.version;
  }
  constructor(t, n) {
    if (((this.signatures = void 0), (this.message = void 0), n !== void 0))
      It(
        n.length === t.header.numRequiredSignatures,
        'Expected signatures length to be equal to the number of required signatures'
      ),
        (this.signatures = n);
    else {
      const r = [];
      for (let i = 0; i < t.header.numRequiredSignatures; i++) r.push(new Uint8Array(Eu));
      this.signatures = r;
    }
    this.message = t;
  }
  serialize() {
    const t = this.message.serialize(),
      n = Array();
    $r(n, this.signatures.length);
    const r = De([
        Xt(n.length, 'encodedSignaturesLength'),
        ur(nee(), this.signatures.length, 'signatures'),
        Xt(t.length, 'serializedMessage'),
      ]),
      i = new Uint8Array(2048),
      s = r.encode(
        {
          encodedSignaturesLength: new Uint8Array(n),
          signatures: this.signatures,
          serializedMessage: t,
        },
        i
      );
    return i.slice(0, s);
  }
  static deserialize(t) {
    let n = [...t];
    const r = [],
      i = Tr(n);
    for (let o = 0; o < i; o++) r.push(new Uint8Array(n.splice(0, Eu)));
    const s = yI.deserialize(new Uint8Array(n));
    return new mI(s, r);
  }
  sign(t) {
    const n = this.message.serialize(),
      r = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
    for (const i of t) {
      const s = r.findIndex((o) => o.equals(i.publicKey));
      It(s >= 0, `Cannot sign with non signer key ${i.publicKey.toBase58()}`),
        (this.signatures[s] = fI(n, i.secretKey));
    }
  }
  addSignature(t, n) {
    It(n.byteLength === 64, 'Signature must be 64 bytes long');
    const i = this.message.staticAccountKeys
      .slice(0, this.message.header.numRequiredSignatures)
      .findIndex((s) => s.equals(t));
    It(
      i >= 0,
      `Can not add signature; \`${t.toBase58()}\` is not required to sign this transaction`
    ),
      (this.signatures[i] = n);
  }
}
const us = new ge('SysvarC1ock11111111111111111111111111111111'),
  cee = new ge('SysvarEpochSchedu1e111111111111111111111111'),
  uee = new ge('Sysvar1nstructions1111111111111111111111111'),
  ry = new ge('SysvarRecentB1ockHashes11111111111111111111'),
  Au = new ge('SysvarRent111111111111111111111111111111111'),
  lee = new ge('SysvarRewards111111111111111111111111111111'),
  dee = new ge('SysvarS1otHashes111111111111111111111111111'),
  fee = new ge('SysvarS1otHistory11111111111111111111111111'),
  iy = new ge('SysvarStakeHistory1111111111111111111111111');
async function sy(e, t, n, r) {
  const i = r && {
      skipPreflight: r.skipPreflight,
      preflightCommitment: r.preflightCommitment || r.commitment,
      maxRetries: r.maxRetries,
      minContextSlot: r.minContextSlot,
    },
    s = await e.sendTransaction(t, n, i);
  let o;
  if (t.recentBlockhash != null && t.lastValidBlockHeight != null)
    o = (
      await e.confirmTransaction(
        {
          abortSignal: r == null ? void 0 : r.abortSignal,
          signature: s,
          blockhash: t.recentBlockhash,
          lastValidBlockHeight: t.lastValidBlockHeight,
        },
        r && r.commitment
      )
    ).value;
  else if (t.minNonceContextSlot != null && t.nonceInfo != null) {
    const { nonceInstruction: a } = t.nonceInfo,
      c = a.keys[0].pubkey;
    o = (
      await e.confirmTransaction(
        {
          abortSignal: r == null ? void 0 : r.abortSignal,
          minContextSlot: t.minNonceContextSlot,
          nonceAccountPubkey: c,
          nonceValue: t.nonceInfo.nonce,
          signature: s,
        },
        r && r.commitment
      )
    ).value;
  } else
    (r == null ? void 0 : r.abortSignal) != null &&
      console.warn(
        'sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.'
      ),
      (o = (await e.confirmTransaction(s, r && r.commitment)).value);
  if (o.err) throw new Error(`Transaction ${s} failed (${JSON.stringify(o)})`);
  return s;
}
function Ra(e) {
  return new Promise((t) => setTimeout(t, e));
}
function _t(e, t) {
  const n = e.layout.span >= 0 ? e.layout.span : iB(e, t),
    r = he.alloc(n),
    i = Object.assign({ instruction: e.index }, t);
  return e.layout.encode(i, r), r;
}
function Pt(e, t) {
  let n;
  try {
    n = e.layout.decode(t);
  } catch (r) {
    throw new Error('invalid instruction; ' + r);
  }
  if (n.instruction !== e.index)
    throw new Error(
      `invalid instruction; instruction index mismatch ${n.instruction} != ${e.index}`
    );
  return n;
}
const sB = ir('lamportsPerSignature'),
  oB = De([
    Ne('version'),
    Ne('state'),
    dt('authorizedPubkey'),
    dt('nonce'),
    De([sB], 'feeCalculator'),
  ]),
  eE = oB.span;
class sm {
  constructor(t) {
    (this.authorizedPubkey = void 0),
      (this.nonce = void 0),
      (this.feeCalculator = void 0),
      (this.authorizedPubkey = t.authorizedPubkey),
      (this.nonce = t.nonce),
      (this.feeCalculator = t.feeCalculator);
  }
  static fromAccountData(t) {
    const n = oB.decode(ot(t), 0);
    return new sm({
      authorizedPubkey: new ge(n.authorizedPubkey),
      nonce: new ge(n.nonce).toString(),
      feeCalculator: n.feeCalculator,
    });
  }
}
const hee = (e) => {
    const t = e.decode.bind(e),
      n = e.encode.bind(e);
    return { decode: t, encode: n };
  },
  pee = (e) => (t) => {
    const n = Xt(e, t),
      { encode: r, decode: i } = hee(n),
      s = n;
    return (
      (s.decode = (o, a) => {
        const c = i(o, a);
        return mL(he.from(c));
      }),
      (s.encode = (o, a, c) => {
        const u = LP(o, e);
        return r(u, a, c);
      }),
      s
    );
  },
  Iu = pee(8);
class gee {
  constructor() {}
  static decodeInstructionType(t) {
    this.checkProgramId(t.programId);
    const r = Ne('instruction').decode(t.data);
    let i;
    for (const [s, o] of Object.entries(zt))
      if (o.index == r) {
        i = s;
        break;
      }
    if (!i) throw new Error('Instruction type incorrect; not a SystemInstruction');
    return i;
  }
  static decodeCreateAccount(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
    const { lamports: n, space: r, programId: i } = Pt(zt.Create, t.data);
    return {
      fromPubkey: t.keys[0].pubkey,
      newAccountPubkey: t.keys[1].pubkey,
      lamports: n,
      space: r,
      programId: new ge(i),
    };
  }
  static decodeTransfer(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
    const { lamports: n } = Pt(zt.Transfer, t.data);
    return { fromPubkey: t.keys[0].pubkey, toPubkey: t.keys[1].pubkey, lamports: n };
  }
  static decodeTransferWithSeed(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
    const { lamports: n, seed: r, programId: i } = Pt(zt.TransferWithSeed, t.data);
    return {
      fromPubkey: t.keys[0].pubkey,
      basePubkey: t.keys[1].pubkey,
      toPubkey: t.keys[2].pubkey,
      lamports: n,
      seed: r,
      programId: new ge(i),
    };
  }
  static decodeAllocate(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 1);
    const { space: n } = Pt(zt.Allocate, t.data);
    return { accountPubkey: t.keys[0].pubkey, space: n };
  }
  static decodeAllocateWithSeed(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 1);
    const { base: n, seed: r, space: i, programId: s } = Pt(zt.AllocateWithSeed, t.data);
    return {
      accountPubkey: t.keys[0].pubkey,
      basePubkey: new ge(n),
      seed: r,
      space: i,
      programId: new ge(s),
    };
  }
  static decodeAssign(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 1);
    const { programId: n } = Pt(zt.Assign, t.data);
    return { accountPubkey: t.keys[0].pubkey, programId: new ge(n) };
  }
  static decodeAssignWithSeed(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 1);
    const { base: n, seed: r, programId: i } = Pt(zt.AssignWithSeed, t.data);
    return {
      accountPubkey: t.keys[0].pubkey,
      basePubkey: new ge(n),
      seed: r,
      programId: new ge(i),
    };
  }
  static decodeCreateWithSeed(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
    const { base: n, seed: r, lamports: i, space: s, programId: o } = Pt(zt.CreateWithSeed, t.data);
    return {
      fromPubkey: t.keys[0].pubkey,
      newAccountPubkey: t.keys[1].pubkey,
      basePubkey: new ge(n),
      seed: r,
      lamports: i,
      space: s,
      programId: new ge(o),
    };
  }
  static decodeNonceInitialize(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
    const { authorized: n } = Pt(zt.InitializeNonceAccount, t.data);
    return { noncePubkey: t.keys[0].pubkey, authorizedPubkey: new ge(n) };
  }
  static decodeNonceAdvance(t) {
    return (
      this.checkProgramId(t.programId),
      this.checkKeyLength(t.keys, 3),
      Pt(zt.AdvanceNonceAccount, t.data),
      { noncePubkey: t.keys[0].pubkey, authorizedPubkey: t.keys[2].pubkey }
    );
  }
  static decodeNonceWithdraw(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 5);
    const { lamports: n } = Pt(zt.WithdrawNonceAccount, t.data);
    return {
      noncePubkey: t.keys[0].pubkey,
      toPubkey: t.keys[1].pubkey,
      authorizedPubkey: t.keys[4].pubkey,
      lamports: n,
    };
  }
  static decodeNonceAuthorize(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
    const { authorized: n } = Pt(zt.AuthorizeNonceAccount, t.data);
    return {
      noncePubkey: t.keys[0].pubkey,
      authorizedPubkey: t.keys[1].pubkey,
      newAuthorizedPubkey: new ge(n),
    };
  }
  static checkProgramId(t) {
    if (!t.equals(Qn.programId))
      throw new Error('invalid instruction; programId is not SystemProgram');
  }
  static checkKeyLength(t, n) {
    if (t.length < n)
      throw new Error(`invalid instruction; found ${t.length} keys, expected at least ${n}`);
  }
}
const zt = Object.freeze({
  Create: {
    index: 0,
    layout: De([Ne('instruction'), ai('lamports'), ai('space'), dt('programId')]),
  },
  Assign: { index: 1, layout: De([Ne('instruction'), dt('programId')]) },
  Transfer: { index: 2, layout: De([Ne('instruction'), Iu('lamports')]) },
  CreateWithSeed: {
    index: 3,
    layout: De([
      Ne('instruction'),
      dt('base'),
      $a('seed'),
      ai('lamports'),
      ai('space'),
      dt('programId'),
    ]),
  },
  AdvanceNonceAccount: { index: 4, layout: De([Ne('instruction')]) },
  WithdrawNonceAccount: { index: 5, layout: De([Ne('instruction'), ai('lamports')]) },
  InitializeNonceAccount: { index: 6, layout: De([Ne('instruction'), dt('authorized')]) },
  AuthorizeNonceAccount: { index: 7, layout: De([Ne('instruction'), dt('authorized')]) },
  Allocate: { index: 8, layout: De([Ne('instruction'), ai('space')]) },
  AllocateWithSeed: {
    index: 9,
    layout: De([Ne('instruction'), dt('base'), $a('seed'), ai('space'), dt('programId')]),
  },
  AssignWithSeed: {
    index: 10,
    layout: De([Ne('instruction'), dt('base'), $a('seed'), dt('programId')]),
  },
  TransferWithSeed: {
    index: 11,
    layout: De([Ne('instruction'), Iu('lamports'), $a('seed'), dt('programId')]),
  },
  UpgradeNonceAccount: { index: 12, layout: De([Ne('instruction')]) },
});
class Qn {
  constructor() {}
  static createAccount(t) {
    const n = zt.Create,
      r = _t(n, { lamports: t.lamports, space: t.space, programId: ot(t.programId.toBuffer()) });
    return new Lt({
      keys: [
        { pubkey: t.fromPubkey, isSigner: !0, isWritable: !0 },
        { pubkey: t.newAccountPubkey, isSigner: !0, isWritable: !0 },
      ],
      programId: this.programId,
      data: r,
    });
  }
  static transfer(t) {
    let n, r;
    if ('basePubkey' in t) {
      const i = zt.TransferWithSeed;
      (n = _t(i, {
        lamports: BigInt(t.lamports),
        seed: t.seed,
        programId: ot(t.programId.toBuffer()),
      })),
        (r = [
          { pubkey: t.fromPubkey, isSigner: !1, isWritable: !0 },
          { pubkey: t.basePubkey, isSigner: !0, isWritable: !1 },
          { pubkey: t.toPubkey, isSigner: !1, isWritable: !0 },
        ]);
    } else {
      const i = zt.Transfer;
      (n = _t(i, { lamports: BigInt(t.lamports) })),
        (r = [
          { pubkey: t.fromPubkey, isSigner: !0, isWritable: !0 },
          { pubkey: t.toPubkey, isSigner: !1, isWritable: !0 },
        ]);
    }
    return new Lt({ keys: r, programId: this.programId, data: n });
  }
  static assign(t) {
    let n, r;
    if ('basePubkey' in t) {
      const i = zt.AssignWithSeed;
      (n = _t(i, {
        base: ot(t.basePubkey.toBuffer()),
        seed: t.seed,
        programId: ot(t.programId.toBuffer()),
      })),
        (r = [
          { pubkey: t.accountPubkey, isSigner: !1, isWritable: !0 },
          { pubkey: t.basePubkey, isSigner: !0, isWritable: !1 },
        ]);
    } else {
      const i = zt.Assign;
      (n = _t(i, { programId: ot(t.programId.toBuffer()) })),
        (r = [{ pubkey: t.accountPubkey, isSigner: !0, isWritable: !0 }]);
    }
    return new Lt({ keys: r, programId: this.programId, data: n });
  }
  static createAccountWithSeed(t) {
    const n = zt.CreateWithSeed,
      r = _t(n, {
        base: ot(t.basePubkey.toBuffer()),
        seed: t.seed,
        lamports: t.lamports,
        space: t.space,
        programId: ot(t.programId.toBuffer()),
      });
    let i = [
      { pubkey: t.fromPubkey, isSigner: !0, isWritable: !0 },
      { pubkey: t.newAccountPubkey, isSigner: !1, isWritable: !0 },
    ];
    return (
      t.basePubkey != t.fromPubkey &&
        i.push({ pubkey: t.basePubkey, isSigner: !0, isWritable: !1 }),
      new Lt({ keys: i, programId: this.programId, data: r })
    );
  }
  static createNonceAccount(t) {
    const n = new jt();
    'basePubkey' in t && 'seed' in t
      ? n.add(
          Qn.createAccountWithSeed({
            fromPubkey: t.fromPubkey,
            newAccountPubkey: t.noncePubkey,
            basePubkey: t.basePubkey,
            seed: t.seed,
            lamports: t.lamports,
            space: eE,
            programId: this.programId,
          })
        )
      : n.add(
          Qn.createAccount({
            fromPubkey: t.fromPubkey,
            newAccountPubkey: t.noncePubkey,
            lamports: t.lamports,
            space: eE,
            programId: this.programId,
          })
        );
    const r = { noncePubkey: t.noncePubkey, authorizedPubkey: t.authorizedPubkey };
    return n.add(this.nonceInitialize(r)), n;
  }
  static nonceInitialize(t) {
    const n = zt.InitializeNonceAccount,
      r = _t(n, { authorized: ot(t.authorizedPubkey.toBuffer()) }),
      i = {
        keys: [
          { pubkey: t.noncePubkey, isSigner: !1, isWritable: !0 },
          { pubkey: ry, isSigner: !1, isWritable: !1 },
          { pubkey: Au, isSigner: !1, isWritable: !1 },
        ],
        programId: this.programId,
        data: r,
      };
    return new Lt(i);
  }
  static nonceAdvance(t) {
    const n = zt.AdvanceNonceAccount,
      r = _t(n),
      i = {
        keys: [
          { pubkey: t.noncePubkey, isSigner: !1, isWritable: !0 },
          { pubkey: ry, isSigner: !1, isWritable: !1 },
          { pubkey: t.authorizedPubkey, isSigner: !0, isWritable: !1 },
        ],
        programId: this.programId,
        data: r,
      };
    return new Lt(i);
  }
  static nonceWithdraw(t) {
    const n = zt.WithdrawNonceAccount,
      r = _t(n, { lamports: t.lamports });
    return new Lt({
      keys: [
        { pubkey: t.noncePubkey, isSigner: !1, isWritable: !0 },
        { pubkey: t.toPubkey, isSigner: !1, isWritable: !0 },
        { pubkey: ry, isSigner: !1, isWritable: !1 },
        { pubkey: Au, isSigner: !1, isWritable: !1 },
        { pubkey: t.authorizedPubkey, isSigner: !0, isWritable: !1 },
      ],
      programId: this.programId,
      data: r,
    });
  }
  static nonceAuthorize(t) {
    const n = zt.AuthorizeNonceAccount,
      r = _t(n, { authorized: ot(t.newAuthorizedPubkey.toBuffer()) });
    return new Lt({
      keys: [
        { pubkey: t.noncePubkey, isSigner: !1, isWritable: !0 },
        { pubkey: t.authorizedPubkey, isSigner: !0, isWritable: !1 },
      ],
      programId: this.programId,
      data: r,
    });
  }
  static allocate(t) {
    let n, r;
    if ('basePubkey' in t) {
      const i = zt.AllocateWithSeed;
      (n = _t(i, {
        base: ot(t.basePubkey.toBuffer()),
        seed: t.seed,
        space: t.space,
        programId: ot(t.programId.toBuffer()),
      })),
        (r = [
          { pubkey: t.accountPubkey, isSigner: !1, isWritable: !0 },
          { pubkey: t.basePubkey, isSigner: !0, isWritable: !1 },
        ]);
    } else {
      const i = zt.Allocate;
      (n = _t(i, { space: t.space })),
        (r = [{ pubkey: t.accountPubkey, isSigner: !0, isWritable: !0 }]);
    }
    return new Lt({ keys: r, programId: this.programId, data: n });
  }
}
Qn.programId = new ge('11111111111111111111111111111111');
const yee = ua - 300;
class sc {
  constructor() {}
  static getMinNumSignatures(t) {
    return 2 * (Math.ceil(t / sc.chunkSize) + 1 + 1);
  }
  static async load(t, n, r, i, s) {
    {
      const d = await t.getMinimumBalanceForRentExemption(s.length),
        f = await t.getAccountInfo(r.publicKey, 'confirmed');
      let h = null;
      if (f !== null) {
        if (f.executable)
          return console.error('Program load failed, account is already executable'), !1;
        f.data.length !== s.length &&
          ((h = h || new jt()),
          h.add(Qn.allocate({ accountPubkey: r.publicKey, space: s.length }))),
          f.owner.equals(i) ||
            ((h = h || new jt()), h.add(Qn.assign({ accountPubkey: r.publicKey, programId: i }))),
          f.lamports < d &&
            ((h = h || new jt()),
            h.add(
              Qn.transfer({
                fromPubkey: n.publicKey,
                toPubkey: r.publicKey,
                lamports: d - f.lamports,
              })
            ));
      } else
        h = new jt().add(
          Qn.createAccount({
            fromPubkey: n.publicKey,
            newAccountPubkey: r.publicKey,
            lamports: d > 0 ? d : 1,
            space: s.length,
            programId: i,
          })
        );
      h !== null && (await sy(t, h, [n, r], { commitment: 'confirmed' }));
    }
    const o = De([
        Ne('instruction'),
        Ne('offset'),
        Ne('bytesLength'),
        Ne('bytesLengthPadding'),
        ur(wt('byte'), Ha(Ne(), -8), 'bytes'),
      ]),
      a = sc.chunkSize;
    let c = 0,
      u = s,
      l = [];
    for (; u.length > 0; ) {
      const d = u.slice(0, a),
        f = he.alloc(a + 16);
      o.encode({ instruction: 0, offset: c, bytes: d, bytesLength: 0, bytesLengthPadding: 0 }, f);
      const h = new jt().add({
        keys: [{ pubkey: r.publicKey, isSigner: !0, isWritable: !0 }],
        programId: i,
        data: f,
      });
      l.push(sy(t, h, [n, r], { commitment: 'confirmed' })),
        t._rpcEndpoint.includes('solana.com') && (await Ra(1e3 / 4)),
        (c += a),
        (u = u.slice(a));
    }
    await Promise.all(l);
    {
      const d = De([Ne('instruction')]),
        f = he.alloc(d.span);
      d.encode({ instruction: 1 }, f);
      const h = new jt().add({
        keys: [
          { pubkey: r.publicKey, isSigner: !0, isWritable: !0 },
          { pubkey: Au, isSigner: !1, isWritable: !1 },
        ],
        programId: i,
        data: f,
      });
      await sy(t, h, [n, r], { commitment: 'confirmed' });
    }
    return !0;
  }
}
sc.chunkSize = yee;
const bee = new ge('BPFLoader2111111111111111111111111111111111');
class mee {
  static getMinNumSignatures(t) {
    return sc.getMinNumSignatures(t);
  }
  static load(t, n, r, i, s) {
    return sc.load(t, n, r, s, i);
  }
}
var wee = Object.prototype.toString,
  vee =
    Object.keys ||
    function (e) {
      var t = [];
      for (var n in e) t.push(n);
      return t;
    };
function Nl(e, t) {
  var n, r, i, s, o, a, c;
  if (e === !0) return 'true';
  if (e === !1) return 'false';
  switch (typeof e) {
    case 'object':
      if (e === null) return null;
      if (e.toJSON && typeof e.toJSON == 'function') return Nl(e.toJSON(), t);
      if (((c = wee.call(e)), c === '[object Array]')) {
        for (i = '[', r = e.length - 1, n = 0; n < r; n++) i += Nl(e[n], !0) + ',';
        return r > -1 && (i += Nl(e[n], !0)), i + ']';
      } else if (c === '[object Object]') {
        for (s = vee(e).sort(), r = s.length, i = '', n = 0; n < r; )
          (o = s[n]),
            (a = Nl(e[o], !1)),
            a !== void 0 && (i && (i += ','), (i += JSON.stringify(o) + ':' + a)),
            n++;
        return '{' + i + '}';
      } else return JSON.stringify(e);
    case 'function':
    case 'undefined':
      return t ? null : void 0;
    case 'string':
      return JSON.stringify(e);
    default:
      return isFinite(e) ? e : null;
  }
}
var _ee = function (e) {
    var t = Nl(e, !1);
    if (t !== void 0) return '' + t;
  },
  $k = _ee;
const pl = 32;
function ov(e) {
  let t = 0;
  for (; e > 1; ) (e /= 2), t++;
  return t;
}
function See(e) {
  return e === 0
    ? 1
    : (e--,
      (e |= e >> 1),
      (e |= e >> 2),
      (e |= e >> 4),
      (e |= e >> 8),
      (e |= e >> 16),
      (e |= e >> 32),
      e + 1);
}
class aB {
  constructor(t, n, r, i, s) {
    (this.slotsPerEpoch = void 0),
      (this.leaderScheduleSlotOffset = void 0),
      (this.warmup = void 0),
      (this.firstNormalEpoch = void 0),
      (this.firstNormalSlot = void 0),
      (this.slotsPerEpoch = t),
      (this.leaderScheduleSlotOffset = n),
      (this.warmup = r),
      (this.firstNormalEpoch = i),
      (this.firstNormalSlot = s);
  }
  getEpoch(t) {
    return this.getEpochAndSlotIndex(t)[0];
  }
  getEpochAndSlotIndex(t) {
    if (t < this.firstNormalSlot) {
      const n = ov(See(t + pl + 1)) - ov(pl) - 1,
        r = this.getSlotsInEpoch(n),
        i = t - (r - pl);
      return [n, i];
    } else {
      const n = t - this.firstNormalSlot,
        r = Math.floor(n / this.slotsPerEpoch),
        i = this.firstNormalEpoch + r,
        s = n % this.slotsPerEpoch;
      return [i, s];
    }
  }
  getFirstSlotInEpoch(t) {
    return t <= this.firstNormalEpoch
      ? (Math.pow(2, t) - 1) * pl
      : (t - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;
  }
  getLastSlotInEpoch(t) {
    return this.getFirstSlotInEpoch(t) + this.getSlotsInEpoch(t) - 1;
  }
  getSlotsInEpoch(t) {
    return t < this.firstNormalEpoch ? Math.pow(2, t + ov(pl)) : this.slotsPerEpoch;
  }
}
class tE extends Error {
  constructor(t, n) {
    super(t), (this.logs = void 0), (this.logs = n);
  }
}
const Eee = {
  JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
  JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,
  JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
  JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
  JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,
  JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
  JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
  JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
  JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
  JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
  JSON_RPC_SCAN_ERROR: -32012,
  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
  JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
  JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
  JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016,
};
class Ue extends Error {
  constructor({ code: t, message: n, data: r }, i) {
    super(i != null ? `${i}: ${n}` : n),
      (this.code = void 0),
      (this.data = void 0),
      (this.code = t),
      (this.data = r),
      (this.name = 'SolanaJSONRPCError');
  }
}
var Aee = globalThis.fetch;
class Iee extends wL {
  constructor(t, n, r) {
    const i = (s) => {
      const o = EL(s, {
        autoconnect: !0,
        max_reconnects: 5,
        reconnect: !0,
        reconnect_interval: 1e3,
        ...n,
      });
      return 'socket' in o ? (this.underlyingSocket = o.socket) : (this.underlyingSocket = o), o;
    };
    super(i, t, n, r), (this.underlyingSocket = void 0);
  }
  call(...t) {
    var r;
    const n = (r = this.underlyingSocket) == null ? void 0 : r.readyState;
    return n === 1
      ? super.call(...t)
      : Promise.reject(
          new Error(
            'Tried to call a JSON-RPC method `' +
              t[0] +
              '` but the socket was not `CONNECTING` or `OPEN` (`readyState` was ' +
              n +
              ')'
          )
        );
  }
  notify(...t) {
    var r;
    const n = (r = this.underlyingSocket) == null ? void 0 : r.readyState;
    return n === 1
      ? super.notify(...t)
      : Promise.reject(
          new Error(
            'Tried to send a JSON-RPC notification `' +
              t[0] +
              '` but the socket was not `CONNECTING` or `OPEN` (`readyState` was ' +
              n +
              ')'
          )
        );
  }
}
const Tee = 160,
  xee = 64,
  kee = Tee / xee,
  Cee = 1e3 / kee;
function Pee(e, t) {
  let n;
  try {
    n = e.layout.decode(t);
  } catch (r) {
    throw new Error('invalid instruction; ' + r);
  }
  if (n.typeIndex !== e.index)
    throw new Error(`invalid account data; account type mismatch ${n.typeIndex} != ${e.index}`);
  return n;
}
const Fk = 56;
class nE {
  constructor(t) {
    (this.key = void 0), (this.state = void 0), (this.key = t.key), (this.state = t.state);
  }
  isActive() {
    const t = BigInt('0xffffffffffffffff');
    return this.state.deactivationSlot === t;
  }
  static deserialize(t) {
    const n = Pee(Mee, t),
      r = t.length - Fk;
    It(r >= 0, 'lookup table is invalid'), It(r % 32 === 0, 'lookup table is invalid');
    const i = r / 32,
      { addresses: s } = De([ur(dt(), i, 'addresses')]).decode(t.slice(Fk));
    return {
      deactivationSlot: n.deactivationSlot,
      lastExtendedSlot: n.lastExtendedSlot,
      lastExtendedSlotStartIndex: n.lastExtendedStartIndex,
      authority: n.authority.length !== 0 ? new ge(n.authority[0]) : void 0,
      addresses: s.map((o) => new ge(o)),
    };
  }
}
const Mee = {
    index: 1,
    layout: De([
      Ne('typeIndex'),
      Iu('deactivationSlot'),
      ir('lastExtendedSlot'),
      wt('lastExtendedStartIndex'),
      wt(),
      ur(dt(), Ha(wt(), -1), 'authority'),
    ]),
  },
  Oee = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
function Bee(e) {
  const t = e.match(Oee);
  if (t == null) throw TypeError(`Failed to validate endpoint URL \`${e}\``);
  const [n, r, i, s] = t,
    o = e.startsWith('https:') ? 'wss:' : 'ws:',
    a = i == null ? null : parseInt(i.slice(1), 10),
    c = a == null ? '' : `:${a + 1}`;
  return `${o}//${r}${c}${s}`;
}
const Nn = hd(hA(ge), pe(), (e) => new ge(e)),
  cB = fA([pe(), rn('base64')]),
  wI = hd(hA(he), cB, (e) => he.from(e[0], 'base64')),
  uB = 30 * 1e3;
function Dee(e) {
  if (/^https?:/.test(e) === !1)
    throw new TypeError('Endpoint URL must start with `http:` or `https:`.');
  return e;
}
function tn(e) {
  let t, n;
  if (typeof e == 'string') t = e;
  else if (e) {
    const { commitment: r, ...i } = e;
    (t = r), (n = i);
  }
  return { commitment: t, config: n };
}
function lB(e) {
  return Or([
    ue({ jsonrpc: rn('2.0'), id: pe(), result: e }),
    ue({ jsonrpc: rn('2.0'), id: pe(), error: ue({ code: pd(), message: pe(), data: He(yL()) }) }),
  ]);
}
const Ree = lB(pd());
function ct(e) {
  return hd(lB(e), Ree, (t) => ('error' in t ? t : { ...t, result: me(t.result, e) }));
}
function Dn(e) {
  return ct(ue({ context: ue({ slot: Q() }), value: e }));
}
function om(e) {
  return ue({ context: ue({ slot: Q() }), value: e });
}
function av(e, t) {
  return e === 0
    ? new ic({
        header: t.header,
        staticAccountKeys: t.accountKeys.map((n) => new ge(n)),
        recentBlockhash: t.recentBlockhash,
        compiledInstructions: t.instructions.map((n) => ({
          programIdIndex: n.programIdIndex,
          accountKeyIndexes: n.accounts,
          data: Jn.decode(n.data),
        })),
        addressTableLookups: t.addressTableLookups,
      })
    : new zi(t);
}
const Nee = ue({ foundation: Q(), foundationTerm: Q(), initial: Q(), taper: Q(), terminal: Q() }),
  jee = ct(
    Ae(
      Ee(
        ue({
          epoch: Q(),
          effectiveSlot: Q(),
          amount: Q(),
          postBalance: Q(),
          commission: He(Ee(Q())),
        })
      )
    )
  ),
  Lee = ue({ total: Q(), validator: Q(), foundation: Q(), epoch: Q() }),
  Uee = ue({
    epoch: Q(),
    slotIndex: Q(),
    slotsInEpoch: Q(),
    absoluteSlot: Q(),
    blockHeight: He(Q()),
    transactionCount: He(Q()),
  }),
  $ee = ue({
    slotsPerEpoch: Q(),
    leaderScheduleSlotOffset: Q(),
    warmup: so(),
    firstNormalEpoch: Q(),
    firstNormalSlot: Q(),
  }),
  Fee = NP(pe(), Ae(Q())),
  Tc = Ee(Or([ue({}), pe()])),
  zee = ue({ err: Tc }),
  Kee = rn('receivedSignature'),
  Vee = ue({ 'solana-core': pe(), 'feature-set': He(Q()) }),
  zk = Dn(
    ue({
      err: Ee(Or([ue({}), pe()])),
      logs: Ee(Ae(pe())),
      accounts: He(
        Ee(
          Ae(
            Ee(
              ue({
                executable: so(),
                owner: pe(),
                lamports: Q(),
                data: Ae(pe()),
                rentEpoch: He(Q()),
              })
            )
          )
        )
      ),
      unitsConsumed: He(Q()),
      returnData: He(Ee(ue({ programId: pe(), data: fA([pe(), rn('base64')]) }))),
    })
  ),
  Wee = Dn(ue({ byIdentity: NP(pe(), Ae(Q())), range: ue({ firstSlot: Q(), lastSlot: Q() }) }));
function Hee(e, t, n, r, i, s) {
  const o = n || Aee;
  let a;
  s != null &&
    console.warn(
      'You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.'
    );
  let c;
  return (
    r &&
      (c = async (l, d) => {
        const f = await new Promise((h, p) => {
          try {
            r(l, d, (b, w) => h([b, w]));
          } catch (b) {
            p(b);
          }
        });
        return await o(...f);
      }),
    new vL(async (l, d) => {
      const f = {
        method: 'POST',
        body: l,
        agent: a,
        headers: Object.assign({ 'Content-Type': 'application/json' }, t || {}, Wte),
      };
      try {
        let h = 5,
          p,
          b = 500;
        for (
          ;
          c ? (p = await c(e, f)) : (p = await o(e, f)),
            !(p.status !== 429 || i === !0 || ((h -= 1), h === 0));

        )
          console.log(
            `Server responded with ${p.status} ${p.statusText}.  Retrying after ${b}ms delay...`
          ),
            await Ra(b),
            (b *= 2);
        const w = await p.text();
        p.ok ? d(null, w) : d(new Error(`${p.status} ${p.statusText}: ${w}`));
      } catch (h) {
        h instanceof Error && d(h);
      }
    }, {})
  );
}
function Gee(e) {
  return (t, n) =>
    new Promise((r, i) => {
      e.request(t, n, (s, o) => {
        if (s) {
          i(s);
          return;
        }
        r(o);
      });
    });
}
function qee(e) {
  return (t) =>
    new Promise((n, r) => {
      t.length === 0 && n([]);
      const i = t.map((s) => e.request(s.methodName, s.args));
      e.request(i, (s, o) => {
        if (s) {
          r(s);
          return;
        }
        n(o);
      });
    });
}
const Yee = ct(Nee),
  Zee = ct(Lee),
  Jee = ct(Uee),
  Xee = ct($ee),
  Qee = ct(Fee),
  ete = ct(Q()),
  tte = Dn(
    ue({ total: Q(), circulating: Q(), nonCirculating: Q(), nonCirculatingAccounts: Ae(Nn) })
  ),
  rE = ue({ amount: pe(), uiAmount: Ee(Q()), decimals: Q(), uiAmountString: He(pe()) }),
  nte = Dn(
    Ae(
      ue({ address: Nn, amount: pe(), uiAmount: Ee(Q()), decimals: Q(), uiAmountString: He(pe()) })
    )
  ),
  rte = Dn(
    Ae(
      ue({
        pubkey: Nn,
        account: ue({ executable: so(), owner: Nn, lamports: Q(), data: wI, rentEpoch: Q() }),
      })
    )
  ),
  iE = ue({ program: pe(), parsed: pd(), space: Q() }),
  ite = Dn(
    Ae(
      ue({
        pubkey: Nn,
        account: ue({ executable: so(), owner: Nn, lamports: Q(), data: iE, rentEpoch: Q() }),
      })
    )
  ),
  ste = Dn(Ae(ue({ lamports: Q(), address: Nn }))),
  id = ue({ executable: so(), owner: Nn, lamports: Q(), data: wI, rentEpoch: Q() }),
  ote = ue({ pubkey: Nn, account: id }),
  ate = hd(Or([hA(he), iE]), Or([cB, iE]), (e) => (Array.isArray(e) ? me(e, wI) : e)),
  sE = ue({ executable: so(), owner: Nn, lamports: Q(), data: ate, rentEpoch: Q() }),
  cte = ue({ pubkey: Nn, account: sE }),
  ute = ue({
    state: Or([rn('active'), rn('inactive'), rn('activating'), rn('deactivating')]),
    active: Q(),
    inactive: Q(),
  }),
  lte = ct(Ae(ue({ signature: pe(), slot: Q(), err: Tc, memo: Ee(pe()), blockTime: He(Ee(Q())) }))),
  dte = ct(Ae(ue({ signature: pe(), slot: Q(), err: Tc, memo: Ee(pe()), blockTime: He(Ee(Q())) }))),
  fte = ue({ subscription: Q(), result: om(id) }),
  hte = ue({ pubkey: Nn, account: id }),
  pte = ue({ subscription: Q(), result: om(hte) }),
  gte = ue({ parent: Q(), slot: Q(), root: Q() }),
  yte = ue({ subscription: Q(), result: gte }),
  bte = Or([
    ue({
      type: Or([
        rn('firstShredReceived'),
        rn('completed'),
        rn('optimisticConfirmation'),
        rn('root'),
      ]),
      slot: Q(),
      timestamp: Q(),
    }),
    ue({ type: rn('createdBank'), parent: Q(), slot: Q(), timestamp: Q() }),
    ue({
      type: rn('frozen'),
      slot: Q(),
      timestamp: Q(),
      stats: ue({
        numTransactionEntries: Q(),
        numSuccessfulTransactions: Q(),
        numFailedTransactions: Q(),
        maxTransactionsPerEntry: Q(),
      }),
    }),
    ue({ type: rn('dead'), slot: Q(), timestamp: Q(), err: pe() }),
  ]),
  mte = ue({ subscription: Q(), result: bte }),
  wte = ue({ subscription: Q(), result: om(Or([zee, Kee])) }),
  vte = ue({ subscription: Q(), result: Q() }),
  _te = ue({ pubkey: pe(), gossip: Ee(pe()), tpu: Ee(pe()), rpc: Ee(pe()), version: Ee(pe()) }),
  Kk = ue({
    votePubkey: pe(),
    nodePubkey: pe(),
    activatedStake: Q(),
    epochVoteAccount: so(),
    epochCredits: Ae(fA([Q(), Q(), Q()])),
    commission: Q(),
    lastVote: Q(),
    rootSlot: Ee(Q()),
  }),
  Ste = ct(ue({ current: Ae(Kk), delinquent: Ae(Kk) })),
  Ete = Or([rn('processed'), rn('confirmed'), rn('finalized')]),
  Ate = ue({ slot: Q(), confirmations: Ee(Q()), err: Tc, confirmationStatus: He(Ete) }),
  Ite = Dn(Ae(Ee(Ate))),
  Tte = ct(Q()),
  dB = ue({ accountKey: Nn, writableIndexes: Ae(Q()), readonlyIndexes: Ae(Q()) }),
  vI = ue({
    signatures: Ae(pe()),
    message: ue({
      accountKeys: Ae(pe()),
      header: ue({
        numRequiredSignatures: Q(),
        numReadonlySignedAccounts: Q(),
        numReadonlyUnsignedAccounts: Q(),
      }),
      instructions: Ae(ue({ accounts: Ae(Q()), data: pe(), programIdIndex: Q() })),
      recentBlockhash: pe(),
      addressTableLookups: He(Ae(dB)),
    }),
  }),
  fB = ue({
    pubkey: Nn,
    signer: so(),
    writable: so(),
    source: He(Or([rn('transaction'), rn('lookupTable')])),
  }),
  hB = ue({ accountKeys: Ae(fB), signatures: Ae(pe()) }),
  pB = ue({ parsed: pd(), program: pe(), programId: Nn }),
  gB = ue({ accounts: Ae(Nn), data: pe(), programId: Nn }),
  xte = Or([gB, pB]),
  kte = Or([
    ue({ parsed: pd(), program: pe(), programId: pe() }),
    ue({ accounts: Ae(pe()), data: pe(), programId: pe() }),
  ]),
  yB = hd(xte, kte, (e) => ('accounts' in e ? me(e, gB) : me(e, pB))),
  bB = ue({
    signatures: Ae(pe()),
    message: ue({
      accountKeys: Ae(fB),
      instructions: Ae(yB),
      recentBlockhash: pe(),
      addressTableLookups: He(Ee(Ae(dB))),
    }),
  }),
  zy = ue({ accountIndex: Q(), mint: pe(), owner: He(pe()), uiTokenAmount: rE }),
  mB = ue({ writable: Ae(Nn), readonly: Ae(Nn) }),
  am = ue({
    err: Tc,
    fee: Q(),
    innerInstructions: He(
      Ee(
        Ae(
          ue({
            index: Q(),
            instructions: Ae(ue({ accounts: Ae(Q()), data: pe(), programIdIndex: Q() })),
          })
        )
      )
    ),
    preBalances: Ae(Q()),
    postBalances: Ae(Q()),
    logMessages: He(Ee(Ae(pe()))),
    preTokenBalances: He(Ee(Ae(zy))),
    postTokenBalances: He(Ee(Ae(zy))),
    loadedAddresses: He(mB),
    computeUnitsConsumed: He(Q()),
  }),
  _I = ue({
    err: Tc,
    fee: Q(),
    innerInstructions: He(Ee(Ae(ue({ index: Q(), instructions: Ae(yB) })))),
    preBalances: Ae(Q()),
    postBalances: Ae(Q()),
    logMessages: He(Ee(Ae(pe()))),
    preTokenBalances: He(Ee(Ae(zy))),
    postTokenBalances: He(Ee(Ae(zy))),
    loadedAddresses: He(mB),
    computeUnitsConsumed: He(Q()),
  }),
  Yu = Or([rn(0), rn('legacy')]),
  xc = ue({
    pubkey: pe(),
    lamports: Q(),
    postBalance: Ee(Q()),
    rewardType: Ee(pe()),
    commission: He(Ee(Q())),
  }),
  Cte = ct(
    Ee(
      ue({
        blockhash: pe(),
        previousBlockhash: pe(),
        parentSlot: Q(),
        transactions: Ae(ue({ transaction: vI, meta: Ee(am), version: He(Yu) })),
        rewards: He(Ae(xc)),
        blockTime: Ee(Q()),
        blockHeight: Ee(Q()),
      })
    )
  ),
  Pte = ct(
    Ee(
      ue({
        blockhash: pe(),
        previousBlockhash: pe(),
        parentSlot: Q(),
        rewards: He(Ae(xc)),
        blockTime: Ee(Q()),
        blockHeight: Ee(Q()),
      })
    )
  ),
  Mte = ct(
    Ee(
      ue({
        blockhash: pe(),
        previousBlockhash: pe(),
        parentSlot: Q(),
        transactions: Ae(ue({ transaction: hB, meta: Ee(am), version: He(Yu) })),
        rewards: He(Ae(xc)),
        blockTime: Ee(Q()),
        blockHeight: Ee(Q()),
      })
    )
  ),
  Ote = ct(
    Ee(
      ue({
        blockhash: pe(),
        previousBlockhash: pe(),
        parentSlot: Q(),
        transactions: Ae(ue({ transaction: bB, meta: Ee(_I), version: He(Yu) })),
        rewards: He(Ae(xc)),
        blockTime: Ee(Q()),
        blockHeight: Ee(Q()),
      })
    )
  ),
  Bte = ct(
    Ee(
      ue({
        blockhash: pe(),
        previousBlockhash: pe(),
        parentSlot: Q(),
        transactions: Ae(ue({ transaction: hB, meta: Ee(_I), version: He(Yu) })),
        rewards: He(Ae(xc)),
        blockTime: Ee(Q()),
        blockHeight: Ee(Q()),
      })
    )
  ),
  Dte = ct(
    Ee(
      ue({
        blockhash: pe(),
        previousBlockhash: pe(),
        parentSlot: Q(),
        rewards: He(Ae(xc)),
        blockTime: Ee(Q()),
        blockHeight: Ee(Q()),
      })
    )
  ),
  Rte = ct(
    Ee(
      ue({
        blockhash: pe(),
        previousBlockhash: pe(),
        parentSlot: Q(),
        transactions: Ae(ue({ transaction: vI, meta: Ee(am) })),
        rewards: He(Ae(xc)),
        blockTime: Ee(Q()),
      })
    )
  ),
  Vk = ct(
    Ee(
      ue({
        blockhash: pe(),
        previousBlockhash: pe(),
        parentSlot: Q(),
        signatures: Ae(pe()),
        blockTime: Ee(Q()),
      })
    )
  ),
  cv = ct(
    Ee(ue({ slot: Q(), meta: am, blockTime: He(Ee(Q())), transaction: vI, version: He(Yu) }))
  ),
  eg = ct(
    Ee(ue({ slot: Q(), transaction: bB, meta: Ee(_I), blockTime: He(Ee(Q())), version: He(Yu) }))
  ),
  Nte = Dn(ue({ blockhash: pe(), feeCalculator: ue({ lamportsPerSignature: Q() }) })),
  jte = Dn(ue({ blockhash: pe(), lastValidBlockHeight: Q() })),
  Lte = ue({ slot: Q(), numTransactions: Q(), numSlots: Q(), samplePeriodSecs: Q() }),
  Ute = ct(Ae(Lte)),
  $te = Dn(Ee(ue({ feeCalculator: ue({ lamportsPerSignature: Q() }) }))),
  Fte = ct(pe()),
  zte = ct(pe()),
  Kte = ue({ err: Tc, logs: Ae(pe()), signature: pe() }),
  Vte = ue({ result: om(Kte), subscription: Q() }),
  Wte = { 'solana-client': 'js/0.0.0-development' };
class Hte {
  constructor(t, n) {
    (this._commitment = void 0),
      (this._confirmTransactionInitialTimeout = void 0),
      (this._rpcEndpoint = void 0),
      (this._rpcWsEndpoint = void 0),
      (this._rpcClient = void 0),
      (this._rpcRequest = void 0),
      (this._rpcBatchRequest = void 0),
      (this._rpcWebSocket = void 0),
      (this._rpcWebSocketConnected = !1),
      (this._rpcWebSocketHeartbeat = null),
      (this._rpcWebSocketIdleTimeout = null),
      (this._rpcWebSocketGeneration = 0),
      (this._disableBlockhashCaching = !1),
      (this._pollingBlockhash = !1),
      (this._blockhashInfo = {
        latestBlockhash: null,
        lastFetch: 0,
        transactionSignatures: [],
        simulatedSignatures: [],
      }),
      (this._nextClientSubscriptionId = 0),
      (this._subscriptionDisposeFunctionsByClientSubscriptionId = {}),
      (this._subscriptionHashByClientSubscriptionId = {}),
      (this._subscriptionStateChangeCallbacksByHash = {}),
      (this._subscriptionCallbacksByServerSubscriptionId = {}),
      (this._subscriptionsByHash = {}),
      (this._subscriptionsAutoDisposedByRpc = new Set()),
      (this.getBlockHeight = (() => {
        const u = {};
        return async (l) => {
          const { commitment: d, config: f } = tn(l),
            h = this._buildArgs([], d, void 0, f),
            p = $k(h);
          return (
            (u[p] =
              u[p] ??
              (async () => {
                try {
                  const b = await this._rpcRequest('getBlockHeight', h),
                    w = me(b, ct(Q()));
                  if ('error' in w) throw new Ue(w.error, 'failed to get block height information');
                  return w.result;
                } finally {
                  delete u[p];
                }
              })()),
            await u[p]
          );
        };
      })());
    let r, i, s, o, a, c;
    n && typeof n == 'string'
      ? (this._commitment = n)
      : n &&
        ((this._commitment = n.commitment),
        (this._confirmTransactionInitialTimeout = n.confirmTransactionInitialTimeout),
        (r = n.wsEndpoint),
        (i = n.httpHeaders),
        (s = n.fetch),
        (o = n.fetchMiddleware),
        (a = n.disableRetryOnRateLimit),
        (c = n.httpAgent)),
      (this._rpcEndpoint = Dee(t)),
      (this._rpcWsEndpoint = r || Bee(t)),
      (this._rpcClient = Hee(t, i, s, o, a, c)),
      (this._rpcRequest = Gee(this._rpcClient)),
      (this._rpcBatchRequest = qee(this._rpcClient)),
      (this._rpcWebSocket = new Iee(this._rpcWsEndpoint, {
        autoconnect: !1,
        max_reconnects: 1 / 0,
      })),
      this._rpcWebSocket.on('open', this._wsOnOpen.bind(this)),
      this._rpcWebSocket.on('error', this._wsOnError.bind(this)),
      this._rpcWebSocket.on('close', this._wsOnClose.bind(this)),
      this._rpcWebSocket.on('accountNotification', this._wsOnAccountNotification.bind(this)),
      this._rpcWebSocket.on('programNotification', this._wsOnProgramAccountNotification.bind(this)),
      this._rpcWebSocket.on('slotNotification', this._wsOnSlotNotification.bind(this)),
      this._rpcWebSocket.on(
        'slotsUpdatesNotification',
        this._wsOnSlotUpdatesNotification.bind(this)
      ),
      this._rpcWebSocket.on('signatureNotification', this._wsOnSignatureNotification.bind(this)),
      this._rpcWebSocket.on('rootNotification', this._wsOnRootNotification.bind(this)),
      this._rpcWebSocket.on('logsNotification', this._wsOnLogsNotification.bind(this));
  }
  get commitment() {
    return this._commitment;
  }
  get rpcEndpoint() {
    return this._rpcEndpoint;
  }
  async getBalanceAndContext(t, n) {
    const { commitment: r, config: i } = tn(n),
      s = this._buildArgs([t.toBase58()], r, void 0, i),
      o = await this._rpcRequest('getBalance', s),
      a = me(o, Dn(Q()));
    if ('error' in a) throw new Ue(a.error, `failed to get balance for ${t.toBase58()}`);
    return a.result;
  }
  async getBalance(t, n) {
    return await this.getBalanceAndContext(t, n)
      .then((r) => r.value)
      .catch((r) => {
        throw new Error('failed to get balance of account ' + t.toBase58() + ': ' + r);
      });
  }
  async getBlockTime(t) {
    const n = await this._rpcRequest('getBlockTime', [t]),
      r = me(n, ct(Ee(Q())));
    if ('error' in r) throw new Ue(r.error, `failed to get block time for slot ${t}`);
    return r.result;
  }
  async getMinimumLedgerSlot() {
    const t = await this._rpcRequest('minimumLedgerSlot', []),
      n = me(t, ct(Q()));
    if ('error' in n) throw new Ue(n.error, 'failed to get minimum ledger slot');
    return n.result;
  }
  async getFirstAvailableBlock() {
    const t = await this._rpcRequest('getFirstAvailableBlock', []),
      n = me(t, ete);
    if ('error' in n) throw new Ue(n.error, 'failed to get first available block');
    return n.result;
  }
  async getSupply(t) {
    let n = {};
    typeof t == 'string'
      ? (n = { commitment: t })
      : t
        ? (n = { ...t, commitment: (t && t.commitment) || this.commitment })
        : (n = { commitment: this.commitment });
    const r = await this._rpcRequest('getSupply', [n]),
      i = me(r, tte);
    if ('error' in i) throw new Ue(i.error, 'failed to get supply');
    return i.result;
  }
  async getTokenSupply(t, n) {
    const r = this._buildArgs([t.toBase58()], n),
      i = await this._rpcRequest('getTokenSupply', r),
      s = me(i, Dn(rE));
    if ('error' in s) throw new Ue(s.error, 'failed to get token supply');
    return s.result;
  }
  async getTokenAccountBalance(t, n) {
    const r = this._buildArgs([t.toBase58()], n),
      i = await this._rpcRequest('getTokenAccountBalance', r),
      s = me(i, Dn(rE));
    if ('error' in s) throw new Ue(s.error, 'failed to get token account balance');
    return s.result;
  }
  async getTokenAccountsByOwner(t, n, r) {
    const { commitment: i, config: s } = tn(r);
    let o = [t.toBase58()];
    'mint' in n
      ? o.push({ mint: n.mint.toBase58() })
      : o.push({ programId: n.programId.toBase58() });
    const a = this._buildArgs(o, i, 'base64', s),
      c = await this._rpcRequest('getTokenAccountsByOwner', a),
      u = me(c, rte);
    if ('error' in u)
      throw new Ue(u.error, `failed to get token accounts owned by account ${t.toBase58()}`);
    return u.result;
  }
  async getParsedTokenAccountsByOwner(t, n, r) {
    let i = [t.toBase58()];
    'mint' in n
      ? i.push({ mint: n.mint.toBase58() })
      : i.push({ programId: n.programId.toBase58() });
    const s = this._buildArgs(i, r, 'jsonParsed'),
      o = await this._rpcRequest('getTokenAccountsByOwner', s),
      a = me(o, ite);
    if ('error' in a)
      throw new Ue(a.error, `failed to get token accounts owned by account ${t.toBase58()}`);
    return a.result;
  }
  async getLargestAccounts(t) {
    const n = { ...t, commitment: (t && t.commitment) || this.commitment },
      r = n.filter || n.commitment ? [n] : [],
      i = await this._rpcRequest('getLargestAccounts', r),
      s = me(i, ste);
    if ('error' in s) throw new Ue(s.error, 'failed to get largest accounts');
    return s.result;
  }
  async getTokenLargestAccounts(t, n) {
    const r = this._buildArgs([t.toBase58()], n),
      i = await this._rpcRequest('getTokenLargestAccounts', r),
      s = me(i, nte);
    if ('error' in s) throw new Ue(s.error, 'failed to get token largest accounts');
    return s.result;
  }
  async getAccountInfoAndContext(t, n) {
    const { commitment: r, config: i } = tn(n),
      s = this._buildArgs([t.toBase58()], r, 'base64', i),
      o = await this._rpcRequest('getAccountInfo', s),
      a = me(o, Dn(Ee(id)));
    if ('error' in a) throw new Ue(a.error, `failed to get info about account ${t.toBase58()}`);
    return a.result;
  }
  async getParsedAccountInfo(t, n) {
    const { commitment: r, config: i } = tn(n),
      s = this._buildArgs([t.toBase58()], r, 'jsonParsed', i),
      o = await this._rpcRequest('getAccountInfo', s),
      a = me(o, Dn(Ee(sE)));
    if ('error' in a) throw new Ue(a.error, `failed to get info about account ${t.toBase58()}`);
    return a.result;
  }
  async getAccountInfo(t, n) {
    try {
      return (await this.getAccountInfoAndContext(t, n)).value;
    } catch (r) {
      throw new Error('failed to get info about account ' + t.toBase58() + ': ' + r);
    }
  }
  async getMultipleParsedAccounts(t, n) {
    const { commitment: r, config: i } = tn(n),
      s = t.map((u) => u.toBase58()),
      o = this._buildArgs([s], r, 'jsonParsed', i),
      a = await this._rpcRequest('getMultipleAccounts', o),
      c = me(a, Dn(Ae(Ee(sE))));
    if ('error' in c) throw new Ue(c.error, `failed to get info for accounts ${s}`);
    return c.result;
  }
  async getMultipleAccountsInfoAndContext(t, n) {
    const { commitment: r, config: i } = tn(n),
      s = t.map((u) => u.toBase58()),
      o = this._buildArgs([s], r, 'base64', i),
      a = await this._rpcRequest('getMultipleAccounts', o),
      c = me(a, Dn(Ae(Ee(id))));
    if ('error' in c) throw new Ue(c.error, `failed to get info for accounts ${s}`);
    return c.result;
  }
  async getMultipleAccountsInfo(t, n) {
    return (await this.getMultipleAccountsInfoAndContext(t, n)).value;
  }
  async getStakeActivation(t, n, r) {
    const { commitment: i, config: s } = tn(n),
      o = this._buildArgs([t.toBase58()], i, void 0, {
        ...s,
        epoch: r ?? (s == null ? void 0 : s.epoch),
      }),
      a = await this._rpcRequest('getStakeActivation', o),
      c = me(a, ct(ute));
    if ('error' in c) throw new Ue(c.error, `failed to get Stake Activation ${t.toBase58()}`);
    return c.result;
  }
  async getProgramAccounts(t, n) {
    const { commitment: r, config: i } = tn(n),
      { encoding: s, ...o } = i || {},
      a = this._buildArgs([t.toBase58()], r, s || 'base64', o),
      c = await this._rpcRequest('getProgramAccounts', a),
      u = me(c, ct(Ae(ote)));
    if ('error' in u)
      throw new Ue(u.error, `failed to get accounts owned by program ${t.toBase58()}`);
    return u.result;
  }
  async getParsedProgramAccounts(t, n) {
    const { commitment: r, config: i } = tn(n),
      s = this._buildArgs([t.toBase58()], r, 'jsonParsed', i),
      o = await this._rpcRequest('getProgramAccounts', s),
      a = me(o, ct(Ae(cte)));
    if ('error' in a)
      throw new Ue(a.error, `failed to get accounts owned by program ${t.toBase58()}`);
    return a.result;
  }
  async confirmTransaction(t, n) {
    var s;
    let r;
    if (typeof t == 'string') r = t;
    else {
      const o = t;
      if ((s = o.abortSignal) != null && s.aborted) return Promise.reject(o.abortSignal.reason);
      r = o.signature;
    }
    let i;
    try {
      i = Jn.decode(r);
    } catch {
      throw new Error('signature must be base58 encoded: ' + r);
    }
    return (
      It(i.length === 64, 'signature has invalid length'),
      typeof t == 'string'
        ? await this.confirmTransactionUsingLegacyTimeoutStrategy({
            commitment: n || this.commitment,
            signature: r,
          })
        : 'lastValidBlockHeight' in t
          ? await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
              commitment: n || this.commitment,
              strategy: t,
            })
          : await this.confirmTransactionUsingDurableNonceStrategy({
              commitment: n || this.commitment,
              strategy: t,
            })
    );
  }
  getCancellationPromise(t) {
    return new Promise((n, r) => {
      t != null &&
        (t.aborted
          ? r(t.reason)
          : t.addEventListener('abort', () => {
              r(t.reason);
            }));
    });
  }
  getTransactionConfirmationPromise({ commitment: t, signature: n }) {
    let r,
      i,
      s = !1;
    const o = new Promise((c, u) => {
      try {
        r = this.onSignature(
          n,
          (d, f) => {
            r = void 0;
            const h = { context: f, value: d };
            c({ __type: Ai.PROCESSED, response: h });
          },
          t
        );
        const l = new Promise((d) => {
          r == null
            ? d()
            : (i = this._onSubscriptionStateChange(r, (f) => {
                f === 'subscribed' && d();
              }));
        });
        (async () => {
          if ((await l, s)) return;
          const d = await this.getSignatureStatus(n);
          if (s || d == null) return;
          const { context: f, value: h } = d;
          if (h != null)
            if (h != null && h.err) u(h.err);
            else {
              switch (t) {
                case 'confirmed':
                case 'single':
                case 'singleGossip': {
                  if (h.confirmationStatus === 'processed') return;
                  break;
                }
                case 'finalized':
                case 'max':
                case 'root': {
                  if (h.confirmationStatus === 'processed' || h.confirmationStatus === 'confirmed')
                    return;
                  break;
                }
                case 'processed':
                case 'recent':
              }
              (s = !0), c({ __type: Ai.PROCESSED, response: { context: f, value: h } });
            }
        })();
      } catch (l) {
        u(l);
      }
    });
    return {
      abortConfirmation: () => {
        i && (i(), (i = void 0)), r != null && (this.removeSignatureListener(r), (r = void 0));
      },
      confirmationPromise: o,
    };
  }
  async confirmTransactionUsingBlockHeightExceedanceStrategy({
    commitment: t,
    strategy: { abortSignal: n, lastValidBlockHeight: r, signature: i },
  }) {
    let s = !1;
    const o = new Promise((d) => {
        const f = async () => {
          try {
            return await this.getBlockHeight(t);
          } catch {
            return -1;
          }
        };
        (async () => {
          let h = await f();
          if (!s) {
            for (; h <= r; ) if ((await Ra(1e3), s || ((h = await f()), s))) return;
            d({ __type: Ai.BLOCKHEIGHT_EXCEEDED });
          }
        })();
      }),
      { abortConfirmation: a, confirmationPromise: c } = this.getTransactionConfirmationPromise({
        commitment: t,
        signature: i,
      }),
      u = this.getCancellationPromise(n);
    let l;
    try {
      const d = await Promise.race([u, c, o]);
      if (d.__type === Ai.PROCESSED) l = d.response;
      else throw new pI(i);
    } finally {
      (s = !0), a();
    }
    return l;
  }
  async confirmTransactionUsingDurableNonceStrategy({
    commitment: t,
    strategy: {
      abortSignal: n,
      minContextSlot: r,
      nonceAccountPubkey: i,
      nonceValue: s,
      signature: o,
    },
  }) {
    let a = !1;
    const c = new Promise((h) => {
        let p = s,
          b = null;
        const w = async () => {
          try {
            const { context: A, value: _ } = await this.getNonceAndContext(i, {
              commitment: t,
              minContextSlot: r,
            });
            return (b = A.slot), _ == null ? void 0 : _.nonce;
          } catch {
            return p;
          }
        };
        (async () => {
          if (((p = await w()), !a))
            for (;;) {
              if (s !== p) {
                h({ __type: Ai.NONCE_INVALID, slotInWhichNonceDidAdvance: b });
                return;
              }
              if ((await Ra(2e3), a || ((p = await w()), a))) return;
            }
        })();
      }),
      { abortConfirmation: u, confirmationPromise: l } = this.getTransactionConfirmationPromise({
        commitment: t,
        signature: o,
      }),
      d = this.getCancellationPromise(n);
    let f;
    try {
      const h = await Promise.race([d, l, c]);
      if (h.__type === Ai.PROCESSED) f = h.response;
      else {
        let p;
        for (;;) {
          const b = await this.getSignatureStatus(o);
          if (b == null) break;
          if (b.context.slot < (h.slotInWhichNonceDidAdvance ?? r)) {
            await Ra(400);
            continue;
          }
          p = b;
          break;
        }
        if (p != null && p.value) {
          const b = t || 'finalized',
            { confirmationStatus: w } = p.value;
          switch (b) {
            case 'processed':
            case 'recent':
              if (w !== 'processed' && w !== 'confirmed' && w !== 'finalized') throw new Yc(o);
              break;
            case 'confirmed':
            case 'single':
            case 'singleGossip':
              if (w !== 'confirmed' && w !== 'finalized') throw new Yc(o);
              break;
            case 'finalized':
            case 'max':
            case 'root':
              if (w !== 'finalized') throw new Yc(o);
              break;
            default:
          }
          f = { context: p.context, value: { err: p.value.err } };
        } else throw new Yc(o);
      }
    } finally {
      (a = !0), u();
    }
    return f;
  }
  async confirmTransactionUsingLegacyTimeoutStrategy({ commitment: t, signature: n }) {
    let r;
    const i = new Promise((c) => {
        let u = this._confirmTransactionInitialTimeout || 6e4;
        switch (t) {
          case 'processed':
          case 'recent':
          case 'single':
          case 'confirmed':
          case 'singleGossip': {
            u = this._confirmTransactionInitialTimeout || 3e4;
            break;
          }
        }
        r = setTimeout(() => c({ __type: Ai.TIMED_OUT, timeoutMs: u }), u);
      }),
      { abortConfirmation: s, confirmationPromise: o } = this.getTransactionConfirmationPromise({
        commitment: t,
        signature: n,
      });
    let a;
    try {
      const c = await Promise.race([o, i]);
      if (c.__type === Ai.PROCESSED) a = c.response;
      else throw new gI(n, c.timeoutMs / 1e3);
    } finally {
      clearTimeout(r), s();
    }
    return a;
  }
  async getClusterNodes() {
    const t = await this._rpcRequest('getClusterNodes', []),
      n = me(t, ct(Ae(_te)));
    if ('error' in n) throw new Ue(n.error, 'failed to get cluster nodes');
    return n.result;
  }
  async getVoteAccounts(t) {
    const n = this._buildArgs([], t),
      r = await this._rpcRequest('getVoteAccounts', n),
      i = me(r, Ste);
    if ('error' in i) throw new Ue(i.error, 'failed to get vote accounts');
    return i.result;
  }
  async getSlot(t) {
    const { commitment: n, config: r } = tn(t),
      i = this._buildArgs([], n, void 0, r),
      s = await this._rpcRequest('getSlot', i),
      o = me(s, ct(Q()));
    if ('error' in o) throw new Ue(o.error, 'failed to get slot');
    return o.result;
  }
  async getSlotLeader(t) {
    const { commitment: n, config: r } = tn(t),
      i = this._buildArgs([], n, void 0, r),
      s = await this._rpcRequest('getSlotLeader', i),
      o = me(s, ct(pe()));
    if ('error' in o) throw new Ue(o.error, 'failed to get slot leader');
    return o.result;
  }
  async getSlotLeaders(t, n) {
    const r = [t, n],
      i = await this._rpcRequest('getSlotLeaders', r),
      s = me(i, ct(Ae(Nn)));
    if ('error' in s) throw new Ue(s.error, 'failed to get slot leaders');
    return s.result;
  }
  async getSignatureStatus(t, n) {
    const { context: r, value: i } = await this.getSignatureStatuses([t], n);
    It(i.length === 1);
    const s = i[0];
    return { context: r, value: s };
  }
  async getSignatureStatuses(t, n) {
    const r = [t];
    n && r.push(n);
    const i = await this._rpcRequest('getSignatureStatuses', r),
      s = me(i, Ite);
    if ('error' in s) throw new Ue(s.error, 'failed to get signature status');
    return s.result;
  }
  async getTransactionCount(t) {
    const { commitment: n, config: r } = tn(t),
      i = this._buildArgs([], n, void 0, r),
      s = await this._rpcRequest('getTransactionCount', i),
      o = me(s, ct(Q()));
    if ('error' in o) throw new Ue(o.error, 'failed to get transaction count');
    return o.result;
  }
  async getTotalSupply(t) {
    return (await this.getSupply({ commitment: t, excludeNonCirculatingAccountsList: !0 })).value
      .total;
  }
  async getInflationGovernor(t) {
    const n = this._buildArgs([], t),
      r = await this._rpcRequest('getInflationGovernor', n),
      i = me(r, Yee);
    if ('error' in i) throw new Ue(i.error, 'failed to get inflation');
    return i.result;
  }
  async getInflationReward(t, n, r) {
    const { commitment: i, config: s } = tn(r),
      o = this._buildArgs([t.map((u) => u.toBase58())], i, void 0, {
        ...s,
        epoch: n ?? (s == null ? void 0 : s.epoch),
      }),
      a = await this._rpcRequest('getInflationReward', o),
      c = me(a, jee);
    if ('error' in c) throw new Ue(c.error, 'failed to get inflation reward');
    return c.result;
  }
  async getInflationRate() {
    const t = await this._rpcRequest('getInflationRate', []),
      n = me(t, Zee);
    if ('error' in n) throw new Ue(n.error, 'failed to get inflation rate');
    return n.result;
  }
  async getEpochInfo(t) {
    const { commitment: n, config: r } = tn(t),
      i = this._buildArgs([], n, void 0, r),
      s = await this._rpcRequest('getEpochInfo', i),
      o = me(s, Jee);
    if ('error' in o) throw new Ue(o.error, 'failed to get epoch info');
    return o.result;
  }
  async getEpochSchedule() {
    const t = await this._rpcRequest('getEpochSchedule', []),
      n = me(t, Xee);
    if ('error' in n) throw new Ue(n.error, 'failed to get epoch schedule');
    const r = n.result;
    return new aB(
      r.slotsPerEpoch,
      r.leaderScheduleSlotOffset,
      r.warmup,
      r.firstNormalEpoch,
      r.firstNormalSlot
    );
  }
  async getLeaderSchedule() {
    const t = await this._rpcRequest('getLeaderSchedule', []),
      n = me(t, Qee);
    if ('error' in n) throw new Ue(n.error, 'failed to get leader schedule');
    return n.result;
  }
  async getMinimumBalanceForRentExemption(t, n) {
    const r = this._buildArgs([t], n),
      i = await this._rpcRequest('getMinimumBalanceForRentExemption', r),
      s = me(i, Tte);
    return 'error' in s
      ? (console.warn('Unable to fetch minimum balance for rent exemption'), 0)
      : s.result;
  }
  async getRecentBlockhashAndContext(t) {
    const n = this._buildArgs([], t),
      r = await this._rpcRequest('getRecentBlockhash', n),
      i = me(r, Nte);
    if ('error' in i) throw new Ue(i.error, 'failed to get recent blockhash');
    return i.result;
  }
  async getRecentPerformanceSamples(t) {
    const n = await this._rpcRequest('getRecentPerformanceSamples', t ? [t] : []),
      r = me(n, Ute);
    if ('error' in r) throw new Ue(r.error, 'failed to get recent performance samples');
    return r.result;
  }
  async getFeeCalculatorForBlockhash(t, n) {
    const r = this._buildArgs([t], n),
      i = await this._rpcRequest('getFeeCalculatorForBlockhash', r),
      s = me(i, $te);
    if ('error' in s) throw new Ue(s.error, 'failed to get fee calculator');
    const { context: o, value: a } = s.result;
    return { context: o, value: a !== null ? a.feeCalculator : null };
  }
  async getFeeForMessage(t, n) {
    const r = ot(t.serialize()).toString('base64'),
      i = this._buildArgs([r], n),
      s = await this._rpcRequest('getFeeForMessage', i),
      o = me(s, Dn(Ee(Q())));
    if ('error' in o) throw new Ue(o.error, 'failed to get fee for message');
    if (o.result === null) throw new Error('invalid blockhash');
    return o.result;
  }
  async getRecentBlockhash(t) {
    try {
      return (await this.getRecentBlockhashAndContext(t)).value;
    } catch (n) {
      throw new Error('failed to get recent blockhash: ' + n);
    }
  }
  async getLatestBlockhash(t) {
    try {
      return (await this.getLatestBlockhashAndContext(t)).value;
    } catch (n) {
      throw new Error('failed to get recent blockhash: ' + n);
    }
  }
  async getLatestBlockhashAndContext(t) {
    const { commitment: n, config: r } = tn(t),
      i = this._buildArgs([], n, void 0, r),
      s = await this._rpcRequest('getLatestBlockhash', i),
      o = me(s, jte);
    if ('error' in o) throw new Ue(o.error, 'failed to get latest blockhash');
    return o.result;
  }
  async getVersion() {
    const t = await this._rpcRequest('getVersion', []),
      n = me(t, ct(Vee));
    if ('error' in n) throw new Ue(n.error, 'failed to get version');
    return n.result;
  }
  async getGenesisHash() {
    const t = await this._rpcRequest('getGenesisHash', []),
      n = me(t, ct(pe()));
    if ('error' in n) throw new Ue(n.error, 'failed to get genesis hash');
    return n.result;
  }
  async getBlock(t, n) {
    const { commitment: r, config: i } = tn(n),
      s = this._buildArgsAtLeastConfirmed([t], r, void 0, i),
      o = await this._rpcRequest('getBlock', s);
    try {
      switch (i == null ? void 0 : i.transactionDetails) {
        case 'accounts': {
          const a = me(o, Mte);
          if ('error' in a) throw a.error;
          return a.result;
        }
        case 'none': {
          const a = me(o, Pte);
          if ('error' in a) throw a.error;
          return a.result;
        }
        default: {
          const a = me(o, Cte);
          if ('error' in a) throw a.error;
          const { result: c } = a;
          return c
            ? {
                ...c,
                transactions: c.transactions.map(({ transaction: u, meta: l, version: d }) => ({
                  meta: l,
                  transaction: { ...u, message: av(d, u.message) },
                  version: d,
                })),
              }
            : null;
        }
      }
    } catch (a) {
      throw new Ue(a, 'failed to get confirmed block');
    }
  }
  async getParsedBlock(t, n) {
    const { commitment: r, config: i } = tn(n),
      s = this._buildArgsAtLeastConfirmed([t], r, 'jsonParsed', i),
      o = await this._rpcRequest('getBlock', s);
    try {
      switch (i == null ? void 0 : i.transactionDetails) {
        case 'accounts': {
          const a = me(o, Bte);
          if ('error' in a) throw a.error;
          return a.result;
        }
        case 'none': {
          const a = me(o, Dte);
          if ('error' in a) throw a.error;
          return a.result;
        }
        default: {
          const a = me(o, Ote);
          if ('error' in a) throw a.error;
          return a.result;
        }
      }
    } catch (a) {
      throw new Ue(a, 'failed to get block');
    }
  }
  async getBlockProduction(t) {
    let n, r;
    if (typeof t == 'string') r = t;
    else if (t) {
      const { commitment: a, ...c } = t;
      (r = a), (n = c);
    }
    const i = this._buildArgs([], r, 'base64', n),
      s = await this._rpcRequest('getBlockProduction', i),
      o = me(s, Wee);
    if ('error' in o) throw new Ue(o.error, 'failed to get block production information');
    return o.result;
  }
  async getTransaction(t, n) {
    const { commitment: r, config: i } = tn(n),
      s = this._buildArgsAtLeastConfirmed([t], r, void 0, i),
      o = await this._rpcRequest('getTransaction', s),
      a = me(o, cv);
    if ('error' in a) throw new Ue(a.error, 'failed to get transaction');
    const c = a.result;
    return (
      c && {
        ...c,
        transaction: { ...c.transaction, message: av(c.version, c.transaction.message) },
      }
    );
  }
  async getParsedTransaction(t, n) {
    const { commitment: r, config: i } = tn(n),
      s = this._buildArgsAtLeastConfirmed([t], r, 'jsonParsed', i),
      o = await this._rpcRequest('getTransaction', s),
      a = me(o, eg);
    if ('error' in a) throw new Ue(a.error, 'failed to get transaction');
    return a.result;
  }
  async getParsedTransactions(t, n) {
    const { commitment: r, config: i } = tn(n),
      s = t.map((c) => ({
        methodName: 'getTransaction',
        args: this._buildArgsAtLeastConfirmed([c], r, 'jsonParsed', i),
      }));
    return (await this._rpcBatchRequest(s)).map((c) => {
      const u = me(c, eg);
      if ('error' in u) throw new Ue(u.error, 'failed to get transactions');
      return u.result;
    });
  }
  async getTransactions(t, n) {
    const { commitment: r, config: i } = tn(n),
      s = t.map((c) => ({
        methodName: 'getTransaction',
        args: this._buildArgsAtLeastConfirmed([c], r, void 0, i),
      }));
    return (await this._rpcBatchRequest(s)).map((c) => {
      const u = me(c, cv);
      if ('error' in u) throw new Ue(u.error, 'failed to get transactions');
      const l = u.result;
      return (
        l && {
          ...l,
          transaction: { ...l.transaction, message: av(l.version, l.transaction.message) },
        }
      );
    });
  }
  async getConfirmedBlock(t, n) {
    const r = this._buildArgsAtLeastConfirmed([t], n),
      i = await this._rpcRequest('getConfirmedBlock', r),
      s = me(i, Rte);
    if ('error' in s) throw new Ue(s.error, 'failed to get confirmed block');
    const o = s.result;
    if (!o) throw new Error('Confirmed block ' + t + ' not found');
    const a = {
      ...o,
      transactions: o.transactions.map(({ transaction: c, meta: u }) => {
        const l = new zi(c.message);
        return { meta: u, transaction: { ...c, message: l } };
      }),
    };
    return {
      ...a,
      transactions: a.transactions.map(({ transaction: c, meta: u }) => ({
        meta: u,
        transaction: jt.populate(c.message, c.signatures),
      })),
    };
  }
  async getBlocks(t, n, r) {
    const i = this._buildArgsAtLeastConfirmed(n !== void 0 ? [t, n] : [t], r),
      s = await this._rpcRequest('getBlocks', i),
      o = me(s, ct(Ae(Q())));
    if ('error' in o) throw new Ue(o.error, 'failed to get blocks');
    return o.result;
  }
  async getBlockSignatures(t, n) {
    const r = this._buildArgsAtLeastConfirmed([t], n, void 0, {
        transactionDetails: 'signatures',
        rewards: !1,
      }),
      i = await this._rpcRequest('getBlock', r),
      s = me(i, Vk);
    if ('error' in s) throw new Ue(s.error, 'failed to get block');
    const o = s.result;
    if (!o) throw new Error('Block ' + t + ' not found');
    return o;
  }
  async getConfirmedBlockSignatures(t, n) {
    const r = this._buildArgsAtLeastConfirmed([t], n, void 0, {
        transactionDetails: 'signatures',
        rewards: !1,
      }),
      i = await this._rpcRequest('getConfirmedBlock', r),
      s = me(i, Vk);
    if ('error' in s) throw new Ue(s.error, 'failed to get confirmed block');
    const o = s.result;
    if (!o) throw new Error('Confirmed block ' + t + ' not found');
    return o;
  }
  async getConfirmedTransaction(t, n) {
    const r = this._buildArgsAtLeastConfirmed([t], n),
      i = await this._rpcRequest('getConfirmedTransaction', r),
      s = me(i, cv);
    if ('error' in s) throw new Ue(s.error, 'failed to get transaction');
    const o = s.result;
    if (!o) return o;
    const a = new zi(o.transaction.message),
      c = o.transaction.signatures;
    return { ...o, transaction: jt.populate(a, c) };
  }
  async getParsedConfirmedTransaction(t, n) {
    const r = this._buildArgsAtLeastConfirmed([t], n, 'jsonParsed'),
      i = await this._rpcRequest('getConfirmedTransaction', r),
      s = me(i, eg);
    if ('error' in s) throw new Ue(s.error, 'failed to get confirmed transaction');
    return s.result;
  }
  async getParsedConfirmedTransactions(t, n) {
    const r = t.map((o) => ({
      methodName: 'getConfirmedTransaction',
      args: this._buildArgsAtLeastConfirmed([o], n, 'jsonParsed'),
    }));
    return (await this._rpcBatchRequest(r)).map((o) => {
      const a = me(o, eg);
      if ('error' in a) throw new Ue(a.error, 'failed to get confirmed transactions');
      return a.result;
    });
  }
  async getConfirmedSignaturesForAddress(t, n, r) {
    let i = {},
      s = await this.getFirstAvailableBlock();
    for (; !('until' in i) && (n--, !(n <= 0 || n < s)); )
      try {
        const c = await this.getConfirmedBlockSignatures(n, 'finalized');
        c.signatures.length > 0 && (i.until = c.signatures[c.signatures.length - 1].toString());
      } catch (c) {
        if (c instanceof Error && c.message.includes('skipped')) continue;
        throw c;
      }
    let o = await this.getSlot('finalized');
    for (; !('before' in i) && (r++, !(r > o)); )
      try {
        const c = await this.getConfirmedBlockSignatures(r);
        c.signatures.length > 0 && (i.before = c.signatures[c.signatures.length - 1].toString());
      } catch (c) {
        if (c instanceof Error && c.message.includes('skipped')) continue;
        throw c;
      }
    return (await this.getConfirmedSignaturesForAddress2(t, i)).map((c) => c.signature);
  }
  async getConfirmedSignaturesForAddress2(t, n, r) {
    const i = this._buildArgsAtLeastConfirmed([t.toBase58()], r, void 0, n),
      s = await this._rpcRequest('getConfirmedSignaturesForAddress2', i),
      o = me(s, lte);
    if ('error' in o) throw new Ue(o.error, 'failed to get confirmed signatures for address');
    return o.result;
  }
  async getSignaturesForAddress(t, n, r) {
    const i = this._buildArgsAtLeastConfirmed([t.toBase58()], r, void 0, n),
      s = await this._rpcRequest('getSignaturesForAddress', i),
      o = me(s, dte);
    if ('error' in o) throw new Ue(o.error, 'failed to get signatures for address');
    return o.result;
  }
  async getAddressLookupTable(t, n) {
    const { context: r, value: i } = await this.getAccountInfoAndContext(t, n);
    let s = null;
    return (
      i !== null && (s = new nE({ key: t, state: nE.deserialize(i.data) })),
      { context: r, value: s }
    );
  }
  async getNonceAndContext(t, n) {
    const { context: r, value: i } = await this.getAccountInfoAndContext(t, n);
    let s = null;
    return i !== null && (s = sm.fromAccountData(i.data)), { context: r, value: s };
  }
  async getNonce(t, n) {
    return await this.getNonceAndContext(t, n)
      .then((r) => r.value)
      .catch((r) => {
        throw new Error('failed to get nonce for account ' + t.toBase58() + ': ' + r);
      });
  }
  async requestAirdrop(t, n) {
    const r = await this._rpcRequest('requestAirdrop', [t.toBase58(), n]),
      i = me(r, Fte);
    if ('error' in i) throw new Ue(i.error, `airdrop to ${t.toBase58()} failed`);
    return i.result;
  }
  async _blockhashWithExpiryBlockHeight(t) {
    if (!t) {
      for (; this._pollingBlockhash; ) await Ra(100);
      const r = Date.now() - this._blockhashInfo.lastFetch >= uB;
      if (this._blockhashInfo.latestBlockhash !== null && !r)
        return this._blockhashInfo.latestBlockhash;
    }
    return await this._pollNewBlockhash();
  }
  async _pollNewBlockhash() {
    this._pollingBlockhash = !0;
    try {
      const t = Date.now(),
        n = this._blockhashInfo.latestBlockhash,
        r = n ? n.blockhash : null;
      for (let i = 0; i < 50; i++) {
        const s = await this.getLatestBlockhash('finalized');
        if (r !== s.blockhash)
          return (
            (this._blockhashInfo = {
              latestBlockhash: s,
              lastFetch: Date.now(),
              transactionSignatures: [],
              simulatedSignatures: [],
            }),
            s
          );
        await Ra(Cee / 2);
      }
      throw new Error(`Unable to obtain a new blockhash after ${Date.now() - t}ms`);
    } finally {
      this._pollingBlockhash = !1;
    }
  }
  async getStakeMinimumDelegation(t) {
    const { commitment: n, config: r } = tn(t),
      i = this._buildArgs([], n, 'base64', r),
      s = await this._rpcRequest('getStakeMinimumDelegation', i),
      o = me(s, Dn(Q()));
    if ('error' in o) throw new Ue(o.error, 'failed to get stake minimum delegation');
    return o.result;
  }
  async simulateTransaction(t, n, r) {
    if ('message' in t) {
      const b = t.serialize(),
        w = he.from(b).toString('base64');
      if (Array.isArray(n) || r !== void 0) throw new Error('Invalid arguments');
      const A = n || {};
      (A.encoding = 'base64'), 'commitment' in A || (A.commitment = this.commitment);
      const _ = [w, A],
        x = await this._rpcRequest('simulateTransaction', _),
        k = me(x, zk);
      if ('error' in k) throw new Error('failed to simulate transaction: ' + k.error.message);
      return k.result;
    }
    let i;
    if (t instanceof jt) {
      let p = t;
      (i = new jt()),
        (i.feePayer = p.feePayer),
        (i.instructions = t.instructions),
        (i.nonceInfo = p.nonceInfo),
        (i.signatures = p.signatures);
    } else (i = jt.populate(t)), (i._message = i._json = void 0);
    if (n !== void 0 && !Array.isArray(n)) throw new Error('Invalid arguments');
    const s = n;
    if (i.nonceInfo && s) i.sign(...s);
    else {
      let p = this._disableBlockhashCaching;
      for (;;) {
        const b = await this._blockhashWithExpiryBlockHeight(p);
        if (
          ((i.lastValidBlockHeight = b.lastValidBlockHeight), (i.recentBlockhash = b.blockhash), !s)
        )
          break;
        if ((i.sign(...s), !i.signature)) throw new Error('!signature');
        const w = i.signature.toString('base64');
        if (
          !this._blockhashInfo.simulatedSignatures.includes(w) &&
          !this._blockhashInfo.transactionSignatures.includes(w)
        ) {
          this._blockhashInfo.simulatedSignatures.push(w);
          break;
        } else p = !0;
      }
    }
    const o = i._compile(),
      a = o.serialize(),
      u = i._serialize(a).toString('base64'),
      l = { encoding: 'base64', commitment: this.commitment };
    if (r) {
      const p = (Array.isArray(r) ? r : o.nonProgramIds()).map((b) => b.toBase58());
      l.accounts = { encoding: 'base64', addresses: p };
    }
    s && (l.sigVerify = !0);
    const d = [u, l],
      f = await this._rpcRequest('simulateTransaction', d),
      h = me(f, zk);
    if ('error' in h) {
      let p;
      if ('data' in h.error && ((p = h.error.data.logs), p && Array.isArray(p))) {
        const b = `
    `,
          w = b + p.join(b);
        console.error(h.error.message, w);
      }
      throw new tE('failed to simulate transaction: ' + h.error.message, p);
    }
    return h.result;
  }
  async sendTransaction(t, n, r) {
    if ('version' in t) {
      if (n && Array.isArray(n)) throw new Error('Invalid arguments');
      const o = t.serialize();
      return await this.sendRawTransaction(o, n);
    }
    if (n === void 0 || !Array.isArray(n)) throw new Error('Invalid arguments');
    const i = n;
    if (t.nonceInfo) t.sign(...i);
    else {
      let o = this._disableBlockhashCaching;
      for (;;) {
        const a = await this._blockhashWithExpiryBlockHeight(o);
        if (
          ((t.lastValidBlockHeight = a.lastValidBlockHeight),
          (t.recentBlockhash = a.blockhash),
          t.sign(...i),
          !t.signature)
        )
          throw new Error('!signature');
        const c = t.signature.toString('base64');
        if (this._blockhashInfo.transactionSignatures.includes(c)) o = !0;
        else {
          this._blockhashInfo.transactionSignatures.push(c);
          break;
        }
      }
    }
    const s = t.serialize();
    return await this.sendRawTransaction(s, r);
  }
  async sendRawTransaction(t, n) {
    const r = ot(t).toString('base64');
    return await this.sendEncodedTransaction(r, n);
  }
  async sendEncodedTransaction(t, n) {
    const r = { encoding: 'base64' },
      i = n && n.skipPreflight,
      s = (n && n.preflightCommitment) || this.commitment;
    n && n.maxRetries != null && (r.maxRetries = n.maxRetries),
      n && n.minContextSlot != null && (r.minContextSlot = n.minContextSlot),
      i && (r.skipPreflight = i),
      s && (r.preflightCommitment = s);
    const o = [t, r],
      a = await this._rpcRequest('sendTransaction', o),
      c = me(a, zte);
    if ('error' in c) {
      let u;
      throw (
        ('data' in c.error && (u = c.error.data.logs),
        new tE('failed to send transaction: ' + c.error.message, u))
      );
    }
    return c.result;
  }
  _wsOnOpen() {
    (this._rpcWebSocketConnected = !0),
      (this._rpcWebSocketHeartbeat = setInterval(() => {
        (async () => {
          try {
            await this._rpcWebSocket.notify('ping');
          } catch {}
        })();
      }, 5e3)),
      this._updateSubscriptions();
  }
  _wsOnError(t) {
    (this._rpcWebSocketConnected = !1), console.error('ws error:', t.message);
  }
  _wsOnClose(t) {
    if (
      ((this._rpcWebSocketConnected = !1),
      (this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER),
      this._rpcWebSocketIdleTimeout &&
        (clearTimeout(this._rpcWebSocketIdleTimeout), (this._rpcWebSocketIdleTimeout = null)),
      this._rpcWebSocketHeartbeat &&
        (clearInterval(this._rpcWebSocketHeartbeat), (this._rpcWebSocketHeartbeat = null)),
      t === 1e3)
    ) {
      this._updateSubscriptions();
      return;
    }
    (this._subscriptionCallbacksByServerSubscriptionId = {}),
      Object.entries(this._subscriptionsByHash).forEach(([n, r]) => {
        this._setSubscription(n, { ...r, state: 'pending' });
      });
  }
  _setSubscription(t, n) {
    var i;
    const r = (i = this._subscriptionsByHash[t]) == null ? void 0 : i.state;
    if (((this._subscriptionsByHash[t] = n), r !== n.state)) {
      const s = this._subscriptionStateChangeCallbacksByHash[t];
      s &&
        s.forEach((o) => {
          try {
            o(n.state);
          } catch {}
        });
    }
  }
  _onSubscriptionStateChange(t, n) {
    var r;
    const i = this._subscriptionHashByClientSubscriptionId[t];
    if (i == null) return () => {};
    const s = (r = this._subscriptionStateChangeCallbacksByHash)[i] || (r[i] = new Set());
    return (
      s.add(n),
      () => {
        s.delete(n), s.size === 0 && delete this._subscriptionStateChangeCallbacksByHash[i];
      }
    );
  }
  async _updateSubscriptions() {
    if (Object.keys(this._subscriptionsByHash).length === 0) {
      this._rpcWebSocketConnected &&
        ((this._rpcWebSocketConnected = !1),
        (this._rpcWebSocketIdleTimeout = setTimeout(() => {
          this._rpcWebSocketIdleTimeout = null;
          try {
            this._rpcWebSocket.close();
          } catch (r) {
            r instanceof Error && console.log(`Error when closing socket connection: ${r.message}`);
          }
        }, 500)));
      return;
    }
    if (
      (this._rpcWebSocketIdleTimeout !== null &&
        (clearTimeout(this._rpcWebSocketIdleTimeout),
        (this._rpcWebSocketIdleTimeout = null),
        (this._rpcWebSocketConnected = !0)),
      !this._rpcWebSocketConnected)
    ) {
      this._rpcWebSocket.connect();
      return;
    }
    const t = this._rpcWebSocketGeneration,
      n = () => t === this._rpcWebSocketGeneration;
    await Promise.all(
      Object.keys(this._subscriptionsByHash).map(async (r) => {
        const i = this._subscriptionsByHash[r];
        if (i !== void 0)
          switch (i.state) {
            case 'pending':
            case 'unsubscribed':
              if (i.callbacks.size === 0) {
                delete this._subscriptionsByHash[r],
                  i.state === 'unsubscribed' &&
                    delete this._subscriptionCallbacksByServerSubscriptionId[
                      i.serverSubscriptionId
                    ],
                  await this._updateSubscriptions();
                return;
              }
              await (async () => {
                const { args: s, method: o } = i;
                try {
                  this._setSubscription(r, { ...i, state: 'subscribing' });
                  const a = await this._rpcWebSocket.call(o, s);
                  this._setSubscription(r, { ...i, serverSubscriptionId: a, state: 'subscribed' }),
                    (this._subscriptionCallbacksByServerSubscriptionId[a] = i.callbacks),
                    await this._updateSubscriptions();
                } catch (a) {
                  if (
                    (a instanceof Error && console.error(`${o} error for argument`, s, a.message),
                    !n())
                  )
                    return;
                  this._setSubscription(r, { ...i, state: 'pending' }),
                    await this._updateSubscriptions();
                }
              })();
              break;
            case 'subscribed':
              i.callbacks.size === 0 &&
                (await (async () => {
                  const { serverSubscriptionId: s, unsubscribeMethod: o } = i;
                  if (this._subscriptionsAutoDisposedByRpc.has(s))
                    this._subscriptionsAutoDisposedByRpc.delete(s);
                  else {
                    this._setSubscription(r, { ...i, state: 'unsubscribing' }),
                      this._setSubscription(r, { ...i, state: 'unsubscribing' });
                    try {
                      await this._rpcWebSocket.call(o, [s]);
                    } catch (a) {
                      if ((a instanceof Error && console.error(`${o} error:`, a.message), !n()))
                        return;
                      this._setSubscription(r, { ...i, state: 'subscribed' }),
                        await this._updateSubscriptions();
                      return;
                    }
                  }
                  this._setSubscription(r, { ...i, state: 'unsubscribed' }),
                    await this._updateSubscriptions();
                })());
              break;
          }
      })
    );
  }
  _handleServerNotification(t, n) {
    const r = this._subscriptionCallbacksByServerSubscriptionId[t];
    r !== void 0 &&
      r.forEach((i) => {
        try {
          i(...n);
        } catch (s) {
          console.error(s);
        }
      });
  }
  _wsOnAccountNotification(t) {
    const { result: n, subscription: r } = me(t, fte);
    this._handleServerNotification(r, [n.value, n.context]);
  }
  _makeSubscription(t, n) {
    const r = this._nextClientSubscriptionId++,
      i = $k([t.method, n]),
      s = this._subscriptionsByHash[i];
    return (
      s === void 0
        ? (this._subscriptionsByHash[i] = {
            ...t,
            args: n,
            callbacks: new Set([t.callback]),
            state: 'pending',
          })
        : s.callbacks.add(t.callback),
      (this._subscriptionHashByClientSubscriptionId[r] = i),
      (this._subscriptionDisposeFunctionsByClientSubscriptionId[r] = async () => {
        delete this._subscriptionDisposeFunctionsByClientSubscriptionId[r],
          delete this._subscriptionHashByClientSubscriptionId[r];
        const o = this._subscriptionsByHash[i];
        It(
          o !== void 0,
          `Could not find a \`Subscription\` when tearing down client subscription #${r}`
        ),
          o.callbacks.delete(t.callback),
          await this._updateSubscriptions();
      }),
      this._updateSubscriptions(),
      r
    );
  }
  onAccountChange(t, n, r) {
    const i = this._buildArgs([t.toBase58()], r || this._commitment || 'finalized', 'base64');
    return this._makeSubscription(
      { callback: n, method: 'accountSubscribe', unsubscribeMethod: 'accountUnsubscribe' },
      i
    );
  }
  async removeAccountChangeListener(t) {
    await this._unsubscribeClientSubscription(t, 'account change');
  }
  _wsOnProgramAccountNotification(t) {
    const { result: n, subscription: r } = me(t, pte);
    this._handleServerNotification(r, [
      { accountId: n.value.pubkey, accountInfo: n.value.account },
      n.context,
    ]);
  }
  onProgramAccountChange(t, n, r, i) {
    const s = this._buildArgs(
      [t.toBase58()],
      r || this._commitment || 'finalized',
      'base64',
      i ? { filters: i } : void 0
    );
    return this._makeSubscription(
      { callback: n, method: 'programSubscribe', unsubscribeMethod: 'programUnsubscribe' },
      s
    );
  }
  async removeProgramAccountChangeListener(t) {
    await this._unsubscribeClientSubscription(t, 'program account change');
  }
  onLogs(t, n, r) {
    const i = this._buildArgs(
      [typeof t == 'object' ? { mentions: [t.toString()] } : t],
      r || this._commitment || 'finalized'
    );
    return this._makeSubscription(
      { callback: n, method: 'logsSubscribe', unsubscribeMethod: 'logsUnsubscribe' },
      i
    );
  }
  async removeOnLogsListener(t) {
    await this._unsubscribeClientSubscription(t, 'logs');
  }
  _wsOnLogsNotification(t) {
    const { result: n, subscription: r } = me(t, Vte);
    this._handleServerNotification(r, [n.value, n.context]);
  }
  _wsOnSlotNotification(t) {
    const { result: n, subscription: r } = me(t, yte);
    this._handleServerNotification(r, [n]);
  }
  onSlotChange(t) {
    return this._makeSubscription(
      { callback: t, method: 'slotSubscribe', unsubscribeMethod: 'slotUnsubscribe' },
      []
    );
  }
  async removeSlotChangeListener(t) {
    await this._unsubscribeClientSubscription(t, 'slot change');
  }
  _wsOnSlotUpdatesNotification(t) {
    const { result: n, subscription: r } = me(t, mte);
    this._handleServerNotification(r, [n]);
  }
  onSlotUpdate(t) {
    return this._makeSubscription(
      {
        callback: t,
        method: 'slotsUpdatesSubscribe',
        unsubscribeMethod: 'slotsUpdatesUnsubscribe',
      },
      []
    );
  }
  async removeSlotUpdateListener(t) {
    await this._unsubscribeClientSubscription(t, 'slot update');
  }
  async _unsubscribeClientSubscription(t, n) {
    const r = this._subscriptionDisposeFunctionsByClientSubscriptionId[t];
    r
      ? await r()
      : console.warn(
          `Ignored unsubscribe request because an active subscription with id \`${t}\` for '${n}' events could not be found.`
        );
  }
  _buildArgs(t, n, r, i) {
    const s = n || this._commitment;
    if (s || r || i) {
      let o = {};
      r && (o.encoding = r), s && (o.commitment = s), i && (o = Object.assign(o, i)), t.push(o);
    }
    return t;
  }
  _buildArgsAtLeastConfirmed(t, n, r, i) {
    const s = n || this._commitment;
    if (s && !['confirmed', 'finalized'].includes(s))
      throw new Error(
        'Using Connection with default commitment: `' +
          this._commitment +
          '`, but method requires at least `confirmed`'
      );
    return this._buildArgs(t, n, r, i);
  }
  _wsOnSignatureNotification(t) {
    const { result: n, subscription: r } = me(t, wte);
    n.value !== 'receivedSignature' && this._subscriptionsAutoDisposedByRpc.add(r),
      this._handleServerNotification(
        r,
        n.value === 'receivedSignature'
          ? [{ type: 'received' }, n.context]
          : [{ type: 'status', result: n.value }, n.context]
      );
  }
  onSignature(t, n, r) {
    const i = this._buildArgs([t], r || this._commitment || 'finalized'),
      s = this._makeSubscription(
        {
          callback: (o, a) => {
            if (o.type === 'status') {
              n(o.result, a);
              try {
                this.removeSignatureListener(s);
              } catch {}
            }
          },
          method: 'signatureSubscribe',
          unsubscribeMethod: 'signatureUnsubscribe',
        },
        i
      );
    return s;
  }
  onSignatureWithOptions(t, n, r) {
    const { commitment: i, ...s } = {
        ...r,
        commitment: (r && r.commitment) || this._commitment || 'finalized',
      },
      o = this._buildArgs([t], i, void 0, s),
      a = this._makeSubscription(
        {
          callback: (c, u) => {
            n(c, u);
            try {
              this.removeSignatureListener(a);
            } catch {}
          },
          method: 'signatureSubscribe',
          unsubscribeMethod: 'signatureUnsubscribe',
        },
        o
      );
    return a;
  }
  async removeSignatureListener(t) {
    await this._unsubscribeClientSubscription(t, 'signature result');
  }
  _wsOnRootNotification(t) {
    const { result: n, subscription: r } = me(t, vte);
    this._handleServerNotification(r, [n]);
  }
  onRootChange(t) {
    return this._makeSubscription(
      { callback: t, method: 'rootSubscribe', unsubscribeMethod: 'rootUnsubscribe' },
      []
    );
  }
  async removeRootChangeListener(t) {
    await this._unsubscribeClientSubscription(t, 'root change');
  }
}
class nu {
  constructor(t) {
    (this._keypair = void 0), (this._keypair = t ?? jk());
  }
  static generate() {
    return new nu(jk());
  }
  static fromSecretKey(t, n) {
    if (t.byteLength !== 64) throw new Error('bad secret key size');
    const r = t.slice(32, 64);
    if (!n || !n.skipValidation) {
      const i = t.slice(0, 32),
        s = Fy(i);
      for (let o = 0; o < 32; o++)
        if (r[o] !== s[o]) throw new Error('provided secretKey is invalid');
    }
    return new nu({ publicKey: r, secretKey: t });
  }
  static fromSeed(t) {
    const n = Fy(t),
      r = new Uint8Array(64);
    return r.set(t), r.set(n, 32), new nu({ publicKey: n, secretKey: r });
  }
  get publicKey() {
    return new ge(this._keypair.publicKey);
  }
  get secretKey() {
    return new Uint8Array(this._keypair.secretKey);
  }
}
const Gs = Object.freeze({
  CreateLookupTable: {
    index: 0,
    layout: De([Ne('instruction'), Iu('recentSlot'), wt('bumpSeed')]),
  },
  FreezeLookupTable: { index: 1, layout: De([Ne('instruction')]) },
  ExtendLookupTable: {
    index: 2,
    layout: De([Ne('instruction'), Iu(), ur(dt(), Ha(Ne(), -8), 'addresses')]),
  },
  DeactivateLookupTable: { index: 3, layout: De([Ne('instruction')]) },
  CloseLookupTable: { index: 4, layout: De([Ne('instruction')]) },
});
class Gte {
  constructor() {}
  static decodeInstructionType(t) {
    this.checkProgramId(t.programId);
    const r = Ne('instruction').decode(t.data);
    let i;
    for (const [s, o] of Object.entries(Gs))
      if (o.index == r) {
        i = s;
        break;
      }
    if (!i) throw new Error('Invalid Instruction. Should be a LookupTable Instruction');
    return i;
  }
  static decodeCreateLookupTable(t) {
    this.checkProgramId(t.programId), this.checkKeysLength(t.keys, 4);
    const { recentSlot: n } = Pt(Gs.CreateLookupTable, t.data);
    return { authority: t.keys[1].pubkey, payer: t.keys[2].pubkey, recentSlot: Number(n) };
  }
  static decodeExtendLookupTable(t) {
    if ((this.checkProgramId(t.programId), t.keys.length < 2))
      throw new Error(`invalid instruction; found ${t.keys.length} keys, expected at least 2`);
    const { addresses: n } = Pt(Gs.ExtendLookupTable, t.data);
    return {
      lookupTable: t.keys[0].pubkey,
      authority: t.keys[1].pubkey,
      payer: t.keys.length > 2 ? t.keys[2].pubkey : void 0,
      addresses: n.map((r) => new ge(r)),
    };
  }
  static decodeCloseLookupTable(t) {
    return (
      this.checkProgramId(t.programId),
      this.checkKeysLength(t.keys, 3),
      { lookupTable: t.keys[0].pubkey, authority: t.keys[1].pubkey, recipient: t.keys[2].pubkey }
    );
  }
  static decodeFreezeLookupTable(t) {
    return (
      this.checkProgramId(t.programId),
      this.checkKeysLength(t.keys, 2),
      { lookupTable: t.keys[0].pubkey, authority: t.keys[1].pubkey }
    );
  }
  static decodeDeactivateLookupTable(t) {
    return (
      this.checkProgramId(t.programId),
      this.checkKeysLength(t.keys, 2),
      { lookupTable: t.keys[0].pubkey, authority: t.keys[1].pubkey }
    );
  }
  static checkProgramId(t) {
    if (!t.equals(SI.programId))
      throw new Error('invalid instruction; programId is not AddressLookupTable Program');
  }
  static checkKeysLength(t, n) {
    if (t.length < n)
      throw new Error(`invalid instruction; found ${t.length} keys, expected at least ${n}`);
  }
}
class SI {
  constructor() {}
  static createLookupTable(t) {
    const [n, r] = ge.findProgramAddressSync(
        [t.authority.toBuffer(), LP(BigInt(t.recentSlot), 8)],
        this.programId
      ),
      i = Gs.CreateLookupTable,
      s = _t(i, { recentSlot: BigInt(t.recentSlot), bumpSeed: r }),
      o = [
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: t.authority, isSigner: !0, isWritable: !1 },
        { pubkey: t.payer, isSigner: !0, isWritable: !0 },
        { pubkey: Qn.programId, isSigner: !1, isWritable: !1 },
      ];
    return [new Lt({ programId: this.programId, keys: o, data: s }), n];
  }
  static freezeLookupTable(t) {
    const n = Gs.FreezeLookupTable,
      r = _t(n),
      i = [
        { pubkey: t.lookupTable, isSigner: !1, isWritable: !0 },
        { pubkey: t.authority, isSigner: !0, isWritable: !1 },
      ];
    return new Lt({ programId: this.programId, keys: i, data: r });
  }
  static extendLookupTable(t) {
    const n = Gs.ExtendLookupTable,
      r = _t(n, { addresses: t.addresses.map((s) => s.toBytes()) }),
      i = [
        { pubkey: t.lookupTable, isSigner: !1, isWritable: !0 },
        { pubkey: t.authority, isSigner: !0, isWritable: !1 },
      ];
    return (
      t.payer &&
        i.push(
          { pubkey: t.payer, isSigner: !0, isWritable: !0 },
          { pubkey: Qn.programId, isSigner: !1, isWritable: !1 }
        ),
      new Lt({ programId: this.programId, keys: i, data: r })
    );
  }
  static deactivateLookupTable(t) {
    const n = Gs.DeactivateLookupTable,
      r = _t(n),
      i = [
        { pubkey: t.lookupTable, isSigner: !1, isWritable: !0 },
        { pubkey: t.authority, isSigner: !0, isWritable: !1 },
      ];
    return new Lt({ programId: this.programId, keys: i, data: r });
  }
  static closeLookupTable(t) {
    const n = Gs.CloseLookupTable,
      r = _t(n),
      i = [
        { pubkey: t.lookupTable, isSigner: !1, isWritable: !0 },
        { pubkey: t.authority, isSigner: !0, isWritable: !1 },
        { pubkey: t.recipient, isSigner: !1, isWritable: !0 },
      ];
    return new Lt({ programId: this.programId, keys: i, data: r });
  }
}
SI.programId = new ge('AddressLookupTab1e1111111111111111111111111');
class qte {
  constructor() {}
  static decodeInstructionType(t) {
    this.checkProgramId(t.programId);
    const r = wt('instruction').decode(t.data);
    let i;
    for (const [s, o] of Object.entries(fs))
      if (o.index == r) {
        i = s;
        break;
      }
    if (!i) throw new Error('Instruction type incorrect; not a ComputeBudgetInstruction');
    return i;
  }
  static decodeRequestUnits(t) {
    this.checkProgramId(t.programId);
    const { units: n, additionalFee: r } = Pt(fs.RequestUnits, t.data);
    return { units: n, additionalFee: r };
  }
  static decodeRequestHeapFrame(t) {
    this.checkProgramId(t.programId);
    const { bytes: n } = Pt(fs.RequestHeapFrame, t.data);
    return { bytes: n };
  }
  static decodeSetComputeUnitLimit(t) {
    this.checkProgramId(t.programId);
    const { units: n } = Pt(fs.SetComputeUnitLimit, t.data);
    return { units: n };
  }
  static decodeSetComputeUnitPrice(t) {
    this.checkProgramId(t.programId);
    const { microLamports: n } = Pt(fs.SetComputeUnitPrice, t.data);
    return { microLamports: n };
  }
  static checkProgramId(t) {
    if (!t.equals(EI.programId))
      throw new Error('invalid instruction; programId is not ComputeBudgetProgram');
  }
}
const fs = Object.freeze({
  RequestUnits: { index: 0, layout: De([wt('instruction'), Ne('units'), Ne('additionalFee')]) },
  RequestHeapFrame: { index: 1, layout: De([wt('instruction'), Ne('bytes')]) },
  SetComputeUnitLimit: { index: 2, layout: De([wt('instruction'), Ne('units')]) },
  SetComputeUnitPrice: { index: 3, layout: De([wt('instruction'), Iu('microLamports')]) },
});
class EI {
  constructor() {}
  static requestUnits(t) {
    const n = fs.RequestUnits,
      r = _t(n, t);
    return new Lt({ keys: [], programId: this.programId, data: r });
  }
  static requestHeapFrame(t) {
    const n = fs.RequestHeapFrame,
      r = _t(n, t);
    return new Lt({ keys: [], programId: this.programId, data: r });
  }
  static setComputeUnitLimit(t) {
    const n = fs.SetComputeUnitLimit,
      r = _t(n, t);
    return new Lt({ keys: [], programId: this.programId, data: r });
  }
  static setComputeUnitPrice(t) {
    const n = fs.SetComputeUnitPrice,
      r = _t(n, { microLamports: BigInt(t.microLamports) });
    return new Lt({ keys: [], programId: this.programId, data: r });
  }
}
EI.programId = new ge('ComputeBudget111111111111111111111111111111');
const Wk = 64,
  Hk = 32,
  Gk = 64,
  qk = De([
    wt('numSignatures'),
    wt('padding'),
    xi('signatureOffset'),
    xi('signatureInstructionIndex'),
    xi('publicKeyOffset'),
    xi('publicKeyInstructionIndex'),
    xi('messageDataOffset'),
    xi('messageDataSize'),
    xi('messageInstructionIndex'),
  ]);
class cm {
  constructor() {}
  static createInstructionWithPublicKey(t) {
    const { publicKey: n, message: r, signature: i, instructionIndex: s } = t;
    It(n.length === Hk, `Public Key must be ${Hk} bytes but received ${n.length} bytes`),
      It(i.length === Gk, `Signature must be ${Gk} bytes but received ${i.length} bytes`);
    const o = qk.span,
      a = o + n.length,
      c = a + i.length,
      u = 1,
      l = he.alloc(c + r.length),
      d = s ?? 65535;
    return (
      qk.encode(
        {
          numSignatures: u,
          padding: 0,
          signatureOffset: a,
          signatureInstructionIndex: d,
          publicKeyOffset: o,
          publicKeyInstructionIndex: d,
          messageDataOffset: c,
          messageDataSize: r.length,
          messageInstructionIndex: d,
        },
        l
      ),
      l.fill(n, o),
      l.fill(i, a),
      l.fill(r, c),
      new Lt({ keys: [], programId: cm.programId, data: l })
    );
  }
  static createInstructionWithPrivateKey(t) {
    const { privateKey: n, message: r, instructionIndex: i } = t;
    It(n.length === Wk, `Private key must be ${Wk} bytes but received ${n.length} bytes`);
    try {
      const s = nu.fromSecretKey(n),
        o = s.publicKey.toBytes(),
        a = fI(r, s.secretKey);
      return this.createInstructionWithPublicKey({
        publicKey: o,
        message: r,
        signature: a,
        instructionIndex: i,
      });
    } catch (s) {
      throw new Error(`Error creating instruction; ${s}`);
    }
  }
}
cm.programId = new ge('Ed25519SigVerify111111111111111111111111111');
jP.hmacSha256Sync = (e, ...t) => {
  const n = tB.create(XS, e);
  return t.forEach((r) => n.update(r)), n.digest();
};
const Yte = (e, t) => _L(e, t, { der: !1, recovered: !0 });
jP.isValidPrivateKey;
const Zte = lS,
  Yk = 32,
  uv = 20,
  Zk = 64,
  Jte = 11,
  lv = De([
    wt('numSignatures'),
    xi('signatureOffset'),
    wt('signatureInstructionIndex'),
    xi('ethAddressOffset'),
    wt('ethAddressInstructionIndex'),
    xi('messageDataOffset'),
    xi('messageDataSize'),
    wt('messageInstructionIndex'),
    Xt(20, 'ethAddress'),
    Xt(64, 'signature'),
    wt('recoveryId'),
  ]);
class ru {
  constructor() {}
  static publicKeyToEthAddress(t) {
    It(t.length === Zk, `Public key must be ${Zk} bytes but received ${t.length} bytes`);
    try {
      return he.from(Nk(ot(t))).slice(-uv);
    } catch (n) {
      throw new Error(`Error constructing Ethereum address: ${n}`);
    }
  }
  static createInstructionWithPublicKey(t) {
    const { publicKey: n, message: r, signature: i, recoveryId: s, instructionIndex: o } = t;
    return ru.createInstructionWithEthAddress({
      ethAddress: ru.publicKeyToEthAddress(n),
      message: r,
      signature: i,
      recoveryId: s,
      instructionIndex: o,
    });
  }
  static createInstructionWithEthAddress(t) {
    const { ethAddress: n, message: r, signature: i, recoveryId: s, instructionIndex: o = 0 } = t;
    let a;
    typeof n == 'string'
      ? n.startsWith('0x')
        ? (a = he.from(n.substr(2), 'hex'))
        : (a = he.from(n, 'hex'))
      : (a = n),
      It(a.length === uv, `Address must be ${uv} bytes but received ${a.length} bytes`);
    const c = 1 + Jte,
      u = c,
      l = c + a.length,
      d = l + i.length + 1,
      f = 1,
      h = he.alloc(lv.span + r.length);
    return (
      lv.encode(
        {
          numSignatures: f,
          signatureOffset: l,
          signatureInstructionIndex: o,
          ethAddressOffset: u,
          ethAddressInstructionIndex: o,
          messageDataOffset: d,
          messageDataSize: r.length,
          messageInstructionIndex: o,
          signature: ot(i),
          ethAddress: ot(a),
          recoveryId: s,
        },
        h
      ),
      h.fill(ot(r), lv.span),
      new Lt({ keys: [], programId: ru.programId, data: h })
    );
  }
  static createInstructionWithPrivateKey(t) {
    const { privateKey: n, message: r, instructionIndex: i } = t;
    It(n.length === Yk, `Private key must be ${Yk} bytes but received ${n.length} bytes`);
    try {
      const s = ot(n),
        o = Zte(s, !1).slice(1),
        a = he.from(Nk(ot(r))),
        [c, u] = Yte(a, s);
      return this.createInstructionWithPublicKey({
        publicKey: o,
        message: r,
        signature: c,
        recoveryId: u,
        instructionIndex: i,
      });
    } catch (s) {
      throw new Error(`Error creating instruction; ${s}`);
    }
  }
}
ru.programId = new ge('KeccakSecp256k11111111111111111111111111111');
const wB = new ge('StakeConfig11111111111111111111111111111111');
class vB {
  constructor(t, n) {
    (this.staker = void 0), (this.withdrawer = void 0), (this.staker = t), (this.withdrawer = n);
  }
}
class sd {
  constructor(t, n, r) {
    (this.unixTimestamp = void 0),
      (this.epoch = void 0),
      (this.custodian = void 0),
      (this.unixTimestamp = t),
      (this.epoch = n),
      (this.custodian = r);
  }
}
sd.default = new sd(0, 0, ge.default);
class Xte {
  constructor() {}
  static decodeInstructionType(t) {
    this.checkProgramId(t.programId);
    const r = Ne('instruction').decode(t.data);
    let i;
    for (const [s, o] of Object.entries(Fn))
      if (o.index == r) {
        i = s;
        break;
      }
    if (!i) throw new Error('Instruction type incorrect; not a StakeInstruction');
    return i;
  }
  static decodeInitialize(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
    const { authorized: n, lockup: r } = Pt(Fn.Initialize, t.data);
    return {
      stakePubkey: t.keys[0].pubkey,
      authorized: new vB(new ge(n.staker), new ge(n.withdrawer)),
      lockup: new sd(r.unixTimestamp, r.epoch, new ge(r.custodian)),
    };
  }
  static decodeDelegate(t) {
    return (
      this.checkProgramId(t.programId),
      this.checkKeyLength(t.keys, 6),
      Pt(Fn.Delegate, t.data),
      {
        stakePubkey: t.keys[0].pubkey,
        votePubkey: t.keys[1].pubkey,
        authorizedPubkey: t.keys[5].pubkey,
      }
    );
  }
  static decodeAuthorize(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
    const { newAuthorized: n, stakeAuthorizationType: r } = Pt(Fn.Authorize, t.data),
      i = {
        stakePubkey: t.keys[0].pubkey,
        authorizedPubkey: t.keys[2].pubkey,
        newAuthorizedPubkey: new ge(n),
        stakeAuthorizationType: { index: r },
      };
    return t.keys.length > 3 && (i.custodianPubkey = t.keys[3].pubkey), i;
  }
  static decodeAuthorizeWithSeed(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
    const {
        newAuthorized: n,
        stakeAuthorizationType: r,
        authoritySeed: i,
        authorityOwner: s,
      } = Pt(Fn.AuthorizeWithSeed, t.data),
      o = {
        stakePubkey: t.keys[0].pubkey,
        authorityBase: t.keys[1].pubkey,
        authoritySeed: i,
        authorityOwner: new ge(s),
        newAuthorizedPubkey: new ge(n),
        stakeAuthorizationType: { index: r },
      };
    return t.keys.length > 3 && (o.custodianPubkey = t.keys[3].pubkey), o;
  }
  static decodeSplit(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
    const { lamports: n } = Pt(Fn.Split, t.data);
    return {
      stakePubkey: t.keys[0].pubkey,
      splitStakePubkey: t.keys[1].pubkey,
      authorizedPubkey: t.keys[2].pubkey,
      lamports: n,
    };
  }
  static decodeMerge(t) {
    return (
      this.checkProgramId(t.programId),
      this.checkKeyLength(t.keys, 3),
      Pt(Fn.Merge, t.data),
      {
        stakePubkey: t.keys[0].pubkey,
        sourceStakePubKey: t.keys[1].pubkey,
        authorizedPubkey: t.keys[4].pubkey,
      }
    );
  }
  static decodeWithdraw(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 5);
    const { lamports: n } = Pt(Fn.Withdraw, t.data),
      r = {
        stakePubkey: t.keys[0].pubkey,
        toPubkey: t.keys[1].pubkey,
        authorizedPubkey: t.keys[4].pubkey,
        lamports: n,
      };
    return t.keys.length > 5 && (r.custodianPubkey = t.keys[5].pubkey), r;
  }
  static decodeDeactivate(t) {
    return (
      this.checkProgramId(t.programId),
      this.checkKeyLength(t.keys, 3),
      Pt(Fn.Deactivate, t.data),
      { stakePubkey: t.keys[0].pubkey, authorizedPubkey: t.keys[2].pubkey }
    );
  }
  static checkProgramId(t) {
    if (!t.equals(um.programId))
      throw new Error('invalid instruction; programId is not StakeProgram');
  }
  static checkKeyLength(t, n) {
    if (t.length < n)
      throw new Error(`invalid instruction; found ${t.length} keys, expected at least ${n}`);
  }
}
const Fn = Object.freeze({
    Initialize: { index: 0, layout: De([Ne('instruction'), ree(), iee()]) },
    Authorize: {
      index: 1,
      layout: De([Ne('instruction'), dt('newAuthorized'), Ne('stakeAuthorizationType')]),
    },
    Delegate: { index: 2, layout: De([Ne('instruction')]) },
    Split: { index: 3, layout: De([Ne('instruction'), ai('lamports')]) },
    Withdraw: { index: 4, layout: De([Ne('instruction'), ai('lamports')]) },
    Deactivate: { index: 5, layout: De([Ne('instruction')]) },
    Merge: { index: 7, layout: De([Ne('instruction')]) },
    AuthorizeWithSeed: {
      index: 8,
      layout: De([
        Ne('instruction'),
        dt('newAuthorized'),
        Ne('stakeAuthorizationType'),
        $a('authoritySeed'),
        dt('authorityOwner'),
      ]),
    },
  }),
  Qte = Object.freeze({ Staker: { index: 0 }, Withdrawer: { index: 1 } });
class um {
  constructor() {}
  static initialize(t) {
    const { stakePubkey: n, authorized: r, lockup: i } = t,
      s = i || sd.default,
      o = Fn.Initialize,
      a = _t(o, {
        authorized: { staker: ot(r.staker.toBuffer()), withdrawer: ot(r.withdrawer.toBuffer()) },
        lockup: {
          unixTimestamp: s.unixTimestamp,
          epoch: s.epoch,
          custodian: ot(s.custodian.toBuffer()),
        },
      }),
      c = {
        keys: [
          { pubkey: n, isSigner: !1, isWritable: !0 },
          { pubkey: Au, isSigner: !1, isWritable: !1 },
        ],
        programId: this.programId,
        data: a,
      };
    return new Lt(c);
  }
  static createAccountWithSeed(t) {
    const n = new jt();
    n.add(
      Qn.createAccountWithSeed({
        fromPubkey: t.fromPubkey,
        newAccountPubkey: t.stakePubkey,
        basePubkey: t.basePubkey,
        seed: t.seed,
        lamports: t.lamports,
        space: this.space,
        programId: this.programId,
      })
    );
    const { stakePubkey: r, authorized: i, lockup: s } = t;
    return n.add(this.initialize({ stakePubkey: r, authorized: i, lockup: s }));
  }
  static createAccount(t) {
    const n = new jt();
    n.add(
      Qn.createAccount({
        fromPubkey: t.fromPubkey,
        newAccountPubkey: t.stakePubkey,
        lamports: t.lamports,
        space: this.space,
        programId: this.programId,
      })
    );
    const { stakePubkey: r, authorized: i, lockup: s } = t;
    return n.add(this.initialize({ stakePubkey: r, authorized: i, lockup: s }));
  }
  static delegate(t) {
    const { stakePubkey: n, authorizedPubkey: r, votePubkey: i } = t,
      s = Fn.Delegate,
      o = _t(s);
    return new jt().add({
      keys: [
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: i, isSigner: !1, isWritable: !1 },
        { pubkey: us, isSigner: !1, isWritable: !1 },
        { pubkey: iy, isSigner: !1, isWritable: !1 },
        { pubkey: wB, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ],
      programId: this.programId,
      data: o,
    });
  }
  static authorize(t) {
    const {
        stakePubkey: n,
        authorizedPubkey: r,
        newAuthorizedPubkey: i,
        stakeAuthorizationType: s,
        custodianPubkey: o,
      } = t,
      a = Fn.Authorize,
      c = _t(a, { newAuthorized: ot(i.toBuffer()), stakeAuthorizationType: s.index }),
      u = [
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: us, isSigner: !1, isWritable: !0 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ];
    return (
      o && u.push({ pubkey: o, isSigner: !1, isWritable: !1 }),
      new jt().add({ keys: u, programId: this.programId, data: c })
    );
  }
  static authorizeWithSeed(t) {
    const {
        stakePubkey: n,
        authorityBase: r,
        authoritySeed: i,
        authorityOwner: s,
        newAuthorizedPubkey: o,
        stakeAuthorizationType: a,
        custodianPubkey: c,
      } = t,
      u = Fn.AuthorizeWithSeed,
      l = _t(u, {
        newAuthorized: ot(o.toBuffer()),
        stakeAuthorizationType: a.index,
        authoritySeed: i,
        authorityOwner: ot(s.toBuffer()),
      }),
      d = [
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
        { pubkey: us, isSigner: !1, isWritable: !1 },
      ];
    return (
      c && d.push({ pubkey: c, isSigner: !1, isWritable: !1 }),
      new jt().add({ keys: d, programId: this.programId, data: l })
    );
  }
  static splitInstruction(t) {
    const { stakePubkey: n, authorizedPubkey: r, splitStakePubkey: i, lamports: s } = t,
      o = Fn.Split,
      a = _t(o, { lamports: s });
    return new Lt({
      keys: [
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: i, isSigner: !1, isWritable: !0 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ],
      programId: this.programId,
      data: a,
    });
  }
  static split(t) {
    const n = new jt();
    return (
      n.add(
        Qn.createAccount({
          fromPubkey: t.authorizedPubkey,
          newAccountPubkey: t.splitStakePubkey,
          lamports: 0,
          space: this.space,
          programId: this.programId,
        })
      ),
      n.add(this.splitInstruction(t))
    );
  }
  static splitWithSeed(t) {
    const {
        stakePubkey: n,
        authorizedPubkey: r,
        splitStakePubkey: i,
        basePubkey: s,
        seed: o,
        lamports: a,
      } = t,
      c = new jt();
    return (
      c.add(
        Qn.allocate({
          accountPubkey: i,
          basePubkey: s,
          seed: o,
          space: this.space,
          programId: this.programId,
        })
      ),
      c.add(
        this.splitInstruction({
          stakePubkey: n,
          authorizedPubkey: r,
          splitStakePubkey: i,
          lamports: a,
        })
      )
    );
  }
  static merge(t) {
    const { stakePubkey: n, sourceStakePubKey: r, authorizedPubkey: i } = t,
      s = Fn.Merge,
      o = _t(s);
    return new jt().add({
      keys: [
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: r, isSigner: !1, isWritable: !0 },
        { pubkey: us, isSigner: !1, isWritable: !1 },
        { pubkey: iy, isSigner: !1, isWritable: !1 },
        { pubkey: i, isSigner: !0, isWritable: !1 },
      ],
      programId: this.programId,
      data: o,
    });
  }
  static withdraw(t) {
    const { stakePubkey: n, authorizedPubkey: r, toPubkey: i, lamports: s, custodianPubkey: o } = t,
      a = Fn.Withdraw,
      c = _t(a, { lamports: s }),
      u = [
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: i, isSigner: !1, isWritable: !0 },
        { pubkey: us, isSigner: !1, isWritable: !1 },
        { pubkey: iy, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ];
    return (
      o && u.push({ pubkey: o, isSigner: !1, isWritable: !1 }),
      new jt().add({ keys: u, programId: this.programId, data: c })
    );
  }
  static deactivate(t) {
    const { stakePubkey: n, authorizedPubkey: r } = t,
      i = Fn.Deactivate,
      s = _t(i);
    return new jt().add({
      keys: [
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: us, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ],
      programId: this.programId,
      data: s,
    });
  }
}
um.programId = new ge('Stake11111111111111111111111111111111111111');
um.space = 200;
class _B {
  constructor(t, n, r, i) {
    (this.nodePubkey = void 0),
      (this.authorizedVoter = void 0),
      (this.authorizedWithdrawer = void 0),
      (this.commission = void 0),
      (this.nodePubkey = t),
      (this.authorizedVoter = n),
      (this.authorizedWithdrawer = r),
      (this.commission = i);
  }
}
class ene {
  constructor() {}
  static decodeInstructionType(t) {
    this.checkProgramId(t.programId);
    const r = Ne('instruction').decode(t.data);
    let i;
    for (const [s, o] of Object.entries(qs))
      if (o.index == r) {
        i = s;
        break;
      }
    if (!i) throw new Error('Instruction type incorrect; not a VoteInstruction');
    return i;
  }
  static decodeInitializeAccount(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 4);
    const { voteInit: n } = Pt(qs.InitializeAccount, t.data);
    return {
      votePubkey: t.keys[0].pubkey,
      nodePubkey: t.keys[3].pubkey,
      voteInit: new _B(
        new ge(n.nodePubkey),
        new ge(n.authorizedVoter),
        new ge(n.authorizedWithdrawer),
        n.commission
      ),
    };
  }
  static decodeAuthorize(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
    const { newAuthorized: n, voteAuthorizationType: r } = Pt(qs.Authorize, t.data);
    return {
      votePubkey: t.keys[0].pubkey,
      authorizedPubkey: t.keys[2].pubkey,
      newAuthorizedPubkey: new ge(n),
      voteAuthorizationType: { index: r },
    };
  }
  static decodeAuthorizeWithSeed(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
    const {
      voteAuthorizeWithSeedArgs: {
        currentAuthorityDerivedKeyOwnerPubkey: n,
        currentAuthorityDerivedKeySeed: r,
        newAuthorized: i,
        voteAuthorizationType: s,
      },
    } = Pt(qs.AuthorizeWithSeed, t.data);
    return {
      currentAuthorityDerivedKeyBasePubkey: t.keys[2].pubkey,
      currentAuthorityDerivedKeyOwnerPubkey: new ge(n),
      currentAuthorityDerivedKeySeed: r,
      newAuthorizedPubkey: new ge(i),
      voteAuthorizationType: { index: s },
      votePubkey: t.keys[0].pubkey,
    };
  }
  static decodeWithdraw(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
    const { lamports: n } = Pt(qs.Withdraw, t.data);
    return {
      votePubkey: t.keys[0].pubkey,
      authorizedWithdrawerPubkey: t.keys[2].pubkey,
      lamports: n,
      toPubkey: t.keys[1].pubkey,
    };
  }
  static checkProgramId(t) {
    if (!t.equals(Zu.programId))
      throw new Error('invalid instruction; programId is not VoteProgram');
  }
  static checkKeyLength(t, n) {
    if (t.length < n)
      throw new Error(`invalid instruction; found ${t.length} keys, expected at least ${n}`);
  }
}
const qs = Object.freeze({
    InitializeAccount: { index: 0, layout: De([Ne('instruction'), see()]) },
    Authorize: {
      index: 1,
      layout: De([Ne('instruction'), dt('newAuthorized'), Ne('voteAuthorizationType')]),
    },
    Withdraw: { index: 3, layout: De([Ne('instruction'), ai('lamports')]) },
    AuthorizeWithSeed: { index: 10, layout: De([Ne('instruction'), oee()]) },
  }),
  tne = Object.freeze({ Voter: { index: 0 }, Withdrawer: { index: 1 } });
class Zu {
  constructor() {}
  static initializeAccount(t) {
    const { votePubkey: n, nodePubkey: r, voteInit: i } = t,
      s = qs.InitializeAccount,
      o = _t(s, {
        voteInit: {
          nodePubkey: ot(i.nodePubkey.toBuffer()),
          authorizedVoter: ot(i.authorizedVoter.toBuffer()),
          authorizedWithdrawer: ot(i.authorizedWithdrawer.toBuffer()),
          commission: i.commission,
        },
      }),
      a = {
        keys: [
          { pubkey: n, isSigner: !1, isWritable: !0 },
          { pubkey: Au, isSigner: !1, isWritable: !1 },
          { pubkey: us, isSigner: !1, isWritable: !1 },
          { pubkey: r, isSigner: !0, isWritable: !1 },
        ],
        programId: this.programId,
        data: o,
      };
    return new Lt(a);
  }
  static createAccount(t) {
    const n = new jt();
    return (
      n.add(
        Qn.createAccount({
          fromPubkey: t.fromPubkey,
          newAccountPubkey: t.votePubkey,
          lamports: t.lamports,
          space: this.space,
          programId: this.programId,
        })
      ),
      n.add(
        this.initializeAccount({
          votePubkey: t.votePubkey,
          nodePubkey: t.voteInit.nodePubkey,
          voteInit: t.voteInit,
        })
      )
    );
  }
  static authorize(t) {
    const {
        votePubkey: n,
        authorizedPubkey: r,
        newAuthorizedPubkey: i,
        voteAuthorizationType: s,
      } = t,
      o = qs.Authorize,
      a = _t(o, { newAuthorized: ot(i.toBuffer()), voteAuthorizationType: s.index }),
      c = [
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: us, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ];
    return new jt().add({ keys: c, programId: this.programId, data: a });
  }
  static authorizeWithSeed(t) {
    const {
        currentAuthorityDerivedKeyBasePubkey: n,
        currentAuthorityDerivedKeyOwnerPubkey: r,
        currentAuthorityDerivedKeySeed: i,
        newAuthorizedPubkey: s,
        voteAuthorizationType: o,
        votePubkey: a,
      } = t,
      c = qs.AuthorizeWithSeed,
      u = _t(c, {
        voteAuthorizeWithSeedArgs: {
          currentAuthorityDerivedKeyOwnerPubkey: ot(r.toBuffer()),
          currentAuthorityDerivedKeySeed: i,
          newAuthorized: ot(s.toBuffer()),
          voteAuthorizationType: o.index,
        },
      }),
      l = [
        { pubkey: a, isSigner: !1, isWritable: !0 },
        { pubkey: us, isSigner: !1, isWritable: !1 },
        { pubkey: n, isSigner: !0, isWritable: !1 },
      ];
    return new jt().add({ keys: l, programId: this.programId, data: u });
  }
  static withdraw(t) {
    const { votePubkey: n, authorizedWithdrawerPubkey: r, lamports: i, toPubkey: s } = t,
      o = qs.Withdraw,
      a = _t(o, { lamports: i }),
      c = [
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: s, isSigner: !1, isWritable: !0 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ];
    return new jt().add({ keys: c, programId: this.programId, data: a });
  }
  static safeWithdraw(t, n, r) {
    if (t.lamports > n - r)
      throw new Error('Withdraw will leave vote account with insuffcient funds.');
    return Zu.withdraw(t);
  }
}
Zu.programId = new ge('Vote111111111111111111111111111111111111111');
Zu.space = 3731;
const SB = new ge('Va1idator1nfo111111111111111111111111111111'),
  nne = ue({ name: pe(), website: He(pe()), details: He(pe()), keybaseUsername: He(pe()) });
class AI {
  constructor(t, n) {
    (this.key = void 0), (this.info = void 0), (this.key = t), (this.info = n);
  }
  static fromConfigData(t) {
    let n = [...t];
    if (Tr(n) !== 2) return null;
    const i = [];
    for (let s = 0; s < 2; s++) {
      const o = new ge(n.slice(0, Gr));
      n = n.slice(Gr);
      const a = n.slice(0, 1)[0] === 1;
      (n = n.slice(1)), i.push({ publicKey: o, isSigner: a });
    }
    if (i[0].publicKey.equals(SB) && i[1].isSigner) {
      const s = $a().decode(he.from(n)),
        o = JSON.parse(s);
      return SL(o, nne), new AI(i[1].publicKey, o);
    }
    return null;
  }
}
const rne = new ge('Vote111111111111111111111111111111111111111'),
  ine = De([
    dt('nodePubkey'),
    dt('authorizedWithdrawer'),
    wt('commission'),
    ir(),
    ur(De([ir('slot'), Ne('confirmationCount')]), Ha(Ne(), -8), 'votes'),
    wt('rootSlotValid'),
    ir('rootSlot'),
    ir(),
    ur(De([ir('epoch'), dt('authorizedVoter')]), Ha(Ne(), -8), 'authorizedVoters'),
    De(
      [
        ur(
          De([dt('authorizedPubkey'), ir('epochOfLastAuthorizedSwitch'), ir('targetEpoch')]),
          32,
          'buf'
        ),
        ir('idx'),
        wt('isEmpty'),
      ],
      'priorVoters'
    ),
    ir(),
    ur(De([ir('epoch'), ir('credits'), ir('prevCredits')]), Ha(Ne(), -8), 'epochCredits'),
    De([ir('slot'), ir('timestamp')], 'lastTimestamp'),
  ]);
class II {
  constructor(t) {
    (this.nodePubkey = void 0),
      (this.authorizedWithdrawer = void 0),
      (this.commission = void 0),
      (this.rootSlot = void 0),
      (this.votes = void 0),
      (this.authorizedVoters = void 0),
      (this.priorVoters = void 0),
      (this.epochCredits = void 0),
      (this.lastTimestamp = void 0),
      (this.nodePubkey = t.nodePubkey),
      (this.authorizedWithdrawer = t.authorizedWithdrawer),
      (this.commission = t.commission),
      (this.rootSlot = t.rootSlot),
      (this.votes = t.votes),
      (this.authorizedVoters = t.authorizedVoters),
      (this.priorVoters = t.priorVoters),
      (this.epochCredits = t.epochCredits),
      (this.lastTimestamp = t.lastTimestamp);
  }
  static fromAccountData(t) {
    const r = ine.decode(ot(t), 4);
    let i = r.rootSlot;
    return (
      r.rootSlotValid || (i = null),
      new II({
        nodePubkey: new ge(r.nodePubkey),
        authorizedWithdrawer: new ge(r.authorizedWithdrawer),
        commission: r.commission,
        votes: r.votes,
        rootSlot: i,
        authorizedVoters: r.authorizedVoters.map(sne),
        priorVoters: one(r.priorVoters),
        epochCredits: r.epochCredits,
        lastTimestamp: r.lastTimestamp,
      })
    );
  }
}
function sne({ authorizedVoter: e, epoch: t }) {
  return { epoch: t, authorizedVoter: new ge(e) };
}
function Jk({ authorizedPubkey: e, epochOfLastAuthorizedSwitch: t, targetEpoch: n }) {
  return { authorizedPubkey: new ge(e), epochOfLastAuthorizedSwitch: t, targetEpoch: n };
}
function one({ buf: e, idx: t, isEmpty: n }) {
  return n ? [] : [...e.slice(t + 1).map(Jk), ...e.slice(0, t).map(Jk)];
}
const Xk = {
  http: {
    devnet: 'http://api.devnet.solana.com',
    testnet: 'http://api.testnet.solana.com',
    'mainnet-beta': 'http://api.mainnet-beta.solana.com/',
  },
  https: {
    devnet: 'https://api.devnet.solana.com',
    testnet: 'https://api.testnet.solana.com',
    'mainnet-beta': 'https://api.mainnet-beta.solana.com/',
  },
};
function ane(e, t) {
  const n = t === !1 ? 'http' : 'https';
  if (!e) return Xk[n].devnet;
  const r = Xk[n][e];
  if (!r) throw new Error(`Unknown ${n} cluster: ${e}`);
  return r;
}
async function cne(e, t, n, r) {
  let i, s;
  (n && Object.prototype.hasOwnProperty.call(n, 'lastValidBlockHeight')) ||
  (n && Object.prototype.hasOwnProperty.call(n, 'nonceValue'))
    ? ((i = n), (s = r))
    : (s = n);
  const o = s && {
      skipPreflight: s.skipPreflight,
      preflightCommitment: s.preflightCommitment || s.commitment,
      minContextSlot: s.minContextSlot,
    },
    a = await e.sendRawTransaction(t, o),
    c = s && s.commitment,
    l = (await (i ? e.confirmTransaction(i, c) : e.confirmTransaction(a, c))).value;
  if (l.err) throw new Error(`Raw transaction ${a} failed (${JSON.stringify(l)})`);
  return a;
}
const une = 1e9,
  lne = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Account: eee,
        AddressLookupTableAccount: nE,
        AddressLookupTableInstruction: Gte,
        AddressLookupTableProgram: SI,
        Authorized: vB,
        BLOCKHASH_CACHE_TIMEOUT_MS: uB,
        BPF_LOADER_DEPRECATED_PROGRAM_ID: tee,
        BPF_LOADER_PROGRAM_ID: bee,
        BpfLoader: mee,
        COMPUTE_BUDGET_INSTRUCTION_LAYOUTS: fs,
        ComputeBudgetInstruction: qte,
        ComputeBudgetProgram: EI,
        Connection: Hte,
        Ed25519Program: cm,
        Enum: XQ,
        EpochSchedule: aB,
        FeeCalculatorLayout: sB,
        Keypair: nu,
        LAMPORTS_PER_SOL: une,
        LOOKUP_TABLE_INSTRUCTION_LAYOUTS: Gs,
        Loader: sc,
        Lockup: sd,
        MAX_SEED_LENGTH: rB,
        Message: zi,
        MessageAccountKeys: rd,
        MessageV0: ic,
        NONCE_ACCOUNT_LENGTH: eE,
        NonceAccount: sm,
        PACKET_DATA_SIZE: ua,
        PUBLIC_KEY_LENGTH: Gr,
        PublicKey: ge,
        SIGNATURE_LENGTH_IN_BYTES: Eu,
        SOLANA_SCHEMA: zl,
        STAKE_CONFIG_ID: wB,
        STAKE_INSTRUCTION_LAYOUTS: Fn,
        SYSTEM_INSTRUCTION_LAYOUTS: zt,
        SYSVAR_CLOCK_PUBKEY: us,
        SYSVAR_EPOCH_SCHEDULE_PUBKEY: cee,
        SYSVAR_INSTRUCTIONS_PUBKEY: uee,
        SYSVAR_RECENT_BLOCKHASHES_PUBKEY: ry,
        SYSVAR_RENT_PUBKEY: Au,
        SYSVAR_REWARDS_PUBKEY: lee,
        SYSVAR_SLOT_HASHES_PUBKEY: dee,
        SYSVAR_SLOT_HISTORY_PUBKEY: fee,
        SYSVAR_STAKE_HISTORY_PUBKEY: iy,
        Secp256k1Program: ru,
        SendTransactionError: tE,
        SolanaJSONRPCError: Ue,
        SolanaJSONRPCErrorCode: Eee,
        StakeAuthorizationLayout: Qte,
        StakeInstruction: Xte,
        StakeProgram: um,
        Struct: hI,
        SystemInstruction: gee,
        SystemProgram: Qn,
        Transaction: jt,
        TransactionExpiredBlockheightExceededError: pI,
        TransactionExpiredNonceInvalidError: Yc,
        TransactionExpiredTimeoutError: gI,
        TransactionInstruction: Lt,
        TransactionMessage: bI,
        get TransactionStatus() {
          return Ai;
        },
        VALIDATOR_INFO_KEY: SB,
        VERSION_PREFIX_MASK: rm,
        VOTE_PROGRAM_ID: rne,
        ValidatorInfo: AI,
        VersionedMessage: yI,
        VersionedTransaction: mI,
        VoteAccount: II,
        VoteAuthorizationLayout: tne,
        VoteInit: _B,
        VoteInstruction: ene,
        VoteProgram: Zu,
        clusterApiUrl: ane,
        sendAndConfirmRawTransaction: cne,
        sendAndConfirmTransaction: sy,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  ne = Sb(lne);
var dv = {},
  oE = {},
  dr = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (o, a, c, u) {
            u === void 0 && (u = c);
            var l = Object.getOwnPropertyDescriptor(a, c);
            (!l || ('get' in l ? !a.__esModule : l.writable || l.configurable)) &&
              (l = {
                enumerable: !0,
                get: function () {
                  return a[c];
                },
              }),
              Object.defineProperty(o, u, l);
          }
        : function (o, a, c, u) {
            u === void 0 && (u = c), (o[u] = a[c]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (o, a) {
            Object.defineProperty(o, 'default', { enumerable: !0, value: a });
          }
        : function (o, a) {
            o.default = a;
          }),
    r =
      (m && m.__importStar) ||
      function (o) {
        if (o && o.__esModule) return o;
        var a = {};
        if (o != null)
          for (var c in o)
            c !== 'default' && Object.prototype.hasOwnProperty.call(o, c) && t(a, o, c);
        return n(a, o), a;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }), (e.keyBeet = e.Key = void 0);
  const i = r(te);
  var s;
  (function (o) {
    (o[(o.Uninitialized = 0)] = 'Uninitialized'),
      (o[(o.EditionV1 = 1)] = 'EditionV1'),
      (o[(o.MasterEditionV1 = 2)] = 'MasterEditionV1'),
      (o[(o.ReservationListV1 = 3)] = 'ReservationListV1'),
      (o[(o.MetadataV1 = 4)] = 'MetadataV1'),
      (o[(o.ReservationListV2 = 5)] = 'ReservationListV2'),
      (o[(o.MasterEditionV2 = 6)] = 'MasterEditionV2'),
      (o[(o.EditionMarker = 7)] = 'EditionMarker'),
      (o[(o.UseAuthorityRecord = 8)] = 'UseAuthorityRecord'),
      (o[(o.CollectionAuthorityRecord = 9)] = 'CollectionAuthorityRecord'),
      (o[(o.TokenOwnedEscrow = 10)] = 'TokenOwnedEscrow'),
      (o[(o.TokenRecord = 11)] = 'TokenRecord'),
      (o[(o.MetadataDelegate = 12)] = 'MetadataDelegate');
  })((s = e.Key || (e.Key = {}))),
    (e.keyBeet = i.fixedScalarEnum(s));
})(dr);
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (u, l, d, f) {
            f === void 0 && (f = d);
            var h = Object.getOwnPropertyDescriptor(l, d);
            (!h || ('get' in h ? !l.__esModule : h.writable || h.configurable)) &&
              (h = {
                enumerable: !0,
                get: function () {
                  return l[d];
                },
              }),
              Object.defineProperty(u, f, h);
          }
        : function (u, l, d, f) {
            f === void 0 && (f = d), (u[f] = l[d]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (u, l) {
            Object.defineProperty(u, 'default', { enumerable: !0, value: l });
          }
        : function (u, l) {
            u.default = l;
          }),
    r =
      (m && m.__importStar) ||
      function (u) {
        if (u && u.__esModule) return u;
        var l = {};
        if (u != null)
          for (var d in u)
            d !== 'default' && Object.prototype.hasOwnProperty.call(u, d) && t(l, u, d);
        return n(l, u), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.collectionAuthorityRecordBeet = e.CollectionAuthorityRecord = void 0);
  const i = r(ne),
    s = r(te),
    o = r(kt),
    a = dr;
  class c {
    constructor(l, d, f) {
      (this.key = l), (this.bump = d), (this.updateAuthority = f);
    }
    static fromArgs(l) {
      return new c(l.key, l.bump, l.updateAuthority);
    }
    static fromAccountInfo(l, d = 0) {
      return c.deserialize(l.data, d);
    }
    static async fromAccountAddress(l, d, f) {
      const h = await l.getAccountInfo(d, f);
      if (h == null) throw new Error(`Unable to find CollectionAuthorityRecord account at ${d}`);
      return c.fromAccountInfo(h, 0)[0];
    }
    static gpaBuilder(l = new i.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
      return o.GpaBuilder.fromStruct(l, e.collectionAuthorityRecordBeet);
    }
    static deserialize(l, d = 0) {
      return e.collectionAuthorityRecordBeet.deserialize(l, d);
    }
    serialize() {
      return e.collectionAuthorityRecordBeet.serialize(this);
    }
    static byteSize(l) {
      const d = c.fromArgs(l);
      return e.collectionAuthorityRecordBeet.toFixedFromValue(d).byteSize;
    }
    static async getMinimumBalanceForRentExemption(l, d, f) {
      return d.getMinimumBalanceForRentExemption(c.byteSize(l), f);
    }
    pretty() {
      return {
        key: 'Key.' + a.Key[this.key],
        bump: this.bump,
        updateAuthority: this.updateAuthority,
      };
    }
  }
  (e.CollectionAuthorityRecord = c),
    (e.collectionAuthorityRecordBeet = new s.FixableBeetStruct(
      [
        ['key', a.keyBeet],
        ['bump', s.u8],
        ['updateAuthority', s.coption(o.publicKey)],
      ],
      c.fromArgs,
      'CollectionAuthorityRecord'
    ));
})(oE);
var aE = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (u, l, d, f) {
            f === void 0 && (f = d);
            var h = Object.getOwnPropertyDescriptor(l, d);
            (!h || ('get' in h ? !l.__esModule : h.writable || h.configurable)) &&
              (h = {
                enumerable: !0,
                get: function () {
                  return l[d];
                },
              }),
              Object.defineProperty(u, f, h);
          }
        : function (u, l, d, f) {
            f === void 0 && (f = d), (u[f] = l[d]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (u, l) {
            Object.defineProperty(u, 'default', { enumerable: !0, value: l });
          }
        : function (u, l) {
            u.default = l;
          }),
    r =
      (m && m.__importStar) ||
      function (u) {
        if (u && u.__esModule) return u;
        var l = {};
        if (u != null)
          for (var d in u)
            d !== 'default' && Object.prototype.hasOwnProperty.call(u, d) && t(l, u, d);
        return n(l, u), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }), (e.editionBeet = e.Edition = void 0);
  const i = r(ne),
    s = r(te),
    o = r(kt),
    a = dr;
  class c {
    constructor(l, d, f) {
      (this.key = l), (this.parent = d), (this.edition = f);
    }
    static fromArgs(l) {
      return new c(l.key, l.parent, l.edition);
    }
    static fromAccountInfo(l, d = 0) {
      return c.deserialize(l.data, d);
    }
    static async fromAccountAddress(l, d, f) {
      const h = await l.getAccountInfo(d, f);
      if (h == null) throw new Error(`Unable to find Edition account at ${d}`);
      return c.fromAccountInfo(h, 0)[0];
    }
    static gpaBuilder(l = new i.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
      return o.GpaBuilder.fromStruct(l, e.editionBeet);
    }
    static deserialize(l, d = 0) {
      return e.editionBeet.deserialize(l, d);
    }
    serialize() {
      return e.editionBeet.serialize(this);
    }
    static get byteSize() {
      return e.editionBeet.byteSize;
    }
    static async getMinimumBalanceForRentExemption(l, d) {
      return l.getMinimumBalanceForRentExemption(c.byteSize, d);
    }
    static hasCorrectByteSize(l, d = 0) {
      return l.byteLength - d === c.byteSize;
    }
    pretty() {
      return {
        key: 'Key.' + a.Key[this.key],
        parent: this.parent.toBase58(),
        edition: (() => {
          const l = this.edition;
          if (typeof l.toNumber == 'function')
            try {
              return l.toNumber();
            } catch {
              return l;
            }
          return l;
        })(),
      };
    }
  }
  (e.Edition = c),
    (e.editionBeet = new s.BeetStruct(
      [
        ['key', a.keyBeet],
        ['parent', o.publicKey],
        ['edition', s.u64],
      ],
      c.fromArgs,
      'Edition'
    ));
})(aE);
var cE = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (u, l, d, f) {
            f === void 0 && (f = d);
            var h = Object.getOwnPropertyDescriptor(l, d);
            (!h || ('get' in h ? !l.__esModule : h.writable || h.configurable)) &&
              (h = {
                enumerable: !0,
                get: function () {
                  return l[d];
                },
              }),
              Object.defineProperty(u, f, h);
          }
        : function (u, l, d, f) {
            f === void 0 && (f = d), (u[f] = l[d]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (u, l) {
            Object.defineProperty(u, 'default', { enumerable: !0, value: l });
          }
        : function (u, l) {
            u.default = l;
          }),
    r =
      (m && m.__importStar) ||
      function (u) {
        if (u && u.__esModule) return u;
        var l = {};
        if (u != null)
          for (var d in u)
            d !== 'default' && Object.prototype.hasOwnProperty.call(u, d) && t(l, u, d);
        return n(l, u), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.editionMarkerBeet = e.EditionMarker = void 0);
  const i = r(te),
    s = r(ne),
    o = r(kt),
    a = dr;
  class c {
    constructor(l, d) {
      (this.key = l), (this.ledger = d);
    }
    static fromArgs(l) {
      return new c(l.key, l.ledger);
    }
    static fromAccountInfo(l, d = 0) {
      return c.deserialize(l.data, d);
    }
    static async fromAccountAddress(l, d, f) {
      const h = await l.getAccountInfo(d, f);
      if (h == null) throw new Error(`Unable to find EditionMarker account at ${d}`);
      return c.fromAccountInfo(h, 0)[0];
    }
    static gpaBuilder(l = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
      return o.GpaBuilder.fromStruct(l, e.editionMarkerBeet);
    }
    static deserialize(l, d = 0) {
      return e.editionMarkerBeet.deserialize(l, d);
    }
    serialize() {
      return e.editionMarkerBeet.serialize(this);
    }
    static get byteSize() {
      return e.editionMarkerBeet.byteSize;
    }
    static async getMinimumBalanceForRentExemption(l, d) {
      return l.getMinimumBalanceForRentExemption(c.byteSize, d);
    }
    static hasCorrectByteSize(l, d = 0) {
      return l.byteLength - d === c.byteSize;
    }
    pretty() {
      return { key: 'Key.' + a.Key[this.key], ledger: this.ledger };
    }
  }
  (e.EditionMarker = c),
    (e.editionMarkerBeet = new i.BeetStruct(
      [
        ['key', a.keyBeet],
        ['ledger', i.uniformFixedSizeArray(i.u8, 31)],
      ],
      c.fromArgs,
      'EditionMarker'
    ));
})(cE);
var uE = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (u, l, d, f) {
            f === void 0 && (f = d);
            var h = Object.getOwnPropertyDescriptor(l, d);
            (!h || ('get' in h ? !l.__esModule : h.writable || h.configurable)) &&
              (h = {
                enumerable: !0,
                get: function () {
                  return l[d];
                },
              }),
              Object.defineProperty(u, f, h);
          }
        : function (u, l, d, f) {
            f === void 0 && (f = d), (u[f] = l[d]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (u, l) {
            Object.defineProperty(u, 'default', { enumerable: !0, value: l });
          }
        : function (u, l) {
            u.default = l;
          }),
    r =
      (m && m.__importStar) ||
      function (u) {
        if (u && u.__esModule) return u;
        var l = {};
        if (u != null)
          for (var d in u)
            d !== 'default' && Object.prototype.hasOwnProperty.call(u, d) && t(l, u, d);
        return n(l, u), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.masterEditionV1Beet = e.MasterEditionV1 = void 0);
  const i = r(te),
    s = r(ne),
    o = r(kt),
    a = dr;
  class c {
    constructor(l, d, f, h, p) {
      (this.key = l),
        (this.supply = d),
        (this.maxSupply = f),
        (this.printingMint = h),
        (this.oneTimePrintingAuthorizationMint = p);
    }
    static fromArgs(l) {
      return new c(
        l.key,
        l.supply,
        l.maxSupply,
        l.printingMint,
        l.oneTimePrintingAuthorizationMint
      );
    }
    static fromAccountInfo(l, d = 0) {
      return c.deserialize(l.data, d);
    }
    static async fromAccountAddress(l, d, f) {
      const h = await l.getAccountInfo(d, f);
      if (h == null) throw new Error(`Unable to find MasterEditionV1 account at ${d}`);
      return c.fromAccountInfo(h, 0)[0];
    }
    static gpaBuilder(l = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
      return o.GpaBuilder.fromStruct(l, e.masterEditionV1Beet);
    }
    static deserialize(l, d = 0) {
      return e.masterEditionV1Beet.deserialize(l, d);
    }
    serialize() {
      return e.masterEditionV1Beet.serialize(this);
    }
    static byteSize(l) {
      const d = c.fromArgs(l);
      return e.masterEditionV1Beet.toFixedFromValue(d).byteSize;
    }
    static async getMinimumBalanceForRentExemption(l, d, f) {
      return d.getMinimumBalanceForRentExemption(c.byteSize(l), f);
    }
    pretty() {
      return {
        key: 'Key.' + a.Key[this.key],
        supply: (() => {
          const l = this.supply;
          if (typeof l.toNumber == 'function')
            try {
              return l.toNumber();
            } catch {
              return l;
            }
          return l;
        })(),
        maxSupply: this.maxSupply,
        printingMint: this.printingMint.toBase58(),
        oneTimePrintingAuthorizationMint: this.oneTimePrintingAuthorizationMint.toBase58(),
      };
    }
  }
  (e.MasterEditionV1 = c),
    (e.masterEditionV1Beet = new i.FixableBeetStruct(
      [
        ['key', a.keyBeet],
        ['supply', i.u64],
        ['maxSupply', i.coption(i.u64)],
        ['printingMint', o.publicKey],
        ['oneTimePrintingAuthorizationMint', o.publicKey],
      ],
      c.fromArgs,
      'MasterEditionV1'
    ));
})(uE);
var lE = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (u, l, d, f) {
            f === void 0 && (f = d);
            var h = Object.getOwnPropertyDescriptor(l, d);
            (!h || ('get' in h ? !l.__esModule : h.writable || h.configurable)) &&
              (h = {
                enumerable: !0,
                get: function () {
                  return l[d];
                },
              }),
              Object.defineProperty(u, f, h);
          }
        : function (u, l, d, f) {
            f === void 0 && (f = d), (u[f] = l[d]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (u, l) {
            Object.defineProperty(u, 'default', { enumerable: !0, value: l });
          }
        : function (u, l) {
            u.default = l;
          }),
    r =
      (m && m.__importStar) ||
      function (u) {
        if (u && u.__esModule) return u;
        var l = {};
        if (u != null)
          for (var d in u)
            d !== 'default' && Object.prototype.hasOwnProperty.call(u, d) && t(l, u, d);
        return n(l, u), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.masterEditionV2Beet = e.MasterEditionV2 = void 0);
  const i = r(te),
    s = r(ne),
    o = r(kt),
    a = dr;
  class c {
    constructor(l, d, f) {
      (this.key = l), (this.supply = d), (this.maxSupply = f);
    }
    static fromArgs(l) {
      return new c(l.key, l.supply, l.maxSupply);
    }
    static fromAccountInfo(l, d = 0) {
      return c.deserialize(l.data, d);
    }
    static async fromAccountAddress(l, d, f) {
      const h = await l.getAccountInfo(d, f);
      if (h == null) throw new Error(`Unable to find MasterEditionV2 account at ${d}`);
      return c.fromAccountInfo(h, 0)[0];
    }
    static gpaBuilder(l = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
      return o.GpaBuilder.fromStruct(l, e.masterEditionV2Beet);
    }
    static deserialize(l, d = 0) {
      return e.masterEditionV2Beet.deserialize(l, d);
    }
    serialize() {
      return e.masterEditionV2Beet.serialize(this);
    }
    static byteSize(l) {
      const d = c.fromArgs(l);
      return e.masterEditionV2Beet.toFixedFromValue(d).byteSize;
    }
    static async getMinimumBalanceForRentExemption(l, d, f) {
      return d.getMinimumBalanceForRentExemption(c.byteSize(l), f);
    }
    pretty() {
      return {
        key: 'Key.' + a.Key[this.key],
        supply: (() => {
          const l = this.supply;
          if (typeof l.toNumber == 'function')
            try {
              return l.toNumber();
            } catch {
              return l;
            }
          return l;
        })(),
        maxSupply: this.maxSupply,
      };
    }
  }
  (e.MasterEditionV2 = c),
    (e.masterEditionV2Beet = new i.FixableBeetStruct(
      [
        ['key', a.keyBeet],
        ['supply', i.u64],
        ['maxSupply', i.coption(i.u64)],
      ],
      c.fromArgs,
      'MasterEditionV2'
    ));
})(lE);
var fv = {},
  kc = {},
  Cc = {},
  dne =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  fne =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  EB =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && dne(t, e, n);
      return fne(t, e), t;
    };
Object.defineProperty(Cc, '__esModule', { value: !0 });
Cc.creatorBeet = void 0;
const hne = EB(kt),
  hv = EB(te);
Cc.creatorBeet = new hv.BeetArgsStruct(
  [
    ['address', hne.publicKey],
    ['verified', hv.bool],
    ['share', hv.u8],
  ],
  'Creator'
);
var pne =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  gne =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  yne =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && pne(t, e, n);
      return gne(t, e), t;
    };
Object.defineProperty(kc, '__esModule', { value: !0 });
kc.dataBeet = void 0;
const Aa = yne(te),
  bne = Cc;
kc.dataBeet = new Aa.FixableBeetArgsStruct(
  [
    ['name', Aa.utf8String],
    ['symbol', Aa.utf8String],
    ['uri', Aa.utf8String],
    ['sellerFeeBasisPoints', Aa.u16],
    ['creators', Aa.coption(Aa.array(bne.creatorBeet))],
  ],
  'Data'
);
var Ju = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (o, a, c, u) {
            u === void 0 && (u = c);
            var l = Object.getOwnPropertyDescriptor(a, c);
            (!l || ('get' in l ? !a.__esModule : l.writable || l.configurable)) &&
              (l = {
                enumerable: !0,
                get: function () {
                  return a[c];
                },
              }),
              Object.defineProperty(o, u, l);
          }
        : function (o, a, c, u) {
            u === void 0 && (u = c), (o[u] = a[c]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (o, a) {
            Object.defineProperty(o, 'default', { enumerable: !0, value: a });
          }
        : function (o, a) {
            o.default = a;
          }),
    r =
      (m && m.__importStar) ||
      function (o) {
        if (o && o.__esModule) return o;
        var a = {};
        if (o != null)
          for (var c in o)
            c !== 'default' && Object.prototype.hasOwnProperty.call(o, c) && t(a, o, c);
        return n(a, o), a;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.tokenStandardBeet = e.TokenStandard = void 0);
  const i = r(te);
  var s;
  (function (o) {
    (o[(o.NonFungible = 0)] = 'NonFungible'),
      (o[(o.FungibleAsset = 1)] = 'FungibleAsset'),
      (o[(o.Fungible = 2)] = 'Fungible'),
      (o[(o.NonFungibleEdition = 3)] = 'NonFungibleEdition'),
      (o[(o.ProgrammableNonFungible = 4)] = 'ProgrammableNonFungible');
  })((s = e.TokenStandard || (e.TokenStandard = {}))),
    (e.tokenStandardBeet = i.fixedScalarEnum(s));
})(Ju);
var ho = {},
  mne =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  wne =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  AB =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && mne(t, e, n);
      return wne(t, e), t;
    };
Object.defineProperty(ho, '__esModule', { value: !0 });
ho.collectionBeet = void 0;
const Qk = AB(te),
  vne = AB(kt);
ho.collectionBeet = new Qk.BeetArgsStruct(
  [
    ['verified', Qk.bool],
    ['key', vne.publicKey],
  ],
  'Collection'
);
var po = {},
  TI = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (o, a, c, u) {
            u === void 0 && (u = c);
            var l = Object.getOwnPropertyDescriptor(a, c);
            (!l || ('get' in l ? !a.__esModule : l.writable || l.configurable)) &&
              (l = {
                enumerable: !0,
                get: function () {
                  return a[c];
                },
              }),
              Object.defineProperty(o, u, l);
          }
        : function (o, a, c, u) {
            u === void 0 && (u = c), (o[u] = a[c]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (o, a) {
            Object.defineProperty(o, 'default', { enumerable: !0, value: a });
          }
        : function (o, a) {
            o.default = a;
          }),
    r =
      (m && m.__importStar) ||
      function (o) {
        if (o && o.__esModule) return o;
        var a = {};
        if (o != null)
          for (var c in o)
            c !== 'default' && Object.prototype.hasOwnProperty.call(o, c) && t(a, o, c);
        return n(a, o), a;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }), (e.useMethodBeet = e.UseMethod = void 0);
  const i = r(te);
  var s;
  (function (o) {
    (o[(o.Burn = 0)] = 'Burn'), (o[(o.Multiple = 1)] = 'Multiple'), (o[(o.Single = 2)] = 'Single');
  })((s = e.UseMethod || (e.UseMethod = {}))),
    (e.useMethodBeet = i.fixedScalarEnum(s));
})(TI);
var _ne =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  Sne =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  Ene =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && _ne(t, e, n);
      return Sne(t, e), t;
    };
Object.defineProperty(po, '__esModule', { value: !0 });
po.usesBeet = void 0;
const pv = Ene(te),
  Ane = TI;
po.usesBeet = new pv.BeetArgsStruct(
  [
    ['useMethod', Ane.useMethodBeet],
    ['remaining', pv.u64],
    ['total', pv.u64],
  ],
  'Uses'
);
var Ki = {},
  Ine =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  Tne =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  xne =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && Ine(t, e, n);
      return Tne(t, e), t;
    };
Object.defineProperty(Ki, '__esModule', { value: !0 });
Ki.collectionDetailsBeet = Ki.isCollectionDetailsV1 = void 0;
const gv = xne(te),
  kne = (e) => e.__kind === 'V1';
Ki.isCollectionDetailsV1 = kne;
Ki.collectionDetailsBeet = gv.dataEnum([
  ['V1', new gv.BeetArgsStruct([['size', gv.u64]], 'CollectionDetailsRecord["V1"]')],
]);
var ga = {},
  Cne =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  Pne =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  IB =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && Cne(t, e, n);
      return Pne(t, e), t;
    };
Object.defineProperty(ga, '__esModule', { value: !0 });
ga.programmableConfigBeet = ga.isProgrammableConfigV1 = void 0;
const yv = IB(te),
  Mne = IB(kt),
  One = (e) => e.__kind === 'V1';
ga.isProgrammableConfigV1 = One;
ga.programmableConfigBeet = yv.dataEnum([
  [
    'V1',
    new yv.FixableBeetArgsStruct(
      [['ruleSet', yv.coption(Mne.publicKey)]],
      'ProgrammableConfigRecord["V1"]'
    ),
  ],
]);
var gl = {},
  e2;
function Bne() {
  if (e2) return gl;
  e2 = 1;
  var e =
      (m && m.__createBinding) ||
      (Object.create
        ? function (w, A, _, x) {
            x === void 0 && (x = _);
            var k = Object.getOwnPropertyDescriptor(A, _);
            (!k || ('get' in k ? !A.__esModule : k.writable || k.configurable)) &&
              (k = {
                enumerable: !0,
                get: function () {
                  return A[_];
                },
              }),
              Object.defineProperty(w, x, k);
          }
        : function (w, A, _, x) {
            x === void 0 && (x = _), (w[x] = A[_]);
          }),
    t =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (w, A) {
            Object.defineProperty(w, 'default', { enumerable: !0, value: A });
          }
        : function (w, A) {
            w.default = A;
          }),
    n =
      (m && m.__importStar) ||
      function (w) {
        if (w && w.__esModule) return w;
        var A = {};
        if (w != null)
          for (var _ in w)
            _ !== 'default' && Object.prototype.hasOwnProperty.call(w, _) && e(A, w, _);
        return t(A, w), A;
      };
  Object.defineProperty(gl, '__esModule', { value: !0 }), (gl.deserialize = void 0);
  const r = n(te),
    i = n(kt),
    s = dE(),
    o = ho,
    a = Ki,
    c = ga,
    u = kc,
    l = dr,
    d = Ju,
    f = po,
    h = r.coptionNone('').byteSize;
  function p(w, A = 0) {
    let _ = A;
    const x = l.keyBeet.read(w, _);
    _ += l.keyBeet.byteSize;
    const k = i.publicKey.read(w, _);
    _ += i.publicKey.byteSize;
    const j = i.publicKey.read(w, _);
    _ += i.publicKey.byteSize;
    const [F, K] = u.dataBeet.deserialize(w, _);
    _ = K;
    const D = r.bool.read(w, _);
    _ += r.bool.byteSize;
    const C = r.bool.read(w, _);
    _ += r.bool.byteSize;
    const B = r.coption(r.u8).toFixedFromData(w, _),
      E = B.read(w, _);
    _ += B.byteSize;
    const [y, v, S] = b(r.coption(d.tokenStandardBeet), w, _);
    _ += v;
    const [T, M, R] = S ? [null, h, !0] : b(r.coption(o.collectionBeet), w, _);
    _ += M;
    const [L, O, I] = S || R ? [null, h, !0] : b(r.coption(f.usesBeet), w, _);
    _ += O;
    const [U, H, X] = S || R || I ? [null, h, !0] : b(r.coption(a.collectionDetailsBeet), w, _);
    _ += H;
    const [J, ie, Z] = S || R || I ? [null, h, !0] : b(r.coption(c.programmableConfigBeet), w, _);
    _ += ie;
    const be = S || R || I || X || Z,
      le = {
        key: x,
        updateAuthority: k,
        mint: j,
        data: F,
        primarySaleHappened: D,
        isMutable: C,
        editionNonce: E,
        tokenStandard: be ? null : y,
        collection: be ? null : T,
        uses: be ? null : L,
        collectionDetails: be ? null : U,
        programmableConfig: be ? null : J,
      };
    return [s.Metadata.fromArgs(le), _];
  }
  gl.deserialize = p;
  function b(w, A, _) {
    try {
      const x = w.toFixedFromData(A, _);
      return [x.read(A, _), x.byteSize, !1];
    } catch {
      return [null, h, !0];
    }
  }
  return gl;
}
var t2;
function dE() {
  return (
    t2 ||
      ((t2 = 1),
      (function (e) {
        var t =
            (m && m.__createBinding) ||
            (Object.create
              ? function (x, k, j, F) {
                  F === void 0 && (F = j);
                  var K = Object.getOwnPropertyDescriptor(k, j);
                  (!K || ('get' in K ? !k.__esModule : K.writable || K.configurable)) &&
                    (K = {
                      enumerable: !0,
                      get: function () {
                        return k[j];
                      },
                    }),
                    Object.defineProperty(x, F, K);
                }
              : function (x, k, j, F) {
                  F === void 0 && (F = j), (x[F] = k[j]);
                }),
          n =
            (m && m.__setModuleDefault) ||
            (Object.create
              ? function (x, k) {
                  Object.defineProperty(x, 'default', { enumerable: !0, value: k });
                }
              : function (x, k) {
                  x.default = k;
                }),
          r =
            (m && m.__importStar) ||
            function (x) {
              if (x && x.__esModule) return x;
              var k = {};
              if (x != null)
                for (var j in x)
                  j !== 'default' && Object.prototype.hasOwnProperty.call(x, j) && t(k, x, j);
              return n(k, x), k;
            };
        Object.defineProperty(e, '__esModule', { value: !0 }),
          (e.metadataBeet = e.Metadata = void 0);
        const i = r(ne),
          s = r(te),
          o = r(kt),
          a = dr,
          c = kc,
          u = Ju,
          l = ho,
          d = po,
          f = Ki,
          h = ga,
          p = r(Bne());
        class b {
          constructor(k, j, F, K, D, C, B, E, y, v, S, T) {
            (this.key = k),
              (this.updateAuthority = j),
              (this.mint = F),
              (this.data = K),
              (this.primarySaleHappened = D),
              (this.isMutable = C),
              (this.editionNonce = B),
              (this.tokenStandard = E),
              (this.collection = y),
              (this.uses = v),
              (this.collectionDetails = S),
              (this.programmableConfig = T);
          }
          static fromArgs(k) {
            return new b(
              k.key,
              k.updateAuthority,
              k.mint,
              k.data,
              k.primarySaleHappened,
              k.isMutable,
              k.editionNonce,
              k.tokenStandard,
              k.collection,
              k.uses,
              k.collectionDetails,
              k.programmableConfig
            );
          }
          static fromAccountInfo(k, j = 0) {
            return b.deserialize(k.data, j);
          }
          static async fromAccountAddress(k, j, F) {
            const K = await k.getAccountInfo(j, F);
            if (K == null) throw new Error(`Unable to find Metadata account at ${j}`);
            return b.fromAccountInfo(K, 0)[0];
          }
          static gpaBuilder(k = new i.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
            return o.GpaBuilder.fromStruct(k, e.metadataBeet);
          }
          static deserialize(k, j = 0) {
            return _(k, j);
          }
          serialize() {
            return A(this);
          }
          static byteSize(k) {
            const j = b.fromArgs(k);
            return e.metadataBeet.toFixedFromValue(j).byteSize;
          }
          static async getMinimumBalanceForRentExemption(k, j, F) {
            return j.getMinimumBalanceForRentExemption(b.byteSize(k), F);
          }
          pretty() {
            return {
              key: 'Key.' + a.Key[this.key],
              updateAuthority: this.updateAuthority.toBase58(),
              mint: this.mint.toBase58(),
              data: this.data,
              primarySaleHappened: this.primarySaleHappened,
              isMutable: this.isMutable,
              editionNonce: this.editionNonce,
              tokenStandard: this.tokenStandard,
              collection: this.collection,
              uses: this.uses,
              collectionDetails: this.collectionDetails,
              programmableConfig: this.programmableConfig,
            };
          }
        }
        (e.Metadata = b),
          (e.metadataBeet = new s.FixableBeetStruct(
            [
              ['key', a.keyBeet],
              ['updateAuthority', o.publicKey],
              ['mint', o.publicKey],
              ['data', c.dataBeet],
              ['primarySaleHappened', s.bool],
              ['isMutable', s.bool],
              ['editionNonce', s.coption(s.u8)],
              ['tokenStandard', s.coption(u.tokenStandardBeet)],
              ['collection', s.coption(l.collectionBeet)],
              ['uses', s.coption(d.usesBeet)],
              ['collectionDetails', s.coption(f.collectionDetailsBeet)],
              ['programmableConfig', s.coption(h.programmableConfigBeet)],
            ],
            b.fromArgs,
            'Metadata'
          ));
        const w = p,
          A =
            typeof w.serialize == 'function'
              ? w.serialize.bind(w)
              : e.metadataBeet.serialize.bind(e.metadataBeet),
          _ =
            typeof w.deserialize == 'function'
              ? w.deserialize.bind(w)
              : e.metadataBeet.deserialize.bind(e.metadataBeet);
      })(fv)),
    fv
  );
}
var fE = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (u, l, d, f) {
            f === void 0 && (f = d);
            var h = Object.getOwnPropertyDescriptor(l, d);
            (!h || ('get' in h ? !l.__esModule : h.writable || h.configurable)) &&
              (h = {
                enumerable: !0,
                get: function () {
                  return l[d];
                },
              }),
              Object.defineProperty(u, f, h);
          }
        : function (u, l, d, f) {
            f === void 0 && (f = d), (u[f] = l[d]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (u, l) {
            Object.defineProperty(u, 'default', { enumerable: !0, value: l });
          }
        : function (u, l) {
            u.default = l;
          }),
    r =
      (m && m.__importStar) ||
      function (u) {
        if (u && u.__esModule) return u;
        var l = {};
        if (u != null)
          for (var d in u)
            d !== 'default' && Object.prototype.hasOwnProperty.call(u, d) && t(l, u, d);
        return n(l, u), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.metadataDelegateRecordBeet = e.MetadataDelegateRecord = void 0);
  const i = r(ne),
    s = r(te),
    o = r(kt),
    a = dr;
  class c {
    constructor(l, d, f, h, p) {
      (this.key = l),
        (this.bump = d),
        (this.mint = f),
        (this.delegate = h),
        (this.updateAuthority = p);
    }
    static fromArgs(l) {
      return new c(l.key, l.bump, l.mint, l.delegate, l.updateAuthority);
    }
    static fromAccountInfo(l, d = 0) {
      return c.deserialize(l.data, d);
    }
    static async fromAccountAddress(l, d, f) {
      const h = await l.getAccountInfo(d, f);
      if (h == null) throw new Error(`Unable to find MetadataDelegateRecord account at ${d}`);
      return c.fromAccountInfo(h, 0)[0];
    }
    static gpaBuilder(l = new i.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
      return o.GpaBuilder.fromStruct(l, e.metadataDelegateRecordBeet);
    }
    static deserialize(l, d = 0) {
      return e.metadataDelegateRecordBeet.deserialize(l, d);
    }
    serialize() {
      return e.metadataDelegateRecordBeet.serialize(this);
    }
    static get byteSize() {
      return e.metadataDelegateRecordBeet.byteSize;
    }
    static async getMinimumBalanceForRentExemption(l, d) {
      return l.getMinimumBalanceForRentExemption(c.byteSize, d);
    }
    static hasCorrectByteSize(l, d = 0) {
      return l.byteLength - d === c.byteSize;
    }
    pretty() {
      return {
        key: 'Key.' + a.Key[this.key],
        bump: this.bump,
        mint: this.mint.toBase58(),
        delegate: this.delegate.toBase58(),
        updateAuthority: this.updateAuthority.toBase58(),
      };
    }
  }
  (e.MetadataDelegateRecord = c),
    (e.metadataDelegateRecordBeet = new s.BeetStruct(
      [
        ['key', a.keyBeet],
        ['bump', s.u8],
        ['mint', o.publicKey],
        ['delegate', o.publicKey],
        ['updateAuthority', o.publicKey],
      ],
      c.fromArgs,
      'MetadataDelegateRecord'
    ));
})(fE);
var hE = {},
  kd = {},
  Dne =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  Rne =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  TB =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && Dne(t, e, n);
      return Rne(t, e), t;
    };
Object.defineProperty(kd, '__esModule', { value: !0 });
kd.reservationV1Beet = void 0;
const Nne = TB(kt),
  bv = TB(te);
kd.reservationV1Beet = new bv.BeetArgsStruct(
  [
    ['address', Nne.publicKey],
    ['spotsRemaining', bv.u8],
    ['totalSpots', bv.u8],
  ],
  'ReservationV1'
);
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (l, d, f, h) {
            h === void 0 && (h = f);
            var p = Object.getOwnPropertyDescriptor(d, f);
            (!p || ('get' in p ? !d.__esModule : p.writable || p.configurable)) &&
              (p = {
                enumerable: !0,
                get: function () {
                  return d[f];
                },
              }),
              Object.defineProperty(l, h, p);
          }
        : function (l, d, f, h) {
            h === void 0 && (h = f), (l[h] = d[f]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (l, d) {
            Object.defineProperty(l, 'default', { enumerable: !0, value: d });
          }
        : function (l, d) {
            l.default = d;
          }),
    r =
      (m && m.__importStar) ||
      function (l) {
        if (l && l.__esModule) return l;
        var d = {};
        if (l != null)
          for (var f in l)
            f !== 'default' && Object.prototype.hasOwnProperty.call(l, f) && t(d, l, f);
        return n(d, l), d;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.reservationListV1Beet = e.ReservationListV1 = void 0);
  const i = r(ne),
    s = r(te),
    o = r(kt),
    a = dr,
    c = kd;
  class u {
    constructor(d, f, h, p) {
      (this.key = d), (this.masterEdition = f), (this.supplySnapshot = h), (this.reservations = p);
    }
    static fromArgs(d) {
      return new u(d.key, d.masterEdition, d.supplySnapshot, d.reservations);
    }
    static fromAccountInfo(d, f = 0) {
      return u.deserialize(d.data, f);
    }
    static async fromAccountAddress(d, f, h) {
      const p = await d.getAccountInfo(f, h);
      if (p == null) throw new Error(`Unable to find ReservationListV1 account at ${f}`);
      return u.fromAccountInfo(p, 0)[0];
    }
    static gpaBuilder(d = new i.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
      return o.GpaBuilder.fromStruct(d, e.reservationListV1Beet);
    }
    static deserialize(d, f = 0) {
      return e.reservationListV1Beet.deserialize(d, f);
    }
    serialize() {
      return e.reservationListV1Beet.serialize(this);
    }
    static byteSize(d) {
      const f = u.fromArgs(d);
      return e.reservationListV1Beet.toFixedFromValue(f).byteSize;
    }
    static async getMinimumBalanceForRentExemption(d, f, h) {
      return f.getMinimumBalanceForRentExemption(u.byteSize(d), h);
    }
    pretty() {
      return {
        key: 'Key.' + a.Key[this.key],
        masterEdition: this.masterEdition.toBase58(),
        supplySnapshot: this.supplySnapshot,
        reservations: this.reservations,
      };
    }
  }
  (e.ReservationListV1 = u),
    (e.reservationListV1Beet = new s.FixableBeetStruct(
      [
        ['key', a.keyBeet],
        ['masterEdition', o.publicKey],
        ['supplySnapshot', s.coption(s.u64)],
        ['reservations', s.array(c.reservationV1Beet)],
      ],
      u.fromArgs,
      'ReservationListV1'
    ));
})(hE);
var pE = {},
  Cd = {},
  jne =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  Lne =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  xB =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && jne(t, e, n);
      return Lne(t, e), t;
    };
Object.defineProperty(Cd, '__esModule', { value: !0 });
Cd.reservationBeet = void 0;
const mv = xB(te),
  Une = xB(kt);
Cd.reservationBeet = new mv.BeetArgsStruct(
  [
    ['address', Une.publicKey],
    ['spotsRemaining', mv.u64],
    ['totalSpots', mv.u64],
  ],
  'Reservation'
);
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (l, d, f, h) {
            h === void 0 && (h = f);
            var p = Object.getOwnPropertyDescriptor(d, f);
            (!p || ('get' in p ? !d.__esModule : p.writable || p.configurable)) &&
              (p = {
                enumerable: !0,
                get: function () {
                  return d[f];
                },
              }),
              Object.defineProperty(l, h, p);
          }
        : function (l, d, f, h) {
            h === void 0 && (h = f), (l[h] = d[f]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (l, d) {
            Object.defineProperty(l, 'default', { enumerable: !0, value: d });
          }
        : function (l, d) {
            l.default = d;
          }),
    r =
      (m && m.__importStar) ||
      function (l) {
        if (l && l.__esModule) return l;
        var d = {};
        if (l != null)
          for (var f in l)
            f !== 'default' && Object.prototype.hasOwnProperty.call(l, f) && t(d, l, f);
        return n(d, l), d;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.reservationListV2Beet = e.ReservationListV2 = void 0);
  const i = r(ne),
    s = r(te),
    o = r(kt),
    a = dr,
    c = Cd;
  class u {
    constructor(d, f, h, p, b, w) {
      (this.key = d),
        (this.masterEdition = f),
        (this.supplySnapshot = h),
        (this.reservations = p),
        (this.totalReservationSpots = b),
        (this.currentReservationSpots = w);
    }
    static fromArgs(d) {
      return new u(
        d.key,
        d.masterEdition,
        d.supplySnapshot,
        d.reservations,
        d.totalReservationSpots,
        d.currentReservationSpots
      );
    }
    static fromAccountInfo(d, f = 0) {
      return u.deserialize(d.data, f);
    }
    static async fromAccountAddress(d, f, h) {
      const p = await d.getAccountInfo(f, h);
      if (p == null) throw new Error(`Unable to find ReservationListV2 account at ${f}`);
      return u.fromAccountInfo(p, 0)[0];
    }
    static gpaBuilder(d = new i.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
      return o.GpaBuilder.fromStruct(d, e.reservationListV2Beet);
    }
    static deserialize(d, f = 0) {
      return e.reservationListV2Beet.deserialize(d, f);
    }
    serialize() {
      return e.reservationListV2Beet.serialize(this);
    }
    static byteSize(d) {
      const f = u.fromArgs(d);
      return e.reservationListV2Beet.toFixedFromValue(f).byteSize;
    }
    static async getMinimumBalanceForRentExemption(d, f, h) {
      return f.getMinimumBalanceForRentExemption(u.byteSize(d), h);
    }
    pretty() {
      return {
        key: 'Key.' + a.Key[this.key],
        masterEdition: this.masterEdition.toBase58(),
        supplySnapshot: this.supplySnapshot,
        reservations: this.reservations,
        totalReservationSpots: (() => {
          const d = this.totalReservationSpots;
          if (typeof d.toNumber == 'function')
            try {
              return d.toNumber();
            } catch {
              return d;
            }
          return d;
        })(),
        currentReservationSpots: (() => {
          const d = this.currentReservationSpots;
          if (typeof d.toNumber == 'function')
            try {
              return d.toNumber();
            } catch {
              return d;
            }
          return d;
        })(),
      };
    }
  }
  (e.ReservationListV2 = u),
    (e.reservationListV2Beet = new s.FixableBeetStruct(
      [
        ['key', a.keyBeet],
        ['masterEdition', o.publicKey],
        ['supplySnapshot', s.coption(s.u64)],
        ['reservations', s.array(c.reservationBeet)],
        ['totalReservationSpots', s.u64],
        ['currentReservationSpots', s.u64],
      ],
      u.fromArgs,
      'ReservationListV2'
    ));
})(pE);
var gE = {},
  to = {},
  $ne =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  Fne =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  kB =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && $ne(t, e, n);
      return Fne(t, e), t;
    };
Object.defineProperty(to, '__esModule', { value: !0 });
to.escrowAuthorityBeet = to.isEscrowAuthorityCreator = to.isEscrowAuthorityTokenOwner = void 0;
const tg = kB(te),
  zne = kB(kt),
  Kne = (e) => e.__kind === 'TokenOwner';
to.isEscrowAuthorityTokenOwner = Kne;
const Vne = (e) => e.__kind === 'Creator';
to.isEscrowAuthorityCreator = Vne;
to.escrowAuthorityBeet = tg.dataEnum([
  ['TokenOwner', tg.unit],
  [
    'Creator',
    new tg.BeetArgsStruct(
      [['fields', tg.fixedSizeTuple([zne.publicKey])]],
      'EscrowAuthorityRecord["Creator"]'
    ),
  ],
]);
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (l, d, f, h) {
            h === void 0 && (h = f);
            var p = Object.getOwnPropertyDescriptor(d, f);
            (!p || ('get' in p ? !d.__esModule : p.writable || p.configurable)) &&
              (p = {
                enumerable: !0,
                get: function () {
                  return d[f];
                },
              }),
              Object.defineProperty(l, h, p);
          }
        : function (l, d, f, h) {
            h === void 0 && (h = f), (l[h] = d[f]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (l, d) {
            Object.defineProperty(l, 'default', { enumerable: !0, value: d });
          }
        : function (l, d) {
            l.default = d;
          }),
    r =
      (m && m.__importStar) ||
      function (l) {
        if (l && l.__esModule) return l;
        var d = {};
        if (l != null)
          for (var f in l)
            f !== 'default' && Object.prototype.hasOwnProperty.call(l, f) && t(d, l, f);
        return n(d, l), d;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.tokenOwnedEscrowBeet = e.TokenOwnedEscrow = void 0);
  const i = r(ne),
    s = r(kt),
    o = r(te),
    a = dr,
    c = to;
  class u {
    constructor(d, f, h, p) {
      (this.key = d), (this.baseToken = f), (this.authority = h), (this.bump = p);
    }
    static fromArgs(d) {
      return new u(d.key, d.baseToken, d.authority, d.bump);
    }
    static fromAccountInfo(d, f = 0) {
      return u.deserialize(d.data, f);
    }
    static async fromAccountAddress(d, f, h) {
      const p = await d.getAccountInfo(f, h);
      if (p == null) throw new Error(`Unable to find TokenOwnedEscrow account at ${f}`);
      return u.fromAccountInfo(p, 0)[0];
    }
    static gpaBuilder(d = new i.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
      return s.GpaBuilder.fromStruct(d, e.tokenOwnedEscrowBeet);
    }
    static deserialize(d, f = 0) {
      return e.tokenOwnedEscrowBeet.deserialize(d, f);
    }
    serialize() {
      return e.tokenOwnedEscrowBeet.serialize(this);
    }
    static byteSize(d) {
      const f = u.fromArgs(d);
      return e.tokenOwnedEscrowBeet.toFixedFromValue(f).byteSize;
    }
    static async getMinimumBalanceForRentExemption(d, f, h) {
      return f.getMinimumBalanceForRentExemption(u.byteSize(d), h);
    }
    pretty() {
      return {
        key: 'Key.' + a.Key[this.key],
        baseToken: this.baseToken.toBase58(),
        authority: this.authority.__kind,
        bump: this.bump,
      };
    }
  }
  (e.TokenOwnedEscrow = u),
    (e.tokenOwnedEscrowBeet = new o.FixableBeetStruct(
      [
        ['key', a.keyBeet],
        ['baseToken', s.publicKey],
        ['authority', c.escrowAuthorityBeet],
        ['bump', o.u8],
      ],
      u.fromArgs,
      'TokenOwnedEscrow'
    ));
})(gE);
var wv = {},
  xI = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (o, a, c, u) {
            u === void 0 && (u = c);
            var l = Object.getOwnPropertyDescriptor(a, c);
            (!l || ('get' in l ? !a.__esModule : l.writable || l.configurable)) &&
              (l = {
                enumerable: !0,
                get: function () {
                  return a[c];
                },
              }),
              Object.defineProperty(o, u, l);
          }
        : function (o, a, c, u) {
            u === void 0 && (u = c), (o[u] = a[c]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (o, a) {
            Object.defineProperty(o, 'default', { enumerable: !0, value: a });
          }
        : function (o, a) {
            o.default = a;
          }),
    r =
      (m && m.__importStar) ||
      function (o) {
        if (o && o.__esModule) return o;
        var a = {};
        if (o != null)
          for (var c in o)
            c !== 'default' && Object.prototype.hasOwnProperty.call(o, c) && t(a, o, c);
        return n(a, o), a;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }), (e.tokenStateBeet = e.TokenState = void 0);
  const i = r(te);
  var s;
  (function (o) {
    (o[(o.Unlocked = 0)] = 'Unlocked'),
      (o[(o.Locked = 1)] = 'Locked'),
      (o[(o.Listed = 2)] = 'Listed');
  })((s = e.TokenState || (e.TokenState = {}))),
    (e.tokenStateBeet = i.fixedScalarEnum(s));
})(xI);
var kI = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (o, a, c, u) {
            u === void 0 && (u = c);
            var l = Object.getOwnPropertyDescriptor(a, c);
            (!l || ('get' in l ? !a.__esModule : l.writable || l.configurable)) &&
              (l = {
                enumerable: !0,
                get: function () {
                  return a[c];
                },
              }),
              Object.defineProperty(o, u, l);
          }
        : function (o, a, c, u) {
            u === void 0 && (u = c), (o[u] = a[c]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (o, a) {
            Object.defineProperty(o, 'default', { enumerable: !0, value: a });
          }
        : function (o, a) {
            o.default = a;
          }),
    r =
      (m && m.__importStar) ||
      function (o) {
        if (o && o.__esModule) return o;
        var a = {};
        if (o != null)
          for (var c in o)
            c !== 'default' && Object.prototype.hasOwnProperty.call(o, c) && t(a, o, c);
        return n(a, o), a;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.tokenDelegateRoleBeet = e.TokenDelegateRole = void 0);
  const i = r(te);
  var s;
  (function (o) {
    (o[(o.Sale = 0)] = 'Sale'),
      (o[(o.Transfer = 1)] = 'Transfer'),
      (o[(o.Utility = 2)] = 'Utility'),
      (o[(o.Staking = 3)] = 'Staking'),
      (o[(o.Standard = 4)] = 'Standard'),
      (o[(o.LockedTransfer = 5)] = 'LockedTransfer'),
      (o[(o.Migration = 6)] = 'Migration');
  })((s = e.TokenDelegateRole || (e.TokenDelegateRole = {}))),
    (e.tokenDelegateRoleBeet = i.fixedScalarEnum(s));
})(kI);
var yl = {},
  lm = {},
  Wne =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  Hne =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  Gne =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && Wne(t, e, n);
      return Hne(t, e), t;
    };
Object.defineProperty(lm, '__esModule', { value: !0 });
lm.tryReadOption = void 0;
const qne = Gne(te),
  Yne = qne.coptionNone('').byteSize;
function Zne(e, t, n) {
  if (t.subarray(n).length == 0) return [null, Yne, !0];
  const r = e.toFixedFromData(t, n);
  return [r.read(t, n), r.byteSize, !1];
}
lm.tryReadOption = Zne;
var n2;
function Jne() {
  if (n2) return yl;
  n2 = 1;
  var e =
      (m && m.__createBinding) ||
      (Object.create
        ? function (l, d, f, h) {
            h === void 0 && (h = f);
            var p = Object.getOwnPropertyDescriptor(d, f);
            (!p || ('get' in p ? !d.__esModule : p.writable || p.configurable)) &&
              (p = {
                enumerable: !0,
                get: function () {
                  return d[f];
                },
              }),
              Object.defineProperty(l, h, p);
          }
        : function (l, d, f, h) {
            h === void 0 && (h = f), (l[h] = d[f]);
          }),
    t =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (l, d) {
            Object.defineProperty(l, 'default', { enumerable: !0, value: d });
          }
        : function (l, d) {
            l.default = d;
          }),
    n =
      (m && m.__importStar) ||
      function (l) {
        if (l && l.__esModule) return l;
        var d = {};
        if (l != null)
          for (var f in l)
            f !== 'default' && Object.prototype.hasOwnProperty.call(l, f) && e(d, l, f);
        return t(d, l), d;
      };
  Object.defineProperty(yl, '__esModule', { value: !0 }), (yl.deserialize = void 0);
  const r = n(te),
    i = n(kt),
    s = dr,
    o = yE(),
    a = $I(),
    c = lm;
  function u(l, d = 0) {
    let f = d;
    const h = s.keyBeet.read(l, f);
    f += s.keyBeet.byteSize;
    const p = r.u8.read(l, f);
    f += r.u8.byteSize;
    const b = a.tokenStateBeet.read(l, f);
    f += a.tokenStateBeet.byteSize;
    const [w, A] = (0, c.tryReadOption)(r.coption(r.u64), l, f);
    f += A;
    const [_, x] = (0, c.tryReadOption)(r.coption(i.publicKey), l, f);
    f += x;
    const [k, j] = (0, c.tryReadOption)(r.coption(a.tokenDelegateRoleBeet), l, f);
    f += j;
    const [F, K, D] = (0, c.tryReadOption)(r.coption(i.publicKey), l, f);
    f += K;
    const C = {
      key: h,
      bump: p,
      state: b,
      ruleSetRevision: w,
      delegate: _,
      delegateRole: k,
      lockedTransfer: D ? null : F,
    };
    return [o.TokenRecord.fromArgs(C), f];
  }
  return (yl.deserialize = u), yl;
}
var r2;
function yE() {
  return (
    r2 ||
      ((r2 = 1),
      (function (e) {
        var t =
            (m && m.__createBinding) ||
            (Object.create
              ? function (b, w, A, _) {
                  _ === void 0 && (_ = A);
                  var x = Object.getOwnPropertyDescriptor(w, A);
                  (!x || ('get' in x ? !w.__esModule : x.writable || x.configurable)) &&
                    (x = {
                      enumerable: !0,
                      get: function () {
                        return w[A];
                      },
                    }),
                    Object.defineProperty(b, _, x);
                }
              : function (b, w, A, _) {
                  _ === void 0 && (_ = A), (b[_] = w[A]);
                }),
          n =
            (m && m.__setModuleDefault) ||
            (Object.create
              ? function (b, w) {
                  Object.defineProperty(b, 'default', { enumerable: !0, value: w });
                }
              : function (b, w) {
                  b.default = w;
                }),
          r =
            (m && m.__importStar) ||
            function (b) {
              if (b && b.__esModule) return b;
              var w = {};
              if (b != null)
                for (var A in b)
                  A !== 'default' && Object.prototype.hasOwnProperty.call(b, A) && t(w, b, A);
              return n(w, b), w;
            };
        Object.defineProperty(e, '__esModule', { value: !0 }),
          (e.tokenRecordBeet = e.TokenRecord = void 0);
        const i = r(te),
          s = r(ne),
          o = r(kt),
          a = dr,
          c = xI,
          u = kI,
          l = r(Jne());
        class d {
          constructor(w, A, _, x, k, j, F) {
            (this.key = w),
              (this.bump = A),
              (this.state = _),
              (this.ruleSetRevision = x),
              (this.delegate = k),
              (this.delegateRole = j),
              (this.lockedTransfer = F);
          }
          static fromArgs(w) {
            return new d(
              w.key,
              w.bump,
              w.state,
              w.ruleSetRevision,
              w.delegate,
              w.delegateRole,
              w.lockedTransfer
            );
          }
          static fromAccountInfo(w, A = 0) {
            return d.deserialize(w.data, A);
          }
          static async fromAccountAddress(w, A, _) {
            const x = await w.getAccountInfo(A, _);
            if (x == null) throw new Error(`Unable to find TokenRecord account at ${A}`);
            return d.fromAccountInfo(x, 0)[0];
          }
          static gpaBuilder(w = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
            return o.GpaBuilder.fromStruct(w, e.tokenRecordBeet);
          }
          static deserialize(w, A = 0) {
            return p(w, A);
          }
          serialize() {
            return h(this);
          }
          static byteSize(w) {
            const A = d.fromArgs(w);
            return e.tokenRecordBeet.toFixedFromValue(A).byteSize;
          }
          static async getMinimumBalanceForRentExemption(w, A, _) {
            return A.getMinimumBalanceForRentExemption(d.byteSize(w), _);
          }
          pretty() {
            return {
              key: 'Key.' + a.Key[this.key],
              bump: this.bump,
              state: 'TokenState.' + c.TokenState[this.state],
              ruleSetRevision: this.ruleSetRevision,
              delegate: this.delegate,
              delegateRole: this.delegateRole,
              lockedTransfer: this.lockedTransfer,
            };
          }
        }
        (e.TokenRecord = d),
          (e.tokenRecordBeet = new i.FixableBeetStruct(
            [
              ['key', a.keyBeet],
              ['bump', i.u8],
              ['state', c.tokenStateBeet],
              ['ruleSetRevision', i.coption(i.u64)],
              ['delegate', i.coption(o.publicKey)],
              ['delegateRole', i.coption(u.tokenDelegateRoleBeet)],
              ['lockedTransfer', i.coption(o.publicKey)],
            ],
            d.fromArgs,
            'TokenRecord'
          ));
        const f = l,
          h =
            typeof f.serialize == 'function'
              ? f.serialize.bind(f)
              : e.tokenRecordBeet.serialize.bind(e.tokenRecordBeet),
          p =
            typeof f.deserialize == 'function'
              ? f.deserialize.bind(f)
              : e.tokenRecordBeet.deserialize.bind(e.tokenRecordBeet);
      })(wv)),
    wv
  );
}
var bE = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (u, l, d, f) {
            f === void 0 && (f = d);
            var h = Object.getOwnPropertyDescriptor(l, d);
            (!h || ('get' in h ? !l.__esModule : h.writable || h.configurable)) &&
              (h = {
                enumerable: !0,
                get: function () {
                  return l[d];
                },
              }),
              Object.defineProperty(u, f, h);
          }
        : function (u, l, d, f) {
            f === void 0 && (f = d), (u[f] = l[d]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (u, l) {
            Object.defineProperty(u, 'default', { enumerable: !0, value: l });
          }
        : function (u, l) {
            u.default = l;
          }),
    r =
      (m && m.__importStar) ||
      function (u) {
        if (u && u.__esModule) return u;
        var l = {};
        if (u != null)
          for (var d in u)
            d !== 'default' && Object.prototype.hasOwnProperty.call(u, d) && t(l, u, d);
        return n(l, u), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.useAuthorityRecordBeet = e.UseAuthorityRecord = void 0);
  const i = r(te),
    s = r(ne),
    o = r(kt),
    a = dr;
  class c {
    constructor(l, d, f) {
      (this.key = l), (this.allowedUses = d), (this.bump = f);
    }
    static fromArgs(l) {
      return new c(l.key, l.allowedUses, l.bump);
    }
    static fromAccountInfo(l, d = 0) {
      return c.deserialize(l.data, d);
    }
    static async fromAccountAddress(l, d, f) {
      const h = await l.getAccountInfo(d, f);
      if (h == null) throw new Error(`Unable to find UseAuthorityRecord account at ${d}`);
      return c.fromAccountInfo(h, 0)[0];
    }
    static gpaBuilder(l = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
      return o.GpaBuilder.fromStruct(l, e.useAuthorityRecordBeet);
    }
    static deserialize(l, d = 0) {
      return e.useAuthorityRecordBeet.deserialize(l, d);
    }
    serialize() {
      return e.useAuthorityRecordBeet.serialize(this);
    }
    static get byteSize() {
      return e.useAuthorityRecordBeet.byteSize;
    }
    static async getMinimumBalanceForRentExemption(l, d) {
      return l.getMinimumBalanceForRentExemption(c.byteSize, d);
    }
    static hasCorrectByteSize(l, d = 0) {
      return l.byteLength - d === c.byteSize;
    }
    pretty() {
      return {
        key: 'Key.' + a.Key[this.key],
        allowedUses: (() => {
          const l = this.allowedUses;
          if (typeof l.toNumber == 'function')
            try {
              return l.toNumber();
            } catch {
              return l;
            }
          return l;
        })(),
        bump: this.bump,
      };
    }
  }
  (e.UseAuthorityRecord = c),
    (e.useAuthorityRecordBeet = new i.BeetStruct(
      [
        ['key', a.keyBeet],
        ['allowedUses', i.u64],
        ['bump', i.u8],
      ],
      c.fromArgs,
      'UseAuthorityRecord'
    ));
})(bE);
var i2;
function Xne() {
  return (
    i2 ||
      ((i2 = 1),
      (function (e) {
        var t =
            (m && m.__createBinding) ||
            (Object.create
              ? function (b, w, A, _) {
                  _ === void 0 && (_ = A);
                  var x = Object.getOwnPropertyDescriptor(w, A);
                  (!x || ('get' in x ? !w.__esModule : x.writable || x.configurable)) &&
                    (x = {
                      enumerable: !0,
                      get: function () {
                        return w[A];
                      },
                    }),
                    Object.defineProperty(b, _, x);
                }
              : function (b, w, A, _) {
                  _ === void 0 && (_ = A), (b[_] = w[A]);
                }),
          n =
            (m && m.__exportStar) ||
            function (b, w) {
              for (var A in b)
                A !== 'default' && !Object.prototype.hasOwnProperty.call(w, A) && t(w, b, A);
            };
        Object.defineProperty(e, '__esModule', { value: !0 }),
          (e.accountProviders = void 0),
          n(oE, e),
          n(aE, e),
          n(cE, e),
          n(uE, e),
          n(lE, e),
          n(dE(), e),
          n(fE, e),
          n(hE, e),
          n(pE, e),
          n(gE, e),
          n(yE(), e),
          n(bE, e);
        const r = oE,
          i = fE,
          s = aE,
          o = cE,
          a = gE,
          c = lE,
          u = uE,
          l = dE(),
          d = yE(),
          f = pE,
          h = hE,
          p = bE;
        e.accountProviders = {
          CollectionAuthorityRecord: r.CollectionAuthorityRecord,
          MetadataDelegateRecord: i.MetadataDelegateRecord,
          Edition: s.Edition,
          EditionMarker: o.EditionMarker,
          TokenOwnedEscrow: a.TokenOwnedEscrow,
          MasterEditionV2: c.MasterEditionV2,
          MasterEditionV1: u.MasterEditionV1,
          Metadata: l.Metadata,
          TokenRecord: d.TokenRecord,
          ReservationListV2: f.ReservationListV2,
          ReservationListV1: h.ReservationListV1,
          UseAuthorityRecord: p.UseAuthorityRecord,
        };
      })(dv)),
    dv
  );
}
var N = {};
Object.defineProperty(N, '__esModule', { value: !0 });
N.ReservationAlreadyMadeError =
  N.ReservationNotSetError =
  N.ReservationDoesNotExistError =
  N.ReservationExistsError =
  N.ShareTotalMustBe100Error =
  N.NoBalanceInAccountForAuthorizationError =
  N.OwnerMismatchError =
  N.PrimarySaleCanOnlyBeFlippedToTrueError =
  N.InvalidBasisPointsError =
  N.CreatorNotFoundError =
  N.NoCreatorsPresentOnMetadataError =
  N.MustBeOneOfCreatorsError =
  N.CreatorsMustBeAtleastOneError =
  N.CreatorsTooLongError =
  N.DisabledError =
  N.AuthorizationTokenAccountOwnerMismatchError =
  N.PrintingMintAuthorizationAccountMismatchError =
  N.NotEnoughTokensError =
  N.TokenAccountMintMismatchV2Error =
  N.TokenAccountMintMismatchError =
  N.OneTimePrintingAuthMintMismatchError =
  N.PrintingMintMismatchError =
  N.DerivedKeyInvalidError =
  N.TokenAccountOneTimeAuthMintMismatchError =
  N.TokenBurnFailedError =
  N.EditionMintDecimalsShouldBeZeroError =
  N.OneTimePrintingAuthorizationMintDecimalsShouldBeZeroError =
  N.PrintingMintDecimalsShouldBeZeroError =
  N.EditionAlreadyMintedError =
  N.DestinationMintMismatchError =
  N.MasterRecordMismatchError =
  N.TokenMintToFailedError =
  N.MaxEditionsMintedAlreadyError =
  N.EditionsMustHaveExactlyOneTokenError =
  N.MintMismatchError =
  N.UpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError =
  N.UriTooLongError =
  N.SymbolTooLongError =
  N.NameTooLongError =
  N.InvalidMintAuthorityError =
  N.NotMintAuthorityError =
  N.UpdateAuthorityIsNotSignerError =
  N.UpdateAuthorityIncorrectError =
  N.InvalidEditionKeyError =
  N.InvalidMetadataKeyError =
  N.UninitializedError =
  N.AlreadyInitializedError =
  N.NotRentExemptError =
  N.InstructionPackErrorError =
  N.InstructionUnpackErrorError =
    void 0;
N.RevokeCollectionAuthoritySignerIncorrectError =
  N.InvalidUserError =
  N.EditionOverrideCannotBeZeroError =
  N.NotAllowedToChangeSellerFeeBasisPointsError =
  N.CannotWipeVerifiedCreatorsError =
  N.CannotRemoveVerifiedCreatorError =
  N.CannotAdjustVerifiedCreatorError =
  N.InvalidDelegateError =
  N.InvalidFreezeAuthorityError =
  N.InvalidCollectionAuthorityRecordError =
  N.InvalidUseAuthorityRecordError =
  N.CollectionAuthorityDoesNotExistError =
  N.CollectionAuthorityRecordAlreadyExistsError =
  N.NotEnoughUsesError =
  N.UnusableError =
  N.UseAuthorityRecordAlreadyRevokedError =
  N.UseAuthorityRecordAlreadyExistsError =
  N.CollectionMustBeAUniqueMasterEditionError =
  N.InvalidCollectionUpdateAuthorityError =
  N.CollectionNotFoundError =
  N.CannotChangeUsesAfterFirstUseError =
  N.CannotChangeUseMethodAfterFirstUseError =
  N.InvalidUseMethodError =
  N.MustBeBurnedError =
  N.RemovedError =
  N.CollectionCannotBeVerifiedInThisInstructionError =
  N.IsMutableCanOnlyBeFlippedToFalseError =
  N.ReservationArrayShouldBeSizeOneError =
  N.InvalidEditionIndexError =
  N.OneTimeAuthMintSupplyMustBeZeroForConversionError =
  N.PrintingMintSupplyMustBeZeroForConversionError =
  N.InvalidOwnerError =
  N.InvalidOperationError =
  N.TriedToReplaceAnExistingReservationError =
  N.ReservationNotCompleteError =
  N.BeyondAlottedAddressSizeError =
  N.DataTypeMismatchError =
  N.InvalidTokenProgramError =
  N.ReservationSpotsRemainingShouldMatchTotalSpotsAtStartError =
  N.DuplicateCreatorAddressError =
  N.DataIsImmutableError =
  N.PrintingWouldBreachMaximumSupplyError =
  N.IncorrectOwnerError =
  N.SpotMismatchError =
  N.CannotUnverifyAnotherCreatorError =
  N.CannotVerifyAnotherCreatorError =
  N.AddressNotInReservationError =
  N.ReservationBreachesMaximumSupplyError =
  N.NumericalOverflowErrorError =
  N.BeyondMaxAddressSizeError =
    void 0;
N.MissingSplTokenProgramError =
  N.MissingTokenAccountError =
  N.OnlySaleDelegateCanTransferError =
  N.InvalidSystemWalletError =
  N.FeatureNotSupportedError =
  N.MissingArgumentInBuilderError =
  N.MissingAccountInBuilderError =
  N.DelegateNotFoundError =
  N.DelegateAlreadyExistsError =
  N.InvalidProgrammableConfigError =
  N.MissingProgrammableConfigError =
  N.MissingAuthorizationRulesError =
  N.InvalidAuthorizationRulesError =
  N.InvalidMintForTokenStandardError =
  N.InvalidTokenStandardError =
  N.MintIsNotSignerError =
  N.EscrowParentHasDelegateError =
  N.InvalidBubblegumSignerError =
  N.InvalidCollectionSizeChangeError =
  N.NoFreezeAuthoritySetError =
  N.BorshSerializationErrorError =
  N.InsufficientTokensError =
  N.MustBeNonFungibleError =
  N.InvalidSystemProgramError =
  N.MustBeEscrowAuthorityError =
  N.InvalidEscrowBumpSeedError =
  N.MustUnverifyError =
  N.EditionNumberGreaterThanMaxSupplyError =
  N.PrintEditionDoesNotMatchMasterEditionError =
  N.ReservationListDeprecatedError =
  N.InvalidEditionMarkerError =
  N.InvalidPrintEditionError =
  N.InvalidMasterEditionError =
  N.NotAPrintEditionError =
  N.AlreadyUnverifiedError =
  N.AlreadyVerifiedError =
  N.CollectionMasterEditionAccountInvalidError =
  N.CannotUpdateVerifiedCollectionError =
  N.BorshDeserializationErrorError =
  N.MasterEditionHasPrintsError =
  N.NotAMasterEditionError =
  N.MissingEditionAccountError =
  N.CouldNotDetermineTokenStandardError =
  N.NotACollectionParentError =
  N.NotVerifiedMemberOfCollectionError =
  N.NotAMemberOfCollectionError =
  N.MissingCollectionMetadataError =
  N.SizedCollectionError =
  N.UnsizedCollectionError =
  N.TokenCloseFailedError =
    void 0;
N.errorFromName =
  N.errorFromCode =
  N.InvalidMetadataFlagsError =
  N.InvalidFeeAccountError =
  N.MissingDelegateRecordError =
  N.InvalidInstructionError =
  N.InvalidCloseAuthorityError =
  N.InvalidTokenRecordError =
  N.MissingCollectionMasterEditionError =
  N.MissingCollectionMintError =
  N.InsufficientTokenBalanceError =
  N.InvalidUpdateArgsError =
  N.InvalidParentAccountsError =
  N.InvalidInstructionsSysvarError =
  N.InvalidAssociatedTokenAccountProgramError =
  N.MissingEditionError =
  N.CannotBurnWithDelegateError =
  N.MissingEditionMarkerAccountError =
  N.MissingMasterEditionTokenAccountError =
  N.MissingMasterEditionMintAccountError =
  N.InvalidAmountError =
  N.CannotUpdateAssetWithDelegateError =
  N.DataIncrementLimitExceededError =
  N.InvalidLockedTransferAddressError =
  N.MissingLockedTransferAddressError =
  N.InvalidDelegateArgsError =
  N.AmountMustBeGreaterThanZeroError =
  N.MissingMasterEditionAccountError =
  N.MissingPrintSupplyError =
  N.InvalidDelegateRoleError =
  N.IncorrectTokenStateError =
  N.InvalidMasterEditionAccountLengthError =
  N.MissingTokenOwnerAccountError =
  N.DataIsEmptyOrZeroedError =
  N.MintSupplyMustBeZeroError =
  N.MissingTokenRecordError =
  N.InvalidAuthorityTypeError =
  N.MissingDelegateRoleError =
  N.UnlockedTokenError =
  N.LockedTokenError =
  N.KeyMismatchError =
  N.InstructionNotSupportedError =
  N.InvalidTransferAuthorityError =
  N.InvalidDelegateRoleForTransferError =
  N.MissingAuthorizationRulesProgramError =
    void 0;
const q = new Map(),
  Y = new Map();
class Pd extends Error {
  constructor() {
    super('Failed to unpack instruction data'),
      (this.code = 0),
      (this.name = 'InstructionUnpackError'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Pd);
  }
}
N.InstructionUnpackErrorError = Pd;
q.set(0, () => new Pd());
Y.set('InstructionUnpackError', () => new Pd());
class Md extends Error {
  constructor() {
    super('Failed to pack instruction data'),
      (this.code = 1),
      (this.name = 'InstructionPackError'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Md);
  }
}
N.InstructionPackErrorError = Md;
q.set(1, () => new Md());
Y.set('InstructionPackError', () => new Md());
class Od extends Error {
  constructor() {
    super('Lamport balance below rent-exempt threshold'),
      (this.code = 2),
      (this.name = 'NotRentExempt'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Od);
  }
}
N.NotRentExemptError = Od;
q.set(2, () => new Od());
Y.set('NotRentExempt', () => new Od());
class Bd extends Error {
  constructor() {
    super('Already initialized'),
      (this.code = 3),
      (this.name = 'AlreadyInitialized'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Bd);
  }
}
N.AlreadyInitializedError = Bd;
q.set(3, () => new Bd());
Y.set('AlreadyInitialized', () => new Bd());
class Dd extends Error {
  constructor() {
    super('Uninitialized'),
      (this.code = 4),
      (this.name = 'Uninitialized'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Dd);
  }
}
N.UninitializedError = Dd;
q.set(4, () => new Dd());
Y.set('Uninitialized', () => new Dd());
class Rd extends Error {
  constructor() {
    super(" Metadata's key must match seed of ['metadata', program id, mint] provided"),
      (this.code = 5),
      (this.name = 'InvalidMetadataKey'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Rd);
  }
}
N.InvalidMetadataKeyError = Rd;
q.set(5, () => new Rd());
Y.set('InvalidMetadataKey', () => new Rd());
class Nd extends Error {
  constructor() {
    super("Edition's key must match seed of ['metadata', program id, name, 'edition'] provided"),
      (this.code = 6),
      (this.name = 'InvalidEditionKey'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Nd);
  }
}
N.InvalidEditionKeyError = Nd;
q.set(6, () => new Nd());
Y.set('InvalidEditionKey', () => new Nd());
class jd extends Error {
  constructor() {
    super('Update Authority given does not match'),
      (this.code = 7),
      (this.name = 'UpdateAuthorityIncorrect'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, jd);
  }
}
N.UpdateAuthorityIncorrectError = jd;
q.set(7, () => new jd());
Y.set('UpdateAuthorityIncorrect', () => new jd());
class Ld extends Error {
  constructor() {
    super('Update Authority needs to be signer to update metadata'),
      (this.code = 8),
      (this.name = 'UpdateAuthorityIsNotSigner'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Ld);
  }
}
N.UpdateAuthorityIsNotSignerError = Ld;
q.set(8, () => new Ld());
Y.set('UpdateAuthorityIsNotSigner', () => new Ld());
class Ud extends Error {
  constructor() {
    super('You must be the mint authority and signer on this transaction'),
      (this.code = 9),
      (this.name = 'NotMintAuthority'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Ud);
  }
}
N.NotMintAuthorityError = Ud;
q.set(9, () => new Ud());
Y.set('NotMintAuthority', () => new Ud());
class $d extends Error {
  constructor() {
    super('Mint authority provided does not match the authority on the mint'),
      (this.code = 10),
      (this.name = 'InvalidMintAuthority'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, $d);
  }
}
N.InvalidMintAuthorityError = $d;
q.set(10, () => new $d());
Y.set('InvalidMintAuthority', () => new $d());
class Fd extends Error {
  constructor() {
    super('Name too long'),
      (this.code = 11),
      (this.name = 'NameTooLong'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Fd);
  }
}
N.NameTooLongError = Fd;
q.set(11, () => new Fd());
Y.set('NameTooLong', () => new Fd());
class zd extends Error {
  constructor() {
    super('Symbol too long'),
      (this.code = 12),
      (this.name = 'SymbolTooLong'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, zd);
  }
}
N.SymbolTooLongError = zd;
q.set(12, () => new zd());
Y.set('SymbolTooLong', () => new zd());
class Kd extends Error {
  constructor() {
    super('URI too long'),
      (this.code = 13),
      (this.name = 'UriTooLong'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Kd);
  }
}
N.UriTooLongError = Kd;
q.set(13, () => new Kd());
Y.set('UriTooLong', () => new Kd());
class Vd extends Error {
  constructor() {
    super(
      "Update authority must be equivalent to the metadata's authority and also signer of this transaction"
    ),
      (this.code = 14),
      (this.name = 'UpdateAuthorityMustBeEqualToMetadataAuthorityAndSigner'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Vd);
  }
}
N.UpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError = Vd;
q.set(14, () => new Vd());
Y.set('UpdateAuthorityMustBeEqualToMetadataAuthorityAndSigner', () => new Vd());
class Wd extends Error {
  constructor() {
    super('Mint given does not match mint on Metadata'),
      (this.code = 15),
      (this.name = 'MintMismatch'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Wd);
  }
}
N.MintMismatchError = Wd;
q.set(15, () => new Wd());
Y.set('MintMismatch', () => new Wd());
class Hd extends Error {
  constructor() {
    super('Editions must have exactly one token'),
      (this.code = 16),
      (this.name = 'EditionsMustHaveExactlyOneToken'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Hd);
  }
}
N.EditionsMustHaveExactlyOneTokenError = Hd;
q.set(16, () => new Hd());
Y.set('EditionsMustHaveExactlyOneToken', () => new Hd());
class Gd extends Error {
  constructor() {
    super('Maximum editions printed already'),
      (this.code = 17),
      (this.name = 'MaxEditionsMintedAlready'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Gd);
  }
}
N.MaxEditionsMintedAlreadyError = Gd;
q.set(17, () => new Gd());
Y.set('MaxEditionsMintedAlready', () => new Gd());
class qd extends Error {
  constructor() {
    super('Token mint to failed'),
      (this.code = 18),
      (this.name = 'TokenMintToFailed'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, qd);
  }
}
N.TokenMintToFailedError = qd;
q.set(18, () => new qd());
Y.set('TokenMintToFailed', () => new qd());
class Yd extends Error {
  constructor() {
    super('The master edition record passed must match the master record on the edition given'),
      (this.code = 19),
      (this.name = 'MasterRecordMismatch'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Yd);
  }
}
N.MasterRecordMismatchError = Yd;
q.set(19, () => new Yd());
Y.set('MasterRecordMismatch', () => new Yd());
class Zd extends Error {
  constructor() {
    super('The destination account does not have the right mint'),
      (this.code = 20),
      (this.name = 'DestinationMintMismatch'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Zd);
  }
}
N.DestinationMintMismatchError = Zd;
q.set(20, () => new Zd());
Y.set('DestinationMintMismatch', () => new Zd());
class Jd extends Error {
  constructor() {
    super('An edition can only mint one of its kind!'),
      (this.code = 21),
      (this.name = 'EditionAlreadyMinted'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Jd);
  }
}
N.EditionAlreadyMintedError = Jd;
q.set(21, () => new Jd());
Y.set('EditionAlreadyMinted', () => new Jd());
class Xd extends Error {
  constructor() {
    super('Printing mint decimals should be zero'),
      (this.code = 22),
      (this.name = 'PrintingMintDecimalsShouldBeZero'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Xd);
  }
}
N.PrintingMintDecimalsShouldBeZeroError = Xd;
q.set(22, () => new Xd());
Y.set('PrintingMintDecimalsShouldBeZero', () => new Xd());
class Qd extends Error {
  constructor() {
    super('OneTimePrintingAuthorization mint decimals should be zero'),
      (this.code = 23),
      (this.name = 'OneTimePrintingAuthorizationMintDecimalsShouldBeZero'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Qd);
  }
}
N.OneTimePrintingAuthorizationMintDecimalsShouldBeZeroError = Qd;
q.set(23, () => new Qd());
Y.set('OneTimePrintingAuthorizationMintDecimalsShouldBeZero', () => new Qd());
class ef extends Error {
  constructor() {
    super('EditionMintDecimalsShouldBeZero'),
      (this.code = 24),
      (this.name = 'EditionMintDecimalsShouldBeZero'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, ef);
  }
}
N.EditionMintDecimalsShouldBeZeroError = ef;
q.set(24, () => new ef());
Y.set('EditionMintDecimalsShouldBeZero', () => new ef());
class tf extends Error {
  constructor() {
    super('Token burn failed'),
      (this.code = 25),
      (this.name = 'TokenBurnFailed'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, tf);
  }
}
N.TokenBurnFailedError = tf;
q.set(25, () => new tf());
Y.set('TokenBurnFailed', () => new tf());
class nf extends Error {
  constructor() {
    super('The One Time authorization mint does not match that on the token account!'),
      (this.code = 26),
      (this.name = 'TokenAccountOneTimeAuthMintMismatch'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, nf);
  }
}
N.TokenAccountOneTimeAuthMintMismatchError = nf;
q.set(26, () => new nf());
Y.set('TokenAccountOneTimeAuthMintMismatch', () => new nf());
class rf extends Error {
  constructor() {
    super('Derived key invalid'),
      (this.code = 27),
      (this.name = 'DerivedKeyInvalid'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, rf);
  }
}
N.DerivedKeyInvalidError = rf;
q.set(27, () => new rf());
Y.set('DerivedKeyInvalid', () => new rf());
class sf extends Error {
  constructor() {
    super('The Printing mint does not match that on the master edition!'),
      (this.code = 28),
      (this.name = 'PrintingMintMismatch'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, sf);
  }
}
N.PrintingMintMismatchError = sf;
q.set(28, () => new sf());
Y.set('PrintingMintMismatch', () => new sf());
class of extends Error {
  constructor() {
    super('The One Time Printing Auth mint does not match that on the master edition!'),
      (this.code = 29),
      (this.name = 'OneTimePrintingAuthMintMismatch'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, of);
  }
}
N.OneTimePrintingAuthMintMismatchError = of;
q.set(29, () => new of());
Y.set('OneTimePrintingAuthMintMismatch', () => new of());
class af extends Error {
  constructor() {
    super('The mint of the token account does not match the Printing mint!'),
      (this.code = 30),
      (this.name = 'TokenAccountMintMismatch'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, af);
  }
}
N.TokenAccountMintMismatchError = af;
q.set(30, () => new af());
Y.set('TokenAccountMintMismatch', () => new af());
class cf extends Error {
  constructor() {
    super('The mint of the token account does not match the master metadata mint!'),
      (this.code = 31),
      (this.name = 'TokenAccountMintMismatchV2'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, cf);
  }
}
N.TokenAccountMintMismatchV2Error = cf;
q.set(31, () => new cf());
Y.set('TokenAccountMintMismatchV2', () => new cf());
class uf extends Error {
  constructor() {
    super('Not enough tokens to mint a limited edition'),
      (this.code = 32),
      (this.name = 'NotEnoughTokens'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, uf);
  }
}
N.NotEnoughTokensError = uf;
q.set(32, () => new uf());
Y.set('NotEnoughTokens', () => new uf());
class lf extends Error {
  constructor() {
    super(
      'The mint on your authorization token holding account does not match your Printing mint!'
    ),
      (this.code = 33),
      (this.name = 'PrintingMintAuthorizationAccountMismatch'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, lf);
  }
}
N.PrintingMintAuthorizationAccountMismatchError = lf;
q.set(33, () => new lf());
Y.set('PrintingMintAuthorizationAccountMismatch', () => new lf());
class df extends Error {
  constructor() {
    super(
      'The authorization token account has a different owner than the update authority for the master edition!'
    ),
      (this.code = 34),
      (this.name = 'AuthorizationTokenAccountOwnerMismatch'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, df);
  }
}
N.AuthorizationTokenAccountOwnerMismatchError = df;
q.set(34, () => new df());
Y.set('AuthorizationTokenAccountOwnerMismatch', () => new df());
class ff extends Error {
  constructor() {
    super('This feature is currently disabled.'),
      (this.code = 35),
      (this.name = 'Disabled'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, ff);
  }
}
N.DisabledError = ff;
q.set(35, () => new ff());
Y.set('Disabled', () => new ff());
class hf extends Error {
  constructor() {
    super('Creators list too long'),
      (this.code = 36),
      (this.name = 'CreatorsTooLong'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, hf);
  }
}
N.CreatorsTooLongError = hf;
q.set(36, () => new hf());
Y.set('CreatorsTooLong', () => new hf());
class pf extends Error {
  constructor() {
    super('Creators must be at least one if set'),
      (this.code = 37),
      (this.name = 'CreatorsMustBeAtleastOne'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, pf);
  }
}
N.CreatorsMustBeAtleastOneError = pf;
q.set(37, () => new pf());
Y.set('CreatorsMustBeAtleastOne', () => new pf());
class gf extends Error {
  constructor() {
    super('If using a creators array, you must be one of the creators listed'),
      (this.code = 38),
      (this.name = 'MustBeOneOfCreators'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, gf);
  }
}
N.MustBeOneOfCreatorsError = gf;
q.set(38, () => new gf());
Y.set('MustBeOneOfCreators', () => new gf());
class yf extends Error {
  constructor() {
    super('This metadata does not have creators'),
      (this.code = 39),
      (this.name = 'NoCreatorsPresentOnMetadata'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, yf);
  }
}
N.NoCreatorsPresentOnMetadataError = yf;
q.set(39, () => new yf());
Y.set('NoCreatorsPresentOnMetadata', () => new yf());
class bf extends Error {
  constructor() {
    super('This creator address was not found'),
      (this.code = 40),
      (this.name = 'CreatorNotFound'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, bf);
  }
}
N.CreatorNotFoundError = bf;
q.set(40, () => new bf());
Y.set('CreatorNotFound', () => new bf());
class mf extends Error {
  constructor() {
    super('Basis points cannot be more than 10000'),
      (this.code = 41),
      (this.name = 'InvalidBasisPoints'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, mf);
  }
}
N.InvalidBasisPointsError = mf;
q.set(41, () => new mf());
Y.set('InvalidBasisPoints', () => new mf());
class wf extends Error {
  constructor() {
    super('Primary sale can only be flipped to true and is immutable'),
      (this.code = 42),
      (this.name = 'PrimarySaleCanOnlyBeFlippedToTrue'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, wf);
  }
}
N.PrimarySaleCanOnlyBeFlippedToTrueError = wf;
q.set(42, () => new wf());
Y.set('PrimarySaleCanOnlyBeFlippedToTrue', () => new wf());
class vf extends Error {
  constructor() {
    super('Owner does not match that on the account given'),
      (this.code = 43),
      (this.name = 'OwnerMismatch'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, vf);
  }
}
N.OwnerMismatchError = vf;
q.set(43, () => new vf());
Y.set('OwnerMismatch', () => new vf());
class _f extends Error {
  constructor() {
    super('This account has no tokens to be used for authorization'),
      (this.code = 44),
      (this.name = 'NoBalanceInAccountForAuthorization'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, _f);
  }
}
N.NoBalanceInAccountForAuthorizationError = _f;
q.set(44, () => new _f());
Y.set('NoBalanceInAccountForAuthorization', () => new _f());
class Sf extends Error {
  constructor() {
    super('Share total must equal 100 for creator array'),
      (this.code = 45),
      (this.name = 'ShareTotalMustBe100'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Sf);
  }
}
N.ShareTotalMustBe100Error = Sf;
q.set(45, () => new Sf());
Y.set('ShareTotalMustBe100', () => new Sf());
class Ef extends Error {
  constructor() {
    super('This reservation list already exists!'),
      (this.code = 46),
      (this.name = 'ReservationExists'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Ef);
  }
}
N.ReservationExistsError = Ef;
q.set(46, () => new Ef());
Y.set('ReservationExists', () => new Ef());
class Af extends Error {
  constructor() {
    super('This reservation list does not exist!'),
      (this.code = 47),
      (this.name = 'ReservationDoesNotExist'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Af);
  }
}
N.ReservationDoesNotExistError = Af;
q.set(47, () => new Af());
Y.set('ReservationDoesNotExist', () => new Af());
class If extends Error {
  constructor() {
    super('This reservation list exists but was never set with reservations'),
      (this.code = 48),
      (this.name = 'ReservationNotSet'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, If);
  }
}
N.ReservationNotSetError = If;
q.set(48, () => new If());
Y.set('ReservationNotSet', () => new If());
class Tf extends Error {
  constructor() {
    super('This reservation list has already been set!'),
      (this.code = 49),
      (this.name = 'ReservationAlreadyMade'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Tf);
  }
}
N.ReservationAlreadyMadeError = Tf;
q.set(49, () => new Tf());
Y.set('ReservationAlreadyMade', () => new Tf());
class xf extends Error {
  constructor() {
    super('Provided more addresses than max allowed in single reservation'),
      (this.code = 50),
      (this.name = 'BeyondMaxAddressSize'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, xf);
  }
}
N.BeyondMaxAddressSizeError = xf;
q.set(50, () => new xf());
Y.set('BeyondMaxAddressSize', () => new xf());
class kf extends Error {
  constructor() {
    super('NumericalOverflowError'),
      (this.code = 51),
      (this.name = 'NumericalOverflowError'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, kf);
  }
}
N.NumericalOverflowErrorError = kf;
q.set(51, () => new kf());
Y.set('NumericalOverflowError', () => new kf());
class Cf extends Error {
  constructor() {
    super('This reservation would go beyond the maximum supply of the master edition!'),
      (this.code = 52),
      (this.name = 'ReservationBreachesMaximumSupply'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Cf);
  }
}
N.ReservationBreachesMaximumSupplyError = Cf;
q.set(52, () => new Cf());
Y.set('ReservationBreachesMaximumSupply', () => new Cf());
class Pf extends Error {
  constructor() {
    super('Address not in reservation!'),
      (this.code = 53),
      (this.name = 'AddressNotInReservation'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Pf);
  }
}
N.AddressNotInReservationError = Pf;
q.set(53, () => new Pf());
Y.set('AddressNotInReservation', () => new Pf());
class Mf extends Error {
  constructor() {
    super('You cannot unilaterally verify another creator, they must sign'),
      (this.code = 54),
      (this.name = 'CannotVerifyAnotherCreator'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Mf);
  }
}
N.CannotVerifyAnotherCreatorError = Mf;
q.set(54, () => new Mf());
Y.set('CannotVerifyAnotherCreator', () => new Mf());
class Of extends Error {
  constructor() {
    super('You cannot unilaterally unverify another creator'),
      (this.code = 55),
      (this.name = 'CannotUnverifyAnotherCreator'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Of);
  }
}
N.CannotUnverifyAnotherCreatorError = Of;
q.set(55, () => new Of());
Y.set('CannotUnverifyAnotherCreator', () => new Of());
class Bf extends Error {
  constructor() {
    super('In initial reservation setting, spots remaining should equal total spots'),
      (this.code = 56),
      (this.name = 'SpotMismatch'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Bf);
  }
}
N.SpotMismatchError = Bf;
q.set(56, () => new Bf());
Y.set('SpotMismatch', () => new Bf());
class Df extends Error {
  constructor() {
    super('Incorrect account owner'),
      (this.code = 57),
      (this.name = 'IncorrectOwner'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Df);
  }
}
N.IncorrectOwnerError = Df;
q.set(57, () => new Df());
Y.set('IncorrectOwner', () => new Df());
class Rf extends Error {
  constructor() {
    super('printing these tokens would breach the maximum supply limit of the master edition'),
      (this.code = 58),
      (this.name = 'PrintingWouldBreachMaximumSupply'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Rf);
  }
}
N.PrintingWouldBreachMaximumSupplyError = Rf;
q.set(58, () => new Rf());
Y.set('PrintingWouldBreachMaximumSupply', () => new Rf());
class Nf extends Error {
  constructor() {
    super('Data is immutable'),
      (this.code = 59),
      (this.name = 'DataIsImmutable'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Nf);
  }
}
N.DataIsImmutableError = Nf;
q.set(59, () => new Nf());
Y.set('DataIsImmutable', () => new Nf());
class jf extends Error {
  constructor() {
    super('No duplicate creator addresses'),
      (this.code = 60),
      (this.name = 'DuplicateCreatorAddress'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, jf);
  }
}
N.DuplicateCreatorAddressError = jf;
q.set(60, () => new jf());
Y.set('DuplicateCreatorAddress', () => new jf());
class Lf extends Error {
  constructor() {
    super('Reservation spots remaining should match total spots when first being created'),
      (this.code = 61),
      (this.name = 'ReservationSpotsRemainingShouldMatchTotalSpotsAtStart'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Lf);
  }
}
N.ReservationSpotsRemainingShouldMatchTotalSpotsAtStartError = Lf;
q.set(61, () => new Lf());
Y.set('ReservationSpotsRemainingShouldMatchTotalSpotsAtStart', () => new Lf());
class Uf extends Error {
  constructor() {
    super('Invalid token program'),
      (this.code = 62),
      (this.name = 'InvalidTokenProgram'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Uf);
  }
}
N.InvalidTokenProgramError = Uf;
q.set(62, () => new Uf());
Y.set('InvalidTokenProgram', () => new Uf());
class $f extends Error {
  constructor() {
    super('Data type mismatch'),
      (this.code = 63),
      (this.name = 'DataTypeMismatch'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, $f);
  }
}
N.DataTypeMismatchError = $f;
q.set(63, () => new $f());
Y.set('DataTypeMismatch', () => new $f());
class Ff extends Error {
  constructor() {
    super('Beyond alotted address size in reservation!'),
      (this.code = 64),
      (this.name = 'BeyondAlottedAddressSize'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Ff);
  }
}
N.BeyondAlottedAddressSizeError = Ff;
q.set(64, () => new Ff());
Y.set('BeyondAlottedAddressSize', () => new Ff());
class zf extends Error {
  constructor() {
    super('The reservation has only been partially alotted'),
      (this.code = 65),
      (this.name = 'ReservationNotComplete'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, zf);
  }
}
N.ReservationNotCompleteError = zf;
q.set(65, () => new zf());
Y.set('ReservationNotComplete', () => new zf());
class Kf extends Error {
  constructor() {
    super('You cannot splice over an existing reservation!'),
      (this.code = 66),
      (this.name = 'TriedToReplaceAnExistingReservation'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Kf);
  }
}
N.TriedToReplaceAnExistingReservationError = Kf;
q.set(66, () => new Kf());
Y.set('TriedToReplaceAnExistingReservation', () => new Kf());
class Vf extends Error {
  constructor() {
    super('Invalid operation'),
      (this.code = 67),
      (this.name = 'InvalidOperation'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Vf);
  }
}
N.InvalidOperationError = Vf;
q.set(67, () => new Vf());
Y.set('InvalidOperation', () => new Vf());
class Wf extends Error {
  constructor() {
    super('Invalid Owner'),
      (this.code = 68),
      (this.name = 'InvalidOwner'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Wf);
  }
}
N.InvalidOwnerError = Wf;
q.set(68, () => new Wf());
Y.set('InvalidOwner', () => new Wf());
class Hf extends Error {
  constructor() {
    super('Printing mint supply must be zero for conversion'),
      (this.code = 69),
      (this.name = 'PrintingMintSupplyMustBeZeroForConversion'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Hf);
  }
}
N.PrintingMintSupplyMustBeZeroForConversionError = Hf;
q.set(69, () => new Hf());
Y.set('PrintingMintSupplyMustBeZeroForConversion', () => new Hf());
class Gf extends Error {
  constructor() {
    super('One Time Auth mint supply must be zero for conversion'),
      (this.code = 70),
      (this.name = 'OneTimeAuthMintSupplyMustBeZeroForConversion'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Gf);
  }
}
N.OneTimeAuthMintSupplyMustBeZeroForConversionError = Gf;
q.set(70, () => new Gf());
Y.set('OneTimeAuthMintSupplyMustBeZeroForConversion', () => new Gf());
class qf extends Error {
  constructor() {
    super('You tried to insert one edition too many into an edition mark pda'),
      (this.code = 71),
      (this.name = 'InvalidEditionIndex'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, qf);
  }
}
N.InvalidEditionIndexError = qf;
q.set(71, () => new qf());
Y.set('InvalidEditionIndex', () => new qf());
class Yf extends Error {
  constructor() {
    super('In the legacy system the reservation needs to be of size one for cpu limit reasons'),
      (this.code = 72),
      (this.name = 'ReservationArrayShouldBeSizeOne'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Yf);
  }
}
N.ReservationArrayShouldBeSizeOneError = Yf;
q.set(72, () => new Yf());
Y.set('ReservationArrayShouldBeSizeOne', () => new Yf());
class Zf extends Error {
  constructor() {
    super('Is Mutable can only be flipped to false'),
      (this.code = 73),
      (this.name = 'IsMutableCanOnlyBeFlippedToFalse'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Zf);
  }
}
N.IsMutableCanOnlyBeFlippedToFalseError = Zf;
q.set(73, () => new Zf());
Y.set('IsMutableCanOnlyBeFlippedToFalse', () => new Zf());
class Jf extends Error {
  constructor() {
    super('Collection cannot be verified in this instruction'),
      (this.code = 74),
      (this.name = 'CollectionCannotBeVerifiedInThisInstruction'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Jf);
  }
}
N.CollectionCannotBeVerifiedInThisInstructionError = Jf;
q.set(74, () => new Jf());
Y.set('CollectionCannotBeVerifiedInThisInstruction', () => new Jf());
class Xf extends Error {
  constructor() {
    super('This instruction was deprecated in a previous release and is now removed'),
      (this.code = 75),
      (this.name = 'Removed'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Xf);
  }
}
N.RemovedError = Xf;
q.set(75, () => new Xf());
Y.set('Removed', () => new Xf());
class Qf extends Error {
  constructor() {
    super('This token use method is burn and there are no remaining uses, it must be burned'),
      (this.code = 76),
      (this.name = 'MustBeBurned'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Qf);
  }
}
N.MustBeBurnedError = Qf;
q.set(76, () => new Qf());
Y.set('MustBeBurned', () => new Qf());
class eh extends Error {
  constructor() {
    super('This use method is invalid'),
      (this.code = 77),
      (this.name = 'InvalidUseMethod'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, eh);
  }
}
N.InvalidUseMethodError = eh;
q.set(77, () => new eh());
Y.set('InvalidUseMethod', () => new eh());
class th extends Error {
  constructor() {
    super('Cannot Change Use Method after the first use'),
      (this.code = 78),
      (this.name = 'CannotChangeUseMethodAfterFirstUse'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, th);
  }
}
N.CannotChangeUseMethodAfterFirstUseError = th;
q.set(78, () => new th());
Y.set('CannotChangeUseMethodAfterFirstUse', () => new th());
class nh extends Error {
  constructor() {
    super('Cannot Change Remaining or Available uses after the first use'),
      (this.code = 79),
      (this.name = 'CannotChangeUsesAfterFirstUse'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, nh);
  }
}
N.CannotChangeUsesAfterFirstUseError = nh;
q.set(79, () => new nh());
Y.set('CannotChangeUsesAfterFirstUse', () => new nh());
class rh extends Error {
  constructor() {
    super('Collection Not Found on Metadata'),
      (this.code = 80),
      (this.name = 'CollectionNotFound'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, rh);
  }
}
N.CollectionNotFoundError = rh;
q.set(80, () => new rh());
Y.set('CollectionNotFound', () => new rh());
class ih extends Error {
  constructor() {
    super('Collection Update Authority is invalid'),
      (this.code = 81),
      (this.name = 'InvalidCollectionUpdateAuthority'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, ih);
  }
}
N.InvalidCollectionUpdateAuthorityError = ih;
q.set(81, () => new ih());
Y.set('InvalidCollectionUpdateAuthority', () => new ih());
class sh extends Error {
  constructor() {
    super('Collection Must Be a Unique Master Edition v2'),
      (this.code = 82),
      (this.name = 'CollectionMustBeAUniqueMasterEdition'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, sh);
  }
}
N.CollectionMustBeAUniqueMasterEditionError = sh;
q.set(82, () => new sh());
Y.set('CollectionMustBeAUniqueMasterEdition', () => new sh());
class oh extends Error {
  constructor() {
    super('The Use Authority Record Already Exists, to modify it Revoke, then Approve'),
      (this.code = 83),
      (this.name = 'UseAuthorityRecordAlreadyExists'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, oh);
  }
}
N.UseAuthorityRecordAlreadyExistsError = oh;
q.set(83, () => new oh());
Y.set('UseAuthorityRecordAlreadyExists', () => new oh());
class ah extends Error {
  constructor() {
    super('The Use Authority Record is empty or already revoked'),
      (this.code = 84),
      (this.name = 'UseAuthorityRecordAlreadyRevoked'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, ah);
  }
}
N.UseAuthorityRecordAlreadyRevokedError = ah;
q.set(84, () => new ah());
Y.set('UseAuthorityRecordAlreadyRevoked', () => new ah());
class ch extends Error {
  constructor() {
    super('This token has no uses'),
      (this.code = 85),
      (this.name = 'Unusable'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, ch);
  }
}
N.UnusableError = ch;
q.set(85, () => new ch());
Y.set('Unusable', () => new ch());
class uh extends Error {
  constructor() {
    super('There are not enough Uses left on this token.'),
      (this.code = 86),
      (this.name = 'NotEnoughUses'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, uh);
  }
}
N.NotEnoughUsesError = uh;
q.set(86, () => new uh());
Y.set('NotEnoughUses', () => new uh());
class lh extends Error {
  constructor() {
    super('This Collection Authority Record Already Exists.'),
      (this.code = 87),
      (this.name = 'CollectionAuthorityRecordAlreadyExists'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, lh);
  }
}
N.CollectionAuthorityRecordAlreadyExistsError = lh;
q.set(87, () => new lh());
Y.set('CollectionAuthorityRecordAlreadyExists', () => new lh());
class dh extends Error {
  constructor() {
    super('This Collection Authority Record Does Not Exist.'),
      (this.code = 88),
      (this.name = 'CollectionAuthorityDoesNotExist'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, dh);
  }
}
N.CollectionAuthorityDoesNotExistError = dh;
q.set(88, () => new dh());
Y.set('CollectionAuthorityDoesNotExist', () => new dh());
class fh extends Error {
  constructor() {
    super('This Use Authority Record is invalid.'),
      (this.code = 89),
      (this.name = 'InvalidUseAuthorityRecord'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, fh);
  }
}
N.InvalidUseAuthorityRecordError = fh;
q.set(89, () => new fh());
Y.set('InvalidUseAuthorityRecord', () => new fh());
class hh extends Error {
  constructor() {
    super('This Collection Authority Record is invalid.'),
      (this.code = 90),
      (this.name = 'InvalidCollectionAuthorityRecord'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, hh);
  }
}
N.InvalidCollectionAuthorityRecordError = hh;
q.set(90, () => new hh());
Y.set('InvalidCollectionAuthorityRecord', () => new hh());
class ph extends Error {
  constructor() {
    super('Metadata does not match the freeze authority on the mint'),
      (this.code = 91),
      (this.name = 'InvalidFreezeAuthority'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, ph);
  }
}
N.InvalidFreezeAuthorityError = ph;
q.set(91, () => new ph());
Y.set('InvalidFreezeAuthority', () => new ph());
class gh extends Error {
  constructor() {
    super('All tokens in this account have not been delegated to this user.'),
      (this.code = 92),
      (this.name = 'InvalidDelegate'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, gh);
  }
}
N.InvalidDelegateError = gh;
q.set(92, () => new gh());
Y.set('InvalidDelegate', () => new gh());
class yh extends Error {
  constructor() {
    super('Creator can not be adjusted once they are verified.'),
      (this.code = 93),
      (this.name = 'CannotAdjustVerifiedCreator'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, yh);
  }
}
N.CannotAdjustVerifiedCreatorError = yh;
q.set(93, () => new yh());
Y.set('CannotAdjustVerifiedCreator', () => new yh());
class bh extends Error {
  constructor() {
    super('Verified creators cannot be removed.'),
      (this.code = 94),
      (this.name = 'CannotRemoveVerifiedCreator'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, bh);
  }
}
N.CannotRemoveVerifiedCreatorError = bh;
q.set(94, () => new bh());
Y.set('CannotRemoveVerifiedCreator', () => new bh());
class mh extends Error {
  constructor() {
    super('Can not wipe verified creators.'),
      (this.code = 95),
      (this.name = 'CannotWipeVerifiedCreators'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, mh);
  }
}
N.CannotWipeVerifiedCreatorsError = mh;
q.set(95, () => new mh());
Y.set('CannotWipeVerifiedCreators', () => new mh());
class wh extends Error {
  constructor() {
    super('Not allowed to change seller fee basis points.'),
      (this.code = 96),
      (this.name = 'NotAllowedToChangeSellerFeeBasisPoints'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, wh);
  }
}
N.NotAllowedToChangeSellerFeeBasisPointsError = wh;
q.set(96, () => new wh());
Y.set('NotAllowedToChangeSellerFeeBasisPoints', () => new wh());
class vh extends Error {
  constructor() {
    super('Edition override cannot be zero'),
      (this.code = 97),
      (this.name = 'EditionOverrideCannotBeZero'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, vh);
  }
}
N.EditionOverrideCannotBeZeroError = vh;
q.set(97, () => new vh());
Y.set('EditionOverrideCannotBeZero', () => new vh());
class _h extends Error {
  constructor() {
    super('Invalid User'),
      (this.code = 98),
      (this.name = 'InvalidUser'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, _h);
  }
}
N.InvalidUserError = _h;
q.set(98, () => new _h());
Y.set('InvalidUser', () => new _h());
class Sh extends Error {
  constructor() {
    super('Revoke Collection Authority signer is incorrect'),
      (this.code = 99),
      (this.name = 'RevokeCollectionAuthoritySignerIncorrect'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Sh);
  }
}
N.RevokeCollectionAuthoritySignerIncorrectError = Sh;
q.set(99, () => new Sh());
Y.set('RevokeCollectionAuthoritySignerIncorrect', () => new Sh());
class Eh extends Error {
  constructor() {
    super('Token close failed'),
      (this.code = 100),
      (this.name = 'TokenCloseFailed'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Eh);
  }
}
N.TokenCloseFailedError = Eh;
q.set(100, () => new Eh());
Y.set('TokenCloseFailed', () => new Eh());
class Ah extends Error {
  constructor() {
    super("Can't use this function on unsized collection"),
      (this.code = 101),
      (this.name = 'UnsizedCollection'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Ah);
  }
}
N.UnsizedCollectionError = Ah;
q.set(101, () => new Ah());
Y.set('UnsizedCollection', () => new Ah());
class Ih extends Error {
  constructor() {
    super("Can't use this function on a sized collection"),
      (this.code = 102),
      (this.name = 'SizedCollection'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Ih);
  }
}
N.SizedCollectionError = Ih;
q.set(102, () => new Ih());
Y.set('SizedCollection', () => new Ih());
class Th extends Error {
  constructor() {
    super('Missing collection metadata account'),
      (this.code = 103),
      (this.name = 'MissingCollectionMetadata'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Th);
  }
}
N.MissingCollectionMetadataError = Th;
q.set(103, () => new Th());
Y.set('MissingCollectionMetadata', () => new Th());
class xh extends Error {
  constructor() {
    super('This NFT is not a member of the specified collection.'),
      (this.code = 104),
      (this.name = 'NotAMemberOfCollection'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, xh);
  }
}
N.NotAMemberOfCollectionError = xh;
q.set(104, () => new xh());
Y.set('NotAMemberOfCollection', () => new xh());
class kh extends Error {
  constructor() {
    super('This NFT is not a verified member of the specified collection.'),
      (this.code = 105),
      (this.name = 'NotVerifiedMemberOfCollection'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, kh);
  }
}
N.NotVerifiedMemberOfCollectionError = kh;
q.set(105, () => new kh());
Y.set('NotVerifiedMemberOfCollection', () => new kh());
class Ch extends Error {
  constructor() {
    super('This NFT is not a collection parent NFT.'),
      (this.code = 106),
      (this.name = 'NotACollectionParent'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Ch);
  }
}
N.NotACollectionParentError = Ch;
q.set(106, () => new Ch());
Y.set('NotACollectionParent', () => new Ch());
class Ph extends Error {
  constructor() {
    super('Could not determine a TokenStandard type.'),
      (this.code = 107),
      (this.name = 'CouldNotDetermineTokenStandard'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Ph);
  }
}
N.CouldNotDetermineTokenStandardError = Ph;
q.set(107, () => new Ph());
Y.set('CouldNotDetermineTokenStandard', () => new Ph());
class Mh extends Error {
  constructor() {
    super('This mint account has an edition but none was provided.'),
      (this.code = 108),
      (this.name = 'MissingEditionAccount'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Mh);
  }
}
N.MissingEditionAccountError = Mh;
q.set(108, () => new Mh());
Y.set('MissingEditionAccount', () => new Mh());
class Oh extends Error {
  constructor() {
    super('This edition is not a Master Edition'),
      (this.code = 109),
      (this.name = 'NotAMasterEdition'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Oh);
  }
}
N.NotAMasterEditionError = Oh;
q.set(109, () => new Oh());
Y.set('NotAMasterEdition', () => new Oh());
class Bh extends Error {
  constructor() {
    super('This Master Edition has existing prints'),
      (this.code = 110),
      (this.name = 'MasterEditionHasPrints'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Bh);
  }
}
N.MasterEditionHasPrintsError = Bh;
q.set(110, () => new Bh());
Y.set('MasterEditionHasPrints', () => new Bh());
class Dh extends Error {
  constructor() {
    super('Borsh Deserialization Error'),
      (this.code = 111),
      (this.name = 'BorshDeserializationError'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Dh);
  }
}
N.BorshDeserializationErrorError = Dh;
q.set(111, () => new Dh());
Y.set('BorshDeserializationError', () => new Dh());
class Rh extends Error {
  constructor() {
    super('Cannot update a verified collection in this command'),
      (this.code = 112),
      (this.name = 'CannotUpdateVerifiedCollection'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Rh);
  }
}
N.CannotUpdateVerifiedCollectionError = Rh;
q.set(112, () => new Rh());
Y.set('CannotUpdateVerifiedCollection', () => new Rh());
class Nh extends Error {
  constructor() {
    super('Edition account doesnt match collection '),
      (this.code = 113),
      (this.name = 'CollectionMasterEditionAccountInvalid'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Nh);
  }
}
N.CollectionMasterEditionAccountInvalidError = Nh;
q.set(113, () => new Nh());
Y.set('CollectionMasterEditionAccountInvalid', () => new Nh());
class jh extends Error {
  constructor() {
    super('Item is already verified.'),
      (this.code = 114),
      (this.name = 'AlreadyVerified'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, jh);
  }
}
N.AlreadyVerifiedError = jh;
q.set(114, () => new jh());
Y.set('AlreadyVerified', () => new jh());
class Lh extends Error {
  constructor() {
    super('Item is already unverified.'),
      (this.code = 115),
      (this.name = 'AlreadyUnverified'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Lh);
  }
}
N.AlreadyUnverifiedError = Lh;
q.set(115, () => new Lh());
Y.set('AlreadyUnverified', () => new Lh());
class Uh extends Error {
  constructor() {
    super('This edition is not a Print Edition'),
      (this.code = 116),
      (this.name = 'NotAPrintEdition'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Uh);
  }
}
N.NotAPrintEditionError = Uh;
q.set(116, () => new Uh());
Y.set('NotAPrintEdition', () => new Uh());
class $h extends Error {
  constructor() {
    super('Invalid Master Edition'),
      (this.code = 117),
      (this.name = 'InvalidMasterEdition'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, $h);
  }
}
N.InvalidMasterEditionError = $h;
q.set(117, () => new $h());
Y.set('InvalidMasterEdition', () => new $h());
class Fh extends Error {
  constructor() {
    super('Invalid Print Edition'),
      (this.code = 118),
      (this.name = 'InvalidPrintEdition'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Fh);
  }
}
N.InvalidPrintEditionError = Fh;
q.set(118, () => new Fh());
Y.set('InvalidPrintEdition', () => new Fh());
class zh extends Error {
  constructor() {
    super('Invalid Edition Marker'),
      (this.code = 119),
      (this.name = 'InvalidEditionMarker'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, zh);
  }
}
N.InvalidEditionMarkerError = zh;
q.set(119, () => new zh());
Y.set('InvalidEditionMarker', () => new zh());
class Kh extends Error {
  constructor() {
    super('Reservation List is Deprecated'),
      (this.code = 120),
      (this.name = 'ReservationListDeprecated'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Kh);
  }
}
N.ReservationListDeprecatedError = Kh;
q.set(120, () => new Kh());
Y.set('ReservationListDeprecated', () => new Kh());
class Vh extends Error {
  constructor() {
    super('Print Edition does not match Master Edition'),
      (this.code = 121),
      (this.name = 'PrintEditionDoesNotMatchMasterEdition'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Vh);
  }
}
N.PrintEditionDoesNotMatchMasterEditionError = Vh;
q.set(121, () => new Vh());
Y.set('PrintEditionDoesNotMatchMasterEdition', () => new Vh());
class Wh extends Error {
  constructor() {
    super('Edition Number greater than max supply'),
      (this.code = 122),
      (this.name = 'EditionNumberGreaterThanMaxSupply'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Wh);
  }
}
N.EditionNumberGreaterThanMaxSupplyError = Wh;
q.set(122, () => new Wh());
Y.set('EditionNumberGreaterThanMaxSupply', () => new Wh());
class Hh extends Error {
  constructor() {
    super('Must unverify before migrating collections.'),
      (this.code = 123),
      (this.name = 'MustUnverify'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Hh);
  }
}
N.MustUnverifyError = Hh;
q.set(123, () => new Hh());
Y.set('MustUnverify', () => new Hh());
class Gh extends Error {
  constructor() {
    super('Invalid Escrow Account Bump Seed'),
      (this.code = 124),
      (this.name = 'InvalidEscrowBumpSeed'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Gh);
  }
}
N.InvalidEscrowBumpSeedError = Gh;
q.set(124, () => new Gh());
Y.set('InvalidEscrowBumpSeed', () => new Gh());
class qh extends Error {
  constructor() {
    super('Must Escrow Authority'),
      (this.code = 125),
      (this.name = 'MustBeEscrowAuthority'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, qh);
  }
}
N.MustBeEscrowAuthorityError = qh;
q.set(125, () => new qh());
Y.set('MustBeEscrowAuthority', () => new qh());
class Yh extends Error {
  constructor() {
    super('Invalid System Program'),
      (this.code = 126),
      (this.name = 'InvalidSystemProgram'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Yh);
  }
}
N.InvalidSystemProgramError = Yh;
q.set(126, () => new Yh());
Y.set('InvalidSystemProgram', () => new Yh());
class Zh extends Error {
  constructor() {
    super('Must be a Non Fungible Token'),
      (this.code = 127),
      (this.name = 'MustBeNonFungible'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Zh);
  }
}
N.MustBeNonFungibleError = Zh;
q.set(127, () => new Zh());
Y.set('MustBeNonFungible', () => new Zh());
class Jh extends Error {
  constructor() {
    super('Insufficient tokens for transfer'),
      (this.code = 128),
      (this.name = 'InsufficientTokens'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Jh);
  }
}
N.InsufficientTokensError = Jh;
q.set(128, () => new Jh());
Y.set('InsufficientTokens', () => new Jh());
class Xh extends Error {
  constructor() {
    super('Borsh Serialization Error'),
      (this.code = 129),
      (this.name = 'BorshSerializationError'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Xh);
  }
}
N.BorshSerializationErrorError = Xh;
q.set(129, () => new Xh());
Y.set('BorshSerializationError', () => new Xh());
class Qh extends Error {
  constructor() {
    super('Cannot create NFT with no Freeze Authority.'),
      (this.code = 130),
      (this.name = 'NoFreezeAuthoritySet'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Qh);
  }
}
N.NoFreezeAuthoritySetError = Qh;
q.set(130, () => new Qh());
Y.set('NoFreezeAuthoritySet', () => new Qh());
class e0 extends Error {
  constructor() {
    super('Invalid collection size change'),
      (this.code = 131),
      (this.name = 'InvalidCollectionSizeChange'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, e0);
  }
}
N.InvalidCollectionSizeChangeError = e0;
q.set(131, () => new e0());
Y.set('InvalidCollectionSizeChange', () => new e0());
class t0 extends Error {
  constructor() {
    super('Invalid bubblegum signer'),
      (this.code = 132),
      (this.name = 'InvalidBubblegumSigner'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, t0);
  }
}
N.InvalidBubblegumSignerError = t0;
q.set(132, () => new t0());
Y.set('InvalidBubblegumSigner', () => new t0());
class n0 extends Error {
  constructor() {
    super('Escrow parent cannot have a delegate'),
      (this.code = 133),
      (this.name = 'EscrowParentHasDelegate'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, n0);
  }
}
N.EscrowParentHasDelegateError = n0;
q.set(133, () => new n0());
Y.set('EscrowParentHasDelegate', () => new n0());
class r0 extends Error {
  constructor() {
    super('Mint needs to be signer to initialize the account'),
      (this.code = 134),
      (this.name = 'MintIsNotSigner'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, r0);
  }
}
N.MintIsNotSignerError = r0;
q.set(134, () => new r0());
Y.set('MintIsNotSigner', () => new r0());
class i0 extends Error {
  constructor() {
    super('Invalid token standard'),
      (this.code = 135),
      (this.name = 'InvalidTokenStandard'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, i0);
  }
}
N.InvalidTokenStandardError = i0;
q.set(135, () => new i0());
Y.set('InvalidTokenStandard', () => new i0());
class s0 extends Error {
  constructor() {
    super('Invalid mint account for specified token standard'),
      (this.code = 136),
      (this.name = 'InvalidMintForTokenStandard'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, s0);
  }
}
N.InvalidMintForTokenStandardError = s0;
q.set(136, () => new s0());
Y.set('InvalidMintForTokenStandard', () => new s0());
class o0 extends Error {
  constructor() {
    super('Invalid authorization rules account'),
      (this.code = 137),
      (this.name = 'InvalidAuthorizationRules'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, o0);
  }
}
N.InvalidAuthorizationRulesError = o0;
q.set(137, () => new o0());
Y.set('InvalidAuthorizationRules', () => new o0());
class a0 extends Error {
  constructor() {
    super('Missing authorization rules account'),
      (this.code = 138),
      (this.name = 'MissingAuthorizationRules'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, a0);
  }
}
N.MissingAuthorizationRulesError = a0;
q.set(138, () => new a0());
Y.set('MissingAuthorizationRules', () => new a0());
class c0 extends Error {
  constructor() {
    super('Missing programmable configuration'),
      (this.code = 139),
      (this.name = 'MissingProgrammableConfig'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, c0);
  }
}
N.MissingProgrammableConfigError = c0;
q.set(139, () => new c0());
Y.set('MissingProgrammableConfig', () => new c0());
class u0 extends Error {
  constructor() {
    super('Invalid programmable configuration'),
      (this.code = 140),
      (this.name = 'InvalidProgrammableConfig'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, u0);
  }
}
N.InvalidProgrammableConfigError = u0;
q.set(140, () => new u0());
Y.set('InvalidProgrammableConfig', () => new u0());
class l0 extends Error {
  constructor() {
    super('Delegate already exists'),
      (this.code = 141),
      (this.name = 'DelegateAlreadyExists'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, l0);
  }
}
N.DelegateAlreadyExistsError = l0;
q.set(141, () => new l0());
Y.set('DelegateAlreadyExists', () => new l0());
class d0 extends Error {
  constructor() {
    super('Delegate not found'),
      (this.code = 142),
      (this.name = 'DelegateNotFound'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, d0);
  }
}
N.DelegateNotFoundError = d0;
q.set(142, () => new d0());
Y.set('DelegateNotFound', () => new d0());
class f0 extends Error {
  constructor() {
    super('Required account not set in instruction builder'),
      (this.code = 143),
      (this.name = 'MissingAccountInBuilder'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, f0);
  }
}
N.MissingAccountInBuilderError = f0;
q.set(143, () => new f0());
Y.set('MissingAccountInBuilder', () => new f0());
class h0 extends Error {
  constructor() {
    super('Required argument not set in instruction builder'),
      (this.code = 144),
      (this.name = 'MissingArgumentInBuilder'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, h0);
  }
}
N.MissingArgumentInBuilderError = h0;
q.set(144, () => new h0());
Y.set('MissingArgumentInBuilder', () => new h0());
class p0 extends Error {
  constructor() {
    super('Feature not supported currently'),
      (this.code = 145),
      (this.name = 'FeatureNotSupported'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, p0);
  }
}
N.FeatureNotSupportedError = p0;
q.set(145, () => new p0());
Y.set('FeatureNotSupported', () => new p0());
class g0 extends Error {
  constructor() {
    super('Invalid system wallet'),
      (this.code = 146),
      (this.name = 'InvalidSystemWallet'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, g0);
  }
}
N.InvalidSystemWalletError = g0;
q.set(146, () => new g0());
Y.set('InvalidSystemWallet', () => new g0());
class y0 extends Error {
  constructor() {
    super('Only the sale delegate can transfer while its set'),
      (this.code = 147),
      (this.name = 'OnlySaleDelegateCanTransfer'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, y0);
  }
}
N.OnlySaleDelegateCanTransferError = y0;
q.set(147, () => new y0());
Y.set('OnlySaleDelegateCanTransfer', () => new y0());
class b0 extends Error {
  constructor() {
    super('Missing token account'),
      (this.code = 148),
      (this.name = 'MissingTokenAccount'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, b0);
  }
}
N.MissingTokenAccountError = b0;
q.set(148, () => new b0());
Y.set('MissingTokenAccount', () => new b0());
class m0 extends Error {
  constructor() {
    super('Missing SPL token program'),
      (this.code = 149),
      (this.name = 'MissingSplTokenProgram'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, m0);
  }
}
N.MissingSplTokenProgramError = m0;
q.set(149, () => new m0());
Y.set('MissingSplTokenProgram', () => new m0());
class w0 extends Error {
  constructor() {
    super('Missing authorization rules program'),
      (this.code = 150),
      (this.name = 'MissingAuthorizationRulesProgram'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, w0);
  }
}
N.MissingAuthorizationRulesProgramError = w0;
q.set(150, () => new w0());
Y.set('MissingAuthorizationRulesProgram', () => new w0());
class v0 extends Error {
  constructor() {
    super('Invalid delegate role for transfer'),
      (this.code = 151),
      (this.name = 'InvalidDelegateRoleForTransfer'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, v0);
  }
}
N.InvalidDelegateRoleForTransferError = v0;
q.set(151, () => new v0());
Y.set('InvalidDelegateRoleForTransfer', () => new v0());
class _0 extends Error {
  constructor() {
    super('Invalid transfer authority'),
      (this.code = 152),
      (this.name = 'InvalidTransferAuthority'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, _0);
  }
}
N.InvalidTransferAuthorityError = _0;
q.set(152, () => new _0());
Y.set('InvalidTransferAuthority', () => new _0());
class S0 extends Error {
  constructor() {
    super('Instruction not supported for ProgrammableNonFungible assets'),
      (this.code = 153),
      (this.name = 'InstructionNotSupported'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, S0);
  }
}
N.InstructionNotSupportedError = S0;
q.set(153, () => new S0());
Y.set('InstructionNotSupported', () => new S0());
class E0 extends Error {
  constructor() {
    super('Public key does not match expected value'),
      (this.code = 154),
      (this.name = 'KeyMismatch'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, E0);
  }
}
N.KeyMismatchError = E0;
q.set(154, () => new E0());
Y.set('KeyMismatch', () => new E0());
class A0 extends Error {
  constructor() {
    super('Token is locked'),
      (this.code = 155),
      (this.name = 'LockedToken'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, A0);
  }
}
N.LockedTokenError = A0;
q.set(155, () => new A0());
Y.set('LockedToken', () => new A0());
class I0 extends Error {
  constructor() {
    super('Token is unlocked'),
      (this.code = 156),
      (this.name = 'UnlockedToken'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, I0);
  }
}
N.UnlockedTokenError = I0;
q.set(156, () => new I0());
Y.set('UnlockedToken', () => new I0());
class T0 extends Error {
  constructor() {
    super('Missing delegate role'),
      (this.code = 157),
      (this.name = 'MissingDelegateRole'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, T0);
  }
}
N.MissingDelegateRoleError = T0;
q.set(157, () => new T0());
Y.set('MissingDelegateRole', () => new T0());
class x0 extends Error {
  constructor() {
    super('Invalid authority type'),
      (this.code = 158),
      (this.name = 'InvalidAuthorityType'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, x0);
  }
}
N.InvalidAuthorityTypeError = x0;
q.set(158, () => new x0());
Y.set('InvalidAuthorityType', () => new x0());
class k0 extends Error {
  constructor() {
    super('Missing token record account'),
      (this.code = 159),
      (this.name = 'MissingTokenRecord'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, k0);
  }
}
N.MissingTokenRecordError = k0;
q.set(159, () => new k0());
Y.set('MissingTokenRecord', () => new k0());
class C0 extends Error {
  constructor() {
    super('Mint supply must be zero for programmable assets'),
      (this.code = 160),
      (this.name = 'MintSupplyMustBeZero'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, C0);
  }
}
N.MintSupplyMustBeZeroError = C0;
q.set(160, () => new C0());
Y.set('MintSupplyMustBeZero', () => new C0());
class P0 extends Error {
  constructor() {
    super('Data is empty or zeroed'),
      (this.code = 161),
      (this.name = 'DataIsEmptyOrZeroed'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, P0);
  }
}
N.DataIsEmptyOrZeroedError = P0;
q.set(161, () => new P0());
Y.set('DataIsEmptyOrZeroed', () => new P0());
class M0 extends Error {
  constructor() {
    super('Missing token owner'),
      (this.code = 162),
      (this.name = 'MissingTokenOwnerAccount'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, M0);
  }
}
N.MissingTokenOwnerAccountError = M0;
q.set(162, () => new M0());
Y.set('MissingTokenOwnerAccount', () => new M0());
class O0 extends Error {
  constructor() {
    super('Master edition account has an invalid length'),
      (this.code = 163),
      (this.name = 'InvalidMasterEditionAccountLength'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, O0);
  }
}
N.InvalidMasterEditionAccountLengthError = O0;
q.set(163, () => new O0());
Y.set('InvalidMasterEditionAccountLength', () => new O0());
class B0 extends Error {
  constructor() {
    super('Incorrect token state'),
      (this.code = 164),
      (this.name = 'IncorrectTokenState'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, B0);
  }
}
N.IncorrectTokenStateError = B0;
q.set(164, () => new B0());
Y.set('IncorrectTokenState', () => new B0());
class D0 extends Error {
  constructor() {
    super('Invalid delegate role'),
      (this.code = 165),
      (this.name = 'InvalidDelegateRole'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, D0);
  }
}
N.InvalidDelegateRoleError = D0;
q.set(165, () => new D0());
Y.set('InvalidDelegateRole', () => new D0());
class R0 extends Error {
  constructor() {
    super('Print supply is required for non-fungibles'),
      (this.code = 166),
      (this.name = 'MissingPrintSupply'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, R0);
  }
}
N.MissingPrintSupplyError = R0;
q.set(166, () => new R0());
Y.set('MissingPrintSupply', () => new R0());
class N0 extends Error {
  constructor() {
    super('Missing master edition account'),
      (this.code = 167),
      (this.name = 'MissingMasterEditionAccount'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, N0);
  }
}
N.MissingMasterEditionAccountError = N0;
q.set(167, () => new N0());
Y.set('MissingMasterEditionAccount', () => new N0());
class j0 extends Error {
  constructor() {
    super('Amount must be greater than zero'),
      (this.code = 168),
      (this.name = 'AmountMustBeGreaterThanZero'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, j0);
  }
}
N.AmountMustBeGreaterThanZeroError = j0;
q.set(168, () => new j0());
Y.set('AmountMustBeGreaterThanZero', () => new j0());
class L0 extends Error {
  constructor() {
    super('Invalid delegate args'),
      (this.code = 169),
      (this.name = 'InvalidDelegateArgs'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, L0);
  }
}
N.InvalidDelegateArgsError = L0;
q.set(169, () => new L0());
Y.set('InvalidDelegateArgs', () => new L0());
class U0 extends Error {
  constructor() {
    super('Missing address for locked transfer'),
      (this.code = 170),
      (this.name = 'MissingLockedTransferAddress'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, U0);
  }
}
N.MissingLockedTransferAddressError = U0;
q.set(170, () => new U0());
Y.set('MissingLockedTransferAddress', () => new U0());
class $0 extends Error {
  constructor() {
    super('Invalid destination address for locked transfer'),
      (this.code = 171),
      (this.name = 'InvalidLockedTransferAddress'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, $0);
  }
}
N.InvalidLockedTransferAddressError = $0;
q.set(171, () => new $0());
Y.set('InvalidLockedTransferAddress', () => new $0());
class F0 extends Error {
  constructor() {
    super('Exceeded account realloc increase limit'),
      (this.code = 172),
      (this.name = 'DataIncrementLimitExceeded'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, F0);
  }
}
N.DataIncrementLimitExceededError = F0;
q.set(172, () => new F0());
Y.set('DataIncrementLimitExceeded', () => new F0());
class z0 extends Error {
  constructor() {
    super('Cannot update the rule set of a programmable asset that has a delegate'),
      (this.code = 173),
      (this.name = 'CannotUpdateAssetWithDelegate'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, z0);
  }
}
N.CannotUpdateAssetWithDelegateError = z0;
q.set(173, () => new z0());
Y.set('CannotUpdateAssetWithDelegate', () => new z0());
class K0 extends Error {
  constructor() {
    super('Invalid token amount for this operation or token standard'),
      (this.code = 174),
      (this.name = 'InvalidAmount'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, K0);
  }
}
N.InvalidAmountError = K0;
q.set(174, () => new K0());
Y.set('InvalidAmount', () => new K0());
class V0 extends Error {
  constructor() {
    super('Missing master edition mint account'),
      (this.code = 175),
      (this.name = 'MissingMasterEditionMintAccount'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, V0);
  }
}
N.MissingMasterEditionMintAccountError = V0;
q.set(175, () => new V0());
Y.set('MissingMasterEditionMintAccount', () => new V0());
class W0 extends Error {
  constructor() {
    super('Missing master edition token account'),
      (this.code = 176),
      (this.name = 'MissingMasterEditionTokenAccount'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, W0);
  }
}
N.MissingMasterEditionTokenAccountError = W0;
q.set(176, () => new W0());
Y.set('MissingMasterEditionTokenAccount', () => new W0());
class H0 extends Error {
  constructor() {
    super('Missing edition marker account'),
      (this.code = 177),
      (this.name = 'MissingEditionMarkerAccount'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, H0);
  }
}
N.MissingEditionMarkerAccountError = H0;
q.set(177, () => new H0());
Y.set('MissingEditionMarkerAccount', () => new H0());
class G0 extends Error {
  constructor() {
    super('Cannot burn while persistent delegate is set'),
      (this.code = 178),
      (this.name = 'CannotBurnWithDelegate'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, G0);
  }
}
N.CannotBurnWithDelegateError = G0;
q.set(178, () => new G0());
Y.set('CannotBurnWithDelegate', () => new G0());
class q0 extends Error {
  constructor() {
    super('Missing edition account'),
      (this.code = 179),
      (this.name = 'MissingEdition'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, q0);
  }
}
N.MissingEditionError = q0;
q.set(179, () => new q0());
Y.set('MissingEdition', () => new q0());
class Y0 extends Error {
  constructor() {
    super('Invalid Associated Token Account Program'),
      (this.code = 180),
      (this.name = 'InvalidAssociatedTokenAccountProgram'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Y0);
  }
}
N.InvalidAssociatedTokenAccountProgramError = Y0;
q.set(180, () => new Y0());
Y.set('InvalidAssociatedTokenAccountProgram', () => new Y0());
class Z0 extends Error {
  constructor() {
    super('Invalid InstructionsSysvar'),
      (this.code = 181),
      (this.name = 'InvalidInstructionsSysvar'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Z0);
  }
}
N.InvalidInstructionsSysvarError = Z0;
q.set(181, () => new Z0());
Y.set('InvalidInstructionsSysvar', () => new Z0());
class J0 extends Error {
  constructor() {
    super('Invalid or Unneeded parent accounts'),
      (this.code = 182),
      (this.name = 'InvalidParentAccounts'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, J0);
  }
}
N.InvalidParentAccountsError = J0;
q.set(182, () => new J0());
Y.set('InvalidParentAccounts', () => new J0());
class X0 extends Error {
  constructor() {
    super('Authority cannot apply all update args'),
      (this.code = 183),
      (this.name = 'InvalidUpdateArgs'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, X0);
  }
}
N.InvalidUpdateArgsError = X0;
q.set(183, () => new X0());
Y.set('InvalidUpdateArgs', () => new X0());
class Q0 extends Error {
  constructor() {
    super('Token account does not have enough tokens'),
      (this.code = 184),
      (this.name = 'InsufficientTokenBalance'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Q0);
  }
}
N.InsufficientTokenBalanceError = Q0;
q.set(184, () => new Q0());
Y.set('InsufficientTokenBalance', () => new Q0());
class ep extends Error {
  constructor() {
    super('Missing collection account'),
      (this.code = 185),
      (this.name = 'MissingCollectionMint'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, ep);
  }
}
N.MissingCollectionMintError = ep;
q.set(185, () => new ep());
Y.set('MissingCollectionMint', () => new ep());
class tp extends Error {
  constructor() {
    super('Missing collection master edition account'),
      (this.code = 186),
      (this.name = 'MissingCollectionMasterEdition'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, tp);
  }
}
N.MissingCollectionMasterEditionError = tp;
q.set(186, () => new tp());
Y.set('MissingCollectionMasterEdition', () => new tp());
class np extends Error {
  constructor() {
    super('Invalid token record account'),
      (this.code = 187),
      (this.name = 'InvalidTokenRecord'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, np);
  }
}
N.InvalidTokenRecordError = np;
q.set(187, () => new np());
Y.set('InvalidTokenRecord', () => new np());
class rp extends Error {
  constructor() {
    super('The close authority needs to be revoked by the Utility Delegate'),
      (this.code = 188),
      (this.name = 'InvalidCloseAuthority'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, rp);
  }
}
N.InvalidCloseAuthorityError = rp;
q.set(188, () => new rp());
Y.set('InvalidCloseAuthority', () => new rp());
class ip extends Error {
  constructor() {
    super('Invalid or removed instruction'),
      (this.code = 189),
      (this.name = 'InvalidInstruction'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, ip);
  }
}
N.InvalidInstructionError = ip;
q.set(189, () => new ip());
Y.set('InvalidInstruction', () => new ip());
class sp extends Error {
  constructor() {
    super('Missing delegate record'),
      (this.code = 190),
      (this.name = 'MissingDelegateRecord'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, sp);
  }
}
N.MissingDelegateRecordError = sp;
q.set(190, () => new sp());
Y.set('MissingDelegateRecord', () => new sp());
class op extends Error {
  constructor() {
    super(''),
      (this.code = 191),
      (this.name = 'InvalidFeeAccount'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, op);
  }
}
N.InvalidFeeAccountError = op;
q.set(191, () => new op());
Y.set('InvalidFeeAccount', () => new op());
class ap extends Error {
  constructor() {
    super(''),
      (this.code = 192),
      (this.name = 'InvalidMetadataFlags'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, ap);
  }
}
N.InvalidMetadataFlagsError = ap;
q.set(192, () => new ap());
Y.set('InvalidMetadataFlags', () => new ap());
function Qne(e) {
  const t = q.get(e);
  return t != null ? t() : null;
}
N.errorFromCode = Qne;
function ere(e) {
  const t = Y.get(e);
  return t != null ? t() : null;
}
N.errorFromName = ere;
var CB = {},
  PB = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (a, c, u, l) {
            l === void 0 && (l = u);
            var d = Object.getOwnPropertyDescriptor(c, u);
            (!d || ('get' in d ? !c.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return c[u];
                },
              }),
              Object.defineProperty(a, l, d);
          }
        : function (a, c, u, l) {
            l === void 0 && (l = u), (a[l] = c[u]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (m && m.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var u in a)
            u !== 'default' && Object.prototype.hasOwnProperty.call(a, u) && t(c, a, u);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createApproveCollectionAuthorityInstruction =
      e.approveCollectionAuthorityInstructionDiscriminator =
      e.ApproveCollectionAuthorityStruct =
        void 0);
  const i = r(te),
    s = r(ne);
  (e.ApproveCollectionAuthorityStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'ApproveCollectionAuthorityInstructionArgs'
  )),
    (e.approveCollectionAuthorityInstructionDiscriminator = 23);
  function o(a, c = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var u;
    const [l] = e.ApproveCollectionAuthorityStruct.serialize({
        instructionDiscriminator: e.approveCollectionAuthorityInstructionDiscriminator,
      }),
      d = [
        { pubkey: a.collectionAuthorityRecord, isWritable: !0, isSigner: !1 },
        { pubkey: a.newCollectionAuthority, isWritable: !1, isSigner: !1 },
        { pubkey: a.updateAuthority, isWritable: !0, isSigner: !0 },
        { pubkey: a.payer, isWritable: !0, isSigner: !0 },
        { pubkey: a.metadata, isWritable: !1, isSigner: !1 },
        { pubkey: a.mint, isWritable: !1, isSigner: !1 },
        {
          pubkey: (u = a.systemProgram) !== null && u !== void 0 ? u : s.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return (
      a.rent != null && d.push({ pubkey: a.rent, isWritable: !1, isSigner: !1 }),
      new s.TransactionInstruction({ programId: c, keys: d, data: l })
    );
  }
  e.createApproveCollectionAuthorityInstruction = o;
})(PB);
var MB = {},
  _r = {},
  OB = {},
  dm = {},
  Ce = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.programSupportsExtensions =
      e.NATIVE_MINT_2022 =
      e.NATIVE_MINT =
      e.ASSOCIATED_TOKEN_PROGRAM_ID =
      e.TOKEN_2022_PROGRAM_ID =
      e.TOKEN_PROGRAM_ID =
        void 0);
  const t = ne;
  (e.TOKEN_PROGRAM_ID = new t.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA')),
    (e.TOKEN_2022_PROGRAM_ID = new t.PublicKey('TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb')),
    (e.ASSOCIATED_TOKEN_PROGRAM_ID = new t.PublicKey(
      'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'
    )),
    (e.NATIVE_MINT = new t.PublicKey('So11111111111111111111111111111111111111112')),
    (e.NATIVE_MINT_2022 = new t.PublicKey('9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP'));
  function n(r) {
    return r !== e.TOKEN_PROGRAM_ID;
  }
  e.programSupportsExtensions = n;
})(Ce);
var fm = {},
  Me = {};
Object.defineProperty(Me, '__esModule', { value: !0 });
Me.TokenUnsupportedInstructionError =
  Me.TokenInvalidInstructionTypeError =
  Me.TokenInvalidInstructionDataError =
  Me.TokenInvalidInstructionKeysError =
  Me.TokenInvalidInstructionProgramError =
  Me.TokenOwnerOffCurveError =
  Me.TokenInvalidOwnerError =
  Me.TokenInvalidMintError =
  Me.TokenInvalidAccountSizeError =
  Me.TokenInvalidAccountOwnerError =
  Me.TokenInvalidAccountError =
  Me.TokenAccountNotFoundError =
  Me.TokenError =
    void 0;
let Xr = class extends Error {
  constructor(t) {
    super(t);
  }
};
Me.TokenError = Xr;
class tre extends Xr {
  constructor() {
    super(...arguments), (this.name = 'TokenAccountNotFoundError');
  }
}
Me.TokenAccountNotFoundError = tre;
class nre extends Xr {
  constructor() {
    super(...arguments), (this.name = 'TokenInvalidAccountError');
  }
}
Me.TokenInvalidAccountError = nre;
class rre extends Xr {
  constructor() {
    super(...arguments), (this.name = 'TokenInvalidAccountOwnerError');
  }
}
Me.TokenInvalidAccountOwnerError = rre;
class ire extends Xr {
  constructor() {
    super(...arguments), (this.name = 'TokenInvalidAccountSizeError');
  }
}
Me.TokenInvalidAccountSizeError = ire;
class sre extends Xr {
  constructor() {
    super(...arguments), (this.name = 'TokenInvalidMintError');
  }
}
Me.TokenInvalidMintError = sre;
class ore extends Xr {
  constructor() {
    super(...arguments), (this.name = 'TokenInvalidOwnerError');
  }
}
Me.TokenInvalidOwnerError = ore;
class are extends Xr {
  constructor() {
    super(...arguments), (this.name = 'TokenOwnerOffCurveError');
  }
}
Me.TokenOwnerOffCurveError = are;
class cre extends Xr {
  constructor() {
    super(...arguments), (this.name = 'TokenInvalidInstructionProgramError');
  }
}
Me.TokenInvalidInstructionProgramError = cre;
class ure extends Xr {
  constructor() {
    super(...arguments), (this.name = 'TokenInvalidInstructionKeysError');
  }
}
Me.TokenInvalidInstructionKeysError = ure;
class lre extends Xr {
  constructor() {
    super(...arguments), (this.name = 'TokenInvalidInstructionDataError');
  }
}
Me.TokenInvalidInstructionDataError = lre;
class dre extends Xr {
  constructor() {
    super(...arguments), (this.name = 'TokenInvalidInstructionTypeError');
  }
}
Me.TokenInvalidInstructionTypeError = dre;
class fre extends Xr {
  constructor() {
    super(...arguments), (this.name = 'TokenUnsupportedInstructionError');
  }
}
Me.TokenUnsupportedInstructionError = fre;
var ft = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.TokenInstruction = void 0),
    (function (t) {
      (t[(t.InitializeMint = 0)] = 'InitializeMint'),
        (t[(t.InitializeAccount = 1)] = 'InitializeAccount'),
        (t[(t.InitializeMultisig = 2)] = 'InitializeMultisig'),
        (t[(t.Transfer = 3)] = 'Transfer'),
        (t[(t.Approve = 4)] = 'Approve'),
        (t[(t.Revoke = 5)] = 'Revoke'),
        (t[(t.SetAuthority = 6)] = 'SetAuthority'),
        (t[(t.MintTo = 7)] = 'MintTo'),
        (t[(t.Burn = 8)] = 'Burn'),
        (t[(t.CloseAccount = 9)] = 'CloseAccount'),
        (t[(t.FreezeAccount = 10)] = 'FreezeAccount'),
        (t[(t.ThawAccount = 11)] = 'ThawAccount'),
        (t[(t.TransferChecked = 12)] = 'TransferChecked'),
        (t[(t.ApproveChecked = 13)] = 'ApproveChecked'),
        (t[(t.MintToChecked = 14)] = 'MintToChecked'),
        (t[(t.BurnChecked = 15)] = 'BurnChecked'),
        (t[(t.InitializeAccount2 = 16)] = 'InitializeAccount2'),
        (t[(t.SyncNative = 17)] = 'SyncNative'),
        (t[(t.InitializeAccount3 = 18)] = 'InitializeAccount3'),
        (t[(t.InitializeMultisig2 = 19)] = 'InitializeMultisig2'),
        (t[(t.InitializeMint2 = 20)] = 'InitializeMint2'),
        (t[(t.GetAccountDataSize = 21)] = 'GetAccountDataSize'),
        (t[(t.InitializeImmutableOwner = 22)] = 'InitializeImmutableOwner'),
        (t[(t.AmountToUiAmount = 23)] = 'AmountToUiAmount'),
        (t[(t.UiAmountToAmount = 24)] = 'UiAmountToAmount'),
        (t[(t.InitializeMintCloseAuthority = 25)] = 'InitializeMintCloseAuthority'),
        (t[(t.TransferFeeExtension = 26)] = 'TransferFeeExtension'),
        (t[(t.ConfidentialTransferExtension = 27)] = 'ConfidentialTransferExtension'),
        (t[(t.DefaultAccountStateExtension = 28)] = 'DefaultAccountStateExtension'),
        (t[(t.Reallocate = 29)] = 'Reallocate'),
        (t[(t.MemoTransferExtension = 30)] = 'MemoTransferExtension'),
        (t[(t.CreateNativeMint = 31)] = 'CreateNativeMint'),
        (t[(t.InitializeNonTransferableMint = 32)] = 'InitializeNonTransferableMint'),
        (t[(t.InterestBearingMintExtension = 33)] = 'InterestBearingMintExtension'),
        (t[(t.CpiGuardExtension = 34)] = 'CpiGuardExtension'),
        (t[(t.InitializePermanentDelegate = 35)] = 'InitializePermanentDelegate');
    })(e.TokenInstruction || (e.TokenInstruction = {}));
})(ft);
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeAmountToUiAmountInstructionUnchecked =
      e.decodeAmountToUiAmountInstruction =
      e.createAmountToUiAmountInstruction =
      e.amountToUiAmountInstructionData =
        void 0);
  const t = Ze,
    n = Rt,
    r = ne,
    i = Ce,
    s = Me,
    o = ft;
  e.amountToUiAmountInstructionData = (0, t.struct)([
    (0, t.u8)('instruction'),
    (0, n.u64)('amount'),
  ]);
  function a(l, d, f = i.TOKEN_PROGRAM_ID) {
    const h = [{ pubkey: l, isSigner: !1, isWritable: !1 }],
      p = z.alloc(e.amountToUiAmountInstructionData.span);
    return (
      e.amountToUiAmountInstructionData.encode(
        { instruction: o.TokenInstruction.AmountToUiAmount, amount: BigInt(d) },
        p
      ),
      new r.TransactionInstruction({ keys: h, programId: f, data: p })
    );
  }
  e.createAmountToUiAmountInstruction = a;
  function c(l, d = i.TOKEN_PROGRAM_ID) {
    if (!l.programId.equals(d)) throw new s.TokenInvalidInstructionProgramError();
    if (l.data.length !== e.amountToUiAmountInstructionData.span)
      throw new s.TokenInvalidInstructionDataError();
    const {
      keys: { mint: f },
      data: h,
    } = u(l);
    if (h.instruction !== o.TokenInstruction.AmountToUiAmount)
      throw new s.TokenInvalidInstructionTypeError();
    if (!f) throw new s.TokenInvalidInstructionKeysError();
    return { programId: d, keys: { mint: f }, data: h };
  }
  e.decodeAmountToUiAmountInstruction = c;
  function u({ programId: l, keys: [d], data: f }) {
    return { programId: l, keys: { mint: d }, data: e.amountToUiAmountInstructionData.decode(f) };
  }
  e.decodeAmountToUiAmountInstructionUnchecked = u;
})(fm);
var hre =
  (m && m.__awaiter) ||
  function (e, t, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(l) {
        try {
          u(r.next(l));
        } catch (d) {
          o(d);
        }
      }
      function c(l) {
        try {
          u(r.throw(l));
        } catch (d) {
          o(d);
        }
      }
      function u(l) {
        l.done ? s(l.value) : i(l.value).then(a, c);
      }
      u((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(dm, '__esModule', { value: !0 });
dm.amountToUiAmount = void 0;
const pre = ne,
  gre = Ce,
  yre = fm;
function bre(e, t, n, r, i = gre.TOKEN_PROGRAM_ID) {
  return hre(this, void 0, void 0, function* () {
    const s = new pre.Transaction().add((0, yre.createAmountToUiAmountInstruction)(n, r, i)),
      { returnData: o, err: a } = (yield e.simulateTransaction(s, [t], !1)).value;
    return o != null && o.data ? z.from(o.data[0], o.data[1]).toString('utf-8') : a;
  });
}
dm.amountToUiAmount = bre;
var hm = {},
  pm = {},
  cn = {};
Object.defineProperty(cn, '__esModule', { value: !0 });
cn.addSigners = void 0;
const mre = ne;
function wre(e, t, n) {
  if (n.length) {
    e.push({ pubkey: t, isSigner: !1, isWritable: !1 });
    for (const r of n)
      e.push({
        pubkey: r instanceof mre.PublicKey ? r : r.publicKey,
        isSigner: !0,
        isWritable: !1,
      });
  } else e.push({ pubkey: t, isSigner: !0, isWritable: !1 });
  return e;
}
cn.addSigners = wre;
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeApproveInstructionUnchecked =
      e.decodeApproveInstruction =
      e.createApproveInstruction =
      e.approveInstructionData =
        void 0);
  const t = Ze,
    n = Rt,
    r = ne,
    i = Ce,
    s = Me,
    o = cn,
    a = ft;
  e.approveInstructionData = (0, t.struct)([(0, t.u8)('instruction'), (0, n.u64)('amount')]);
  function c(d, f, h, p, b = [], w = i.TOKEN_PROGRAM_ID) {
    const A = (0, o.addSigners)(
        [
          { pubkey: d, isSigner: !1, isWritable: !0 },
          { pubkey: f, isSigner: !1, isWritable: !1 },
        ],
        h,
        b
      ),
      _ = z.alloc(e.approveInstructionData.span);
    return (
      e.approveInstructionData.encode(
        { instruction: a.TokenInstruction.Approve, amount: BigInt(p) },
        _
      ),
      new r.TransactionInstruction({ keys: A, programId: w, data: _ })
    );
  }
  e.createApproveInstruction = c;
  function u(d, f = i.TOKEN_PROGRAM_ID) {
    if (!d.programId.equals(f)) throw new s.TokenInvalidInstructionProgramError();
    if (d.data.length !== e.approveInstructionData.span)
      throw new s.TokenInvalidInstructionDataError();
    const {
      keys: { account: h, delegate: p, owner: b, multiSigners: w },
      data: A,
    } = l(d);
    if (A.instruction !== a.TokenInstruction.Approve)
      throw new s.TokenInvalidInstructionTypeError();
    if (!h || !p || !b) throw new s.TokenInvalidInstructionKeysError();
    return { programId: f, keys: { account: h, delegate: p, owner: b, multiSigners: w }, data: A };
  }
  e.decodeApproveInstruction = u;
  function l({ programId: d, keys: [f, h, p, ...b], data: w }) {
    return {
      programId: d,
      keys: { account: f, delegate: h, owner: p, multiSigners: b },
      data: e.approveInstructionData.decode(w),
    };
  }
  e.decodeApproveInstructionUnchecked = l;
})(pm);
var ln = {};
Object.defineProperty(ln, '__esModule', { value: !0 });
ln.getSigners = void 0;
const vre = ne;
function _re(e, t) {
  return e instanceof vre.PublicKey ? [e, t] : [e.publicKey, [e]];
}
ln.getSigners = _re;
var Sre =
  (m && m.__awaiter) ||
  function (e, t, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(l) {
        try {
          u(r.next(l));
        } catch (d) {
          o(d);
        }
      }
      function c(l) {
        try {
          u(r.throw(l));
        } catch (d) {
          o(d);
        }
      }
      function u(l) {
        l.done ? s(l.value) : i(l.value).then(a, c);
      }
      u((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(hm, '__esModule', { value: !0 });
hm.approve = void 0;
const s2 = ne,
  Ere = Ce,
  Are = pm,
  Ire = ln;
function Tre(e, t, n, r, i, s, o = [], a, c = Ere.TOKEN_PROGRAM_ID) {
  return Sre(this, void 0, void 0, function* () {
    const [u, l] = (0, Ire.getSigners)(i, o),
      d = new s2.Transaction().add((0, Are.createApproveInstruction)(n, r, u, s, o, c));
    return yield (0, s2.sendAndConfirmTransaction)(e, d, [t, ...l], a);
  });
}
hm.approve = Tre;
var gm = {},
  ym = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeApproveCheckedInstructionUnchecked =
      e.decodeApproveCheckedInstruction =
      e.createApproveCheckedInstruction =
      e.approveCheckedInstructionData =
        void 0);
  const t = Ze,
    n = Rt,
    r = ne,
    i = Ce,
    s = Me,
    o = cn,
    a = ft;
  e.approveCheckedInstructionData = (0, t.struct)([
    (0, t.u8)('instruction'),
    (0, n.u64)('amount'),
    (0, t.u8)('decimals'),
  ]);
  function c(d, f, h, p, b, w, A = [], _ = i.TOKEN_PROGRAM_ID) {
    const x = (0, o.addSigners)(
        [
          { pubkey: d, isSigner: !1, isWritable: !0 },
          { pubkey: f, isSigner: !1, isWritable: !1 },
          { pubkey: h, isSigner: !1, isWritable: !1 },
        ],
        p,
        A
      ),
      k = z.alloc(e.approveCheckedInstructionData.span);
    return (
      e.approveCheckedInstructionData.encode(
        { instruction: a.TokenInstruction.ApproveChecked, amount: BigInt(b), decimals: w },
        k
      ),
      new r.TransactionInstruction({ keys: x, programId: _, data: k })
    );
  }
  e.createApproveCheckedInstruction = c;
  function u(d, f = i.TOKEN_PROGRAM_ID) {
    if (!d.programId.equals(f)) throw new s.TokenInvalidInstructionProgramError();
    if (d.data.length !== e.approveCheckedInstructionData.span)
      throw new s.TokenInvalidInstructionDataError();
    const {
      keys: { account: h, mint: p, delegate: b, owner: w, multiSigners: A },
      data: _,
    } = l(d);
    if (_.instruction !== a.TokenInstruction.ApproveChecked)
      throw new s.TokenInvalidInstructionTypeError();
    if (!h || !p || !b || !w) throw new s.TokenInvalidInstructionKeysError();
    return {
      programId: f,
      keys: { account: h, mint: p, delegate: b, owner: w, multiSigners: A },
      data: _,
    };
  }
  e.decodeApproveCheckedInstruction = u;
  function l({ programId: d, keys: [f, h, p, b, ...w], data: A }) {
    return {
      programId: d,
      keys: { account: f, mint: h, delegate: p, owner: b, multiSigners: w },
      data: e.approveCheckedInstructionData.decode(A),
    };
  }
  e.decodeApproveCheckedInstructionUnchecked = l;
})(ym);
var xre =
  (m && m.__awaiter) ||
  function (e, t, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(l) {
        try {
          u(r.next(l));
        } catch (d) {
          o(d);
        }
      }
      function c(l) {
        try {
          u(r.throw(l));
        } catch (d) {
          o(d);
        }
      }
      function u(l) {
        l.done ? s(l.value) : i(l.value).then(a, c);
      }
      u((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(gm, '__esModule', { value: !0 });
gm.approveChecked = void 0;
const o2 = ne,
  kre = Ce,
  Cre = ym,
  Pre = ln;
function Mre(e, t, n, r, i, s, o, a, c = [], u, l = kre.TOKEN_PROGRAM_ID) {
  return xre(this, void 0, void 0, function* () {
    const [d, f] = (0, Pre.getSigners)(s, c),
      h = new o2.Transaction().add(
        (0, Cre.createApproveCheckedInstruction)(r, n, i, d, o, a, c, l)
      );
    return yield (0, o2.sendAndConfirmTransaction)(e, h, [t, ...f], u);
  });
}
gm.approveChecked = Mre;
var bm = {},
  mm = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeBurnInstructionUnchecked =
      e.decodeBurnInstruction =
      e.createBurnInstruction =
      e.burnInstructionData =
        void 0);
  const t = Ze,
    n = Rt,
    r = ne,
    i = Ce,
    s = Me,
    o = cn,
    a = ft;
  e.burnInstructionData = (0, t.struct)([(0, t.u8)('instruction'), (0, n.u64)('amount')]);
  function c(d, f, h, p, b = [], w = i.TOKEN_PROGRAM_ID) {
    const A = (0, o.addSigners)(
        [
          { pubkey: d, isSigner: !1, isWritable: !0 },
          { pubkey: f, isSigner: !1, isWritable: !0 },
        ],
        h,
        b
      ),
      _ = z.alloc(e.burnInstructionData.span);
    return (
      e.burnInstructionData.encode({ instruction: a.TokenInstruction.Burn, amount: BigInt(p) }, _),
      new r.TransactionInstruction({ keys: A, programId: w, data: _ })
    );
  }
  e.createBurnInstruction = c;
  function u(d, f = i.TOKEN_PROGRAM_ID) {
    if (!d.programId.equals(f)) throw new s.TokenInvalidInstructionProgramError();
    if (d.data.length !== e.burnInstructionData.span)
      throw new s.TokenInvalidInstructionDataError();
    const {
      keys: { account: h, mint: p, owner: b, multiSigners: w },
      data: A,
    } = l(d);
    if (A.instruction !== a.TokenInstruction.Burn) throw new s.TokenInvalidInstructionTypeError();
    if (!h || !p || !b) throw new s.TokenInvalidInstructionKeysError();
    return { programId: f, keys: { account: h, mint: p, owner: b, multiSigners: w }, data: A };
  }
  e.decodeBurnInstruction = u;
  function l({ programId: d, keys: [f, h, p, ...b], data: w }) {
    return {
      programId: d,
      keys: { account: f, mint: h, owner: p, multiSigners: b },
      data: e.burnInstructionData.decode(w),
    };
  }
  e.decodeBurnInstructionUnchecked = l;
})(mm);
var Ore =
  (m && m.__awaiter) ||
  function (e, t, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(l) {
        try {
          u(r.next(l));
        } catch (d) {
          o(d);
        }
      }
      function c(l) {
        try {
          u(r.throw(l));
        } catch (d) {
          o(d);
        }
      }
      function u(l) {
        l.done ? s(l.value) : i(l.value).then(a, c);
      }
      u((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(bm, '__esModule', { value: !0 });
bm.burn = void 0;
const a2 = ne,
  Bre = Ce,
  Dre = mm,
  Rre = ln;
function Nre(e, t, n, r, i, s, o = [], a, c = Bre.TOKEN_PROGRAM_ID) {
  return Ore(this, void 0, void 0, function* () {
    const [u, l] = (0, Rre.getSigners)(i, o),
      d = new a2.Transaction().add((0, Dre.createBurnInstruction)(n, r, u, s, o, c));
    return yield (0, a2.sendAndConfirmTransaction)(e, d, [t, ...l], a);
  });
}
bm.burn = Nre;
var wm = {},
  vm = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeBurnCheckedInstructionUnchecked =
      e.decodeBurnCheckedInstruction =
      e.createBurnCheckedInstruction =
      e.burnCheckedInstructionData =
        void 0);
  const t = Ze,
    n = Rt,
    r = ne,
    i = Ce,
    s = Me,
    o = cn,
    a = ft;
  e.burnCheckedInstructionData = (0, t.struct)([
    (0, t.u8)('instruction'),
    (0, n.u64)('amount'),
    (0, t.u8)('decimals'),
  ]);
  function c(d, f, h, p, b, w = [], A = i.TOKEN_PROGRAM_ID) {
    const _ = (0, o.addSigners)(
        [
          { pubkey: d, isSigner: !1, isWritable: !0 },
          { pubkey: f, isSigner: !1, isWritable: !0 },
        ],
        h,
        w
      ),
      x = z.alloc(e.burnCheckedInstructionData.span);
    return (
      e.burnCheckedInstructionData.encode(
        { instruction: a.TokenInstruction.BurnChecked, amount: BigInt(p), decimals: b },
        x
      ),
      new r.TransactionInstruction({ keys: _, programId: A, data: x })
    );
  }
  e.createBurnCheckedInstruction = c;
  function u(d, f = i.TOKEN_PROGRAM_ID) {
    if (!d.programId.equals(f)) throw new s.TokenInvalidInstructionProgramError();
    if (d.data.length !== e.burnCheckedInstructionData.span)
      throw new s.TokenInvalidInstructionDataError();
    const {
      keys: { account: h, mint: p, owner: b, multiSigners: w },
      data: A,
    } = l(d);
    if (A.instruction !== a.TokenInstruction.BurnChecked)
      throw new s.TokenInvalidInstructionTypeError();
    if (!h || !p || !b) throw new s.TokenInvalidInstructionKeysError();
    return { programId: f, keys: { account: h, mint: p, owner: b, multiSigners: w }, data: A };
  }
  e.decodeBurnCheckedInstruction = u;
  function l({ programId: d, keys: [f, h, p, ...b], data: w }) {
    return {
      programId: d,
      keys: { account: f, mint: h, owner: p, multiSigners: b },
      data: e.burnCheckedInstructionData.decode(w),
    };
  }
  e.decodeBurnCheckedInstructionUnchecked = l;
})(vm);
var jre =
  (m && m.__awaiter) ||
  function (e, t, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(l) {
        try {
          u(r.next(l));
        } catch (d) {
          o(d);
        }
      }
      function c(l) {
        try {
          u(r.throw(l));
        } catch (d) {
          o(d);
        }
      }
      function u(l) {
        l.done ? s(l.value) : i(l.value).then(a, c);
      }
      u((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(wm, '__esModule', { value: !0 });
wm.burnChecked = void 0;
const c2 = ne,
  Lre = Ce,
  Ure = vm,
  $re = ln;
function Fre(e, t, n, r, i, s, o, a = [], c, u = Lre.TOKEN_PROGRAM_ID) {
  return jre(this, void 0, void 0, function* () {
    const [l, d] = (0, $re.getSigners)(i, a),
      f = new c2.Transaction().add((0, Ure.createBurnCheckedInstruction)(n, r, l, s, o, a, u));
    return yield (0, c2.sendAndConfirmTransaction)(e, f, [t, ...d], c);
  });
}
wm.burnChecked = Fre;
var _m = {},
  Sm = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeCloseAccountInstructionUnchecked =
      e.decodeCloseAccountInstruction =
      e.createCloseAccountInstruction =
      e.closeAccountInstructionData =
        void 0);
  const t = Ze,
    n = ne,
    r = Ce,
    i = Me,
    s = cn,
    o = ft;
  e.closeAccountInstructionData = (0, t.struct)([(0, t.u8)('instruction')]);
  function a(l, d, f, h = [], p = r.TOKEN_PROGRAM_ID) {
    const b = (0, s.addSigners)(
        [
          { pubkey: l, isSigner: !1, isWritable: !0 },
          { pubkey: d, isSigner: !1, isWritable: !0 },
        ],
        f,
        h
      ),
      w = z.alloc(e.closeAccountInstructionData.span);
    return (
      e.closeAccountInstructionData.encode({ instruction: o.TokenInstruction.CloseAccount }, w),
      new n.TransactionInstruction({ keys: b, programId: p, data: w })
    );
  }
  e.createCloseAccountInstruction = a;
  function c(l, d = r.TOKEN_PROGRAM_ID) {
    if (!l.programId.equals(d)) throw new i.TokenInvalidInstructionProgramError();
    if (l.data.length !== e.closeAccountInstructionData.span)
      throw new i.TokenInvalidInstructionDataError();
    const {
      keys: { account: f, destination: h, authority: p, multiSigners: b },
      data: w,
    } = u(l);
    if (w.instruction !== o.TokenInstruction.CloseAccount)
      throw new i.TokenInvalidInstructionTypeError();
    if (!f || !h || !p) throw new i.TokenInvalidInstructionKeysError();
    return {
      programId: d,
      keys: { account: f, destination: h, authority: p, multiSigners: b },
      data: w,
    };
  }
  e.decodeCloseAccountInstruction = c;
  function u({ programId: l, keys: [d, f, h, ...p], data: b }) {
    return {
      programId: l,
      keys: { account: d, destination: f, authority: h, multiSigners: p },
      data: e.closeAccountInstructionData.decode(b),
    };
  }
  e.decodeCloseAccountInstructionUnchecked = u;
})(Sm);
var zre =
  (m && m.__awaiter) ||
  function (e, t, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(l) {
        try {
          u(r.next(l));
        } catch (d) {
          o(d);
        }
      }
      function c(l) {
        try {
          u(r.throw(l));
        } catch (d) {
          o(d);
        }
      }
      function u(l) {
        l.done ? s(l.value) : i(l.value).then(a, c);
      }
      u((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(_m, '__esModule', { value: !0 });
_m.closeAccount = void 0;
const u2 = ne,
  Kre = Ce,
  Vre = Sm,
  Wre = ln;
function Hre(e, t, n, r, i, s = [], o, a = Kre.TOKEN_PROGRAM_ID) {
  return zre(this, void 0, void 0, function* () {
    const [c, u] = (0, Wre.getSigners)(i, s),
      l = new u2.Transaction().add((0, Vre.createCloseAccountInstruction)(n, r, c, s, a));
    return yield (0, u2.sendAndConfirmTransaction)(e, l, [t, ...u], o);
  });
}
_m.closeAccount = Hre;
var cp = {},
  vv = {},
  _v = {},
  up = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.ACCOUNT_TYPE_SIZE = e.AccountType = void 0),
    (function (t) {
      (t[(t.Uninitialized = 0)] = 'Uninitialized'),
        (t[(t.Mint = 1)] = 'Mint'),
        (t[(t.Account = 2)] = 'Account');
    })(e.AccountType || (e.AccountType = {})),
    (e.ACCOUNT_TYPE_SIZE = 1);
})(up);
var Xu = {};
(function (e) {
  var t =
    (m && m.__awaiter) ||
    function (u, l, d, f) {
      function h(p) {
        return p instanceof d
          ? p
          : new d(function (b) {
              b(p);
            });
      }
      return new (d || (d = Promise))(function (p, b) {
        function w(x) {
          try {
            _(f.next(x));
          } catch (k) {
            b(k);
          }
        }
        function A(x) {
          try {
            _(f.throw(x));
          } catch (k) {
            b(k);
          }
        }
        function _(x) {
          x.done ? p(x.value) : h(x.value).then(w, A);
        }
        _((f = f.apply(u, l || [])).next());
      });
    };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.getMinimumBalanceForRentExemptMultisig =
      e.unpackMultisig =
      e.getMultisig =
      e.MULTISIG_SIZE =
      e.MultisigLayout =
        void 0);
  const n = Ze,
    r = Rt,
    i = Ce,
    s = Me;
  (e.MultisigLayout = (0, n.struct)([
    (0, n.u8)('m'),
    (0, n.u8)('n'),
    (0, r.bool)('isInitialized'),
    (0, r.publicKey)('signer1'),
    (0, r.publicKey)('signer2'),
    (0, r.publicKey)('signer3'),
    (0, r.publicKey)('signer4'),
    (0, r.publicKey)('signer5'),
    (0, r.publicKey)('signer6'),
    (0, r.publicKey)('signer7'),
    (0, r.publicKey)('signer8'),
    (0, r.publicKey)('signer9'),
    (0, r.publicKey)('signer10'),
    (0, r.publicKey)('signer11'),
  ])),
    (e.MULTISIG_SIZE = e.MultisigLayout.span);
  function o(u, l, d, f = i.TOKEN_PROGRAM_ID) {
    return t(this, void 0, void 0, function* () {
      const h = yield u.getAccountInfo(l, d);
      return a(l, h, f);
    });
  }
  e.getMultisig = o;
  function a(u, l, d = i.TOKEN_PROGRAM_ID) {
    if (!l) throw new s.TokenAccountNotFoundError();
    if (!l.owner.equals(d)) throw new s.TokenInvalidAccountOwnerError();
    if (l.data.length != e.MULTISIG_SIZE) throw new s.TokenInvalidAccountSizeError();
    const f = e.MultisigLayout.decode(l.data);
    return Object.assign({ address: u }, f);
  }
  e.unpackMultisig = a;
  function c(u, l) {
    return t(this, void 0, void 0, function* () {
      return yield u.getMinimumBalanceForRentExemption(e.MULTISIG_SIZE, l);
    });
  }
  e.getMinimumBalanceForRentExemptMultisig = c;
})(Xu);
var l2;
function lp() {
  return (
    l2 ||
      ((l2 = 1),
      (function (e) {
        var t =
          (m && m.__awaiter) ||
          function (b, w, A, _) {
            function x(k) {
              return k instanceof A
                ? k
                : new A(function (j) {
                    j(k);
                  });
            }
            return new (A || (A = Promise))(function (k, j) {
              function F(C) {
                try {
                  D(_.next(C));
                } catch (B) {
                  j(B);
                }
              }
              function K(C) {
                try {
                  D(_.throw(C));
                } catch (B) {
                  j(B);
                }
              }
              function D(C) {
                C.done ? k(C.value) : x(C.value).then(F, K);
              }
              D((_ = _.apply(b, w || [])).next());
            });
          };
        Object.defineProperty(e, '__esModule', { value: !0 }),
          (e.unpackAccount =
            e.getMinimumBalanceForRentExemptAccountWithExtensions =
            e.getMinimumBalanceForRentExemptAccount =
            e.getMultipleAccounts =
            e.getAccount =
            e.ACCOUNT_SIZE =
            e.AccountLayout =
            e.AccountState =
              void 0);
        const n = Ze,
          r = Rt,
          i = Ce,
          s = Me,
          o = up,
          a = Br(),
          c = Xu;
        var u;
        (function (b) {
          (b[(b.Uninitialized = 0)] = 'Uninitialized'),
            (b[(b.Initialized = 1)] = 'Initialized'),
            (b[(b.Frozen = 2)] = 'Frozen');
        })((u = e.AccountState || (e.AccountState = {}))),
          (e.AccountLayout = (0, n.struct)([
            (0, r.publicKey)('mint'),
            (0, r.publicKey)('owner'),
            (0, r.u64)('amount'),
            (0, n.u32)('delegateOption'),
            (0, r.publicKey)('delegate'),
            (0, n.u8)('state'),
            (0, n.u32)('isNativeOption'),
            (0, r.u64)('isNative'),
            (0, r.u64)('delegatedAmount'),
            (0, n.u32)('closeAuthorityOption'),
            (0, r.publicKey)('closeAuthority'),
          ])),
          (e.ACCOUNT_SIZE = e.AccountLayout.span);
        function l(b, w, A, _ = i.TOKEN_PROGRAM_ID) {
          return t(this, void 0, void 0, function* () {
            const x = yield b.getAccountInfo(w, A);
            return p(w, x, _);
          });
        }
        e.getAccount = l;
        function d(b, w, A, _ = i.TOKEN_PROGRAM_ID) {
          return t(this, void 0, void 0, function* () {
            const x = yield b.getMultipleAccountsInfo(w, A);
            return w.map((k, j) => p(k, x[j], _));
          });
        }
        e.getMultipleAccounts = d;
        function f(b, w) {
          return t(this, void 0, void 0, function* () {
            return yield h(b, [], w);
          });
        }
        e.getMinimumBalanceForRentExemptAccount = f;
        function h(b, w, A) {
          return t(this, void 0, void 0, function* () {
            const _ = (0, a.getAccountLen)(w);
            return yield b.getMinimumBalanceForRentExemption(_, A);
          });
        }
        e.getMinimumBalanceForRentExemptAccountWithExtensions = h;
        function p(b, w, A = i.TOKEN_PROGRAM_ID) {
          if (!w) throw new s.TokenAccountNotFoundError();
          if (!w.owner.equals(A)) throw new s.TokenInvalidAccountOwnerError();
          if (w.data.length < e.ACCOUNT_SIZE) throw new s.TokenInvalidAccountSizeError();
          const _ = e.AccountLayout.decode(w.data.slice(0, e.ACCOUNT_SIZE));
          let x = z.alloc(0);
          if (w.data.length > e.ACCOUNT_SIZE) {
            if (w.data.length === c.MULTISIG_SIZE) throw new s.TokenInvalidAccountSizeError();
            if (w.data[e.ACCOUNT_SIZE] != o.AccountType.Account)
              throw new s.TokenInvalidAccountError();
            x = w.data.slice(e.ACCOUNT_SIZE + o.ACCOUNT_TYPE_SIZE);
          }
          return {
            address: b,
            mint: _.mint,
            owner: _.owner,
            amount: _.amount,
            delegate: _.delegateOption ? _.delegate : null,
            delegatedAmount: _.delegatedAmount,
            isInitialized: _.state !== u.Uninitialized,
            isFrozen: _.state === u.Frozen,
            isNative: !!_.isNativeOption,
            rentExemptReserve: _.isNativeOption ? _.isNative : null,
            closeAuthority: _.closeAuthorityOption ? _.closeAuthority : null,
            tlvData: x,
          };
        }
        e.unpackAccount = p;
      })(_v)),
    _v
  );
}
var Sv = {},
  d2;
function Sa() {
  return (
    d2 ||
      ((d2 = 1),
      (function (e) {
        var t =
          (m && m.__awaiter) ||
          function (A, _, x, k) {
            function j(F) {
              return F instanceof x
                ? F
                : new x(function (K) {
                    K(F);
                  });
            }
            return new (x || (x = Promise))(function (F, K) {
              function D(E) {
                try {
                  B(k.next(E));
                } catch (y) {
                  K(y);
                }
              }
              function C(E) {
                try {
                  B(k.throw(E));
                } catch (y) {
                  K(y);
                }
              }
              function B(E) {
                E.done ? F(E.value) : j(E.value).then(D, C);
              }
              B((k = k.apply(A, _ || [])).next());
            });
          };
        Object.defineProperty(e, '__esModule', { value: !0 }),
          (e.getAssociatedTokenAddressSync =
            e.getAssociatedTokenAddress =
            e.getMinimumBalanceForRentExemptMintWithExtensions =
            e.getMinimumBalanceForRentExemptMint =
            e.unpackMint =
            e.getMint =
            e.MINT_SIZE =
            e.MintLayout =
              void 0);
        const n = Ze,
          r = Rt,
          i = ne,
          s = Ce,
          o = Me,
          a = up,
          c = Br(),
          u = lp(),
          l = Xu;
        (e.MintLayout = (0, n.struct)([
          (0, n.u32)('mintAuthorityOption'),
          (0, r.publicKey)('mintAuthority'),
          (0, r.u64)('supply'),
          (0, n.u8)('decimals'),
          (0, r.bool)('isInitialized'),
          (0, n.u32)('freezeAuthorityOption'),
          (0, r.publicKey)('freezeAuthority'),
        ])),
          (e.MINT_SIZE = e.MintLayout.span);
        function d(A, _, x, k = s.TOKEN_PROGRAM_ID) {
          return t(this, void 0, void 0, function* () {
            const j = yield A.getAccountInfo(_, x);
            return f(_, j, k);
          });
        }
        e.getMint = d;
        function f(A, _, x = s.TOKEN_PROGRAM_ID) {
          if (!_) throw new o.TokenAccountNotFoundError();
          if (!_.owner.equals(x)) throw new o.TokenInvalidAccountOwnerError();
          if (_.data.length < e.MINT_SIZE) throw new o.TokenInvalidAccountSizeError();
          const k = e.MintLayout.decode(_.data.slice(0, e.MINT_SIZE));
          let j = z.alloc(0);
          if (_.data.length > e.MINT_SIZE) {
            if (_.data.length <= u.ACCOUNT_SIZE) throw new o.TokenInvalidAccountSizeError();
            if (_.data.length === l.MULTISIG_SIZE) throw new o.TokenInvalidAccountSizeError();
            if (_.data[u.ACCOUNT_SIZE] != a.AccountType.Mint) throw new o.TokenInvalidMintError();
            j = _.data.slice(u.ACCOUNT_SIZE + a.ACCOUNT_TYPE_SIZE);
          }
          return {
            address: A,
            mintAuthority: k.mintAuthorityOption ? k.mintAuthority : null,
            supply: k.supply,
            decimals: k.decimals,
            isInitialized: k.isInitialized,
            freezeAuthority: k.freezeAuthorityOption ? k.freezeAuthority : null,
            tlvData: j,
          };
        }
        e.unpackMint = f;
        function h(A, _) {
          return t(this, void 0, void 0, function* () {
            return yield p(A, [], _);
          });
        }
        e.getMinimumBalanceForRentExemptMint = h;
        function p(A, _, x) {
          return t(this, void 0, void 0, function* () {
            const k = (0, c.getMintLen)(_);
            return yield A.getMinimumBalanceForRentExemption(k, x);
          });
        }
        e.getMinimumBalanceForRentExemptMintWithExtensions = p;
        function b(A, _, x = !1, k = s.TOKEN_PROGRAM_ID, j = s.ASSOCIATED_TOKEN_PROGRAM_ID) {
          return t(this, void 0, void 0, function* () {
            if (!x && !i.PublicKey.isOnCurve(_.toBuffer())) throw new o.TokenOwnerOffCurveError();
            const [F] = yield i.PublicKey.findProgramAddress(
              [_.toBuffer(), k.toBuffer(), A.toBuffer()],
              j
            );
            return F;
          });
        }
        e.getAssociatedTokenAddress = b;
        function w(A, _, x = !1, k = s.TOKEN_PROGRAM_ID, j = s.ASSOCIATED_TOKEN_PROGRAM_ID) {
          if (!x && !i.PublicKey.isOnCurve(_.toBuffer())) throw new o.TokenOwnerOffCurveError();
          const [F] = i.PublicKey.findProgramAddressSync(
            [_.toBuffer(), k.toBuffer(), A.toBuffer()],
            j
          );
          return F;
        }
        e.getAssociatedTokenAddressSync = w;
      })(Sv)),
    Sv
  );
}
var Ev = {},
  Tu = {},
  CI = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createDisableCpiGuardInstruction =
      e.createEnableCpiGuardInstruction =
      e.cpiGuardInstructionData =
      e.CpiGuardInstruction =
        void 0);
  const t = Ze,
    n = ne,
    r = Ce,
    i = Me,
    s = cn,
    o = ft;
  var a;
  (function (d) {
    (d[(d.Enable = 0)] = 'Enable'), (d[(d.Disable = 1)] = 'Disable');
  })((a = e.CpiGuardInstruction || (e.CpiGuardInstruction = {}))),
    (e.cpiGuardInstructionData = (0, t.struct)([
      (0, t.u8)('instruction'),
      (0, t.u8)('cpiGuardInstruction'),
    ]));
  function c(d, f, h = [], p = r.TOKEN_2022_PROGRAM_ID) {
    return l(a.Enable, d, f, h, p);
  }
  e.createEnableCpiGuardInstruction = c;
  function u(d, f, h = [], p = r.TOKEN_2022_PROGRAM_ID) {
    return l(a.Disable, d, f, h, p);
  }
  e.createDisableCpiGuardInstruction = u;
  function l(d, f, h, p, b) {
    if (!(0, r.programSupportsExtensions)(b)) throw new i.TokenUnsupportedInstructionError();
    const w = (0, s.addSigners)([{ pubkey: f, isSigner: !1, isWritable: !0 }], h, p),
      A = z.alloc(e.cpiGuardInstructionData.span);
    return (
      e.cpiGuardInstructionData.encode(
        { instruction: o.TokenInstruction.CpiGuardExtension, cpiGuardInstruction: d },
        A
      ),
      new n.TransactionInstruction({ keys: w, programId: b, data: A })
    );
  }
})(CI);
var BB =
  (m && m.__awaiter) ||
  function (e, t, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(l) {
        try {
          u(r.next(l));
        } catch (d) {
          o(d);
        }
      }
      function c(l) {
        try {
          u(r.throw(l));
        } catch (d) {
          o(d);
        }
      }
      function u(l) {
        l.done ? s(l.value) : i(l.value).then(a, c);
      }
      u((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(Tu, '__esModule', { value: !0 });
Tu.disableCpiGuard = Tu.enableCpiGuard = void 0;
const Ky = ne,
  DB = ln,
  RB = Ce,
  NB = CI;
function Gre(e, t, n, r, i = [], s, o = RB.TOKEN_2022_PROGRAM_ID) {
  return BB(this, void 0, void 0, function* () {
    const [a, c] = (0, DB.getSigners)(r, i),
      u = new Ky.Transaction().add((0, NB.createEnableCpiGuardInstruction)(n, a, c, o));
    return yield (0, Ky.sendAndConfirmTransaction)(e, u, [t, ...c], s);
  });
}
Tu.enableCpiGuard = Gre;
function qre(e, t, n, r, i = [], s, o = RB.TOKEN_2022_PROGRAM_ID) {
  return BB(this, void 0, void 0, function* () {
    const [a, c] = (0, DB.getSigners)(r, i),
      u = new Ky.Transaction().add((0, NB.createDisableCpiGuardInstruction)(n, a, c, o));
    return yield (0, Ky.sendAndConfirmTransaction)(e, u, [t, ...c], s);
  });
}
Tu.disableCpiGuard = qre;
var Av = {},
  f2;
function Yre() {
  return (
    f2 ||
      ((f2 = 1),
      (function (e) {
        Object.defineProperty(e, '__esModule', { value: !0 }),
          (e.getCpiGuard = e.CPI_GUARD_SIZE = e.CpiGuardLayout = void 0);
        const t = Ze,
          n = Rt,
          r = Br();
        (e.CpiGuardLayout = (0, t.struct)([(0, n.bool)('lockCpi')])),
          (e.CPI_GUARD_SIZE = e.CpiGuardLayout.span);
        function i(s) {
          const o = (0, r.getExtensionData)(r.ExtensionType.CpiGuard, s.tlvData);
          return o !== null ? e.CpiGuardLayout.decode(o) : null;
        }
        e.getCpiGuard = i;
      })(Av)),
    Av
  );
}
var h2;
function jB() {
  return (
    h2 ||
      ((h2 = 1),
      (function (e) {
        var t =
            (m && m.__createBinding) ||
            (Object.create
              ? function (r, i, s, o) {
                  o === void 0 && (o = s);
                  var a = Object.getOwnPropertyDescriptor(i, s);
                  (!a || ('get' in a ? !i.__esModule : a.writable || a.configurable)) &&
                    (a = {
                      enumerable: !0,
                      get: function () {
                        return i[s];
                      },
                    }),
                    Object.defineProperty(r, o, a);
                }
              : function (r, i, s, o) {
                  o === void 0 && (o = s), (r[o] = i[s]);
                }),
          n =
            (m && m.__exportStar) ||
            function (r, i) {
              for (var s in r)
                s !== 'default' && !Object.prototype.hasOwnProperty.call(i, s) && t(i, r, s);
            };
        Object.defineProperty(e, '__esModule', { value: !0 }), n(Tu, e), n(CI, e), n(Yre(), e);
      })(Ev)),
    Ev
  );
}
var Iv = {},
  xu = {},
  PI = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createUpdateDefaultAccountStateInstruction =
      e.createInitializeDefaultAccountStateInstruction =
      e.defaultAccountStateInstructionData =
      e.DefaultAccountStateInstruction =
        void 0);
  const t = Ze,
    n = ne,
    r = Ce,
    i = Me,
    s = cn,
    o = ft;
  var a;
  (function (l) {
    (l[(l.Initialize = 0)] = 'Initialize'), (l[(l.Update = 1)] = 'Update');
  })((a = e.DefaultAccountStateInstruction || (e.DefaultAccountStateInstruction = {}))),
    (e.defaultAccountStateInstructionData = (0, t.struct)([
      (0, t.u8)('instruction'),
      (0, t.u8)('defaultAccountStateInstruction'),
      (0, t.u8)('accountState'),
    ]));
  function c(l, d, f = r.TOKEN_2022_PROGRAM_ID) {
    if (!(0, r.programSupportsExtensions)(f)) throw new i.TokenUnsupportedInstructionError();
    const h = [{ pubkey: l, isSigner: !1, isWritable: !0 }],
      p = z.alloc(e.defaultAccountStateInstructionData.span);
    return (
      e.defaultAccountStateInstructionData.encode(
        {
          instruction: o.TokenInstruction.DefaultAccountStateExtension,
          defaultAccountStateInstruction: a.Initialize,
          accountState: d,
        },
        p
      ),
      new n.TransactionInstruction({ keys: h, programId: f, data: p })
    );
  }
  e.createInitializeDefaultAccountStateInstruction = c;
  function u(l, d, f, h = [], p = r.TOKEN_2022_PROGRAM_ID) {
    if (!(0, r.programSupportsExtensions)(p)) throw new i.TokenUnsupportedInstructionError();
    const b = (0, s.addSigners)([{ pubkey: l, isSigner: !1, isWritable: !0 }], f, h),
      w = z.alloc(e.defaultAccountStateInstructionData.span);
    return (
      e.defaultAccountStateInstructionData.encode(
        {
          instruction: o.TokenInstruction.DefaultAccountStateExtension,
          defaultAccountStateInstruction: a.Update,
          accountState: d,
        },
        w
      ),
      new n.TransactionInstruction({ keys: b, programId: p, data: w })
    );
  }
  e.createUpdateDefaultAccountStateInstruction = u;
})(PI);
var LB =
  (m && m.__awaiter) ||
  function (e, t, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(l) {
        try {
          u(r.next(l));
        } catch (d) {
          o(d);
        }
      }
      function c(l) {
        try {
          u(r.throw(l));
        } catch (d) {
          o(d);
        }
      }
      function u(l) {
        l.done ? s(l.value) : i(l.value).then(a, c);
      }
      u((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(xu, '__esModule', { value: !0 });
xu.updateDefaultAccountState = xu.initializeDefaultAccountState = void 0;
const Vy = ne,
  Zre = ln,
  UB = Ce,
  $B = PI;
function Jre(e, t, n, r, i, s = UB.TOKEN_2022_PROGRAM_ID) {
  return LB(this, void 0, void 0, function* () {
    const o = new Vy.Transaction().add(
      (0, $B.createInitializeDefaultAccountStateInstruction)(n, r, s)
    );
    return yield (0, Vy.sendAndConfirmTransaction)(e, o, [t], i);
  });
}
xu.initializeDefaultAccountState = Jre;
function Xre(e, t, n, r, i, s = [], o, a = UB.TOKEN_2022_PROGRAM_ID) {
  return LB(this, void 0, void 0, function* () {
    const [c, u] = (0, Zre.getSigners)(i, s),
      l = new Vy.Transaction().add(
        (0, $B.createUpdateDefaultAccountStateInstruction)(n, r, c, u, a)
      );
    return yield (0, Vy.sendAndConfirmTransaction)(e, l, [t, ...u], o);
  });
}
xu.updateDefaultAccountState = Xre;
var Tv = {},
  p2;
function Qre() {
  return (
    p2 ||
      ((p2 = 1),
      (function (e) {
        Object.defineProperty(e, '__esModule', { value: !0 }),
          (e.getDefaultAccountState =
            e.DEFAULT_ACCOUNT_STATE_SIZE =
            e.DefaultAccountStateLayout =
              void 0);
        const t = Ze,
          n = Br();
        (e.DefaultAccountStateLayout = (0, t.struct)([(0, t.u8)('state')])),
          (e.DEFAULT_ACCOUNT_STATE_SIZE = e.DefaultAccountStateLayout.span);
        function r(i) {
          const s = (0, n.getExtensionData)(n.ExtensionType.DefaultAccountState, i.tlvData);
          return s !== null ? e.DefaultAccountStateLayout.decode(s) : null;
        }
        e.getDefaultAccountState = r;
      })(Tv)),
    Tv
  );
}
var g2;
function FB() {
  return (
    g2 ||
      ((g2 = 1),
      (function (e) {
        var t =
            (m && m.__createBinding) ||
            (Object.create
              ? function (r, i, s, o) {
                  o === void 0 && (o = s);
                  var a = Object.getOwnPropertyDescriptor(i, s);
                  (!a || ('get' in a ? !i.__esModule : a.writable || a.configurable)) &&
                    (a = {
                      enumerable: !0,
                      get: function () {
                        return i[s];
                      },
                    }),
                    Object.defineProperty(r, o, a);
                }
              : function (r, i, s, o) {
                  o === void 0 && (o = s), (r[o] = i[s]);
                }),
          n =
            (m && m.__exportStar) ||
            function (r, i) {
              for (var s in r)
                s !== 'default' && !Object.prototype.hasOwnProperty.call(i, s) && t(i, r, s);
            };
        Object.defineProperty(e, '__esModule', { value: !0 }), n(xu, e), n(PI, e), n(Qre(), e);
      })(Iv)),
    Iv
  );
}
var xv = {},
  y2;
function zB() {
  return (
    y2 ||
      ((y2 = 1),
      (function (e) {
        Object.defineProperty(e, '__esModule', { value: !0 }),
          (e.getImmutableOwner = e.IMMUTABLE_OWNER_SIZE = e.ImmutableOwnerLayout = void 0);
        const t = Ze,
          n = Br();
        (e.ImmutableOwnerLayout = (0, t.struct)([])),
          (e.IMMUTABLE_OWNER_SIZE = e.ImmutableOwnerLayout.span);
        function r(i) {
          const s = (0, n.getExtensionData)(n.ExtensionType.ImmutableOwner, i.tlvData);
          return s !== null ? e.ImmutableOwnerLayout.decode(s) : null;
        }
        e.getImmutableOwner = r;
      })(xv)),
    xv
  );
}
var kv = {},
  b2;
function KB() {
  return (
    b2 ||
      ((b2 = 1),
      (function (e) {
        Object.defineProperty(e, '__esModule', { value: !0 }),
          (e.getInterestBearingMintConfigState =
            e.INTEREST_BEARING_MINT_CONFIG_STATE_SIZE =
            e.InterestBearingMintConfigStateLayout =
              void 0);
        const t = Ze,
          n = Rt,
          r = Br();
        (e.InterestBearingMintConfigStateLayout = (0, t.struct)([
          (0, n.publicKey)('rateAuthority'),
          (0, t.ns64)('initializationTimestamp'),
          (0, t.s16)('preUpdateAverageRate'),
          (0, t.ns64)('lastUpdateTimestamp'),
          (0, t.s16)('currentRate'),
        ])),
          (e.INTEREST_BEARING_MINT_CONFIG_STATE_SIZE = e.InterestBearingMintConfigStateLayout.span);
        function i(s) {
          const o = (0, r.getExtensionData)(r.ExtensionType.InterestBearingConfig, s.tlvData);
          return o !== null ? e.InterestBearingMintConfigStateLayout.decode(o) : null;
        }
        e.getInterestBearingMintConfigState = i;
      })(kv)),
    kv
  );
}
var Cv = {},
  ku = {},
  MI = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createDisableRequiredMemoTransfersInstruction =
      e.createEnableRequiredMemoTransfersInstruction =
      e.memoTransferInstructionData =
      e.MemoTransferInstruction =
        void 0);
  const t = Ze,
    n = ne,
    r = Ce,
    i = Me,
    s = cn,
    o = ft;
  var a;
  (function (d) {
    (d[(d.Enable = 0)] = 'Enable'), (d[(d.Disable = 1)] = 'Disable');
  })((a = e.MemoTransferInstruction || (e.MemoTransferInstruction = {}))),
    (e.memoTransferInstructionData = (0, t.struct)([
      (0, t.u8)('instruction'),
      (0, t.u8)('memoTransferInstruction'),
    ]));
  function c(d, f, h = [], p = r.TOKEN_2022_PROGRAM_ID) {
    return l(a.Enable, d, f, h, p);
  }
  e.createEnableRequiredMemoTransfersInstruction = c;
  function u(d, f, h = [], p = r.TOKEN_2022_PROGRAM_ID) {
    return l(a.Disable, d, f, h, p);
  }
  e.createDisableRequiredMemoTransfersInstruction = u;
  function l(d, f, h, p, b) {
    if (!(0, r.programSupportsExtensions)(b)) throw new i.TokenUnsupportedInstructionError();
    const w = (0, s.addSigners)([{ pubkey: f, isSigner: !1, isWritable: !0 }], h, p),
      A = z.alloc(e.memoTransferInstructionData.span);
    return (
      e.memoTransferInstructionData.encode(
        { instruction: o.TokenInstruction.MemoTransferExtension, memoTransferInstruction: d },
        A
      ),
      new n.TransactionInstruction({ keys: w, programId: b, data: A })
    );
  }
})(MI);
var VB =
  (m && m.__awaiter) ||
  function (e, t, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(l) {
        try {
          u(r.next(l));
        } catch (d) {
          o(d);
        }
      }
      function c(l) {
        try {
          u(r.throw(l));
        } catch (d) {
          o(d);
        }
      }
      function u(l) {
        l.done ? s(l.value) : i(l.value).then(a, c);
      }
      u((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(ku, '__esModule', { value: !0 });
ku.disableRequiredMemoTransfers = ku.enableRequiredMemoTransfers = void 0;
const Wy = ne,
  WB = ln,
  HB = Ce,
  GB = MI;
function eie(e, t, n, r, i = [], s, o = HB.TOKEN_2022_PROGRAM_ID) {
  return VB(this, void 0, void 0, function* () {
    const [a, c] = (0, WB.getSigners)(r, i),
      u = new Wy.Transaction().add(
        (0, GB.createEnableRequiredMemoTransfersInstruction)(n, a, c, o)
      );
    return yield (0, Wy.sendAndConfirmTransaction)(e, u, [t, ...c], s);
  });
}
ku.enableRequiredMemoTransfers = eie;
function tie(e, t, n, r, i = [], s, o = HB.TOKEN_2022_PROGRAM_ID) {
  return VB(this, void 0, void 0, function* () {
    const [a, c] = (0, WB.getSigners)(r, i),
      u = new Wy.Transaction().add(
        (0, GB.createDisableRequiredMemoTransfersInstruction)(n, a, c, o)
      );
    return yield (0, Wy.sendAndConfirmTransaction)(e, u, [t, ...c], s);
  });
}
ku.disableRequiredMemoTransfers = tie;
var Pv = {},
  m2;
function nie() {
  return (
    m2 ||
      ((m2 = 1),
      (function (e) {
        Object.defineProperty(e, '__esModule', { value: !0 }),
          (e.getMemoTransfer = e.MEMO_TRANSFER_SIZE = e.MemoTransferLayout = void 0);
        const t = Ze,
          n = Rt,
          r = Br();
        (e.MemoTransferLayout = (0, t.struct)([(0, n.bool)('requireIncomingTransferMemos')])),
          (e.MEMO_TRANSFER_SIZE = e.MemoTransferLayout.span);
        function i(s) {
          const o = (0, r.getExtensionData)(r.ExtensionType.MemoTransfer, s.tlvData);
          return o !== null ? e.MemoTransferLayout.decode(o) : null;
        }
        e.getMemoTransfer = i;
      })(Pv)),
    Pv
  );
}
var w2;
function qB() {
  return (
    w2 ||
      ((w2 = 1),
      (function (e) {
        var t =
            (m && m.__createBinding) ||
            (Object.create
              ? function (r, i, s, o) {
                  o === void 0 && (o = s);
                  var a = Object.getOwnPropertyDescriptor(i, s);
                  (!a || ('get' in a ? !i.__esModule : a.writable || a.configurable)) &&
                    (a = {
                      enumerable: !0,
                      get: function () {
                        return i[s];
                      },
                    }),
                    Object.defineProperty(r, o, a);
                }
              : function (r, i, s, o) {
                  o === void 0 && (o = s), (r[o] = i[s]);
                }),
          n =
            (m && m.__exportStar) ||
            function (r, i) {
              for (var s in r)
                s !== 'default' && !Object.prototype.hasOwnProperty.call(i, s) && t(i, r, s);
            };
        Object.defineProperty(e, '__esModule', { value: !0 }), n(ku, e), n(MI, e), n(nie(), e);
      })(Cv)),
    Cv
  );
}
var Mv = {},
  v2;
function YB() {
  return (
    v2 ||
      ((v2 = 1),
      (function (e) {
        Object.defineProperty(e, '__esModule', { value: !0 }),
          (e.getMintCloseAuthority =
            e.MINT_CLOSE_AUTHORITY_SIZE =
            e.MintCloseAuthorityLayout =
              void 0);
        const t = Ze,
          n = Rt,
          r = Br();
        (e.MintCloseAuthorityLayout = (0, t.struct)([(0, n.publicKey)('closeAuthority')])),
          (e.MINT_CLOSE_AUTHORITY_SIZE = e.MintCloseAuthorityLayout.span);
        function i(s) {
          const o = (0, r.getExtensionData)(r.ExtensionType.MintCloseAuthority, s.tlvData);
          return o !== null ? e.MintCloseAuthorityLayout.decode(o) : null;
        }
        e.getMintCloseAuthority = i;
      })(Mv)),
    Mv
  );
}
var Ov = {},
  _2;
function ZB() {
  return (
    _2 ||
      ((_2 = 1),
      (function (e) {
        Object.defineProperty(e, '__esModule', { value: !0 }),
          (e.getNonTransferable = e.NON_TRANSFERABLE_SIZE = e.NonTransferableLayout = void 0);
        const t = Ze,
          n = Br();
        (e.NonTransferableLayout = (0, t.struct)([])),
          (e.NON_TRANSFERABLE_SIZE = e.NonTransferableLayout.span);
        function r(i) {
          const s = (0, n.getExtensionData)(n.ExtensionType.NonTransferable, i.tlvData);
          return s !== null ? e.NonTransferableLayout.decode(s) : null;
        }
        e.getNonTransferable = r;
      })(Ov)),
    Ov
  );
}
var Bv = {},
  S2;
function JB() {
  return (
    S2 ||
      ((S2 = 1),
      (function (e) {
        Object.defineProperty(e, '__esModule', { value: !0 }),
          (e.getPermanentDelegate = e.PERMANENT_DELEGATE_SIZE = e.PermanentDelegateLayout = void 0);
        const t = Ze,
          n = Rt,
          r = Br();
        (e.PermanentDelegateLayout = (0, t.struct)([(0, n.publicKey)('delegate')])),
          (e.PERMANENT_DELEGATE_SIZE = e.PermanentDelegateLayout.span);
        function i(s) {
          const o = (0, r.getExtensionData)(r.ExtensionType.PermanentDelegate, s.tlvData);
          return o !== null ? e.PermanentDelegateLayout.decode(o) : null;
        }
        e.getPermanentDelegate = i;
      })(Bv)),
    Bv
  );
}
var Dv = {},
  hs = {},
  OI = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeHarvestWithheldTokensToMintInstructionUnchecked =
      e.decodeHarvestWithheldTokensToMintInstruction =
      e.createHarvestWithheldTokensToMintInstruction =
      e.harvestWithheldTokensToMintInstructionData =
      e.decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked =
      e.decodeWithdrawWithheldTokensFromAccountsInstruction =
      e.createWithdrawWithheldTokensFromAccountsInstruction =
      e.withdrawWithheldTokensFromAccountsInstructionData =
      e.decodeWithdrawWithheldTokensFromMintInstructionUnchecked =
      e.decodeWithdrawWithheldTokensFromMintInstruction =
      e.createWithdrawWithheldTokensFromMintInstruction =
      e.withdrawWithheldTokensFromMintInstructionData =
      e.decodeTransferCheckedWithFeeInstructionUnchecked =
      e.decodeTransferCheckedWithFeeInstruction =
      e.createTransferCheckedWithFeeInstruction =
      e.transferCheckedWithFeeInstructionData =
      e.decodeInitializeTransferFeeConfigInstructionUnchecked =
      e.decodeInitializeTransferFeeConfigInstruction =
      e.createInitializeTransferFeeConfigInstruction =
      e.initializeTransferFeeConfigInstructionData =
      e.TransferFeeInstruction =
        void 0);
  const t = Ze,
    n = Rt,
    r = ne,
    i = Ce,
    s = Me,
    o = cn,
    a = ft;
  var c;
  (function (D) {
    (D[(D.InitializeTransferFeeConfig = 0)] = 'InitializeTransferFeeConfig'),
      (D[(D.TransferCheckedWithFee = 1)] = 'TransferCheckedWithFee'),
      (D[(D.WithdrawWithheldTokensFromMint = 2)] = 'WithdrawWithheldTokensFromMint'),
      (D[(D.WithdrawWithheldTokensFromAccounts = 3)] = 'WithdrawWithheldTokensFromAccounts'),
      (D[(D.HarvestWithheldTokensToMint = 4)] = 'HarvestWithheldTokensToMint'),
      (D[(D.SetTransferFee = 5)] = 'SetTransferFee');
  })((c = e.TransferFeeInstruction || (e.TransferFeeInstruction = {}))),
    (e.initializeTransferFeeConfigInstructionData = (0, t.struct)([
      (0, t.u8)('instruction'),
      (0, t.u8)('transferFeeInstruction'),
      (0, t.u8)('transferFeeConfigAuthorityOption'),
      (0, n.publicKey)('transferFeeConfigAuthority'),
      (0, t.u8)('withdrawWithheldAuthorityOption'),
      (0, n.publicKey)('withdrawWithheldAuthority'),
      (0, t.u16)('transferFeeBasisPoints'),
      (0, n.u64)('maximumFee'),
    ]));
  function u(D, C, B, E, y, v = i.TOKEN_2022_PROGRAM_ID) {
    if (!(0, i.programSupportsExtensions)(v)) throw new s.TokenUnsupportedInstructionError();
    const S = [{ pubkey: D, isSigner: !1, isWritable: !0 }],
      T = z.alloc(e.initializeTransferFeeConfigInstructionData.span);
    return (
      e.initializeTransferFeeConfigInstructionData.encode(
        {
          instruction: a.TokenInstruction.TransferFeeExtension,
          transferFeeInstruction: c.InitializeTransferFeeConfig,
          transferFeeConfigAuthorityOption: C ? 1 : 0,
          transferFeeConfigAuthority: C || new r.PublicKey(0),
          withdrawWithheldAuthorityOption: B ? 1 : 0,
          withdrawWithheldAuthority: B || new r.PublicKey(0),
          transferFeeBasisPoints: E,
          maximumFee: y,
        },
        T
      ),
      new r.TransactionInstruction({ keys: S, programId: v, data: T })
    );
  }
  e.createInitializeTransferFeeConfigInstruction = u;
  function l(D, C) {
    if (!D.programId.equals(C)) throw new s.TokenInvalidInstructionProgramError();
    if (D.data.length !== e.initializeTransferFeeConfigInstructionData.span)
      throw new s.TokenInvalidInstructionDataError();
    const {
      keys: { mint: B },
      data: E,
    } = d(D);
    if (
      E.instruction !== a.TokenInstruction.TransferFeeExtension ||
      E.transferFeeInstruction !== c.InitializeTransferFeeConfig
    )
      throw new s.TokenInvalidInstructionTypeError();
    if (!B) throw new s.TokenInvalidInstructionKeysError();
    return { programId: C, keys: { mint: B }, data: E };
  }
  e.decodeInitializeTransferFeeConfigInstruction = l;
  function d({ programId: D, keys: [C], data: B }) {
    const {
      instruction: E,
      transferFeeInstruction: y,
      transferFeeConfigAuthorityOption: v,
      transferFeeConfigAuthority: S,
      withdrawWithheldAuthorityOption: T,
      withdrawWithheldAuthority: M,
      transferFeeBasisPoints: R,
      maximumFee: L,
    } = e.initializeTransferFeeConfigInstructionData.decode(B);
    return {
      programId: D,
      keys: { mint: C },
      data: {
        instruction: E,
        transferFeeInstruction: y,
        transferFeeConfigAuthority: v ? S : null,
        withdrawWithheldAuthority: T ? M : null,
        transferFeeBasisPoints: R,
        maximumFee: L,
      },
    };
  }
  (e.decodeInitializeTransferFeeConfigInstructionUnchecked = d),
    (e.transferCheckedWithFeeInstructionData = (0, t.struct)([
      (0, t.u8)('instruction'),
      (0, t.u8)('transferFeeInstruction'),
      (0, n.u64)('amount'),
      (0, t.u8)('decimals'),
      (0, n.u64)('fee'),
    ]));
  function f(D, C, B, E, y, v, S, T = [], M = i.TOKEN_2022_PROGRAM_ID) {
    if (!(0, i.programSupportsExtensions)(M)) throw new s.TokenUnsupportedInstructionError();
    const R = z.alloc(e.transferCheckedWithFeeInstructionData.span);
    e.transferCheckedWithFeeInstructionData.encode(
      {
        instruction: a.TokenInstruction.TransferFeeExtension,
        transferFeeInstruction: c.TransferCheckedWithFee,
        amount: y,
        decimals: v,
        fee: S,
      },
      R
    );
    const L = (0, o.addSigners)(
      [
        { pubkey: D, isSigner: !1, isWritable: !0 },
        { pubkey: C, isSigner: !1, isWritable: !1 },
        { pubkey: B, isSigner: !1, isWritable: !0 },
      ],
      E,
      T
    );
    return new r.TransactionInstruction({ keys: L, programId: M, data: R });
  }
  e.createTransferCheckedWithFeeInstruction = f;
  function h(D, C) {
    if (!D.programId.equals(C)) throw new s.TokenInvalidInstructionProgramError();
    if (D.data.length !== e.transferCheckedWithFeeInstructionData.span)
      throw new s.TokenInvalidInstructionDataError();
    const {
      keys: { source: B, mint: E, destination: y, authority: v, signers: S },
      data: T,
    } = p(D);
    if (
      T.instruction !== a.TokenInstruction.TransferFeeExtension ||
      T.transferFeeInstruction !== c.TransferCheckedWithFee
    )
      throw new s.TokenInvalidInstructionTypeError();
    if (!E) throw new s.TokenInvalidInstructionKeysError();
    return {
      programId: C,
      keys: { source: B, mint: E, destination: y, authority: v, signers: S || null },
      data: T,
    };
  }
  e.decodeTransferCheckedWithFeeInstruction = h;
  function p({ programId: D, keys: [C, B, E, y, ...v], data: S }) {
    const {
      instruction: T,
      transferFeeInstruction: M,
      amount: R,
      decimals: L,
      fee: O,
    } = e.transferCheckedWithFeeInstructionData.decode(S);
    return {
      programId: D,
      keys: { source: C, mint: B, destination: E, authority: y, signers: v },
      data: { instruction: T, transferFeeInstruction: M, amount: R, decimals: L, fee: O },
    };
  }
  (e.decodeTransferCheckedWithFeeInstructionUnchecked = p),
    (e.withdrawWithheldTokensFromMintInstructionData = (0, t.struct)([
      (0, t.u8)('instruction'),
      (0, t.u8)('transferFeeInstruction'),
    ]));
  function b(D, C, B, E = [], y = i.TOKEN_2022_PROGRAM_ID) {
    if (!(0, i.programSupportsExtensions)(y)) throw new s.TokenUnsupportedInstructionError();
    const v = z.alloc(e.withdrawWithheldTokensFromMintInstructionData.span);
    e.withdrawWithheldTokensFromMintInstructionData.encode(
      {
        instruction: a.TokenInstruction.TransferFeeExtension,
        transferFeeInstruction: c.WithdrawWithheldTokensFromMint,
      },
      v
    );
    const S = (0, o.addSigners)(
      [
        { pubkey: D, isSigner: !1, isWritable: !0 },
        { pubkey: C, isSigner: !1, isWritable: !0 },
      ],
      B,
      E
    );
    return new r.TransactionInstruction({ keys: S, programId: y, data: v });
  }
  e.createWithdrawWithheldTokensFromMintInstruction = b;
  function w(D, C) {
    if (!D.programId.equals(C)) throw new s.TokenInvalidInstructionProgramError();
    if (D.data.length !== e.withdrawWithheldTokensFromMintInstructionData.span)
      throw new s.TokenInvalidInstructionDataError();
    const {
      keys: { mint: B, destination: E, authority: y, signers: v },
      data: S,
    } = A(D);
    if (
      S.instruction !== a.TokenInstruction.TransferFeeExtension ||
      S.transferFeeInstruction !== c.WithdrawWithheldTokensFromMint
    )
      throw new s.TokenInvalidInstructionTypeError();
    if (!B) throw new s.TokenInvalidInstructionKeysError();
    return {
      programId: C,
      keys: { mint: B, destination: E, authority: y, signers: v || null },
      data: S,
    };
  }
  e.decodeWithdrawWithheldTokensFromMintInstruction = w;
  function A({ programId: D, keys: [C, B, E, ...y], data: v }) {
    const { instruction: S, transferFeeInstruction: T } =
      e.withdrawWithheldTokensFromMintInstructionData.decode(v);
    return {
      programId: D,
      keys: { mint: C, destination: B, authority: E, signers: y },
      data: { instruction: S, transferFeeInstruction: T },
    };
  }
  (e.decodeWithdrawWithheldTokensFromMintInstructionUnchecked = A),
    (e.withdrawWithheldTokensFromAccountsInstructionData = (0, t.struct)([
      (0, t.u8)('instruction'),
      (0, t.u8)('transferFeeInstruction'),
      (0, t.u8)('numTokenAccounts'),
    ]));
  function _(D, C, B, E, y, v = i.TOKEN_2022_PROGRAM_ID) {
    if (!(0, i.programSupportsExtensions)(v)) throw new s.TokenUnsupportedInstructionError();
    const S = z.alloc(e.withdrawWithheldTokensFromAccountsInstructionData.span);
    e.withdrawWithheldTokensFromAccountsInstructionData.encode(
      {
        instruction: a.TokenInstruction.TransferFeeExtension,
        transferFeeInstruction: c.WithdrawWithheldTokensFromAccounts,
        numTokenAccounts: y.length,
      },
      S
    );
    const T = (0, o.addSigners)(
      [
        { pubkey: D, isSigner: !1, isWritable: !0 },
        { pubkey: C, isSigner: !1, isWritable: !0 },
      ],
      B,
      E
    );
    for (const M of y) T.push({ pubkey: M, isSigner: !1, isWritable: !0 });
    return new r.TransactionInstruction({ keys: T, programId: v, data: S });
  }
  e.createWithdrawWithheldTokensFromAccountsInstruction = _;
  function x(D, C) {
    if (!D.programId.equals(C)) throw new s.TokenInvalidInstructionProgramError();
    if (D.data.length !== e.withdrawWithheldTokensFromAccountsInstructionData.span)
      throw new s.TokenInvalidInstructionDataError();
    const {
      keys: { mint: B, destination: E, authority: y, signers: v, sources: S },
      data: T,
    } = k(D);
    if (
      T.instruction !== a.TokenInstruction.TransferFeeExtension ||
      T.transferFeeInstruction !== c.WithdrawWithheldTokensFromAccounts
    )
      throw new s.TokenInvalidInstructionTypeError();
    if (!B) throw new s.TokenInvalidInstructionKeysError();
    return {
      programId: C,
      keys: { mint: B, destination: E, authority: y, signers: v || null, sources: S || null },
      data: T,
    };
  }
  e.decodeWithdrawWithheldTokensFromAccountsInstruction = x;
  function k({ programId: D, keys: C, data: B }) {
    const {
        instruction: E,
        transferFeeInstruction: y,
        numTokenAccounts: v,
      } = e.withdrawWithheldTokensFromAccountsInstructionData.decode(B),
      [S, T, M, R, L] = [C[0], C[1], C[2], C.slice(3, 3 + v), C.slice(-1 * v)];
    return {
      programId: D,
      keys: { mint: S, destination: T, authority: M, signers: R, sources: L },
      data: { instruction: E, transferFeeInstruction: y, numTokenAccounts: v },
    };
  }
  (e.decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked = k),
    (e.harvestWithheldTokensToMintInstructionData = (0, t.struct)([
      (0, t.u8)('instruction'),
      (0, t.u8)('transferFeeInstruction'),
    ]));
  function j(D, C, B = i.TOKEN_2022_PROGRAM_ID) {
    if (!(0, i.programSupportsExtensions)(B)) throw new s.TokenUnsupportedInstructionError();
    const E = z.alloc(e.harvestWithheldTokensToMintInstructionData.span);
    e.harvestWithheldTokensToMintInstructionData.encode(
      {
        instruction: a.TokenInstruction.TransferFeeExtension,
        transferFeeInstruction: c.HarvestWithheldTokensToMint,
      },
      E
    );
    const y = [];
    y.push({ pubkey: D, isSigner: !1, isWritable: !0 });
    for (const v of C) y.push({ pubkey: v, isSigner: !1, isWritable: !0 });
    return new r.TransactionInstruction({ keys: y, programId: B, data: E });
  }
  e.createHarvestWithheldTokensToMintInstruction = j;
  function F(D, C) {
    if (!D.programId.equals(C)) throw new s.TokenInvalidInstructionProgramError();
    if (D.data.length !== e.harvestWithheldTokensToMintInstructionData.span)
      throw new s.TokenInvalidInstructionDataError();
    const {
      keys: { mint: B, sources: E },
      data: y,
    } = K(D);
    if (
      y.instruction !== a.TokenInstruction.TransferFeeExtension ||
      y.transferFeeInstruction !== c.HarvestWithheldTokensToMint
    )
      throw new s.TokenInvalidInstructionTypeError();
    if (!B) throw new s.TokenInvalidInstructionKeysError();
    return { programId: C, keys: { mint: B, sources: E }, data: y };
  }
  e.decodeHarvestWithheldTokensToMintInstruction = F;
  function K({ programId: D, keys: [C, ...B], data: E }) {
    const { instruction: y, transferFeeInstruction: v } =
      e.harvestWithheldTokensToMintInstructionData.decode(E);
    return {
      programId: D,
      keys: { mint: C, sources: B },
      data: { instruction: y, transferFeeInstruction: v },
    };
  }
  e.decodeHarvestWithheldTokensToMintInstructionUnchecked = K;
})(OI);
var Em =
  (m && m.__awaiter) ||
  function (e, t, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(l) {
        try {
          u(r.next(l));
        } catch (d) {
          o(d);
        }
      }
      function c(l) {
        try {
          u(r.throw(l));
        } catch (d) {
          o(d);
        }
      }
      function u(l) {
        l.done ? s(l.value) : i(l.value).then(a, c);
      }
      u((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(hs, '__esModule', { value: !0 });
hs.harvestWithheldTokensToMint =
  hs.withdrawWithheldTokensFromAccounts =
  hs.withdrawWithheldTokensFromMint =
  hs.transferCheckedWithFee =
    void 0;
const ya = ne,
  BI = ln,
  Am = Ce,
  Im = OI;
function rie(e, t, n, r, i, s, o, a, c, u = [], l, d = Am.TOKEN_2022_PROGRAM_ID) {
  return Em(this, void 0, void 0, function* () {
    const [f, h] = (0, BI.getSigners)(s, u),
      p = new ya.Transaction().add(
        (0, Im.createTransferCheckedWithFeeInstruction)(n, r, i, f, o, a, c, u, d)
      );
    return yield (0, ya.sendAndConfirmTransaction)(e, p, [t, ...h], l);
  });
}
hs.transferCheckedWithFee = rie;
function iie(e, t, n, r, i, s = [], o, a = Am.TOKEN_2022_PROGRAM_ID) {
  return Em(this, void 0, void 0, function* () {
    const [c, u] = (0, BI.getSigners)(i, s),
      l = new ya.Transaction().add(
        (0, Im.createWithdrawWithheldTokensFromMintInstruction)(n, r, c, u, a)
      );
    return yield (0, ya.sendAndConfirmTransaction)(e, l, [t, ...u], o);
  });
}
hs.withdrawWithheldTokensFromMint = iie;
function sie(e, t, n, r, i, s, o, a, c = Am.TOKEN_2022_PROGRAM_ID) {
  return Em(this, void 0, void 0, function* () {
    const [u, l] = (0, BI.getSigners)(i, s),
      d = new ya.Transaction().add(
        (0, Im.createWithdrawWithheldTokensFromAccountsInstruction)(n, r, u, l, o, c)
      );
    return yield (0, ya.sendAndConfirmTransaction)(e, d, [t, ...l], a);
  });
}
hs.withdrawWithheldTokensFromAccounts = sie;
function oie(e, t, n, r, i, s = Am.TOKEN_2022_PROGRAM_ID) {
  return Em(this, void 0, void 0, function* () {
    const o = new ya.Transaction().add(
      (0, Im.createHarvestWithheldTokensToMintInstruction)(n, r, s)
    );
    return yield (0, ya.sendAndConfirmTransaction)(e, o, [t], i);
  });
}
hs.harvestWithheldTokensToMint = oie;
var Rv = {},
  E2;
function aie() {
  return (
    E2 ||
      ((E2 = 1),
      (function (e) {
        Object.defineProperty(e, '__esModule', { value: !0 }),
          (e.getTransferFeeAmount =
            e.getTransferFeeConfig =
            e.TRANSFER_FEE_AMOUNT_SIZE =
            e.TransferFeeAmountLayout =
            e.TRANSFER_FEE_CONFIG_SIZE =
            e.TransferFeeConfigLayout =
            e.transferFeeLayout =
            e.ONE_IN_BASIS_POINTS =
            e.MAX_FEE_BASIS_POINTS =
              void 0);
        const t = Ze,
          n = Rt,
          r = Br();
        (e.MAX_FEE_BASIS_POINTS = 1e4), (e.ONE_IN_BASIS_POINTS = e.MAX_FEE_BASIS_POINTS);
        function i(a) {
          return (0, t.struct)(
            [(0, n.u64)('epoch'), (0, n.u64)('maximumFee'), (0, t.u16)('transferFeeBasisPoints')],
            a
          );
        }
        (e.transferFeeLayout = i),
          (e.TransferFeeConfigLayout = (0, t.struct)([
            (0, n.publicKey)('transferFeeConfigAuthority'),
            (0, n.publicKey)('withdrawWithheldAuthority'),
            (0, n.u64)('withheldAmount'),
            i('olderTransferFee'),
            i('newerTransferFee'),
          ])),
          (e.TRANSFER_FEE_CONFIG_SIZE = e.TransferFeeConfigLayout.span),
          (e.TransferFeeAmountLayout = (0, t.struct)([(0, n.u64)('withheldAmount')])),
          (e.TRANSFER_FEE_AMOUNT_SIZE = e.TransferFeeAmountLayout.span);
        function s(a) {
          const c = (0, r.getExtensionData)(r.ExtensionType.TransferFeeConfig, a.tlvData);
          return c !== null ? e.TransferFeeConfigLayout.decode(c) : null;
        }
        e.getTransferFeeConfig = s;
        function o(a) {
          const c = (0, r.getExtensionData)(r.ExtensionType.TransferFeeAmount, a.tlvData);
          return c !== null ? e.TransferFeeAmountLayout.decode(c) : null;
        }
        e.getTransferFeeAmount = o;
      })(Rv)),
    Rv
  );
}
var A2;
function XB() {
  return (
    A2 ||
      ((A2 = 1),
      (function (e) {
        var t =
            (m && m.__createBinding) ||
            (Object.create
              ? function (r, i, s, o) {
                  o === void 0 && (o = s);
                  var a = Object.getOwnPropertyDescriptor(i, s);
                  (!a || ('get' in a ? !i.__esModule : a.writable || a.configurable)) &&
                    (a = {
                      enumerable: !0,
                      get: function () {
                        return i[s];
                      },
                    }),
                    Object.defineProperty(r, o, a);
                }
              : function (r, i, s, o) {
                  o === void 0 && (o = s), (r[o] = i[s]);
                }),
          n =
            (m && m.__exportStar) ||
            function (r, i) {
              for (var s in r)
                s !== 'default' && !Object.prototype.hasOwnProperty.call(i, s) && t(i, r, s);
            };
        Object.defineProperty(e, '__esModule', { value: !0 }), n(hs, e), n(OI, e), n(aie(), e);
      })(Dv)),
    Dv
  );
}
var I2;
function Br() {
  return (
    I2 ||
      ((I2 = 1),
      (function (e) {
        Object.defineProperty(e, '__esModule', { value: !0 }),
          (e.getAccountLenForMint =
            e.getExtensionTypes =
            e.getExtensionData =
            e.getAccountLen =
            e.getMintLen =
            e.getAccountTypeOfMintType =
            e.isAccountExtension =
            e.isMintExtension =
            e.getTypeLen =
            e.LENGTH_SIZE =
            e.TYPE_SIZE =
            e.ExtensionType =
              void 0);
        const t = lp(),
          n = Sa(),
          r = Xu,
          i = up,
          s = jB(),
          o = FB(),
          a = zB(),
          c = KB(),
          u = qB(),
          l = YB(),
          d = ZB(),
          f = JB(),
          h = XB();
        var p;
        (function (C) {
          (C[(C.Uninitialized = 0)] = 'Uninitialized'),
            (C[(C.TransferFeeConfig = 1)] = 'TransferFeeConfig'),
            (C[(C.TransferFeeAmount = 2)] = 'TransferFeeAmount'),
            (C[(C.MintCloseAuthority = 3)] = 'MintCloseAuthority'),
            (C[(C.ConfidentialTransferMint = 4)] = 'ConfidentialTransferMint'),
            (C[(C.ConfidentialTransferAccount = 5)] = 'ConfidentialTransferAccount'),
            (C[(C.DefaultAccountState = 6)] = 'DefaultAccountState'),
            (C[(C.ImmutableOwner = 7)] = 'ImmutableOwner'),
            (C[(C.MemoTransfer = 8)] = 'MemoTransfer'),
            (C[(C.NonTransferable = 9)] = 'NonTransferable'),
            (C[(C.InterestBearingConfig = 10)] = 'InterestBearingConfig'),
            (C[(C.CpiGuard = 11)] = 'CpiGuard'),
            (C[(C.PermanentDelegate = 12)] = 'PermanentDelegate');
        })((p = e.ExtensionType || (e.ExtensionType = {}))),
          (e.TYPE_SIZE = 2),
          (e.LENGTH_SIZE = 2);
        function b(C) {
          switch (C) {
            case p.Uninitialized:
              return 0;
            case p.TransferFeeConfig:
              return h.TRANSFER_FEE_CONFIG_SIZE;
            case p.TransferFeeAmount:
              return h.TRANSFER_FEE_AMOUNT_SIZE;
            case p.MintCloseAuthority:
              return l.MINT_CLOSE_AUTHORITY_SIZE;
            case p.ConfidentialTransferMint:
              return 97;
            case p.ConfidentialTransferAccount:
              return 286;
            case p.CpiGuard:
              return s.CPI_GUARD_SIZE;
            case p.DefaultAccountState:
              return o.DEFAULT_ACCOUNT_STATE_SIZE;
            case p.ImmutableOwner:
              return a.IMMUTABLE_OWNER_SIZE;
            case p.MemoTransfer:
              return u.MEMO_TRANSFER_SIZE;
            case p.NonTransferable:
              return d.NON_TRANSFERABLE_SIZE;
            case p.InterestBearingConfig:
              return c.INTEREST_BEARING_MINT_CONFIG_STATE_SIZE;
            case p.PermanentDelegate:
              return f.PERMANENT_DELEGATE_SIZE;
            default:
              throw Error(`Unknown extension type: ${C}`);
          }
        }
        e.getTypeLen = b;
        function w(C) {
          switch (C) {
            case p.TransferFeeConfig:
            case p.MintCloseAuthority:
            case p.ConfidentialTransferMint:
            case p.DefaultAccountState:
            case p.NonTransferable:
            case p.InterestBearingConfig:
            case p.PermanentDelegate:
              return !0;
            case p.Uninitialized:
            case p.TransferFeeAmount:
            case p.ConfidentialTransferAccount:
            case p.ImmutableOwner:
            case p.MemoTransfer:
            case p.CpiGuard:
              return !1;
            default:
              throw Error(`Unknown extension type: ${C}`);
          }
        }
        e.isMintExtension = w;
        function A(C) {
          switch (C) {
            case p.TransferFeeAmount:
            case p.ConfidentialTransferAccount:
            case p.ImmutableOwner:
            case p.MemoTransfer:
            case p.CpiGuard:
              return !0;
            case p.Uninitialized:
            case p.TransferFeeConfig:
            case p.MintCloseAuthority:
            case p.ConfidentialTransferMint:
            case p.DefaultAccountState:
            case p.NonTransferable:
            case p.InterestBearingConfig:
            case p.PermanentDelegate:
              return !1;
            default:
              throw Error(`Unknown extension type: ${C}`);
          }
        }
        e.isAccountExtension = A;
        function _(C) {
          switch (C) {
            case p.TransferFeeConfig:
              return p.TransferFeeAmount;
            case p.ConfidentialTransferMint:
              return p.ConfidentialTransferAccount;
            case p.TransferFeeAmount:
            case p.ConfidentialTransferAccount:
            case p.CpiGuard:
            case p.DefaultAccountState:
            case p.ImmutableOwner:
            case p.MemoTransfer:
            case p.MintCloseAuthority:
            case p.NonTransferable:
            case p.Uninitialized:
            case p.InterestBearingConfig:
            case p.PermanentDelegate:
              return p.Uninitialized;
          }
        }
        e.getAccountTypeOfMintType = _;
        function x(C, B) {
          if (C.length === 0) return B;
          {
            const E =
              t.ACCOUNT_SIZE +
              i.ACCOUNT_TYPE_SIZE +
              C.filter((y, v) => v === C.indexOf(y))
                .map((y) => b(y) + e.TYPE_SIZE + e.LENGTH_SIZE)
                .reduce((y, v) => y + v);
            return E === r.MULTISIG_SIZE ? E + e.TYPE_SIZE : E;
          }
        }
        function k(C) {
          return x(C, n.MINT_SIZE);
        }
        e.getMintLen = k;
        function j(C) {
          return x(C, t.ACCOUNT_SIZE);
        }
        e.getAccountLen = j;
        function F(C, B) {
          let E = 0;
          for (; E + e.TYPE_SIZE + e.LENGTH_SIZE <= B.length; ) {
            const y = B.readUInt16LE(E),
              v = B.readUInt16LE(E + e.TYPE_SIZE),
              S = E + e.TYPE_SIZE + e.LENGTH_SIZE;
            if (y == C) return B.slice(S, S + v);
            E = S + v;
          }
          return null;
        }
        e.getExtensionData = F;
        function K(C) {
          const B = [];
          let E = 0;
          for (; E < C.length; ) {
            const y = C.readUInt16LE(E);
            B.push(y);
            const v = C.readUInt16LE(E + e.TYPE_SIZE);
            E += e.TYPE_SIZE + e.LENGTH_SIZE + v;
          }
          return B;
        }
        e.getExtensionTypes = K;
        function D(C) {
          const E = K(C.tlvData).map(_);
          return j(E);
        }
        e.getAccountLenForMint = D;
      })(vv)),
    vv
  );
}
var dp = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeInitializeAccountInstructionUnchecked =
      e.decodeInitializeAccountInstruction =
      e.createInitializeAccountInstruction =
      e.initializeAccountInstructionData =
        void 0);
  const t = Ze,
    n = ne,
    r = Ce,
    i = Me,
    s = ft;
  e.initializeAccountInstructionData = (0, t.struct)([(0, t.u8)('instruction')]);
  function o(u, l, d, f = r.TOKEN_PROGRAM_ID) {
    const h = [
        { pubkey: u, isSigner: !1, isWritable: !0 },
        { pubkey: l, isSigner: !1, isWritable: !1 },
        { pubkey: d, isSigner: !1, isWritable: !1 },
        { pubkey: n.SYSVAR_RENT_PUBKEY, isSigner: !1, isWritable: !1 },
      ],
      p = z.alloc(e.initializeAccountInstructionData.span);
    return (
      e.initializeAccountInstructionData.encode(
        { instruction: s.TokenInstruction.InitializeAccount },
        p
      ),
      new n.TransactionInstruction({ keys: h, programId: f, data: p })
    );
  }
  e.createInitializeAccountInstruction = o;
  function a(u, l = r.TOKEN_PROGRAM_ID) {
    if (!u.programId.equals(l)) throw new i.TokenInvalidInstructionProgramError();
    if (u.data.length !== e.initializeAccountInstructionData.span)
      throw new i.TokenInvalidInstructionDataError();
    const {
      keys: { account: d, mint: f, owner: h, rent: p },
      data: b,
    } = c(u);
    if (b.instruction !== s.TokenInstruction.InitializeAccount)
      throw new i.TokenInvalidInstructionTypeError();
    if (!d || !f || !h || !p) throw new i.TokenInvalidInstructionKeysError();
    return { programId: l, keys: { account: d, mint: f, owner: h, rent: p }, data: b };
  }
  e.decodeInitializeAccountInstruction = a;
  function c({ programId: u, keys: [l, d, f, h], data: p }) {
    return {
      programId: u,
      keys: { account: l, mint: d, owner: f, rent: h },
      data: e.initializeAccountInstructionData.decode(p),
    };
  }
  e.decodeInitializeAccountInstructionUnchecked = c;
})(dp);
var fp = {},
  vs = {};
Object.defineProperty(vs, '__esModule', { value: !0 });
vs.createAssociatedTokenAccountIdempotentInstruction = vs.createAssociatedTokenAccountInstruction =
  void 0;
const T2 = ne,
  Cu = Ce;
function cie(e, t, n, r, i = Cu.TOKEN_PROGRAM_ID, s = Cu.ASSOCIATED_TOKEN_PROGRAM_ID) {
  return QB(e, t, n, r, z.alloc(0), i, s);
}
vs.createAssociatedTokenAccountInstruction = cie;
function uie(e, t, n, r, i = Cu.TOKEN_PROGRAM_ID, s = Cu.ASSOCIATED_TOKEN_PROGRAM_ID) {
  return QB(e, t, n, r, z.from([1]), i, s);
}
vs.createAssociatedTokenAccountIdempotentInstruction = uie;
function QB(e, t, n, r, i, s = Cu.TOKEN_PROGRAM_ID, o = Cu.ASSOCIATED_TOKEN_PROGRAM_ID) {
  const a = [
    { pubkey: e, isSigner: !0, isWritable: !0 },
    { pubkey: t, isSigner: !1, isWritable: !0 },
    { pubkey: n, isSigner: !1, isWritable: !1 },
    { pubkey: r, isSigner: !1, isWritable: !1 },
    { pubkey: T2.SystemProgram.programId, isSigner: !1, isWritable: !1 },
    { pubkey: s, isSigner: !1, isWritable: !1 },
  ];
  return new T2.TransactionInstruction({ keys: a, programId: o, data: i });
}
var lie =
  (m && m.__awaiter) ||
  function (e, t, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(l) {
        try {
          u(r.next(l));
        } catch (d) {
          o(d);
        }
      }
      function c(l) {
        try {
          u(r.throw(l));
        } catch (d) {
          o(d);
        }
      }
      function u(l) {
        l.done ? s(l.value) : i(l.value).then(a, c);
      }
      u((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(fp, '__esModule', { value: !0 });
fp.createAssociatedTokenAccount = void 0;
const x2 = ne,
  k2 = Ce,
  die = vs,
  fie = Sa();
function hie(e, t, n, r, i, s = k2.TOKEN_PROGRAM_ID, o = k2.ASSOCIATED_TOKEN_PROGRAM_ID) {
  return lie(this, void 0, void 0, function* () {
    const a = yield (0, fie.getAssociatedTokenAddress)(n, r, !1, s, o),
      c = new x2.Transaction().add(
        (0, die.createAssociatedTokenAccountInstruction)(t.publicKey, a, r, n, s, o)
      );
    return yield (0, x2.sendAndConfirmTransaction)(e, c, [t], i), a;
  });
}
fp.createAssociatedTokenAccount = hie;
var pie =
  (m && m.__awaiter) ||
  function (e, t, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(l) {
        try {
          u(r.next(l));
        } catch (d) {
          o(d);
        }
      }
      function c(l) {
        try {
          u(r.throw(l));
        } catch (d) {
          o(d);
        }
      }
      function u(l) {
        l.done ? s(l.value) : i(l.value).then(a, c);
      }
      u((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(cp, '__esModule', { value: !0 });
cp.createAccount = void 0;
const Nv = ne,
  gie = Ce,
  yie = Br(),
  bie = dp,
  mie = Sa(),
  wie = fp;
function vie(e, t, n, r, i, s, o = gie.TOKEN_PROGRAM_ID) {
  return pie(this, void 0, void 0, function* () {
    if (!i) return yield (0, wie.createAssociatedTokenAccount)(e, t, n, r, s, o);
    const a = yield (0, mie.getMint)(e, n, s == null ? void 0 : s.commitment, o),
      c = (0, yie.getAccountLenForMint)(a),
      u = yield e.getMinimumBalanceForRentExemption(c),
      l = new Nv.Transaction().add(
        Nv.SystemProgram.createAccount({
          fromPubkey: t.publicKey,
          newAccountPubkey: i.publicKey,
          space: c,
          lamports: u,
          programId: o,
        }),
        (0, bie.createInitializeAccountInstruction)(i.publicKey, n, r, o)
      );
    return yield (0, Nv.sendAndConfirmTransaction)(e, l, [t, i], s), i.publicKey;
  });
}
cp.createAccount = vie;
var Tm = {},
  _ie =
    (m && m.__awaiter) ||
    function (e, t, n, r) {
      function i(s) {
        return s instanceof n
          ? s
          : new n(function (o) {
              o(s);
            });
      }
      return new (n || (n = Promise))(function (s, o) {
        function a(l) {
          try {
            u(r.next(l));
          } catch (d) {
            o(d);
          }
        }
        function c(l) {
          try {
            u(r.throw(l));
          } catch (d) {
            o(d);
          }
        }
        function u(l) {
          l.done ? s(l.value) : i(l.value).then(a, c);
        }
        u((r = r.apply(e, t || [])).next());
      });
    };
Object.defineProperty(Tm, '__esModule', { value: !0 });
Tm.createAssociatedTokenAccountIdempotent = void 0;
const C2 = ne,
  P2 = Ce,
  Sie = vs,
  Eie = Sa();
function Aie(e, t, n, r, i, s = P2.TOKEN_PROGRAM_ID, o = P2.ASSOCIATED_TOKEN_PROGRAM_ID) {
  return _ie(this, void 0, void 0, function* () {
    const a = yield (0, Eie.getAssociatedTokenAddress)(n, r, !1, s, o),
      c = new C2.Transaction().add(
        (0, Sie.createAssociatedTokenAccountIdempotentInstruction)(t.publicKey, a, r, n, s, o)
      );
    return yield (0, C2.sendAndConfirmTransaction)(e, c, [t], i), a;
  });
}
Tm.createAssociatedTokenAccountIdempotent = Aie;
var xm = {},
  km = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeInitializeMint2InstructionUnchecked =
      e.decodeInitializeMint2Instruction =
      e.createInitializeMint2Instruction =
      e.initializeMint2InstructionData =
        void 0);
  const t = Ze,
    n = Rt,
    r = ne,
    i = Ce,
    s = Me,
    o = ft;
  e.initializeMint2InstructionData = (0, t.struct)([
    (0, t.u8)('instruction'),
    (0, t.u8)('decimals'),
    (0, n.publicKey)('mintAuthority'),
    (0, t.u8)('freezeAuthorityOption'),
    (0, n.publicKey)('freezeAuthority'),
  ]);
  function a(l, d, f, h, p = i.TOKEN_PROGRAM_ID) {
    const b = [{ pubkey: l, isSigner: !1, isWritable: !0 }],
      w = z.alloc(e.initializeMint2InstructionData.span);
    return (
      e.initializeMint2InstructionData.encode(
        {
          instruction: o.TokenInstruction.InitializeMint2,
          decimals: d,
          mintAuthority: f,
          freezeAuthorityOption: h ? 1 : 0,
          freezeAuthority: h || new r.PublicKey(0),
        },
        w
      ),
      new r.TransactionInstruction({ keys: b, programId: p, data: w })
    );
  }
  e.createInitializeMint2Instruction = a;
  function c(l, d = i.TOKEN_PROGRAM_ID) {
    if (!l.programId.equals(d)) throw new s.TokenInvalidInstructionProgramError();
    if (l.data.length !== e.initializeMint2InstructionData.span)
      throw new s.TokenInvalidInstructionDataError();
    const {
      keys: { mint: f },
      data: h,
    } = u(l);
    if (h.instruction !== o.TokenInstruction.InitializeMint2)
      throw new s.TokenInvalidInstructionTypeError();
    if (!f) throw new s.TokenInvalidInstructionKeysError();
    return { programId: d, keys: { mint: f }, data: h };
  }
  e.decodeInitializeMint2Instruction = c;
  function u({ programId: l, keys: [d], data: f }) {
    const {
      instruction: h,
      decimals: p,
      mintAuthority: b,
      freezeAuthorityOption: w,
      freezeAuthority: A,
    } = e.initializeMint2InstructionData.decode(f);
    return {
      programId: l,
      keys: { mint: d },
      data: { instruction: h, decimals: p, mintAuthority: b, freezeAuthority: w ? A : null },
    };
  }
  e.decodeInitializeMint2InstructionUnchecked = u;
})(km);
var Iie =
  (m && m.__awaiter) ||
  function (e, t, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(l) {
        try {
          u(r.next(l));
        } catch (d) {
          o(d);
        }
      }
      function c(l) {
        try {
          u(r.throw(l));
        } catch (d) {
          o(d);
        }
      }
      function u(l) {
        l.done ? s(l.value) : i(l.value).then(a, c);
      }
      u((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(xm, '__esModule', { value: !0 });
xm.createMint = void 0;
const ng = ne,
  Tie = Ce,
  xie = km,
  M2 = Sa();
function kie(e, t, n, r, i, s = ng.Keypair.generate(), o, a = Tie.TOKEN_PROGRAM_ID) {
  return Iie(this, void 0, void 0, function* () {
    const c = yield (0, M2.getMinimumBalanceForRentExemptMint)(e),
      u = new ng.Transaction().add(
        ng.SystemProgram.createAccount({
          fromPubkey: t.publicKey,
          newAccountPubkey: s.publicKey,
          space: M2.MINT_SIZE,
          lamports: c,
          programId: a,
        }),
        (0, xie.createInitializeMint2Instruction)(s.publicKey, i, n, r, a)
      );
    return yield (0, ng.sendAndConfirmTransaction)(e, u, [t, s], o), s.publicKey;
  });
}
xm.createMint = kie;
var Cm = {},
  Pm = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeInitializeMultisigInstructionUnchecked =
      e.decodeInitializeMultisigInstruction =
      e.createInitializeMultisigInstruction =
      e.initializeMultisigInstructionData =
        void 0);
  const t = Ze,
    n = ne,
    r = Ce,
    i = Me,
    s = ft;
  e.initializeMultisigInstructionData = (0, t.struct)([(0, t.u8)('instruction'), (0, t.u8)('m')]);
  function o(u, l, d, f = r.TOKEN_PROGRAM_ID) {
    const h = [
      { pubkey: u, isSigner: !1, isWritable: !0 },
      { pubkey: n.SYSVAR_RENT_PUBKEY, isSigner: !1, isWritable: !1 },
    ];
    for (const b of l)
      h.push({ pubkey: b instanceof n.PublicKey ? b : b.publicKey, isSigner: !1, isWritable: !1 });
    const p = z.alloc(e.initializeMultisigInstructionData.span);
    return (
      e.initializeMultisigInstructionData.encode(
        { instruction: s.TokenInstruction.InitializeMultisig, m: d },
        p
      ),
      new n.TransactionInstruction({ keys: h, programId: f, data: p })
    );
  }
  e.createInitializeMultisigInstruction = o;
  function a(u, l = r.TOKEN_PROGRAM_ID) {
    if (!u.programId.equals(l)) throw new i.TokenInvalidInstructionProgramError();
    if (u.data.length !== e.initializeMultisigInstructionData.span)
      throw new i.TokenInvalidInstructionDataError();
    const {
      keys: { account: d, rent: f, signers: h },
      data: p,
    } = c(u);
    if (p.instruction !== s.TokenInstruction.InitializeMultisig)
      throw new i.TokenInvalidInstructionTypeError();
    if (!d || !f || !h.length) throw new i.TokenInvalidInstructionKeysError();
    return { programId: l, keys: { account: d, rent: f, signers: h }, data: p };
  }
  e.decodeInitializeMultisigInstruction = a;
  function c({ programId: u, keys: [l, d, ...f], data: h }) {
    return {
      programId: u,
      keys: { account: l, rent: d, signers: f },
      data: e.initializeMultisigInstructionData.decode(h),
    };
  }
  e.decodeInitializeMultisigInstructionUnchecked = c;
})(Pm);
var Cie =
  (m && m.__awaiter) ||
  function (e, t, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(l) {
        try {
          u(r.next(l));
        } catch (d) {
          o(d);
        }
      }
      function c(l) {
        try {
          u(r.throw(l));
        } catch (d) {
          o(d);
        }
      }
      function u(l) {
        l.done ? s(l.value) : i(l.value).then(a, c);
      }
      u((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(Cm, '__esModule', { value: !0 });
Cm.createMultisig = void 0;
const rg = ne,
  Pie = Ce,
  Mie = Pm,
  O2 = Xu;
function Oie(e, t, n, r, i = rg.Keypair.generate(), s, o = Pie.TOKEN_PROGRAM_ID) {
  return Cie(this, void 0, void 0, function* () {
    const a = yield (0, O2.getMinimumBalanceForRentExemptMultisig)(e),
      c = new rg.Transaction().add(
        rg.SystemProgram.createAccount({
          fromPubkey: t.publicKey,
          newAccountPubkey: i.publicKey,
          space: O2.MULTISIG_SIZE,
          lamports: a,
          programId: o,
        }),
        (0, Mie.createInitializeMultisigInstruction)(i.publicKey, n, r, o)
      );
    return yield (0, rg.sendAndConfirmTransaction)(e, c, [t, i], s), i.publicKey;
  });
}
Cm.createMultisig = Oie;
var Mm = {},
  DI = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createCreateNativeMintInstruction = e.createNativeMintInstructionData = void 0);
  const t = Ze,
    n = ne,
    r = Ce,
    i = Me,
    s = ft;
  e.createNativeMintInstructionData = (0, t.struct)([(0, t.u8)('instruction')]);
  function o(a, c = r.NATIVE_MINT_2022, u = r.TOKEN_2022_PROGRAM_ID) {
    if (!(0, r.programSupportsExtensions)(u)) throw new i.TokenUnsupportedInstructionError();
    const l = [
        { pubkey: a, isSigner: !0, isWritable: !0 },
        { pubkey: c, isSigner: !1, isWritable: !0 },
        { pubkey: n.SystemProgram.programId, isSigner: !1, isWritable: !1 },
      ],
      d = z.alloc(e.createNativeMintInstructionData.span);
    return (
      e.createNativeMintInstructionData.encode(
        { instruction: s.TokenInstruction.CreateNativeMint },
        d
      ),
      new n.TransactionInstruction({ keys: l, programId: u, data: d })
    );
  }
  e.createCreateNativeMintInstruction = o;
})(DI);
var Bie =
  (m && m.__awaiter) ||
  function (e, t, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(l) {
        try {
          u(r.next(l));
        } catch (d) {
          o(d);
        }
      }
      function c(l) {
        try {
          u(r.throw(l));
        } catch (d) {
          o(d);
        }
      }
      function u(l) {
        l.done ? s(l.value) : i(l.value).then(a, c);
      }
      u((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(Mm, '__esModule', { value: !0 });
Mm.createNativeMint = void 0;
const B2 = ne,
  D2 = Ce,
  Die = DI;
function Rie(e, t, n, r = D2.NATIVE_MINT_2022, i = D2.TOKEN_2022_PROGRAM_ID) {
  return Bie(this, void 0, void 0, function* () {
    const s = new B2.Transaction().add(
      (0, Die.createCreateNativeMintInstruction)(t.publicKey, r, i)
    );
    yield (0, B2.sendAndConfirmTransaction)(e, s, [t], n);
  });
}
Mm.createNativeMint = Rie;
var Om = {},
  hp = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeSyncNativeInstructionUnchecked =
      e.decodeSyncNativeInstruction =
      e.createSyncNativeInstruction =
      e.syncNativeInstructionData =
        void 0);
  const t = Ze,
    n = ne,
    r = Ce,
    i = Me,
    s = ft;
  e.syncNativeInstructionData = (0, t.struct)([(0, t.u8)('instruction')]);
  function o(u, l = r.TOKEN_PROGRAM_ID) {
    const d = [{ pubkey: u, isSigner: !1, isWritable: !0 }],
      f = z.alloc(e.syncNativeInstructionData.span);
    return (
      e.syncNativeInstructionData.encode({ instruction: s.TokenInstruction.SyncNative }, f),
      new n.TransactionInstruction({ keys: d, programId: l, data: f })
    );
  }
  e.createSyncNativeInstruction = o;
  function a(u, l = r.TOKEN_PROGRAM_ID) {
    if (!u.programId.equals(l)) throw new i.TokenInvalidInstructionProgramError();
    if (u.data.length !== e.syncNativeInstructionData.span)
      throw new i.TokenInvalidInstructionDataError();
    const {
      keys: { account: d },
      data: f,
    } = c(u);
    if (f.instruction !== s.TokenInstruction.SyncNative)
      throw new i.TokenInvalidInstructionTypeError();
    if (!d) throw new i.TokenInvalidInstructionKeysError();
    return { programId: l, keys: { account: d }, data: f };
  }
  e.decodeSyncNativeInstruction = a;
  function c({ programId: u, keys: [l], data: d }) {
    return { programId: u, keys: { account: l }, data: e.syncNativeInstructionData.decode(d) };
  }
  e.decodeSyncNativeInstructionUnchecked = c;
})(hp);
var Nie =
  (m && m.__awaiter) ||
  function (e, t, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(l) {
        try {
          u(r.next(l));
        } catch (d) {
          o(d);
        }
      }
      function c(l) {
        try {
          u(r.throw(l));
        } catch (d) {
          o(d);
        }
      }
      function u(l) {
        l.done ? s(l.value) : i(l.value).then(a, c);
      }
      u((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(Om, '__esModule', { value: !0 });
Om.createWrappedNativeAccount = void 0;
const Ia = ne,
  ig = Ce,
  jie = vs,
  Lie = dp,
  Uie = hp,
  R2 = lp(),
  $ie = Sa(),
  Fie = cp;
function zie(e, t, n, r, i, s, o = ig.TOKEN_PROGRAM_ID, a = ig.NATIVE_MINT) {
  return Nie(this, void 0, void 0, function* () {
    if (!r) return yield (0, Fie.createAccount)(e, t, a, n, i, s, o);
    if (!i) {
      const l = yield (0, $ie.getAssociatedTokenAddress)(
          a,
          n,
          !1,
          o,
          ig.ASSOCIATED_TOKEN_PROGRAM_ID
        ),
        d = new Ia.Transaction().add(
          (0, jie.createAssociatedTokenAccountInstruction)(
            t.publicKey,
            l,
            n,
            a,
            o,
            ig.ASSOCIATED_TOKEN_PROGRAM_ID
          ),
          Ia.SystemProgram.transfer({ fromPubkey: t.publicKey, toPubkey: l, lamports: r }),
          (0, Uie.createSyncNativeInstruction)(l, o)
        );
      return yield (0, Ia.sendAndConfirmTransaction)(e, d, [t], s), l;
    }
    const c = yield (0, R2.getMinimumBalanceForRentExemptAccount)(e),
      u = new Ia.Transaction().add(
        Ia.SystemProgram.createAccount({
          fromPubkey: t.publicKey,
          newAccountPubkey: i.publicKey,
          space: R2.ACCOUNT_SIZE,
          lamports: c,
          programId: o,
        }),
        Ia.SystemProgram.transfer({ fromPubkey: t.publicKey, toPubkey: i.publicKey, lamports: r }),
        (0, Lie.createInitializeAccountInstruction)(i.publicKey, a, n, o)
      );
    return yield (0, Ia.sendAndConfirmTransaction)(e, u, [t, i], s), i.publicKey;
  });
}
Om.createWrappedNativeAccount = zie;
var Bm = {},
  Dm = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeFreezeAccountInstructionUnchecked =
      e.decodeFreezeAccountInstruction =
      e.createFreezeAccountInstruction =
      e.freezeAccountInstructionData =
        void 0);
  const t = Ze,
    n = ne,
    r = Ce,
    i = Me,
    s = cn,
    o = ft;
  e.freezeAccountInstructionData = (0, t.struct)([(0, t.u8)('instruction')]);
  function a(l, d, f, h = [], p = r.TOKEN_PROGRAM_ID) {
    const b = (0, s.addSigners)(
        [
          { pubkey: l, isSigner: !1, isWritable: !0 },
          { pubkey: d, isSigner: !1, isWritable: !1 },
        ],
        f,
        h
      ),
      w = z.alloc(e.freezeAccountInstructionData.span);
    return (
      e.freezeAccountInstructionData.encode({ instruction: o.TokenInstruction.FreezeAccount }, w),
      new n.TransactionInstruction({ keys: b, programId: p, data: w })
    );
  }
  e.createFreezeAccountInstruction = a;
  function c(l, d = r.TOKEN_PROGRAM_ID) {
    if (!l.programId.equals(d)) throw new i.TokenInvalidInstructionProgramError();
    if (l.data.length !== e.freezeAccountInstructionData.span)
      throw new i.TokenInvalidInstructionDataError();
    const {
      keys: { account: f, mint: h, authority: p, multiSigners: b },
      data: w,
    } = u(l);
    if (w.instruction !== o.TokenInstruction.FreezeAccount)
      throw new i.TokenInvalidInstructionTypeError();
    if (!f || !h || !p) throw new i.TokenInvalidInstructionKeysError();
    return { programId: d, keys: { account: f, mint: h, authority: p, multiSigners: b }, data: w };
  }
  e.decodeFreezeAccountInstruction = c;
  function u({ programId: l, keys: [d, f, h, ...p], data: b }) {
    return {
      programId: l,
      keys: { account: d, mint: f, authority: h, multiSigners: p },
      data: e.freezeAccountInstructionData.decode(b),
    };
  }
  e.decodeFreezeAccountInstructionUnchecked = u;
})(Dm);
var Kie =
  (m && m.__awaiter) ||
  function (e, t, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(l) {
        try {
          u(r.next(l));
        } catch (d) {
          o(d);
        }
      }
      function c(l) {
        try {
          u(r.throw(l));
        } catch (d) {
          o(d);
        }
      }
      function u(l) {
        l.done ? s(l.value) : i(l.value).then(a, c);
      }
      u((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(Bm, '__esModule', { value: !0 });
Bm.freezeAccount = void 0;
const N2 = ne,
  Vie = Ce,
  Wie = Dm,
  Hie = ln;
function Gie(e, t, n, r, i, s = [], o, a = Vie.TOKEN_PROGRAM_ID) {
  return Kie(this, void 0, void 0, function* () {
    const [c, u] = (0, Hie.getSigners)(i, s),
      l = new N2.Transaction().add((0, Wie.createFreezeAccountInstruction)(n, r, c, s, a));
    return yield (0, N2.sendAndConfirmTransaction)(e, l, [t, ...u], o);
  });
}
Bm.freezeAccount = Gie;
var Rm = {},
  qie =
    (m && m.__awaiter) ||
    function (e, t, n, r) {
      function i(s) {
        return s instanceof n
          ? s
          : new n(function (o) {
              o(s);
            });
      }
      return new (n || (n = Promise))(function (s, o) {
        function a(l) {
          try {
            u(r.next(l));
          } catch (d) {
            o(d);
          }
        }
        function c(l) {
          try {
            u(r.throw(l));
          } catch (d) {
            o(d);
          }
        }
        function u(l) {
          l.done ? s(l.value) : i(l.value).then(a, c);
        }
        u((r = r.apply(e, t || [])).next());
      });
    };
Object.defineProperty(Rm, '__esModule', { value: !0 });
Rm.getOrCreateAssociatedTokenAccount = void 0;
const j2 = ne,
  L2 = Ce,
  sg = Me,
  Yie = vs,
  U2 = lp(),
  Zie = Sa();
function Jie(
  e,
  t,
  n,
  r,
  i = !1,
  s,
  o,
  a = L2.TOKEN_PROGRAM_ID,
  c = L2.ASSOCIATED_TOKEN_PROGRAM_ID
) {
  return qie(this, void 0, void 0, function* () {
    const u = yield (0, Zie.getAssociatedTokenAddress)(n, r, i, a, c);
    let l;
    try {
      l = yield (0, U2.getAccount)(e, u, s, a);
    } catch (d) {
      if (
        d instanceof sg.TokenAccountNotFoundError ||
        d instanceof sg.TokenInvalidAccountOwnerError
      ) {
        try {
          const f = new j2.Transaction().add(
            (0, Yie.createAssociatedTokenAccountInstruction)(t.publicKey, u, r, n, a, c)
          );
          yield (0, j2.sendAndConfirmTransaction)(e, f, [t], o);
        } catch {}
        l = yield (0, U2.getAccount)(e, u, s, a);
      } else throw d;
    }
    if (!l.mint.equals(n)) throw new sg.TokenInvalidMintError();
    if (!l.owner.equals(r)) throw new sg.TokenInvalidOwnerError();
    return l;
  });
}
Rm.getOrCreateAssociatedTokenAccount = Jie;
var Nm = {},
  jm = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeMintToInstructionUnchecked =
      e.decodeMintToInstruction =
      e.createMintToInstruction =
      e.mintToInstructionData =
        void 0);
  const t = Ze,
    n = Rt,
    r = ne,
    i = Ce,
    s = Me,
    o = cn,
    a = ft;
  e.mintToInstructionData = (0, t.struct)([(0, t.u8)('instruction'), (0, n.u64)('amount')]);
  function c(d, f, h, p, b = [], w = i.TOKEN_PROGRAM_ID) {
    const A = (0, o.addSigners)(
        [
          { pubkey: d, isSigner: !1, isWritable: !0 },
          { pubkey: f, isSigner: !1, isWritable: !0 },
        ],
        h,
        b
      ),
      _ = z.alloc(e.mintToInstructionData.span);
    return (
      e.mintToInstructionData.encode(
        { instruction: a.TokenInstruction.MintTo, amount: BigInt(p) },
        _
      ),
      new r.TransactionInstruction({ keys: A, programId: w, data: _ })
    );
  }
  e.createMintToInstruction = c;
  function u(d, f = i.TOKEN_PROGRAM_ID) {
    if (!d.programId.equals(f)) throw new s.TokenInvalidInstructionProgramError();
    if (d.data.length !== e.mintToInstructionData.span)
      throw new s.TokenInvalidInstructionDataError();
    const {
      keys: { mint: h, destination: p, authority: b, multiSigners: w },
      data: A,
    } = l(d);
    if (A.instruction !== a.TokenInstruction.MintTo) throw new s.TokenInvalidInstructionTypeError();
    if (!h || !p || !b) throw new s.TokenInvalidInstructionKeysError();
    return {
      programId: f,
      keys: { mint: h, destination: p, authority: b, multiSigners: w },
      data: A,
    };
  }
  e.decodeMintToInstruction = u;
  function l({ programId: d, keys: [f, h, p, ...b], data: w }) {
    return {
      programId: d,
      keys: { mint: f, destination: h, authority: p, multiSigners: b },
      data: e.mintToInstructionData.decode(w),
    };
  }
  e.decodeMintToInstructionUnchecked = l;
})(jm);
var Xie =
  (m && m.__awaiter) ||
  function (e, t, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(l) {
        try {
          u(r.next(l));
        } catch (d) {
          o(d);
        }
      }
      function c(l) {
        try {
          u(r.throw(l));
        } catch (d) {
          o(d);
        }
      }
      function u(l) {
        l.done ? s(l.value) : i(l.value).then(a, c);
      }
      u((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(Nm, '__esModule', { value: !0 });
Nm.mintTo = void 0;
const $2 = ne,
  Qie = Ce,
  ese = jm,
  tse = ln;
function nse(e, t, n, r, i, s, o = [], a, c = Qie.TOKEN_PROGRAM_ID) {
  return Xie(this, void 0, void 0, function* () {
    const [u, l] = (0, tse.getSigners)(i, o),
      d = new $2.Transaction().add((0, ese.createMintToInstruction)(n, r, u, s, o, c));
    return yield (0, $2.sendAndConfirmTransaction)(e, d, [t, ...l], a);
  });
}
Nm.mintTo = nse;
var Lm = {},
  Um = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeMintToCheckedInstructionUnchecked =
      e.decodeMintToCheckedInstruction =
      e.createMintToCheckedInstruction =
      e.mintToCheckedInstructionData =
        void 0);
  const t = Ze,
    n = Rt,
    r = ne,
    i = Ce,
    s = Me,
    o = cn,
    a = ft;
  e.mintToCheckedInstructionData = (0, t.struct)([
    (0, t.u8)('instruction'),
    (0, n.u64)('amount'),
    (0, t.u8)('decimals'),
  ]);
  function c(d, f, h, p, b, w = [], A = i.TOKEN_PROGRAM_ID) {
    const _ = (0, o.addSigners)(
        [
          { pubkey: d, isSigner: !1, isWritable: !0 },
          { pubkey: f, isSigner: !1, isWritable: !0 },
        ],
        h,
        w
      ),
      x = z.alloc(e.mintToCheckedInstructionData.span);
    return (
      e.mintToCheckedInstructionData.encode(
        { instruction: a.TokenInstruction.MintToChecked, amount: BigInt(p), decimals: b },
        x
      ),
      new r.TransactionInstruction({ keys: _, programId: A, data: x })
    );
  }
  e.createMintToCheckedInstruction = c;
  function u(d, f = i.TOKEN_PROGRAM_ID) {
    if (!d.programId.equals(f)) throw new s.TokenInvalidInstructionProgramError();
    if (d.data.length !== e.mintToCheckedInstructionData.span)
      throw new s.TokenInvalidInstructionDataError();
    const {
      keys: { mint: h, destination: p, authority: b, multiSigners: w },
      data: A,
    } = l(d);
    if (A.instruction !== a.TokenInstruction.MintToChecked)
      throw new s.TokenInvalidInstructionTypeError();
    if (!h || !p || !b) throw new s.TokenInvalidInstructionKeysError();
    return {
      programId: f,
      keys: { mint: h, destination: p, authority: b, multiSigners: w },
      data: A,
    };
  }
  e.decodeMintToCheckedInstruction = u;
  function l({ programId: d, keys: [f, h, p, ...b], data: w }) {
    return {
      programId: d,
      keys: { mint: f, destination: h, authority: p, multiSigners: b },
      data: e.mintToCheckedInstructionData.decode(w),
    };
  }
  e.decodeMintToCheckedInstructionUnchecked = l;
})(Um);
var rse =
  (m && m.__awaiter) ||
  function (e, t, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(l) {
        try {
          u(r.next(l));
        } catch (d) {
          o(d);
        }
      }
      function c(l) {
        try {
          u(r.throw(l));
        } catch (d) {
          o(d);
        }
      }
      function u(l) {
        l.done ? s(l.value) : i(l.value).then(a, c);
      }
      u((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(Lm, '__esModule', { value: !0 });
Lm.mintToChecked = void 0;
const F2 = ne,
  ise = Ce,
  sse = Um,
  ose = ln;
function ase(e, t, n, r, i, s, o, a = [], c, u = ise.TOKEN_PROGRAM_ID) {
  return rse(this, void 0, void 0, function* () {
    const [l, d] = (0, ose.getSigners)(i, a),
      f = new F2.Transaction().add((0, sse.createMintToCheckedInstruction)(n, r, l, s, o, a, u));
    return yield (0, F2.sendAndConfirmTransaction)(e, f, [t, ...d], c);
  });
}
Lm.mintToChecked = ase;
var $m = {},
  Fm = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeRevokeInstructionUnchecked =
      e.decodeRevokeInstruction =
      e.createRevokeInstruction =
      e.revokeInstructionData =
        void 0);
  const t = Ze,
    n = ne,
    r = Ce,
    i = Me,
    s = cn,
    o = ft;
  e.revokeInstructionData = (0, t.struct)([(0, t.u8)('instruction')]);
  function a(l, d, f = [], h = r.TOKEN_PROGRAM_ID) {
    const p = (0, s.addSigners)([{ pubkey: l, isSigner: !1, isWritable: !0 }], d, f),
      b = z.alloc(e.revokeInstructionData.span);
    return (
      e.revokeInstructionData.encode({ instruction: o.TokenInstruction.Revoke }, b),
      new n.TransactionInstruction({ keys: p, programId: h, data: b })
    );
  }
  e.createRevokeInstruction = a;
  function c(l, d = r.TOKEN_PROGRAM_ID) {
    if (!l.programId.equals(d)) throw new i.TokenInvalidInstructionProgramError();
    if (l.data.length !== e.revokeInstructionData.span)
      throw new i.TokenInvalidInstructionDataError();
    const {
      keys: { account: f, owner: h, multiSigners: p },
      data: b,
    } = u(l);
    if (b.instruction !== o.TokenInstruction.Revoke) throw new i.TokenInvalidInstructionTypeError();
    if (!f || !h) throw new i.TokenInvalidInstructionKeysError();
    return { programId: d, keys: { account: f, owner: h, multiSigners: p }, data: b };
  }
  e.decodeRevokeInstruction = c;
  function u({ programId: l, keys: [d, f, ...h], data: p }) {
    return {
      programId: l,
      keys: { account: d, owner: f, multiSigners: h },
      data: e.revokeInstructionData.decode(p),
    };
  }
  e.decodeRevokeInstructionUnchecked = u;
})(Fm);
var cse =
  (m && m.__awaiter) ||
  function (e, t, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(l) {
        try {
          u(r.next(l));
        } catch (d) {
          o(d);
        }
      }
      function c(l) {
        try {
          u(r.throw(l));
        } catch (d) {
          o(d);
        }
      }
      function u(l) {
        l.done ? s(l.value) : i(l.value).then(a, c);
      }
      u((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty($m, '__esModule', { value: !0 });
$m.revoke = void 0;
const z2 = ne,
  use = Ce,
  lse = Fm,
  dse = ln;
function fse(e, t, n, r, i = [], s, o = use.TOKEN_PROGRAM_ID) {
  return cse(this, void 0, void 0, function* () {
    const [a, c] = (0, dse.getSigners)(r, i),
      u = new z2.Transaction().add((0, lse.createRevokeInstruction)(n, a, i, o));
    return yield (0, z2.sendAndConfirmTransaction)(e, u, [t, ...c], s);
  });
}
$m.revoke = fse;
var zm = {},
  Km = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeSetAuthorityInstructionUnchecked =
      e.decodeSetAuthorityInstruction =
      e.createSetAuthorityInstruction =
      e.setAuthorityInstructionData =
      e.AuthorityType =
        void 0);
  const t = Ze,
    n = Rt,
    r = ne,
    i = Ce,
    s = Me,
    o = cn,
    a = ft;
  (function (d) {
    (d[(d.MintTokens = 0)] = 'MintTokens'),
      (d[(d.FreezeAccount = 1)] = 'FreezeAccount'),
      (d[(d.AccountOwner = 2)] = 'AccountOwner'),
      (d[(d.CloseAccount = 3)] = 'CloseAccount');
  })(e.AuthorityType || (e.AuthorityType = {})),
    (e.setAuthorityInstructionData = (0, t.struct)([
      (0, t.u8)('instruction'),
      (0, t.u8)('authorityType'),
      (0, t.u8)('newAuthorityOption'),
      (0, n.publicKey)('newAuthority'),
    ]));
  function c(d, f, h, p, b = [], w = i.TOKEN_PROGRAM_ID) {
    const A = (0, o.addSigners)([{ pubkey: d, isSigner: !1, isWritable: !0 }], f, b),
      _ = z.alloc(e.setAuthorityInstructionData.span);
    return (
      e.setAuthorityInstructionData.encode(
        {
          instruction: a.TokenInstruction.SetAuthority,
          authorityType: h,
          newAuthorityOption: p ? 1 : 0,
          newAuthority: p || new r.PublicKey(0),
        },
        _
      ),
      new r.TransactionInstruction({ keys: A, programId: w, data: _ })
    );
  }
  e.createSetAuthorityInstruction = c;
  function u(d, f = i.TOKEN_PROGRAM_ID) {
    if (!d.programId.equals(f)) throw new s.TokenInvalidInstructionProgramError();
    if (d.data.length !== e.setAuthorityInstructionData.span)
      throw new s.TokenInvalidInstructionDataError();
    const {
      keys: { account: h, currentAuthority: p, multiSigners: b },
      data: w,
    } = l(d);
    if (w.instruction !== a.TokenInstruction.SetAuthority)
      throw new s.TokenInvalidInstructionTypeError();
    if (!h || !p) throw new s.TokenInvalidInstructionKeysError();
    return { programId: f, keys: { account: h, currentAuthority: p, multiSigners: b }, data: w };
  }
  e.decodeSetAuthorityInstruction = u;
  function l({ programId: d, keys: [f, h, ...p], data: b }) {
    const {
      instruction: w,
      authorityType: A,
      newAuthorityOption: _,
      newAuthority: x,
    } = e.setAuthorityInstructionData.decode(b);
    return {
      programId: d,
      keys: { account: f, currentAuthority: h, multiSigners: p },
      data: { instruction: w, authorityType: A, newAuthority: _ ? x : null },
    };
  }
  e.decodeSetAuthorityInstructionUnchecked = l;
})(Km);
var hse =
  (m && m.__awaiter) ||
  function (e, t, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(l) {
        try {
          u(r.next(l));
        } catch (d) {
          o(d);
        }
      }
      function c(l) {
        try {
          u(r.throw(l));
        } catch (d) {
          o(d);
        }
      }
      function u(l) {
        l.done ? s(l.value) : i(l.value).then(a, c);
      }
      u((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(zm, '__esModule', { value: !0 });
zm.setAuthority = void 0;
const K2 = ne,
  pse = Ce,
  gse = Km,
  yse = ln;
function bse(e, t, n, r, i, s, o = [], a, c = pse.TOKEN_PROGRAM_ID) {
  return hse(this, void 0, void 0, function* () {
    const [u, l] = (0, yse.getSigners)(r, o),
      d = new K2.Transaction().add((0, gse.createSetAuthorityInstruction)(n, u, i, s, o, c));
    return yield (0, K2.sendAndConfirmTransaction)(e, d, [t, ...l], a);
  });
}
zm.setAuthority = bse;
var Vm = {},
  mse =
    (m && m.__awaiter) ||
    function (e, t, n, r) {
      function i(s) {
        return s instanceof n
          ? s
          : new n(function (o) {
              o(s);
            });
      }
      return new (n || (n = Promise))(function (s, o) {
        function a(l) {
          try {
            u(r.next(l));
          } catch (d) {
            o(d);
          }
        }
        function c(l) {
          try {
            u(r.throw(l));
          } catch (d) {
            o(d);
          }
        }
        function u(l) {
          l.done ? s(l.value) : i(l.value).then(a, c);
        }
        u((r = r.apply(e, t || [])).next());
      });
    };
Object.defineProperty(Vm, '__esModule', { value: !0 });
Vm.syncNative = void 0;
const V2 = ne,
  wse = Ce,
  vse = hp;
function _se(e, t, n, r, i = wse.TOKEN_PROGRAM_ID) {
  return mse(this, void 0, void 0, function* () {
    const s = new V2.Transaction().add((0, vse.createSyncNativeInstruction)(n, i));
    return yield (0, V2.sendAndConfirmTransaction)(e, s, [t], r);
  });
}
Vm.syncNative = _se;
var Wm = {},
  Hm = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeThawAccountInstructionUnchecked =
      e.decodeThawAccountInstruction =
      e.createThawAccountInstruction =
      e.thawAccountInstructionData =
        void 0);
  const t = Ze,
    n = ne,
    r = Ce,
    i = Me,
    s = cn,
    o = ft;
  e.thawAccountInstructionData = (0, t.struct)([(0, t.u8)('instruction')]);
  function a(l, d, f, h = [], p = r.TOKEN_PROGRAM_ID) {
    const b = (0, s.addSigners)(
        [
          { pubkey: l, isSigner: !1, isWritable: !0 },
          { pubkey: d, isSigner: !1, isWritable: !1 },
        ],
        f,
        h
      ),
      w = z.alloc(e.thawAccountInstructionData.span);
    return (
      e.thawAccountInstructionData.encode({ instruction: o.TokenInstruction.ThawAccount }, w),
      new n.TransactionInstruction({ keys: b, programId: p, data: w })
    );
  }
  e.createThawAccountInstruction = a;
  function c(l, d = r.TOKEN_PROGRAM_ID) {
    if (!l.programId.equals(d)) throw new i.TokenInvalidInstructionProgramError();
    if (l.data.length !== e.thawAccountInstructionData.span)
      throw new i.TokenInvalidInstructionDataError();
    const {
      keys: { account: f, mint: h, authority: p, multiSigners: b },
      data: w,
    } = u(l);
    if (w.instruction !== o.TokenInstruction.ThawAccount)
      throw new i.TokenInvalidInstructionTypeError();
    if (!f || !h || !p) throw new i.TokenInvalidInstructionKeysError();
    return { programId: d, keys: { account: f, mint: h, authority: p, multiSigners: b }, data: w };
  }
  e.decodeThawAccountInstruction = c;
  function u({ programId: l, keys: [d, f, h, ...p], data: b }) {
    return {
      programId: l,
      keys: { account: d, mint: f, authority: h, multiSigners: p },
      data: e.thawAccountInstructionData.decode(b),
    };
  }
  e.decodeThawAccountInstructionUnchecked = u;
})(Hm);
var Sse =
  (m && m.__awaiter) ||
  function (e, t, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(l) {
        try {
          u(r.next(l));
        } catch (d) {
          o(d);
        }
      }
      function c(l) {
        try {
          u(r.throw(l));
        } catch (d) {
          o(d);
        }
      }
      function u(l) {
        l.done ? s(l.value) : i(l.value).then(a, c);
      }
      u((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(Wm, '__esModule', { value: !0 });
Wm.thawAccount = void 0;
const W2 = ne,
  Ese = Ce,
  Ase = Hm,
  Ise = ln;
function Tse(e, t, n, r, i, s = [], o, a = Ese.TOKEN_PROGRAM_ID) {
  return Sse(this, void 0, void 0, function* () {
    const [c, u] = (0, Ise.getSigners)(i, s),
      l = new W2.Transaction().add((0, Ase.createThawAccountInstruction)(n, r, c, s, a));
    return yield (0, W2.sendAndConfirmTransaction)(e, l, [t, ...u], o);
  });
}
Wm.thawAccount = Tse;
var Gm = {},
  qm = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeTransferInstructionUnchecked =
      e.decodeTransferInstruction =
      e.createTransferInstruction =
      e.transferInstructionData =
        void 0);
  const t = Ze,
    n = Rt,
    r = ne,
    i = Ce,
    s = Me,
    o = cn,
    a = ft;
  e.transferInstructionData = (0, t.struct)([(0, t.u8)('instruction'), (0, n.u64)('amount')]);
  function c(d, f, h, p, b = [], w = i.TOKEN_PROGRAM_ID) {
    const A = (0, o.addSigners)(
        [
          { pubkey: d, isSigner: !1, isWritable: !0 },
          { pubkey: f, isSigner: !1, isWritable: !0 },
        ],
        h,
        b
      ),
      _ = z.alloc(e.transferInstructionData.span);
    return (
      e.transferInstructionData.encode(
        { instruction: a.TokenInstruction.Transfer, amount: BigInt(p) },
        _
      ),
      new r.TransactionInstruction({ keys: A, programId: w, data: _ })
    );
  }
  e.createTransferInstruction = c;
  function u(d, f = i.TOKEN_PROGRAM_ID) {
    if (!d.programId.equals(f)) throw new s.TokenInvalidInstructionProgramError();
    if (d.data.length !== e.transferInstructionData.span)
      throw new s.TokenInvalidInstructionDataError();
    const {
      keys: { source: h, destination: p, owner: b, multiSigners: w },
      data: A,
    } = l(d);
    if (A.instruction !== a.TokenInstruction.Transfer)
      throw new s.TokenInvalidInstructionTypeError();
    if (!h || !p || !b) throw new s.TokenInvalidInstructionKeysError();
    return {
      programId: f,
      keys: { source: h, destination: p, owner: b, multiSigners: w },
      data: A,
    };
  }
  e.decodeTransferInstruction = u;
  function l({ programId: d, keys: [f, h, p, ...b], data: w }) {
    return {
      programId: d,
      keys: { source: f, destination: h, owner: p, multiSigners: b },
      data: e.transferInstructionData.decode(w),
    };
  }
  e.decodeTransferInstructionUnchecked = l;
})(qm);
var xse =
  (m && m.__awaiter) ||
  function (e, t, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(l) {
        try {
          u(r.next(l));
        } catch (d) {
          o(d);
        }
      }
      function c(l) {
        try {
          u(r.throw(l));
        } catch (d) {
          o(d);
        }
      }
      function u(l) {
        l.done ? s(l.value) : i(l.value).then(a, c);
      }
      u((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(Gm, '__esModule', { value: !0 });
Gm.transfer = void 0;
const H2 = ne,
  kse = Ce,
  Cse = qm,
  Pse = ln;
function Mse(e, t, n, r, i, s, o = [], a, c = kse.TOKEN_PROGRAM_ID) {
  return xse(this, void 0, void 0, function* () {
    const [u, l] = (0, Pse.getSigners)(i, o),
      d = new H2.Transaction().add((0, Cse.createTransferInstruction)(n, r, u, s, o, c));
    return yield (0, H2.sendAndConfirmTransaction)(e, d, [t, ...l], a);
  });
}
Gm.transfer = Mse;
var Ym = {},
  Zm = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeTransferCheckedInstructionUnchecked =
      e.decodeTransferCheckedInstruction =
      e.createTransferCheckedInstruction =
      e.transferCheckedInstructionData =
        void 0);
  const t = Ze,
    n = Rt,
    r = ne,
    i = Ce,
    s = Me,
    o = cn,
    a = ft;
  e.transferCheckedInstructionData = (0, t.struct)([
    (0, t.u8)('instruction'),
    (0, n.u64)('amount'),
    (0, t.u8)('decimals'),
  ]);
  function c(d, f, h, p, b, w, A = [], _ = i.TOKEN_PROGRAM_ID) {
    const x = (0, o.addSigners)(
        [
          { pubkey: d, isSigner: !1, isWritable: !0 },
          { pubkey: f, isSigner: !1, isWritable: !1 },
          { pubkey: h, isSigner: !1, isWritable: !0 },
        ],
        p,
        A
      ),
      k = z.alloc(e.transferCheckedInstructionData.span);
    return (
      e.transferCheckedInstructionData.encode(
        { instruction: a.TokenInstruction.TransferChecked, amount: BigInt(b), decimals: w },
        k
      ),
      new r.TransactionInstruction({ keys: x, programId: _, data: k })
    );
  }
  e.createTransferCheckedInstruction = c;
  function u(d, f = i.TOKEN_PROGRAM_ID) {
    if (!d.programId.equals(f)) throw new s.TokenInvalidInstructionProgramError();
    if (d.data.length !== e.transferCheckedInstructionData.span)
      throw new s.TokenInvalidInstructionDataError();
    const {
      keys: { source: h, mint: p, destination: b, owner: w, multiSigners: A },
      data: _,
    } = l(d);
    if (_.instruction !== a.TokenInstruction.TransferChecked)
      throw new s.TokenInvalidInstructionTypeError();
    if (!h || !p || !b || !w) throw new s.TokenInvalidInstructionKeysError();
    return {
      programId: f,
      keys: { source: h, mint: p, destination: b, owner: w, multiSigners: A },
      data: _,
    };
  }
  e.decodeTransferCheckedInstruction = u;
  function l({ programId: d, keys: [f, h, p, b, ...w], data: A }) {
    return {
      programId: d,
      keys: { source: f, mint: h, destination: p, owner: b, multiSigners: w },
      data: e.transferCheckedInstructionData.decode(A),
    };
  }
  e.decodeTransferCheckedInstructionUnchecked = l;
})(Zm);
var Ose =
  (m && m.__awaiter) ||
  function (e, t, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(l) {
        try {
          u(r.next(l));
        } catch (d) {
          o(d);
        }
      }
      function c(l) {
        try {
          u(r.throw(l));
        } catch (d) {
          o(d);
        }
      }
      function u(l) {
        l.done ? s(l.value) : i(l.value).then(a, c);
      }
      u((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(Ym, '__esModule', { value: !0 });
Ym.transferChecked = void 0;
const G2 = ne,
  Bse = Ce,
  Dse = Zm,
  Rse = ln;
function Nse(e, t, n, r, i, s, o, a, c = [], u, l = Bse.TOKEN_PROGRAM_ID) {
  return Ose(this, void 0, void 0, function* () {
    const [d, f] = (0, Rse.getSigners)(s, c),
      h = new G2.Transaction().add(
        (0, Dse.createTransferCheckedInstruction)(n, r, i, d, o, a, c, l)
      );
    return yield (0, G2.sendAndConfirmTransaction)(e, h, [t, ...f], u);
  });
}
Ym.transferChecked = Nse;
var Jm = {},
  gs = {};
Object.defineProperty(gs, '__esModule', { value: !0 });
gs.decodeUiAmountToAmountInstructionUnchecked =
  gs.decodeUiAmountToAmountInstruction =
  gs.createUiAmountToAmountInstruction =
    void 0;
const no = Ze,
  jse = ne,
  eD = Ce,
  og = Me,
  tD = ft;
function Lse(e, t, n = eD.TOKEN_PROGRAM_ID) {
  const r = [{ pubkey: e, isSigner: !1, isWritable: !1 }],
    i = z.from(t, 'utf8'),
    s = (0, no.struct)([(0, no.u8)('instruction'), (0, no.blob)(i.length, 'amount')]),
    o = z.alloc(s.span);
  return (
    s.encode({ instruction: tD.TokenInstruction.UiAmountToAmount, amount: i }, o),
    new jse.TransactionInstruction({ keys: r, programId: n, data: o })
  );
}
gs.createUiAmountToAmountInstruction = Lse;
function Use(e, t = eD.TOKEN_PROGRAM_ID) {
  if (!e.programId.equals(t)) throw new og.TokenInvalidInstructionProgramError();
  const n = (0, no.struct)([(0, no.u8)('instruction'), (0, no.blob)(e.data.length - 1, 'amount')]);
  if (e.data.length !== n.span) throw new og.TokenInvalidInstructionDataError();
  const {
    keys: { mint: r },
    data: i,
  } = nD(e);
  if (i.instruction !== tD.TokenInstruction.UiAmountToAmount)
    throw new og.TokenInvalidInstructionTypeError();
  if (!r) throw new og.TokenInvalidInstructionKeysError();
  return { programId: t, keys: { mint: r }, data: i };
}
gs.decodeUiAmountToAmountInstruction = Use;
function nD({ programId: e, keys: [t], data: n }) {
  const r = (0, no.struct)([(0, no.u8)('instruction'), (0, no.blob)(n.length - 1, 'amount')]);
  return { programId: e, keys: { mint: t }, data: r.decode(n) };
}
gs.decodeUiAmountToAmountInstructionUnchecked = nD;
var $se =
  (m && m.__awaiter) ||
  function (e, t, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(l) {
        try {
          u(r.next(l));
        } catch (d) {
          o(d);
        }
      }
      function c(l) {
        try {
          u(r.throw(l));
        } catch (d) {
          o(d);
        }
      }
      function u(l) {
        l.done ? s(l.value) : i(l.value).then(a, c);
      }
      u((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(Jm, '__esModule', { value: !0 });
Jm.uiAmountToAmount = void 0;
const Fse = Rt,
  zse = ne,
  Kse = Ce,
  Vse = gs;
function Wse(e, t, n, r, i = Kse.TOKEN_PROGRAM_ID) {
  return $se(this, void 0, void 0, function* () {
    const s = new zse.Transaction().add((0, Vse.createUiAmountToAmountInstruction)(n, r, i)),
      { returnData: o, err: a } = (yield e.simulateTransaction(s, [t], !1)).value;
    if (o) {
      const c = z.from(o.data[0], o.data[1]);
      return (0, Fse.u64)().decode(c);
    }
    return a;
  });
}
Jm.uiAmountToAmount = Wse;
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (r, i, s, o) {
            o === void 0 && (o = s);
            var a = Object.getOwnPropertyDescriptor(i, s);
            (!a || ('get' in a ? !i.__esModule : a.writable || a.configurable)) &&
              (a = {
                enumerable: !0,
                get: function () {
                  return i[s];
                },
              }),
              Object.defineProperty(r, o, a);
          }
        : function (r, i, s, o) {
            o === void 0 && (o = s), (r[o] = i[s]);
          }),
    n =
      (m && m.__exportStar) ||
      function (r, i) {
        for (var s in r)
          s !== 'default' && !Object.prototype.hasOwnProperty.call(i, s) && t(i, r, s);
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    n(dm, e),
    n(hm, e),
    n(gm, e),
    n(bm, e),
    n(wm, e),
    n(_m, e),
    n(cp, e),
    n(fp, e),
    n(Tm, e),
    n(xm, e),
    n(Cm, e),
    n(Mm, e),
    n(Om, e),
    n(Bm, e),
    n(Rm, e),
    n(Nm, e),
    n(Lm, e),
    n($m, e),
    n(zm, e),
    n(Vm, e),
    n(Wm, e),
    n(Gm, e),
    n(Ym, e),
    n(Jm, e);
})(OB);
var rD = {},
  iD = {},
  Pu = {},
  Xm = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeInitializeMintInstructionUnchecked =
      e.decodeInitializeMintInstruction =
      e.createInitializeMintInstruction =
      e.initializeMintInstructionData =
        void 0);
  const t = Ze,
    n = Rt,
    r = ne,
    i = Ce,
    s = Me,
    o = ft;
  e.initializeMintInstructionData = (0, t.struct)([
    (0, t.u8)('instruction'),
    (0, t.u8)('decimals'),
    (0, n.publicKey)('mintAuthority'),
    (0, t.u8)('freezeAuthorityOption'),
    (0, n.publicKey)('freezeAuthority'),
  ]);
  function a(l, d, f, h, p = i.TOKEN_PROGRAM_ID) {
    const b = [
        { pubkey: l, isSigner: !1, isWritable: !0 },
        { pubkey: r.SYSVAR_RENT_PUBKEY, isSigner: !1, isWritable: !1 },
      ],
      w = z.alloc(e.initializeMintInstructionData.span);
    return (
      e.initializeMintInstructionData.encode(
        {
          instruction: o.TokenInstruction.InitializeMint,
          decimals: d,
          mintAuthority: f,
          freezeAuthorityOption: h ? 1 : 0,
          freezeAuthority: h || new r.PublicKey(0),
        },
        w
      ),
      new r.TransactionInstruction({ keys: b, programId: p, data: w })
    );
  }
  e.createInitializeMintInstruction = a;
  function c(l, d = i.TOKEN_PROGRAM_ID) {
    if (!l.programId.equals(d)) throw new s.TokenInvalidInstructionProgramError();
    if (l.data.length !== e.initializeMintInstructionData.span)
      throw new s.TokenInvalidInstructionDataError();
    const {
      keys: { mint: f, rent: h },
      data: p,
    } = u(l);
    if (p.instruction !== o.TokenInstruction.InitializeMint)
      throw new s.TokenInvalidInstructionTypeError();
    if (!f || !h) throw new s.TokenInvalidInstructionKeysError();
    return { programId: d, keys: { mint: f, rent: h }, data: p };
  }
  e.decodeInitializeMintInstruction = c;
  function u({ programId: l, keys: [d, f], data: h }) {
    const {
      instruction: p,
      decimals: b,
      mintAuthority: w,
      freezeAuthorityOption: A,
      freezeAuthority: _,
    } = e.initializeMintInstructionData.decode(h);
    return {
      programId: l,
      keys: { mint: d, rent: f },
      data: { instruction: p, decimals: b, mintAuthority: w, freezeAuthority: A ? _ : null },
    };
  }
  e.decodeInitializeMintInstructionUnchecked = u;
})(Xm);
var RI = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createUpdateRateInterestBearingMintInstruction =
      e.createInitializeInterestBearingMintInstruction =
      e.interestBearingMintUpdateRateInstructionData =
      e.interestBearingMintInitializeInstructionData =
      e.InterestBearingMintInstruction =
        void 0);
  const t = Ze,
    n = Rt,
    r = ne,
    i = Ce,
    s = cn,
    o = ft;
  var a;
  (function (l) {
    (l[(l.Initialize = 0)] = 'Initialize'), (l[(l.UpdateRate = 1)] = 'UpdateRate');
  })((a = e.InterestBearingMintInstruction || (e.InterestBearingMintInstruction = {}))),
    (e.interestBearingMintInitializeInstructionData = (0, t.struct)([
      (0, t.u8)('instruction'),
      (0, t.u8)('interestBearingMintInstruction'),
      (0, n.publicKey)('rateAuthority'),
      (0, t.s16)('rate'),
    ])),
    (e.interestBearingMintUpdateRateInstructionData = (0, t.struct)([
      (0, t.u8)('instruction'),
      (0, t.u8)('interestBearingMintInstruction'),
      (0, t.s16)('rate'),
    ]));
  function c(l, d, f, h = i.TOKEN_2022_PROGRAM_ID) {
    const p = [{ pubkey: l, isSigner: !1, isWritable: !0 }],
      b = z.alloc(e.interestBearingMintInitializeInstructionData.span);
    return (
      e.interestBearingMintInitializeInstructionData.encode(
        {
          instruction: o.TokenInstruction.InterestBearingMintExtension,
          interestBearingMintInstruction: a.Initialize,
          rateAuthority: d,
          rate: f,
        },
        b
      ),
      new r.TransactionInstruction({ keys: p, programId: h, data: b })
    );
  }
  e.createInitializeInterestBearingMintInstruction = c;
  function u(l, d, f, h = [], p = i.TOKEN_2022_PROGRAM_ID) {
    const b = (0, s.addSigners)(
        [
          { pubkey: l, isSigner: !1, isWritable: !0 },
          { pubkey: d, isSigner: !h.length, isWritable: !1 },
        ],
        d,
        h
      ),
      w = z.alloc(e.interestBearingMintUpdateRateInstructionData.span);
    return (
      e.interestBearingMintUpdateRateInstructionData.encode(
        {
          instruction: o.TokenInstruction.InterestBearingMintExtension,
          interestBearingMintInstruction: a.UpdateRate,
          rate: f,
        },
        w
      ),
      new r.TransactionInstruction({ keys: b, programId: p, data: w })
    );
  }
  e.createUpdateRateInterestBearingMintInstruction = u;
})(RI);
var sD =
  (m && m.__awaiter) ||
  function (e, t, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(l) {
        try {
          u(r.next(l));
        } catch (d) {
          o(d);
        }
      }
      function c(l) {
        try {
          u(r.throw(l));
        } catch (d) {
          o(d);
        }
      }
      function u(l) {
        l.done ? s(l.value) : i(l.value).then(a, c);
      }
      u((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(Pu, '__esModule', { value: !0 });
Pu.updateRateInterestBearingMint = Pu.createInterestBearingMint = void 0;
const Zc = ne,
  Hse = ln,
  oD = Ce,
  Gse = Xm,
  q2 = Br(),
  aD = RI;
function qse(e, t, n, r, i, s, o, a = Zc.Keypair.generate(), c, u = oD.TOKEN_2022_PROGRAM_ID) {
  return sD(this, void 0, void 0, function* () {
    const l = (0, q2.getMintLen)([q2.ExtensionType.InterestBearingConfig]),
      d = yield e.getMinimumBalanceForRentExemption(l),
      f = new Zc.Transaction().add(
        Zc.SystemProgram.createAccount({
          fromPubkey: t.publicKey,
          newAccountPubkey: a.publicKey,
          space: l,
          lamports: d,
          programId: u,
        }),
        (0, aD.createInitializeInterestBearingMintInstruction)(a.publicKey, i, s, u),
        (0, Gse.createInitializeMintInstruction)(a.publicKey, o, n, r, u)
      );
    return yield (0, Zc.sendAndConfirmTransaction)(e, f, [t, a], c), a.publicKey;
  });
}
Pu.createInterestBearingMint = qse;
function Yse(e, t, n, r, i, s = [], o, a = oD.TOKEN_2022_PROGRAM_ID) {
  return sD(this, void 0, void 0, function* () {
    const [c, u] = (0, Hse.getSigners)(r, s),
      l = new Zc.Transaction().add(
        (0, aD.createUpdateRateInterestBearingMintInstruction)(n, c, i, u, a)
      );
    return yield (0, Zc.sendAndConfirmTransaction)(e, l, [t, r, ...u], o);
  });
}
Pu.updateRateInterestBearingMint = Yse;
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (r, i, s, o) {
            o === void 0 && (o = s);
            var a = Object.getOwnPropertyDescriptor(i, s);
            (!a || ('get' in a ? !i.__esModule : a.writable || a.configurable)) &&
              (a = {
                enumerable: !0,
                get: function () {
                  return i[s];
                },
              }),
              Object.defineProperty(r, o, a);
          }
        : function (r, i, s, o) {
            o === void 0 && (o = s), (r[o] = i[s]);
          }),
    n =
      (m && m.__exportStar) ||
      function (r, i) {
        for (var s in r)
          s !== 'default' && !Object.prototype.hasOwnProperty.call(i, s) && t(i, r, s);
      };
  Object.defineProperty(e, '__esModule', { value: !0 }), n(Pu, e), n(RI, e), n(KB(), e);
})(iD);
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (r, i, s, o) {
            o === void 0 && (o = s);
            var a = Object.getOwnPropertyDescriptor(i, s);
            (!a || ('get' in a ? !i.__esModule : a.writable || a.configurable)) &&
              (a = {
                enumerable: !0,
                get: function () {
                  return i[s];
                },
              }),
              Object.defineProperty(r, o, a);
          }
        : function (r, i, s, o) {
            o === void 0 && (o = s), (r[o] = i[s]);
          }),
    n =
      (m && m.__exportStar) ||
      function (r, i) {
        for (var s in r)
          s !== 'default' && !Object.prototype.hasOwnProperty.call(i, s) && t(i, r, s);
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    n(up, e),
    n(jB(), e),
    n(FB(), e),
    n(Br(), e),
    n(zB(), e),
    n(iD, e),
    n(qB(), e),
    n(YB(), e),
    n(ZB(), e),
    n(XB(), e),
    n(JB(), e);
})(rD);
var cD = {},
  qe = {},
  NI = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeInitializeAccount2InstructionUnchecked =
      e.decodeInitializeAccount2Instruction =
      e.createInitializeAccount2Instruction =
      e.initializeAccount2InstructionData =
        void 0);
  const t = Ze,
    n = Rt,
    r = ne,
    i = Ce,
    s = Me,
    o = ft;
  e.initializeAccount2InstructionData = (0, t.struct)([
    (0, t.u8)('instruction'),
    (0, n.publicKey)('owner'),
  ]);
  function a(l, d, f, h = i.TOKEN_PROGRAM_ID) {
    const p = [
        { pubkey: l, isSigner: !1, isWritable: !0 },
        { pubkey: d, isSigner: !1, isWritable: !1 },
        { pubkey: r.SYSVAR_RENT_PUBKEY, isSigner: !1, isWritable: !1 },
      ],
      b = z.alloc(e.initializeAccount2InstructionData.span);
    return (
      e.initializeAccount2InstructionData.encode(
        { instruction: o.TokenInstruction.InitializeAccount2, owner: f },
        b
      ),
      new r.TransactionInstruction({ keys: p, programId: h, data: b })
    );
  }
  e.createInitializeAccount2Instruction = a;
  function c(l, d = i.TOKEN_PROGRAM_ID) {
    if (!l.programId.equals(d)) throw new s.TokenInvalidInstructionProgramError();
    if (l.data.length !== e.initializeAccount2InstructionData.span)
      throw new s.TokenInvalidInstructionDataError();
    const {
      keys: { account: f, mint: h, rent: p },
      data: b,
    } = u(l);
    if (b.instruction !== o.TokenInstruction.InitializeAccount2)
      throw new s.TokenInvalidInstructionTypeError();
    if (!f || !h || !p) throw new s.TokenInvalidInstructionKeysError();
    return { programId: d, keys: { account: f, mint: h, rent: p }, data: b };
  }
  e.decodeInitializeAccount2Instruction = c;
  function u({ programId: l, keys: [d, f, h], data: p }) {
    return {
      programId: l,
      keys: { account: d, mint: f, rent: h },
      data: e.initializeAccount2InstructionData.decode(p),
    };
  }
  e.decodeInitializeAccount2InstructionUnchecked = u;
})(NI);
var jI = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeInitializeAccount3InstructionUnchecked =
      e.decodeInitializeAccount3Instruction =
      e.createInitializeAccount3Instruction =
      e.initializeAccount3InstructionData =
        void 0);
  const t = Ze,
    n = Rt,
    r = ne,
    i = Ce,
    s = Me,
    o = ft;
  e.initializeAccount3InstructionData = (0, t.struct)([
    (0, t.u8)('instruction'),
    (0, n.publicKey)('owner'),
  ]);
  function a(l, d, f, h = i.TOKEN_PROGRAM_ID) {
    const p = [
        { pubkey: l, isSigner: !1, isWritable: !0 },
        { pubkey: d, isSigner: !1, isWritable: !1 },
      ],
      b = z.alloc(e.initializeAccount3InstructionData.span);
    return (
      e.initializeAccount3InstructionData.encode(
        { instruction: o.TokenInstruction.InitializeAccount3, owner: f },
        b
      ),
      new r.TransactionInstruction({ keys: p, programId: h, data: b })
    );
  }
  e.createInitializeAccount3Instruction = a;
  function c(l, d = i.TOKEN_PROGRAM_ID) {
    if (!l.programId.equals(d)) throw new s.TokenInvalidInstructionProgramError();
    if (l.data.length !== e.initializeAccount3InstructionData.span)
      throw new s.TokenInvalidInstructionDataError();
    const {
      keys: { account: f, mint: h },
      data: p,
    } = u(l);
    if (p.instruction !== o.TokenInstruction.InitializeAccount3)
      throw new s.TokenInvalidInstructionTypeError();
    if (!f || !h) throw new s.TokenInvalidInstructionKeysError();
    return { programId: d, keys: { account: f, mint: h }, data: p };
  }
  e.decodeInitializeAccount3Instruction = c;
  function u({ programId: l, keys: [d, f], data: h }) {
    return {
      programId: l,
      keys: { account: d, mint: f },
      data: e.initializeAccount3InstructionData.decode(h),
    };
  }
  e.decodeInitializeAccount3InstructionUnchecked = u;
})(jI);
Object.defineProperty(qe, '__esModule', { value: !0 });
qe.isUiamountToAmountInstruction =
  qe.isAmountToUiAmountInstruction =
  qe.isInitializeMint2Instruction =
  qe.isInitializeAccount3Instruction =
  qe.isSyncNativeInstruction =
  qe.isInitializeAccount2Instruction =
  qe.isBurnCheckedInstruction =
  qe.isMintToCheckedInstruction =
  qe.isApproveCheckedInstruction =
  qe.isTransferCheckedInstruction =
  qe.isThawAccountInstruction =
  qe.isFreezeAccountInstruction =
  qe.isCloseAccountInstruction =
  qe.isBurnInstruction =
  qe.isMintToInstruction =
  qe.isSetAuthorityInstruction =
  qe.isRevokeInstruction =
  qe.isApproveInstruction =
  qe.isTransferInstruction =
  qe.isInitializeMultisigInstruction =
  qe.isInitializeAccountInstruction =
  qe.isInitializeMintInstruction =
  qe.decodeInstruction =
    void 0;
const Zse = Ze,
  Jse = Ce,
  jv = Me,
  Xse = fm,
  Qse = pm,
  eoe = ym,
  toe = mm,
  noe = vm,
  roe = Sm,
  ioe = Dm,
  soe = dp,
  ooe = NI,
  aoe = jI,
  coe = Xm,
  uoe = km,
  loe = Pm,
  doe = jm,
  foe = Um,
  hoe = Fm,
  poe = Km,
  goe = hp,
  yoe = Hm,
  boe = qm,
  moe = Zm,
  Xe = ft,
  woe = gs;
function voe(e, t = Jse.TOKEN_PROGRAM_ID) {
  if (!e.data.length) throw new jv.TokenInvalidInstructionDataError();
  const n = (0, Zse.u8)().decode(e.data);
  if (n === Xe.TokenInstruction.InitializeMint)
    return (0, coe.decodeInitializeMintInstruction)(e, t);
  if (n === Xe.TokenInstruction.InitializeAccount)
    return (0, soe.decodeInitializeAccountInstruction)(e, t);
  if (n === Xe.TokenInstruction.InitializeMultisig)
    return (0, loe.decodeInitializeMultisigInstruction)(e, t);
  if (n === Xe.TokenInstruction.Transfer) return (0, boe.decodeTransferInstruction)(e, t);
  if (n === Xe.TokenInstruction.Approve) return (0, Qse.decodeApproveInstruction)(e, t);
  if (n === Xe.TokenInstruction.Revoke) return (0, hoe.decodeRevokeInstruction)(e, t);
  if (n === Xe.TokenInstruction.SetAuthority) return (0, poe.decodeSetAuthorityInstruction)(e, t);
  if (n === Xe.TokenInstruction.MintTo) return (0, doe.decodeMintToInstruction)(e, t);
  if (n === Xe.TokenInstruction.Burn) return (0, toe.decodeBurnInstruction)(e, t);
  if (n === Xe.TokenInstruction.CloseAccount) return (0, roe.decodeCloseAccountInstruction)(e, t);
  if (n === Xe.TokenInstruction.FreezeAccount) return (0, ioe.decodeFreezeAccountInstruction)(e, t);
  if (n === Xe.TokenInstruction.ThawAccount) return (0, yoe.decodeThawAccountInstruction)(e, t);
  if (n === Xe.TokenInstruction.TransferChecked)
    return (0, moe.decodeTransferCheckedInstruction)(e, t);
  if (n === Xe.TokenInstruction.ApproveChecked)
    return (0, eoe.decodeApproveCheckedInstruction)(e, t);
  if (n === Xe.TokenInstruction.MintToChecked) return (0, foe.decodeMintToCheckedInstruction)(e, t);
  if (n === Xe.TokenInstruction.BurnChecked) return (0, noe.decodeBurnCheckedInstruction)(e, t);
  if (n === Xe.TokenInstruction.InitializeAccount2)
    return (0, ooe.decodeInitializeAccount2Instruction)(e, t);
  if (n === Xe.TokenInstruction.SyncNative) return (0, goe.decodeSyncNativeInstruction)(e, t);
  if (n === Xe.TokenInstruction.InitializeAccount3)
    return (0, aoe.decodeInitializeAccount3Instruction)(e, t);
  if (n === Xe.TokenInstruction.InitializeMint2)
    return (0, uoe.decodeInitializeMint2Instruction)(e, t);
  if (n === Xe.TokenInstruction.AmountToUiAmount)
    return (0, Xse.decodeAmountToUiAmountInstruction)(e, t);
  if (n === Xe.TokenInstruction.UiAmountToAmount)
    return (0, woe.decodeUiAmountToAmountInstruction)(e, t);
  throw n === Xe.TokenInstruction.InitializeMultisig2
    ? new jv.TokenInvalidInstructionTypeError()
    : new jv.TokenInvalidInstructionTypeError();
}
qe.decodeInstruction = voe;
function _oe(e) {
  return e.data.instruction === Xe.TokenInstruction.InitializeMint;
}
qe.isInitializeMintInstruction = _oe;
function Soe(e) {
  return e.data.instruction === Xe.TokenInstruction.InitializeAccount;
}
qe.isInitializeAccountInstruction = Soe;
function Eoe(e) {
  return e.data.instruction === Xe.TokenInstruction.InitializeMultisig;
}
qe.isInitializeMultisigInstruction = Eoe;
function Aoe(e) {
  return e.data.instruction === Xe.TokenInstruction.Transfer;
}
qe.isTransferInstruction = Aoe;
function Ioe(e) {
  return e.data.instruction === Xe.TokenInstruction.Approve;
}
qe.isApproveInstruction = Ioe;
function Toe(e) {
  return e.data.instruction === Xe.TokenInstruction.Revoke;
}
qe.isRevokeInstruction = Toe;
function xoe(e) {
  return e.data.instruction === Xe.TokenInstruction.SetAuthority;
}
qe.isSetAuthorityInstruction = xoe;
function koe(e) {
  return e.data.instruction === Xe.TokenInstruction.MintTo;
}
qe.isMintToInstruction = koe;
function Coe(e) {
  return e.data.instruction === Xe.TokenInstruction.Burn;
}
qe.isBurnInstruction = Coe;
function Poe(e) {
  return e.data.instruction === Xe.TokenInstruction.CloseAccount;
}
qe.isCloseAccountInstruction = Poe;
function Moe(e) {
  return e.data.instruction === Xe.TokenInstruction.FreezeAccount;
}
qe.isFreezeAccountInstruction = Moe;
function Ooe(e) {
  return e.data.instruction === Xe.TokenInstruction.ThawAccount;
}
qe.isThawAccountInstruction = Ooe;
function Boe(e) {
  return e.data.instruction === Xe.TokenInstruction.TransferChecked;
}
qe.isTransferCheckedInstruction = Boe;
function Doe(e) {
  return e.data.instruction === Xe.TokenInstruction.ApproveChecked;
}
qe.isApproveCheckedInstruction = Doe;
function Roe(e) {
  return e.data.instruction === Xe.TokenInstruction.MintToChecked;
}
qe.isMintToCheckedInstruction = Roe;
function Noe(e) {
  return e.data.instruction === Xe.TokenInstruction.BurnChecked;
}
qe.isBurnCheckedInstruction = Noe;
function joe(e) {
  return e.data.instruction === Xe.TokenInstruction.InitializeAccount2;
}
qe.isInitializeAccount2Instruction = joe;
function Loe(e) {
  return e.data.instruction === Xe.TokenInstruction.SyncNative;
}
qe.isSyncNativeInstruction = Loe;
function Uoe(e) {
  return e.data.instruction === Xe.TokenInstruction.InitializeAccount3;
}
qe.isInitializeAccount3Instruction = Uoe;
function $oe(e) {
  return e.data.instruction === Xe.TokenInstruction.InitializeMint2;
}
qe.isInitializeMint2Instruction = $oe;
function Foe(e) {
  return e.data.instruction === Xe.TokenInstruction.AmountToUiAmount;
}
qe.isAmountToUiAmountInstruction = Foe;
function zoe(e) {
  return e.data.instruction === Xe.TokenInstruction.UiAmountToAmount;
}
qe.isUiamountToAmountInstruction = zoe;
var uD = {};
Object.defineProperty(uD, '__esModule', { value: !0 });
var lD = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeInitializeImmutableOwnerInstructionUnchecked =
      e.decodeInitializeImmutableOwnerInstruction =
      e.createInitializeImmutableOwnerInstruction =
      e.initializeImmutableOwnerInstructionData =
        void 0);
  const t = Ze,
    n = ne,
    r = Me,
    i = ft;
  e.initializeImmutableOwnerInstructionData = (0, t.struct)([(0, t.u8)('instruction')]);
  function s(c, u) {
    const l = [{ pubkey: c, isSigner: !1, isWritable: !0 }],
      d = z.alloc(e.initializeImmutableOwnerInstructionData.span);
    return (
      e.initializeImmutableOwnerInstructionData.encode(
        { instruction: i.TokenInstruction.InitializeImmutableOwner },
        d
      ),
      new n.TransactionInstruction({ keys: l, programId: u, data: d })
    );
  }
  e.createInitializeImmutableOwnerInstruction = s;
  function o(c, u) {
    if (!c.programId.equals(u)) throw new r.TokenInvalidInstructionProgramError();
    if (c.data.length !== e.initializeImmutableOwnerInstructionData.span)
      throw new r.TokenInvalidInstructionDataError();
    const {
      keys: { account: l },
      data: d,
    } = a(c);
    if (d.instruction !== i.TokenInstruction.InitializeImmutableOwner)
      throw new r.TokenInvalidInstructionTypeError();
    if (!l) throw new r.TokenInvalidInstructionKeysError();
    return { programId: u, keys: { account: l }, data: d };
  }
  e.decodeInitializeImmutableOwnerInstruction = o;
  function a({ programId: c, keys: [u], data: l }) {
    const { instruction: d } = e.initializeImmutableOwnerInstructionData.decode(l);
    return { programId: c, keys: { account: u }, data: { instruction: d } };
  }
  e.decodeInitializeImmutableOwnerInstructionUnchecked = a;
})(lD);
var dD = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeInitializeMintCloseAuthorityInstructionUnchecked =
      e.decodeInitializeMintCloseAuthorityInstruction =
      e.createInitializeMintCloseAuthorityInstruction =
      e.initializeMintCloseAuthorityInstructionData =
        void 0);
  const t = Ze,
    n = Rt,
    r = ne,
    i = Ce,
    s = Me,
    o = ft;
  e.initializeMintCloseAuthorityInstructionData = (0, t.struct)([
    (0, t.u8)('instruction'),
    (0, t.u8)('closeAuthorityOption'),
    (0, n.publicKey)('closeAuthority'),
  ]);
  function a(l, d, f) {
    if (!(0, i.programSupportsExtensions)(f)) throw new s.TokenUnsupportedInstructionError();
    const h = [{ pubkey: l, isSigner: !1, isWritable: !0 }],
      p = z.alloc(e.initializeMintCloseAuthorityInstructionData.span);
    return (
      e.initializeMintCloseAuthorityInstructionData.encode(
        {
          instruction: o.TokenInstruction.InitializeMintCloseAuthority,
          closeAuthorityOption: d ? 1 : 0,
          closeAuthority: d || new r.PublicKey(0),
        },
        p
      ),
      new r.TransactionInstruction({ keys: h, programId: f, data: p })
    );
  }
  e.createInitializeMintCloseAuthorityInstruction = a;
  function c(l, d) {
    if (!l.programId.equals(d)) throw new s.TokenInvalidInstructionProgramError();
    if (l.data.length !== e.initializeMintCloseAuthorityInstructionData.span)
      throw new s.TokenInvalidInstructionDataError();
    const {
      keys: { mint: f },
      data: h,
    } = u(l);
    if (h.instruction !== o.TokenInstruction.InitializeMintCloseAuthority)
      throw new s.TokenInvalidInstructionTypeError();
    if (!f) throw new s.TokenInvalidInstructionKeysError();
    return { programId: d, keys: { mint: f }, data: h };
  }
  e.decodeInitializeMintCloseAuthorityInstruction = c;
  function u({ programId: l, keys: [d], data: f }) {
    const {
      instruction: h,
      closeAuthorityOption: p,
      closeAuthority: b,
    } = e.initializeMintCloseAuthorityInstructionData.decode(f);
    return {
      programId: l,
      keys: { mint: d },
      data: { instruction: h, closeAuthority: p ? b : null },
    };
  }
  e.decodeInitializeMintCloseAuthorityInstructionUnchecked = u;
})(dD);
var Qm = {};
Object.defineProperty(Qm, '__esModule', { value: !0 });
Qm.createReallocateInstruction = void 0;
const ag = Ze,
  Y2 = ne,
  Z2 = Ce,
  Koe = Me,
  Voe = cn,
  Woe = ft;
function Hoe(e, t, n, r, i = [], s = Z2.TOKEN_2022_PROGRAM_ID) {
  if (!(0, Z2.programSupportsExtensions)(s)) throw new Koe.TokenUnsupportedInstructionError();
  const o = [
      { pubkey: e, isSigner: !1, isWritable: !0 },
      { pubkey: t, isSigner: !0, isWritable: !0 },
      { pubkey: Y2.SystemProgram.programId, isSigner: !1, isWritable: !1 },
    ],
    a = (0, Voe.addSigners)(o, r, i),
    c = (0, ag.struct)([
      (0, ag.u8)('instruction'),
      (0, ag.seq)((0, ag.u16)(), n.length, 'extensionTypes'),
    ]),
    u = z.alloc(c.span);
  return (
    c.encode({ instruction: Woe.TokenInstruction.Reallocate, extensionTypes: n }, u),
    new Y2.TransactionInstruction({ keys: a, programId: s, data: u })
  );
}
Qm.createReallocateInstruction = Hoe;
var fD = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createInitializeNonTransferableMintInstruction =
      e.initializeNonTransferableMintInstructionData =
        void 0);
  const t = Ze,
    n = ne,
    r = Ce,
    i = Me,
    s = ft;
  e.initializeNonTransferableMintInstructionData = (0, t.struct)([(0, t.u8)('instruction')]);
  function o(a, c) {
    if (!(0, r.programSupportsExtensions)(c)) throw new i.TokenUnsupportedInstructionError();
    const u = [{ pubkey: a, isSigner: !1, isWritable: !0 }],
      l = z.alloc(e.initializeNonTransferableMintInstructionData.span);
    return (
      e.initializeNonTransferableMintInstructionData.encode(
        { instruction: s.TokenInstruction.InitializeNonTransferableMint },
        l
      ),
      new n.TransactionInstruction({ keys: u, programId: c, data: l })
    );
  }
  e.createInitializeNonTransferableMintInstruction = o;
})(fD);
var hD = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeInitializePermanentDelegateInstructionUnchecked =
      e.decodeInitializePermanentDelegateInstruction =
      e.createInitializePermanentDelegateInstruction =
      e.initializePermanentDelegateInstructionData =
        void 0);
  const t = Ze,
    n = Rt,
    r = ne,
    i = ne,
    s = Ce,
    o = Me,
    a = ft;
  e.initializePermanentDelegateInstructionData = (0, t.struct)([
    (0, t.u8)('instruction'),
    (0, n.publicKey)('delegate'),
  ]);
  function c(d, f, h) {
    if (!(0, s.programSupportsExtensions)(h)) throw new o.TokenUnsupportedInstructionError();
    const p = [{ pubkey: d, isSigner: !1, isWritable: !0 }],
      b = z.alloc(e.initializePermanentDelegateInstructionData.span);
    return (
      e.initializePermanentDelegateInstructionData.encode(
        {
          instruction: a.TokenInstruction.InitializePermanentDelegate,
          delegate: f || new r.PublicKey(0),
        },
        b
      ),
      new i.TransactionInstruction({ keys: p, programId: h, data: b })
    );
  }
  e.createInitializePermanentDelegateInstruction = c;
  function u(d, f) {
    if (!d.programId.equals(f)) throw new o.TokenInvalidInstructionProgramError();
    if (d.data.length !== e.initializePermanentDelegateInstructionData.span)
      throw new o.TokenInvalidInstructionDataError();
    const {
      keys: { mint: h },
      data: p,
    } = l(d);
    if (p.instruction !== a.TokenInstruction.InitializePermanentDelegate)
      throw new o.TokenInvalidInstructionTypeError();
    if (!h) throw new o.TokenInvalidInstructionKeysError();
    return { programId: f, keys: { mint: h }, data: p };
  }
  e.decodeInitializePermanentDelegateInstruction = u;
  function l({ programId: d, keys: [f], data: h }) {
    const { instruction: p, delegate: b } = e.initializePermanentDelegateInstructionData.decode(h);
    return { programId: d, keys: { mint: f }, data: { instruction: p, delegate: b } };
  }
  e.decodeInitializePermanentDelegateInstructionUnchecked = l;
})(hD);
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (r, i, s, o) {
            o === void 0 && (o = s);
            var a = Object.getOwnPropertyDescriptor(i, s);
            (!a || ('get' in a ? !i.__esModule : a.writable || a.configurable)) &&
              (a = {
                enumerable: !0,
                get: function () {
                  return i[s];
                },
              }),
              Object.defineProperty(r, o, a);
          }
        : function (r, i, s, o) {
            o === void 0 && (o = s), (r[o] = i[s]);
          }),
    n =
      (m && m.__exportStar) ||
      function (r, i) {
        for (var s in r)
          s !== 'default' && !Object.prototype.hasOwnProperty.call(i, s) && t(i, r, s);
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    n(vs, e),
    n(qe, e),
    n(ft, e),
    n(Xm, e),
    n(dp, e),
    n(Pm, e),
    n(qm, e),
    n(pm, e),
    n(Fm, e),
    n(Km, e),
    n(jm, e),
    n(mm, e),
    n(Sm, e),
    n(Dm, e),
    n(Hm, e),
    n(Zm, e),
    n(ym, e),
    n(Um, e),
    n(vm, e),
    n(NI, e),
    n(hp, e),
    n(jI, e),
    n(uD, e),
    n(km, e),
    n(lD, e),
    n(fm, e),
    n(gs, e),
    n(dD, e),
    n(Qm, e),
    n(DI, e),
    n(fD, e),
    n(hD, e);
})(cD);
var pD = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (r, i, s, o) {
            o === void 0 && (o = s);
            var a = Object.getOwnPropertyDescriptor(i, s);
            (!a || ('get' in a ? !i.__esModule : a.writable || a.configurable)) &&
              (a = {
                enumerable: !0,
                get: function () {
                  return i[s];
                },
              }),
              Object.defineProperty(r, o, a);
          }
        : function (r, i, s, o) {
            o === void 0 && (o = s), (r[o] = i[s]);
          }),
    n =
      (m && m.__exportStar) ||
      function (r, i) {
        for (var s in r)
          s !== 'default' && !Object.prototype.hasOwnProperty.call(i, s) && t(i, r, s);
      };
  Object.defineProperty(e, '__esModule', { value: !0 }), n(lp(), e), n(Sa(), e), n(Xu, e);
})(pD);
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (r, i, s, o) {
            o === void 0 && (o = s);
            var a = Object.getOwnPropertyDescriptor(i, s);
            (!a || ('get' in a ? !i.__esModule : a.writable || a.configurable)) &&
              (a = {
                enumerable: !0,
                get: function () {
                  return i[s];
                },
              }),
              Object.defineProperty(r, o, a);
          }
        : function (r, i, s, o) {
            o === void 0 && (o = s), (r[o] = i[s]);
          }),
    n =
      (m && m.__exportStar) ||
      function (r, i) {
        for (var s in r)
          s !== 'default' && !Object.prototype.hasOwnProperty.call(i, s) && t(i, r, s);
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    n(OB, e),
    n(Ce, e),
    n(Me, e),
    n(rD, e),
    n(cD, e),
    n(pD, e);
})(_r);
var pp = {},
  Goe =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  qoe =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  Yoe =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && Goe(t, e, n);
      return qoe(t, e), t;
    };
Object.defineProperty(pp, '__esModule', { value: !0 });
pp.approveUseAuthorityArgsBeet = void 0;
const J2 = Yoe(te);
pp.approveUseAuthorityArgsBeet = new J2.BeetArgsStruct(
  [['numberOfUses', J2.u64]],
  'ApproveUseAuthorityArgs'
);
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (u, l, d, f) {
            f === void 0 && (f = d);
            var h = Object.getOwnPropertyDescriptor(l, d);
            (!h || ('get' in h ? !l.__esModule : h.writable || h.configurable)) &&
              (h = {
                enumerable: !0,
                get: function () {
                  return l[d];
                },
              }),
              Object.defineProperty(u, f, h);
          }
        : function (u, l, d, f) {
            f === void 0 && (f = d), (u[f] = l[d]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (u, l) {
            Object.defineProperty(u, 'default', { enumerable: !0, value: l });
          }
        : function (u, l) {
            u.default = l;
          }),
    r =
      (m && m.__importStar) ||
      function (u) {
        if (u && u.__esModule) return u;
        var l = {};
        if (u != null)
          for (var d in u)
            d !== 'default' && Object.prototype.hasOwnProperty.call(u, d) && t(l, u, d);
        return n(l, u), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createApproveUseAuthorityInstruction =
      e.approveUseAuthorityInstructionDiscriminator =
      e.ApproveUseAuthorityStruct =
        void 0);
  const i = r(_r),
    s = r(te),
    o = r(ne),
    a = pp;
  (e.ApproveUseAuthorityStruct = new s.BeetArgsStruct(
    [
      ['instructionDiscriminator', s.u8],
      ['approveUseAuthorityArgs', a.approveUseAuthorityArgsBeet],
    ],
    'ApproveUseAuthorityInstructionArgs'
  )),
    (e.approveUseAuthorityInstructionDiscriminator = 20);
  function c(u, l, d = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var f, h;
    const [p] = e.ApproveUseAuthorityStruct.serialize({
        instructionDiscriminator: e.approveUseAuthorityInstructionDiscriminator,
        ...l,
      }),
      b = [
        { pubkey: u.useAuthorityRecord, isWritable: !0, isSigner: !1 },
        { pubkey: u.owner, isWritable: !0, isSigner: !0 },
        { pubkey: u.payer, isWritable: !0, isSigner: !0 },
        { pubkey: u.user, isWritable: !1, isSigner: !1 },
        { pubkey: u.ownerTokenAccount, isWritable: !0, isSigner: !1 },
        { pubkey: u.metadata, isWritable: !1, isSigner: !1 },
        { pubkey: u.mint, isWritable: !1, isSigner: !1 },
        { pubkey: u.burner, isWritable: !1, isSigner: !1 },
        {
          pubkey: (f = u.tokenProgram) !== null && f !== void 0 ? f : i.TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (h = u.systemProgram) !== null && h !== void 0 ? h : o.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return (
      u.rent != null && b.push({ pubkey: u.rent, isWritable: !1, isSigner: !1 }),
      new o.TransactionInstruction({ programId: d, keys: b, data: p })
    );
  }
  e.createApproveUseAuthorityInstruction = c;
})(MB);
var gD = {},
  Qu = {},
  Zoe =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  Joe =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  Xoe =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && Zoe(t, e, n);
      return Joe(t, e), t;
    };
Object.defineProperty(Qu, '__esModule', { value: !0 });
Qu.setCollectionSizeArgsBeet = void 0;
const X2 = Xoe(te);
Qu.setCollectionSizeArgsBeet = new X2.BeetArgsStruct([['size', X2.u64]], 'SetCollectionSizeArgs');
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (c, u, l, d) {
            d === void 0 && (d = l);
            var f = Object.getOwnPropertyDescriptor(u, l);
            (!f || ('get' in f ? !u.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return u[l];
                },
              }),
              Object.defineProperty(c, d, f);
          }
        : function (c, u, l, d) {
            d === void 0 && (d = l), (c[d] = u[l]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (c, u) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: u });
          }
        : function (c, u) {
            c.default = u;
          }),
    r =
      (m && m.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var u = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(u, c, l);
        return n(u, c), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createBubblegumSetCollectionSizeInstruction =
      e.bubblegumSetCollectionSizeInstructionDiscriminator =
      e.BubblegumSetCollectionSizeStruct =
        void 0);
  const i = r(te),
    s = r(ne),
    o = Qu;
  (e.BubblegumSetCollectionSizeStruct = new i.BeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['setCollectionSizeArgs', o.setCollectionSizeArgsBeet],
    ],
    'BubblegumSetCollectionSizeInstructionArgs'
  )),
    (e.bubblegumSetCollectionSizeInstructionDiscriminator = 36);
  function a(c, u, l = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [d] = e.BubblegumSetCollectionSizeStruct.serialize({
        instructionDiscriminator: e.bubblegumSetCollectionSizeInstructionDiscriminator,
        ...u,
      }),
      f = [
        { pubkey: c.collectionMetadata, isWritable: !0, isSigner: !1 },
        { pubkey: c.collectionAuthority, isWritable: !0, isSigner: !0 },
        { pubkey: c.collectionMint, isWritable: !1, isSigner: !1 },
        { pubkey: c.bubblegumSigner, isWritable: !1, isSigner: !0 },
      ];
    return (
      c.collectionAuthorityRecord != null &&
        f.push({ pubkey: c.collectionAuthorityRecord, isWritable: !1, isSigner: !1 }),
      new s.TransactionInstruction({ programId: l, keys: f, data: d })
    );
  }
  e.createBubblegumSetCollectionSizeInstruction = a;
})(gD);
var yD = {},
  oc = {},
  Qoe =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  eae =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  tae =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && Qoe(t, e, n);
      return eae(t, e), t;
    };
Object.defineProperty(oc, '__esModule', { value: !0 });
oc.burnArgsBeet = oc.isBurnArgsV1 = void 0;
const Lv = tae(te),
  nae = (e) => e.__kind === 'V1';
oc.isBurnArgsV1 = nae;
oc.burnArgsBeet = Lv.dataEnum([
  ['V1', new Lv.BeetArgsStruct([['amount', Lv.u64]], 'BurnArgsRecord["V1"]')],
]);
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (c, u, l, d) {
            d === void 0 && (d = l);
            var f = Object.getOwnPropertyDescriptor(u, l);
            (!f || ('get' in f ? !u.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return u[l];
                },
              }),
              Object.defineProperty(c, d, f);
          }
        : function (c, u, l, d) {
            d === void 0 && (d = l), (c[d] = u[l]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (c, u) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: u });
          }
        : function (c, u) {
            c.default = u;
          }),
    r =
      (m && m.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var u = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(u, c, l);
        return n(u, c), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createBurnInstruction = e.burnInstructionDiscriminator = e.BurnStruct = void 0);
  const i = r(te),
    s = r(ne),
    o = oc;
  (e.BurnStruct = new i.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['burnArgs', o.burnArgsBeet],
    ],
    'BurnInstructionArgs'
  )),
    (e.burnInstructionDiscriminator = 41);
  function a(c, u, l = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var d, f, h, p, b, w, A, _;
    const [x] = e.BurnStruct.serialize({
        instructionDiscriminator: e.burnInstructionDiscriminator,
        ...u,
      }),
      k = [
        { pubkey: c.authority, isWritable: !0, isSigner: !0 },
        {
          pubkey: (d = c.collectionMetadata) !== null && d !== void 0 ? d : l,
          isWritable: c.collectionMetadata != null,
          isSigner: !1,
        },
        { pubkey: c.metadata, isWritable: !0, isSigner: !1 },
        {
          pubkey: (f = c.edition) !== null && f !== void 0 ? f : l,
          isWritable: c.edition != null,
          isSigner: !1,
        },
        { pubkey: c.mint, isWritable: !0, isSigner: !1 },
        { pubkey: c.token, isWritable: !0, isSigner: !1 },
        {
          pubkey: (h = c.masterEdition) !== null && h !== void 0 ? h : l,
          isWritable: c.masterEdition != null,
          isSigner: !1,
        },
        {
          pubkey: (p = c.masterEditionMint) !== null && p !== void 0 ? p : l,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (b = c.masterEditionToken) !== null && b !== void 0 ? b : l,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (w = c.editionMarker) !== null && w !== void 0 ? w : l,
          isWritable: c.editionMarker != null,
          isSigner: !1,
        },
        {
          pubkey: (A = c.tokenRecord) !== null && A !== void 0 ? A : l,
          isWritable: c.tokenRecord != null,
          isSigner: !1,
        },
        {
          pubkey: (_ = c.systemProgram) !== null && _ !== void 0 ? _ : s.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: c.sysvarInstructions, isWritable: !1, isSigner: !1 },
        { pubkey: c.splTokenProgram, isWritable: !1, isSigner: !1 },
      ];
    return new s.TransactionInstruction({ programId: l, keys: k, data: x });
  }
  e.createBurnInstruction = a;
})(yD);
var bD = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (a, c, u, l) {
            l === void 0 && (l = u);
            var d = Object.getOwnPropertyDescriptor(c, u);
            (!d || ('get' in d ? !c.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return c[u];
                },
              }),
              Object.defineProperty(a, l, d);
          }
        : function (a, c, u, l) {
            l === void 0 && (l = u), (a[l] = c[u]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (m && m.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var u in a)
            u !== 'default' && Object.prototype.hasOwnProperty.call(a, u) && t(c, a, u);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createBurnEditionNftInstruction =
      e.burnEditionNftInstructionDiscriminator =
      e.BurnEditionNftStruct =
        void 0);
  const i = r(te),
    s = r(ne);
  (e.BurnEditionNftStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'BurnEditionNftInstructionArgs'
  )),
    (e.burnEditionNftInstructionDiscriminator = 37);
  function o(a, c = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [u] = e.BurnEditionNftStruct.serialize({
        instructionDiscriminator: e.burnEditionNftInstructionDiscriminator,
      }),
      l = [
        { pubkey: a.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: a.owner, isWritable: !0, isSigner: !0 },
        { pubkey: a.printEditionMint, isWritable: !0, isSigner: !1 },
        { pubkey: a.masterEditionMint, isWritable: !1, isSigner: !1 },
        { pubkey: a.printEditionTokenAccount, isWritable: !0, isSigner: !1 },
        { pubkey: a.masterEditionTokenAccount, isWritable: !1, isSigner: !1 },
        { pubkey: a.masterEditionAccount, isWritable: !0, isSigner: !1 },
        { pubkey: a.printEditionAccount, isWritable: !0, isSigner: !1 },
        { pubkey: a.editionMarkerAccount, isWritable: !0, isSigner: !1 },
        { pubkey: a.splTokenProgram, isWritable: !1, isSigner: !1 },
      ];
    return new s.TransactionInstruction({ programId: c, keys: l, data: u });
  }
  e.createBurnEditionNftInstruction = o;
})(bD);
var mD = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (a, c, u, l) {
            l === void 0 && (l = u);
            var d = Object.getOwnPropertyDescriptor(c, u);
            (!d || ('get' in d ? !c.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return c[u];
                },
              }),
              Object.defineProperty(a, l, d);
          }
        : function (a, c, u, l) {
            l === void 0 && (l = u), (a[l] = c[u]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (m && m.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var u in a)
            u !== 'default' && Object.prototype.hasOwnProperty.call(a, u) && t(c, a, u);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createBurnNftInstruction = e.burnNftInstructionDiscriminator = e.BurnNftStruct = void 0);
  const i = r(te),
    s = r(ne);
  (e.BurnNftStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'BurnNftInstructionArgs'
  )),
    (e.burnNftInstructionDiscriminator = 29);
  function o(a, c = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [u] = e.BurnNftStruct.serialize({
        instructionDiscriminator: e.burnNftInstructionDiscriminator,
      }),
      l = [
        { pubkey: a.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: a.owner, isWritable: !0, isSigner: !0 },
        { pubkey: a.mint, isWritable: !0, isSigner: !1 },
        { pubkey: a.tokenAccount, isWritable: !0, isSigner: !1 },
        { pubkey: a.masterEditionAccount, isWritable: !0, isSigner: !1 },
        { pubkey: a.splTokenProgram, isWritable: !1, isSigner: !1 },
      ];
    return (
      a.collectionMetadata != null &&
        l.push({ pubkey: a.collectionMetadata, isWritable: !0, isSigner: !1 }),
      new s.TransactionInstruction({ programId: c, keys: l, data: u })
    );
  }
  e.createBurnNftInstruction = o;
})(mD);
var wD = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (a, c, u, l) {
            l === void 0 && (l = u);
            var d = Object.getOwnPropertyDescriptor(c, u);
            (!d || ('get' in d ? !c.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return c[u];
                },
              }),
              Object.defineProperty(a, l, d);
          }
        : function (a, c, u, l) {
            l === void 0 && (l = u), (a[l] = c[u]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (m && m.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var u in a)
            u !== 'default' && Object.prototype.hasOwnProperty.call(a, u) && t(c, a, u);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createCloseEscrowAccountInstruction =
      e.closeEscrowAccountInstructionDiscriminator =
      e.CloseEscrowAccountStruct =
        void 0);
  const i = r(te),
    s = r(ne);
  (e.CloseEscrowAccountStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'CloseEscrowAccountInstructionArgs'
  )),
    (e.closeEscrowAccountInstructionDiscriminator = 39);
  function o(a, c = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var u;
    const [l] = e.CloseEscrowAccountStruct.serialize({
        instructionDiscriminator: e.closeEscrowAccountInstructionDiscriminator,
      }),
      d = [
        { pubkey: a.escrow, isWritable: !0, isSigner: !1 },
        { pubkey: a.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: a.mint, isWritable: !1, isSigner: !1 },
        { pubkey: a.tokenAccount, isWritable: !1, isSigner: !1 },
        { pubkey: a.edition, isWritable: !1, isSigner: !1 },
        { pubkey: a.payer, isWritable: !0, isSigner: !0 },
        {
          pubkey: (u = a.systemProgram) !== null && u !== void 0 ? u : s.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: a.sysvarInstructions, isWritable: !1, isSigner: !1 },
      ];
    return new s.TransactionInstruction({ programId: c, keys: d, data: l });
  }
  e.createCloseEscrowAccountInstruction = o;
})(wD);
var vD = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (a, c, u, l) {
            l === void 0 && (l = u);
            var d = Object.getOwnPropertyDescriptor(c, u);
            (!d || ('get' in d ? !c.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return c[u];
                },
              }),
              Object.defineProperty(a, l, d);
          }
        : function (a, c, u, l) {
            l === void 0 && (l = u), (a[l] = c[u]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (m && m.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var u in a)
            u !== 'default' && Object.prototype.hasOwnProperty.call(a, u) && t(c, a, u);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createCollectInstruction = e.collectInstructionDiscriminator = e.CollectStruct = void 0);
  const i = r(te),
    s = r(ne);
  (e.CollectStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'CollectInstructionArgs'
  )),
    (e.collectInstructionDiscriminator = 54);
  function o(a, c = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [u] = e.CollectStruct.serialize({
        instructionDiscriminator: e.collectInstructionDiscriminator,
      }),
      l = [
        { pubkey: a.authority, isWritable: !1, isSigner: !0 },
        { pubkey: a.pdaAccount, isWritable: !1, isSigner: !1 },
      ];
    return new s.TransactionInstruction({ programId: c, keys: l, data: u });
  }
  e.createCollectInstruction = o;
})(vD);
var _D = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (a, c, u, l) {
            l === void 0 && (l = u);
            var d = Object.getOwnPropertyDescriptor(c, u);
            (!d || ('get' in d ? !c.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return c[u];
                },
              }),
              Object.defineProperty(a, l, d);
          }
        : function (a, c, u, l) {
            l === void 0 && (l = u), (a[l] = c[u]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (m && m.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var u in a)
            u !== 'default' && Object.prototype.hasOwnProperty.call(a, u) && t(c, a, u);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createConvertMasterEditionV1ToV2Instruction =
      e.convertMasterEditionV1ToV2InstructionDiscriminator =
      e.ConvertMasterEditionV1ToV2Struct =
        void 0);
  const i = r(te),
    s = r(ne);
  (e.ConvertMasterEditionV1ToV2Struct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'ConvertMasterEditionV1ToV2InstructionArgs'
  )),
    (e.convertMasterEditionV1ToV2InstructionDiscriminator = 12);
  function o(a, c = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [u] = e.ConvertMasterEditionV1ToV2Struct.serialize({
        instructionDiscriminator: e.convertMasterEditionV1ToV2InstructionDiscriminator,
      }),
      l = [
        { pubkey: a.masterEdition, isWritable: !0, isSigner: !1 },
        { pubkey: a.oneTimeAuth, isWritable: !0, isSigner: !1 },
        { pubkey: a.printingMint, isWritable: !0, isSigner: !1 },
      ];
    return new s.TransactionInstruction({ programId: c, keys: l, data: u });
  }
  e.createConvertMasterEditionV1ToV2Instruction = o;
})(_D);
var SD = {},
  ac = {},
  gp = {},
  rae =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  iae =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  ED =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && rae(t, e, n);
      return iae(t, e), t;
    };
Object.defineProperty(gp, '__esModule', { value: !0 });
gp.assetDataBeet = void 0;
const Nr = ED(te),
  sae = ED(kt),
  oae = Cc,
  aae = Ju,
  cae = ho,
  uae = po,
  lae = Ki;
gp.assetDataBeet = new Nr.FixableBeetArgsStruct(
  [
    ['name', Nr.utf8String],
    ['symbol', Nr.utf8String],
    ['uri', Nr.utf8String],
    ['sellerFeeBasisPoints', Nr.u16],
    ['creators', Nr.coption(Nr.array(oae.creatorBeet))],
    ['primarySaleHappened', Nr.bool],
    ['isMutable', Nr.bool],
    ['tokenStandard', aae.tokenStandardBeet],
    ['collection', Nr.coption(cae.collectionBeet)],
    ['uses', Nr.coption(uae.usesBeet)],
    ['collectionDetails', Nr.coption(lae.collectionDetailsBeet)],
    ['ruleSet', Nr.coption(sae.publicKey)],
  ],
  'AssetData'
);
var Bi = {},
  dae =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  fae =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  hae =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && dae(t, e, n);
      return fae(t, e), t;
    };
Object.defineProperty(Bi, '__esModule', { value: !0 });
Bi.printSupplyBeet =
  Bi.isPrintSupplyUnlimited =
  Bi.isPrintSupplyLimited =
  Bi.isPrintSupplyZero =
    void 0;
const jc = hae(te),
  pae = (e) => e.__kind === 'Zero';
Bi.isPrintSupplyZero = pae;
const gae = (e) => e.__kind === 'Limited';
Bi.isPrintSupplyLimited = gae;
const yae = (e) => e.__kind === 'Unlimited';
Bi.isPrintSupplyUnlimited = yae;
Bi.printSupplyBeet = jc.dataEnum([
  ['Zero', jc.unit],
  [
    'Limited',
    new jc.BeetArgsStruct(
      [['fields', jc.fixedSizeTuple([jc.u64])]],
      'PrintSupplyRecord["Limited"]'
    ),
  ],
  ['Unlimited', jc.unit],
]);
var bae =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  mae =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  wae =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && bae(t, e, n);
      return mae(t, e), t;
    };
Object.defineProperty(ac, '__esModule', { value: !0 });
ac.createArgsBeet = ac.isCreateArgsV1 = void 0;
const bl = wae(te),
  vae = gp,
  _ae = Bi,
  Sae = (e) => e.__kind === 'V1';
ac.isCreateArgsV1 = Sae;
ac.createArgsBeet = bl.dataEnum([
  [
    'V1',
    new bl.FixableBeetArgsStruct(
      [
        ['assetData', vae.assetDataBeet],
        ['decimals', bl.coption(bl.u8)],
        ['printSupply', bl.coption(_ae.printSupplyBeet)],
      ],
      'CreateArgsRecord["V1"]'
    ),
  ],
]);
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (c, u, l, d) {
            d === void 0 && (d = l);
            var f = Object.getOwnPropertyDescriptor(u, l);
            (!f || ('get' in f ? !u.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return u[l];
                },
              }),
              Object.defineProperty(c, d, f);
          }
        : function (c, u, l, d) {
            d === void 0 && (d = l), (c[d] = u[l]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (c, u) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: u });
          }
        : function (c, u) {
            c.default = u;
          }),
    r =
      (m && m.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var u = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(u, c, l);
        return n(u, c), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createCreateInstruction = e.createInstructionDiscriminator = e.CreateStruct = void 0);
  const i = r(te),
    s = r(ne),
    o = ac;
  (e.CreateStruct = new i.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['createArgs', o.createArgsBeet],
    ],
    'CreateInstructionArgs'
  )),
    (e.createInstructionDiscriminator = 42);
  function a(c, u, l = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var d, f;
    const [h] = e.CreateStruct.serialize({
        instructionDiscriminator: e.createInstructionDiscriminator,
        ...u,
      }),
      p = [
        { pubkey: c.metadata, isWritable: !0, isSigner: !1 },
        {
          pubkey: (d = c.masterEdition) !== null && d !== void 0 ? d : l,
          isWritable: c.masterEdition != null,
          isSigner: !1,
        },
        { pubkey: c.mint, isWritable: !0, isSigner: !1 },
        { pubkey: c.authority, isWritable: !1, isSigner: !0 },
        { pubkey: c.payer, isWritable: !0, isSigner: !0 },
        { pubkey: c.updateAuthority, isWritable: !1, isSigner: !1 },
        {
          pubkey: (f = c.systemProgram) !== null && f !== void 0 ? f : s.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: c.sysvarInstructions, isWritable: !1, isSigner: !1 },
        { pubkey: c.splTokenProgram, isWritable: !1, isSigner: !1 },
      ];
    return new s.TransactionInstruction({ programId: l, keys: p, data: h });
  }
  e.createCreateInstruction = a;
})(SD);
var AD = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (a, c, u, l) {
            l === void 0 && (l = u);
            var d = Object.getOwnPropertyDescriptor(c, u);
            (!d || ('get' in d ? !c.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return c[u];
                },
              }),
              Object.defineProperty(a, l, d);
          }
        : function (a, c, u, l) {
            l === void 0 && (l = u), (a[l] = c[u]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (m && m.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var u in a)
            u !== 'default' && Object.prototype.hasOwnProperty.call(a, u) && t(c, a, u);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createCreateEscrowAccountInstruction =
      e.createEscrowAccountInstructionDiscriminator =
      e.CreateEscrowAccountStruct =
        void 0);
  const i = r(te),
    s = r(ne);
  (e.CreateEscrowAccountStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'CreateEscrowAccountInstructionArgs'
  )),
    (e.createEscrowAccountInstructionDiscriminator = 38);
  function o(a, c = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var u;
    const [l] = e.CreateEscrowAccountStruct.serialize({
        instructionDiscriminator: e.createEscrowAccountInstructionDiscriminator,
      }),
      d = [
        { pubkey: a.escrow, isWritable: !0, isSigner: !1 },
        { pubkey: a.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: a.mint, isWritable: !1, isSigner: !1 },
        { pubkey: a.tokenAccount, isWritable: !1, isSigner: !1 },
        { pubkey: a.edition, isWritable: !1, isSigner: !1 },
        { pubkey: a.payer, isWritable: !0, isSigner: !0 },
        {
          pubkey: (u = a.systemProgram) !== null && u !== void 0 ? u : s.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: a.sysvarInstructions, isWritable: !1, isSigner: !1 },
      ];
    return (
      a.authority != null && d.push({ pubkey: a.authority, isWritable: !1, isSigner: !0 }),
      new s.TransactionInstruction({ programId: c, keys: d, data: l })
    );
  }
  e.createCreateEscrowAccountInstruction = o;
})(AD);
var ID = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (c, u, l, d) {
            d === void 0 && (d = l);
            var f = Object.getOwnPropertyDescriptor(u, l);
            (!f || ('get' in f ? !u.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return u[l];
                },
              }),
              Object.defineProperty(c, d, f);
          }
        : function (c, u, l, d) {
            d === void 0 && (d = l), (c[d] = u[l]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (c, u) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: u });
          }
        : function (c, u) {
            c.default = u;
          }),
    r =
      (m && m.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var u = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(u, c, l);
        return n(u, c), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createCreateMasterEditionInstruction =
      e.createMasterEditionInstructionDiscriminator =
      e.CreateMasterEditionStruct =
        void 0);
  const i = r(_r),
    s = r(te),
    o = r(ne);
  (e.CreateMasterEditionStruct = new s.BeetArgsStruct(
    [['instructionDiscriminator', s.u8]],
    'CreateMasterEditionInstructionArgs'
  )),
    (e.createMasterEditionInstructionDiscriminator = 10);
  function a(c, u = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var l, d, f;
    const [h] = e.CreateMasterEditionStruct.serialize({
        instructionDiscriminator: e.createMasterEditionInstructionDiscriminator,
      }),
      p = [
        { pubkey: c.edition, isWritable: !0, isSigner: !1 },
        { pubkey: c.mint, isWritable: !0, isSigner: !1 },
        { pubkey: c.updateAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: c.mintAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: c.payer, isWritable: !0, isSigner: !0 },
        { pubkey: c.metadata, isWritable: !1, isSigner: !1 },
        {
          pubkey: (l = c.tokenProgram) !== null && l !== void 0 ? l : i.TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (d = c.systemProgram) !== null && d !== void 0 ? d : o.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (f = c.rent) !== null && f !== void 0 ? f : o.SYSVAR_RENT_PUBKEY,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return new o.TransactionInstruction({ programId: u, keys: p, data: h });
  }
  e.createCreateMasterEditionInstruction = a;
})(ID);
var TD = {},
  yp = {},
  Eae =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  Aae =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  Iae =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && Eae(t, e, n);
      return Aae(t, e), t;
    };
Object.defineProperty(yp, '__esModule', { value: !0 });
yp.createMasterEditionArgsBeet = void 0;
const Uv = Iae(te);
yp.createMasterEditionArgsBeet = new Uv.FixableBeetArgsStruct(
  [['maxSupply', Uv.coption(Uv.u64)]],
  'CreateMasterEditionArgs'
);
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (u, l, d, f) {
            f === void 0 && (f = d);
            var h = Object.getOwnPropertyDescriptor(l, d);
            (!h || ('get' in h ? !l.__esModule : h.writable || h.configurable)) &&
              (h = {
                enumerable: !0,
                get: function () {
                  return l[d];
                },
              }),
              Object.defineProperty(u, f, h);
          }
        : function (u, l, d, f) {
            f === void 0 && (f = d), (u[f] = l[d]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (u, l) {
            Object.defineProperty(u, 'default', { enumerable: !0, value: l });
          }
        : function (u, l) {
            u.default = l;
          }),
    r =
      (m && m.__importStar) ||
      function (u) {
        if (u && u.__esModule) return u;
        var l = {};
        if (u != null)
          for (var d in u)
            d !== 'default' && Object.prototype.hasOwnProperty.call(u, d) && t(l, u, d);
        return n(l, u), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createCreateMasterEditionV3Instruction =
      e.createMasterEditionV3InstructionDiscriminator =
      e.CreateMasterEditionV3Struct =
        void 0);
  const i = r(_r),
    s = r(te),
    o = r(ne),
    a = yp;
  (e.CreateMasterEditionV3Struct = new s.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', s.u8],
      ['createMasterEditionArgs', a.createMasterEditionArgsBeet],
    ],
    'CreateMasterEditionV3InstructionArgs'
  )),
    (e.createMasterEditionV3InstructionDiscriminator = 17);
  function c(u, l, d = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var f, h;
    const [p] = e.CreateMasterEditionV3Struct.serialize({
        instructionDiscriminator: e.createMasterEditionV3InstructionDiscriminator,
        ...l,
      }),
      b = [
        { pubkey: u.edition, isWritable: !0, isSigner: !1 },
        { pubkey: u.mint, isWritable: !0, isSigner: !1 },
        { pubkey: u.updateAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: u.mintAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: u.payer, isWritable: !0, isSigner: !0 },
        { pubkey: u.metadata, isWritable: !0, isSigner: !1 },
        {
          pubkey: (f = u.tokenProgram) !== null && f !== void 0 ? f : i.TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (h = u.systemProgram) !== null && h !== void 0 ? h : o.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return (
      u.rent != null && b.push({ pubkey: u.rent, isWritable: !1, isSigner: !1 }),
      new o.TransactionInstruction({ programId: d, keys: b, data: p })
    );
  }
  e.createCreateMasterEditionV3Instruction = c;
})(TD);
var xD = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (a, c, u, l) {
            l === void 0 && (l = u);
            var d = Object.getOwnPropertyDescriptor(c, u);
            (!d || ('get' in d ? !c.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return c[u];
                },
              }),
              Object.defineProperty(a, l, d);
          }
        : function (a, c, u, l) {
            l === void 0 && (l = u), (a[l] = c[u]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (m && m.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var u in a)
            u !== 'default' && Object.prototype.hasOwnProperty.call(a, u) && t(c, a, u);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createCreateMetadataAccountInstruction =
      e.createMetadataAccountInstructionDiscriminator =
      e.CreateMetadataAccountStruct =
        void 0);
  const i = r(te),
    s = r(ne);
  (e.CreateMetadataAccountStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'CreateMetadataAccountInstructionArgs'
  )),
    (e.createMetadataAccountInstructionDiscriminator = 0);
  function o(a, c = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var u, l;
    const [d] = e.CreateMetadataAccountStruct.serialize({
        instructionDiscriminator: e.createMetadataAccountInstructionDiscriminator,
      }),
      f = [
        { pubkey: a.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: a.mint, isWritable: !1, isSigner: !1 },
        { pubkey: a.mintAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: a.payer, isWritable: !0, isSigner: !0 },
        { pubkey: a.updateAuthority, isWritable: !1, isSigner: !1 },
        {
          pubkey: (u = a.systemProgram) !== null && u !== void 0 ? u : s.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (l = a.rent) !== null && l !== void 0 ? l : s.SYSVAR_RENT_PUBKEY,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return new s.TransactionInstruction({ programId: c, keys: f, data: d });
  }
  e.createCreateMetadataAccountInstruction = o;
})(xD);
var kD = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (a, c, u, l) {
            l === void 0 && (l = u);
            var d = Object.getOwnPropertyDescriptor(c, u);
            (!d || ('get' in d ? !c.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return c[u];
                },
              }),
              Object.defineProperty(a, l, d);
          }
        : function (a, c, u, l) {
            l === void 0 && (l = u), (a[l] = c[u]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (m && m.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var u in a)
            u !== 'default' && Object.prototype.hasOwnProperty.call(a, u) && t(c, a, u);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createCreateMetadataAccountV2Instruction =
      e.createMetadataAccountV2InstructionDiscriminator =
      e.CreateMetadataAccountV2Struct =
        void 0);
  const i = r(te),
    s = r(ne);
  (e.CreateMetadataAccountV2Struct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'CreateMetadataAccountV2InstructionArgs'
  )),
    (e.createMetadataAccountV2InstructionDiscriminator = 16);
  function o(a, c = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var u;
    const [l] = e.CreateMetadataAccountV2Struct.serialize({
        instructionDiscriminator: e.createMetadataAccountV2InstructionDiscriminator,
      }),
      d = [
        { pubkey: a.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: a.mint, isWritable: !1, isSigner: !1 },
        { pubkey: a.mintAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: a.payer, isWritable: !0, isSigner: !0 },
        { pubkey: a.updateAuthority, isWritable: !1, isSigner: !1 },
        {
          pubkey: (u = a.systemProgram) !== null && u !== void 0 ? u : s.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return (
      a.rent != null && d.push({ pubkey: a.rent, isWritable: !1, isSigner: !1 }),
      new s.TransactionInstruction({ programId: c, keys: d, data: l })
    );
  }
  e.createCreateMetadataAccountV2Instruction = o;
})(kD);
var CD = {},
  bp = {},
  el = {},
  Tae =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  xae =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  kae =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && Tae(t, e, n);
      return xae(t, e), t;
    };
Object.defineProperty(el, '__esModule', { value: !0 });
el.dataV2Beet = void 0;
const Ds = kae(te),
  Cae = Cc,
  Pae = ho,
  Mae = po;
el.dataV2Beet = new Ds.FixableBeetArgsStruct(
  [
    ['name', Ds.utf8String],
    ['symbol', Ds.utf8String],
    ['uri', Ds.utf8String],
    ['sellerFeeBasisPoints', Ds.u16],
    ['creators', Ds.coption(Ds.array(Cae.creatorBeet))],
    ['collection', Ds.coption(Pae.collectionBeet)],
    ['uses', Ds.coption(Mae.usesBeet)],
  ],
  'DataV2'
);
var Oae =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  Bae =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  Dae =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && Oae(t, e, n);
      return Bae(t, e), t;
    };
Object.defineProperty(bp, '__esModule', { value: !0 });
bp.createMetadataAccountArgsV3Beet = void 0;
const $v = Dae(te),
  Rae = el,
  Nae = Ki;
bp.createMetadataAccountArgsV3Beet = new $v.FixableBeetArgsStruct(
  [
    ['data', Rae.dataV2Beet],
    ['isMutable', $v.bool],
    ['collectionDetails', $v.coption(Nae.collectionDetailsBeet)],
  ],
  'CreateMetadataAccountArgsV3'
);
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (c, u, l, d) {
            d === void 0 && (d = l);
            var f = Object.getOwnPropertyDescriptor(u, l);
            (!f || ('get' in f ? !u.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return u[l];
                },
              }),
              Object.defineProperty(c, d, f);
          }
        : function (c, u, l, d) {
            d === void 0 && (d = l), (c[d] = u[l]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (c, u) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: u });
          }
        : function (c, u) {
            c.default = u;
          }),
    r =
      (m && m.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var u = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(u, c, l);
        return n(u, c), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createCreateMetadataAccountV3Instruction =
      e.createMetadataAccountV3InstructionDiscriminator =
      e.CreateMetadataAccountV3Struct =
        void 0);
  const i = r(te),
    s = r(ne),
    o = bp;
  (e.CreateMetadataAccountV3Struct = new i.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['createMetadataAccountArgsV3', o.createMetadataAccountArgsV3Beet],
    ],
    'CreateMetadataAccountV3InstructionArgs'
  )),
    (e.createMetadataAccountV3InstructionDiscriminator = 33);
  function a(c, u, l = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var d;
    const [f] = e.CreateMetadataAccountV3Struct.serialize({
        instructionDiscriminator: e.createMetadataAccountV3InstructionDiscriminator,
        ...u,
      }),
      h = [
        { pubkey: c.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: c.mint, isWritable: !1, isSigner: !1 },
        { pubkey: c.mintAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: c.payer, isWritable: !0, isSigner: !0 },
        { pubkey: c.updateAuthority, isWritable: !1, isSigner: !1 },
        {
          pubkey: (d = c.systemProgram) !== null && d !== void 0 ? d : s.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return (
      c.rent != null && h.push({ pubkey: c.rent, isWritable: !1, isSigner: !1 }),
      new s.TransactionInstruction({ programId: l, keys: h, data: f })
    );
  }
  e.createCreateMetadataAccountV3Instruction = a;
})(CD);
var PD = {},
  xt = {},
  Wi = {},
  mp = {},
  Vr = {},
  wp = {},
  jae =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  Lae =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  Uae =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && jae(t, e, n);
      return Lae(t, e), t;
    };
Object.defineProperty(wp, '__esModule', { value: !0 });
wp.seedsVecBeet = void 0;
const Fv = Uae(te);
wp.seedsVecBeet = new Fv.FixableBeetArgsStruct([['seeds', Fv.array(Fv.bytes)]], 'SeedsVec');
var vp = {},
  $ae =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  Fae =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  zae =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && $ae(t, e, n);
      return Fae(t, e), t;
    };
Object.defineProperty(vp, '__esModule', { value: !0 });
vp.leafInfoBeet = void 0;
const Lc = zae(te);
vp.leafInfoBeet = new Lc.FixableBeetArgsStruct(
  [
    ['leaf', Lc.uniformFixedSizeArray(Lc.u8, 32)],
    ['proof', Lc.array(Lc.uniformFixedSizeArray(Lc.u8, 32))],
  ],
  'LeafInfo'
);
var Kae =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  Vae =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  MD =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && Kae(t, e, n);
      return Vae(t, e), t;
    };
Object.defineProperty(Vr, '__esModule', { value: !0 });
Vr.payloadTypeBeet =
  Vr.isPayloadTypeNumber =
  Vr.isPayloadTypeMerkleProof =
  Vr.isPayloadTypeSeeds =
  Vr.isPayloadTypePubkey =
    void 0;
const ts = MD(te),
  Wae = MD(kt),
  Hae = wp,
  Gae = vp,
  qae = (e) => e.__kind === 'Pubkey';
Vr.isPayloadTypePubkey = qae;
const Yae = (e) => e.__kind === 'Seeds';
Vr.isPayloadTypeSeeds = Yae;
const Zae = (e) => e.__kind === 'MerkleProof';
Vr.isPayloadTypeMerkleProof = Zae;
const Jae = (e) => e.__kind === 'Number';
Vr.isPayloadTypeNumber = Jae;
Vr.payloadTypeBeet = ts.dataEnum([
  [
    'Pubkey',
    new ts.BeetArgsStruct(
      [['fields', ts.fixedSizeTuple([Wae.publicKey])]],
      'PayloadTypeRecord["Pubkey"]'
    ),
  ],
  [
    'Seeds',
    new ts.FixableBeetArgsStruct(
      [['fields', ts.tuple([Hae.seedsVecBeet])]],
      'PayloadTypeRecord["Seeds"]'
    ),
  ],
  [
    'MerkleProof',
    new ts.FixableBeetArgsStruct(
      [['fields', ts.tuple([Gae.leafInfoBeet])]],
      'PayloadTypeRecord["MerkleProof"]'
    ),
  ],
  [
    'Number',
    new ts.BeetArgsStruct([['fields', ts.fixedSizeTuple([ts.u64])]], 'PayloadTypeRecord["Number"]'),
  ],
]);
var Xae =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  Qae =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  ece =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && Xae(t, e, n);
      return Qae(t, e), t;
    };
Object.defineProperty(mp, '__esModule', { value: !0 });
mp.payloadBeet = void 0;
const zv = ece(te),
  tce = Vr;
mp.payloadBeet = new zv.FixableBeetArgsStruct(
  [['map', zv.map(zv.utf8String, tce.payloadTypeBeet)]],
  'Payload'
);
var nce =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  rce =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  ice =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && nce(t, e, n);
      return rce(t, e), t;
    };
Object.defineProperty(Wi, '__esModule', { value: !0 });
Wi.authorizationDataBeet = void 0;
const sce = ice(te),
  oce = mp;
Wi.authorizationDataBeet = new sce.FixableBeetArgsStruct(
  [['payload', oce.payloadBeet]],
  'AuthorizationData'
);
var ace =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  cce =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  OD =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && ace(t, e, n);
      return cce(t, e), t;
    };
Object.defineProperty(xt, '__esModule', { value: !0 });
xt.delegateArgsBeet =
  xt.isDelegateArgsProgrammableConfigItemV1 =
  xt.isDelegateArgsCollectionItemV1 =
  xt.isDelegateArgsDataItemV1 =
  xt.isDelegateArgsAuthorityItemV1 =
  xt.isDelegateArgsProgrammableConfigV1 =
  xt.isDelegateArgsLockedTransferV1 =
  xt.isDelegateArgsStandardV1 =
  xt.isDelegateArgsStakingV1 =
  xt.isDelegateArgsUtilityV1 =
  xt.isDelegateArgsDataV1 =
  xt.isDelegateArgsTransferV1 =
  xt.isDelegateArgsSaleV1 =
  xt.isDelegateArgsCollectionV1 =
    void 0;
const Et = OD(te),
  uce = OD(kt),
  ei = Wi,
  lce = (e) => e.__kind === 'CollectionV1';
xt.isDelegateArgsCollectionV1 = lce;
const dce = (e) => e.__kind === 'SaleV1';
xt.isDelegateArgsSaleV1 = dce;
const fce = (e) => e.__kind === 'TransferV1';
xt.isDelegateArgsTransferV1 = fce;
const hce = (e) => e.__kind === 'DataV1';
xt.isDelegateArgsDataV1 = hce;
const pce = (e) => e.__kind === 'UtilityV1';
xt.isDelegateArgsUtilityV1 = pce;
const gce = (e) => e.__kind === 'StakingV1';
xt.isDelegateArgsStakingV1 = gce;
const yce = (e) => e.__kind === 'StandardV1';
xt.isDelegateArgsStandardV1 = yce;
const bce = (e) => e.__kind === 'LockedTransferV1';
xt.isDelegateArgsLockedTransferV1 = bce;
const mce = (e) => e.__kind === 'ProgrammableConfigV1';
xt.isDelegateArgsProgrammableConfigV1 = mce;
const wce = (e) => e.__kind === 'AuthorityItemV1';
xt.isDelegateArgsAuthorityItemV1 = wce;
const vce = (e) => e.__kind === 'DataItemV1';
xt.isDelegateArgsDataItemV1 = vce;
const _ce = (e) => e.__kind === 'CollectionItemV1';
xt.isDelegateArgsCollectionItemV1 = _ce;
const Sce = (e) => e.__kind === 'ProgrammableConfigItemV1';
xt.isDelegateArgsProgrammableConfigItemV1 = Sce;
xt.delegateArgsBeet = Et.dataEnum([
  [
    'CollectionV1',
    new Et.FixableBeetArgsStruct(
      [['authorizationData', Et.coption(ei.authorizationDataBeet)]],
      'DelegateArgsRecord["CollectionV1"]'
    ),
  ],
  [
    'SaleV1',
    new Et.FixableBeetArgsStruct(
      [
        ['amount', Et.u64],
        ['authorizationData', Et.coption(ei.authorizationDataBeet)],
      ],
      'DelegateArgsRecord["SaleV1"]'
    ),
  ],
  [
    'TransferV1',
    new Et.FixableBeetArgsStruct(
      [
        ['amount', Et.u64],
        ['authorizationData', Et.coption(ei.authorizationDataBeet)],
      ],
      'DelegateArgsRecord["TransferV1"]'
    ),
  ],
  [
    'DataV1',
    new Et.FixableBeetArgsStruct(
      [['authorizationData', Et.coption(ei.authorizationDataBeet)]],
      'DelegateArgsRecord["DataV1"]'
    ),
  ],
  [
    'UtilityV1',
    new Et.FixableBeetArgsStruct(
      [
        ['amount', Et.u64],
        ['authorizationData', Et.coption(ei.authorizationDataBeet)],
      ],
      'DelegateArgsRecord["UtilityV1"]'
    ),
  ],
  [
    'StakingV1',
    new Et.FixableBeetArgsStruct(
      [
        ['amount', Et.u64],
        ['authorizationData', Et.coption(ei.authorizationDataBeet)],
      ],
      'DelegateArgsRecord["StakingV1"]'
    ),
  ],
  ['StandardV1', new Et.BeetArgsStruct([['amount', Et.u64]], 'DelegateArgsRecord["StandardV1"]')],
  [
    'LockedTransferV1',
    new Et.FixableBeetArgsStruct(
      [
        ['amount', Et.u64],
        ['lockedAddress', uce.publicKey],
        ['authorizationData', Et.coption(ei.authorizationDataBeet)],
      ],
      'DelegateArgsRecord["LockedTransferV1"]'
    ),
  ],
  [
    'ProgrammableConfigV1',
    new Et.FixableBeetArgsStruct(
      [['authorizationData', Et.coption(ei.authorizationDataBeet)]],
      'DelegateArgsRecord["ProgrammableConfigV1"]'
    ),
  ],
  [
    'AuthorityItemV1',
    new Et.FixableBeetArgsStruct(
      [['authorizationData', Et.coption(ei.authorizationDataBeet)]],
      'DelegateArgsRecord["AuthorityItemV1"]'
    ),
  ],
  [
    'DataItemV1',
    new Et.FixableBeetArgsStruct(
      [['authorizationData', Et.coption(ei.authorizationDataBeet)]],
      'DelegateArgsRecord["DataItemV1"]'
    ),
  ],
  [
    'CollectionItemV1',
    new Et.FixableBeetArgsStruct(
      [['authorizationData', Et.coption(ei.authorizationDataBeet)]],
      'DelegateArgsRecord["CollectionItemV1"]'
    ),
  ],
  [
    'ProgrammableConfigItemV1',
    new Et.FixableBeetArgsStruct(
      [['authorizationData', Et.coption(ei.authorizationDataBeet)]],
      'DelegateArgsRecord["ProgrammableConfigItemV1"]'
    ),
  ],
]);
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (c, u, l, d) {
            d === void 0 && (d = l);
            var f = Object.getOwnPropertyDescriptor(u, l);
            (!f || ('get' in f ? !u.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return u[l];
                },
              }),
              Object.defineProperty(c, d, f);
          }
        : function (c, u, l, d) {
            d === void 0 && (d = l), (c[d] = u[l]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (c, u) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: u });
          }
        : function (c, u) {
            c.default = u;
          }),
    r =
      (m && m.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var u = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(u, c, l);
        return n(u, c), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createDelegateInstruction = e.delegateInstructionDiscriminator = e.DelegateStruct = void 0);
  const i = r(te),
    s = r(ne),
    o = xt;
  (e.DelegateStruct = new i.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['delegateArgs', o.delegateArgsBeet],
    ],
    'DelegateInstructionArgs'
  )),
    (e.delegateInstructionDiscriminator = 44);
  function a(c, u, l = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var d, f, h, p, b, w, A, _;
    const [x] = e.DelegateStruct.serialize({
        instructionDiscriminator: e.delegateInstructionDiscriminator,
        ...u,
      }),
      k = [
        {
          pubkey: (d = c.delegateRecord) !== null && d !== void 0 ? d : l,
          isWritable: c.delegateRecord != null,
          isSigner: !1,
        },
        { pubkey: c.delegate, isWritable: !1, isSigner: !1 },
        { pubkey: c.metadata, isWritable: !0, isSigner: !1 },
        {
          pubkey: (f = c.masterEdition) !== null && f !== void 0 ? f : l,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (h = c.tokenRecord) !== null && h !== void 0 ? h : l,
          isWritable: c.tokenRecord != null,
          isSigner: !1,
        },
        { pubkey: c.mint, isWritable: !1, isSigner: !1 },
        {
          pubkey: (p = c.token) !== null && p !== void 0 ? p : l,
          isWritable: c.token != null,
          isSigner: !1,
        },
        { pubkey: c.authority, isWritable: !1, isSigner: !0 },
        { pubkey: c.payer, isWritable: !0, isSigner: !0 },
        {
          pubkey: (b = c.systemProgram) !== null && b !== void 0 ? b : s.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: c.sysvarInstructions, isWritable: !1, isSigner: !1 },
        {
          pubkey: (w = c.splTokenProgram) !== null && w !== void 0 ? w : l,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (A = c.authorizationRulesProgram) !== null && A !== void 0 ? A : l,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (_ = c.authorizationRules) !== null && _ !== void 0 ? _ : l,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return new s.TransactionInstruction({ programId: l, keys: k, data: x });
  }
  e.createDelegateInstruction = a;
})(PD);
var BD = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (c, u, l, d) {
            d === void 0 && (d = l);
            var f = Object.getOwnPropertyDescriptor(u, l);
            (!f || ('get' in f ? !u.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return u[l];
                },
              }),
              Object.defineProperty(c, d, f);
          }
        : function (c, u, l, d) {
            d === void 0 && (d = l), (c[d] = u[l]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (c, u) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: u });
          }
        : function (c, u) {
            c.default = u;
          }),
    r =
      (m && m.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var u = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(u, c, l);
        return n(u, c), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createDeprecatedCreateMasterEditionInstruction =
      e.deprecatedCreateMasterEditionInstructionDiscriminator =
      e.DeprecatedCreateMasterEditionStruct =
        void 0);
  const i = r(_r),
    s = r(te),
    o = r(ne);
  (e.DeprecatedCreateMasterEditionStruct = new s.BeetArgsStruct(
    [['instructionDiscriminator', s.u8]],
    'DeprecatedCreateMasterEditionInstructionArgs'
  )),
    (e.deprecatedCreateMasterEditionInstructionDiscriminator = 2);
  function a(c, u = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var l, d, f;
    const [h] = e.DeprecatedCreateMasterEditionStruct.serialize({
        instructionDiscriminator: e.deprecatedCreateMasterEditionInstructionDiscriminator,
      }),
      p = [
        { pubkey: c.edition, isWritable: !0, isSigner: !1 },
        { pubkey: c.mint, isWritable: !0, isSigner: !1 },
        { pubkey: c.printingMint, isWritable: !0, isSigner: !1 },
        { pubkey: c.oneTimePrintingAuthorizationMint, isWritable: !0, isSigner: !1 },
        { pubkey: c.updateAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: c.printingMintAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: c.mintAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: c.metadata, isWritable: !1, isSigner: !1 },
        { pubkey: c.payer, isWritable: !1, isSigner: !0 },
        {
          pubkey: (l = c.tokenProgram) !== null && l !== void 0 ? l : i.TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (d = c.systemProgram) !== null && d !== void 0 ? d : o.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (f = c.rent) !== null && f !== void 0 ? f : o.SYSVAR_RENT_PUBKEY,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: c.oneTimePrintingAuthorizationMintAuthority, isWritable: !1, isSigner: !0 },
      ];
    return new o.TransactionInstruction({ programId: u, keys: p, data: h });
  }
  e.createDeprecatedCreateMasterEditionInstruction = a;
})(BD);
var DD = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (a, c, u, l) {
            l === void 0 && (l = u);
            var d = Object.getOwnPropertyDescriptor(c, u);
            (!d || ('get' in d ? !c.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return c[u];
                },
              }),
              Object.defineProperty(a, l, d);
          }
        : function (a, c, u, l) {
            l === void 0 && (l = u), (a[l] = c[u]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (m && m.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var u in a)
            u !== 'default' && Object.prototype.hasOwnProperty.call(a, u) && t(c, a, u);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createDeprecatedCreateReservationListInstruction =
      e.deprecatedCreateReservationListInstructionDiscriminator =
      e.DeprecatedCreateReservationListStruct =
        void 0);
  const i = r(te),
    s = r(ne);
  (e.DeprecatedCreateReservationListStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'DeprecatedCreateReservationListInstructionArgs'
  )),
    (e.deprecatedCreateReservationListInstructionDiscriminator = 6);
  function o(a, c = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var u, l;
    const [d] = e.DeprecatedCreateReservationListStruct.serialize({
        instructionDiscriminator: e.deprecatedCreateReservationListInstructionDiscriminator,
      }),
      f = [
        { pubkey: a.reservationList, isWritable: !0, isSigner: !1 },
        { pubkey: a.payer, isWritable: !1, isSigner: !0 },
        { pubkey: a.updateAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: a.masterEdition, isWritable: !1, isSigner: !1 },
        { pubkey: a.resource, isWritable: !1, isSigner: !1 },
        { pubkey: a.metadata, isWritable: !1, isSigner: !1 },
        {
          pubkey: (u = a.systemProgram) !== null && u !== void 0 ? u : s.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (l = a.rent) !== null && l !== void 0 ? l : s.SYSVAR_RENT_PUBKEY,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return new s.TransactionInstruction({ programId: c, keys: f, data: d });
  }
  e.createDeprecatedCreateReservationListInstruction = o;
})(DD);
var RD = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (c, u, l, d) {
            d === void 0 && (d = l);
            var f = Object.getOwnPropertyDescriptor(u, l);
            (!f || ('get' in f ? !u.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return u[l];
                },
              }),
              Object.defineProperty(c, d, f);
          }
        : function (c, u, l, d) {
            d === void 0 && (d = l), (c[d] = u[l]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (c, u) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: u });
          }
        : function (c, u) {
            c.default = u;
          }),
    r =
      (m && m.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var u = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(u, c, l);
        return n(u, c), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createDeprecatedMintNewEditionFromMasterEditionViaPrintingTokenInstruction =
      e.deprecatedMintNewEditionFromMasterEditionViaPrintingTokenInstructionDiscriminator =
      e.DeprecatedMintNewEditionFromMasterEditionViaPrintingTokenStruct =
        void 0);
  const i = r(_r),
    s = r(te),
    o = r(ne);
  (e.DeprecatedMintNewEditionFromMasterEditionViaPrintingTokenStruct = new s.BeetArgsStruct(
    [['instructionDiscriminator', s.u8]],
    'DeprecatedMintNewEditionFromMasterEditionViaPrintingTokenInstructionArgs'
  )),
    (e.deprecatedMintNewEditionFromMasterEditionViaPrintingTokenInstructionDiscriminator = 3);
  function a(c, u = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var l, d, f;
    const [h] = e.DeprecatedMintNewEditionFromMasterEditionViaPrintingTokenStruct.serialize({
        instructionDiscriminator:
          e.deprecatedMintNewEditionFromMasterEditionViaPrintingTokenInstructionDiscriminator,
      }),
      p = [
        { pubkey: c.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: c.edition, isWritable: !0, isSigner: !1 },
        { pubkey: c.masterEdition, isWritable: !0, isSigner: !1 },
        { pubkey: c.mint, isWritable: !0, isSigner: !1 },
        { pubkey: c.mintAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: c.printingMint, isWritable: !0, isSigner: !1 },
        { pubkey: c.masterTokenAccount, isWritable: !0, isSigner: !1 },
        { pubkey: c.editionMarker, isWritable: !0, isSigner: !1 },
        { pubkey: c.burnAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: c.payer, isWritable: !1, isSigner: !0 },
        { pubkey: c.masterUpdateAuthority, isWritable: !1, isSigner: !1 },
        { pubkey: c.masterMetadata, isWritable: !1, isSigner: !1 },
        {
          pubkey: (l = c.tokenProgram) !== null && l !== void 0 ? l : i.TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (d = c.systemProgram) !== null && d !== void 0 ? d : o.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (f = c.rent) !== null && f !== void 0 ? f : o.SYSVAR_RENT_PUBKEY,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return (
      c.reservationList != null &&
        p.push({ pubkey: c.reservationList, isWritable: !0, isSigner: !1 }),
      new o.TransactionInstruction({ programId: u, keys: p, data: h })
    );
  }
  e.createDeprecatedMintNewEditionFromMasterEditionViaPrintingTokenInstruction = a;
})(RD);
var ND = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (c, u, l, d) {
            d === void 0 && (d = l);
            var f = Object.getOwnPropertyDescriptor(u, l);
            (!f || ('get' in f ? !u.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return u[l];
                },
              }),
              Object.defineProperty(c, d, f);
          }
        : function (c, u, l, d) {
            d === void 0 && (d = l), (c[d] = u[l]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (c, u) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: u });
          }
        : function (c, u) {
            c.default = u;
          }),
    r =
      (m && m.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var u = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(u, c, l);
        return n(u, c), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createDeprecatedMintPrintingTokensInstruction =
      e.deprecatedMintPrintingTokensInstructionDiscriminator =
      e.DeprecatedMintPrintingTokensStruct =
        void 0);
  const i = r(_r),
    s = r(te),
    o = r(ne);
  (e.DeprecatedMintPrintingTokensStruct = new s.BeetArgsStruct(
    [['instructionDiscriminator', s.u8]],
    'DeprecatedMintPrintingTokensInstructionArgs'
  )),
    (e.deprecatedMintPrintingTokensInstructionDiscriminator = 9);
  function a(c, u = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var l, d;
    const [f] = e.DeprecatedMintPrintingTokensStruct.serialize({
        instructionDiscriminator: e.deprecatedMintPrintingTokensInstructionDiscriminator,
      }),
      h = [
        { pubkey: c.destination, isWritable: !0, isSigner: !1 },
        { pubkey: c.printingMint, isWritable: !0, isSigner: !1 },
        { pubkey: c.updateAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: c.metadata, isWritable: !1, isSigner: !1 },
        { pubkey: c.masterEdition, isWritable: !1, isSigner: !1 },
        {
          pubkey: (l = c.tokenProgram) !== null && l !== void 0 ? l : i.TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (d = c.rent) !== null && d !== void 0 ? d : o.SYSVAR_RENT_PUBKEY,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return new o.TransactionInstruction({ programId: u, keys: h, data: f });
  }
  e.createDeprecatedMintPrintingTokensInstruction = a;
})(ND);
var jD = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (c, u, l, d) {
            d === void 0 && (d = l);
            var f = Object.getOwnPropertyDescriptor(u, l);
            (!f || ('get' in f ? !u.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return u[l];
                },
              }),
              Object.defineProperty(c, d, f);
          }
        : function (c, u, l, d) {
            d === void 0 && (d = l), (c[d] = u[l]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (c, u) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: u });
          }
        : function (c, u) {
            c.default = u;
          }),
    r =
      (m && m.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var u = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(u, c, l);
        return n(u, c), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createDeprecatedMintPrintingTokensViaTokenInstruction =
      e.deprecatedMintPrintingTokensViaTokenInstructionDiscriminator =
      e.DeprecatedMintPrintingTokensViaTokenStruct =
        void 0);
  const i = r(_r),
    s = r(te),
    o = r(ne);
  (e.DeprecatedMintPrintingTokensViaTokenStruct = new s.BeetArgsStruct(
    [['instructionDiscriminator', s.u8]],
    'DeprecatedMintPrintingTokensViaTokenInstructionArgs'
  )),
    (e.deprecatedMintPrintingTokensViaTokenInstructionDiscriminator = 8);
  function a(c, u = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var l, d;
    const [f] = e.DeprecatedMintPrintingTokensViaTokenStruct.serialize({
        instructionDiscriminator: e.deprecatedMintPrintingTokensViaTokenInstructionDiscriminator,
      }),
      h = [
        { pubkey: c.destination, isWritable: !0, isSigner: !1 },
        { pubkey: c.token, isWritable: !0, isSigner: !1 },
        { pubkey: c.oneTimePrintingAuthorizationMint, isWritable: !0, isSigner: !1 },
        { pubkey: c.printingMint, isWritable: !0, isSigner: !1 },
        { pubkey: c.burnAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: c.metadata, isWritable: !1, isSigner: !1 },
        { pubkey: c.masterEdition, isWritable: !1, isSigner: !1 },
        {
          pubkey: (l = c.tokenProgram) !== null && l !== void 0 ? l : i.TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (d = c.rent) !== null && d !== void 0 ? d : o.SYSVAR_RENT_PUBKEY,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return new o.TransactionInstruction({ programId: u, keys: h, data: f });
  }
  e.createDeprecatedMintPrintingTokensViaTokenInstruction = a;
})(jD);
var LD = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (a, c, u, l) {
            l === void 0 && (l = u);
            var d = Object.getOwnPropertyDescriptor(c, u);
            (!d || ('get' in d ? !c.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return c[u];
                },
              }),
              Object.defineProperty(a, l, d);
          }
        : function (a, c, u, l) {
            l === void 0 && (l = u), (a[l] = c[u]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (m && m.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var u in a)
            u !== 'default' && Object.prototype.hasOwnProperty.call(a, u) && t(c, a, u);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createDeprecatedSetReservationListInstruction =
      e.deprecatedSetReservationListInstructionDiscriminator =
      e.DeprecatedSetReservationListStruct =
        void 0);
  const i = r(te),
    s = r(ne);
  (e.DeprecatedSetReservationListStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'DeprecatedSetReservationListInstructionArgs'
  )),
    (e.deprecatedSetReservationListInstructionDiscriminator = 5);
  function o(a, c = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [u] = e.DeprecatedSetReservationListStruct.serialize({
        instructionDiscriminator: e.deprecatedSetReservationListInstructionDiscriminator,
      }),
      l = [
        { pubkey: a.masterEdition, isWritable: !0, isSigner: !1 },
        { pubkey: a.reservationList, isWritable: !0, isSigner: !1 },
        { pubkey: a.resource, isWritable: !1, isSigner: !0 },
      ];
    return new s.TransactionInstruction({ programId: c, keys: l, data: u });
  }
  e.createDeprecatedSetReservationListInstruction = o;
})(LD);
var UD = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (c, u, l, d) {
            d === void 0 && (d = l);
            var f = Object.getOwnPropertyDescriptor(u, l);
            (!f || ('get' in f ? !u.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return u[l];
                },
              }),
              Object.defineProperty(c, d, f);
          }
        : function (c, u, l, d) {
            d === void 0 && (d = l), (c[d] = u[l]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (c, u) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: u });
          }
        : function (c, u) {
            c.default = u;
          }),
    r =
      (m && m.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var u = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(u, c, l);
        return n(u, c), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createFreezeDelegatedAccountInstruction =
      e.freezeDelegatedAccountInstructionDiscriminator =
      e.FreezeDelegatedAccountStruct =
        void 0);
  const i = r(_r),
    s = r(te),
    o = r(ne);
  (e.FreezeDelegatedAccountStruct = new s.BeetArgsStruct(
    [['instructionDiscriminator', s.u8]],
    'FreezeDelegatedAccountInstructionArgs'
  )),
    (e.freezeDelegatedAccountInstructionDiscriminator = 26);
  function a(c, u = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var l;
    const [d] = e.FreezeDelegatedAccountStruct.serialize({
        instructionDiscriminator: e.freezeDelegatedAccountInstructionDiscriminator,
      }),
      f = [
        { pubkey: c.delegate, isWritable: !0, isSigner: !0 },
        { pubkey: c.tokenAccount, isWritable: !0, isSigner: !1 },
        { pubkey: c.edition, isWritable: !1, isSigner: !1 },
        { pubkey: c.mint, isWritable: !1, isSigner: !1 },
        {
          pubkey: (l = c.tokenProgram) !== null && l !== void 0 ? l : i.TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return new o.TransactionInstruction({ programId: u, keys: f, data: d });
  }
  e.createFreezeDelegatedAccountInstruction = a;
})(UD);
var $D = {},
  cc = {},
  Ece =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  Ace =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  Ice =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && Ece(t, e, n);
      return Ace(t, e), t;
    };
Object.defineProperty(cc, '__esModule', { value: !0 });
cc.lockArgsBeet = cc.isLockArgsV1 = void 0;
const Kv = Ice(te),
  Tce = Wi,
  xce = (e) => e.__kind === 'V1';
cc.isLockArgsV1 = xce;
cc.lockArgsBeet = Kv.dataEnum([
  [
    'V1',
    new Kv.FixableBeetArgsStruct(
      [['authorizationData', Kv.coption(Tce.authorizationDataBeet)]],
      'LockArgsRecord["V1"]'
    ),
  ],
]);
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (c, u, l, d) {
            d === void 0 && (d = l);
            var f = Object.getOwnPropertyDescriptor(u, l);
            (!f || ('get' in f ? !u.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return u[l];
                },
              }),
              Object.defineProperty(c, d, f);
          }
        : function (c, u, l, d) {
            d === void 0 && (d = l), (c[d] = u[l]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (c, u) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: u });
          }
        : function (c, u) {
            c.default = u;
          }),
    r =
      (m && m.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var u = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(u, c, l);
        return n(u, c), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createLockInstruction = e.lockInstructionDiscriminator = e.LockStruct = void 0);
  const i = r(te),
    s = r(ne),
    o = cc;
  (e.LockStruct = new i.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['lockArgs', o.lockArgsBeet],
    ],
    'LockInstructionArgs'
  )),
    (e.lockInstructionDiscriminator = 46);
  function a(c, u, l = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var d, f, h, p, b, w, A;
    const [_] = e.LockStruct.serialize({
        instructionDiscriminator: e.lockInstructionDiscriminator,
        ...u,
      }),
      x = [
        { pubkey: c.authority, isWritable: !1, isSigner: !0 },
        {
          pubkey: (d = c.tokenOwner) !== null && d !== void 0 ? d : l,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: c.token, isWritable: !0, isSigner: !1 },
        { pubkey: c.mint, isWritable: !1, isSigner: !1 },
        { pubkey: c.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: (f = c.edition) !== null && f !== void 0 ? f : l, isWritable: !1, isSigner: !1 },
        {
          pubkey: (h = c.tokenRecord) !== null && h !== void 0 ? h : l,
          isWritable: c.tokenRecord != null,
          isSigner: !1,
        },
        { pubkey: c.payer, isWritable: !0, isSigner: !0 },
        {
          pubkey: (p = c.systemProgram) !== null && p !== void 0 ? p : s.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: c.sysvarInstructions, isWritable: !1, isSigner: !1 },
        {
          pubkey: (b = c.splTokenProgram) !== null && b !== void 0 ? b : l,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (w = c.authorizationRulesProgram) !== null && w !== void 0 ? w : l,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (A = c.authorizationRules) !== null && A !== void 0 ? A : l,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return new s.TransactionInstruction({ programId: l, keys: x, data: _ });
  }
  e.createLockInstruction = a;
})($D);
var FD = {},
  uc = {},
  LI = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (o, a, c, u) {
            u === void 0 && (u = c);
            var l = Object.getOwnPropertyDescriptor(a, c);
            (!l || ('get' in l ? !a.__esModule : l.writable || l.configurable)) &&
              (l = {
                enumerable: !0,
                get: function () {
                  return a[c];
                },
              }),
              Object.defineProperty(o, u, l);
          }
        : function (o, a, c, u) {
            u === void 0 && (u = c), (o[u] = a[c]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (o, a) {
            Object.defineProperty(o, 'default', { enumerable: !0, value: a });
          }
        : function (o, a) {
            o.default = a;
          }),
    r =
      (m && m.__importStar) ||
      function (o) {
        if (o && o.__esModule) return o;
        var a = {};
        if (o != null)
          for (var c in o)
            c !== 'default' && Object.prototype.hasOwnProperty.call(o, c) && t(a, o, c);
        return n(a, o), a;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.migrationTypeBeet = e.MigrationType = void 0);
  const i = r(te);
  var s;
  (function (o) {
    (o[(o.CollectionV1 = 0)] = 'CollectionV1'), (o[(o.ProgrammableV1 = 1)] = 'ProgrammableV1');
  })((s = e.MigrationType || (e.MigrationType = {}))),
    (e.migrationTypeBeet = i.fixedScalarEnum(s));
})(LI);
var kce =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  Cce =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  zD =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && kce(t, e, n);
      return Cce(t, e), t;
    };
Object.defineProperty(uc, '__esModule', { value: !0 });
uc.migrateArgsBeet = uc.isMigrateArgsV1 = void 0;
const Vv = zD(te),
  Pce = zD(kt),
  Mce = LI,
  Oce = (e) => e.__kind === 'V1';
uc.isMigrateArgsV1 = Oce;
uc.migrateArgsBeet = Vv.dataEnum([
  [
    'V1',
    new Vv.FixableBeetArgsStruct(
      [
        ['migrationType', Mce.migrationTypeBeet],
        ['ruleSet', Vv.coption(Pce.publicKey)],
      ],
      'MigrateArgsRecord["V1"]'
    ),
  ],
]);
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (c, u, l, d) {
            d === void 0 && (d = l);
            var f = Object.getOwnPropertyDescriptor(u, l);
            (!f || ('get' in f ? !u.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return u[l];
                },
              }),
              Object.defineProperty(c, d, f);
          }
        : function (c, u, l, d) {
            d === void 0 && (d = l), (c[d] = u[l]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (c, u) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: u });
          }
        : function (c, u) {
            c.default = u;
          }),
    r =
      (m && m.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var u = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(u, c, l);
        return n(u, c), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createMigrateInstruction = e.migrateInstructionDiscriminator = e.MigrateStruct = void 0);
  const i = r(te),
    s = r(ne),
    o = uc;
  (e.MigrateStruct = new i.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['migrateArgs', o.migrateArgsBeet],
    ],
    'MigrateInstructionArgs'
  )),
    (e.migrateInstructionDiscriminator = 48);
  function a(c, u, l = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var d, f, h;
    const [p] = e.MigrateStruct.serialize({
        instructionDiscriminator: e.migrateInstructionDiscriminator,
        ...u,
      }),
      b = [
        { pubkey: c.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: c.edition, isWritable: !0, isSigner: !1 },
        { pubkey: c.token, isWritable: !0, isSigner: !1 },
        { pubkey: c.tokenOwner, isWritable: !1, isSigner: !1 },
        { pubkey: c.mint, isWritable: !1, isSigner: !1 },
        { pubkey: c.payer, isWritable: !0, isSigner: !0 },
        { pubkey: c.authority, isWritable: !1, isSigner: !0 },
        { pubkey: c.collectionMetadata, isWritable: !1, isSigner: !1 },
        { pubkey: c.delegateRecord, isWritable: !1, isSigner: !1 },
        { pubkey: c.tokenRecord, isWritable: !0, isSigner: !1 },
        {
          pubkey: (d = c.systemProgram) !== null && d !== void 0 ? d : s.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: c.sysvarInstructions, isWritable: !1, isSigner: !1 },
        { pubkey: c.splTokenProgram, isWritable: !1, isSigner: !1 },
        {
          pubkey: (f = c.authorizationRulesProgram) !== null && f !== void 0 ? f : l,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (h = c.authorizationRules) !== null && h !== void 0 ? h : l,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return new s.TransactionInstruction({ programId: l, keys: b, data: p });
  }
  e.createMigrateInstruction = a;
})(FD);
var KD = {},
  lc = {},
  Bce =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  Dce =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  Rce =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && Bce(t, e, n);
      return Dce(t, e), t;
    };
Object.defineProperty(lc, '__esModule', { value: !0 });
lc.mintArgsBeet = lc.isMintArgsV1 = void 0;
const cg = Rce(te),
  Nce = Wi,
  jce = (e) => e.__kind === 'V1';
lc.isMintArgsV1 = jce;
lc.mintArgsBeet = cg.dataEnum([
  [
    'V1',
    new cg.FixableBeetArgsStruct(
      [
        ['amount', cg.u64],
        ['authorizationData', cg.coption(Nce.authorizationDataBeet)],
      ],
      'MintArgsRecord["V1"]'
    ),
  ],
]);
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (c, u, l, d) {
            d === void 0 && (d = l);
            var f = Object.getOwnPropertyDescriptor(u, l);
            (!f || ('get' in f ? !u.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return u[l];
                },
              }),
              Object.defineProperty(c, d, f);
          }
        : function (c, u, l, d) {
            d === void 0 && (d = l), (c[d] = u[l]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (c, u) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: u });
          }
        : function (c, u) {
            c.default = u;
          }),
    r =
      (m && m.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var u = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(u, c, l);
        return n(u, c), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createMintInstruction = e.mintInstructionDiscriminator = e.MintStruct = void 0);
  const i = r(te),
    s = r(ne),
    o = lc;
  (e.MintStruct = new i.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['mintArgs', o.mintArgsBeet],
    ],
    'MintInstructionArgs'
  )),
    (e.mintInstructionDiscriminator = 43);
  function a(c, u, l = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var d, f, h, p, b, w, A;
    const [_] = e.MintStruct.serialize({
        instructionDiscriminator: e.mintInstructionDiscriminator,
        ...u,
      }),
      x = [
        { pubkey: c.token, isWritable: !0, isSigner: !1 },
        {
          pubkey: (d = c.tokenOwner) !== null && d !== void 0 ? d : l,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: c.metadata, isWritable: !1, isSigner: !1 },
        {
          pubkey: (f = c.masterEdition) !== null && f !== void 0 ? f : l,
          isWritable: c.masterEdition != null,
          isSigner: !1,
        },
        {
          pubkey: (h = c.tokenRecord) !== null && h !== void 0 ? h : l,
          isWritable: c.tokenRecord != null,
          isSigner: !1,
        },
        { pubkey: c.mint, isWritable: !0, isSigner: !1 },
        { pubkey: c.authority, isWritable: !1, isSigner: !0 },
        {
          pubkey: (p = c.delegateRecord) !== null && p !== void 0 ? p : l,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: c.payer, isWritable: !0, isSigner: !0 },
        {
          pubkey: (b = c.systemProgram) !== null && b !== void 0 ? b : s.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: c.sysvarInstructions, isWritable: !1, isSigner: !1 },
        { pubkey: c.splTokenProgram, isWritable: !1, isSigner: !1 },
        { pubkey: c.splAtaProgram, isWritable: !1, isSigner: !1 },
        {
          pubkey: (w = c.authorizationRulesProgram) !== null && w !== void 0 ? w : l,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (A = c.authorizationRules) !== null && A !== void 0 ? A : l,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return new s.TransactionInstruction({ programId: l, keys: x, data: _ });
  }
  e.createMintInstruction = a;
})(KD);
var VD = {},
  tl = {},
  Lce =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  Uce =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  $ce =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && Lce(t, e, n);
      return Uce(t, e), t;
    };
Object.defineProperty(tl, '__esModule', { value: !0 });
tl.mintNewEditionFromMasterEditionViaTokenArgsBeet = void 0;
const Q2 = $ce(te);
tl.mintNewEditionFromMasterEditionViaTokenArgsBeet = new Q2.BeetArgsStruct(
  [['edition', Q2.u64]],
  'MintNewEditionFromMasterEditionViaTokenArgs'
);
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (u, l, d, f) {
            f === void 0 && (f = d);
            var h = Object.getOwnPropertyDescriptor(l, d);
            (!h || ('get' in h ? !l.__esModule : h.writable || h.configurable)) &&
              (h = {
                enumerable: !0,
                get: function () {
                  return l[d];
                },
              }),
              Object.defineProperty(u, f, h);
          }
        : function (u, l, d, f) {
            f === void 0 && (f = d), (u[f] = l[d]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (u, l) {
            Object.defineProperty(u, 'default', { enumerable: !0, value: l });
          }
        : function (u, l) {
            u.default = l;
          }),
    r =
      (m && m.__importStar) ||
      function (u) {
        if (u && u.__esModule) return u;
        var l = {};
        if (u != null)
          for (var d in u)
            d !== 'default' && Object.prototype.hasOwnProperty.call(u, d) && t(l, u, d);
        return n(l, u), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createMintNewEditionFromMasterEditionViaTokenInstruction =
      e.mintNewEditionFromMasterEditionViaTokenInstructionDiscriminator =
      e.MintNewEditionFromMasterEditionViaTokenStruct =
        void 0);
  const i = r(_r),
    s = r(te),
    o = r(ne),
    a = tl;
  (e.MintNewEditionFromMasterEditionViaTokenStruct = new s.BeetArgsStruct(
    [
      ['instructionDiscriminator', s.u8],
      [
        'mintNewEditionFromMasterEditionViaTokenArgs',
        a.mintNewEditionFromMasterEditionViaTokenArgsBeet,
      ],
    ],
    'MintNewEditionFromMasterEditionViaTokenInstructionArgs'
  )),
    (e.mintNewEditionFromMasterEditionViaTokenInstructionDiscriminator = 11);
  function c(u, l, d = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var f, h;
    const [p] = e.MintNewEditionFromMasterEditionViaTokenStruct.serialize({
        instructionDiscriminator: e.mintNewEditionFromMasterEditionViaTokenInstructionDiscriminator,
        ...l,
      }),
      b = [
        { pubkey: u.newMetadata, isWritable: !0, isSigner: !1 },
        { pubkey: u.newEdition, isWritable: !0, isSigner: !1 },
        { pubkey: u.masterEdition, isWritable: !0, isSigner: !1 },
        { pubkey: u.newMint, isWritable: !0, isSigner: !1 },
        { pubkey: u.editionMarkPda, isWritable: !0, isSigner: !1 },
        { pubkey: u.newMintAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: u.payer, isWritable: !0, isSigner: !0 },
        { pubkey: u.tokenAccountOwner, isWritable: !1, isSigner: !0 },
        { pubkey: u.tokenAccount, isWritable: !1, isSigner: !1 },
        { pubkey: u.newMetadataUpdateAuthority, isWritable: !1, isSigner: !1 },
        { pubkey: u.metadata, isWritable: !1, isSigner: !1 },
        {
          pubkey: (f = u.tokenProgram) !== null && f !== void 0 ? f : i.TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (h = u.systemProgram) !== null && h !== void 0 ? h : o.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return (
      u.rent != null && b.push({ pubkey: u.rent, isWritable: !1, isSigner: !1 }),
      new o.TransactionInstruction({ programId: d, keys: b, data: p })
    );
  }
  e.createMintNewEditionFromMasterEditionViaTokenInstruction = c;
})(VD);
var WD = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (u, l, d, f) {
            f === void 0 && (f = d);
            var h = Object.getOwnPropertyDescriptor(l, d);
            (!h || ('get' in h ? !l.__esModule : h.writable || h.configurable)) &&
              (h = {
                enumerable: !0,
                get: function () {
                  return l[d];
                },
              }),
              Object.defineProperty(u, f, h);
          }
        : function (u, l, d, f) {
            f === void 0 && (f = d), (u[f] = l[d]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (u, l) {
            Object.defineProperty(u, 'default', { enumerable: !0, value: l });
          }
        : function (u, l) {
            u.default = l;
          }),
    r =
      (m && m.__importStar) ||
      function (u) {
        if (u && u.__esModule) return u;
        var l = {};
        if (u != null)
          for (var d in u)
            d !== 'default' && Object.prototype.hasOwnProperty.call(u, d) && t(l, u, d);
        return n(l, u), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createMintNewEditionFromMasterEditionViaVaultProxyInstruction =
      e.mintNewEditionFromMasterEditionViaVaultProxyInstructionDiscriminator =
      e.MintNewEditionFromMasterEditionViaVaultProxyStruct =
        void 0);
  const i = r(_r),
    s = r(te),
    o = r(ne),
    a = tl;
  (e.MintNewEditionFromMasterEditionViaVaultProxyStruct = new s.BeetArgsStruct(
    [
      ['instructionDiscriminator', s.u8],
      [
        'mintNewEditionFromMasterEditionViaTokenArgs',
        a.mintNewEditionFromMasterEditionViaTokenArgsBeet,
      ],
    ],
    'MintNewEditionFromMasterEditionViaVaultProxyInstructionArgs'
  )),
    (e.mintNewEditionFromMasterEditionViaVaultProxyInstructionDiscriminator = 13);
  function c(u, l, d = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var f, h;
    const [p] = e.MintNewEditionFromMasterEditionViaVaultProxyStruct.serialize({
        instructionDiscriminator:
          e.mintNewEditionFromMasterEditionViaVaultProxyInstructionDiscriminator,
        ...l,
      }),
      b = [
        { pubkey: u.newMetadata, isWritable: !0, isSigner: !1 },
        { pubkey: u.newEdition, isWritable: !0, isSigner: !1 },
        { pubkey: u.masterEdition, isWritable: !0, isSigner: !1 },
        { pubkey: u.newMint, isWritable: !0, isSigner: !1 },
        { pubkey: u.editionMarkPda, isWritable: !0, isSigner: !1 },
        { pubkey: u.newMintAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: u.payer, isWritable: !0, isSigner: !0 },
        { pubkey: u.vaultAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: u.safetyDepositStore, isWritable: !1, isSigner: !1 },
        { pubkey: u.safetyDepositBox, isWritable: !1, isSigner: !1 },
        { pubkey: u.vault, isWritable: !1, isSigner: !1 },
        { pubkey: u.newMetadataUpdateAuthority, isWritable: !1, isSigner: !1 },
        { pubkey: u.metadata, isWritable: !1, isSigner: !1 },
        {
          pubkey: (f = u.tokenProgram) !== null && f !== void 0 ? f : i.TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: u.tokenVaultProgram, isWritable: !1, isSigner: !1 },
        {
          pubkey: (h = u.systemProgram) !== null && h !== void 0 ? h : o.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return (
      u.rent != null && b.push({ pubkey: u.rent, isWritable: !1, isSigner: !1 }),
      new o.TransactionInstruction({ programId: d, keys: b, data: p })
    );
  }
  e.createMintNewEditionFromMasterEditionViaVaultProxyInstruction = c;
})(WD);
var HD = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (a, c, u, l) {
            l === void 0 && (l = u);
            var d = Object.getOwnPropertyDescriptor(c, u);
            (!d || ('get' in d ? !c.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return c[u];
                },
              }),
              Object.defineProperty(a, l, d);
          }
        : function (a, c, u, l) {
            l === void 0 && (l = u), (a[l] = c[u]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (m && m.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var u in a)
            u !== 'default' && Object.prototype.hasOwnProperty.call(a, u) && t(c, a, u);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createPuffMetadataInstruction =
      e.puffMetadataInstructionDiscriminator =
      e.PuffMetadataStruct =
        void 0);
  const i = r(te),
    s = r(ne);
  (e.PuffMetadataStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'PuffMetadataInstructionArgs'
  )),
    (e.puffMetadataInstructionDiscriminator = 14);
  function o(a, c = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [u] = e.PuffMetadataStruct.serialize({
        instructionDiscriminator: e.puffMetadataInstructionDiscriminator,
      }),
      l = [{ pubkey: a.metadata, isWritable: !0, isSigner: !1 }];
    return new s.TransactionInstruction({ programId: c, keys: l, data: u });
  }
  e.createPuffMetadataInstruction = o;
})(HD);
var GD = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (a, c, u, l) {
            l === void 0 && (l = u);
            var d = Object.getOwnPropertyDescriptor(c, u);
            (!d || ('get' in d ? !c.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return c[u];
                },
              }),
              Object.defineProperty(a, l, d);
          }
        : function (a, c, u, l) {
            l === void 0 && (l = u), (a[l] = c[u]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (m && m.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var u in a)
            u !== 'default' && Object.prototype.hasOwnProperty.call(a, u) && t(c, a, u);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createRemoveCreatorVerificationInstruction =
      e.removeCreatorVerificationInstructionDiscriminator =
      e.RemoveCreatorVerificationStruct =
        void 0);
  const i = r(te),
    s = r(ne);
  (e.RemoveCreatorVerificationStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'RemoveCreatorVerificationInstructionArgs'
  )),
    (e.removeCreatorVerificationInstructionDiscriminator = 28);
  function o(a, c = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [u] = e.RemoveCreatorVerificationStruct.serialize({
        instructionDiscriminator: e.removeCreatorVerificationInstructionDiscriminator,
      }),
      l = [
        { pubkey: a.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: a.creator, isWritable: !1, isSigner: !0 },
      ];
    return new s.TransactionInstruction({ programId: c, keys: l, data: u });
  }
  e.createRemoveCreatorVerificationInstruction = o;
})(GD);
var qD = {},
  UI = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (o, a, c, u) {
            u === void 0 && (u = c);
            var l = Object.getOwnPropertyDescriptor(a, c);
            (!l || ('get' in l ? !a.__esModule : l.writable || l.configurable)) &&
              (l = {
                enumerable: !0,
                get: function () {
                  return a[c];
                },
              }),
              Object.defineProperty(o, u, l);
          }
        : function (o, a, c, u) {
            u === void 0 && (u = c), (o[u] = a[c]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (o, a) {
            Object.defineProperty(o, 'default', { enumerable: !0, value: a });
          }
        : function (o, a) {
            o.default = a;
          }),
    r =
      (m && m.__importStar) ||
      function (o) {
        if (o && o.__esModule) return o;
        var a = {};
        if (o != null)
          for (var c in o)
            c !== 'default' && Object.prototype.hasOwnProperty.call(o, c) && t(a, o, c);
        return n(a, o), a;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }), (e.revokeArgsBeet = e.RevokeArgs = void 0);
  const i = r(te);
  var s;
  (function (o) {
    (o[(o.CollectionV1 = 0)] = 'CollectionV1'),
      (o[(o.SaleV1 = 1)] = 'SaleV1'),
      (o[(o.TransferV1 = 2)] = 'TransferV1'),
      (o[(o.DataV1 = 3)] = 'DataV1'),
      (o[(o.UtilityV1 = 4)] = 'UtilityV1'),
      (o[(o.StakingV1 = 5)] = 'StakingV1'),
      (o[(o.StandardV1 = 6)] = 'StandardV1'),
      (o[(o.LockedTransferV1 = 7)] = 'LockedTransferV1'),
      (o[(o.ProgrammableConfigV1 = 8)] = 'ProgrammableConfigV1'),
      (o[(o.MigrationV1 = 9)] = 'MigrationV1'),
      (o[(o.AuthorityItemV1 = 10)] = 'AuthorityItemV1'),
      (o[(o.DataItemV1 = 11)] = 'DataItemV1'),
      (o[(o.CollectionItemV1 = 12)] = 'CollectionItemV1'),
      (o[(o.ProgrammableConfigItemV1 = 13)] = 'ProgrammableConfigItemV1');
  })((s = e.RevokeArgs || (e.RevokeArgs = {}))),
    (e.revokeArgsBeet = i.fixedScalarEnum(s));
})(UI);
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (c, u, l, d) {
            d === void 0 && (d = l);
            var f = Object.getOwnPropertyDescriptor(u, l);
            (!f || ('get' in f ? !u.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return u[l];
                },
              }),
              Object.defineProperty(c, d, f);
          }
        : function (c, u, l, d) {
            d === void 0 && (d = l), (c[d] = u[l]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (c, u) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: u });
          }
        : function (c, u) {
            c.default = u;
          }),
    r =
      (m && m.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var u = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(u, c, l);
        return n(u, c), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createRevokeInstruction = e.revokeInstructionDiscriminator = e.RevokeStruct = void 0);
  const i = r(te),
    s = r(ne),
    o = UI;
  (e.RevokeStruct = new i.BeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['revokeArgs', o.revokeArgsBeet],
    ],
    'RevokeInstructionArgs'
  )),
    (e.revokeInstructionDiscriminator = 45);
  function a(c, u, l = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var d, f, h, p, b, w, A, _;
    const [x] = e.RevokeStruct.serialize({
        instructionDiscriminator: e.revokeInstructionDiscriminator,
        ...u,
      }),
      k = [
        {
          pubkey: (d = c.delegateRecord) !== null && d !== void 0 ? d : l,
          isWritable: c.delegateRecord != null,
          isSigner: !1,
        },
        { pubkey: c.delegate, isWritable: !1, isSigner: !1 },
        { pubkey: c.metadata, isWritable: !0, isSigner: !1 },
        {
          pubkey: (f = c.masterEdition) !== null && f !== void 0 ? f : l,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (h = c.tokenRecord) !== null && h !== void 0 ? h : l,
          isWritable: c.tokenRecord != null,
          isSigner: !1,
        },
        { pubkey: c.mint, isWritable: !1, isSigner: !1 },
        {
          pubkey: (p = c.token) !== null && p !== void 0 ? p : l,
          isWritable: c.token != null,
          isSigner: !1,
        },
        { pubkey: c.authority, isWritable: !1, isSigner: !0 },
        { pubkey: c.payer, isWritable: !0, isSigner: !0 },
        {
          pubkey: (b = c.systemProgram) !== null && b !== void 0 ? b : s.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: c.sysvarInstructions, isWritable: !1, isSigner: !1 },
        {
          pubkey: (w = c.splTokenProgram) !== null && w !== void 0 ? w : l,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (A = c.authorizationRulesProgram) !== null && A !== void 0 ? A : l,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (_ = c.authorizationRules) !== null && _ !== void 0 ? _ : l,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return new s.TransactionInstruction({ programId: l, keys: k, data: x });
  }
  e.createRevokeInstruction = a;
})(qD);
var YD = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (a, c, u, l) {
            l === void 0 && (l = u);
            var d = Object.getOwnPropertyDescriptor(c, u);
            (!d || ('get' in d ? !c.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return c[u];
                },
              }),
              Object.defineProperty(a, l, d);
          }
        : function (a, c, u, l) {
            l === void 0 && (l = u), (a[l] = c[u]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (m && m.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var u in a)
            u !== 'default' && Object.prototype.hasOwnProperty.call(a, u) && t(c, a, u);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createRevokeCollectionAuthorityInstruction =
      e.revokeCollectionAuthorityInstructionDiscriminator =
      e.RevokeCollectionAuthorityStruct =
        void 0);
  const i = r(te),
    s = r(ne);
  (e.RevokeCollectionAuthorityStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'RevokeCollectionAuthorityInstructionArgs'
  )),
    (e.revokeCollectionAuthorityInstructionDiscriminator = 24);
  function o(a, c = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [u] = e.RevokeCollectionAuthorityStruct.serialize({
        instructionDiscriminator: e.revokeCollectionAuthorityInstructionDiscriminator,
      }),
      l = [
        { pubkey: a.collectionAuthorityRecord, isWritable: !0, isSigner: !1 },
        { pubkey: a.delegateAuthority, isWritable: !0, isSigner: !1 },
        { pubkey: a.revokeAuthority, isWritable: !0, isSigner: !0 },
        { pubkey: a.metadata, isWritable: !1, isSigner: !1 },
        { pubkey: a.mint, isWritable: !1, isSigner: !1 },
      ];
    return new s.TransactionInstruction({ programId: c, keys: l, data: u });
  }
  e.createRevokeCollectionAuthorityInstruction = o;
})(YD);
var ZD = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (c, u, l, d) {
            d === void 0 && (d = l);
            var f = Object.getOwnPropertyDescriptor(u, l);
            (!f || ('get' in f ? !u.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return u[l];
                },
              }),
              Object.defineProperty(c, d, f);
          }
        : function (c, u, l, d) {
            d === void 0 && (d = l), (c[d] = u[l]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (c, u) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: u });
          }
        : function (c, u) {
            c.default = u;
          }),
    r =
      (m && m.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var u = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(u, c, l);
        return n(u, c), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createRevokeUseAuthorityInstruction =
      e.revokeUseAuthorityInstructionDiscriminator =
      e.RevokeUseAuthorityStruct =
        void 0);
  const i = r(_r),
    s = r(te),
    o = r(ne);
  (e.RevokeUseAuthorityStruct = new s.BeetArgsStruct(
    [['instructionDiscriminator', s.u8]],
    'RevokeUseAuthorityInstructionArgs'
  )),
    (e.revokeUseAuthorityInstructionDiscriminator = 21);
  function a(c, u = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var l, d;
    const [f] = e.RevokeUseAuthorityStruct.serialize({
        instructionDiscriminator: e.revokeUseAuthorityInstructionDiscriminator,
      }),
      h = [
        { pubkey: c.useAuthorityRecord, isWritable: !0, isSigner: !1 },
        { pubkey: c.owner, isWritable: !0, isSigner: !0 },
        { pubkey: c.user, isWritable: !1, isSigner: !1 },
        { pubkey: c.ownerTokenAccount, isWritable: !0, isSigner: !1 },
        { pubkey: c.mint, isWritable: !1, isSigner: !1 },
        { pubkey: c.metadata, isWritable: !1, isSigner: !1 },
        {
          pubkey: (l = c.tokenProgram) !== null && l !== void 0 ? l : i.TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (d = c.systemProgram) !== null && d !== void 0 ? d : o.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return (
      c.rent != null && h.push({ pubkey: c.rent, isWritable: !1, isSigner: !1 }),
      new o.TransactionInstruction({ programId: u, keys: h, data: f })
    );
  }
  e.createRevokeUseAuthorityInstruction = a;
})(ZD);
var JD = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (a, c, u, l) {
            l === void 0 && (l = u);
            var d = Object.getOwnPropertyDescriptor(c, u);
            (!d || ('get' in d ? !c.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return c[u];
                },
              }),
              Object.defineProperty(a, l, d);
          }
        : function (a, c, u, l) {
            l === void 0 && (l = u), (a[l] = c[u]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (m && m.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var u in a)
            u !== 'default' && Object.prototype.hasOwnProperty.call(a, u) && t(c, a, u);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createSetAndVerifyCollectionInstruction =
      e.setAndVerifyCollectionInstructionDiscriminator =
      e.SetAndVerifyCollectionStruct =
        void 0);
  const i = r(te),
    s = r(ne);
  (e.SetAndVerifyCollectionStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'SetAndVerifyCollectionInstructionArgs'
  )),
    (e.setAndVerifyCollectionInstructionDiscriminator = 25);
  function o(a, c = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [u] = e.SetAndVerifyCollectionStruct.serialize({
        instructionDiscriminator: e.setAndVerifyCollectionInstructionDiscriminator,
      }),
      l = [
        { pubkey: a.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: a.collectionAuthority, isWritable: !0, isSigner: !0 },
        { pubkey: a.payer, isWritable: !0, isSigner: !0 },
        { pubkey: a.updateAuthority, isWritable: !1, isSigner: !1 },
        { pubkey: a.collectionMint, isWritable: !1, isSigner: !1 },
        { pubkey: a.collection, isWritable: !1, isSigner: !1 },
        { pubkey: a.collectionMasterEditionAccount, isWritable: !1, isSigner: !1 },
      ];
    return (
      a.collectionAuthorityRecord != null &&
        l.push({ pubkey: a.collectionAuthorityRecord, isWritable: !1, isSigner: !1 }),
      new s.TransactionInstruction({ programId: c, keys: l, data: u })
    );
  }
  e.createSetAndVerifyCollectionInstruction = o;
})(JD);
var XD = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (a, c, u, l) {
            l === void 0 && (l = u);
            var d = Object.getOwnPropertyDescriptor(c, u);
            (!d || ('get' in d ? !c.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return c[u];
                },
              }),
              Object.defineProperty(a, l, d);
          }
        : function (a, c, u, l) {
            l === void 0 && (l = u), (a[l] = c[u]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (m && m.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var u in a)
            u !== 'default' && Object.prototype.hasOwnProperty.call(a, u) && t(c, a, u);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createSetAndVerifySizedCollectionItemInstruction =
      e.setAndVerifySizedCollectionItemInstructionDiscriminator =
      e.SetAndVerifySizedCollectionItemStruct =
        void 0);
  const i = r(te),
    s = r(ne);
  (e.SetAndVerifySizedCollectionItemStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'SetAndVerifySizedCollectionItemInstructionArgs'
  )),
    (e.setAndVerifySizedCollectionItemInstructionDiscriminator = 32);
  function o(a, c = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [u] = e.SetAndVerifySizedCollectionItemStruct.serialize({
        instructionDiscriminator: e.setAndVerifySizedCollectionItemInstructionDiscriminator,
      }),
      l = [
        { pubkey: a.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: a.collectionAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: a.payer, isWritable: !0, isSigner: !0 },
        { pubkey: a.updateAuthority, isWritable: !1, isSigner: !1 },
        { pubkey: a.collectionMint, isWritable: !1, isSigner: !1 },
        { pubkey: a.collection, isWritable: !0, isSigner: !1 },
        { pubkey: a.collectionMasterEditionAccount, isWritable: !0, isSigner: !1 },
      ];
    return (
      a.collectionAuthorityRecord != null &&
        l.push({ pubkey: a.collectionAuthorityRecord, isWritable: !1, isSigner: !1 }),
      new s.TransactionInstruction({ programId: c, keys: l, data: u })
    );
  }
  e.createSetAndVerifySizedCollectionItemInstruction = o;
})(XD);
var QD = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (c, u, l, d) {
            d === void 0 && (d = l);
            var f = Object.getOwnPropertyDescriptor(u, l);
            (!f || ('get' in f ? !u.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return u[l];
                },
              }),
              Object.defineProperty(c, d, f);
          }
        : function (c, u, l, d) {
            d === void 0 && (d = l), (c[d] = u[l]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (c, u) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: u });
          }
        : function (c, u) {
            c.default = u;
          }),
    r =
      (m && m.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var u = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(u, c, l);
        return n(u, c), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createSetCollectionSizeInstruction =
      e.setCollectionSizeInstructionDiscriminator =
      e.SetCollectionSizeStruct =
        void 0);
  const i = r(te),
    s = r(ne),
    o = Qu;
  (e.SetCollectionSizeStruct = new i.BeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['setCollectionSizeArgs', o.setCollectionSizeArgsBeet],
    ],
    'SetCollectionSizeInstructionArgs'
  )),
    (e.setCollectionSizeInstructionDiscriminator = 34);
  function a(c, u, l = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [d] = e.SetCollectionSizeStruct.serialize({
        instructionDiscriminator: e.setCollectionSizeInstructionDiscriminator,
        ...u,
      }),
      f = [
        { pubkey: c.collectionMetadata, isWritable: !0, isSigner: !1 },
        { pubkey: c.collectionAuthority, isWritable: !0, isSigner: !0 },
        { pubkey: c.collectionMint, isWritable: !1, isSigner: !1 },
      ];
    return (
      c.collectionAuthorityRecord != null &&
        f.push({ pubkey: c.collectionAuthorityRecord, isWritable: !1, isSigner: !1 }),
      new s.TransactionInstruction({ programId: l, keys: f, data: d })
    );
  }
  e.createSetCollectionSizeInstruction = a;
})(QD);
var e5 = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (a, c, u, l) {
            l === void 0 && (l = u);
            var d = Object.getOwnPropertyDescriptor(c, u);
            (!d || ('get' in d ? !c.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return c[u];
                },
              }),
              Object.defineProperty(a, l, d);
          }
        : function (a, c, u, l) {
            l === void 0 && (l = u), (a[l] = c[u]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (m && m.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var u in a)
            u !== 'default' && Object.prototype.hasOwnProperty.call(a, u) && t(c, a, u);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createSetTokenStandardInstruction =
      e.setTokenStandardInstructionDiscriminator =
      e.SetTokenStandardStruct =
        void 0);
  const i = r(te),
    s = r(ne);
  (e.SetTokenStandardStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'SetTokenStandardInstructionArgs'
  )),
    (e.setTokenStandardInstructionDiscriminator = 35);
  function o(a, c = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [u] = e.SetTokenStandardStruct.serialize({
        instructionDiscriminator: e.setTokenStandardInstructionDiscriminator,
      }),
      l = [
        { pubkey: a.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: a.updateAuthority, isWritable: !0, isSigner: !0 },
        { pubkey: a.mint, isWritable: !1, isSigner: !1 },
      ];
    return (
      a.edition != null && l.push({ pubkey: a.edition, isWritable: !1, isSigner: !1 }),
      new s.TransactionInstruction({ programId: c, keys: l, data: u })
    );
  }
  e.createSetTokenStandardInstruction = o;
})(e5);
var t5 = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (a, c, u, l) {
            l === void 0 && (l = u);
            var d = Object.getOwnPropertyDescriptor(c, u);
            (!d || ('get' in d ? !c.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return c[u];
                },
              }),
              Object.defineProperty(a, l, d);
          }
        : function (a, c, u, l) {
            l === void 0 && (l = u), (a[l] = c[u]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (m && m.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var u in a)
            u !== 'default' && Object.prototype.hasOwnProperty.call(a, u) && t(c, a, u);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createSignMetadataInstruction =
      e.signMetadataInstructionDiscriminator =
      e.SignMetadataStruct =
        void 0);
  const i = r(te),
    s = r(ne);
  (e.SignMetadataStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'SignMetadataInstructionArgs'
  )),
    (e.signMetadataInstructionDiscriminator = 7);
  function o(a, c = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [u] = e.SignMetadataStruct.serialize({
        instructionDiscriminator: e.signMetadataInstructionDiscriminator,
      }),
      l = [
        { pubkey: a.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: a.creator, isWritable: !1, isSigner: !0 },
      ];
    return new s.TransactionInstruction({ programId: c, keys: l, data: u });
  }
  e.createSignMetadataInstruction = o;
})(t5);
var n5 = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (c, u, l, d) {
            d === void 0 && (d = l);
            var f = Object.getOwnPropertyDescriptor(u, l);
            (!f || ('get' in f ? !u.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return u[l];
                },
              }),
              Object.defineProperty(c, d, f);
          }
        : function (c, u, l, d) {
            d === void 0 && (d = l), (c[d] = u[l]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (c, u) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: u });
          }
        : function (c, u) {
            c.default = u;
          }),
    r =
      (m && m.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var u = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(u, c, l);
        return n(u, c), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createThawDelegatedAccountInstruction =
      e.thawDelegatedAccountInstructionDiscriminator =
      e.ThawDelegatedAccountStruct =
        void 0);
  const i = r(_r),
    s = r(te),
    o = r(ne);
  (e.ThawDelegatedAccountStruct = new s.BeetArgsStruct(
    [['instructionDiscriminator', s.u8]],
    'ThawDelegatedAccountInstructionArgs'
  )),
    (e.thawDelegatedAccountInstructionDiscriminator = 27);
  function a(c, u = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var l;
    const [d] = e.ThawDelegatedAccountStruct.serialize({
        instructionDiscriminator: e.thawDelegatedAccountInstructionDiscriminator,
      }),
      f = [
        { pubkey: c.delegate, isWritable: !0, isSigner: !0 },
        { pubkey: c.tokenAccount, isWritable: !0, isSigner: !1 },
        { pubkey: c.edition, isWritable: !1, isSigner: !1 },
        { pubkey: c.mint, isWritable: !1, isSigner: !1 },
        {
          pubkey: (l = c.tokenProgram) !== null && l !== void 0 ? l : i.TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return new o.TransactionInstruction({ programId: u, keys: f, data: d });
  }
  e.createThawDelegatedAccountInstruction = a;
})(n5);
var r5 = {},
  dc = {},
  Fce =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  zce =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  Kce =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && Fce(t, e, n);
      return zce(t, e), t;
    };
Object.defineProperty(dc, '__esModule', { value: !0 });
dc.transferArgsBeet = dc.isTransferArgsV1 = void 0;
const ug = Kce(te),
  Vce = Wi,
  Wce = (e) => e.__kind === 'V1';
dc.isTransferArgsV1 = Wce;
dc.transferArgsBeet = ug.dataEnum([
  [
    'V1',
    new ug.FixableBeetArgsStruct(
      [
        ['amount', ug.u64],
        ['authorizationData', ug.coption(Vce.authorizationDataBeet)],
      ],
      'TransferArgsRecord["V1"]'
    ),
  ],
]);
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (c, u, l, d) {
            d === void 0 && (d = l);
            var f = Object.getOwnPropertyDescriptor(u, l);
            (!f || ('get' in f ? !u.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return u[l];
                },
              }),
              Object.defineProperty(c, d, f);
          }
        : function (c, u, l, d) {
            d === void 0 && (d = l), (c[d] = u[l]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (c, u) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: u });
          }
        : function (c, u) {
            c.default = u;
          }),
    r =
      (m && m.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var u = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(u, c, l);
        return n(u, c), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createTransferInstruction = e.transferInstructionDiscriminator = e.TransferStruct = void 0);
  const i = r(te),
    s = r(ne),
    o = dc;
  (e.TransferStruct = new i.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['transferArgs', o.transferArgsBeet],
    ],
    'TransferInstructionArgs'
  )),
    (e.transferInstructionDiscriminator = 49);
  function a(c, u, l = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var d, f, h, p, b, w;
    const [A] = e.TransferStruct.serialize({
        instructionDiscriminator: e.transferInstructionDiscriminator,
        ...u,
      }),
      _ = [
        { pubkey: c.token, isWritable: !0, isSigner: !1 },
        { pubkey: c.tokenOwner, isWritable: !1, isSigner: !1 },
        { pubkey: c.destination, isWritable: !0, isSigner: !1 },
        { pubkey: c.destinationOwner, isWritable: !1, isSigner: !1 },
        { pubkey: c.mint, isWritable: !1, isSigner: !1 },
        { pubkey: c.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: (d = c.edition) !== null && d !== void 0 ? d : l, isWritable: !1, isSigner: !1 },
        {
          pubkey: (f = c.ownerTokenRecord) !== null && f !== void 0 ? f : l,
          isWritable: c.ownerTokenRecord != null,
          isSigner: !1,
        },
        {
          pubkey: (h = c.destinationTokenRecord) !== null && h !== void 0 ? h : l,
          isWritable: c.destinationTokenRecord != null,
          isSigner: !1,
        },
        { pubkey: c.authority, isWritable: !1, isSigner: !0 },
        { pubkey: c.payer, isWritable: !0, isSigner: !0 },
        {
          pubkey: (p = c.systemProgram) !== null && p !== void 0 ? p : s.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: c.sysvarInstructions, isWritable: !1, isSigner: !1 },
        { pubkey: c.splTokenProgram, isWritable: !1, isSigner: !1 },
        { pubkey: c.splAtaProgram, isWritable: !1, isSigner: !1 },
        {
          pubkey: (b = c.authorizationRulesProgram) !== null && b !== void 0 ? b : l,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (w = c.authorizationRules) !== null && w !== void 0 ? w : l,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return new s.TransactionInstruction({ programId: l, keys: _, data: A });
  }
  e.createTransferInstruction = a;
})(r5);
var i5 = {},
  _p = {},
  Hce =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  Gce =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  qce =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && Hce(t, e, n);
      return Gce(t, e), t;
    };
Object.defineProperty(_p, '__esModule', { value: !0 });
_p.transferOutOfEscrowArgsBeet = void 0;
const e3 = qce(te);
_p.transferOutOfEscrowArgsBeet = new e3.BeetArgsStruct(
  [['amount', e3.u64]],
  'TransferOutOfEscrowArgs'
);
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (u, l, d, f) {
            f === void 0 && (f = d);
            var h = Object.getOwnPropertyDescriptor(l, d);
            (!h || ('get' in h ? !l.__esModule : h.writable || h.configurable)) &&
              (h = {
                enumerable: !0,
                get: function () {
                  return l[d];
                },
              }),
              Object.defineProperty(u, f, h);
          }
        : function (u, l, d, f) {
            f === void 0 && (f = d), (u[f] = l[d]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (u, l) {
            Object.defineProperty(u, 'default', { enumerable: !0, value: l });
          }
        : function (u, l) {
            u.default = l;
          }),
    r =
      (m && m.__importStar) ||
      function (u) {
        if (u && u.__esModule) return u;
        var l = {};
        if (u != null)
          for (var d in u)
            d !== 'default' && Object.prototype.hasOwnProperty.call(u, d) && t(l, u, d);
        return n(l, u), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createTransferOutOfEscrowInstruction =
      e.transferOutOfEscrowInstructionDiscriminator =
      e.TransferOutOfEscrowStruct =
        void 0);
  const i = r(_r),
    s = r(te),
    o = r(ne),
    a = _p;
  (e.TransferOutOfEscrowStruct = new s.BeetArgsStruct(
    [
      ['instructionDiscriminator', s.u8],
      ['transferOutOfEscrowArgs', a.transferOutOfEscrowArgsBeet],
    ],
    'TransferOutOfEscrowInstructionArgs'
  )),
    (e.transferOutOfEscrowInstructionDiscriminator = 40);
  function c(u, l, d = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var f, h, p;
    const [b] = e.TransferOutOfEscrowStruct.serialize({
        instructionDiscriminator: e.transferOutOfEscrowInstructionDiscriminator,
        ...l,
      }),
      w = [
        { pubkey: u.escrow, isWritable: !1, isSigner: !1 },
        { pubkey: u.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: u.payer, isWritable: !0, isSigner: !0 },
        { pubkey: u.attributeMint, isWritable: !1, isSigner: !1 },
        { pubkey: u.attributeSrc, isWritable: !0, isSigner: !1 },
        { pubkey: u.attributeDst, isWritable: !0, isSigner: !1 },
        { pubkey: u.escrowMint, isWritable: !1, isSigner: !1 },
        { pubkey: u.escrowAccount, isWritable: !1, isSigner: !1 },
        {
          pubkey: (f = u.systemProgram) !== null && f !== void 0 ? f : o.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (h = u.ataProgram) !== null && h !== void 0 ? h : i.ASSOCIATED_TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (p = u.tokenProgram) !== null && p !== void 0 ? p : i.TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: u.sysvarInstructions, isWritable: !1, isSigner: !1 },
      ];
    return (
      u.authority != null && w.push({ pubkey: u.authority, isWritable: !1, isSigner: !0 }),
      new o.TransactionInstruction({ programId: d, keys: w, data: b })
    );
  }
  e.createTransferOutOfEscrowInstruction = c;
})(i5);
var s5 = {},
  fc = {},
  Yce =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  Zce =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  Jce =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && Yce(t, e, n);
      return Zce(t, e), t;
    };
Object.defineProperty(fc, '__esModule', { value: !0 });
fc.unlockArgsBeet = fc.isUnlockArgsV1 = void 0;
const Wv = Jce(te),
  Xce = Wi,
  Qce = (e) => e.__kind === 'V1';
fc.isUnlockArgsV1 = Qce;
fc.unlockArgsBeet = Wv.dataEnum([
  [
    'V1',
    new Wv.FixableBeetArgsStruct(
      [['authorizationData', Wv.coption(Xce.authorizationDataBeet)]],
      'UnlockArgsRecord["V1"]'
    ),
  ],
]);
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (c, u, l, d) {
            d === void 0 && (d = l);
            var f = Object.getOwnPropertyDescriptor(u, l);
            (!f || ('get' in f ? !u.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return u[l];
                },
              }),
              Object.defineProperty(c, d, f);
          }
        : function (c, u, l, d) {
            d === void 0 && (d = l), (c[d] = u[l]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (c, u) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: u });
          }
        : function (c, u) {
            c.default = u;
          }),
    r =
      (m && m.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var u = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(u, c, l);
        return n(u, c), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createUnlockInstruction = e.unlockInstructionDiscriminator = e.UnlockStruct = void 0);
  const i = r(te),
    s = r(ne),
    o = fc;
  (e.UnlockStruct = new i.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['unlockArgs', o.unlockArgsBeet],
    ],
    'UnlockInstructionArgs'
  )),
    (e.unlockInstructionDiscriminator = 47);
  function a(c, u, l = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var d, f, h, p, b, w, A;
    const [_] = e.UnlockStruct.serialize({
        instructionDiscriminator: e.unlockInstructionDiscriminator,
        ...u,
      }),
      x = [
        { pubkey: c.authority, isWritable: !1, isSigner: !0 },
        {
          pubkey: (d = c.tokenOwner) !== null && d !== void 0 ? d : l,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: c.token, isWritable: !0, isSigner: !1 },
        { pubkey: c.mint, isWritable: !1, isSigner: !1 },
        { pubkey: c.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: (f = c.edition) !== null && f !== void 0 ? f : l, isWritable: !1, isSigner: !1 },
        {
          pubkey: (h = c.tokenRecord) !== null && h !== void 0 ? h : l,
          isWritable: c.tokenRecord != null,
          isSigner: !1,
        },
        { pubkey: c.payer, isWritable: !0, isSigner: !0 },
        {
          pubkey: (p = c.systemProgram) !== null && p !== void 0 ? p : s.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: c.sysvarInstructions, isWritable: !1, isSigner: !1 },
        {
          pubkey: (b = c.splTokenProgram) !== null && b !== void 0 ? b : l,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (w = c.authorizationRulesProgram) !== null && w !== void 0 ? w : l,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (A = c.authorizationRules) !== null && A !== void 0 ? A : l,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return new s.TransactionInstruction({ programId: l, keys: x, data: _ });
  }
  e.createUnlockInstruction = a;
})(s5);
var o5 = {},
  e1 = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (o, a, c, u) {
            u === void 0 && (u = c);
            var l = Object.getOwnPropertyDescriptor(a, c);
            (!l || ('get' in l ? !a.__esModule : l.writable || l.configurable)) &&
              (l = {
                enumerable: !0,
                get: function () {
                  return a[c];
                },
              }),
              Object.defineProperty(o, u, l);
          }
        : function (o, a, c, u) {
            u === void 0 && (u = c), (o[u] = a[c]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (o, a) {
            Object.defineProperty(o, 'default', { enumerable: !0, value: a });
          }
        : function (o, a) {
            o.default = a;
          }),
    r =
      (m && m.__importStar) ||
      function (o) {
        if (o && o.__esModule) return o;
        var a = {};
        if (o != null)
          for (var c in o)
            c !== 'default' && Object.prototype.hasOwnProperty.call(o, c) && t(a, o, c);
        return n(a, o), a;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.verificationArgsBeet = e.VerificationArgs = void 0);
  const i = r(te);
  var s;
  (function (o) {
    (o[(o.CreatorV1 = 0)] = 'CreatorV1'), (o[(o.CollectionV1 = 1)] = 'CollectionV1');
  })((s = e.VerificationArgs || (e.VerificationArgs = {}))),
    (e.verificationArgsBeet = i.fixedScalarEnum(s));
})(e1);
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (c, u, l, d) {
            d === void 0 && (d = l);
            var f = Object.getOwnPropertyDescriptor(u, l);
            (!f || ('get' in f ? !u.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return u[l];
                },
              }),
              Object.defineProperty(c, d, f);
          }
        : function (c, u, l, d) {
            d === void 0 && (d = l), (c[d] = u[l]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (c, u) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: u });
          }
        : function (c, u) {
            c.default = u;
          }),
    r =
      (m && m.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var u = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(u, c, l);
        return n(u, c), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createUnverifyInstruction = e.unverifyInstructionDiscriminator = e.UnverifyStruct = void 0);
  const i = r(te),
    s = r(ne),
    o = e1;
  (e.UnverifyStruct = new i.BeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['verificationArgs', o.verificationArgsBeet],
    ],
    'UnverifyInstructionArgs'
  )),
    (e.unverifyInstructionDiscriminator = 53);
  function a(c, u, l = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var d, f, h, p;
    const [b] = e.UnverifyStruct.serialize({
        instructionDiscriminator: e.unverifyInstructionDiscriminator,
        ...u,
      }),
      w = [
        { pubkey: c.authority, isWritable: !1, isSigner: !0 },
        {
          pubkey: (d = c.delegateRecord) !== null && d !== void 0 ? d : l,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: c.metadata, isWritable: !0, isSigner: !1 },
        {
          pubkey: (f = c.collectionMint) !== null && f !== void 0 ? f : l,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (h = c.collectionMetadata) !== null && h !== void 0 ? h : l,
          isWritable: c.collectionMetadata != null,
          isSigner: !1,
        },
        {
          pubkey: (p = c.systemProgram) !== null && p !== void 0 ? p : s.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: c.sysvarInstructions, isWritable: !1, isSigner: !1 },
      ];
    return new s.TransactionInstruction({ programId: l, keys: w, data: b });
  }
  e.createUnverifyInstruction = a;
})(o5);
var a5 = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (a, c, u, l) {
            l === void 0 && (l = u);
            var d = Object.getOwnPropertyDescriptor(c, u);
            (!d || ('get' in d ? !c.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return c[u];
                },
              }),
              Object.defineProperty(a, l, d);
          }
        : function (a, c, u, l) {
            l === void 0 && (l = u), (a[l] = c[u]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (m && m.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var u in a)
            u !== 'default' && Object.prototype.hasOwnProperty.call(a, u) && t(c, a, u);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createUnverifyCollectionInstruction =
      e.unverifyCollectionInstructionDiscriminator =
      e.UnverifyCollectionStruct =
        void 0);
  const i = r(te),
    s = r(ne);
  (e.UnverifyCollectionStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'UnverifyCollectionInstructionArgs'
  )),
    (e.unverifyCollectionInstructionDiscriminator = 22);
  function o(a, c = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [u] = e.UnverifyCollectionStruct.serialize({
        instructionDiscriminator: e.unverifyCollectionInstructionDiscriminator,
      }),
      l = [
        { pubkey: a.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: a.collectionAuthority, isWritable: !0, isSigner: !0 },
        { pubkey: a.collectionMint, isWritable: !1, isSigner: !1 },
        { pubkey: a.collection, isWritable: !1, isSigner: !1 },
        { pubkey: a.collectionMasterEditionAccount, isWritable: !1, isSigner: !1 },
      ];
    return (
      a.collectionAuthorityRecord != null &&
        l.push({ pubkey: a.collectionAuthorityRecord, isWritable: !1, isSigner: !1 }),
      new s.TransactionInstruction({ programId: c, keys: l, data: u })
    );
  }
  e.createUnverifyCollectionInstruction = o;
})(a5);
var c5 = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (a, c, u, l) {
            l === void 0 && (l = u);
            var d = Object.getOwnPropertyDescriptor(c, u);
            (!d || ('get' in d ? !c.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return c[u];
                },
              }),
              Object.defineProperty(a, l, d);
          }
        : function (a, c, u, l) {
            l === void 0 && (l = u), (a[l] = c[u]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (m && m.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var u in a)
            u !== 'default' && Object.prototype.hasOwnProperty.call(a, u) && t(c, a, u);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createUnverifySizedCollectionItemInstruction =
      e.unverifySizedCollectionItemInstructionDiscriminator =
      e.UnverifySizedCollectionItemStruct =
        void 0);
  const i = r(te),
    s = r(ne);
  (e.UnverifySizedCollectionItemStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'UnverifySizedCollectionItemInstructionArgs'
  )),
    (e.unverifySizedCollectionItemInstructionDiscriminator = 31);
  function o(a, c = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [u] = e.UnverifySizedCollectionItemStruct.serialize({
        instructionDiscriminator: e.unverifySizedCollectionItemInstructionDiscriminator,
      }),
      l = [
        { pubkey: a.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: a.collectionAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: a.payer, isWritable: !0, isSigner: !0 },
        { pubkey: a.collectionMint, isWritable: !1, isSigner: !1 },
        { pubkey: a.collection, isWritable: !0, isSigner: !1 },
        { pubkey: a.collectionMasterEditionAccount, isWritable: !1, isSigner: !1 },
      ];
    return (
      a.collectionAuthorityRecord != null &&
        l.push({ pubkey: a.collectionAuthorityRecord, isWritable: !1, isSigner: !1 }),
      new s.TransactionInstruction({ programId: c, keys: l, data: u })
    );
  }
  e.createUnverifySizedCollectionItemInstruction = o;
})(c5);
var u5 = {},
  nn = {},
  Di = {},
  eue =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  tue =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  nue =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && eue(t, e, n);
      return tue(t, e), t;
    };
Object.defineProperty(Di, '__esModule', { value: !0 });
Di.collectionToggleBeet =
  Di.isCollectionToggleSet =
  Di.isCollectionToggleClear =
  Di.isCollectionToggleNone =
    void 0;
const ml = nue(te),
  rue = ho,
  iue = (e) => e.__kind === 'None';
Di.isCollectionToggleNone = iue;
const sue = (e) => e.__kind === 'Clear';
Di.isCollectionToggleClear = sue;
const oue = (e) => e.__kind === 'Set';
Di.isCollectionToggleSet = oue;
Di.collectionToggleBeet = ml.dataEnum([
  ['None', ml.unit],
  ['Clear', ml.unit],
  [
    'Set',
    new ml.BeetArgsStruct(
      [['fields', ml.fixedSizeTuple([rue.collectionBeet])]],
      'CollectionToggleRecord["Set"]'
    ),
  ],
]);
var Ri = {},
  aue =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  cue =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  uue =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && aue(t, e, n);
      return cue(t, e), t;
    };
Object.defineProperty(Ri, '__esModule', { value: !0 });
Ri.collectionDetailsToggleBeet =
  Ri.isCollectionDetailsToggleSet =
  Ri.isCollectionDetailsToggleClear =
  Ri.isCollectionDetailsToggleNone =
    void 0;
const wl = uue(te),
  lue = Ki,
  due = (e) => e.__kind === 'None';
Ri.isCollectionDetailsToggleNone = due;
const fue = (e) => e.__kind === 'Clear';
Ri.isCollectionDetailsToggleClear = fue;
const hue = (e) => e.__kind === 'Set';
Ri.isCollectionDetailsToggleSet = hue;
Ri.collectionDetailsToggleBeet = wl.dataEnum([
  ['None', wl.unit],
  ['Clear', wl.unit],
  [
    'Set',
    new wl.FixableBeetArgsStruct(
      [['fields', wl.tuple([lue.collectionDetailsBeet])]],
      'CollectionDetailsToggleRecord["Set"]'
    ),
  ],
]);
var Ni = {},
  pue =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  gue =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  yue =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && pue(t, e, n);
      return gue(t, e), t;
    };
Object.defineProperty(Ni, '__esModule', { value: !0 });
Ni.usesToggleBeet = Ni.isUsesToggleSet = Ni.isUsesToggleClear = Ni.isUsesToggleNone = void 0;
const vl = yue(te),
  bue = po,
  mue = (e) => e.__kind === 'None';
Ni.isUsesToggleNone = mue;
const wue = (e) => e.__kind === 'Clear';
Ni.isUsesToggleClear = wue;
const vue = (e) => e.__kind === 'Set';
Ni.isUsesToggleSet = vue;
Ni.usesToggleBeet = vl.dataEnum([
  ['None', vl.unit],
  ['Clear', vl.unit],
  [
    'Set',
    new vl.BeetArgsStruct(
      [['fields', vl.fixedSizeTuple([bue.usesBeet])]],
      'UsesToggleRecord["Set"]'
    ),
  ],
]);
var ji = {},
  _ue =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  Sue =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  l5 =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && _ue(t, e, n);
      return Sue(t, e), t;
    };
Object.defineProperty(ji, '__esModule', { value: !0 });
ji.ruleSetToggleBeet =
  ji.isRuleSetToggleSet =
  ji.isRuleSetToggleClear =
  ji.isRuleSetToggleNone =
    void 0;
const _l = l5(te),
  Eue = l5(kt),
  Aue = (e) => e.__kind === 'None';
ji.isRuleSetToggleNone = Aue;
const Iue = (e) => e.__kind === 'Clear';
ji.isRuleSetToggleClear = Iue;
const Tue = (e) => e.__kind === 'Set';
ji.isRuleSetToggleSet = Tue;
ji.ruleSetToggleBeet = _l.dataEnum([
  ['None', _l.unit],
  ['Clear', _l.unit],
  [
    'Set',
    new _l.BeetArgsStruct(
      [['fields', _l.fixedSizeTuple([Eue.publicKey])]],
      'RuleSetToggleRecord["Set"]'
    ),
  ],
]);
var xue =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  kue =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  d5 =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && xue(t, e, n);
      return kue(t, e), t;
    };
Object.defineProperty(nn, '__esModule', { value: !0 });
nn.updateArgsBeet =
  nn.isUpdateArgsAsProgrammableConfigItemDelegateV2 =
  nn.isUpdateArgsAsCollectionItemDelegateV2 =
  nn.isUpdateArgsAsDataItemDelegateV2 =
  nn.isUpdateArgsAsProgrammableConfigDelegateV2 =
  nn.isUpdateArgsAsDataDelegateV2 =
  nn.isUpdateArgsAsCollectionDelegateV2 =
  nn.isUpdateArgsAsAuthorityItemDelegateV2 =
  nn.isUpdateArgsAsUpdateAuthorityV2 =
  nn.isUpdateArgsV1 =
    void 0;
const rt = d5(te),
  Hv = d5(kt),
  lg = kc,
  dg = Di,
  t3 = Ri,
  n3 = Ni,
  fg = ji,
  Rs = Wi,
  r3 = Ju,
  Cue = (e) => e.__kind === 'V1';
nn.isUpdateArgsV1 = Cue;
const Pue = (e) => e.__kind === 'AsUpdateAuthorityV2';
nn.isUpdateArgsAsUpdateAuthorityV2 = Pue;
const Mue = (e) => e.__kind === 'AsAuthorityItemDelegateV2';
nn.isUpdateArgsAsAuthorityItemDelegateV2 = Mue;
const Oue = (e) => e.__kind === 'AsCollectionDelegateV2';
nn.isUpdateArgsAsCollectionDelegateV2 = Oue;
const Bue = (e) => e.__kind === 'AsDataDelegateV2';
nn.isUpdateArgsAsDataDelegateV2 = Bue;
const Due = (e) => e.__kind === 'AsProgrammableConfigDelegateV2';
nn.isUpdateArgsAsProgrammableConfigDelegateV2 = Due;
const Rue = (e) => e.__kind === 'AsDataItemDelegateV2';
nn.isUpdateArgsAsDataItemDelegateV2 = Rue;
const Nue = (e) => e.__kind === 'AsCollectionItemDelegateV2';
nn.isUpdateArgsAsCollectionItemDelegateV2 = Nue;
const jue = (e) => e.__kind === 'AsProgrammableConfigItemDelegateV2';
nn.isUpdateArgsAsProgrammableConfigItemDelegateV2 = jue;
nn.updateArgsBeet = rt.dataEnum([
  [
    'V1',
    new rt.FixableBeetArgsStruct(
      [
        ['newUpdateAuthority', rt.coption(Hv.publicKey)],
        ['data', rt.coption(lg.dataBeet)],
        ['primarySaleHappened', rt.coption(rt.bool)],
        ['isMutable', rt.coption(rt.bool)],
        ['collection', dg.collectionToggleBeet],
        ['collectionDetails', t3.collectionDetailsToggleBeet],
        ['uses', n3.usesToggleBeet],
        ['ruleSet', fg.ruleSetToggleBeet],
        ['authorizationData', rt.coption(Rs.authorizationDataBeet)],
      ],
      'UpdateArgsRecord["V1"]'
    ),
  ],
  [
    'AsUpdateAuthorityV2',
    new rt.FixableBeetArgsStruct(
      [
        ['newUpdateAuthority', rt.coption(Hv.publicKey)],
        ['data', rt.coption(lg.dataBeet)],
        ['primarySaleHappened', rt.coption(rt.bool)],
        ['isMutable', rt.coption(rt.bool)],
        ['collection', dg.collectionToggleBeet],
        ['collectionDetails', t3.collectionDetailsToggleBeet],
        ['uses', n3.usesToggleBeet],
        ['ruleSet', fg.ruleSetToggleBeet],
        ['tokenStandard', rt.coption(r3.tokenStandardBeet)],
        ['authorizationData', rt.coption(Rs.authorizationDataBeet)],
      ],
      'UpdateArgsRecord["AsUpdateAuthorityV2"]'
    ),
  ],
  [
    'AsAuthorityItemDelegateV2',
    new rt.FixableBeetArgsStruct(
      [
        ['newUpdateAuthority', rt.coption(Hv.publicKey)],
        ['primarySaleHappened', rt.coption(rt.bool)],
        ['isMutable', rt.coption(rt.bool)],
        ['tokenStandard', rt.coption(r3.tokenStandardBeet)],
        ['authorizationData', rt.coption(Rs.authorizationDataBeet)],
      ],
      'UpdateArgsRecord["AsAuthorityItemDelegateV2"]'
    ),
  ],
  [
    'AsCollectionDelegateV2',
    new rt.FixableBeetArgsStruct(
      [
        ['collection', dg.collectionToggleBeet],
        ['authorizationData', rt.coption(Rs.authorizationDataBeet)],
      ],
      'UpdateArgsRecord["AsCollectionDelegateV2"]'
    ),
  ],
  [
    'AsDataDelegateV2',
    new rt.FixableBeetArgsStruct(
      [
        ['data', rt.coption(lg.dataBeet)],
        ['authorizationData', rt.coption(Rs.authorizationDataBeet)],
      ],
      'UpdateArgsRecord["AsDataDelegateV2"]'
    ),
  ],
  [
    'AsProgrammableConfigDelegateV2',
    new rt.FixableBeetArgsStruct(
      [
        ['ruleSet', fg.ruleSetToggleBeet],
        ['authorizationData', rt.coption(Rs.authorizationDataBeet)],
      ],
      'UpdateArgsRecord["AsProgrammableConfigDelegateV2"]'
    ),
  ],
  [
    'AsDataItemDelegateV2',
    new rt.FixableBeetArgsStruct(
      [
        ['data', rt.coption(lg.dataBeet)],
        ['authorizationData', rt.coption(Rs.authorizationDataBeet)],
      ],
      'UpdateArgsRecord["AsDataItemDelegateV2"]'
    ),
  ],
  [
    'AsCollectionItemDelegateV2',
    new rt.FixableBeetArgsStruct(
      [
        ['collection', dg.collectionToggleBeet],
        ['authorizationData', rt.coption(Rs.authorizationDataBeet)],
      ],
      'UpdateArgsRecord["AsCollectionItemDelegateV2"]'
    ),
  ],
  [
    'AsProgrammableConfigItemDelegateV2',
    new rt.FixableBeetArgsStruct(
      [
        ['ruleSet', fg.ruleSetToggleBeet],
        ['authorizationData', rt.coption(Rs.authorizationDataBeet)],
      ],
      'UpdateArgsRecord["AsProgrammableConfigItemDelegateV2"]'
    ),
  ],
]);
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (c, u, l, d) {
            d === void 0 && (d = l);
            var f = Object.getOwnPropertyDescriptor(u, l);
            (!f || ('get' in f ? !u.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return u[l];
                },
              }),
              Object.defineProperty(c, d, f);
          }
        : function (c, u, l, d) {
            d === void 0 && (d = l), (c[d] = u[l]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (c, u) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: u });
          }
        : function (c, u) {
            c.default = u;
          }),
    r =
      (m && m.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var u = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(u, c, l);
        return n(u, c), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createUpdateInstruction = e.updateInstructionDiscriminator = e.UpdateStruct = void 0);
  const i = r(te),
    s = r(ne),
    o = nn;
  (e.UpdateStruct = new i.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['updateArgs', o.updateArgsBeet],
    ],
    'UpdateInstructionArgs'
  )),
    (e.updateInstructionDiscriminator = 50);
  function a(c, u, l = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var d, f, h, p, b, w;
    const [A] = e.UpdateStruct.serialize({
        instructionDiscriminator: e.updateInstructionDiscriminator,
        ...u,
      }),
      _ = [
        { pubkey: c.authority, isWritable: !1, isSigner: !0 },
        {
          pubkey: (d = c.delegateRecord) !== null && d !== void 0 ? d : l,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: (f = c.token) !== null && f !== void 0 ? f : l, isWritable: !1, isSigner: !1 },
        { pubkey: c.mint, isWritable: !1, isSigner: !1 },
        { pubkey: c.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: (h = c.edition) !== null && h !== void 0 ? h : l, isWritable: !1, isSigner: !1 },
        { pubkey: c.payer, isWritable: !0, isSigner: !0 },
        {
          pubkey: (p = c.systemProgram) !== null && p !== void 0 ? p : s.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: c.sysvarInstructions, isWritable: !1, isSigner: !1 },
        {
          pubkey: (b = c.authorizationRulesProgram) !== null && b !== void 0 ? b : l,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (w = c.authorizationRules) !== null && w !== void 0 ? w : l,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return new s.TransactionInstruction({ programId: l, keys: _, data: A });
  }
  e.createUpdateInstruction = a;
})(u5);
var f5 = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (a, c, u, l) {
            l === void 0 && (l = u);
            var d = Object.getOwnPropertyDescriptor(c, u);
            (!d || ('get' in d ? !c.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return c[u];
                },
              }),
              Object.defineProperty(a, l, d);
          }
        : function (a, c, u, l) {
            l === void 0 && (l = u), (a[l] = c[u]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (m && m.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var u in a)
            u !== 'default' && Object.prototype.hasOwnProperty.call(a, u) && t(c, a, u);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createUpdateMetadataAccountInstruction =
      e.updateMetadataAccountInstructionDiscriminator =
      e.UpdateMetadataAccountStruct =
        void 0);
  const i = r(te),
    s = r(ne);
  (e.UpdateMetadataAccountStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'UpdateMetadataAccountInstructionArgs'
  )),
    (e.updateMetadataAccountInstructionDiscriminator = 1);
  function o(a, c = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [u] = e.UpdateMetadataAccountStruct.serialize({
        instructionDiscriminator: e.updateMetadataAccountInstructionDiscriminator,
      }),
      l = [
        { pubkey: a.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: a.updateAuthority, isWritable: !1, isSigner: !0 },
      ];
    return new s.TransactionInstruction({ programId: c, keys: l, data: u });
  }
  e.createUpdateMetadataAccountInstruction = o;
})(f5);
var h5 = {},
  Sp = {},
  Lue =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  Uue =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  p5 =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && Lue(t, e, n);
      return Uue(t, e), t;
    };
Object.defineProperty(Sp, '__esModule', { value: !0 });
Sp.updateMetadataAccountArgsV2Beet = void 0;
const Ta = p5(te),
  $ue = p5(kt),
  Fue = el;
Sp.updateMetadataAccountArgsV2Beet = new Ta.FixableBeetArgsStruct(
  [
    ['data', Ta.coption(Fue.dataV2Beet)],
    ['updateAuthority', Ta.coption($ue.publicKey)],
    ['primarySaleHappened', Ta.coption(Ta.bool)],
    ['isMutable', Ta.coption(Ta.bool)],
  ],
  'UpdateMetadataAccountArgsV2'
);
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (c, u, l, d) {
            d === void 0 && (d = l);
            var f = Object.getOwnPropertyDescriptor(u, l);
            (!f || ('get' in f ? !u.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return u[l];
                },
              }),
              Object.defineProperty(c, d, f);
          }
        : function (c, u, l, d) {
            d === void 0 && (d = l), (c[d] = u[l]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (c, u) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: u });
          }
        : function (c, u) {
            c.default = u;
          }),
    r =
      (m && m.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var u = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(u, c, l);
        return n(u, c), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createUpdateMetadataAccountV2Instruction =
      e.updateMetadataAccountV2InstructionDiscriminator =
      e.UpdateMetadataAccountV2Struct =
        void 0);
  const i = r(te),
    s = r(ne),
    o = Sp;
  (e.UpdateMetadataAccountV2Struct = new i.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['updateMetadataAccountArgsV2', o.updateMetadataAccountArgsV2Beet],
    ],
    'UpdateMetadataAccountV2InstructionArgs'
  )),
    (e.updateMetadataAccountV2InstructionDiscriminator = 15);
  function a(c, u, l = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [d] = e.UpdateMetadataAccountV2Struct.serialize({
        instructionDiscriminator: e.updateMetadataAccountV2InstructionDiscriminator,
        ...u,
      }),
      f = [
        { pubkey: c.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: c.updateAuthority, isWritable: !1, isSigner: !0 },
      ];
    return new s.TransactionInstruction({ programId: l, keys: f, data: d });
  }
  e.createUpdateMetadataAccountV2Instruction = a;
})(h5);
var g5 = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (a, c, u, l) {
            l === void 0 && (l = u);
            var d = Object.getOwnPropertyDescriptor(c, u);
            (!d || ('get' in d ? !c.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return c[u];
                },
              }),
              Object.defineProperty(a, l, d);
          }
        : function (a, c, u, l) {
            l === void 0 && (l = u), (a[l] = c[u]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (m && m.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var u in a)
            u !== 'default' && Object.prototype.hasOwnProperty.call(a, u) && t(c, a, u);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createUpdatePrimarySaleHappenedViaTokenInstruction =
      e.updatePrimarySaleHappenedViaTokenInstructionDiscriminator =
      e.UpdatePrimarySaleHappenedViaTokenStruct =
        void 0);
  const i = r(te),
    s = r(ne);
  (e.UpdatePrimarySaleHappenedViaTokenStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'UpdatePrimarySaleHappenedViaTokenInstructionArgs'
  )),
    (e.updatePrimarySaleHappenedViaTokenInstructionDiscriminator = 4);
  function o(a, c = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [u] = e.UpdatePrimarySaleHappenedViaTokenStruct.serialize({
        instructionDiscriminator: e.updatePrimarySaleHappenedViaTokenInstructionDiscriminator,
      }),
      l = [
        { pubkey: a.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: a.owner, isWritable: !1, isSigner: !0 },
        { pubkey: a.token, isWritable: !1, isSigner: !1 },
      ];
    return new s.TransactionInstruction({ programId: c, keys: l, data: u });
  }
  e.createUpdatePrimarySaleHappenedViaTokenInstruction = o;
})(g5);
var y5 = {},
  hc = {},
  zue =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  Kue =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  Vue =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && zue(t, e, n);
      return Kue(t, e), t;
    };
Object.defineProperty(hc, '__esModule', { value: !0 });
hc.useArgsBeet = hc.isUseArgsV1 = void 0;
const Gv = Vue(te),
  Wue = Wi,
  Hue = (e) => e.__kind === 'V1';
hc.isUseArgsV1 = Hue;
hc.useArgsBeet = Gv.dataEnum([
  [
    'V1',
    new Gv.FixableBeetArgsStruct(
      [['authorizationData', Gv.coption(Wue.authorizationDataBeet)]],
      'UseArgsRecord["V1"]'
    ),
  ],
]);
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (c, u, l, d) {
            d === void 0 && (d = l);
            var f = Object.getOwnPropertyDescriptor(u, l);
            (!f || ('get' in f ? !u.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return u[l];
                },
              }),
              Object.defineProperty(c, d, f);
          }
        : function (c, u, l, d) {
            d === void 0 && (d = l), (c[d] = u[l]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (c, u) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: u });
          }
        : function (c, u) {
            c.default = u;
          }),
    r =
      (m && m.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var u = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(u, c, l);
        return n(u, c), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createUseInstruction = e.useInstructionDiscriminator = e.UseStruct = void 0);
  const i = r(te),
    s = r(ne),
    o = hc;
  (e.UseStruct = new i.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['useArgs', o.useArgsBeet],
    ],
    'UseInstructionArgs'
  )),
    (e.useInstructionDiscriminator = 51);
  function a(c, u, l = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var d, f, h, p, b, w, A;
    const [_] = e.UseStruct.serialize({
        instructionDiscriminator: e.useInstructionDiscriminator,
        ...u,
      }),
      x = [
        { pubkey: c.authority, isWritable: !1, isSigner: !0 },
        {
          pubkey: (d = c.delegateRecord) !== null && d !== void 0 ? d : l,
          isWritable: c.delegateRecord != null,
          isSigner: !1,
        },
        {
          pubkey: (f = c.token) !== null && f !== void 0 ? f : l,
          isWritable: c.token != null,
          isSigner: !1,
        },
        { pubkey: c.mint, isWritable: !1, isSigner: !1 },
        { pubkey: c.metadata, isWritable: !0, isSigner: !1 },
        {
          pubkey: (h = c.edition) !== null && h !== void 0 ? h : l,
          isWritable: c.edition != null,
          isSigner: !1,
        },
        { pubkey: c.payer, isWritable: !1, isSigner: !0 },
        {
          pubkey: (p = c.systemProgram) !== null && p !== void 0 ? p : s.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: c.sysvarInstructions, isWritable: !1, isSigner: !1 },
        {
          pubkey: (b = c.splTokenProgram) !== null && b !== void 0 ? b : l,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (w = c.authorizationRulesProgram) !== null && w !== void 0 ? w : l,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (A = c.authorizationRules) !== null && A !== void 0 ? A : l,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return new s.TransactionInstruction({ programId: l, keys: x, data: _ });
  }
  e.createUseInstruction = a;
})(y5);
var b5 = {},
  Ep = {},
  Gue =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  que =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  Yue =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && Gue(t, e, n);
      return que(t, e), t;
    };
Object.defineProperty(Ep, '__esModule', { value: !0 });
Ep.utilizeArgsBeet = void 0;
const i3 = Yue(te);
Ep.utilizeArgsBeet = new i3.BeetArgsStruct([['numberOfUses', i3.u64]], 'UtilizeArgs');
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (u, l, d, f) {
            f === void 0 && (f = d);
            var h = Object.getOwnPropertyDescriptor(l, d);
            (!h || ('get' in h ? !l.__esModule : h.writable || h.configurable)) &&
              (h = {
                enumerable: !0,
                get: function () {
                  return l[d];
                },
              }),
              Object.defineProperty(u, f, h);
          }
        : function (u, l, d, f) {
            f === void 0 && (f = d), (u[f] = l[d]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (u, l) {
            Object.defineProperty(u, 'default', { enumerable: !0, value: l });
          }
        : function (u, l) {
            u.default = l;
          }),
    r =
      (m && m.__importStar) ||
      function (u) {
        if (u && u.__esModule) return u;
        var l = {};
        if (u != null)
          for (var d in u)
            d !== 'default' && Object.prototype.hasOwnProperty.call(u, d) && t(l, u, d);
        return n(l, u), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createUtilizeInstruction = e.utilizeInstructionDiscriminator = e.UtilizeStruct = void 0);
  const i = r(_r),
    s = r(te),
    o = r(ne),
    a = Ep;
  (e.UtilizeStruct = new s.BeetArgsStruct(
    [
      ['instructionDiscriminator', s.u8],
      ['utilizeArgs', a.utilizeArgsBeet],
    ],
    'UtilizeInstructionArgs'
  )),
    (e.utilizeInstructionDiscriminator = 19);
  function c(u, l, d = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var f, h, p, b;
    const [w] = e.UtilizeStruct.serialize({
        instructionDiscriminator: e.utilizeInstructionDiscriminator,
        ...l,
      }),
      A = [
        { pubkey: u.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: u.tokenAccount, isWritable: !0, isSigner: !1 },
        { pubkey: u.mint, isWritable: !0, isSigner: !1 },
        { pubkey: u.useAuthority, isWritable: !0, isSigner: !0 },
        { pubkey: u.owner, isWritable: !1, isSigner: !1 },
        {
          pubkey: (f = u.tokenProgram) !== null && f !== void 0 ? f : i.TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (h = u.ataProgram) !== null && h !== void 0 ? h : i.ASSOCIATED_TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (p = u.systemProgram) !== null && p !== void 0 ? p : o.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (b = u.rent) !== null && b !== void 0 ? b : o.SYSVAR_RENT_PUBKEY,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    if (
      (u.useAuthorityRecord != null &&
        A.push({ pubkey: u.useAuthorityRecord, isWritable: !0, isSigner: !1 }),
      u.burner != null)
    ) {
      if (u.useAuthorityRecord == null)
        throw new Error(
          "When providing 'burner' then 'accounts.useAuthorityRecord' need(s) to be provided as well."
        );
      A.push({ pubkey: u.burner, isWritable: !1, isSigner: !1 });
    }
    return new o.TransactionInstruction({ programId: d, keys: A, data: w });
  }
  e.createUtilizeInstruction = c;
})(b5);
var m5 = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (c, u, l, d) {
            d === void 0 && (d = l);
            var f = Object.getOwnPropertyDescriptor(u, l);
            (!f || ('get' in f ? !u.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return u[l];
                },
              }),
              Object.defineProperty(c, d, f);
          }
        : function (c, u, l, d) {
            d === void 0 && (d = l), (c[d] = u[l]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (c, u) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: u });
          }
        : function (c, u) {
            c.default = u;
          }),
    r =
      (m && m.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var u = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(u, c, l);
        return n(u, c), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createVerifyInstruction = e.verifyInstructionDiscriminator = e.VerifyStruct = void 0);
  const i = r(te),
    s = r(ne),
    o = e1;
  (e.VerifyStruct = new i.BeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['verificationArgs', o.verificationArgsBeet],
    ],
    'VerifyInstructionArgs'
  )),
    (e.verifyInstructionDiscriminator = 52);
  function a(c, u, l = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var d, f, h, p, b;
    const [w] = e.VerifyStruct.serialize({
        instructionDiscriminator: e.verifyInstructionDiscriminator,
        ...u,
      }),
      A = [
        { pubkey: c.authority, isWritable: !1, isSigner: !0 },
        {
          pubkey: (d = c.delegateRecord) !== null && d !== void 0 ? d : l,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: c.metadata, isWritable: !0, isSigner: !1 },
        {
          pubkey: (f = c.collectionMint) !== null && f !== void 0 ? f : l,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (h = c.collectionMetadata) !== null && h !== void 0 ? h : l,
          isWritable: c.collectionMetadata != null,
          isSigner: !1,
        },
        {
          pubkey: (p = c.collectionMasterEdition) !== null && p !== void 0 ? p : l,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (b = c.systemProgram) !== null && b !== void 0 ? b : s.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: c.sysvarInstructions, isWritable: !1, isSigner: !1 },
      ];
    return new s.TransactionInstruction({ programId: l, keys: A, data: w });
  }
  e.createVerifyInstruction = a;
})(m5);
var w5 = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (a, c, u, l) {
            l === void 0 && (l = u);
            var d = Object.getOwnPropertyDescriptor(c, u);
            (!d || ('get' in d ? !c.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return c[u];
                },
              }),
              Object.defineProperty(a, l, d);
          }
        : function (a, c, u, l) {
            l === void 0 && (l = u), (a[l] = c[u]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (m && m.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var u in a)
            u !== 'default' && Object.prototype.hasOwnProperty.call(a, u) && t(c, a, u);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createVerifyCollectionInstruction =
      e.verifyCollectionInstructionDiscriminator =
      e.VerifyCollectionStruct =
        void 0);
  const i = r(te),
    s = r(ne);
  (e.VerifyCollectionStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'VerifyCollectionInstructionArgs'
  )),
    (e.verifyCollectionInstructionDiscriminator = 18);
  function o(a, c = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [u] = e.VerifyCollectionStruct.serialize({
        instructionDiscriminator: e.verifyCollectionInstructionDiscriminator,
      }),
      l = [
        { pubkey: a.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: a.collectionAuthority, isWritable: !0, isSigner: !0 },
        { pubkey: a.payer, isWritable: !0, isSigner: !0 },
        { pubkey: a.collectionMint, isWritable: !1, isSigner: !1 },
        { pubkey: a.collection, isWritable: !1, isSigner: !1 },
        { pubkey: a.collectionMasterEditionAccount, isWritable: !1, isSigner: !1 },
      ];
    return (
      a.collectionAuthorityRecord != null &&
        l.push({ pubkey: a.collectionAuthorityRecord, isWritable: !1, isSigner: !1 }),
      new s.TransactionInstruction({ programId: c, keys: l, data: u })
    );
  }
  e.createVerifyCollectionInstruction = o;
})(w5);
var v5 = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (a, c, u, l) {
            l === void 0 && (l = u);
            var d = Object.getOwnPropertyDescriptor(c, u);
            (!d || ('get' in d ? !c.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return c[u];
                },
              }),
              Object.defineProperty(a, l, d);
          }
        : function (a, c, u, l) {
            l === void 0 && (l = u), (a[l] = c[u]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (m && m.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var u in a)
            u !== 'default' && Object.prototype.hasOwnProperty.call(a, u) && t(c, a, u);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createVerifySizedCollectionItemInstruction =
      e.verifySizedCollectionItemInstructionDiscriminator =
      e.VerifySizedCollectionItemStruct =
        void 0);
  const i = r(te),
    s = r(ne);
  (e.VerifySizedCollectionItemStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'VerifySizedCollectionItemInstructionArgs'
  )),
    (e.verifySizedCollectionItemInstructionDiscriminator = 30);
  function o(a, c = new s.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [u] = e.VerifySizedCollectionItemStruct.serialize({
        instructionDiscriminator: e.verifySizedCollectionItemInstructionDiscriminator,
      }),
      l = [
        { pubkey: a.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: a.collectionAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: a.payer, isWritable: !0, isSigner: !0 },
        { pubkey: a.collectionMint, isWritable: !1, isSigner: !1 },
        { pubkey: a.collection, isWritable: !0, isSigner: !1 },
        { pubkey: a.collectionMasterEditionAccount, isWritable: !1, isSigner: !1 },
      ];
    return (
      a.collectionAuthorityRecord != null &&
        l.push({ pubkey: a.collectionAuthorityRecord, isWritable: !1, isSigner: !1 }),
      new s.TransactionInstruction({ programId: c, keys: l, data: u })
    );
  }
  e.createVerifySizedCollectionItemInstruction = o;
})(v5);
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (r, i, s, o) {
            o === void 0 && (o = s);
            var a = Object.getOwnPropertyDescriptor(i, s);
            (!a || ('get' in a ? !i.__esModule : a.writable || a.configurable)) &&
              (a = {
                enumerable: !0,
                get: function () {
                  return i[s];
                },
              }),
              Object.defineProperty(r, o, a);
          }
        : function (r, i, s, o) {
            o === void 0 && (o = s), (r[o] = i[s]);
          }),
    n =
      (m && m.__exportStar) ||
      function (r, i) {
        for (var s in r)
          s !== 'default' && !Object.prototype.hasOwnProperty.call(i, s) && t(i, r, s);
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    n(PB, e),
    n(MB, e),
    n(gD, e),
    n(yD, e),
    n(bD, e),
    n(mD, e),
    n(wD, e),
    n(vD, e),
    n(_D, e),
    n(SD, e),
    n(AD, e),
    n(ID, e),
    n(TD, e),
    n(xD, e),
    n(kD, e),
    n(CD, e),
    n(PD, e),
    n(BD, e),
    n(DD, e),
    n(RD, e),
    n(ND, e),
    n(jD, e),
    n(LD, e),
    n(UD, e),
    n($D, e),
    n(FD, e),
    n(KD, e),
    n(VD, e),
    n(WD, e),
    n(HD, e),
    n(GD, e),
    n(qD, e),
    n(YD, e),
    n(ZD, e),
    n(JD, e),
    n(XD, e),
    n(QD, e),
    n(e5, e),
    n(t5, e),
    n(n5, e),
    n(r5, e),
    n(i5, e),
    n(s5, e),
    n(o5, e),
    n(a5, e),
    n(c5, e),
    n(u5, e),
    n(f5, e),
    n(h5, e),
    n(g5, e),
    n(y5, e),
    n(b5, e),
    n(m5, e),
    n(w5, e),
    n(v5, e);
})(CB);
var _5 = {},
  S5 = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (o, a, c, u) {
            u === void 0 && (u = c);
            var l = Object.getOwnPropertyDescriptor(a, c);
            (!l || ('get' in l ? !a.__esModule : l.writable || l.configurable)) &&
              (l = {
                enumerable: !0,
                get: function () {
                  return a[c];
                },
              }),
              Object.defineProperty(o, u, l);
          }
        : function (o, a, c, u) {
            u === void 0 && (u = c), (o[u] = a[c]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (o, a) {
            Object.defineProperty(o, 'default', { enumerable: !0, value: a });
          }
        : function (o, a) {
            o.default = a;
          }),
    r =
      (m && m.__importStar) ||
      function (o) {
        if (o && o.__esModule) return o;
        var a = {};
        if (o != null)
          for (var c in o)
            c !== 'default' && Object.prototype.hasOwnProperty.call(o, c) && t(a, o, c);
        return n(a, o), a;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.authorityTypeBeet = e.AuthorityType = void 0);
  const i = r(te);
  var s;
  (function (o) {
    (o[(o.None = 0)] = 'None'),
      (o[(o.Metadata = 1)] = 'Metadata'),
      (o[(o.Holder = 2)] = 'Holder'),
      (o[(o.MetadataDelegate = 3)] = 'MetadataDelegate'),
      (o[(o.TokenDelegate = 4)] = 'TokenDelegate');
  })((s = e.AuthorityType || (e.AuthorityType = {}))),
    (e.authorityTypeBeet = i.fixedScalarEnum(s));
})(S5);
var E5 = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (o, a, c, u) {
            u === void 0 && (u = c);
            var l = Object.getOwnPropertyDescriptor(a, c);
            (!l || ('get' in l ? !a.__esModule : l.writable || l.configurable)) &&
              (l = {
                enumerable: !0,
                get: function () {
                  return a[c];
                },
              }),
              Object.defineProperty(o, u, l);
          }
        : function (o, a, c, u) {
            u === void 0 && (u = c), (o[u] = a[c]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (o, a) {
            Object.defineProperty(o, 'default', { enumerable: !0, value: a });
          }
        : function (o, a) {
            o.default = a;
          }),
    r =
      (m && m.__importStar) ||
      function (o) {
        if (o && o.__esModule) return o;
        var a = {};
        if (o != null)
          for (var c in o)
            c !== 'default' && Object.prototype.hasOwnProperty.call(o, c) && t(a, o, c);
        return n(a, o), a;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.metadataDelegateRoleBeet = e.MetadataDelegateRole = void 0);
  const i = r(te);
  var s;
  (function (o) {
    (o[(o.AuthorityItem = 0)] = 'AuthorityItem'),
      (o[(o.Collection = 1)] = 'Collection'),
      (o[(o.Use = 2)] = 'Use'),
      (o[(o.Data = 3)] = 'Data'),
      (o[(o.ProgrammableConfig = 4)] = 'ProgrammableConfig'),
      (o[(o.DataItem = 5)] = 'DataItem'),
      (o[(o.CollectionItem = 6)] = 'CollectionItem'),
      (o[(o.ProgrammableConfigItem = 7)] = 'ProgrammableConfigItem');
  })((s = e.MetadataDelegateRole || (e.MetadataDelegateRole = {}))),
    (e.metadataDelegateRoleBeet = i.fixedScalarEnum(s));
})(E5);
var A5 = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (o, a, c, u) {
            u === void 0 && (u = c);
            var l = Object.getOwnPropertyDescriptor(a, c);
            (!l || ('get' in l ? !a.__esModule : l.writable || l.configurable)) &&
              (l = {
                enumerable: !0,
                get: function () {
                  return a[c];
                },
              }),
              Object.defineProperty(o, u, l);
          }
        : function (o, a, c, u) {
            u === void 0 && (u = c), (o[u] = a[c]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (o, a) {
            Object.defineProperty(o, 'default', { enumerable: !0, value: a });
          }
        : function (o, a) {
            o.default = a;
          }),
    r =
      (m && m.__importStar) ||
      function (o) {
        if (o && o.__esModule) return o;
        var a = {};
        if (o != null)
          for (var c in o)
            c !== 'default' && Object.prototype.hasOwnProperty.call(o, c) && t(a, o, c);
        return n(a, o), a;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }), (e.payloadKeyBeet = e.PayloadKey = void 0);
  const i = r(te);
  var s;
  (function (o) {
    (o[(o.Amount = 0)] = 'Amount'),
      (o[(o.Authority = 1)] = 'Authority'),
      (o[(o.AuthoritySeeds = 2)] = 'AuthoritySeeds'),
      (o[(o.Delegate = 3)] = 'Delegate'),
      (o[(o.DelegateSeeds = 4)] = 'DelegateSeeds'),
      (o[(o.Destination = 5)] = 'Destination'),
      (o[(o.DestinationSeeds = 6)] = 'DestinationSeeds'),
      (o[(o.Holder = 7)] = 'Holder'),
      (o[(o.Source = 8)] = 'Source'),
      (o[(o.SourceSeeds = 9)] = 'SourceSeeds');
  })((s = e.PayloadKey || (e.PayloadKey = {}))),
    (e.payloadKeyBeet = i.fixedScalarEnum(s));
})(A5);
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (r, i, s, o) {
            o === void 0 && (o = s);
            var a = Object.getOwnPropertyDescriptor(i, s);
            (!a || ('get' in a ? !i.__esModule : a.writable || a.configurable)) &&
              (a = {
                enumerable: !0,
                get: function () {
                  return i[s];
                },
              }),
              Object.defineProperty(r, o, a);
          }
        : function (r, i, s, o) {
            o === void 0 && (o = s), (r[o] = i[s]);
          }),
    n =
      (m && m.__exportStar) ||
      function (r, i) {
        for (var s in r)
          s !== 'default' && !Object.prototype.hasOwnProperty.call(i, s) && t(i, r, s);
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    n(pp, e),
    n(gp, e),
    n(S5, e),
    n(Wi, e),
    n(oc, e),
    n(ho, e),
    n(Ki, e),
    n(Ri, e),
    n(Di, e),
    n(ac, e),
    n(yp, e),
    n(bp, e),
    n(Cc, e),
    n(kc, e),
    n(el, e),
    n(xt, e),
    n(to, e),
    n(dr, e),
    n(vp, e),
    n(cc, e),
    n(E5, e),
    n(uc, e),
    n(LI, e),
    n(lc, e),
    n(tl, e),
    n(mp, e),
    n(A5, e),
    n(Vr, e),
    n(Bi, e),
    n(ga, e),
    n(Cd, e),
    n(kd, e),
    n(UI, e),
    n(ji, e),
    n(wp, e),
    n(Qu, e),
    n(kI, e),
    n(Ju, e),
    n(xI, e),
    n(dc, e),
    n(_p, e),
    n(fc, e),
    n(nn, e),
    n(Sp, e),
    n(hc, e),
    n(TI, e),
    n(po, e),
    n(Ni, e),
    n(Ep, e),
    n(e1, e);
})(_5);
var s3;
function $I() {
  return (
    s3 ||
      ((s3 = 1),
      (function (e) {
        var t =
            (m && m.__createBinding) ||
            (Object.create
              ? function (i, s, o, a) {
                  a === void 0 && (a = o);
                  var c = Object.getOwnPropertyDescriptor(s, o);
                  (!c || ('get' in c ? !s.__esModule : c.writable || c.configurable)) &&
                    (c = {
                      enumerable: !0,
                      get: function () {
                        return s[o];
                      },
                    }),
                    Object.defineProperty(i, a, c);
                }
              : function (i, s, o, a) {
                  a === void 0 && (a = o), (i[a] = s[o]);
                }),
          n =
            (m && m.__exportStar) ||
            function (i, s) {
              for (var o in i)
                o !== 'default' && !Object.prototype.hasOwnProperty.call(s, o) && t(s, i, o);
            };
        Object.defineProperty(e, '__esModule', { value: !0 }),
          (e.PROGRAM_ID = e.PROGRAM_ADDRESS = void 0);
        const r = ne;
        n(Xne(), e),
          n(N, e),
          n(CB, e),
          n(_5, e),
          (e.PROGRAM_ADDRESS = 'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'),
          (e.PROGRAM_ID = new r.PublicKey(e.PROGRAM_ADDRESS));
      })(rv)),
    rv
  );
}
Object.defineProperty(em, '__esModule', { value: !0 });
em.cusper = void 0;
const Zue = AL,
  Jue = $I();
em.cusper = (0, Zue.initCusper)(Jue.errorFromCode);
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (r, i, s, o) {
            o === void 0 && (o = s);
            var a = Object.getOwnPropertyDescriptor(i, s);
            (!a || ('get' in a ? !i.__esModule : a.writable || a.configurable)) &&
              (a = {
                enumerable: !0,
                get: function () {
                  return i[s];
                },
              }),
              Object.defineProperty(r, o, a);
          }
        : function (r, i, s, o) {
            o === void 0 && (o = s), (r[o] = i[s]);
          }),
    n =
      (m && m.__exportStar) ||
      function (r, i) {
        for (var s in r)
          s !== 'default' && !Object.prototype.hasOwnProperty.call(i, s) && t(i, r, s);
      };
  Object.defineProperty(e, '__esModule', { value: !0 }), n(em, e), n($I(), e);
})(LX);
new nr('CMTQqjzH6Anr9XcPVt73EFDTjWkJWPzH7H6DtvhHcyzV');
const Xue = new nr('ocp4vWUzA2z2XMYJ3QhM9vWdyoyoQwAFJhRdVTbvo9E'),
  o3 = [81, 17, 143, 120, 23, 57, 22, 117];
class Na {
  constructor(t, n, r, i, s, o, a, c) {
    (this.version = t),
      (this.bump = n),
      (this.mint = r),
      (this.policy = i),
      (this.lockedBy = s),
      (this.lastApprovedAt = o),
      (this.lastTransferredAt = a),
      (this.transferredCount = c);
  }
  static fromArgs(t) {
    return new Na(
      t.version,
      t.bump,
      t.mint,
      t.policy,
      t.lockedBy,
      t.lastApprovedAt,
      t.lastTransferredAt,
      t.transferredCount
    );
  }
  static fromAccountInfo(t, n = 0) {
    return Na.deserialize(t.data, n);
  }
  static async fromAccountAddress(t, n) {
    const r = await t.getAccountInfo(n);
    if (r == null) throw new Error(`Unable to find MintState account at ${n}`);
    return Na.fromAccountInfo(r, 0)[0];
  }
  static gpaBuilder(t = Xue) {
    return kt.GpaBuilder.fromStruct(t, hg);
  }
  static deserialize(t, n = 0) {
    return hg.deserialize(t, n);
  }
  serialize() {
    return hg.serialize({ accountDiscriminator: o3, ...this });
  }
  static byteSize(t) {
    const n = Na.fromArgs(t);
    return hg.toFixedFromValue({ accountDiscriminator: o3, ...n }).byteSize;
  }
  static async getMinimumBalanceForRentExemption(t, n, r) {
    return n.getMinimumBalanceForRentExemption(Na.byteSize(t), r);
  }
  pretty() {
    return {
      version: this.version,
      bump: this.bump,
      mint: this.mint.toBase58(),
      policy: this.policy.toBase58(),
      lockedBy: this.lockedBy,
      lastApprovedAt: (() => {
        const t = this.lastApprovedAt;
        if (typeof t.toNumber == 'function')
          try {
            return t.toNumber();
          } catch {
            return t;
          }
        return t;
      })(),
      lastTransferredAt: (() => {
        const t = this.lastTransferredAt;
        if (typeof t.toNumber == 'function')
          try {
            return t.toNumber();
          } catch {
            return t;
          }
        return t;
      })(),
      transferredCount: this.transferredCount,
    };
  }
}
const hg = new te.FixableBeetStruct(
  [
    ['accountDiscriminator', te.uniformFixedSizeArray(te.u8, 8)],
    ['version', te.u8],
    ['bump', te.uniformFixedSizeArray(te.u8, 1)],
    ['mint', kt.publicKey],
    ['policy', kt.publicKey],
    ['lockedBy', te.coption(kt.publicKey)],
    ['lastApprovedAt', te.i64],
    ['lastTransferredAt', te.i64],
    ['transferredCount', te.u32],
  ],
  Na.fromArgs,
  'MintState'
);
new te.BeetArgsStruct(
  [['instructionDiscriminator', te.uniformFixedSizeArray(te.u8, 8)]],
  'InitAccountInstructionArgs'
);
new te.BeetArgsStruct(
  [['instructionDiscriminator', te.uniformFixedSizeArray(te.u8, 8)]],
  'TransferInstructionArgs'
);
const iu = {
    [G.BitcoinLegacy]: { header: 10, perInput: 148, perOutput: 34 },
    [G.BitcoinNestedSegwit]: { header: 10.5, perInput: 91, perOutput: 32 },
    [G.BitcoinNativeSegwit]: { header: 10.5, perInput: 68, perOutput: 31 },
    [G.BitcoinTaproot]: { header: 10.5, perInput: 57.5, perOutput: 43 },
  },
  Que = {
    [G.BitcoinTaproot]: 330,
    [G.BitcoinNativeSegwit]: 294,
    [G.BitcoinNestedSegwit]: 540,
    [G.BitcoinLegacy]: 546,
  };
function ele(e) {
  switch (!0) {
    case de.isBitcoinNetworkID(e):
      return {
        virtualBytes: new fe(
          iu[G.BitcoinNativeSegwit].header +
            iu[G.BitcoinNativeSegwit].perInput +
            2 * iu[G.BitcoinTaproot].perOutput
        ),
        additionalCosts: { vb: new fe(0), sats: new fe(0) },
      };
    case de.isEVMNetworkID(e):
      return { gasLimit: new fe(21e3) };
    default:
      throw new Error(`Unsupported networkID: ${e}`);
  }
}
function I5({ btcPerKilobyte: e, virtualBytes: t, additionalCosts: n }) {
  return t1(e).times(t).plus(n).integerValue(fe.ROUND_UP);
}
function t1(e) {
  const t = new fe(0.001),
    n = fa(de.getTokenDecimals(mt.Bitcoin.Mainnet));
  return e.times(n).times(t);
}
function tle(e) {
  const t = e.data.inputs[0];
  let n;
  if (t.witnessUtxo) n = t.witnessUtxo.script;
  else if (t.nonWitnessUtxo)
    n = bi.Transaction.fromBuffer(t.nonWitnessUtxo).outs[e.txInputs[0].index].script;
  else throw new Error(`Unable to determine sender address from input: ${JSON.stringify(t)}`);
  return KL(n);
}
function T5(e) {
  return e.extractTransaction().getId();
}
const n1 = (e) => de.isSolanaNetworkID(e.networkID),
  r1 = (e) => de.isSuiNetworkID(e.networkID),
  i1 = (e) => de.isEVMNetworkID(e.networkID),
  s1 = (e) => de.isBitcoinNetworkID(e.networkID);
function x5(e) {
  return de.isBitcoinNetworkID(e.networkID);
}
function k5(e) {
  return de.isEVMNetworkID(e.networkID);
}
function nle(e) {
  return de.isSolanaNetworkID(e.networkID);
}
function rle(e) {
  return de.isSuiNetworkID(e.networkID);
}
const C5 = (e) => {
    if (!e) return;
    const t = e.networkID,
      n = de.getTokenSymbol(t),
      r = de.getTokenDecimals(t);
    if (n1(e)) {
      const i = new fe(e.value);
      return `${parseFloat(IP(i == null ? void 0 : i.toNumber()).toFixed(6))} ${n}`;
    } else if (i1(e)) {
      const i = e.gasLimit.times(e.maxFeePerGas);
      return `${parseFloat(new fe(i).div(fa(r)).toFixed(6))} ${n}`;
    } else if (s1(e)) {
      const i = I5(e);
      return `${parseFloat(i.div(fa(r)).toFixed(6))} ${n}`;
    } else if (r1(e)) return `${TP(e.gasBudget, r)} ${n}`;
  },
  ile = (e, t, n, r) => {
    const i = yX(e);
    return r ? new xx(t, n, new qL(r, i)) : new xx(t, n, i);
  },
  sle = '0x420000000000000000000000000000000000000F',
  ole = ['function getL1Fee(bytes memory _data) external view returns (uint256)'],
  P5 = async ({ networkId: e, serializedUnsignedTransaction: t }) => {
    const r = await ile(e, sle, ole).getL1Fee(t);
    return new fe(r.toString());
  },
  M5 = (e, t) => {
    const { gas: n, nonce: r, from: i, type: s, chainId: o, ...a } = e,
      c = 2,
      u = typeof r == 'string' ? parseInt(r, 16) : void 0,
      l = o ? parseInt(o) : void 0,
      d = { ...a, gasLimit: n, nonce: u, type: c, chainId: l };
    return YL(d, t);
  };
function ale(e, t) {
  const n = N9.parse({ ...e.unsignedTransaction, ...cle(t) });
  return { ...e, unsignedTransaction: n };
}
function cle(e) {
  return e
    ? {
        gasLimit: `0x${e.gasLimit.toString(16)}`,
        maxFeePerGas: `0x${e.maxFeePerGas.toString(16)}`,
        maxPriorityFeePerGas: `0x${e.maxPriorityFeePerGas.toString(16)}`,
      }
    : {};
}
function ule(e, t = !1, n) {
  const r = n[e];
  return r ? (t ? r.descriptionAbbreviatedKey : r.descriptionKey) : '';
}
const o1 = {
    transactionSpeedDescription: function (e, t) {
      return ule(e, t, this.transactionTimes);
    },
    transactionSpeedSeconds: function (e) {
      var t;
      return (t = this.transactionTimes[e]) == null ? void 0 : t.seconds;
    },
    transactionTimes: {},
    onBeforeSend: ({ multichainTransaction: e }) => Promise.resolve(e),
  },
  nl = {
    ...o1,
    transactionSettingsRowFeeDescription: void 0,
    isPendingTransactionMined: function (e) {
      return e.data.transactions.some((t) => t.confirmations > 0);
    },
    networkFeeRowString: function (e, t) {
      return t ? (e ? l9('gasUpTo', { amount: e }) : '') : (e ?? '');
    },
    isPendingTransactionsEqual: ({ data: e }, { data: t }) =>
      e.nonce === t.nonce && e.transactions.every((n, r) => n.hash === t.transactions[r].hash),
    sendSuccessRedirect: () => ao.History,
    droppedTransactionThresholdMs: we({ days: 2 }),
    onBeforeSend: ({ multichainTransaction: e, gasEstimation: t }) => {
      const n = t ? ale(e, t) : e;
      return Promise.resolve(n);
    },
    supportsNetworkSettings: !0,
  },
  lle = {
    ...nl,
    isPendingTransactionConfirmed: function ({ data: e }) {
      return e.transactions.some((t) => t.confirmations > 5);
    },
    sendSuccessRedirect: (e) => (e ? ao.Home : ao.History),
    additionalTransactionCost: async ({ networkID: e, unsignedTransaction: t }) =>
      P5({ networkId: e, serializedUnsignedTransaction: M5(t) }),
    droppedTransactionThresholdMs: we({ minutes: 5 }),
  },
  dle = {
    ...nl,
    isPendingTransactionConfirmed: function ({ data: e }) {
      return e.transactions.some((t) => t.confirmations > 5);
    },
    sendSuccessRedirect: (e) => (e ? ao.Home : ao.History),
    additionalTransactionCost: async ({ networkID: e, unsignedTransaction: t }) =>
      P5({ networkId: e, serializedUnsignedTransaction: M5(t) }),
    droppedTransactionThresholdMs: we({ minutes: 5 }),
  },
  fle = {
    descriptionKey: 'timeDescription1hour',
    descriptionAbbreviatedKey: 'timeDescriptionAbbrev1hour',
    seconds: 3600,
  },
  hle = {
    descriptionKey: 'timeDescription30minutes',
    descriptionAbbreviatedKey: 'timeDescriptionAbbrev30minutes',
    seconds: 1800,
  },
  ple = {
    descriptionKey: 'timeDescription10minutes',
    descriptionAbbreviatedKey: 'timeDescriptionAbbrev10minutes',
    seconds: 600,
  },
  gle = {
    descriptionKey: 'timeDescription2minutes',
    descriptionAbbreviatedKey: 'timeDescriptionAbbrev2minutes',
    seconds: 120,
  },
  yle = {
    descriptionKey: 'timeDescription30seconds',
    descriptionAbbreviatedKey: 'timeDescriptionAbbrev30seconds',
    seconds: 30,
  },
  ble = {
    descriptionKey: 'timeDescription15seconds',
    descriptionAbbreviatedKey: 'timeDescriptionAbbrev15seconds',
    seconds: 15,
  },
  mle = {
    descriptionKey: 'timeDescription10seconds',
    descriptionAbbreviatedKey: 'timeDescriptionAbbrev10seconds',
    seconds: 10,
  },
  wle = {
    descriptionKey: 'timeDescription5seconds',
    descriptionAbbreviatedKey: 'timeDescriptionAbbrev5seconds',
    seconds: 5,
  },
  vle = {
    descriptionKey: 'timeDescription1second',
    descriptionAbbreviatedKey: 'timeDescriptionAbbrev1second',
    seconds: 1,
  },
  wr = {
    TIME_1_HOUR: fle,
    TIME_30_MINUTES: hle,
    TIME_10_MINUTES: ple,
    TIME_2_MINUTES: gle,
    TIME_30_SECONDS: yle,
    TIME_15_SECONDS: ble,
    TIME_10_SECONDS: mle,
    TIME_5_SECONDS: wle,
    TIME_1_SECOND: vle,
  },
  _le = 35e5,
  Sle = 'http://127.0.0.1:8899';
j9(5e-6);
const Ele = {
    ...o1,
    transactionSettingsRowFeeDescription: (e) =>
      `${t1(e.btcPerKilobyte).decimalPlaces(1, fe.ROUND_HALF_UP)} sats/vB`,
    isPendingTransactionConfirmed: function (e) {
      return e.data.confirmations > 0;
    },
    isPendingTransactionMined: function (e) {
      return e.data.confirmations > 0;
    },
    networkFeeRowString: function (e) {
      return e || '';
    },
    transactionTimes: {
      slow: wr.TIME_10_MINUTES,
      standard: wr.TIME_10_MINUTES,
      fast: wr.TIME_10_MINUTES,
    },
    isPendingTransactionsEqual: (e, t) => e.data.txID === t.data.txID,
    sendSuccessRedirect: () => ao.History,
    droppedTransactionThresholdMs: we({ hours: 3 }),
    supportsNetworkSettings: !0,
  },
  Ale = {
    ...nl,
    isPendingTransactionConfirmed: function ({ data: e }) {
      return e.transactions.some((t) => t.confirmations > 0);
    },
    transactionTimes: {
      slow: wr.TIME_2_MINUTES,
      standard: wr.TIME_30_SECONDS,
      fast: wr.TIME_15_SECONDS,
    },
  },
  Ile = {
    ...nl,
    isPendingTransactionConfirmed: function ({ data: e }) {
      return e.transactions.some((t) => t.confirmations > 5);
    },
    transactionTimes: {
      slow: wr.TIME_15_SECONDS,
      standard: wr.TIME_10_SECONDS,
      fast: wr.TIME_5_SECONDS,
    },
  },
  Tle = {
    ...nl,
    isPendingTransactionConfirmed: function ({ data: e }) {
      return e.transactions.some((t) => t.confirmations > 1);
    },
    transactionTimes: {
      slow: wr.TIME_1_SECOND,
      standard: wr.TIME_1_SECOND,
      fast: wr.TIME_1_SECOND,
    },
    supportsNetworkSettings: !1,
  },
  xle = {
    ...nl,
    isPendingTransactionConfirmed: function ({ data: e }) {
      return e.transactions.some((t) => t.confirmations > 5);
    },
    transactionTimes: {
      slow: wr.TIME_15_SECONDS,
      standard: wr.TIME_10_SECONDS,
      fast: wr.TIME_5_SECONDS,
    },
  },
  kle = {
    ...o1,
    transactionSettingsRowFeeDescription: void 0,
    isPendingTransactionConfirmed: function (e) {
      return e.data.confirmationStatus === 'confirmed';
    },
    isPendingTransactionMined: function (e) {
      return e.data.confirmationStatus === 'processed';
    },
    networkFeeRowString: function (e) {
      return e || '';
    },
    transactionTimes: {},
    isPendingTransactionsEqual: (e, t) => e.data.signature === t.data.signature,
    sendSuccessRedirect: () => ao.History,
    droppedTransactionThresholdMs: Number.POSITIVE_INFINITY,
    supportsNetworkSettings: !1,
  },
  FI = (e) => {
    const t = de.getRpcProxyUrl(e);
    if (!t) throw new Error(`Unable to instantiate client for ${e}`);
    return new nU({ url: t });
  };
async function Cle({ multichainTransaction: e, gasEstimation: t }) {
  if (!t) return e;
  const { transaction: n, networkID: r } = e,
    i = Eb.from(n);
  i.setGasBudget(BigInt(t.gasBudget.toString()));
  const s = await i.build({ client: FI(r) });
  return { ...e, transaction: s };
}
const Ple = {
    ...o1,
    transactionSettingsRowFeeDescription: void 0,
    isPendingTransactionConfirmed: function (e) {
      throw new Error('Function not implemented for Sui.');
    },
    isPendingTransactionMined: function (e) {
      throw new Error('Function not implemented for Sui.');
    },
    networkFeeRowString: function (e) {
      return e || '';
    },
    isPendingTransactionsEqual: function (e, t) {
      return e.data.digest === t.data.digest;
    },
    sendSuccessRedirect: () => ao.History,
    droppedTransactionThresholdMs: we({ minutes: 5 }),
    amountForGasEstimation: 1,
    onBeforeSend: Cle,
    supportsNetworkSettings: !1,
  },
  Mle = new Lu({
    [ze.Solana]: kle,
    [ze.Ethereum]: Ale,
    [ze.Polygon]: xle,
    [ze.Monad]: Tle,
    [ze.Base]: dle,
    [ze.Arbitrum]: lle,
    [ze.Bitcoin]: Ele,
    [ze.Sui]: Ple,
    [ze.Hypercore]: Ile,
  }),
  Mu = Uu(Mle),
  Ole = {
    [mt.Bitcoin.Mainnet]: 'https://btc-mainnet.phantom.app',
    [mt.Bitcoin.Testnet]: 'https://btc-mainnet.phantom.dev',
  },
  Ble = (e) => {
    if (!de.isBitcoinNetworkID(e)) throw new Error(`Unsupported network id: ${e}`);
    return hX(Ole[e]);
  };
new nr('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');
new nr('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');
new nr('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr');
new nr('DeJBGdMFa1uynnnKiwrVioatTuHmNLpyFKnmB5kaFdzQ');
new nr('11111111111111111111111111111111');
const Dle = (e, t) => {
    const n = Nle(e);
    return Rle(n, t);
  },
  Rle = (e, t) => {
    const n = { commitment: 'processed', fetch: t$ };
    if ((t && (n.httpHeaders = t), e === 'localhost')) return new Sw(Sle, n);
    if (e === 'mainnet-beta') {
      const r = de.getRpcProxyUrl(Js.Mainnet);
      if (!r) throw new Error('Unable to find RPC Proxy Url for Solana Mainnet');
      return new Sw(r, n);
    }
    return new Sw(ML(e), n);
  },
  Nle = (e) => {
    switch (e) {
      case mt.Solana.Mainnet:
        return 'mainnet-beta';
      case mt.Solana.Testnet:
        return 'testnet';
      case mt.Solana.Devnet:
        return 'devnet';
      case mt.Solana.Localnet:
        return 'localhost';
    }
  };
mt.Ethereum.Mainnet + '',
  mt.Ethereum.Sepolia + '',
  mt.Polygon.Mainnet + '',
  mt.Polygon.Amoy + '',
  mt.Base.Mainnet + '',
  mt.Base.Sepolia + '',
  mt.Monad.Mainnet + '',
  mt.Monad.Testnet + '',
  mt.Monad.Devnet + '',
  mt.Bitcoin.Mainnet + '',
  mt.Bitcoin.Testnet + '',
  mt.Arbitrum.Mainnet + '',
  mt.Arbitrum.Sepolia + '',
  mt.Hypercore.Mainnet + '',
  mt.Hypercore.Testnet + '';
g.object({ recommendedComputeUnitPriceInMicrolamports: g.number().positive() });
g.object({
  min: g.number().positive(),
  low: g.number().positive(),
  high: g.number().positive(),
  max: g.number().positive(),
});
const jle = 2,
  Lle = 3;
De([wt('instruction'), L9('microLamports')]);
De([wt('instruction'), Ne('units')]);
function Ule(e) {
  return e
    ? {
        gasLimit: `0x${e.gasLimit.toString(16)}`,
        maxFeePerGas: `0x${e.maxFeePerGas.toString(16)}`,
        maxPriorityFeePerGas: `0x${e.maxPriorityFeePerGas.toString(16)}`,
      }
    : {};
}
function O5(e, t, n, r) {
  if (de.isBitcoinNetworkID(e)) {
    const { virtualBytes: i, additionalCosts: s } = n,
      { sats: o, vb: a } = s,
      c = t,
      l = t1(c.btcPerKilobyte).times(a).plus(o);
    return { networkID: e, virtualBytes: i, btcPerKilobyte: c.btcPerKilobyte, additionalCosts: l };
  } else if (de.isEVMNetworkID(e)) {
    const i = t;
    return {
      networkID: e,
      gasLimit: n.gasLimit,
      maxFeePerGas: i.maxFeePerGas,
      maxPriorityFeePerGas: i.maxPriorityFeePerGas,
      l1Fee: r,
    };
  } else {
    if (de.isSolanaNetworkID(e))
      throw new Error(
        'Solana gas estimations are not constructed from transaction units and transaction unit costs.'
      );
    if (de.isSuiNetworkID(e)) throw new wy('create gas estimation');
    return qt();
  }
}
const Hy = {
    deserializeVersionedTransaction: (e) => {
      let t;
      try {
        t = or.decode(e);
      } catch {
        t = z.from(e, 'base64');
      }
      const n = OL.deserialize(t);
      return {
        transaction: n,
        metadata: { numInstructions: n.message.compiledInstructions.length, type: 0 },
      };
    },
    getTransactionClassType(e) {
      return mx(e) ? 'versioned' : 'legacy';
    },
    deserializeWithVersion: (e) => {
      const { transaction: t, type: n } = e;
      let r;
      try {
        r = or.decode(t);
      } catch {
        r = z.from(t, 'base64');
      }
      if (n === 'legacy') {
        const i = BL.from(r);
        return { transaction: i, metadata: { numInstructions: i.instructions.length, type: n } };
      } else {
        if (n === 0) return Hy.deserializeVersionedTransaction(t);
        throw new Error(`Unknown transaction type => ${n}`);
      }
    },
    deserializeWithMessage(e) {
      const { transaction: t, message: n } = e,
        r = or.decode(n),
        i = DL.deserializeMessageVersion(r);
      return Hy.deserializeWithVersion({ transaction: t, type: i });
    },
    serialize(e) {
      if (mx(e)) {
        const t = or.encode(e.serialize()),
          n = or.encode(e.message.serialize());
        return { transaction: t, message: n };
      } else {
        const t = or.encode(e.serialize({ requireAllSignatures: !1, verifySignatures: !0 })),
          n = or.encode(e.serializeMessage());
        return { transaction: t, message: n };
      }
    },
  },
  $le = ({ networkID: e, address: t }) => ({ chainId: e, address: t });
lP.extend(xP);
const Fle = (e) =>
    g
      .array(g.unknown())
      .transform((t) => (t == null ? void 0 : t.filter((n) => e.safeParse(n).success))),
  zle = g.object({
    chainId: mb,
    transaction: g.object({ txID: g.string() }),
    submittedAt: g.string().datetime(),
    utxos: g.array(g.object({ address: g.string() })),
  });
g.object({ transactions: Fle(zle) });
const B5 = (e) => e.gasLimit.times(e.maxFeePerGas),
  D5 = (e) => new fe(e.value),
  R5 = (e) => I5(e),
  Kle = ({ gasBudget: e }) => e,
  Vle = (e) => {
    if (e) {
      if (i1(e)) return B5(e);
      if (n1(e)) return D5(e);
      if (s1(e)) return R5(e);
      if (r1(e)) return Kle(e);
      throw new Error('unsupported chain type');
    }
  },
  zI = (e) => iu[e].perInput,
  oy = (e) => iu[e].perOutput,
  Wle = (e) => iu[e].header,
  N5 = (e, t, n) =>
    Wle(e) + t * zI(e) + jl(n.map((r) => ({ value: oy(bs(mt.Bitcoin.Mainnet, r.address)) })));
function jl(e) {
  return e.reduce((t, n) => t + (typeof n.value == 'string' ? parseFloat(n.value) : n.value), 0);
}
function Hle(e, t, n, r) {
  let i = N5(e, t.length, n);
  const s = r * (i + oy(e)),
    o = jl(t) - (jl(n) + s),
    a = r * oy(e),
    c = Que[e];
  o > c && o > a && ((n = n.concat({ value: Math.ceil(o), address: t[0].owner })), (i += oy(e)));
  const u = jl(t) - jl(n);
  return { type: 'success', inputs: t, outputs: n, vb: i, fee: u };
}
function Gle(e, t, n, r, i) {
  const s = zI(e),
    o = i * s,
    a = r.reduce((h, p) => h + p.value, 0);
  let c = N5(e, n.length, r),
    u = _y(n.map((h) => parseFloat(h.value)));
  const l = [];
  for (let h = 0; h < t.length; h++) {
    const p = t[h],
      b = parseFloat(p.value);
    if (o > b) {
      if (h === t.length - 1) {
        const A = i * c;
        return { type: 'error', maxAmount: u - A, vb: c };
      }
      continue;
    }
    (c += s), (u += b), l.push(p);
    const w = i * c;
    if (u >= a + w) return Hle(e, n.concat(l), r, i);
  }
  const d = i * c;
  return { type: 'error', maxAmount: u - d, vb: c };
}
function qle(e, t, n, r, i = []) {
  const o = Yle(e, t, r).filter(
    (a) => !i.some((c) => c.transactionHash === a.transactionHash && c.index === a.index)
  );
  return Gle(e, o, i, n, r);
}
function a3(e, t, n) {
  return parseFloat(t.value) - n * zI(e);
}
function Yle(e, t, n) {
  return t.concat().sort((r, i) => a3(e, i, n) - a3(e, r, n));
}
var Kl = ((e) => (
  (e.UnconfirmedOutput = 'UnconfirmedOutput'), (e.UnconfirmedInput = 'UnconfirmedInput'), e
))(Kl || {});
const Zle = g.object({ transactionHash: g.string(), index: g.number() }),
  Jle = g.object({ id: g.string() });
Zle.extend({
  value: g.string(),
  owner: g.string(),
  inscription: g.optional(Jle),
  isSafeToSend: g.boolean(),
});
var Xs = ((e) => (
  (e.AddUtxo = 'AddUtxo'),
  (e.UpsertMeta = 'UpsertMeta'),
  (e.RemoveMeta = 'RemoveMeta'),
  (e.ReplaceUtxo = 'ReplaceUtxo'),
  e
))(Xs || {});
const Xle = g.object({
    value: g.string(),
    transactionHash: g.string(),
    index: g.string(),
    inscriptionId: g.string().nullish(),
    isSafeToSend: g.boolean(),
  }),
  Qle = g.object({ utxos: g.array(Xle) });
function ay(e, t) {
  return e.transactionHash === t.transactionHash && e.index === t.index;
}
function ede(e) {
  const t = T5(e);
  return e.txInputs.map((n, r) => {
    if (typeof n.hash == 'string') throw new Error('Expected hash to be a Buffer');
    return {
      type: Kl.UnconfirmedInput,
      unconfirmedTransactionHash: t,
      unconfirmedTransactionIndex: r,
      id: { index: n.index, transactionHash: tde(n.hash) },
    };
  });
}
function tde(e) {
  return z.from(e).reverse().toString('hex');
}
function nde(e) {
  const t = T5(e);
  return e.txOutputs.map((n, r) => ({
    transactionHash: t,
    index: r,
    value: n.value.toString(),
    owner: n.address ?? '',
    inscription: void 0,
    isSafeToSend: !1,
  }));
}
const rde = 'utxos.v1',
  ide = 'utxo_metadata.v1';
class sde {
  constructor(t) {
    ae(this, '_storage');
    this._storage = t;
  }
  getUtxoStorageKey(t) {
    return `${rde}.${t}`;
  }
  getMetadataStorageKey(t) {
    return `${ide}.${t}`;
  }
  async getUtxos(t) {
    try {
      const n = await this._storage.get(this.getUtxoStorageKey(t));
      return n || [];
    } catch {
      return this.reset(t), [];
    }
  }
  async getMetadata(t) {
    try {
      const n = await this._storage.get(this.getMetadataStorageKey(t));
      return n || [];
    } catch {
      return this.reset(t), [];
    }
  }
  async getSafeToSendUtxos(t) {
    return (await this.getUtxos(t)).filter((r) => r.isSafeToSend);
  }
  async getInscribedUtxos(t) {
    return this.getUtxos(t).then((n) => n.filter((r) => r.inscription));
  }
  async getRareSatsUtxos(t) {
    return this.getUtxos(t).then((n) => n.filter((r) => !r.inscription && !r.isSafeToSend));
  }
  async apply(t, n) {
    let [r, i] = await Promise.all([this.getUtxos(t), this.getMetadata(t)]);
    for (const s of n)
      switch (s.type) {
        case Xs.UpsertMeta:
          i = this.upsertMetadata(s, i);
          break;
        case Xs.RemoveMeta:
          i = this.removeMetadata(s, i);
          break;
        case Xs.AddUtxo:
          r = this.addUtxos(s, r);
          break;
        case Xs.ReplaceUtxo:
          r = this.replaceUtxo(s, r);
          break;
      }
    return (
      await Promise.all([
        this._storage.set(this.getUtxoStorageKey(t), r),
        this._storage.set(this.getMetadataStorageKey(t), i),
      ]),
      r
    );
  }
  replaceUtxo(t, n) {
    return t.utxos;
  }
  removeMetadata(t, n) {
    return n.filter((r) => !t.metasToRemove.some((i) => ay(i, r.id)));
  }
  upsertMetadata(t, n) {
    for (const r of t.metas) {
      const i = n.findIndex((s) => ay(s.id, r.id) && s.type === r.type);
      i !== -1 ? (n[i] = r) : n.push(r);
    }
    return n;
  }
  addUtxos(t, n) {
    for (const r of t.utxos) n.some((s) => ay(s, r)) || n.push(r);
    return n;
  }
  async reset(t) {
    return Promise.all([
      this._storage.remove(this.getUtxoStorageKey(t)),
      this._storage.remove(this.getMetadataStorageKey(t)),
    ]);
  }
}
const c3 = new Error('Failed to get utxos for addresses'),
  ode = (e) => {
    async function t(a) {
      const c = tle(a),
        u = ede(a),
        l = nde(a).filter((h) => h.owner === c),
        d = l.map((h) => ({
          type: Kl.UnconfirmedOutput,
          id: { transactionHash: h.transactionHash, index: h.index },
        })),
        f = [
          { type: Xs.UpsertMeta, metas: [...u, ...d] },
          { type: Xs.AddUtxo, utxos: l },
        ];
      return e.apply(c, f);
    }
    async function n(a) {
      const c = { address: a.address, chainId: a.networkID, resourceType: Pr.address };
      try {
        const u = await Ge.api().post('/bitcoin/v1/spendable-utxos', { address: c });
        if (u.status !== 200) throw c3;
        const l = Qle.parse(u.data),
          d = l.utxos
            .map((f) => ({
              index: parseFloat(f.index),
              owner: a.address,
              transactionHash: f.transactionHash,
              value: f.value,
              inscription: f.inscriptionId ? { id: f.inscriptionId } : void 0,
              isSafeToSend: f.isSafeToSend,
            }))
            .sort((f, h) => new fe(h.value).comparedTo(new fe(f.value)));
        return await r(d), l.utxos;
      } catch {
        throw c3;
      }
    }
    async function r(a) {
      if (a.length === 0) return [];
      const c = a[0].owner,
        l = (await e.getMetadata(c)).reduce((d, f) => {
          const h = a.some((p) => ay(p, f.id));
          return (
            ((f.type === Kl.UnconfirmedOutput && h) || (f.type === Kl.UnconfirmedInput && !h)) &&
              d.push(f.id),
            d
          );
        }, []);
      return e.apply(c, [
        { type: Xs.RemoveMeta, metasToRemove: l },
        { type: Xs.ReplaceUtxo, utxos: a },
      ]);
    }
    async function i(a) {
      return e.getSafeToSendUtxos(a);
    }
    async function s(a) {
      return e.getInscribedUtxos(a);
    }
    async function o(a) {
      return e.getRareSatsUtxos(a);
    }
    return {
      notifyPendingTransaction: t,
      refetchUtxos: n,
      getSafeToSendUtxos: i,
      getInscribedUtxos: s,
      getRareSatsUtxos: o,
    };
  };
g.union([g.literal('UNSET'), g.literal('ECONOMICAL'), g.literal('CONSERVATIVE')]);
const ade = (e, t, n, r, i = Ie.Info, s = { minStatusCode: 400, maxStatusCode: 500 }) => {
  (!t || (t >= s.minStatusCode && t < s.maxStatusCode)) &&
    (re.addBreadcrumb(n, e.message, i, r), re.captureError(e, ce.Transaction));
};
we({ seconds: 2 });
const cde = g
    .string()
    .refine((e) => typeof e == 'string' && e.match(/^0x[0-9A-Fa-f]*$/), {
      message: 'Value is not a valid hex string.',
    }),
  ude = (e) => {
    if (cde.safeParse(e).success) {
      if (parseInt(e, 16) === 0) return '0x0';
      const n = e.replace('0x', '');
      let r = 0;
      for (; r < n.length && n[r] === '0'; ) r++;
      return '0x' + n.substring(r);
    } else throw new Error('string is not in hex encoding.');
  },
  lde = (e) => ude('0x' + e.toString(16));
lde(new fe('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'));
g.object({
  domain: g.object({
    chainId: g.number(),
    name: g.string(),
    verifyingContract: g.string(),
    version: g.string(),
  }),
  message: g.object({
    expiry: g.number(),
    nonce: g.number(),
    spender: g.string(),
    holder: g.string(),
    allowed: g.boolean(),
  }),
  primaryType: g.literal('Permit'),
  types: g.object({
    EIP712Domain: g.array(g.object({ name: g.string(), type: g.string() })),
    Permit: g.array(g.object({ name: g.string(), type: g.string() })),
  }),
});
g.object({
  domain: g.object({
    chainId: g.number(),
    name: g.string(),
    verifyingContract: g.string(),
    version: g.string(),
  }),
  message: g.object({
    deadline: g.number(),
    nonce: g.number(),
    spender: g.string(),
    holder: g.string(),
    value: g.number(),
  }),
  primaryType: g.literal('Permit'),
  types: g.object({
    EIP712Domain: g.array(g.object({ name: g.string(), type: g.string() })),
    Permit: g.array(g.object({ name: g.string(), type: g.string() })),
  }),
});
g.object({
  domain: g.object({
    chainId: g.string(),
    name: g.literal('Permit2'),
    verifyingContract: g.string(),
  }),
  message: g.object({
    details: g.object({
      token: g.string(),
      amount: g.string(),
      expiration: g.string(),
      nonce: g.string(),
    }),
    spender: g.string(),
    sigDeadline: g.string(),
  }),
  primaryType: g.literal('PermitSingle'),
  types: g.object({
    EIP712Domain: g.array(g.object({ name: g.string(), type: g.string() })),
    PermitSingle: g.array(g.object({ name: g.string(), type: g.string() })),
    PermitDetails: g.array(g.object({ name: g.string(), type: g.string() })),
  }),
});
g.object({
  domain: g.object({
    chainId: g.string(),
    name: g.literal('Permit2'),
    verifyingContract: g.string(),
  }),
  message: g.object({
    details: g.array(
      g.object({ token: g.string(), amount: g.string(), expiration: g.string(), nonce: g.string() })
    ),
    spender: g.string(),
    sigDeadline: g.string(),
  }),
  primaryType: g.literal('PermitBatch'),
  types: g.object({
    EIP712Domain: g.array(g.object({ name: g.string(), type: g.string() })),
    PermitBatch: g.array(g.object({ name: g.string(), type: g.string() })),
    PermitDetails: g.array(g.object({ name: g.string(), type: g.string() })),
  }),
});
g.object({
  results: g.array(
    g.object({
      id: g.string(),
      interactionData: g.object({
        dapp: g.union([g.null(), g.object({ displayName: g.string(), logoURI: g.string() })]),
      }),
    })
  ),
});
const u3 = BigInt('2000'),
  dde = 5e10,
  fde = BigInt(1e3),
  hde = 1.2,
  pde = async ({ networkID: e, transaction: t }) => {
    const n = FI(e),
      r = yde(),
      i = Eb.from(t);
    if (!i.getData().sender)
      throw new Error(
        `Transaction does not yet have a sender set: ${i.getData()}. Cannot dry run transaction.`
      );
    i.setGasBudgetIfNotSet(dde), i.setGasPayment([]);
    const s = await i.build({ client: n }),
      { effects: o } = await n.dryRunTransactionBlock({ transactionBlock: s }),
      a = o.gasUsed,
      c = gde(a),
      u = c > u3 ? c : u3,
      l = BigInt(Math.ceil(Number(u) * r));
    return { networkID: e, gasBudget: fe(l.toString()) };
  },
  gde = ({ computationCost: e, storageCost: t, storageRebate: n }) => {
    const r = BigInt(e) + fde,
      i = r + BigInt(t) - BigInt(n);
    return i > r ? i : r;
  };
function yde() {
  const e = ms.getMultivariateAssignment('sui-gas-budget-multiplier'),
    t = e ? parseFloat(e) : NaN;
  return Number.isFinite(t) ? t : hde;
}
const bde = 3,
  mde = 1e3,
  wde = (e) => !0,
  vde = async (e, t) => {
    const n = FI(t);
    return U9(() => e.build({ client: n }), wde, bde, mde);
  },
  _de = async (e, t = { fallbackToProvider: !0 }) => {
    const { networkID: n, transaction: r, address: i } = e,
      s = Eb.from(r);
    i && s.setSenderIfNotSet(i);
    try {
      return await s.build();
    } catch (o) {
      if (!t.fallbackToProvider) throw o;
      try {
        return await vde(s, n);
      } catch (a) {
        throw new Error(
          `Failed to build Sui transaction: ${a instanceof Error ? a.message : 'Unknown error'}`
        );
      }
    }
  };
/**
 * Support for translating between Buffer instances and JavaScript
 * native types.
 *
 * {@link module:Layout~Layout|Layout} is the basis of a class
 * hierarchy that associates property names with sequences of encoded
 * bytes.
 *
 * Layouts are supported for these scalar (numeric) types:
 * * {@link module:Layout~UInt|Unsigned integers in little-endian
 *   format} with {@link module:Layout.u8|8-bit}, {@link
 *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},
 *   {@link module:Layout.u32|32-bit}, {@link
 *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}
 *   representation ranges;
 * * {@link module:Layout~UIntBE|Unsigned integers in big-endian
 *   format} with {@link module:Layout.u16be|16-bit}, {@link
 *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},
 *   {@link module:Layout.u40be|40-bit}, and {@link
 *   module:Layout.u48be|48-bit} representation ranges;
 * * {@link module:Layout~Int|Signed integers in little-endian
 *   format} with {@link module:Layout.s8|8-bit}, {@link
 *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},
 *   {@link module:Layout.s32|32-bit}, {@link
 *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}
 *   representation ranges;
 * * {@link module:Layout~IntBE|Signed integers in big-endian format}
 *   with {@link module:Layout.s16be|16-bit}, {@link
 *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},
 *   {@link module:Layout.s40be|40-bit}, and {@link
 *   module:Layout.s48be|48-bit} representation ranges;
 * * 64-bit integral values that decode to an exact (if magnitude is
 *   less than 2^53) or nearby integral Number in {@link
 *   module:Layout.nu64|unsigned little-endian}, {@link
 *   module:Layout.nu64be|unsigned big-endian}, {@link
 *   module:Layout.ns64|signed little-endian}, and {@link
 *   module:Layout.ns64be|unsigned big-endian} encodings;
 * * 32-bit floating point values with {@link
 *   module:Layout.f32|little-endian} and {@link
 *   module:Layout.f32be|big-endian} representations;
 * * 64-bit floating point values with {@link
 *   module:Layout.f64|little-endian} and {@link
 *   module:Layout.f64be|big-endian} representations;
 * * {@link module:Layout.const|Constants} that take no space in the
 *   encoded expression.
 *
 * and for these aggregate types:
 * * {@link module:Layout.seq|Sequence}s of instances of a {@link
 *   module:Layout~Layout|Layout}, with JavaScript representation as
 *   an Array and constant or data-dependent {@link
 *   module:Layout~Sequence#count|length};
 * * {@link module:Layout.struct|Structure}s that aggregate a
 *   heterogeneous sequence of {@link module:Layout~Layout|Layout}
 *   instances, with JavaScript representation as an Object;
 * * {@link module:Layout.union|Union}s that support multiple {@link
 *   module:Layout~VariantLayout|variant layouts} over a fixed
 *   (padded) or variable (not padded) span of bytes, using an
 *   unsigned integer at the start of the data or a separate {@link
 *   module:Layout.unionLayoutDiscriminator|layout element} to
 *   determine which layout to use when interpreting the buffer
 *   contents;
 * * {@link module:Layout.bits|BitStructure}s that contain a sequence
 *   of individual {@link
 *   module:Layout~BitStructure#addField|BitField}s packed into an 8,
 *   16, 24, or 32-bit unsigned integer starting at the least- or
 *   most-significant bit;
 * * {@link module:Layout.cstr|C strings} of varying length;
 * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link
 *   module:Layout~Blob#length|length} raw data.
 *
 * All {@link module:Layout~Layout|Layout} instances are immutable
 * after construction, to prevent internal state from becoming
 * inconsistent.
 *
 * @local Layout
 * @local ExternalLayout
 * @local GreedyCount
 * @local OffsetLayout
 * @local UInt
 * @local UIntBE
 * @local Int
 * @local IntBE
 * @local NearUInt64
 * @local NearUInt64BE
 * @local NearInt64
 * @local NearInt64BE
 * @local Float
 * @local FloatBE
 * @local Double
 * @local DoubleBE
 * @local Sequence
 * @local Structure
 * @local UnionDiscriminator
 * @local UnionLayoutDiscriminator
 * @local Union
 * @local VariantLayout
 * @local BitStructure
 * @local BitField
 * @local Boolean
 * @local Blob
 * @local CString
 * @local Constant
 * @local bindConstructorLayout
 * @module Layout
 * @license MIT
 * @author Peter A. Bigot
 * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}
 */ class od {
  constructor(t, n) {
    if (!Number.isInteger(t)) throw new TypeError('span must be an integer');
    (this.span = t), (this.property = n);
  }
  makeDestinationObject() {
    return {};
  }
  decode(t, n) {
    throw new Error('Layout is abstract');
  }
  encode(t, n, r) {
    throw new Error('Layout is abstract');
  }
  getSpan(t, n) {
    if (0 > this.span) throw new RangeError('indeterminate span');
    return this.span;
  }
  replicate(t) {
    const n = Object.create(this.constructor.prototype);
    return Object.assign(n, this), (n.property = t), n;
  }
  fromArray(t) {}
}
function Sde(e, t) {
  return t.property ? e + '[' + t.property + ']' : e;
}
class pg extends od {
  isCount() {
    throw new Error('ExternalLayout is abstract');
  }
}
const mE = Math.pow(2, 32);
function Ede(e) {
  const t = Math.floor(e / mE),
    n = e - t * mE;
  return { hi32: t, lo32: n };
}
function Ade(e, t) {
  return e * mE + t;
}
class Ide extends od {
  constructor(t) {
    super(8, t);
  }
  decode(t, n) {
    n === void 0 && (n = 0);
    const r = t.readUInt32LE(n),
      i = t.readUInt32LE(n + 4);
    return Ade(i, r);
  }
  encode(t, n, r) {
    r === void 0 && (r = 0);
    const i = Ede(t);
    return n.writeUInt32LE(i.lo32, r), n.writeUInt32LE(i.hi32, r + 4), 8;
  }
}
class Tde extends od {
  constructor(t, n, r) {
    if (!(Array.isArray(t) && t.reduce((s, o) => s && o instanceof od, !0)))
      throw new TypeError('fields must be array of Layout instances');
    typeof n == 'boolean' && r === void 0 && ((r = n), (n = void 0));
    for (const s of t)
      if (0 > s.span && s.property === void 0)
        throw new Error('fields cannot contain unnamed variable-length layout');
    let i = -1;
    try {
      i = t.reduce((s, o) => s + o.getSpan(), 0);
    } catch {}
    super(i, n), (this.fields = t), (this.decodePrefixes = !!r);
  }
  getSpan(t, n) {
    if (0 <= this.span) return this.span;
    n === void 0 && (n = 0);
    let r = 0;
    try {
      r = this.fields.reduce((i, s) => {
        const o = s.getSpan(t, n);
        return (n += o), i + o;
      }, 0);
    } catch {
      throw new RangeError('indeterminate span');
    }
    return r;
  }
  decode(t, n) {
    n === void 0 && (n = 0);
    const r = this.makeDestinationObject();
    for (const i of this.fields)
      if (
        (i.property !== void 0 && (r[i.property] = i.decode(t, n)),
        (n += i.getSpan(t, n)),
        this.decodePrefixes && t.length === n)
      )
        break;
    return r;
  }
  encode(t, n, r) {
    r === void 0 && (r = 0);
    const i = r;
    let s = 0,
      o = 0;
    for (const a of this.fields) {
      let c = a.span;
      if (((o = 0 < c ? c : 0), a.property !== void 0)) {
        const u = t[a.property];
        u !== void 0 && ((o = a.encode(u, n, r)), 0 > c && (c = a.getSpan(n, r)));
      }
      (s = r), (r += c);
    }
    return s + o - i;
  }
  fromArray(t) {
    const n = this.makeDestinationObject();
    for (const r of this.fields)
      r.property !== void 0 && 0 < t.length && (n[r.property] = t.shift());
    return n;
  }
  layoutFor(t) {
    if (typeof t != 'string') throw new TypeError('property must be string');
    for (const n of this.fields) if (n.property === t) return n;
  }
  offsetOf(t) {
    if (typeof t != 'string') throw new TypeError('property must be string');
    let n = 0;
    for (const r of this.fields) {
      if (r.property === t) return n;
      0 > r.span ? (n = -1) : 0 <= n && (n += r.span);
    }
  }
}
let j5 = class extends od {
  constructor(t, n) {
    if (!((t instanceof pg && t.isCount()) || (Number.isInteger(t) && 0 <= t)))
      throw new TypeError('length must be positive integer or an unsigned integer ExternalLayout');
    let r = -1;
    t instanceof pg || (r = t), super(r, n), (this.length = t);
  }
  getSpan(t, n) {
    let r = this.span;
    return 0 > r && (r = this.length.decode(t, n)), r;
  }
  decode(t, n) {
    n === void 0 && (n = 0);
    let r = this.span;
    return 0 > r && (r = this.length.decode(t, n)), t.slice(n, n + r);
  }
  encode(t, n, r) {
    let i = this.length;
    if ((this.length instanceof pg && (i = t.length), !(z.isBuffer(t) && i === t.length)))
      throw new TypeError(Sde('Blob.encode', this) + ' requires (length ' + i + ') Buffer as src');
    if (r + i > n.length) throw new RangeError('encoding overruns Buffer');
    return (
      n.write(t.toString('hex'), r, i, 'hex'),
      this.length instanceof pg && this.length.encode(i, n, r),
      i
    );
  }
};
var xde = j5,
  kde = (e) => new Ide(e),
  L5 = (e, t, n) => new Tde(e, t, n),
  qv = (e, t) => new j5(e, t);
class Cde extends xde {
  constructor(t) {
    super(32, t);
  }
  decode(t, n) {
    return new nr(super.decode(t, n));
  }
  encode(t, n, r) {
    return super.encode(t.toBuffer(), n, r);
  }
}
function Pde(e) {
  return new Cde(e);
}
L5([Pde('account')]);
const l3 = 'estimate-fee-from-message',
  d3 = 5e3,
  Mde = async (e, t) => {
    const n = [];
    for (const s of t)
      n.push(
        (async () => {
          let o;
          try {
            o = await Dle(e).getFeeForMessage(s, 'confirmed');
          } catch {
            return re.addBreadcrumb(l3, 'rpc failed', Ie.Info), s.header.numRequiredSignatures * d3;
          }
          return o.value === null
            ? (re.addBreadcrumb(l3, 'null value returned from rpc', Ie.Info),
              s.header.numRequiredSignatures * d3)
            : o.value;
        })()
      );
    const r = _y(await Promise.all(n)),
      i = r / t.length > _le;
    return { networkID: e, value: r, highFees: i };
  };
class ls extends Error {
  constructor(n, r, i) {
    const s = [r];
    i && s.push(JSON.stringify(i));
    super(s.join(':'));
    ae(this, 'kind');
    ae(this, 'meta');
    (this.meta = i), (this.kind = n);
  }
  static createUnknownError(n, r) {
    return Ma.UNKNOWN_ERROR(n, r);
  }
}
const Ma = {
  ATL_MISMATCH: () =>
    new ls('ATL_MISMATCH', 'Address table lookups do not match the initial transaction'),
  INSTRUCTION_MISMATCH: () =>
    new ls('INSTRUCTION_MISMATCH', 'Instructions do not match the initial transaction'),
  UNKNOWN_PROGRAM_INTERACTION: (e) =>
    new ls(
      'UNKNOWN_PROGRAM_INTERACTION',
      'Instruction is attempting to interact with an unknown program',
      { programId: e }
    ),
  MISSING_LIGHTHOUSE_PROGRAM_CALL: () =>
    new ls('MISSING_LIGHTHOUSE_PROGRAM_CALL', 'Instructions are missing Lighthouse program call'),
  TX_COUNT_MISMATCH: () =>
    new ls('TX_COUNT_MISMATCH', 'There are more original transactions than Safeguard transactions'),
  UNKNOWN_ERROR: (e, t) => new ls('UNKNOWN_ERROR', e, t),
};
function su(e, t, n) {
  if (e !== t) throw n();
}
function Yv(e, t) {
  if (!e) throw t();
}
function Ode(e, t) {
  if (e) throw t();
}
function Bde(e, t, n) {
  if (e.length !== t.length) throw n();
  for (const [r, i] of e.entries())
    su(i.pubkey.toString(), t[r].pubkey.toString(), n),
      su(i.isSigner, t[r].isSigner, n),
      su(i.isWritable, t[r].isWritable, n);
}
function Dde(e, t, n) {
  su(e.data.toString(), t.data.toString(), n),
    su(e.programId.toString(), t.programId.toString(), n),
    Bde(e.keys, t.keys, n);
}
const Gy = [
    'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',
    'L2TExMFKdjpN9kozasaurPirfHy9P8sbXoAN1qA3S95',
  ],
  Rde = Gy[Gy.length - 1],
  Nde = { lighthouseIds: Gy };
function jde(e, t, { lighthouseIds: n = Gy } = Nde) {
  Yv(t.length >= e.length, Ma.TX_COUNT_MISMATCH);
  const r = e.map((d) => Hy.deserializeVersionedTransaction(d).transaction),
    i = t.map((d) => Hy.deserializeVersionedTransaction(d).transaction),
    s = r
      .flatMap((d) => d.message.addressTableLookups)
      .map((d) => d.accountKey.toString())
      .sort(),
    o = i
      .flatMap((d) => d.message.addressTableLookups)
      .map((d) => d.accountKey.toString())
      .sort();
  for (const [d, f] of s.entries()) {
    const h = o[d];
    su(f, h, Ma.ATL_MISMATCH);
  }
  const a = r.flatMap((d) => f3(d)).filter((d) => !h3(d)),
    c = i.flatMap((d) => f3(d)).filter((d) => !h3(d));
  for (const [d, f] of a.entries()) {
    const h = c[d];
    Yv(h, Ma.INSTRUCTION_MISMATCH), Dde(f, h, Ma.INSTRUCTION_MISMATCH);
  }
  const u = c.slice(a.length);
  Yv(u.length > 0, Ma.MISSING_LIGHTHOUSE_PROGRAM_CALL);
  const l = u.find((d) => !n.includes(d.programId));
  Ode(l, Ma.UNKNOWN_PROGRAM_INTERACTION.bind(void 0, l == null ? void 0 : l.programId));
}
function f3(e) {
  return e.message.compiledInstructions.map((t) => Lde(t, e));
}
function Lde(e, t) {
  const n = [
      ...t.message.staticAccountKeys.map((i) => i.toBase58()),
      ...t.message.addressTableLookups.flatMap((i) =>
        i.writableIndexes.map(() => 'ATL_WRITABLE_ACC')
      ),
      ...t.message.addressTableLookups.flatMap((i) =>
        i.readonlyIndexes.map(() => 'ATL_READONLY_ACC')
      ),
    ],
    r = (i) => {
      const s = n[i];
      if (!s) throw new Error(`Failed to get account at index ${i}`);
      return s;
    };
  return {
    programId: r(e.programIdIndex),
    data: he.from(e.data),
    keys: e.accountKeyIndexes
      .map((i) => [r(i), i])
      .map(([i, s]) => ({
        pubkey: i,
        isSigner: t.message.isAccountSigner(s),
        isWritable: t.message.isAccountWritable(s),
      })),
  };
}
function h3(e) {
  return e.programId === RL.programId.toString();
}
var Ys = ((e) => ((e.Plus = 'PLUS'), (e.Minus = 'MINUS'), (e.Equal = 'EQUAL'), e))(Ys || {}),
  U5 = ((e) => (
    (e.approval = 'approval'),
    (e.revokal = 'revokal'),
    (e.transfer = 'transfer'),
    (e.mint = 'mint'),
    (e.unknown = 'unknown'),
    e
  ))(U5 || {});
const gg = { GREEN: 'accentSuccess', RED: 'accentAlert', WHITE: 'textPrimary' };
function Ude(e) {
  switch (e) {
    case Ys.Plus:
      return gg.GREEN;
    case Ys.Minus:
      return gg.RED;
    case Ys.Equal:
      return gg.WHITE;
    default:
      return gg.WHITE;
  }
}
function $de(e, t) {
  var n;
  if (
    e.params &&
    'safeguard' in e.params &&
    e.params.safeguard &&
    t != null &&
    t.advancedDetails &&
    'safeguard' in t.advancedDetails &&
    (n = t.advancedDetails.safeguard) != null &&
    n.transactions
  ) {
    const r = t.advancedDetails.safeguard;
    if (r.error) return r.error;
    const i = e.params.transactions,
      s = r.transactions;
    if (s) {
      let o;
      try {
        jde(i, s);
      } catch (a) {
        a instanceof ls
          ? (o = a)
          : a instanceof Error
            ? (o = ls.createUnknownError(a.message))
            : (o = ls.createUnknownError('Non error type', a));
      }
      if (o) return (t.advancedDetails.safeguard.verifyError = o), o;
    }
  }
}
function Fde(e) {
  if (e.advancedDetails && 'requestId' in e.advancedDetails) return e.advancedDetails.requestId;
}
const zde = async (e, t, n) => {
    const r = `/simulation/v1?language=${e}`,
      i = await Ge.api().post(r, {
        ...n,
        chainId: n.networkID,
        appVersion: fd,
        platform: sA,
        deviceId: t,
      });
    if (!tr(i)) throw new Error('Failed to scan message');
    return i.data;
  },
  Kde = async (e, t, n) => {
    const r = `/simulation/v1?language=${e}`,
      i = {
        ...n.params,
        ...(n.params && 'safeguard' in n.params
          ? { safeguard: { ...n.params.safeguard, lighthouseProgramId: Rde } }
          : {}),
      },
      s = await Ge.api().post(r, {
        ...n,
        chainId: n.networkID,
        params: i,
        metadata: n.metadata,
        appVersion: fd,
        platform: sA,
        deviceId: t,
      });
    if (!tr(s)) throw new Error('Failed to scan transaction');
    const o = s.data,
      a = $de(n, o);
    if (a instanceof ls) {
      const c = Fde(o);
      re.captureMessage(`Verify error ${c ?? ''}: ${a.message}`, ce.Safeguard);
    }
    return o;
  };
function $5(e, t) {
  var p;
  const { data: n } = Xb(),
    { params: r, networkID: i } = e,
    [s, o] = W.useState(null),
    a = ['scan-message', { url: e.url, message: r.message }],
    c =
      (p = n == null ? void 0 : n.addresses.find((b) => b.networkID === i)) == null
        ? void 0
        : p.address,
    u = WO(qr.language) ?? 'en',
    l = Un(),
    d = new D4(l),
    f = F5(),
    h = Qt({
      queryKey: a,
      queryFn: async () => {
        try {
          const b = await zde(u, await l.getDeviceId(), { ...e, userAccount: c });
          return (
            o(null),
            d.onScannedMessageByUser({
              networkId: i,
              warnings: b.warnings.map((w) => w.severity),
              shouldBlock: !!b.block,
              errorCode: b.error ?? '',
            }),
            b
          );
        } catch (b) {
          o(b),
            d.onFailedScannedMessageByUser({ networkId: i, url: e.url }),
            re.addBreadcrumb(
              'simulation',
              `networkID: ${i}, url: ${e.url}, type: message`,
              Ie.Info
            ),
            re.captureError(h.error, ce.Simulation);
        }
      },
      enabled: !!c && !!e.url && !!r.message && !(t != null && t.disabled),
      refetchInterval: t != null && t.disableRefetch ? !1 : f,
      staleTime: 1e3 * 10,
      ...C4(),
    });
  return {
    isFetched: h.isFetched,
    isFetching: h.isFetching,
    data: h.data,
    isLoading: h.isPending && !(t != null && t.disabled),
    isError: h.isError || !!s,
    error: h.error || s,
  };
}
function KI(e, t) {
  const { params: n } = e,
    [r, i] = W.useState(null),
    s = Un(),
    o = ['scan-transaction', e.networkID, e.url, n ? (n.transactions ?? n.transaction) : ''],
    a = F5();
  let c = !1;
  de.isEVMNetworkID(e.networkID) || de.isSolanaNetworkID(e.networkID)
    ? (c = !!n && n.transactions.length > 0 && !!e.userAccount)
    : de.isBitcoinNetworkID(e.networkID)
      ? (c = !!n && !!n.transaction && !!n.userAddresses && n.userAddresses.length > 0)
      : de.isSuiNetworkID(e.networkID) && (c = !!n && !!e.userAccount);
  const u = WO(qr.language) ?? 'en',
    l = new D4(s),
    d = Qt({
      queryKey: o,
      queryFn: async () => {
        var f, h;
        try {
          const p = await Kde(u, await s.getDeviceId(), e);
          return (
            l.onScannedTransactionByUser({
              networkId: e.networkID,
              warnings: p.warnings.map((b) => b.severity),
              shouldBlock: !!p.block,
              errorCode: p.error ?? '',
            }),
            i(null),
            (f = t == null ? void 0 : t.onSettled) == null || f.call(t, p, void 0),
            p
          );
        } catch (p) {
          l.onFailedScannedTransactionByUser({ networkId: e.networkID, url: e.url }),
            re.addBreadcrumb(
              'simulation',
              `networkID: ${e.networkID}, url: ${e.url}, type: transaction`,
              Ie.Info
            ),
            i(p),
            (h = t == null ? void 0 : t.onSettled) == null || h.call(t, void 0, p),
            re.captureError(p, ce.Simulation);
        }
      },
      enabled: c && !(t != null && t.disabled),
      refetchInterval: t != null && t.disableRefetch ? !1 : a,
      staleTime: 1e3 * 10,
      ...C4(),
    });
  return {
    isFetched: d.isFetched,
    isFetching: d.isFetching,
    data: d.data,
    isLoading: d.isPending && !(t != null && t.disabled),
    isError: d.isError || !!r,
    error: d.error || r,
  };
}
const p3 = 5e3;
function F5() {
  const e = ms.getMultivariateAssignment('transactions-simulation-interval-ms');
  if (!e) return p3;
  const t = parseInt(e, 10);
  return Number.isNaN(t) ? p3 : t;
}
const g3 = (e) => e / 1e8;
g.union([
  g.literal('signTransaction'),
  g.literal('signAllTransactions'),
  g.literal('signAndSendTransaction'),
  g.literal('signAndSendAllTransactions'),
]);
we({ seconds: 10 });
var z5 = ((e) => (
  (e.hiddenMints = 'hiddenMints'),
  (e.splTokenMap = 'splTokenMap'),
  (e.tokenPrices = 'tokenPrices'),
  (e.tokens = 'tokens'),
  (e.transferFungibleLoggingContext = 'transferFungibleLoggingContext'),
  (e.transferTransaction = 'transferTransaction'),
  (e.unwrapTransaction = 'unwrapTransaction'),
  (e.minimumRequiredBalance = 'minimumRequiredBalance'),
  (e.solanaBalance = 'solanaBalance'),
  (e.fungibleDetail = 'fungibleDetail'),
  (e.fungibleHoldings = 'fungibleHoldings'),
  (e.swapperDiscovery = 'swapperDiscovery'),
  e
))(z5 || {});
function Vde(e) {
  return e.map((t) => `${t.networkID}/${t.address}`).sort();
}
function y3(e) {
  return ['tokens', Vde(e)];
}
const qy = {
    swapperDiscovery(e) {
      return ['swapperDiscovery', e];
    },
    hiddenMints(e) {
      return ['hiddenMints', { accountId: e }];
    },
    splTokenMap: ['splTokenMap'],
    tokenPrices(e) {
      return ['tokenPrices', { tokenIds: e }];
    },
    tokens(e) {
      return y3(e);
    },
    tokensErrorCount(e) {
      return [...y3(e), 'tokensError'];
    },
    minimumRequiredBalance(e) {
      return ['minimumRequiredBalance', { chainAddress: e }];
    },
    solanaBalance(e) {
      return ['solanaBalance', { chainAddress: e }];
    },
    transferFungibleLoggingContext(e) {
      return ['transferFungibleLoggingContext', { fungibleKey: e }];
    },
    transferTransaction(e) {
      return ['transferTransaction', e];
    },
    unwrapTransaction({ caip19: e, amount: t, owner: n }) {
      return ['unwrapTransaction', { caip19: e, amount: t, owner: n }];
    },
    fungibleDetail({ caip19: e }) {
      return ['fungibleDetail', { caip19: e }];
    },
    fungibleHoldings({ caip19: e, walletAddress: t }) {
      return ['fungibleHoldings', { caip19: e, walletAddress: t }];
    },
  },
  Wde = ['asc', 'desc'],
  Hde = g.enum(Wde),
  Gde = ['rank', 'volume', 'price', 'price-change', 'market-cap'],
  qde = g.enum(Gde),
  Yde = ['1h', '24h', '7d', '30d'];
g.enum(Yde);
const Zde = g
  .object({
    chainId: $u,
    address: g.string(),
    name: g.string(),
    symbol: g.string().default(''),
    logoUrl: g.string().optional(),
    marketCap: g.number().optional(),
    volume: g.number().optional(),
    price: g.number().optional(),
    priceChange: g.number().optional(),
    volumeChange: g.number().optional(),
  })
  .transform((e) => ({ ...e, symbol: e.symbol || e.name }));
g.object({ items: dA(Zde), sortBy: qde, sortDirection: Hde });
var a1 = ((e) => (
  (e.Verified = 'VERIFIED'),
  (e.NotVerified = 'NOT_VERIFIED'),
  (e.PossibleSpam = 'POSSIBLE_SPAM'),
  (e.Spam = 'SPAM'),
  e
))(a1 || {});
const K5 = g.nativeEnum(a1),
  St = g.object({
    chain: $9,
    decimals: g.number(),
    logoUri: g.string().nullish().default(null),
    name: g.string().nullish().default(null),
    symbol: g.string().nullish().default(null),
    spamStatus: K5.optional().default(a1.NotVerified),
    marketCap: g.number().optional(),
    volume24hUsd: g.number().optional(),
  });
var V5 = ((e) => (
  (e.Website = 'website'), (e.Telegram = 'telegram'), (e.X = 'x'), (e.Discrod = 'discord'), e
))(V5 || {});
const Jde = g.object({ type: g.nativeEnum(V5), url: g.string() });
var VI = ((e) => (
  (e.transferFeeConfig = 'transferFeeConfig'),
  (e.interestBearingConfig = 'interestBearingConfig'),
  (e.permanentDelegate = 'permanentDelegate'),
  (e.transferHook = 'transferHook'),
  (e.tokenMetadata = 'tokenMetadata'),
  (e.mintCloseAuthority = 'mintCloseAuthority'),
  (e.metadataPointer = 'metadataPointer'),
  (e.groupMemberPointer = 'groupMemberPointer'),
  (e.nonTransferable = 'nonTransferable'),
  e
))(VI || {});
const Xde = g.object({
    extension: g.literal('interestBearingConfig'),
    state: g.object({
      currentRate: g.number(),
      initializationTimestamp: g.number(),
      lastUpdateTimestamp: g.number(),
      preUpdateAverageRate: g.number(),
      rateAuthority: g.string(),
    }),
    meta: g.object({ amountPrincipal: g.string() }).optional(),
  }),
  Qde = g.object({
    extension: g.literal('transferFeeConfig'),
    state: g.object({ newerTransferFee: g.object({ transferFeeBasisPoints: g.number() }) }),
  }),
  efe = g.object({
    extension: g.literal('permanentDelegate'),
    state: g.object({ delegate: g.string() }),
  }),
  tfe = g.object({
    extension: g.literal('transferHook'),
    state: g.object({ authority: g.string(), programId: g.string() }),
  }),
  nfe = g.object({
    extension: g.literal('tokenMetadata'),
    state: g.object({
      additionalMetadata: g.array(g.array(g.string())),
      mint: g.string(),
      name: g.string(),
      symbol: g.string(),
      updateAuthority: g.string(),
      uri: g.string(),
    }),
  }),
  rfe = g.object({
    extension: g.literal('mintCloseAuthority'),
    state: g.object({ closeAuthority: g.string() }),
  }),
  ife = g.object({
    extension: g.literal('groupMemberPointer'),
    state: g.object({ authority: g.string(), memberAddress: g.string() }),
  }),
  sfe = g.object({
    extension: g.literal('metadataPointer'),
    state: g.object({ authority: g.string(), metadataAddress: g.string() }),
  }),
  ofe = g.object({ extension: g.literal('nonTransferable') }),
  W5 = g.union([Xde, Qde, efe, tfe, nfe, rfe, sfe, ife, ofe]);
St.merge(
  g.object({
    address: g.string().nullish(),
    description: g.string().nullish(),
    logoURI: g.string().nullish(),
    links: g.array(Jde).nullish(),
    marketCap: g.number({ coerce: !0 }).nullish(),
    totalSupply: g.number({ coerce: !0 }).nullish(),
    circulatingSupply: g.number({ coerce: !0 }).nullish(),
    maxSupply: g.number({ coerce: !0 }).nullish(),
    holders: g.number().nullish(),
    volume24hUSD: g.number({ coerce: !0 }).nullish(),
    volume24hUSDChangePercentage: g.number().nullish(),
    trades24h: g.number().nullish(),
    trades24hChangePercentage: g.number().nullish(),
    uniqueWallets24h: g.number().nullish(),
    uniqueWallets24hChangePercentage: g.number().nullish(),
    top10HoldersPercent: g.number().nullish(),
    mintable: g.boolean().nullish(),
    freezable: g.boolean().nullish(),
    mutableMetadata: g.boolean().nullish(),
    ownershipRenounced: g.boolean().nullish(),
    updateAuthority: g.string().nullish(),
    freezeAuthority: g.string().nullish(),
    spamStatus: K5.optional().default(a1.NotVerified),
    mintExtensions: dA(W5).nullish(),
    createdDate: g.string().datetime().nullish().default(null),
    categories: g
      .object({ id: g.string(), name: g.string(), imageUri: g.string(), numTokens: g.number() })
      .array()
      .optional(),
  })
);
g.object({ code: g.string(), message: g.string() });
const afe = g.object({
    usd: g.number().optional(),
    usd_24h_change: g.number().optional(),
    price: g.number().optional(),
    priceChange24h: g.number().optional(),
    currencyValue: g.number().optional(),
    currencyChange: g.number().optional(),
    lastUpdatedAt: g.string().datetime().optional(),
  }),
  cfe = [
    g.literal('1H'),
    g.literal('1D'),
    g.literal('1W'),
    g.literal('1M'),
    g.literal('YTD'),
    g.literal('ALL'),
  ];
g.union(cfe)
  .nullish()
  .transform((e) => e ?? '1D');
const ufe = [
  g.literal('1m'),
  g.literal('5m'),
  g.literal('1h'),
  g.literal('4h'),
  g.literal('1d'),
  g.literal('1w'),
  g.literal('4w'),
  g.literal('1mo'),
];
g.union(ufe)
  .nullish()
  .transform((e) => e ?? '1d');
const lfe = g.object({ unixTime: g.number(), value: g.string() });
g.object({ history: g.array(lfe) });
function dfe({ balance: e, priceId: t, priceMap: n }) {
  var a, c;
  const r = t ? ((a = n[t]) == null ? void 0 : a.usd) : void 0,
    i = t ? ((c = n[t]) == null ? void 0 : c.usd_24h_change) : void 0;
  if (r === void 0) return { usd: void 0, usd_24h_change: void 0, price: r };
  const s = e.multipliedBy(r);
  let o;
  return (
    i !== void 0 && (o = s.minus(s.dividedBy(1 + i / 100))),
    {
      usd: s.toNumber(),
      usd_24h_change: o == null ? void 0 : o.toNumber(),
      price: r,
      priceChange24h: i,
      currencyValue: s.toNumber(),
      currencyChange: o == null ? void 0 : o.toNumber(),
    }
  );
}
const ffe = new Lu({
    [ze.Solana]: {},
    [ze.Ethereum]: {},
    [ze.Polygon]: {},
    [ze.Base]: {},
    [ze.Arbitrum]: {},
    [ze.Monad]: { pricesDisabled: !0 },
    [ze.Bitcoin]: {},
    [ze.Sui]: {},
    [ze.Hypercore]: {},
  }),
  H5 = Uu(ffe);
var WI = ((e) => (
    (e[(e.Always = 1 / 0)] = 'Always'),
    (e[(e.Short = we({ days: 1 }))] = 'Short'),
    (e[(e.Medium = we({ days: 3 }))] = 'Medium'),
    (e[(e.Long = we({ days: 7 }))] = 'Long'),
    (e[(e.VeryLong = we({ days: 30 }))] = 'VeryLong'),
    (e[(e.Never = 0)] = 'Never'),
    e
  ))(WI || {}),
  pc = ((e) => (
    (e[(e.Immediate = 0)] = 'Immediate'),
    (e[(e.VeryShort = we({ seconds: 1 }))] = 'VeryShort'),
    (e[(e.Short = we({ seconds: 15 }))] = 'Short'),
    (e[(e.Medium = we({ minutes: 3 }))] = 'Medium'),
    (e[(e.Long = we({ minutes: 5 }))] = 'Long'),
    (e[(e.VeryLong = we({ minutes: 10 }))] = 'VeryLong'),
    (e[(e.Never = 1 / 0)] = 'Never'),
    e
  ))(pc || {}),
  Ap = ((e) => (
    (e[(e.VeryShort = we({ seconds: 2 }))] = 'VeryShort'),
    (e[(e.Short = we({ seconds: 15 }))] = 'Short'),
    (e[(e.Medium = we({ minutes: 3 }))] = 'Medium'),
    (e[(e.Long = we({ minutes: 5 }))] = 'Long'),
    e
  ))(Ap || {});
const hfe = we({ seconds: 10 }),
  pfe = { gcTime: WI.Short, staleTime: pc.Short },
  gfe = 'prices',
  G5 = (e, t) => {
    var i;
    if (!nM(e)) return;
    const r = (i = e.response) == null ? void 0 : i.status;
    (!r || (r >= 400 && r < 500 && r !== 404)) &&
      (re.addBreadcrumb(gfe, e.message, Ie.Info, t), re.captureError(e, ce.Prices));
  },
  yfe = g.object({
    price: g.number(),
    priceChange24h: g.number(),
    lastUpdatedAt: g.string().datetime().optional(),
  }),
  b3 = g.object({ prices: g.record(F9, yfe) });
async function q5({ tokens: e }) {
  try {
    const t = e.filter((o) => {
        var a;
        return !((a = H5.get(o.chainId)) != null && a.pricesDisabled);
      }),
      n = { tokens: t.map((o) => ({ token: o })) };
    let r = '/price/v1',
      i;
    const s = Ge.timeout(hfe).retry(1, 200).validateStatus(!0).api();
    if (t.length === 0) return {};
    if (t.length === 1) {
      const o = t[0];
      (r += `/${o.chainId}`),
        o.resourceType === Pr.nativeToken
          ? (r += `/nativeToken/${o.slip44}`)
          : (r += `/address/${o.address}`);
      const a = await s.get(r);
      i = b3.parse({ prices: { [ha(o)]: a.data } });
    } else {
      const o = await s.post(r, n);
      i = b3.parse(o.data);
    }
    return bfe(i.prices);
  } catch (t) {
    throw (G5(t), t);
  }
}
function bfe(e) {
  const t = {};
  for (const n of Object.keys(e)) {
    const { price: r, priceChange24h: i, lastUpdatedAt: s } = e[n],
      o = { price: r, usd: r, usd_24h_change: i, lastUpdatedAt: s };
    t[n] = o;
  }
  return t;
}
const yg = 'prices',
  ja = {
    price: (e) => [yg, { id: e }],
    priceError: () => [yg, 'error'],
    priceHistory: (e, t) => [yg, e, t],
    priceHistoryInterval: (e, t, n, r) => [yg, e, t, n, ...(r ? [r] : [])],
    tempPrices: (e) => ['tempPrices', e],
  };
we({ minutes: 1 }),
  we({ minutes: 5 }),
  we({ hours: 1 }),
  we({ hours: 4 }),
  we({ days: 1 }),
  we({ days: 7 }),
  we({ days: 28 }),
  we({ days: 30 });
var lt = ((e) => (
  (e.BRC20 = 'BRC20'),
  (e.ERC20 = 'ERC20'),
  (e.SPL = 'SPL'),
  (e.CompressedSPL = 'CompressedSPL'),
  (e.SuiCoin = 'SuiCoin'),
  (e.SolanaNative = 'SolanaNative'),
  (e.EthereumNative = 'EthereumNative'),
  (e.PolygonNative = 'PolygonNative'),
  (e.MonadNative = 'MonadNative'),
  (e.BaseNative = 'BaseNative'),
  (e.ArbitrumNative = 'ArbitrumNative'),
  (e.BitcoinNative = 'BitcoinNative'),
  (e.SuiNative = 'SuiNative'),
  (e.HypercoreNative = 'HypercoreNative'),
  e
))(lt || {});
const mfe = [
    'BitcoinNative',
    'EthereumNative',
    'PolygonNative',
    'MonadNative',
    'SolanaNative',
    'BaseNative',
    'ArbitrumNative',
    'SuiNative',
    'HypercoreNative',
  ],
  Dt = g.object({ walletAddress: g.string(), amount: g.string() }),
  wfe = g.object({ type: g.literal('SolanaNative'), data: St }),
  vfe = g.object({ type: g.literal('SolanaNative'), data: St.merge(Dt) }),
  _fe = g.object({ type: g.literal('EthereumNative'), data: St }),
  Sfe = g.object({ type: g.literal('EthereumNative'), data: St.merge(Dt) }),
  Efe = g.object({ type: g.literal('PolygonNative'), data: St }),
  Afe = g.object({ type: g.literal('PolygonNative'), data: St.merge(Dt) }),
  Ife = g.object({ type: g.literal('BaseNative'), data: St }),
  Tfe = g.object({ type: g.literal('BaseNative'), data: St.merge(Dt) }),
  xfe = g.object({ type: g.literal('ArbitrumNative'), data: St }),
  kfe = g.object({ type: g.literal('ArbitrumNative'), data: St.merge(Dt) }),
  Cfe = g.object({ type: g.literal('MonadNative'), data: St }),
  Pfe = g.object({ type: g.literal('MonadNative'), data: St.merge(Dt) }),
  Mfe = g.object({ type: g.literal('SuiNative'), data: St }),
  Ofe = g.object({ type: g.literal('SuiNative'), data: St.merge(Dt) }),
  Bfe = g.object({ type: g.literal('HypercoreNative'), data: St }),
  Dfe = g.object({ type: g.literal('HypercoreNative'), data: St.merge(Dt) }),
  Rfe = g.object({ type: g.literal('BitcoinNative'), data: St }),
  Nfe = g.object({ type: g.literal('BitcoinNative'), data: St.merge(Dt) });
var Y5 = ((e) => ((e.PreDeploy = 'preDeploy'), (e.Graduated = 'graduated'), e))(Y5 || {});
const jfe = g.object({ programId: g.string(), status: g.nativeEnum(Y5) }),
  Ou = St.extend({
    mintAddress: g.string(),
    splTokenAccountPubkey: g.string(),
    programId: g.string(),
    mintExtensions: dA(W5).optional(),
    ugcTokenMeta: jfe.optional(),
  });
g.object({ type: g.literal('SPL'), data: Ou });
const Lfe = g.object({ type: g.literal('SPL'), data: Ou.merge(Dt) }),
  Ufe = g.object({
    type: g.literal('CompressedSPL'),
    data: Ou.merge(Dt).omit({ splTokenAccountPubkey: !0 }),
  }),
  $fe = g.object({
    type: g.literal('SPL'),
    data: Ou.omit({ splTokenAccountPubkey: !0, programId: !0 }),
  }),
  HI = St.extend({ contractAddress: g.string() }),
  Ffe = g.object({ type: g.literal('ERC20'), data: HI }),
  zfe = g.object({ type: g.literal('ERC20'), data: HI.merge(Dt) }),
  GI = St.extend({
    firstCreatedTransactionHash: g.string().optional(),
    firstCreatedInscriptionId: g.string(),
  }),
  Kfe = g.object({ type: g.literal('BRC20'), data: GI }),
  Vfe = g.object({ type: g.literal('BRC20'), data: GI.merge(Dt) }),
  Z5 = St.extend({ contractAddress: g.string() }),
  Wfe = g.object({ type: g.literal('SuiCoin'), data: Z5 }),
  J5 = St.extend({ contractAddress: g.string() });
g.object({ type: g.literal('SuiCoin'), data: J5 });
const Hfe = g.object({ type: g.literal('SuiCoin'), data: J5.merge(Dt) }),
  Gfe = g.discriminatedUnion('type', [
    Vfe,
    zfe,
    Lfe,
    Ufe,
    Hfe,
    vfe,
    Sfe,
    Afe,
    Tfe,
    kfe,
    Pfe,
    Nfe,
    Ofe,
    Dfe,
  ]);
g.union([Kfe, Ffe, $fe, wfe, _fe, Efe, Ife, xfe, Cfe, Rfe, Mfe, Wfe, Bfe]);
const qfe = g.object({
    code: g.string(),
    message: g.string(),
    details: g.object({ chainId: $u, address: g.string() }),
  }),
  xr = afe.extend({
    balance: g.instanceof(fe),
    key: g.string(),
    tokenAddress: g.string().optional(),
    externalUrl: g.string().optional(),
  }),
  Yfe = g.union([
    g.object({ type: g.literal('SolanaNative'), data: g.intersection(St.merge(Dt), xr) }),
    g.object({ type: g.literal('SPL'), data: g.intersection(Ou.merge(Dt), xr) }),
    g.object({
      type: g.literal('CompressedSPL'),
      data: g.intersection(Ou.merge(Dt).omit({ splTokenAccountPubkey: !0 }), xr),
    }),
  ]),
  Zfe = g.union([
    g.object({ type: g.literal('EthereumNative'), data: g.intersection(St.merge(Dt), xr) }),
    g.object({ type: g.literal('ERC20'), data: g.intersection(HI.merge(Dt), xr) }),
    g.object({ type: g.literal('PolygonNative'), data: g.intersection(St.merge(Dt), xr) }),
    g.object({ type: g.literal('BaseNative'), data: g.intersection(St.merge(Dt), xr) }),
    g.object({ type: g.literal('ArbitrumNative'), data: g.intersection(St.merge(Dt), xr) }),
    g.object({ type: g.literal('MonadNative'), data: g.intersection(St.merge(Dt), xr) }),
    g.object({ type: g.literal('HypercoreNative'), data: g.intersection(St.merge(Dt), xr) }),
  ]),
  Jfe = g.union([
    g.object({ type: g.literal('BitcoinNative'), data: g.intersection(St.merge(Dt), xr) }),
    g.object({ type: g.literal('BRC20'), data: g.intersection(GI.merge(Dt), xr) }),
  ]),
  Xfe = g.union([
    g.object({ type: g.literal('SuiNative'), data: g.intersection(St.merge(Dt), xr) }),
    g.object({ type: g.literal('SuiCoin'), data: g.intersection(Z5.merge(Dt), xr) }),
  ]);
g.union([Yfe, Zfe, Jfe, Xfe]);
var X5 = ((e) => (
  (e.NOT_ONBOARDED = 'not_onboarded'),
  (e.ONBOARDING = 'onboarding'),
  (e.ONBOARDED = 'onboarded'),
  (e.ONBOARDING_FAILED = 'onboarding_failed'),
  e
))(X5 || {});
g.object({ status: g.nativeEnum(X5), averageCost: g.string({ coerce: !0 }).optional() });
let Q5 = class eR extends Error {
  constructor(n) {
    super(n);
    ae(this, 'statusCode', 400);
    Object.setPrototypeOf(this, eR.prototype), (this.name = 'FungibleError');
  }
  getMessage() {
    return `Something went wrong: ${this.message}`;
  }
};
var Ip = ((e) => ((e.CONFIRMATION = 'CONFIRMATION'), (e.SUBMISSION = 'SUBMISSION'), e))(Ip || {});
const rl = {
    sendSuccessCondition: Ip.CONFIRMATION,
    formDisplayPrecision: 4,
    minimumSendableCurrencyAmount: 0.01,
    nonNativeFungibleTokenType: lt.ERC20,
  },
  Qfe = {
    ...rl,
    nativeFungibleTokenType: lt.ArbitrumNative,
    nativeTokenFungibleBalanceKey: function (e) {
      return this.nativeFungibleTokenType;
    },
    alwaysShowNetworkBadge: !0,
  },
  ehe = {
    ...rl,
    nativeFungibleTokenType: lt.BaseNative,
    nativeTokenFungibleBalanceKey: function (e) {
      return this.nativeFungibleTokenType;
    },
    alwaysShowNetworkBadge: !0,
  },
  the = {
    sendSuccessCondition: Ip.SUBMISSION,
    formDisplayPrecision: 6,
    minimumSendableCurrencyAmount: 0.5,
    nativeFungibleTokenType: lt.BitcoinNative,
    nonNativeFungibleTokenType: lt.BRC20,
    nativeTokenFungibleBalanceKey: function (e, t) {
      if (t !== void 0) return `${lt.BitcoinNative}-${t}`;
    },
    alwaysShowNetworkBadge: !1,
  },
  nhe = {
    ...rl,
    nativeFungibleTokenType: lt.EthereumNative,
    nativeTokenFungibleBalanceKey(e) {
      return this.nativeFungibleTokenType;
    },
    alwaysShowNetworkBadge: !1,
  },
  rhe = {
    ...rl,
    nativeFungibleTokenType: lt.HypercoreNative,
    nativeTokenFungibleBalanceKey: function (e) {
      return this.nativeFungibleTokenType;
    },
    alwaysShowNetworkBadge: !1,
  },
  ihe = {
    ...rl,
    nativeFungibleTokenType: lt.MonadNative,
    nativeTokenFungibleBalanceKey: function (e) {
      return this.nativeFungibleTokenType;
    },
    alwaysShowNetworkBadge: !1,
    isPriceDetailSupported: !1,
  },
  she = {
    ...rl,
    nativeFungibleTokenType: lt.PolygonNative,
    nativeTokenFungibleBalanceKey: function (e) {
      return this.nativeFungibleTokenType;
    },
    alwaysShowNetworkBadge: !1,
  },
  ohe = {
    sendSuccessCondition: Ip.CONFIRMATION,
    formDisplayPrecision: 4,
    minimumSendableCurrencyAmount: 0.01,
    nativeFungibleTokenType: lt.SolanaNative,
    nonNativeFungibleTokenType: lt.SPL,
    nativeTokenFungibleBalanceKey: function (e) {
      return this.nativeFungibleTokenType;
    },
    alwaysShowNetworkBadge: !1,
  },
  ahe = {
    nativeFungibleTokenType: lt.SuiNative,
    nativeTokenFungibleBalanceKey: function (e) {
      return this.nativeFungibleTokenType;
    },
    alwaysShowNetworkBadge: !1,
    isPriceDetailSupported: !0,
    sendSuccessCondition: Ip.CONFIRMATION,
    formDisplayPrecision: 9,
    minimumSendableCurrencyAmount: 0,
    nonNativeFungibleTokenType: lt.SuiCoin,
  },
  che = new Lu({
    [ze.Solana]: ohe,
    [ze.Ethereum]: nhe,
    [ze.Polygon]: she,
    [ze.Base]: ehe,
    [ze.Arbitrum]: Qfe,
    [ze.Bitcoin]: the,
    [ze.Monad]: ihe,
    [ze.Sui]: ahe,
    [ze.Hypercore]: rhe,
  }),
  gc = Uu(che);
function uhe(e) {
  return e.resourceType === Pr.nativeToken
    ? gc.get(e.chainId).nativeFungibleTokenType
    : gc.get(e.chainId).nonNativeFungibleTokenType;
}
function yc(e) {
  return !!e && mfe.includes(e);
}
function qI(e) {
  if (yc(e.type))
    return e.type === lt.BitcoinNative
      ? `${e.type}-${bs(e.data.chain.id, e.data.walletAddress)}`
      : e.type;
  switch (e.type) {
    case lt.SPL:
    case lt.CompressedSPL:
      return e.data.mintAddress ?? '';
    case lt.ERC20:
    case lt.SuiCoin:
      return e.data.contractAddress;
    case lt.BRC20: {
      const t = bs(e.data.chain.id, e.data.walletAddress);
      return `${e.data.firstCreatedInscriptionId}-${t}`;
    }
  }
}
function lhe(e, t) {
  const n = uhe(e);
  if (yc(n)) return n === lt.BitcoinNative && t !== void 0 ? [`${n}-${bs(e.chainId, t)}`] : [n];
  if (n === lt.SPL && e.resourceType === Pr.address) return [e.address];
  if (n === lt.ERC20 && e.resourceType === Pr.address) return [e.address];
  if (n === lt.BRC20 && e.resourceType === Pr.address) return z9.map((r) => `${e.address}-${r}`);
  if (n === lt.SuiCoin && e.resourceType === Pr.address) return [e.address];
}
var c1 = ((e) => (
    (e[(e.Always = 1 / 0)] = 'Always'),
    (e[(e.Short = we({ days: 1 }))] = 'Short'),
    (e[(e.Medium = we({ days: 3 }))] = 'Medium'),
    (e[(e.Long = we({ days: 7 }))] = 'Long'),
    e
  ))(c1 || {}),
  u1 = ((e) => (
    (e[(e.Immediate = 0)] = 'Immediate'),
    (e[(e.Short = we({ minutes: 1 }))] = 'Short'),
    (e[(e.Medium = we({ minutes: 2.5 }))] = 'Medium'),
    (e[(e.Long = we({ minutes: 5 }))] = 'Long'),
    (e[(e.Never = 1 / 0)] = 'Never'),
    e
  ))(u1 || {}),
  tR = ((e) => (
    (e[(e.Short = we({ minutes: 1 }))] = 'Short'),
    (e[(e.Medium = we({ minutes: 2.5 }))] = 'Medium'),
    (e[(e.Long = we({ minutes: 5 }))] = 'Long'),
    e
  ))(tR || {});
const dhe = (e) => e.extension === VI.interestBearingConfig,
  fhe = (e) =>
    'data' in e && e.data && 'mintExtensions' in e.data
      ? e.data.mintExtensions || []
      : 'chainData' in e && e.chainData && 'mintExtensions' in e.chainData
        ? e.chainData.mintExtensions || []
        : [];
function hhe(e) {
  if (!e) return;
  const t = fhe(e);
  return t == null ? void 0 : t.find(dhe);
}
const m3 = new fe('31556736'),
  w3 = new fe('10000'),
  phe = 17,
  v3 = (e) => new fe(Math.exp(e.toNumber()));
class ghe {
  constructor(t) {
    ae(this, 'initializationTimestamp');
    ae(this, 'preUpdateAverageRate');
    ae(this, 'lastUpdateTimestamp');
    ae(this, 'currentRate');
    (this.initializationTimestamp = new fe(t.initializationTimestamp)),
      (this.preUpdateAverageRate = new fe(t.preUpdateAverageRate)),
      (this.lastUpdateTimestamp = new fe(t.lastUpdateTimestamp)),
      (this.currentRate = new fe(t.currentRate));
  }
  preUpdateTimespan() {
    return this.lastUpdateTimestamp.minus(this.initializationTimestamp);
  }
  preUpdateExp() {
    const n = new fe(this.preUpdateAverageRate).times(this.preUpdateTimespan()).div(m3).div(w3);
    return v3(n);
  }
  postUpdateTimespan(t) {
    return t.minus(this.lastUpdateTimestamp);
  }
  postUpdateExp(t) {
    const r = new fe(this.currentRate).times(this.postUpdateTimespan(t)).div(m3).div(w3);
    return v3(r);
  }
  totalScale(t, n) {
    var r;
    return (r = this.preUpdateExp()) == null ? void 0 : r.times(this.postUpdateExp(n)).div(fa(t));
  }
  amountToUiAmount(t, n, r) {
    return new fe(t)
      .times(this.totalScale(n, new fe(r)))
      .precision(phe)
      .decimalPlaces(n)
      .toString();
  }
}
const yhe = (e) => {
  var c;
  if (e.type !== lt.SPL) return e;
  const t = (c = hhe(e)) == null ? void 0 : c.state;
  if (!t) return e;
  const { amount: n, mintExtensions: r } = e.data,
    i = new ghe(t),
    s = Date.now() / 1e3,
    o = i.amountToUiAmount(n, 0, s),
    a = r
      ? r == null
        ? void 0
        : r.map((u) =>
            u.extension === VI.interestBearingConfig ? { ...u, meta: { amountPrincipal: n } } : u
          )
      : void 0;
  return { ...e, data: { ...e.data, amount: o, mintExtensions: a } };
};
new Q5('Failed to get fungible tokens for addresses');
async function bhe(e) {
  const { addresses: t, analytics: n, enableSolCompressedTokens: r = !1 } = e;
  try {
    const i = await Ge.api()
      .headers({ 'Content-Type': 'application/json' })
      .timeout(we({ seconds: 20 }))
      .post(
        '/tokens/v1',
        { addresses: t },
        { params: r ? { isSolCompressedTokensEnabled: 'true' } : void 0 }
      );
    if (i.status !== 200) throw new cx({ key: 'TokensNotLoading' });
    const s = await i.data,
      o = [],
      a = [];
    let c = !1;
    for (const u of s.tokens) {
      const l = Gfe.safeParse(u);
      if (l.success) {
        const d = yhe(l.data);
        o.push(d);
      } else c = !0;
    }
    return (
      s.errors.forEach((u) => {
        const l = qfe.safeParse(u);
        l.success && a.push(l.data);
      }),
      a.length === 0 &&
        s.isTrimmed &&
        a.push({
          code: 'TokensTrimmed',
          message: '',
          details: { chainId: Js.Mainnet, address: 'unknown' },
        }),
      a.length &&
        n.capture('getBalanceRequestError', { data: { chains: a.map((u) => u.details.chainId) } }),
      c && re.captureError(new Error('fungibles failed to parse some items'), ce.Fungibles),
      { tokens: o, errors: a, isTrimmed: s.isTrimmed }
    );
  } catch {
    throw new cx({ key: 'TokensNotLoading' });
  }
}
function mhe({
  select: e,
  chainAddresses: t = [],
  queryOptions: n = { staleTime: u1.Short, refetchInterval: tR.Long },
}) {
  const r = qy.tokens(t),
    i = qy.tokensErrorCount(t),
    s = Un(),
    o = lo(),
    {
      data: [a],
    } = _P(['enable-sol-compressed-tokens']);
  return Qt({
    queryKey: r,
    enabled: t.length > 0 && t.every((c) => !de.isLocalNetworkID(c.networkID)),
    gcTime: c1.Medium,
    staleTime: n.staleTime,
    refetchInterval: n.refetchInterval,
    refetchOnReconnect: !0,
    networkMode: 'always',
    retry: !1,
    select: e,
    async queryFn({ queryKey: c }) {
      try {
        const u = t.map($le),
          l = await bhe({ addresses: u, analytics: s, enableSolCompressedTokens: Wj() ? !1 : a });
        if (l.errors.length > 0 && !l.isTrimmed) {
          const d = o.getQueryData(c);
          if (d)
            for (const f of l.errors) {
              const h = d.tokens.filter((p) => p.data.chain.id === f.details.chainId);
              l.tokens.push(...h);
            }
        }
        return o.removeQueries({ queryKey: i }), l;
      } catch (u) {
        const l = o.getQueryData(i) ?? 0;
        throw (o.setQueryData(i, l + 1), u);
      }
    },
  });
}
function whe({ chainAddresses: e, keys: t, queryOptions: n }) {
  const r = W.useCallback(
    ({ tokens: i }) => (!t || !t.length ? i : i.filter((s) => t.includes(qI(s)))),
    [t]
  );
  return mhe({ select: r, chainAddresses: e, queryOptions: n });
}
we({ days: 30 });
L5([qv(32, 'mint'), qv(32, 'owner'), kde('amount'), qv(93)]);
const Zv = g.object({ feerate: g.string() }),
  _3 = g.object({ conservative: Zv, economical: Zv, unset: Zv }),
  vhe = g.object({
    recommended: g.object({ priceEstimates: _3 }),
    bitcoin_rpc: g.object({ priceEstimates: _3 }),
  }),
  _he = g.object({ gasPriceSources: vhe }),
  She = new fe('1.25'),
  Ehe = new fe('1.5'),
  Ahe = async (e, t = !0) => {
    let n, r, i;
    try {
      const { priceEstimates: s } = (await Ihe(e)).gasPriceSources.recommended,
        { conservative: o, economical: a, unset: c } = s;
      (n = new fe(o.feerate)), (r = new fe(a.feerate)), (i = new fe(c.feerate));
    } catch (s) {
      if (!t) throw s;
      const o = await Ble(e).estimateSmartFee(2, 'ECONOMICAL');
      (i = new fe(o.feerate)), (r = i.times(She)), (n = i.times(Ehe));
    }
    return {
      [er.fast]: { btcPerKilobyte: n.multipliedBy(1) },
      [er.standard]: { btcPerKilobyte: r.multipliedBy(1) },
      [er.slow]: { btcPerKilobyte: i.multipliedBy(1) },
    };
  };
async function Ihe(e) {
  const t = `https://gas-price-oracle.phantom.app/?chainId=${e}`,
    n = await Ge.headers({ 'Content-Type': 'application/json' }).get(t);
  return _he.parse(n.data);
}
const YI = 'gas-estimation',
  The = 3,
  xhe = 600,
  khe = we({ seconds: 30 }),
  ZI = ({
    networkID: e,
    enableFallback: t = !1,
    retry: n = The,
    retryDelay: r = xhe,
    enabled: i = !0,
  }) =>
    Qt({
      queryFn: async () => {
        try {
          if (!e) throw new Error('Missing networkID');
          if (de.isBitcoinNetworkID(e)) return await Ahe(e, t);
          if (de.isEVMNetworkID(e)) return await IX(e, t);
          if (de.isSolanaNetworkID(e))
            throw new Error('Transaction speeds is not supported for Solana.');
          if (de.isSuiNetworkID(e)) throw new wy('transaction speeds to unit cost');
          return qt(e);
        } catch (s) {
          throw (
            (s instanceof j4 ||
              (re.addBreadcrumb(YI, `enableFallback: ${t}, networkID: ${e}`, Ie.Info),
              re.captureError(s, ce.Transaction)),
            s)
          );
        }
      },
      queryKey: fo.transactionSpeedsToUnitCost(e),
      refetchOnMount: 'always',
      retry: n,
      retryDelay: r,
      staleTime: khe,
      enabled: i && !!e && (de.isEVMNetworkID(e) || de.isBitcoinNetworkID(e)),
      placeholderData: kP,
    }),
  Che = we({ seconds: 30 }),
  Phe = we({ minutes: 5 }),
  Mhe = (e) =>
    Qt({
      queryKey: fo.transactionAdditionalCosts(e),
      queryFn: async () => {
        if (!e) return new fe(0);
        const t = Mu.get(e.networkID).additionalTransactionCost;
        return t ? await t(e) : new fe(0);
      },
      enabled: !!e,
      staleTime: Che,
      gcTime: Phe,
    }),
  Ohe = async (e, t) => {
    const n = uI(e),
      r = await cI.eth_estimateGas(n, [t]);
    if ('error' in r) throw new Error(`[${r.error.code}] ${r.error.message}`);
    return new fe(r.result);
  };
new fe(21e3);
const Bhe = 6,
  Dhe = 600,
  Rhe = we({ seconds: 5 }),
  Nhe = we({ days: 1 }),
  jhe = (e, t = !0) =>
    Qt({
      queryFn: async () => {
        if (!e) throw new Error('Args is required for calculating transaction units.');
        try {
          return await Lhe(e);
        } catch (r) {
          throw (
            (re.addBreadcrumb(YI, `networkId: ${e == null ? void 0 : e.networkID}`, Ie.Info),
            re.captureError(r, ce.Transaction),
            r)
          );
        }
      },
      queryKey: fo.transactionUnitAmount(e),
      enabled: !!e && (de.isEVMNetworkID(e.networkID) || de.isBitcoinNetworkID(e.networkID)) && t,
      retry: Bhe,
      retryDelay: Dhe,
      staleTime: Rhe,
      gcTime: Nhe,
    }),
  Lhe = async (e) => {
    if (k5(e)) {
      const { gas: t } = e.unsignedTransaction;
      if (t) return { gasLimit: new fe(t, 16) };
      {
        const n = await Ohe(e.networkID, e.unsignedTransaction);
        return { gasLimit: new fe(PX(n)) };
      }
    } else if (x5(e)) {
      const t = e.psbtChain,
        n = t ? new fe(_y(t.map((i) => i.additionalCost.vb.toNumber()))) : new fe(0),
        r = t ? new fe(_y(t.map((i) => i.additionalCost.sats.toNumber()))) : new fe(0);
      return { virtualBytes: new fe(e.vb), additionalCosts: { vb: n, sats: r } };
    } else
      throw new Error(
        `Unsupported transaction networkId: ${e.networkID} for calculating transaction units.`
      );
  },
  Uhe = 6,
  $he = 600,
  Fhe = we({ seconds: 5 }),
  zhe = we({ days: 1 }),
  Khe = [er.fast, er.standard, er.slow],
  Vhe = (e) => {
    if (!e) return er.fast;
    for (const t of Khe) if (e[t]) return t;
    throw new Error('No valid transaction speeds found.');
  },
  JI = (e) => {
    var u;
    const t = Ghe(e),
      n = (u = e == null ? void 0 : e.queryOptions) == null ? void 0 : u.refetchInterval,
      { data: r, isError: i } = jhe(e == null ? void 0 : e.multichainTransaction, t),
      { data: s } = ZI({
        networkID: e == null ? void 0 : e.networkID,
        enableFallback: !0,
        refetchInterval: n,
      }),
      { data: o } = Mhe(e == null ? void 0 : e.multichainTransaction),
      a = Hhe(e, r, s);
    return Qt({
      queryFn: async () => {
        try {
          if (!e) throw new Error('Missing args');
          const { multichainTransaction: l, transactionSpeed: d = er.standard } = e;
          if (!l) throw new Error('Multichain transaction is null.');
          if (i && XI(e.networkID))
            throw new Error('Transaction unit amount is required but errored.');
          if (k5(l) || x5(l)) {
            if (!s) throw new Error('Missing transactionSpeedsToUnitCost');
            if (!r) throw new Error('Missing transactionUnit');
            const f = d === 'fastest' ? Vhe(s) : d,
              h = s[f];
            if (!h) throw new Error(`Missing transactionSpeedsToUnitCost for ${d}`);
            return O5(l.networkID, h, r, o);
          }
          if (nle(l))
            return l.networkID === Js.Localnet
              ? { networkID: l.networkID, value: 0, highFees: !1 }
              : await Mde(
                  l.networkID,
                  l.transaction.map((h) => ('version' in h ? h.message : h.compileMessage()))
                );
          if (rle(l)) return await pde(l);
          qt(l);
        } catch (l) {
          throw (
            (re.addBreadcrumb(YI, `chainId: ${e == null ? void 0 : e.networkID}`, Ie.Info),
            re.captureError(l, ce.Transaction),
            l)
          );
        }
      },
      queryKey: fo.gasEstimation(
        e == null ? void 0 : e.networkID,
        e == null ? void 0 : e.multichainTransaction,
        e == null ? void 0 : e.transactionSpeed,
        o
      ),
      enabled: a,
      retry: Uhe,
      retryDelay: $he,
      refetchInterval: n,
      staleTime: Fhe,
      gcTime: zhe,
      placeholderData: (l) => l,
    });
  };
function XI(e) {
  return de.isBitcoinNetworkID(e) || de.isEVMNetworkID(e)
    ? !0
    : de.isSolanaNetworkID(e) || de.isSuiNetworkID(e)
      ? !1
      : qt();
}
function Whe(e) {
  return de.isBitcoinNetworkID(e) || de.isEVMNetworkID(e)
    ? !0
    : de.isSolanaNetworkID(e) || de.isSuiNetworkID(e)
      ? !1
      : qt();
}
function Hhe(e, t, n) {
  if (!e) return !1;
  const { networkID: r, multichainTransaction: i } = e;
  return i ? (!!t || !XI(r)) && (!!n || !Whe(r)) : !1;
}
function Ghe(e) {
  return e ? XI(e.networkID) : !1;
}
const qhe = function (e, t = 0) {
  let n = 3735928559 ^ t,
    r = 1103547991 ^ t;
  for (let i = 0, s; i < e.length; i++)
    (s = e.charCodeAt(i)), (n = Math.imul(n ^ s, 2654435761)), (r = Math.imul(r ^ s, 1597334677));
  return (
    (n = Math.imul(n ^ (n >>> 16), 2246822507)),
    (n ^= Math.imul(r ^ (r >>> 13), 3266489909)),
    (r = Math.imul(r ^ (r >>> 16), 2246822507)),
    (r ^= Math.imul(n ^ (n >>> 13), 3266489909)),
    4294967296 * (2097151 & r) + (n >>> 0)
  );
};
function nR(e) {
  return { caip19: rR(e) };
}
function rR(e) {
  return typeof e == 'string' ? wb(e) : e;
}
function Yhe(e) {
  return e.data.map(nR);
}
const Zhe = 500;
async function Jhe({ queryClient: e, queries: t }) {
  const n = {};
  try {
    const r = {},
      i = [];
    for (const u of t) {
      const l = u.caip19,
        d = ha(l);
      if (r[d]) continue;
      r[d] = !0;
      const f = ja.price(d),
        h = e.getQueryState(f);
      if (h && Date.now() - h.dataUpdatedAt < pfe.staleTime) {
        n[d] = h.data;
        continue;
      }
      i.push(l);
    }
    const s = await Promise.allSettled(cA(i, Zhe).map((u) => q5({ tokens: u }))),
      o = [],
      a = s.some((u) => u.status === 'rejected'),
      c = s.reduce((u, l) => (l.status === 'rejected' ? u : { ...u, ...l.value }), {});
    for (const u of i) {
      const l = ha(u);
      let d = c[l];
      const f = ja.price(l);
      !d && a && (d = e.getQueryData(f)),
        d && (n[l] = d),
        o.push(() => {
          const h = d ?? null;
          e.setQueryData(f, h, { updatedAt: Date.now() });
        });
    }
    if (a) {
      const u = e.getQueryData(ja.priceError()) ?? 0;
      e.setQueryData(ja.priceError(), u + 1);
    } else e.removeQueries({ queryKey: ja.priceError() });
    Xhe(o, 50);
  } catch (r) {
    G5(r);
  }
  return n;
}
function Xhe(e, t) {
  const n = e.length;
  let r = 0;
  function i() {
    const s = e.slice(r, r + t);
    CP.batch(() => {
      s.forEach((o) => o());
    }),
      (r += t),
      r < n && setTimeout(i, 0);
  }
  i();
}
const Qhe = (e) =>
    typeof e == 'string' ? e : e.resourceType === 'nativeToken' ? e.slip44 : e.address,
  e0e = (e, t) => e.localeCompare(t),
  t0e = (e) => {
    const t = e.map(Qhe).sort(e0e).join(',');
    return qhe(t);
  },
  n0e = ({
    query: e,
    enabled: t = !0,
    key: n,
    queryOptions: r = { refetchInterval: Ap.Short },
    queryClient: i,
  }) => {
    const { refetchInterval: s } = r,
      o = Yhe(e),
      a = t && e != null && e.data.length > 0;
    return {
      queryKey: ja.tempPrices(n),
      staleTime: pc.Immediate,
      gcTime: WI.Never,
      refetchInterval: s,
      queryFn: () => Jhe({ queryClient: i, queries: o }),
      enabled: a,
    };
  };
function r0e({ query: e, enabled: t = !0, queryOptions: n = { refetchInterval: Ap.Short } }) {
  const r = lo(),
    i = W.useMemo(() => t0e(e.data), [e]);
  return Qt(n0e({ query: e, enabled: t, key: i, queryOptions: n, queryClient: r }));
}
const S3 = new Error('Price not available'),
  i0e = ({
    query: e,
    enabled: t = !0,
    queryOptions: n = { refetchInterval: Ap.Short, staleTime: pc.Short, gcTime: pc.Short },
  }) => {
    const r = e ? e.data : void 0,
      i = r ? s0e(r) : void 0,
      s = n.refetchInterval,
      o = n.staleTime,
      a = n.gcTime,
      c = r ? nR(r).caip19.chainId : void 0,
      u = c ? !H5.get(c).pricesDisabled : !1;
    return {
      enabled: t && !!i && u,
      queryKey: ja.price(i),
      refetchInterval(d) {
        return d.state.error === S3 ? !1 : s;
      },
      staleTime: o,
      gcTime: a,
      retry: !1,
      queryFn: async () => {
        var f, h;
        if (!r || !i) throw new Error('No caip19able provided');
        const d = rR(r);
        try {
          const b = (await q5({ tokens: [d] }))[i];
          if (!b) throw new Error(`Failed to fetch price for ${r}`);
          return b;
        } catch (p) {
          const b = p;
          throw i &&
            (((f = b.response) == null ? void 0 : f.status) === 404 ||
              ((h = b.response) == null ? void 0 : h.status) === 400)
            ? S3
            : p;
        }
      },
    };
  };
function iR({
  query: e,
  enabled: t = !0,
  queryOptions: n = { refetchInterval: Ap.Short, staleTime: pc.Short, gcTime: pc.Short },
}) {
  return Qt(i0e({ query: e, enabled: t, queryOptions: n }));
}
function s0e(e) {
  return typeof e == 'string' ? e : ha(e);
}
const o0e = new Error('missing price'),
  a0e = new Error('Unable to format gas estimation'),
  sR = (e, t) => {
    if (!t.usd) throw o0e;
    try {
      const n = de.getTokenDecimals(e.networkID);
      if (i1(e)) {
        const r = B5(e),
          s = new fe(r).div(fa(n)).times(new fe(t.usd));
        return {
          gasEstimationPriceUSD: Xp(s),
          gasEstimationPriceUSDNumber: s.toNumber(),
          gasEstimationAmount: r,
        };
      } else if (n1(e)) {
        const r = D5(e),
          s = r.div(new fe(NL)).times(t.usd);
        return {
          gasEstimationPriceUSD: Xp(s),
          gasEstimationPriceUSDNumber: s.toNumber(),
          gasEstimationAmount: r,
        };
      } else if (r1(e)) {
        const i = TP(e.gasBudget, n).times(t.usd);
        return {
          gasEstimationPriceUSD: Xp(i),
          gasEstimationPriceUSDNumber: i.toNumber(),
          gasEstimationAmount: e.gasBudget,
        };
      } else if (s1(e)) {
        const r = R5(e),
          s = new fe(r).div(fa(n)).times(t.usd);
        return {
          gasEstimationPriceUSD: Xp(s),
          gasEstimationPriceUSDNumber: s.toNumber(),
          gasEstimationAmount: r,
        };
      } else throw (qt(e), new Error('unsupported chain type'));
    } catch {
      throw a0e;
    }
  },
  c0e = (e, t, n) => {
    const r = e ? de.getChainID(e) : null,
      i = r ? PP(r) : void 0,
      { data: s, isFetched: o } = iR({ query: { data: i } }),
      a = !!e && !!t && o,
      c = fo.gasEstimationPrice(e, t);
    return Qt({
      enabled: a,
      queryKey: c,
      queryFn: () => {
        if (!s || !t) throw new Error('missing args');
        return sR(t, s);
      },
      refetchOnMount: !0,
      placeholderData: kP,
      ...(n || {}),
    });
  },
  u0e = (e) => {
    var o;
    const t = (o = e[0]) == null ? void 0 : o.networkID,
      n = t ? de.getChainID(t) : null,
      r = n ? PP(n) : void 0,
      { data: i } = iR({ query: { data: r } });
    return K9({
      queries: e.map((a) => ({
        queryKey: fo.gasEstimationPrice(t, a),
        queryFn: () => {
          if (!i || !a) throw new Error('missing args');
          return sR(a, i);
        },
      })),
    }).map((a) => a.data);
  };
we({ days: 5 });
const l0e = (e, t, n = !1) => {
  const r = lo();
  return W.useCallback(
    (s, o, a) => {
      if (s === void 0) return;
      const c = fo.timestamps(),
        l = r.getQueryData(c) || {
          [s]: { chainId: t, transactionType: e, isLedger: n, transactionId: s, timestamps: {} },
        },
        d = l[s];
      if (d != null && d.timestamps[o]) return;
      const f = {
        ...l,
        [s]: {
          ...(d || {
            chainId: t,
            transactionType: e,
            isLedger: n,
            transactionId: s,
            timestamps: {},
          }),
          timestamps: { ...((d == null ? void 0 : d.timestamps) ?? {}), [o]: a ?? Date.now() },
        },
      };
      r.setQueryData(c, f);
    },
    [t, n, r, e]
  );
};
lP.extend(xP);
const d0e = { [er.fast]: 'gasFast', [er.standard]: 'gasAverage', [er.slow]: 'gasSlow' };
function f0e(e, t, n) {
  const [r, i] = W.useState(t),
    s = n ?? ele(e),
    { data: o = {} } = ZI({ networkID: e }),
    a = W.useMemo(
      () =>
        Object.keys(o).reduce((w, A) => {
          const _ = A,
            x = o[_];
          return x && (w[_] = O5(e, x, s, void 0)), w;
        }, {}),
      [o, e, s]
    ),
    c = Object.keys(a),
    u = Object.values(a),
    l = u0e(Object.values(a)),
    d = u.map((w) => C5(w)),
    { fromUsd: f, formatLocalizedPrice: h } = y4(),
    p = c.map((w, A) => {
      const _ = u[A],
        x = l[A],
        k = d[A];
      return h0e(x, k, w, _, f, h);
    });
  return {
    presets: W.useMemo(
      () =>
        p.map((w, A) => ({
          description: w,
          title: qr.t(d0e[c[A]]),
          selected: r === c[A],
          onClick: () => i(c[A]),
          withBorderTop: A !== 0,
        })),
      [p, c, r]
    ),
    transactionSpeed: r,
  };
}
const h0e = (e, t, n, r, i, s) => {
    var f, h;
    const o = [],
      a =
        e != null && e.gasEstimationPriceUSDNumber
          ? i(e == null ? void 0 : e.gasEstimationPriceUSDNumber)
          : void 0,
      c = a ? s(a, { maximumFractionDigits: 4 }) : void 0,
      u = c ? qr.t('gasUpTo', { amount: c }) : t ? qr.t('gasUpTo', { amount: t }) : void 0;
    o.push(u);
    const l = r
      ? (h = (f = Mu.get(r.networkID)).transactionSettingsRowFeeDescription) == null
        ? void 0
        : h.call(f, r)
      : void 0;
    o.push(l);
    const d = r == null ? void 0 : r.networkID;
    if (d) {
      const p = Mu.get(d).transactionSpeedDescription(n);
      p && o.push(qr.t(p));
    }
    return o.filter(V9).join('  •  ');
  },
  p0e = wP(Es, (e) => ode(new sde(e))),
  g0e = 'transactions-utxo-state',
  y0e = 6,
  b0e = 600,
  m0e = we({ seconds: 30 }),
  w0e = we({ seconds: 5 }),
  v0e = we({ minutes: 10 }),
  _0e = (e) => {
    const t = p0e();
    return Qt({
      queryFn: S0e(e, t),
      queryKey: fo.utxoState(e),
      enabled: E0e(e),
      retry: y0e,
      retryDelay: b0e,
      refetchInterval: m0e,
      staleTime: w0e,
      gcTime: v0e,
    });
  };
function S0e(e, t) {
  return async () => {
    var n;
    try {
      if (!e) throw new Error('chainAddress not provided when fetching utxo state.');
      if (MP(e)) {
        await t.refetchUtxos(e);
        const [r, i, s] = await Promise.all([
          t.getSafeToSendUtxos(e.address),
          t.getInscribedUtxos(e.address),
          t.getRareSatsUtxos(e.address),
        ]);
        return { safeToSendUtxos: r, inscribedUtxos: i, rareSatsUtxos: s };
      } else
        throw new Error(`Unsupported chain address type for fetching utxo state: ${e.addressType}`);
    } catch (r) {
      if (nM(r)) {
        const i = (n = r.response) == null ? void 0 : n.status;
        ade(r, i, g0e);
      }
      throw r;
    }
  };
}
function E0e(e) {
  return !!e && MP(e);
}
const oR = ({ networkID: e, gasEstimation: t, gasEstimationPrice: n }) => {
  const r = C5(t),
    { fromUsd: i, formatLocalizedPrice: s } = y4(),
    o =
      n != null && n.gasEstimationPriceUSDNumber
        ? i(n == null ? void 0 : n.gasEstimationPriceUSDNumber)
        : void 0,
    a = o ? s(o, { maximumFractionDigits: 4 }) : void 0,
    c = !de.isMainnetNetworkID(e),
    u = a && !c ? a : r || void 0;
  return Mu.get(e).networkFeeRowString(u, a);
};
we({ seconds: 5 });
const A0e = (e) => {
  const t = e.transaction.getData();
  return Qt({ queryKey: fo.suiTransaction(t), queryFn: () => _de(e) });
};
var Fa = ((e) => (
    (e.Verified = 'VERIFIED'),
    (e.NotVerified = 'NOT_VERIFIED'),
    (e.PossibleSpam = 'POSSIBLE_SPAM'),
    (e.Spam = 'SPAM'),
    e
  ))(Fa || {}),
  ad = ((e) => (
    (e.Visible = 'visible'),
    (e.Hidden = 'hidden'),
    (e.VisibleNotSpam = 'visible:reported_notSpam'),
    (e.HiddenSpam = 'hidden:reported_spam'),
    e
  ))(ad || {});
class QI extends Error {
  constructor(t) {
    super(t), Object.setPrototypeOf(this, QI.prototype), (this.name = 'FungibleError');
  }
}
var aR = ((e) => ((e.AccountIdToHiddenMints = 'accountIdToHiddenMints'), e))(aR || {});
function I0e(e) {
  return e.map((t) => (typeof t == 'string' ? { mintId: t, status: ad.Hidden } : t));
}
function T0e(e) {
  return e
    ? e.version === 2
      ? e
      : {
          version: 2,
          value: Object.entries(e.value).reduce((t, [n, r]) => ((t[n] = I0e(r)), t), {}),
        }
    : null;
}
async function x0e(e) {
  try {
    return T0e(await e.get(aR.AccountIdToHiddenMints));
  } catch {
    throw new QI('Failed to get visibility overrides');
  }
}
function k0e(e) {
  return new Map(
    e.map((t) => (typeof t == 'string' ? [t, { mintId: t, status: ad.Hidden }] : [t.mintId, t]))
  );
}
async function cR(e, t) {
  var i;
  const r = (((i = await x0e(e)) == null ? void 0 : i.value) ?? {})[t] ?? [];
  return k0e(r);
}
function C0e(e, { key: t, spamStatus: n }) {
  const r = e == null ? void 0 : e.get(t);
  return P0e(r, { spamStatus: n });
}
function P0e(e, { spamStatus: t }) {
  if (!e && (t === Fa.PossibleSpam || t === Fa.Spam)) return !0;
  if (!e) return !1;
  const { status: n } = e;
  return n === ad.Hidden || n === ad.HiddenSpam;
}
function M0e(e, { key: t, spamStatus: n }) {
  return !C0e(e, { key: t, spamStatus: n });
}
function O0e(e) {
  const t = Es();
  return Qt(B0e(t, e ?? ''));
}
function B0e(e, t) {
  return {
    gcTime: c1.Long,
    staleTime: u1.Never,
    enabled: !!t && !!e,
    queryKey: qy.hiddenMints(t ?? ''),
    async queryFn() {
      return !t || !e ? new Map() : await cR(e, t);
    },
  };
}
function D0e(e) {
  let t, n;
  for (const { data: r } of e) {
    const { usd: i, usd_24h_change: s } = r;
    i !== void 0 && (t = t !== void 0 ? t + i : i), s !== void 0 && (n = n !== void 0 ? n + s : s);
  }
  return { value: t, earnings: n };
}
function R0e(e, t) {
  return e
    .getQueriesData({ predicate: (r) => r.queryKey[0] === z5.transferFungibleLoggingContext })
    .map(([, r]) => r)
    .filter((r) => {
      if (!r) return !1;
      const { previousBalance: i, fungibleKey: s } = r,
        o = t.get(s);
      return o ? !o.data.balance.isEqualTo(i) : !1;
    });
}
const E3 = [
    G.Solana,
    G.EVM,
    G.Sui,
    G.BitcoinTaproot,
    G.BitcoinNativeSegwit,
    G.BitcoinNestedSegwit,
    G.BitcoinLegacy,
  ],
  A3 = OP(bs);
function N0e(e, t) {
  const n = A3(e.data.chain.id, e.data.walletAddress),
    r = A3(t.data.chain.id, t.data.walletAddress),
    i = E3.indexOf(n) - E3.indexOf(r);
  return i === 0 ? 0 : i < 0 ? -1 : 1;
}
const j0e = OP(N0e);
function L0e(e, t) {
  return t.data.balance.comparedTo(e.data.balance);
}
const I3 = '￿';
function U0e(e, t) {
  var i, s;
  const n = ((i = e.data.name) == null ? void 0 : i.toUpperCase()) ?? I3,
    r = ((s = t.data.name) == null ? void 0 : s.toUpperCase()) ?? I3;
  return n.localeCompare(r);
}
function $0e(e, t) {
  const n = e.data.usd ?? Number.NEGATIVE_INFINITY,
    r = t.data.usd ?? Number.NEGATIVE_INFINITY;
  return n > r ? -1 : n < r ? 1 : 0;
}
function F0e(e, t) {
  const n = e.data.spamStatus,
    r = t.data.spamStatus,
    i = (a) => {
      switch (a) {
        case Fa.Verified:
          return 4;
        case Fa.NotVerified:
          return 3;
        case Fa.PossibleSpam:
          return 2;
        case Fa.Spam:
          return 1;
      }
    },
    s = i(n),
    o = i(r);
  return s > o ? -1 : s < o ? 1 : 0;
}
const T3 = '￿';
function z0e(e, t) {
  var i, s;
  const n = ((i = e.data.symbol) == null ? void 0 : i.toUpperCase()) ?? T3,
    r = ((s = t.data.symbol) == null ? void 0 : s.toUpperCase()) ?? T3;
  return n.localeCompare(r);
}
function K0e(e, t) {
  const n = yc(e.type),
    r = yc(t.type);
  return n !== r ? (n ? -1 : 1) : de.compareNetworkID(e.data.chain.id, t.data.chain.id);
}
const V0e = (e, t) => {
    const n = $0e(e, t);
    if (n) return n;
    const r = F0e(e, t);
    if (r) return r;
    const i = L0e(e, t);
    if (i) return i;
    const s = K0e(e, t);
    if (s) return s;
    const o = j0e(e, t);
    if (o) return o;
    const a = U0e(e, t);
    return a || z0e(e, t);
  },
  uR = (e) => {
    const t = e.data.chain.id;
    if (yc(e.type)) return { chainId: t, slip44: de.getSlip44(t), resourceType: Pr.nativeToken };
    {
      let n;
      switch (e.type) {
        case lt.SPL:
        case lt.CompressedSPL:
          n = e.data.mintAddress;
          break;
        case lt.ERC20:
        case lt.SuiCoin:
          n = e.data.contractAddress;
          break;
        case lt.BRC20:
          n = e.data.firstCreatedInscriptionId;
          break;
      }
      return { chainId: t, address: n, resourceType: Pr.address };
    }
  },
  W0e = (e, t) => {
    const n = qy.transferFungibleLoggingContext(e);
    t.removeQueries({ queryKey: n });
  };
fe.config({ EXPONENTIAL_AT: 1e3, DECIMAL_PLACES: 78 });
const H0e = (e, t) => new fe(e).div(fa(t));
function G0e({ tokens: e, priceMap: t }) {
  const n = [];
  for (const r of e) {
    const { amount: i, decimals: s } = r.data,
      o = uR(r),
      a = ha(o),
      c = qI(r),
      u = H0e(i, s),
      l = { type: r.type, data: { ...r.data, balance: u, key: c } };
    let d;
    const f = dfe({ priceId: a, balance: u, priceMap: t });
    if (r.type === lt.SPL || r.type === lt.CompressedSPL) {
      const { mintAddress: h } = r.data;
      d = h;
    } else if (r.type === lt.ERC20 || r.type === lt.SuiCoin) {
      const { contractAddress: h } = r.data;
      d = h;
    } else if (r.type === lt.BRC20) {
      const { firstCreatedInscriptionId: h } = r.data;
      d = h;
    }
    (l.data.tokenAddress = d),
      (l.data.usd = f.usd),
      (l.data.price = f.price),
      (l.data.usd_24h_change = f.usd_24h_change),
      (l.data.priceChange24h = f.priceChange24h),
      (l.data.currencyChange = f.currencyChange),
      (l.data.currencyValue = f.currencyValue),
      n.push(l);
  }
  return n;
}
function q0e({
  showHiddenMints: e = !1,
  keys: t,
  enablePrices: n = !0,
  enableSorting: r = !0,
  usePricesQueryOptions: i,
  useTokenQueryOptions: s,
} = {}) {
  const { data: o } = Xb(),
    {
      data: a = [],
      isPending: c,
      isRefetching: u,
      refetch: l,
      isError: d,
      error: f,
    } = whe({ chainAddresses: o == null ? void 0 : o.addresses, keys: t, queryOptions: s }),
    { data: h, isPending: p, isRefetching: b } = O0e(o == null ? void 0 : o.identifier),
    { query: w } = W.useMemo(() => ({ query: { data: a.map(uR) } }), [a]),
    {
      data: A,
      isPending: _,
      isRefetching: x,
      refetch: k,
      isError: j,
    } = r0e({
      query: w,
      enabled: n && !c && (o == null ? void 0 : o.identifier) != null,
      queryOptions: i,
    }),
    { fungibles: F, fungibleMap: K } = W.useMemo(() => {
      const S = e
        ? a
        : a.filter((R) => {
            const L = qI(R),
              O = (t || []).includes(L),
              I = M0e(h, { key: L, spamStatus: R.data.spamStatus });
            return O || I;
          });
      let T = G0e({ tokens: S, priceMap: A ?? {} });
      r &&
        (t === void 0
          ? (T = T.sort(V0e))
          : (T = T.sort((R, L) => {
              const O = t.indexOf(R.data.key),
                I = t.indexOf(L.data.key);
              return O < I ? -1 : O > I ? 1 : 0;
            })));
      const M = new Map();
      for (const R of T) M.set(R.data.key, R);
      return { fungibles: T, fungibleMap: M };
    }, [a, t, e, h, A, r]),
    D = W.useMemo(() => !!h && h.size > 0 && a.length > 0 && F.length === 0, [a, h, F]),
    C = lo(),
    B = W.useMemo(() => R0e(C, K), [K, C]),
    E = l0e('send:fungible', mt.Solana.Mainnet);
  W.useEffect(() => {
    for (const S of B) E(S.transactionId, 'appUpdated'), W0e(S.fungibleKey, C);
  }, [B, E, C]);
  const y = W.useMemo(() => D0e(F), [F]),
    v = W.useCallback(async () => {
      await Promise.all([l(), k()]);
    }, [l, k]);
  return {
    fungibles: F,
    portfolio: y,
    visibilityOverrides: h,
    isHidingAllFungibles: D,
    isLoadingTokens: c,
    isLoadingVisibilityOverrides: p,
    isLoadingPrices: n ? _ : !1,
    isRefetchingTokens: u,
    isRefetchingVisibilityOverrides: b,
    isRefetchingPrices: n ? x : !1,
    isErrorTokens: d,
    tokensError: f,
    isErrorPrices: j,
    refetch: v,
  };
}
function Y0e({ key: e, splTokenAccount: t, ...n }) {
  const { fungibles: r, ...i } = q0e({ ...n, keys: e ? [e] : [] });
  let s;
  return (
    r.length === 1
      ? (s = r[0])
      : r.length > 1 &&
        t &&
        (s = r.find((o) => o.type === lt.SPL && o.data.splTokenAccountPubkey === t)),
    { fungible: s, ...i }
  );
}
BigInt('4000000');
we({ seconds: 30 });
const Z0e = [
  'receive',
  'send',
  'decompress',
  'swap',
  'buy',
  'stakeSol',
  'mintLST',
  'stake',
  'unstake',
  'viewOnExplorer',
  'copyTokenAddress',
  'unwrapWrappedSol',
  'share',
  'reportIssue',
];
new Map(Z0e.map((e, t) => [e, t + 1]));
const x3 = 1e-5,
  J0e = '0,0.[00]a',
  X0e = 1e5,
  Q0e = (e, t = 5) => {
    const n = new fe(e);
    if (n.abs().isGreaterThan(0) && n.abs().isLessThan(x3))
      return `< ${n.isLessThan(0) ? '-' : ''}${x3}`;
    const r = AP(n.toNumber());
    return n.isGreaterThanOrEqualTo(X0e) ? r.format(J0e) : r.format(`0,0.[${'0'.repeat(t)}]`);
  },
  eT = { small: 44, medium: 72, large: 128 };
var lR = { exports: {} },
  Ot = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var tT = Symbol.for('react.element'),
  nT = Symbol.for('react.portal'),
  l1 = Symbol.for('react.fragment'),
  d1 = Symbol.for('react.strict_mode'),
  f1 = Symbol.for('react.profiler'),
  h1 = Symbol.for('react.provider'),
  p1 = Symbol.for('react.context'),
  epe = Symbol.for('react.server_context'),
  g1 = Symbol.for('react.forward_ref'),
  y1 = Symbol.for('react.suspense'),
  b1 = Symbol.for('react.suspense_list'),
  m1 = Symbol.for('react.memo'),
  w1 = Symbol.for('react.lazy'),
  tpe = Symbol.for('react.offscreen'),
  dR;
dR = Symbol.for('react.module.reference');
function mi(e) {
  if (typeof e == 'object' && e !== null) {
    var t = e.$$typeof;
    switch (t) {
      case tT:
        switch (((e = e.type), e)) {
          case l1:
          case f1:
          case d1:
          case y1:
          case b1:
            return e;
          default:
            switch (((e = e && e.$$typeof), e)) {
              case epe:
              case p1:
              case g1:
              case w1:
              case m1:
              case h1:
                return e;
              default:
                return t;
            }
        }
      case nT:
        return t;
    }
  }
}
Ot.ContextConsumer = p1;
Ot.ContextProvider = h1;
Ot.Element = tT;
Ot.ForwardRef = g1;
Ot.Fragment = l1;
Ot.Lazy = w1;
Ot.Memo = m1;
Ot.Portal = nT;
Ot.Profiler = f1;
Ot.StrictMode = d1;
Ot.Suspense = y1;
Ot.SuspenseList = b1;
Ot.isAsyncMode = function () {
  return !1;
};
Ot.isConcurrentMode = function () {
  return !1;
};
Ot.isContextConsumer = function (e) {
  return mi(e) === p1;
};
Ot.isContextProvider = function (e) {
  return mi(e) === h1;
};
Ot.isElement = function (e) {
  return typeof e == 'object' && e !== null && e.$$typeof === tT;
};
Ot.isForwardRef = function (e) {
  return mi(e) === g1;
};
Ot.isFragment = function (e) {
  return mi(e) === l1;
};
Ot.isLazy = function (e) {
  return mi(e) === w1;
};
Ot.isMemo = function (e) {
  return mi(e) === m1;
};
Ot.isPortal = function (e) {
  return mi(e) === nT;
};
Ot.isProfiler = function (e) {
  return mi(e) === f1;
};
Ot.isStrictMode = function (e) {
  return mi(e) === d1;
};
Ot.isSuspense = function (e) {
  return mi(e) === y1;
};
Ot.isSuspenseList = function (e) {
  return mi(e) === b1;
};
Ot.isValidElementType = function (e) {
  return (
    typeof e == 'string' ||
    typeof e == 'function' ||
    e === l1 ||
    e === f1 ||
    e === d1 ||
    e === y1 ||
    e === b1 ||
    e === tpe ||
    (typeof e == 'object' &&
      e !== null &&
      (e.$$typeof === w1 ||
        e.$$typeof === m1 ||
        e.$$typeof === h1 ||
        e.$$typeof === p1 ||
        e.$$typeof === g1 ||
        e.$$typeof === dR ||
        e.getModuleId !== void 0))
  );
};
Ot.typeOf = mi;
lR.exports = Ot;
var fR = lR.exports;
function npe(e) {
  function t(H, X, J, ie, Z) {
    for (
      var be = 0,
        le = 0,
        Oe = 0,
        Re = 0,
        ht,
        xe,
        We = 0,
        Yt = 0,
        Fe,
        nt = (Fe = ht = 0),
        vt = 0,
        ut = 0,
        Ut = 0,
        dn = 0,
        Kt = J.length,
        $t = Kt - 1,
        Er,
        Pe = '',
        Qe = '',
        Oc = '',
        Zt = '',
        Mt;
      vt < Kt;

    ) {
      if (
        ((xe = J.charCodeAt(vt)),
        vt === $t &&
          le + Re + Oe + be !== 0 &&
          (le !== 0 && (xe = le === 47 ? 10 : 47), (Re = Oe = be = 0), Kt++, $t++),
        le + Re + Oe + be === 0)
      ) {
        if (vt === $t && (0 < ut && (Pe = Pe.replace(f, '')), 0 < Pe.trim().length)) {
          switch (xe) {
            case 32:
            case 9:
            case 59:
            case 13:
            case 10:
              break;
            default:
              Pe += J.charAt(vt);
          }
          xe = 59;
        }
        switch (xe) {
          case 123:
            for (Pe = Pe.trim(), ht = Pe.charCodeAt(0), Fe = 1, dn = ++vt; vt < Kt; ) {
              switch ((xe = J.charCodeAt(vt))) {
                case 123:
                  Fe++;
                  break;
                case 125:
                  Fe--;
                  break;
                case 47:
                  switch ((xe = J.charCodeAt(vt + 1))) {
                    case 42:
                    case 47:
                      e: {
                        for (nt = vt + 1; nt < $t; ++nt)
                          switch (J.charCodeAt(nt)) {
                            case 47:
                              if (xe === 42 && J.charCodeAt(nt - 1) === 42 && vt + 2 !== nt) {
                                vt = nt + 1;
                                break e;
                              }
                              break;
                            case 10:
                              if (xe === 47) {
                                vt = nt + 1;
                                break e;
                              }
                          }
                        vt = nt;
                      }
                  }
                  break;
                case 91:
                  xe++;
                case 40:
                  xe++;
                case 34:
                case 39:
                  for (; vt++ < $t && J.charCodeAt(vt) !== xe; );
              }
              if (Fe === 0) break;
              vt++;
            }
            switch (
              ((Fe = J.substring(dn, vt)),
              ht === 0 && (ht = (Pe = Pe.replace(d, '').trim()).charCodeAt(0)),
              ht)
            ) {
              case 64:
                switch ((0 < ut && (Pe = Pe.replace(f, '')), (xe = Pe.charCodeAt(1)), xe)) {
                  case 100:
                  case 109:
                  case 115:
                  case 45:
                    ut = X;
                    break;
                  default:
                    ut = M;
                }
                if (
                  ((Fe = t(X, ut, Fe, xe, Z + 1)),
                  (dn = Fe.length),
                  0 < L &&
                    ((ut = n(M, Pe, Ut)),
                    (Mt = a(3, Fe, ut, X, v, y, dn, xe, Z, ie)),
                    (Pe = ut.join('')),
                    Mt !== void 0 && (dn = (Fe = Mt.trim()).length) === 0 && ((xe = 0), (Fe = ''))),
                  0 < dn)
                )
                  switch (xe) {
                    case 115:
                      Pe = Pe.replace(F, o);
                    case 100:
                    case 109:
                    case 45:
                      Fe = Pe + '{' + Fe + '}';
                      break;
                    case 107:
                      (Pe = Pe.replace(_, '$1 $2')),
                        (Fe = Pe + '{' + Fe + '}'),
                        (Fe =
                          T === 1 || (T === 2 && s('@' + Fe, 3))
                            ? '@-webkit-' + Fe + '@' + Fe
                            : '@' + Fe);
                      break;
                    default:
                      (Fe = Pe + Fe), ie === 112 && (Fe = ((Qe += Fe), ''));
                  }
                else Fe = '';
                break;
              default:
                Fe = t(X, n(X, Pe, Ut), Fe, ie, Z + 1);
            }
            (Oc += Fe), (Fe = Ut = ut = nt = ht = 0), (Pe = ''), (xe = J.charCodeAt(++vt));
            break;
          case 125:
          case 59:
            if (((Pe = (0 < ut ? Pe.replace(f, '') : Pe).trim()), 1 < (dn = Pe.length)))
              switch (
                (nt === 0 &&
                  ((ht = Pe.charCodeAt(0)), ht === 45 || (96 < ht && 123 > ht)) &&
                  (dn = (Pe = Pe.replace(' ', ':')).length),
                0 < L &&
                  (Mt = a(1, Pe, X, H, v, y, Qe.length, ie, Z, ie)) !== void 0 &&
                  (dn = (Pe = Mt.trim()).length) === 0 &&
                  (Pe = '\0\0'),
                (ht = Pe.charCodeAt(0)),
                (xe = Pe.charCodeAt(1)),
                ht)
              ) {
                case 0:
                  break;
                case 64:
                  if (xe === 105 || xe === 99) {
                    Zt += Pe + J.charAt(vt);
                    break;
                  }
                default:
                  Pe.charCodeAt(dn - 1) !== 58 && (Qe += i(Pe, ht, xe, Pe.charCodeAt(2)));
              }
            (Ut = ut = nt = ht = 0), (Pe = ''), (xe = J.charCodeAt(++vt));
        }
      }
      switch (xe) {
        case 13:
        case 10:
          le === 47
            ? (le = 0)
            : 1 + ht === 0 && ie !== 107 && 0 < Pe.length && ((ut = 1), (Pe += '\0')),
            0 < L * I && a(0, Pe, X, H, v, y, Qe.length, ie, Z, ie),
            (y = 1),
            v++;
          break;
        case 59:
        case 125:
          if (le + Re + Oe + be === 0) {
            y++;
            break;
          }
        default:
          switch ((y++, (Er = J.charAt(vt)), xe)) {
            case 9:
            case 32:
              if (Re + be + le === 0)
                switch (We) {
                  case 44:
                  case 58:
                  case 9:
                  case 32:
                    Er = '';
                    break;
                  default:
                    xe !== 32 && (Er = ' ');
                }
              break;
            case 0:
              Er = '\\0';
              break;
            case 12:
              Er = '\\f';
              break;
            case 11:
              Er = '\\v';
              break;
            case 38:
              Re + le + be === 0 && ((ut = Ut = 1), (Er = '\f' + Er));
              break;
            case 108:
              if (Re + le + be + S === 0 && 0 < nt)
                switch (vt - nt) {
                  case 2:
                    We === 112 && J.charCodeAt(vt - 3) === 58 && (S = We);
                  case 8:
                    Yt === 111 && (S = Yt);
                }
              break;
            case 58:
              Re + le + be === 0 && (nt = vt);
              break;
            case 44:
              le + Oe + Re + be === 0 && ((ut = 1), (Er += '\r'));
              break;
            case 34:
            case 39:
              le === 0 && (Re = Re === xe ? 0 : Re === 0 ? xe : Re);
              break;
            case 91:
              Re + le + Oe === 0 && be++;
              break;
            case 93:
              Re + le + Oe === 0 && be--;
              break;
            case 41:
              Re + le + be === 0 && Oe--;
              break;
            case 40:
              if (Re + le + be === 0) {
                if (ht === 0)
                  switch (2 * We + 3 * Yt) {
                    case 533:
                      break;
                    default:
                      ht = 1;
                  }
                Oe++;
              }
              break;
            case 64:
              le + Oe + Re + be + nt + Fe === 0 && (Fe = 1);
              break;
            case 42:
            case 47:
              if (!(0 < Re + be + Oe))
                switch (le) {
                  case 0:
                    switch (2 * xe + 3 * J.charCodeAt(vt + 1)) {
                      case 235:
                        le = 47;
                        break;
                      case 220:
                        (dn = vt), (le = 42);
                    }
                    break;
                  case 42:
                    xe === 47 &&
                      We === 42 &&
                      dn + 2 !== vt &&
                      (J.charCodeAt(dn + 2) === 33 && (Qe += J.substring(dn, vt + 1)),
                      (Er = ''),
                      (le = 0));
                }
          }
          le === 0 && (Pe += Er);
      }
      (Yt = We), (We = xe), vt++;
    }
    if (((dn = Qe.length), 0 < dn)) {
      if (
        ((ut = X),
        0 < L &&
          ((Mt = a(2, Qe, ut, H, v, y, dn, ie, Z, ie)), Mt !== void 0 && (Qe = Mt).length === 0))
      )
        return Zt + Qe + Oc;
      if (((Qe = ut.join(',') + '{' + Qe + '}'), T * S !== 0)) {
        switch ((T !== 2 || s(Qe, 2) || (S = 0), S)) {
          case 111:
            Qe = Qe.replace(k, ':-moz-$1') + Qe;
            break;
          case 112:
            Qe =
              Qe.replace(x, '::-webkit-input-$1') +
              Qe.replace(x, '::-moz-$1') +
              Qe.replace(x, ':-ms-input-$1') +
              Qe;
        }
        S = 0;
      }
    }
    return Zt + Qe + Oc;
  }
  function n(H, X, J) {
    var ie = X.trim().split(w);
    X = ie;
    var Z = ie.length,
      be = H.length;
    switch (be) {
      case 0:
      case 1:
        var le = 0;
        for (H = be === 0 ? '' : H[0] + ' '; le < Z; ++le) X[le] = r(H, X[le], J).trim();
        break;
      default:
        var Oe = (le = 0);
        for (X = []; le < Z; ++le)
          for (var Re = 0; Re < be; ++Re) X[Oe++] = r(H[Re] + ' ', ie[le], J).trim();
    }
    return X;
  }
  function r(H, X, J) {
    var ie = X.charCodeAt(0);
    switch ((33 > ie && (ie = (X = X.trim()).charCodeAt(0)), ie)) {
      case 38:
        return X.replace(A, '$1' + H.trim());
      case 58:
        return H.trim() + X.replace(A, '$1' + H.trim());
      default:
        if (0 < 1 * J && 0 < X.indexOf('\f'))
          return X.replace(A, (H.charCodeAt(0) === 58 ? '' : '$1') + H.trim());
    }
    return H + X;
  }
  function i(H, X, J, ie) {
    var Z = H + ';',
      be = 2 * X + 3 * J + 4 * ie;
    if (be === 944) {
      H = Z.indexOf(':', 9) + 1;
      var le = Z.substring(H, Z.length - 1).trim();
      return (
        (le = Z.substring(0, H).trim() + le + ';'),
        T === 1 || (T === 2 && s(le, 1)) ? '-webkit-' + le + le : le
      );
    }
    if (T === 0 || (T === 2 && !s(Z, 1))) return Z;
    switch (be) {
      case 1015:
        return Z.charCodeAt(10) === 97 ? '-webkit-' + Z + Z : Z;
      case 951:
        return Z.charCodeAt(3) === 116 ? '-webkit-' + Z + Z : Z;
      case 963:
        return Z.charCodeAt(5) === 110 ? '-webkit-' + Z + Z : Z;
      case 1009:
        if (Z.charCodeAt(4) !== 100) break;
      case 969:
      case 942:
        return '-webkit-' + Z + Z;
      case 978:
        return '-webkit-' + Z + '-moz-' + Z + Z;
      case 1019:
      case 983:
        return '-webkit-' + Z + '-moz-' + Z + '-ms-' + Z + Z;
      case 883:
        if (Z.charCodeAt(8) === 45) return '-webkit-' + Z + Z;
        if (0 < Z.indexOf('image-set(', 11)) return Z.replace(E, '$1-webkit-$2') + Z;
        break;
      case 932:
        if (Z.charCodeAt(4) === 45)
          switch (Z.charCodeAt(5)) {
            case 103:
              return (
                '-webkit-box-' +
                Z.replace('-grow', '') +
                '-webkit-' +
                Z +
                '-ms-' +
                Z.replace('grow', 'positive') +
                Z
              );
            case 115:
              return '-webkit-' + Z + '-ms-' + Z.replace('shrink', 'negative') + Z;
            case 98:
              return '-webkit-' + Z + '-ms-' + Z.replace('basis', 'preferred-size') + Z;
          }
        return '-webkit-' + Z + '-ms-' + Z + Z;
      case 964:
        return '-webkit-' + Z + '-ms-flex-' + Z + Z;
      case 1023:
        if (Z.charCodeAt(8) !== 99) break;
        return (
          (le = Z.substring(Z.indexOf(':', 15))
            .replace('flex-', '')
            .replace('space-between', 'justify')),
          '-webkit-box-pack' + le + '-webkit-' + Z + '-ms-flex-pack' + le + Z
        );
      case 1005:
        return p.test(Z) ? Z.replace(h, ':-webkit-') + Z.replace(h, ':-moz-') + Z : Z;
      case 1e3:
        switch (
          ((le = Z.substring(13).trim()),
          (X = le.indexOf('-') + 1),
          le.charCodeAt(0) + le.charCodeAt(X))
        ) {
          case 226:
            le = Z.replace(j, 'tb');
            break;
          case 232:
            le = Z.replace(j, 'tb-rl');
            break;
          case 220:
            le = Z.replace(j, 'lr');
            break;
          default:
            return Z;
        }
        return '-webkit-' + Z + '-ms-' + le + Z;
      case 1017:
        if (Z.indexOf('sticky', 9) === -1) break;
      case 975:
        switch (
          ((X = (Z = H).length - 10),
          (le = (Z.charCodeAt(X) === 33 ? Z.substring(0, X) : Z)
            .substring(H.indexOf(':', 7) + 1)
            .trim()),
          (be = le.charCodeAt(0) + (le.charCodeAt(7) | 0)))
        ) {
          case 203:
            if (111 > le.charCodeAt(8)) break;
          case 115:
            Z = Z.replace(le, '-webkit-' + le) + ';' + Z;
            break;
          case 207:
          case 102:
            Z =
              Z.replace(le, '-webkit-' + (102 < be ? 'inline-' : '') + 'box') +
              ';' +
              Z.replace(le, '-webkit-' + le) +
              ';' +
              Z.replace(le, '-ms-' + le + 'box') +
              ';' +
              Z;
        }
        return Z + ';';
      case 938:
        if (Z.charCodeAt(5) === 45)
          switch (Z.charCodeAt(6)) {
            case 105:
              return (
                (le = Z.replace('-items', '')),
                '-webkit-' + Z + '-webkit-box-' + le + '-ms-flex-' + le + Z
              );
            case 115:
              return '-webkit-' + Z + '-ms-flex-item-' + Z.replace(D, '') + Z;
            default:
              return (
                '-webkit-' +
                Z +
                '-ms-flex-line-pack' +
                Z.replace('align-content', '').replace(D, '') +
                Z
              );
          }
        break;
      case 973:
      case 989:
        if (Z.charCodeAt(3) !== 45 || Z.charCodeAt(4) === 122) break;
      case 931:
      case 953:
        if (B.test(H) === !0)
          return (le = H.substring(H.indexOf(':') + 1)).charCodeAt(0) === 115
            ? i(H.replace('stretch', 'fill-available'), X, J, ie).replace(
                ':fill-available',
                ':stretch'
              )
            : Z.replace(le, '-webkit-' + le) + Z.replace(le, '-moz-' + le.replace('fill-', '')) + Z;
        break;
      case 962:
        if (
          ((Z = '-webkit-' + Z + (Z.charCodeAt(5) === 102 ? '-ms-' + Z : '') + Z),
          J + ie === 211 && Z.charCodeAt(13) === 105 && 0 < Z.indexOf('transform', 10))
        )
          return Z.substring(0, Z.indexOf(';', 27) + 1).replace(b, '$1-webkit-$2') + Z;
    }
    return Z;
  }
  function s(H, X) {
    var J = H.indexOf(X === 1 ? ':' : '{'),
      ie = H.substring(0, X !== 3 ? J : 10);
    return (J = H.substring(J + 1, H.length - 1)), O(X !== 2 ? ie : ie.replace(C, '$1'), J, X);
  }
  function o(H, X) {
    var J = i(X, X.charCodeAt(0), X.charCodeAt(1), X.charCodeAt(2));
    return J !== X + ';' ? J.replace(K, ' or ($1)').substring(4) : '(' + X + ')';
  }
  function a(H, X, J, ie, Z, be, le, Oe, Re, ht) {
    for (var xe = 0, We = X, Yt; xe < L; ++xe)
      switch ((Yt = R[xe].call(l, H, We, J, ie, Z, be, le, Oe, Re, ht))) {
        case void 0:
        case !1:
        case !0:
        case null:
          break;
        default:
          We = Yt;
      }
    if (We !== X) return We;
  }
  function c(H) {
    switch (H) {
      case void 0:
      case null:
        L = R.length = 0;
        break;
      default:
        if (typeof H == 'function') R[L++] = H;
        else if (typeof H == 'object') for (var X = 0, J = H.length; X < J; ++X) c(H[X]);
        else I = !!H | 0;
    }
    return c;
  }
  function u(H) {
    return (
      (H = H.prefix),
      H !== void 0 &&
        ((O = null), H ? (typeof H != 'function' ? (T = 1) : ((T = 2), (O = H))) : (T = 0)),
      u
    );
  }
  function l(H, X) {
    var J = H;
    if ((33 > J.charCodeAt(0) && (J = J.trim()), (U = J), (J = [U]), 0 < L)) {
      var ie = a(-1, X, J, J, v, y, 0, 0, 0, 0);
      ie !== void 0 && typeof ie == 'string' && (X = ie);
    }
    var Z = t(M, J, X, 0, 0);
    return (
      0 < L && ((ie = a(-2, Z, J, J, v, y, Z.length, 0, 0, 0)), ie !== void 0 && (Z = ie)),
      (U = ''),
      (S = 0),
      (y = v = 1),
      Z
    );
  }
  var d = /^\0+/g,
    f = /[\0\r\f]/g,
    h = /: */g,
    p = /zoo|gra/,
    b = /([,: ])(transform)/g,
    w = /,\r+?/g,
    A = /([\t\r\n ])*\f?&/g,
    _ = /@(k\w+)\s*(\S*)\s*/,
    x = /::(place)/g,
    k = /:(read-only)/g,
    j = /[svh]\w+-[tblr]{2}/,
    F = /\(\s*(.*)\s*\)/g,
    K = /([\s\S]*?);/g,
    D = /-self|flex-/g,
    C = /[^]*?(:[rp][el]a[\w-]+)[^]*/,
    B = /stretch|:\s*\w+\-(?:conte|avail)/,
    E = /([^-])(image-set\()/,
    y = 1,
    v = 1,
    S = 0,
    T = 1,
    M = [],
    R = [],
    L = 0,
    O = null,
    I = 0,
    U = '';
  return (l.use = c), (l.set = u), e !== void 0 && u(e), l;
}
var rpe = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1,
};
function ipe(e) {
  var t = {};
  return function (n) {
    return t[n] === void 0 && (t[n] = e(n)), t[n];
  };
}
var spe =
    /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,
  k3 = ipe(function (e) {
    return (
      spe.test(e) || (e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91)
    );
  }),
  as = {};
function Qs() {
  return (Qs =
    Object.assign ||
    function (e) {
      for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t];
        for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
      }
      return e;
    }).apply(this, arguments);
}
var C3 = function (e, t) {
    for (var n = [e[0]], r = 0, i = t.length; r < i; r += 1) n.push(t[r], e[r + 1]);
    return n;
  },
  wE = function (e) {
    return (
      e !== null &&
      typeof e == 'object' &&
      (e.toString ? e.toString() : Object.prototype.toString.call(e)) === '[object Object]' &&
      !fR.typeOf(e)
    );
  },
  Yy = Object.freeze([]),
  la = Object.freeze({});
function cd(e) {
  return typeof e == 'function';
}
function P3(e) {
  return e.displayName || e.name || 'Component';
}
function rT(e) {
  return e && typeof e.styledComponentId == 'string';
}
var Bu = (typeof hu < 'u' && (as.REACT_APP_SC_ATTR || as.SC_ATTR)) || 'data-styled',
  iT = typeof window < 'u' && 'HTMLElement' in window,
  ope = !!(typeof SC_DISABLE_SPEEDY == 'boolean'
    ? SC_DISABLE_SPEEDY
    : typeof hu < 'u' &&
        as.REACT_APP_SC_DISABLE_SPEEDY !== void 0 &&
        as.REACT_APP_SC_DISABLE_SPEEDY !== ''
      ? as.REACT_APP_SC_DISABLE_SPEEDY !== 'false' && as.REACT_APP_SC_DISABLE_SPEEDY
      : typeof hu < 'u' &&
        as.SC_DISABLE_SPEEDY !== void 0 &&
        as.SC_DISABLE_SPEEDY !== '' &&
        as.SC_DISABLE_SPEEDY !== 'false' &&
        as.SC_DISABLE_SPEEDY);
function Tp(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  throw new Error(
    'An error occurred. See https://git.io/JUIaE#' +
      e +
      ' for more information.' +
      (n.length > 0 ? ' Args: ' + n.join(', ') : '')
  );
}
var ape = (function () {
    function e(n) {
      (this.groupSizes = new Uint32Array(512)), (this.length = 512), (this.tag = n);
    }
    var t = e.prototype;
    return (
      (t.indexOfGroup = function (n) {
        for (var r = 0, i = 0; i < n; i++) r += this.groupSizes[i];
        return r;
      }),
      (t.insertRules = function (n, r) {
        if (n >= this.groupSizes.length) {
          for (var i = this.groupSizes, s = i.length, o = s; n >= o; )
            (o <<= 1) < 0 && Tp(16, '' + n);
          (this.groupSizes = new Uint32Array(o)), this.groupSizes.set(i), (this.length = o);
          for (var a = s; a < o; a++) this.groupSizes[a] = 0;
        }
        for (var c = this.indexOfGroup(n + 1), u = 0, l = r.length; u < l; u++)
          this.tag.insertRule(c, r[u]) && (this.groupSizes[n]++, c++);
      }),
      (t.clearGroup = function (n) {
        if (n < this.length) {
          var r = this.groupSizes[n],
            i = this.indexOfGroup(n),
            s = i + r;
          this.groupSizes[n] = 0;
          for (var o = i; o < s; o++) this.tag.deleteRule(i);
        }
      }),
      (t.getGroup = function (n) {
        var r = '';
        if (n >= this.length || this.groupSizes[n] === 0) return r;
        for (var i = this.groupSizes[n], s = this.indexOfGroup(n), o = s + i, a = s; a < o; a++)
          r +=
            this.tag.getRule(a) +
            `/*!sc*/
`;
        return r;
      }),
      e
    );
  })(),
  cy = new Map(),
  Zy = new Map(),
  Vl = 1,
  bg = function (e) {
    if (cy.has(e)) return cy.get(e);
    for (; Zy.has(Vl); ) Vl++;
    var t = Vl++;
    return cy.set(e, t), Zy.set(t, e), t;
  },
  cpe = function (e) {
    return Zy.get(e);
  },
  upe = function (e, t) {
    t >= Vl && (Vl = t + 1), cy.set(e, t), Zy.set(t, e);
  },
  lpe = 'style[' + Bu + '][data-styled-version="5.3.3"]',
  dpe = new RegExp('^' + Bu + '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)'),
  fpe = function (e, t, n) {
    for (var r, i = n.split(','), s = 0, o = i.length; s < o; s++)
      (r = i[s]) && e.registerName(t, r);
  },
  hpe = function (e, t) {
    for (
      var n = (t.textContent || '').split(`/*!sc*/
`),
        r = [],
        i = 0,
        s = n.length;
      i < s;
      i++
    ) {
      var o = n[i].trim();
      if (o) {
        var a = o.match(dpe);
        if (a) {
          var c = 0 | parseInt(a[1], 10),
            u = a[2];
          c !== 0 && (upe(u, c), fpe(e, u, a[3]), e.getTag().insertRules(c, r)), (r.length = 0);
        } else r.push(o);
      }
    }
  },
  ppe = function () {
    return typeof window < 'u' && window.__webpack_nonce__ !== void 0
      ? window.__webpack_nonce__
      : null;
  },
  hR = function (e) {
    var t = document.head,
      n = e || t,
      r = document.createElement('style'),
      i = (function (a) {
        for (var c = a.childNodes, u = c.length; u >= 0; u--) {
          var l = c[u];
          if (l && l.nodeType === 1 && l.hasAttribute(Bu)) return l;
        }
      })(n),
      s = i !== void 0 ? i.nextSibling : null;
    r.setAttribute(Bu, 'active'), r.setAttribute('data-styled-version', '5.3.3');
    var o = ppe();
    return o && r.setAttribute('nonce', o), n.insertBefore(r, s), r;
  },
  gpe = (function () {
    function e(n) {
      var r = (this.element = hR(n));
      r.appendChild(document.createTextNode('')),
        (this.sheet = (function (i) {
          if (i.sheet) return i.sheet;
          for (var s = document.styleSheets, o = 0, a = s.length; o < a; o++) {
            var c = s[o];
            if (c.ownerNode === i) return c;
          }
          Tp(17);
        })(r)),
        (this.length = 0);
    }
    var t = e.prototype;
    return (
      (t.insertRule = function (n, r) {
        try {
          return this.sheet.insertRule(r, n), this.length++, !0;
        } catch {
          return !1;
        }
      }),
      (t.deleteRule = function (n) {
        this.sheet.deleteRule(n), this.length--;
      }),
      (t.getRule = function (n) {
        var r = this.sheet.cssRules[n];
        return r !== void 0 && typeof r.cssText == 'string' ? r.cssText : '';
      }),
      e
    );
  })(),
  ype = (function () {
    function e(n) {
      var r = (this.element = hR(n));
      (this.nodes = r.childNodes), (this.length = 0);
    }
    var t = e.prototype;
    return (
      (t.insertRule = function (n, r) {
        if (n <= this.length && n >= 0) {
          var i = document.createTextNode(r),
            s = this.nodes[n];
          return this.element.insertBefore(i, s || null), this.length++, !0;
        }
        return !1;
      }),
      (t.deleteRule = function (n) {
        this.element.removeChild(this.nodes[n]), this.length--;
      }),
      (t.getRule = function (n) {
        return n < this.length ? this.nodes[n].textContent : '';
      }),
      e
    );
  })(),
  bpe = (function () {
    function e(n) {
      (this.rules = []), (this.length = 0);
    }
    var t = e.prototype;
    return (
      (t.insertRule = function (n, r) {
        return n <= this.length && (this.rules.splice(n, 0, r), this.length++, !0);
      }),
      (t.deleteRule = function (n) {
        this.rules.splice(n, 1), this.length--;
      }),
      (t.getRule = function (n) {
        return n < this.length ? this.rules[n] : '';
      }),
      e
    );
  })(),
  M3 = iT,
  mpe = { isServer: !iT, useCSSOMInjection: !ope },
  pR = (function () {
    function e(n, r, i) {
      n === void 0 && (n = la),
        r === void 0 && (r = {}),
        (this.options = Qs({}, mpe, {}, n)),
        (this.gs = r),
        (this.names = new Map(i)),
        (this.server = !!n.isServer),
        !this.server &&
          iT &&
          M3 &&
          ((M3 = !1),
          (function (s) {
            for (var o = document.querySelectorAll(lpe), a = 0, c = o.length; a < c; a++) {
              var u = o[a];
              u &&
                u.getAttribute(Bu) !== 'active' &&
                (hpe(s, u), u.parentNode && u.parentNode.removeChild(u));
            }
          })(this));
    }
    e.registerId = function (n) {
      return bg(n);
    };
    var t = e.prototype;
    return (
      (t.reconstructWithOptions = function (n, r) {
        return (
          r === void 0 && (r = !0),
          new e(Qs({}, this.options, {}, n), this.gs, (r && this.names) || void 0)
        );
      }),
      (t.allocateGSInstance = function (n) {
        return (this.gs[n] = (this.gs[n] || 0) + 1);
      }),
      (t.getTag = function () {
        return (
          this.tag ||
          (this.tag =
            ((i = (r = this.options).isServer),
            (s = r.useCSSOMInjection),
            (o = r.target),
            (n = i ? new bpe(o) : s ? new gpe(o) : new ype(o)),
            new ape(n)))
        );
        var n, r, i, s, o;
      }),
      (t.hasNameForId = function (n, r) {
        return this.names.has(n) && this.names.get(n).has(r);
      }),
      (t.registerName = function (n, r) {
        if ((bg(n), this.names.has(n))) this.names.get(n).add(r);
        else {
          var i = new Set();
          i.add(r), this.names.set(n, i);
        }
      }),
      (t.insertRules = function (n, r, i) {
        this.registerName(n, r), this.getTag().insertRules(bg(n), i);
      }),
      (t.clearNames = function (n) {
        this.names.has(n) && this.names.get(n).clear();
      }),
      (t.clearRules = function (n) {
        this.getTag().clearGroup(bg(n)), this.clearNames(n);
      }),
      (t.clearTag = function () {
        this.tag = void 0;
      }),
      (t.toString = function () {
        return (function (n) {
          for (var r = n.getTag(), i = r.length, s = '', o = 0; o < i; o++) {
            var a = cpe(o);
            if (a !== void 0) {
              var c = n.names.get(a),
                u = r.getGroup(o);
              if (c && u && c.size) {
                var l = Bu + '.g' + o + '[id="' + a + '"]',
                  d = '';
                c !== void 0 &&
                  c.forEach(function (f) {
                    f.length > 0 && (d += f + ',');
                  }),
                  (s +=
                    '' +
                    u +
                    l +
                    '{content:"' +
                    d +
                    `"}/*!sc*/
`);
              }
            }
          }
          return s;
        })(this);
      }),
      e
    );
  })(),
  wpe = /(a)(d)/gi,
  O3 = function (e) {
    return String.fromCharCode(e + (e > 25 ? 39 : 97));
  };
function vE(e) {
  var t,
    n = '';
  for (t = Math.abs(e); t > 52; t = (t / 52) | 0) n = O3(t % 52) + n;
  return (O3(t % 52) + n).replace(wpe, '$1-$2');
}
var Jc = function (e, t) {
    for (var n = t.length; n; ) e = (33 * e) ^ t.charCodeAt(--n);
    return e;
  },
  gR = function (e) {
    return Jc(5381, e);
  };
function vpe(e) {
  for (var t = 0; t < e.length; t += 1) {
    var n = e[t];
    if (cd(n) && !rT(n)) return !1;
  }
  return !0;
}
var _pe = gR('5.3.3'),
  Spe = (function () {
    function e(t, n, r) {
      (this.rules = t),
        (this.staticRulesId = ''),
        (this.isStatic = (r === void 0 || r.isStatic) && vpe(t)),
        (this.componentId = n),
        (this.baseHash = Jc(_pe, n)),
        (this.baseStyle = r),
        pR.registerId(n);
    }
    return (
      (e.prototype.generateAndInjectStyles = function (t, n, r) {
        var i = this.componentId,
          s = [];
        if (
          (this.baseStyle && s.push(this.baseStyle.generateAndInjectStyles(t, n, r)),
          this.isStatic && !r.hash)
        )
          if (this.staticRulesId && n.hasNameForId(i, this.staticRulesId))
            s.push(this.staticRulesId);
          else {
            var o = Du(this.rules, t, n, r).join(''),
              a = vE(Jc(this.baseHash, o) >>> 0);
            if (!n.hasNameForId(i, a)) {
              var c = r(o, '.' + a, void 0, i);
              n.insertRules(i, a, c);
            }
            s.push(a), (this.staticRulesId = a);
          }
        else {
          for (
            var u = this.rules.length, l = Jc(this.baseHash, r.hash), d = '', f = 0;
            f < u;
            f++
          ) {
            var h = this.rules[f];
            if (typeof h == 'string') d += h;
            else if (h) {
              var p = Du(h, t, n, r),
                b = Array.isArray(p) ? p.join('') : p;
              (l = Jc(l, b + f)), (d += b);
            }
          }
          if (d) {
            var w = vE(l >>> 0);
            if (!n.hasNameForId(i, w)) {
              var A = r(d, '.' + w, void 0, i);
              n.insertRules(i, w, A);
            }
            s.push(w);
          }
        }
        return s.join(' ');
      }),
      e
    );
  })(),
  Epe = /^\s*\/\/.*$/gm,
  Ape = [':', '[', '.', '#'];
function Ipe(e) {
  var t,
    n,
    r,
    i,
    s = e === void 0 ? la : e,
    o = s.options,
    a = o === void 0 ? la : o,
    c = s.plugins,
    u = c === void 0 ? Yy : c,
    l = new npe(a),
    d = [],
    f = (function (b) {
      function w(A) {
        if (A)
          try {
            b(A + '}');
          } catch {}
      }
      return function (A, _, x, k, j, F, K, D, C, B) {
        switch (A) {
          case 1:
            if (C === 0 && _.charCodeAt(0) === 64) return b(_ + ';'), '';
            break;
          case 2:
            if (D === 0) return _ + '/*|*/';
            break;
          case 3:
            switch (D) {
              case 102:
              case 112:
                return b(x[0] + _), '';
              default:
                return _ + (B === 0 ? '/*|*/' : '');
            }
          case -2:
            _.split('/*|*/}').forEach(w);
        }
      };
    })(function (b) {
      d.push(b);
    }),
    h = function (b, w, A) {
      return (w === 0 && Ape.indexOf(A[n.length]) !== -1) || A.match(i) ? b : '.' + t;
    };
  function p(b, w, A, _) {
    _ === void 0 && (_ = '&');
    var x = b.replace(Epe, ''),
      k = w && A ? A + ' ' + w + ' { ' + x + ' }' : x;
    return (
      (t = _),
      (n = w),
      (r = new RegExp('\\' + n + '\\b', 'g')),
      (i = new RegExp('(\\' + n + '\\b){2,}')),
      l(A || !w ? '' : w, k)
    );
  }
  return (
    l.use(
      [].concat(u, [
        function (b, w, A) {
          b === 2 && A.length && A[0].lastIndexOf(n) > 0 && (A[0] = A[0].replace(r, h));
        },
        f,
        function (b) {
          if (b === -2) {
            var w = d;
            return (d = []), w;
          }
        },
      ])
    ),
    (p.hash = u.length
      ? u
          .reduce(function (b, w) {
            return w.name || Tp(15), Jc(b, w.name);
          }, 5381)
          .toString()
      : ''),
    p
  );
}
var yR = Kn.createContext();
yR.Consumer;
var bR = Kn.createContext(),
  Tpe = (bR.Consumer, new pR()),
  _E = Ipe();
function xpe() {
  return W.useContext(yR) || Tpe;
}
function kpe() {
  return W.useContext(bR) || _E;
}
var Cpe = (function () {
    function e(t, n) {
      var r = this;
      (this.inject = function (i, s) {
        s === void 0 && (s = _E);
        var o = r.name + s.hash;
        i.hasNameForId(r.id, o) || i.insertRules(r.id, o, s(r.rules, o, '@keyframes'));
      }),
        (this.toString = function () {
          return Tp(12, String(r.name));
        }),
        (this.name = t),
        (this.id = 'sc-keyframes-' + t),
        (this.rules = n);
    }
    return (
      (e.prototype.getName = function (t) {
        return t === void 0 && (t = _E), this.name + t.hash;
      }),
      e
    );
  })(),
  Ppe = /([A-Z])/,
  Mpe = /([A-Z])/g,
  Ope = /^ms-/,
  Bpe = function (e) {
    return '-' + e.toLowerCase();
  };
function B3(e) {
  return Ppe.test(e) ? e.replace(Mpe, Bpe).replace(Ope, '-ms-') : e;
}
var D3 = function (e) {
  return e == null || e === !1 || e === '';
};
function Du(e, t, n, r) {
  if (Array.isArray(e)) {
    for (var i, s = [], o = 0, a = e.length; o < a; o += 1)
      (i = Du(e[o], t, n, r)) !== '' && (Array.isArray(i) ? s.push.apply(s, i) : s.push(i));
    return s;
  }
  if (D3(e)) return '';
  if (rT(e)) return '.' + e.styledComponentId;
  if (cd(e)) {
    if (typeof (u = e) != 'function' || (u.prototype && u.prototype.isReactComponent) || !t)
      return e;
    var c = e(t);
    return Du(c, t, n, r);
  }
  var u;
  return e instanceof Cpe
    ? n
      ? (e.inject(n, r), e.getName(r))
      : e
    : wE(e)
      ? (function l(d, f) {
          var h,
            p,
            b = [];
          for (var w in d)
            d.hasOwnProperty(w) &&
              !D3(d[w]) &&
              ((Array.isArray(d[w]) && d[w].isCss) || cd(d[w])
                ? b.push(B3(w) + ':', d[w], ';')
                : wE(d[w])
                  ? b.push.apply(b, l(d[w], w))
                  : b.push(
                      B3(w) +
                        ': ' +
                        ((h = w),
                        (p = d[w]) == null || typeof p == 'boolean' || p === ''
                          ? ''
                          : typeof p != 'number' || p === 0 || h in rpe
                            ? String(p).trim()
                            : p + 'px') +
                        ';'
                    ));
          return f ? [f + ' {'].concat(b, ['}']) : b;
        })(e)
      : e.toString();
}
var R3 = function (e) {
  return Array.isArray(e) && (e.isCss = !0), e;
};
function Dpe(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  return cd(e) || wE(e)
    ? R3(Du(C3(Yy, [e].concat(n))))
    : n.length === 0 && e.length === 1 && typeof e[0] == 'string'
      ? e
      : R3(Du(C3(e, n)));
}
var Rpe = function (e, t, n) {
    return n === void 0 && (n = la), (e.theme !== n.theme && e.theme) || t || n.theme;
  },
  Npe = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g,
  jpe = /(^-|-$)/g;
function Jv(e) {
  return e.replace(Npe, '-').replace(jpe, '');
}
var Lpe = function (e) {
  return vE(gR(e) >>> 0);
};
function mg(e) {
  return typeof e == 'string' && !0;
}
var SE = function (e) {
    return typeof e == 'function' || (typeof e == 'object' && e !== null && !Array.isArray(e));
  },
  Upe = function (e) {
    return e !== '__proto__' && e !== 'constructor' && e !== 'prototype';
  };
function $pe(e, t, n) {
  var r = e[n];
  SE(t) && SE(r) ? mR(r, t) : (e[n] = t);
}
function mR(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  for (var i = 0, s = n; i < s.length; i++) {
    var o = s[i];
    if (SE(o)) for (var a in o) Upe(a) && $pe(e, o[a], a);
  }
  return e;
}
var wR = Kn.createContext();
wR.Consumer;
var Xv = {};
function vR(e, t, n) {
  var r = rT(e),
    i = !mg(e),
    s = t.attrs,
    o = s === void 0 ? Yy : s,
    a = t.componentId,
    c =
      a === void 0
        ? (function (_, x) {
            var k = typeof _ != 'string' ? 'sc' : Jv(_);
            Xv[k] = (Xv[k] || 0) + 1;
            var j = k + '-' + Lpe('5.3.3' + k + Xv[k]);
            return x ? x + '-' + j : j;
          })(t.displayName, t.parentComponentId)
        : a,
    u = t.displayName,
    l =
      u === void 0
        ? (function (_) {
            return mg(_) ? 'styled.' + _ : 'Styled(' + P3(_) + ')';
          })(e)
        : u,
    d =
      t.displayName && t.componentId ? Jv(t.displayName) + '-' + t.componentId : t.componentId || c,
    f = r && e.attrs ? Array.prototype.concat(e.attrs, o).filter(Boolean) : o,
    h = t.shouldForwardProp;
  r &&
    e.shouldForwardProp &&
    (h = t.shouldForwardProp
      ? function (_, x, k) {
          return e.shouldForwardProp(_, x, k) && t.shouldForwardProp(_, x, k);
        }
      : e.shouldForwardProp);
  var p,
    b = new Spe(n, d, r ? e.componentStyle : void 0),
    w = b.isStatic && o.length === 0,
    A = function (_, x) {
      return (function (k, j, F, K) {
        var D = k.attrs,
          C = k.componentStyle,
          B = k.defaultProps,
          E = k.foldedComponentIds,
          y = k.shouldForwardProp,
          v = k.styledComponentId,
          S = k.target,
          T = (function (ie, Z, be) {
            ie === void 0 && (ie = la);
            var le = Qs({}, Z, { theme: ie }),
              Oe = {};
            return (
              be.forEach(function (Re) {
                var ht,
                  xe,
                  We,
                  Yt = Re;
                for (ht in (cd(Yt) && (Yt = Yt(le)), Yt))
                  le[ht] = Oe[ht] =
                    ht === 'className'
                      ? ((xe = Oe[ht]), (We = Yt[ht]), xe && We ? xe + ' ' + We : xe || We)
                      : Yt[ht];
              }),
              [le, Oe]
            );
          })(Rpe(j, W.useContext(wR), B) || la, j, D),
          M = T[0],
          R = T[1],
          L = (function (ie, Z, be, le) {
            var Oe = xpe(),
              Re = kpe(),
              ht = Z
                ? ie.generateAndInjectStyles(la, Oe, Re)
                : ie.generateAndInjectStyles(be, Oe, Re);
            return ht;
          })(C, K, M),
          O = F,
          I = R.$as || j.$as || R.as || j.as || S,
          U = mg(I),
          H = R !== j ? Qs({}, j, {}, R) : j,
          X = {};
        for (var J in H)
          J[0] !== '$' &&
            J !== 'as' &&
            (J === 'forwardedAs'
              ? (X.as = H[J])
              : (y ? y(J, k3, I) : !U || k3(J)) && (X[J] = H[J]));
        return (
          j.style && R.style !== j.style && (X.style = Qs({}, j.style, {}, R.style)),
          (X.className = Array.prototype
            .concat(E, v, L !== v ? L : null, j.className, R.className)
            .filter(Boolean)
            .join(' ')),
          (X.ref = O),
          W.createElement(I, X)
        );
      })(p, _, x, w);
    };
  return (
    (A.displayName = l),
    ((p = Kn.forwardRef(A)).attrs = f),
    (p.componentStyle = b),
    (p.displayName = l),
    (p.shouldForwardProp = h),
    (p.foldedComponentIds = r
      ? Array.prototype.concat(e.foldedComponentIds, e.styledComponentId)
      : Yy),
    (p.styledComponentId = d),
    (p.target = r ? e.target : e),
    (p.withComponent = function (_) {
      var x = t.componentId,
        k = (function (F, K) {
          if (F == null) return {};
          var D,
            C,
            B = {},
            E = Object.keys(F);
          for (C = 0; C < E.length; C++) (D = E[C]), K.indexOf(D) >= 0 || (B[D] = F[D]);
          return B;
        })(t, ['componentId']),
        j = x && x + '-' + (mg(_) ? _ : Jv(P3(_)));
      return vR(_, Qs({}, k, { attrs: f, componentId: j }), n);
    }),
    Object.defineProperty(p, 'defaultProps', {
      get: function () {
        return this._foldedDefaultProps;
      },
      set: function (_) {
        this._foldedDefaultProps = r ? mR({}, e.defaultProps, _) : _;
      },
    }),
    (p.toString = function () {
      return '.' + p.styledComponentId;
    }),
    i &&
      JL(p, e, {
        attrs: !0,
        componentStyle: !0,
        displayName: !0,
        foldedComponentIds: !0,
        shouldForwardProp: !0,
        styledComponentId: !0,
        target: !0,
        withComponent: !0,
      }),
    p
  );
}
var _s = function (e) {
  return (function t(n, r, i) {
    if ((i === void 0 && (i = la), !fR.isValidElementType(r))) return Tp(1, String(r));
    var s = function () {
      return n(r, i, Dpe.apply(void 0, arguments));
    };
    return (
      (s.withConfig = function (o) {
        return t(n, r, Qs({}, i, {}, o));
      }),
      (s.attrs = function (o) {
        return t(n, r, Qs({}, i, { attrs: Array.prototype.concat(i.attrs, o).filter(Boolean) }));
      }),
      s
    );
  })(vR, e);
};
[
  'a',
  'abbr',
  'address',
  'area',
  'article',
  'aside',
  'audio',
  'b',
  'base',
  'bdi',
  'bdo',
  'big',
  'blockquote',
  'body',
  'br',
  'button',
  'canvas',
  'caption',
  'cite',
  'code',
  'col',
  'colgroup',
  'data',
  'datalist',
  'dd',
  'del',
  'details',
  'dfn',
  'dialog',
  'div',
  'dl',
  'dt',
  'em',
  'embed',
  'fieldset',
  'figcaption',
  'figure',
  'footer',
  'form',
  'h1',
  'h2',
  'h3',
  'h4',
  'h5',
  'h6',
  'head',
  'header',
  'hgroup',
  'hr',
  'html',
  'i',
  'iframe',
  'img',
  'input',
  'ins',
  'kbd',
  'keygen',
  'label',
  'legend',
  'li',
  'link',
  'main',
  'map',
  'mark',
  'marquee',
  'menu',
  'menuitem',
  'meta',
  'meter',
  'nav',
  'noscript',
  'object',
  'ol',
  'optgroup',
  'option',
  'output',
  'p',
  'param',
  'picture',
  'pre',
  'progress',
  'q',
  'rp',
  'rt',
  'ruby',
  's',
  'samp',
  'script',
  'section',
  'select',
  'small',
  'source',
  'span',
  'strong',
  'style',
  'sub',
  'summary',
  'sup',
  'table',
  'tbody',
  'td',
  'textarea',
  'tfoot',
  'th',
  'thead',
  'time',
  'title',
  'tr',
  'track',
  'u',
  'ul',
  'var',
  'video',
  'wbr',
  'circle',
  'clipPath',
  'defs',
  'ellipse',
  'foreignObject',
  'g',
  'image',
  'line',
  'linearGradient',
  'marker',
  'mask',
  'path',
  'pattern',
  'polygon',
  'polyline',
  'radialGradient',
  'rect',
  'stop',
  'svg',
  'text',
  'textPath',
  'tspan',
].forEach(function (e) {
  _s[e] = _s(e);
});
const Jy = (e, t, n = !1) => {
    const r = Math.max(t, eT.large);
    return e.endsWith('.ico') ? e : Hj(e, r, r, !n);
  },
  _R = _s.svg`
  display: inline-flex;
  width: ${({ responsive: e, size: t }) => (e ? '100%' : t)};

  g {
    transform-origin: center;
  }

  g,
  rect,
  circle,
  use,
  symbol {
    transition-property: fill, stroke, opacity, filter;
    transition-timing-function: cubic-bezier(0.16, 1, 0.3, 1); // ease-out-expo https://easings.net/#easeOutExpo
    transition-duration: 500ms;
  }

  @keyframes opacity {
    0% {
      opacity: 1;
    }
    100% {
      opacity: 0.5;
    }
  }

  .background.loading {
    animation: opacity 1s ease-in-out alternate infinite;
    fill: rgba(from ${Le.colors.legacy.white} r g b / 10%);
  }

  img {
    transition:
      filter 200ms ease-out,
      opacity 100ms ease-out;
  }

  img.loading {
    opacity: 0;
    filter: blur(6px);
  }
`,
  SR = (e, t) => `
@keyframes rotation-${e} {
  0% {
    stroke-dashoffset: ${t(0)};
  }
  100% {
    stroke-dashoffset: -${t(100)};
  }
}

@keyframes size-${e} {
  0%,
  100% {
    stroke-dasharray: ${t(10)}, ${t(90)};
  }
  33% {
    stroke-dasharray: ${t(75)}, ${t(25)};
  }
}

.${e} {
  animation: rotation-${e} 1s linear infinite, size-${e} 3s ease-in-out infinite;
}
`,
  Fpe = _s.span`
  box-sizing: border-box;
  color: ${({ color: e }) => e};
  display: inline-block;
  font-size: ${({ size: e }) => Math.round(e / 4)}px;
  font-weight: 600;
  letter-spacing: -0.05em;
  line-height: ${({ size: e }) => e}px;
  overflow: hidden;
  padding: 0 ${({ size: e }) => Math.round(e * 0.1)}px;
  text-align: center;
  text-overflow: ellipsis;
  user-select: none;
  white-space: nowrap;
  width: 100%;
`,
  zpe = W.memo(({ content: e, size: t, color: n }) =>
    P.jsx('foreignObject', {
      width: '100%',
      height: '100%',
      children: P.jsx(Fpe, {
        size: t,
        color: n,
        children: e.replaceAll(' ', '').slice(0, 5).trim(),
      }),
    })
  ),
  N3 = (e, t, n, r = !1) => {
    const [i, s] = W.useState(void 0),
      [o, a] = W.useState(Jy(e, t, r)),
      [c, u] = W.useState(e);
    e !== c && (u(e), s(void 0), a(Jy(e, t, r)));
    const l = W.useCallback(() => {
        s('fail'), n && n();
      }, [n]),
      d = W.useCallback(() => s('success'), []);
    return { src: o, status: i, handleError: l, handleLoad: d };
  },
  j3 = {
    18: 'M0 9C0 6.20435 0 4.80653 0.456723 3.7039C1.06569 2.23373 2.23373 1.06569 3.7039 0.456723C4.80653 0 6.20435 0 9 0C11.7956 0 13.1935 0 14.2961 0.456723C15.7663 1.06569 16.9343 2.23373 17.5433 3.7039C18 4.80653 18 6.20435 18 9C18 11.7956 18 13.1935 17.5433 14.2961C16.9343 15.7663 15.7663 16.9343 14.2961 17.5433C13.1935 18 11.7956 18 9 18C6.20435 18 4.80653 18 3.7039 17.5433C2.23373 16.9343 1.06569 15.7663 0.456723 14.2961C0 13.1935 0 11.7956 0 9Z',
    24: 'M0 12C0 8.27247 0 6.4087 0.608964 4.93853C1.42092 2.97831 2.97831 1.42092 4.93853 0.608964C6.4087 0 8.27247 0 12 0C15.7275 0 17.5913 0 19.0615 0.608964C21.0217 1.42092 22.5791 2.97831 23.391 4.93853C24 6.4087 24 8.27247 24 12C24 15.7275 24 17.5913 23.391 19.0615C22.5791 21.0217 21.0217 22.5791 19.0615 23.391C17.5913 24 15.7275 24 12 24C8.27247 24 6.4087 24 4.93853 23.391C2.97831 22.5791 1.42092 21.0217 0.608964 19.0615C0 17.5913 0 15.7275 0 12Z',
    40: 'M0 19.2C0 12.4794 0 9.11906 1.30792 6.55211C2.4584 4.29417 4.29417 2.4584 6.55211 1.30792C9.11906 0 12.4794 0 19.2 0H20.8C27.5206 0 30.8809 0 33.4479 1.30792C35.7058 2.4584 37.5416 4.29417 38.6921 6.55211C40 9.11906 40 12.4794 40 19.2V20.8C40 27.5206 40 30.8809 38.6921 33.4479C37.5416 35.7058 35.7058 37.5416 33.4479 38.6921C30.8809 40 27.5206 40 20.8 40H19.2C12.4794 40 9.11906 40 6.55211 38.6921C4.29417 37.5416 2.4584 35.7058 1.30792 33.4479C0 30.8809 0 27.5206 0 20.8V19.2Z',
    48: 'M0 24C0 16.5449 0 12.8174 1.21793 9.87706C2.84183 5.95662 5.95662 2.84183 9.87706 1.21793C12.8174 0 16.5449 0 24 0C31.4551 0 35.1826 0 38.1229 1.21793C42.0434 2.84183 45.1582 5.95662 46.7821 9.87706C48 12.8174 48 16.5449 48 24C48 31.4551 48 35.1826 46.7821 38.1229C45.1582 42.0434 42.0434 45.1582 38.1229 46.7821C35.1826 48 31.4551 48 24 48C16.5449 48 12.8174 48 9.87706 46.7821C5.95662 45.1582 2.84183 42.0434 1.21793 38.1229C0 35.1826 0 31.4551 0 24Z',
    64: 'M0 32C0 22.6872 0 18.0308 1.38711 14.3118C3.61706 8.33304 8.33304 3.61706 14.3118 1.38711C18.0308 0 22.6872 0 32 0C41.3128 0 45.9692 0 49.6882 1.38711C55.667 3.61706 60.3829 8.33304 62.6129 14.3118C64 18.0308 64 22.6872 64 32C64 41.3128 64 45.9692 62.6129 49.6882C60.3829 55.667 55.667 60.3829 49.6882 62.6129C45.9692 64 41.3128 64 32 64C22.6872 64 18.0308 64 14.3118 62.6129C8.33304 60.3829 3.61706 55.667 1.38711 49.6882C0 45.9692 0 41.3128 0 32Z',
  },
  Kpe = `rgba(from ${Le.colors.legacy.white} r g b / 4%)`,
  Vpe = Le.colors.legacy.white,
  Wpe = Le.colors.legacy.white,
  Hpe = Le.colors.legacy.black,
  ER = (e) => {
    const t = IL(),
      n = `img-m-${t}`,
      r = `img-s-${t}`,
      i = `bdg-s-${t}`,
      s = `bdg-m-${t}`,
      o = `spnr-r-${t}`,
      a = Math.max(8, Math.round(e * 0.2)),
      c = 1 + a / 10,
      u = c + a / 20,
      l = (e / 3) * 2,
      d = Math.round(a * 0.75 * 2),
      f = e / 2,
      h = (e - l) / 2,
      p = f,
      b = a * 2,
      w = e - b + u,
      A = e - a + u,
      _ = w + (b - d) / 2,
      x = w - c,
      k = 2 * c + b,
      j = c + b,
      F = (C) => {
        const B = parseInt(
          Object.keys(j3).reduce((E, y) =>
            Math.abs(parseInt(y) - C) < Math.abs(parseInt(E) - C) ? y : E
          )
        );
        return { viewBox: `0 0 ${B} ${B}`, path: j3[B] };
      },
      K = F(e),
      D = F(b);
    return {
      badgeBorder: c,
      badgeBoxXY: w,
      badgeCXY: A,
      badgeIconOffset: _,
      badgeIconSize: d,
      badgeMaskBoxXY: x,
      badgeMaskId: s,
      badgeMaskSize: k,
      badgeOvershoot: u,
      badgeRadius: a,
      badgeRect: D,
      badgeShapeId: i,
      badgeSize: b,
      badgeSpinnerSize: j,
      fallbackBadgeBgColor: Wpe,
      fallbackBadgeFgColor: Hpe,
      fallbackBgColor: Kpe,
      fallbackFgColor: Vpe,
      imageCXY: f,
      imageIconOffset: h,
      imageIconSize: l,
      imageMaskId: n,
      imageRadius: p,
      imageRect: K,
      imageShapeId: r,
      spinnerId: o,
    };
  },
  Gpe = W.memo(
    ({
      size: e = eT.small,
      image: t,
      badge: n,
      responsive: r = !1,
      loading: i = !1,
      dimmed: s = !1,
      enableAnimations: o = !1,
      onError: a,
      className: c,
      onClick: u,
    }) => {
      const {
          badgeBorder: l,
          badgeBoxXY: d,
          badgeIconOffset: f,
          badgeIconSize: h,
          badgeMaskBoxXY: p,
          badgeMaskId: b,
          badgeMaskSize: w,
          badgeRadius: A,
          badgeRect: _,
          badgeShapeId: x,
          badgeSize: k,
          badgeSpinnerSize: j,
          fallbackBadgeBgColor: F,
          fallbackBadgeFgColor: K,
          fallbackBgColor: D,
          fallbackFgColor: C,
          imageCXY: B,
          imageIconOffset: E,
          imageIconSize: y,
          imageMaskId: v,
          imageRadius: S,
          imageRect: T,
          imageShapeId: M,
          spinnerId: R,
        } = ER(e),
        L = N3(typeof t.src == 'string' ? t.src : '', e, a, o),
        O = N3(typeof (n == null ? void 0 : n.src) == 'string' ? n.src : '', k),
        I = (J) => {
          if ((n == null ? void 0 : n.shape) === 'square') return k * (4 - e / 60) * (J / 100);
          {
            const ie = n ? A : y / 2;
            return 2 * Math.PI * ie * (J / 100);
          }
        },
        U = W.useCallback((J) => {
          J.preventDefault();
        }, []),
        H = Gj,
        X = W.useCallback(
          (J) => {
            u && u(J);
          },
          [u]
        );
      return P.jsxs(_R, {
        className: c,
        fill: 'none',
        overflow: 'visible',
        responsive: r,
        size: e,
        viewBox: `0 0 ${e} ${e}`,
        width: e,
        xmlns: 'http://www.w3.org/2000/svg',
        onClick: X,
        style: { cursor: u ? 'pointer' : 'default' },
        children: [
          P.jsxs('defs', {
            children: [
              P.jsx('style', { children: SR(R, I) }),
              i &&
                P.jsxs('symbol', {
                  id: R,
                  viewBox: `0 0 ${e} ${e}`,
                  overflow: 'visible',
                  children: [
                    !n &&
                      P.jsxs(P.Fragment, {
                        children: [
                          P.jsx('circle', {
                            cx: B,
                            cy: B,
                            fill: 'none',
                            r: y / 2,
                            stroke:
                              typeof t.src == 'function' ? (t == null ? void 0 : t.fgColor) : C,
                            strokeLinecap: 'round',
                            strokeOpacity: '0.25',
                            strokeWidth: l,
                          }),
                          P.jsx('circle', {
                            className: R,
                            cx: B,
                            cy: B,
                            fill: 'none',
                            r: y / 2,
                            stroke:
                              typeof t.src == 'function' ? (t == null ? void 0 : t.fgColor) : C,
                            strokeLinecap: 'round',
                            strokeWidth: l,
                          }),
                        ],
                      }),
                    n &&
                      P.jsx('use', {
                        className: R,
                        fill: 'none',
                        height: j,
                        href: `#${x}`,
                        strokeWidth: l,
                        stroke: (n && 'bgColor' in n && n.bgColor) || t.fgColor || C,
                        strokeLinecap: 'round',
                        width: j,
                        x: p + l / 2,
                        y: p + l / 2,
                      }),
                  ],
                }),
              t.shape === 'circle' &&
                P.jsx('symbol', {
                  id: M,
                  viewBox: `0 0 ${e} ${e}`,
                  overflow: 'visible',
                  children: P.jsx('circle', { cx: S, cy: S, r: S }),
                }),
              t.shape === 'square' &&
                P.jsx('symbol', {
                  id: M,
                  viewBox: T.viewBox,
                  overflow: 'visible',
                  children: P.jsx('path', { d: T.path }),
                }),
              n &&
                O.status !== 'fail' &&
                P.jsxs(P.Fragment, {
                  children: [
                    n.shape === 'circle' &&
                      P.jsx('symbol', {
                        id: x,
                        viewBox: `0 0 ${k} ${k}`,
                        overflow: 'visible',
                        children: P.jsx('circle', { cx: A, cy: A, r: A }),
                      }),
                    n.shape === 'square' &&
                      P.jsx('symbol', {
                        id: x,
                        viewBox: _.viewBox,
                        overflow: 'visible',
                        children: P.jsx('path', { d: _.path }),
                      }),
                  ],
                }),
              P.jsxs('mask', {
                id: v,
                x: '0',
                y: '0',
                width: e,
                height: e,
                children: [
                  P.jsx('use', { href: `#${M}`, width: e, height: e, fill: 'white' }),
                  n &&
                    O.status !== 'fail' &&
                    P.jsx('use', { href: `#${x}`, x: p, y: p, width: w, height: w, fill: 'black' }),
                ],
              }),
              typeof (n == null ? void 0 : n.src) == 'string' &&
                P.jsx('mask', {
                  id: b,
                  children: P.jsx('use', {
                    href: `#${x}`,
                    x: d,
                    y: d,
                    width: k,
                    height: k,
                    fill: 'white',
                  }),
                }),
            ],
          }),
          P.jsxs('g', {
            mask: `url(#${v})`,
            opacity: i || s ? 0.5 : 1,
            style: { filter: s ? 'grayscale(100%)' : i ? 'grayscale(25%)' : '' },
            children: [
              !('fullSize' in t && t.fullSize) &&
                P.jsx('use', {
                  href: `#${M}`,
                  width: e,
                  height: e,
                  fill: t.bgColor || D,
                  className: `${L.status} background`,
                }),
              (L.status === 'fail' || t.src === null || t.src === void 0) &&
                ('fallback' in t && t.fallback
                  ? typeof t.fallback == 'string'
                    ? P.jsx(zpe, { content: t.fallback, size: e, color: t.fgColor || C })
                    : P.jsx('g', {
                        transform: `scale(${i ? 0.66 : 0.75}) translate(${E},${E})`,
                        opacity: '0.25',
                        children: t.fallback({ width: y, fill: t.fgColor || C }),
                      })
                  : P.jsxs('g', {
                      color: 'black',
                      width: 56,
                      children: [
                        P.jsx('use', { href: `#${M}`, width: e, height: e, fill: 'black' }),
                        P.jsx(H, { size: '50%', color: 'gray', x: '25%', y: '25%' }),
                      ],
                    })),
              typeof t.src == 'string' &&
                L.status !== 'fail' &&
                P.jsx('foreignObject', {
                  width: e,
                  height: e,
                  children: P.jsx('img', {
                    className: L.status,
                    crossOrigin: 'anonymous',
                    height: e,
                    onError: L.handleError,
                    onLoad: L.handleLoad,
                    src: L.src,
                    width: e,
                    onDragStart: U,
                  }),
                }),
              typeof t.src == 'function' &&
                ('fullSize' in t && t.fullSize
                  ? t.src({ width: e, height: e })
                  : P.jsx('g', {
                      transform: `${i && !n ? 'scale(0.66) ' : ''}translate(${E},${E})`,
                      children: t.src({
                        width: y,
                        height: y,
                        fill: ('fgColor' in t && t.fgColor) || C,
                      }),
                    })),
            ],
          }),
          n &&
            O.status !== 'fail' &&
            P.jsxs('g', {
              children: [
                P.jsx('use', {
                  href: `#${x}`,
                  opacity: i ? 0.2 : 1,
                  fill: i
                    ? 'transparent'
                    : typeof n.src == 'string' && O.status === 'success'
                      ? D
                      : n.bgColor || F,
                  x: d,
                  y: d,
                  width: k,
                  height: k,
                  className: `${O.status} background`,
                }),
                typeof n.src == 'string' &&
                  P.jsx('g', {
                    mask: `url(#${b})`,
                    children: P.jsx('foreignObject', {
                      x: d,
                      y: d,
                      width: k,
                      height: k,
                      children: P.jsx('img', {
                        className: O.status,
                        crossOrigin: 'anonymous',
                        height: k,
                        onError: O.handleError,
                        onLoad: O.handleLoad,
                        src: O.src,
                        width: k,
                      }),
                    }),
                  }),
                typeof n.src == 'function' &&
                  P.jsx('g', {
                    transform: `translate(${f},${f})`,
                    children: n.src({
                      width: h,
                      height: h,
                      fill: i
                        ? ('bgColor' in n && (n == null ? void 0 : n.bgColor)) || F
                        : ('fgColor' in n && n.fgColor) || K,
                    }),
                  }),
              ],
            }),
          i && P.jsx('use', { href: `#${R}`, x: '0', y: '0', width: e, height: e }),
        ],
      });
    }
  ),
  qpe = W.memo(
    ({
      size: e = eT.small,
      bgToken: t,
      fgToken: n,
      badge: r,
      responsive: i = !1,
      loading: s = !1,
      onError: o,
      className: a,
      onClick: c,
    }) => {
      const {
          badgeBorder: u,
          fallbackBgColor: l,
          fallbackFgColor: d,
          imageMaskId: f,
          badgeMaskId: h,
          spinnerId: p,
        } = ER(e),
        [b, w] = W.useState(void 0),
        [A, _] = W.useState(void 0),
        x = W.useCallback(
          (y) => {
            b === void 0 && w(y != null && y.complete ? 'success' : 'loading');
          },
          [b]
        ),
        k = W.useCallback(
          (y) => {
            A === void 0 && _(y != null && y.complete ? 'success' : 'loading');
          },
          [A]
        );
      if (b === 'fail' || A === 'fail')
        return P.jsx(il, {
          className: a,
          image: { type: 'icon', preset: 'swap' },
          badge: r,
          loading: s,
          onError: o,
          responsive: i,
          size: e,
        });
      const j = Math.round(e / 3.25),
        F = Math.round(e / 2.75),
        K = 2 * j,
        D = 2 * F,
        C = e - D,
        B = e - F,
        E = (y) => {
          const v = F + u / 2;
          return 2 * Math.PI * v * (y / 100);
        };
      return P.jsxs(_R, {
        className: a,
        fill: 'none',
        overflow: 'visible',
        responsive: i,
        size: e,
        viewBox: `0 0 ${e} ${e}`,
        width: e,
        xmlns: 'http://www.w3.org/2000/svg',
        onClick: c,
        style: { cursor: c ? 'pointer' : 'default' },
        children: [
          P.jsxs('defs', {
            children: [
              P.jsx('style', { children: SR(p, E) }),
              s &&
                P.jsx('symbol', {
                  id: p,
                  viewBox: `0 0 ${e} ${e}`,
                  overflow: 'visible',
                  children: P.jsx('circle', {
                    className: p,
                    cx: B,
                    cy: B,
                    fill: 'none',
                    r: F + u / 2,
                    stroke: d,
                    strokeLinecap: 'round',
                    strokeWidth: u,
                  }),
                }),
              P.jsxs('mask', {
                id: f,
                x: '0',
                y: '0',
                width: '100%',
                height: '100%',
                children: [
                  P.jsx('circle', { cx: j, cy: j, r: j, fill: 'white' }),
                  P.jsx('circle', { cx: B, cy: B, r: F + u, fill: 'black' }),
                ],
              }),
              P.jsx('mask', {
                id: h,
                x: '0',
                y: '0',
                width: '100%',
                height: '100%',
                children: P.jsx('circle', { cx: B, cy: B, r: F, fill: 'white' }),
              }),
            ],
          }),
          P.jsxs('g', {
            opacity: s ? 0.5 : 1,
            style: { filter: s ? 'grayscale(25%)' : '' },
            children: [
              P.jsxs('g', {
                mask: `url(#${f})`,
                children: [
                  P.jsx('circle', {
                    r: j,
                    cx: j,
                    cy: j,
                    fill: t.bgColor || l,
                    className: `${b} background`,
                  }),
                  typeof t.src == 'string'
                    ? P.jsx('foreignObject', {
                        width: K,
                        height: K,
                        children: P.jsx('img', {
                          width: K,
                          height: K,
                          src: Jy(t.src, K),
                          ref: x,
                          onError: () => {
                            w('fail'), o && o();
                          },
                          onLoad: () => w('success'),
                          className: b,
                        }),
                      })
                    : P.jsx('g', {
                        transform: `translate(${Math.floor(K / 6)}, ${Math.floor(K / 6)})`,
                        children: t.src({
                          width: Math.ceil(K / 3) * 2,
                          fill: ('fgColor' in t && t.fgColor) || d,
                        }),
                      }),
                ],
              }),
              P.jsx('g', {
                mask: `url(#${h})`,
                children: P.jsxs('g', {
                  transform: `translate(${C}, ${C})`,
                  children: [
                    P.jsx('circle', {
                      r: F,
                      cx: F,
                      cy: F,
                      fill: n.bgColor || l,
                      style: { filter: 'drop-shadow(-2px -2px 5px rgba(0, 0, 0, 0.33))' },
                      className: `${A} background`,
                    }),
                    typeof n.src == 'string'
                      ? P.jsx('foreignObject', {
                          width: D,
                          height: D,
                          children: P.jsx('img', {
                            src: Jy(n.src, D),
                            width: D,
                            height: D,
                            ref: k,
                            onError: () => {
                              _('fail'), o && o();
                            },
                            onLoad: () => _('success'),
                            className: A,
                          }),
                        })
                      : P.jsx('g', {
                          transform: `translate(${Math.floor(D / 6)}, ${Math.floor(D / 6)})`,
                          children: n.src({
                            width: Math.ceil(D / 3) * 2,
                            fill: ('fgColor' in n && n.fgColor) || d,
                          }),
                        }),
                  ],
                }),
              }),
            ],
          }),
          s && P.jsx('use', { href: `#${p}`, x: '0', y: '0', width: e, height: e }),
        ],
      });
    }
  ),
  Ype = _s.div`
  position: relative;
  height: ${(e) => e.diameter};
  width: ${(e) => e.diameter};
  background-color: ${(e) => e.color};
  border-radius: ${(e) => (e.shape === 'square' ? 20 : 50)}%;
  border: ${(e) => e.border};
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  opacity: ${(e) => e.opacity};
  mask: ${(e) => e.mask};
`;
Ype.defaultProps = { color: 'blue', shape: 'circle', diameter: '100%', border: 'none' };
const Zpe = ({ width: e = 94 }) =>
    P.jsxs('svg', {
      width: e,
      height: e,
      viewBox: '0 0 94 94',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: [
        P.jsx('g', {
          filter: 'url(#filter0_i)',
          children: P.jsx('circle', { cx: '47', cy: '47', r: '47', fill: '#000000' }),
        }),
        P.jsx('path', {
          d: 'M32.1506 56.7183C32.4198 56.4452 32.7848 56.2919 33.1654 56.2919H68.2807C68.9203 56.2919 69.2406 57.077 68.788 57.536L61.8494 64.5735C61.5801 64.8466 61.2151 65 60.8345 65H25.7193C25.0796 65 24.7594 64.2148 25.2119 63.7558L32.1506 56.7183Z',
          fill: 'url(#paint0_linear)',
        }),
        P.jsx('path', {
          d: 'M32.1507 30.4265C32.4199 30.1534 32.7849 30 33.1655 30H68.2807C68.9204 30 69.2406 30.7852 68.7881 31.2442L61.8494 38.2817C61.5802 38.5548 61.2152 38.7081 60.8346 38.7081H25.7194C25.0797 38.7081 24.7595 37.9229 25.2119 37.464L32.1507 30.4265Z',
          fill: 'url(#paint1_linear)',
        }),
        P.jsx('path', {
          d: 'M61.8494 43.4886C61.5801 43.2156 61.2151 43.0622 60.8345 43.0622H25.7193C25.0796 43.0622 24.7594 43.8474 25.2119 44.3063L32.1506 51.3439C32.4198 51.617 32.7848 51.7704 33.1654 51.7704H68.2807C68.9203 51.7704 69.2406 50.9852 68.788 50.5262L61.8494 43.4886Z',
          fill: 'url(#paint2_linear)',
        }),
        P.jsxs('defs', {
          children: [
            P.jsxs('filter', {
              id: 'filter0_i',
              x: '0',
              y: '0',
              width: '94',
              height: '94',
              filterUnits: 'userSpaceOnUse',
              colorInterpolationFilters: 'sRGB',
              children: [
                P.jsx('feFlood', { floodOpacity: '0', result: 'BackgroundImageFix' }),
                P.jsx('feBlend', {
                  mode: 'normal',
                  in: 'SourceGraphic',
                  in2: 'BackgroundImageFix',
                  result: 'shape',
                }),
                P.jsx('feColorMatrix', {
                  in: 'SourceAlpha',
                  type: 'matrix',
                  values: '0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0',
                  result: 'hardAlpha',
                }),
                P.jsx('feOffset', {}),
                P.jsx('feGaussianBlur', { stdDeviation: '2' }),
                P.jsx('feComposite', {
                  in2: 'hardAlpha',
                  operator: 'arithmetic',
                  k2: '-1',
                  k3: '1',
                }),
                P.jsx('feColorMatrix', {
                  type: 'matrix',
                  values: '0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0',
                }),
                P.jsx('feBlend', { mode: 'normal', in2: 'shape', result: 'effect1_innerShadow' }),
              ],
            }),
            P.jsxs('linearGradient', {
              id: 'paint0_linear',
              x1: '54.7466',
              y1: '20.3993',
              x2: '29.8682',
              y2: '67.3446',
              gradientUnits: 'userSpaceOnUse',
              children: [
                P.jsx('stop', { stopColor: '#00FFA3' }),
                P.jsx('stop', { offset: '1', stopColor: '#DC1FFF' }),
              ],
            }),
            P.jsxs('linearGradient', {
              id: 'paint1_linear',
              x1: '54.7466',
              y1: '20.3993',
              x2: '29.8682',
              y2: '67.3446',
              gradientUnits: 'userSpaceOnUse',
              children: [
                P.jsx('stop', { stopColor: '#00FFA3' }),
                P.jsx('stop', { offset: '1', stopColor: '#DC1FFF' }),
              ],
            }),
            P.jsxs('linearGradient', {
              id: 'paint2_linear',
              x1: '54.7466',
              y1: '20.3993',
              x2: '29.8682',
              y2: '67.3446',
              gradientUnits: 'userSpaceOnUse',
              children: [
                P.jsx('stop', { stopColor: '#00FFA3' }),
                P.jsx('stop', { offset: '1', stopColor: '#DC1FFF' }),
              ],
            }),
          ],
        }),
      ],
    }),
  Jpe = ({ width: e, fill: t = 'white' }) =>
    P.jsxs('svg', {
      width: e,
      height: e,
      viewBox: '0 0 24 24',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: [
        P.jsx('path', {
          d: 'M12 15.8204L18.1317 12.2036L12 2.00002L5.86826 12.2036L12 15.8204Z',
          fill: t,
        }),
        P.jsx('path', { d: 'M12 22L18.1317 13.3533L12 16.9701L5.86826 13.3533L12 22Z', fill: t }),
      ],
    }),
  Xpe = ({ width: e, fill: t = 'white' }) =>
    P.jsx('svg', {
      width: e,
      height: e,
      viewBox: '0 0 24 24',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: P.jsx('path', {
        d: 'M17.1436 8.57817C16.7781 8.36929 16.3081 8.36929 15.8904 8.57817L12.9661 10.3014L10.9817 11.398L8.10968 13.1212C7.74414 13.3301 7.27417 13.3301 6.85641 13.1212L4.61098 11.7635C4.24545 11.5547 3.98435 11.1369 3.98435 10.6669V8.05597C3.98435 7.63822 4.19323 7.22047 4.61098 6.95937L6.85641 5.65389C7.22195 5.44501 7.69192 5.44501 8.10968 5.65389L10.3551 7.01159C10.7206 7.22047 10.9817 7.63822 10.9817 8.10819V9.83143L12.9661 8.68261V6.90715C12.9661 6.4894 12.7572 6.07164 12.3394 5.81055L8.1619 3.35624C7.79636 3.14737 7.32639 3.14737 6.90863 3.35624L2.62665 5.86277C2.20889 6.07164 2.00002 6.4894 2.00002 6.90715V11.8158C2.00002 12.2335 2.20889 12.6513 2.62665 12.9124L6.85641 15.3667C7.22195 15.5755 7.69192 15.5755 8.10968 15.3667L10.9817 13.6957L12.9661 12.5468L15.8381 10.8758C16.2037 10.6669 16.6736 10.6669 17.0914 10.8758L19.3368 12.1813C19.7024 12.3902 19.9635 12.8079 19.9635 13.2779V15.8889C19.9635 16.3066 19.7546 16.7244 19.3368 16.9855L17.1436 18.2909C16.7781 18.4998 16.3081 18.4998 15.8904 18.2909L13.6449 16.9855C13.2794 16.7766 13.0183 16.3588 13.0183 15.8889V14.2178L11.034 15.3667V17.0899C11.034 17.5077 11.2428 17.9254 11.6606 18.1865L15.8904 20.6408C16.2559 20.8497 16.7259 20.8497 17.1436 20.6408L21.3734 18.1865C21.7389 17.9776 22 17.5599 22 17.0899V12.1291C22 11.7113 21.7911 11.2936 21.3734 11.0325L17.1436 8.57817Z',
        fill: t,
      }),
    }),
  L3 = ({ width: e, fill: t = 'white' }) =>
    P.jsx('svg', {
      width: e,
      height: e,
      viewBox: '0 0 24 24',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: P.jsx('path', {
        d: 'M20.9073 16.5239L17.9359 19.6285C17.8713 19.6959 17.7931 19.7497 17.7063 19.7864C17.6194 19.8232 17.5257 19.8421 17.4311 19.8421H3.34497C3.27776 19.8421 3.21201 19.8229 3.15581 19.787C3.0996 19.7511 3.05539 19.7 3.0286 19.6399C3.00181 19.5799 2.99361 19.5135 3.005 19.449C3.0164 19.3845 3.0469 19.3246 3.09276 19.2767L6.06644 16.1722C6.13086 16.1049 6.20876 16.0513 6.29532 16.0145C6.3819 15.9778 6.47529 15.9588 6.56973 15.9586H20.655C20.7222 15.9586 20.788 15.9777 20.8442 16.0136C20.9004 16.0495 20.9446 16.1007 20.9715 16.1607C20.9982 16.2208 21.0064 16.2871 20.995 16.3517C20.9836 16.4162 20.9531 16.4761 20.9073 16.5239ZM17.9359 10.2723C17.8713 10.2049 17.7931 10.1511 17.7063 10.1144C17.6194 10.0776 17.5257 10.0587 17.4311 10.0588H3.34497C3.27776 10.0588 3.21201 10.0779 3.15581 10.1138C3.0996 10.1497 3.05539 10.2008 3.0286 10.2609C3.00181 10.3209 2.99361 10.3873 3.005 10.4518C3.0164 10.5163 3.0469 10.5762 3.09276 10.6241L6.06644 13.7286C6.13086 13.7959 6.20876 13.8495 6.29532 13.8863C6.3819 13.923 6.47529 13.942 6.56973 13.9422H20.655C20.7222 13.9422 20.788 13.9231 20.8442 13.8872C20.9004 13.8512 20.9446 13.8001 20.9715 13.7401C20.9982 13.68 21.0064 13.6137 20.995 13.5491C20.9836 13.4846 20.9531 13.4247 20.9073 13.3768L17.9359 10.2723ZM3.34497 8.04234H17.4311C17.5257 8.04238 17.6194 8.02345 17.7063 7.9867C17.7931 7.94996 17.8713 7.89619 17.9359 7.82875L20.9073 4.72423C20.9531 4.67636 20.9836 4.61648 20.995 4.55195C21.0064 4.48742 20.9982 4.42105 20.9715 4.361C20.9446 4.30095 20.9004 4.24983 20.8442 4.21393C20.788 4.17802 20.7222 4.15889 20.655 4.15889H6.56973C6.47529 4.15905 6.3819 4.17808 6.29532 4.21482C6.20876 4.25156 6.13086 4.30522 6.06644 4.37248L3.09352 7.477C3.04771 7.52482 3.01723 7.58465 3.0058 7.64909C2.99438 7.71355 3.00251 7.77986 3.02921 7.83989C3.05591 7.89991 3.1 7.95103 3.15609 7.98699C3.21218 8.02295 3.27782 8.04218 3.34497 8.04234Z',
        fill: t,
      }),
    }),
  U3 = ({ width: e, fill: t = 'white' }) =>
    P.jsxs('svg', {
      width: e,
      height: e,
      viewBox: '0 0 24 24',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: [
        P.jsx('path', {
          d: 'M12 15.8204L18.1317 12.2036L12 2.00002L5.86826 12.2036L12 15.8204Z',
          fill: t,
        }),
        P.jsx('path', { d: 'M12 22L18.1317 13.3533L12 16.9701L5.86826 13.3533L12 22Z', fill: t }),
      ],
    }),
  $3 = ({ width: e, fill: t = 'white' }) =>
    P.jsx('svg', {
      width: e,
      height: e,
      viewBox: '0 0 24 24',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: P.jsx('path', {
        d: 'M17.1436 8.57817C16.7781 8.36929 16.3081 8.36929 15.8904 8.57817L12.9661 10.3014L10.9817 11.398L8.10968 13.1212C7.74414 13.3301 7.27417 13.3301 6.85641 13.1212L4.61098 11.7635C4.24545 11.5547 3.98435 11.1369 3.98435 10.6669V8.05597C3.98435 7.63822 4.19323 7.22047 4.61098 6.95937L6.85641 5.65389C7.22195 5.44501 7.69192 5.44501 8.10968 5.65389L10.3551 7.01159C10.7206 7.22047 10.9817 7.63822 10.9817 8.10819V9.83143L12.9661 8.68261V6.90715C12.9661 6.4894 12.7572 6.07164 12.3394 5.81055L8.1619 3.35624C7.79636 3.14737 7.32639 3.14737 6.90863 3.35624L2.62665 5.86277C2.20889 6.07164 2.00002 6.4894 2.00002 6.90715V11.8158C2.00002 12.2335 2.20889 12.6513 2.62665 12.9124L6.85641 15.3667C7.22195 15.5755 7.69192 15.5755 8.10968 15.3667L10.9817 13.6957L12.9661 12.5468L15.8381 10.8758C16.2037 10.6669 16.6736 10.6669 17.0914 10.8758L19.3368 12.1813C19.7024 12.3902 19.9635 12.8079 19.9635 13.2779V15.8889C19.9635 16.3066 19.7546 16.7244 19.3368 16.9855L17.1436 18.2909C16.7781 18.4998 16.3081 18.4998 15.8904 18.2909L13.6449 16.9855C13.2794 16.7766 13.0183 16.3588 13.0183 15.8889V14.2178L11.034 15.3667V17.0899C11.034 17.5077 11.2428 17.9254 11.6606 18.1865L15.8904 20.6408C16.2559 20.8497 16.7259 20.8497 17.1436 20.6408L21.3734 18.1865C21.7389 17.9776 22 17.5599 22 17.0899V12.1291C22 11.7113 21.7911 11.2936 21.3734 11.0325L17.1436 8.57817Z',
        fill: t,
      }),
    }),
  F3 = ({ width: e, fill: t = 'white' }) =>
    P.jsx('svg', {
      width: e,
      height: e,
      viewBox: '0 0 16 16',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: P.jsx('path', {
        d: 'M7.99996 1C5.97853 1 1 5.97836 1 7.99988C1 10.0214 5.97853 14.9998 7.99996 14.9998C10.0214 14.9998 15 10.0213 15 7.99988C15 5.97844 10.0215 1 7.99996 1ZM6.90913 12.0026C6.05671 11.7704 3.76491 7.76146 3.99723 6.90905C4.22955 6.0566 8.23842 3.76487 9.09083 3.99719C9.94328 4.22947 12.2351 8.2383 12.0028 9.09075C11.7704 9.9432 7.76154 12.235 6.90913 12.0026Z',
        fill: t,
      }),
    }),
  Qv = ({ width: e, height: t, fill: n = 'white' }) =>
    P.jsx('svg', {
      width: e,
      height: t,
      viewBox: '0 0 18 26',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: P.jsx('path', {
        d: 'M14.5119 12.0902C15.807 11.4229 16.6173 10.2476 16.428 8.28976C16.1731 5.61412 13.889 4.71692 11.0056 4.46141L11.005 0.750082H8.77096L8.77034 4.36381C8.18254 4.36381 7.58334 4.37549 6.98685 4.38759L6.98637 0.750575L4.75431 0.750364L4.7539 4.46078C4.27016 4.47077 3.79511 4.48027 3.33125 4.48027V4.46929L0.249756 4.46802L0.250173 6.88041C0.250173 6.88041 1.89999 6.84903 1.87281 6.8795C2.77737 6.88013 3.07273 7.41142 3.15768 7.87001L3.15837 12.098V18.0369C3.11854 18.3247 2.95095 18.7846 2.31845 18.7854C2.34723 18.811 0.693316 18.7851 0.693316 18.7851L0.250173 21.4827H3.15698C3.69863 21.4834 4.23081 21.4919 4.75292 21.4961L4.75487 25.2494L6.98637 25.2501L6.98574 21.5361C7.59968 21.5487 8.19227 21.5542 8.7711 21.5535L8.77048 25.2501H11.0045L11.0057 21.503C14.7609 21.2849 17.3899 20.3281 17.7168 16.7612C17.9802 13.8895 16.6439 12.6077 14.5119 12.0902ZM7.04024 7.04325C8.30022 7.04325 12.2629 6.63743 12.2634 9.29956C12.2629 11.8518 8.30148 11.5536 7.04024 11.5536V7.04325ZM7.03926 18.8037L7.04024 13.8306C8.55408 13.8302 13.3023 13.39 13.3029 16.316C13.3035 19.1221 8.55408 18.8026 7.03926 18.8037Z',
        fill: n,
      }),
    }),
  z3 = ({ width: e, height: t, fill: n = Le.colors.legacy.textPrimary }) => {
    const r = e || t || 17;
    return P.jsx('svg', {
      width: r,
      height: r,
      viewBox: '0 0 24 24',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: P.jsx('path', {
        fillRule: 'evenodd',
        clipRule: 'evenodd',
        d: 'M9.51948 13.9003L17.4173 6.26045C17.7763 5.91318 18.3546 5.91318 18.7136 6.26045L19.7308 7.24437C20.0897 7.59164 20.0897 8.15113 19.7308 8.4791L10.1776 17.7395C9.81863 18.0868 9.24026 18.0868 8.88127 17.7395L4.25428 13.2637C3.91524 12.9357 3.91524 12.3762 4.25428 12.0289L5.29137 11.045C5.63041 10.6977 6.20879 10.6977 6.56778 11.045L9.51948 13.9003Z',
        fill: n,
      }),
    });
  },
  e_ = ({ width: e = 16, height: t = 16, fill: n = Le.colors.legacy.textPrimary }) =>
    P.jsx('svg', {
      width: e,
      height: t,
      viewBox: '0 0 16 16',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: P.jsx('path', {
        d: 'M3.69466 12.3154C3.97135 12.5921 4.4362 12.5811 4.70182 12.321L8 9.02279L11.2926 12.321C11.5638 12.5921 12.0286 12.5921 12.2998 12.3154C12.571 12.0387 12.5765 11.5794 12.3053 11.3083L9.0127 8.01009L12.3053 4.71745C12.5765 4.44629 12.5765 3.98698 12.2998 3.71029C12.0231 3.43913 11.5638 3.43359 11.2926 3.70475L8 7.00293L4.70182 3.70475C4.4362 3.44466 3.96582 3.43359 3.69466 3.71029C3.4235 3.98698 3.42904 4.45182 3.68913 4.71191L6.9873 8.01009L3.68913 11.3138C3.42904 11.5739 3.41797 12.0443 3.69466 12.3154Z',
        fill: n,
      }),
    }),
  K3 = ({ width: e, height: t, fill: n = Le.colors.legacy.bgRow }) => {
    const r = e || t || 62;
    return P.jsx('svg', {
      width: r,
      height: r,
      viewBox: '0 0 24 24',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: P.jsx('path', {
        d: 'M5.70147 4.0003C5.58476 4.00441 5.47074 4.03658 5.36909 4.0941C5.26743 4.15162 5.18113 4.23278 5.11747 4.33074C5.05382 4.42869 5.01469 4.54054 5.0034 4.65682C4.99212 4.7731 5.009 4.89039 5.05262 4.99876L7.56284 11.2736H13.0007C13.1937 11.2736 13.3788 11.3503 13.5152 11.4868C13.6517 11.6233 13.7283 11.8084 13.7283 12.0015C13.7283 12.1945 13.6517 12.3797 13.5152 12.5162C13.3788 12.6527 13.1937 12.7294 13.0007 12.7294H7.56142L5.05262 19.0042C4.99813 19.1414 4.98666 19.2919 5.01974 19.4358C5.05283 19.5797 5.1289 19.71 5.23785 19.8096C5.3468 19.9092 5.48346 19.9733 5.62968 19.9933C5.77589 20.0133 5.92474 19.9883 6.05642 19.9217L20.5938 12.6541C20.7157 12.5941 20.8184 12.5012 20.8902 12.3859C20.9619 12.2705 21 12.1374 21 12.0015C21 11.8656 20.9619 11.7324 20.8902 11.6171C20.8184 11.5017 20.7157 11.4088 20.5938 11.3489L6.05642 4.08126C5.94689 4.0246 5.82474 3.99674 5.70147 4.0003V4.0003Z',
        fill: n,
      }),
    });
  },
  Qpe = ({ width: e, height: t, fill: n = 'none' }) => {
    const r = e || t || 32;
    return P.jsxs('svg', {
      width: r,
      height: r,
      viewBox: '0 0 24 24',
      xmlns: 'http://www.w3.org/2000/svg',
      children: [
        P.jsx('path', {
          d: 'M16.1121 20L19.7726 16.3439C19.9182 16.1983 20 16.0009 20 15.795C20 15.5892 19.9182 15.3917 19.7726 15.2461L16.1121 11.59L15.0129 12.6879L17.3461 15.0182H6.74062V16.5718H17.3461L15.0129 18.9021L16.1121 20Z',
          fill: n,
        }),
        P.jsx('path', {
          d: 'M7.88794 4L4.22745 7.65606C4.08181 7.8017 4 7.99914 4 8.20498C4 8.41083 4.08181 8.60826 4.22745 8.75391L7.88794 12.41L8.98712 11.3121L6.65395 8.98177H17.2594V7.4282H6.65395L8.98712 5.09785L7.88794 4Z',
          fill: n,
        }),
      ],
    });
  },
  V3 = ({ width: e, height: t, fill: n = Le.colors.legacy.textSecondary }) => {
    const r = e || t || 16;
    return P.jsx('svg', {
      width: r,
      height: r,
      viewBox: '0 0 24 24',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: P.jsx('path', {
        d: 'M11.0737 19.4932L4.89026 13.7049L6.76695 11.9256L10.6888 15.6193V3.75H13.3354V15.6193L17.2572 11.9256L19.1339 13.7049L12.9504 19.4932L12.0121 20.3265L11.0737 19.4932Z',
        fill: n,
      }),
    });
  },
  W3 = ({ width: e = 20, fill: t = Le.colors.legacy.accentWarning }) => {
    const n = e;
    return P.jsx('svg', {
      width: n,
      height: n,
      viewBox: '0 0 24 24',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: P.jsx('path', {
        d: 'M13.0831 4.76662L14.3 8.46686C14.4444 8.93706 14.8776 9.24371 15.3726 9.24371H19.2917C20.3849 9.24371 20.8387 10.6339 19.9518 11.2676L16.7752 13.5777C16.3833 13.8639 16.2183 14.375 16.3627 14.8247L17.5797 18.525C17.9097 19.5676 16.734 20.4262 15.847 19.772L12.6705 17.4824C12.2786 17.1962 11.7423 17.1962 11.3504 17.4824L8.15327 19.772C7.26632 20.4058 6.06997 19.5471 6.42063 18.525L7.6376 14.8247C7.78199 14.3545 7.61698 13.8639 7.22507 13.5777L4.04856 11.288C3.16161 10.6543 3.61539 9.26415 4.70861 9.26415H8.62769C9.12273 9.26415 9.55589 8.9575 9.70028 8.48731L10.9173 4.76662C11.2679 3.74446 12.7324 3.74446 13.0831 4.76662Z',
        fill: t,
      }),
    });
  },
  H3 = ({ width: e, height: t, fill: n = Le.colors.legacy.bgRow }) => {
    const r = e || t || 16;
    return P.jsx('svg', {
      width: r,
      height: r,
      viewBox: '0 0 24 24',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: P.jsx('path', {
        d: 'M10.7984 3.36833C10.7984 3.36833 8.52118 5.53552 6.92542 7.13129C3.88627 10.1704 4.00056 13.0106 4.00056 14.0688C4.00056 15.635 4.91907 17.5059 6.32436 18.9111C7.53917 20.126 8.90213 20.9894 11.6407 20.9894C14.3794 20.9894 15.8524 20.0371 16.8682 19.0339C18.2143 17.709 19.3317 16.0159 19.3317 13.5567C19.3317 10.9196 18.4428 9.41276 17.7995 8.82017C17.4354 8.48578 16.936 8.21488 16.4661 8.63393C15.9963 9.05297 15.6196 9.39583 15.463 9.53128C15.3063 9.66673 15.0651 9.5863 15.137 9.27308C15.209 8.95985 15.4291 8.8625 15.4291 8.06673C15.4291 7.27097 14.9635 6.24663 14.2016 5.31965L12.6651 3.46145C12.191 2.88579 11.3233 2.84347 10.79 3.3641L10.7984 3.36833Z',
        fill: n,
      }),
    });
  },
  t_ = ({ width: e = 22, fill: t = 'white' }) =>
    P.jsx('svg', {
      width: e,
      height: e,
      viewBox: '0 0 16 16',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: P.jsx('path', {
        d: 'M7.98768 15C11.8606 15 15 11.8662 15 8C15 4.13376 11.8606 1 7.98768 1C4.31352 1 1.2996 3.82128 1 7.41144H10.2686V8.58856H1C1.2996 12.1787 4.31352 15 7.98768 15Z',
        fill: t,
      }),
    }),
  n_ = ({ width: e = 22, fill: t = 'white' }) =>
    P.jsx('svg', {
      width: e,
      height: e,
      viewBox: '0 0 14 14',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: P.jsx('path', {
        'fill-rule': 'evenodd',
        'clip-rule': 'evenodd',
        d: 'M12.8019 10.8873L7.54184 13.8568C7.37489 13.9513 7.18743 14 7 14C6.81257 14 6.62511 13.9513 6.45816 13.8568L1.19808 10.8873C0.864194 10.6983 0.65625 10.3461 0.65625 9.96809V4.02905C0.65625 3.65106 0.864194 3.3017 1.19808 3.1127L6.45816 0.143178C6.62511 0.0486806 6.81257 0 7 0C7.18743 0 7.37489 0.0486806 7.54478 0.143178L12.8019 3.10984C13.1358 3.29883 13.3438 3.65106 13.3438 4.02905V9.96809C13.3438 10.3489 13.1387 10.6983 12.8019 10.8873ZM7 0.867663C7.03513 0.867663 7.06738 0.876251 7.09958 0.893436L12.3597 3.86296C12.4212 3.89732 12.4593 3.96032 12.4593 4.02905V9.96809C12.4593 10.0368 12.4212 10.0998 12.3597 10.1342L11.5587 10.5868L9.45113 4.9368C9.41306 4.83373 9.26663 4.83373 9.22857 4.9368L8.53443 6.79526C8.51391 6.84684 8.51391 6.90411 8.53443 6.95565L10.1795 11.3662L9.63248 11.6753L8.2861 8.06388C8.24799 7.9608 8.10156 7.9608 8.0635 8.06388L7.36936 9.92233C7.34889 9.97387 7.34889 10.0311 7.36936 10.0827L8.25329 12.4546L7.09958 13.1066C7.07031 13.1237 7.03513 13.1323 7 13.1323C6.96487 13.1323 6.93262 13.1237 6.90042 13.1066L5.75819 12.4614L9.00287 3.76272C9.03214 3.6854 8.97361 3.60522 8.89157 3.60522H7.55899C7.45942 3.60522 7.36859 3.66536 7.33639 3.75699L4.51511 11.3174L4.00718 10.9045L3.83211 11.3734L6.67195 3.75986C6.69829 3.68541 6.64264 3.60522 6.55772 3.60522H5.22514C5.12557 3.60522 5.03474 3.66536 5.00254 3.75699L2.45214 10.594L1.64325 10.1371C1.58175 10.1027 1.54367 10.0397 1.54367 9.97097V4.02905C1.54367 3.96032 1.58175 3.89732 1.64325 3.86296L6.90336 0.893436C6.93263 0.876251 6.9678 0.867663 7 0.867663Z',
        fill: t,
      }),
    }),
  r_ = ({ width: e = 16, fill: t = 'white' }) =>
    P.jsx('svg', {
      width: e,
      height: e,
      viewBox: '0 0 16 16',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: P.jsx('path', {
        d: 'M13.333 8.00031C13.333 6.89574 12.4376 6.00031 11.333 6.00031C10.7822 6.00039 10.2598 6.22726 9.88477 6.6214L9.7334 6.80011L8.83301 7.99933L9.7334 9.19952C10.111 9.70305 10.7036 10.0002 11.333 10.0003C12.4375 10.0003 13.3328 9.10472 13.333 8.00031ZM2.66699 8.00031C2.66717 9.10473 3.56253 10.0003 4.66699 10.0003C5.29639 10.0002 5.88896 9.70305 6.2666 9.19952L7.16602 7.99933L6.2666 6.80011C5.88896 6.29659 5.29639 6.00041 4.66699 6.00031C3.56242 6.00031 2.66699 6.89574 2.66699 8.00031ZM14.667 8.00031C14.6668 9.8411 13.1738 11.3333 11.333 11.3333C10.2841 11.3332 9.29645 10.8393 8.66699 10.0003L8 9.11066L7.33301 10.0003C6.70355 10.8393 5.71591 11.3332 4.66699 11.3333C2.82615 11.3333 1.33318 9.8411 1.33301 8.00031C1.33301 6.15936 2.82604 4.66632 4.66699 4.66632C5.71606 4.66642 6.70356 5.16104 7.33301 6.00031L8 6.88898L8.66699 6.00031L8.78906 5.84698C9.42008 5.10115 10.3495 4.66642 11.333 4.66632C13.174 4.66632 14.667 6.15936 14.667 8.00031Z',
        fill: t,
      }),
    }),
  i_ = ({ width: e, fill: t = 'white' }) =>
    P.jsx('svg', {
      width: e,
      height: e,
      viewBox: '0 0 16 16',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: P.jsx('path', {
        d: 'M11.2833 6.8302C11.8536 7.5462 12.1946 8.45172 12.1946 9.43671C12.1946 10.4217 11.8432 11.3549 11.258 12.0749L11.2073 12.1371L11.194 12.0582C11.1825 11.9913 11.1693 11.9234 11.1537 11.8554C10.8605 10.5674 9.90549 9.46322 8.33352 8.56864C7.27189 7.96613 6.6642 7.24148 6.50466 6.4172C6.40156 5.8844 6.47816 5.34926 6.62618 4.89072C6.77423 4.4328 6.99426 4.0486 7.18147 3.81761L7.79321 3.06994C7.90036 2.9386 8.10139 2.9386 8.2085 3.06994L11.2839 6.8302H11.2833ZM12.2505 6.08309L8.15148 1.07171C8.07317 0.976095 7.92683 0.976095 7.84852 1.07171L3.75011 6.08309L3.73687 6.09983C2.98285 7.03586 2.53125 8.22535 2.53125 9.52024C2.53125 12.5357 4.97992 14.9803 8 14.9803C11.0201 14.9803 13.4688 12.5357 13.4688 9.52024C13.4688 8.22535 13.0171 7.03586 12.2631 6.10038L12.2499 6.08368L12.2505 6.08309ZM4.73108 6.81408L5.09743 6.36535L5.10837 6.4483C5.11701 6.51396 5.12795 6.57962 5.14063 6.64586C5.37795 7.89066 6.22528 8.92808 7.64172 9.73163C8.87325 10.4326 9.59038 11.2385 9.79659 12.1221C9.883 12.4908 9.89798 12.8537 9.86054 13.1711L9.85824 13.1906L9.84038 13.1993C9.28454 13.4706 8.65953 13.6232 7.99942 13.6232C5.68324 13.6232 3.80541 11.7489 3.80541 9.43613C3.80541 8.44308 4.1516 7.53122 4.72992 6.81292L4.73108 6.81408Z',
        fill: t,
      }),
    }),
  wg = {
    icon: {
      badge: {
        x: { bgColor: Le.colors.legacy.accentAlert, shape: 'circle', src: e_ },
        send: { bgColor: Le.colors.legacy.accentPrimary, shape: 'circle', src: K3 },
        receive: { bgColor: Le.colors.legacy.accentPrimary, shape: 'circle', src: V3 },
        star: { bgColor: Le.colors.legacy.accentWarning, shape: 'circle', src: W3 },
        burn: { bgColor: Le.colors.legacy.accentAlert, shape: 'circle', src: H3 },
        check: { bgColor: Le.colors.legacy.accentSuccess, shape: 'circle', src: z3 },
      },
      image: {
        x: {
          bgColor: ss(Le.colors.legacy.accentAlert, 0.1),
          fgColor: Le.colors.legacy.accentAlert,
          shape: 'circle',
          src: e_,
        },
        'x-bold': {
          bgColor: Le.colors.legacy.accentAlert,
          fgColor: ss(Le.colors.legacy.black, 0.75),
          shape: 'circle',
          src: e_,
        },
        send: {
          bgColor: ss(Le.colors.legacy.accentPrimary, 0.1),
          fgColor: Le.colors.legacy.accentPrimary,
          shape: 'circle',
          src: K3,
        },
        receive: {
          bgColor: ss(Le.colors.legacy.accentPrimary, 0.1),
          fgColor: Le.colors.legacy.accentPrimary,
          shape: 'circle',
          src: V3,
        },
        swap: {
          bgColor: ss(Le.colors.legacy.accentSuccess, 0.1),
          fgColor: Le.colors.legacy.accentSuccess,
          shape: 'circle',
          src: Qpe,
        },
        star: {
          bgColor: ss(Le.colors.legacy.accentWarning, 0.1),
          fgColor: Le.colors.legacy.accentWarning,
          shape: 'circle',
          src: W3,
        },
        burn: {
          bgColor: ss(Le.colors.legacy.accentAlert, 0.1),
          fgColor: Le.colors.legacy.accentAlert,
          shape: 'circle',
          src: H3,
        },
        check: {
          bgColor: ss(Le.colors.legacy.accentSuccess, 0.1),
          fgColor: Le.colors.legacy.accentSuccess,
          shape: 'circle',
          src: z3,
        },
      },
    },
    network: {
      badge: {
        solana: { src: L3, shape: 'square' },
        ethereum: { src: U3, shape: 'square' },
        polygon: { src: $3, shape: 'square' },
        monad: { src: F3, shape: 'square' },
        bitcoin: { src: Qv, shape: 'square' },
        base: { src: t_, shape: 'square' },
        arbitrum: { src: n_, shape: 'square' },
        sui: { src: i_, shape: 'square' },
        hypercore: { src: r_, shape: 'square' },
      },
      image: {
        solana: {
          src: L3,
          shape: 'square',
          fgColor: Le.colors.legacy.black,
          bgColor: Le.colors.legacy.white,
        },
        ethereum: {
          src: U3,
          shape: 'square',
          fgColor: Le.colors.legacy.black,
          bgColor: Le.colors.legacy.white,
        },
        polygon: {
          src: $3,
          shape: 'square',
          fgColor: Le.colors.legacy.black,
          bgColor: Le.colors.legacy.white,
        },
        monad: {
          src: F3,
          shape: 'square',
          fgColor: Le.colors.legacy.black,
          bgColor: Le.colors.legacy.white,
        },
        bitcoin: {
          src: Qv,
          shape: 'square',
          fgColor: Le.colors.legacy.black,
          bgColor: Le.colors.legacy.white,
        },
        base: {
          src: t_,
          shape: 'square',
          fgColor: Le.colors.legacy.black,
          bgColor: Le.colors.legacy.white,
        },
        arbitrum: {
          src: n_,
          shape: 'square',
          fgColor: Le.colors.legacy.black,
          bgColor: Le.colors.legacy.white,
        },
        sui: {
          src: i_,
          shape: 'square',
          fgColor: Le.colors.legacy.black,
          bgColor: Le.colors.legacy.white,
        },
        hypercore: {
          src: r_,
          shape: 'square',
          fgColor: Le.colors.legacy.black,
          bgColor: Le.colors.legacy.white,
        },
      },
    },
    fungible: {
      image: {
        sol: { src: Zpe, shape: 'circle', fullSize: !0 },
        eth: { src: Jpe, shape: 'circle' },
        matic: { src: Xpe, shape: 'circle' },
        btc: { src: Qv, shape: 'circle' },
        base: { src: t_, shape: 'circle' },
        arbitrum: { src: n_, shape: 'circle' },
        sui: { src: i_, shape: 'circle' },
        hypercore: { src: r_, shape: 'circle' },
      },
    },
  },
  ege = ['collectible', 'dapp', 'network'],
  il = W.memo((e) => {
    if ('tokenSell' in e) {
      const o = typeof e.tokenSell == 'string' ? wg.fungible.image[e.tokenSell] : e.tokenSell,
        a = typeof e.tokenBuy == 'string' ? wg.fungible.image[e.tokenBuy] : e.tokenBuy,
        { image: c, tokenBuy: u, tokenSell: l, onClick: d, ...f } = e;
      return P.jsx(qpe, { bgToken: o, fgToken: a, onClick: d, ...f });
    }
    if ('tokenType' in e) return P.jsx(tge, { ...e });
    let t, n;
    if ('preset' in e.image) {
      const o = e.image.type,
        a = e.image.preset;
      t = wg[o].image[a];
    } else {
      const o = ege.includes(e.image.type) ? 'square' : 'circle';
      t = { ...e.image, shape: o };
    }
    if ('badge' in e && e.badge)
      if ('preset' in e.badge) {
        const o = e.badge.type,
          a = e.badge.preset;
        n = wg[o].badge[a];
      } else n = { ...e.badge, shape: 'square' };
    const { image: r, badge: i, ...s } = e;
    return P.jsx(Gpe, { image: t, badge: n, ...s });
  }),
  tge = W.memo(({ image: e, tokenType: t, chainMeta: n, ...r }) => {
    const i = WY(),
      s = de.getChainID(n.id),
      o = nge(i, t, s) ? s : void 0;
    return P.jsx(il, { image: e, badge: o && { type: 'network', preset: o }, ...r });
  }),
  nge = (e, t, n) => (e ? !1 : gc.get(n).alwaysShowNetworkBadge ? !0 : !yc(t)),
  AR = ({ rows: e }) => {
    const t = W.useMemo(
      () =>
        e.map((n, r) =>
          n.type === 'AssetChange'
            ? rge({ change: n })
            : n.type === 'MessageOnly'
              ? G3({ change: n })
              : G3({ change: n })
        ),
      [e]
    );
    return P.jsx(ye, { testID: 'expected-changes-table', children: P.jsx(uo, { rows: t }) });
  },
  rge = ({ change: e }) => {
    const t = e.asset.type === 'native' || e.asset.type === 'unknown' ? 'fungible' : e.asset.type,
      n = e.changeText || e.fallbackMessage,
      r = Ude(e.changeSign),
      i = e.changeSign === Ys.Equal,
      s = e.name === ((e == null ? void 0 : e.changeText) ?? e.fallbackMessage),
      o = i || s,
      a = e.image
        ? P.jsxs(P.Fragment, {
            children: [
              P.jsx(il, { image: { type: t, src: e.image }, size: 24 }),
              P.jsx('div', { style: { display: 'none' }, 'data-testid': 'estimated-change-image' }),
            ],
          })
        : P.jsxs(ye, {
            backgroundColor:
              e.changeSign === Ys.Plus
                ? 'accentSuccess'
                : e.changeSign === Ys.Minus
                  ? 'accentAlert'
                  : 'textSecondary',
            size: 24,
            flex: 'none',
            borderRadius: 12,
            justifyContent: 'center',
            alignItems: 'center',
            children: [
              e.changeSign === Ys.Plus &&
                P.jsx(qj, {
                  'data-testid': 'estimated-changes-icon-receive',
                  size: 16,
                  color: 'bgWallet',
                }),
              e.changeSign === Ys.Minus &&
                P.jsx(Yj, {
                  'data-testid': 'estimated-changes-icon-send',
                  size: 16,
                  color: 'bgWallet',
                }),
              i &&
                P.jsx(iP, {
                  'data-testid': 'estimated-changes-icon-check',
                  size: 16,
                  color: 'bgWallet',
                }),
            ],
          });
    return {
      topLeft: P.jsxs(ye, {
        gap: 8,
        direction: 'row',
        alignItems: 'center',
        justifyContent: 'center',
        children: [
          a,
          !o &&
            P.jsx(je, {
              whiteSpace: 'pre-line',
              wordBreak: 'break-word',
              color: 'textPrimary',
              children: e.name,
            }),
        ],
      }),
      topRight: P.jsx(je, {
        whiteSpace: 'pre-line',
        wordBreak: 'break-word',
        color: r,
        align: o ? 'left' : 'right',
        children: n,
      }),
    };
  },
  G3 = ({ change: e }) => {
    const t = 'fungible';
    let n;
    return (
      e.image && (n = P.jsx(il, { image: { type: t, src: e.image }, size: 24 })),
      !e.image &&
        e.changeType === U5.approval &&
        (n = P.jsx(ye, {
          backgroundColor: 'textSecondary',
          size: 24,
          flex: 'none',
          borderRadius: 12,
          justifyContent: 'center',
          alignItems: 'center',
          children: P.jsx(iP, { size: 16, color: 'bgWallet' }),
        })),
      {
        topLeft: P.jsxs(ye, {
          gap: 8,
          direction: 'row',
          alignItems: 'center',
          justifyContent: 'center',
          children: [
            n,
            P.jsx(je, {
              whiteSpace: 'pre-line',
              wordBreak: 'break-word',
              color: 'textPrimary',
              children: e.message || e.fallbackMessage,
            }),
          ],
        }),
      }
    );
  },
  sT = ({ header: e, children: t }) => {
    const n = !!e,
      [r, i] = W.useState(!n),
      s = W.useCallback(() => {
        i(!r);
      }, [r]);
    return P.jsxs(P.Fragment, {
      children: [
        e &&
          P.jsxs(ye, {
            testID: 'toggle-table',
            onPress: s,
            paddingTop: 4,
            paddingBottom: 4,
            paddingRight: 4,
            direction: 'row',
            alignItems: 'center',
            children: [
              P.jsx(ye, {
                marginRight: 6,
                width: 16,
                height: 16,
                children: r
                  ? P.jsx(Zj, { color: 'textSecondary' })
                  : P.jsx(Jj, { color: 'textSecondary' }),
              }),
              P.jsx(je, { font: 'captionSemibold', color: 'textSecondary', children: e }),
            ],
          }),
        r && t,
      ],
    });
  },
  v1 = (e) => {
    const { type: t, description: n, domain: r } = e,
      { t: i } = Ct(),
      { originIsBlocklisted: s } = dX(e.domain);
    let o;
    'iconUrl' in e && e.iconUrl && (o = e.iconUrl),
      !o && e.domain && (o = BP(e.domain)),
      s && (o = void 0);
    function a(u) {
      switch (u) {
        case 'APPROVE_TRANSACTION':
          return 'notificationSignatureRequestConfirmTransactionCapitalized';
        case 'APPROVE_TRANSACTIONS':
          return 'notificationSignatureRequestConfirmTransactionsCapitalized';
        case 'SIGN_MESSAGE':
          return 'dappApprovePopupSignMessage';
        case 'CONNECT':
          return 'notificationApplicationApprovalActionButtonConnect';
        case 'SIGN_IN':
          return 'notificationApplicationApprovalActionButtonSignIn';
      }
    }
    let c = 'textSecondary';
    return (
      s && (c = 'accentAlert'),
      P.jsxs(ye, {
        gap: 8,
        children: [
          P.jsxs(ye, {
            direction: 'row',
            gap: 8,
            alignItems: 'center',
            children: [
              P.jsx(il, { image: { type: 'dapp', src: o }, size: 56 }),
              P.jsxs(ye, {
                gap: 6,
                children: [
                  P.jsx(je, { color: 'textPrimary', font: 'heading3', children: i(a(t)) }),
                  r && P.jsx(je, { font: 'labelMedium', color: c, children: ba(r ?? '') }),
                ],
              }),
            ],
          }),
          n &&
            (typeof n == 'string'
              ? P.jsx(je, { font: 'caption', color: 'textSecondary', children: n })
              : n),
        ],
      })
    );
  },
  oT = (e) => {
    const { t } = Ct(),
      n = de.getChainName(e),
      r = n.toLowerCase();
    return {
      topLeft: { text: t('notificationTransactionApprovalNetwork') },
      topRight: { before: P.jsx(il, { image: { type: 'network', preset: r }, size: 16 }), text: n },
    };
  };
var ige = (e) => typeof e == 'function',
  EE = (e, t) => (ige(e) ? e(t) : e),
  sge = (() => {
    let e = 0;
    return () => (++e).toString();
  })(),
  oge = (() => {
    let e;
    return () => {
      if (e === void 0 && typeof window < 'u') {
        let t = matchMedia('(prefers-reduced-motion: reduce)');
        e = !t || t.matches;
      }
      return e;
    };
  })(),
  age = 20,
  uy = new Map(),
  cge = 1e3,
  q3 = (e) => {
    if (uy.has(e)) return;
    let t = setTimeout(() => {
      uy.delete(e), _1({ type: 4, toastId: e });
    }, cge);
    uy.set(e, t);
  },
  uge = (e) => {
    let t = uy.get(e);
    t && clearTimeout(t);
  },
  AE = (e, t) => {
    switch (t.type) {
      case 0:
        return { ...e, toasts: [t.toast, ...e.toasts].slice(0, age) };
      case 1:
        return (
          t.toast.id && uge(t.toast.id),
          { ...e, toasts: e.toasts.map((s) => (s.id === t.toast.id ? { ...s, ...t.toast } : s)) }
        );
      case 2:
        let { toast: n } = t;
        return e.toasts.find((s) => s.id === n.id)
          ? AE(e, { type: 1, toast: n })
          : AE(e, { type: 0, toast: n });
      case 3:
        let { toastId: r } = t;
        return (
          r
            ? q3(r)
            : e.toasts.forEach((s) => {
                q3(s.id);
              }),
          {
            ...e,
            toasts: e.toasts.map((s) => (s.id === r || r === void 0 ? { ...s, visible: !1 } : s)),
          }
        );
      case 4:
        return t.toastId === void 0
          ? { ...e, toasts: [] }
          : { ...e, toasts: e.toasts.filter((s) => s.id !== t.toastId) };
      case 5:
        return { ...e, pausedAt: t.time };
      case 6:
        let i = t.time - (e.pausedAt || 0);
        return {
          ...e,
          pausedAt: void 0,
          toasts: e.toasts.map((s) => ({ ...s, pauseDuration: s.pauseDuration + i })),
        };
    }
  },
  lge = [],
  s_ = { toasts: [], pausedAt: void 0 },
  _1 = (e) => {
    (s_ = AE(s_, e)),
      lge.forEach((t) => {
        t(s_);
      });
  },
  dge = (e, t = 'blank', n) => ({
    createdAt: Date.now(),
    visible: !0,
    type: t,
    ariaProps: { role: 'status', 'aria-live': 'polite' },
    message: e,
    pauseDuration: 0,
    ...n,
    id: (n == null ? void 0 : n.id) || sge(),
  }),
  xp = (e) => (t, n) => {
    let r = dge(t, e, n);
    return _1({ type: 2, toast: r }), r.id;
  },
  Mr = (e, t) => xp('blank')(e, t);
Mr.error = xp('error');
Mr.success = xp('success');
Mr.loading = xp('loading');
Mr.custom = xp('custom');
Mr.dismiss = (e) => {
  _1({ type: 3, toastId: e });
};
Mr.remove = (e) => _1({ type: 4, toastId: e });
Mr.promise = (e, t, n) => {
  let r = Mr.loading(t.loading, { ...n, ...(n == null ? void 0 : n.loading) });
  return (
    e
      .then(
        (i) => (
          Mr.success(EE(t.success, i), { id: r, ...n, ...(n == null ? void 0 : n.success) }), i
        )
      )
      .catch((i) => {
        Mr.error(EE(t.error, i), { id: r, ...n, ...(n == null ? void 0 : n.error) });
      }),
    e
  );
};
var fge = Rn`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`,
  hge = Rn`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`,
  pge = Rn`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`,
  gge = lr('div')`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || '#ff4b4b'};
  position: relative;
  transform: rotate(45deg);

  animation: ${fge} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${hge} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || '#fff'};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${pge} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`,
  yge = Rn`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`,
  bge = lr('div')`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || '#e0e0e0'};
  border-right-color: ${(e) => e.primary || '#616161'};
  animation: ${yge} 1s linear infinite;
`,
  mge = Rn`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`,
  wge = Rn`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`,
  vge = lr('div')`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || '#61d345'};
  position: relative;
  transform: rotate(45deg);

  animation: ${mge} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${wge} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || '#fff'};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`,
  _ge = lr('div')`
  position: absolute;
`,
  Sge = lr('div')`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`,
  Ege = Rn`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`,
  Age = lr('div')`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${Ege} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`,
  Ige = ({ toast: e }) => {
    let { icon: t, type: n, iconTheme: r } = e;
    return t !== void 0
      ? typeof t == 'string'
        ? W.createElement(Age, null, t)
        : t
      : n === 'blank'
        ? null
        : W.createElement(
            Sge,
            null,
            W.createElement(bge, { ...r }),
            n !== 'loading' &&
              W.createElement(
                _ge,
                null,
                n === 'error' ? W.createElement(gge, { ...r }) : W.createElement(vge, { ...r })
              )
          );
  },
  Tge = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`,
  xge = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`,
  kge = '0%{opacity:0;} 100%{opacity:1;}',
  Cge = '0%{opacity:1;} 100%{opacity:0;}',
  Pge = lr('div')`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`,
  Mge = lr('div')`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`,
  Oge = (e, t) => {
    let n = e.includes('top') ? 1 : -1,
      [r, i] = oge() ? [kge, Cge] : [Tge(n), xge(n)];
    return {
      animation: t
        ? `${Rn(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards`
        : `${Rn(i)} 0.4s forwards cubic-bezier(.06,.71,.55,1)`,
    };
  };
W.memo(({ toast: e, position: t, style: n, children: r }) => {
  let i = e.height ? Oge(e.position || t || 'top-center', e.visible) : { opacity: 0 },
    s = W.createElement(Ige, { toast: e }),
    o = W.createElement(Mge, { ...e.ariaProps }, EE(e.message, e));
  return W.createElement(
    Pge,
    { className: e.className, style: { ...i, ...n, ...e.style } },
    typeof r == 'function' ? r({ icon: s, message: o }) : W.createElement(W.Fragment, null, s, o)
  );
});
S4(W.createElement);
Id`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
const IR = Kn.memo(({ message: e, isJson: t, header: n }) => {
    const { t: r } = Ct();
    return P.jsx(uo, {
      rows: [
        {
          type: 'collapsible',
          topLeft: { text: n },
          bottomLeft: { text: e },
          allowCopy: t,
          onCopied: () => {
            Mr.success(r('notificationMessageCopied'));
          },
        },
      ],
    });
  }),
  aT = (e) => {
    const { t } = Ct(),
      {
        origin: n,
        message: r,
        isJson: i,
        networkID: s,
        scanWarnings: o,
        confirmApproval: a,
        simulationResults: c,
        denyApproval: u,
        scanFailed: l,
        icon: d,
        advancedDetails: f,
        testID: h = 'sign-plain-message',
        headerDescription: p = t('notificationSignMessageParagraphText'),
      } = e,
      b = oT(s),
      w = (o || []).some((x) => x.severity === Qb.criticalAlert),
      A = !!c && (c == null ? void 0 : c.length) > 0,
      _ = [
        P.jsx(
          on,
          {
            theme: 'secondary',
            onClick: u,
            'data-testid': 'secondary-button',
            children: t(a ? 'commandCancel' : 'commandClose'),
          },
          'secondary'
        ),
      ];
    return (
      !w &&
        a &&
        _.push(
          P.jsx(
            on,
            {
              theme: l ? 'destructive' : 'primary',
              onClick: a,
              'data-testid': 'primary-button',
              children: t('commandConfirm'),
            },
            'primary'
          )
        ),
      w &&
        _.push(
          P.jsx(
            on,
            { theme: 'destructive', onClick: a, children: t('commandConfirmUnsafe') },
            'unsafe'
          )
        ),
      P.jsxs(P.Fragment, {
        children: [
          P.jsxs(ye, {
            justifyContent: 'space-between',
            flex: 1,
            overflow: 'auto',
            padding: 'screen',
            minHeight: 0,
            height: '100%',
            gap: 'section',
            testID: h,
            children: [
              P.jsx(v1, { type: 'SIGN_MESSAGE', domain: ba(n), iconUrl: d, description: p }),
              ((o == null ? void 0 : o.length) || l) &&
                P.jsxs(ye, {
                  gap: 8,
                  children: [
                    o &&
                      (o == null ? void 0 : o.length) > 0 &&
                      P.jsx(P.Fragment, {
                        children: o.map((x, k) =>
                          P.jsx(
                            ra,
                            { level: P4(x.severity), children: x.message },
                            `simulation-warning-${k}`
                          )
                        ),
                      }),
                    l &&
                      P.jsx(ra, {
                        level: '1-critical-alert',
                        testID: 'simulation-failed',
                        children: t('notificationFailedToScan'),
                      }),
                  ],
                }),
              P.jsxs(ye, {
                gap: 8,
                children: [
                  P.jsx(ye, {
                    testID: 'message',
                    asChild: !0,
                    children: A
                      ? c
                        ? P.jsx(AR, { rows: c })
                        : null
                      : P.jsx(IR, {
                          header: t('notificationMessageHeader'),
                          message: r,
                          isJson: i,
                        }),
                  }),
                  P.jsx(uo, { rows: [b] }),
                  f && P.jsx(sT, { header: t('notificationAdvancedDetailsText'), children: f }),
                ],
              }),
              P.jsx(je, {
                align: 'center',
                marginTop: 'auto',
                font: 'caption',
                color: 'textSecondary',
                children: t('notificationConfirmFooter'),
              }),
            ],
          }),
          P.jsx(Fi, {
            direction: 'row',
            type: 'solid',
            children: P.jsx(P.Fragment, { children: _ }),
          }),
        ],
      })
    );
  };
function kp(e) {
  const { t } = Ct(),
    { domain: n, type: r, onClose: i, icon: s } = e,
    o =
      r === 'APPROVE_TRANSACTION' || r === 'APPROVE_TRANSACTIONS'
        ? t('notificationBalanceChangesText')
        : void 0,
    a = [
      P.jsx(
        on,
        {
          theme: 'secondary',
          onClick: i,
          'data-testid': 'btn-cancel',
          children: t('commandCancel'),
        },
        'secondary-first'
      ),
      P.jsx(
        on,
        {
          theme: 'secondary',
          onClick: () => !0,
          'data-testid': 'btn-confirm',
          disabled: !0,
          children: t('commandConfirm'),
        },
        'secondary-second'
      ),
    ],
    c = Array.from({ length: 3 }).map(() => ({
      start: P.jsx(Xj, { height: 24, width: 24 }),
      topLeft: P.jsx($p, { font: 'body', width: 80 }),
      topRight: P.jsx($p, { font: 'body', width: 80 }),
    }));
  return P.jsxs(P.Fragment, {
    children: [
      P.jsxs(ye, {
        flex: 1,
        overflow: 'auto',
        padding: 'screen',
        minHeight: 0,
        height: '100%',
        gap: 'section',
        testID: 'scan-loading',
        children: [
          P.jsx(v1, {
            domain: n,
            type: r,
            iconUrl: s,
            description:
              o ||
              P.jsxs(P.Fragment, {
                children: [
                  P.jsx($p, { font: 'body', width: '90%' }),
                  P.jsx($p, { font: 'body', width: '70%' }),
                ],
              }),
          }),
          P.jsx(uo, { rows: c }),
        ],
      }),
      P.jsx(ye, {
        padding: 'screen',
        children: P.jsx(Fi, { children: P.jsx(P.Fragment, { children: a }) }),
      }),
    ],
  });
}
const TR = (e) => {
    let t = e,
      n = !1;
    try {
      const r = JSON.parse(e);
      (t = JSON.stringify(r, null, 2)), (n = !0);
    } catch {}
    return { formattedMessage: t, isJson: n };
  },
  Bge = W.memo(
    ({
      icon: e,
      origin: t,
      message: n,
      display: r,
      confirmApproval: i,
      denyApproval: s,
      networkID: o,
    }) => {
      const a = Un(),
        {
          parsedMessage: c,
          formattedMessage: u,
          isJson: l,
        } = W.useMemo(() => {
          const A = z.from(n).toString('utf8'),
            _ = r === 'hex' ? `0x${z.from(n).toString('hex')}` : new TextDecoder().decode(n),
            { formattedMessage: x, isJson: k } = TR(_);
          return { parsedMessage: A, formattedMessage: x, isJson: k };
        }, [n, r]),
        {
          isError: d,
          data: f,
          isLoading: h,
        } = $5({ networkID: o ?? Js.Mainnet, type: 'message', url: t, params: { message: c } }),
        p = (f == null ? void 0 : f.warnings) || [],
        b = f == null ? void 0 : f.advancedDetails,
        w = W.useCallback(async () => {
          var A, _, x;
          p != null &&
            p.length &&
            b &&
            b.errorSignInWithSolana &&
            (await a.capture('userIgnoredSignInWithMessageError', {
              data: {
                type: (A = b.errorSignInWithSolana) == null ? void 0 : A.type,
                format: (_ = b.errorSignInWithSolana) == null ? void 0 : _.format,
                origin: t,
                error: (x = b.errorSignInWithSolana) == null ? void 0 : x.error,
              },
            })),
            i == null || i();
        }, [p == null ? void 0 : p.length, b, i, a, t]);
      return h
        ? P.jsx(kp, { type: 'SIGN_MESSAGE', icon: e, domain: t, onClose: s })
        : P.jsx(aT, {
            testID: 'solana-sign-message',
            icon: e,
            origin: t,
            message: u,
            isJson: l,
            networkID: o,
            confirmApproval: w,
            denyApproval: s,
            scanFailed: d,
            scanIsLoading: h,
            scanWarnings: (f == null ? void 0 : f.warnings) || [],
          });
    }
  );
_s.div`
  flex: none;
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;

  > * {
    margin-top: 27px;
  }
`;
_s.div`
  flex: 1;
  overflow: auto;
  padding: 0px 16px;
`;
_s.div`
  position: fixed;
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;
  left: 0;
  bottom: 0;
  background: ${Le.colors.legacy.bgWallet};
`;
_s.div`
  ${(e) => {
    var t, n, r, i;
    return (
      !e.plain &&
      `
    background-color: ${((n = (t = e.theme) == null ? void 0 : t.footer) == null ? void 0 : n.backgroundColor) ?? Le.colors.legacy.bgRow};
    border-top: ${((i = (r = e.theme) == null ? void 0 : r.footer) == null ? void 0 : i.borderTop) ?? `1px solid ${Le.colors.legacy.borderSecondary}`};
  `
    );
  }}
  flex: none;
  padding: 14px 20px;
`;
_s.div`
  padding: 20px;
  height: 100%;
`;
const cT = (e, t, n, r, i = 'textSecondary', s, o, a) => [
    {
      topLeft: e('bottomSheetNetworkFeeRow'),
      ...(a ? { onClick: a, type: 'drawer' } : { type: 'base' }),
      topRight: { text: n && !r ? 'Loading...' : t, color: i },
      ...(s && { bottomLeft: { text: s, color: o ?? 'accentAlert' } }),
    },
  ],
  Dge = (e, t) => (t ? [{ topLeft: e('bottomSheetEstimatedTimeRow'), topRight: t }] : []),
  Rge = (...e) => {
    console != null &&
      console.warn &&
      (qa(e[0]) && (e[0] = `react-i18next:: ${e[0]}`), console.warn(...e));
  },
  Y3 = {},
  IE = (...e) => {
    (qa(e[0]) && Y3[e[0]]) || (qa(e[0]) && (Y3[e[0]] = new Date()), Rge(...e));
  },
  xR = (e, t) => () => {
    if (e.isInitialized) t();
    else {
      const n = () => {
        setTimeout(() => {
          e.off('initialized', n);
        }, 0),
          t();
      };
      e.on('initialized', n);
    }
  },
  Z3 = (e, t, n) => {
    e.loadNamespaces(t, xR(e, n));
  },
  J3 = (e, t, n, r) => {
    qa(n) && (n = [n]),
      n.forEach((i) => {
        e.options.ns.indexOf(i) < 0 && e.options.ns.push(i);
      }),
      e.loadLanguages(t, xR(e, r));
  },
  Nge = (e, t, n = {}) =>
    !t.languages || !t.languages.length
      ? (IE('i18n.languages were undefined or empty', t.languages), !0)
      : t.hasLoadedNamespace(e, {
          lng: n.lng,
          precheck: (r, i) => {
            var s;
            if (
              ((s = n.bindI18n) == null ? void 0 : s.indexOf('languageChanging')) > -1 &&
              r.services.backendConnector.backend &&
              r.isLanguageChangingTo &&
              !i(r.isLanguageChangingTo, e)
            )
              return !1;
          },
        }),
  qa = (e) => typeof e == 'string',
  jge = (e) => typeof e == 'object' && e !== null,
  Lge =
    /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g,
  Uge = {
    '&amp;': '&',
    '&#38;': '&',
    '&lt;': '<',
    '&#60;': '<',
    '&gt;': '>',
    '&#62;': '>',
    '&apos;': "'",
    '&#39;': "'",
    '&quot;': '"',
    '&#34;': '"',
    '&nbsp;': ' ',
    '&#160;': ' ',
    '&copy;': '©',
    '&#169;': '©',
    '&reg;': '®',
    '&#174;': '®',
    '&hellip;': '…',
    '&#8230;': '…',
    '&#x2F;': '/',
    '&#47;': '/',
  },
  $ge = (e) => Uge[e],
  Fge = (e) => e.replace(Lge, $ge);
let zge = {
  bindI18n: 'languageChanged',
  bindI18nStore: '',
  transEmptyNodeValue: '',
  transSupportBasicHtmlNodes: !0,
  transWrapTextNodes: '',
  transKeepBasicHtmlNodesFor: ['br', 'strong', 'i', 'p'],
  useSuspense: !0,
  unescape: Fge,
};
const Kge = () => zge;
let Vge;
const Wge = () => Vge,
  Hge = W.createContext();
class Gge {
  constructor() {
    this.usedNamespaces = {};
  }
  addUsedNamespaces(t) {
    t.forEach((n) => {
      this.usedNamespaces[n] || (this.usedNamespaces[n] = !0);
    });
  }
  getUsedNamespaces() {
    return Object.keys(this.usedNamespaces);
  }
}
const qge = (e, t) => {
    const n = W.useRef();
    return (
      W.useEffect(() => {
        n.current = t ? n.current : e;
      }, [e, t]),
      n.current
    );
  },
  kR = (e, t, n, r) => e.getFixedT(t, n, r),
  Yge = (e, t, n, r) => W.useCallback(kR(e, t, n, r), [e, t, n, r]),
  Zge = (e, t = {}) => {
    var k, j, F, K;
    const { i18n: n } = t,
      { i18n: r, defaultNS: i } = W.useContext(Hge) || {},
      s = n || r || Wge();
    if ((s && !s.reportNamespaces && (s.reportNamespaces = new Gge()), !s)) {
      IE('You will need to pass in an i18next instance by using initReactI18next');
      const D = (B, E) =>
          qa(E)
            ? E
            : jge(E) && qa(E.defaultValue)
              ? E.defaultValue
              : Array.isArray(B)
                ? B[B.length - 1]
                : B,
        C = [D, {}, !1];
      return (C.t = D), (C.i18n = {}), (C.ready = !1), C;
    }
    (k = s.options.react) != null &&
      k.wait &&
      IE(
        'It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.'
      );
    const o = { ...Kge(), ...s.options.react, ...t },
      { useSuspense: a, keyPrefix: c } = o;
    let u = e || i || ((j = s.options) == null ? void 0 : j.defaultNS);
    (u = qa(u) ? [u] : u || ['translation']),
      (K = (F = s.reportNamespaces).addUsedNamespaces) == null || K.call(F, u);
    const l = (s.isInitialized || s.initializedStoreOnce) && u.every((D) => Nge(D, s, o)),
      d = Yge(s, t.lng || null, o.nsMode === 'fallback' ? u : u[0], c),
      f = () => d,
      h = () => kR(s, t.lng || null, o.nsMode === 'fallback' ? u : u[0], c),
      [p, b] = W.useState(f);
    let w = u.join();
    t.lng && (w = `${t.lng}${w}`);
    const A = qge(w),
      _ = W.useRef(!0);
    W.useEffect(() => {
      const { bindI18n: D, bindI18nStore: C } = o;
      (_.current = !0),
        !l &&
          !a &&
          (t.lng
            ? J3(s, t.lng, u, () => {
                _.current && b(h);
              })
            : Z3(s, u, () => {
                _.current && b(h);
              })),
        l && A && A !== w && _.current && b(h);
      const B = () => {
        _.current && b(h);
      };
      return (
        D && (s == null || s.on(D, B)),
        C && (s == null || s.store.on(C, B)),
        () => {
          (_.current = !1),
            s && (D == null || D.split(' ').forEach((E) => s.off(E, B))),
            C && s && C.split(' ').forEach((E) => s.store.off(E, B));
        }
      );
    }, [s, w]),
      W.useEffect(() => {
        _.current && l && b(f);
      }, [s, c, l]);
    const x = [p, s, l];
    if (((x.t = p), (x.i18n = s), (x.ready = l), l || (!l && !a))) return x;
    throw new Promise((D) => {
      t.lng ? J3(s, t.lng, u, () => D()) : Z3(s, u, () => D());
    });
  },
  Jge = ({ setRiskAcknowledged: e }) => {
    const { t } = Zge(),
      [n, r] = W.useState(!1),
      i = () => {
        r((o) => !o);
      };
    W.useEffect(() => {
      e(n);
    }, [n, e]);
    const s = yr({ textAlign: 'left' });
    return P.jsx(ye, {
      style: { backgroundColor: ss(Le.colors.legacy.accentAlert, 0.1) },
      onPress: i,
      testID: 'acknowledge--button',
      borderRadius: 'table',
      padding: 'base',
      direction: 'row',
      width: '100%',
      children: P.jsx(Qj, {
        checked: n,
        onChange: i,
        label: { text: t('maliciousRequestAcknowledge'), color: 'accentAlert', className: s },
        shape: 'square',
        theme: 'alert',
      }),
    });
  },
  uT = Kn.memo(
    ({
      advancedDetails: e,
      confirmApproval: t,
      denyApproval: n,
      hasSimulationFailed: r,
      numTransactions: i,
      domain: s,
      rows: o = [],
      networkFeeRows: a = [],
      isLoading: c,
      isErrorNetworkFee: u,
      isErrorNativeTokenBalance: l,
      simulationResults: d,
      simulationWarnings: f,
      icon: h,
      networkID: p,
      showFriction: b,
      showConfirmAnyway: w,
      testID: A,
    }) => {
      const { t: _ } = Ct(),
        x = oT(p),
        k = f.length > 0 || u || l || r,
        j = f.some((B) => B.severity === Qb.criticalAlert),
        F = d.length === 0,
        K = !r && !(F && k),
        [D, C] = W.useMemo(() => {
          let B = 'row';
          const E = [
            P.jsx(
              on,
              {
                testID: 'secondary-button',
                onClick: n,
                children: _(t ? 'commandCancel' : 'commandClose'),
              },
              'secondary-button'
            ),
          ];
          return (
            !b &&
              !w &&
              t &&
              E.push(
                P.jsx(
                  on,
                  {
                    testID: 'primary-button',
                    theme: j || r ? 'destructive' : 'primary',
                    disabled: c,
                    onClick: t,
                    children: _('commandConfirm'),
                  },
                  'primary-button'
                )
              ),
            b &&
              t &&
              (E.push(
                P.jsx(ye, {
                  height: 24,
                  children: P.jsx(
                    je,
                    {
                      onPress: t,
                      color: ['textSecondary', 'accentAlert'],
                      children: _('commandConfirmUnsafe'),
                    },
                    'friction-confirm-button'
                  ),
                })
              ),
              (B = 'column')),
            w &&
              t &&
              !b &&
              (E.push(
                P.jsx(ye, {
                  children: P.jsx(
                    je,
                    {
                      onPress: t,
                      color: ['textSecondary', 'accentAlert'],
                      children: _('commandConfirmAnyway'),
                    },
                    'confirm-anyway-button'
                  ),
                })
              ),
              (B = 'column')),
            [E, B]
          );
        }, [t, n, j, r, b, w, c, _]);
      return P.jsxs(P.Fragment, {
        children: [
          P.jsxs(ye, {
            justifyContent: 'space-between',
            flex: 1,
            overflow: 'auto',
            padding: 'screen',
            minHeight: 0,
            height: '100%',
            gap: 'section',
            testID: A ?? 'approve-transaction',
            children: [
              P.jsx(v1, {
                domain: s,
                type: i && i > 1 ? 'APPROVE_TRANSACTIONS' : 'APPROVE_TRANSACTION',
                iconUrl: h,
                description: _('notificationBalanceChangesText'),
              }),
              k &&
                P.jsxs(ye, {
                  gap: 8,
                  testID: 'warning-container',
                  children: [
                    f.map((B, E) =>
                      P.jsx(
                        ra,
                        {
                          level: P4(B.severity),
                          testID: 'approval-warning-text',
                          children: B.message,
                        },
                        `simulation-warning-${E}`
                      )
                    ),
                    r &&
                      P.jsx(ra, {
                        level: '1-critical-alert',
                        testID: 'simulation-failed',
                        children: _('notificationFailedToScan'),
                      }),
                    l &&
                      P.jsx(ra, {
                        testID: 'approval-warning-text',
                        level: '3-critical-error',
                        children: _('nativeTokenBalanceErrorWarning'),
                      }),
                    u &&
                      P.jsx(ra, {
                        testID: 'approval-warning-text',
                        level: '3-critical-error',
                        children: _('gasEstimationErrorWarning'),
                      }),
                  ],
                }),
              P.jsxs(ye, {
                gap: 8,
                children: [
                  K && P.jsx(AR, { rows: d }),
                  P.jsx(uo, { rows: [x, ...a, ...o] }),
                  e && P.jsx(sT, { header: _('notificationAdvancedDetailsText'), children: e }),
                ],
              }),
              P.jsx(je, {
                align: 'center',
                marginTop: 'auto',
                font: 'caption',
                color: 'textSecondary',
                children: _('notificationConfirmFooter'),
              }),
            ],
          }),
          P.jsx(Fi, { direction: C, type: 'solid', children: P.jsx(P.Fragment, { children: D }) }),
        ],
      });
    }
  ),
  lT = ({ origin: e, onConfirm: t, onClose: n, warningMessage: r }) => {
    const { t: i } = Ct(),
      s = Un();
    return (
      Kn.useEffect(() => {
        s.capture('blockScreenSeenByUser', { data: { warningMessage: r, url: e } });
      }, [s, e, r]),
      P.jsxs(P.Fragment, {
        children: [
          P.jsxs(ye, {
            testID: 'blocklist-connect-request',
            justifyContent: 'flex-start',
            flex: 1,
            overflow: 'auto',
            padding: 'screen',
            minHeight: 0,
            height: '100%',
            gap: 'section',
            children: [
              P.jsxs(ye, {
                gap: 8,
                children: [
                  P.jsx(sP, { size: 36, color: 'accentAlert' }),
                  P.jsx(je, { font: 'heading2', children: i('maliciousRequestBlockedTitle') }),
                  P.jsx(je, { font: 'caption', color: 'accentAlert', children: ba(e) }),
                ],
              }),
              r && P.jsx(ra, { level: '1-critical-alert', children: r }),
              P.jsx(je, {
                color: 'textSecondary',
                font: 'caption',
                children: i('maliciousRequestBlocked'),
              }),
            ],
          }),
          P.jsxs(Fi, {
            direction: 'column',
            type: 'solid',
            children: [
              P.jsx(on, { onClick: n, children: i('commandClose') }),
              P.jsx(je, {
                onPress: t,
                color: ['textSecondary', 'accentAlert'],
                height: 24,
                children: i('commandProceedAnywayUnsafe'),
              }),
            ],
          }),
        ],
      })
    );
  },
  S1 = ({ origin: e, onConfirm: t, onClose: n, onBack: r, warningMessage: i }) => {
    const [s, o] = Kn.useState(!1),
      { t: a } = Ct();
    return P.jsxs(P.Fragment, {
      children: [
        P.jsxs(ye, {
          testID: 'friction-notification',
          justifyContent: 'flex-start',
          flex: 1,
          overflow: 'auto',
          padding: 'screen',
          minHeight: 0,
          height: '100%',
          gap: 'section',
          children: [
            P.jsxs(ye, {
              gap: 8,
              children: [
                P.jsx(sP, { size: 36, color: 'accentAlert' }),
                P.jsx(je, { font: 'heading2', children: a('maliciousRequestAreYouSure') }),
                P.jsx(je, { font: 'caption', color: 'accentAlert', children: ba(e) }),
              ],
            }),
            i && P.jsx(ra, { level: '1-critical-alert', children: i }),
            P.jsx(je, {
              color: 'textSecondary',
              font: 'caption',
              children: a('maliciousRequestFrictionDescription'),
            }),
            P.jsx(Jge, { setRiskAcknowledged: o }),
          ],
        }),
        P.jsxs(Fi, {
          direction: 'column',
          type: 'solid',
          children: [
            P.jsxs(Fi, {
              direction: 'row',
              children: [
                P.jsx(on, { onClick: r, children: a('commandBack') }),
                P.jsx(on, { onClick: n, children: a('commandClose') }),
              ],
            }),
            P.jsx(ye, {
              height: 24,
              children: P.jsx(je, {
                align: 'center',
                onPress: s ? t : () => {},
                disabled: !s,
                style: {
                  color: s ? Le.colors.legacy.accentAlert : ss(Le.colors.legacy.accentAlert, 0.5),
                },
                children: a('commandYesConfirmUnsafe'),
              }),
            }),
          ],
        }),
      ],
    });
  },
  Xge = (e) => {
    const t = document.createElement('textarea');
    (t.value = e),
      t.setAttribute('readonly', ''),
      (t.style.position = 'absolute'),
      (t.style.left = '-9999px'),
      document.body.appendChild(t);
    const n = document.getSelection().rangeCount > 0 ? document.getSelection().getRangeAt(0) : !1;
    t.select();
    const r = document.execCommand('copy');
    return (
      document.body.removeChild(t),
      n && (document.getSelection().removeAllRanges(), document.getSelection().addRange(n)),
      r
    );
  };
var X3 = {
  copyTransactionButton:
    '_1wc370g1 _1wc370g0 _16y4lb7437 _16y4lb71kj _16y4lb71nr _16y4lb71me _16y4lb7kv _16y4lb71t4',
  transactionValue: '_1wc370g2',
  toastWrapper: '_1wc370g3',
};
const CR = ({ networkID: e, scanResult: t, copyTransactions: n }) => {
    const { t: r } = Ct(),
      i = W.useMemo(
        () =>
          (n || []).map((s, o) =>
            P.jsxs(
              'div',
              {
                className: X3.copyTransactionButton,
                role: 'button',
                'aria-label': r('commandCopy'),
                onClick: () => {
                  Xge(s),
                    Mr.success(qr.t('notificationTransactionCopied'), {
                      id: 'copy-transaction-toast',
                      duration: 3e3,
                    });
                },
                children: [
                  P.jsx('span', { className: X3.transactionValue, children: s.slice(0, 20) }),
                  P.jsx(e9, { size: 16 }),
                ],
              },
              `copy-transaction-${o}`
            )
          ),
        [r, n]
      );
    return P.jsxs(ye, {
      children: [
        i == null
          ? void 0
          : i.map((s, o) =>
              P.jsx(
                ye,
                {
                  marginBottom: 8,
                  children: P.jsx(t9, {
                    topLeft: r('notificationCopyTransactionText'),
                    topRight: s,
                  }),
                },
                `copy-advanced-row-${o}`
              )
            ),
        t && P.jsx(Qge, { selectedAddresses: void 0, scanResult: t, networkID: e }),
      ],
    });
  },
  Qge = ({ selectedAddresses: e, scanResult: t, networkID: n }) => {
    const { data: r } = s4(),
      { t: i } = Ct(),
      s = W.useCallback(
        (a) => {
          if (!r) return '';
          const c = r.explorers[n];
          return VO({ endpoint: 'address', explorerType: c, networkID: n, param: a });
        },
        [r, n]
      ),
      o = W.useMemo(() => {
        var a;
        if (!t) return [];
        if (de.isEVMNetworkID(n) || de.isSolanaNetworkID(n))
          return (a = t.advancedDetails) != null && a.advancedRows
            ? t.advancedDetails.advancedRows.map((u) => ({
                title: u.title,
                rowItems: u.items.map((l) =>
                  l.isAddress
                    ? {
                        type: 'link',
                        topLeft: l.title,
                        topRight: FU(l.value),
                        onClick: () => window.open(s(l.value), '_blank'),
                      }
                    : l.value.length > 50
                      ? {
                          type: 'collapsible',
                          topLeft: { text: l.title },
                          bottomLeft: { text: l.value },
                          allowCopy: !0,
                          onCopied: () => {
                            Mr.success(i('notificationMessageCopied'));
                          },
                        }
                      : { topLeft: l.title, topRight: l.value }
                ),
              }))
            : [];
        if (de.isBitcoinNetworkID(n)) {
          const { inputs: c, outputs: u } = (t == null ? void 0 : t.advancedDetails) ?? {};
          return !c || !u
            ? []
            : [
                ...c.map((d, f) => ({
                  title: `Input #${f + 1}`,
                  rowItems: [
                    {
                      topLeft: 'address',
                      topRight:
                        (e != null && e.includes(d.address) ? 'You · ' : '') + Ty(d.address),
                      type: 'link',
                      onClick: () =>
                        window.open(`https://mempool.space/address/${d.address}`, '_blank'),
                    },
                    { topLeft: 'value', topRight: `${g3(d.amount)} BTC` },
                  ],
                })),
                ...u.map((d, f) => ({
                  title: `Output #${f + 1}`,
                  rowItems: [
                    {
                      topLeft: 'address',
                      topRight:
                        (e != null && e.includes(d.address) ? 'You · ' : '') + Ty(d.address),
                      type: 'link',
                      onClick: () =>
                        window.open(`https://mempool.space/address/${d.address}`, '_blank'),
                    },
                    { topLeft: 'value', topRight: `${g3(d.amount)} BTC` },
                  ],
                })),
              ];
        }
        return [];
      }, [s, n, t, e, i]);
    return P.jsx(P.Fragment, {
      children: o.map((a, c) =>
        P.jsx(eye, { index: c, title: a.title, rowItems: a.rowItems }, `advanced-detail-table-${c}`)
      ),
    });
  },
  eye = ({ title: e, rowItems: t, index: n }) =>
    P.jsxs(P.Fragment, {
      children: [
        P.jsx(ye, {
          padding: 4,
          children: P.jsx(je, { font: 'captionMedium', color: 'textSecondary', children: e }),
        }),
        P.jsx(uo, { rows: t }, `instruction-table-${n}`),
      ],
    });
function E1({ block: e, warnings: t, isLoadingSimulation: n }) {
  const r = t == null ? void 0 : t.some((a) => a.severity === Qb.criticalAlert);
  let i = 'loading';
  !n && e ? (i = 'block') : n || (i = 'main');
  const [s, o] = W.useState(i);
  return (
    W.useEffect(() => {
      o(n ? 'loading' : e ? 'block' : 'main');
    }, [e, n]),
    { showFrictionInterstitial: !!r, initialScreen: i, screen: s, setScreen: o }
  );
}
const tye = (e) => {
    var B, E, y;
    const t = e.url.origin,
      n = ba(t),
      { t: r } = Ct(),
      i = Un(),
      { data: s } = p4(G.Solana),
      o = (s == null ? void 0 : s.address) ?? '',
      a = (s == null ? void 0 : s.networkID) ?? mt.Solana.Mainnet,
      c = W.useMemo(() => {
        const v = [];
        for (const S of e.transactions) {
          const T = wx(S, 'bs58');
          v.push(T);
        }
        return v;
      }, [e.transactions]),
      u = { networkID: a ?? Js.Mainnet, transaction: c },
      {
        data: l,
        isError: d,
        isLoading: f,
      } = JI({
        networkID: a,
        multichainTransaction: u,
        transactionSpeed: 'fastest',
        queryOptions: { refetchInterval: !1 },
      }),
      {
        isError: h,
        data: p,
        isFetched: b,
        isLoading: w,
      } = KI({
        networkID: a,
        type: 'transaction',
        url: e.url.href,
        userAccount: o,
        params: { transactions: e.transactions, method: e.originalMethod },
      }),
      A =
        (p == null ? void 0 : p.error) === $y.INSUFFICIENT_GAS ||
        (p == null ? void 0 : p.error) === $y.INSUFFICIENT_FUNDS,
      {
        screen: _,
        setScreen: x,
        showFrictionInterstitial: k,
      } = E1({
        block: p == null ? void 0 : p.block,
        isLoadingSimulation: w && !b,
        warnings: p == null ? void 0 : p.warnings,
      }),
      j = W.useCallback(async () => {
        e.denyApproval();
      }, [e]),
      F = W.useCallback(async () => {
        e.confirmApproval();
      }, [e]),
      K = W.useCallback(() => {
        i.capture('userIgnoredKnownMaliciousWarning', { data: { origin: t } }), x('main');
      }, [i, t, x]),
      D = W.useMemo(
        () => e.transactions.map((S) => z.from(wx(S, 'bs58').serialize()).toString('base64')),
        [e.transactions]
      ),
      C = W.useMemo(
        () =>
          l != null && l.highFees
            ? r('notificationTransactionApprovalNetworkFeeHighWarning')
            : A
              ? r('transactionNotEnoughNative', { nativeTokenSymbol: 'SOL' })
              : d
                ? r('networkFeeCouldNotFetch')
                : void 0,
        [l, r, A, d]
      );
    return _ === 'block'
      ? P.jsx(lT, {
          warningMessage: ((B = p == null ? void 0 : p.block) == null ? void 0 : B.message) ?? '',
          origin: e.url.origin,
          onConfirm: K,
          onClose: j,
        })
      : _ === 'loading'
        ? P.jsx(kp, {
            type: e.transactions.length === 1 ? 'APPROVE_TRANSACTION' : 'APPROVE_TRANSACTIONS',
            icon: e.icon,
            domain: n,
            onClose: j,
          })
        : _ === 'friction'
          ? P.jsx(S1, {
              onClose: j,
              onConfirm: F,
              onBack: () => x('main'),
              origin: e.url.origin,
              warningMessage:
                (y = (E = p == null ? void 0 : p.warnings) == null ? void 0 : E[0]) == null
                  ? void 0
                  : y.message,
            })
          : P.jsx(uT, {
              advancedDetails: P.jsx(CR, { copyTransactions: D, scanResult: p, networkID: a }),
              testID: 'approve-sol-transaction',
              confirmApproval: k ? () => x('friction') : F,
              denyApproval: j,
              hasSimulationFailed: !!h,
              numTransactions: c.length,
              domain: n,
              rows: [],
              simulationResults: (p == null ? void 0 : p.expectedChanges) ?? [],
              simulationWarnings: (p == null ? void 0 : p.warnings) ?? [],
              icon: e.icon,
              networkID: u.networkID,
              showFriction: k,
              showConfirmAnyway: !k && A,
              isErrorNativeTokenBalance: !1,
              isErrorNetworkFee: d,
              isLoading: f,
              networkFeeRows: [
                ...cT(
                  r,
                  l ? `${Q0e(IP(l == null ? void 0 : l.value))} SOL` : '',
                  f,
                  d,
                  A ? 'accentAlert' : 'textSecondary',
                  C,
                  (l != null && l.highFees) || A || C ? 'accentAlert' : 'textSecondary'
                ),
              ],
            });
  },
  vg = tye;
var Q3 = '_5bfw5t0';
const nye = ({ signInData: e, errorObject: t = {} }) => {
    const { t: n } = Ct(),
      r = Object.entries(e).filter(([s, o]) => s !== 'statement'),
      i = W.useMemo(
        () =>
          r.map(([s, o]) => ({
            topLeft: P.jsx(je, { font: 'caption', children: n(`siwsFieldLable_${s}`) }),
            topRight: P.jsx(je, {
              font: 'caption',
              color: 'textSecondary',
              wordBreak: 'break-word',
              className: Q3,
              children:
                s === 'resources'
                  ? o.join(`
`)
                  : o,
            }),
            bottomLeft:
              s in t
                ? P.jsx(je, {
                    font: 'caption',
                    color: 'accentAlert',
                    className: Q3,
                    children: n(t[s]),
                  })
                : void 0,
            bottomRight: P.jsx(P.Fragment, {}),
          })),
        [r, t, n]
      );
    return P.jsx(uo, { rows: i });
  },
  rye = ({
    confirmApproval: e,
    denyApproval: t,
    url: n,
    signInData: r,
    message: i,
    errorDetails: s,
    icon: o,
  }) => {
    const a = n.origin,
      c = W.useMemo(() => or.decode(i).toString('utf8'), [i]),
      { t: u } = Ct(),
      [l, d] = W.useMemo(() => {
        const h = {};
        if (!s) return [h, 0];
        for (const p of s) h[p.label] = p.message;
        return [h, Object.keys(h).length];
      }, [s]),
      f = oT(mt.Solana.Mainnet);
    return P.jsxs(P.Fragment, {
      children: [
        P.jsxs(ye, {
          justifyContent: 'space-between',
          flex: 1,
          overflow: 'auto',
          padding: 'screen',
          minHeight: 0,
          height: '100%',
          gap: 'section',
          children: [
            P.jsx(v1, {
              type: 'SIGN_IN',
              domain: a,
              iconUrl: o,
              description: u('notificationApplicationApprovalParagraphText'),
            }),
            P.jsxs(ye, {
              gap: 8,
              children: [
                P.jsx(IR, { header: u('notificationMessageHeader'), message: c, isJson: !1 }),
                P.jsx(uo, { rows: [f] }),
                P.jsx(sT, {
                  header: P.jsxs(P.Fragment, {
                    children: [
                      u('notificationAdvancedDetailsText') + ' ',
                      !!d &&
                        P.jsxs(je, {
                          font: 'captionSemibold',
                          color: 'accentAlert',
                          children: ['(', u('siwsErrorNumIssues', { n: d }), ')'],
                        }),
                    ],
                  }),
                  children: P.jsx(nye, { signInData: r, errorObject: l }),
                }),
              ],
            }),
            P.jsx(je, {
              align: 'center',
              marginTop: 'auto',
              font: 'caption',
              color: 'textSecondary',
              children: u('notificationApplicationApprovalSignInDisclaimer'),
            }),
          ],
        }),
        P.jsxs(Fi, {
          direction: 'row',
          type: 'solid',
          children: [
            P.jsx(
              on,
              {
                theme: 'secondary',
                onClick: t,
                testID: 'secondary-button',
                children: u('commandCancel'),
              },
              'secondary'
            ),
            P.jsx(
              on,
              {
                testID: 'primary-button',
                theme: d > 0 ? 'destructive' : 'primary',
                onClick: e,
                children: u('commandConfirm'),
              },
              'primary-button'
            ),
          ],
        }),
      ],
    });
  },
  iye = g.object({ data: g.string(), from: g.string(), to: g.string() });
g.object({ transaction: iye });
const sye = '25.13.0',
  sl = `fungible-tokens-${sye}`,
  oye = [sl, 'token-updates'],
  aye = [sl, 'token-details'],
  cye = [sl, 'portfolio-value'],
  uye = [sl, 'token-balance'],
  lye = [sl, 'infinite-token-balances'],
  dye = [sl, 'visibility-overrides'],
  A1 = {
    infiniteTokenBalances: ({ walletCaip19s: e }) => [...lye, { walletCaip19s: e }],
    tokenBalance: ({ wallets: e, encodedCaip19: t, isSplCompressed: n }) => {
      const r = e
        .map((i) =>
          typeof i == 'string'
            ? i
            : ha({ chainId: i.networkID, address: i.address, resourceType: Pr.address })
        )
        .sort();
      return [...uye, { walletCaip19s: r, encodedCaip19: t, isSplCompressed: n }];
    },
    tokenUpdates: ({ walletCaip19s: e, from: t }) => [...oye, { walletCaip19s: e, from: t }],
    portfolioValue: ({ walletCaip19s: e, include: t, exclude: n, isMainnet: r }) => [
      ...cye,
      { walletCaip19s: e, include: t, exclude: n, isMainnet: r },
    ],
    visibilityOverrides: ({ accountId: e }) => [...dye, { accountId: e }],
    tokenDetails: ({ caip19: e, includePrice: t }) => [...aye, { caip19: e, includePrice: t }],
  },
  Gn = [];
for (let e = 0; e < 256; ++e) Gn.push((e + 256).toString(16).slice(1));
function fye(e, t = 0) {
  return (
    Gn[e[t + 0]] +
    Gn[e[t + 1]] +
    Gn[e[t + 2]] +
    Gn[e[t + 3]] +
    '-' +
    Gn[e[t + 4]] +
    Gn[e[t + 5]] +
    '-' +
    Gn[e[t + 6]] +
    Gn[e[t + 7]] +
    '-' +
    Gn[e[t + 8]] +
    Gn[e[t + 9]] +
    '-' +
    Gn[e[t + 10]] +
    Gn[e[t + 11]] +
    Gn[e[t + 12]] +
    Gn[e[t + 13]] +
    Gn[e[t + 14]] +
    Gn[e[t + 15]]
  ).toLowerCase();
}
let o_;
const hye = new Uint8Array(16);
function pye() {
  if (!o_) {
    if (typeof crypto > 'u' || !crypto.getRandomValues)
      throw new Error(
        'crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported'
      );
    o_ = crypto.getRandomValues.bind(crypto);
  }
  return o_(hye);
}
const gye = typeof crypto < 'u' && crypto.randomUUID && crypto.randomUUID.bind(crypto),
  e8 = { randomUUID: gye };
function yye(e, t, n) {
  var i;
  if (e8.randomUUID && !t && !e) return e8.randomUUID();
  e = e || {};
  const r = e.random ?? ((i = e.rng) == null ? void 0 : i.call(e)) ?? pye();
  if (r.length < 16) throw new Error('Random bytes length must be >= 16');
  if (((r[6] = (r[6] & 15) | 64), (r[8] = (r[8] & 63) | 128), t)) {
    if (((n = n || 0), n < 0 || n + 16 > t.length))
      throw new RangeError(`UUID byte range ${n}:${n + 15} is out of buffer bounds`);
    for (let s = 0; s < 16; ++s) t[n + s] = r[s];
    return t;
  }
  return fye(r);
}
const PR = {
    recipient: '',
    recipientHandle: '',
    addressBookRecipient: void 0,
    amountAsset: new fe(0),
    amountUsd: 0,
    transactionSpeed: 'standard',
    solana: { references: [] },
    multichainTransaction: void 0,
  },
  t8 = {
    sendSessionId: '',
    encodedCaip19: void 0,
    fungibleKey: void 0,
    splTokenAccount: void 0,
    analyticsRecipient: void 0,
    sendFormValues: PR,
    shouldShowFiatValues: !1,
    retryArgs: void 0,
    confirmedFungibleAndSender: null,
    gasEstimation: void 0,
  };
qu((e, t) => ({
  ...By(t8),
  resetSendSlice: () => {
    const n = By(t8);
    (n.sendSessionId = yye()), e(n);
  },
  setAnalyticsRecipient: (n) => {
    e({ analyticsRecipient: n });
  },
  setSendFungibleKey: (n, r, i) => {
    e({ fungibleKey: n, splTokenAccount: r, encodedCaip19: i });
  },
  setSendFormValues: (n) => {
    e({ sendFormValues: n });
  },
  setInputAmount: (n) => {
    const r = t();
    e({ sendFormValues: { ...r.sendFormValues, inputAmount: n } });
  },
  setShouldShowFiatValues: (n) => {
    e({ shouldShowFiatValues: n });
  },
  setRetryArgs: (n) => {
    e({ retryArgs: n });
  },
  setGasEstimation: (n) => {
    e({ gasEstimation: n });
  },
}));
const n8 = { collectible: void 0, sendFormValues: PR, shouldRequireAmount: !1 };
qu((e) => ({
  ...n8,
  resetSendSlice: () => {
    e({ ...n8 });
  },
  setSendCollectible: (t) => {
    e({ collectible: t });
  },
  setSendFormValues: (t) => {
    e({ sendFormValues: t });
  },
  setShouldRequireAmount: (t) => {
    e({ shouldRequireAmount: t });
  },
}));
const bye = { query: '' };
qu((e) => ({
  ...bye,
  setQuery: (t) => {
    e({ query: t });
  },
}));
const a_ = new fe(0),
  mye = ({
    chainAddress: e,
    type: t,
    balance: n,
    decimals: r,
    recipient: i,
    gasEstimation: s,
    clampToZero: o = !0,
  }) => {
    const { data: a, isPending: c } = _0e(e);
    if (!t || !n) return a_;
    const u = new fe(n).multipliedBy(fa(r));
    if (!yc(t)) return u;
    if (!s) return;
    let l = new fe(0);
    if (n1(s)) l = u.minus(new fe(s.value));
    else if (i1(s)) {
      const { gasLimit: d, maxFeePerGas: f, l1Fee: h = new fe(0) } = s,
        p = d.times(f).plus(h);
      l = u.minus(p);
    } else if (s1(s)) {
      if (!e || c) return;
      const d = e.addressType,
        f = (a == null ? void 0 : a.safeToSendUtxos) ?? [],
        h = t1(s.btcPerKilobyte),
        p = i && W9.safeParse(i).success ? i : 'bc1p',
        w = [
          { value: f.reduce((_, x) => _.plus(new fe(x.value)), new fe(0)).toNumber(), address: p },
        ],
        A = qle(d, f, w, h.toNumber(), []);
      if (A.type === 'error') l = new fe(A.maxAmount).integerValue(fe.ROUND_DOWN);
      else {
        const { inputs: _, fee: x } = A;
        l = _.reduce((j, F) => j.plus(new fe(F.value)), new fe(0))
          .minus(x)
          .integerValue(fe.ROUND_DOWN);
      }
    } else if (r1(s)) l = u.minus(s.gasBudget);
    else return qt();
    return l.isGreaterThan(a_) ? l : o ? a_ : l;
  };
new Q5('Unable to unwrap SOL. Wrapped SOL Token account does not exist.');
we({ minutes: 1 });
const dT = (e) => {
    var t;
    return (t = lhe(e)) == null ? void 0 : t[0];
  },
  wye = (e) =>
    de.isBitcoinNetworkID(e.decodedCaip19.chainId) &&
    e.decodedCaip19.resourceType === Pr.nativeToken
      ? e.queriedWalletBalances.map((r) => {
          const i = bs(e.decodedCaip19.chainId, r.address);
          return {
            ...e,
            queriedWalletBalances: [r],
            totalQuantity: r.quantity,
            totalQuantityString: r.quantityString,
            walletAddress: r.address,
            legacyKey: gc
              .get(e.decodedCaip19.chainId)
              .nativeTokenFungibleBalanceKey(e.decodedCaip19.chainId, i),
          };
        })
      : e,
  MR = (e) => (t) =>
    t.flatMap((n) => {
      const r = e(n);
      return wye(r);
    }),
  vye = (e) => {
    const { caip19: t, ...n } = e,
      r = wb(t);
    return {
      ...n,
      type: t.includes('/nativeToken:') ? 'native' : 'fungible',
      chainName: de.getChainName(r.chainId),
      encodedCaip19: t,
      decodedCaip19: r,
      legacyKey: dT(r),
    };
  },
  _ye = (e) => {
    const { caip19: t, timestamp: n, ...r } = e,
      i = wb(t);
    return {
      ...r,
      type: t.includes('/nativeToken:') ? 'native' : 'fungible',
      encodedCaip19: t,
      decodedCaip19: i,
      chainName: de.getChainName(i.chainId),
      timestamp: n ?? void 0,
      legacyKey: dT(i),
      totalQuantity: e.postQuantity,
      totalQuantityString: e.postQuantityString,
    };
  },
  Sye = MR(vye),
  Eye = MR(_ye),
  Aye = g.object({ account: g.string(), quantity: g.number(), quantityString: g.string() }),
  Iye = g.object({
    address: g.string(),
    quantity: g.number(),
    quantityString: g.string(),
    lastTransferredDate: g.coerce.date().nullish(),
    subaccounts: g.array(Aye).optional(),
  }),
  OR = g
    .object({
      price: g.number(),
      priceChange24h: g.number().optional(),
      lastUpdatedAt: g.coerce.date(),
    })
    .nullish(),
  Tye = g.object({
    price: g.number(),
    priceChange24h: g.number().optional(),
    lastUpdatedAt: g.coerce.date(),
  }),
  fT = {
    name: g.string().nullish(),
    symbol: g.string().nullish(),
    decimals: g.number(),
    spamStatus: g.enum(['VERIFIED', 'NOT_VERIFIED', 'POSSIBLE_SPAM', 'SPAM']).nullish(),
    logoUri: g.string().nullish(),
    price: OR,
    livePrice: Tye.nullish().optional(),
    queriedWalletBalances: g.array(Iye),
    extraMetadata: g
      .object({
        compression: g.object({ compressed: g.boolean() }).optional(),
        tokenProgram: g.string().nullish(),
        extensions: g.array(g.unknown()).nullish(),
      })
      .optional(),
  },
  hT = g.object({
    ...fT,
    type: g.enum(['native', 'fungible']),
    totalQuantity: g.number(),
    totalQuantityString: g.string(),
    encodedCaip19: g.string(),
    decodedCaip19: H9,
    chainName: g.string(),
    legacyKey: g.string().nullish(),
    timestamp: g.string().optional(),
    walletAddress: g.string().optional(),
  });
hT.omit({
  totalQuantity: !0,
  totalQuantityString: !0,
  queriedWalletBalances: !0,
  walletAddress: !0,
});
const BR = g.object({
  ...fT,
  caip19: g.string(),
  totalQuantity: g.number(),
  totalQuantityString: g.string(),
});
BR.omit({ totalQuantity: !0, totalQuantityString: !0, queriedWalletBalances: !0 });
const xye = g
    .object({ items: g.array(BR), cursor: g.string().nullish().default(null) })
    .transform((e) => {
      const { items: t, cursor: n, ...r } = e;
      return { ...r, nextCursor: n, tokens: t, updatedAt: Date.now() };
    }),
  kye = g.object({
    ...fT,
    caip19: g.string(),
    timestamp: g.string().nullish(),
    postQuantityString: g.string(),
    postQuantity: g.number(),
  }),
  Cye = g
    .object({ cursor: g.string().nullish().default(null), items: g.array(kye) })
    .transform((e) => ({ nextCursor: e.cursor, transfers: e.items }));
g.object({
  totalValueUsdCentsCurrent: g.number(),
  totalValueUsdStringCurrent: g.string(),
  totalValueUsdCents24h: g.number(),
  totalValueUsdString24h: g.string(),
  totalPercentChange24h: g.number(),
});
g.object({
  totalValueUsdCentsCurrent: g.number().optional(),
  totalValueUsdStringCurrent: g.string().optional(),
  totalValueUsdCents24h: g.number().optional(),
  totalValueUsdString24h: g.string().optional(),
  totalPercentChange24h: g.number().optional(),
});
const r8 = g.object({
    caip19: g.string(),
    name: g.string(),
    symbol: g.string(),
    decimals: g.number(),
    logoUri: g.string().nullish().default(null),
    spamStatus: g
      .enum(['VERIFIED', 'NOT_VERIFIED', 'POSSIBLE_SPAM', 'SPAM'])
      .nullish()
      .transform((e) => e ?? 'NOT_VERIFIED'),
    createdDate: g.coerce.date().nullish().default(null),
    extraMetadata: g.object({
      isMutable: g.boolean().nullish().default(null),
      creators: g
        .array(g.object({ address: g.string(), share: g.number(), verified: g.boolean() }))
        .nullish(),
      tokenProgram: g.string().nullish(),
      extensions: g.array(g.unknown()).nullish(),
    }),
    categories: g
      .object({
        id: g.string(),
        name: g.string(),
        imageUri: g
          .string()
          .nullish()
          .transform((e) => e ?? ''),
        numTokens: g.number(),
      })
      .array()
      .optional(),
  }),
  Pye = r8.extend({
    price: OR,
    extraMetadata: r8.shape.extraMetadata.extend({
      id: g.string().nullish().default(null),
      description: g.string().nullish().default(null),
      marketCap: g.coerce.number().optional(),
      circulatingSupply: g.coerce.number().optional(),
      totalSupply: g.coerce.number().optional(),
      liquidity: g.coerce.number().optional(),
      holders: g.coerce.number().optional(),
      links: g.array(g.object({ type: g.string(), url: g.string() })).optional(),
      volume24hUSD: g.coerce.number().optional(),
      volume24hUSDChangePercentage: g.coerce.number().optional(),
      trades24h: g.coerce.number().optional(),
      trades24hChangePercentage: g.coerce.number().optional(),
      uniqueWallets24h: g.coerce.number().optional(),
      uniqueWallets24hChangePercentage: g.coerce.number().optional(),
      top10HoldersPercent: g.coerce.number().optional(),
      mintable: g.boolean().optional(),
      freezable: g.boolean().optional(),
      mutableMetadata: g.boolean().optional(),
      ownershipRenounced: g.boolean().optional(),
      updateAuthority: g.string().optional(),
    }),
  });
Pye.transform(({ caip19: e, ...t }) => {
  const n = wb(e);
  return {
    ...t,
    type: e.includes('/nativeToken:') ? 'native' : 'fungible',
    chainName: de.getChainName(n.chainId),
    encodedCaip19: e,
    decodedCaip19: n,
    legacyKey: dT(n) ?? e,
  };
});
const Mye = we({ minutes: 10 });
async function DR({ walletCaip19s: e, fungibleCaip19s: t, cursor: n }) {
  const r = { walletAddresses: e.join(','), includePrices: 'true' };
  n && (r.cursor = n), t && t.length > 0 && (r.fungibleAddresses = t.sort().join(','));
  try {
    const i = await Ge.api()
        .timeout(we({ seconds: 30 }))
        .get('/portfolio/v1/fungibles/balances', { params: r })
        .then((o) => {
          var a, c, u;
          if (tr(o)) return o.data;
          throw new Error(
            ((a = o.data) == null ? void 0 : a.message) ||
              ((c = o.data) == null ? void 0 : c.error) ||
              o.statusText,
            { cause: (u = o.data) == null ? void 0 : u.code }
          );
        }),
      s = xye.parse(i);
    return { ...s, tokens: Sye(s.tokens) };
  } catch (i) {
    throw (
      (i instanceof Error &&
        (re.addBreadcrumb(ce.Tokens, 'getTokenBalances', Ie.Error, {
          ...r,
          message: i.message,
          ...(typeof i.cause == 'string' || typeof i.cause == 'number' ? { cause: i.cause } : {}),
        }),
        re.captureError(i, ce.Tokens)),
      i)
    );
  }
}
function Oye({ walletCaip19s: e, isEnabled: t = !0 }) {
  return {
    staleTime: Mye,
    gcTime: we({ days: 3 }),
    queryKey: A1.infiniteTokenBalances({ walletCaip19s: e }),
    enabled: t && !!e.length,
    queryFn: async ({ pageParam: n }) => DR({ walletCaip19s: e, cursor: n }),
    initialPageParam: '',
    getNextPageParam: (n) => (n == null ? void 0 : n.nextCursor) || void 0,
  };
}
function Bye(e) {
  const { walletCaip19s: t, encodedCaip19: n, queryOptions: r = { enabled: !0 } } = e;
  return {
    staleTime: we({ seconds: 10 }),
    gcTime: we({ days: 3 }),
    queryKey: A1.tokenBalance({ wallets: t, encodedCaip19: n }),
    enabled: r.enabled && !!t.length,
    queryFn: async () => (await DR({ walletCaip19s: t, fungibleCaip19s: [n] })).tokens,
  };
}
const ro = {
  BASE_URL: '/',
  DEV: !1,
  MODE: 'production',
  PROD: !0,
  SSR: !1,
  VITE_DATADOG_CLIENT_TOKEN: 'pubf4dfb4e9016d7a11cef2cab4d41ee6ef',
  VITE_DEPLOY_ENVIRONMENT: 'production',
  VITE_RUDDERSTACK_KEY_BROWSER_EMBEDDED: 'cc94b84a-50e8-4aae-8296-ac417de90524',
};
let Dye = 0;
function yt(e, t) {
  const n = `atom${++Dye}`,
    r = {
      toString() {
        return (ro ? 'production' : void 0) !== 'production' && this.debugLabel
          ? n + ':' + this.debugLabel
          : n;
      },
    };
  return (
    typeof e == 'function' ? (r.read = e) : ((r.init = e), (r.read = Rye), (r.write = Nye)),
    t && (r.write = t),
    r
  );
}
function Rye(e) {
  return e(this);
}
function Nye(e, t, n) {
  return t(this, typeof n == 'function' ? n(e(this)) : n);
}
const i8 = (e, t) => (e.unstable_is ? e.unstable_is(t) : t === e),
  TE = (e) => 'init' in e,
  c_ = (e) => !!e.write,
  Xy = new WeakMap(),
  xE = (e) => {
    var t;
    return kE(e) && !((t = Xy.get(e)) != null && t[1]);
  },
  jye = (e, t) => {
    const n = Xy.get(e);
    if (n) (n[1] = !0), n[0].forEach((r) => r(t));
    else if ((ro ? 'production' : void 0) !== 'production')
      throw new Error('[Bug] cancelable promise not found');
  },
  Lye = (e) => {
    if (Xy.has(e)) return;
    const t = [new Set(), !1];
    Xy.set(e, t);
    const n = () => {
      t[1] = !0;
    };
    e.then(n, n),
      (e.onCancel = (r) => {
        t[0].add(r);
      });
  },
  kE = (e) => typeof (e == null ? void 0 : e.then) == 'function',
  s8 = (e) => 'v' in e || 'e' in e,
  _g = (e) => {
    if ('e' in e) throw e.e;
    if ((ro ? 'production' : void 0) !== 'production' && !('v' in e))
      throw new Error('[Bug] atom state is not initialized');
    return e.v;
  },
  RR = (e, t, n) => {
    n.p.has(e) ||
      (n.p.add(e),
      t.then(
        () => {
          n.p.delete(e);
        },
        () => {
          n.p.delete(e);
        }
      ));
  },
  Uye = (e, t, n, r) => {
    var i;
    if ((ro ? 'production' : void 0) !== 'production' && n === e)
      throw new Error('[Bug] atom cannot depend on itself');
    t.d.set(n, r.n), xE(t.v) && RR(e, t.v, r), (i = r.m) == null || i.t.add(e);
  },
  $ye = Symbol.for('JOTAI.EXPERIMENTAL.FLUSHSTOREHOOK'),
  NR = (...e) => {
    const [t, n, r, i, s, o] = e,
      a = (E) => {
        if ((ro ? 'production' : void 0) !== 'production' && !E)
          throw new Error('Atom is undefined or null');
        let y = t(E);
        return y || ((y = { d: new Map(), p: new Set(), n: 0 }), n(E, y), s == null || s(E, B)), y;
      },
      c = new WeakMap(),
      u = new Map(),
      l = new Set(),
      d = new Set(),
      f = () => {
        var E;
        const y = [],
          v = (S) => {
            try {
              S();
            } catch (T) {
              y.push(T);
            }
          };
        do {
          (E = B[$ye]) == null || E.call(B);
          const S = new Set(),
            T = S.add.bind(S);
          u.forEach((M) => {
            var R;
            return (R = M.m) == null ? void 0 : R.l.forEach(T);
          }),
            u.clear(),
            l.forEach(T),
            l.clear(),
            d.forEach(T),
            d.clear(),
            S.forEach(v),
            u.size && _();
        } while (u.size || l.size || d.size);
        if (y.length) throw y[0];
      },
      h = (E, y, v) => {
        const S = 'v' in y,
          T = y.v,
          M = xE(y.v) ? y.v : null;
        if (kE(v)) {
          Lye(v);
          for (const R of y.d.keys()) RR(E, v, a(R));
          y.v = v;
        } else y.v = v;
        delete y.e, (!S || !Object.is(T, y.v)) && (++y.n, M && jye(M, v));
      },
      p = (E) => {
        var y;
        const v = a(E);
        if (s8(v) && ((v.m && c.get(E) !== v.n) || Array.from(v.d).every(([I, U]) => p(I).n === U)))
          return v;
        v.d.clear();
        let S = !0;
        const T = () => {
            v.m && (j(E, v), _(), f());
          },
          M = (I) => {
            if (i8(E, I)) {
              const H = a(I);
              if (!s8(H))
                if (TE(I)) h(I, H, I.init);
                else throw new Error('no atom init');
              return _g(H);
            }
            const U = p(I);
            try {
              return _g(U);
            } finally {
              Uye(E, v, I, U), S || T();
            }
          };
        let R, L;
        const O = {
          get signal() {
            return R || (R = new AbortController()), R.signal;
          },
          get setSelf() {
            return (
              (ro ? 'production' : void 0) !== 'production' &&
                !c_(E) &&
                console.warn('setSelf function cannot be used with read-only atom'),
              !L &&
                c_(E) &&
                (L = (...I) => {
                  if (
                    ((ro ? 'production' : void 0) !== 'production' &&
                      S &&
                      console.warn('setSelf function cannot be called in sync'),
                    !S)
                  )
                    return k(E, ...I);
                }),
              L
            );
          },
        };
        try {
          const I = r(E, M, O);
          return (
            h(E, v, I),
            kE(I) &&
              ((y = I.onCancel) == null || y.call(I, () => (R == null ? void 0 : R.abort())),
              I.then(T, T)),
            v
          );
        } catch (I) {
          return delete v.v, (v.e = I), ++v.n, v;
        } finally {
          S = !1;
        }
      },
      b = (E) => _g(p(E)),
      w = (E) => {
        var y;
        const v = new Map();
        for (const S of ((y = E.m) == null ? void 0 : y.t) || []) {
          const T = a(S);
          T.m && v.set(S, T);
        }
        for (const S of E.p) v.set(S, a(S));
        return v;
      },
      A = (E) => {
        const y = [E];
        for (; y.length; ) {
          const v = y.pop();
          for (const [S, T] of w(v)) c.has(S) || (c.set(S, T.n), y.push(T));
        }
      },
      _ = () => {
        var E;
        const y = [],
          v = new WeakSet(),
          S = new WeakSet(),
          T = Array.from(u);
        for (; T.length; ) {
          const [M, R] = T[T.length - 1];
          if (S.has(M)) {
            T.pop();
            continue;
          }
          if (v.has(M)) {
            c.get(M) === R.n ? y.push([M, R, R.n]) : (c.delete(M), u.set(M, R)), S.add(M), T.pop();
            continue;
          }
          v.add(M);
          for (const [L, O] of w(R)) v.has(L) || T.push([L, O]);
        }
        for (let M = y.length - 1; M >= 0; --M) {
          const [R, L, O] = y[M];
          let I = !1;
          for (const U of L.d.keys())
            if (U !== R && u.has(U)) {
              I = !0;
              break;
            }
          I && (p(R), j(R, L), O !== L.n && (u.set(R, L), (E = L.u) == null || E.call(L))),
            c.delete(R);
        }
      },
      x = (E, ...y) => {
        let v = !0;
        const S = (M) => _g(p(M)),
          T = (M, ...R) => {
            var L;
            const O = a(M);
            try {
              if (i8(E, M)) {
                if (!TE(M)) throw new Error('atom not writable');
                const I = O.n,
                  U = R[0];
                h(M, O, U),
                  j(M, O),
                  I !== O.n && (u.set(M, O), (L = O.u) == null || L.call(O), A(O));
                return;
              } else return x(M, ...R);
            } finally {
              v || (_(), f());
            }
          };
        try {
          return i(E, S, T, ...y);
        } finally {
          v = !1;
        }
      },
      k = (E, ...y) => {
        try {
          return x(E, ...y);
        } finally {
          _(), f();
        }
      },
      j = (E, y) => {
        var v;
        if (y.m && !xE(y.v)) {
          for (const [S, T] of y.d)
            if (!y.m.d.has(S)) {
              const M = a(S);
              F(S, M).t.add(E),
                y.m.d.add(S),
                T !== M.n && (u.set(S, M), (v = M.u) == null || v.call(M), A(M));
            }
          for (const S of y.m.d || [])
            if (!y.d.has(S)) {
              y.m.d.delete(S);
              const T = K(S, a(S));
              T == null || T.t.delete(E);
            }
        }
      },
      F = (E, y) => {
        var v;
        if (!y.m) {
          p(E);
          for (const S of y.d.keys()) F(S, a(S)).t.add(E);
          if (
            ((y.m = { l: new Set(), d: new Set(y.d.keys()), t: new Set() }),
            (v = y.h) == null || v.call(y),
            c_(E))
          ) {
            const S = y.m,
              T = () => {
                let M = !0;
                const R = (...L) => {
                  try {
                    return x(E, ...L);
                  } finally {
                    M || (_(), f());
                  }
                };
                try {
                  const L = o(E, R);
                  L &&
                    (S.u = () => {
                      M = !0;
                      try {
                        L();
                      } finally {
                        M = !1;
                      }
                    });
                } finally {
                  M = !1;
                }
              };
            d.add(T);
          }
        }
        return y.m;
      },
      K = (E, y) => {
        var v;
        if (
          y.m &&
          !y.m.l.size &&
          !Array.from(y.m.t).some((S) => {
            var T;
            return (T = a(S).m) == null ? void 0 : T.d.has(E);
          })
        ) {
          const S = y.m.u;
          S && l.add(S), delete y.m, (v = y.h) == null || v.call(y);
          for (const T of y.d.keys()) {
            const M = K(T, a(T));
            M == null || M.t.delete(E);
          }
          return;
        }
        return y.m;
      },
      B = {
        get: b,
        set: k,
        sub: (E, y) => {
          const v = a(E),
            T = F(E, v).l;
          return (
            T.add(y),
            f(),
            () => {
              T.delete(y), K(E, v), f();
            }
          );
        },
        unstable_derive: (E) => NR(...E(...e)),
      };
    return B;
  },
  Fye = (e) => {
    const t = new Set();
    let n,
      r = 0;
    const i = e.unstable_derive((...a) => {
        const [c, u, , l] = a;
        return (
          (n = c),
          (a[1] = function (f, h) {
            u(f, h);
            const p = h.h;
            h.h = () => {
              p == null || p(), h.m ? t.add(f) : t.delete(f);
            };
          }),
          (a[3] = function (f, h, p, ...b) {
            return r ? p(f, ...b) : l(f, h, p, ...b);
          }),
          a
        );
      }),
      s = i.set;
    return Object.assign(i, {
      dev4_get_internal_weak_map: () => ({
        get: (a) => {
          const c = n(a);
          if (!(!c || c.n === 0)) return c;
        },
      }),
      dev4_get_mounted_atoms: () => t,
      dev4_restore_atoms: (a) => {
        s({
          read: () => null,
          write: (u, l) => {
            ++r;
            try {
              for (const [d, f] of a) TE(d) && l(d, f);
            } finally {
              --r;
            }
          },
        });
      },
    });
  },
  zye = () => {
    const e = new WeakMap(),
      t = NR(
        (n) => e.get(n),
        (n, r) => e.set(n, r).get(n),
        (n, ...r) => n.read(...r),
        (n, ...r) => n.write(...r),
        (n, ...r) => {
          var i;
          return (i = n.unstable_onInit) == null ? void 0 : i.call(n, ...r);
        },
        (n, ...r) => {
          var i;
          return (i = n.onMount) == null ? void 0 : i.call(n, ...r);
        }
      );
    return (ro ? 'production' : void 0) !== 'production' ? Fye(t) : t;
  };
let Sl;
const Kye = () => (
    Sl ||
      ((Sl = zye()),
      (ro ? 'production' : void 0) !== 'production' &&
        (globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = Sl),
        globalThis.__JOTAI_DEFAULT_STORE__ !== Sl &&
          console.warn(
            'Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044'
          ))),
    Sl
  ),
  jR = {
    BASE_URL: '/',
    DEV: !1,
    MODE: 'production',
    PROD: !0,
    SSR: !1,
    VITE_DATADOG_CLIENT_TOKEN: 'pubf4dfb4e9016d7a11cef2cab4d41ee6ef',
    VITE_DEPLOY_ENVIRONMENT: 'production',
    VITE_RUDDERSTACK_KEY_BROWSER_EMBEDDED: 'cc94b84a-50e8-4aae-8296-ac417de90524',
  },
  Vye = W.createContext(void 0),
  LR = (e) => {
    const t = W.useContext(Vye);
    return (e == null ? void 0 : e.store) || t || Kye();
  },
  CE = (e) => typeof (e == null ? void 0 : e.then) == 'function',
  UR = (e) => {
    (e.status = 'pending'),
      e.then(
        (t) => {
          (e.status = 'fulfilled'), (e.value = t);
        },
        (t) => {
          (e.status = 'rejected'), (e.reason = t);
        }
      );
  },
  Wye =
    Kn.use ||
    ((e) => {
      if (e.status === 'pending') throw e;
      if (e.status === 'fulfilled') return e.value;
      throw e.status === 'rejected' ? e.reason : (UR(e), e);
    }),
  u_ = new WeakMap(),
  o8 = (e) => {
    let t = u_.get(e);
    return (
      t ||
        ((t = new Promise((n, r) => {
          let i = e;
          const s = (c) => (u) => {
              i === c && n(u);
            },
            o = (c) => (u) => {
              i === c && r(u);
            },
            a = (c) => {
              'onCancel' in c &&
                typeof c.onCancel == 'function' &&
                c.onCancel((u) => {
                  if ((jR ? 'production' : void 0) !== 'production' && u === c)
                    throw new Error('[Bug] p is not updated even after cancelation');
                  CE(u) ? (u_.set(u, t), (i = u), u.then(s(u), o(u)), a(u)) : n(u);
                });
            };
          e.then(s(e), o(e)), a(e);
        })),
        u_.set(e, t)),
      t
    );
  };
function a8(e, t) {
  const n = LR(t),
    [[r, i, s], o] = W.useReducer(
      (u) => {
        const l = n.get(e);
        return Object.is(u[0], l) && u[1] === n && u[2] === e ? u : [l, n, e];
      },
      void 0,
      () => [n.get(e), n, e]
    );
  let a = r;
  (i !== n || s !== e) && (o(), (a = n.get(e)));
  const c = t == null ? void 0 : t.delay;
  if (
    (W.useEffect(() => {
      const u = n.sub(e, () => {
        if (typeof c == 'number') {
          const l = n.get(e);
          CE(l) && UR(o8(l)), setTimeout(o, c);
          return;
        }
        o();
      });
      return o(), u;
    }, [n, e, c]),
    W.useDebugValue(a),
    CE(a))
  ) {
    const u = o8(a);
    return Wye(u);
  }
  return a;
}
function Hye(e, t) {
  const n = LR(t);
  return W.useCallback(
    (...i) => {
      if ((jR ? 'production' : void 0) !== 'production' && !('write' in e))
        throw new Error('not writable atom');
      return n.set(e, ...i);
    },
    [n, e]
  );
}
const I1 = yt(new vP());
function PE() {
  return (
    (PE = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
          }
          return e;
        }),
    PE.apply(this, arguments)
  );
}
const Gye = (e, t, n) => (e == null ? void 0 : e.suspense) && qye(t, n),
  qye = (e, t) => e.isPending && !t,
  Yye = ({ result: e, throwOnError: t, query: n }) =>
    e.isError && !e.isFetching && Zye(t, [e.error, n]);
function Zye(e, t) {
  return typeof e == 'function' ? e(...t) : !!e;
}
const Jye = (e) =>
  e.suspense && typeof e.staleTime != 'number' ? PE({}, e, { staleTime: 1e3 }) : e;
function $R(e, t, n = (r) => r(I1)) {
  const r = yt(0),
    i = yt(n),
    s = yt(() => new WeakMap()),
    o = yt((u) => {
      const l = u(i),
        d = e(u),
        f = l.defaultQueryOptions(d),
        h = u(s).get(l);
      return (f._optimisticResults = 'optimistic'), h && h.setOptions(f, { listeners: !1 }), Jye(f);
    }),
    a = yt((u) => {
      const l = u(i),
        d = u(o),
        f = u(s),
        h = f.get(l);
      if (h) return h;
      const p = new t(l, d);
      return f.set(l, p), p;
    }),
    c = yt((u) => {
      const l = u(a),
        d = u(o),
        f = l.getOptimisticResult(d),
        h = yt(f);
      return (
        (h.onMount = (p) => {
          const b = l.subscribe(CP.batchCalls(p));
          return () => {
            l.getCurrentResult().isError && l.getCurrentQuery().reset(), b();
          };
        }),
        h
      );
    });
  return yt(
    (u) => {
      u(r);
      const l = u(a),
        d = u(o),
        f = u(u(c));
      if (Gye(d, f, !1)) return l.fetchOptimistic(d);
      if (Yye({ result: f, query: l.getCurrentQuery(), throwOnError: d.throwOnError }))
        throw f.error;
      return f;
    },
    (u, l) => {
      l(r, (d) => d + 1);
    }
  );
}
function FR(e, t = (n) => n(I1)) {
  return $R(e, G9, t);
}
function Xye(e, t = (n) => n(I1)) {
  return $R(e, q9, t);
}
const Qye = {
    BASE_URL: '/',
    DEV: !1,
    MODE: 'production',
    PROD: !0,
    SSR: !1,
    VITE_DATADOG_CLIENT_TOKEN: 'pubf4dfb4e9016d7a11cef2cab4d41ee6ef',
    VITE_DEPLOY_ENVIRONMENT: 'production',
    VITE_RUDDERSTACK_KEY_BROWSER_EMBEDDED: 'cc94b84a-50e8-4aae-8296-ac417de90524',
  },
  l_ = (e, t, n) => (t.has(n) ? t : t.set(n, e())).get(n),
  ebe = new WeakMap(),
  tbe = (e, t, n, r) => {
    const i = l_(() => new WeakMap(), ebe, t),
      s = l_(() => new WeakMap(), i, n);
    return l_(e, s, r);
  };
function ol(e, t, n = Object.is) {
  return tbe(
    () => {
      const r = Symbol(),
        i = ([o, a]) => {
          if (a === r) return t(o);
          const c = t(o, a);
          return n(a, c) ? a : c;
        },
        s = yt((o) => {
          const a = o(s),
            c = o(e);
          return i([c, a]);
        });
      return (s.init = r), s;
    },
    e,
    t,
    n
  );
}
const nbe = (e) => typeof (e == null ? void 0 : e.then) == 'function';
function rbe(
  e = () => {
    try {
      return window.localStorage;
    } catch (n) {
      (Qye ? 'production' : void 0) !== 'production' && typeof window < 'u' && console.warn(n);
      return;
    }
  },
  t
) {
  var n;
  let r, i;
  const s = {
      getItem: (c, u) => {
        var l, d;
        const f = (p) => {
            if (((p = p || ''), r !== p)) {
              try {
                i = JSON.parse(p, t == null ? void 0 : t.reviver);
              } catch {
                return u;
              }
              r = p;
            }
            return i;
          },
          h = (d = (l = e()) == null ? void 0 : l.getItem(c)) != null ? d : null;
        return nbe(h) ? h.then(f) : f(h);
      },
      setItem: (c, u) => {
        var l;
        return (l = e()) == null
          ? void 0
          : l.setItem(c, JSON.stringify(u, t == null ? void 0 : t.replacer));
      },
      removeItem: (c) => {
        var u;
        return (u = e()) == null ? void 0 : u.removeItem(c);
      },
    },
    o = (c) => (u, l, d) =>
      c(u, (f) => {
        let h;
        try {
          h = JSON.parse(f || '');
        } catch {
          h = d;
        }
        l(h);
      });
  let a;
  try {
    a = (n = e()) == null ? void 0 : n.subscribe;
  } catch {}
  return (
    !a &&
      typeof window < 'u' &&
      typeof window.addEventListener == 'function' &&
      window.Storage &&
      (a = (c, u) => {
        if (!(e() instanceof window.Storage)) return () => {};
        const l = (d) => {
          d.storageArea === e() && d.key === c && u(d.newValue);
        };
        return (
          window.addEventListener('storage', l),
          () => {
            window.removeEventListener('storage', l);
          }
        );
      }),
    a && (s.subscribe = o(a)),
    s
  );
}
rbe();
function Ya(e) {
  const t = yt(0),
    n = yt(
      () => ({ i: 0 }),
      (c, u) => {
        const l = c(n);
        return (
          Object.assign(l, { m: !0, peek: c, set: u }),
          u(t, (d) => d + 1),
          () => {
            (l.m = !1), o(l), a(l);
          }
        );
      }
    );
  n.onMount = (c) => c();
  const r = yt((c) => {
      c(t);
      const u = c(n);
      if (!u.m || u.irc || (u.i && !u.irf)) return u.p;
      a(u);
      const l = new Map(),
        d = (b) => {
          const w = c(b);
          return l.set(b, w), w;
        };
      d.peek = u.peek;
      const f = (...b) => {
        try {
          return ++u.i, u.set(...b);
        } finally {
          Array.from(l.keys(), c), --u.i;
        }
      };
      f.recurse = (b, ...w) => {
        if (!u.fc)
          try {
            return (u.irc = !0), u.set(b, ...w);
          } finally {
            (u.irc = !1), Array.from(l).some(h) && s(u);
          }
      };
      function h([b, w]) {
        return c(b) !== w;
      }
      ++u.i;
      function p() {
        try {
          if (((u.irf = !1), !u.m)) return;
          o(u), (u.c = i.effect(d, f));
        } catch (b) {
          (u.e = b), s(u);
        } finally {
          (u.p = void 0), --u.i;
        }
      }
      return u.irf ? p() : (u.p = Promise.resolve().then(p));
    }),
    i = yt((c) => void c(r));
  return (i.effect = e), i;
  function s(c) {
    try {
      (c.irf = !0), c.set(t, (u) => u + 1);
    } finally {
      c.irf = !1;
    }
  }
  function o(c) {
    if (typeof c.c == 'function')
      try {
        (c.fc = !0), c.c();
      } finally {
        (c.fc = !1), (c.c = void 0);
      }
  }
  function a(c) {
    if ('e' in c) {
      const u = c.e;
      throw (delete c.e, u);
    }
  }
}
const ibe = () => {
  var e;
  try {
    return (
      typeof chrome < 'u' &&
      (((e = chrome.runtime) == null ? void 0 : e.id) !== void 0 || typeof browser < 'u')
    );
  } catch (t) {
    return console.error('Error checking for extension context:', t), !1;
  }
};
class sbe {
  constructor(t) {
    ae(this, 'browser');
    ae(this, 'storage');
    if (!t || !t.storage || !t.storage.local)
      throw new Error("[ExtensionStorage] Invalid 'browser' object received.");
    (this.browser = t), (this.storage = this.browser.storage.local);
  }
  async get(t) {
    try {
      const r = (await this.storage.get(t))[t];
      return r == null || typeof r != 'string' ? null : JSON.parse(r);
    } catch (n) {
      return console.error(`[ExtensionStorage.get] Error getting/parsing key (${t}):`, n), null;
    }
  }
  async getAll(t) {
    try {
      const n = await this.storage.get(t),
        r = {};
      for (const i in n)
        if (Object.prototype.hasOwnProperty.call(n, i)) {
          const s = n[i];
          if (s == null || typeof s != 'string') r[i] = null;
          else
            try {
              r[i] = JSON.parse(s);
            } catch (o) {
              console.error(`[ExtensionStorage.getAll] Error parsing key (${i}):`, o),
                (r[i] = null);
            }
        }
      return r;
    } catch (n) {
      const r = `[ExtensionStorage.getAll] Error getting keys (${t}): ${n}`;
      throw (console.error(r), new Error(r));
    }
  }
  async remove(t) {
    try {
      await this.storage.remove(t);
    } catch (n) {
      const r = `[ExtensionStorage.remove] Error removing key(s) (${t}): ${n}`;
      throw (console.error(r), new Error(r));
    }
  }
  async set(t, n) {
    try {
      const r = JSON.stringify(n);
      await this.storage.set({ [t]: r });
    } catch (r) {
      const i = `[ExtensionStorage.set] Error setting/stringifying key (${t}): ${r}`;
      throw (console.error(i), new Error(i));
    }
  }
  async setAll(t) {
    try {
      const n = {};
      for (const r in t)
        Object.prototype.hasOwnProperty.call(t, r) && (n[r] = JSON.stringify(t[r]));
      await this.storage.set(n);
    } catch (n) {
      const i = `[ExtensionStorage.setAll] Error setting/stringifying keys (${Object.keys(t)}): ${n}`;
      throw (console.error(i), new Error(i));
    }
  }
  async update(t, n) {
    if (!navigator.locks) {
      const r = await this.get(t),
        i = await n(r);
      i === null ? await this.remove(t) : await this.set(t, i);
      return;
    }
    try {
      await navigator.locks.request(`storage.${t}`, async (r) => {
        const i = await this.get(t),
          s = await n(i);
        s === null ? await this.remove(t) : await this.set(t, s);
      });
    } catch (r) {
      const i = `[ExtensionStorage.update] Error updating key (${t}): ${r}`;
      throw (console.error(i), new Error(i));
    }
  }
  async clear() {
    try {
      await this.storage.clear();
    } catch (t) {
      const n = `[ExtensionStorage.clear] Error clearing storage: ${t}`;
      throw (console.error(n), new Error(n));
    }
  }
}
class c8 {
  constructor() {
    ae(this, 'storage', window.localStorage);
  }
  async get(t) {
    try {
      const n = this.storage.getItem(t);
      return n === null || typeof n != 'string' ? null : JSON.parse(n);
    } catch (n) {
      return console.error(`[WebLocalStorage.get] Error getting/parsing key (${t}):`, n), null;
    }
  }
  async getAll(t) {
    const n = {},
      r = t ?? Object.keys(this.storage);
    for (const i of r)
      try {
        const s = this.storage.getItem(i);
        if (t && s === null) continue;
        if (s === null || typeof s != 'string') n[i] = null;
        else
          try {
            n[i] = JSON.parse(s);
          } catch (o) {
            console.error(`[WebLocalStorage.getAll] Error parsing key (${i}):`, o), (n[i] = null);
          }
      } catch (s) {
        console.error(`[WebLocalStorage.getAll] Error reading key (${i}) from storage:`, s),
          t || (n[i] = null);
      }
    return n;
  }
  async remove(t) {
    try {
      const n = Array.isArray(t) ? t : [t];
      for (const r of n) this.storage.removeItem(r);
    } catch (n) {
      const r = `[WebLocalStorage.remove] Error removing key(s) (${t}): ${n}`;
      throw (console.error(r), new Error(r));
    }
  }
  async set(t, n) {
    try {
      const r = JSON.stringify(n);
      this.storage.setItem(t, r);
    } catch (r) {
      const i = `[WebLocalStorage.set] Error setting/stringifying key (${t}): ${r}`;
      throw (console.error(i), new Error(i));
    }
  }
  async setAll(t) {
    let n = !1;
    const r = Object.keys(t);
    for (const i in t)
      if (Object.prototype.hasOwnProperty.call(t, i))
        try {
          await this.set(i, t[i]);
        } catch {
          n = !0;
        }
    if (n)
      throw new Error(
        `[WebLocalStorage.setAll] One or more errors occurred while setting keys (${r})`
      );
  }
  async update(t, n) {
    if (!navigator.locks) {
      const r = await this.get(t),
        i = await n(r);
      i === null ? await this.remove(t) : await this.set(t, i);
      return;
    }
    try {
      await navigator.locks.request(`storage.${t}`, async (r) => {
        const i = await this.get(t),
          s = await n(i);
        s === null ? await this.remove(t) : await this.set(t, s);
      });
    } catch (r) {
      const i = `[WebLocalStorage.update] Error updating key (${t}): ${r}`;
      throw (console.error(i), new Error(i));
    }
  }
  async clear() {
    try {
      this.storage.clear();
    } catch (t) {
      const n = `[WebLocalStorage.clear] Error clearing storage: ${t}`;
      throw (console.error(n), new Error(n));
    }
  }
}
class obe {
  constructor() {
    ae(this, 'initPromise');
    ae(this, 'storageImpl', null);
    (this.initPromise = this._initialize()),
      this.initPromise.catch((t) => {
        console.error('LocalStorage initialization failed:', t);
      });
  }
  async _initialize() {
    if (!this.storageImpl)
      if (ibe())
        try {
          const n = (
            await mA(
              () => import('./browser-polyfill--SpK_K58.js').then((r) => r.b),
              __vite__mapDeps([13, 2])
            )
          ).default;
          if (!n || !n.storage || !n.storage.local)
            throw new Error('webextension-polyfill loaded but missing storage.local API.');
          this.storageImpl = new sbe(n);
        } catch {
          this.storageImpl = new c8();
        }
      else this.storageImpl = new c8();
  }
  async ensureInitialized() {
    if ((await this.initPromise, !this.storageImpl))
      throw new Error('LocalStorage is not initialized. Initialization may have failed.');
  }
  async get(t) {
    return await this.ensureInitialized(), this.storageImpl.get(t);
  }
  async getAll(t) {
    return await this.ensureInitialized(), this.storageImpl.getAll(t);
  }
  async remove(t) {
    return await this.ensureInitialized(), this.storageImpl.remove(t);
  }
  async set(t, n) {
    return await this.ensureInitialized(), this.storageImpl.set(t, n);
  }
  async setAll(t) {
    return await this.ensureInitialized(), this.storageImpl.setAll(t);
  }
  async update(t, n) {
    return await this.ensureInitialized(), this.storageImpl.update(t, n);
  }
  async clear() {
    return await this.ensureInitialized(), this.storageImpl.clear();
  }
}
const u8 = new obe();
class abe {
  constructor(t) {
    ae(this, 'namespaceKey');
    ae(this, 'ttlMilliseconds');
    ae(this, 'storage');
    ae(this, 'onError');
    ae(this, 'data', {});
    ae(this, 'isLoaded', !1);
    (this.namespaceKey = t.namespaceKey),
      (this.ttlMilliseconds = t.ttlMilliseconds),
      (this.storage = t.storage),
      (this.onError = t.onError),
      this._load()
        .then(() => {
          if (this._cleanupExpired()) return this._save();
        })
        .catch((n) => {
          console.error('Failed to load data', n);
        });
  }
  async _load() {
    var t, n;
    if (!this.isLoaded) {
      try {
        const r = await this.storage.get(this.namespaceKey);
        r
          ? ((this.data = r),
            (typeof this.data != 'object' || this.data === null) &&
              ((t = this.onError) == null ||
                t.call(this, new Error('Stored data is not a valid object.'), 'load'),
              (this.data = {})))
          : (this.data = {});
      } catch (r) {
        (n = this.onError) == null ||
          n.call(this, r instanceof Error ? r : new Error('Failed to parse stored data'), 'load'),
          (this.data = {});
      }
      this.isLoaded = !0;
    }
  }
  async _save() {
    var t;
    try {
      await this.storage.set(this.namespaceKey, this.data);
    } catch (n) {
      (t = this.onError) == null ||
        t.call(
          this,
          n instanceof Error ? n : new Error('Failed to serialize data for storage'),
          'save'
        );
    }
  }
  _cleanupExpired() {
    const t = Date.now();
    let n = !1;
    for (const r in this.data)
      Object.prototype.hasOwnProperty.call(this.data, r) &&
        this.data[r].expiresAt <= t &&
        (delete this.data[r], (n = !0));
    return n;
  }
  _updateExpiration(t) {
    return this.data[t] ? ((this.data[t].expiresAt = Date.now() + this.ttlMilliseconds), !0) : !1;
  }
  async set(t, n) {
    this.isLoaded || (await this._load()),
      this._cleanupExpired(),
      (this.data[t] = { value: n, expiresAt: Date.now() + this.ttlMilliseconds }),
      await this._save();
  }
  async get(t, n) {
    var a;
    this.isLoaded || (await this._load());
    const r = this._cleanupExpired(),
      i = this.data[t];
    if (!i) return r && (await this._save()), null;
    const s = this._updateExpiration(t),
      o = n.safeParse(i.value);
    return o.success
      ? ((r || s) && (await this._save()), o.data)
      : ((a = this.onError) == null ||
          a.call(this, new oA(o.error.issues), `get (validation failed for key: ${t})`),
        delete this.data[t],
        await this._save(),
        null);
  }
  async remove(t) {
    const n = this._cleanupExpired();
    let r = !1;
    Object.prototype.hasOwnProperty.call(this.data, t) && (delete this.data[t], (r = !0)),
      (n || r) && (await this._save());
  }
  async clear() {
    (this.data = {}), await this._save();
  }
}
const l8 = new Map();
function d8({ storage: e, namespaceKey: t, ttlMs: n }) {
  const r = l8.get(t);
  if (r) return r;
  if (!e) throw new Error('Storage is required');
  const i = new abe({
    storage: e,
    namespaceKey: t,
    ttlMilliseconds: n,
    onError: (s, o) => {
      console.error(`[PersistentStore Error - ${o}]:`, s.message),
        s instanceof oA && console.error('Zod Issues:', s.issues);
    },
  });
  return l8.set(t, i), i;
}
function zR({
  atomToStoreOffline: e,
  namespaceKey: t,
  ttlMs: n,
  initialValue: r,
  schema: i,
  ...s
}) {
  const o = yt({ status: 'pending', value: r }),
    a = yt((d) => {
      if ('offlineKey' in s) return d(s.offlineKey);
      const f = d(e);
      if ('offlineKey' in f && typeof f.offlineKey == 'string') return f.offlineKey;
      throw new Error('No key provided');
    }),
    c = Ya((d, f) => {
      d8({ storage: u8, namespaceKey: `.offline.${t}`, ttlMs: n })
        .get(d(a), i)
        .then((h) => {
          h && f(o, { status: 'offline', value: h });
        })
        .catch((h) => {
          console.error(h);
        });
    }),
    u = Ya((d, f) => {
      d(a), f(o, { status: 'pending', value: r });
    }),
    l = Ya((d, f) => {
      const h = d(e),
        p = d(a);
      h.status === 'success' &&
        h.data &&
        h.data !== d(o).value &&
        d8({ storage: u8, namespaceKey: `.offline.${t}`, ttlMs: n })
          .set(p, h.data)
          .then(() => {
            h.data && f(o, { status: 'live', value: h.data });
          })
          .catch((b) => {
            console.error(b);
          });
    });
  return ol(
    yt((d) => {
      const f = d(e);
      d(u), d(c), d(l);
      const h = d(o);
      return f.data ? { status: 'live', value: f.data } : { status: 'offline', value: h.value };
    }),
    (d) => d.value
  );
}
async function cbe(e) {
  const t = { walletAddresses: e.walletCaip19s.join(','), includePrices: 'true' };
  'cursor' in e && (t.cursor = e.cursor),
    'fromMicroseconds' in e
      ? (t.fromTimestamp = e.fromMicroseconds.toString())
      : 'from' in e && (t.fromTimestamp = e.from.toString());
  const n = await Ge.api()
    .timeout(we({ seconds: 30 }))
    .get('/portfolio/v1/fungibles/updates', { params: t })
    .then((r) => {
      var i, s, o, a;
      if (tr(r)) return r.data;
      throw new Error(
        ((i = r.data) == null ? void 0 : i.message) ||
          ((s = r.data) == null ? void 0 : s.error) ||
          r.statusText,
        {
          cause:
            ((o = r.data) == null ? void 0 : o.code) ?? ((a = r.data) == null ? void 0 : a.name),
        }
      );
    })
    .catch((r) => {
      throw (
        (re.addBreadcrumb(ce.Tokens, 'getTokenBalanceUpdates', Ie.Error, {
          message: r.message,
          cause: r.cause,
          ...t,
        }),
        re.captureError(r, ce.Tokens),
        r)
      );
    });
  try {
    return Cye.parse(n);
  } catch (r) {
    throw (
      (r instanceof oA &&
        re.addBreadcrumb(ce.Tokens, 'getTokenBalanceUpdates parse error', Ie.Error, {
          message: r.message,
          ...(r.issues ? { issues: JSON.stringify(r.issues) } : {}),
          result: JSON.stringify(n),
        }),
      r)
    );
  }
}
async function ube(e) {
  const t = [],
    n = () => {
      var r;
      return (r = t.at(-1)) == null ? void 0 : r.nextCursor;
    };
  do {
    const r = n(),
      i = await cbe(r ? { walletCaip19s: e.walletCaip19s, cursor: r } : e);
    t.push(i);
  } while (n());
  return Eye(t.flatMap((r) => r.transfers));
}
function lbe({ newUpdates: e, existingUpdates: t = {} }) {
  return e.reduce((n, r) => {
    var i;
    return ((i = n[r.encodedCaip19]) == null ? void 0 : i.totalQuantityString) ===
      r.totalQuantityString
      ? n
      : r.chainName === 'Solana' &&
          r.decodedCaip19.resourceType === Pr.address &&
          r.queriedWalletBalances.some((s) => {
            var o;
            return !((o = s.subaccounts) != null && o.length);
          })
        ? { ...n, [`${r.encodedCaip19}-compressed`]: r }
        : r
          ? { ...n, [r.encodedCaip19]: r }
          : n;
  }, t);
}
function KR(e) {
  var a;
  const t = e.match(/(.*\d{2}:\d{2}:\d{2})\.(?<fraction>\d+)Z/);
  if (!t || !((a = t.groups) != null && a.fraction)) throw new Error('Invalid date format');
  const n = new Date(e).getTime(),
    s = t.groups.fraction.padEnd(6, '0').slice(-3);
  return n * 1e3 + parseInt(s, 10);
}
const dbe = yt(!1),
  VR = yt(null),
  pT = yt((e) => {
    const t = e(VR);
    return t
      ? t.addresses
          .map((n) => ha({ chainId: n.networkID, address: n.address, resourceType: Pr.address }))
          .sort()
      : [];
  }),
  Cp = Xye((e) => {
    const t = e(pT);
    return Oye({ walletCaip19s: t });
  }),
  fbe = yt((e) => {
    const { data: t } = e(Cp),
      n = t == null ? void 0 : t.pages[0];
    return !n || !n.tokens.length ? 0 : n.updatedAt;
  }),
  T1 = ol(VR, (e) => (e == null ? void 0 : e.identifier)),
  hbe = 1e3,
  WR = 5e3,
  HR = Math.ceil(WR * 2.25);
function GR(e) {
  return we(e) * 1e3;
}
function pbe(e) {
  if (!(e != null && e.length)) return null;
  const t = new Date(Date.now() - HR).toISOString();
  return Math.floor(Math.max(...e.map(({ timestamp: n }) => KR(n || t))));
}
function gbe(e) {
  const t = pbe(e);
  return t ? t - GR({ seconds: 1 }) : null;
}
const ybe = FR((e) => {
    const t = e(I1),
      n = e(fbe),
      r = Math.floor(n - we({ minutes: 10 })),
      i = e(pT),
      s = e(dbe),
      o = r > Date.now() - we({ days: 10 }),
      a = A1.tokenUpdates({ walletCaip19s: i, from: r }),
      c = async () => {
        var h, p;
        const u = (h = t.getQueryData(a)) == null ? void 0 : h.lastTimestamp;
        if (!u) {
          const b = new Date(r - HR).toISOString();
          return { updates: {}, lastTimestamp: KR(b) };
        }
        const l = await ube({ walletCaip19s: i, fromMicroseconds: u - GR({ seconds: 30 }) }),
          d = ((p = t.getQueryData(a)) == null ? void 0 : p.updates) ?? {};
        return {
          updates: lbe({ newUpdates: l, existingUpdates: d }),
          lastTimestamp: Math.max(gbe(l) ?? 0, u),
        };
      };
    return {
      meta: { fetchCount: 0 },
      enabled: o && !s && i.length > 0,
      queryKey: a,
      refetchInterval: (u) => {
        var d;
        const l = Number(((d = u.meta) == null ? void 0 : d.fetchCount) ?? 0);
        return u.meta && (u.meta.fetchCount = l + 1), Math.min(Math.max(l * 250, hbe), WR);
      },
      queryFn: c,
    };
  }),
  bbe = zR({
    atomToStoreOffline: ybe,
    offlineKey: yt((e) => `${e(T1) ?? ''}:token-balance-updates`),
    namespaceKey: 'fungible-tokens',
    ttlMs: we({ days: 10 }),
    initialValue: { updates: {}, lastTimestamp: 0 },
    schema: g.object({ updates: g.record(g.string(), hT), lastTimestamp: g.number() }),
  }),
  qR = ol(
    bbe,
    (e) => (e == null ? void 0 : e.updates) ?? {},
    (e, t) => JSON.stringify(e) === JSON.stringify(t)
  );
function YR(e) {
  return (t) => {
    var i, s;
    let n = !1;
    const r = { ...t };
    for (const [o, a] of Object.entries(e)) {
      const c = a == null ? void 0 : a.price,
        u = a != null && a.lastUpdatedAt ? new Date(a.lastUpdatedAt) : null;
      if (!c || !u) continue;
      const l =
        ((i = t[o]) == null ? void 0 : i.price) !== c &&
        (!((s = t[o]) != null && s.lastUpdatedAt) || u > t[o].lastUpdatedAt);
      (n = n || l),
        l && (r[o] = { price: a.price, priceChange24h: a.priceChange24h, lastUpdatedAt: u });
    }
    return n ? r : t;
  };
}
const mbe = yt((e) => {
    const { data: t, status: n } = e(Cp);
    return { data: t == null ? void 0 : t.pages.flatMap((r) => r.tokens), status: n };
  }),
  x1 = zR({
    atomToStoreOffline: mbe,
    offlineKey: yt((e) => `${e(T1) ?? ''}:infinite-tokens`),
    namespaceKey: 'fungible-tokens',
    ttlMs: we({ days: 10 }),
    initialValue: [],
    schema: g.array(hT),
  }),
  Qy = yt({}),
  wbe = yt((e) =>
    e(x1)
      .slice(-100)
      .reduce((r, i) => (i.price && (r[i.encodedCaip19] = i.price), r), {})
  ),
  vbe = Ya((e, t) => {
    const n = e(wbe);
    !n || Object.keys(n).length === 0 || t(Qy, YR(n));
  }),
  _be = yt((e) => {
    const t = e(qR);
    return Object.values(t).reduce((r, i) => (i.price && (r[i.encodedCaip19] = i.price), r), {});
  }),
  Sbe = Ya((e, t) => {
    const n = e(_be);
    !n || Object.keys(n).length === 0 || t(Qy, YR(n));
  }),
  gT = yt(
    (e) => (e(vbe), e(Sbe), e(Qy)),
    (e, t, n) => {
      t(Qy, n);
    }
  ),
  Ebe = ol(Cp, (e) => e.hasNextPage),
  El = yt(1 / 0),
  eb = yt(
    (e) => (e(Abe), e(Ibe), e(Ebe) ? e(El) : 0),
    (e, t, n) => {
      if (n === null) {
        t(El, 1 / 0);
        return;
      }
      const r = Math.min(e(El), n);
      r !== e(El) && t(El, r);
    }
  ),
  Abe = Ya((e, t) => {
    const { hasNextPage: n } = e(Cp),
      r = e(x1),
      i = e(gT);
    if (r.length > 0 && !n) {
      t(eb, 0);
      return;
    }
    const s = r
      .slice(-100)
      .filter((o) => o.type === 'fungible')
      .map((o) => {
        const a = i[o.encodedCaip19] ?? o.price;
        return a ? (o.totalQuantity * a.price) / 10 ** o.decimals : 1 / 0;
      });
    t(eb, Math.min(...s));
  }),
  Ibe = Ya((e, t) => {
    e(T1) && t(eb, 1 / 0);
  });
function Tbe(e, t) {
  if (e.type === 'native' && t.type !== 'native') return -1;
  if (e.type !== 'native' && t.type === 'native') return 1;
  if (e.type === 'native' && t.type === 'native')
    return e.name && t.name ? e.name.localeCompare(t.name) : 0;
}
function xbe(e, t) {
  if (!e && t) return 1;
  if (e && !t) return -1;
}
function f8(e, t) {
  if (e && t) return e.localeCompare(t);
  if (e && !t) return -1;
  if (!e && t) return 1;
}
function h8(e, t) {
  if (e !== t) return t - e;
}
function kbe(e) {
  return { totalQuantity: e.totalQuantity, totalQuantityString: e.totalQuantityString };
}
const Cbe = yt((e) => {
    const t = e(x1),
      n = e(qR),
      r = new Set(Object.keys(n));
    if (t.length === 0) return [];
    const i = t.map((s) => {
      var c, u;
      const o =
          (u = (c = s.extraMetadata) == null ? void 0 : c.compression) != null && u.compressed
            ? `${s.encodedCaip19}-compressed`
            : s.encodedCaip19,
        a = n[o];
      return a ? (r.delete(o), { ...s, ...kbe(a) }) : s;
    });
    return (
      r.forEach((s) => {
        const o = n[s];
        o && i.push(o);
      }),
      i
    );
  }),
  Pbe = yt((e) => {
    const t = e(gT),
      n = e(Cbe),
      r = e(eb),
      i = n
        .filter((s) => s.totalQuantity > 0 || s.type === 'native')
        .map((s) => ({ ...s, livePrice: t[s.encodedCaip19] ?? s.price }))
        .sort((s, o) => {
          var b, w;
          const a = (b = s.livePrice) == null ? void 0 : b.price,
            c = (w = o.livePrice) == null ? void 0 : w.price,
            u = xbe(a, c);
          if (u) return u;
          const l = s.totalQuantity / 10 ** s.decimals,
            d = o.totalQuantity / 10 ** o.decimals;
          if (!a && !c) {
            const A = Tbe(s, o);
            if (A) return A;
            const _ = h8(l, d);
            if (_) return _;
            const x = f8(s.name, o.name);
            return x || 0;
          }
          const f = (a ?? 0) * l,
            h = (c ?? 0) * d,
            p = h8(f, h);
          return p || (f8(s.name, o.name) ?? 0);
        });
    return r
      ? i.filter((s) => {
          var u;
          const o = (u = s.livePrice) == null ? void 0 : u.price,
            a = s.totalQuantity / 10 ** s.decimals;
          return (o ?? 0) * a >= r;
        })
      : i;
  });
function Mbe(e) {
  if (e) return typeof e == 'string' || typeof e == 'number' ? new Date(e) : e;
}
function Obe(e, { key: t, newPriceData: n }) {
  const r = e[t];
  if (!n || (r == null ? void 0 : r.price) === (n == null ? void 0 : n.price)) return e;
  const i = Mbe(n.lastUpdatedAt);
  return !i || !(!(r != null && r.lastUpdatedAt) || i > r.lastUpdatedAt)
    ? e
    : {
        ...e,
        [t]: {
          price: n.price,
          priceChange24h: n.priceChange24h ?? n.usd_24h_change,
          lastUpdatedAt: i,
        },
      };
}
const Bbe = (e, t, n) => {
    var s, o, a, c;
    const r =
        (o = (s = e.extraMetadata) == null ? void 0 : s.compression) == null
          ? void 0
          : o.compressed,
      i =
        (c = (a = t.extraMetadata) == null ? void 0 : a.compression) == null
          ? void 0
          : c.compressed;
    if (r !== i) return n ? (r ? -1 : 1) : r ? 1 : -1;
  },
  Dbe = (e, t, n) => {
    const r = e.legacyKey === n,
      i = t.legacyKey === n;
    if (r !== i) return r ? -1 : 1;
  },
  Rbe = ({ isSplCompressed: e, legacyKey: t }, n) =>
    n.length
      ? n.length === 1
        ? n[0]
        : [...n].sort((i, s) => {
            if (
              e !== void 0 &&
              (i.encodedCaip19.includes('solana:') || s.encodedCaip19.includes('solana:'))
            ) {
              const o = Bbe(i, s, e);
              if (o) return o;
            }
            if (t) {
              const o = Dbe(i, s, t);
              if (o) return o;
            }
            return s.totalQuantity - i.totalQuantity;
          })[0]
      : null,
  Nbe = (e) => {
    const t = a8(pT),
      n = a8(Pbe),
      r = W.useMemo(
        () =>
          n.filter(
            (a) =>
              a.encodedCaip19 === e.encodedCaip19 && (!e.legacyKey || a.legacyKey === e.legacyKey)
          ),
        [e.encodedCaip19, e.legacyKey]
      ),
      i = Bye({ ...e, walletCaip19s: t });
    i.refetchInterval || (i.refetchInterval = we({ seconds: 3 }));
    const s = Qt({ ...i, select: (a) => Rbe(e, a), placeholderData: r }),
      o = Hye(gT);
    return (
      W.useEffect(() => {
        const a = s.data;
        a &&
          !s.isPlaceholderData &&
          a.price &&
          o((c) => {
            const u = a.encodedCaip19,
              l = a.price;
            return Obe(c, { key: u, newPriceData: l });
          });
      }, [s.data, s.isPlaceholderData, o]),
      s
    );
  },
  jbe = ({ networkID: e, queryOptions: t, addressType: n }) => {
    const r = { chainId: e, slip44: de.getSlip44(e), resourceType: Pr.nativeToken },
      i = gc.get(e).nativeTokenFungibleBalanceKey(e, n) ?? null,
      s = ha(r);
    return Nbe({ encodedCaip19: s, legacyKey: i, queryOptions: t });
  };
function Lbe(e, t) {
  return {
    gcTime: c1.Long,
    staleTime: u1.Never,
    enabled: !!t && !!e,
    queryKey: A1.visibilityOverrides({ accountId: t ?? '' }),
    async queryFn() {
      return !t || !e ? new Map() : await cR(e, t);
    },
  };
}
const Ube = yt(null),
  $be = new Map(),
  ZR = FR((e) => {
    const t = e(Ube),
      n = e(T1);
    return Lbe(t, n);
  }),
  Fbe = ol(ZR, (e) => e.status);
yt((e) => e(ZR).data ?? $be);
const zbe = yt((e) => {
  const { isLoading: t } = e(Cp),
    n = e(x1),
    r = e(Fbe);
  return (t && n.length === 0) || r === 'pending';
});
ol(zbe, (e) => e);
const Kbe = ({
    networkID: e,
    addressType: t,
    gasEstimation: n,
    transactionValue: r = new fe(0),
    recipient: i,
  }) => {
    const { data: s, isLoading: o, isError: a } = jbe({ networkID: e, addressType: t }),
      c = gc.get(e).nativeFungibleTokenType;
    let u = 'unknown',
      l = '';
    const d = W.useMemo(() => {
        var b;
        const h =
          (b = s == null ? void 0 : s.queriedWalletBalances[0]) == null ? void 0 : b.address;
        if (!h) return;
        const p = bs(e, h);
        return { networkID: e, address: h, addressType: p };
      }, [s == null ? void 0 : s.queriedWalletBalances, e]),
      f = mye({
        chainAddress: d,
        type: c,
        balance:
          s != null && s.totalQuantityString
            ? new fe(s == null ? void 0 : s.totalQuantityString)
            : void 0,
        decimals: (s == null ? void 0 : s.decimals) ?? 0,
        recipient: i,
        gasEstimation: n,
        clampToZero: !1,
      });
    return (
      !a &&
        s &&
        f &&
        (f.gte(r) ? (u = 'sufficient') : (u = 'insufficient'),
        (l = (s == null ? void 0 : s.symbol) || '')),
      W.useMemo(
        () => ({ hasSufficientFunds: u, nativeTokenSymbol: l, isLoading: o, isError: a }),
        [u, l, o, a]
      )
    );
  },
  p8 = qu((e) => ({
    transactionSpeed: er.standard,
    setTransactionSpeed: (t) => e({ transactionSpeed: t }),
  })),
  JR = (e, t) => {
    const { status: n, data: r } = ZI({ networkID: e, enableFallback: !0 }),
      i = p8((c) => c.transactionSpeed),
      s = p8((c) => c.setTransactionSpeed),
      o = Mu.get(e).supportsNetworkSettings && n !== 'error' && r && i && t;
    return {
      transactionSpeed: i,
      setTransactionSpeed: s,
      canOpenGasSettings: o,
      resetTransactionSpeed: () => {
        s(er.standard);
      },
    };
  },
  Vbe = (e, t, n, r) => {
    const {
        data: i,
        isPending: s,
        isError: o,
      } = JI({
        networkID: e,
        multichainTransaction: t,
        transactionSpeed: n,
        queryOptions: { refetchInterval: Y9 },
      }),
      { data: a, isPending: c, isError: u } = c0e(e, i),
      l = n ? Mu.get(e).transactionSpeedDescription(n, !0) : void 0,
      d = l ? r(l) : '';
    return {
      networkFee: oR({ networkID: t.networkID, gasEstimation: i, gasEstimationPrice: a }),
      isLoadingNetworkFee: s || c,
      gasEstimation: i,
      isErrorGasEstimation: o,
      isErrorGasEstimationPrice: u,
      estimatedTime: d,
    };
  },
  Wbe = (e) => {
    var H, X, J;
    const t = ba(e.url.origin),
      { url: n, icon: r } = e,
      i = n.origin,
      s = Un(),
      o = bb.parse(
        `eip155:${e.transaction.chainId ? parseInt(e.transaction.chainId, 16) : void 0}`
      ),
      { t: a } = Ct(),
      {
        data: c,
        isError: u,
        isFetched: l,
        isLoading: d,
      } = KI({
        networkID: o,
        url: n.href,
        userAccount: e.transaction.from,
        params: { transactions: [e.transaction], method: 'eth_sendTransaction' },
        type: 'transaction',
      }),
      f =
        (c == null ? void 0 : c.error) === $y.INSUFFICIENT_GAS ||
        (c == null ? void 0 : c.error) === $y.INSUFFICIENT_FUNDS,
      {
        screen: h,
        setScreen: p,
        showFrictionInterstitial: b,
      } = E1({
        block: c == null ? void 0 : c.block,
        isLoadingSimulation: d && !l,
        warnings: c == null ? void 0 : c.warnings,
      }),
      w = W.useCallback(() => {
        s.capture('userIgnoredKnownMaliciousWarning', { data: { origin: i } }), p('main');
      }, [s, i, p]),
      A = W.useMemo(
        () => (typeof e.transaction.gas == 'string' ? new fe(e.transaction.gas, 16) : void 0),
        [e.transaction.gas]
      ),
      {
        transactionSpeed: _,
        canOpenGasSettings: x,
        resetTransactionSpeed: k,
      } = JR(o, A ? { gasLimit: A } : void 0),
      j = W.useCallback(() => {
        x &&
          e.navigateToTransactionSettings({
            networkID: o,
            transactionUnitAmount: A ? { gasLimit: A } : void 0,
          });
      }, [x, A, o, e]),
      F = { networkID: o, unsignedTransaction: e.transaction },
      {
        networkFee: K,
        isLoadingNetworkFee: D,
        isErrorGasEstimation: C,
        isErrorGasEstimationPrice: B,
        gasEstimation: E,
        estimatedTime: y,
      } = Vbe(o, F, _, a),
      {
        hasSufficientFunds: v,
        nativeTokenSymbol: S,
        isLoading: T,
        isError: M,
      } = Kbe({ networkID: o, addressType: G.EVM, gasEstimation: E }),
      { maxFeePerGas: R, maxPriorityFeePerGas: L } = Ule(
        E || {
          gasLimit: new fe(0),
          maxFeePerGas: new fe(0),
          maxPriorityFeePerGas: new fe(0),
          networkID: o,
        }
      ),
      O = W.useCallback(async () => {
        e.denyApproval(), k();
      }, [e, k]),
      I = W.useCallback(async () => {
        e.confirmApproval(R ?? '0x0', L ?? '0x0'), k();
      }, [e, R, L, k]),
      U = { networkID: o, unsignedTransaction: e.transaction };
    return h === 'block'
      ? P.jsx(lT, {
          warningMessage: ((H = c == null ? void 0 : c.block) == null ? void 0 : H.message) ?? '',
          origin: i,
          onConfirm: w,
          onClose: O,
        })
      : h === 'loading'
        ? P.jsx(kp, { type: 'APPROVE_TRANSACTION', icon: r ?? void 0, domain: t, onClose: O })
        : h === 'friction'
          ? P.jsx(S1, {
              onClose: O,
              onConfirm: I,
              onBack: () => p('main'),
              origin: i,
              warningMessage:
                (J = (X = c == null ? void 0 : c.warnings) == null ? void 0 : X[0]) == null
                  ? void 0
                  : J.message,
            })
          : P.jsx(uT, {
              testID: 'approve-eth-transaction',
              advancedDetails: P.jsx(CR, { copyTransactions: [], scanResult: c, networkID: o }),
              confirmApproval: b ? () => p('friction') : I,
              denyApproval: O,
              hasSimulationFailed: !!u,
              numTransactions: 1,
              domain: t,
              rows: [],
              simulationResults: (c == null ? void 0 : c.expectedChanges) ?? [],
              simulationWarnings: (c == null ? void 0 : c.warnings) ?? [],
              icon: r ?? void 0,
              networkID: U.networkID,
              showFriction: b,
              showConfirmAnyway: !b && f,
              isErrorNativeTokenBalance: M,
              isErrorNetworkFee: C,
              isLoading: (D && !C) || T,
              networkFeeRows: [
                ...cT(
                  a,
                  K,
                  D,
                  C || B,
                  v === 'insufficient' ? 'accentAlert' : 'textSecondary',
                  v === 'insufficient'
                    ? a('transactionNotEnoughNative', { nativeTokenSymbol: S })
                    : C
                      ? a('gasEstimationCouldNotFetch')
                      : void 0,
                  'accentAlert',
                  j
                ),
                ...Dge(a, y),
              ],
            });
  },
  Hbe = ({ networkID: e, transactionUnitAmount: t, onClose: n }) => {
    const { setTransactionSpeed: r, transactionSpeed: i } = JR(e, t),
      { t: s } = Ct(),
      { presets: o, transactionSpeed: a } = f0e(e, i, t),
      c = W.useCallback(() => {
        r(a), n();
      }, [n, a, r]),
      u = s('settingsTransactions'),
      l = s('commandSave');
    return { headerText: u, primaryText: l, onPress: c, presetViewStates: o, onCancel: n };
  },
  Gbe = ({ onClose: e, networkID: t, transactionUnitAmount: n }) => {
    const r = Hbe({ networkID: t, transactionUnitAmount: n, onClose: e });
    return P.jsx(qbe, { ...r });
  },
  qbe = Kn.memo(
    ({ headerText: e, primaryText: t, onPress: n, presetViewStates: r, onCancel: i }) => {
      const { t: s } = Ct();
      return P.jsx(P.Fragment, {
        children: P.jsxs(ye, {
          direction: 'column',
          gap: 8,
          justifyContent: 'space-between',
          height: '100%',
          children: [
            P.jsxs(ye, {
              children: [
                P.jsxs(ye, {
                  direction: 'row',
                  gap: 8,
                  alignItems: 'center',
                  padding: 8,
                  children: [
                    P.jsx(n9, {
                      backgroundColor: ['bgWallet', 'bgArea'],
                      color: 'textPrimary',
                      label: s('commandBack'),
                      icon: 'ArrowLeft',
                      onClick: i,
                      shape: 'circle',
                      size: 28,
                    }),
                    P.jsx(ye, {
                      direction: 'row',
                      justifyContent: 'center',
                      children: P.jsx(je, { color: 'textPrimary', font: 'body', children: e }),
                    }),
                  ],
                }),
                P.jsx(ye, {
                  padding: 16,
                  paddingBottom: 32,
                  children: P.jsx(ye, {
                    borderRadius: 6,
                    overflow: 'hidden',
                    children: r.map((o, a) =>
                      P.jsx(
                        Ybe,
                        {
                          onClick: o.onClick,
                          title: o.title,
                          description: o.description,
                          selected: o.selected,
                          borderTop: a !== 0,
                        },
                        `preset-${a}`
                      )
                    ),
                  }),
                }),
              ],
            }),
            P.jsx(Fi, {
              direction: 'column',
              type: 'solid',
              children: P.jsx(on, { theme: 'primary', onClick: n, children: t }),
            }),
          ],
        }),
      });
    }
  ),
  Ybe = ({ selected: e, title: t, description: n, onClick: r, borderTop: i }) =>
    P.jsx('div', {
      onClick: r,
      className: yr({
        display: 'flex',
        backgroundColor: e ? 'brandPrimary' : 'bgRow',
        padding: 16,
        cursor: 'pointer',
        alignItems: 'center',
        borderTopColor: i ? 'bgWallet' : void 0,
        borderTopWidth: i ? 1 : void 0,
        borderTopStyle: i ? 'solid' : void 0,
      }),
      children: P.jsxs(ye, {
        children: [
          P.jsx(je, { color: e ? 'bgRow' : 'white', marginBottom: 6, font: 'body', children: t }),
          P.jsx(je, {
            color: e ? 'bgRow' : 'textSecondary',
            font: 'micro1',
            children: n || P.jsx('span', { children: ' ' }),
          }),
        ],
      }),
    }),
  Zbe = 'Unknown Error',
  Jbe = 'Looks like you ran into an unknown error. Please close Phantom and try again.',
  Xbe = 'Close';
let Qbe = class extends Kn.Component {
  constructor(t) {
    super(t), (this.state = { error: null });
  }
  static getDerivedStateFromError(t) {
    return t instanceof Error
      ? { error: t }
      : typeof t == 'string'
        ? { error: new Error(t) }
        : { error: new Error() };
  }
  componentDidCatch(t, n) {
    t instanceof Error && re.captureError(t, ce.Generic);
  }
  render() {
    return this.state.error
      ? typeof this.props.fallback == 'function'
        ? this.props.fallback(this.state.error)
        : this.props.fallback
      : this.props.children;
  }
};
const eme = (e) => P.jsx(Qbe, { fallback: (t) => e.fallback, children: e.children }),
  tme = ({ method: e, onReset: t = () => window.close(), buttonText: n = Xbe, children: r }) => {
    const i =
        Z9.safeParse(e).success ||
        J9.safeParse(e).success ||
        X9.safeParse(e).success ||
        Q9.safeParse(e).success,
      s = i ? 'Connection Error' : 'Transaction Error',
      o = `There was an error attempting to ${i ? 'connect to the application' : 'sign the transaction'}. Please try again.`,
      a = s || Zbe,
      c = o || Jbe;
    function u() {
      return P.jsxs(ye, {
        padding: 16,
        backgroundColor: 'bgWallet',
        justifyContent: 'center',
        alignItems: 'center',
        height: '100%',
        gap: 24,
        children: [
          P.jsxs(ye, {
            flex: 1,
            justifyContent: 'center',
            alignItems: 'center',
            gap: 16,
            children: [
              P.jsx(Lg, {
                icon: 'AlertCircle',
                size: 64,
                shape: 'circle',
                backgroundColor: 'accentAlert',
                color: 'bgWallet',
              }),
              P.jsx(je, {
                color: 'textPrimary',
                align: 'center',
                font: 'title1Semibold',
                children: a,
              }),
              P.jsx(je, {
                color: 'textSecondary',
                align: 'center',
                font: 'body',
                marginBottom: 8,
                children: c,
              }),
              P.jsxs(ye, {
                direction: 'row',
                alignItems: 'center',
                gap: 8,
                marginTop: 8,
                children: [
                  P.jsx(r9, { size: 16, color: 'accentPrimary' }),
                  P.jsx(je, {
                    color: 'accentPrimary',
                    font: 'bodyMedium',
                    onPress: () => {
                      window.open('https://help.phantom.app', '_blank'), t();
                    },
                    children: 'Help & Support',
                  }),
                ],
              }),
            ],
          }),
          P.jsx(on, { theme: 'secondary', onClick: t, children: n }),
        ],
      });
    }
    return P.jsx(eme, { fallback: P.jsx(u, {}), children: r });
  },
  nme = /^[0-9A-Fa-f]+$/gu;
function rme(e) {
  try {
    const t = ZL(e);
    if (t.match(nme)) return ime(t);
  } catch {
    return kx.bufferToHex(z.from(e, 'utf8'));
  }
  return kx.bufferToHex(z.from(e, 'utf8'));
}
const ime = (e) =>
    typeof e != 'string' || e.match(/^-?0x/u)
      ? e
      : e.match(/^-?0X/u)
        ? e.replace('0X', '0x')
        : e.startsWith('-')
          ? e.replace('-', '-0x')
          : `0x${e}`,
  sme = (e) => {
    const t = z.from(e.substring(2), 'hex'),
      n = t.length === 32 ? 'hex' : 'utf8';
    let r;
    switch (n) {
      case 'hex':
        r = rme(e);
        break;
      case 'utf8':
      default:
        r = t.toString('utf8');
    }
    return r;
  },
  ome = ({ networkID: e, formattedMessage: t, scanResult: n }) => {
    var u;
    const { t: r } = Ct(),
      i = n == null ? void 0 : n.advancedDetails,
      s =
        !!(n != null && n.expectedChanges) &&
        ((u = n.expectedChanges) == null ? void 0 : u.length) > 0,
      { data: o } = s4(),
      a = W.useCallback(
        (l) => {
          if (!o) return '';
          const d = o.explorers[e];
          return VO({ endpoint: 'address', explorerType: d, networkID: e, param: l });
        },
        [o, e]
      ),
      c = W.useMemo(() => {
        const l = [];
        return (
          i != null &&
            i.contractAddress &&
            l.push({
              type: 'link',
              topLeft: r('notificationContractAddress'),
              topRight: Ty(i.contractAddress ?? '', 4),
              onClick: () => () => window.open(a(i.contractAddress), '_blank'),
            }),
          s &&
            l.push({
              type: 'collapsible',
              topLeft: { text: r('notificationMessageHeader') },
              bottomLeft: { text: t },
              allowCopy: !0,
              onCopied: () => {
                Mr.success(r('notificationMessageCopied'));
              },
            }),
          l
        );
      }, [i == null ? void 0 : i.contractAddress, t, s, a, r]);
    return P.jsx(uo, { rows: c });
  },
  ame = (e) => {
    var E, y, v, S;
    const {
        icon: t,
        url: n,
        message: r,
        originalMethod: i,
        hexChainId: s,
        autoConfirmStatusCode: o,
        confirmApproval: a,
        denyApproval: c,
      } = e,
      u = n.origin,
      l = Un(),
      d = eL(s),
      {
        parsedMessage: f,
        formattedMessage: h,
        isJson: p,
      } = W.useMemo(() => {
        const T = sme(r),
          { formattedMessage: M, isJson: R } = TR(T);
        return { parsedMessage: T, formattedMessage: M, isJson: R };
      }, [r]),
      { t: b } = Ct(),
      {
        data: w,
        isError: A,
        isLoading: _,
        isFetched: x,
      } = $5(
        { networkID: d, url: n.href, type: 'message', params: { message: f } },
        { disabled: i === 'personal_sign' }
      ),
      k =
        !!(w != null && w.expectedChanges) &&
        ((E = w == null ? void 0 : w.expectedChanges) == null ? void 0 : E.length) > 0,
      j = i === 'eth_sign' || i === 'personal_sign',
      F = W.useMemo(
        () =>
          j
            ? void 0
            : P.jsx(P.Fragment, {
                children: k
                  ? P.jsxs(P.Fragment, {
                      children: [
                        P.jsx(je, {
                          color: 'textSecondary',
                          children: b('notificationPermissionRequestText'),
                        }),
                        P.jsx(je, {
                          color: 'textSecondary',
                          children: b('notificationBalanceChangesText'),
                        }),
                      ],
                    })
                  : P.jsx(je, {
                      color: 'textSecondary',
                      children: b('notificationBalanceChangesText'),
                    }),
              }),
        [k, j, b]
      ),
      {
        screen: K,
        setScreen: D,
        showFrictionInterstitial: C,
      } = E1({
        block: w == null ? void 0 : w.block,
        isLoadingSimulation: _ && !x,
        warnings: w == null ? void 0 : w.warnings,
      }),
      B = W.useCallback(() => {
        l.capture('userIgnoredKnownMaliciousWarning', { data: { origin: u } }), D('main');
      }, [u, D, l]);
    return K === 'block'
      ? P.jsx(lT, {
          warningMessage: ((y = w == null ? void 0 : w.block) == null ? void 0 : y.message) ?? '',
          origin: u,
          onConfirm: B,
          onClose: c,
        })
      : K === 'loading'
        ? P.jsx(kp, { type: 'SIGN_MESSAGE', domain: ba(u), onClose: c, icon: t })
        : K === 'friction'
          ? P.jsx(S1, {
              onClose: c,
              onConfirm: () => {
                a({ approvalType: 'user' });
              },
              onBack: () => D('main'),
              origin: u,
              warningMessage:
                (S = (v = w == null ? void 0 : w.warnings) == null ? void 0 : v[0]) == null
                  ? void 0
                  : S.message,
            })
          : P.jsx(aT, {
              testID: 'eth-sign-message',
              denyApproval: c,
              autoConfirmStatusCode: o,
              message: h,
              simulationResults: (w == null ? void 0 : w.expectedChanges) || [],
              scanWarnings: (w == null ? void 0 : w.warnings) || [],
              scanFailed: A,
              confirmApproval: () => {
                C ? D('friction') : a({ approvalType: 'user' });
              },
              networkID: d,
              origin: u,
              icon: t,
              headerDescription: F,
              isJson: p,
              advancedDetails: j
                ? null
                : P.jsx(ome, { formattedMessage: h, scanResult: w, networkID: d }),
            });
  },
  cme = (e) => {
    var u;
    const { icon: t, url: n, message: r, confirmApproval: i, denyApproval: s } = e,
      o = n.origin,
      { data: a } = Xb(),
      { networkID: c } = ((u = a == null ? void 0 : a.addresses) == null
        ? void 0
        : u.find((l) => de.isSuiNetworkID(l.networkID))) ?? {
        addressType: G.Sui,
        networkID: mt.Sui.Mainnet,
      };
    return P.jsx(aT, {
      testID: 'sui-sign-message',
      denyApproval: s,
      confirmApproval: i,
      origin: o,
      message: r,
      networkID: c,
      icon: t,
      isJson: !1,
    });
  },
  ume = 'No valid gas coins found for the transaction';
function lme({ networkID: e, transaction: t, buildError: n }) {
  const { t: r } = Ct(),
    { fungible: i } = Y0e({ key: gc.get(e).nativeFungibleTokenType }),
    {
      data: s,
      isLoading: o,
      isError: a,
    } = JI({
      networkID: e,
      multichainTransaction: t ? { networkID: e, transaction: t } : void 0,
      queryOptions: {},
    }),
    c = W.useMemo(() => Vle(s), [s]),
    u = W.useMemo(() => (i && c ? new fe(i.data.amount).gt(c) : void 0), [i, c]),
    l = oR({ networkID: e, gasEstimation: s }),
    d = W.useMemo(
      () =>
        (n == null ? void 0 : n.message.includes(ume)) || (!u && !!s)
          ? r('transactionNotEnoughNative', { nativeTokenSymbol: 'SUI' })
          : a
            ? r('gasEstimationCouldNotFetch')
            : n && !u && !s && !o
              ? r('networkFeeCouldNotFetch')
              : void 0,
      [n, u, s, a, o, r]
    );
  return {
    hasSufficientBalance: u,
    networkFeeString: l,
    gasEstimation: s,
    isGasEstimationLoading: o,
    isGasEstimationError: a,
    errorMessage: d,
  };
}
const dme = ({ url: e, transaction: t, icon: n, confirmApproval: r, denyApproval: i }) => {
    var v, S;
    const { t: s } = Ct(),
      o = ba(e.origin),
      a = e.origin,
      { data: c } = p4(G.Sui),
      u = c ? c.networkID : Ml.Mainnet;
    if (!de.isSuiNetworkID(u)) throw new Error('Selected Sui account is not available');
    const l = Eb.from(t),
      d = (c == null ? void 0 : c.address) ?? '';
    d && l.setSenderIfNotSet(d);
    const {
        data: f,
        isError: h,
        isLoading: p,
        error: b,
      } = A0e({ networkID: u, transaction: l, address: d }),
      {
        data: w,
        isLoading: A,
        isFetched: _,
        isError: x,
      } = KI(
        {
          networkID: u,
          url: e.href,
          userAccount: d,
          params: { rawTransaction: f ? DP(f) : '', method: 'signAndSendTransaction' },
          type: 'transaction',
        },
        { disabled: !f, disableRefetch: !0 }
      ),
      {
        hasSufficientBalance: k,
        networkFeeString: j,
        errorMessage: F,
        isGasEstimationLoading: K,
        isGasEstimationError: D,
      } = lme({ networkID: u, transaction: f, buildError: b }),
      {
        screen: C,
        setScreen: B,
        showFrictionInterstitial: E,
      } = E1({
        block: w == null ? void 0 : w.block,
        isLoadingSimulation: (A && !_) || K || p,
        warnings: w == null ? void 0 : w.warnings,
      }),
      y = !k || D || h ? 'accentAlert' : 'textSecondary';
    return C === 'loading'
      ? P.jsx(kp, { type: 'APPROVE_TRANSACTION', icon: n ?? void 0, domain: o, onClose: i })
      : C === 'friction'
        ? P.jsx(S1, {
            onClose: i,
            onConfirm: r,
            onBack: () => B('main'),
            origin: a,
            warningMessage:
              ((S = (v = w == null ? void 0 : w.warnings) == null ? void 0 : v[0]) == null
                ? void 0
                : S.message) ?? '',
          })
        : P.jsx(uT, {
            confirmApproval: E ? () => B('friction') : r,
            denyApproval: i,
            hasSimulationFailed: x,
            numTransactions: 1,
            domain: o,
            simulationResults: (w == null ? void 0 : w.expectedChanges) ?? [],
            simulationWarnings: (w == null ? void 0 : w.warnings) ?? [],
            icon: n ?? void 0,
            networkID: u,
            isErrorNativeTokenBalance: !1,
            isErrorNetworkFee: D,
            isLoading: K || p,
            networkFeeRows: [...cT(s, j, K, D || h, y, F, 'accentAlert')],
            showFriction: E,
            showConfirmAnyway: !E && !k,
          });
  },
  fme = ({ userApproveRequest: e }) => {
    const t = w4(),
      n = wA();
    let { icon: r, url: i } = e.params[0];
    const s = uS(i);
    !r && s && (r = BP(s));
    const o = e.id;
    if (e.method == 'user_approveSolSignMessage') {
      const a = e.params,
        { message: c, display: u } = a[1];
      return P.jsx(ye, {
        height: '100%',
        children: P.jsx(Bge, {
          confirmApproval: () => {
            t({ result: { type: 'signAndSend' } });
          },
          denyApproval: () => {
            t({ error: Yi(1).error });
          },
          icon: r ?? void 0,
          origin: i,
          message: or.decode(c),
          display: u,
          networkID: mt.Solana.Mainnet,
          isSimulationLoading: !1,
          hasSimulationFailed: !1,
          scanResult: { warnings: [], expectedChanges: [], type: 'message' },
        }),
      });
    }
    if (e.method === 'user_approveSolSignTransaction') {
      const a = e.params,
        { transaction: c, autoConfirmStatusCode: u } = a[1];
      return P.jsx(ye, {
        height: '100%',
        children: P.jsx(vg, {
          url: new URL(i),
          transactions: [c],
          autoConfirmStatusCode: u,
          originalMethod: 'signTransaction',
          icon: r ?? void 0,
          confirmApproval: () => {
            t({ result: { type: 'signAndSend' } });
          },
          denyApproval: () => {
            t({ error: Yi(1).error });
          },
        }),
      });
    }
    if (e.method === 'user_approveSolSignAllTransactions') {
      const a = e.params,
        { transactions: c, autoConfirmStatusCode: u } = a[1];
      return P.jsx(ye, {
        height: '100%',
        children: P.jsx(vg, {
          url: new URL(i),
          transactions: c,
          autoConfirmStatusCode: u,
          originalMethod: 'signAllTransactions',
          icon: r ?? void 0,
          confirmApproval: () => {
            t({ result: { type: 'signAndSend' } });
          },
          denyApproval: () => {
            t({ error: Yi(1).error });
          },
        }),
      });
    }
    if (e.method === 'user_approveSolSignAndSendTransaction') {
      const a = e.params,
        { transaction: c, autoConfirmStatusCode: u } = a[1];
      return P.jsx(ye, {
        height: '100%',
        children: P.jsx(vg, {
          url: new URL(i),
          transactions: [c],
          autoConfirmStatusCode: u,
          originalMethod: 'signAndSendTransaction',
          icon: r ?? void 0,
          confirmApproval: () => {
            t({ result: { type: 'signAndSend' } });
          },
          denyApproval: () => {
            t({ error: Yi(1).error });
          },
        }),
      });
    }
    if (e.method === 'user_approveSolSignAndSendAllTransactions') {
      const a = e.params,
        { transactions: c, autoConfirmStatusCode: u } = a[1];
      return P.jsx(ye, {
        height: '100%',
        children: P.jsx(vg, {
          url: new URL(i),
          transactions: c,
          autoConfirmStatusCode: u,
          originalMethod: 'signAndSendAllTransactions',
          icon: r ?? void 0,
          confirmApproval: () => {
            t({ result: { type: 'signAndSend' } });
          },
          denyApproval: () => {
            t({ error: Yi(1).error });
          },
        }),
      });
    }
    if (e.method === 'user_approveSolSignIn') {
      const a = e.params,
        { signInData: c, message: u, errorDetails: l } = a[1];
      return P.jsx(ye, {
        height: '100%',
        children: P.jsx(rye, {
          icon: r ?? void 0,
          url: new URL(i),
          signInData: c,
          message: u,
          errorDetails: l,
          confirmApproval: () => t({ result: { type: 'signAndSend' } }),
          denyApproval: () => t({ error: Yi(1).error }),
        }),
      });
    }
    if (e.method === 'user_approveEthSendTransaction') {
      const a = e.params,
        { transaction: c, autoConfirmStatusCode: u } = a[1];
      return P.jsx(ye, {
        height: '100%',
        children: P.jsx(Wbe, {
          icon: r,
          url: new URL(i),
          transaction: c,
          autoConfirmStatusCode: u,
          confirmApproval: (l, d) => {
            t({ result: { type: 'signAndSend', maxFeePerGas: l, maxPriorityFeePerGas: d } });
          },
          denyApproval: () => {
            t({ error: Yi(1).error });
          },
          navigateToTransactionSettings: ({ networkID: l, transactionUnitAmount: d }) => {
            n.to('transactionSettings', { params: { networkID: l, transactionUnitAmount: d } });
          },
        }),
      });
    }
    if (e.method === 'user_approveEthSignMessage') {
      const a = e.params,
        { message: c, originalMethod: u, chainId: l, autoConfirmStatusCode: d } = a[1];
      return P.jsx(ye, {
        height: '100%',
        children: P.jsx(ame, {
          icon: r ?? void 0,
          url: new URL(i),
          message: c,
          originalMethod: u,
          hexChainId: l,
          autoConfirmStatusCode: d,
          confirmApproval: (f) => {
            t({ result: f });
          },
          denyApproval: () => {
            t({ error: Yi(o).error });
          },
        }),
      });
    }
    if (e.method === 'user_approveSuiSignMessage') {
      const a = e.params,
        c = DP(a[1].message);
      return P.jsx(ye, {
        height: '100%',
        children: P.jsx(cme, {
          message: c,
          icon: r ?? void 0,
          url: new URL(i),
          confirmApproval: () => {
            t({ result: { message: c } });
          },
          denyApproval: () => {
            t({ error: Yi(1).error });
          },
        }),
      });
    }
    if (e.method === 'user_approveSuiSignTransaction') {
      const a = e.params,
        { transaction: c } = a[1];
      return P.jsx(ye, {
        height: '100%',
        children: P.jsx(dme, {
          transaction: c,
          url: new URL(i),
          icon: r ?? null,
          confirmApproval: () => {
            t({ result: { transaction: c } });
          },
          denyApproval: () => {
            t({ error: Yi(1).error });
          },
        }),
      });
    }
    return null;
  },
  hme = () => {
    const e = KP(),
      t = e == null ? void 0 : e.userApproveRequest;
    if (!t) return null;
    const { method: n } = t;
    return P.jsx(tme, { method: n, children: P.jsx(fme, { userApproveRequest: t }) });
  };
var ME = ((e) => (
  (e.Initial = 'initial'),
  (e.Create = 'create'),
  (e.ImportSeed = 'importSeed'),
  (e.ImportPrivateKey = 'importPrivateKey'),
  (e.ConnectHardware = 'connectHardware'),
  (e.SeedlessRecover = 'seedlessRecover'),
  (e.SeedlessBackup = 'seedlessBackup'),
  (e.SeedVault = 'seedVault'),
  (e.Restore = 'restore'),
  (e.Append = 'append'),
  e
))(ME || {});
const pme = g.object({ balance: g.boolean(), history: g.boolean() });
g.record(g.string(), pme);
var OE = ((e) => (
  (e.FirstTimeOnboarding = 'firstTimeOnboarding'),
  (e.IsResettingApp = 'isResettingApp'),
  (e.OnBoardedAt = 'onboardedAt'),
  e
))(OE || {});
OE.FirstTimeOnboarding, OE.IsResettingApp;
ee.Seed, ee.Seedless, ee.PrivateKey;
var Gt = ((e) => (
  (e.Multichain = 'Multichain'),
  (e.MultichainSwapper = 'MultichainSwapper'),
  (e.InvalidChecksum = 'InvalidChecksum'),
  (e.AdditionalPermissions = 'AdditionalPermissions'),
  (e.SuiWelcome = 'SuiWelcome'),
  (e.SuiWelcomeDefaultOn = 'SuiWelcomeDefaultOn'),
  (e.MonadWelcome = 'MonadWelcome'),
  (e.ArbitrumWelcome = 'ArbitrumWelcome'),
  (e.ClaimUsernameNudge = 'ClaimUsernameNudge'),
  (e.QuickClaimUsername = 'QuickClaimUsername'),
  (e.SeedlessPinVerification = 'SeedlessPinVerification'),
  (e.TermsOfServiceUpdate = 'TermsOfServiceUpdate'),
  e
))(Gt || {});
Gt.Multichain + '',
  Gt.MultichainSwapper + '',
  Gt.InvalidChecksum + '',
  Gt.SuiWelcome + '',
  Gt.SuiWelcomeDefaultOn + '',
  Gt.MonadWelcome + '',
  Gt.ArbitrumWelcome + '',
  Gt.ClaimUsernameNudge + '',
  Gt.QuickClaimUsername + '',
  Gt.SeedlessPinVerification + '',
  Gt.AdditionalPermissions + '',
  Gt.TermsOfServiceUpdate + '';
Gt.Multichain + '',
  Gt.MultichainSwapper + '',
  Gt.InvalidChecksum + '',
  Gt.SuiWelcome + '',
  Gt.SuiWelcomeDefaultOn + '',
  Gt.MonadWelcome + '',
  Gt.ArbitrumWelcome + '',
  Gt.ClaimUsernameNudge + '',
  Gt.QuickClaimUsername + '',
  Gt.AdditionalPermissions + '',
  Gt.SeedlessPinVerification + '',
  Gt.TermsOfServiceUpdate + '';
we({ minutes: 1 });
class gme extends Kn.Component {
  constructor(t) {
    super(t), (this.state = { error: null });
  }
  static getDerivedStateFromError(t) {
    return t instanceof Error
      ? { error: t }
      : typeof t == 'string'
        ? { error: new Error(t) }
        : { error: new Error() };
  }
  componentDidCatch(t, n) {
    t instanceof Error && re.captureError(t, ce.Generic);
  }
  render() {
    return this.state.error
      ? typeof this.props.fallback == 'function'
        ? this.props.fallback(this.state.error)
        : this.props.fallback
      : this.props.children;
  }
}
Kn.memo((e) => {
  const { children: t, i18nKey: n, ...r } = e,
    { t: i } = Ct(),
    s = W.useMemo(() => {
      const a = (n ? `${i(n, { ...r, ...r.values })}` : '').replace(/<\/?[^>]+(>|$)/g, '');
      return P.jsx(je, { children: a });
    }, [n, r, i]);
  return P.jsx(gme, { fallback: s, children: P.jsx(dP, { i18nKey: n, ...r, children: t }) });
});
const yme = g.record(g.string(), g.number()),
  bme = g.object({
    type: g.union([g.literal('Buffer'), g.literal('Object')]),
    data: g.array(g.number()),
  }),
  mme = g.union([yme, bme]),
  wme = g.object({ seeds: g.array(g.tuple([g.string(), mme])) }),
  vme = (e) => (_me(e) ? new Uint8Array(z.from(e.data)) : new Uint8Array(Object.values(e))),
  _me = (e) =>
    !!e &&
    typeof e == 'object' &&
    by('type', e) &&
    typeof e.type == 'string' &&
    by('data', e) &&
    Array.isArray(e.data) &&
    e.data.every((t) => !Number.isNaN(parseInt(t))),
  Sme = g.object({ deviceId: g.string(), encryptionKey: g.string().length(44).base64() });
var ys = ((e) => (
  (e.RotationResult = 'seedlessRotationResult'),
  (e.RecoverResult = 'seedlessRecoverResult'),
  (e.BackupResult = 'seedlessBackupResult'),
  e
))(ys || {});
const Pc = '/seedless',
  Eme = 30 * 24 * 60 * 60 * 1e3,
  Ame = 32,
  Ime = 32,
  Tme = '/seedless',
  Ho = 7,
  XR = 1,
  QR = 4,
  e7 = 2,
  tb = 4,
  t7 = 4;
class n7 extends Error {
  constructor(n) {
    super('Failed to backup share from Juicebox');
    ae(this, 'reasonString');
    ae(this, 'reasonCode');
    (this.reasonCode = n), (this.reasonString = s7[n]);
  }
}
class r7 extends Error {
  constructor(n, r) {
    super('Failed to recover share from Juicebox');
    ae(this, 'guessesRemaining');
    ae(this, 'reasonString');
    ae(this, 'reasonCode');
    (this.guessesRemaining = r), (this.reasonCode = n), (this.reasonString = al[n]);
  }
}
class i7 extends Error {
  constructor(n) {
    super('Failed to delete share from Juicebox');
    ae(this, 'reasonString');
    ae(this, 'reasonCode');
    (this.reasonCode = n), (this.reasonString = o7[n]);
  }
}
var s7 = ((e) => (
    (e[(e.InvalidAuth = 0)] = 'InvalidAuth'),
    (e[(e.UpgradeRequired = 1)] = 'UpgradeRequired'),
    (e[(e.Assertion = 2)] = 'Assertion'),
    (e[(e.Transient = 3)] = 'Transient'),
    e
  ))(s7 || {}),
  al = ((e) => (
    (e[(e.InvalidPin = 0)] = 'InvalidPin'),
    (e[(e.NotRegistered = 1)] = 'NotRegistered'),
    (e[(e.InvalidAuth = 2)] = 'InvalidAuth'),
    (e[(e.UpgradeRequired = 3)] = 'UpgradeRequired'),
    (e[(e.Assertion = 4)] = 'Assertion'),
    (e[(e.Transient = 5)] = 'Transient'),
    (e[(e.CooldownTimer = 6)] = 'CooldownTimer'),
    e
  ))(al || {}),
  o7 = ((e) => (
    (e[(e.InvalidAuth = 0)] = 'InvalidAuth'),
    (e[(e.UpgradeRequired = 1)] = 'UpgradeRequired'),
    (e[(e.RateLimitExceeded = 2)] = 'RateLimitExceeded'),
    (e[(e.Assertion = 3)] = 'Assertion'),
    (e[(e.Transient = 4)] = 'Transient'),
    e
  ))(o7 || {});
const a7 = (e) => c7(e) || u7(e) || xme(e),
  c7 = (e) => e instanceof r7,
  u7 = (e) => e instanceof n7,
  xme = (e) => e instanceof i7;
globalThis.JuiceboxGetAuthToken = async (e) => {
  const t = z.from(e).toString('hex');
  return globalThis.JuiceboxTokens[t];
};
class l7 {
  constructor(t) {
    ae(this, 'encoder');
    ae(this, 'provider');
    (this.encoder = new TextEncoder()), (this.provider = t);
  }
  async getJwts(t) {
    const n = await Ge.api().bearer(t).post(`${Tme}/v1/juiceboxtoken`);
    (tr(n) || n.status === 304) && this.provider.setJuiceboxTokens(n.data);
  }
  async sendJuiceboxShare(t, n, r, i) {
    await this.getJwts(i);
    try {
      await this.provider.backupShare(
        t,
        n,
        this.encoder.encode(r),
        this.encoder.encode('phantom'),
        Ho
      ),
        re.addBreadcrumb(ce.Seedless, 'Successful backup share to Juicebox', Ie.Debug);
    } catch (s) {
      re.addBreadcrumb(ce.Seedless, 'Failed to backup share to Juicebox', Ie.Error);
      const o = new n7(s);
      throw (re.captureError(o, ce.Seedless), o);
    }
    return !0;
  }
  async getJuiceboxShare(t, n, r) {
    await this.getJwts(r);
    try {
      const i = await this.provider.recoverShare(
        t,
        this.encoder.encode(n),
        this.encoder.encode('phantom')
      );
      return (
        re.addBreadcrumb(ce.Seedless, 'Successfully recovered share from Juicebox', Ie.Debug), i
      );
    } catch (i) {
      const s = i.reason,
        o = i.guessesRemaining !== void 0 ? i.guessesRemaining : i.guesses_remaining;
      re.addBreadcrumb(ce.Seedless, 'Failed to recover share from Juicebox', Ie.Error);
      const a = new r7(s, o);
      throw (re.captureError(a, ce.Seedless), a);
    }
  }
  async deleteShare(t, n) {
    await this.getJwts(n);
    try {
      await this.provider.deleteShare(t),
        re.addBreadcrumb(ce.Seedless, 'Successfully deleted share from Juicebox', Ie.Debug);
    } catch (r) {
      re.addBreadcrumb(ce.Seedless, 'Failed to delete share from Juicebox', Ie.Error);
      const i = new i7(r);
      throw (re.captureError(i, ce.Seedless), i);
    }
  }
}
const d7 = W.createContext(null);
function kme({ children: e, seedlessRepository: t }) {
  return P.jsx(d7.Provider, { value: { seedlessRepository: t }, children: e });
}
function Cme() {
  const e = W.useContext(d7);
  if (!e) throw new Error('useSeedlessContext must be used within a SeedlessProvider');
  return e;
}
function Pp() {
  return Cme().seedlessRepository;
}
const d_ = '@phantom/seedless',
  yT = {
    hasSeedlessBundle: ['seedless', `${d_}:has_seedless_bundle`],
    needsBundleUpdate: ['seedless', `${d_}:needs_bundle_update`],
    timeLeftCooldown: ['seedless', `${d_}:time_left_cooldown`],
  },
  Pme = async (e) => {
    await e.invalidateQueries({ queryKey: yT.hasSeedlessBundle });
  },
  f7 = async (e) => {
    await e.invalidateQueries({ queryKey: yT.needsBundleUpdate });
  };
function Mme() {
  const e = Pp(),
    t = lo(),
    n = Un();
  return Fu({
    mutationFn: async ({ entropy: r, pin: i }) => await e.backup(r, i),
    onSuccess: async () => {
      n.capture('seedlessBackupSuccess'), await Pme(t), await f7(t);
    },
    onError: () => {
      n.capture('seedlessBackupError');
    },
  });
}
function Ome() {
  const e = Pp(),
    t = lo(),
    n = Un();
  return Fu({
    mutationFn: async (i) => await e.recover(i),
    onSuccess: async () => {
      n.capture('seedlessRecoverSuccess'), await f7(t);
    },
    onError: () => {
      n.capture('seedlessRecoverError');
    },
  });
}
function Bme() {
  const e = Pp(),
    t = Un();
  return Fu({
    mutationFn: async (r) => {
      await e.verifyPin(r);
    },
    onSuccess: () => {
      re.addBreadcrumb(ce.Seedless, 'Successfully verified PIN', Ie.Info),
        t.capture('seedlessVerifyPinSuccess');
    },
    onError: () => {
      re.addBreadcrumb(ce.Seedless, 'Failed to verify PIN', Ie.Error),
        t.capture('seedlessVerifyPinError');
    },
  });
}
const Dme = 1e3,
  Rme = 500;
function h7() {
  const e = yT.timeLeftCooldown,
    t = Pp(),
    n = UM();
  return Qt({
    enabled: n,
    queryKey: e,
    queryFn: async () => await t.timeLeftCooldown(),
    refetchInterval: Dme,
    refetchOnMount: 'always',
    staleTime: Rme,
  });
}
const g8 = 1e3,
  Nme = () => {
    const [e, t] = W.useState(0);
    return (
      W.useEffect(() => {
        if (!e) return;
        const n = setInterval(async () => {
          t(e - g8);
        }, g8);
        return () => clearInterval(n);
      }, [e]),
      { cooldownTimer: e, setCooldownTimer: t }
    );
  };
g.string()
  .transform((e) => Number(e))
  .pipe(g.number())
  .nullish()
  .catch(null);
const p7 = () => {
  const e = lo(),
    t = Pp();
  return Fu({
    mutationFn: async () => {
      re.addBreadcrumb(ce.Seedless, 'Resetting PIN verification timer', Ie.Info),
        await t.setPinVerificationTimer(Date.now());
    },
    onSuccess: async () => {
      re.addBreadcrumb(ce.Seedless, 'Successfully reset PIN verification timer', Ie.Info),
        await e.invalidateQueries({ queryKey: [et.SeedlessPinVerificationLockTimerInMs] });
    },
    onError: () => {
      re.addBreadcrumb(ce.Seedless, 'Failed to reset PIN verification timer', Ie.Error);
    },
  });
};
function BE(e) {
  if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`);
}
function jme(e) {
  if (typeof e != 'boolean') throw new Error(`Expected boolean, not ${e}`);
}
function g7(e, ...t) {
  if (!(e instanceof Uint8Array)) throw new TypeError('Expected Uint8Array');
  if (t.length > 0 && !t.includes(e.length))
    throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function Lme(e) {
  if (typeof e != 'function' || typeof e.create != 'function')
    throw new Error('Hash should be wrapped by utils.wrapConstructor');
  BE(e.outputLen), BE(e.blockLen);
}
function Ume(e, t = !0) {
  if (e.destroyed) throw new Error('Hash instance has been destroyed');
  if (t && e.finished) throw new Error('Hash#digest() has already been called');
}
function $me(e, t) {
  g7(e);
  const n = t.outputLen;
  if (e.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`);
}
const f_ = { number: BE, bool: jme, bytes: g7, hash: Lme, exists: Ume, output: $me },
  y8 = {
    node: void 0,
    web: typeof globalThis == 'object' && 'crypto' in globalThis ? globalThis.crypto : void 0,
  };
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const h_ = (e) =>
    new DataView(e.buffer, e.byteOffset, e.byteLength),
  ns = (e, t) => (e << (32 - t)) | (e >>> t),
  Fme = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!Fme) throw new Error('Non little-endian hardware is not supported');
const zme = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, '0'));
function y7(e) {
  if (!(e instanceof Uint8Array)) throw new Error('Uint8Array expected');
  let t = '';
  for (let n = 0; n < e.length; n++) t += zme[e[n]];
  return t;
}
function Kme(e) {
  if (typeof e != 'string') throw new TypeError('hexToBytes: expected string, got ' + typeof e);
  if (e.length % 2) throw new Error('hexToBytes: received invalid unpadded hex');
  const t = new Uint8Array(e.length / 2);
  for (let n = 0; n < t.length; n++) {
    const r = n * 2,
      i = e.slice(r, r + 2),
      s = Number.parseInt(i, 16);
    if (Number.isNaN(s) || s < 0) throw new Error('Invalid byte sequence');
    t[n] = s;
  }
  return t;
}
function Vme(e) {
  if (typeof e != 'string') throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function b7(e) {
  if ((typeof e == 'string' && (e = Vme(e)), !(e instanceof Uint8Array)))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
  return e;
}
let Wme = class {
  clone() {
    return this._cloneInto();
  }
};
function m7(e) {
  const t = (r) => e().update(b7(r)).digest(),
    n = e();
  return (t.outputLen = n.outputLen), (t.blockLen = n.blockLen), (t.create = () => e()), t;
}
function w7(e = 32) {
  if (y8.web) return y8.web.getRandomValues(new Uint8Array(e));
  throw new Error("The environment doesn't have randomBytes function");
}
function Hme(e, t, n, r) {
  if (typeof e.setBigUint64 == 'function') return e.setBigUint64(t, n, r);
  const i = BigInt(32),
    s = BigInt(4294967295),
    o = Number((n >> i) & s),
    a = Number(n & s),
    c = r ? 4 : 0,
    u = r ? 0 : 4;
  e.setUint32(t + c, o, r), e.setUint32(t + u, a, r);
}
let Gme = class extends Wme {
  constructor(t, n, r, i) {
    super(),
      (this.blockLen = t),
      (this.outputLen = n),
      (this.padOffset = r),
      (this.isLE = i),
      (this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.buffer = new Uint8Array(t)),
      (this.view = h_(this.buffer));
  }
  update(t) {
    f_.exists(this);
    const { view: n, buffer: r, blockLen: i } = this;
    t = b7(t);
    const s = t.length;
    for (let o = 0; o < s; ) {
      const a = Math.min(i - this.pos, s - o);
      if (a === i) {
        const c = h_(t);
        for (; i <= s - o; o += i) this.process(c, o);
        continue;
      }
      r.set(t.subarray(o, o + a), this.pos),
        (this.pos += a),
        (o += a),
        this.pos === i && (this.process(n, 0), (this.pos = 0));
    }
    return (this.length += t.length), this.roundClean(), this;
  }
  digestInto(t) {
    f_.exists(this), f_.output(t, this), (this.finished = !0);
    const { buffer: n, view: r, blockLen: i, isLE: s } = this;
    let { pos: o } = this;
    (n[o++] = 128),
      this.buffer.subarray(o).fill(0),
      this.padOffset > i - o && (this.process(r, 0), (o = 0));
    for (let d = o; d < i; d++) n[d] = 0;
    Hme(r, i - 8, BigInt(this.length * 8), s), this.process(r, 0);
    const a = h_(t),
      c = this.outputLen;
    if (c % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
    const u = c / 4,
      l = this.get();
    if (u > l.length) throw new Error('_sha2: outputLen bigger than state');
    for (let d = 0; d < u; d++) a.setUint32(4 * d, l[d], s);
  }
  digest() {
    const { buffer: t, outputLen: n } = this;
    this.digestInto(t);
    const r = t.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: n, buffer: r, length: i, finished: s, destroyed: o, pos: a } = this;
    return (
      (t.length = i), (t.pos = a), (t.finished = s), (t.destroyed = o), i % n && t.buffer.set(r), t
    );
  }
};
const qme = (e, t, n) => (e & t) ^ (~e & n),
  Yme = (e, t, n) => (e & t) ^ (e & n) ^ (t & n),
  Zme = new Uint32Array([
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221,
    3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580,
    3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895,
    666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037,
    2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
    1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298,
  ]),
  Ro = new Uint32Array([
    1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225,
  ]),
  No = new Uint32Array(64);
let v7 = class extends Gme {
    constructor() {
      super(64, 32, 8, !1),
        (this.A = Ro[0] | 0),
        (this.B = Ro[1] | 0),
        (this.C = Ro[2] | 0),
        (this.D = Ro[3] | 0),
        (this.E = Ro[4] | 0),
        (this.F = Ro[5] | 0),
        (this.G = Ro[6] | 0),
        (this.H = Ro[7] | 0);
    }
    get() {
      const { A: t, B: n, C: r, D: i, E: s, F: o, G: a, H: c } = this;
      return [t, n, r, i, s, o, a, c];
    }
    set(t, n, r, i, s, o, a, c) {
      (this.A = t | 0),
        (this.B = n | 0),
        (this.C = r | 0),
        (this.D = i | 0),
        (this.E = s | 0),
        (this.F = o | 0),
        (this.G = a | 0),
        (this.H = c | 0);
    }
    process(t, n) {
      for (let d = 0; d < 16; d++, n += 4) No[d] = t.getUint32(n, !1);
      for (let d = 16; d < 64; d++) {
        const f = No[d - 15],
          h = No[d - 2],
          p = ns(f, 7) ^ ns(f, 18) ^ (f >>> 3),
          b = ns(h, 17) ^ ns(h, 19) ^ (h >>> 10);
        No[d] = (b + No[d - 7] + p + No[d - 16]) | 0;
      }
      let { A: r, B: i, C: s, D: o, E: a, F: c, G: u, H: l } = this;
      for (let d = 0; d < 64; d++) {
        const f = ns(a, 6) ^ ns(a, 11) ^ ns(a, 25),
          h = (l + f + qme(a, c, u) + Zme[d] + No[d]) | 0,
          b = ((ns(r, 2) ^ ns(r, 13) ^ ns(r, 22)) + Yme(r, i, s)) | 0;
        (l = u), (u = c), (c = a), (a = (o + h) | 0), (o = s), (s = i), (i = r), (r = (h + b) | 0);
      }
      (r = (r + this.A) | 0),
        (i = (i + this.B) | 0),
        (s = (s + this.C) | 0),
        (o = (o + this.D) | 0),
        (a = (a + this.E) | 0),
        (c = (c + this.F) | 0),
        (u = (u + this.G) | 0),
        (l = (l + this.H) | 0),
        this.set(r, i, s, o, a, c, u, l);
    }
    roundClean() {
      No.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
    }
  },
  Jme = class extends v7 {
    constructor() {
      super(),
        (this.A = -1056596264),
        (this.B = 914150663),
        (this.C = 812702999),
        (this.D = -150054599),
        (this.E = -4191439),
        (this.F = 1750603025),
        (this.G = 1694076839),
        (this.H = -1090891868),
        (this.outputLen = 28);
    }
  };
const Xme = m7(() => new v7());
m7(() => new Jme());
const Mp = (e) => {
  const t = DE(e),
    n = JSON.stringify(t);
  return y7(Xme(n));
};
function _7(e) {
  return /^\d+$/.test(e);
}
const k1 = (e) => (e.length !== 4 ? !1 : _7(e)),
  DE = (e) => {
    if (Array.isArray(e)) return e.map((t) => (typeof t == 'object' ? DE(t) : t)).sort();
    if (typeof e == 'object' && e !== null) {
      const t = {},
        n = Object.keys(e).sort();
      for (const r of n) t[r] = DE(e[r]);
      return t;
    } else return e;
  },
  S7 = (e) => {
    const t = Math.max(0, Math.floor(e / 1e3)),
      n = Math.floor(t / 60).toString(),
      r = t % 60 > 9 ? `${t % 60}` : `0${t % 60}`;
    return { minutes: n, seconds: r };
  };
class E7 extends Error {
  constructor(n) {
    super(`Unable to recover seedless bundle: ${n.type}`);
    ae(this, 'result');
    this.result = n;
  }
}
class Qme extends Error {
  constructor(n) {
    super(`Unable to backup seedless bundle: ${n.type}`);
    ae(this, 'result');
    this.result = n;
  }
}
const Mc = (e) => e instanceof E7,
  e1e = (e) => Mc(e) && e.result.type === 'unauthorized',
  bT = (e) =>
    Mc(e) && e.result.type === 'error-juicebox-recover' && e.result.reason === al.InvalidPin,
  A7 = (e) => Mc(e) && e.result.type === 'cooldown',
  I7 = (e) => Mc(e) && e.result.type === 'upgrade-required',
  t1e = ({
    hasEnrolledAuthentication: e,
    onAccountsAdded: t,
    onOnboardingDone: n,
    onOnboardingProtect: r,
    onImportAndSyncAccounts: i,
    onForgot: s,
  }) => {
    const { t: o } = Ct(),
      a = Un(),
      { data: c = [] } = Oz(),
      { refetch: u } = h7(),
      { mutateAsync: l } = p7(),
      { mutateAsync: d } = Ome(),
      [f, h] = W.useState(!1),
      [p, b] = W.useState({ isInvalidPin: !1, triesLeft: void 0, pin: '' }),
      [w, A] = W.useState(!1),
      { cooldownTimer: _, setCooldownTimer: x } = Nme(),
      { minutes: k, seconds: j } = S7(_),
      [F, K] = W.useState(null);
    return (
      W.useEffect(() => {
        !p.triesLeft || p.triesLeft > 0 || s();
      }, [p.triesLeft, s]),
      W.useEffect(() => {
        (async () => {
          const { data: E = 0 } = await u();
          return E;
        })().then((E) => x(E));
      }, []),
      {
        isLoading: w,
        isError: f,
        handleInput: (B) => {
          b((E) => ({ ...E, isInvalidPin: B !== '' && !_7(B), pin: B }));
        },
        onSubmit: async () => {
          if (!w) {
            if (!k1(p.pin)) {
              b((B) => ({ ...B, isInvalidPin: !0, triesLeft: void 0, pin: '' }));
              return;
            }
            try {
              A(!0), h(!1), b((E) => ({ ...E, isInvalidPin: !1, triesLeft: void 0 }));
              const { entropy: B } = await d(p.pin);
              await i(B),
                await l(),
                a.capture('seedlessEnterPinContinue'),
                c.length > 1 && t ? t() : !e && n ? n() : r == null || r();
            } catch (B) {
              if (bT(B) || A7(B)) {
                let E;
                if (('guessesRemaining' in B.result && (E = B.result.guessesRemaining), E === 0)) {
                  b((S) => ({ ...S, isInvalidPin: !0, triesLeft: E, pin: '' })), s();
                  return;
                }
                let y = !1;
                'reason' in B.result && B.result.reason === al.InvalidPin && (y = !0);
                const { data: v = 0 } = await u();
                x(v),
                  a.capture('seedlessPinError', { data: { triesLeft: E, cooldownTimer: v } }),
                  b((S) => ({ ...S, isInvalidPin: y, triesLeft: E, pin: '' }));
              } else
                I7(B)
                  ? (h(!0),
                    K({
                      title: o('seedlessRecoverErrorUpgradeRequiredTitle'),
                      description: o('seedlessRecoverErrorUpgradeRequiredDescription'),
                    }))
                  : (re.captureError(B, ce.Seedless),
                    h(!0),
                    K({
                      title: o('seedlessEnterPinUnknownErrorPrimaryText'),
                      description: o('seedlessEnterPinUnknownErrorSecondaryText'),
                      buttonText: o('seedlessTryAgain'),
                    }));
            } finally {
              A(!1);
            }
          }
        },
        onForgot: s,
        pinAttemptsLeft: p.triesLeft,
        isPinError: p.isInvalidPin,
        hasCooldownTimer: _ > 0,
        disabled: _ > 0 || p.isInvalidPin || !p.pin || p.pin.length < 4,
        pin: p.pin,
        continueButtonText: o('seedlessContinueText'),
        forgotButtonText: o('seedlessVerifyPinForgotButtonText'),
        attemptsLeftText: o('seedlessEnterPinNumTriesLeft', { numTries: p.triesLeft }),
        cooldownTimerText: o('seedlessEnterPinCooldown', { minutesLeft: k, secondsLeft: j }),
        invalidPinText: o('seedlessEnterPinInvalidPinError'),
        title: o('seedlessEnterPinPrimaryText'),
        loadingTitle: o('seedlessLoadingWalletPrimaryText'),
        loadingDescription: o('seedlessLoadingWalletSecondaryText'),
        errorTitle: F ? F.title : o('seedlessLoadingWalletErrorPrimaryText'),
        errorDescription: F ? F.description : o('seedlessErrorSecondaryText'),
        tryAgainButtonText: F ? F.buttonText : o('seedlessTryAgain'),
      }
    );
  },
  n1e = new Error('request for lock canceled');
var r1e = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(l) {
      try {
        u(r.next(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      try {
        u(r.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function u(l) {
      l.done ? s(l.value) : i(l.value).then(a, c);
    }
    u((r = r.apply(e, t || [])).next());
  });
};
class i1e {
  constructor(t, n = n1e) {
    (this._value = t),
      (this._cancelError = n),
      (this._weightedQueues = []),
      (this._weightedWaiters = []);
  }
  acquire(t = 1) {
    if (t <= 0) throw new Error(`invalid weight ${t}: must be positive`);
    return new Promise((n, r) => {
      this._weightedQueues[t - 1] || (this._weightedQueues[t - 1] = []),
        this._weightedQueues[t - 1].push({ resolve: n, reject: r }),
        this._dispatch();
    });
  }
  runExclusive(t, n = 1) {
    return r1e(this, void 0, void 0, function* () {
      const [r, i] = yield this.acquire(n);
      try {
        return yield t(r);
      } finally {
        i();
      }
    });
  }
  waitForUnlock(t = 1) {
    if (t <= 0) throw new Error(`invalid weight ${t}: must be positive`);
    return new Promise((n) => {
      this._weightedWaiters[t - 1] || (this._weightedWaiters[t - 1] = []),
        this._weightedWaiters[t - 1].push(n),
        this._dispatch();
    });
  }
  isLocked() {
    return this._value <= 0;
  }
  getValue() {
    return this._value;
  }
  setValue(t) {
    (this._value = t), this._dispatch();
  }
  release(t = 1) {
    if (t <= 0) throw new Error(`invalid weight ${t}: must be positive`);
    (this._value += t), this._dispatch();
  }
  cancel() {
    this._weightedQueues.forEach((t) => t.forEach((n) => n.reject(this._cancelError))),
      (this._weightedQueues = []);
  }
  _dispatch() {
    var t;
    for (let n = this._value; n > 0; n--) {
      const r = (t = this._weightedQueues[n - 1]) === null || t === void 0 ? void 0 : t.shift();
      if (!r) continue;
      const i = this._value,
        s = n;
      (this._value -= n), (n = this._value + 1), r.resolve([i, this._newReleaser(s)]);
    }
    this._drainUnlockWaiters();
  }
  _newReleaser(t) {
    let n = !1;
    return () => {
      n || ((n = !0), this.release(t));
    };
  }
  _drainUnlockWaiters() {
    for (let t = this._value; t > 0; t--)
      this._weightedWaiters[t - 1] &&
        (this._weightedWaiters[t - 1].forEach((n) => n()), (this._weightedWaiters[t - 1] = []));
  }
}
var s1e = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(l) {
      try {
        u(r.next(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      try {
        u(r.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function u(l) {
      l.done ? s(l.value) : i(l.value).then(a, c);
    }
    u((r = r.apply(e, t || [])).next());
  });
};
class b8 {
  constructor(t) {
    this._semaphore = new i1e(1, t);
  }
  acquire() {
    return s1e(this, void 0, void 0, function* () {
      const [, t] = yield this._semaphore.acquire();
      return t;
    });
  }
  runExclusive(t) {
    return this._semaphore.runExclusive(() => t());
  }
  isLocked() {
    return this._semaphore.isLocked();
  }
  waitForUnlock() {
    return this._semaphore.waitForUnlock();
  }
  release() {
    this._semaphore.isLocked() && this._semaphore.release();
  }
  cancel() {
    return this._semaphore.cancel();
  }
}
const qn = [];
for (let e = 0; e < 256; ++e) qn.push((e + 256).toString(16).slice(1));
function o1e(e, t = 0) {
  return (
    qn[e[t + 0]] +
    qn[e[t + 1]] +
    qn[e[t + 2]] +
    qn[e[t + 3]] +
    '-' +
    qn[e[t + 4]] +
    qn[e[t + 5]] +
    '-' +
    qn[e[t + 6]] +
    qn[e[t + 7]] +
    '-' +
    qn[e[t + 8]] +
    qn[e[t + 9]] +
    '-' +
    qn[e[t + 10]] +
    qn[e[t + 11]] +
    qn[e[t + 12]] +
    qn[e[t + 13]] +
    qn[e[t + 14]] +
    qn[e[t + 15]]
  ).toLowerCase();
}
let p_;
const a1e = new Uint8Array(16);
function c1e() {
  if (!p_) {
    if (typeof crypto > 'u' || !crypto.getRandomValues)
      throw new Error(
        'crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported'
      );
    p_ = crypto.getRandomValues.bind(crypto);
  }
  return p_(a1e);
}
const u1e = typeof crypto < 'u' && crypto.randomUUID && crypto.randomUUID.bind(crypto),
  m8 = { randomUUID: u1e };
function T7(e, t, n) {
  var i;
  if (m8.randomUUID && !t && !e) return m8.randomUUID();
  e = e || {};
  const r = e.random ?? ((i = e.rng) == null ? void 0 : i.call(e)) ?? c1e();
  if (r.length < 16) throw new Error('Random bytes length must be >= 16');
  if (((r[6] = (r[6] & 15) | 64), (r[8] = (r[8] & 63) | 128), t)) {
    if (((n = n || 0), n < 0 || n + 16 > t.length))
      throw new RangeError(`UUID byte range ${n}:${n + 15} is out of buffer bounds`);
    for (let s = 0; s < 16; ++s) t[n + s] = r[s];
    return t;
  }
  return o1e(r);
}
async function l1e(e, t, n) {
  const r = await e.decryptionKeySharePhantom.foldAsync(async (u) =>
      z.from(new Uint8Array(u)).toString('base64')
    ),
    i = z.from(e.encryptedAccounts, 'hex').toString('base64'),
    s = z.from(e.encryptionKey, 'hex').toString('base64'),
    o = { ciphertext: i, encryptionKey: s, share: r, externalId: t, mode: 'JUICEBOX' },
    a = await Ge.api()
      .bearer(n)
      .headers({ 'Content-Type': 'application/json' })
      .post(`${Pc}/v1/bundles`, o),
    c = tr(a);
  return (
    c ||
      re.addBreadcrumb(ce.Seedless, 'Failed to backup bundle to backend', Ie.Error, {
        status: a.status,
        statusText: a.statusText,
      }),
    c
  );
}
async function x7(e, t) {
  const n = await Ge.api().bearer(t).get(`${Pc}/v1/bundles/${e}?mode=JUICEBOX`);
  if (n.status === 404) throw new Error('bundle not found');
  if (!tr(n)) {
    re.addBreadcrumb(ce.Seedless, 'Failed to recover bundle from backend', Ie.Error, {
      status: n.status,
      statusText: n.statusText,
    });
    const r = new Error('Got invalid response from seedless backend: ' + n.statusText);
    throw (re.captureError(r, ce.Seedless), r);
  }
  if (!('share' in n.data)) {
    re.addBreadcrumb(ce.Seedless, 'No share found in bundle', Ie.Error);
    const r = new Error('Did not receive share from seedless backend');
    throw (re.captureError(r, ce.Seedless), r);
  }
  try {
    const r = mr.from(new Uint8Array(z.from(n.data.share, 'base64'))),
      i = z.from(n.data.ciphertext, 'base64').toString('hex'),
      s = z.from(n.data.encryptionKey, 'base64').toString('hex');
    return {
      id: n.data.externalId,
      encryptedAccounts: i,
      encryptionKey: s,
      decryptionKeyShare1: r,
    };
  } catch {
    throw new Error('Unable to parse bundle. Incorrect format.');
  }
}
async function k7(e, t) {
  const n = await Ge.api().bearer(t).get(`${Pc}/v1/bundles/${e}?mode=JUICEBOX&populate=none`);
  if ((re.addBreadcrumb(ce.Seedless, 'Checking if user has a se*dless bundle', Ie.Info), tr(n)))
    return (
      re.addBreadcrumb(ce.Seedless, 'A se*dless bundle has been found for this user', Ie.Info, {
        status: n.status,
        statusText: n.statusText,
      }),
      !0
    );
  if (n.status === 404)
    return (
      re.addBreadcrumb(ce.Seedless, 'No se*dless bundle found for user', Ie.Info, {
        status: n.status,
        statusText: n.statusText,
      }),
      !1
    );
  const r = new Error('Failed to check for se*dless bundle.');
  throw (re.captureError(r, ce.Seedless), r);
}
async function C7(e, t) {
  let n = Ge.api().bearer(t).headers({ 'Content-Type': 'application/json' });
  e !== 'latest' && (n = n.retry(3, 500));
  const r = await n.delete(`${Pc}/v1/bundles/${e}`, { mode: 'JUICEBOX' });
  if ((re.addBreadcrumb(ce.Seedless, 'Deleting se*dless bundle', Ie.Info), tr(r)))
    return (
      re.addBreadcrumb(ce.Seedless, 'A se*dless bundle has been deleted for this user', Ie.Info, {
        status: r.status,
        statusText: r.statusText,
      }),
      !0
    );
  if (r.status === 404)
    return (
      re.addBreadcrumb(ce.Seedless, 'No se*dless bundle found for user', Ie.Info, {
        status: r.status,
        statusText: r.statusText,
      }),
      !1
    );
  const i = new Error('Failed to delete se*dless bundle.');
  throw (re.captureError(i, ce.Seedless), i);
}
async function P7(e, t) {
  const n = await Ge.api().bearer(e).get(`${Pc}/v1/device-encryption-keys/${t}`);
  if (n.status === 404)
    return re.addBreadcrumb(ce.Seedless, 'No device encryption key found for user', Ie.Info), null;
  if (!tr(n)) throw new Error('Unable to get device encryption key.');
  try {
    const { encryptionKey: r } = Sme.parse(n.data);
    return mr.from(new Uint8Array(z.from(r, 'base64')));
  } catch {
    throw new Error('Unable to parse device encryption key from response.');
  }
}
async function d1e(e, t, n) {
  const r = await Ge.api()
    .bearer(e)
    .post(`${Pc}/v1/device-encryption-keys`, {
      deviceId: t,
      encryptionKey: n.fold((i) => z.from(i).toString('base64')),
    });
  if (!tr(r)) throw new Error('Unable to set device encryption key.');
}
async function f1e(e, t) {
  const n = await Ge.api().bearer(e).delete(`${Pc}/v1/device-encryption-keys/${t}`);
  if (!tr(n)) throw new Error('Unable to delete device encryption key.');
}
function ly(e) {
  if (!Number.isSafeInteger(e) || e < 0) throw new Error(`positive integer expected, not ${e}`);
}
function w8(e) {
  if (typeof e != 'boolean') throw new Error(`boolean expected, not ${e}`);
}
function M7(e) {
  return (
    e instanceof Uint8Array ||
    (e != null && typeof e == 'object' && e.constructor.name === 'Uint8Array')
  );
}
function Li(e, ...t) {
  if (!M7(e)) throw new Error('Uint8Array expected');
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`);
}
function v8(e, t = !0) {
  if (e.destroyed) throw new Error('Hash instance has been destroyed');
  if (t && e.finished) throw new Error('Hash#digest() has already been called');
}
function h1e(e, t) {
  Li(e);
  const n = t.outputLen;
  if (e.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`);
}
/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */ const da = (e) =>
    new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)),
  p1e = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength),
  g1e = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!g1e) throw new Error('Non little-endian hardware is not supported');
function O7(e) {
  if (typeof e != 'string') throw new Error(`string expected, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function RE(e) {
  if (typeof e == 'string') e = O7(e);
  else if (M7(e)) e = e.slice();
  else throw new Error(`Uint8Array expected, got ${typeof e}`);
  return e;
}
function y1e(...e) {
  let t = 0;
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    Li(i), (t += i.length);
  }
  const n = new Uint8Array(t);
  for (let r = 0, i = 0; r < e.length; r++) {
    const s = e[r];
    n.set(s, i), (i += s.length);
  }
  return n;
}
function b1e(e, t) {
  if (t == null || typeof t != 'object') throw new Error('options must be defined');
  return Object.assign(e, t);
}
function m1e(e, t) {
  if (e.length !== t.length) return !1;
  let n = 0;
  for (let r = 0; r < e.length; r++) n |= e[r] ^ t[r];
  return n === 0;
}
const w1e = (e, t) => (Object.assign(t, e), t);
function _8(e, t, n, r) {
  if (typeof e.setBigUint64 == 'function') return e.setBigUint64(t, n, r);
  const i = BigInt(32),
    s = BigInt(4294967295),
    o = Number((n >> i) & s),
    a = Number(n & s),
    c = r ? 4 : 0,
    u = r ? 0 : 4;
  e.setUint32(t + c, o, r), e.setUint32(t + u, a, r);
}
const Wn = (e, t) => (e[t++] & 255) | ((e[t++] & 255) << 8);
class v1e {
  constructor(t) {
    (this.blockLen = 16),
      (this.outputLen = 16),
      (this.buffer = new Uint8Array(16)),
      (this.r = new Uint16Array(10)),
      (this.h = new Uint16Array(10)),
      (this.pad = new Uint16Array(8)),
      (this.pos = 0),
      (this.finished = !1),
      (t = RE(t)),
      Li(t, 32);
    const n = Wn(t, 0),
      r = Wn(t, 2),
      i = Wn(t, 4),
      s = Wn(t, 6),
      o = Wn(t, 8),
      a = Wn(t, 10),
      c = Wn(t, 12),
      u = Wn(t, 14);
    (this.r[0] = n & 8191),
      (this.r[1] = ((n >>> 13) | (r << 3)) & 8191),
      (this.r[2] = ((r >>> 10) | (i << 6)) & 7939),
      (this.r[3] = ((i >>> 7) | (s << 9)) & 8191),
      (this.r[4] = ((s >>> 4) | (o << 12)) & 255),
      (this.r[5] = (o >>> 1) & 8190),
      (this.r[6] = ((o >>> 14) | (a << 2)) & 8191),
      (this.r[7] = ((a >>> 11) | (c << 5)) & 8065),
      (this.r[8] = ((c >>> 8) | (u << 8)) & 8191),
      (this.r[9] = (u >>> 5) & 127);
    for (let l = 0; l < 8; l++) this.pad[l] = Wn(t, 16 + 2 * l);
  }
  process(t, n, r = !1) {
    const i = r ? 0 : 2048,
      { h: s, r: o } = this,
      a = o[0],
      c = o[1],
      u = o[2],
      l = o[3],
      d = o[4],
      f = o[5],
      h = o[6],
      p = o[7],
      b = o[8],
      w = o[9],
      A = Wn(t, n + 0),
      _ = Wn(t, n + 2),
      x = Wn(t, n + 4),
      k = Wn(t, n + 6),
      j = Wn(t, n + 8),
      F = Wn(t, n + 10),
      K = Wn(t, n + 12),
      D = Wn(t, n + 14);
    let C = s[0] + (A & 8191),
      B = s[1] + (((A >>> 13) | (_ << 3)) & 8191),
      E = s[2] + (((_ >>> 10) | (x << 6)) & 8191),
      y = s[3] + (((x >>> 7) | (k << 9)) & 8191),
      v = s[4] + (((k >>> 4) | (j << 12)) & 8191),
      S = s[5] + ((j >>> 1) & 8191),
      T = s[6] + (((j >>> 14) | (F << 2)) & 8191),
      M = s[7] + (((F >>> 11) | (K << 5)) & 8191),
      R = s[8] + (((K >>> 8) | (D << 8)) & 8191),
      L = s[9] + ((D >>> 5) | i),
      O = 0,
      I = O + C * a + B * (5 * w) + E * (5 * b) + y * (5 * p) + v * (5 * h);
    (O = I >>> 13),
      (I &= 8191),
      (I += S * (5 * f) + T * (5 * d) + M * (5 * l) + R * (5 * u) + L * (5 * c)),
      (O += I >>> 13),
      (I &= 8191);
    let U = O + C * c + B * a + E * (5 * w) + y * (5 * b) + v * (5 * p);
    (O = U >>> 13),
      (U &= 8191),
      (U += S * (5 * h) + T * (5 * f) + M * (5 * d) + R * (5 * l) + L * (5 * u)),
      (O += U >>> 13),
      (U &= 8191);
    let H = O + C * u + B * c + E * a + y * (5 * w) + v * (5 * b);
    (O = H >>> 13),
      (H &= 8191),
      (H += S * (5 * p) + T * (5 * h) + M * (5 * f) + R * (5 * d) + L * (5 * l)),
      (O += H >>> 13),
      (H &= 8191);
    let X = O + C * l + B * u + E * c + y * a + v * (5 * w);
    (O = X >>> 13),
      (X &= 8191),
      (X += S * (5 * b) + T * (5 * p) + M * (5 * h) + R * (5 * f) + L * (5 * d)),
      (O += X >>> 13),
      (X &= 8191);
    let J = O + C * d + B * l + E * u + y * c + v * a;
    (O = J >>> 13),
      (J &= 8191),
      (J += S * (5 * w) + T * (5 * b) + M * (5 * p) + R * (5 * h) + L * (5 * f)),
      (O += J >>> 13),
      (J &= 8191);
    let ie = O + C * f + B * d + E * l + y * u + v * c;
    (O = ie >>> 13),
      (ie &= 8191),
      (ie += S * a + T * (5 * w) + M * (5 * b) + R * (5 * p) + L * (5 * h)),
      (O += ie >>> 13),
      (ie &= 8191);
    let Z = O + C * h + B * f + E * d + y * l + v * u;
    (O = Z >>> 13),
      (Z &= 8191),
      (Z += S * c + T * a + M * (5 * w) + R * (5 * b) + L * (5 * p)),
      (O += Z >>> 13),
      (Z &= 8191);
    let be = O + C * p + B * h + E * f + y * d + v * l;
    (O = be >>> 13),
      (be &= 8191),
      (be += S * u + T * c + M * a + R * (5 * w) + L * (5 * b)),
      (O += be >>> 13),
      (be &= 8191);
    let le = O + C * b + B * p + E * h + y * f + v * d;
    (O = le >>> 13),
      (le &= 8191),
      (le += S * l + T * u + M * c + R * a + L * (5 * w)),
      (O += le >>> 13),
      (le &= 8191);
    let Oe = O + C * w + B * b + E * p + y * h + v * f;
    (O = Oe >>> 13),
      (Oe &= 8191),
      (Oe += S * d + T * l + M * u + R * c + L * a),
      (O += Oe >>> 13),
      (Oe &= 8191),
      (O = ((O << 2) + O) | 0),
      (O = (O + I) | 0),
      (I = O & 8191),
      (O = O >>> 13),
      (U += O),
      (s[0] = I),
      (s[1] = U),
      (s[2] = H),
      (s[3] = X),
      (s[4] = J),
      (s[5] = ie),
      (s[6] = Z),
      (s[7] = be),
      (s[8] = le),
      (s[9] = Oe);
  }
  finalize() {
    const { h: t, pad: n } = this,
      r = new Uint16Array(10);
    let i = t[1] >>> 13;
    t[1] &= 8191;
    for (let a = 2; a < 10; a++) (t[a] += i), (i = t[a] >>> 13), (t[a] &= 8191);
    (t[0] += i * 5),
      (i = t[0] >>> 13),
      (t[0] &= 8191),
      (t[1] += i),
      (i = t[1] >>> 13),
      (t[1] &= 8191),
      (t[2] += i),
      (r[0] = t[0] + 5),
      (i = r[0] >>> 13),
      (r[0] &= 8191);
    for (let a = 1; a < 10; a++) (r[a] = t[a] + i), (i = r[a] >>> 13), (r[a] &= 8191);
    r[9] -= 8192;
    let s = (i ^ 1) - 1;
    for (let a = 0; a < 10; a++) r[a] &= s;
    s = ~s;
    for (let a = 0; a < 10; a++) t[a] = (t[a] & s) | r[a];
    (t[0] = (t[0] | (t[1] << 13)) & 65535),
      (t[1] = ((t[1] >>> 3) | (t[2] << 10)) & 65535),
      (t[2] = ((t[2] >>> 6) | (t[3] << 7)) & 65535),
      (t[3] = ((t[3] >>> 9) | (t[4] << 4)) & 65535),
      (t[4] = ((t[4] >>> 12) | (t[5] << 1) | (t[6] << 14)) & 65535),
      (t[5] = ((t[6] >>> 2) | (t[7] << 11)) & 65535),
      (t[6] = ((t[7] >>> 5) | (t[8] << 8)) & 65535),
      (t[7] = ((t[8] >>> 8) | (t[9] << 5)) & 65535);
    let o = t[0] + n[0];
    t[0] = o & 65535;
    for (let a = 1; a < 8; a++) (o = (((t[a] + n[a]) | 0) + (o >>> 16)) | 0), (t[a] = o & 65535);
  }
  update(t) {
    v8(this);
    const { buffer: n, blockLen: r } = this;
    t = RE(t);
    const i = t.length;
    for (let s = 0; s < i; ) {
      const o = Math.min(r - this.pos, i - s);
      if (o === r) {
        for (; r <= i - s; s += r) this.process(t, s);
        continue;
      }
      n.set(t.subarray(s, s + o), this.pos),
        (this.pos += o),
        (s += o),
        this.pos === r && (this.process(n, 0, !1), (this.pos = 0));
    }
    return this;
  }
  destroy() {
    this.h.fill(0), this.r.fill(0), this.buffer.fill(0), this.pad.fill(0);
  }
  digestInto(t) {
    v8(this), h1e(t, this), (this.finished = !0);
    const { buffer: n, h: r } = this;
    let { pos: i } = this;
    if (i) {
      for (n[i++] = 1; i < 16; i++) n[i] = 0;
      this.process(n, 0, !0);
    }
    this.finalize();
    let s = 0;
    for (let o = 0; o < 8; o++) (t[s++] = r[o] >>> 0), (t[s++] = r[o] >>> 8);
    return t;
  }
  digest() {
    const { buffer: t, outputLen: n } = this;
    this.digestInto(t);
    const r = t.slice(0, n);
    return this.destroy(), r;
  }
}
function _1e(e) {
  const t = (r, i) => e(i).update(RE(r)).digest(),
    n = e(new Uint8Array(32));
  return (t.outputLen = n.outputLen), (t.blockLen = n.blockLen), (t.create = (r) => e(r)), t;
}
const S1e = _1e((e) => new v1e(e)),
  B7 = (e) => Uint8Array.from(e.split('').map((t) => t.charCodeAt(0))),
  E1e = B7('expand 16-byte k'),
  A1e = B7('expand 32-byte k'),
  I1e = da(E1e),
  D7 = da(A1e);
D7.slice();
function Be(e, t) {
  return (e << t) | (e >>> (32 - t));
}
function NE(e) {
  return e.byteOffset % 4 === 0;
}
const Sg = 64,
  T1e = 16,
  R7 = 2 ** 32 - 1,
  S8 = new Uint32Array();
function x1e(e, t, n, r, i, s, o, a) {
  const c = i.length,
    u = new Uint8Array(Sg),
    l = da(u),
    d = NE(i) && NE(s),
    f = d ? da(i) : S8,
    h = d ? da(s) : S8;
  for (let p = 0; p < c; o++) {
    if ((e(t, n, r, l, o, a), o >= R7)) throw new Error('arx: counter overflow');
    const b = Math.min(Sg, c - p);
    if (d && b === Sg) {
      const w = p / 4;
      if (p % 4 !== 0) throw new Error('arx: invalid block position');
      for (let A = 0, _; A < T1e; A++) (_ = w + A), (h[_] = f[_] ^ l[A]);
      p += Sg;
      continue;
    }
    for (let w = 0, A; w < b; w++) (A = p + w), (s[A] = i[A] ^ u[w]);
    p += b;
  }
}
function k1e(e, t) {
  const {
    allowShortKeys: n,
    extendNonceFn: r,
    counterLength: i,
    counterRight: s,
    rounds: o,
  } = b1e({ allowShortKeys: !1, counterLength: 8, counterRight: !1, rounds: 20 }, t);
  if (typeof e != 'function') throw new Error('core must be a function');
  return (
    ly(i),
    ly(o),
    w8(s),
    w8(n),
    (a, c, u, l, d = 0) => {
      Li(a), Li(c), Li(u);
      const f = u.length;
      if ((l || (l = new Uint8Array(f)), Li(l), ly(d), d < 0 || d >= R7))
        throw new Error('arx: counter overflow');
      if (l.length < f) throw new Error(`arx: output (${l.length}) is shorter than data (${f})`);
      const h = [];
      let p = a.length,
        b,
        w;
      if (p === 32) (b = a.slice()), h.push(b), (w = D7);
      else if (p === 16 && n)
        (b = new Uint8Array(32)), b.set(a), b.set(a, 16), (w = I1e), h.push(b);
      else throw new Error(`arx: invalid 32-byte key, got length=${p}`);
      NE(c) || ((c = c.slice()), h.push(c));
      const A = da(b);
      if (r) {
        if (c.length !== 24) throw new Error('arx: extended nonce must be 24 bytes');
        r(w, A, da(c.subarray(0, 16)), A), (c = c.subarray(16));
      }
      const _ = 16 - i;
      if (_ !== c.length) throw new Error(`arx: nonce must be ${_} or 16 bytes`);
      if (_ !== 12) {
        const k = new Uint8Array(12);
        k.set(c, s ? 0 : 12 - c.length), (c = k), h.push(c);
      }
      const x = da(c);
      for (x1e(e, w, A, x, u, l, d, o); h.length > 0; ) h.pop().fill(0);
      return l;
    }
  );
}
function C1e(e, t, n, r, i, s = 20) {
  let o = e[0],
    a = e[1],
    c = e[2],
    u = e[3],
    l = t[0],
    d = t[1],
    f = t[2],
    h = t[3],
    p = t[4],
    b = t[5],
    w = t[6],
    A = t[7],
    _ = i,
    x = n[0],
    k = n[1],
    j = n[2],
    F = o,
    K = a,
    D = c,
    C = u,
    B = l,
    E = d,
    y = f,
    v = h,
    S = p,
    T = b,
    M = w,
    R = A,
    L = _,
    O = x,
    I = k,
    U = j;
  for (let X = 0; X < s; X += 2)
    (F = (F + B) | 0),
      (L = Be(L ^ F, 16)),
      (S = (S + L) | 0),
      (B = Be(B ^ S, 12)),
      (F = (F + B) | 0),
      (L = Be(L ^ F, 8)),
      (S = (S + L) | 0),
      (B = Be(B ^ S, 7)),
      (K = (K + E) | 0),
      (O = Be(O ^ K, 16)),
      (T = (T + O) | 0),
      (E = Be(E ^ T, 12)),
      (K = (K + E) | 0),
      (O = Be(O ^ K, 8)),
      (T = (T + O) | 0),
      (E = Be(E ^ T, 7)),
      (D = (D + y) | 0),
      (I = Be(I ^ D, 16)),
      (M = (M + I) | 0),
      (y = Be(y ^ M, 12)),
      (D = (D + y) | 0),
      (I = Be(I ^ D, 8)),
      (M = (M + I) | 0),
      (y = Be(y ^ M, 7)),
      (C = (C + v) | 0),
      (U = Be(U ^ C, 16)),
      (R = (R + U) | 0),
      (v = Be(v ^ R, 12)),
      (C = (C + v) | 0),
      (U = Be(U ^ C, 8)),
      (R = (R + U) | 0),
      (v = Be(v ^ R, 7)),
      (F = (F + E) | 0),
      (U = Be(U ^ F, 16)),
      (M = (M + U) | 0),
      (E = Be(E ^ M, 12)),
      (F = (F + E) | 0),
      (U = Be(U ^ F, 8)),
      (M = (M + U) | 0),
      (E = Be(E ^ M, 7)),
      (K = (K + y) | 0),
      (L = Be(L ^ K, 16)),
      (R = (R + L) | 0),
      (y = Be(y ^ R, 12)),
      (K = (K + y) | 0),
      (L = Be(L ^ K, 8)),
      (R = (R + L) | 0),
      (y = Be(y ^ R, 7)),
      (D = (D + v) | 0),
      (O = Be(O ^ D, 16)),
      (S = (S + O) | 0),
      (v = Be(v ^ S, 12)),
      (D = (D + v) | 0),
      (O = Be(O ^ D, 8)),
      (S = (S + O) | 0),
      (v = Be(v ^ S, 7)),
      (C = (C + B) | 0),
      (I = Be(I ^ C, 16)),
      (T = (T + I) | 0),
      (B = Be(B ^ T, 12)),
      (C = (C + B) | 0),
      (I = Be(I ^ C, 8)),
      (T = (T + I) | 0),
      (B = Be(B ^ T, 7));
  let H = 0;
  (r[H++] = (o + F) | 0),
    (r[H++] = (a + K) | 0),
    (r[H++] = (c + D) | 0),
    (r[H++] = (u + C) | 0),
    (r[H++] = (l + B) | 0),
    (r[H++] = (d + E) | 0),
    (r[H++] = (f + y) | 0),
    (r[H++] = (h + v) | 0),
    (r[H++] = (p + S) | 0),
    (r[H++] = (b + T) | 0),
    (r[H++] = (w + M) | 0),
    (r[H++] = (A + R) | 0),
    (r[H++] = (_ + L) | 0),
    (r[H++] = (x + O) | 0),
    (r[H++] = (k + I) | 0),
    (r[H++] = (j + U) | 0);
}
function P1e(e, t, n, r) {
  let i = e[0],
    s = e[1],
    o = e[2],
    a = e[3],
    c = t[0],
    u = t[1],
    l = t[2],
    d = t[3],
    f = t[4],
    h = t[5],
    p = t[6],
    b = t[7],
    w = n[0],
    A = n[1],
    _ = n[2],
    x = n[3];
  for (let j = 0; j < 20; j += 2)
    (i = (i + c) | 0),
      (w = Be(w ^ i, 16)),
      (f = (f + w) | 0),
      (c = Be(c ^ f, 12)),
      (i = (i + c) | 0),
      (w = Be(w ^ i, 8)),
      (f = (f + w) | 0),
      (c = Be(c ^ f, 7)),
      (s = (s + u) | 0),
      (A = Be(A ^ s, 16)),
      (h = (h + A) | 0),
      (u = Be(u ^ h, 12)),
      (s = (s + u) | 0),
      (A = Be(A ^ s, 8)),
      (h = (h + A) | 0),
      (u = Be(u ^ h, 7)),
      (o = (o + l) | 0),
      (_ = Be(_ ^ o, 16)),
      (p = (p + _) | 0),
      (l = Be(l ^ p, 12)),
      (o = (o + l) | 0),
      (_ = Be(_ ^ o, 8)),
      (p = (p + _) | 0),
      (l = Be(l ^ p, 7)),
      (a = (a + d) | 0),
      (x = Be(x ^ a, 16)),
      (b = (b + x) | 0),
      (d = Be(d ^ b, 12)),
      (a = (a + d) | 0),
      (x = Be(x ^ a, 8)),
      (b = (b + x) | 0),
      (d = Be(d ^ b, 7)),
      (i = (i + u) | 0),
      (x = Be(x ^ i, 16)),
      (p = (p + x) | 0),
      (u = Be(u ^ p, 12)),
      (i = (i + u) | 0),
      (x = Be(x ^ i, 8)),
      (p = (p + x) | 0),
      (u = Be(u ^ p, 7)),
      (s = (s + l) | 0),
      (w = Be(w ^ s, 16)),
      (b = (b + w) | 0),
      (l = Be(l ^ b, 12)),
      (s = (s + l) | 0),
      (w = Be(w ^ s, 8)),
      (b = (b + w) | 0),
      (l = Be(l ^ b, 7)),
      (o = (o + d) | 0),
      (A = Be(A ^ o, 16)),
      (f = (f + A) | 0),
      (d = Be(d ^ f, 12)),
      (o = (o + d) | 0),
      (A = Be(A ^ o, 8)),
      (f = (f + A) | 0),
      (d = Be(d ^ f, 7)),
      (a = (a + c) | 0),
      (_ = Be(_ ^ a, 16)),
      (h = (h + _) | 0),
      (c = Be(c ^ h, 12)),
      (a = (a + c) | 0),
      (_ = Be(_ ^ a, 8)),
      (h = (h + _) | 0),
      (c = Be(c ^ h, 7));
  let k = 0;
  (r[k++] = i),
    (r[k++] = s),
    (r[k++] = o),
    (r[k++] = a),
    (r[k++] = w),
    (r[k++] = A),
    (r[k++] = _),
    (r[k++] = x);
}
const M1e = k1e(C1e, {
    counterRight: !1,
    counterLength: 8,
    extendNonceFn: P1e,
    allowShortKeys: !1,
  }),
  O1e = new Uint8Array(16),
  E8 = (e, t) => {
    e.update(t);
    const n = t.length % 16;
    n && e.update(O1e.subarray(n));
  },
  B1e = new Uint8Array(32);
function A8(e, t, n, r, i) {
  const s = e(t, n, B1e),
    o = S1e.create(s);
  i && E8(o, i), E8(o, r);
  const a = new Uint8Array(16),
    c = p1e(a);
  _8(c, 0, BigInt(i ? i.length : 0), !0), _8(c, 8, BigInt(r.length), !0), o.update(a);
  const u = o.digest();
  return s.fill(0), u;
}
const D1e = (e) => (t, n, r) => (
    Li(t, 32),
    Li(n),
    {
      encrypt: (s, o) => {
        const a = s.length,
          c = a + 16;
        o ? Li(o, c) : (o = new Uint8Array(c)), e(t, n, s, o, 1);
        const u = A8(e, t, n, o.subarray(0, -16), r);
        return o.set(u, a), o;
      },
      decrypt: (s, o) => {
        const a = s.length,
          c = a - 16;
        if (a < 16) throw new Error('encrypted data must be at least 16 bytes');
        o ? Li(o, c) : (o = new Uint8Array(c));
        const u = s.subarray(0, -16),
          l = s.subarray(-16),
          d = A8(e, t, n, u, r);
        if (!m1e(l, d)) throw new Error('invalid tag');
        return e(t, n, u, o, 1), o;
      },
    }
  ),
  N7 = w1e({ blockSize: 64, nonceLength: 24, tagLength: 16 }, D1e(M1e)),
  g_ = typeof globalThis == 'object' && 'crypto' in globalThis ? globalThis.crypto : void 0;
function R1e(e = 32) {
  if (g_ && typeof g_.getRandomValues == 'function') return g_.getRandomValues(new Uint8Array(e));
  throw new Error('crypto.getRandomValues must be defined');
}
function j7(e) {
  return (
    ly(e.nonceLength),
    (t, ...n) => ({
      encrypt: (r, ...i) => {
        const { nonceLength: s } = e,
          o = R1e(s),
          a = e(t, o, ...n).encrypt(r, ...i),
          c = y1e(o, a);
        return a.fill(0), c;
      },
      decrypt: (r, ...i) => {
        const { nonceLength: s } = e,
          o = r.subarray(0, s),
          a = r.subarray(s);
        return e(t, o, ...n).decrypt(a, ...i);
      },
    })
  );
}
function L7(e) {
  return crypto.getRandomValues(new Uint8Array(e));
}
const nb = new Uint8Array([
    0, 255, 200, 8, 145, 16, 208, 54, 90, 62, 216, 67, 153, 119, 254, 24, 35, 32, 7, 112, 161, 108,
    12, 127, 98, 139, 64, 70, 199, 75, 224, 14, 235, 22, 232, 173, 207, 205, 57, 83, 106, 39, 53,
    147, 212, 78, 72, 195, 43, 121, 84, 40, 9, 120, 15, 33, 144, 135, 20, 42, 169, 156, 214, 116,
    180, 124, 222, 237, 177, 134, 118, 164, 152, 226, 150, 143, 2, 50, 28, 193, 51, 238, 239, 129,
    253, 48, 92, 19, 157, 41, 23, 196, 17, 68, 140, 128, 243, 115, 66, 30, 29, 181, 240, 18, 209,
    91, 65, 162, 215, 44, 233, 213, 89, 203, 80, 168, 220, 252, 242, 86, 114, 166, 101, 47, 159,
    155, 61, 186, 125, 194, 69, 130, 167, 87, 182, 163, 122, 117, 79, 174, 63, 55, 109, 71, 97, 190,
    171, 211, 95, 176, 88, 175, 202, 94, 250, 133, 228, 77, 138, 5, 251, 96, 183, 123, 184, 38, 74,
    103, 198, 26, 248, 105, 37, 179, 219, 189, 102, 221, 241, 210, 223, 3, 141, 52, 217, 146, 13,
    99, 85, 170, 73, 236, 188, 149, 60, 132, 11, 245, 230, 231, 229, 172, 126, 110, 185, 249, 218,
    142, 154, 201, 36, 225, 10, 21, 107, 58, 160, 81, 244, 234, 178, 151, 158, 93, 34, 136, 148,
    206, 25, 1, 113, 76, 165, 227, 197, 49, 187, 204, 31, 45, 59, 82, 111, 246, 46, 137, 247, 192,
    104, 27, 100, 4, 6, 191, 131, 56,
  ]),
  U7 = new Uint8Array([
    1, 229, 76, 181, 251, 159, 252, 18, 3, 52, 212, 196, 22, 186, 31, 54, 5, 92, 103, 87, 58, 213,
    33, 90, 15, 228, 169, 249, 78, 100, 99, 238, 17, 55, 224, 16, 210, 172, 165, 41, 51, 89, 59, 48,
    109, 239, 244, 123, 85, 235, 77, 80, 183, 42, 7, 141, 255, 38, 215, 240, 194, 126, 9, 140, 26,
    106, 98, 11, 93, 130, 27, 143, 46, 190, 166, 29, 231, 157, 45, 138, 114, 217, 241, 39, 50, 188,
    119, 133, 150, 112, 8, 105, 86, 223, 153, 148, 161, 144, 24, 187, 250, 122, 176, 167, 248, 171,
    40, 214, 21, 142, 203, 242, 19, 230, 120, 97, 63, 137, 70, 13, 53, 49, 136, 163, 65, 128, 202,
    23, 95, 83, 131, 254, 195, 155, 69, 57, 225, 245, 158, 25, 94, 182, 207, 75, 56, 4, 185, 43,
    226, 193, 74, 221, 72, 12, 208, 125, 61, 88, 222, 124, 216, 20, 107, 135, 71, 232, 121, 132,
    115, 60, 189, 146, 201, 35, 139, 151, 149, 68, 220, 173, 64, 101, 134, 162, 164, 204, 127, 236,
    192, 175, 145, 253, 247, 79, 129, 47, 91, 234, 168, 28, 2, 209, 152, 113, 237, 37, 227, 36, 6,
    104, 179, 147, 44, 111, 62, 108, 10, 184, 206, 174, 116, 177, 66, 180, 30, 211, 73, 233, 156,
    200, 198, 199, 34, 110, 219, 32, 191, 67, 81, 82, 102, 178, 118, 96, 218, 197, 243, 246, 170,
    205, 154, 160, 117, 84, 14, 1,
  ]);
function dy(e, t) {
  if (!Number.isInteger(e) || e < 0 || e > 255)
    throw new RangeError('Number is out of Uint8 range');
  if (!Number.isInteger(t) || t < 0 || t > 255)
    throw new RangeError('Number is out of Uint8 range');
  return e ^ t;
}
function N1e(e, t) {
  if (!Number.isInteger(e) || e < 0 || e > 255)
    throw new RangeError('Number is out of Uint8 range');
  if (!Number.isInteger(t) || t < 0 || t > 255)
    throw new RangeError('Number is out of Uint8 range');
  if (t === 0) throw new Error('cannot divide by zero');
  const n = nb[e],
    r = nb[t],
    i = (n - r + 255) % 255,
    s = U7[i];
  return e === 0 ? 0 : s;
}
function jE(e, t) {
  if (!Number.isInteger(e) || e < 0 || e > 255)
    throw new RangeError('Number is out of Uint8 range');
  if (!Number.isInteger(t) || t < 0 || t > 255)
    throw new RangeError('Number is out of Uint8 range');
  const n = nb[e],
    r = nb[t],
    i = (n + r) % 255,
    s = U7[i];
  return e === 0 || t === 0 ? 0 : s;
}
function j1e(e, t, n) {
  if (e.length !== t.length) throw new Error('sample length mistmatch');
  const r = e.length;
  let i = 0,
    s = 0;
  for (let o = 0; o < r; o++) {
    i = 1;
    for (let a = 0; a < r; ++a) {
      if (o === a) continue;
      const c = dy(n, e[a]),
        u = dy(e[o], e[a]),
        l = N1e(c, u);
      i = jE(i, l);
    }
    s = dy(s, jE(t[o], i));
  }
  return s;
}
function L1e(e, t, n) {
  if (t === 0) throw new Error('cannot evaluate secret polynomial at zero');
  let r = e[n];
  for (let i = n - 1; i >= 0; i--) {
    const s = e[i];
    r = dy(jE(r, t), s);
  }
  return r;
}
function $7() {
  return L7(1)[0];
}
function U1e() {
  for (;;) {
    const e = $7();
    if (e > 0) return e;
  }
}
function $1e(e, t) {
  const n = new Uint8Array(t + 1);
  n[0] = e;
  for (let r = 1; r <= t; r++) {
    const i = r === t;
    n[r] = i ? U1e() : $7();
  }
  return n;
}
function F1e() {
  const e = new Uint8Array(255);
  for (let n = 0; n < 255; n++) e[n] = n + 1;
  const t = L7(255);
  for (let n = 0; n < 255; n++) {
    const r = t[n] % 255,
      i = e[n];
    (e[n] = e[r]), (e[r] = i);
  }
  return e;
}
const Fr = {
  instanceOf(e, t, n) {
    if (e.constructor !== t) throw new TypeError(n);
  },
  inRange(e, t, n, r) {
    if (!(t < n && e >= t && e < n)) throw new RangeError(r);
  },
  greaterThanOrEqualTo(e, t, n) {
    if (e < t) throw new Error(n);
  },
  equalTo(e, t, n) {
    if (e !== t) throw new Error(n);
  },
};
async function z1e(e, t, n) {
  Fr.instanceOf(e, Uint8Array, 'secret must be a Uint8Array'),
    Fr.greaterThanOrEqualTo(e.byteLength, 1, 'secret cannot be empty'),
    Fr.instanceOf(t, Number, 'shares must be a number'),
    Fr.inRange(t, 2, 256, 'shares must be at least 2 and at most 255'),
    Fr.instanceOf(n, Number, 'threshold must be a number'),
    Fr.inRange(n, 2, 256, 'threshold must be at least 2 and at most 255'),
    Fr.greaterThanOrEqualTo(t, n, 'shares cannot be less than threshold');
  const r = [],
    i = e.byteLength,
    s = F1e();
  for (let a = 0; a < t; a++) {
    const c = new Uint8Array(i + 1);
    (c[i] = s[a]), r.push(c);
  }
  const o = n - 1;
  for (let a = 0; a < i; a++) {
    const c = e[a],
      u = $1e(c, o);
    for (let l = 0; l < t; ++l) {
      const d = s[l],
        f = L1e(u, d, o);
      r[l][a] = f;
    }
  }
  return r;
}
async function K1e(e) {
  Fr.instanceOf(e, Array, 'shares must be an Array'),
    Fr.inRange(e.length, 2, 256, 'shares must have at least 2 and at most 255 elements');
  const t = e[0];
  Fr.instanceOf(t, Uint8Array, 'each share must be a Uint8Array');
  for (const u of e)
    Fr.instanceOf(u, Uint8Array, 'each share must be a Uint8Array'),
      Fr.greaterThanOrEqualTo(u.byteLength, 2, 'each share must be at least 2 bytes'),
      Fr.equalTo(u.byteLength, t.byteLength, 'all shares must have the same byte length');
  const n = e.length,
    r = t.byteLength,
    i = r - 1,
    s = new Uint8Array(i),
    o = new Uint8Array(n),
    a = new Uint8Array(n),
    c = new Set();
  for (let u = 0; u < n; u++) {
    const d = e[u][r - 1];
    if (c.has(d)) throw new Error('shares must contain unique values but a duplicate was found');
    c.add(d), (o[u] = d);
  }
  for (let u = 0; u < i; u++) {
    for (let l = 0; l < n; ++l) a[l] = e[l][u];
    s[u] = j1e(o, a, 0);
  }
  return s;
}
const V1e = async (e, t) => {
  if (e.length !== 32) throw new Error('encryption key must be 32 bytes');
  G1e(e);
  const n = { seeds: [] };
  for (const u of t) {
    const l = 'unused',
      d = u.fold((f) => new Uint8Array(f));
    n.seeds.push([l, d]);
  }
  const r = j7(N7)(e),
    i = O7(JSON.stringify(n)),
    s = r.encrypt(i),
    [o, a] = await z1e(e, 2, 2);
  return {
    encryptedAccounts: y7(s),
    decryptionKeySharePhantom: mr.from(o),
    decryptionKeyShareExternal: mr.from(a),
    encryptionKey: 'unused',
  };
};
class Ll extends Error {
  constructor(n) {
    super(`Unable to decrypt seedless bundle: ${n}`);
    ae(this, 'reason');
    this.reason = n;
  }
}
const W1e = async (e) => {
    let t;
    try {
      t = await H1e(e.decryptionKeySharePhantom, e.decryptionKeyShareExternal);
    } catch {
      throw new Ll('incompatible-shares');
    }
    let n;
    try {
      n = j7(N7)(t).decrypt(Kme(e.encryptedAccounts));
    } catch {
      throw new Ll('incorrect-decryption-key');
    }
    let r;
    try {
      r = JSON.parse(z.from(n).toString());
    } catch {
      throw new Ll('invalid-json');
    }
    const i = wme.safeParse(r);
    if (!i.success) throw new Ll('invalid-format');
    return i.data.seeds.map((a) => {
      const c = a[1],
        u = vme(c);
      return mr.from(u);
    });
  },
  H1e = async (e, t) => {
    const n = e.fold((s) => new Uint8Array(s)),
      r = t.fold((s) => new Uint8Array(s));
    return await K1e([n, r]);
  },
  G1e = (e) => {
    if (e.every((t) => t === 0)) throw new Error('encryption key must not be all zeros');
  },
  q1e = [
    { id: 'a4caa86247c60f61b2454d8cbdb1ba2a', address: 'https://production-juicebox.phantom.dev' },
    { id: '7dd7ac88b0584725a2db014818631f8c', address: 'https://juicebox.rpcpool.com' },
  ],
  Y1e = 2,
  Z1e = 2,
  J1e = 'Standard2019',
  X1e = { realms: q1e, register_threshold: Y1e, recover_threshold: Z1e, pin_hashing_mode: J1e },
  Q1e = [
    { id: 'a4caa86247c60f61b2454d8cbdb1ba2a', address: 'https://production-juicebox.phantom.app' },
    { id: '7dd7ac88b0584725a2db014818631f8c', address: 'https://juicebox.rpcpool.com' },
  ],
  ewe = 2,
  twe = 2,
  nwe = 'Standard2019',
  rwe = { realms: Q1e, register_threshold: ewe, recover_threshold: twe, pin_hashing_mode: nwe },
  iwe = [
    { id: '497efc0c17f850465b9387a549affb2b', address: 'https://development-juicebox.phantom.dev' },
    { id: '7dd7ac88b0584725a2db014818631f8c', address: 'https://juicebox.rpcpool.com' },
  ],
  swe = 2,
  owe = 2,
  awe = 'Standard2019',
  cwe = { realms: iwe, register_threshold: swe, recover_threshold: owe, pin_hashing_mode: awe },
  uwe = [
    {
      id: '497efc0c17f850465b9387a549affb2b',
      address: 'https://development-juicebox.phantom.dev/',
    },
    { id: '7dd7ac88b0584725a2db014818631f8c', address: 'https://juicebox.rpcpool.com' },
  ],
  lwe = 2,
  dwe = 2,
  fwe = 'Standard2019',
  hwe = { realms: uwe, register_threshold: lwe, recover_threshold: dwe, pin_hashing_mode: fwe },
  pwe = [
    { id: '497efc0c17f850465b9387a549affb2b', address: 'https://development-juicebox.phantom.dev' },
    { id: '7dd7ac88b0584725a2db014818631f8c', address: 'https://juicebox.rpcpool.com' },
  ],
  gwe = 'f76005fd-80e5-483e-9d84-c09ef7c60ba3',
  ywe = 2,
  bwe = 2,
  mwe = 'Standard2019',
  wwe = {
    realms: pwe,
    uuid_nonce: gwe,
    register_threshold: ywe,
    recover_threshold: bwe,
    pin_hashing_mode: mwe,
  },
  vwe = [
    { id: '497efc0c17f850465b9387a549affb2b', address: 'https://development-juicebox.phantom.app' },
    { id: '7dd7ac88b0584725a2db014818631f8c', address: 'https://juicebox.rpcpool.com' },
  ],
  _we = '153ebe7b-400c-4d27-be76-139248bb3acd',
  Swe = 2,
  Ewe = 2,
  Awe = 'Standard2019',
  Iwe = {
    realms: vwe,
    uuid_nonce: _we,
    register_threshold: Swe,
    recover_threshold: Ewe,
    pin_hashing_mode: Awe,
  },
  Twe = [
    { id: '497efc0c17f850465b9387a549affb2b', address: 'https://development-juicebox.phantom.app' },
    { id: '7dd7ac88b0584725a2db014818631f8c', address: 'https://juicebox.rpcpool.com' },
  ],
  xwe = 'f577175c-3f1e-4f4a-91d1-cb30aaa0d5d4',
  kwe = 2,
  Cwe = 2,
  Pwe = 'Standard2019',
  Mwe = {
    realms: Twe,
    uuid_nonce: xwe,
    register_threshold: kwe,
    recover_threshold: Cwe,
    pin_hashing_mode: Pwe,
  },
  F7 = [X1e, rwe],
  Owe = F7.reduce((e, t) => ((e[Mp(t)] = t), e), {}),
  Bwe = [cwe, hwe, wwe, Iwe, Mwe];
Bwe.reduce((e, t) => ((e[Mp(t)] = t), e), {});
function z7() {
  return Owe;
}
function rb() {
  const e = F7;
  return e[e.length - 1];
}
const wi = {
    success: { type: 'success', didBackup: !0 },
    unauthorized: { type: 'unauthorized', didBackup: !1 },
    bundleAlreadyExists: { type: 'bundle-already-exists', didBackup: !1 },
    errorBackendCheck: { type: 'error-backend-check', didBackup: !1 },
    invalidPin: { type: 'invalid-pin-format', didBackup: !1 },
    errorEncryptionFailed: { type: 'error-encryption-failed', didBackup: !1 },
    errorBackendUpload: { type: 'error-backend-upload', didBackup: !1 },
    errorJuiceboxUpload: { type: 'error-juicebox-upload', didBackup: !1 },
    recoveredFromJuiceboxError: { type: 'recovered-juicebox-error', didBackup: !1 },
    errorBackendDelete: { type: 'error-backend-delete', didBackup: !1 },
  },
  mT = async (e, { pin: t, entropy: n }) => {
    if (!k1(t)) return wi.invalidPin;
    let r;
    try {
      if (((r = await e.authRepository.getUser()), !r)) return wi.unauthorized;
    } catch {
      return wi.unauthorized;
    }
    const i = rb(),
      s = Mp(i);
    try {
      if (await k7(s, r.accessToken)) return wi.bundleAlreadyExists;
    } catch {
      return wi.errorBackendCheck;
    }
    let o;
    try {
      const l = w7(Ame);
      o = await V1e(l, [n]);
    } catch {
      return wi.errorEncryptionFailed;
    }
    try {
      if (!(await l1e(o, s, r.accessToken))) return wi.errorBackendUpload;
    } catch {
      return wi.errorBackendUpload;
    }
    const a = o.decryptionKeyShareExternal.fold((l) => new Uint8Array(l)),
      c = await e.juiceboxClient();
    let u = !0;
    try {
      u = await c.sendJuiceboxShare(rb(), a, t, r.accessToken);
    } catch {
      u = !1;
    }
    if (!u)
      try {
        return await C7(s, r.accessToken), wi.recoveredFromJuiceboxError;
      } catch {
        return wi.errorBackendDelete;
      }
    return wi.success;
  },
  K7 = 'seedlessJuiceboxPinCooldownTimer',
  wT = '.phantom.seedless.juiceboxPinCooldownTimer',
  LE = async (e) => {
    const t = await e.get(K7),
      n = await e.get(wT),
      r = (n == null ? void 0 : n.timeRemaining) || t,
      i = n == null ? void 0 : n.guessesRemaining;
    return !r || r < 0
      ? { timeRemaining: 0, guessesRemaining: i }
      : { timeRemaining: r - Date.now(), guessesRemaining: i };
  },
  Dwe = async (e, t) => {
    const n = Nwe(e);
    if (!n) return;
    const r = Date.now() + n * 1e3;
    t.set(wT, { version: 2, timeRemaining: r, guessesRemaining: e });
  },
  Rwe = async (e) => {
    await e.remove(K7), await e.remove(wT);
  },
  Nwe = (e) => jwe[e],
  jwe = {
    [Ho]: 0,
    [Ho - 1]: 0,
    [Ho - 2]: 30,
    [Ho - 3]: 60,
    [Ho - 4]: 120,
    [Ho - 5]: 300,
    [XR]: 300,
  },
  Lwe = (e) => {
    let t = 'unknown';
    return (
      e instanceof Error &&
        (e.message.includes('bundle not found')
          ? (t = 'bundle-not-found')
          : e.message.includes('Got invalid response from seedless backend')
            ? (t = 'non-ok-response')
            : e.message.includes('Did not receive share from seedless backend')
              ? (t = 'no-share-in-bundle')
              : e.message.includes('Unable to parse bundle. Incorrect format.') &&
                (t = 'incorrect-format')),
      { type: 'error-backend-recover', reason: t }
    );
  },
  Uwe = async (e, t, { pin: n, ignoreCooldown: r = !1 }) => {
    const { authRepository: i, juiceboxClient: s, storage: o } = e,
      { timeRemaining: a, guessesRemaining: c } = await LE(o);
    if (a > 0 && !r) return { type: 'cooldown', timeRemaining: a, guessesRemaining: c };
    if (!k1(n)) return { type: 'invalid-pin-format' };
    const u = await i.getUser();
    if (!u) return { type: 'unauthorized' };
    const { accessToken: l } = u;
    let d;
    try {
      d = await x7('latest', l);
    } catch (_) {
      return Lwe(_);
    }
    const f = z7()[d.id];
    if (!f) return { type: 'upgrade-required' };
    const h = await s();
    let p;
    try {
      (p = new Uint8Array(await h.getJuiceboxShare(f, n, l))), await Rwe(o);
    } catch (_) {
      const x = _ == null ? void 0 : _.reasonCode,
        k = _ == null ? void 0 : _.guessesRemaining;
      if (c7(_))
        if (!r && k && k <= Ho - e7) {
          await Dwe(k, o);
          const { timeRemaining: F } = await LE(o);
          return { type: 'cooldown', timeRemaining: F, guessesRemaining: k };
        } else return { type: 'error-juicebox-recover', reason: x, guessesRemaining: k };
      else return { type: 'error-juicebox-recover', reason: x || 'unknown' };
    }
    if (p.every((_) => _ === 0)) return { type: 'error-juicebox-share-zero' };
    let w;
    try {
      w = await W1e({
        encryptedAccounts: d.encryptedAccounts,
        encryptionKey: d.encryptionKey,
        decryptionKeySharePhantom: d.decryptionKeyShare1,
        decryptionKeyShareExternal: mr.from(p),
      });
    } catch (_) {
      let x;
      return (
        _ instanceof Ll ? (x = _.reason) : (x = 'unknown'),
        { type: 'error-decrypt-accounts', reason: x }
      );
    }
    if (w.length === 0) return { type: 'error-no-entropies' };
    const A = await mT(e, { entropy: w[0], pin: n });
    return t.emitRotationResult(A), { type: 'success', entropy: w[0] };
  };
class $we extends PM {
  emitRotationResult(t) {
    this.emitEvent(ys.RotationResult, { type: t.type, didRotate: t.didBackup });
  }
  emitRecoverResult(t) {
    const n = t.type;
    let r;
    'reason' in t && (typeof t.reason == 'string' ? (r = t.reason) : (r = al[t.reason])),
      this.emitEvent(ys.RecoverResult, { type: n, reason: r });
  }
  emitBackupResult(t) {
    this.emitEvent(ys.BackupResult, { type: t.type, didBackup: t.didBackup });
  }
}
const V7 = (e) => {
    const t = new $we(),
      n = new b8(),
      r = {
        backup: (o, a) => n.runExclusive(async () => await zwe(e, o, a, t)),
        recover: (o) => n.runExclusive(async () => await W7(e, o, !1, t)),
        verifyPin: (o) => n.runExclusive(async () => await Kwe(e, o, !0, t)),
        resetBundleFromDevice: (o, a) => n.runExclusive(async () => await Fwe(e, o, a)),
      },
      i = new b8();
    return {
      ...r,
      hasSeedlessBundle: (o) => Wwe(e, o),
      deleteBundle: () => H7(e),
      needsBundleUpdate: () => Vwe(e),
      timeLeftCooldown: () => Hwe(e),
      getPinVerificationTimer: ({ pinVerificationExpiryInMs: o }) =>
        Gwe({ ...e, pinVerificationExpiryInMs: o }),
      setPinVerificationTimer: (o) => qwe(e, o),
      ...{ getDeviceEncryptionKey: () => i.runExclusive(async () => await Ywe(e)) },
      generateDeviceEncryptionKey: q7,
      setDeviceEncryptionKey: (o) => Z7(e, o),
      deleteDeviceEncryptionKey: () => Zwe(e),
      getOrCreateSeedlessDeviceID: () => Y7(e),
      subscribe: (o, a) => t.subscribe(o, a),
    };
  },
  UE = {},
  Fwe = async (e, t, n) => {
    if (!k1(t)) throw new Error('Invalid PIN provided. Only numbers are accepted.');
    await H7(e);
    const r = await mT(e, { pin: t, entropy: n[0] });
    if (r.type !== 'success' && r.type !== 'bundle-already-exists')
      throw new Error(`Failed to backup bundle: ${r.type}`);
    return { entropy: n[0] };
  },
  zwe = async (e, t, n, r) => {
    const i = await mT(e, { pin: n, entropy: t });
    if ((r.emitBackupResult(i), i.type !== 'success')) throw new Qme(i);
  },
  W7 = async (e, t, n = !1, r) => {
    const i = await Uwe(e, r, { pin: t, ignoreCooldown: n });
    if ((r.emitRecoverResult(i), i.type !== 'success')) throw new E7(i);
    return { entropy: i.entropy };
  },
  Kwe = async (e, t, n = !0, r) => {
    await W7(e, t, n, r);
  },
  Vwe = async ({ authRepository: e }) => {
    const t = await e.getUser();
    if (!t) throw new Error('User is not logged in, cannot check for seedless bundle update');
    const { accessToken: n } = t;
    let r;
    const i = Mp(rb());
    try {
      r = await x7('latest', n);
    } catch (o) {
      if (o instanceof Error && o.message === 'bundle not found') return !1;
      throw o;
    }
    return !!z7()[r.id] && r.id !== i;
  },
  Wwe = async (e, t = 'latest') => {
    const n = await e.authRepository.getUser();
    if (!n) throw new Error('User is not logged in, cannot check for se*dless bundle');
    const { accessToken: r } = n;
    return await k7(t, r);
  },
  H7 = async ({ authRepository: e }) => {
    const t = await e.getUser();
    if (!t) throw new Error('User is not logged in, cannot delete se*dless bundle');
    const { accessToken: n } = t,
      r = Mp(rb());
    return await C7(r, n);
  },
  Hwe = async ({ storage: e }) => {
    const { timeRemaining: t } = await LE(e);
    return t;
  },
  Gwe = async ({ storage: e, pinVerificationExpiryInMs: t }) => {
    const n = Date.now(),
      r = (await e.get(et.SeedlessPinVerificationLockTimerInMs)) ?? Date.now();
    return { expired: n >= r + (t ?? Eme), timestampInMs: r };
  },
  qwe = async ({ storage: e }, t) => {
    await e.set(et.SeedlessPinVerificationLockTimerInMs, t);
  },
  vT = async (e) => {
    const t = await e.get(et.SeedlessDeviceID);
    return (t == null ? void 0 : t.deviceID) ?? null;
  },
  G7 = async (e, t) => {
    await e.set(et.SeedlessDeviceID, { version: 1, deviceID: t });
  },
  q7 = () => {
    const e = w7(Ime);
    try {
      return Promise.resolve(mr.from(e));
    } finally {
      e.fill(0);
    }
  },
  Y7 = async ({ storage: e }) => {
    let t = await vT(e);
    return t || ((t = T7()), await G7(e, t)), t;
  },
  Ywe = async (e) => {
    const { authRepository: t } = e,
      n = await t.getUser();
    if (!n) throw new Error('User not logged in, cannot retrieve device encryption key.');
    const r = await Y7(e),
      i = UE[r];
    if (i) return i;
    let s = await P7(n.accessToken, r);
    return s || ((s = await q7()), await Z7(e, s)), (UE[r] = s), s;
  },
  Z7 = async ({ authRepository: e, storage: t }, n) => {
    const r = await e.getUser();
    if (!r) throw new Error('User not logged in, cannot set device encryption key.');
    let i = await vT(t);
    return i || ((i = T7()), await G7(t, i)), await d1e(r.accessToken, i, n), (UE[i] = n), n;
  },
  Zwe = async ({ authRepository: e, storage: t }) => {
    const n = await e.getUser();
    if (!n) throw new Error('User not logged in, cannot delete device encryption key.');
    const r = await vT(t);
    if (!r) return null;
    const i = await P7(n.accessToken, r);
    return i ? (await f1e(n.accessToken, r), i) : null;
  },
  J7 = '/assets/juicebox-sdk_bg-Cyi4tcPi.wasm',
  Jwe = Object.freeze(
    Object.defineProperty({ __proto__: null, default: J7 }, Symbol.toStringTag, { value: 'Module' })
  );
let Ye;
function X7(e) {
  Ye = e;
}
const Zs = new Array(128).fill(void 0);
Zs.push(void 0, null, !0, !1);
function ve(e) {
  return Zs[e];
}
let Wl = Zs.length;
function Xwe(e) {
  e < 132 || ((Zs[e] = Wl), (Wl = e));
}
function Za(e) {
  const t = ve(e);
  return Xwe(e), t;
}
let Wr = 0,
  Eg = null;
function Hl() {
  return (Eg === null || Eg.byteLength === 0) && (Eg = new Uint8Array(Ye.memory.buffer)), Eg;
}
const Qwe = typeof TextEncoder > 'u' ? _b('util').TextEncoder : TextEncoder;
let fy = new Qwe('utf-8');
const eve =
  typeof fy.encodeInto == 'function'
    ? function (e, t) {
        return fy.encodeInto(e, t);
      }
    : function (e, t) {
        const n = fy.encode(e);
        return t.set(n), { read: e.length, written: n.length };
      };
function ud(e, t, n) {
  if (n === void 0) {
    const a = fy.encode(e),
      c = t(a.length, 1) >>> 0;
    return (
      Hl()
        .subarray(c, c + a.length)
        .set(a),
      (Wr = a.length),
      c
    );
  }
  let r = e.length,
    i = t(r, 1) >>> 0;
  const s = Hl();
  let o = 0;
  for (; o < r; o++) {
    const a = e.charCodeAt(o);
    if (a > 127) break;
    s[i + o] = a;
  }
  if (o !== r) {
    o !== 0 && (e = e.slice(o)), (i = n(i, r, (r = o + e.length * 3), 1) >>> 0);
    const a = Hl().subarray(i + o, i + r),
      c = eve(e, a);
    o += c.written;
  }
  return (Wr = o), i;
}
function ib(e) {
  return e == null;
}
let Ag = null;
function Ui() {
  return (Ag === null || Ag.byteLength === 0) && (Ag = new Int32Array(Ye.memory.buffer)), Ag;
}
const tve = typeof TextDecoder > 'u' ? _b('util').TextDecoder : TextDecoder;
let Q7 = new tve('utf-8', { ignoreBOM: !0, fatal: !0 });
Q7.decode();
function Ss(e, t) {
  return (e = e >>> 0), Q7.decode(Hl().subarray(e, e + t));
}
function $e(e) {
  Wl === Zs.length && Zs.push(Zs.length + 1);
  const t = Wl;
  return (Wl = Zs[t]), (Zs[t] = e), t;
}
let Ig = null;
function nve() {
  return (Ig === null || Ig.byteLength === 0) && (Ig = new Float64Array(Ye.memory.buffer)), Ig;
}
function $E(e) {
  const t = typeof e;
  if (t == 'number' || t == 'boolean' || e == null) return `${e}`;
  if (t == 'string') return `"${e}"`;
  if (t == 'symbol') {
    const i = e.description;
    return i == null ? 'Symbol' : `Symbol(${i})`;
  }
  if (t == 'function') {
    const i = e.name;
    return typeof i == 'string' && i.length > 0 ? `Function(${i})` : 'Function';
  }
  if (Array.isArray(e)) {
    const i = e.length;
    let s = '[';
    i > 0 && (s += $E(e[0]));
    for (let o = 1; o < i; o++) s += ', ' + $E(e[o]);
    return (s += ']'), s;
  }
  const n = /\[object ([^\]]+)\]/.exec(toString.call(e));
  let r;
  if (n.length > 1) r = n[1];
  else return toString.call(e);
  if (r == 'Object')
    try {
      return 'Object(' + JSON.stringify(e) + ')';
    } catch {
      return 'Object';
    }
  return e instanceof Error
    ? `${e.name}: ${e.message}
${e.stack}`
    : r;
}
function eN(e, t, n, r) {
  const i = { a: e, b: t, cnt: 1, dtor: n },
    s = (...o) => {
      i.cnt++;
      const a = i.a;
      i.a = 0;
      try {
        return r(a, i.b, ...o);
      } finally {
        --i.cnt === 0 ? Ye.__wbindgen_export_2.get(i.dtor)(a, i.b) : (i.a = a);
      }
    };
  return (s.original = i), s;
}
function rve(e, t) {
  Ye.wasm_bindgen__convert__closures__invoke0_mut__haa5973ef449a5fac(e, t);
}
function ive(e, t, n) {
  Ye._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h664375554e075ae3(
    e,
    t,
    $e(n)
  );
}
function sve(e, t) {
  if (!(e instanceof t)) throw new Error(`expected instance of ${t.name}`);
  return e.ptr;
}
function Al(e, t) {
  const n = t(e.length * 1, 1) >>> 0;
  return Hl().set(e, n / 1), (Wr = e.length), n;
}
function Vn(e, t) {
  try {
    return e.apply(this, t);
  } catch (n) {
    Ye.__wbindgen_exn_store($e(n));
  }
}
function ove(e, t, n, r) {
  Ye.wasm_bindgen__convert__closures__invoke2_mut__h35a3737c9c8313d7(e, t, $e(n), $e(r));
}
const ave = Object.freeze({
    InvalidAuth: 0,
    0: 'InvalidAuth',
    UpgradeRequired: 1,
    1: 'UpgradeRequired',
    Assertion: 2,
    2: 'Assertion',
    Transient: 3,
    3: 'Transient',
  }),
  cve = Object.freeze({
    InvalidAuth: 0,
    0: 'InvalidAuth',
    UpgradeRequired: 1,
    1: 'UpgradeRequired',
    Assertion: 2,
    2: 'Assertion',
    Transient: 3,
    3: 'Transient',
  }),
  uve = Object.freeze({
    InvalidPin: 0,
    0: 'InvalidPin',
    NotRegistered: 1,
    1: 'NotRegistered',
    InvalidAuth: 2,
    2: 'InvalidAuth',
    UpgradeRequired: 3,
    3: 'UpgradeRequired',
    Assertion: 4,
    4: 'Assertion',
    Transient: 5,
    5: 'Transient',
  });
class lve {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return (this.__wbg_ptr = 0), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    Ye.__wbg_authtokengenerator_free(t);
  }
  constructor(t) {
    const n = Ye.authtokengenerator_new($e(t));
    return (this.__wbg_ptr = n >>> 0), this;
  }
  vend(t, n) {
    let r, i;
    try {
      const a = Ye.__wbindgen_add_to_stack_pointer(-16),
        c = ud(t, Ye.__wbindgen_malloc, Ye.__wbindgen_realloc),
        u = Wr,
        l = ud(n, Ye.__wbindgen_malloc, Ye.__wbindgen_realloc),
        d = Wr;
      Ye.authtokengenerator_vend(a, this.__wbg_ptr, c, u, l, d);
      var s = Ui()[a / 4 + 0],
        o = Ui()[a / 4 + 1];
      return (r = s), (i = o), Ss(s, o);
    } finally {
      Ye.__wbindgen_add_to_stack_pointer(16), Ye.__wbindgen_free(r, i, 1);
    }
  }
  static random_secret_id() {
    let t, n;
    try {
      const s = Ye.__wbindgen_add_to_stack_pointer(-16);
      Ye.authtokengenerator_random_secret_id(s);
      var r = Ui()[s / 4 + 0],
        i = Ui()[s / 4 + 1];
      return (t = r), (n = i), Ss(r, i);
    } finally {
      Ye.__wbindgen_add_to_stack_pointer(16), Ye.__wbindgen_free(t, n, 1);
    }
  }
}
class tN {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return (this.__wbg_ptr = 0), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    Ye.__wbg_client_free(t);
  }
  constructor(t, n) {
    sve(t, _T);
    var r = t.__destroy_into_raw();
    const i = Ye.client_new(r, $e(n));
    return (this.__wbg_ptr = i >>> 0), this;
  }
  register(t, n, r, i) {
    const s = Al(t, Ye.__wbindgen_malloc),
      o = Wr,
      a = Al(n, Ye.__wbindgen_malloc),
      c = Wr,
      u = Al(r, Ye.__wbindgen_malloc),
      l = Wr,
      d = Ye.client_register(this.__wbg_ptr, s, o, a, c, u, l, i);
    return Za(d);
  }
  recover(t, n) {
    const r = Al(t, Ye.__wbindgen_malloc),
      i = Wr,
      s = Al(n, Ye.__wbindgen_malloc),
      o = Wr,
      a = Ye.client_recover(this.__wbg_ptr, r, i, s, o);
    return Za(a);
  }
  delete() {
    const t = Ye.client_delete(this.__wbg_ptr);
    return Za(t);
  }
}
class _T {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return (this.__wbg_ptr = 0), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    Ye.__wbg_configuration_free(t);
  }
  constructor(t) {
    const n = Ye.configuration_new($e(t));
    return (this.__wbg_ptr = n >>> 0), this;
  }
}
class C1 {
  static __wrap(t) {
    t = t >>> 0;
    const n = Object.create(C1.prototype);
    return (n.__wbg_ptr = t), n;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return (this.__wbg_ptr = 0), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    Ye.__wbg_recovererror_free(t);
  }
  get reason() {
    return Ye.__wbg_get_recovererror_reason(this.__wbg_ptr);
  }
  set reason(t) {
    Ye.__wbg_set_recovererror_reason(this.__wbg_ptr, t);
  }
  get guesses_remaining() {
    const t = Ye.__wbg_get_recovererror_guesses_remaining(this.__wbg_ptr);
    return t === 16777215 ? void 0 : t;
  }
  set guesses_remaining(t) {
    Ye.__wbg_set_recovererror_guesses_remaining(this.__wbg_ptr, ib(t) ? 16777215 : t);
  }
}
function dve(e) {
  Za(e);
}
function fve(e) {
  const t = C1.__wrap(e);
  return $e(t);
}
function hve(e) {
  const t = Za(e).original;
  return t.cnt-- == 1 ? ((t.a = 0), !0) : !1;
}
function pve(e, t) {
  const n = ve(t),
    r = typeof n == 'string' ? n : void 0;
  var i = ib(r) ? 0 : ud(r, Ye.__wbindgen_malloc, Ye.__wbindgen_realloc),
    s = Wr;
  (Ui()[e / 4 + 1] = s), (Ui()[e / 4 + 0] = i);
}
function gve(e) {
  const t = fetch(ve(e));
  return $e(t);
}
function yve() {
  return Vn(function (e, t) {
    const n = setTimeout(ve(e), t);
    return $e(n);
  }, arguments);
}
function bve() {
  return Vn(function (e) {
    const t = JuiceboxGetAuthToken(Za(e));
    return $e(t);
  }, arguments);
}
function mve(e) {
  return typeof ve(e) == 'string';
}
function wve(e) {
  const t = ve(e);
  return typeof t == 'object' && t !== null;
}
function vve(e) {
  return ve(e) === void 0;
}
function _ve(e, t) {
  return ve(e) in ve(t);
}
function Sve(e, t) {
  const n = new Error(Ss(e, t));
  return $e(n);
}
function Eve() {
  const e = new Error();
  return $e(e);
}
function Ave(e, t) {
  const n = ve(t).stack,
    r = ud(n, Ye.__wbindgen_malloc, Ye.__wbindgen_realloc),
    i = Wr;
  (Ui()[e / 4 + 1] = i), (Ui()[e / 4 + 0] = r);
}
function Ive(e, t) {
  let n, r;
  try {
    (n = e), (r = t), console.error(Ss(e, t));
  } finally {
    Ye.__wbindgen_free(n, r, 1);
  }
}
function Tve(e) {
  queueMicrotask(ve(e));
}
function xve(e) {
  const t = ve(e).queueMicrotask;
  return $e(t);
}
function kve(e) {
  return typeof ve(e) == 'function';
}
function Cve(e) {
  const t = ve(e);
  return $e(t);
}
function Pve(e, t) {
  return ve(e) == ve(t);
}
function Mve(e) {
  const t = ve(e);
  return typeof t == 'boolean' ? (t ? 1 : 0) : 2;
}
function Ove(e, t) {
  const n = ve(t),
    r = typeof n == 'number' ? n : void 0;
  (nve()[e / 8 + 1] = ib(r) ? 0 : r), (Ui()[e / 4 + 0] = !ib(r));
}
function Bve(e) {
  return +ve(e);
}
function Dve(e) {
  return $e(e);
}
function Rve(e, t) {
  const n = Ss(e, t);
  return $e(n);
}
function Nve(e, t) {
  const n = ve(e)[ve(t)];
  return $e(n);
}
function jve() {
  return Date.now();
}
function Lve(e) {
  return ve(e).now();
}
function Uve(e) {
  const t = ve(e).headers;
  return $e(t);
}
function $ve() {
  return Vn(function (e, t, n) {
    const r = new Request(Ss(e, t), ve(n));
    return $e(r);
  }, arguments);
}
function Fve() {
  return Vn(function (e, t, n, r, i) {
    ve(e).set(Ss(t, n), Ss(r, i));
  }, arguments);
}
function zve(e) {
  const t = ve(e).arrayBuffer();
  return $e(t);
}
function Kve(e) {
  let t;
  try {
    t = ve(e) instanceof Response;
  } catch {
    t = !1;
  }
  return t;
}
function Vve(e) {
  return ve(e).status;
}
function Wve(e) {
  const t = ve(e).headers;
  return $e(t);
}
function Hve() {
  return Vn(function (e) {
    const t = ve(e).blob();
    return $e(t);
  }, arguments);
}
function Gve(e) {
  const t = ve(e).crypto;
  return $e(t);
}
function qve(e) {
  const t = ve(e).process;
  return $e(t);
}
function Yve(e) {
  const t = ve(e).versions;
  return $e(t);
}
function Zve(e) {
  const t = ve(e).node;
  return $e(t);
}
function Jve(e) {
  const t = ve(e).msCrypto;
  return $e(t);
}
function Xve() {
  return Vn(function () {
    return $e(_b);
  }, arguments);
}
function Qve() {
  return Vn(function (e, t) {
    ve(e).randomFillSync(Za(t));
  }, arguments);
}
function e_e() {
  return Vn(function (e, t) {
    ve(e).getRandomValues(ve(t));
  }, arguments);
}
function t_e(e, t) {
  const n = ve(e)[t >>> 0];
  return $e(n);
}
function n_e(e) {
  return ve(e).length;
}
function r_e(e, t) {
  const n = new Function(Ss(e, t));
  return $e(n);
}
function i_e(e) {
  const t = ve(e).next;
  return $e(t);
}
function s_e() {
  return Vn(function (e) {
    const t = ve(e).next();
    return $e(t);
  }, arguments);
}
function o_e(e) {
  return ve(e).done;
}
function a_e(e) {
  const t = ve(e).value;
  return $e(t);
}
function c_e() {
  return $e(Symbol.iterator);
}
function u_e() {
  return Vn(function (e, t) {
    const n = Reflect.get(ve(e), ve(t));
    return $e(n);
  }, arguments);
}
function l_e() {
  return Vn(function (e, t) {
    const n = ve(e).call(ve(t));
    return $e(n);
  }, arguments);
}
function d_e() {
  const e = new Object();
  return $e(e);
}
function f_e() {
  return Vn(function () {
    const e = globalThis.self;
    return $e(e);
  }, arguments);
}
function h_e() {
  return Vn(function () {
    const e = window.window;
    return $e(e);
  }, arguments);
}
function p_e() {
  return Vn(function () {
    const e = globalThis.globalThis;
    return $e(e);
  }, arguments);
}
function g_e() {
  return Vn(function () {
    const e = globalThis.global;
    return $e(e);
  }, arguments);
}
function y_e(e) {
  const t = Array.from(ve(e));
  return $e(t);
}
function b_e(e) {
  return Array.isArray(ve(e));
}
function m_e(e) {
  let t;
  try {
    t = ve(e) instanceof ArrayBuffer;
  } catch {
    t = !1;
  }
  return t;
}
function w_e() {
  return Vn(function (e, t, n) {
    const r = ve(e).call(ve(t), ve(n));
    return $e(r);
  }, arguments);
}
function v_e(e) {
  return Number.isSafeInteger(ve(e));
}
function __e(e) {
  const t = Object.entries(ve(e));
  return $e(t);
}
function S_e(e, t) {
  try {
    var n = { a: e, b: t },
      r = (s, o) => {
        const a = n.a;
        n.a = 0;
        try {
          return ove(a, n.b, s, o);
        } finally {
          n.a = a;
        }
      };
    const i = new Promise(r);
    return $e(i);
  } finally {
    n.a = n.b = 0;
  }
}
function E_e(e) {
  const t = Promise.resolve(ve(e));
  return $e(t);
}
function A_e(e, t) {
  const n = ve(e).then(ve(t));
  return $e(n);
}
function I_e(e, t, n) {
  const r = ve(e).then(ve(t), ve(n));
  return $e(r);
}
function T_e(e) {
  const t = ve(e).buffer;
  return $e(t);
}
function x_e(e, t, n) {
  const r = new Uint8Array(ve(e), t >>> 0, n >>> 0);
  return $e(r);
}
function k_e(e) {
  const t = new Uint8Array(ve(e));
  return $e(t);
}
function C_e(e, t, n) {
  ve(e).set(ve(t), n >>> 0);
}
function P_e(e) {
  return ve(e).length;
}
function M_e(e) {
  let t;
  try {
    t = ve(e) instanceof Uint8Array;
  } catch {
    t = !1;
  }
  return t;
}
function O_e(e) {
  const t = new Uint8Array(e >>> 0);
  return $e(t);
}
function B_e(e, t, n) {
  const r = ve(e).subarray(t >>> 0, n >>> 0);
  return $e(r);
}
function D_e() {
  return Vn(function (e) {
    const t = JSON.stringify(ve(e));
    return $e(t);
  }, arguments);
}
function R_e() {
  return Vn(function (e, t, n) {
    return Reflect.set(ve(e), ve(t), ve(n));
  }, arguments);
}
function N_e(e, t) {
  const n = $E(ve(t)),
    r = ud(n, Ye.__wbindgen_malloc, Ye.__wbindgen_realloc),
    i = Wr;
  (Ui()[e / 4 + 1] = i), (Ui()[e / 4 + 0] = r);
}
function j_e(e, t) {
  throw new Error(Ss(e, t));
}
function L_e() {
  const e = Ye.memory;
  return $e(e);
}
function U_e(e, t, n) {
  const r = eN(e, t, 196, rve);
  return $e(r);
}
function $_e(e, t, n) {
  const r = eN(e, t, 219, ive);
  return $e(r);
}
const F_e = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      AuthTokenGenerator: lve,
      Client: tN,
      Configuration: _T,
      DeleteError: ave,
      RecoverError: C1,
      RecoverErrorReason: uve,
      RegisterError: cve,
      __wbg_JuiceboxGetAuthToken_06fb1d3c42d3a182: bve,
      __wbg_arrayBuffer_a9d862b05aaee2f9: zve,
      __wbg_blob_c6537f3e31e66dad: Hve,
      __wbg_buffer_a448f833075b71ba: T_e,
      __wbg_call_5da1969d7cd31ccd: w_e,
      __wbg_call_90c26b09837aba1c: l_e,
      __wbg_crypto_58f13aa23ffcb166: Gve,
      __wbg_done_5fe336b092d60cf2: o_e,
      __wbg_entries_9e2e2aa45aa5094a: __e,
      __wbg_error_f851667af71bcfc6: Ive,
      __wbg_fetch_0c82eef617317d0a: gve,
      __wbg_from_71add2e723d1f1b2: y_e,
      __wbg_getRandomValues_504510b5564925af: e_e,
      __wbg_get_7b48513de5dc5ea4: u_e,
      __wbg_get_f01601b5a68d10e3: t_e,
      __wbg_getwithrefkey_4a92a5eca60879b9: Nve,
      __wbg_globalThis_9caa27ff917c6860: p_e,
      __wbg_global_35dfdd59a4da3e74: g_e,
      __wbg_headers_24def508a7518df9: Wve,
      __wbg_headers_d135d2bb8cc60413: Uve,
      __wbg_instanceof_ArrayBuffer_e7d53d51371448e2: m_e,
      __wbg_instanceof_Response_4c3b1446206114d1: Kve,
      __wbg_instanceof_Uint8Array_bced6f43aed8c1aa: M_e,
      __wbg_isArray_74fb723e24f76012: b_e,
      __wbg_isSafeInteger_f93fde0dca9820f8: v_e,
      __wbg_iterator_db7ca081358d4fb2: c_e,
      __wbg_length_1009b1af0c481d7b: n_e,
      __wbg_length_1d25fa9e4ac21ce7: P_e,
      __wbg_msCrypto_abcb1295e768d1f2: Jve,
      __wbg_new_60f57089c7563e81: S_e,
      __wbg_new_8f67e318f15d7254: k_e,
      __wbg_new_9fb8d994e1c0aaac: d_e,
      __wbg_new_abda76e883ba8a5f: Eve,
      __wbg_newnoargs_c62ea9419c21fbac: r_e,
      __wbg_newwithbyteoffsetandlength_d0482f893617af71: x_e,
      __wbg_newwithlength_6c2df9e2f3028c43: O_e,
      __wbg_newwithstrandinit_f581dff0d19a8b03: $ve,
      __wbg_next_6529ee0cca8d57ed: s_e,
      __wbg_next_9b877f231f476d01: i_e,
      __wbg_node_523d7bd03ef69fba: Zve,
      __wbg_now_0343d9c3e0e8eedc: jve,
      __wbg_now_b724952e890dc703: Lve,
      __wbg_process_5b786e71d465a513: qve,
      __wbg_queueMicrotask_4d890031a6a5a50c: Tve,
      __wbg_queueMicrotask_adae4bc085237231: xve,
      __wbg_randomFillSync_a0d98aa11c81fe89: Qve,
      __wbg_recovererror_new: fve,
      __wbg_require_2784e593a4674877: Xve,
      __wbg_resolve_6e1c6553a82f85b7: E_e,
      __wbg_self_f0e34d89f33b99fd: f_e,
      __wbg_setTimeout_7864ca813139bafe: yve,
      __wbg_set_2357bf09366ee480: C_e,
      __wbg_set_27f236f6d7a28c29: Fve,
      __wbg_set_759f75cd92b612d2: R_e,
      __wbg_set_wasm: X7,
      __wbg_stack_658279fe44541cf6: Ave,
      __wbg_status_d6d47ad2837621eb: Vve,
      __wbg_stringify_e1b19966d964d242: D_e,
      __wbg_subarray_2e940e41c0f5a1d9: B_e,
      __wbg_then_3ab08cd4fbb91ae9: A_e,
      __wbg_then_8371cc12cfedc5a2: I_e,
      __wbg_value_0c248a78fdc8e19f: a_e,
      __wbg_versions_c2ab80650590b6a2: Yve,
      __wbg_window_d3b084224f4774d7: h_e,
      __wbindgen_as_number: Bve,
      __wbindgen_boolean_get: Mve,
      __wbindgen_cb_drop: hve,
      __wbindgen_closure_wrapper853: U_e,
      __wbindgen_closure_wrapper903: $_e,
      __wbindgen_debug_string: N_e,
      __wbindgen_error_new: Sve,
      __wbindgen_in: _ve,
      __wbindgen_is_function: kve,
      __wbindgen_is_object: wve,
      __wbindgen_is_string: mve,
      __wbindgen_is_undefined: vve,
      __wbindgen_jsval_loose_eq: Pve,
      __wbindgen_memory: L_e,
      __wbindgen_number_get: Ove,
      __wbindgen_number_new: Dve,
      __wbindgen_object_clone_ref: Cve,
      __wbindgen_object_drop_ref: dve,
      __wbindgen_string_get: pve,
      __wbindgen_string_new: Rve,
      __wbindgen_throw: j_e,
    },
    Symbol.toStringTag,
    { value: 'Module' }
  )
);
X7(Jwe);
let I8 = !1;
const z_e = async () => {
  if (I8) return;
  const e = await mA(() => Promise.resolve().then(() => F_e), void 0),
    t = await WebAssembly.instantiateStreaming(fetch(J7), { './juicebox-sdk_bg.js': e });
  e.__wbg_set_wasm(t.instance.exports), (I8 = !0);
};
function nN(e) {
  globalThis.JuiceboxTokens = e;
}
nN({});
class rN {
  setJuiceboxTokens(t) {
    nN(t);
  }
  async backupShare(t, n, r, i, s) {
    await (await this.client(t)).register(r, n, i, s);
  }
  async recoverShare(t, n, r) {
    return await (await this.client(t)).recover(n, r);
  }
  async deleteShare(t) {
    await (await this.client(t)).delete();
  }
  async client(t) {
    return await z_e(), new tN(new _T(t), []);
  }
}
const T8 = g
  .string()
  .regex(/^[0-9A-Fa-f]*$/, { message: 'String must have only valid hex characters' });
g.object({ publicKey: T8, chainCode: T8 });
g.object({ name: g.string(), id: g.string().min(1), rssi: g.number().int() });
g.union([g.literal('low'), g.literal('medium'), g.literal('high')]);
var K_e = {},
  P1 = {},
  Ru = {},
  iN = {},
  cr = {};
Object.defineProperty(cr, '__esModule', { value: !0 });
cr.output = cr.exists = cr.hash = cr.bytes = cr.bool = cr.number = void 0;
function sb(e) {
  if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`);
}
cr.number = sb;
function sN(e) {
  if (typeof e != 'boolean') throw new Error(`Expected boolean, not ${e}`);
}
cr.bool = sN;
function ST(e, ...t) {
  if (!(e instanceof Uint8Array)) throw new TypeError('Expected Uint8Array');
  if (t.length > 0 && !t.includes(e.length))
    throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
cr.bytes = ST;
function oN(e) {
  if (typeof e != 'function' || typeof e.create != 'function')
    throw new Error('Hash should be wrapped by utils.wrapConstructor');
  sb(e.outputLen), sb(e.blockLen);
}
cr.hash = oN;
function aN(e, t = !0) {
  if (e.destroyed) throw new Error('Hash instance has been destroyed');
  if (t && e.finished) throw new Error('Hash#digest() has already been called');
}
cr.exists = aN;
function cN(e, t) {
  ST(e);
  const n = t.outputLen;
  if (e.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`);
}
cr.output = cN;
const V_e = { number: sb, bool: sN, bytes: ST, hash: oN, exists: aN, output: cN };
cr.default = V_e;
var cl = {},
  M1 = {};
Object.defineProperty(M1, '__esModule', { value: !0 });
M1.crypto = void 0;
M1.crypto = {
  node: void 0,
  web: typeof globalThis == 'object' && 'crypto' in globalThis ? globalThis.crypto : void 0,
};
(function (e) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(
    e,
    '__esModule',
    { value: !0 }
  ),
    (e.randomBytes =
      e.wrapConstructorWithOpts =
      e.wrapConstructor =
      e.checkOpts =
      e.Hash =
      e.concatBytes =
      e.toBytes =
      e.utf8ToBytes =
      e.asyncLoop =
      e.nextTick =
      e.hexToBytes =
      e.bytesToHex =
      e.isLE =
      e.rotr =
      e.createView =
      e.u32 =
      e.u8 =
        void 0);
  const t = M1,
    n = (k) => new Uint8Array(k.buffer, k.byteOffset, k.byteLength);
  e.u8 = n;
  const r = (k) => new Uint32Array(k.buffer, k.byteOffset, Math.floor(k.byteLength / 4));
  e.u32 = r;
  const i = (k) => new DataView(k.buffer, k.byteOffset, k.byteLength);
  e.createView = i;
  const s = (k, j) => (k << (32 - j)) | (k >>> j);
  if (
    ((e.rotr = s),
    (e.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68),
    !e.isLE)
  )
    throw new Error('Non little-endian hardware is not supported');
  const o = Array.from({ length: 256 }, (k, j) => j.toString(16).padStart(2, '0'));
  function a(k) {
    if (!(k instanceof Uint8Array)) throw new Error('Uint8Array expected');
    let j = '';
    for (let F = 0; F < k.length; F++) j += o[k[F]];
    return j;
  }
  e.bytesToHex = a;
  function c(k) {
    if (typeof k != 'string') throw new TypeError('hexToBytes: expected string, got ' + typeof k);
    if (k.length % 2) throw new Error('hexToBytes: received invalid unpadded hex');
    const j = new Uint8Array(k.length / 2);
    for (let F = 0; F < j.length; F++) {
      const K = F * 2,
        D = k.slice(K, K + 2),
        C = Number.parseInt(D, 16);
      if (Number.isNaN(C) || C < 0) throw new Error('Invalid byte sequence');
      j[F] = C;
    }
    return j;
  }
  e.hexToBytes = c;
  const u = async () => {};
  e.nextTick = u;
  async function l(k, j, F) {
    let K = Date.now();
    for (let D = 0; D < k; D++) {
      F(D);
      const C = Date.now() - K;
      (C >= 0 && C < j) || (await (0, e.nextTick)(), (K += C));
    }
  }
  e.asyncLoop = l;
  function d(k) {
    if (typeof k != 'string') throw new TypeError(`utf8ToBytes expected string, got ${typeof k}`);
    return new TextEncoder().encode(k);
  }
  e.utf8ToBytes = d;
  function f(k) {
    if ((typeof k == 'string' && (k = d(k)), !(k instanceof Uint8Array)))
      throw new TypeError(`Expected input type is Uint8Array (got ${typeof k})`);
    return k;
  }
  e.toBytes = f;
  function h(...k) {
    if (!k.every((K) => K instanceof Uint8Array)) throw new Error('Uint8Array list expected');
    if (k.length === 1) return k[0];
    const j = k.reduce((K, D) => K + D.length, 0),
      F = new Uint8Array(j);
    for (let K = 0, D = 0; K < k.length; K++) {
      const C = k[K];
      F.set(C, D), (D += C.length);
    }
    return F;
  }
  e.concatBytes = h;
  class p {
    clone() {
      return this._cloneInto();
    }
  }
  e.Hash = p;
  const b = (k) =>
    Object.prototype.toString.call(k) === '[object Object]' && k.constructor === Object;
  function w(k, j) {
    if (j !== void 0 && (typeof j != 'object' || !b(j)))
      throw new TypeError('Options should be object or undefined');
    return Object.assign(k, j);
  }
  e.checkOpts = w;
  function A(k) {
    const j = (K) => k().update(f(K)).digest(),
      F = k();
    return (j.outputLen = F.outputLen), (j.blockLen = F.blockLen), (j.create = () => k()), j;
  }
  e.wrapConstructor = A;
  function _(k) {
    const j = (K, D) => k(D).update(f(K)).digest(),
      F = k({});
    return (j.outputLen = F.outputLen), (j.blockLen = F.blockLen), (j.create = (K) => k(K)), j;
  }
  e.wrapConstructorWithOpts = _;
  function x(k = 32) {
    if (t.crypto.web) return t.crypto.web.getRandomValues(new Uint8Array(k));
    if (t.crypto.node) return new Uint8Array(t.crypto.node.randomBytes(k).buffer);
    throw new Error("The environment doesn't have randomBytes function");
  }
  e.randomBytes = x;
})(cl);
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }), (e.hmac = void 0);
  const t = cr,
    n = cl;
  class r extends n.Hash {
    constructor(o, a) {
      super(), (this.finished = !1), (this.destroyed = !1), t.default.hash(o);
      const c = (0, n.toBytes)(a);
      if (((this.iHash = o.create()), typeof this.iHash.update != 'function'))
        throw new TypeError('Expected instance of class which extends utils.Hash');
      (this.blockLen = this.iHash.blockLen), (this.outputLen = this.iHash.outputLen);
      const u = this.blockLen,
        l = new Uint8Array(u);
      l.set(c.length > u ? o.create().update(c).digest() : c);
      for (let d = 0; d < l.length; d++) l[d] ^= 54;
      this.iHash.update(l), (this.oHash = o.create());
      for (let d = 0; d < l.length; d++) l[d] ^= 106;
      this.oHash.update(l), l.fill(0);
    }
    update(o) {
      return t.default.exists(this), this.iHash.update(o), this;
    }
    digestInto(o) {
      t.default.exists(this),
        t.default.bytes(o, this.outputLen),
        (this.finished = !0),
        this.iHash.digestInto(o),
        this.oHash.update(o),
        this.oHash.digestInto(o),
        this.destroy();
    }
    digest() {
      const o = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(o), o;
    }
    _cloneInto(o) {
      o || (o = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: a, iHash: c, finished: u, destroyed: l, blockLen: d, outputLen: f } = this;
      return (
        (o = o),
        (o.finished = u),
        (o.destroyed = l),
        (o.blockLen = d),
        (o.outputLen = f),
        (o.oHash = a._cloneInto(o.oHash)),
        (o.iHash = c._cloneInto(o.iHash)),
        o
      );
    }
    destroy() {
      (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
    }
  }
  const i = (s, o, a) => new r(s, o).update(a).digest();
  (e.hmac = i), (e.hmac.create = (s, o) => new r(s, o));
})(iN);
var Nu = {},
  ul = {};
Object.defineProperty(ul, '__esModule', { value: !0 });
ul.SHA2 = void 0;
const y_ = cr,
  Il = cl;
function W_e(e, t, n, r) {
  if (typeof e.setBigUint64 == 'function') return e.setBigUint64(t, n, r);
  const i = BigInt(32),
    s = BigInt(4294967295),
    o = Number((n >> i) & s),
    a = Number(n & s),
    c = r ? 4 : 0,
    u = r ? 0 : 4;
  e.setUint32(t + c, o, r), e.setUint32(t + u, a, r);
}
let H_e = class extends Il.Hash {
  constructor(t, n, r, i) {
    super(),
      (this.blockLen = t),
      (this.outputLen = n),
      (this.padOffset = r),
      (this.isLE = i),
      (this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.buffer = new Uint8Array(t)),
      (this.view = (0, Il.createView)(this.buffer));
  }
  update(t) {
    y_.default.exists(this);
    const { view: n, buffer: r, blockLen: i } = this;
    t = (0, Il.toBytes)(t);
    const s = t.length;
    for (let o = 0; o < s; ) {
      const a = Math.min(i - this.pos, s - o);
      if (a === i) {
        const c = (0, Il.createView)(t);
        for (; i <= s - o; o += i) this.process(c, o);
        continue;
      }
      r.set(t.subarray(o, o + a), this.pos),
        (this.pos += a),
        (o += a),
        this.pos === i && (this.process(n, 0), (this.pos = 0));
    }
    return (this.length += t.length), this.roundClean(), this;
  }
  digestInto(t) {
    y_.default.exists(this), y_.default.output(t, this), (this.finished = !0);
    const { buffer: n, view: r, blockLen: i, isLE: s } = this;
    let { pos: o } = this;
    (n[o++] = 128),
      this.buffer.subarray(o).fill(0),
      this.padOffset > i - o && (this.process(r, 0), (o = 0));
    for (let d = o; d < i; d++) n[d] = 0;
    W_e(r, i - 8, BigInt(this.length * 8), s), this.process(r, 0);
    const a = (0, Il.createView)(t),
      c = this.outputLen;
    if (c % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
    const u = c / 4,
      l = this.get();
    if (u > l.length) throw new Error('_sha2: outputLen bigger than state');
    for (let d = 0; d < u; d++) a.setUint32(4 * d, l[d], s);
  }
  digest() {
    const { buffer: t, outputLen: n } = this;
    this.digestInto(t);
    const r = t.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: n, buffer: r, length: i, finished: s, destroyed: o, pos: a } = this;
    return (
      (t.length = i), (t.pos = a), (t.finished = s), (t.destroyed = o), i % n && t.buffer.set(r), t
    );
  }
};
ul.SHA2 = H_e;
Object.defineProperty(Nu, '__esModule', { value: !0 });
Nu.ripemd160 = Nu.RIPEMD160 = void 0;
const G_e = ul,
  q_e = cl,
  Y_e = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]),
  uN = Uint8Array.from({ length: 16 }, (e, t) => t),
  Z_e = uN.map((e) => (9 * e + 5) % 16);
let ET = [uN],
  AT = [Z_e];
for (let e = 0; e < 4; e++) for (let t of [ET, AT]) t.push(t[e].map((n) => Y_e[n]));
const lN = [
    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],
  ].map((e) => new Uint8Array(e)),
  J_e = ET.map((e, t) => e.map((n) => lN[t][n])),
  X_e = AT.map((e, t) => e.map((n) => lN[t][n])),
  Q_e = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838]),
  eSe = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0]),
  Tg = (e, t) => (e << t) | (e >>> (32 - t));
function x8(e, t, n, r) {
  return e === 0
    ? t ^ n ^ r
    : e === 1
      ? (t & n) | (~t & r)
      : e === 2
        ? (t | ~n) ^ r
        : e === 3
          ? (t & r) | (n & ~r)
          : t ^ (n | ~r);
}
const xg = new Uint32Array(16);
class dN extends G_e.SHA2 {
  constructor() {
    super(64, 20, 8, !0),
      (this.h0 = 1732584193),
      (this.h1 = -271733879),
      (this.h2 = -1732584194),
      (this.h3 = 271733878),
      (this.h4 = -1009589776);
  }
  get() {
    const { h0: t, h1: n, h2: r, h3: i, h4: s } = this;
    return [t, n, r, i, s];
  }
  set(t, n, r, i, s) {
    (this.h0 = t | 0), (this.h1 = n | 0), (this.h2 = r | 0), (this.h3 = i | 0), (this.h4 = s | 0);
  }
  process(t, n) {
    for (let h = 0; h < 16; h++, n += 4) xg[h] = t.getUint32(n, !0);
    let r = this.h0 | 0,
      i = r,
      s = this.h1 | 0,
      o = s,
      a = this.h2 | 0,
      c = a,
      u = this.h3 | 0,
      l = u,
      d = this.h4 | 0,
      f = d;
    for (let h = 0; h < 5; h++) {
      const p = 4 - h,
        b = Q_e[h],
        w = eSe[h],
        A = ET[h],
        _ = AT[h],
        x = J_e[h],
        k = X_e[h];
      for (let j = 0; j < 16; j++) {
        const F = (Tg(r + x8(h, s, a, u) + xg[A[j]] + b, x[j]) + d) | 0;
        (r = d), (d = u), (u = Tg(a, 10) | 0), (a = s), (s = F);
      }
      for (let j = 0; j < 16; j++) {
        const F = (Tg(i + x8(p, o, c, l) + xg[_[j]] + w, k[j]) + f) | 0;
        (i = f), (f = l), (l = Tg(c, 10) | 0), (c = o), (o = F);
      }
    }
    this.set(
      (this.h1 + a + l) | 0,
      (this.h2 + u + f) | 0,
      (this.h3 + d + i) | 0,
      (this.h4 + r + o) | 0,
      (this.h0 + s + c) | 0
    );
  }
  roundClean() {
    xg.fill(0);
  }
  destroy() {
    (this.destroyed = !0), this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
}
Nu.RIPEMD160 = dN;
Nu.ripemd160 = (0, q_e.wrapConstructor)(() => new dN());
var bc = {};
Object.defineProperty(bc, '__esModule', { value: !0 });
bc.sha224 = bc.sha256 = void 0;
const tSe = ul,
  ni = cl,
  nSe = (e, t, n) => (e & t) ^ (~e & n),
  rSe = (e, t, n) => (e & t) ^ (e & n) ^ (t & n),
  iSe = new Uint32Array([
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221,
    3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580,
    3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895,
    666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037,
    2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
    1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298,
  ]),
  jo = new Uint32Array([
    1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225,
  ]),
  Lo = new Uint32Array(64);
let fN = class extends tSe.SHA2 {
    constructor() {
      super(64, 32, 8, !1),
        (this.A = jo[0] | 0),
        (this.B = jo[1] | 0),
        (this.C = jo[2] | 0),
        (this.D = jo[3] | 0),
        (this.E = jo[4] | 0),
        (this.F = jo[5] | 0),
        (this.G = jo[6] | 0),
        (this.H = jo[7] | 0);
    }
    get() {
      const { A: t, B: n, C: r, D: i, E: s, F: o, G: a, H: c } = this;
      return [t, n, r, i, s, o, a, c];
    }
    set(t, n, r, i, s, o, a, c) {
      (this.A = t | 0),
        (this.B = n | 0),
        (this.C = r | 0),
        (this.D = i | 0),
        (this.E = s | 0),
        (this.F = o | 0),
        (this.G = a | 0),
        (this.H = c | 0);
    }
    process(t, n) {
      for (let d = 0; d < 16; d++, n += 4) Lo[d] = t.getUint32(n, !1);
      for (let d = 16; d < 64; d++) {
        const f = Lo[d - 15],
          h = Lo[d - 2],
          p = (0, ni.rotr)(f, 7) ^ (0, ni.rotr)(f, 18) ^ (f >>> 3),
          b = (0, ni.rotr)(h, 17) ^ (0, ni.rotr)(h, 19) ^ (h >>> 10);
        Lo[d] = (b + Lo[d - 7] + p + Lo[d - 16]) | 0;
      }
      let { A: r, B: i, C: s, D: o, E: a, F: c, G: u, H: l } = this;
      for (let d = 0; d < 64; d++) {
        const f = (0, ni.rotr)(a, 6) ^ (0, ni.rotr)(a, 11) ^ (0, ni.rotr)(a, 25),
          h = (l + f + nSe(a, c, u) + iSe[d] + Lo[d]) | 0,
          b = (((0, ni.rotr)(r, 2) ^ (0, ni.rotr)(r, 13) ^ (0, ni.rotr)(r, 22)) + rSe(r, i, s)) | 0;
        (l = u), (u = c), (c = a), (a = (o + h) | 0), (o = s), (s = i), (i = r), (r = (h + b) | 0);
      }
      (r = (r + this.A) | 0),
        (i = (i + this.B) | 0),
        (s = (s + this.C) | 0),
        (o = (o + this.D) | 0),
        (a = (a + this.E) | 0),
        (c = (c + this.F) | 0),
        (u = (u + this.G) | 0),
        (l = (l + this.H) | 0),
        this.set(r, i, s, o, a, c, u, l);
    }
    roundClean() {
      Lo.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
    }
  },
  sSe = class extends fN {
    constructor() {
      super(),
        (this.A = -1056596264),
        (this.B = 914150663),
        (this.C = 812702999),
        (this.D = -150054599),
        (this.E = -4191439),
        (this.F = 1750603025),
        (this.G = 1694076839),
        (this.H = -1090891868),
        (this.outputLen = 28);
    }
  };
bc.sha256 = (0, ni.wrapConstructor)(() => new fN());
bc.sha224 = (0, ni.wrapConstructor)(() => new sSe());
var ui = {},
  hN = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.add = e.toBig = e.split = e.fromBig = void 0);
  const t = BigInt(2 ** 32 - 1),
    n = BigInt(32);
  function r(B, E = !1) {
    return E
      ? { h: Number(B & t), l: Number((B >> n) & t) }
      : { h: Number((B >> n) & t) | 0, l: Number(B & t) | 0 };
  }
  e.fromBig = r;
  function i(B, E = !1) {
    let y = new Uint32Array(B.length),
      v = new Uint32Array(B.length);
    for (let S = 0; S < B.length; S++) {
      const { h: T, l: M } = r(B[S], E);
      [y[S], v[S]] = [T, M];
    }
    return [y, v];
  }
  e.split = i;
  const s = (B, E) => (BigInt(B >>> 0) << n) | BigInt(E >>> 0);
  e.toBig = s;
  const o = (B, E, y) => B >>> y,
    a = (B, E, y) => (B << (32 - y)) | (E >>> y),
    c = (B, E, y) => (B >>> y) | (E << (32 - y)),
    u = (B, E, y) => (B << (32 - y)) | (E >>> y),
    l = (B, E, y) => (B << (64 - y)) | (E >>> (y - 32)),
    d = (B, E, y) => (B >>> (y - 32)) | (E << (64 - y)),
    f = (B, E) => E,
    h = (B, E) => B,
    p = (B, E, y) => (B << y) | (E >>> (32 - y)),
    b = (B, E, y) => (E << y) | (B >>> (32 - y)),
    w = (B, E, y) => (E << (y - 32)) | (B >>> (64 - y)),
    A = (B, E, y) => (B << (y - 32)) | (E >>> (64 - y));
  function _(B, E, y, v) {
    const S = (E >>> 0) + (v >>> 0);
    return { h: (B + y + ((S / 2 ** 32) | 0)) | 0, l: S | 0 };
  }
  e.add = _;
  const x = (B, E, y) => (B >>> 0) + (E >>> 0) + (y >>> 0),
    k = (B, E, y, v) => (E + y + v + ((B / 2 ** 32) | 0)) | 0,
    j = (B, E, y, v) => (B >>> 0) + (E >>> 0) + (y >>> 0) + (v >>> 0),
    F = (B, E, y, v, S) => (E + y + v + S + ((B / 2 ** 32) | 0)) | 0,
    K = (B, E, y, v, S) => (B >>> 0) + (E >>> 0) + (y >>> 0) + (v >>> 0) + (S >>> 0),
    D = (B, E, y, v, S, T) => (E + y + v + S + T + ((B / 2 ** 32) | 0)) | 0,
    C = {
      fromBig: r,
      split: i,
      toBig: e.toBig,
      shrSH: o,
      shrSL: a,
      rotrSH: c,
      rotrSL: u,
      rotrBH: l,
      rotrBL: d,
      rotr32H: f,
      rotr32L: h,
      rotlSH: p,
      rotlSL: b,
      rotlBH: w,
      rotlBL: A,
      add: _,
      add3L: x,
      add3H: k,
      add4L: j,
      add4H: F,
      add5H: D,
      add5L: K,
    };
  e.default = C;
})(hN);
Object.defineProperty(ui, '__esModule', { value: !0 });
ui.sha384 = ui.sha512_256 = ui.sha512_224 = ui.sha512 = ui.SHA512 = void 0;
const oSe = ul,
  st = hN,
  O1 = cl,
  [aSe, cSe] = st.default.split(
    [
      '0x428a2f98d728ae22',
      '0x7137449123ef65cd',
      '0xb5c0fbcfec4d3b2f',
      '0xe9b5dba58189dbbc',
      '0x3956c25bf348b538',
      '0x59f111f1b605d019',
      '0x923f82a4af194f9b',
      '0xab1c5ed5da6d8118',
      '0xd807aa98a3030242',
      '0x12835b0145706fbe',
      '0x243185be4ee4b28c',
      '0x550c7dc3d5ffb4e2',
      '0x72be5d74f27b896f',
      '0x80deb1fe3b1696b1',
      '0x9bdc06a725c71235',
      '0xc19bf174cf692694',
      '0xe49b69c19ef14ad2',
      '0xefbe4786384f25e3',
      '0x0fc19dc68b8cd5b5',
      '0x240ca1cc77ac9c65',
      '0x2de92c6f592b0275',
      '0x4a7484aa6ea6e483',
      '0x5cb0a9dcbd41fbd4',
      '0x76f988da831153b5',
      '0x983e5152ee66dfab',
      '0xa831c66d2db43210',
      '0xb00327c898fb213f',
      '0xbf597fc7beef0ee4',
      '0xc6e00bf33da88fc2',
      '0xd5a79147930aa725',
      '0x06ca6351e003826f',
      '0x142929670a0e6e70',
      '0x27b70a8546d22ffc',
      '0x2e1b21385c26c926',
      '0x4d2c6dfc5ac42aed',
      '0x53380d139d95b3df',
      '0x650a73548baf63de',
      '0x766a0abb3c77b2a8',
      '0x81c2c92e47edaee6',
      '0x92722c851482353b',
      '0xa2bfe8a14cf10364',
      '0xa81a664bbc423001',
      '0xc24b8b70d0f89791',
      '0xc76c51a30654be30',
      '0xd192e819d6ef5218',
      '0xd69906245565a910',
      '0xf40e35855771202a',
      '0x106aa07032bbd1b8',
      '0x19a4c116b8d2d0c8',
      '0x1e376c085141ab53',
      '0x2748774cdf8eeb99',
      '0x34b0bcb5e19b48a8',
      '0x391c0cb3c5c95a63',
      '0x4ed8aa4ae3418acb',
      '0x5b9cca4f7763e373',
      '0x682e6ff3d6b2b8a3',
      '0x748f82ee5defb2fc',
      '0x78a5636f43172f60',
      '0x84c87814a1f0ab72',
      '0x8cc702081a6439ec',
      '0x90befffa23631e28',
      '0xa4506cebde82bde9',
      '0xbef9a3f7b2c67915',
      '0xc67178f2e372532b',
      '0xca273eceea26619c',
      '0xd186b8c721c0c207',
      '0xeada7dd6cde0eb1e',
      '0xf57d4f7fee6ed178',
      '0x06f067aa72176fba',
      '0x0a637dc5a2c898a6',
      '0x113f9804bef90dae',
      '0x1b710b35131c471b',
      '0x28db77f523047d84',
      '0x32caab7b40c72493',
      '0x3c9ebe0a15c9bebc',
      '0x431d67c49c100d4c',
      '0x4cc5d4becb3e42b6',
      '0x597f299cfc657e2a',
      '0x5fcb6fab3ad6faec',
      '0x6c44198c4a475817',
    ].map((e) => BigInt(e))
  ),
  Uo = new Uint32Array(80),
  $o = new Uint32Array(80);
class Op extends oSe.SHA2 {
  constructor() {
    super(128, 64, 16, !1),
      (this.Ah = 1779033703),
      (this.Al = -205731576),
      (this.Bh = -1150833019),
      (this.Bl = -2067093701),
      (this.Ch = 1013904242),
      (this.Cl = -23791573),
      (this.Dh = -1521486534),
      (this.Dl = 1595750129),
      (this.Eh = 1359893119),
      (this.El = -1377402159),
      (this.Fh = -1694144372),
      (this.Fl = 725511199),
      (this.Gh = 528734635),
      (this.Gl = -79577749),
      (this.Hh = 1541459225),
      (this.Hl = 327033209);
  }
  get() {
    const {
      Ah: t,
      Al: n,
      Bh: r,
      Bl: i,
      Ch: s,
      Cl: o,
      Dh: a,
      Dl: c,
      Eh: u,
      El: l,
      Fh: d,
      Fl: f,
      Gh: h,
      Gl: p,
      Hh: b,
      Hl: w,
    } = this;
    return [t, n, r, i, s, o, a, c, u, l, d, f, h, p, b, w];
  }
  set(t, n, r, i, s, o, a, c, u, l, d, f, h, p, b, w) {
    (this.Ah = t | 0),
      (this.Al = n | 0),
      (this.Bh = r | 0),
      (this.Bl = i | 0),
      (this.Ch = s | 0),
      (this.Cl = o | 0),
      (this.Dh = a | 0),
      (this.Dl = c | 0),
      (this.Eh = u | 0),
      (this.El = l | 0),
      (this.Fh = d | 0),
      (this.Fl = f | 0),
      (this.Gh = h | 0),
      (this.Gl = p | 0),
      (this.Hh = b | 0),
      (this.Hl = w | 0);
  }
  process(t, n) {
    for (let x = 0; x < 16; x++, n += 4) (Uo[x] = t.getUint32(n)), ($o[x] = t.getUint32((n += 4)));
    for (let x = 16; x < 80; x++) {
      const k = Uo[x - 15] | 0,
        j = $o[x - 15] | 0,
        F = st.default.rotrSH(k, j, 1) ^ st.default.rotrSH(k, j, 8) ^ st.default.shrSH(k, j, 7),
        K = st.default.rotrSL(k, j, 1) ^ st.default.rotrSL(k, j, 8) ^ st.default.shrSL(k, j, 7),
        D = Uo[x - 2] | 0,
        C = $o[x - 2] | 0,
        B = st.default.rotrSH(D, C, 19) ^ st.default.rotrBH(D, C, 61) ^ st.default.shrSH(D, C, 6),
        E = st.default.rotrSL(D, C, 19) ^ st.default.rotrBL(D, C, 61) ^ st.default.shrSL(D, C, 6),
        y = st.default.add4L(K, E, $o[x - 7], $o[x - 16]),
        v = st.default.add4H(y, F, B, Uo[x - 7], Uo[x - 16]);
      (Uo[x] = v | 0), ($o[x] = y | 0);
    }
    let {
      Ah: r,
      Al: i,
      Bh: s,
      Bl: o,
      Ch: a,
      Cl: c,
      Dh: u,
      Dl: l,
      Eh: d,
      El: f,
      Fh: h,
      Fl: p,
      Gh: b,
      Gl: w,
      Hh: A,
      Hl: _,
    } = this;
    for (let x = 0; x < 80; x++) {
      const k =
          st.default.rotrSH(d, f, 14) ^ st.default.rotrSH(d, f, 18) ^ st.default.rotrBH(d, f, 41),
        j = st.default.rotrSL(d, f, 14) ^ st.default.rotrSL(d, f, 18) ^ st.default.rotrBL(d, f, 41),
        F = (d & h) ^ (~d & b),
        K = (f & p) ^ (~f & w),
        D = st.default.add5L(_, j, K, cSe[x], $o[x]),
        C = st.default.add5H(D, A, k, F, aSe[x], Uo[x]),
        B = D | 0,
        E = st.default.rotrSH(r, i, 28) ^ st.default.rotrBH(r, i, 34) ^ st.default.rotrBH(r, i, 39),
        y = st.default.rotrSL(r, i, 28) ^ st.default.rotrBL(r, i, 34) ^ st.default.rotrBL(r, i, 39),
        v = (r & s) ^ (r & a) ^ (s & a),
        S = (i & o) ^ (i & c) ^ (o & c);
      (A = b | 0),
        (_ = w | 0),
        (b = h | 0),
        (w = p | 0),
        (h = d | 0),
        (p = f | 0),
        ({ h: d, l: f } = st.default.add(u | 0, l | 0, C | 0, B | 0)),
        (u = a | 0),
        (l = c | 0),
        (a = s | 0),
        (c = o | 0),
        (s = r | 0),
        (o = i | 0);
      const T = st.default.add3L(B, y, S);
      (r = st.default.add3H(T, C, E, v)), (i = T | 0);
    }
    ({ h: r, l: i } = st.default.add(this.Ah | 0, this.Al | 0, r | 0, i | 0)),
      ({ h: s, l: o } = st.default.add(this.Bh | 0, this.Bl | 0, s | 0, o | 0)),
      ({ h: a, l: c } = st.default.add(this.Ch | 0, this.Cl | 0, a | 0, c | 0)),
      ({ h: u, l } = st.default.add(this.Dh | 0, this.Dl | 0, u | 0, l | 0)),
      ({ h: d, l: f } = st.default.add(this.Eh | 0, this.El | 0, d | 0, f | 0)),
      ({ h, l: p } = st.default.add(this.Fh | 0, this.Fl | 0, h | 0, p | 0)),
      ({ h: b, l: w } = st.default.add(this.Gh | 0, this.Gl | 0, b | 0, w | 0)),
      ({ h: A, l: _ } = st.default.add(this.Hh | 0, this.Hl | 0, A | 0, _ | 0)),
      this.set(r, i, s, o, a, c, u, l, d, f, h, p, b, w, A, _);
  }
  roundClean() {
    Uo.fill(0), $o.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
ui.SHA512 = Op;
class uSe extends Op {
  constructor() {
    super(),
      (this.Ah = -1942145080),
      (this.Al = 424955298),
      (this.Bh = 1944164710),
      (this.Bl = -1982016298),
      (this.Ch = 502970286),
      (this.Cl = 855612546),
      (this.Dh = 1738396948),
      (this.Dl = 1479516111),
      (this.Eh = 258812777),
      (this.El = 2077511080),
      (this.Fh = 2011393907),
      (this.Fl = 79989058),
      (this.Gh = 1067287976),
      (this.Gl = 1780299464),
      (this.Hh = 286451373),
      (this.Hl = -1848208735),
      (this.outputLen = 28);
  }
}
class lSe extends Op {
  constructor() {
    super(),
      (this.Ah = 573645204),
      (this.Al = -64227540),
      (this.Bh = -1621794909),
      (this.Bl = -934517566),
      (this.Ch = 596883563),
      (this.Cl = 1867755857),
      (this.Dh = -1774684391),
      (this.Dl = 1497426621),
      (this.Eh = -1775747358),
      (this.El = -1467023389),
      (this.Fh = -1101128155),
      (this.Fl = 1401305490),
      (this.Gh = 721525244),
      (this.Gl = 746961066),
      (this.Hh = 246885852),
      (this.Hl = -2117784414),
      (this.outputLen = 32);
  }
}
class dSe extends Op {
  constructor() {
    super(),
      (this.Ah = -876896931),
      (this.Al = -1056596264),
      (this.Bh = 1654270250),
      (this.Bl = 914150663),
      (this.Ch = -1856437926),
      (this.Cl = 812702999),
      (this.Dh = 355462360),
      (this.Dl = -150054599),
      (this.Eh = 1731405415),
      (this.El = -4191439),
      (this.Fh = -1900787065),
      (this.Fl = 1750603025),
      (this.Gh = -619958771),
      (this.Gl = 1694076839),
      (this.Hh = 1203062813),
      (this.Hl = -1090891868),
      (this.outputLen = 48);
  }
}
ui.sha512 = (0, O1.wrapConstructor)(() => new Op());
ui.sha512_224 = (0, O1.wrapConstructor)(() => new uSe());
ui.sha512_256 = (0, O1.wrapConstructor)(() => new lSe());
ui.sha384 = (0, O1.wrapConstructor)(() => new dSe());
Object.defineProperty(Ru, '__esModule', { value: !0 });
Ru.hmacSHA512 = Ru.hash160 = void 0;
const fSe = iN,
  hSe = Nu,
  pSe = bc,
  gSe = ui;
function ySe(e) {
  const t = (0, pSe.sha256)(Uint8Array.from(e));
  return z.from((0, hSe.ripemd160)(t));
}
Ru.hash160 = ySe;
function bSe(e, t) {
  return z.from((0, fSe.hmac)(gSe.sha512, e, t));
}
Ru.hmacSHA512 = bSe;
var B1 = {};
Object.defineProperty(B1, '__esModule', { value: !0 });
B1.testEcc = void 0;
const tt = (e) => z.from(e, 'hex');
function mSe(e) {
  if (
    (Ln(e.isPoint(tt('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'))),
    Ln(!e.isPoint(tt('030000000000000000000000000000000000000000000000000000000000000005'))),
    Ln(e.isPrivate(tt('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'))),
    Ln(e.isPrivate(tt('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140'))),
    Ln(!e.isPrivate(tt('0000000000000000000000000000000000000000000000000000000000000000'))),
    Ln(!e.isPrivate(tt('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'))),
    Ln(!e.isPrivate(tt('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142'))),
    Ln(
      z
        .from(
          e.pointFromScalar(tt('b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af'))
        )
        .equals(tt('02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99'))
    ),
    e.xOnlyPointAddTweak)
  ) {
    Ln(
      e.xOnlyPointAddTweak(
        tt('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
        tt('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')
      ) === null
    );
    let t = e.xOnlyPointAddTweak(
      tt('1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b'),
      tt('a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac')
    );
    Ln(
      z
        .from(t.xOnlyPubkey)
        .equals(tt('e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf')) &&
        t.parity === 1
    ),
      (t = e.xOnlyPointAddTweak(
        tt('2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991'),
        tt('823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47')
      ));
  }
  Ln(
    z
      .from(
        e.pointAddScalar(
          tt('0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
          tt('0000000000000000000000000000000000000000000000000000000000000003')
        )
      )
      .equals(tt('02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5'))
  ),
    Ln(
      z
        .from(
          e.privateAdd(
            tt('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e'),
            tt('0000000000000000000000000000000000000000000000000000000000000002')
          )
        )
        .equals(tt('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140'))
    ),
    e.privateNegate &&
      (Ln(
        z
          .from(
            e.privateNegate(tt('0000000000000000000000000000000000000000000000000000000000000001'))
          )
          .equals(tt('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140'))
      ),
      Ln(
        z
          .from(
            e.privateNegate(tt('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e'))
          )
          .equals(tt('0000000000000000000000000000000000000000000000000000000000000003'))
      ),
      Ln(
        z
          .from(
            e.privateNegate(tt('b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af'))
          )
          .equals(tt('4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792'))
      )),
    Ln(
      z
        .from(
          e.sign(
            tt('5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed'),
            tt('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')
          )
        )
        .equals(
          tt(
            '54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5'
          )
        )
    ),
    Ln(
      e.verify(
        tt('5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed'),
        tt('0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
        tt(
          '54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5'
        )
      )
    ),
    e.signSchnorr &&
      Ln(
        z
          .from(
            e.signSchnorr(
              tt('7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c'),
              tt('c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9'),
              tt('c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906')
            )
          )
          .equals(
            tt(
              '5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7'
            )
          )
      ),
    e.verifySchnorr &&
      Ln(
        e.verifySchnorr(
          tt('7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c'),
          tt('dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8'),
          tt(
            '5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7'
          )
        )
      );
}
B1.testEcc = mSe;
function Ln(e) {
  if (!e) throw new Error('ecc library invalid');
}
const wSe = Sb(VL);
Object.defineProperty(P1, '__esModule', { value: !0 });
P1.BIP32Factory = void 0;
const b_ = Ru,
  vSe = B1,
  _Se = wSe,
  SSe = bc,
  Hn = $P,
  ESe = bP,
  k8 = (0, _Se.base58check)(SSe.sha256),
  C8 = { encode: (e) => k8.encode(Uint8Array.from(e)), decode: (e) => z.from(k8.decode(e)) };
function ASe(e) {
  (0, vSe.testEcc)(e);
  const t = Hn.BufferN(32),
    n = Hn.compile({ wif: Hn.UInt8, bip32: { public: Hn.UInt32, private: Hn.UInt32 } }),
    r = {
      messagePrefix: `Bitcoin Signed Message:
`,
      bech32: 'bc',
      bip32: { public: 76067358, private: 76066276 },
      pubKeyHash: 0,
      scriptHash: 5,
      wif: 128,
    },
    i = 2147483648,
    s = Math.pow(2, 31) - 1;
  function o(A) {
    return Hn.String(A) && A.match(/^(m\/)?(\d+'?\/)*\d+'?$/) !== null;
  }
  function a(A) {
    return Hn.UInt32(A) && A <= s;
  }
  function c(A) {
    return A.length === 32 ? A : A.slice(1, 33);
  }
  class u {
    constructor(_, x) {
      (this.__D = _), (this.__Q = x), (this.lowR = !1);
    }
    get publicKey() {
      return this.__Q === void 0 && (this.__Q = z.from(e.pointFromScalar(this.__D, !0))), this.__Q;
    }
    get privateKey() {
      return this.__D;
    }
    sign(_, x) {
      if (!this.privateKey) throw new Error('Missing private key');
      if ((x === void 0 && (x = this.lowR), x === !1)) return z.from(e.sign(_, this.privateKey));
      {
        let k = z.from(e.sign(_, this.privateKey));
        const j = z.alloc(32, 0);
        let F = 0;
        for (; k[0] > 127; )
          F++, j.writeUIntLE(F, 0, 6), (k = z.from(e.sign(_, this.privateKey, j)));
        return k;
      }
    }
    signSchnorr(_) {
      if (!this.privateKey) throw new Error('Missing private key');
      if (!e.signSchnorr) throw new Error('signSchnorr not supported by ecc library');
      return z.from(e.signSchnorr(_, this.privateKey));
    }
    verify(_, x) {
      return e.verify(_, this.publicKey, x);
    }
    verifySchnorr(_, x) {
      if (!e.verifySchnorr) throw new Error('verifySchnorr not supported by ecc library');
      return e.verifySchnorr(_, this.publicKey.subarray(1, 33), x);
    }
  }
  class l extends u {
    constructor(_, x, k, j, F = 0, K = 0, D = 0) {
      super(_, x),
        (this.chainCode = k),
        (this.network = j),
        (this.__DEPTH = F),
        (this.__INDEX = K),
        (this.__PARENT_FINGERPRINT = D),
        Hn(n, j);
    }
    get depth() {
      return this.__DEPTH;
    }
    get index() {
      return this.__INDEX;
    }
    get parentFingerprint() {
      return this.__PARENT_FINGERPRINT;
    }
    get identifier() {
      return b_.hash160(this.publicKey);
    }
    get fingerprint() {
      return this.identifier.slice(0, 4);
    }
    get compressed() {
      return !0;
    }
    isNeutered() {
      return this.__D === void 0;
    }
    neutered() {
      return b(
        this.publicKey,
        this.chainCode,
        this.network,
        this.depth,
        this.index,
        this.parentFingerprint
      );
    }
    toBase58() {
      const _ = this.network,
        x = this.isNeutered() ? _.bip32.public : _.bip32.private,
        k = z.allocUnsafe(78);
      return (
        k.writeUInt32BE(x, 0),
        k.writeUInt8(this.depth, 4),
        k.writeUInt32BE(this.parentFingerprint, 5),
        k.writeUInt32BE(this.index, 9),
        this.chainCode.copy(k, 13),
        this.isNeutered()
          ? this.publicKey.copy(k, 45)
          : (k.writeUInt8(0, 45), this.privateKey.copy(k, 46)),
        C8.encode(k)
      );
    }
    toWIF() {
      if (!this.privateKey) throw new TypeError('Missing private key');
      return ESe.encode(this.network.wif, this.privateKey, !0);
    }
    derive(_) {
      Hn(Hn.UInt32, _);
      const x = _ >= i,
        k = z.allocUnsafe(37);
      if (x) {
        if (this.isNeutered()) throw new TypeError('Missing private key for hardened child key');
        (k[0] = 0), this.privateKey.copy(k, 1), k.writeUInt32BE(_, 33);
      } else this.publicKey.copy(k, 0), k.writeUInt32BE(_, 33);
      const j = b_.hmacSHA512(this.chainCode, k),
        F = j.slice(0, 32),
        K = j.slice(32);
      if (!e.isPrivate(F)) return this.derive(_ + 1);
      let D;
      if (this.isNeutered()) {
        const C = z.from(e.pointAddScalar(this.publicKey, F, !0));
        if (C === null) return this.derive(_ + 1);
        D = b(C, K, this.network, this.depth + 1, _, this.fingerprint.readUInt32BE(0));
      } else {
        const C = z.from(e.privateAdd(this.privateKey, F));
        if (C == null) return this.derive(_ + 1);
        D = h(C, K, this.network, this.depth + 1, _, this.fingerprint.readUInt32BE(0));
      }
      return D;
    }
    deriveHardened(_) {
      return Hn(a, _), this.derive(_ + i);
    }
    derivePath(_) {
      Hn(o, _);
      let x = _.split('/');
      if (x[0] === 'm') {
        if (this.parentFingerprint) throw new TypeError('Expected master, got child');
        x = x.slice(1);
      }
      return x.reduce((k, j) => {
        let F;
        return j.slice(-1) === "'"
          ? ((F = parseInt(j.slice(0, -1), 10)), k.deriveHardened(F))
          : ((F = parseInt(j, 10)), k.derive(F));
      }, this);
    }
    tweak(_) {
      return this.privateKey ? this.tweakFromPrivateKey(_) : this.tweakFromPublicKey(_);
    }
    tweakFromPublicKey(_) {
      const x = c(this.publicKey);
      if (!e.xOnlyPointAddTweak) throw new Error('xOnlyPointAddTweak not supported by ecc library');
      const k = e.xOnlyPointAddTweak(x, _);
      if (!k || k.xOnlyPubkey === null) throw new Error('Cannot tweak public key!');
      const j = z.from([k.parity === 0 ? 2 : 3]),
        F = z.concat([j, k.xOnlyPubkey]);
      return new u(void 0, F);
    }
    tweakFromPrivateKey(_) {
      const x =
          this.publicKey[0] === 3 || (this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1),
        k = (() => {
          if (x) {
            if (e.privateNegate) return e.privateNegate(this.privateKey);
            throw new Error('privateNegate not supported by ecc library');
          } else return this.privateKey;
        })(),
        j = e.privateAdd(k, _);
      if (!j) throw new Error('Invalid tweaked private key!');
      return new u(z.from(j), void 0);
    }
  }
  function d(A, _) {
    const x = C8.decode(A);
    if (x.length !== 78) throw new TypeError('Invalid buffer length');
    _ = _ || r;
    const k = x.readUInt32BE(0);
    if (k !== _.bip32.private && k !== _.bip32.public)
      throw new TypeError('Invalid network version');
    const j = x[4],
      F = x.readUInt32BE(5);
    if (j === 0 && F !== 0) throw new TypeError('Invalid parent fingerprint');
    const K = x.readUInt32BE(9);
    if (j === 0 && K !== 0) throw new TypeError('Invalid index');
    const D = x.slice(13, 45);
    let C;
    if (k === _.bip32.private) {
      if (x.readUInt8(45) !== 0) throw new TypeError('Invalid private key');
      const B = x.slice(46, 78);
      C = h(B, D, _, j, K, F);
    } else {
      const B = x.slice(45, 78);
      C = b(B, D, _, j, K, F);
    }
    return C;
  }
  function f(A, _, x) {
    return h(A, _, x);
  }
  function h(A, _, x, k, j, F) {
    if (
      (Hn({ privateKey: t, chainCode: t }, { privateKey: A, chainCode: _ }),
      (x = x || r),
      !e.isPrivate(A))
    )
      throw new TypeError('Private key not in range [1, n)');
    return new l(A, void 0, _, x, k, j, F);
  }
  function p(A, _, x) {
    return b(A, _, x);
  }
  function b(A, _, x, k, j, F) {
    if (
      (Hn({ publicKey: Hn.BufferN(33), chainCode: t }, { publicKey: A, chainCode: _ }),
      (x = x || r),
      !e.isPoint(A))
    )
      throw new TypeError('Point is not on the curve');
    return new l(void 0, A, _, x, k, j, F);
  }
  function w(A, _) {
    if ((Hn(Hn.Buffer, A), A.length < 16)) throw new TypeError('Seed should be at least 128 bits');
    if (A.length > 64) throw new TypeError('Seed should be at most 512 bits');
    _ = _ || r;
    const x = b_.hmacSHA512(z.from('Bitcoin seed', 'utf8'), A),
      k = x.slice(0, 32),
      j = x.slice(32);
    return f(k, j, _);
  }
  return { fromSeed: w, fromBase58: d, fromPublicKey: p, fromPrivateKey: f };
}
P1.BIP32Factory = ASe;
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }), (e.BIP32Factory = e.default = void 0);
  var t = P1;
  Object.defineProperty(e, 'default', {
    enumerable: !0,
    get: function () {
      return t.BIP32Factory;
    },
  }),
    Object.defineProperty(e, 'BIP32Factory', {
      enumerable: !0,
      get: function () {
        return t.BIP32Factory;
      },
    });
})(K_e);
var ISe = {},
  mc = {},
  ar = {};
const ob = 2147483648;
var yi = function (e) {
  if (!Array.isArray(e)) throw new Error('Input must be an Array');
  if (e.length === 0) throw new Error('Path must contain at least one level');
  for (var t = 0; t < e.length; t++)
    if (typeof e[t] != 'number') throw new Error('Path element is not a number');
  this.path = e;
};
yi.validatePathArray = function (e) {
  try {
    return yi.fromPathArray(e), !0;
  } catch {
    return !1;
  }
};
yi.validateString = function (e, t) {
  try {
    return yi.fromString(e, t), !0;
  } catch {
    return !1;
  }
};
yi.fromPathArray = function (e) {
  return new yi(e);
};
yi.fromString = function (e, t) {
  if (/^m\//i.test(e)) e = e.slice(2);
  else if (t) throw new Error('Root element is required');
  for (var n = e.split('/'), r = new Array(n.length), i = 0; i < n.length; i++) {
    var s = /(\d+)([hH\']?)/.exec(n[i]);
    if (s === null) throw new Error('Invalid input');
    if (((r[i] = parseInt(s[1], 10)), r[i] >= ob)) throw new Error('Invalid child index');
    if (s[2] === 'h' || s[2] === 'H' || s[2] === "'") r[i] += ob;
    else if (s[2].length != 0) throw new Error('Invalid modifier');
  }
  return new yi(r);
};
yi.prototype.toPathArray = function () {
  return this.path;
};
yi.prototype.toString = function (e, t) {
  for (var n = new Array(this.path.length), r = 0; r < this.path.length; r++) {
    var i = this.path[r];
    i & ob ? (n[r] = (i & ~ob) + (t ? 'h' : "'")) : (n[r] = i);
  }
  return (e ? '' : 'm/') + n.join('/');
};
yi.prototype.inspect = function () {
  return 'BIPPath <' + this.toString() + '>';
};
var TSe = yi,
  pN =
    (m && m.__importDefault) ||
    function (e) {
      return e && e.__esModule ? e : { default: e };
    };
Object.defineProperty(ar, '__esModule', { value: !0 });
ar.hardenedPathOf =
  ar.getXpubComponents =
  ar.pubkeyFromXpub =
  ar.pathStringToArray =
  ar.pathArrayToString =
  ar.bip32asBuffer =
  ar.pathElementsToBuffer =
    void 0;
const gN = pN(TSe),
  yN = pN(WL);
function bN(e) {
  const t = z.alloc(1 + e.length * 4);
  return (
    (t[0] = e.length),
    e.forEach((n, r) => {
      t.writeUInt32BE(n, 1 + 4 * r);
    }),
    t
  );
}
ar.pathElementsToBuffer = bN;
function xSe(e) {
  const t = e ? mN(e) : [];
  return bN(t);
}
ar.bip32asBuffer = xSe;
function kSe(e) {
  return e.length == 0 ? 'm' : gN.default.fromPathArray(e).toString();
}
ar.pathArrayToString = kSe;
function mN(e) {
  return e == 'm' || e == '' ? [] : gN.default.fromString(e).toPathArray();
}
ar.pathStringToArray = mN;
function CSe(e) {
  const t = yN.default.decode(e);
  return t.slice(t.length - 33);
}
ar.pubkeyFromXpub = CSe;
function PSe(e) {
  const t = yN.default.decode(e);
  return { chaincode: t.slice(13, 45), pubkey: t.slice(t.length - 33), version: t.readUInt32BE(0) };
}
ar.getXpubComponents = PSe;
function MSe(e) {
  for (let t = e.length - 1; t >= 0; t--) if (e[t] >= 2147483648) return e.slice(0, t + 1);
  return [];
}
ar.hardenedPathOf = MSe;
var kr = {},
  fi = {},
  pi = {};
Object.defineProperty(pi, '__esModule', { value: !0 });
pi.createVarint = pi.parseVarint = pi.sanitizeBigintToNumber = void 0;
function OSe(e, t, n, r) {
  for (let i = 0; i < t; i++) {
    if (n[i + r] == null) throw Error('Buffer too small');
    (n[i + r] = Number(e % BigInt(256))), (e = e >> BigInt(8));
  }
}
function BSe(e, t, n) {
  let r = BigInt(0);
  for (let i = 0; i < n; i++) {
    if (e[i + t] == null) throw Error('Buffer too small');
    r += BigInt(e[i + t]) << BigInt(i * 8);
  }
  return r;
}
function IT(e) {
  if (e < 0) throw RangeError('Negative bigint is not a valid varint');
  if (e > Number.MAX_SAFE_INTEGER) throw RangeError('Too large for a Number');
  return Number(e);
}
pi.sanitizeBigintToNumber = IT;
function DSe(e) {
  if ((typeof e == 'number' && (e = IT(e)), e < BigInt(0)))
    throw new RangeError('Negative numbers are not supported');
  if (e >= BigInt(1) << BigInt(64)) throw new RangeError('Too large for a Bitcoin-style varint');
  return e < BigInt(253) ? 1 : e <= BigInt(65535) ? 3 : e <= BigInt(4294967295) ? 5 : 9;
}
function RSe(e, t) {
  if (t < 0) throw RangeError('Negative offset is invalid');
  if (e[t] == null) throw Error('Buffer too small');
  if (e[t] < 253) return [BigInt(e[t]), 1];
  {
    let n;
    return e[t] === 253 ? (n = 2) : e[t] === 254 ? (n = 4) : (n = 8), [BSe(e, t + 1, n), n + 1];
  }
}
pi.parseVarint = RSe;
function NSe(e) {
  typeof e == 'number' && (e = IT(e));
  const t = DSe(e);
  e = BigInt(e);
  const n = z.alloc(t);
  return (
    t == 1
      ? (n[0] = Number(e))
      : (t == 3 ? (n[0] = 253) : t === 5 ? (n[0] = 254) : (n[0] = 255), OSe(e, t - 1, n, 1)),
    n
  );
}
pi.createVarint = NSe;
Object.defineProperty(fi, '__esModule', { value: !0 });
fi.BufferReader = fi.BufferWriter = fi.unsafeFrom64bitLE = fi.unsafeTo64bitLE = void 0;
const FE = pi;
function wN(e) {
  if (e > Number.MAX_SAFE_INTEGER) throw new Error("Can't convert numbers > MAX_SAFE_INT");
  const t = z.alloc(8, 0);
  for (let n = 0; n < t.length; n++) {
    const r = e & 255;
    (t[n] = r), (e = (e - r) / 256);
  }
  return t;
}
fi.unsafeTo64bitLE = wN;
function vN(e) {
  let t = 0;
  if (e.length != 8) throw new Error('Expected Bufffer of lenght 8');
  if (e[7] != 0) throw new Error("Can't encode numbers > MAX_SAFE_INT");
  if (e[6] > 31) throw new Error("Can't encode numbers > MAX_SAFE_INT");
  for (let n = e.length - 1; n >= 0; n--) t = t * 256 + e[n];
  return t;
}
fi.unsafeFrom64bitLE = vN;
class jSe {
  constructor() {
    this.bufs = [];
  }
  write(t, n) {
    const r = z.alloc(t);
    n(r), this.bufs.push(r);
  }
  writeUInt8(t) {
    this.write(1, (n) => n.writeUInt8(t, 0));
  }
  writeInt32(t) {
    this.write(4, (n) => n.writeInt32LE(t, 0));
  }
  writeUInt32(t) {
    this.write(4, (n) => n.writeUInt32LE(t, 0));
  }
  writeUInt64(t) {
    const n = wN(t);
    this.writeSlice(n);
  }
  writeVarInt(t) {
    this.bufs.push((0, FE.createVarint)(t));
  }
  writeSlice(t) {
    this.bufs.push(z.from(t));
  }
  writeVarSlice(t) {
    this.writeVarInt(t.length), this.writeSlice(t);
  }
  buffer() {
    return z.concat(this.bufs);
  }
}
fi.BufferWriter = jSe;
class LSe {
  constructor(t, n = 0) {
    (this.buffer = t), (this.offset = n);
  }
  available() {
    return this.buffer.length - this.offset;
  }
  readUInt8() {
    const t = this.buffer.readUInt8(this.offset);
    return this.offset++, t;
  }
  readInt32() {
    const t = this.buffer.readInt32LE(this.offset);
    return (this.offset += 4), t;
  }
  readUInt32() {
    const t = this.buffer.readUInt32LE(this.offset);
    return (this.offset += 4), t;
  }
  readUInt64() {
    const t = this.readSlice(8);
    return vN(t);
  }
  readVarInt() {
    const [t, n] = (0, FE.parseVarint)(this.buffer, this.offset);
    return (this.offset += n), t;
  }
  readSlice(t) {
    if (this.buffer.length < this.offset + t) throw new Error('Cannot read slice out of bounds');
    const n = this.buffer.slice(this.offset, this.offset + t);
    return (this.offset += t), n;
  }
  readVarSlice() {
    const t = (0, FE.sanitizeBigintToNumber)(this.readVarInt());
    return this.readSlice(t);
  }
  readVector() {
    const t = this.readVarInt(),
      n = [];
    for (let r = 0; r < t; r++) n.push(this.readVarSlice());
    return n;
  }
}
fi.BufferReader = LSe;
var co = {};
Object.defineProperty(co, '__esModule', { value: !0 });
co.hashLeaf = co.Merkle = void 0;
const _N = bi;
class USe {
  constructor(t, n = _N.crypto.sha256) {
    (this.leaves = t), (this.h = n);
    const r = this.calculateRoot(t);
    (this.rootNode = r.root), (this.leafNodes = r.leaves);
  }
  getRoot() {
    return this.rootNode.hash;
  }
  size() {
    return this.leaves.length;
  }
  getLeaves() {
    return this.leaves;
  }
  getLeafHash(t) {
    return this.leafNodes[t].hash;
  }
  getProof(t) {
    if (t >= this.leaves.length) throw Error('Index out of bounds');
    return zE(this.leafNodes[t]);
  }
  calculateRoot(t) {
    const n = t.length;
    if (n == 0) return { root: new m_(void 0, void 0, z.alloc(32, 0)), leaves: [] };
    if (n == 1) {
      const l = new m_(void 0, void 0, t[0]);
      return { root: l, leaves: [l] };
    }
    const r = zSe(n),
      i = this.calculateRoot(t.slice(0, r)),
      s = this.calculateRoot(t.slice(r)),
      o = i.root,
      a = s.root,
      c = this.hashNode(o.hash, a.hash),
      u = new m_(o, a, c);
    return (o.parent = u), (a.parent = u), { root: u, leaves: i.leaves.concat(s.leaves) };
  }
  hashNode(t, n) {
    return this.h(z.concat([z.from([1]), t, n]));
  }
}
co.Merkle = USe;
function $Se(e, t = _N.crypto.sha256) {
  return FSe(z.from([0]), e, t);
}
co.hashLeaf = $Se;
function FSe(e, t, n) {
  return n(z.concat([e, t]));
}
let m_ = class {
  constructor(t, n, r) {
    (this.leftChild = t), (this.rightChild = n), (this.hash = r);
  }
  isLeaf() {
    return this.leftChild == null;
  }
};
function zE(e) {
  if (!e.parent) return [];
  if (e.parent.leftChild == e) {
    if (!e.parent.rightChild) throw new Error('Expected right child to exist');
    return [e.parent.rightChild.hash, ...zE(e.parent)];
  } else {
    if (!e.parent.leftChild) throw new Error('Expected left child to exist');
    return [e.parent.leftChild.hash, ...zE(e.parent)];
  }
}
function zSe(e) {
  if (e < 2) throw Error('Expected n >= 2');
  return KSe(e) ? e / 2 : 1 << Math.floor(Math.log2(e));
}
function KSe(e) {
  return (e & (e - 1)) == 0;
}
Object.defineProperty(kr, '__esModule', { value: !0 });
kr.ClientCommandInterpreter =
  kr.GetMoreElementsCommand =
  kr.GetMerkleLeafIndexCommand =
  kr.GetMerkleLeafProofCommand =
  kr.GetPreimageCommand =
  kr.YieldCommand =
    void 0;
const VSe = bi,
  WSe = fi,
  P8 = co,
  ab = pi;
var wc;
(function (e) {
  (e[(e.YIELD = 16)] = 'YIELD'),
    (e[(e.GET_PREIMAGE = 64)] = 'GET_PREIMAGE'),
    (e[(e.GET_MERKLE_LEAF_PROOF = 65)] = 'GET_MERKLE_LEAF_PROOF'),
    (e[(e.GET_MERKLE_LEAF_INDEX = 66)] = 'GET_MERKLE_LEAF_INDEX'),
    (e[(e.GET_MORE_ELEMENTS = 160)] = 'GET_MORE_ELEMENTS');
})(wc || (wc = {}));
class Bp {}
class SN extends Bp {
  constructor(t, n) {
    super(), (this.progressCallback = n), (this.code = wc.YIELD), (this.results = t);
  }
  execute(t) {
    return (
      this.results.push(z.from(t.subarray(1))),
      this.progressCallback && this.progressCallback(),
      z.from('')
    );
  }
}
kr.YieldCommand = SN;
class EN extends Bp {
  constructor(t, n) {
    super(), (this.code = wc.GET_PREIMAGE), (this.known_preimages = t), (this.queue = n);
  }
  execute(t) {
    const n = z.from(t.subarray(1));
    if (n.length != 33) throw new Error('Invalid request, unexpected trailing data');
    if (n[0] != 0) throw new Error('Unsupported request, the first byte should be 0');
    const r = z.alloc(32);
    for (let o = 0; o < 32; o++) r[o] = n[1 + o];
    const i = r.toString('hex'),
      s = this.known_preimages.get(i);
    if (s != null) {
      const o = (0, ab.createVarint)(s.length),
        a = 255 - o.length - 1,
        c = Math.min(a, s.length);
      if (c < s.length) for (let u = c; u < s.length; u++) this.queue.push(z.from([s[u]]));
      return z.concat([o, z.from([c]), z.from(s.subarray(0, c))]);
    }
    throw Error(`Requested unknown preimage for: ${i}`);
  }
}
kr.GetPreimageCommand = EN;
class AN extends Bp {
  constructor(t, n) {
    super(), (this.code = wc.GET_MERKLE_LEAF_PROOF), (this.known_trees = t), (this.queue = n);
  }
  execute(t) {
    const n = z.from(t.subarray(1));
    if (n.length < 34) throw new Error('Invalid request, expected at least 34 bytes');
    const r = new WSe.BufferReader(n),
      s = r.readSlice(32).toString('hex');
    let o, a;
    try {
      (o = (0, ab.sanitizeBigintToNumber)(r.readVarInt())),
        (a = (0, ab.sanitizeBigintToNumber)(r.readVarInt()));
    } catch {
      throw new Error("Invalid request, couldn't parse tree_size or leaf_index");
    }
    const c = this.known_trees.get(s);
    if (!c) throw Error(`Requested Merkle leaf proof for unknown tree: ${s}`);
    if (a >= o || c.size() != o) throw Error('Invalid index or tree size.');
    if (this.queue.length != 0)
      throw Error('This command should not execute when the queue is not empty.');
    const u = c.getProof(a),
      l = Math.min(Math.floor(221 / 32), u.length),
      d = u.length - l;
    return (
      d > 0 && this.queue.push(...u.slice(-d)),
      z.concat([c.getLeafHash(a), z.from([u.length]), z.from([l]), ...u.slice(0, l)])
    );
  }
}
kr.GetMerkleLeafProofCommand = AN;
class IN extends Bp {
  constructor(t) {
    super(), (this.code = wc.GET_MERKLE_LEAF_INDEX), (this.known_trees = t);
  }
  execute(t) {
    const n = z.from(t.subarray(1));
    if (n.length != 64) throw new Error('Invalid request, unexpected trailing data');
    const r = z.alloc(32);
    for (let l = 0; l < 32; l++) r[l] = n.readUInt8(l);
    const i = r.toString('hex'),
      s = z.alloc(32);
    for (let l = 0; l < 32; l++) s[l] = n.readUInt8(32 + l);
    const o = s.toString('hex'),
      a = this.known_trees.get(i);
    if (!a) throw Error(`Requested Merkle leaf index for unknown root: ${i}`);
    let c = 0,
      u = 0;
    for (let l = 0; l < a.size(); l++)
      if (a.getLeafHash(l).toString('hex') == o) {
        (u = 1), (c = l);
        break;
      }
    return z.concat([z.from([u]), (0, ab.createVarint)(c)]);
  }
}
kr.GetMerkleLeafIndexCommand = IN;
class TN extends Bp {
  constructor(t) {
    super(), (this.code = wc.GET_MORE_ELEMENTS), (this.queue = t);
  }
  execute(t) {
    if (t.length != 1) throw new Error('Invalid request, unexpected trailing data');
    if (this.queue.length === 0) throw new Error('No elements to get');
    const n = this.queue[0].length;
    if (this.queue.some((o) => o.length != n))
      throw new Error(
        'The queue contains elements with different byte length, which is not expected'
      );
    const r = Math.floor(253 / n),
      i = Math.min(r, this.queue.length),
      s = this.queue.splice(0, i);
    return z.concat([z.from([i]), z.from([n]), ...s]);
  }
}
kr.GetMoreElementsCommand = TN;
class HSe {
  constructor(t) {
    (this.roots = new Map()),
      (this.preimages = new Map()),
      (this.yielded = []),
      (this.queue = []),
      (this.commands = new Map());
    const n = [
      new SN(this.yielded, t),
      new EN(this.preimages, this.queue),
      new IN(this.roots),
      new AN(this.roots, this.queue),
      new TN(this.queue),
    ];
    for (const r of n) {
      if (this.commands.has(r.code)) throw new Error(`Multiple commands with code ${r.code}`);
      this.commands.set(r.code, r);
    }
  }
  getYielded() {
    return this.yielded;
  }
  addKnownPreimage(t) {
    this.preimages.set(VSe.crypto.sha256(t).toString('hex'), t);
  }
  addKnownList(t) {
    for (const r of t) {
      const i = z.concat([z.from([0]), r]);
      this.addKnownPreimage(i);
    }
    const n = new P8.Merkle(t.map((r) => (0, P8.hashLeaf)(r)));
    this.roots.set(n.getRoot().toString('hex'), n);
  }
  addKnownMapping(t) {
    this.addKnownList(t.keys), this.addKnownList(t.values);
  }
  addKnownWalletPolicy(t) {
    this.addKnownPreimage(t.serialize()),
      this.addKnownList(t.keys.map((n) => z.from(n, 'ascii'))),
      this.addKnownPreimage(z.from(t.descriptorTemplate));
  }
  execute(t) {
    if (t.length == 0) throw new Error('Unexpected empty command');
    const n = t[0],
      r = this.commands.get(n);
    if (!r) throw new Error(`Unexpected command code ${n}`);
    return r.execute(t);
  }
}
kr.ClientCommandInterpreter = HSe;
var D1 = {},
  R1 = {};
Object.defineProperty(R1, '__esModule', { value: !0 });
R1.MerkleMap = void 0;
const kg = co,
  GSe = pi;
class qSe {
  constructor(t, n) {
    if (t.length != n.length) throw new Error('keys and values should have the same length');
    for (let r = 0; r < t.length - 1; r++)
      if (t[r].toString('hex') >= t[r + 1].toString('hex'))
        throw new Error('keys must be in strictly increasing order');
    (this.keys = t),
      (this.keysTree = new kg.Merkle(t.map((r) => (0, kg.hashLeaf)(r)))),
      (this.values = n),
      (this.valuesTree = new kg.Merkle(n.map((r) => (0, kg.hashLeaf)(r))));
  }
  commitment() {
    return z.concat([
      (0, GSe.createVarint)(this.keys.length),
      this.keysTree.getRoot(),
      this.valuesTree.getRoot(),
    ]);
  }
}
R1.MerkleMap = qSe;
var N1 = {};
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (D, C, B, E) {
            E === void 0 && (E = B);
            var y = Object.getOwnPropertyDescriptor(C, B);
            (!y || ('get' in y ? !C.__esModule : y.writable || y.configurable)) &&
              (y = {
                enumerable: !0,
                get: function () {
                  return C[B];
                },
              }),
              Object.defineProperty(D, E, y);
          }
        : function (D, C, B, E) {
            E === void 0 && (E = B), (D[E] = C[B]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (D, C) {
            Object.defineProperty(D, 'default', { enumerable: !0, value: C });
          }
        : function (D, C) {
            D.default = C;
          }),
    r =
      (m && m.__importStar) ||
      function (D) {
        if (D && D.__esModule) return D;
        var C = {};
        if (D != null)
          for (var B in D)
            B !== 'default' && Object.prototype.hasOwnProperty.call(D, B) && t(C, D, B);
        return n(C, D), C;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.PsbtV2 = e.NoSuchEntry = e.psbtOut = e.psbtIn = e.psbtGlobal = void 0);
  const i = r(bi),
    s = fi,
    o = pi;
  var a;
  (function (D) {
    (D[(D.UNSIGNED_TX = 0)] = 'UNSIGNED_TX'),
      (D[(D.XPUB = 1)] = 'XPUB'),
      (D[(D.TX_VERSION = 2)] = 'TX_VERSION'),
      (D[(D.FALLBACK_LOCKTIME = 3)] = 'FALLBACK_LOCKTIME'),
      (D[(D.INPUT_COUNT = 4)] = 'INPUT_COUNT'),
      (D[(D.OUTPUT_COUNT = 5)] = 'OUTPUT_COUNT'),
      (D[(D.TX_MODIFIABLE = 6)] = 'TX_MODIFIABLE'),
      (D[(D.VERSION = 251)] = 'VERSION');
  })((a = e.psbtGlobal || (e.psbtGlobal = {})));
  var c;
  (function (D) {
    (D[(D.NON_WITNESS_UTXO = 0)] = 'NON_WITNESS_UTXO'),
      (D[(D.WITNESS_UTXO = 1)] = 'WITNESS_UTXO'),
      (D[(D.PARTIAL_SIG = 2)] = 'PARTIAL_SIG'),
      (D[(D.SIGHASH_TYPE = 3)] = 'SIGHASH_TYPE'),
      (D[(D.REDEEM_SCRIPT = 4)] = 'REDEEM_SCRIPT'),
      (D[(D.WITNESS_SCRIPT = 5)] = 'WITNESS_SCRIPT'),
      (D[(D.BIP32_DERIVATION = 6)] = 'BIP32_DERIVATION'),
      (D[(D.FINAL_SCRIPTSIG = 7)] = 'FINAL_SCRIPTSIG'),
      (D[(D.FINAL_SCRIPTWITNESS = 8)] = 'FINAL_SCRIPTWITNESS'),
      (D[(D.PREVIOUS_TXID = 14)] = 'PREVIOUS_TXID'),
      (D[(D.OUTPUT_INDEX = 15)] = 'OUTPUT_INDEX'),
      (D[(D.SEQUENCE = 16)] = 'SEQUENCE'),
      (D[(D.TAP_KEY_SIG = 19)] = 'TAP_KEY_SIG'),
      (D[(D.TAP_BIP32_DERIVATION = 22)] = 'TAP_BIP32_DERIVATION');
  })((c = e.psbtIn || (e.psbtIn = {})));
  var u;
  (function (D) {
    (D[(D.REDEEM_SCRIPT = 0)] = 'REDEEM_SCRIPT'),
      (D[(D.WITNESS_SCRIPT = 1)] = 'WITNESS_SCRIPT'),
      (D[(D.BIP_32_DERIVATION = 2)] = 'BIP_32_DERIVATION'),
      (D[(D.AMOUNT = 3)] = 'AMOUNT'),
      (D[(D.SCRIPT = 4)] = 'SCRIPT'),
      (D[(D.TAP_BIP32_DERIVATION = 7)] = 'TAP_BIP32_DERIVATION');
  })((u = e.psbtOut || (e.psbtOut = {})));
  const l = z.from([112, 115, 98, 116, 255]);
  class d extends Error {}
  e.NoSuchEntry = d;
  class f {
    constructor() {
      (this.globalMap = new Map()), (this.inputMaps = []), (this.outputMaps = []);
    }
    setGlobalTxVersion(C) {
      this.setGlobal(a.TX_VERSION, k(C));
    }
    getGlobalTxVersion() {
      return this.getGlobal(a.TX_VERSION).readUInt32LE(0);
    }
    setGlobalFallbackLocktime(C) {
      this.setGlobal(a.FALLBACK_LOCKTIME, k(C));
    }
    getGlobalFallbackLocktime() {
      var C;
      return (C = this.getGlobalOptional(a.FALLBACK_LOCKTIME)) === null || C === void 0
        ? void 0
        : C.readUInt32LE(0);
    }
    setGlobalInputCount(C) {
      this.setGlobal(a.INPUT_COUNT, F(C));
    }
    getGlobalInputCount() {
      return K(this.getGlobal(a.INPUT_COUNT));
    }
    setGlobalOutputCount(C) {
      this.setGlobal(a.OUTPUT_COUNT, F(C));
    }
    getGlobalOutputCount() {
      return K(this.getGlobal(a.OUTPUT_COUNT));
    }
    setGlobalTxModifiable(C) {
      this.setGlobal(a.TX_MODIFIABLE, C);
    }
    getGlobalTxModifiable() {
      return this.getGlobalOptional(a.TX_MODIFIABLE);
    }
    setGlobalPsbtVersion(C) {
      this.setGlobal(a.VERSION, k(C));
    }
    getGlobalPsbtVersion() {
      return this.getGlobal(a.VERSION).readUInt32LE(0);
    }
    setInputNonWitnessUtxo(C, B) {
      this.setInput(C, c.NON_WITNESS_UTXO, _(), B);
    }
    getInputNonWitnessUtxo(C) {
      return this.getInputOptional(C, c.NON_WITNESS_UTXO, _());
    }
    setInputWitnessUtxo(C, B, E) {
      const y = new s.BufferWriter();
      y.writeSlice(j(B)), y.writeVarSlice(E), this.setInput(C, c.WITNESS_UTXO, _(), y.buffer());
    }
    getInputWitnessUtxo(C) {
      const B = this.getInputOptional(C, c.WITNESS_UTXO, _());
      if (!B) return;
      const E = new s.BufferReader(B);
      return { amount: (0, s.unsafeFrom64bitLE)(E.readSlice(8)), scriptPubKey: E.readVarSlice() };
    }
    setInputPartialSig(C, B, E) {
      this.setInput(C, c.PARTIAL_SIG, B, E);
    }
    getInputPartialSig(C, B) {
      return this.getInputOptional(C, c.PARTIAL_SIG, B);
    }
    setInputSighashType(C, B) {
      this.setInput(C, c.SIGHASH_TYPE, _(), k(B));
    }
    getInputSighashType(C) {
      const B = this.getInputOptional(C, c.SIGHASH_TYPE, _());
      if (B) return B.readUInt32LE(0);
    }
    setInputRedeemScript(C, B) {
      this.setInput(C, c.REDEEM_SCRIPT, _(), B);
    }
    getInputRedeemScript(C) {
      return this.getInputOptional(C, c.REDEEM_SCRIPT, _());
    }
    setInputWitnessScript(C, B) {
      this.setInput(C, c.WITNESS_SCRIPT, _(), B);
    }
    getInputWitnessScript(C) {
      return this.getInputOptional(C, c.WITNESS_SCRIPT, _());
    }
    setInputBip32Derivation(C, B, E, y) {
      if (B.length != 33) throw new Error('Invalid pubkey length: ' + B.length);
      this.setInput(C, c.BIP32_DERIVATION, B, this.encodeBip32Derivation(E, y));
    }
    getInputBip32Derivation(C, B) {
      const E = this.getInputOptional(C, c.BIP32_DERIVATION, B);
      if (E) return this.decodeBip32Derivation(E);
    }
    setInputFinalScriptsig(C, B) {
      this.setInput(C, c.FINAL_SCRIPTSIG, _(), B);
    }
    getInputFinalScriptsig(C) {
      return this.getInputOptional(C, c.FINAL_SCRIPTSIG, _());
    }
    setInputFinalScriptwitness(C, B) {
      this.setInput(C, c.FINAL_SCRIPTWITNESS, _(), B);
    }
    getInputFinalScriptwitness(C) {
      return this.getInput(C, c.FINAL_SCRIPTWITNESS, _());
    }
    setInputPreviousTxId(C, B) {
      this.setInput(C, c.PREVIOUS_TXID, _(), B);
    }
    getInputPreviousTxid(C) {
      return this.getInput(C, c.PREVIOUS_TXID, _());
    }
    setInputOutputIndex(C, B) {
      this.setInput(C, c.OUTPUT_INDEX, _(), k(B));
    }
    getInputOutputIndex(C) {
      return this.getInput(C, c.OUTPUT_INDEX, _()).readUInt32LE(0);
    }
    setInputSequence(C, B) {
      this.setInput(C, c.SEQUENCE, _(), k(B));
    }
    getInputSequence(C) {
      var B, E;
      return (E =
        (B = this.getInputOptional(C, c.SEQUENCE, _())) === null || B === void 0
          ? void 0
          : B.readUInt32LE(0)) !== null && E !== void 0
        ? E
        : 4294967295;
    }
    setInputTapKeySig(C, B) {
      this.setInput(C, c.TAP_KEY_SIG, _(), B);
    }
    getInputTapKeySig(C) {
      return this.getInputOptional(C, c.TAP_KEY_SIG, _());
    }
    setInputTapBip32Derivation(C, B, E, y, v) {
      if (B.length != 32) throw new Error('Invalid pubkey length: ' + B.length);
      const S = this.encodeTapBip32Derivation(E, y, v);
      this.setInput(C, c.TAP_BIP32_DERIVATION, B, S);
    }
    getInputTapBip32Derivation(C, B) {
      const E = this.getInput(C, c.TAP_BIP32_DERIVATION, B);
      return this.decodeTapBip32Derivation(E);
    }
    getInputKeyDatas(C, B) {
      return this.getKeyDatas(this.inputMaps[C], B);
    }
    setOutputRedeemScript(C, B) {
      this.setOutput(C, u.REDEEM_SCRIPT, _(), B);
    }
    getOutputRedeemScript(C) {
      return this.getOutput(C, u.REDEEM_SCRIPT, _());
    }
    setOutputBip32Derivation(C, B, E, y) {
      this.setOutput(C, u.BIP_32_DERIVATION, B, this.encodeBip32Derivation(E, y));
    }
    getOutputBip32Derivation(C, B) {
      const E = this.getOutput(C, u.BIP_32_DERIVATION, B);
      return this.decodeBip32Derivation(E);
    }
    setOutputAmount(C, B) {
      this.setOutput(C, u.AMOUNT, _(), j(B));
    }
    getOutputAmount(C) {
      const B = this.getOutput(C, u.AMOUNT, _());
      return (0, s.unsafeFrom64bitLE)(B);
    }
    setOutputScript(C, B) {
      this.setOutput(C, u.SCRIPT, _(), B);
    }
    getOutputScript(C) {
      return this.getOutput(C, u.SCRIPT, _());
    }
    setOutputTapBip32Derivation(C, B, E, y, v) {
      const S = this.encodeTapBip32Derivation(E, y, v);
      this.setOutput(C, u.TAP_BIP32_DERIVATION, B, S);
    }
    getOutputTapBip32Derivation(C, B) {
      const E = this.getOutput(C, u.TAP_BIP32_DERIVATION, B);
      return this.decodeTapBip32Derivation(E);
    }
    deleteInputEntries(C, B) {
      this.inputMaps[C].forEach((y, v, S) => {
        this.isKeyType(v, B) && S.delete(v);
      });
    }
    copy(C) {
      this.copyMap(this.globalMap, C.globalMap),
        this.copyMaps(this.inputMaps, C.inputMaps),
        this.copyMaps(this.outputMaps, C.outputMaps);
    }
    copyMaps(C, B) {
      C.forEach((E, y) => {
        const v = new Map();
        this.copyMap(E, v), (B[y] = v);
      });
    }
    copyMap(C, B) {
      C.forEach((E, y) => B.set(y, z.from(E)));
    }
    serialize() {
      const C = new s.BufferWriter();
      return (
        C.writeSlice(z.from([112, 115, 98, 116, 255])),
        A(C, this.globalMap),
        this.inputMaps.forEach((B) => {
          A(C, B);
        }),
        this.outputMaps.forEach((B) => {
          A(C, B);
        }),
        C.buffer()
      );
    }
    deserialize(C) {
      const B = new s.BufferReader(C);
      if (!B.readSlice(5).equals(l)) throw new Error('Invalid magic bytes');
      for (; this.readKeyPair(this.globalMap, B); );
      let E;
      try {
        E = this.getGlobalPsbtVersion();
      } catch {
        E = 0;
      }
      if (E !== 0 && E !== 2) throw new Error('Only PSBTs of version 0 or 2 are supported');
      let y, v;
      if (E == 0) {
        const S = this.getGlobal(a.UNSIGNED_TX),
          T = i.Transaction.fromBuffer(S);
        (y = T.ins.length), (v = T.outs.length);
      } else (y = this.getGlobalInputCount()), (v = this.getGlobalOutputCount());
      for (let S = 0; S < y; S++)
        for (this.inputMaps[S] = new Map(); this.readKeyPair(this.inputMaps[S], B); );
      for (let S = 0; S < v; S++)
        for (this.outputMaps[S] = new Map(); this.readKeyPair(this.outputMaps[S], B); );
      this.normalizeToV2();
    }
    normalizeToV2() {
      var C;
      const B =
        (C = this.getGlobalOptional(a.VERSION)) === null || C === void 0
          ? void 0
          : C.readInt32LE(0);
      if (B === 2) return;
      if (B !== void 0) throw new Error('Invalid or unsupported value for PSBT_GLOBAL_VERSION');
      const E = this.getGlobal(a.UNSIGNED_TX),
        y = i.Transaction.fromBuffer(E);
      this.setGlobalPsbtVersion(2),
        this.setGlobalTxVersion(y.version),
        this.setGlobalFallbackLocktime(y.locktime),
        this.setGlobalInputCount(y.ins.length),
        this.setGlobalOutputCount(y.outs.length);
      for (let v = 0; v < y.ins.length; v++)
        this.setInputPreviousTxId(v, y.ins[v].hash),
          this.setInputOutputIndex(v, y.ins[v].index),
          this.setInputSequence(v, y.ins[v].sequence);
      for (let v = 0; v < y.outs.length; v++)
        this.setOutputAmount(v, y.outs[v].value), this.setOutputScript(v, y.outs[v].script);
      this.globalMap.delete(a.UNSIGNED_TX.toString(16).padStart(2, '0'));
    }
    fromBitcoinJS(C) {
      function B(E) {
        let y;
        try {
          i.payments.p2tr({ output: E.witnessUtxo.script }), (y = !0);
        } catch {
          y = !1;
        }
        return (
          E &&
          !!(
            E.tapInternalKey ||
            E.tapMerkleRoot ||
            (E.tapLeafScript && E.tapLeafScript.length) ||
            (E.tapBip32Derivation && E.tapBip32Derivation.length) ||
            y
          )
        );
      }
      return (
        this.setGlobalPsbtVersion(2),
        this.setGlobalTxVersion(C.version),
        this.setGlobalInputCount(C.data.inputs.length),
        this.setGlobalOutputCount(C.txOutputs.length),
        C.locktime !== void 0 && this.setGlobalFallbackLocktime(C.locktime),
        C.data.inputs.forEach((E, y) => {
          if (B(E)) throw new Error('Taproot inputs not supported');
          this.setInputPreviousTxId(y, C.txInputs[y].hash),
            C.txInputs[y].sequence !== void 0 && this.setInputSequence(y, C.txInputs[y].sequence),
            this.setInputOutputIndex(y, C.txInputs[y].index),
            E.sighashType !== void 0 && this.setInputSighashType(y, E.sighashType),
            E.nonWitnessUtxo && this.setInputNonWitnessUtxo(y, E.nonWitnessUtxo),
            E.witnessUtxo && this.setInputWitnessUtxo(y, E.witnessUtxo.value, E.witnessUtxo.script),
            E.witnessScript && this.setInputWitnessScript(y, E.witnessScript),
            E.redeemScript && this.setInputRedeemScript(y, E.redeemScript),
            C.data.inputs[y].bip32Derivation.forEach((v) => {
              if (!/^m\//i.test(v.path)) throw new Error('Invalid input bip32 derivation');
              const S = v.path
                .replace(/m\//i, '')
                .split('/')
                .map((T) => (T.match(/['h]/i) ? parseInt(T) + 2147483648 : Number(T)));
              this.setInputBip32Derivation(y, v.pubkey, v.masterFingerprint, S);
            });
        }),
        C.txOutputs.forEach((E, y) => {
          this.setOutputAmount(y, E.value), this.setOutputScript(y, E.script);
        }),
        this
      );
    }
    readKeyPair(C, B) {
      const E = (0, o.sanitizeBigintToNumber)(B.readVarInt());
      if (E == 0) return !1;
      const y = B.readUInt8(),
        v = B.readSlice(E - 1),
        S = B.readVarSlice();
      return x(C, y, v, S), !0;
    }
    getKeyDatas(C, B) {
      const E = [];
      return (
        C.forEach((y, v) => {
          this.isKeyType(v, [B]) && E.push(z.from(v.substring(2), 'hex'));
        }),
        E
      );
    }
    isKeyType(C, B) {
      const E = z.from(C.substring(0, 2), 'hex').readUInt8(0);
      return B.some((y) => y == E);
    }
    setGlobal(C, B) {
      const E = new p(C, z.from([]));
      this.globalMap.set(E.toString(), B);
    }
    getGlobal(C) {
      return h(this.globalMap, C, _(), !1);
    }
    getGlobalOptional(C) {
      return h(this.globalMap, C, _(), !0);
    }
    setInput(C, B, E, y) {
      x(this.getMap(C, this.inputMaps), B, E, y);
    }
    getInput(C, B, E) {
      return h(this.inputMaps[C], B, E, !1);
    }
    getInputOptional(C, B, E) {
      return h(this.inputMaps[C], B, E, !0);
    }
    setOutput(C, B, E, y) {
      x(this.getMap(C, this.outputMaps), B, E, y);
    }
    getOutput(C, B, E) {
      return h(this.outputMaps[C], B, E, !1);
    }
    getMap(C, B) {
      return B[C] ? B[C] : (B[C] = new Map());
    }
    encodeBip32Derivation(C, B) {
      const E = new s.BufferWriter();
      return this.writeBip32Derivation(E, C, B), E.buffer();
    }
    decodeBip32Derivation(C) {
      const B = new s.BufferReader(C);
      return this.readBip32Derivation(B);
    }
    writeBip32Derivation(C, B, E) {
      C.writeSlice(B),
        E.forEach((y) => {
          C.writeUInt32(y);
        });
    }
    readBip32Derivation(C) {
      const B = C.readSlice(4),
        E = [];
      for (; C.offset < C.buffer.length; ) E.push(C.readUInt32());
      return { masterFingerprint: B, path: E };
    }
    encodeTapBip32Derivation(C, B, E) {
      const y = new s.BufferWriter();
      return (
        y.writeVarInt(C.length),
        C.forEach((v) => {
          y.writeSlice(v);
        }),
        this.writeBip32Derivation(y, B, E),
        y.buffer()
      );
    }
    decodeTapBip32Derivation(C) {
      const B = new s.BufferReader(C),
        E = (0, o.sanitizeBigintToNumber)(B.readVarInt()),
        y = [];
      for (let S = 0; S < E; S++) y.push(B.readSlice(32));
      const v = this.readBip32Derivation(B);
      return Object.assign({ hashes: y }, v);
    }
  }
  e.PsbtV2 = f;
  function h(D, C, B, E) {
    if (!D) throw Error('No such map');
    const y = new p(C, B),
      v = D.get(y.toString());
    if (!v) {
      if (E) return;
      throw new d(y.toString());
    }
    return z.from(v);
  }
  class p {
    constructor(C, B) {
      (this.keyType = C), (this.keyData = B);
    }
    toString() {
      const C = new s.BufferWriter();
      return this.toBuffer(C), C.buffer().toString('hex');
    }
    serialize(C) {
      C.writeVarInt(1 + this.keyData.length), this.toBuffer(C);
    }
    toBuffer(C) {
      C.writeUInt8(this.keyType), C.writeSlice(this.keyData);
    }
  }
  class b {
    constructor(C, B) {
      (this.key = C), (this.value = B);
    }
    serialize(C) {
      this.key.serialize(C), C.writeVarSlice(this.value);
    }
  }
  function w(D) {
    return new p(D.readUInt8(0), D.slice(1));
  }
  function A(D, C) {
    for (let [B, E] of [...C].sort(([y], [v]) => y.localeCompare(v)))
      new b(w(z.from(B, 'hex')), E).serialize(D);
    D.writeUInt8(0);
  }
  function _() {
    return z.from([]);
  }
  function x(D, C, B, E) {
    const y = new p(C, B);
    D.set(y.toString(), E);
  }
  function k(D) {
    const C = z.alloc(4);
    return C.writeUInt32LE(D, 0), C;
  }
  function j(D) {
    return (0, s.unsafeTo64bitLE)(D);
  }
  function F(D) {
    const C = new s.BufferWriter();
    return C.writeVarInt(D), C.buffer();
  }
  function K(D) {
    return (0, o.sanitizeBigintToNumber)(new s.BufferReader(D).readVarInt());
  }
})(N1);
Object.defineProperty(D1, '__esModule', { value: !0 });
D1.MerkelizedPsbt = void 0;
const YSe = R1,
  ZSe = N1;
class Gl extends ZSe.PsbtV2 {
  constructor(t) {
    super(),
      (this.inputMerkleMaps = []),
      (this.outputMerkleMaps = []),
      t.copy(this),
      (this.globalMerkleMap = Gl.createMerkleMap(this.globalMap));
    for (let n = 0; n < this.getGlobalInputCount(); n++)
      this.inputMerkleMaps.push(Gl.createMerkleMap(this.inputMaps[n]));
    this.inputMapCommitments = [...this.inputMerkleMaps.values()].map((n) => n.commitment());
    for (let n = 0; n < this.getGlobalOutputCount(); n++)
      this.outputMerkleMaps.push(Gl.createMerkleMap(this.outputMaps[n]));
    this.outputMapCommitments = [...this.outputMerkleMaps.values()].map((n) => n.commitment());
  }
  getGlobalSize() {
    return this.globalMap.size;
  }
  getGlobalKeysValuesRoot() {
    return this.globalMerkleMap.commitment();
  }
  static createMerkleMap(t) {
    const n = [...t.keys()].sort(),
      r = n.map((s) => {
        const o = t.get(s);
        if (!o) throw new Error('No value for key ' + s);
        return o;
      }),
      i = n.map((s) => z.from(s, 'hex'));
    return new YSe.MerkleMap(i, r);
  }
}
D1.MerkelizedPsbt = Gl;
Object.defineProperty(mc, '__esModule', { value: !0 });
mc.AppClient = mc.PartialSignature = void 0;
const Cg = ar,
  Pg = kr,
  JSe = D1,
  Uc = co,
  XSe = N1,
  Tl = pi,
  QSe = 225,
  eEe = 248,
  tEe = 1;
var Go;
(function (e) {
  (e[(e.GET_PUBKEY = 0)] = 'GET_PUBKEY'),
    (e[(e.REGISTER_WALLET = 2)] = 'REGISTER_WALLET'),
    (e[(e.GET_WALLET_ADDRESS = 3)] = 'GET_WALLET_ADDRESS'),
    (e[(e.SIGN_PSBT = 4)] = 'SIGN_PSBT'),
    (e[(e.GET_MASTER_FINGERPRINT = 5)] = 'GET_MASTER_FINGERPRINT'),
    (e[(e.SIGN_MESSAGE = 16)] = 'SIGN_MESSAGE');
})(Go || (Go = {}));
var KE;
(function (e) {
  e[(e.CONTINUE_INTERRUPTED = 1)] = 'CONTINUE_INTERRUPTED';
})(KE || (KE = {}));
class VE {
  constructor(t, n, r) {
    (this.pubkey = t), (this.signature = n), (this.tapleafHash = r);
  }
}
mc.PartialSignature = VE;
function nEe(e, t) {
  if (e.length == 64) return new VE(e.slice(0, 32), t, e.slice(32, 64));
  if (e.length == 32 || e.length == 33) return new VE(e, t);
  throw new Error(`Invalid length for pubkeyAugm: ${e.length} bytes.`);
}
function rEe(e) {
  return (e.match(/[asctdvjnlu]+:/g) || []).some((n) => n.includes('a'));
}
class xN {
  constructor(t) {
    this.transport = t;
  }
  async makeRequest(t, n, r) {
    let i = await this.transport.send(QSe, t, 0, tEe, n, [36864, 57344]);
    for (; i.readUInt16BE(i.length - 2) === 57344; ) {
      if (!r) throw new Error('Unexpected SW_INTERRUPTED_EXECUTION');
      const s = i.slice(0, -2),
        o = r.execute(s);
      i = await this.transport.send(eEe, KE.CONTINUE_INTERRUPTED, 0, 0, o, [36864, 57344]);
    }
    return i.slice(0, -2);
  }
  async getAppAndVersion() {
    const t = await this.transport.send(176, 1, 0, 0);
    let n = 0;
    if (t[n++] !== 1) throw new Error('Unexpected response');
    const i = t[n++],
      s = t.slice(n, (n += i)).toString('ascii'),
      o = t[n++],
      a = t.slice(n, (n += o)).toString('ascii'),
      c = t[n++],
      u = t.slice(n, (n += c));
    return { name: s, version: a, flags: u };
  }
  async getExtendedPubkey(t, n = !1) {
    const r = (0, Cg.pathStringToArray)(t);
    if (r.length > 6) throw new Error('Path too long. At most 6 levels allowed.');
    return (
      await this.makeRequest(
        Go.GET_PUBKEY,
        z.concat([z.from(n ? [1] : [0]), (0, Cg.pathElementsToBuffer)(r)])
      )
    ).toString('ascii');
  }
  async registerWallet(t) {
    await this.validatePolicy(t);
    const n = new Pg.ClientCommandInterpreter();
    n.addKnownWalletPolicy(t);
    const r = t.serialize(),
      i = await this.makeRequest(
        Go.REGISTER_WALLET,
        z.concat([(0, Tl.createVarint)(r.length), r]),
        n
      );
    if (i.length != 64) throw Error(`Invalid response length. Expected 64 bytes, got ${i.length}`);
    return [i.subarray(0, 32), i.subarray(32)];
  }
  async getWalletAddress(t, n, r, i, s) {
    if (r !== 0 && r !== 1) throw new Error('Change can only be 0 or 1');
    if (i < 0 || !Number.isInteger(i)) throw new Error('Invalid address index');
    if (n != null && n.length != 32) throw new Error('Invalid HMAC length');
    await this.validatePolicy(t);
    const o = new Pg.ClientCommandInterpreter();
    o.addKnownWalletPolicy(t);
    const a = z.alloc(4);
    return (
      a.writeUInt32BE(i, 0),
      (
        await this.makeRequest(
          Go.GET_WALLET_ADDRESS,
          z.concat([z.from(s ? [1] : [0]), t.getId(), n || z.alloc(32, 0), z.from([r]), a]),
          o
        )
      ).toString('ascii')
    );
  }
  async signPsbt(t, n, r, i) {
    if (
      (await this.validatePolicy(n),
      typeof t == 'string' && (t = z.from(t, 'base64')),
      z.isBuffer(t))
    ) {
      const d = new XSe.PsbtV2();
      d.deserialize(t), (t = d);
    }
    const s = new JSe.MerkelizedPsbt(t);
    if (r != null && r.length != 32) throw new Error('Invalid HMAC length');
    const o = new Pg.ClientCommandInterpreter(i);
    o.addKnownWalletPolicy(n), o.addKnownMapping(s.globalMerkleMap);
    for (const d of s.inputMerkleMaps) o.addKnownMapping(d);
    for (const d of s.outputMerkleMaps) o.addKnownMapping(d);
    o.addKnownList(s.inputMapCommitments);
    const a = new Uc.Merkle(s.inputMapCommitments.map((d) => (0, Uc.hashLeaf)(d))).getRoot();
    o.addKnownList(s.outputMapCommitments);
    const c = new Uc.Merkle(s.outputMapCommitments.map((d) => (0, Uc.hashLeaf)(d))).getRoot();
    await this.makeRequest(
      Go.SIGN_PSBT,
      z.concat([
        s.getGlobalKeysValuesRoot(),
        (0, Tl.createVarint)(s.getGlobalInputCount()),
        a,
        (0, Tl.createVarint)(s.getGlobalOutputCount()),
        c,
        n.getId(),
        r || z.alloc(32, 0),
      ]),
      o
    );
    const u = o.getYielded(),
      l = [];
    for (const d of u) {
      const [f, h] = (0, Tl.parseVarint)(d, 0),
        p = d[h],
        b = d.subarray(h + 1, h + 1 + p),
        w = d.subarray(h + 1 + p),
        A = nEe(b, w);
      l.push([Number(f), A]);
    }
    return l;
  }
  async getMasterFingerprint() {
    return (await this.makeRequest(Go.GET_MASTER_FINGERPRINT, z.from([]))).toString('hex');
  }
  async signMessage(t, n) {
    const r = (0, Cg.pathStringToArray)(n),
      i = new Pg.ClientCommandInterpreter(),
      s = Math.ceil(t.length / 64),
      o = [];
    for (let u = 0; u < s; u++) o.push(t.subarray(64 * u, 64 * u + 64));
    i.addKnownList(o);
    const a = new Uc.Merkle(o.map((u) => (0, Uc.hashLeaf)(u))).getRoot();
    return (
      await this.makeRequest(
        Go.SIGN_MESSAGE,
        z.concat([(0, Cg.pathElementsToBuffer)(r), (0, Tl.createVarint)(t.length), a]),
        i
      )
    ).toString('base64');
  }
  async validatePolicy(t) {
    if (rEe(t.descriptorTemplate)) {
      const n = await this.getAppAndVersion();
      if (['2.1.0', '2.1.1'].includes(n.version))
        throw new Error('Please update your Ledger Bitcoin app.');
    }
  }
}
mc.AppClient = xN;
mc.default = xN;
var ju = {};
Object.defineProperty(ju, '__esModule', { value: !0 });
ju.DefaultWalletPolicy = ju.WalletPolicy = void 0;
const M8 = bi,
  iEe = fi,
  O8 = co,
  sEe = 2;
class kN {
  constructor(t, n, r) {
    (this.name = t), (this.descriptorTemplate = n), (this.keys = r);
  }
  getId() {
    return M8.crypto.sha256(this.serialize());
  }
  serialize() {
    const t = this.keys.map((i) => z.from(i, 'ascii')),
      n = new O8.Merkle(t.map((i) => (0, O8.hashLeaf)(i))),
      r = new iEe.BufferWriter();
    return (
      r.writeUInt8(sEe),
      r.writeVarSlice(z.from(this.name, 'ascii')),
      r.writeVarInt(this.descriptorTemplate.length),
      r.writeSlice(M8.crypto.sha256(z.from(this.descriptorTemplate))),
      r.writeVarInt(this.keys.length),
      r.writeSlice(n.getRoot()),
      r.buffer()
    );
  }
}
ju.WalletPolicy = kN;
class oEe extends kN {
  constructor(t, n) {
    super('', t, [n]);
  }
}
ju.DefaultWalletPolicy = oEe;
(function (e) {
  var t =
    (m && m.__importDefault) ||
    function (s) {
      return s && s.__esModule ? s : { default: s };
    };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.WalletPolicy = e.DefaultWalletPolicy = e.PsbtV2 = e.AppClient = void 0);
  const n = t(mc);
  e.AppClient = n.default;
  const r = ju;
  Object.defineProperty(e, 'DefaultWalletPolicy', {
    enumerable: !0,
    get: function () {
      return r.DefaultWalletPolicy;
    },
  }),
    Object.defineProperty(e, 'WalletPolicy', {
      enumerable: !0,
      get: function () {
        return r.WalletPolicy;
      },
    });
  const i = N1;
  Object.defineProperty(e, 'PsbtV2', {
    enumerable: !0,
    get: function () {
      return i.PsbtV2;
    },
  }),
    (e.default = n.default);
})(ISe);
var B8 = function (e, t) {
    var n = typeof Symbol == 'function' && e[Symbol.iterator];
    if (!n) return e;
    var r = n.call(e),
      i,
      s = [],
      o;
    try {
      for (; (t === void 0 || t-- > 0) && !(i = r.next()).done; ) s.push(i.value);
    } catch (a) {
      o = { error: a };
    } finally {
      try {
        i && !i.done && (n = r.return) && n.call(r);
      } finally {
        if (o) throw o.error;
      }
    }
    return s;
  },
  D8 = function (e, t, n) {
    if (n || arguments.length === 2)
      for (var r = 0, i = t.length, s; r < i; r++)
        (s || !(r in t)) && (s || (s = Array.prototype.slice.call(t, 0, r)), (s[r] = t[r]));
    return e.concat(s || Array.prototype.slice.call(t));
  },
  WE;
(function (e) {
  (e.APPROVE = '0x095ea7b3'), (e.TRANSFER = '0xa9059cbb');
})(WE || (WE = {}));
var HE;
(function (e) {
  (e.APPROVE = '0x095ea7b3'),
    (e.SET_APPROVAL_FOR_ALL = '0xa22cb465'),
    (e.TRANSFER_FROM = '0x23b872dd'),
    (e.SAFE_TRANSFER_FROM = '0x42842e0e'),
    (e.SAFE_TRANSFER_FROM_WITH_DATA = '0xb88d4fde');
})(HE || (HE = {}));
var GE;
(function (e) {
  (e.SET_APPROVAL_FOR_ALL = '0xa22cb465'),
    (e.SAFE_TRANSFER_FROM = '0xf242432a'),
    (e.SAFE_BATCH_TRANSFER_FROM = '0x2eb2c2d6');
})(GE || (GE = {}));
Object.values(WE);
D8(D8([], B8(Object.values(HE)), !1), B8(Object.values(GE)), !1);
var aEe = 0,
  qo = [],
  R8 = function (e, t, n) {
    var r = { type: e, id: String(++aEe), date: new Date() };
    t && (r.message = t), n && (r.data = n), uEe(r);
  },
  cEe = function (e) {
    return (
      qo.push(e),
      function () {
        var t = qo.indexOf(e);
        t !== -1 && ((qo[t] = qo[qo.length - 1]), qo.pop());
      }
    );
  };
function uEe(e) {
  for (var t = 0; t < qo.length; t++)
    try {
      qo[t](e);
    } catch (n) {
      console.error(n);
    }
}
typeof window < 'u' && (window.__ledgerLogsListen = cEe);
var CN = { exports: {} },
  PN = function (t, n) {
    return function () {
      for (var i = new Array(arguments.length), s = 0; s < i.length; s++) i[s] = arguments[s];
      return t.apply(n, i);
    };
  },
  lEe = PN,
  Ea = Object.prototype.toString;
function TT(e) {
  return Array.isArray(e);
}
function qE(e) {
  return typeof e > 'u';
}
function dEe(e) {
  return (
    e !== null &&
    !qE(e) &&
    e.constructor !== null &&
    !qE(e.constructor) &&
    typeof e.constructor.isBuffer == 'function' &&
    e.constructor.isBuffer(e)
  );
}
function MN(e) {
  return Ea.call(e) === '[object ArrayBuffer]';
}
function fEe(e) {
  return Ea.call(e) === '[object FormData]';
}
function hEe(e) {
  var t;
  return (
    typeof ArrayBuffer < 'u' && ArrayBuffer.isView
      ? (t = ArrayBuffer.isView(e))
      : (t = e && e.buffer && MN(e.buffer)),
    t
  );
}
function pEe(e) {
  return typeof e == 'string';
}
function gEe(e) {
  return typeof e == 'number';
}
function ON(e) {
  return e !== null && typeof e == 'object';
}
function hy(e) {
  if (Ea.call(e) !== '[object Object]') return !1;
  var t = Object.getPrototypeOf(e);
  return t === null || t === Object.prototype;
}
function yEe(e) {
  return Ea.call(e) === '[object Date]';
}
function bEe(e) {
  return Ea.call(e) === '[object File]';
}
function mEe(e) {
  return Ea.call(e) === '[object Blob]';
}
function BN(e) {
  return Ea.call(e) === '[object Function]';
}
function wEe(e) {
  return ON(e) && BN(e.pipe);
}
function vEe(e) {
  return Ea.call(e) === '[object URLSearchParams]';
}
function _Ee(e) {
  return e.trim ? e.trim() : e.replace(/^\s+|\s+$/g, '');
}
function SEe() {
  return typeof navigator < 'u' &&
    (navigator.product === 'ReactNative' ||
      navigator.product === 'NativeScript' ||
      navigator.product === 'NS')
    ? !1
    : typeof window < 'u' && typeof document < 'u';
}
function xT(e, t) {
  if (!(e === null || typeof e > 'u'))
    if ((typeof e != 'object' && (e = [e]), TT(e)))
      for (var n = 0, r = e.length; n < r; n++) t.call(null, e[n], n, e);
    else for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.call(null, e[i], i, e);
}
function YE() {
  var e = {};
  function t(i, s) {
    hy(e[s]) && hy(i)
      ? (e[s] = YE(e[s], i))
      : hy(i)
        ? (e[s] = YE({}, i))
        : TT(i)
          ? (e[s] = i.slice())
          : (e[s] = i);
  }
  for (var n = 0, r = arguments.length; n < r; n++) xT(arguments[n], t);
  return e;
}
function EEe(e, t, n) {
  return (
    xT(t, function (i, s) {
      n && typeof i == 'function' ? (e[s] = lEe(i, n)) : (e[s] = i);
    }),
    e
  );
}
function AEe(e) {
  return e.charCodeAt(0) === 65279 && (e = e.slice(1)), e;
}
var Dr = {
    isArray: TT,
    isArrayBuffer: MN,
    isBuffer: dEe,
    isFormData: fEe,
    isArrayBufferView: hEe,
    isString: pEe,
    isNumber: gEe,
    isObject: ON,
    isPlainObject: hy,
    isUndefined: qE,
    isDate: yEe,
    isFile: bEe,
    isBlob: mEe,
    isFunction: BN,
    isStream: wEe,
    isURLSearchParams: vEe,
    isStandardBrowserEnv: SEe,
    forEach: xT,
    merge: YE,
    extend: EEe,
    trim: _Ee,
    stripBOM: AEe,
  },
  $c = Dr;
function N8(e) {
  return encodeURIComponent(e)
    .replace(/%3A/gi, ':')
    .replace(/%24/g, '$')
    .replace(/%2C/gi, ',')
    .replace(/%20/g, '+')
    .replace(/%5B/gi, '[')
    .replace(/%5D/gi, ']');
}
var DN = function (t, n, r) {
    if (!n) return t;
    var i;
    if (r) i = r(n);
    else if ($c.isURLSearchParams(n)) i = n.toString();
    else {
      var s = [];
      $c.forEach(n, function (c, u) {
        c === null ||
          typeof c > 'u' ||
          ($c.isArray(c) ? (u = u + '[]') : (c = [c]),
          $c.forEach(c, function (d) {
            $c.isDate(d) ? (d = d.toISOString()) : $c.isObject(d) && (d = JSON.stringify(d)),
              s.push(N8(u) + '=' + N8(d));
          }));
      }),
        (i = s.join('&'));
    }
    if (i) {
      var o = t.indexOf('#');
      o !== -1 && (t = t.slice(0, o)), (t += (t.indexOf('?') === -1 ? '?' : '&') + i);
    }
    return t;
  },
  IEe = Dr;
function j1() {
  this.handlers = [];
}
j1.prototype.use = function (t, n, r) {
  return (
    this.handlers.push({
      fulfilled: t,
      rejected: n,
      synchronous: r ? r.synchronous : !1,
      runWhen: r ? r.runWhen : null,
    }),
    this.handlers.length - 1
  );
};
j1.prototype.eject = function (t) {
  this.handlers[t] && (this.handlers[t] = null);
};
j1.prototype.forEach = function (t) {
  IEe.forEach(this.handlers, function (r) {
    r !== null && t(r);
  });
};
var TEe = j1,
  xEe = Dr,
  kEe = function (t, n) {
    xEe.forEach(t, function (i, s) {
      s !== n && s.toUpperCase() === n.toUpperCase() && ((t[n] = i), delete t[s]);
    });
  },
  RN = function (t, n, r, i, s) {
    return (
      (t.config = n),
      r && (t.code = r),
      (t.request = i),
      (t.response = s),
      (t.isAxiosError = !0),
      (t.toJSON = function () {
        return {
          message: this.message,
          name: this.name,
          description: this.description,
          number: this.number,
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null,
        };
      }),
      t
    );
  },
  NN = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 },
  w_,
  j8;
function jN() {
  if (j8) return w_;
  j8 = 1;
  var e = RN;
  return (
    (w_ = function (n, r, i, s, o) {
      var a = new Error(n);
      return e(a, r, i, s, o);
    }),
    w_
  );
}
var v_, L8;
function CEe() {
  if (L8) return v_;
  L8 = 1;
  var e = jN();
  return (
    (v_ = function (n, r, i) {
      var s = i.config.validateStatus;
      !i.status || !s || s(i.status)
        ? n(i)
        : r(e('Request failed with status code ' + i.status, i.config, null, i.request, i));
    }),
    v_
  );
}
var __, U8;
function PEe() {
  if (U8) return __;
  U8 = 1;
  var e = Dr;
  return (
    (__ = e.isStandardBrowserEnv()
      ? (function () {
          return {
            write: function (r, i, s, o, a, c) {
              var u = [];
              u.push(r + '=' + encodeURIComponent(i)),
                e.isNumber(s) && u.push('expires=' + new Date(s).toGMTString()),
                e.isString(o) && u.push('path=' + o),
                e.isString(a) && u.push('domain=' + a),
                c === !0 && u.push('secure'),
                (document.cookie = u.join('; '));
            },
            read: function (r) {
              var i = document.cookie.match(new RegExp('(^|;\\s*)(' + r + ')=([^;]*)'));
              return i ? decodeURIComponent(i[3]) : null;
            },
            remove: function (r) {
              this.write(r, '', Date.now() - 864e5);
            },
          };
        })()
      : (function () {
          return {
            write: function () {},
            read: function () {
              return null;
            },
            remove: function () {},
          };
        })()),
    __
  );
}
var S_, $8;
function MEe() {
  return (
    $8 ||
      (($8 = 1),
      (S_ = function (t) {
        return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t);
      })),
    S_
  );
}
var E_, F8;
function OEe() {
  return (
    F8 ||
      ((F8 = 1),
      (E_ = function (t, n) {
        return n ? t.replace(/\/+$/, '') + '/' + n.replace(/^\/+/, '') : t;
      })),
    E_
  );
}
var A_, z8;
function BEe() {
  if (z8) return A_;
  z8 = 1;
  var e = MEe(),
    t = OEe();
  return (
    (A_ = function (r, i) {
      return r && !e(i) ? t(r, i) : i;
    }),
    A_
  );
}
var I_, K8;
function DEe() {
  if (K8) return I_;
  K8 = 1;
  var e = Dr,
    t = [
      'age',
      'authorization',
      'content-length',
      'content-type',
      'etag',
      'expires',
      'from',
      'host',
      'if-modified-since',
      'if-unmodified-since',
      'last-modified',
      'location',
      'max-forwards',
      'proxy-authorization',
      'referer',
      'retry-after',
      'user-agent',
    ];
  return (
    (I_ = function (r) {
      var i = {},
        s,
        o,
        a;
      return (
        r &&
          e.forEach(
            r.split(`
`),
            function (u) {
              if (
                ((a = u.indexOf(':')),
                (s = e.trim(u.substr(0, a)).toLowerCase()),
                (o = e.trim(u.substr(a + 1))),
                s)
              ) {
                if (i[s] && t.indexOf(s) >= 0) return;
                s === 'set-cookie'
                  ? (i[s] = (i[s] ? i[s] : []).concat([o]))
                  : (i[s] = i[s] ? i[s] + ', ' + o : o);
              }
            }
          ),
        i
      );
    }),
    I_
  );
}
var T_, V8;
function REe() {
  if (V8) return T_;
  V8 = 1;
  var e = Dr;
  return (
    (T_ = e.isStandardBrowserEnv()
      ? (function () {
          var n = /(msie|trident)/i.test(navigator.userAgent),
            r = document.createElement('a'),
            i;
          function s(o) {
            var a = o;
            return (
              n && (r.setAttribute('href', a), (a = r.href)),
              r.setAttribute('href', a),
              {
                href: r.href,
                protocol: r.protocol ? r.protocol.replace(/:$/, '') : '',
                host: r.host,
                search: r.search ? r.search.replace(/^\?/, '') : '',
                hash: r.hash ? r.hash.replace(/^#/, '') : '',
                hostname: r.hostname,
                port: r.port,
                pathname: r.pathname.charAt(0) === '/' ? r.pathname : '/' + r.pathname,
              }
            );
          }
          return (
            (i = s(window.location.href)),
            function (a) {
              var c = e.isString(a) ? s(a) : a;
              return c.protocol === i.protocol && c.host === i.host;
            }
          );
        })()
      : (function () {
          return function () {
            return !0;
          };
        })()),
    T_
  );
}
var x_, W8;
function L1() {
  if (W8) return x_;
  W8 = 1;
  function e(t) {
    this.message = t;
  }
  return (
    (e.prototype.toString = function () {
      return 'Cancel' + (this.message ? ': ' + this.message : '');
    }),
    (e.prototype.__CANCEL__ = !0),
    (x_ = e),
    x_
  );
}
var k_, H8;
function G8() {
  if (H8) return k_;
  H8 = 1;
  var e = Dr,
    t = CEe(),
    n = PEe(),
    r = DN,
    i = BEe(),
    s = DEe(),
    o = REe(),
    a = jN(),
    c = NN,
    u = L1();
  return (
    (k_ = function (d) {
      return new Promise(function (h, p) {
        var b = d.data,
          w = d.headers,
          A = d.responseType,
          _;
        function x() {
          d.cancelToken && d.cancelToken.unsubscribe(_),
            d.signal && d.signal.removeEventListener('abort', _);
        }
        e.isFormData(b) && delete w['Content-Type'];
        var k = new XMLHttpRequest();
        if (d.auth) {
          var j = d.auth.username || '',
            F = d.auth.password ? unescape(encodeURIComponent(d.auth.password)) : '';
          w.Authorization = 'Basic ' + btoa(j + ':' + F);
        }
        var K = i(d.baseURL, d.url);
        k.open(d.method.toUpperCase(), r(K, d.params, d.paramsSerializer), !0),
          (k.timeout = d.timeout);
        function D() {
          if (k) {
            var B = 'getAllResponseHeaders' in k ? s(k.getAllResponseHeaders()) : null,
              E = !A || A === 'text' || A === 'json' ? k.responseText : k.response,
              y = {
                data: E,
                status: k.status,
                statusText: k.statusText,
                headers: B,
                config: d,
                request: k,
              };
            t(
              function (S) {
                h(S), x();
              },
              function (S) {
                p(S), x();
              },
              y
            ),
              (k = null);
          }
        }
        if (
          ('onloadend' in k
            ? (k.onloadend = D)
            : (k.onreadystatechange = function () {
                !k ||
                  k.readyState !== 4 ||
                  (k.status === 0 && !(k.responseURL && k.responseURL.indexOf('file:') === 0)) ||
                  setTimeout(D);
              }),
          (k.onabort = function () {
            k && (p(a('Request aborted', d, 'ECONNABORTED', k)), (k = null));
          }),
          (k.onerror = function () {
            p(a('Network Error', d, null, k)), (k = null);
          }),
          (k.ontimeout = function () {
            var E = d.timeout ? 'timeout of ' + d.timeout + 'ms exceeded' : 'timeout exceeded',
              y = d.transitional || c;
            d.timeoutErrorMessage && (E = d.timeoutErrorMessage),
              p(a(E, d, y.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED', k)),
              (k = null);
          }),
          e.isStandardBrowserEnv())
        ) {
          var C =
            (d.withCredentials || o(K)) && d.xsrfCookieName ? n.read(d.xsrfCookieName) : void 0;
          C && (w[d.xsrfHeaderName] = C);
        }
        'setRequestHeader' in k &&
          e.forEach(w, function (E, y) {
            typeof b > 'u' && y.toLowerCase() === 'content-type'
              ? delete w[y]
              : k.setRequestHeader(y, E);
          }),
          e.isUndefined(d.withCredentials) || (k.withCredentials = !!d.withCredentials),
          A && A !== 'json' && (k.responseType = d.responseType),
          typeof d.onDownloadProgress == 'function' &&
            k.addEventListener('progress', d.onDownloadProgress),
          typeof d.onUploadProgress == 'function' &&
            k.upload &&
            k.upload.addEventListener('progress', d.onUploadProgress),
          (d.cancelToken || d.signal) &&
            ((_ = function (B) {
              k && (p(!B || (B && B.type) ? new u('canceled') : B), k.abort(), (k = null));
            }),
            d.cancelToken && d.cancelToken.subscribe(_),
            d.signal && (d.signal.aborted ? _() : d.signal.addEventListener('abort', _))),
          b || (b = null),
          k.send(b);
      });
    }),
    k_
  );
}
var Yn = Dr,
  q8 = kEe,
  NEe = RN,
  jEe = NN,
  LEe = { 'Content-Type': 'application/x-www-form-urlencoded' };
function Y8(e, t) {
  !Yn.isUndefined(e) && Yn.isUndefined(e['Content-Type']) && (e['Content-Type'] = t);
}
function UEe() {
  var e;
  return (
    (typeof XMLHttpRequest < 'u' ||
      (typeof hu < 'u' && Object.prototype.toString.call(hu) === '[object process]')) &&
      (e = G8()),
    e
  );
}
function $Ee(e, t, n) {
  if (Yn.isString(e))
    try {
      return (t || JSON.parse)(e), Yn.trim(e);
    } catch (r) {
      if (r.name !== 'SyntaxError') throw r;
    }
  return (n || JSON.stringify)(e);
}
var U1 = {
  transitional: jEe,
  adapter: UEe(),
  transformRequest: [
    function (t, n) {
      return (
        q8(n, 'Accept'),
        q8(n, 'Content-Type'),
        Yn.isFormData(t) ||
        Yn.isArrayBuffer(t) ||
        Yn.isBuffer(t) ||
        Yn.isStream(t) ||
        Yn.isFile(t) ||
        Yn.isBlob(t)
          ? t
          : Yn.isArrayBufferView(t)
            ? t.buffer
            : Yn.isURLSearchParams(t)
              ? (Y8(n, 'application/x-www-form-urlencoded;charset=utf-8'), t.toString())
              : Yn.isObject(t) || (n && n['Content-Type'] === 'application/json')
                ? (Y8(n, 'application/json'), $Ee(t))
                : t
      );
    },
  ],
  transformResponse: [
    function (t) {
      var n = this.transitional || U1.transitional,
        r = n && n.silentJSONParsing,
        i = n && n.forcedJSONParsing,
        s = !r && this.responseType === 'json';
      if (s || (i && Yn.isString(t) && t.length))
        try {
          return JSON.parse(t);
        } catch (o) {
          if (s) throw o.name === 'SyntaxError' ? NEe(o, this, 'E_JSON_PARSE') : o;
        }
      return t;
    },
  ],
  timeout: 0,
  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',
  maxContentLength: -1,
  maxBodyLength: -1,
  validateStatus: function (t) {
    return t >= 200 && t < 300;
  },
  headers: { common: { Accept: 'application/json, text/plain, */*' } },
};
Yn.forEach(['delete', 'get', 'head'], function (t) {
  U1.headers[t] = {};
});
Yn.forEach(['post', 'put', 'patch'], function (t) {
  U1.headers[t] = Yn.merge(LEe);
});
var kT = U1,
  FEe = Dr,
  zEe = kT,
  KEe = function (t, n, r) {
    var i = this || zEe;
    return (
      FEe.forEach(r, function (o) {
        t = o.call(i, t, n);
      }),
      t
    );
  },
  C_,
  Z8;
function LN() {
  return (
    Z8 ||
      ((Z8 = 1),
      (C_ = function (t) {
        return !!(t && t.__CANCEL__);
      })),
    C_
  );
}
var J8 = Dr,
  P_ = KEe,
  VEe = LN(),
  WEe = kT,
  HEe = L1();
function M_(e) {
  if ((e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted))
    throw new HEe('canceled');
}
var GEe = function (t) {
    M_(t),
      (t.headers = t.headers || {}),
      (t.data = P_.call(t, t.data, t.headers, t.transformRequest)),
      (t.headers = J8.merge(t.headers.common || {}, t.headers[t.method] || {}, t.headers)),
      J8.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function (i) {
        delete t.headers[i];
      });
    var n = t.adapter || WEe.adapter;
    return n(t).then(
      function (i) {
        return M_(t), (i.data = P_.call(t, i.data, i.headers, t.transformResponse)), i;
      },
      function (i) {
        return (
          VEe(i) ||
            (M_(t),
            i &&
              i.response &&
              (i.response.data = P_.call(
                t,
                i.response.data,
                i.response.headers,
                t.transformResponse
              ))),
          Promise.reject(i)
        );
      }
    );
  },
  jr = Dr,
  UN = function (t, n) {
    n = n || {};
    var r = {};
    function i(l, d) {
      return jr.isPlainObject(l) && jr.isPlainObject(d)
        ? jr.merge(l, d)
        : jr.isPlainObject(d)
          ? jr.merge({}, d)
          : jr.isArray(d)
            ? d.slice()
            : d;
    }
    function s(l) {
      if (jr.isUndefined(n[l])) {
        if (!jr.isUndefined(t[l])) return i(void 0, t[l]);
      } else return i(t[l], n[l]);
    }
    function o(l) {
      if (!jr.isUndefined(n[l])) return i(void 0, n[l]);
    }
    function a(l) {
      if (jr.isUndefined(n[l])) {
        if (!jr.isUndefined(t[l])) return i(void 0, t[l]);
      } else return i(void 0, n[l]);
    }
    function c(l) {
      if (l in n) return i(t[l], n[l]);
      if (l in t) return i(void 0, t[l]);
    }
    var u = {
      url: o,
      method: o,
      data: o,
      baseURL: a,
      transformRequest: a,
      transformResponse: a,
      paramsSerializer: a,
      timeout: a,
      timeoutMessage: a,
      withCredentials: a,
      adapter: a,
      responseType: a,
      xsrfCookieName: a,
      xsrfHeaderName: a,
      onUploadProgress: a,
      onDownloadProgress: a,
      decompress: a,
      maxContentLength: a,
      maxBodyLength: a,
      transport: a,
      httpAgent: a,
      httpsAgent: a,
      cancelToken: a,
      socketPath: a,
      responseEncoding: a,
      validateStatus: c,
    };
    return (
      jr.forEach(Object.keys(t).concat(Object.keys(n)), function (d) {
        var f = u[d] || s,
          h = f(d);
        (jr.isUndefined(h) && f !== c) || (r[d] = h);
      }),
      r
    );
  },
  O_,
  X8;
function $N() {
  return X8 || ((X8 = 1), (O_ = { version: '0.26.1' })), O_;
}
var qEe = $N().version,
  CT = {};
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function (e, t) {
  CT[e] = function (r) {
    return typeof r === e || 'a' + (t < 1 ? 'n ' : ' ') + e;
  };
});
var Q8 = {};
CT.transitional = function (t, n, r) {
  function i(s, o) {
    return '[Axios v' + qEe + "] Transitional option '" + s + "'" + o + (r ? '. ' + r : '');
  }
  return function (s, o, a) {
    if (t === !1) throw new Error(i(o, ' has been removed' + (n ? ' in ' + n : '')));
    return (
      n &&
        !Q8[o] &&
        ((Q8[o] = !0),
        console.warn(
          i(o, ' has been deprecated since v' + n + ' and will be removed in the near future')
        )),
      t ? t(s, o, a) : !0
    );
  };
};
function YEe(e, t, n) {
  if (typeof e != 'object') throw new TypeError('options must be an object');
  for (var r = Object.keys(e), i = r.length; i-- > 0; ) {
    var s = r[i],
      o = t[s];
    if (o) {
      var a = e[s],
        c = a === void 0 || o(a, s, e);
      if (c !== !0) throw new TypeError('option ' + s + ' must be ' + c);
      continue;
    }
    if (n !== !0) throw Error('Unknown option ' + s);
  }
}
var ZEe = { assertOptions: YEe, validators: CT },
  FN = Dr,
  JEe = DN,
  eC = TEe,
  tC = GEe,
  $1 = UN,
  zN = ZEe,
  Fc = zN.validators;
function Dp(e) {
  (this.defaults = e), (this.interceptors = { request: new eC(), response: new eC() });
}
Dp.prototype.request = function (t, n) {
  typeof t == 'string' ? ((n = n || {}), (n.url = t)) : (n = t || {}),
    (n = $1(this.defaults, n)),
    n.method
      ? (n.method = n.method.toLowerCase())
      : this.defaults.method
        ? (n.method = this.defaults.method.toLowerCase())
        : (n.method = 'get');
  var r = n.transitional;
  r !== void 0 &&
    zN.assertOptions(
      r,
      {
        silentJSONParsing: Fc.transitional(Fc.boolean),
        forcedJSONParsing: Fc.transitional(Fc.boolean),
        clarifyTimeoutError: Fc.transitional(Fc.boolean),
      },
      !1
    );
  var i = [],
    s = !0;
  this.interceptors.request.forEach(function (h) {
    (typeof h.runWhen == 'function' && h.runWhen(n) === !1) ||
      ((s = s && h.synchronous), i.unshift(h.fulfilled, h.rejected));
  });
  var o = [];
  this.interceptors.response.forEach(function (h) {
    o.push(h.fulfilled, h.rejected);
  });
  var a;
  if (!s) {
    var c = [tC, void 0];
    for (Array.prototype.unshift.apply(c, i), c = c.concat(o), a = Promise.resolve(n); c.length; )
      a = a.then(c.shift(), c.shift());
    return a;
  }
  for (var u = n; i.length; ) {
    var l = i.shift(),
      d = i.shift();
    try {
      u = l(u);
    } catch (f) {
      d(f);
      break;
    }
  }
  try {
    a = tC(u);
  } catch (f) {
    return Promise.reject(f);
  }
  for (; o.length; ) a = a.then(o.shift(), o.shift());
  return a;
};
Dp.prototype.getUri = function (t) {
  return (t = $1(this.defaults, t)), JEe(t.url, t.params, t.paramsSerializer).replace(/^\?/, '');
};
FN.forEach(['delete', 'get', 'head', 'options'], function (t) {
  Dp.prototype[t] = function (n, r) {
    return this.request($1(r || {}, { method: t, url: n, data: (r || {}).data }));
  };
});
FN.forEach(['post', 'put', 'patch'], function (t) {
  Dp.prototype[t] = function (n, r, i) {
    return this.request($1(i || {}, { method: t, url: n, data: r }));
  };
});
var XEe = Dp,
  B_,
  nC;
function QEe() {
  if (nC) return B_;
  nC = 1;
  var e = L1();
  function t(n) {
    if (typeof n != 'function') throw new TypeError('executor must be a function.');
    var r;
    this.promise = new Promise(function (o) {
      r = o;
    });
    var i = this;
    this.promise.then(function (s) {
      if (i._listeners) {
        var o,
          a = i._listeners.length;
        for (o = 0; o < a; o++) i._listeners[o](s);
        i._listeners = null;
      }
    }),
      (this.promise.then = function (s) {
        var o,
          a = new Promise(function (c) {
            i.subscribe(c), (o = c);
          }).then(s);
        return (
          (a.cancel = function () {
            i.unsubscribe(o);
          }),
          a
        );
      }),
      n(function (o) {
        i.reason || ((i.reason = new e(o)), r(i.reason));
      });
  }
  return (
    (t.prototype.throwIfRequested = function () {
      if (this.reason) throw this.reason;
    }),
    (t.prototype.subscribe = function (r) {
      if (this.reason) {
        r(this.reason);
        return;
      }
      this._listeners ? this._listeners.push(r) : (this._listeners = [r]);
    }),
    (t.prototype.unsubscribe = function (r) {
      if (this._listeners) {
        var i = this._listeners.indexOf(r);
        i !== -1 && this._listeners.splice(i, 1);
      }
    }),
    (t.source = function () {
      var r,
        i = new t(function (o) {
          r = o;
        });
      return { token: i, cancel: r };
    }),
    (B_ = t),
    B_
  );
}
var D_, rC;
function eAe() {
  return (
    rC ||
      ((rC = 1),
      (D_ = function (t) {
        return function (r) {
          return t.apply(null, r);
        };
      })),
    D_
  );
}
var R_, iC;
function tAe() {
  if (iC) return R_;
  iC = 1;
  var e = Dr;
  return (
    (R_ = function (n) {
      return e.isObject(n) && n.isAxiosError === !0;
    }),
    R_
  );
}
var sC = Dr,
  nAe = PN,
  py = XEe,
  rAe = UN,
  iAe = kT;
function KN(e) {
  var t = new py(e),
    n = nAe(py.prototype.request, t);
  return (
    sC.extend(n, py.prototype, t),
    sC.extend(n, t),
    (n.create = function (i) {
      return KN(rAe(e, i));
    }),
    n
  );
}
var Cs = KN(iAe);
Cs.Axios = py;
Cs.Cancel = L1();
Cs.CancelToken = QEe();
Cs.isCancel = LN();
Cs.VERSION = $N().version;
Cs.all = function (t) {
  return Promise.all(t);
};
Cs.spread = eAe();
Cs.isAxiosError = tAe();
CN.exports = Cs;
CN.exports.default = Cs;
var sAe = (function () {
    var e = function (t, n) {
      return (
        (e =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (r, i) {
              r.__proto__ = i;
            }) ||
          function (r, i) {
            for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (r[s] = i[s]);
          }),
        e(t, n)
      );
    };
    return function (t, n) {
      if (typeof n != 'function' && n !== null)
        throw new TypeError('Class extends value ' + String(n) + ' is not a constructor or null');
      e(t, n);
      function r() {
        this.constructor = t;
      }
      t.prototype = n === null ? Object.create(n) : ((r.prototype = n.prototype), new r());
    };
  })(),
  oAe = function (e) {
    var t = typeof Symbol == 'function' && Symbol.iterator,
      n = t && e[t],
      r = 0;
    if (n) return n.call(e);
    if (e && typeof e.length == 'number')
      return {
        next: function () {
          return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e };
        },
      };
    throw new TypeError(t ? 'Object is not iterable.' : 'Symbol.iterator is not defined.');
  },
  VN = {},
  WN = {},
  PT = function (e, t) {
    WN[e] = t;
  },
  se = function (e) {
    var t = (function (n) {
      sAe(r, n);
      function r(i, s, o) {
        var a = n.call(this, i || e, o) || this;
        if ((Object.setPrototypeOf(a, r.prototype), (a.name = e), s)) for (var c in s) a[c] = s[c];
        if (o && aAe(o) && 'cause' in o && !('cause' in a)) {
          var u = o.cause;
          (a.cause = u),
            'stack' in u &&
              (a.stack =
                a.stack +
                `
CAUSE: ` +
                u.stack);
        }
        return a;
      }
      return r;
    })(Error);
    return (VN[e] = t), t;
  };
function aAe(e) {
  return typeof e == 'object';
}
var HN = function (e) {
    if (e && typeof e == 'object') {
      try {
        if (typeof e.message == 'string') {
          var t = JSON.parse(e.message);
          t.message && t.name && (e = t);
        }
      } catch {}
      var n = void 0;
      if (typeof e.name == 'string') {
        var r = e.name,
          i = WN[r];
        if (i) n = i(e);
        else {
          var s = r === 'Error' ? Error : VN[r];
          s || (console.warn("deserializing an unknown class '" + r + "'"), (s = se(r))),
            (n = Object.create(s.prototype));
          try {
            for (var o in e) e.hasOwnProperty(o) && (n[o] = e[o]);
          } catch {}
        }
      } else typeof e.message == 'string' && (n = new Error(e.message));
      return n && !n.stack && Error.captureStackTrace && Error.captureStackTrace(n, HN), n;
    }
    return new Error(String(e));
  },
  cAe = function (e) {
    return (
      e &&
      (typeof e == 'object'
        ? GN(e, [])
        : typeof e == 'function'
          ? '[Function: '.concat(e.name || 'anonymous', ']')
          : e)
    );
  };
function GN(e, t) {
  var n,
    r,
    i = {};
  t.push(e);
  try {
    for (var s = oAe(Object.keys(e)), o = s.next(); !o.done; o = s.next()) {
      var a = o.value,
        c = e[a];
      if (typeof c != 'function') {
        if (!c || typeof c != 'object') {
          i[a] = c;
          continue;
        }
        if (t.indexOf(e[a]) === -1) {
          i[a] = GN(e[a], t.slice(0));
          continue;
        }
        i[a] = '[Circular]';
      }
    }
  } catch (u) {
    n = { error: u };
  } finally {
    try {
      o && !o.done && (r = s.return) && r.call(s);
    } finally {
      if (n) throw n.error;
    }
  }
  return (
    typeof e.name == 'string' && (i.name = e.name),
    typeof e.message == 'string' && (i.message = e.message),
    typeof e.stack == 'string' && (i.stack = e.stack),
    i
  );
}
var uAe = (function () {
    var e = function (t, n) {
      return (
        (e =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (r, i) {
              r.__proto__ = i;
            }) ||
          function (r, i) {
            for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (r[s] = i[s]);
          }),
        e(t, n)
      );
    };
    return function (t, n) {
      if (typeof n != 'function' && n !== null)
        throw new TypeError('Class extends value ' + String(n) + ' is not a constructor or null');
      e(t, n);
      function r() {
        this.constructor = t;
      }
      t.prototype = n === null ? Object.create(n) : ((r.prototype = n.prototype), new r());
    };
  })(),
  lAe = se('AccountNameRequired'),
  dAe = se('AccountNotSupported'),
  fAe = se('AmountRequired'),
  hAe = se('BluetoothRequired'),
  pAe = se('BtcUnmatchedApp'),
  gAe = se('CantOpenDevice'),
  yAe = se('CashAddrNotSupported'),
  bAe = se('CurrencyNotSupported'),
  mAe = se('DeviceAppVerifyNotSupported'),
  wAe = se('DeviceGenuineSocketEarlyClose'),
  vAe = se('DeviceNotGenuine'),
  _Ae = se('DeviceOnDashboardExpected'),
  SAe = se('DeviceOnDashboardUnexpected'),
  EAe = se('DeviceInOSUExpected'),
  AAe = se('DeviceHalted'),
  IAe = se('DeviceNameInvalid'),
  TAe = se('DeviceSocketFail'),
  xAe = se('DeviceSocketNoBulkStatus'),
  qN = se('DisconnectedDevice'),
  YN = se('DisconnectedDeviceDuringOperation'),
  kAe = se('DeviceExtractOnboardingStateError'),
  CAe = se('DeviceOnboardingStatePollingError'),
  PAe = se('EnpointConfig'),
  MAe = se('EthAppPleaseEnableContractData'),
  OAe = se('FeeEstimationFailed'),
  BAe = se('FirmwareNotRecognized'),
  DAe = se('HardResetFail'),
  RAe = se('InvalidXRPTag'),
  NAe = se('InvalidAddress'),
  jAe = se('InvalidAddressBecauseDestinationIsAlsoSource'),
  LAe = se('LatestMCUInstalledError'),
  UAe = se('UnknownMCU'),
  $Ae = se('LedgerAPIError'),
  FAe = se('LedgerAPIErrorWithMessage'),
  zAe = se('LedgerAPINotAvailable'),
  KAe = se('ManagerAppAlreadyInstalled'),
  VAe = se('ManagerAppRelyOnBTC'),
  WAe = se('ManagerAppDepInstallRequired'),
  HAe = se('ManagerAppDepUninstallRequired'),
  GAe = se('ManagerDeviceLocked'),
  qAe = se('ManagerFirmwareNotEnoughSpace'),
  YAe = se('ManagerNotEnoughSpace'),
  ZAe = se('ManagerUninstallBTCDep'),
  JAe = se('NetworkDown'),
  XAe = se('NoAddressesFound'),
  QAe = se('NotEnoughBalance'),
  eIe = se('NotEnoughBalanceToDelegate'),
  tIe = se('NotEnoughBalanceInParentAccount'),
  nIe = se('NotEnoughSpendableBalance'),
  rIe = se('NotEnoughBalanceBecauseDestinationNotCreated'),
  iIe = se('NoAccessToCamera'),
  sIe = se('NotEnoughGas'),
  oIe = se('NotSupportedLegacyAddress'),
  aIe = se('GasLessThanEstimate'),
  cIe = se('PriorityFeeTooLow'),
  uIe = se('PriorityFeeTooHigh'),
  lIe = se('PriorityFeeHigherThanMaxFee'),
  dIe = se('MaxFeeTooLow'),
  fIe = se('PasswordsDontMatch'),
  hIe = se('PasswordIncorrect'),
  pIe = se('RecommendSubAccountsToEmpty'),
  gIe = se('RecommendUndelegation'),
  yIe = se('TimeoutTagged'),
  bIe = se('UnexpectedBootloader'),
  mIe = se('MCUNotGenuineToDashboard'),
  wIe = se('RecipientRequired'),
  vIe = se('UnavailableTezosOriginatedAccountReceive'),
  _Ie = se('UnavailableTezosOriginatedAccountSend'),
  SIe = se('UpdateFetchFileFail'),
  EIe = se('UpdateIncorrectHash'),
  AIe = se('UpdateIncorrectSig'),
  IIe = se('UpdateYourApp'),
  TIe = se('UserRefusedDeviceNameChange'),
  xIe = se('UserRefusedAddress'),
  kIe = se('UserRefusedFirmwareUpdate'),
  CIe = se('UserRefusedAllowManager'),
  PIe = se('UserRefusedOnDevice'),
  ZE = se('TransportOpenUserCancelled'),
  MIe = se('TransportInterfaceNotAvailable'),
  ZN = se('TransportRaceCondition'),
  OIe = se('TransportWebUSBGestureRequired'),
  BIe = se('DeviceShouldStayInApp'),
  DIe = se('WebsocketConnectionError'),
  RIe = se('WebsocketConnectionFailed'),
  NIe = se('WrongDeviceForAccount'),
  jIe = se('WrongAppForCurrency'),
  LIe = se('ETHAddressNonEIP'),
  UIe = se('CantScanQRCode'),
  $Ie = se('FeeNotLoaded'),
  FIe = se('FeeRequired'),
  zIe = se('FeeTooHigh'),
  KIe = se('DustLimit'),
  VIe = se('PendingOperation'),
  WIe = se('SyncError'),
  HIe = se('PairingFailed'),
  GIe = se('GenuineCheckFailed'),
  qIe = se('LedgerAPI4xx'),
  YIe = se('LedgerAPI5xx'),
  ZIe = se('FirmwareOrAppUpdateRequired'),
  JIe = se('LanguageNotFound'),
  XIe = se('NoDBPathGiven'),
  QIe = se('DBWrongPassword'),
  eTe = se('DBNotReset'),
  za = (function (e) {
    uAe(t, e);
    function t(n, r) {
      var i = this,
        s = 'TransportError';
      return (
        (i = e.call(this, n || s) || this),
        (i.name = s),
        (i.message = n),
        (i.stack = new Error().stack),
        (i.id = r),
        i
      );
    }
    return t;
  })(Error);
PT('TransportError', function (e) {
  return new za(e.message, e.id);
});
var cb = {
  PIN_REMAINING_ATTEMPTS: 25536,
  INCORRECT_LENGTH: 26368,
  MISSING_CRITICAL_PARAMETER: 26624,
  COMMAND_INCOMPATIBLE_FILE_STRUCTURE: 27009,
  SECURITY_STATUS_NOT_SATISFIED: 27010,
  CONDITIONS_OF_USE_NOT_SATISFIED: 27013,
  INCORRECT_DATA: 27264,
  NOT_ENOUGH_MEMORY_SPACE: 27268,
  REFERENCED_DATA_NOT_FOUND: 27272,
  FILE_ALREADY_EXISTS: 27273,
  INCORRECT_P1_P2: 27392,
  INS_NOT_SUPPORTED: 27904,
  CLA_NOT_SUPPORTED: 28160,
  TECHNICAL_PROBLEM: 28416,
  OK: 36864,
  MEMORY_PROBLEM: 37440,
  NO_EF_SELECTED: 37888,
  INVALID_OFFSET: 37890,
  FILE_NOT_FOUND: 37892,
  INCONSISTENT_FILE: 37896,
  ALGORITHM_NOT_SUPPORTED: 38020,
  INVALID_KCV: 38021,
  CODE_NOT_INITIALIZED: 38914,
  ACCESS_CONDITION_NOT_FULFILLED: 38916,
  CONTRADICTION_SECRET_CODE_STATUS: 38920,
  CONTRADICTION_INVALIDATION: 38928,
  CODE_BLOCKED: 38976,
  MAX_VALUE_REACHED: 38992,
  GP_AUTH_FAILED: 25344,
  LICENSING: 28482,
  HALTED: 28586,
  LOCKED_DEVICE: 21781,
};
function JN(e) {
  switch (e) {
    case 26368:
      return 'Incorrect length';
    case 26624:
      return 'Missing critical parameter';
    case 27010:
      return 'Security not satisfied (dongle locked or have invalid access rights)';
    case 27013:
      return 'Condition of use not satisfied (denied by the user?)';
    case 27264:
      return 'Invalid data received';
    case 27392:
      return 'Invalid parameter received';
    case 21781:
      return 'Locked device';
  }
  if (28416 <= e && e <= 28671) return 'Internal error, please report';
}
function F1(e) {
  this.name = 'TransportStatusError';
  var t =
      Object.keys(cb).find(function (i) {
        return cb[i] === e;
      }) || 'UNKNOWN_ERROR',
    n = JN(e) || t,
    r = e.toString(16);
  (this.message = 'Ledger device: '.concat(n, ' (0x').concat(r, ')')),
    (this.stack = new Error().stack),
    (this.statusCode = e),
    (this.statusText = t);
}
F1.prototype = new Error();
PT('TransportStatusError', function (e) {
  return new F1(e.statusCode);
});
const tTe = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      AccountNameRequiredError: lAe,
      AccountNotSupported: dAe,
      AmountRequired: fAe,
      BluetoothRequired: hAe,
      BtcUnmatchedApp: pAe,
      CantOpenDevice: gAe,
      CantScanQRCode: UIe,
      CashAddrNotSupported: yAe,
      CurrencyNotSupported: bAe,
      DBNotReset: eTe,
      DBWrongPassword: QIe,
      DeviceAppVerifyNotSupported: mAe,
      DeviceExtractOnboardingStateError: kAe,
      DeviceGenuineSocketEarlyClose: wAe,
      DeviceHalted: AAe,
      DeviceInOSUExpected: EAe,
      DeviceNameInvalid: IAe,
      DeviceNotGenuineError: vAe,
      DeviceOnDashboardExpected: _Ae,
      DeviceOnDashboardUnexpected: SAe,
      DeviceOnboardingStatePollingError: CAe,
      DeviceShouldStayInApp: BIe,
      DeviceSocketFail: TAe,
      DeviceSocketNoBulkStatus: xAe,
      DisconnectedDevice: qN,
      DisconnectedDeviceDuringOperation: YN,
      DustLimit: KIe,
      ETHAddressNonEIP: LIe,
      EnpointConfigError: PAe,
      EthAppPleaseEnableContractData: MAe,
      FeeEstimationFailed: OAe,
      FeeNotLoaded: $Ie,
      FeeRequired: FIe,
      FeeTooHigh: zIe,
      FirmwareNotRecognized: BAe,
      FirmwareOrAppUpdateRequired: ZIe,
      GasLessThanEstimate: aIe,
      GenuineCheckFailed: GIe,
      HardResetFail: DAe,
      InvalidAddress: NAe,
      InvalidAddressBecauseDestinationIsAlsoSource: jAe,
      InvalidXRPTag: RAe,
      LanguageNotFound: JIe,
      LatestMCUInstalledError: LAe,
      LedgerAPI4xx: qIe,
      LedgerAPI5xx: YIe,
      LedgerAPIError: $Ae,
      LedgerAPIErrorWithMessage: FAe,
      LedgerAPINotAvailable: zAe,
      MCUNotGenuineToDashboard: mIe,
      ManagerAppAlreadyInstalledError: KAe,
      ManagerAppDepInstallRequired: WAe,
      ManagerAppDepUninstallRequired: HAe,
      ManagerAppRelyOnBTCError: VAe,
      ManagerDeviceLockedError: GAe,
      ManagerFirmwareNotEnoughSpaceError: qAe,
      ManagerNotEnoughSpaceError: YAe,
      ManagerUninstallBTCDep: ZAe,
      MaxFeeTooLow: dIe,
      NetworkDown: JAe,
      NoAccessToCamera: iIe,
      NoAddressesFound: XAe,
      NoDBPathGiven: XIe,
      NotEnoughBalance: QAe,
      NotEnoughBalanceBecauseDestinationNotCreated: rIe,
      NotEnoughBalanceInParentAccount: tIe,
      NotEnoughBalanceToDelegate: eIe,
      NotEnoughGas: sIe,
      NotEnoughSpendableBalance: nIe,
      NotSupportedLegacyAddress: oIe,
      PairingFailed: HIe,
      PasswordIncorrectError: hIe,
      PasswordsDontMatchError: fIe,
      PendingOperation: VIe,
      PriorityFeeHigherThanMaxFee: lIe,
      PriorityFeeTooHigh: uIe,
      PriorityFeeTooLow: cIe,
      RecipientRequired: wIe,
      RecommendSubAccountsToEmpty: pIe,
      RecommendUndelegation: gIe,
      StatusCodes: cb,
      SyncError: WIe,
      TimeoutTagged: yIe,
      TransportError: za,
      TransportInterfaceNotAvailable: MIe,
      TransportOpenUserCancelled: ZE,
      TransportRaceCondition: ZN,
      TransportStatusError: F1,
      TransportWebUSBGestureRequired: OIe,
      UnavailableTezosOriginatedAccountReceive: vIe,
      UnavailableTezosOriginatedAccountSend: _Ie,
      UnexpectedBootloader: bIe,
      UnknownMCU: UAe,
      UpdateFetchFileFail: SIe,
      UpdateIncorrectHash: EIe,
      UpdateIncorrectSig: AIe,
      UpdateYourApp: IIe,
      UserRefusedAddress: xIe,
      UserRefusedAllowManager: CIe,
      UserRefusedDeviceNameChange: TIe,
      UserRefusedFirmwareUpdate: kIe,
      UserRefusedOnDevice: PIe,
      WebsocketConnectionError: DIe,
      WebsocketConnectionFailed: RIe,
      WrongAppForCurrency: jIe,
      WrongDeviceForAccount: NIe,
      addCustomErrorDeserializer: PT,
      createCustomErrorClass: se,
      deserializeError: HN,
      getAltStatusMessage: JN,
      serializeError: cAe,
    },
    Symbol.toStringTag,
    { value: 'Module' }
  )
);
se('EthAppPleaseEnableContractData');
se('EthAppNftNotSupported');
var nTe = { exports: {} },
  N_ = { exports: {} },
  oC;
function XN() {
  return (
    oC ||
      ((oC = 1),
      (function (e, t) {
        (function (n, r) {
          e.exports = r();
        })(m, function () {
          var n =
            n ||
            (function (r, i) {
              var s;
              if (
                (typeof window < 'u' && window.crypto && (s = window.crypto),
                typeof globalThis < 'u' && globalThis.crypto && (s = globalThis.crypto),
                typeof globalThis < 'u' && globalThis.crypto && (s = globalThis.crypto),
                !s && typeof window < 'u' && window.msCrypto && (s = window.msCrypto),
                !s && typeof globalThis < 'u' && globalThis.crypto && (s = globalThis.crypto),
                !s && typeof _b == 'function')
              )
                try {
                  s = TL();
                } catch {}
              var o = function () {
                  if (s) {
                    if (typeof s.getRandomValues == 'function')
                      try {
                        return s.getRandomValues(new Uint32Array(1))[0];
                      } catch {}
                    if (typeof s.randomBytes == 'function')
                      try {
                        return s.randomBytes(4).readInt32LE();
                      } catch {}
                  }
                  throw new Error(
                    'Native crypto module could not be used to get secure random number.'
                  );
                },
                a =
                  Object.create ||
                  (function () {
                    function _() {}
                    return function (x) {
                      var k;
                      return (_.prototype = x), (k = new _()), (_.prototype = null), k;
                    };
                  })(),
                c = {},
                u = (c.lib = {}),
                l = (u.Base = (function () {
                  return {
                    extend: function (_) {
                      var x = a(this);
                      return (
                        _ && x.mixIn(_),
                        (!x.hasOwnProperty('init') || this.init === x.init) &&
                          (x.init = function () {
                            x.$super.init.apply(this, arguments);
                          }),
                        (x.init.prototype = x),
                        (x.$super = this),
                        x
                      );
                    },
                    create: function () {
                      var _ = this.extend();
                      return _.init.apply(_, arguments), _;
                    },
                    init: function () {},
                    mixIn: function (_) {
                      for (var x in _) _.hasOwnProperty(x) && (this[x] = _[x]);
                      _.hasOwnProperty('toString') && (this.toString = _.toString);
                    },
                    clone: function () {
                      return this.init.prototype.extend(this);
                    },
                  };
                })()),
                d = (u.WordArray = l.extend({
                  init: function (_, x) {
                    (_ = this.words = _ || []),
                      x != i ? (this.sigBytes = x) : (this.sigBytes = _.length * 4);
                  },
                  toString: function (_) {
                    return (_ || h).stringify(this);
                  },
                  concat: function (_) {
                    var x = this.words,
                      k = _.words,
                      j = this.sigBytes,
                      F = _.sigBytes;
                    if ((this.clamp(), j % 4))
                      for (var K = 0; K < F; K++) {
                        var D = (k[K >>> 2] >>> (24 - (K % 4) * 8)) & 255;
                        x[(j + K) >>> 2] |= D << (24 - ((j + K) % 4) * 8);
                      }
                    else for (var C = 0; C < F; C += 4) x[(j + C) >>> 2] = k[C >>> 2];
                    return (this.sigBytes += F), this;
                  },
                  clamp: function () {
                    var _ = this.words,
                      x = this.sigBytes;
                    (_[x >>> 2] &= 4294967295 << (32 - (x % 4) * 8)), (_.length = r.ceil(x / 4));
                  },
                  clone: function () {
                    var _ = l.clone.call(this);
                    return (_.words = this.words.slice(0)), _;
                  },
                  random: function (_) {
                    for (var x = [], k = 0; k < _; k += 4) x.push(o());
                    return new d.init(x, _);
                  },
                })),
                f = (c.enc = {}),
                h = (f.Hex = {
                  stringify: function (_) {
                    for (var x = _.words, k = _.sigBytes, j = [], F = 0; F < k; F++) {
                      var K = (x[F >>> 2] >>> (24 - (F % 4) * 8)) & 255;
                      j.push((K >>> 4).toString(16)), j.push((K & 15).toString(16));
                    }
                    return j.join('');
                  },
                  parse: function (_) {
                    for (var x = _.length, k = [], j = 0; j < x; j += 2)
                      k[j >>> 3] |= parseInt(_.substr(j, 2), 16) << (24 - (j % 8) * 4);
                    return new d.init(k, x / 2);
                  },
                }),
                p = (f.Latin1 = {
                  stringify: function (_) {
                    for (var x = _.words, k = _.sigBytes, j = [], F = 0; F < k; F++) {
                      var K = (x[F >>> 2] >>> (24 - (F % 4) * 8)) & 255;
                      j.push(String.fromCharCode(K));
                    }
                    return j.join('');
                  },
                  parse: function (_) {
                    for (var x = _.length, k = [], j = 0; j < x; j++)
                      k[j >>> 2] |= (_.charCodeAt(j) & 255) << (24 - (j % 4) * 8);
                    return new d.init(k, x);
                  },
                }),
                b = (f.Utf8 = {
                  stringify: function (_) {
                    try {
                      return decodeURIComponent(escape(p.stringify(_)));
                    } catch {
                      throw new Error('Malformed UTF-8 data');
                    }
                  },
                  parse: function (_) {
                    return p.parse(unescape(encodeURIComponent(_)));
                  },
                }),
                w = (u.BufferedBlockAlgorithm = l.extend({
                  reset: function () {
                    (this._data = new d.init()), (this._nDataBytes = 0);
                  },
                  _append: function (_) {
                    typeof _ == 'string' && (_ = b.parse(_)),
                      this._data.concat(_),
                      (this._nDataBytes += _.sigBytes);
                  },
                  _process: function (_) {
                    var x,
                      k = this._data,
                      j = k.words,
                      F = k.sigBytes,
                      K = this.blockSize,
                      D = K * 4,
                      C = F / D;
                    _ ? (C = r.ceil(C)) : (C = r.max((C | 0) - this._minBufferSize, 0));
                    var B = C * K,
                      E = r.min(B * 4, F);
                    if (B) {
                      for (var y = 0; y < B; y += K) this._doProcessBlock(j, y);
                      (x = j.splice(0, B)), (k.sigBytes -= E);
                    }
                    return new d.init(x, E);
                  },
                  clone: function () {
                    var _ = l.clone.call(this);
                    return (_._data = this._data.clone()), _;
                  },
                  _minBufferSize: 0,
                }));
              u.Hasher = w.extend({
                cfg: l.extend(),
                init: function (_) {
                  (this.cfg = this.cfg.extend(_)), this.reset();
                },
                reset: function () {
                  w.reset.call(this), this._doReset();
                },
                update: function (_) {
                  return this._append(_), this._process(), this;
                },
                finalize: function (_) {
                  _ && this._append(_);
                  var x = this._doFinalize();
                  return x;
                },
                blockSize: 16,
                _createHelper: function (_) {
                  return function (x, k) {
                    return new _.init(k).finalize(x);
                  };
                },
                _createHmacHelper: function (_) {
                  return function (x, k) {
                    return new A.HMAC.init(_, k).finalize(x);
                  };
                },
              });
              var A = (c.algo = {});
              return c;
            })(Math);
          return n;
        });
      })(N_)),
    N_.exports
  );
}
var j_ = { exports: {} },
  aC;
function rTe() {
  return (
    aC ||
      ((aC = 1),
      (function (e, t) {
        (function (n, r) {
          e.exports = r(XN());
        })(m, function (n) {
          return (
            (function (r) {
              var i = n,
                s = i.lib,
                o = s.WordArray,
                a = s.Hasher,
                c = i.algo,
                u = [],
                l = [];
              (function () {
                function h(A) {
                  for (var _ = r.sqrt(A), x = 2; x <= _; x++) if (!(A % x)) return !1;
                  return !0;
                }
                function p(A) {
                  return ((A - (A | 0)) * 4294967296) | 0;
                }
                for (var b = 2, w = 0; w < 64; )
                  h(b) && (w < 8 && (u[w] = p(r.pow(b, 1 / 2))), (l[w] = p(r.pow(b, 1 / 3))), w++),
                    b++;
              })();
              var d = [],
                f = (c.SHA256 = a.extend({
                  _doReset: function () {
                    this._hash = new o.init(u.slice(0));
                  },
                  _doProcessBlock: function (h, p) {
                    for (
                      var b = this._hash.words,
                        w = b[0],
                        A = b[1],
                        _ = b[2],
                        x = b[3],
                        k = b[4],
                        j = b[5],
                        F = b[6],
                        K = b[7],
                        D = 0;
                      D < 64;
                      D++
                    ) {
                      if (D < 16) d[D] = h[p + D] | 0;
                      else {
                        var C = d[D - 15],
                          B = ((C << 25) | (C >>> 7)) ^ ((C << 14) | (C >>> 18)) ^ (C >>> 3),
                          E = d[D - 2],
                          y = ((E << 15) | (E >>> 17)) ^ ((E << 13) | (E >>> 19)) ^ (E >>> 10);
                        d[D] = B + d[D - 7] + y + d[D - 16];
                      }
                      var v = (k & j) ^ (~k & F),
                        S = (w & A) ^ (w & _) ^ (A & _),
                        T =
                          ((w << 30) | (w >>> 2)) ^
                          ((w << 19) | (w >>> 13)) ^
                          ((w << 10) | (w >>> 22)),
                        M =
                          ((k << 26) | (k >>> 6)) ^
                          ((k << 21) | (k >>> 11)) ^
                          ((k << 7) | (k >>> 25)),
                        R = K + M + v + l[D] + d[D],
                        L = T + S;
                      (K = F),
                        (F = j),
                        (j = k),
                        (k = (x + R) | 0),
                        (x = _),
                        (_ = A),
                        (A = w),
                        (w = (R + L) | 0);
                    }
                    (b[0] = (b[0] + w) | 0),
                      (b[1] = (b[1] + A) | 0),
                      (b[2] = (b[2] + _) | 0),
                      (b[3] = (b[3] + x) | 0),
                      (b[4] = (b[4] + k) | 0),
                      (b[5] = (b[5] + j) | 0),
                      (b[6] = (b[6] + F) | 0),
                      (b[7] = (b[7] + K) | 0);
                  },
                  _doFinalize: function () {
                    var h = this._data,
                      p = h.words,
                      b = this._nDataBytes * 8,
                      w = h.sigBytes * 8;
                    return (
                      (p[w >>> 5] |= 128 << (24 - (w % 32))),
                      (p[(((w + 64) >>> 9) << 4) + 14] = r.floor(b / 4294967296)),
                      (p[(((w + 64) >>> 9) << 4) + 15] = b),
                      (h.sigBytes = p.length * 4),
                      this._process(),
                      this._hash
                    );
                  },
                  clone: function () {
                    var h = a.clone.call(this);
                    return (h._hash = this._hash.clone()), h;
                  },
                }));
              (i.SHA256 = a._createHelper(f)), (i.HmacSHA256 = a._createHmacHelper(f));
            })(Math),
            n.SHA256
          );
        });
      })(j_)),
    j_.exports
  );
}
(function (e, t) {
  (function (n, r, i) {
    e.exports = r(XN(), rTe());
  })(m, function (n) {
    return (
      (function () {
        var r = n,
          i = r.lib,
          s = i.WordArray,
          o = r.algo,
          a = o.SHA256,
          c = (o.SHA224 = a.extend({
            _doReset: function () {
              this._hash = new s.init([
                3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839,
                3204075428,
              ]);
            },
            _doFinalize: function () {
              var u = a._doFinalize.call(this);
              return (u.sigBytes -= 4), u;
            },
          }));
        (r.SHA224 = a._createHelper(c)), (r.HmacSHA224 = a._createHmacHelper(c));
      })(),
      n.SHA224
    );
  });
})(nTe);
var cC;
(function (e) {
  (e[(e.DYNAMIC = 0)] = 'DYNAMIC'), (e[(e.FIXED = 1)] = 'FIXED');
})(cC || (cC = {}));
var uC;
(function (e) {
  e[(e.BLIND_SIGNATURE_REQUIRED = 26632)] = 'BLIND_SIGNATURE_REQUIRED';
})(uC || (uC = {}));
var lC;
(function (e) {
  (e[(e.LONG = 0)] = 'LONG'), (e[(e.SHORT = 1)] = 'SHORT');
})(lC || (lC = {}));
g.object({
  name: g.string().optional(),
  message: g.string().optional(),
  statusCode: g.number().optional(),
  statusText: g.string().optional(),
});
var iTe = {},
  Rp = {},
  QN = { exports: {} };
(function (e) {
  (function (t, n) {
    var r = {};
    n(r);
    var i = r.default;
    for (var s in r) i[s] = r[s];
    e.exports = i;
  })(m, function (t) {
    (t.__esModule = !0), (t.digestLength = 32), (t.blockSize = 64);
    var n = new Uint32Array([
      1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221,
      3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580,
      3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
      2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895,
      666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037,
      2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
      430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
      1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479,
      3329325298,
    ]);
    function r(f, h, p, b, w) {
      for (var A, _, x, k, j, F, K, D, C, B, E, y, v; w >= 64; ) {
        for (
          A = h[0], _ = h[1], x = h[2], k = h[3], j = h[4], F = h[5], K = h[6], D = h[7], B = 0;
          B < 16;
          B++
        )
          (E = b + B * 4),
            (f[B] =
              ((p[E] & 255) << 24) |
              ((p[E + 1] & 255) << 16) |
              ((p[E + 2] & 255) << 8) |
              (p[E + 3] & 255));
        for (B = 16; B < 64; B++)
          (C = f[B - 2]),
            (y = ((C >>> 17) | (C << 15)) ^ ((C >>> 19) | (C << 13)) ^ (C >>> 10)),
            (C = f[B - 15]),
            (v = ((C >>> 7) | (C << 25)) ^ ((C >>> 18) | (C << 14)) ^ (C >>> 3)),
            (f[B] = ((y + f[B - 7]) | 0) + ((v + f[B - 16]) | 0));
        for (B = 0; B < 64; B++)
          (y =
            ((((((j >>> 6) | (j << 26)) ^ ((j >>> 11) | (j << 21)) ^ ((j >>> 25) | (j << 7))) +
              ((j & F) ^ (~j & K))) |
              0) +
              ((D + ((n[B] + f[B]) | 0)) | 0)) |
            0),
            (v =
              ((((A >>> 2) | (A << 30)) ^ ((A >>> 13) | (A << 19)) ^ ((A >>> 22) | (A << 10))) +
                ((A & _) ^ (A & x) ^ (_ & x))) |
              0),
            (D = K),
            (K = F),
            (F = j),
            (j = (k + y) | 0),
            (k = x),
            (x = _),
            (_ = A),
            (A = (y + v) | 0);
        (h[0] += A),
          (h[1] += _),
          (h[2] += x),
          (h[3] += k),
          (h[4] += j),
          (h[5] += F),
          (h[6] += K),
          (h[7] += D),
          (b += 64),
          (w -= 64);
      }
      return b;
    }
    var i = (function () {
      function f() {
        (this.digestLength = t.digestLength),
          (this.blockSize = t.blockSize),
          (this.state = new Int32Array(8)),
          (this.temp = new Int32Array(64)),
          (this.buffer = new Uint8Array(128)),
          (this.bufferLength = 0),
          (this.bytesHashed = 0),
          (this.finished = !1),
          this.reset();
      }
      return (
        (f.prototype.reset = function () {
          return (
            (this.state[0] = 1779033703),
            (this.state[1] = 3144134277),
            (this.state[2] = 1013904242),
            (this.state[3] = 2773480762),
            (this.state[4] = 1359893119),
            (this.state[5] = 2600822924),
            (this.state[6] = 528734635),
            (this.state[7] = 1541459225),
            (this.bufferLength = 0),
            (this.bytesHashed = 0),
            (this.finished = !1),
            this
          );
        }),
        (f.prototype.clean = function () {
          for (var h = 0; h < this.buffer.length; h++) this.buffer[h] = 0;
          for (var h = 0; h < this.temp.length; h++) this.temp[h] = 0;
          this.reset();
        }),
        (f.prototype.update = function (h, p) {
          if ((p === void 0 && (p = h.length), this.finished))
            throw new Error("SHA256: can't update because hash was finished.");
          var b = 0;
          if (((this.bytesHashed += p), this.bufferLength > 0)) {
            for (; this.bufferLength < 64 && p > 0; )
              (this.buffer[this.bufferLength++] = h[b++]), p--;
            this.bufferLength === 64 &&
              (r(this.temp, this.state, this.buffer, 0, 64), (this.bufferLength = 0));
          }
          for (p >= 64 && ((b = r(this.temp, this.state, h, b, p)), (p %= 64)); p > 0; )
            (this.buffer[this.bufferLength++] = h[b++]), p--;
          return this;
        }),
        (f.prototype.finish = function (h) {
          if (!this.finished) {
            var p = this.bytesHashed,
              b = this.bufferLength,
              w = (p / 536870912) | 0,
              A = p << 3,
              _ = p % 64 < 56 ? 64 : 128;
            this.buffer[b] = 128;
            for (var x = b + 1; x < _ - 8; x++) this.buffer[x] = 0;
            (this.buffer[_ - 8] = (w >>> 24) & 255),
              (this.buffer[_ - 7] = (w >>> 16) & 255),
              (this.buffer[_ - 6] = (w >>> 8) & 255),
              (this.buffer[_ - 5] = (w >>> 0) & 255),
              (this.buffer[_ - 4] = (A >>> 24) & 255),
              (this.buffer[_ - 3] = (A >>> 16) & 255),
              (this.buffer[_ - 2] = (A >>> 8) & 255),
              (this.buffer[_ - 1] = (A >>> 0) & 255),
              r(this.temp, this.state, this.buffer, 0, _),
              (this.finished = !0);
          }
          for (var x = 0; x < 8; x++)
            (h[x * 4 + 0] = (this.state[x] >>> 24) & 255),
              (h[x * 4 + 1] = (this.state[x] >>> 16) & 255),
              (h[x * 4 + 2] = (this.state[x] >>> 8) & 255),
              (h[x * 4 + 3] = (this.state[x] >>> 0) & 255);
          return this;
        }),
        (f.prototype.digest = function () {
          var h = new Uint8Array(this.digestLength);
          return this.finish(h), h;
        }),
        (f.prototype._saveState = function (h) {
          for (var p = 0; p < this.state.length; p++) h[p] = this.state[p];
        }),
        (f.prototype._restoreState = function (h, p) {
          for (var b = 0; b < this.state.length; b++) this.state[b] = h[b];
          (this.bytesHashed = p), (this.finished = !1), (this.bufferLength = 0);
        }),
        f
      );
    })();
    t.Hash = i;
    var s = (function () {
      function f(h) {
        (this.inner = new i()),
          (this.outer = new i()),
          (this.blockSize = this.inner.blockSize),
          (this.digestLength = this.inner.digestLength);
        var p = new Uint8Array(this.blockSize);
        if (h.length > this.blockSize) new i().update(h).finish(p).clean();
        else for (var b = 0; b < h.length; b++) p[b] = h[b];
        for (var b = 0; b < p.length; b++) p[b] ^= 54;
        this.inner.update(p);
        for (var b = 0; b < p.length; b++) p[b] ^= 106;
        this.outer.update(p),
          (this.istate = new Uint32Array(8)),
          (this.ostate = new Uint32Array(8)),
          this.inner._saveState(this.istate),
          this.outer._saveState(this.ostate);
        for (var b = 0; b < p.length; b++) p[b] = 0;
      }
      return (
        (f.prototype.reset = function () {
          return (
            this.inner._restoreState(this.istate, this.inner.blockSize),
            this.outer._restoreState(this.ostate, this.outer.blockSize),
            this
          );
        }),
        (f.prototype.clean = function () {
          for (var h = 0; h < this.istate.length; h++) this.ostate[h] = this.istate[h] = 0;
          this.inner.clean(), this.outer.clean();
        }),
        (f.prototype.update = function (h) {
          return this.inner.update(h), this;
        }),
        (f.prototype.finish = function (h) {
          return (
            this.outer.finished
              ? this.outer.finish(h)
              : (this.inner.finish(h), this.outer.update(h, this.digestLength).finish(h)),
            this
          );
        }),
        (f.prototype.digest = function () {
          var h = new Uint8Array(this.digestLength);
          return this.finish(h), h;
        }),
        f
      );
    })();
    t.HMAC = s;
    function o(f) {
      var h = new i().update(f),
        p = h.digest();
      return h.clean(), p;
    }
    (t.hash = o), (t.default = o);
    function a(f, h) {
      var p = new s(f).update(h),
        b = p.digest();
      return p.clean(), b;
    }
    t.hmac = a;
    function c(f, h, p, b) {
      var w = b[0];
      if (w === 0) throw new Error('hkdf: cannot expand more');
      h.reset(), w > 1 && h.update(f), p && h.update(p), h.update(b), h.finish(f), b[0]++;
    }
    var u = new Uint8Array(t.digestLength);
    function l(f, h, p, b) {
      h === void 0 && (h = u), b === void 0 && (b = 32);
      for (
        var w = new Uint8Array([1]),
          A = a(h, f),
          _ = new s(A),
          x = new Uint8Array(_.digestLength),
          k = x.length,
          j = new Uint8Array(b),
          F = 0;
        F < b;
        F++
      )
        k === x.length && (c(x, _, p, w), (k = 0)), (j[F] = x[k++]);
      return _.clean(), x.fill(0), w.fill(0), j;
    }
    t.hkdf = l;
    function d(f, h, p, b) {
      for (
        var w = new s(f),
          A = w.digestLength,
          _ = new Uint8Array(4),
          x = new Uint8Array(A),
          k = new Uint8Array(A),
          j = new Uint8Array(b),
          F = 0;
        F * A < b;
        F++
      ) {
        var K = F + 1;
        (_[0] = (K >>> 24) & 255),
          (_[1] = (K >>> 16) & 255),
          (_[2] = (K >>> 8) & 255),
          (_[3] = (K >>> 0) & 255),
          w.reset(),
          w.update(h),
          w.update(_),
          w.finish(k);
        for (var D = 0; D < A; D++) x[D] = k[D];
        for (var D = 2; D <= p; D++) {
          w.reset(), w.update(k).finish(k);
          for (var C = 0; C < A; C++) x[C] ^= k[C];
        }
        for (var D = 0; D < A && F * A + D < b; D++) j[F * A + D] = x[D];
      }
      for (var F = 0; F < A; F++) x[F] = k[F] = 0;
      for (var F = 0; F < 4; F++) _[F] = 0;
      return w.clean(), j;
    }
    t.pbkdf2 = d;
  });
})(QN);
var sTe = QN.exports,
  oTe =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  aTe =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  cTe =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && oTe(t, e, n);
      return aTe(t, e), t;
    };
Object.defineProperty(Rp, '__esModule', { value: !0 });
const dC = sTe,
  fC = cTe(bi);
class ej {
  static hashMessage(t) {
    const n = new dC.Hash();
    n.update(this.TAG);
    const r = n.digest(),
      i = new dC.Hash();
    return i.update(r), i.update(r), i.update(z.from(t)), i.digest();
  }
  static buildToSpendTx(t, n) {
    const r = new fC.Psbt();
    r.setVersion(0), r.setLocktime(0);
    const i = this.hashMessage(t),
      s = new Uint8Array([0, 32]),
      o = new Uint8Array(s.length + i.length);
    return (
      o.set(s),
      o.set(i, s.length),
      r.addInput({
        hash: '0'.repeat(64),
        index: 4294967295,
        sequence: 0,
        finalScriptSig: z.from(o),
        witnessScript: z.from([]),
      }),
      r.addOutput({ value: 0, script: n }),
      r.extractTransaction()
    );
  }
  static buildToSignTx(t, n, r = !1, i = void 0) {
    const s = new fC.Psbt();
    return (
      s.setVersion(0),
      s.setLocktime(0),
      s.addInput({ hash: t, index: 0, sequence: 0, witnessUtxo: { script: n, value: 0 } }),
      r && s.updateInput(0, { redeemScript: n }),
      i && s.updateInput(0, { tapInternalKey: i }),
      s.addOutput({ value: 0, script: z.from([106]) }),
      s
    );
  }
  static encodeWitness(t) {
    const n = t.data.inputs[0].finalScriptWitness;
    if (n) return n.toString('base64');
    throw new Error('Cannot encode empty witness stack.');
  }
}
ej.TAG = z.from('BIP0322-signed-message');
Rp.default = ej;
var MT = {},
  Cr = {},
  OT = {},
  uTe =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  lTe =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  dTe =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && uTe(t, e, n);
      return lTe(t, e), t;
    };
Object.defineProperty(OT, '__esModule', { value: !0 });
const pt = dTe(bi);
class fTe {
  static isP2PKH(t) {
    return t[0] === '1' || t[0] === 'm' || t[0] === 'n';
  }
  static isP2SH(t) {
    return t[0] === '3' || t[0] === '2';
  }
  static isP2WPKH(t) {
    return t.slice(0, 4) === 'bc1q' || t.slice(0, 4) === 'tb1q'
      ? this.convertAdressToScriptPubkey(t).byteLength === 22
      : !1;
  }
  static isP2TR(t) {
    return t.slice(0, 4) === 'bc1p' || t.slice(0, 4) === 'tb1p';
  }
  static isP2WPKHWitness(t) {
    return t.length === 2 && t[1].byteLength === 33 && (t[1][0] === 2 || t[1][0] === 3);
  }
  static isSingleKeyP2TRWitness(t) {
    return t.length === 1;
  }
  static convertAdressToScriptPubkey(t) {
    if (t[0] === '1' || t[0] === 'm' || t[0] === 'n')
      return pt.payments.p2pkh({
        address: t,
        network: t[0] === '1' ? pt.networks.bitcoin : pt.networks.testnet,
      }).output;
    if (t[0] === '3' || t[0] === '2')
      return pt.payments.p2sh({
        address: t,
        network: t[0] === '3' ? pt.networks.bitcoin : pt.networks.testnet,
      }).output;
    if (t.slice(0, 4) === 'bc1q' || t.slice(0, 4) === 'tb1q') {
      if (t.length === 42)
        return pt.payments.p2wpkh({
          address: t,
          network: t.slice(0, 4) === 'bc1q' ? pt.networks.bitcoin : pt.networks.testnet,
        }).output;
      if (t.length === 62)
        return pt.payments.p2wsh({
          address: t,
          network: t.slice(0, 4) === 'bc1q' ? pt.networks.bitcoin : pt.networks.testnet,
        }).output;
    } else if ((t.slice(0, 4) === 'bc1p' || t.slice(0, 4) === 'tb1p') && t.length === 62)
      return pt.payments.p2tr({
        address: t,
        network: t.slice(0, 4) === 'bc1p' ? pt.networks.bitcoin : pt.networks.testnet,
      }).output;
    throw new Error('Unknown address type');
  }
  static convertPubKeyIntoAddress(t, n) {
    switch (n) {
      case 'p2pkh':
        return {
          mainnet: pt.payments.p2pkh({ pubkey: t, network: pt.networks.bitcoin }).address,
          testnet: pt.payments.p2pkh({ pubkey: t, network: pt.networks.testnet }).address,
        };
      case 'p2sh-p2wpkh':
        return {
          mainnet: pt.payments.p2sh({
            redeem: pt.payments.p2wpkh({ pubkey: t, network: pt.networks.bitcoin }),
            network: pt.networks.bitcoin,
          }).address,
          testnet: pt.payments.p2sh({
            redeem: pt.payments.p2wpkh({ pubkey: t, network: pt.networks.testnet }),
            network: pt.networks.testnet,
          }).address,
        };
      case 'p2wpkh':
        return {
          mainnet: pt.payments.p2wpkh({ pubkey: t, network: pt.networks.bitcoin }).address,
          testnet: pt.payments.p2wpkh({ pubkey: t, network: pt.networks.testnet }).address,
        };
      case 'p2tr':
        const r = t.byteLength === 33 ? t.subarray(1, 33) : t;
        return {
          mainnet: pt.payments.p2tr({ internalPubkey: r, network: pt.networks.bitcoin }).address,
          testnet: pt.payments.p2tr({ internalPubkey: r, network: pt.networks.testnet }).address,
        };
      default:
        throw new Error('Cannot convert public key into unsupported address type.');
    }
  }
}
OT.default = fTe;
var BT = {};
const At = {
  IMPOSSIBLE_CASE: 'Impossible case. Please create issue.',
  TWEAK_ADD: 'The tweak was out of range or the resulted private key is invalid',
  TWEAK_MUL: 'The tweak was out of range or equal to zero',
  CONTEXT_RANDOMIZE_UNKNOW: 'Unknow error on context randomization',
  SECKEY_INVALID: 'Private Key is invalid',
  PUBKEY_PARSE: 'Public Key could not be parsed',
  PUBKEY_SERIALIZE: 'Public Key serialization error',
  PUBKEY_COMBINE: 'The sum of the public keys is not valid',
  SIG_PARSE: 'Signature could not be parsed',
  SIGN: 'The nonce generation function failed, or the private key was invalid',
  RECOVER: 'Public key could not be recover',
  ECDH: 'Scalar was invalid (zero or overflow)',
};
function oi(e, t) {
  if (!e) throw new Error(t);
}
function bt(e, t, n) {
  if ((oi(t instanceof Uint8Array, `Expected ${e} to be an Uint8Array`), n !== void 0))
    if (Array.isArray(n)) {
      const r = n.join(', '),
        i = `Expected ${e} to be an Uint8Array with length [${r}]`;
      oi(n.includes(t.length), i);
    } else {
      const r = `Expected ${e} to be an Uint8Array with length ${n}`;
      oi(t.length === n, r);
    }
}
function xa(e) {
  oi(Hc(e) === 'Boolean', 'Expected compressed to be a Boolean');
}
function vi(e = (n) => new Uint8Array(n), t) {
  return typeof e == 'function' && (e = e(t)), bt('output', e, t), e;
}
function Hc(e) {
  return Object.prototype.toString.call(e).slice(8, -1);
}
var hTe = (e) => ({
  contextRandomize(t) {
    switch (
      (oi(t === null || t instanceof Uint8Array, 'Expected seed to be an Uint8Array or null'),
      t !== null && bt('seed', t, 32),
      e.contextRandomize(t))
    ) {
      case 1:
        throw new Error(At.CONTEXT_RANDOMIZE_UNKNOW);
    }
  },
  privateKeyVerify(t) {
    return bt('private key', t, 32), e.privateKeyVerify(t) === 0;
  },
  privateKeyNegate(t) {
    switch ((bt('private key', t, 32), e.privateKeyNegate(t))) {
      case 0:
        return t;
      case 1:
        throw new Error(At.IMPOSSIBLE_CASE);
    }
  },
  privateKeyTweakAdd(t, n) {
    switch ((bt('private key', t, 32), bt('tweak', n, 32), e.privateKeyTweakAdd(t, n))) {
      case 0:
        return t;
      case 1:
        throw new Error(At.TWEAK_ADD);
    }
  },
  privateKeyTweakMul(t, n) {
    switch ((bt('private key', t, 32), bt('tweak', n, 32), e.privateKeyTweakMul(t, n))) {
      case 0:
        return t;
      case 1:
        throw new Error(At.TWEAK_MUL);
    }
  },
  publicKeyVerify(t) {
    return bt('public key', t, [33, 65]), e.publicKeyVerify(t) === 0;
  },
  publicKeyCreate(t, n = !0, r) {
    switch ((bt('private key', t, 32), xa(n), (r = vi(r, n ? 33 : 65)), e.publicKeyCreate(r, t))) {
      case 0:
        return r;
      case 1:
        throw new Error(At.SECKEY_INVALID);
      case 2:
        throw new Error(At.PUBKEY_SERIALIZE);
    }
  },
  publicKeyConvert(t, n = !0, r) {
    switch (
      (bt('public key', t, [33, 65]), xa(n), (r = vi(r, n ? 33 : 65)), e.publicKeyConvert(r, t))
    ) {
      case 0:
        return r;
      case 1:
        throw new Error(At.PUBKEY_PARSE);
      case 2:
        throw new Error(At.PUBKEY_SERIALIZE);
    }
  },
  publicKeyNegate(t, n = !0, r) {
    switch (
      (bt('public key', t, [33, 65]), xa(n), (r = vi(r, n ? 33 : 65)), e.publicKeyNegate(r, t))
    ) {
      case 0:
        return r;
      case 1:
        throw new Error(At.PUBKEY_PARSE);
      case 2:
        throw new Error(At.IMPOSSIBLE_CASE);
      case 3:
        throw new Error(At.PUBKEY_SERIALIZE);
    }
  },
  publicKeyCombine(t, n = !0, r) {
    oi(Array.isArray(t), 'Expected public keys to be an Array'),
      oi(t.length > 0, 'Expected public keys array will have more than zero items');
    for (const i of t) bt('public key', i, [33, 65]);
    switch ((xa(n), (r = vi(r, n ? 33 : 65)), e.publicKeyCombine(r, t))) {
      case 0:
        return r;
      case 1:
        throw new Error(At.PUBKEY_PARSE);
      case 2:
        throw new Error(At.PUBKEY_COMBINE);
      case 3:
        throw new Error(At.PUBKEY_SERIALIZE);
    }
  },
  publicKeyTweakAdd(t, n, r = !0, i) {
    switch (
      (bt('public key', t, [33, 65]),
      bt('tweak', n, 32),
      xa(r),
      (i = vi(i, r ? 33 : 65)),
      e.publicKeyTweakAdd(i, t, n))
    ) {
      case 0:
        return i;
      case 1:
        throw new Error(At.PUBKEY_PARSE);
      case 2:
        throw new Error(At.TWEAK_ADD);
    }
  },
  publicKeyTweakMul(t, n, r = !0, i) {
    switch (
      (bt('public key', t, [33, 65]),
      bt('tweak', n, 32),
      xa(r),
      (i = vi(i, r ? 33 : 65)),
      e.publicKeyTweakMul(i, t, n))
    ) {
      case 0:
        return i;
      case 1:
        throw new Error(At.PUBKEY_PARSE);
      case 2:
        throw new Error(At.TWEAK_MUL);
    }
  },
  signatureNormalize(t) {
    switch ((bt('signature', t, 64), e.signatureNormalize(t))) {
      case 0:
        return t;
      case 1:
        throw new Error(At.SIG_PARSE);
    }
  },
  signatureExport(t, n) {
    bt('signature', t, 64), (n = vi(n, 72));
    const r = { output: n, outputlen: 72 };
    switch (e.signatureExport(r, t)) {
      case 0:
        return n.slice(0, r.outputlen);
      case 1:
        throw new Error(At.SIG_PARSE);
      case 2:
        throw new Error(At.IMPOSSIBLE_CASE);
    }
  },
  signatureImport(t, n) {
    switch ((bt('signature', t), (n = vi(n, 64)), e.signatureImport(n, t))) {
      case 0:
        return n;
      case 1:
        throw new Error(At.SIG_PARSE);
      case 2:
        throw new Error(At.IMPOSSIBLE_CASE);
    }
  },
  ecdsaSign(t, n, r = {}, i) {
    bt('message', t, 32),
      bt('private key', n, 32),
      oi(Hc(r) === 'Object', 'Expected options to be an Object'),
      r.data !== void 0 && bt('options.data', r.data),
      r.noncefn !== void 0 &&
        oi(Hc(r.noncefn) === 'Function', 'Expected options.noncefn to be a Function'),
      (i = vi(i, 64));
    const s = { signature: i, recid: null };
    switch (e.ecdsaSign(s, t, n, r.data, r.noncefn)) {
      case 0:
        return s;
      case 1:
        throw new Error(At.SIGN);
      case 2:
        throw new Error(At.IMPOSSIBLE_CASE);
    }
  },
  ecdsaVerify(t, n, r) {
    switch (
      (bt('signature', t, 64),
      bt('message', n, 32),
      bt('public key', r, [33, 65]),
      e.ecdsaVerify(t, n, r))
    ) {
      case 0:
        return !0;
      case 3:
        return !1;
      case 1:
        throw new Error(At.SIG_PARSE);
      case 2:
        throw new Error(At.PUBKEY_PARSE);
    }
  },
  ecdsaRecover(t, n, r, i = !0, s) {
    switch (
      (bt('signature', t, 64),
      oi(
        Hc(n) === 'Number' && n >= 0 && n <= 3,
        'Expected recovery id to be a Number within interval [0, 3]'
      ),
      bt('message', r, 32),
      xa(i),
      (s = vi(s, i ? 33 : 65)),
      e.ecdsaRecover(s, t, n, r))
    ) {
      case 0:
        return s;
      case 1:
        throw new Error(At.SIG_PARSE);
      case 2:
        throw new Error(At.RECOVER);
      case 3:
        throw new Error(At.IMPOSSIBLE_CASE);
    }
  },
  ecdh(t, n, r = {}, i) {
    switch (
      (bt('public key', t, [33, 65]),
      bt('private key', n, 32),
      oi(Hc(r) === 'Object', 'Expected options to be an Object'),
      r.data !== void 0 && bt('options.data', r.data),
      r.hashfn !== void 0
        ? (oi(Hc(r.hashfn) === 'Function', 'Expected options.hashfn to be a Function'),
          r.xbuf !== void 0 && bt('options.xbuf', r.xbuf, 32),
          r.ybuf !== void 0 && bt('options.ybuf', r.ybuf, 32),
          bt('output', i))
        : (i = vi(i, 32)),
      e.ecdh(i, t, n, r.data, r.hashfn, r.xbuf, r.ybuf))
    ) {
      case 0:
        return i;
      case 1:
        throw new Error(At.PUBKEY_PARSE);
      case 2:
        throw new Error(At.ECDH);
    }
  },
});
const pTe = UP().ec,
  cs = new pTe('secp256k1'),
  gt = cs.curve,
  Nt = gt.n.constructor;
function gTe(e, t) {
  let n = new Nt(t);
  if (n.cmp(gt.p) >= 0) return null;
  n = n.toRed(gt.red);
  let r = n.redSqr().redIMul(n).redIAdd(gt.b).redSqrt();
  return (e === 3) !== r.isOdd() && (r = r.redNeg()), cs.keyPair({ pub: { x: n, y: r } });
}
function yTe(e, t, n) {
  let r = new Nt(t),
    i = new Nt(n);
  if (
    r.cmp(gt.p) >= 0 ||
    i.cmp(gt.p) >= 0 ||
    ((r = r.toRed(gt.red)), (i = i.toRed(gt.red)), (e === 6 || e === 7) && i.isOdd() !== (e === 7))
  )
    return null;
  const s = r.redSqr().redIMul(r);
  return i.redSqr().redISub(s.redIAdd(gt.b)).isZero() ? cs.keyPair({ pub: { x: r, y: i } }) : null;
}
function Fo(e) {
  const t = e[0];
  switch (t) {
    case 2:
    case 3:
      return e.length !== 33 ? null : gTe(t, e.subarray(1, 33));
    case 4:
    case 6:
    case 7:
      return e.length !== 65 ? null : yTe(t, e.subarray(1, 33), e.subarray(33, 65));
    default:
      return null;
  }
}
function ka(e, t) {
  const n = t.encode(null, e.length === 33);
  for (let r = 0; r < e.length; ++r) e[r] = n[r];
}
var bTe = {
    contextRandomize() {
      return 0;
    },
    privateKeyVerify(e) {
      const t = new Nt(e);
      return t.cmp(gt.n) < 0 && !t.isZero() ? 0 : 1;
    },
    privateKeyNegate(e) {
      const t = new Nt(e),
        n = gt.n.sub(t).umod(gt.n).toArrayLike(Uint8Array, 'be', 32);
      return e.set(n), 0;
    },
    privateKeyTweakAdd(e, t) {
      const n = new Nt(t);
      if (n.cmp(gt.n) >= 0 || (n.iadd(new Nt(e)), n.cmp(gt.n) >= 0 && n.isub(gt.n), n.isZero()))
        return 1;
      const r = n.toArrayLike(Uint8Array, 'be', 32);
      return e.set(r), 0;
    },
    privateKeyTweakMul(e, t) {
      let n = new Nt(t);
      if (n.cmp(gt.n) >= 0 || n.isZero()) return 1;
      n.imul(new Nt(e)), n.cmp(gt.n) >= 0 && (n = n.umod(gt.n));
      const r = n.toArrayLike(Uint8Array, 'be', 32);
      return e.set(r), 0;
    },
    publicKeyVerify(e) {
      return Fo(e) === null ? 1 : 0;
    },
    publicKeyCreate(e, t) {
      const n = new Nt(t);
      if (n.cmp(gt.n) >= 0 || n.isZero()) return 1;
      const r = cs.keyFromPrivate(t).getPublic();
      return ka(e, r), 0;
    },
    publicKeyConvert(e, t) {
      const n = Fo(t);
      if (n === null) return 1;
      const r = n.getPublic();
      return ka(e, r), 0;
    },
    publicKeyNegate(e, t) {
      const n = Fo(t);
      if (n === null) return 1;
      const r = n.getPublic();
      return (r.y = r.y.redNeg()), ka(e, r), 0;
    },
    publicKeyCombine(e, t) {
      const n = new Array(t.length);
      for (let i = 0; i < t.length; ++i) if (((n[i] = Fo(t[i])), n[i] === null)) return 1;
      let r = n[0].getPublic();
      for (let i = 1; i < n.length; ++i) r = r.add(n[i].pub);
      return r.isInfinity() ? 2 : (ka(e, r), 0);
    },
    publicKeyTweakAdd(e, t, n) {
      const r = Fo(t);
      if (r === null) return 1;
      if (((n = new Nt(n)), n.cmp(gt.n) >= 0)) return 2;
      const i = r.getPublic().add(gt.g.mul(n));
      return i.isInfinity() ? 2 : (ka(e, i), 0);
    },
    publicKeyTweakMul(e, t, n) {
      const r = Fo(t);
      if (r === null) return 1;
      if (((n = new Nt(n)), n.cmp(gt.n) >= 0 || n.isZero())) return 2;
      const i = r.getPublic().mul(n);
      return ka(e, i), 0;
    },
    signatureNormalize(e) {
      const t = new Nt(e.subarray(0, 32)),
        n = new Nt(e.subarray(32, 64));
      return t.cmp(gt.n) >= 0 || n.cmp(gt.n) >= 0
        ? 1
        : (n.cmp(cs.nh) === 1 && e.set(gt.n.sub(n).toArrayLike(Uint8Array, 'be', 32), 32), 0);
    },
    signatureExport(e, t) {
      const n = t.subarray(0, 32),
        r = t.subarray(32, 64);
      if (new Nt(n).cmp(gt.n) >= 0 || new Nt(r).cmp(gt.n) >= 0) return 1;
      const { output: i } = e;
      let s = i.subarray(4, 37);
      (s[0] = 0), s.set(n, 1);
      let o = 33,
        a = 0;
      for (; o > 1 && s[a] === 0 && !(s[a + 1] & 128); --o, ++a);
      if (((s = s.subarray(a)), s[0] & 128 || (o > 1 && s[0] === 0 && !(s[1] & 128)))) return 1;
      let c = i.subarray(39, 72);
      (c[0] = 0), c.set(r, 1);
      let u = 33,
        l = 0;
      for (; u > 1 && c[l] === 0 && !(c[l + 1] & 128); --u, ++l);
      return (
        (c = c.subarray(l)),
        c[0] & 128 || (u > 1 && c[0] === 0 && !(c[1] & 128))
          ? 1
          : ((e.outputlen = 6 + o + u),
            (i[0] = 48),
            (i[1] = e.outputlen - 2),
            (i[2] = 2),
            (i[3] = s.length),
            i.set(s, 4),
            (i[4 + o] = 2),
            (i[5 + o] = c.length),
            i.set(c, 6 + o),
            0)
      );
    },
    signatureImport(e, t) {
      if (t.length < 8 || t.length > 72 || t[0] !== 48 || t[1] !== t.length - 2 || t[2] !== 2)
        return 1;
      const n = t[3];
      if (n === 0 || 5 + n >= t.length || t[4 + n] !== 2) return 1;
      const r = t[5 + n];
      if (
        r === 0 ||
        6 + n + r !== t.length ||
        t[4] & 128 ||
        (n > 1 && t[4] === 0 && !(t[5] & 128)) ||
        t[n + 6] & 128 ||
        (r > 1 && t[n + 6] === 0 && !(t[n + 7] & 128))
      )
        return 1;
      let i = t.subarray(4, 4 + n);
      if ((i.length === 33 && i[0] === 0 && (i = i.subarray(1)), i.length > 32)) return 1;
      let s = t.subarray(6 + n);
      if ((s.length === 33 && s[0] === 0 && (s = s.slice(1)), s.length > 32))
        throw new Error('S length is too long');
      let o = new Nt(i);
      o.cmp(gt.n) >= 0 && (o = new Nt(0));
      let a = new Nt(t.subarray(6 + n));
      return (
        a.cmp(gt.n) >= 0 && (a = new Nt(0)),
        e.set(o.toArrayLike(Uint8Array, 'be', 32), 0),
        e.set(a.toArrayLike(Uint8Array, 'be', 32), 32),
        0
      );
    },
    ecdsaSign(e, t, n, r, i) {
      if (i) {
        const a = i;
        i = (c) => {
          const u = a(t, n, null, r, c);
          if (!(u instanceof Uint8Array && u.length === 32)) throw new Error('This is the way');
          return new Nt(u);
        };
      }
      const s = new Nt(n);
      if (s.cmp(gt.n) >= 0 || s.isZero()) return 1;
      let o;
      try {
        o = cs.sign(t, n, { canonical: !0, k: i, pers: r });
      } catch {
        return 1;
      }
      return (
        e.signature.set(o.r.toArrayLike(Uint8Array, 'be', 32), 0),
        e.signature.set(o.s.toArrayLike(Uint8Array, 'be', 32), 32),
        (e.recid = o.recoveryParam),
        0
      );
    },
    ecdsaVerify(e, t, n) {
      const r = { r: e.subarray(0, 32), s: e.subarray(32, 64) },
        i = new Nt(r.r),
        s = new Nt(r.s);
      if (i.cmp(gt.n) >= 0 || s.cmp(gt.n) >= 0) return 1;
      if (s.cmp(cs.nh) === 1 || i.isZero() || s.isZero()) return 3;
      const o = Fo(n);
      if (o === null) return 2;
      const a = o.getPublic();
      return cs.verify(t, r, a) ? 0 : 3;
    },
    ecdsaRecover(e, t, n, r) {
      const i = { r: t.slice(0, 32), s: t.slice(32, 64) },
        s = new Nt(i.r),
        o = new Nt(i.s);
      if (s.cmp(gt.n) >= 0 || o.cmp(gt.n) >= 0) return 1;
      if (s.isZero() || o.isZero()) return 2;
      let a;
      try {
        a = cs.recoverPubKey(r, i, n);
      } catch {
        return 2;
      }
      return ka(e, a), 0;
    },
    ecdh(e, t, n, r, i, s, o) {
      const a = Fo(t);
      if (a === null) return 1;
      const c = new Nt(n);
      if (c.cmp(gt.n) >= 0 || c.isZero()) return 2;
      const u = a.getPublic().mul(c);
      if (i === void 0) {
        const l = u.encode(null, !0),
          d = cs.hash().update(l).digest();
        for (let f = 0; f < 32; ++f) e[f] = d[f];
      } else {
        s || (s = new Uint8Array(32));
        const l = u.getX().toArray('be', 32);
        for (let p = 0; p < 32; ++p) s[p] = l[p];
        o || (o = new Uint8Array(32));
        const d = u.getY().toArray('be', 32);
        for (let p = 0; p < 32; ++p) o[p] = d[p];
        const f = i(s, o, r);
        if (!(f instanceof Uint8Array && f.length === e.length)) return 2;
        e.set(f);
      }
      return 0;
    },
  },
  mTe = hTe(bTe),
  L_ = xL,
  wTe = vb.Buffer,
  vTe = function (e) {
    function t(s) {
      var o = e(s);
      return L_.encode(wTe.concat([s, o], s.length + 4));
    }
    function n(s) {
      var o = s.slice(0, -4),
        a = s.slice(-4),
        c = e(o);
      if (!((a[0] ^ c[0]) | (a[1] ^ c[1]) | (a[2] ^ c[2]) | (a[3] ^ c[3]))) return o;
    }
    function r(s) {
      var o = L_.decodeUnsafe(s);
      if (o) return n(o);
    }
    function i(s) {
      var o = L_.decode(s),
        a = n(o);
      if (!a) throw new Error('Invalid checksum');
      return a;
    }
    return { encode: t, decode: i, decodeUnsafe: r };
  },
  hC = gA,
  _Te = vTe;
function STe(e) {
  var t = hC('sha256').update(e).digest();
  return hC('sha256').update(t).digest();
}
var ETe = _Te(STe),
  ub = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l',
  JE = {};
for (var Mg = 0; Mg < ub.length; Mg++) {
  var U_ = ub.charAt(Mg);
  if (JE[U_] !== void 0) throw new TypeError(U_ + ' is ambiguous');
  JE[U_] = Mg;
}
function ou(e) {
  var t = e >> 25;
  return (
    ((e & 33554431) << 5) ^
    (-((t >> 0) & 1) & 996825010) ^
    (-((t >> 1) & 1) & 642813549) ^
    (-((t >> 2) & 1) & 513874426) ^
    (-((t >> 3) & 1) & 1027748829) ^
    (-((t >> 4) & 1) & 705979059)
  );
}
function tj(e) {
  for (var t = 1, n = 0; n < e.length; ++n) {
    var r = e.charCodeAt(n);
    if (r < 33 || r > 126) return 'Invalid prefix (' + e + ')';
    t = ou(t) ^ (r >> 5);
  }
  for (t = ou(t), n = 0; n < e.length; ++n) {
    var i = e.charCodeAt(n);
    t = ou(t) ^ (i & 31);
  }
  return t;
}
function ATe(e, t, n) {
  if (((n = n || 90), e.length + 7 + t.length > n)) throw new TypeError('Exceeds length limit');
  e = e.toLowerCase();
  var r = tj(e);
  if (typeof r == 'string') throw new Error(r);
  for (var i = e + '1', s = 0; s < t.length; ++s) {
    var o = t[s];
    if (o >> 5) throw new Error('Non 5-bit word');
    (r = ou(r) ^ o), (i += ub.charAt(o));
  }
  for (s = 0; s < 6; ++s) r = ou(r);
  for (r ^= 1, s = 0; s < 6; ++s) {
    var a = (r >> ((5 - s) * 5)) & 31;
    i += ub.charAt(a);
  }
  return i;
}
function nj(e, t) {
  if (((t = t || 90), e.length < 8)) return e + ' too short';
  if (e.length > t) return 'Exceeds length limit';
  var n = e.toLowerCase(),
    r = e.toUpperCase();
  if (e !== n && e !== r) return 'Mixed-case string ' + e;
  e = n;
  var i = e.lastIndexOf('1');
  if (i === -1) return 'No separator character for ' + e;
  if (i === 0) return 'Missing prefix for ' + e;
  var s = e.slice(0, i),
    o = e.slice(i + 1);
  if (o.length < 6) return 'Data too short';
  var a = tj(s);
  if (typeof a == 'string') return a;
  for (var c = [], u = 0; u < o.length; ++u) {
    var l = o.charAt(u),
      d = JE[l];
    if (d === void 0) return 'Unknown character ' + l;
    (a = ou(a) ^ d), !(u + 6 >= o.length) && c.push(d);
  }
  return a !== 1 ? 'Invalid checksum for ' + e : { prefix: s, words: c };
}
function ITe() {
  var e = nj.apply(null, arguments);
  if (typeof e == 'object') return e;
}
function TTe(e) {
  var t = nj.apply(null, arguments);
  if (typeof t == 'object') return t;
  throw new Error(t);
}
function z1(e, t, n, r) {
  for (var i = 0, s = 0, o = (1 << n) - 1, a = [], c = 0; c < e.length; ++c)
    for (i = (i << t) | e[c], s += t; s >= n; ) (s -= n), a.push((i >> s) & o);
  if (r) s > 0 && a.push((i << (n - s)) & o);
  else {
    if (s >= t) return 'Excess padding';
    if ((i << (n - s)) & o) return 'Non-zero padding';
  }
  return a;
}
function xTe(e) {
  var t = z1(e, 8, 5, !0);
  if (Array.isArray(t)) return t;
}
function kTe(e) {
  var t = z1(e, 8, 5, !0);
  if (Array.isArray(t)) return t;
  throw new Error(t);
}
function CTe(e) {
  var t = z1(e, 5, 8, !1);
  if (Array.isArray(t)) return t;
}
function PTe(e) {
  var t = z1(e, 5, 8, !1);
  if (Array.isArray(t)) return t;
  throw new Error(t);
}
var MTe = {
    decodeUnsafe: ITe,
    decode: TTe,
    encode: ATe,
    toWordsUnsafe: xTe,
    toWords: kTe,
    fromWordsUnsafe: CTe,
    fromWords: PTe,
  },
  OTe = function (e, t) {
    if (!z.isBuffer(e) || !z.isBuffer(t)) throw new TypeError('Arguments must be Buffers');
    if (e === t) return !0;
    if (typeof e.equals == 'function') return e.equals(t);
    if (e.length !== t.length) return !1;
    for (var n = 0; n < e.length; n++) if (e[n] !== t[n]) return !1;
    return !0;
  },
  Hi = {},
  K1 = Object.prototype.toString;
Hi.isArray = function (e, t) {
  if (!Array.isArray(e)) throw TypeError(t);
};
Hi.isBoolean = function (e, t) {
  if (K1.call(e) !== '[object Boolean]') throw TypeError(t);
};
Hi.isBuffer = function (e, t) {
  if (!z.isBuffer(e)) throw TypeError(t);
};
Hi.isFunction = function (e, t) {
  if (K1.call(e) !== '[object Function]') throw TypeError(t);
};
Hi.isNumber = function (e, t) {
  if (K1.call(e) !== '[object Number]') throw TypeError(t);
};
Hi.isObject = function (e, t) {
  if (K1.call(e) !== '[object Object]') throw TypeError(t);
};
Hi.isBufferLength = function (e, t, n) {
  if (e.length !== t) throw RangeError(n);
};
Hi.isBufferLength2 = function (e, t, n, r) {
  if (e.length !== t && e.length !== n) throw RangeError(r);
};
Hi.isLengthGTZero = function (e, t) {
  if (e.length === 0) throw RangeError(t);
};
Hi.isNumberInInterval = function (e, t, n, r) {
  if (e <= t || e >= n) throw RangeError(r);
};
var ll = {},
  BTe = vb.Buffer;
function DTe(e) {
  if (e.length < 8 || e.length > 72 || e[0] !== 48 || e[1] !== e.length - 2 || e[2] !== 2)
    return !1;
  var t = e[3];
  if (t === 0 || 5 + t >= e.length || e[4 + t] !== 2) return !1;
  var n = e[5 + t];
  return !(
    n === 0 ||
    6 + t + n !== e.length ||
    e[4] & 128 ||
    (t > 1 && e[4] === 0 && !(e[5] & 128)) ||
    e[t + 6] & 128 ||
    (n > 1 && e[t + 6] === 0 && !(e[t + 7] & 128))
  );
}
function RTe(e) {
  if (e.length < 8) throw new Error('DER sequence length is too short');
  if (e.length > 72) throw new Error('DER sequence length is too long');
  if (e[0] !== 48) throw new Error('Expected DER sequence');
  if (e[1] !== e.length - 2) throw new Error('DER sequence length is invalid');
  if (e[2] !== 2) throw new Error('Expected DER integer');
  var t = e[3];
  if (t === 0) throw new Error('R length is zero');
  if (5 + t >= e.length) throw new Error('R length is too long');
  if (e[4 + t] !== 2) throw new Error('Expected DER integer (2)');
  var n = e[5 + t];
  if (n === 0) throw new Error('S length is zero');
  if (6 + t + n !== e.length) throw new Error('S length is invalid');
  if (e[4] & 128) throw new Error('R value is negative');
  if (t > 1 && e[4] === 0 && !(e[5] & 128)) throw new Error('R value excessively padded');
  if (e[t + 6] & 128) throw new Error('S value is negative');
  if (n > 1 && e[t + 6] === 0 && !(e[t + 7] & 128)) throw new Error('S value excessively padded');
  return { r: e.slice(4, 4 + t), s: e.slice(6 + t) };
}
function NTe(e, t) {
  var n = e.length,
    r = t.length;
  if (n === 0) throw new Error('R length is zero');
  if (r === 0) throw new Error('S length is zero');
  if (n > 33) throw new Error('R length is too long');
  if (r > 33) throw new Error('S length is too long');
  if (e[0] & 128) throw new Error('R value is negative');
  if (t[0] & 128) throw new Error('S value is negative');
  if (n > 1 && e[0] === 0 && !(e[1] & 128)) throw new Error('R value excessively padded');
  if (r > 1 && t[0] === 0 && !(t[1] & 128)) throw new Error('S value excessively padded');
  var i = BTe.allocUnsafe(6 + n + r);
  return (
    (i[0] = 48),
    (i[1] = i.length - 2),
    (i[2] = 2),
    (i[3] = e.length),
    e.copy(i, 4),
    (i[4 + n] = 2),
    (i[5 + n] = t.length),
    t.copy(i, 6 + n),
    i
  );
}
var jTe = { check: DTe, decode: RTe, encode: NTe },
  $i = vb.Buffer,
  rj = jTe,
  LTe = $i.from([
    48, 129, 211, 2, 1, 1, 4, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 160, 129, 133, 48, 129, 130, 2, 1, 1, 48, 44, 6, 7, 42, 134, 72,
    206, 61, 1, 1, 2, 33, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254, 255, 255, 252, 47, 48, 6,
    4, 1, 0, 4, 1, 7, 4, 33, 2, 121, 190, 102, 126, 249, 220, 187, 172, 85, 160, 98, 149, 206, 135,
    11, 7, 2, 155, 252, 219, 45, 206, 40, 217, 89, 242, 129, 91, 22, 248, 23, 152, 2, 33, 0, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254, 186, 174, 220, 230,
    175, 72, 160, 59, 191, 210, 94, 140, 208, 54, 65, 65, 2, 1, 1, 161, 36, 3, 34, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  ]),
  UTe = $i.from([
    48, 130, 1, 19, 2, 1, 1, 4, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 160, 129, 165, 48, 129, 162, 2, 1, 1, 48, 44, 6, 7, 42, 134,
    72, 206, 61, 1, 1, 2, 33, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254, 255, 255, 252, 47,
    48, 6, 4, 1, 0, 4, 1, 7, 4, 65, 4, 121, 190, 102, 126, 249, 220, 187, 172, 85, 160, 98, 149,
    206, 135, 11, 7, 2, 155, 252, 219, 45, 206, 40, 217, 89, 242, 129, 91, 22, 248, 23, 152, 72, 58,
    218, 119, 38, 163, 196, 101, 93, 164, 251, 252, 14, 17, 8, 168, 253, 23, 180, 72, 166, 133, 84,
    25, 156, 71, 208, 143, 251, 16, 212, 184, 2, 33, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 254, 186, 174, 220, 230, 175, 72, 160, 59, 191, 210, 94, 140, 208,
    54, 65, 65, 2, 1, 1, 161, 68, 3, 66, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  ]);
ll.privateKeyExport = function (e, t, n) {
  var r = $i.from(n ? LTe : UTe);
  return e.copy(r, n ? 8 : 9), t.copy(r, n ? 181 : 214), r;
};
ll.privateKeyImport = function (e) {
  var t = e.length,
    n = 0;
  if (!(t < n + 1 || e[n] !== 48) && ((n += 1), !(t < n + 1 || !(e[n] & 128)))) {
    var r = e[n] & 127;
    if (((n += 1), !(r < 1 || r > 2) && !(t < n + r))) {
      var i = e[n + r - 1] | (r > 1 ? e[n + r - 2] << 8 : 0);
      if (
        ((n += r),
        !(t < n + i) &&
          !(t < n + 3 || e[n] !== 2 || e[n + 1] !== 1 || e[n + 2] !== 1) &&
          ((n += 3), !(t < n + 2 || e[n] !== 4 || e[n + 1] > 32 || t < n + 2 + e[n + 1])))
      )
        return e.slice(n + 2, n + 2 + e[n + 1]);
    }
  }
};
ll.signatureExport = function (e) {
  for (
    var t = $i.concat([$i.from([0]), e.r]), n = 33, r = 0;
    n > 1 && t[r] === 0 && !(t[r + 1] & 128);
    --n, ++r
  );
  for (
    var i = $i.concat([$i.from([0]), e.s]), s = 33, o = 0;
    s > 1 && i[o] === 0 && !(i[o + 1] & 128);
    --s, ++o
  );
  return rj.encode(t.slice(r), i.slice(o));
};
ll.signatureImport = function (e) {
  var t = $i.alloc(32, 0),
    n = $i.alloc(32, 0);
  try {
    var r = rj.decode(e);
    if ((r.r.length === 33 && r.r[0] === 0 && (r.r = r.r.slice(1)), r.r.length > 32))
      throw new Error('R length is too long');
    if ((r.s.length === 33 && r.s[0] === 0 && (r.s = r.s.slice(1)), r.s.length > 32))
      throw new Error('S length is too long');
  } catch {
    return;
  }
  return r.r.copy(t, 32 - r.r.length), r.s.copy(n, 32 - r.s.length), { r: t, s: n };
};
ll.signatureImportLax = function (e) {
  var t = $i.alloc(32, 0),
    n = $i.alloc(32, 0),
    r = e.length,
    i = 0;
  if (e[i++] === 48) {
    var s = e[i++];
    if (!(s & 128 && ((i += s - 128), i > r)) && e[i++] === 2) {
      var o = e[i++];
      if (o & 128) {
        if (((s = o - 128), i + s > r)) return;
        for (; s > 0 && e[i] === 0; i += 1, s -= 1);
        for (o = 0; s > 0; i += 1, s -= 1) o = (o << 8) + e[i];
      }
      if (!(o > r - i)) {
        var a = i;
        if (((i += o), e[i++] === 2)) {
          var c = e[i++];
          if (c & 128) {
            if (((s = c - 128), i + s > r)) return;
            for (; s > 0 && e[i] === 0; i += 1, s -= 1);
            for (c = 0; s > 0; i += 1, s -= 1) c = (c << 8) + e[i];
          }
          if (!(c > r - i)) {
            var u = i;
            for (i += c; o > 0 && e[a] === 0; o -= 1, a += 1);
            if (!(o > 32)) {
              var l = e.slice(a, a + o);
              for (l.copy(t, 32 - l.length); c > 0 && e[u] === 0; c -= 1, u += 1);
              if (!(c > 32)) {
                var d = e.slice(u, u + c);
                return d.copy(n, 32 - d.length), { r: t, s: n };
              }
            }
          }
        }
      }
    }
  }
};
const $Te = 'compressed should be a boolean',
  FTe = 'private key should be a Buffer',
  zTe = 'private key length is invalid',
  KTe = 'private key range is invalid',
  VTe = 'tweak out of range or resulting private key is invalid',
  WTe = 'tweak out of range',
  HTe = "couldn't export to DER format",
  GTe = "couldn't import from DER format",
  qTe = 'public keys should be an Array',
  YTe = 'public keys Array should have at least 1 element',
  ZTe = 'public key should be a Buffer',
  JTe = 'public key length is invalid',
  XTe = 'the public key could not be parsed or is invalid',
  QTe = 'private was invalid, try again',
  exe = 'tweak out of range or resulting public key is invalid',
  txe = 'tweak out of range',
  nxe = 'the sum of the public keys is not valid',
  rxe = 'scalar was invalid (zero or overflow)',
  ixe = 'signature should be a Buffer',
  sxe = 'signature length is invalid',
  oxe = "couldn't parse signature",
  axe = "couldn't parse DER signature",
  cxe = "couldn't serialize signature to DER format",
  uxe = 'nonce generation function failed or private key is invalid',
  lxe = "couldn't recover public key from signature",
  dxe = 'message should be a Buffer',
  fxe = 'message length is invalid',
  hxe = 'options should be an Object',
  pxe = 'options.data should be a Buffer',
  gxe = 'options.data length is invalid',
  yxe = 'options.noncefn should be a Function',
  bxe = 'recovery should be a Number',
  mxe = 'recovery should have value between -1 and 4',
  wxe = 'tweak should be a Buffer',
  vxe = 'tweak length is invalid',
  ij = {
    COMPRESSED_TYPE_INVALID: $Te,
    EC_PRIVATE_KEY_TYPE_INVALID: FTe,
    EC_PRIVATE_KEY_LENGTH_INVALID: zTe,
    EC_PRIVATE_KEY_RANGE_INVALID: KTe,
    EC_PRIVATE_KEY_TWEAK_ADD_FAIL: VTe,
    EC_PRIVATE_KEY_TWEAK_MUL_FAIL: WTe,
    EC_PRIVATE_KEY_EXPORT_DER_FAIL: HTe,
    EC_PRIVATE_KEY_IMPORT_DER_FAIL: GTe,
    EC_PUBLIC_KEYS_TYPE_INVALID: qTe,
    EC_PUBLIC_KEYS_LENGTH_INVALID: YTe,
    EC_PUBLIC_KEY_TYPE_INVALID: ZTe,
    EC_PUBLIC_KEY_LENGTH_INVALID: JTe,
    EC_PUBLIC_KEY_PARSE_FAIL: XTe,
    EC_PUBLIC_KEY_CREATE_FAIL: QTe,
    EC_PUBLIC_KEY_TWEAK_ADD_FAIL: exe,
    EC_PUBLIC_KEY_TWEAK_MUL_FAIL: txe,
    EC_PUBLIC_KEY_COMBINE_FAIL: nxe,
    ECDH_FAIL: rxe,
    ECDSA_SIGNATURE_TYPE_INVALID: ixe,
    ECDSA_SIGNATURE_LENGTH_INVALID: sxe,
    ECDSA_SIGNATURE_PARSE_FAIL: oxe,
    ECDSA_SIGNATURE_PARSE_DER_FAIL: axe,
    ECDSA_SIGNATURE_SERIALIZE_DER_FAIL: cxe,
    ECDSA_SIGN_FAIL: uxe,
    ECDSA_RECOVER_FAIL: lxe,
    MSG32_TYPE_INVALID: dxe,
    MSG32_LENGTH_INVALID: fxe,
    OPTIONS_TYPE_INVALID: hxe,
    OPTIONS_DATA_TYPE_INVALID: pxe,
    OPTIONS_DATA_LENGTH_INVALID: gxe,
    OPTIONS_NONCEFN_TYPE_INVALID: yxe,
    RECOVERY_ID_TYPE_INVALID: bxe,
    RECOVERY_ID_VALUE_INVALID: mxe,
    TWEAK_TYPE_INVALID: wxe,
    TWEAK_LENGTH_INVALID: vxe,
  };
var Te = Hi,
  xl = ll,
  _e = ij;
function zo(e, t) {
  return e === void 0 ? t : (Te.isBoolean(e, _e.COMPRESSED_TYPE_INVALID), e);
}
var _xe = function (e) {
    return {
      privateKeyVerify: function (t) {
        return (
          Te.isBuffer(t, _e.EC_PRIVATE_KEY_TYPE_INVALID), t.length === 32 && e.privateKeyVerify(t)
        );
      },
      privateKeyExport: function (t, n) {
        Te.isBuffer(t, _e.EC_PRIVATE_KEY_TYPE_INVALID),
          Te.isBufferLength(t, 32, _e.EC_PRIVATE_KEY_LENGTH_INVALID),
          (n = zo(n, !0));
        var r = e.privateKeyExport(t, n);
        return xl.privateKeyExport(t, r, n);
      },
      privateKeyImport: function (t) {
        if (
          (Te.isBuffer(t, _e.EC_PRIVATE_KEY_TYPE_INVALID),
          (t = xl.privateKeyImport(t)),
          t && t.length === 32 && e.privateKeyVerify(t))
        )
          return t;
        throw new Error(_e.EC_PRIVATE_KEY_IMPORT_DER_FAIL);
      },
      privateKeyNegate: function (t) {
        return (
          Te.isBuffer(t, _e.EC_PRIVATE_KEY_TYPE_INVALID),
          Te.isBufferLength(t, 32, _e.EC_PRIVATE_KEY_LENGTH_INVALID),
          e.privateKeyNegate(t)
        );
      },
      privateKeyModInverse: function (t) {
        return (
          Te.isBuffer(t, _e.EC_PRIVATE_KEY_TYPE_INVALID),
          Te.isBufferLength(t, 32, _e.EC_PRIVATE_KEY_LENGTH_INVALID),
          e.privateKeyModInverse(t)
        );
      },
      privateKeyTweakAdd: function (t, n) {
        return (
          Te.isBuffer(t, _e.EC_PRIVATE_KEY_TYPE_INVALID),
          Te.isBufferLength(t, 32, _e.EC_PRIVATE_KEY_LENGTH_INVALID),
          Te.isBuffer(n, _e.TWEAK_TYPE_INVALID),
          Te.isBufferLength(n, 32, _e.TWEAK_LENGTH_INVALID),
          e.privateKeyTweakAdd(t, n)
        );
      },
      privateKeyTweakMul: function (t, n) {
        return (
          Te.isBuffer(t, _e.EC_PRIVATE_KEY_TYPE_INVALID),
          Te.isBufferLength(t, 32, _e.EC_PRIVATE_KEY_LENGTH_INVALID),
          Te.isBuffer(n, _e.TWEAK_TYPE_INVALID),
          Te.isBufferLength(n, 32, _e.TWEAK_LENGTH_INVALID),
          e.privateKeyTweakMul(t, n)
        );
      },
      publicKeyCreate: function (t, n) {
        return (
          Te.isBuffer(t, _e.EC_PRIVATE_KEY_TYPE_INVALID),
          Te.isBufferLength(t, 32, _e.EC_PRIVATE_KEY_LENGTH_INVALID),
          (n = zo(n, !0)),
          e.publicKeyCreate(t, n)
        );
      },
      publicKeyConvert: function (t, n) {
        return (
          Te.isBuffer(t, _e.EC_PUBLIC_KEY_TYPE_INVALID),
          Te.isBufferLength2(t, 33, 65, _e.EC_PUBLIC_KEY_LENGTH_INVALID),
          (n = zo(n, !0)),
          e.publicKeyConvert(t, n)
        );
      },
      publicKeyVerify: function (t) {
        return Te.isBuffer(t, _e.EC_PUBLIC_KEY_TYPE_INVALID), e.publicKeyVerify(t);
      },
      publicKeyTweakAdd: function (t, n, r) {
        return (
          Te.isBuffer(t, _e.EC_PUBLIC_KEY_TYPE_INVALID),
          Te.isBufferLength2(t, 33, 65, _e.EC_PUBLIC_KEY_LENGTH_INVALID),
          Te.isBuffer(n, _e.TWEAK_TYPE_INVALID),
          Te.isBufferLength(n, 32, _e.TWEAK_LENGTH_INVALID),
          (r = zo(r, !0)),
          e.publicKeyTweakAdd(t, n, r)
        );
      },
      publicKeyTweakMul: function (t, n, r) {
        return (
          Te.isBuffer(t, _e.EC_PUBLIC_KEY_TYPE_INVALID),
          Te.isBufferLength2(t, 33, 65, _e.EC_PUBLIC_KEY_LENGTH_INVALID),
          Te.isBuffer(n, _e.TWEAK_TYPE_INVALID),
          Te.isBufferLength(n, 32, _e.TWEAK_LENGTH_INVALID),
          (r = zo(r, !0)),
          e.publicKeyTweakMul(t, n, r)
        );
      },
      publicKeyCombine: function (t, n) {
        Te.isArray(t, _e.EC_PUBLIC_KEYS_TYPE_INVALID),
          Te.isLengthGTZero(t, _e.EC_PUBLIC_KEYS_LENGTH_INVALID);
        for (var r = 0; r < t.length; ++r)
          Te.isBuffer(t[r], _e.EC_PUBLIC_KEY_TYPE_INVALID),
            Te.isBufferLength2(t[r], 33, 65, _e.EC_PUBLIC_KEY_LENGTH_INVALID);
        return (n = zo(n, !0)), e.publicKeyCombine(t, n);
      },
      signatureNormalize: function (t) {
        return (
          Te.isBuffer(t, _e.ECDSA_SIGNATURE_TYPE_INVALID),
          Te.isBufferLength(t, 64, _e.ECDSA_SIGNATURE_LENGTH_INVALID),
          e.signatureNormalize(t)
        );
      },
      signatureExport: function (t) {
        Te.isBuffer(t, _e.ECDSA_SIGNATURE_TYPE_INVALID),
          Te.isBufferLength(t, 64, _e.ECDSA_SIGNATURE_LENGTH_INVALID);
        var n = e.signatureExport(t);
        return xl.signatureExport(n);
      },
      signatureImport: function (t) {
        Te.isBuffer(t, _e.ECDSA_SIGNATURE_TYPE_INVALID),
          Te.isLengthGTZero(t, _e.ECDSA_SIGNATURE_LENGTH_INVALID);
        var n = xl.signatureImport(t);
        if (n) return e.signatureImport(n);
        throw new Error(_e.ECDSA_SIGNATURE_PARSE_DER_FAIL);
      },
      signatureImportLax: function (t) {
        Te.isBuffer(t, _e.ECDSA_SIGNATURE_TYPE_INVALID),
          Te.isLengthGTZero(t, _e.ECDSA_SIGNATURE_LENGTH_INVALID);
        var n = xl.signatureImportLax(t);
        if (n) return e.signatureImport(n);
        throw new Error(_e.ECDSA_SIGNATURE_PARSE_DER_FAIL);
      },
      sign: function (t, n, r) {
        Te.isBuffer(t, _e.MSG32_TYPE_INVALID),
          Te.isBufferLength(t, 32, _e.MSG32_LENGTH_INVALID),
          Te.isBuffer(n, _e.EC_PRIVATE_KEY_TYPE_INVALID),
          Te.isBufferLength(n, 32, _e.EC_PRIVATE_KEY_LENGTH_INVALID);
        var i = null,
          s = null;
        return (
          r !== void 0 &&
            (Te.isObject(r, _e.OPTIONS_TYPE_INVALID),
            r.data !== void 0 &&
              (Te.isBuffer(r.data, _e.OPTIONS_DATA_TYPE_INVALID),
              Te.isBufferLength(r.data, 32, _e.OPTIONS_DATA_LENGTH_INVALID),
              (i = r.data)),
            r.noncefn !== void 0 &&
              (Te.isFunction(r.noncefn, _e.OPTIONS_NONCEFN_TYPE_INVALID), (s = r.noncefn))),
          e.sign(t, n, s, i)
        );
      },
      verify: function (t, n, r) {
        return (
          Te.isBuffer(t, _e.MSG32_TYPE_INVALID),
          Te.isBufferLength(t, 32, _e.MSG32_LENGTH_INVALID),
          Te.isBuffer(n, _e.ECDSA_SIGNATURE_TYPE_INVALID),
          Te.isBufferLength(n, 64, _e.ECDSA_SIGNATURE_LENGTH_INVALID),
          Te.isBuffer(r, _e.EC_PUBLIC_KEY_TYPE_INVALID),
          Te.isBufferLength2(r, 33, 65, _e.EC_PUBLIC_KEY_LENGTH_INVALID),
          e.verify(t, n, r)
        );
      },
      recover: function (t, n, r, i) {
        return (
          Te.isBuffer(t, _e.MSG32_TYPE_INVALID),
          Te.isBufferLength(t, 32, _e.MSG32_LENGTH_INVALID),
          Te.isBuffer(n, _e.ECDSA_SIGNATURE_TYPE_INVALID),
          Te.isBufferLength(n, 64, _e.ECDSA_SIGNATURE_LENGTH_INVALID),
          Te.isNumber(r, _e.RECOVERY_ID_TYPE_INVALID),
          Te.isNumberInInterval(r, -1, 4, _e.RECOVERY_ID_VALUE_INVALID),
          (i = zo(i, !0)),
          e.recover(t, n, r, i)
        );
      },
      ecdh: function (t, n) {
        return (
          Te.isBuffer(t, _e.EC_PUBLIC_KEY_TYPE_INVALID),
          Te.isBufferLength2(t, 33, 65, _e.EC_PUBLIC_KEY_LENGTH_INVALID),
          Te.isBuffer(n, _e.EC_PRIVATE_KEY_TYPE_INVALID),
          Te.isBufferLength(n, 32, _e.EC_PRIVATE_KEY_LENGTH_INVALID),
          e.ecdh(t, n)
        );
      },
      ecdhUnsafe: function (t, n, r) {
        return (
          Te.isBuffer(t, _e.EC_PUBLIC_KEY_TYPE_INVALID),
          Te.isBufferLength2(t, 33, 65, _e.EC_PUBLIC_KEY_LENGTH_INVALID),
          Te.isBuffer(n, _e.EC_PRIVATE_KEY_TYPE_INVALID),
          Te.isBufferLength(n, 32, _e.EC_PRIVATE_KEY_LENGTH_INVALID),
          (r = zo(r, !0)),
          e.ecdhUnsafe(t, n, r)
        );
      },
    };
  },
  sj = {},
  DT = { exports: {} };
DT.exports;
(function (e) {
  (function (t, n) {
    function r(E, y) {
      if (!E) throw new Error(y || 'Assertion failed');
    }
    function i(E, y) {
      E.super_ = y;
      var v = function () {};
      (v.prototype = y.prototype), (E.prototype = new v()), (E.prototype.constructor = E);
    }
    function s(E, y, v) {
      if (s.isBN(E)) return E;
      (this.negative = 0),
        (this.words = null),
        (this.length = 0),
        (this.red = null),
        E !== null &&
          ((y === 'le' || y === 'be') && ((v = y), (y = 10)),
          this._init(E || 0, y || 10, v || 'be'));
    }
    typeof t == 'object' ? (t.exports = s) : (n.BN = s), (s.BN = s), (s.wordSize = 26);
    var o;
    try {
      typeof window < 'u' && typeof window.Buffer < 'u' ? (o = window.Buffer) : (o = kL.Buffer);
    } catch {}
    (s.isBN = function (y) {
      return y instanceof s
        ? !0
        : y !== null &&
            typeof y == 'object' &&
            y.constructor.wordSize === s.wordSize &&
            Array.isArray(y.words);
    }),
      (s.max = function (y, v) {
        return y.cmp(v) > 0 ? y : v;
      }),
      (s.min = function (y, v) {
        return y.cmp(v) < 0 ? y : v;
      }),
      (s.prototype._init = function (y, v, S) {
        if (typeof y == 'number') return this._initNumber(y, v, S);
        if (typeof y == 'object') return this._initArray(y, v, S);
        v === 'hex' && (v = 16),
          r(v === (v | 0) && v >= 2 && v <= 36),
          (y = y.toString().replace(/\s+/g, ''));
        var T = 0;
        y[0] === '-' && (T++, (this.negative = 1)),
          T < y.length &&
            (v === 16
              ? this._parseHex(y, T, S)
              : (this._parseBase(y, v, T), S === 'le' && this._initArray(this.toArray(), v, S)));
      }),
      (s.prototype._initNumber = function (y, v, S) {
        y < 0 && ((this.negative = 1), (y = -y)),
          y < 67108864
            ? ((this.words = [y & 67108863]), (this.length = 1))
            : y < 4503599627370496
              ? ((this.words = [y & 67108863, (y / 67108864) & 67108863]), (this.length = 2))
              : (r(y < 9007199254740992),
                (this.words = [y & 67108863, (y / 67108864) & 67108863, 1]),
                (this.length = 3)),
          S === 'le' && this._initArray(this.toArray(), v, S);
      }),
      (s.prototype._initArray = function (y, v, S) {
        if ((r(typeof y.length == 'number'), y.length <= 0))
          return (this.words = [0]), (this.length = 1), this;
        (this.length = Math.ceil(y.length / 3)), (this.words = new Array(this.length));
        for (var T = 0; T < this.length; T++) this.words[T] = 0;
        var M,
          R,
          L = 0;
        if (S === 'be')
          for (T = y.length - 1, M = 0; T >= 0; T -= 3)
            (R = y[T] | (y[T - 1] << 8) | (y[T - 2] << 16)),
              (this.words[M] |= (R << L) & 67108863),
              (this.words[M + 1] = (R >>> (26 - L)) & 67108863),
              (L += 24),
              L >= 26 && ((L -= 26), M++);
        else if (S === 'le')
          for (T = 0, M = 0; T < y.length; T += 3)
            (R = y[T] | (y[T + 1] << 8) | (y[T + 2] << 16)),
              (this.words[M] |= (R << L) & 67108863),
              (this.words[M + 1] = (R >>> (26 - L)) & 67108863),
              (L += 24),
              L >= 26 && ((L -= 26), M++);
        return this.strip();
      });
    function a(E, y) {
      var v = E.charCodeAt(y);
      return v >= 65 && v <= 70 ? v - 55 : v >= 97 && v <= 102 ? v - 87 : (v - 48) & 15;
    }
    function c(E, y, v) {
      var S = a(E, v);
      return v - 1 >= y && (S |= a(E, v - 1) << 4), S;
    }
    s.prototype._parseHex = function (y, v, S) {
      (this.length = Math.ceil((y.length - v) / 6)), (this.words = new Array(this.length));
      for (var T = 0; T < this.length; T++) this.words[T] = 0;
      var M = 0,
        R = 0,
        L;
      if (S === 'be')
        for (T = y.length - 1; T >= v; T -= 2)
          (L = c(y, v, T) << M),
            (this.words[R] |= L & 67108863),
            M >= 18 ? ((M -= 18), (R += 1), (this.words[R] |= L >>> 26)) : (M += 8);
      else {
        var O = y.length - v;
        for (T = O % 2 === 0 ? v + 1 : v; T < y.length; T += 2)
          (L = c(y, v, T) << M),
            (this.words[R] |= L & 67108863),
            M >= 18 ? ((M -= 18), (R += 1), (this.words[R] |= L >>> 26)) : (M += 8);
      }
      this.strip();
    };
    function u(E, y, v, S) {
      for (var T = 0, M = Math.min(E.length, v), R = y; R < M; R++) {
        var L = E.charCodeAt(R) - 48;
        (T *= S), L >= 49 ? (T += L - 49 + 10) : L >= 17 ? (T += L - 17 + 10) : (T += L);
      }
      return T;
    }
    (s.prototype._parseBase = function (y, v, S) {
      (this.words = [0]), (this.length = 1);
      for (var T = 0, M = 1; M <= 67108863; M *= v) T++;
      T--, (M = (M / v) | 0);
      for (var R = y.length - S, L = R % T, O = Math.min(R, R - L) + S, I = 0, U = S; U < O; U += T)
        (I = u(y, U, U + T, v)),
          this.imuln(M),
          this.words[0] + I < 67108864 ? (this.words[0] += I) : this._iaddn(I);
      if (L !== 0) {
        var H = 1;
        for (I = u(y, U, y.length, v), U = 0; U < L; U++) H *= v;
        this.imuln(H), this.words[0] + I < 67108864 ? (this.words[0] += I) : this._iaddn(I);
      }
      this.strip();
    }),
      (s.prototype.copy = function (y) {
        y.words = new Array(this.length);
        for (var v = 0; v < this.length; v++) y.words[v] = this.words[v];
        (y.length = this.length), (y.negative = this.negative), (y.red = this.red);
      }),
      (s.prototype.clone = function () {
        var y = new s(null);
        return this.copy(y), y;
      }),
      (s.prototype._expand = function (y) {
        for (; this.length < y; ) this.words[this.length++] = 0;
        return this;
      }),
      (s.prototype.strip = function () {
        for (; this.length > 1 && this.words[this.length - 1] === 0; ) this.length--;
        return this._normSign();
      }),
      (s.prototype._normSign = function () {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }),
      (s.prototype.inspect = function () {
        return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
      });
    var l = [
        '',
        '0',
        '00',
        '000',
        '0000',
        '00000',
        '000000',
        '0000000',
        '00000000',
        '000000000',
        '0000000000',
        '00000000000',
        '000000000000',
        '0000000000000',
        '00000000000000',
        '000000000000000',
        '0000000000000000',
        '00000000000000000',
        '000000000000000000',
        '0000000000000000000',
        '00000000000000000000',
        '000000000000000000000',
        '0000000000000000000000',
        '00000000000000000000000',
        '000000000000000000000000',
        '0000000000000000000000000',
      ],
      d = [
        0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5,
        5, 5, 5, 5, 5, 5, 5, 5,
      ],
      f = [
        0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7,
        19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881,
        64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
        243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176,
      ];
    (s.prototype.toString = function (y, v) {
      (y = y || 10), (v = v | 0 || 1);
      var S;
      if (y === 16 || y === 'hex') {
        S = '';
        for (var T = 0, M = 0, R = 0; R < this.length; R++) {
          var L = this.words[R],
            O = (((L << T) | M) & 16777215).toString(16);
          (M = (L >>> (24 - T)) & 16777215),
            M !== 0 || R !== this.length - 1 ? (S = l[6 - O.length] + O + S) : (S = O + S),
            (T += 2),
            T >= 26 && ((T -= 26), R--);
        }
        for (M !== 0 && (S = M.toString(16) + S); S.length % v !== 0; ) S = '0' + S;
        return this.negative !== 0 && (S = '-' + S), S;
      }
      if (y === (y | 0) && y >= 2 && y <= 36) {
        var I = d[y],
          U = f[y];
        S = '';
        var H = this.clone();
        for (H.negative = 0; !H.isZero(); ) {
          var X = H.modn(U).toString(y);
          (H = H.idivn(U)), H.isZero() ? (S = X + S) : (S = l[I - X.length] + X + S);
        }
        for (this.isZero() && (S = '0' + S); S.length % v !== 0; ) S = '0' + S;
        return this.negative !== 0 && (S = '-' + S), S;
      }
      r(!1, 'Base should be between 2 and 36');
    }),
      (s.prototype.toNumber = function () {
        var y = this.words[0];
        return (
          this.length === 2
            ? (y += this.words[1] * 67108864)
            : this.length === 3 && this.words[2] === 1
              ? (y += 4503599627370496 + this.words[1] * 67108864)
              : this.length > 2 && r(!1, 'Number can only safely store up to 53 bits'),
          this.negative !== 0 ? -y : y
        );
      }),
      (s.prototype.toJSON = function () {
        return this.toString(16);
      }),
      (s.prototype.toBuffer = function (y, v) {
        return r(typeof o < 'u'), this.toArrayLike(o, y, v);
      }),
      (s.prototype.toArray = function (y, v) {
        return this.toArrayLike(Array, y, v);
      }),
      (s.prototype.toArrayLike = function (y, v, S) {
        var T = this.byteLength(),
          M = S || Math.max(1, T);
        r(T <= M, 'byte array longer than desired length'),
          r(M > 0, 'Requested array length <= 0'),
          this.strip();
        var R = v === 'le',
          L = new y(M),
          O,
          I,
          U = this.clone();
        if (R) {
          for (I = 0; !U.isZero(); I++) (O = U.andln(255)), U.iushrn(8), (L[I] = O);
          for (; I < M; I++) L[I] = 0;
        } else {
          for (I = 0; I < M - T; I++) L[I] = 0;
          for (I = 0; !U.isZero(); I++) (O = U.andln(255)), U.iushrn(8), (L[M - I - 1] = O);
        }
        return L;
      }),
      Math.clz32
        ? (s.prototype._countBits = function (y) {
            return 32 - Math.clz32(y);
          })
        : (s.prototype._countBits = function (y) {
            var v = y,
              S = 0;
            return (
              v >= 4096 && ((S += 13), (v >>>= 13)),
              v >= 64 && ((S += 7), (v >>>= 7)),
              v >= 8 && ((S += 4), (v >>>= 4)),
              v >= 2 && ((S += 2), (v >>>= 2)),
              S + v
            );
          }),
      (s.prototype._zeroBits = function (y) {
        if (y === 0) return 26;
        var v = y,
          S = 0;
        return (
          v & 8191 || ((S += 13), (v >>>= 13)),
          v & 127 || ((S += 7), (v >>>= 7)),
          v & 15 || ((S += 4), (v >>>= 4)),
          v & 3 || ((S += 2), (v >>>= 2)),
          v & 1 || S++,
          S
        );
      }),
      (s.prototype.bitLength = function () {
        var y = this.words[this.length - 1],
          v = this._countBits(y);
        return (this.length - 1) * 26 + v;
      });
    function h(E) {
      for (var y = new Array(E.bitLength()), v = 0; v < y.length; v++) {
        var S = (v / 26) | 0,
          T = v % 26;
        y[v] = (E.words[S] & (1 << T)) >>> T;
      }
      return y;
    }
    (s.prototype.zeroBits = function () {
      if (this.isZero()) return 0;
      for (var y = 0, v = 0; v < this.length; v++) {
        var S = this._zeroBits(this.words[v]);
        if (((y += S), S !== 26)) break;
      }
      return y;
    }),
      (s.prototype.byteLength = function () {
        return Math.ceil(this.bitLength() / 8);
      }),
      (s.prototype.toTwos = function (y) {
        return this.negative !== 0 ? this.abs().inotn(y).iaddn(1) : this.clone();
      }),
      (s.prototype.fromTwos = function (y) {
        return this.testn(y - 1) ? this.notn(y).iaddn(1).ineg() : this.clone();
      }),
      (s.prototype.isNeg = function () {
        return this.negative !== 0;
      }),
      (s.prototype.neg = function () {
        return this.clone().ineg();
      }),
      (s.prototype.ineg = function () {
        return this.isZero() || (this.negative ^= 1), this;
      }),
      (s.prototype.iuor = function (y) {
        for (; this.length < y.length; ) this.words[this.length++] = 0;
        for (var v = 0; v < y.length; v++) this.words[v] = this.words[v] | y.words[v];
        return this.strip();
      }),
      (s.prototype.ior = function (y) {
        return r((this.negative | y.negative) === 0), this.iuor(y);
      }),
      (s.prototype.or = function (y) {
        return this.length > y.length ? this.clone().ior(y) : y.clone().ior(this);
      }),
      (s.prototype.uor = function (y) {
        return this.length > y.length ? this.clone().iuor(y) : y.clone().iuor(this);
      }),
      (s.prototype.iuand = function (y) {
        var v;
        this.length > y.length ? (v = y) : (v = this);
        for (var S = 0; S < v.length; S++) this.words[S] = this.words[S] & y.words[S];
        return (this.length = v.length), this.strip();
      }),
      (s.prototype.iand = function (y) {
        return r((this.negative | y.negative) === 0), this.iuand(y);
      }),
      (s.prototype.and = function (y) {
        return this.length > y.length ? this.clone().iand(y) : y.clone().iand(this);
      }),
      (s.prototype.uand = function (y) {
        return this.length > y.length ? this.clone().iuand(y) : y.clone().iuand(this);
      }),
      (s.prototype.iuxor = function (y) {
        var v, S;
        this.length > y.length ? ((v = this), (S = y)) : ((v = y), (S = this));
        for (var T = 0; T < S.length; T++) this.words[T] = v.words[T] ^ S.words[T];
        if (this !== v) for (; T < v.length; T++) this.words[T] = v.words[T];
        return (this.length = v.length), this.strip();
      }),
      (s.prototype.ixor = function (y) {
        return r((this.negative | y.negative) === 0), this.iuxor(y);
      }),
      (s.prototype.xor = function (y) {
        return this.length > y.length ? this.clone().ixor(y) : y.clone().ixor(this);
      }),
      (s.prototype.uxor = function (y) {
        return this.length > y.length ? this.clone().iuxor(y) : y.clone().iuxor(this);
      }),
      (s.prototype.inotn = function (y) {
        r(typeof y == 'number' && y >= 0);
        var v = Math.ceil(y / 26) | 0,
          S = y % 26;
        this._expand(v), S > 0 && v--;
        for (var T = 0; T < v; T++) this.words[T] = ~this.words[T] & 67108863;
        return S > 0 && (this.words[T] = ~this.words[T] & (67108863 >> (26 - S))), this.strip();
      }),
      (s.prototype.notn = function (y) {
        return this.clone().inotn(y);
      }),
      (s.prototype.setn = function (y, v) {
        r(typeof y == 'number' && y >= 0);
        var S = (y / 26) | 0,
          T = y % 26;
        return (
          this._expand(S + 1),
          v
            ? (this.words[S] = this.words[S] | (1 << T))
            : (this.words[S] = this.words[S] & ~(1 << T)),
          this.strip()
        );
      }),
      (s.prototype.iadd = function (y) {
        var v;
        if (this.negative !== 0 && y.negative === 0)
          return (this.negative = 0), (v = this.isub(y)), (this.negative ^= 1), this._normSign();
        if (this.negative === 0 && y.negative !== 0)
          return (y.negative = 0), (v = this.isub(y)), (y.negative = 1), v._normSign();
        var S, T;
        this.length > y.length ? ((S = this), (T = y)) : ((S = y), (T = this));
        for (var M = 0, R = 0; R < T.length; R++)
          (v = (S.words[R] | 0) + (T.words[R] | 0) + M),
            (this.words[R] = v & 67108863),
            (M = v >>> 26);
        for (; M !== 0 && R < S.length; R++)
          (v = (S.words[R] | 0) + M), (this.words[R] = v & 67108863), (M = v >>> 26);
        if (((this.length = S.length), M !== 0)) (this.words[this.length] = M), this.length++;
        else if (S !== this) for (; R < S.length; R++) this.words[R] = S.words[R];
        return this;
      }),
      (s.prototype.add = function (y) {
        var v;
        return y.negative !== 0 && this.negative === 0
          ? ((y.negative = 0), (v = this.sub(y)), (y.negative ^= 1), v)
          : y.negative === 0 && this.negative !== 0
            ? ((this.negative = 0), (v = y.sub(this)), (this.negative = 1), v)
            : this.length > y.length
              ? this.clone().iadd(y)
              : y.clone().iadd(this);
      }),
      (s.prototype.isub = function (y) {
        if (y.negative !== 0) {
          y.negative = 0;
          var v = this.iadd(y);
          return (y.negative = 1), v._normSign();
        } else if (this.negative !== 0)
          return (this.negative = 0), this.iadd(y), (this.negative = 1), this._normSign();
        var S = this.cmp(y);
        if (S === 0) return (this.negative = 0), (this.length = 1), (this.words[0] = 0), this;
        var T, M;
        S > 0 ? ((T = this), (M = y)) : ((T = y), (M = this));
        for (var R = 0, L = 0; L < M.length; L++)
          (v = (T.words[L] | 0) - (M.words[L] | 0) + R),
            (R = v >> 26),
            (this.words[L] = v & 67108863);
        for (; R !== 0 && L < T.length; L++)
          (v = (T.words[L] | 0) + R), (R = v >> 26), (this.words[L] = v & 67108863);
        if (R === 0 && L < T.length && T !== this)
          for (; L < T.length; L++) this.words[L] = T.words[L];
        return (
          (this.length = Math.max(this.length, L)), T !== this && (this.negative = 1), this.strip()
        );
      }),
      (s.prototype.sub = function (y) {
        return this.clone().isub(y);
      });
    function p(E, y, v) {
      v.negative = y.negative ^ E.negative;
      var S = (E.length + y.length) | 0;
      (v.length = S), (S = (S - 1) | 0);
      var T = E.words[0] | 0,
        M = y.words[0] | 0,
        R = T * M,
        L = R & 67108863,
        O = (R / 67108864) | 0;
      v.words[0] = L;
      for (var I = 1; I < S; I++) {
        for (
          var U = O >>> 26,
            H = O & 67108863,
            X = Math.min(I, y.length - 1),
            J = Math.max(0, I - E.length + 1);
          J <= X;
          J++
        ) {
          var ie = (I - J) | 0;
          (T = E.words[ie] | 0),
            (M = y.words[J] | 0),
            (R = T * M + H),
            (U += (R / 67108864) | 0),
            (H = R & 67108863);
        }
        (v.words[I] = H | 0), (O = U | 0);
      }
      return O !== 0 ? (v.words[I] = O | 0) : v.length--, v.strip();
    }
    var b = function (y, v, S) {
      var T = y.words,
        M = v.words,
        R = S.words,
        L = 0,
        O,
        I,
        U,
        H = T[0] | 0,
        X = H & 8191,
        J = H >>> 13,
        ie = T[1] | 0,
        Z = ie & 8191,
        be = ie >>> 13,
        le = T[2] | 0,
        Oe = le & 8191,
        Re = le >>> 13,
        ht = T[3] | 0,
        xe = ht & 8191,
        We = ht >>> 13,
        Yt = T[4] | 0,
        Fe = Yt & 8191,
        nt = Yt >>> 13,
        vt = T[5] | 0,
        ut = vt & 8191,
        Ut = vt >>> 13,
        dn = T[6] | 0,
        Kt = dn & 8191,
        $t = dn >>> 13,
        Er = T[7] | 0,
        Pe = Er & 8191,
        Qe = Er >>> 13,
        Oc = T[8] | 0,
        Zt = Oc & 8191,
        Mt = Oc >>> 13,
        YT = T[9] | 0,
        fn = YT & 8191,
        hn = YT >>> 13,
        ZT = M[0] | 0,
        pn = ZT & 8191,
        gn = ZT >>> 13,
        JT = M[1] | 0,
        yn = JT & 8191,
        bn = JT >>> 13,
        XT = M[2] | 0,
        mn = XT & 8191,
        wn = XT >>> 13,
        QT = M[3] | 0,
        vn = QT & 8191,
        _n = QT >>> 13,
        ex = M[4] | 0,
        Sn = ex & 8191,
        En = ex >>> 13,
        tx = M[5] | 0,
        An = tx & 8191,
        In = tx >>> 13,
        nx = M[6] | 0,
        Tn = nx & 8191,
        xn = nx >>> 13,
        rx = M[7] | 0,
        kn = rx & 8191,
        Cn = rx >>> 13,
        ix = M[8] | 0,
        Pn = ix & 8191,
        Mn = ix >>> 13,
        sx = M[9] | 0,
        On = sx & 8191,
        Bn = sx >>> 13;
      (S.negative = y.negative ^ v.negative),
        (S.length = 19),
        (O = Math.imul(X, pn)),
        (I = Math.imul(X, gn)),
        (I = (I + Math.imul(J, pn)) | 0),
        (U = Math.imul(J, gn));
      var ew = (((L + O) | 0) + ((I & 8191) << 13)) | 0;
      (L = (((U + (I >>> 13)) | 0) + (ew >>> 26)) | 0),
        (ew &= 67108863),
        (O = Math.imul(Z, pn)),
        (I = Math.imul(Z, gn)),
        (I = (I + Math.imul(be, pn)) | 0),
        (U = Math.imul(be, gn)),
        (O = (O + Math.imul(X, yn)) | 0),
        (I = (I + Math.imul(X, bn)) | 0),
        (I = (I + Math.imul(J, yn)) | 0),
        (U = (U + Math.imul(J, bn)) | 0);
      var tw = (((L + O) | 0) + ((I & 8191) << 13)) | 0;
      (L = (((U + (I >>> 13)) | 0) + (tw >>> 26)) | 0),
        (tw &= 67108863),
        (O = Math.imul(Oe, pn)),
        (I = Math.imul(Oe, gn)),
        (I = (I + Math.imul(Re, pn)) | 0),
        (U = Math.imul(Re, gn)),
        (O = (O + Math.imul(Z, yn)) | 0),
        (I = (I + Math.imul(Z, bn)) | 0),
        (I = (I + Math.imul(be, yn)) | 0),
        (U = (U + Math.imul(be, bn)) | 0),
        (O = (O + Math.imul(X, mn)) | 0),
        (I = (I + Math.imul(X, wn)) | 0),
        (I = (I + Math.imul(J, mn)) | 0),
        (U = (U + Math.imul(J, wn)) | 0);
      var nw = (((L + O) | 0) + ((I & 8191) << 13)) | 0;
      (L = (((U + (I >>> 13)) | 0) + (nw >>> 26)) | 0),
        (nw &= 67108863),
        (O = Math.imul(xe, pn)),
        (I = Math.imul(xe, gn)),
        (I = (I + Math.imul(We, pn)) | 0),
        (U = Math.imul(We, gn)),
        (O = (O + Math.imul(Oe, yn)) | 0),
        (I = (I + Math.imul(Oe, bn)) | 0),
        (I = (I + Math.imul(Re, yn)) | 0),
        (U = (U + Math.imul(Re, bn)) | 0),
        (O = (O + Math.imul(Z, mn)) | 0),
        (I = (I + Math.imul(Z, wn)) | 0),
        (I = (I + Math.imul(be, mn)) | 0),
        (U = (U + Math.imul(be, wn)) | 0),
        (O = (O + Math.imul(X, vn)) | 0),
        (I = (I + Math.imul(X, _n)) | 0),
        (I = (I + Math.imul(J, vn)) | 0),
        (U = (U + Math.imul(J, _n)) | 0);
      var rw = (((L + O) | 0) + ((I & 8191) << 13)) | 0;
      (L = (((U + (I >>> 13)) | 0) + (rw >>> 26)) | 0),
        (rw &= 67108863),
        (O = Math.imul(Fe, pn)),
        (I = Math.imul(Fe, gn)),
        (I = (I + Math.imul(nt, pn)) | 0),
        (U = Math.imul(nt, gn)),
        (O = (O + Math.imul(xe, yn)) | 0),
        (I = (I + Math.imul(xe, bn)) | 0),
        (I = (I + Math.imul(We, yn)) | 0),
        (U = (U + Math.imul(We, bn)) | 0),
        (O = (O + Math.imul(Oe, mn)) | 0),
        (I = (I + Math.imul(Oe, wn)) | 0),
        (I = (I + Math.imul(Re, mn)) | 0),
        (U = (U + Math.imul(Re, wn)) | 0),
        (O = (O + Math.imul(Z, vn)) | 0),
        (I = (I + Math.imul(Z, _n)) | 0),
        (I = (I + Math.imul(be, vn)) | 0),
        (U = (U + Math.imul(be, _n)) | 0),
        (O = (O + Math.imul(X, Sn)) | 0),
        (I = (I + Math.imul(X, En)) | 0),
        (I = (I + Math.imul(J, Sn)) | 0),
        (U = (U + Math.imul(J, En)) | 0);
      var iw = (((L + O) | 0) + ((I & 8191) << 13)) | 0;
      (L = (((U + (I >>> 13)) | 0) + (iw >>> 26)) | 0),
        (iw &= 67108863),
        (O = Math.imul(ut, pn)),
        (I = Math.imul(ut, gn)),
        (I = (I + Math.imul(Ut, pn)) | 0),
        (U = Math.imul(Ut, gn)),
        (O = (O + Math.imul(Fe, yn)) | 0),
        (I = (I + Math.imul(Fe, bn)) | 0),
        (I = (I + Math.imul(nt, yn)) | 0),
        (U = (U + Math.imul(nt, bn)) | 0),
        (O = (O + Math.imul(xe, mn)) | 0),
        (I = (I + Math.imul(xe, wn)) | 0),
        (I = (I + Math.imul(We, mn)) | 0),
        (U = (U + Math.imul(We, wn)) | 0),
        (O = (O + Math.imul(Oe, vn)) | 0),
        (I = (I + Math.imul(Oe, _n)) | 0),
        (I = (I + Math.imul(Re, vn)) | 0),
        (U = (U + Math.imul(Re, _n)) | 0),
        (O = (O + Math.imul(Z, Sn)) | 0),
        (I = (I + Math.imul(Z, En)) | 0),
        (I = (I + Math.imul(be, Sn)) | 0),
        (U = (U + Math.imul(be, En)) | 0),
        (O = (O + Math.imul(X, An)) | 0),
        (I = (I + Math.imul(X, In)) | 0),
        (I = (I + Math.imul(J, An)) | 0),
        (U = (U + Math.imul(J, In)) | 0);
      var sw = (((L + O) | 0) + ((I & 8191) << 13)) | 0;
      (L = (((U + (I >>> 13)) | 0) + (sw >>> 26)) | 0),
        (sw &= 67108863),
        (O = Math.imul(Kt, pn)),
        (I = Math.imul(Kt, gn)),
        (I = (I + Math.imul($t, pn)) | 0),
        (U = Math.imul($t, gn)),
        (O = (O + Math.imul(ut, yn)) | 0),
        (I = (I + Math.imul(ut, bn)) | 0),
        (I = (I + Math.imul(Ut, yn)) | 0),
        (U = (U + Math.imul(Ut, bn)) | 0),
        (O = (O + Math.imul(Fe, mn)) | 0),
        (I = (I + Math.imul(Fe, wn)) | 0),
        (I = (I + Math.imul(nt, mn)) | 0),
        (U = (U + Math.imul(nt, wn)) | 0),
        (O = (O + Math.imul(xe, vn)) | 0),
        (I = (I + Math.imul(xe, _n)) | 0),
        (I = (I + Math.imul(We, vn)) | 0),
        (U = (U + Math.imul(We, _n)) | 0),
        (O = (O + Math.imul(Oe, Sn)) | 0),
        (I = (I + Math.imul(Oe, En)) | 0),
        (I = (I + Math.imul(Re, Sn)) | 0),
        (U = (U + Math.imul(Re, En)) | 0),
        (O = (O + Math.imul(Z, An)) | 0),
        (I = (I + Math.imul(Z, In)) | 0),
        (I = (I + Math.imul(be, An)) | 0),
        (U = (U + Math.imul(be, In)) | 0),
        (O = (O + Math.imul(X, Tn)) | 0),
        (I = (I + Math.imul(X, xn)) | 0),
        (I = (I + Math.imul(J, Tn)) | 0),
        (U = (U + Math.imul(J, xn)) | 0);
      var ow = (((L + O) | 0) + ((I & 8191) << 13)) | 0;
      (L = (((U + (I >>> 13)) | 0) + (ow >>> 26)) | 0),
        (ow &= 67108863),
        (O = Math.imul(Pe, pn)),
        (I = Math.imul(Pe, gn)),
        (I = (I + Math.imul(Qe, pn)) | 0),
        (U = Math.imul(Qe, gn)),
        (O = (O + Math.imul(Kt, yn)) | 0),
        (I = (I + Math.imul(Kt, bn)) | 0),
        (I = (I + Math.imul($t, yn)) | 0),
        (U = (U + Math.imul($t, bn)) | 0),
        (O = (O + Math.imul(ut, mn)) | 0),
        (I = (I + Math.imul(ut, wn)) | 0),
        (I = (I + Math.imul(Ut, mn)) | 0),
        (U = (U + Math.imul(Ut, wn)) | 0),
        (O = (O + Math.imul(Fe, vn)) | 0),
        (I = (I + Math.imul(Fe, _n)) | 0),
        (I = (I + Math.imul(nt, vn)) | 0),
        (U = (U + Math.imul(nt, _n)) | 0),
        (O = (O + Math.imul(xe, Sn)) | 0),
        (I = (I + Math.imul(xe, En)) | 0),
        (I = (I + Math.imul(We, Sn)) | 0),
        (U = (U + Math.imul(We, En)) | 0),
        (O = (O + Math.imul(Oe, An)) | 0),
        (I = (I + Math.imul(Oe, In)) | 0),
        (I = (I + Math.imul(Re, An)) | 0),
        (U = (U + Math.imul(Re, In)) | 0),
        (O = (O + Math.imul(Z, Tn)) | 0),
        (I = (I + Math.imul(Z, xn)) | 0),
        (I = (I + Math.imul(be, Tn)) | 0),
        (U = (U + Math.imul(be, xn)) | 0),
        (O = (O + Math.imul(X, kn)) | 0),
        (I = (I + Math.imul(X, Cn)) | 0),
        (I = (I + Math.imul(J, kn)) | 0),
        (U = (U + Math.imul(J, Cn)) | 0);
      var aw = (((L + O) | 0) + ((I & 8191) << 13)) | 0;
      (L = (((U + (I >>> 13)) | 0) + (aw >>> 26)) | 0),
        (aw &= 67108863),
        (O = Math.imul(Zt, pn)),
        (I = Math.imul(Zt, gn)),
        (I = (I + Math.imul(Mt, pn)) | 0),
        (U = Math.imul(Mt, gn)),
        (O = (O + Math.imul(Pe, yn)) | 0),
        (I = (I + Math.imul(Pe, bn)) | 0),
        (I = (I + Math.imul(Qe, yn)) | 0),
        (U = (U + Math.imul(Qe, bn)) | 0),
        (O = (O + Math.imul(Kt, mn)) | 0),
        (I = (I + Math.imul(Kt, wn)) | 0),
        (I = (I + Math.imul($t, mn)) | 0),
        (U = (U + Math.imul($t, wn)) | 0),
        (O = (O + Math.imul(ut, vn)) | 0),
        (I = (I + Math.imul(ut, _n)) | 0),
        (I = (I + Math.imul(Ut, vn)) | 0),
        (U = (U + Math.imul(Ut, _n)) | 0),
        (O = (O + Math.imul(Fe, Sn)) | 0),
        (I = (I + Math.imul(Fe, En)) | 0),
        (I = (I + Math.imul(nt, Sn)) | 0),
        (U = (U + Math.imul(nt, En)) | 0),
        (O = (O + Math.imul(xe, An)) | 0),
        (I = (I + Math.imul(xe, In)) | 0),
        (I = (I + Math.imul(We, An)) | 0),
        (U = (U + Math.imul(We, In)) | 0),
        (O = (O + Math.imul(Oe, Tn)) | 0),
        (I = (I + Math.imul(Oe, xn)) | 0),
        (I = (I + Math.imul(Re, Tn)) | 0),
        (U = (U + Math.imul(Re, xn)) | 0),
        (O = (O + Math.imul(Z, kn)) | 0),
        (I = (I + Math.imul(Z, Cn)) | 0),
        (I = (I + Math.imul(be, kn)) | 0),
        (U = (U + Math.imul(be, Cn)) | 0),
        (O = (O + Math.imul(X, Pn)) | 0),
        (I = (I + Math.imul(X, Mn)) | 0),
        (I = (I + Math.imul(J, Pn)) | 0),
        (U = (U + Math.imul(J, Mn)) | 0);
      var cw = (((L + O) | 0) + ((I & 8191) << 13)) | 0;
      (L = (((U + (I >>> 13)) | 0) + (cw >>> 26)) | 0),
        (cw &= 67108863),
        (O = Math.imul(fn, pn)),
        (I = Math.imul(fn, gn)),
        (I = (I + Math.imul(hn, pn)) | 0),
        (U = Math.imul(hn, gn)),
        (O = (O + Math.imul(Zt, yn)) | 0),
        (I = (I + Math.imul(Zt, bn)) | 0),
        (I = (I + Math.imul(Mt, yn)) | 0),
        (U = (U + Math.imul(Mt, bn)) | 0),
        (O = (O + Math.imul(Pe, mn)) | 0),
        (I = (I + Math.imul(Pe, wn)) | 0),
        (I = (I + Math.imul(Qe, mn)) | 0),
        (U = (U + Math.imul(Qe, wn)) | 0),
        (O = (O + Math.imul(Kt, vn)) | 0),
        (I = (I + Math.imul(Kt, _n)) | 0),
        (I = (I + Math.imul($t, vn)) | 0),
        (U = (U + Math.imul($t, _n)) | 0),
        (O = (O + Math.imul(ut, Sn)) | 0),
        (I = (I + Math.imul(ut, En)) | 0),
        (I = (I + Math.imul(Ut, Sn)) | 0),
        (U = (U + Math.imul(Ut, En)) | 0),
        (O = (O + Math.imul(Fe, An)) | 0),
        (I = (I + Math.imul(Fe, In)) | 0),
        (I = (I + Math.imul(nt, An)) | 0),
        (U = (U + Math.imul(nt, In)) | 0),
        (O = (O + Math.imul(xe, Tn)) | 0),
        (I = (I + Math.imul(xe, xn)) | 0),
        (I = (I + Math.imul(We, Tn)) | 0),
        (U = (U + Math.imul(We, xn)) | 0),
        (O = (O + Math.imul(Oe, kn)) | 0),
        (I = (I + Math.imul(Oe, Cn)) | 0),
        (I = (I + Math.imul(Re, kn)) | 0),
        (U = (U + Math.imul(Re, Cn)) | 0),
        (O = (O + Math.imul(Z, Pn)) | 0),
        (I = (I + Math.imul(Z, Mn)) | 0),
        (I = (I + Math.imul(be, Pn)) | 0),
        (U = (U + Math.imul(be, Mn)) | 0),
        (O = (O + Math.imul(X, On)) | 0),
        (I = (I + Math.imul(X, Bn)) | 0),
        (I = (I + Math.imul(J, On)) | 0),
        (U = (U + Math.imul(J, Bn)) | 0);
      var uw = (((L + O) | 0) + ((I & 8191) << 13)) | 0;
      (L = (((U + (I >>> 13)) | 0) + (uw >>> 26)) | 0),
        (uw &= 67108863),
        (O = Math.imul(fn, yn)),
        (I = Math.imul(fn, bn)),
        (I = (I + Math.imul(hn, yn)) | 0),
        (U = Math.imul(hn, bn)),
        (O = (O + Math.imul(Zt, mn)) | 0),
        (I = (I + Math.imul(Zt, wn)) | 0),
        (I = (I + Math.imul(Mt, mn)) | 0),
        (U = (U + Math.imul(Mt, wn)) | 0),
        (O = (O + Math.imul(Pe, vn)) | 0),
        (I = (I + Math.imul(Pe, _n)) | 0),
        (I = (I + Math.imul(Qe, vn)) | 0),
        (U = (U + Math.imul(Qe, _n)) | 0),
        (O = (O + Math.imul(Kt, Sn)) | 0),
        (I = (I + Math.imul(Kt, En)) | 0),
        (I = (I + Math.imul($t, Sn)) | 0),
        (U = (U + Math.imul($t, En)) | 0),
        (O = (O + Math.imul(ut, An)) | 0),
        (I = (I + Math.imul(ut, In)) | 0),
        (I = (I + Math.imul(Ut, An)) | 0),
        (U = (U + Math.imul(Ut, In)) | 0),
        (O = (O + Math.imul(Fe, Tn)) | 0),
        (I = (I + Math.imul(Fe, xn)) | 0),
        (I = (I + Math.imul(nt, Tn)) | 0),
        (U = (U + Math.imul(nt, xn)) | 0),
        (O = (O + Math.imul(xe, kn)) | 0),
        (I = (I + Math.imul(xe, Cn)) | 0),
        (I = (I + Math.imul(We, kn)) | 0),
        (U = (U + Math.imul(We, Cn)) | 0),
        (O = (O + Math.imul(Oe, Pn)) | 0),
        (I = (I + Math.imul(Oe, Mn)) | 0),
        (I = (I + Math.imul(Re, Pn)) | 0),
        (U = (U + Math.imul(Re, Mn)) | 0),
        (O = (O + Math.imul(Z, On)) | 0),
        (I = (I + Math.imul(Z, Bn)) | 0),
        (I = (I + Math.imul(be, On)) | 0),
        (U = (U + Math.imul(be, Bn)) | 0);
      var lw = (((L + O) | 0) + ((I & 8191) << 13)) | 0;
      (L = (((U + (I >>> 13)) | 0) + (lw >>> 26)) | 0),
        (lw &= 67108863),
        (O = Math.imul(fn, mn)),
        (I = Math.imul(fn, wn)),
        (I = (I + Math.imul(hn, mn)) | 0),
        (U = Math.imul(hn, wn)),
        (O = (O + Math.imul(Zt, vn)) | 0),
        (I = (I + Math.imul(Zt, _n)) | 0),
        (I = (I + Math.imul(Mt, vn)) | 0),
        (U = (U + Math.imul(Mt, _n)) | 0),
        (O = (O + Math.imul(Pe, Sn)) | 0),
        (I = (I + Math.imul(Pe, En)) | 0),
        (I = (I + Math.imul(Qe, Sn)) | 0),
        (U = (U + Math.imul(Qe, En)) | 0),
        (O = (O + Math.imul(Kt, An)) | 0),
        (I = (I + Math.imul(Kt, In)) | 0),
        (I = (I + Math.imul($t, An)) | 0),
        (U = (U + Math.imul($t, In)) | 0),
        (O = (O + Math.imul(ut, Tn)) | 0),
        (I = (I + Math.imul(ut, xn)) | 0),
        (I = (I + Math.imul(Ut, Tn)) | 0),
        (U = (U + Math.imul(Ut, xn)) | 0),
        (O = (O + Math.imul(Fe, kn)) | 0),
        (I = (I + Math.imul(Fe, Cn)) | 0),
        (I = (I + Math.imul(nt, kn)) | 0),
        (U = (U + Math.imul(nt, Cn)) | 0),
        (O = (O + Math.imul(xe, Pn)) | 0),
        (I = (I + Math.imul(xe, Mn)) | 0),
        (I = (I + Math.imul(We, Pn)) | 0),
        (U = (U + Math.imul(We, Mn)) | 0),
        (O = (O + Math.imul(Oe, On)) | 0),
        (I = (I + Math.imul(Oe, Bn)) | 0),
        (I = (I + Math.imul(Re, On)) | 0),
        (U = (U + Math.imul(Re, Bn)) | 0);
      var dw = (((L + O) | 0) + ((I & 8191) << 13)) | 0;
      (L = (((U + (I >>> 13)) | 0) + (dw >>> 26)) | 0),
        (dw &= 67108863),
        (O = Math.imul(fn, vn)),
        (I = Math.imul(fn, _n)),
        (I = (I + Math.imul(hn, vn)) | 0),
        (U = Math.imul(hn, _n)),
        (O = (O + Math.imul(Zt, Sn)) | 0),
        (I = (I + Math.imul(Zt, En)) | 0),
        (I = (I + Math.imul(Mt, Sn)) | 0),
        (U = (U + Math.imul(Mt, En)) | 0),
        (O = (O + Math.imul(Pe, An)) | 0),
        (I = (I + Math.imul(Pe, In)) | 0),
        (I = (I + Math.imul(Qe, An)) | 0),
        (U = (U + Math.imul(Qe, In)) | 0),
        (O = (O + Math.imul(Kt, Tn)) | 0),
        (I = (I + Math.imul(Kt, xn)) | 0),
        (I = (I + Math.imul($t, Tn)) | 0),
        (U = (U + Math.imul($t, xn)) | 0),
        (O = (O + Math.imul(ut, kn)) | 0),
        (I = (I + Math.imul(ut, Cn)) | 0),
        (I = (I + Math.imul(Ut, kn)) | 0),
        (U = (U + Math.imul(Ut, Cn)) | 0),
        (O = (O + Math.imul(Fe, Pn)) | 0),
        (I = (I + Math.imul(Fe, Mn)) | 0),
        (I = (I + Math.imul(nt, Pn)) | 0),
        (U = (U + Math.imul(nt, Mn)) | 0),
        (O = (O + Math.imul(xe, On)) | 0),
        (I = (I + Math.imul(xe, Bn)) | 0),
        (I = (I + Math.imul(We, On)) | 0),
        (U = (U + Math.imul(We, Bn)) | 0);
      var fw = (((L + O) | 0) + ((I & 8191) << 13)) | 0;
      (L = (((U + (I >>> 13)) | 0) + (fw >>> 26)) | 0),
        (fw &= 67108863),
        (O = Math.imul(fn, Sn)),
        (I = Math.imul(fn, En)),
        (I = (I + Math.imul(hn, Sn)) | 0),
        (U = Math.imul(hn, En)),
        (O = (O + Math.imul(Zt, An)) | 0),
        (I = (I + Math.imul(Zt, In)) | 0),
        (I = (I + Math.imul(Mt, An)) | 0),
        (U = (U + Math.imul(Mt, In)) | 0),
        (O = (O + Math.imul(Pe, Tn)) | 0),
        (I = (I + Math.imul(Pe, xn)) | 0),
        (I = (I + Math.imul(Qe, Tn)) | 0),
        (U = (U + Math.imul(Qe, xn)) | 0),
        (O = (O + Math.imul(Kt, kn)) | 0),
        (I = (I + Math.imul(Kt, Cn)) | 0),
        (I = (I + Math.imul($t, kn)) | 0),
        (U = (U + Math.imul($t, Cn)) | 0),
        (O = (O + Math.imul(ut, Pn)) | 0),
        (I = (I + Math.imul(ut, Mn)) | 0),
        (I = (I + Math.imul(Ut, Pn)) | 0),
        (U = (U + Math.imul(Ut, Mn)) | 0),
        (O = (O + Math.imul(Fe, On)) | 0),
        (I = (I + Math.imul(Fe, Bn)) | 0),
        (I = (I + Math.imul(nt, On)) | 0),
        (U = (U + Math.imul(nt, Bn)) | 0);
      var hw = (((L + O) | 0) + ((I & 8191) << 13)) | 0;
      (L = (((U + (I >>> 13)) | 0) + (hw >>> 26)) | 0),
        (hw &= 67108863),
        (O = Math.imul(fn, An)),
        (I = Math.imul(fn, In)),
        (I = (I + Math.imul(hn, An)) | 0),
        (U = Math.imul(hn, In)),
        (O = (O + Math.imul(Zt, Tn)) | 0),
        (I = (I + Math.imul(Zt, xn)) | 0),
        (I = (I + Math.imul(Mt, Tn)) | 0),
        (U = (U + Math.imul(Mt, xn)) | 0),
        (O = (O + Math.imul(Pe, kn)) | 0),
        (I = (I + Math.imul(Pe, Cn)) | 0),
        (I = (I + Math.imul(Qe, kn)) | 0),
        (U = (U + Math.imul(Qe, Cn)) | 0),
        (O = (O + Math.imul(Kt, Pn)) | 0),
        (I = (I + Math.imul(Kt, Mn)) | 0),
        (I = (I + Math.imul($t, Pn)) | 0),
        (U = (U + Math.imul($t, Mn)) | 0),
        (O = (O + Math.imul(ut, On)) | 0),
        (I = (I + Math.imul(ut, Bn)) | 0),
        (I = (I + Math.imul(Ut, On)) | 0),
        (U = (U + Math.imul(Ut, Bn)) | 0);
      var pw = (((L + O) | 0) + ((I & 8191) << 13)) | 0;
      (L = (((U + (I >>> 13)) | 0) + (pw >>> 26)) | 0),
        (pw &= 67108863),
        (O = Math.imul(fn, Tn)),
        (I = Math.imul(fn, xn)),
        (I = (I + Math.imul(hn, Tn)) | 0),
        (U = Math.imul(hn, xn)),
        (O = (O + Math.imul(Zt, kn)) | 0),
        (I = (I + Math.imul(Zt, Cn)) | 0),
        (I = (I + Math.imul(Mt, kn)) | 0),
        (U = (U + Math.imul(Mt, Cn)) | 0),
        (O = (O + Math.imul(Pe, Pn)) | 0),
        (I = (I + Math.imul(Pe, Mn)) | 0),
        (I = (I + Math.imul(Qe, Pn)) | 0),
        (U = (U + Math.imul(Qe, Mn)) | 0),
        (O = (O + Math.imul(Kt, On)) | 0),
        (I = (I + Math.imul(Kt, Bn)) | 0),
        (I = (I + Math.imul($t, On)) | 0),
        (U = (U + Math.imul($t, Bn)) | 0);
      var gw = (((L + O) | 0) + ((I & 8191) << 13)) | 0;
      (L = (((U + (I >>> 13)) | 0) + (gw >>> 26)) | 0),
        (gw &= 67108863),
        (O = Math.imul(fn, kn)),
        (I = Math.imul(fn, Cn)),
        (I = (I + Math.imul(hn, kn)) | 0),
        (U = Math.imul(hn, Cn)),
        (O = (O + Math.imul(Zt, Pn)) | 0),
        (I = (I + Math.imul(Zt, Mn)) | 0),
        (I = (I + Math.imul(Mt, Pn)) | 0),
        (U = (U + Math.imul(Mt, Mn)) | 0),
        (O = (O + Math.imul(Pe, On)) | 0),
        (I = (I + Math.imul(Pe, Bn)) | 0),
        (I = (I + Math.imul(Qe, On)) | 0),
        (U = (U + Math.imul(Qe, Bn)) | 0);
      var yw = (((L + O) | 0) + ((I & 8191) << 13)) | 0;
      (L = (((U + (I >>> 13)) | 0) + (yw >>> 26)) | 0),
        (yw &= 67108863),
        (O = Math.imul(fn, Pn)),
        (I = Math.imul(fn, Mn)),
        (I = (I + Math.imul(hn, Pn)) | 0),
        (U = Math.imul(hn, Mn)),
        (O = (O + Math.imul(Zt, On)) | 0),
        (I = (I + Math.imul(Zt, Bn)) | 0),
        (I = (I + Math.imul(Mt, On)) | 0),
        (U = (U + Math.imul(Mt, Bn)) | 0);
      var bw = (((L + O) | 0) + ((I & 8191) << 13)) | 0;
      (L = (((U + (I >>> 13)) | 0) + (bw >>> 26)) | 0),
        (bw &= 67108863),
        (O = Math.imul(fn, On)),
        (I = Math.imul(fn, Bn)),
        (I = (I + Math.imul(hn, On)) | 0),
        (U = Math.imul(hn, Bn));
      var mw = (((L + O) | 0) + ((I & 8191) << 13)) | 0;
      return (
        (L = (((U + (I >>> 13)) | 0) + (mw >>> 26)) | 0),
        (mw &= 67108863),
        (R[0] = ew),
        (R[1] = tw),
        (R[2] = nw),
        (R[3] = rw),
        (R[4] = iw),
        (R[5] = sw),
        (R[6] = ow),
        (R[7] = aw),
        (R[8] = cw),
        (R[9] = uw),
        (R[10] = lw),
        (R[11] = dw),
        (R[12] = fw),
        (R[13] = hw),
        (R[14] = pw),
        (R[15] = gw),
        (R[16] = yw),
        (R[17] = bw),
        (R[18] = mw),
        L !== 0 && ((R[19] = L), S.length++),
        S
      );
    };
    Math.imul || (b = p);
    function w(E, y, v) {
      (v.negative = y.negative ^ E.negative), (v.length = E.length + y.length);
      for (var S = 0, T = 0, M = 0; M < v.length - 1; M++) {
        var R = T;
        T = 0;
        for (
          var L = S & 67108863, O = Math.min(M, y.length - 1), I = Math.max(0, M - E.length + 1);
          I <= O;
          I++
        ) {
          var U = M - I,
            H = E.words[U] | 0,
            X = y.words[I] | 0,
            J = H * X,
            ie = J & 67108863;
          (R = (R + ((J / 67108864) | 0)) | 0),
            (ie = (ie + L) | 0),
            (L = ie & 67108863),
            (R = (R + (ie >>> 26)) | 0),
            (T += R >>> 26),
            (R &= 67108863);
        }
        (v.words[M] = L), (S = R), (R = T);
      }
      return S !== 0 ? (v.words[M] = S) : v.length--, v.strip();
    }
    function A(E, y, v) {
      var S = new _();
      return S.mulp(E, y, v);
    }
    s.prototype.mulTo = function (y, v) {
      var S,
        T = this.length + y.length;
      return (
        this.length === 10 && y.length === 10
          ? (S = b(this, y, v))
          : T < 63
            ? (S = p(this, y, v))
            : T < 1024
              ? (S = w(this, y, v))
              : (S = A(this, y, v)),
        S
      );
    };
    function _(E, y) {
      (this.x = E), (this.y = y);
    }
    (_.prototype.makeRBT = function (y) {
      for (var v = new Array(y), S = s.prototype._countBits(y) - 1, T = 0; T < y; T++)
        v[T] = this.revBin(T, S, y);
      return v;
    }),
      (_.prototype.revBin = function (y, v, S) {
        if (y === 0 || y === S - 1) return y;
        for (var T = 0, M = 0; M < v; M++) (T |= (y & 1) << (v - M - 1)), (y >>= 1);
        return T;
      }),
      (_.prototype.permute = function (y, v, S, T, M, R) {
        for (var L = 0; L < R; L++) (T[L] = v[y[L]]), (M[L] = S[y[L]]);
      }),
      (_.prototype.transform = function (y, v, S, T, M, R) {
        this.permute(R, y, v, S, T, M);
        for (var L = 1; L < M; L <<= 1)
          for (
            var O = L << 1, I = Math.cos((2 * Math.PI) / O), U = Math.sin((2 * Math.PI) / O), H = 0;
            H < M;
            H += O
          )
            for (var X = I, J = U, ie = 0; ie < L; ie++) {
              var Z = S[H + ie],
                be = T[H + ie],
                le = S[H + ie + L],
                Oe = T[H + ie + L],
                Re = X * le - J * Oe;
              (Oe = X * Oe + J * le),
                (le = Re),
                (S[H + ie] = Z + le),
                (T[H + ie] = be + Oe),
                (S[H + ie + L] = Z - le),
                (T[H + ie + L] = be - Oe),
                ie !== O && ((Re = I * X - U * J), (J = I * J + U * X), (X = Re));
            }
      }),
      (_.prototype.guessLen13b = function (y, v) {
        var S = Math.max(v, y) | 1,
          T = S & 1,
          M = 0;
        for (S = (S / 2) | 0; S; S = S >>> 1) M++;
        return 1 << (M + 1 + T);
      }),
      (_.prototype.conjugate = function (y, v, S) {
        if (!(S <= 1))
          for (var T = 0; T < S / 2; T++) {
            var M = y[T];
            (y[T] = y[S - T - 1]),
              (y[S - T - 1] = M),
              (M = v[T]),
              (v[T] = -v[S - T - 1]),
              (v[S - T - 1] = -M);
          }
      }),
      (_.prototype.normalize13b = function (y, v) {
        for (var S = 0, T = 0; T < v / 2; T++) {
          var M = Math.round(y[2 * T + 1] / v) * 8192 + Math.round(y[2 * T] / v) + S;
          (y[T] = M & 67108863), M < 67108864 ? (S = 0) : (S = (M / 67108864) | 0);
        }
        return y;
      }),
      (_.prototype.convert13b = function (y, v, S, T) {
        for (var M = 0, R = 0; R < v; R++)
          (M = M + (y[R] | 0)),
            (S[2 * R] = M & 8191),
            (M = M >>> 13),
            (S[2 * R + 1] = M & 8191),
            (M = M >>> 13);
        for (R = 2 * v; R < T; ++R) S[R] = 0;
        r(M === 0), r((M & -8192) === 0);
      }),
      (_.prototype.stub = function (y) {
        for (var v = new Array(y), S = 0; S < y; S++) v[S] = 0;
        return v;
      }),
      (_.prototype.mulp = function (y, v, S) {
        var T = 2 * this.guessLen13b(y.length, v.length),
          M = this.makeRBT(T),
          R = this.stub(T),
          L = new Array(T),
          O = new Array(T),
          I = new Array(T),
          U = new Array(T),
          H = new Array(T),
          X = new Array(T),
          J = S.words;
        (J.length = T),
          this.convert13b(y.words, y.length, L, T),
          this.convert13b(v.words, v.length, U, T),
          this.transform(L, R, O, I, T, M),
          this.transform(U, R, H, X, T, M);
        for (var ie = 0; ie < T; ie++) {
          var Z = O[ie] * H[ie] - I[ie] * X[ie];
          (I[ie] = O[ie] * X[ie] + I[ie] * H[ie]), (O[ie] = Z);
        }
        return (
          this.conjugate(O, I, T),
          this.transform(O, I, J, R, T, M),
          this.conjugate(J, R, T),
          this.normalize13b(J, T),
          (S.negative = y.negative ^ v.negative),
          (S.length = y.length + v.length),
          S.strip()
        );
      }),
      (s.prototype.mul = function (y) {
        var v = new s(null);
        return (v.words = new Array(this.length + y.length)), this.mulTo(y, v);
      }),
      (s.prototype.mulf = function (y) {
        var v = new s(null);
        return (v.words = new Array(this.length + y.length)), A(this, y, v);
      }),
      (s.prototype.imul = function (y) {
        return this.clone().mulTo(y, this);
      }),
      (s.prototype.imuln = function (y) {
        r(typeof y == 'number'), r(y < 67108864);
        for (var v = 0, S = 0; S < this.length; S++) {
          var T = (this.words[S] | 0) * y,
            M = (T & 67108863) + (v & 67108863);
          (v >>= 26), (v += (T / 67108864) | 0), (v += M >>> 26), (this.words[S] = M & 67108863);
        }
        return v !== 0 && ((this.words[S] = v), this.length++), this;
      }),
      (s.prototype.muln = function (y) {
        return this.clone().imuln(y);
      }),
      (s.prototype.sqr = function () {
        return this.mul(this);
      }),
      (s.prototype.isqr = function () {
        return this.imul(this.clone());
      }),
      (s.prototype.pow = function (y) {
        var v = h(y);
        if (v.length === 0) return new s(1);
        for (var S = this, T = 0; T < v.length && v[T] === 0; T++, S = S.sqr());
        if (++T < v.length)
          for (var M = S.sqr(); T < v.length; T++, M = M.sqr()) v[T] !== 0 && (S = S.mul(M));
        return S;
      }),
      (s.prototype.iushln = function (y) {
        r(typeof y == 'number' && y >= 0);
        var v = y % 26,
          S = (y - v) / 26,
          T = (67108863 >>> (26 - v)) << (26 - v),
          M;
        if (v !== 0) {
          var R = 0;
          for (M = 0; M < this.length; M++) {
            var L = this.words[M] & T,
              O = ((this.words[M] | 0) - L) << v;
            (this.words[M] = O | R), (R = L >>> (26 - v));
          }
          R && ((this.words[M] = R), this.length++);
        }
        if (S !== 0) {
          for (M = this.length - 1; M >= 0; M--) this.words[M + S] = this.words[M];
          for (M = 0; M < S; M++) this.words[M] = 0;
          this.length += S;
        }
        return this.strip();
      }),
      (s.prototype.ishln = function (y) {
        return r(this.negative === 0), this.iushln(y);
      }),
      (s.prototype.iushrn = function (y, v, S) {
        r(typeof y == 'number' && y >= 0);
        var T;
        v ? (T = (v - (v % 26)) / 26) : (T = 0);
        var M = y % 26,
          R = Math.min((y - M) / 26, this.length),
          L = 67108863 ^ ((67108863 >>> M) << M),
          O = S;
        if (((T -= R), (T = Math.max(0, T)), O)) {
          for (var I = 0; I < R; I++) O.words[I] = this.words[I];
          O.length = R;
        }
        if (R !== 0)
          if (this.length > R)
            for (this.length -= R, I = 0; I < this.length; I++) this.words[I] = this.words[I + R];
          else (this.words[0] = 0), (this.length = 1);
        var U = 0;
        for (I = this.length - 1; I >= 0 && (U !== 0 || I >= T); I--) {
          var H = this.words[I] | 0;
          (this.words[I] = (U << (26 - M)) | (H >>> M)), (U = H & L);
        }
        return (
          O && U !== 0 && (O.words[O.length++] = U),
          this.length === 0 && ((this.words[0] = 0), (this.length = 1)),
          this.strip()
        );
      }),
      (s.prototype.ishrn = function (y, v, S) {
        return r(this.negative === 0), this.iushrn(y, v, S);
      }),
      (s.prototype.shln = function (y) {
        return this.clone().ishln(y);
      }),
      (s.prototype.ushln = function (y) {
        return this.clone().iushln(y);
      }),
      (s.prototype.shrn = function (y) {
        return this.clone().ishrn(y);
      }),
      (s.prototype.ushrn = function (y) {
        return this.clone().iushrn(y);
      }),
      (s.prototype.testn = function (y) {
        r(typeof y == 'number' && y >= 0);
        var v = y % 26,
          S = (y - v) / 26,
          T = 1 << v;
        if (this.length <= S) return !1;
        var M = this.words[S];
        return !!(M & T);
      }),
      (s.prototype.imaskn = function (y) {
        r(typeof y == 'number' && y >= 0);
        var v = y % 26,
          S = (y - v) / 26;
        if ((r(this.negative === 0, 'imaskn works only with positive numbers'), this.length <= S))
          return this;
        if ((v !== 0 && S++, (this.length = Math.min(S, this.length)), v !== 0)) {
          var T = 67108863 ^ ((67108863 >>> v) << v);
          this.words[this.length - 1] &= T;
        }
        return this.strip();
      }),
      (s.prototype.maskn = function (y) {
        return this.clone().imaskn(y);
      }),
      (s.prototype.iaddn = function (y) {
        return (
          r(typeof y == 'number'),
          r(y < 67108864),
          y < 0
            ? this.isubn(-y)
            : this.negative !== 0
              ? this.length === 1 && (this.words[0] | 0) < y
                ? ((this.words[0] = y - (this.words[0] | 0)), (this.negative = 0), this)
                : ((this.negative = 0), this.isubn(y), (this.negative = 1), this)
              : this._iaddn(y)
        );
      }),
      (s.prototype._iaddn = function (y) {
        this.words[0] += y;
        for (var v = 0; v < this.length && this.words[v] >= 67108864; v++)
          (this.words[v] -= 67108864),
            v === this.length - 1 ? (this.words[v + 1] = 1) : this.words[v + 1]++;
        return (this.length = Math.max(this.length, v + 1)), this;
      }),
      (s.prototype.isubn = function (y) {
        if ((r(typeof y == 'number'), r(y < 67108864), y < 0)) return this.iaddn(-y);
        if (this.negative !== 0)
          return (this.negative = 0), this.iaddn(y), (this.negative = 1), this;
        if (((this.words[0] -= y), this.length === 1 && this.words[0] < 0))
          (this.words[0] = -this.words[0]), (this.negative = 1);
        else
          for (var v = 0; v < this.length && this.words[v] < 0; v++)
            (this.words[v] += 67108864), (this.words[v + 1] -= 1);
        return this.strip();
      }),
      (s.prototype.addn = function (y) {
        return this.clone().iaddn(y);
      }),
      (s.prototype.subn = function (y) {
        return this.clone().isubn(y);
      }),
      (s.prototype.iabs = function () {
        return (this.negative = 0), this;
      }),
      (s.prototype.abs = function () {
        return this.clone().iabs();
      }),
      (s.prototype._ishlnsubmul = function (y, v, S) {
        var T = y.length + S,
          M;
        this._expand(T);
        var R,
          L = 0;
        for (M = 0; M < y.length; M++) {
          R = (this.words[M + S] | 0) + L;
          var O = (y.words[M] | 0) * v;
          (R -= O & 67108863),
            (L = (R >> 26) - ((O / 67108864) | 0)),
            (this.words[M + S] = R & 67108863);
        }
        for (; M < this.length - S; M++)
          (R = (this.words[M + S] | 0) + L), (L = R >> 26), (this.words[M + S] = R & 67108863);
        if (L === 0) return this.strip();
        for (r(L === -1), L = 0, M = 0; M < this.length; M++)
          (R = -(this.words[M] | 0) + L), (L = R >> 26), (this.words[M] = R & 67108863);
        return (this.negative = 1), this.strip();
      }),
      (s.prototype._wordDiv = function (y, v) {
        var S = this.length - y.length,
          T = this.clone(),
          M = y,
          R = M.words[M.length - 1] | 0,
          L = this._countBits(R);
        (S = 26 - L), S !== 0 && ((M = M.ushln(S)), T.iushln(S), (R = M.words[M.length - 1] | 0));
        var O = T.length - M.length,
          I;
        if (v !== 'mod') {
          (I = new s(null)), (I.length = O + 1), (I.words = new Array(I.length));
          for (var U = 0; U < I.length; U++) I.words[U] = 0;
        }
        var H = T.clone()._ishlnsubmul(M, 1, O);
        H.negative === 0 && ((T = H), I && (I.words[O] = 1));
        for (var X = O - 1; X >= 0; X--) {
          var J = (T.words[M.length + X] | 0) * 67108864 + (T.words[M.length + X - 1] | 0);
          for (J = Math.min((J / R) | 0, 67108863), T._ishlnsubmul(M, J, X); T.negative !== 0; )
            J--, (T.negative = 0), T._ishlnsubmul(M, 1, X), T.isZero() || (T.negative ^= 1);
          I && (I.words[X] = J);
        }
        return (
          I && I.strip(),
          T.strip(),
          v !== 'div' && S !== 0 && T.iushrn(S),
          { div: I || null, mod: T }
        );
      }),
      (s.prototype.divmod = function (y, v, S) {
        if ((r(!y.isZero()), this.isZero())) return { div: new s(0), mod: new s(0) };
        var T, M, R;
        return this.negative !== 0 && y.negative === 0
          ? ((R = this.neg().divmod(y, v)),
            v !== 'mod' && (T = R.div.neg()),
            v !== 'div' && ((M = R.mod.neg()), S && M.negative !== 0 && M.iadd(y)),
            { div: T, mod: M })
          : this.negative === 0 && y.negative !== 0
            ? ((R = this.divmod(y.neg(), v)),
              v !== 'mod' && (T = R.div.neg()),
              { div: T, mod: R.mod })
            : this.negative & y.negative
              ? ((R = this.neg().divmod(y.neg(), v)),
                v !== 'div' && ((M = R.mod.neg()), S && M.negative !== 0 && M.isub(y)),
                { div: R.div, mod: M })
              : y.length > this.length || this.cmp(y) < 0
                ? { div: new s(0), mod: this }
                : y.length === 1
                  ? v === 'div'
                    ? { div: this.divn(y.words[0]), mod: null }
                    : v === 'mod'
                      ? { div: null, mod: new s(this.modn(y.words[0])) }
                      : { div: this.divn(y.words[0]), mod: new s(this.modn(y.words[0])) }
                  : this._wordDiv(y, v);
      }),
      (s.prototype.div = function (y) {
        return this.divmod(y, 'div', !1).div;
      }),
      (s.prototype.mod = function (y) {
        return this.divmod(y, 'mod', !1).mod;
      }),
      (s.prototype.umod = function (y) {
        return this.divmod(y, 'mod', !0).mod;
      }),
      (s.prototype.divRound = function (y) {
        var v = this.divmod(y);
        if (v.mod.isZero()) return v.div;
        var S = v.div.negative !== 0 ? v.mod.isub(y) : v.mod,
          T = y.ushrn(1),
          M = y.andln(1),
          R = S.cmp(T);
        return R < 0 || (M === 1 && R === 0)
          ? v.div
          : v.div.negative !== 0
            ? v.div.isubn(1)
            : v.div.iaddn(1);
      }),
      (s.prototype.modn = function (y) {
        r(y <= 67108863);
        for (var v = (1 << 26) % y, S = 0, T = this.length - 1; T >= 0; T--)
          S = (v * S + (this.words[T] | 0)) % y;
        return S;
      }),
      (s.prototype.idivn = function (y) {
        r(y <= 67108863);
        for (var v = 0, S = this.length - 1; S >= 0; S--) {
          var T = (this.words[S] | 0) + v * 67108864;
          (this.words[S] = (T / y) | 0), (v = T % y);
        }
        return this.strip();
      }),
      (s.prototype.divn = function (y) {
        return this.clone().idivn(y);
      }),
      (s.prototype.egcd = function (y) {
        r(y.negative === 0), r(!y.isZero());
        var v = this,
          S = y.clone();
        v.negative !== 0 ? (v = v.umod(y)) : (v = v.clone());
        for (
          var T = new s(1), M = new s(0), R = new s(0), L = new s(1), O = 0;
          v.isEven() && S.isEven();

        )
          v.iushrn(1), S.iushrn(1), ++O;
        for (var I = S.clone(), U = v.clone(); !v.isZero(); ) {
          for (var H = 0, X = 1; !(v.words[0] & X) && H < 26; ++H, X <<= 1);
          if (H > 0)
            for (v.iushrn(H); H-- > 0; )
              (T.isOdd() || M.isOdd()) && (T.iadd(I), M.isub(U)), T.iushrn(1), M.iushrn(1);
          for (var J = 0, ie = 1; !(S.words[0] & ie) && J < 26; ++J, ie <<= 1);
          if (J > 0)
            for (S.iushrn(J); J-- > 0; )
              (R.isOdd() || L.isOdd()) && (R.iadd(I), L.isub(U)), R.iushrn(1), L.iushrn(1);
          v.cmp(S) >= 0 ? (v.isub(S), T.isub(R), M.isub(L)) : (S.isub(v), R.isub(T), L.isub(M));
        }
        return { a: R, b: L, gcd: S.iushln(O) };
      }),
      (s.prototype._invmp = function (y) {
        r(y.negative === 0), r(!y.isZero());
        var v = this,
          S = y.clone();
        v.negative !== 0 ? (v = v.umod(y)) : (v = v.clone());
        for (var T = new s(1), M = new s(0), R = S.clone(); v.cmpn(1) > 0 && S.cmpn(1) > 0; ) {
          for (var L = 0, O = 1; !(v.words[0] & O) && L < 26; ++L, O <<= 1);
          if (L > 0) for (v.iushrn(L); L-- > 0; ) T.isOdd() && T.iadd(R), T.iushrn(1);
          for (var I = 0, U = 1; !(S.words[0] & U) && I < 26; ++I, U <<= 1);
          if (I > 0) for (S.iushrn(I); I-- > 0; ) M.isOdd() && M.iadd(R), M.iushrn(1);
          v.cmp(S) >= 0 ? (v.isub(S), T.isub(M)) : (S.isub(v), M.isub(T));
        }
        var H;
        return v.cmpn(1) === 0 ? (H = T) : (H = M), H.cmpn(0) < 0 && H.iadd(y), H;
      }),
      (s.prototype.gcd = function (y) {
        if (this.isZero()) return y.abs();
        if (y.isZero()) return this.abs();
        var v = this.clone(),
          S = y.clone();
        (v.negative = 0), (S.negative = 0);
        for (var T = 0; v.isEven() && S.isEven(); T++) v.iushrn(1), S.iushrn(1);
        do {
          for (; v.isEven(); ) v.iushrn(1);
          for (; S.isEven(); ) S.iushrn(1);
          var M = v.cmp(S);
          if (M < 0) {
            var R = v;
            (v = S), (S = R);
          } else if (M === 0 || S.cmpn(1) === 0) break;
          v.isub(S);
        } while (!0);
        return S.iushln(T);
      }),
      (s.prototype.invm = function (y) {
        return this.egcd(y).a.umod(y);
      }),
      (s.prototype.isEven = function () {
        return (this.words[0] & 1) === 0;
      }),
      (s.prototype.isOdd = function () {
        return (this.words[0] & 1) === 1;
      }),
      (s.prototype.andln = function (y) {
        return this.words[0] & y;
      }),
      (s.prototype.bincn = function (y) {
        r(typeof y == 'number');
        var v = y % 26,
          S = (y - v) / 26,
          T = 1 << v;
        if (this.length <= S) return this._expand(S + 1), (this.words[S] |= T), this;
        for (var M = T, R = S; M !== 0 && R < this.length; R++) {
          var L = this.words[R] | 0;
          (L += M), (M = L >>> 26), (L &= 67108863), (this.words[R] = L);
        }
        return M !== 0 && ((this.words[R] = M), this.length++), this;
      }),
      (s.prototype.isZero = function () {
        return this.length === 1 && this.words[0] === 0;
      }),
      (s.prototype.cmpn = function (y) {
        var v = y < 0;
        if (this.negative !== 0 && !v) return -1;
        if (this.negative === 0 && v) return 1;
        this.strip();
        var S;
        if (this.length > 1) S = 1;
        else {
          v && (y = -y), r(y <= 67108863, 'Number is too big');
          var T = this.words[0] | 0;
          S = T === y ? 0 : T < y ? -1 : 1;
        }
        return this.negative !== 0 ? -S | 0 : S;
      }),
      (s.prototype.cmp = function (y) {
        if (this.negative !== 0 && y.negative === 0) return -1;
        if (this.negative === 0 && y.negative !== 0) return 1;
        var v = this.ucmp(y);
        return this.negative !== 0 ? -v | 0 : v;
      }),
      (s.prototype.ucmp = function (y) {
        if (this.length > y.length) return 1;
        if (this.length < y.length) return -1;
        for (var v = 0, S = this.length - 1; S >= 0; S--) {
          var T = this.words[S] | 0,
            M = y.words[S] | 0;
          if (T !== M) {
            T < M ? (v = -1) : T > M && (v = 1);
            break;
          }
        }
        return v;
      }),
      (s.prototype.gtn = function (y) {
        return this.cmpn(y) === 1;
      }),
      (s.prototype.gt = function (y) {
        return this.cmp(y) === 1;
      }),
      (s.prototype.gten = function (y) {
        return this.cmpn(y) >= 0;
      }),
      (s.prototype.gte = function (y) {
        return this.cmp(y) >= 0;
      }),
      (s.prototype.ltn = function (y) {
        return this.cmpn(y) === -1;
      }),
      (s.prototype.lt = function (y) {
        return this.cmp(y) === -1;
      }),
      (s.prototype.lten = function (y) {
        return this.cmpn(y) <= 0;
      }),
      (s.prototype.lte = function (y) {
        return this.cmp(y) <= 0;
      }),
      (s.prototype.eqn = function (y) {
        return this.cmpn(y) === 0;
      }),
      (s.prototype.eq = function (y) {
        return this.cmp(y) === 0;
      }),
      (s.red = function (y) {
        return new C(y);
      }),
      (s.prototype.toRed = function (y) {
        return (
          r(!this.red, 'Already a number in reduction context'),
          r(this.negative === 0, 'red works only with positives'),
          y.convertTo(this)._forceRed(y)
        );
      }),
      (s.prototype.fromRed = function () {
        return (
          r(this.red, 'fromRed works only with numbers in reduction context'),
          this.red.convertFrom(this)
        );
      }),
      (s.prototype._forceRed = function (y) {
        return (this.red = y), this;
      }),
      (s.prototype.forceRed = function (y) {
        return r(!this.red, 'Already a number in reduction context'), this._forceRed(y);
      }),
      (s.prototype.redAdd = function (y) {
        return r(this.red, 'redAdd works only with red numbers'), this.red.add(this, y);
      }),
      (s.prototype.redIAdd = function (y) {
        return r(this.red, 'redIAdd works only with red numbers'), this.red.iadd(this, y);
      }),
      (s.prototype.redSub = function (y) {
        return r(this.red, 'redSub works only with red numbers'), this.red.sub(this, y);
      }),
      (s.prototype.redISub = function (y) {
        return r(this.red, 'redISub works only with red numbers'), this.red.isub(this, y);
      }),
      (s.prototype.redShl = function (y) {
        return r(this.red, 'redShl works only with red numbers'), this.red.shl(this, y);
      }),
      (s.prototype.redMul = function (y) {
        return (
          r(this.red, 'redMul works only with red numbers'),
          this.red._verify2(this, y),
          this.red.mul(this, y)
        );
      }),
      (s.prototype.redIMul = function (y) {
        return (
          r(this.red, 'redMul works only with red numbers'),
          this.red._verify2(this, y),
          this.red.imul(this, y)
        );
      }),
      (s.prototype.redSqr = function () {
        return (
          r(this.red, 'redSqr works only with red numbers'),
          this.red._verify1(this),
          this.red.sqr(this)
        );
      }),
      (s.prototype.redISqr = function () {
        return (
          r(this.red, 'redISqr works only with red numbers'),
          this.red._verify1(this),
          this.red.isqr(this)
        );
      }),
      (s.prototype.redSqrt = function () {
        return (
          r(this.red, 'redSqrt works only with red numbers'),
          this.red._verify1(this),
          this.red.sqrt(this)
        );
      }),
      (s.prototype.redInvm = function () {
        return (
          r(this.red, 'redInvm works only with red numbers'),
          this.red._verify1(this),
          this.red.invm(this)
        );
      }),
      (s.prototype.redNeg = function () {
        return (
          r(this.red, 'redNeg works only with red numbers'),
          this.red._verify1(this),
          this.red.neg(this)
        );
      }),
      (s.prototype.redPow = function (y) {
        return (
          r(this.red && !y.red, 'redPow(normalNum)'), this.red._verify1(this), this.red.pow(this, y)
        );
      });
    var x = { k256: null, p224: null, p192: null, p25519: null };
    function k(E, y) {
      (this.name = E),
        (this.p = new s(y, 16)),
        (this.n = this.p.bitLength()),
        (this.k = new s(1).iushln(this.n).isub(this.p)),
        (this.tmp = this._tmp());
    }
    (k.prototype._tmp = function () {
      var y = new s(null);
      return (y.words = new Array(Math.ceil(this.n / 13))), y;
    }),
      (k.prototype.ireduce = function (y) {
        var v = y,
          S;
        do
          this.split(v, this.tmp), (v = this.imulK(v)), (v = v.iadd(this.tmp)), (S = v.bitLength());
        while (S > this.n);
        var T = S < this.n ? -1 : v.ucmp(this.p);
        return (
          T === 0
            ? ((v.words[0] = 0), (v.length = 1))
            : T > 0
              ? v.isub(this.p)
              : v.strip !== void 0
                ? v.strip()
                : v._strip(),
          v
        );
      }),
      (k.prototype.split = function (y, v) {
        y.iushrn(this.n, 0, v);
      }),
      (k.prototype.imulK = function (y) {
        return y.imul(this.k);
      });
    function j() {
      k.call(
        this,
        'k256',
        'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f'
      );
    }
    i(j, k),
      (j.prototype.split = function (y, v) {
        for (var S = 4194303, T = Math.min(y.length, 9), M = 0; M < T; M++) v.words[M] = y.words[M];
        if (((v.length = T), y.length <= 9)) {
          (y.words[0] = 0), (y.length = 1);
          return;
        }
        var R = y.words[9];
        for (v.words[v.length++] = R & S, M = 10; M < y.length; M++) {
          var L = y.words[M] | 0;
          (y.words[M - 10] = ((L & S) << 4) | (R >>> 22)), (R = L);
        }
        (R >>>= 22),
          (y.words[M - 10] = R),
          R === 0 && y.length > 10 ? (y.length -= 10) : (y.length -= 9);
      }),
      (j.prototype.imulK = function (y) {
        (y.words[y.length] = 0), (y.words[y.length + 1] = 0), (y.length += 2);
        for (var v = 0, S = 0; S < y.length; S++) {
          var T = y.words[S] | 0;
          (v += T * 977), (y.words[S] = v & 67108863), (v = T * 64 + ((v / 67108864) | 0));
        }
        return (
          y.words[y.length - 1] === 0 && (y.length--, y.words[y.length - 1] === 0 && y.length--), y
        );
      });
    function F() {
      k.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
    }
    i(F, k);
    function K() {
      k.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
    }
    i(K, k);
    function D() {
      k.call(this, '25519', '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
    }
    i(D, k),
      (D.prototype.imulK = function (y) {
        for (var v = 0, S = 0; S < y.length; S++) {
          var T = (y.words[S] | 0) * 19 + v,
            M = T & 67108863;
          (T >>>= 26), (y.words[S] = M), (v = T);
        }
        return v !== 0 && (y.words[y.length++] = v), y;
      }),
      (s._prime = function (y) {
        if (x[y]) return x[y];
        var v;
        if (y === 'k256') v = new j();
        else if (y === 'p224') v = new F();
        else if (y === 'p192') v = new K();
        else if (y === 'p25519') v = new D();
        else throw new Error('Unknown prime ' + y);
        return (x[y] = v), v;
      });
    function C(E) {
      if (typeof E == 'string') {
        var y = s._prime(E);
        (this.m = y.p), (this.prime = y);
      } else r(E.gtn(1), 'modulus must be greater than 1'), (this.m = E), (this.prime = null);
    }
    (C.prototype._verify1 = function (y) {
      r(y.negative === 0, 'red works only with positives'),
        r(y.red, 'red works only with red numbers');
    }),
      (C.prototype._verify2 = function (y, v) {
        r((y.negative | v.negative) === 0, 'red works only with positives'),
          r(y.red && y.red === v.red, 'red works only with red numbers');
      }),
      (C.prototype.imod = function (y) {
        return this.prime ? this.prime.ireduce(y)._forceRed(this) : y.umod(this.m)._forceRed(this);
      }),
      (C.prototype.neg = function (y) {
        return y.isZero() ? y.clone() : this.m.sub(y)._forceRed(this);
      }),
      (C.prototype.add = function (y, v) {
        this._verify2(y, v);
        var S = y.add(v);
        return S.cmp(this.m) >= 0 && S.isub(this.m), S._forceRed(this);
      }),
      (C.prototype.iadd = function (y, v) {
        this._verify2(y, v);
        var S = y.iadd(v);
        return S.cmp(this.m) >= 0 && S.isub(this.m), S;
      }),
      (C.prototype.sub = function (y, v) {
        this._verify2(y, v);
        var S = y.sub(v);
        return S.cmpn(0) < 0 && S.iadd(this.m), S._forceRed(this);
      }),
      (C.prototype.isub = function (y, v) {
        this._verify2(y, v);
        var S = y.isub(v);
        return S.cmpn(0) < 0 && S.iadd(this.m), S;
      }),
      (C.prototype.shl = function (y, v) {
        return this._verify1(y), this.imod(y.ushln(v));
      }),
      (C.prototype.imul = function (y, v) {
        return this._verify2(y, v), this.imod(y.imul(v));
      }),
      (C.prototype.mul = function (y, v) {
        return this._verify2(y, v), this.imod(y.mul(v));
      }),
      (C.prototype.isqr = function (y) {
        return this.imul(y, y.clone());
      }),
      (C.prototype.sqr = function (y) {
        return this.mul(y, y);
      }),
      (C.prototype.sqrt = function (y) {
        if (y.isZero()) return y.clone();
        var v = this.m.andln(3);
        if ((r(v % 2 === 1), v === 3)) {
          var S = this.m.add(new s(1)).iushrn(2);
          return this.pow(y, S);
        }
        for (var T = this.m.subn(1), M = 0; !T.isZero() && T.andln(1) === 0; ) M++, T.iushrn(1);
        r(!T.isZero());
        var R = new s(1).toRed(this),
          L = R.redNeg(),
          O = this.m.subn(1).iushrn(1),
          I = this.m.bitLength();
        for (I = new s(2 * I * I).toRed(this); this.pow(I, O).cmp(L) !== 0; ) I.redIAdd(L);
        for (
          var U = this.pow(I, T), H = this.pow(y, T.addn(1).iushrn(1)), X = this.pow(y, T), J = M;
          X.cmp(R) !== 0;

        ) {
          for (var ie = X, Z = 0; ie.cmp(R) !== 0; Z++) ie = ie.redSqr();
          r(Z < J);
          var be = this.pow(U, new s(1).iushln(J - Z - 1));
          (H = H.redMul(be)), (U = be.redSqr()), (X = X.redMul(U)), (J = Z);
        }
        return H;
      }),
      (C.prototype.invm = function (y) {
        var v = y._invmp(this.m);
        return v.negative !== 0 ? ((v.negative = 0), this.imod(v).redNeg()) : this.imod(v);
      }),
      (C.prototype.pow = function (y, v) {
        if (v.isZero()) return new s(1).toRed(this);
        if (v.cmpn(1) === 0) return y.clone();
        var S = 4,
          T = new Array(1 << S);
        (T[0] = new s(1).toRed(this)), (T[1] = y);
        for (var M = 2; M < T.length; M++) T[M] = this.mul(T[M - 1], y);
        var R = T[0],
          L = 0,
          O = 0,
          I = v.bitLength() % 26;
        for (I === 0 && (I = 26), M = v.length - 1; M >= 0; M--) {
          for (var U = v.words[M], H = I - 1; H >= 0; H--) {
            var X = (U >> H) & 1;
            if ((R !== T[0] && (R = this.sqr(R)), X === 0 && L === 0)) {
              O = 0;
              continue;
            }
            (L <<= 1),
              (L |= X),
              O++,
              !(O !== S && (M !== 0 || H !== 0)) && ((R = this.mul(R, T[L])), (O = 0), (L = 0));
          }
          I = 26;
        }
        return R;
      }),
      (C.prototype.convertTo = function (y) {
        var v = y.umod(this.m);
        return v === y ? v.clone() : v;
      }),
      (C.prototype.convertFrom = function (y) {
        var v = y.clone();
        return (v.red = null), v;
      }),
      (s.mont = function (y) {
        return new B(y);
      });
    function B(E) {
      C.call(this, E),
        (this.shift = this.m.bitLength()),
        this.shift % 26 !== 0 && (this.shift += 26 - (this.shift % 26)),
        (this.r = new s(1).iushln(this.shift)),
        (this.r2 = this.imod(this.r.sqr())),
        (this.rinv = this.r._invmp(this.m)),
        (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
        (this.minv = this.minv.umod(this.r)),
        (this.minv = this.r.sub(this.minv));
    }
    i(B, C),
      (B.prototype.convertTo = function (y) {
        return this.imod(y.ushln(this.shift));
      }),
      (B.prototype.convertFrom = function (y) {
        var v = this.imod(y.mul(this.rinv));
        return (v.red = null), v;
      }),
      (B.prototype.imul = function (y, v) {
        if (y.isZero() || v.isZero()) return (y.words[0] = 0), (y.length = 1), y;
        var S = y.imul(v),
          T = S.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
          M = S.isub(T).iushrn(this.shift),
          R = M;
        return (
          M.cmp(this.m) >= 0 ? (R = M.isub(this.m)) : M.cmpn(0) < 0 && (R = M.iadd(this.m)),
          R._forceRed(this)
        );
      }),
      (B.prototype.mul = function (y, v) {
        if (y.isZero() || v.isZero()) return new s(0)._forceRed(this);
        var S = y.mul(v),
          T = S.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
          M = S.isub(T).iushrn(this.shift),
          R = M;
        return (
          M.cmp(this.m) >= 0 ? (R = M.isub(this.m)) : M.cmpn(0) < 0 && (R = M.iadd(this.m)),
          R._forceRed(this)
        );
      }),
      (B.prototype.invm = function (y) {
        var v = this.imod(y._invmp(this.m).mul(this.r2));
        return v._forceRed(this);
      });
  })(e, m);
})(DT);
var Sxe = DT.exports;
(function (e) {
  var t = vb.Buffer,
    n = gA,
    r = Sxe,
    i = UP().ec,
    s = ij,
    o = new i('secp256k1'),
    a = o.curve;
  function c(d, f) {
    var h = new r(f);
    if (h.cmp(a.p) >= 0) return null;
    h = h.toRed(a.red);
    var p = h.redSqr().redIMul(h).redIAdd(a.b).redSqrt();
    (d === 3) !== p.isOdd() && (p = p.redNeg());
    const b = h.redSqr().redIMul(h);
    return p.redSqr().redISub(b.redIAdd(a.b)).isZero() ? o.keyPair({ pub: { x: h, y: p } }) : null;
  }
  function u(d, f, h) {
    var p = new r(f),
      b = new r(h);
    if (
      p.cmp(a.p) >= 0 ||
      b.cmp(a.p) >= 0 ||
      ((p = p.toRed(a.red)), (b = b.toRed(a.red)), (d === 6 || d === 7) && b.isOdd() !== (d === 7))
    )
      return null;
    var w = p.redSqr().redIMul(p);
    return b.redSqr().redISub(w.redIAdd(a.b)).isZero() ? o.keyPair({ pub: { x: p, y: b } }) : null;
  }
  function l(d) {
    var f = d[0];
    switch (f) {
      case 2:
      case 3:
        return d.length !== 33 ? null : c(f, d.slice(1, 33));
      case 4:
      case 6:
      case 7:
        return d.length !== 65 ? null : u(f, d.slice(1, 33), d.slice(33, 65));
      default:
        return null;
    }
  }
  (e.privateKeyVerify = function (d) {
    var f = new r(d);
    return f.cmp(a.n) < 0 && !f.isZero();
  }),
    (e.privateKeyExport = function (d, f) {
      var h = new r(d);
      if (h.cmp(a.n) >= 0 || h.isZero()) throw new Error(s.EC_PRIVATE_KEY_EXPORT_DER_FAIL);
      return t.from(o.keyFromPrivate(d).getPublic(f, !0));
    }),
    (e.privateKeyNegate = function (d) {
      var f = new r(d);
      return f.isZero() ? t.alloc(32) : a.n.sub(f).umod(a.n).toArrayLike(t, 'be', 32);
    }),
    (e.privateKeyModInverse = function (d) {
      var f = new r(d);
      if (f.cmp(a.n) >= 0 || f.isZero()) throw new Error(s.EC_PRIVATE_KEY_RANGE_INVALID);
      return f.invm(a.n).toArrayLike(t, 'be', 32);
    }),
    (e.privateKeyTweakAdd = function (d, f) {
      var h = new r(f);
      if (h.cmp(a.n) >= 0) throw new Error(s.EC_PRIVATE_KEY_TWEAK_ADD_FAIL);
      if ((h.iadd(new r(d)), h.cmp(a.n) >= 0 && h.isub(a.n), h.isZero()))
        throw new Error(s.EC_PRIVATE_KEY_TWEAK_ADD_FAIL);
      return h.toArrayLike(t, 'be', 32);
    }),
    (e.privateKeyTweakMul = function (d, f) {
      var h = new r(f);
      if (h.cmp(a.n) >= 0 || h.isZero()) throw new Error(s.EC_PRIVATE_KEY_TWEAK_MUL_FAIL);
      return h.imul(new r(d)), h.cmp(a.n) && (h = h.umod(a.n)), h.toArrayLike(t, 'be', 32);
    }),
    (e.publicKeyCreate = function (d, f) {
      var h = new r(d);
      if (h.cmp(a.n) >= 0 || h.isZero()) throw new Error(s.EC_PUBLIC_KEY_CREATE_FAIL);
      return t.from(o.keyFromPrivate(d).getPublic(f, !0));
    }),
    (e.publicKeyConvert = function (d, f) {
      var h = l(d);
      if (h === null) throw new Error(s.EC_PUBLIC_KEY_PARSE_FAIL);
      return t.from(h.getPublic(f, !0));
    }),
    (e.publicKeyVerify = function (d) {
      return l(d) !== null;
    }),
    (e.publicKeyTweakAdd = function (d, f, h) {
      var p = l(d);
      if (p === null) throw new Error(s.EC_PUBLIC_KEY_PARSE_FAIL);
      if (((f = new r(f)), f.cmp(a.n) >= 0)) throw new Error(s.EC_PUBLIC_KEY_TWEAK_ADD_FAIL);
      var b = a.g.mul(f).add(p.pub);
      if (b.isInfinity()) throw new Error(s.EC_PUBLIC_KEY_TWEAK_ADD_FAIL);
      return t.from(b.encode(!0, h));
    }),
    (e.publicKeyTweakMul = function (d, f, h) {
      var p = l(d);
      if (p === null) throw new Error(s.EC_PUBLIC_KEY_PARSE_FAIL);
      if (((f = new r(f)), f.cmp(a.n) >= 0 || f.isZero()))
        throw new Error(s.EC_PUBLIC_KEY_TWEAK_MUL_FAIL);
      return t.from(p.pub.mul(f).encode(!0, h));
    }),
    (e.publicKeyCombine = function (d, f) {
      for (var h = new Array(d.length), p = 0; p < d.length; ++p)
        if (((h[p] = l(d[p])), h[p] === null)) throw new Error(s.EC_PUBLIC_KEY_PARSE_FAIL);
      for (var b = h[0].pub, w = 1; w < h.length; ++w) b = b.add(h[w].pub);
      if (b.isInfinity()) throw new Error(s.EC_PUBLIC_KEY_COMBINE_FAIL);
      return t.from(b.encode(!0, f));
    }),
    (e.signatureNormalize = function (d) {
      var f = new r(d.slice(0, 32)),
        h = new r(d.slice(32, 64));
      if (f.cmp(a.n) >= 0 || h.cmp(a.n) >= 0) throw new Error(s.ECDSA_SIGNATURE_PARSE_FAIL);
      var p = t.from(d);
      return h.cmp(o.nh) === 1 && a.n.sub(h).toArrayLike(t, 'be', 32).copy(p, 32), p;
    }),
    (e.signatureExport = function (d) {
      var f = d.slice(0, 32),
        h = d.slice(32, 64);
      if (new r(f).cmp(a.n) >= 0 || new r(h).cmp(a.n) >= 0)
        throw new Error(s.ECDSA_SIGNATURE_PARSE_FAIL);
      return { r: f, s: h };
    }),
    (e.signatureImport = function (d) {
      var f = new r(d.r);
      f.cmp(a.n) >= 0 && (f = new r(0));
      var h = new r(d.s);
      return (
        h.cmp(a.n) >= 0 && (h = new r(0)),
        t.concat([f.toArrayLike(t, 'be', 32), h.toArrayLike(t, 'be', 32)])
      );
    }),
    (e.sign = function (d, f, h, p) {
      if (typeof h == 'function') {
        var b = h;
        h = function (_) {
          var x = b(d, f, null, p, _);
          if (!t.isBuffer(x) || x.length !== 32) throw new Error(s.ECDSA_SIGN_FAIL);
          return new r(x);
        };
      }
      var w = new r(f);
      if (w.cmp(a.n) >= 0 || w.isZero()) throw new Error(s.ECDSA_SIGN_FAIL);
      var A = o.sign(d, f, { canonical: !0, k: h, pers: p });
      return {
        signature: t.concat([A.r.toArrayLike(t, 'be', 32), A.s.toArrayLike(t, 'be', 32)]),
        recovery: A.recoveryParam,
      };
    }),
    (e.verify = function (d, f, h) {
      var p = { r: f.slice(0, 32), s: f.slice(32, 64) },
        b = new r(p.r),
        w = new r(p.s);
      if (b.cmp(a.n) >= 0 || w.cmp(a.n) >= 0) throw new Error(s.ECDSA_SIGNATURE_PARSE_FAIL);
      if (w.cmp(o.nh) === 1 || b.isZero() || w.isZero()) return !1;
      var A = l(h);
      if (A === null) throw new Error(s.EC_PUBLIC_KEY_PARSE_FAIL);
      return o.verify(d, p, { x: A.pub.x, y: A.pub.y });
    }),
    (e.recover = function (d, f, h, p) {
      var b = { r: f.slice(0, 32), s: f.slice(32, 64) },
        w = new r(b.r),
        A = new r(b.s);
      if (w.cmp(a.n) >= 0 || A.cmp(a.n) >= 0) throw new Error(s.ECDSA_SIGNATURE_PARSE_FAIL);
      try {
        if (w.isZero() || A.isZero()) throw new Error();
        var _ = o.recoverPubKey(d, b, h);
        return t.from(_.encode(!0, p));
      } catch {
        throw new Error(s.ECDSA_RECOVER_FAIL);
      }
    }),
    (e.ecdh = function (d, f) {
      var h = e.ecdhUnsafe(d, f, !0);
      return n('sha256').update(h).digest();
    }),
    (e.ecdhUnsafe = function (d, f, h) {
      var p = l(d);
      if (p === null) throw new Error(s.EC_PUBLIC_KEY_PARSE_FAIL);
      var b = new r(f);
      if (b.cmp(a.n) >= 0 || b.isZero()) throw new Error(s.ECDH_FAIL);
      return t.from(p.pub.mul(b).encode(!0, h));
    });
})(sj);
var Exe = _xe(sj);
const $_ = ETe,
  pC = MTe,
  Og = OTe,
  oj = gA,
  RT = Exe,
  gC = yA,
  sa = { P2WPKH: 'p2wpkh', P2SH_P2WPKH: 'p2sh(p2wpkh)' };
function XE(e) {
  return oj('sha256').update(e).digest();
}
function Axe(e) {
  return XE(XE(e));
}
function aj(e) {
  return oj('ripemd160').update(XE(e)).digest();
}
function cj(e, t, n, r) {
  return (
    r !== void 0 ? ((t += 8), r === sa.P2WPKH && (t += 4)) : n && (t += 4),
    z.concat([z.alloc(1, t + 27), e])
  );
}
function Ixe(e) {
  if (e.length !== 65) throw new Error('Invalid signature length');
  const t = e.readUInt8(0) - 27;
  if (t > 15 || t < 0) throw new Error('Invalid signature parameter');
  return {
    compressed: !!(t & 12),
    segwitType: t & 8 ? (t & 4 ? sa.P2WPKH : sa.P2SH_P2WPKH) : null,
    recovery: t & 3,
    signature: e.slice(1),
  };
}
function V1(e, t) {
  (t =
    t ||
    `Bitcoin Signed Message:
`),
    z.isBuffer(t) || (t = z.from(t, 'utf8')),
    z.isBuffer(e) || (e = z.from(e, 'utf8'));
  const n = gC.encodingLength(e.length),
    r = z.allocUnsafe(t.length + n + e.length);
  return t.copy(r, 0), gC.encode(e.length, r, t.length), e.copy(r, t.length + n), Axe(r);
}
function uj(e, t) {
  typeof e == 'object' && t === void 0 && ((t = e), (e = void 0));
  let { segwitType: n, extraEntropy: r } = t || {};
  if (
    (n && (typeof n == 'string' || n instanceof String) && (n = n.toLowerCase()),
    n && n !== sa.P2SH_P2WPKH && n !== sa.P2WPKH)
  )
    throw new Error('Unrecognized segwitType: use "' + sa.P2SH_P2WPKH + '" or "' + sa.P2WPKH + '"');
  return { messagePrefixArg: e, segwitType: n, extraEntropy: r };
}
function lj(e) {
  return e && typeof e.sign == 'function';
}
function Txe(e, t, n, r, i) {
  const { messagePrefixArg: s, segwitType: o, extraEntropy: a } = uj(r, i),
    c = V1(e, s),
    u = lj(t) ? t.sign(c, a) : RT.sign(c, t, { data: a });
  return cj(u.signature, u.recovery, n, o);
}
function xxe(e, t, n, r, i) {
  let s, o, a;
  return Promise.resolve()
    .then(() => {
      ({ messagePrefixArg: s, segwitType: o, extraEntropy: a } = uj(r, i));
      const c = V1(e, s);
      return lj(t) ? t.sign(c, a) : RT.sign(c, t, { data: a });
    })
    .then((c) => cj(c.signature, c.recovery, n, o));
}
function yC(e) {
  const t = z.concat([z.from('0014', 'hex'), e]);
  return aj(t);
}
function bC(e) {
  const t = pC.decode(e),
    n = pC.fromWords(t.words.slice(1));
  return z.from(n);
}
function kxe(e, t, n, r, i) {
  z.isBuffer(n) || (n = z.from(n, 'base64'));
  const s = Ixe(n);
  if (i && !s.compressed)
    throw new Error(
      'checkSegwitAlways can only be used with a compressed pubkey signature flagbyte'
    );
  const o = V1(e, r),
    a = RT.recover(o, s.signature, s.recovery, s.compressed),
    c = aj(a);
  let u, l;
  if (s.segwitType)
    s.segwitType === sa.P2SH_P2WPKH
      ? ((u = yC(c)), (l = $_.decode(t).slice(1)))
      : ((u = c), (l = bC(t)));
  else if (i)
    try {
      return (l = bC(t)), Og(c, l);
    } catch {
      const f = yC(c);
      return (l = $_.decode(t).slice(1)), Og(c, l) || Og(f, l);
    }
  else (u = c), (l = $_.decode(t).slice(1));
  return Og(u, l);
}
var NT = { magicHash: V1, sign: Txe, signAsync: xxe, verify: kxe },
  Cxe =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  Pxe =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  Mxe =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && Cxe(t, e, n);
      return Pxe(t, e), t;
    },
  Oxe =
    (m && m.__importDefault) ||
    function (e) {
      return e && e.__esModule ? e : { default: e };
    };
Object.defineProperty(BT, '__esModule', { value: !0 });
const Bxe = Oxe(mTe),
  Dxe = Mxe(NT);
class Rxe {
  static isBIP137Signature(t) {
    return z.from(t, 'base64').byteLength === 65;
  }
  static derivePubKey(t, n) {
    const r = Dxe.magicHash(t),
      i = this.decodeSignature(z.from(n, 'base64'));
    return z.from(Bxe.default.ecdsaRecover(i.signature, i.recovery, r, i.compressed));
  }
  static decodeSignature(t) {
    if (t.length !== 65) throw new Error('Invalid signature length');
    const n = t.readUInt8(0) - 27;
    if (n > 19 || n < 0) throw new Error('Invalid signature parameter');
    return { compressed: !!(n & 12), recovery: n & 3, signature: t.subarray(1) };
  }
}
BT.default = Rxe;
var Np = {};
Object.defineProperty(Np, '__esModule', { value: !0 });
class Nxe {
  static encode(t) {
    if (t < 253) {
      const n = z.alloc(1);
      return n.writeUInt8(t), n;
    } else if (t < 65536) {
      const n = z.alloc(3);
      return n.writeUInt8(253), n.writeUInt16LE(t, 1), n;
    } else if (t < 4294967296) {
      const n = z.alloc(5);
      return n.writeUInt8(254), n.writeUInt32LE(t, 1), n;
    } else if (t < 281474976710656) {
      const n = z.alloc(9);
      return n.writeUInt8(255), n.writeUIntLE(t, 1, 6), n.writeUInt8(0, 7), n.writeUInt8(0, 8), n;
    } else throw new Error(`Integer too large: ${t}`);
  }
  static decode(t) {
    if (t.byteLength === 0) throw new Error('Empty buffer provided');
    const n = t.readUInt8();
    return n === 253
      ? t.readUInt16LE(1)
      : n === 254
        ? t.readUInt32LE(1)
        : n === 255
          ? t.readUIntLE(1, 6)
          : n;
  }
}
Np.default = Nxe;
var W1 = {},
  jxe =
    (m && m.__importDefault) ||
    function (e) {
      return e && e.__esModule ? e : { default: e };
    };
Object.defineProperty(W1, '__esModule', { value: !0 });
const F_ = jxe(Np);
class Lxe {
  static encode(t) {
    const n = F_.default.encode(t.length);
    return z.concat([n, t]);
  }
  static decode(t) {
    const n = F_.default.decode(t),
      r = F_.default.encode(n).byteLength;
    return t.subarray(r, n + r);
  }
}
W1.default = Lxe;
var jT = {},
  dj =
    (m && m.__importDefault) ||
    function (e) {
      return e && e.__esModule ? e : { default: e };
    };
Object.defineProperty(jT, '__esModule', { value: !0 });
const z_ = dj(Np),
  K_ = dj(W1);
class Uxe {
  static serialize(t) {
    let n = z_.default.encode(t.length);
    return (
      t.forEach((r) => {
        n = z.concat([n, K_.default.encode(z.from(r))]);
      }),
      n.toString('base64')
    );
  }
  static deserialize(t) {
    let n = [],
      r;
    typeof t == 'string' ? (r = z.from(t, 'base64')) : (r = t);
    const i = z_.default.decode(r),
      s = z_.default.encode(i).byteLength;
    r = r.subarray(s);
    for (let o = 0; o < i; o++) {
      const a = K_.default.decode(r);
      n.push(a);
      const c = K_.default.encode(a).byteLength;
      r = r.subarray(c);
    }
    return n;
  }
}
jT.default = Uxe;
var jp =
  (m && m.__importDefault) ||
  function (e) {
    return e && e.__esModule ? e : { default: e };
  };
Object.defineProperty(Cr, '__esModule', { value: !0 });
Cr.Witness = Cr.VarStr = Cr.VarInt = Cr.BIP137 = Cr.Address = void 0;
const $xe = jp(OT);
Cr.Address = $xe.default;
const Fxe = jp(BT);
Cr.BIP137 = Fxe.default;
const zxe = jp(Np);
Cr.VarInt = zxe.default;
const Kxe = jp(W1);
Cr.VarStr = Kxe.default;
const Vxe = jp(jT);
Cr.Witness = Vxe.default;
var Wxe =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  Hxe =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  fj =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && Wxe(t, e, n);
      return Hxe(t, e), t;
    },
  LT =
    (m && m.__importDefault) ||
    function (e) {
      return e && e.__esModule ? e : { default: e };
    };
Object.defineProperty(MT, '__esModule', { value: !0 });
const kl = LT(Rp),
  Gxe = LT(nI),
  ti = Cr,
  zc = fj(bi),
  qxe = LT(bA),
  Yxe = fj(NT);
let Zxe = class {
  static sign(t, n, r, i = zc.networks.bitcoin) {
    let o = (0, Gxe.default)(qxe.default).fromWIF(t, i);
    if (!this.checkPubKeyCorrespondToAddress(o.publicKey, n))
      throw new Error(`Invalid private key provided for signing message for ${n}.`);
    if (ti.Address.isP2PKH(n)) return Yxe.sign(r, o.privateKey, o.compressed);
    const a = ti.Address.convertAdressToScriptPubkey(n),
      c = kl.default.buildToSpendTx(r, a);
    let u;
    if (ti.Address.isP2SH(n)) {
      const d = zc.payments.p2wpkh({ hash: zc.crypto.hash160(o.publicKey), network: i }).output;
      u = kl.default.buildToSignTx(c.getId(), d, !0);
    } else if (ti.Address.isP2WPKH(n)) u = kl.default.buildToSignTx(c.getId(), a);
    else {
      const d = o.publicKey.subarray(1, 33);
      (o = o.tweak(zc.crypto.taggedHash('TapTweak', o.publicKey.subarray(1, 33)))),
        (u = kl.default.buildToSignTx(c.getId(), a, !1, d)),
        u.updateInput(0, { sighashType: zc.Transaction.SIGHASH_ALL });
    }
    const l = u.signAllInputs(o, [zc.Transaction.SIGHASH_ALL]).finalizeAllInputs();
    return kl.default.encodeWitness(l);
  }
  static checkPubKeyCorrespondToAddress(t, n) {
    let r;
    if (ti.Address.isP2PKH(n)) r = ti.Address.convertPubKeyIntoAddress(t, 'p2pkh');
    else if (ti.Address.isP2SH(n)) r = ti.Address.convertPubKeyIntoAddress(t, 'p2sh-p2wpkh');
    else if (ti.Address.isP2WPKH(n)) r = ti.Address.convertPubKeyIntoAddress(t, 'p2wpkh');
    else if (ti.Address.isP2TR(n)) r = ti.Address.convertPubKeyIntoAddress(t, 'p2tr');
    else throw new Error('Unable to sign BIP-322 message for unsupported address type.');
    return r.mainnet === n || r.testnet === n;
  }
};
MT.default = Zxe;
var UT = {},
  hj = {},
  H1 = {};
Object.defineProperty(H1, '__esModule', { value: !0 });
H1.decodeScriptSignature = void 0;
function Jxe(e) {
  const t = e.readUInt8(e.length - 1),
    n = t & -129;
  if (n <= 0 || n >= 4) throw new Error('Invalid hashType ' + t);
  const r = Xxe(e.slice(0, -1)),
    i = mC(r.r),
    s = mC(r.s);
  return { signature: z.concat([i, s], 64), hashType: t };
}
H1.decodeScriptSignature = Jxe;
function mC(e) {
  e[0] === 0 && (e = e.slice(1));
  const t = z.alloc(32, 0),
    n = Math.max(0, 32 - e.length);
  return e.copy(t, n), t;
}
function Xxe(e) {
  if (e.length < 8) throw new Error('DER sequence length is too short');
  if (e.length > 72) throw new Error('DER sequence length is too long');
  if (e[0] !== 48) throw new Error('Expected DER sequence');
  if (e[1] !== e.length - 2) throw new Error('DER sequence length is invalid');
  if (e[2] !== 2) throw new Error('Expected DER integer');
  const t = e[3];
  if (t === 0) throw new Error('R length is zero');
  if (5 + t >= e.length) throw new Error('R length is too long');
  if (e[4 + t] !== 2) throw new Error('Expected DER integer (2)');
  const n = e[5 + t];
  if (n === 0) throw new Error('S length is zero');
  if (6 + t + n !== e.length) throw new Error('S length is invalid');
  if (e[4] & 128) throw new Error('R value is negative');
  if (t > 1 && e[4] === 0 && !(e[5] & 128)) throw new Error('R value excessively padded');
  if (e[t + 6] & 128) throw new Error('S value is negative');
  if (n > 1 && e[t + 6] === 0 && !(e[t + 7] & 128)) throw new Error('S value excessively padded');
  return { r: e.slice(4, 4 + t), s: e.slice(6 + t) };
}
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }), (e.decodeScriptSignature = void 0);
  const t = H1;
  Object.defineProperty(e, 'decodeScriptSignature', {
    enumerable: !0,
    get: function () {
      return t.decodeScriptSignature;
    },
  });
})(hj);
var Qxe =
    (m && m.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  eke =
    (m && m.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  pj =
    (m && m.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && Qxe(t, e, n);
      return eke(t, e), t;
    },
  gj =
    (m && m.__importDefault) ||
    function (e) {
      return e && e.__esModule ? e : { default: e };
    };
Object.defineProperty(UT, '__esModule', { value: !0 });
const wC = gj(Rp),
  rr = Cr,
  Ko = pj(bi),
  vC = gj(bA),
  _C = pj(NT),
  tke = hj;
class nke {
  static verifySignature(t, n, r) {
    if (rr.Address.isP2PKH(t) || rr.BIP137.isBIP137Signature(r))
      return this.verifyBIP137Signature(t, n, r);
    const i = rr.Address.convertAdressToScriptPubkey(t),
      s = wC.default.buildToSpendTx(n, i),
      o = wC.default.buildToSignTx(s.getId(), i);
    o.updateInput(0, { finalScriptWitness: z.from(r, 'base64') });
    const a = o.extractTransaction().ins[0].witness,
      c = a[0];
    if (rr.Address.isP2WPKHWitness(a)) {
      const u = a[1],
        { signature: l } = (0, tke.decodeScriptSignature)(c),
        d = Ko.crypto.hash160(u);
      let f;
      if (rr.Address.isP2SH(t)) {
        f = this.getHashForSigP2SHInP2WPKH(o, d);
        const h = z.concat([z.from([0, 20]), d]),
          p = Ko.crypto.hash160(h),
          b = i.subarray(2, -1);
        if (z.compare(p, b) !== 0) return !1;
      } else {
        f = this.getHashForSigP2WPKH(o);
        const h = i.subarray(2);
        if (z.compare(d, h) !== 0) return !1;
      }
      return vC.default.verify(f, u, l);
    } else if (rr.Address.isP2TR(t)) {
      if (!rr.Address.isSingleKeyP2TRWitness(a))
        throw new Error('BIP-322 verification from script-spend P2TR is unsupported.');
      const u = i.subarray(2);
      let l, d;
      if (c.byteLength === 64) (l = this.getHashForSigP2TR(o, 0)), (d = c);
      else if (c.byteLength === 65) (l = this.getHashForSigP2TR(o, c[64])), (d = c.subarray(0, -1));
      else throw new Error('Invalid Schnorr signature provided.');
      return vC.default.verifySchnorr(l, u, d);
    } else
      throw new Error(
        'Only P2WPKH, P2SH-P2WPKH, and single-key-spend P2TR BIP-322 verification is supported. Unsupported address is provided.'
      );
  }
  static verifyBIP137Signature(t, n, r) {
    if (rr.Address.isP2PKH(t)) return _C.verify(n, t, r);
    {
      const i = rr.BIP137.derivePubKey(n, r),
        s = rr.Address.convertPubKeyIntoAddress(i, 'p2pkh').mainnet;
      if (rr.Address.isP2SH(t)) {
        const o = rr.Address.convertPubKeyIntoAddress(i, 'p2sh-p2wpkh');
        if (o.mainnet !== t && o.testnet !== t) return !1;
      } else if (rr.Address.isP2WPKH(t)) {
        const o = rr.Address.convertPubKeyIntoAddress(i, 'p2wpkh');
        if (o.mainnet !== t && o.testnet !== t) return !1;
      } else if (rr.Address.isP2TR(t)) {
        const o = rr.Address.convertPubKeyIntoAddress(i, 'p2tr');
        if (o.mainnet !== t && o.testnet !== t) return !1;
      } else return !1;
      return _C.verify(n, s, r);
    }
  }
  static getHashForSigP2WPKH(t) {
    const n = Ko.payments.p2pkh({ hash: t.data.inputs[0].witnessUtxo.script.subarray(2) }).output;
    return t.extractTransaction().hashForWitnessV0(0, n, 0, Ko.Transaction.SIGHASH_ALL);
  }
  static getHashForSigP2SHInP2WPKH(t, n) {
    const r = Ko.payments.p2pkh({ hash: n }).output;
    return t.extractTransaction().hashForWitnessV0(0, r, 0, Ko.Transaction.SIGHASH_ALL);
  }
  static getHashForSigP2TR(t, n) {
    if (n !== Ko.Transaction.SIGHASH_DEFAULT && n !== Ko.Transaction.SIGHASH_ALL)
      throw new Error(
        'Invalid SIGHASH used in signature. Must be either SIGHASH_ALL or SIGHASH_DEFAULT.'
      );
    return t
      .extractTransaction()
      .hashForWitnessV1(0, [t.data.inputs[0].witnessUtxo.script], [0], n);
  }
}
UT.default = nke;
(function (e) {
  var t =
      (m && m.__createBinding) ||
      (Object.create
        ? function (d, f, h, p) {
            p === void 0 && (p = h);
            var b = Object.getOwnPropertyDescriptor(f, h);
            (!b || ('get' in b ? !f.__esModule : b.writable || b.configurable)) &&
              (b = {
                enumerable: !0,
                get: function () {
                  return f[h];
                },
              }),
              Object.defineProperty(d, p, b);
          }
        : function (d, f, h, p) {
            p === void 0 && (p = h), (d[p] = f[h]);
          }),
    n =
      (m && m.__setModuleDefault) ||
      (Object.create
        ? function (d, f) {
            Object.defineProperty(d, 'default', { enumerable: !0, value: f });
          }
        : function (d, f) {
            d.default = f;
          }),
    r =
      (m && m.__importStar) ||
      function (d) {
        if (d && d.__esModule) return d;
        var f = {};
        if (d != null)
          for (var h in d)
            h !== 'default' && Object.prototype.hasOwnProperty.call(d, h) && t(f, d, h);
        return n(f, d), f;
      },
    i =
      (m && m.__importDefault) ||
      function (d) {
        return d && d.__esModule ? d : { default: d };
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.BIP137 = e.Address = e.Witness = e.Verifier = e.Signer = e.BIP322 = void 0);
  const s = i(Rp);
  e.BIP322 = s.default;
  const o = i(MT);
  e.Signer = o.default;
  const a = i(UT);
  e.Verifier = a.default;
  const c = Cr;
  Object.defineProperty(e, 'Witness', {
    enumerable: !0,
    get: function () {
      return c.Witness;
    },
  }),
    Object.defineProperty(e, 'Address', {
      enumerable: !0,
      get: function () {
        return c.Address;
      },
    }),
    Object.defineProperty(e, 'BIP137', {
      enumerable: !0,
      get: function () {
        return c.BIP137;
      },
    });
  const u = i(bA);
  r(bi).initEccLib(u.default);
})(iTe);
var V_ = function (e, t, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(l) {
        try {
          u(r.next(l));
        } catch (d) {
          o(d);
        }
      }
      function c(l) {
        try {
          u(r.throw(l));
        } catch (d) {
          o(d);
        }
      }
      function u(l) {
        l.done ? s(l.value) : i(l.value).then(a, c);
      }
      u((r = r.apply(e, t || [])).next());
    });
  },
  W_ = function (e, t) {
    var n = {
        label: 0,
        sent: function () {
          if (s[0] & 1) throw s[1];
          return s[1];
        },
        trys: [],
        ops: [],
      },
      r,
      i,
      s,
      o;
    return (
      (o = { next: a(0), throw: a(1), return: a(2) }),
      typeof Symbol == 'function' &&
        (o[Symbol.iterator] = function () {
          return this;
        }),
      o
    );
    function a(u) {
      return function (l) {
        return c([u, l]);
      };
    }
    function c(u) {
      if (r) throw new TypeError('Generator is already executing.');
      for (; n; )
        try {
          if (
            ((r = 1),
            i &&
              (s =
                u[0] & 2
                  ? i.return
                  : u[0]
                    ? i.throw || ((s = i.return) && s.call(i), 0)
                    : i.next) &&
              !(s = s.call(i, u[1])).done)
          )
            return s;
          switch (((i = 0), s && (u = [u[0] & 2, s.value]), u[0])) {
            case 0:
            case 1:
              s = u;
              break;
            case 4:
              return n.label++, { value: u[1], done: !1 };
            case 5:
              n.label++, (i = u[1]), (u = [0]);
              continue;
            case 7:
              (u = n.ops.pop()), n.trys.pop();
              continue;
            default:
              if (
                ((s = n.trys), !(s = s.length > 0 && s[s.length - 1]) && (u[0] === 6 || u[0] === 2))
              ) {
                n = 0;
                continue;
              }
              if (u[0] === 3 && (!s || (u[1] > s[0] && u[1] < s[3]))) {
                n.label = u[1];
                break;
              }
              if (u[0] === 6 && n.label < s[1]) {
                (n.label = s[1]), (s = u);
                break;
              }
              if (s && n.label < s[2]) {
                (n.label = s[2]), n.ops.push(u);
                break;
              }
              s[2] && n.ops.pop(), n.trys.pop();
              continue;
          }
          u = t.call(e, n);
        } catch (l) {
          (u = [6, l]), (i = 0);
        } finally {
          r = s = 0;
        }
      if (u[0] & 5) throw u[1];
      return { value: u[0] ? u[1] : void 0, done: !0 };
    }
  },
  rke = function (e, t) {
    var n = typeof Symbol == 'function' && e[Symbol.iterator];
    if (!n) return e;
    var r = n.call(e),
      i,
      s = [],
      o;
    try {
      for (; (t === void 0 || t-- > 0) && !(i = r.next()).done; ) s.push(i.value);
    } catch (a) {
      o = { error: a };
    } finally {
      try {
        i && !i.done && (n = r.return) && n.call(r);
      } finally {
        if (o) throw o.error;
      }
    }
    return s;
  },
  ike = function (e, t, n) {
    if (n || arguments.length === 2)
      for (var r = 0, i = t.length, s; r < i; r++)
        (s || !(r in t)) && (s || (s = Array.prototype.slice.call(t, 0, r)), (s[r] = t[r]));
    return e.concat(s || Array.prototype.slice.call(t));
  },
  ske = function (e) {
    var t = typeof Symbol == 'function' && Symbol.iterator,
      n = t && e[t],
      r = 0;
    if (n) return n.call(e);
    if (e && typeof e.length == 'number')
      return {
        next: function () {
          return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e };
        },
      };
    throw new TypeError(t ? 'Object is not iterable.' : 'Symbol.iterator is not defined.');
  },
  oke = (function () {
    function e() {
      var t = this;
      (this.exchangeTimeout = 3e4),
        (this.unresponsiveTimeout = 15e3),
        (this.deviceModel = null),
        (this._events = new CL()),
        (this.send = function (n, r, i, s, o, a) {
          return (
            o === void 0 && (o = z.alloc(0)),
            a === void 0 && (a = [cb.OK]),
            V_(t, void 0, void 0, function () {
              var c, u;
              return W_(this, function (l) {
                switch (l.label) {
                  case 0:
                    if (o.length >= 256)
                      throw new za(
                        'data.length exceed 256 bytes limit. Got: ' + o.length,
                        'DataLengthTooBig'
                      );
                    return [
                      4,
                      this.exchange(z.concat([z.from([n, r, i, s]), z.from([o.length]), o])),
                    ];
                  case 1:
                    if (
                      ((c = l.sent()),
                      (u = c.readUInt16BE(c.length - 2)),
                      !a.some(function (d) {
                        return d === u;
                      }))
                    )
                      throw new F1(u);
                    return [2, c];
                }
              });
            })
          );
        }),
        (this.exchangeAtomicImpl = function (n) {
          return V_(t, void 0, void 0, function () {
            var r,
              i,
              s,
              o,
              a,
              c = this;
            return W_(this, function (u) {
              switch (u.label) {
                case 0:
                  if (this.exchangeBusyPromise)
                    throw new ZN(
                      'An action was already pending on the Ledger device. Please deny or reconnect.'
                    );
                  (i = new Promise(function (l) {
                    r = l;
                  })),
                    (this.exchangeBusyPromise = i),
                    (s = !1),
                    (o = setTimeout(function () {
                      (s = !0), c.emit('unresponsive');
                    }, this.unresponsiveTimeout)),
                    (u.label = 1);
                case 1:
                  return u.trys.push([1, , 3, 4]), [4, n()];
                case 2:
                  return (a = u.sent()), s && this.emit('responsive'), [2, a];
                case 3:
                  return clearTimeout(o), r && r(), (this.exchangeBusyPromise = null), [7];
                case 4:
                  return [2];
              }
            });
          });
        }),
        (this._appAPIlock = null);
    }
    return (
      (e.prototype.exchange = function (t) {
        throw new Error('exchange not implemented');
      }),
      (e.prototype.setScrambleKey = function (t) {}),
      (e.prototype.close = function () {
        return Promise.resolve();
      }),
      (e.prototype.on = function (t, n) {
        this._events.on(t, n);
      }),
      (e.prototype.off = function (t, n) {
        this._events.removeListener(t, n);
      }),
      (e.prototype.emit = function (t) {
        for (var n, r = [], i = 1; i < arguments.length; i++) r[i - 1] = arguments[i];
        (n = this._events).emit.apply(n, ike([t], rke(r), !1));
      }),
      (e.prototype.setDebugMode = function () {
        console.warn(
          'setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.'
        );
      }),
      (e.prototype.setExchangeTimeout = function (t) {
        this.exchangeTimeout = t;
      }),
      (e.prototype.setExchangeUnresponsiveTimeout = function (t) {
        this.unresponsiveTimeout = t;
      }),
      (e.create = function (t, n) {
        var r = this;
        return (
          t === void 0 && (t = 3e3),
          new Promise(function (i, s) {
            var o = !1,
              a = r.listen({
                next: function (u) {
                  (o = !0),
                    a && a.unsubscribe(),
                    c && clearTimeout(c),
                    r.open(u.descriptor, t).then(i, s);
                },
                error: function (u) {
                  c && clearTimeout(c), s(u);
                },
                complete: function () {
                  c && clearTimeout(c),
                    o || s(new za(r.ErrorMessage_NoDeviceFound, 'NoDeviceFound'));
                },
              }),
              c = n
                ? setTimeout(function () {
                    a.unsubscribe(), s(new za(r.ErrorMessage_ListenTimeout, 'ListenTimeout'));
                  }, n)
                : null;
          })
        );
      }),
      (e.prototype.decorateAppAPIMethods = function (t, n, r) {
        var i, s;
        try {
          for (var o = ske(n), a = o.next(); !a.done; a = o.next()) {
            var c = a.value;
            t[c] = this.decorateAppAPIMethod(c, t[c], t, r);
          }
        } catch (u) {
          i = { error: u };
        } finally {
          try {
            a && !a.done && (s = o.return) && s.call(o);
          } finally {
            if (i) throw i.error;
          }
        }
      }),
      (e.prototype.decorateAppAPIMethod = function (t, n, r, i) {
        var s = this;
        return function () {
          for (var o = [], a = 0; a < arguments.length; a++) o[a] = arguments[a];
          return V_(s, void 0, void 0, function () {
            var c;
            return W_(this, function (u) {
              switch (u.label) {
                case 0:
                  if (((c = this._appAPIlock), c))
                    return [
                      2,
                      Promise.reject(
                        new za('Ledger Device is busy (lock ' + c + ')', 'TransportLocked')
                      ),
                    ];
                  u.label = 1;
                case 1:
                  return (
                    u.trys.push([1, , 3, 4]),
                    (this._appAPIlock = t),
                    this.setScrambleKey(i),
                    [4, n.apply(r, o)]
                  );
                case 2:
                  return [2, u.sent()];
                case 3:
                  return (this._appAPIlock = null), [7];
                case 4:
                  return [2];
              }
            });
          });
        };
      }),
      (e.ErrorMessage_ListenTimeout = 'No Ledger device found (timeout)'),
      (e.ErrorMessage_NoDeviceFound = 'No Ledger device found'),
      e
    );
  })(),
  yj = {};
const ake = Sb(tTe);
(function (e) {
  e.__esModule = !0;
  var t = ake,
    n = 5;
  function r(o) {
    var a = z.alloc(2);
    return a.writeUInt16BE(o, 0), a;
  }
  var i = { data: z.alloc(0), dataLength: 0, sequence: 0 },
    s = function (o, a) {
      return {
        makeBlocks: function (c) {
          var u = z.concat([r(c.length), c]),
            l = a - 5,
            d = Math.ceil(u.length / l);
          u = z.concat([u, z.alloc(d * l - u.length + 1).fill(0)]);
          for (var f = [], h = 0; h < d; h++) {
            var p = z.alloc(5);
            p.writeUInt16BE(o, 0), p.writeUInt8(n, 2), p.writeUInt16BE(h, 3);
            var b = u.slice(h * l, (h + 1) * l);
            f.push(z.concat([p, b]));
          }
          return f;
        },
        reduceResponse: function (c, u) {
          var l = c || i,
            d = l.data,
            f = l.dataLength,
            h = l.sequence;
          if (u.readUInt16BE(0) !== o)
            throw new t.TransportError('Invalid channel', 'InvalidChannel');
          if (u.readUInt8(2) !== n) throw new t.TransportError('Invalid tag', 'InvalidTag');
          if (u.readUInt16BE(3) !== h)
            throw new t.TransportError('Invalid sequence', 'InvalidSequence');
          c || (f = u.readUInt16BE(5)), h++;
          var p = u.slice(c ? 5 : 7);
          return (
            (d = z.concat([d, p])),
            d.length > f && (d = d.slice(0, f)),
            { data: d, dataLength: f, sequence: h }
          );
        },
        getReducedResult: function (c) {
          if (c && c.dataLength === c.data.length) return c.data;
        },
      };
    };
  e.default = s;
})(yj);
const cke = Sc(yj);
var QE = { exports: {} };
const uke = '2.0.0',
  lke = 256,
  dke = Number.MAX_SAFE_INTEGER || 9007199254740991,
  fke = 16,
  hke = ['major', 'premajor', 'minor', 'preminor', 'patch', 'prepatch', 'prerelease'];
var G1 = {
    MAX_LENGTH: lke,
    MAX_SAFE_COMPONENT_LENGTH: fke,
    MAX_SAFE_INTEGER: dke,
    RELEASE_TYPES: hke,
    SEMVER_SPEC_VERSION: uke,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2,
  },
  H_ = {};
const pke =
  typeof hu == 'object' && H_ && H_.NODE_DEBUG && /\bsemver\b/i.test(H_.NODE_DEBUG)
    ? (...e) => console.error('SEMVER', ...e)
    : () => {};
var q1 = pke;
(function (e, t) {
  const { MAX_SAFE_COMPONENT_LENGTH: n } = G1,
    r = q1;
  t = e.exports = {};
  const i = (t.re = []),
    s = (t.safeRe = []),
    o = (t.src = []),
    a = (t.t = {});
  let c = 0;
  const u = (l, d, f) => {
    const h = d.split('\\s*').join('\\s{0,1}').split('\\s+').join('\\s'),
      p = c++;
    r(l, p, d),
      (a[l] = p),
      (o[p] = d),
      (i[p] = new RegExp(d, f ? 'g' : void 0)),
      (s[p] = new RegExp(h, f ? 'g' : void 0));
  };
  u('NUMERICIDENTIFIER', '0|[1-9]\\d*'),
    u('NUMERICIDENTIFIERLOOSE', '[0-9]+'),
    u('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*'),
    u(
      'MAINVERSION',
      `(${o[a.NUMERICIDENTIFIER]})\\.(${o[a.NUMERICIDENTIFIER]})\\.(${o[a.NUMERICIDENTIFIER]})`
    ),
    u(
      'MAINVERSIONLOOSE',
      `(${o[a.NUMERICIDENTIFIERLOOSE]})\\.(${o[a.NUMERICIDENTIFIERLOOSE]})\\.(${o[a.NUMERICIDENTIFIERLOOSE]})`
    ),
    u('PRERELEASEIDENTIFIER', `(?:${o[a.NUMERICIDENTIFIER]}|${o[a.NONNUMERICIDENTIFIER]})`),
    u(
      'PRERELEASEIDENTIFIERLOOSE',
      `(?:${o[a.NUMERICIDENTIFIERLOOSE]}|${o[a.NONNUMERICIDENTIFIER]})`
    ),
    u('PRERELEASE', `(?:-(${o[a.PRERELEASEIDENTIFIER]}(?:\\.${o[a.PRERELEASEIDENTIFIER]})*))`),
    u(
      'PRERELEASELOOSE',
      `(?:-?(${o[a.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${o[a.PRERELEASEIDENTIFIERLOOSE]})*))`
    ),
    u('BUILDIDENTIFIER', '[0-9A-Za-z-]+'),
    u('BUILD', `(?:\\+(${o[a.BUILDIDENTIFIER]}(?:\\.${o[a.BUILDIDENTIFIER]})*))`),
    u('FULLPLAIN', `v?${o[a.MAINVERSION]}${o[a.PRERELEASE]}?${o[a.BUILD]}?`),
    u('FULL', `^${o[a.FULLPLAIN]}$`),
    u('LOOSEPLAIN', `[v=\\s]*${o[a.MAINVERSIONLOOSE]}${o[a.PRERELEASELOOSE]}?${o[a.BUILD]}?`),
    u('LOOSE', `^${o[a.LOOSEPLAIN]}$`),
    u('GTLT', '((?:<|>)?=?)'),
    u('XRANGEIDENTIFIERLOOSE', `${o[a.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`),
    u('XRANGEIDENTIFIER', `${o[a.NUMERICIDENTIFIER]}|x|X|\\*`),
    u(
      'XRANGEPLAIN',
      `[v=\\s]*(${o[a.XRANGEIDENTIFIER]})(?:\\.(${o[a.XRANGEIDENTIFIER]})(?:\\.(${o[a.XRANGEIDENTIFIER]})(?:${o[a.PRERELEASE]})?${o[a.BUILD]}?)?)?`
    ),
    u(
      'XRANGEPLAINLOOSE',
      `[v=\\s]*(${o[a.XRANGEIDENTIFIERLOOSE]})(?:\\.(${o[a.XRANGEIDENTIFIERLOOSE]})(?:\\.(${o[a.XRANGEIDENTIFIERLOOSE]})(?:${o[a.PRERELEASELOOSE]})?${o[a.BUILD]}?)?)?`
    ),
    u('XRANGE', `^${o[a.GTLT]}\\s*${o[a.XRANGEPLAIN]}$`),
    u('XRANGELOOSE', `^${o[a.GTLT]}\\s*${o[a.XRANGEPLAINLOOSE]}$`),
    u('COERCE', `(^|[^\\d])(\\d{1,${n}})(?:\\.(\\d{1,${n}}))?(?:\\.(\\d{1,${n}}))?(?:$|[^\\d])`),
    u('COERCERTL', o[a.COERCE], !0),
    u('LONETILDE', '(?:~>?)'),
    u('TILDETRIM', `(\\s*)${o[a.LONETILDE]}\\s+`, !0),
    (t.tildeTrimReplace = '$1~'),
    u('TILDE', `^${o[a.LONETILDE]}${o[a.XRANGEPLAIN]}$`),
    u('TILDELOOSE', `^${o[a.LONETILDE]}${o[a.XRANGEPLAINLOOSE]}$`),
    u('LONECARET', '(?:\\^)'),
    u('CARETTRIM', `(\\s*)${o[a.LONECARET]}\\s+`, !0),
    (t.caretTrimReplace = '$1^'),
    u('CARET', `^${o[a.LONECARET]}${o[a.XRANGEPLAIN]}$`),
    u('CARETLOOSE', `^${o[a.LONECARET]}${o[a.XRANGEPLAINLOOSE]}$`),
    u('COMPARATORLOOSE', `^${o[a.GTLT]}\\s*(${o[a.LOOSEPLAIN]})$|^$`),
    u('COMPARATOR', `^${o[a.GTLT]}\\s*(${o[a.FULLPLAIN]})$|^$`),
    u('COMPARATORTRIM', `(\\s*)${o[a.GTLT]}\\s*(${o[a.LOOSEPLAIN]}|${o[a.XRANGEPLAIN]})`, !0),
    (t.comparatorTrimReplace = '$1$2$3'),
    u('HYPHENRANGE', `^\\s*(${o[a.XRANGEPLAIN]})\\s+-\\s+(${o[a.XRANGEPLAIN]})\\s*$`),
    u(
      'HYPHENRANGELOOSE',
      `^\\s*(${o[a.XRANGEPLAINLOOSE]})\\s+-\\s+(${o[a.XRANGEPLAINLOOSE]})\\s*$`
    ),
    u('STAR', '(<|>)?=?\\s*\\*'),
    u('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$'),
    u('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$');
})(QE, QE.exports);
var Lp = QE.exports;
const gke = Object.freeze({ loose: !0 }),
  yke = Object.freeze({}),
  bke = (e) => (e ? (typeof e != 'object' ? gke : e) : yke);
var $T = bke;
const SC = /^[0-9]+$/,
  bj = (e, t) => {
    const n = SC.test(e),
      r = SC.test(t);
    return (
      n && r && ((e = +e), (t = +t)), e === t ? 0 : n && !r ? -1 : r && !n ? 1 : e < t ? -1 : 1
    );
  },
  mke = (e, t) => bj(t, e);
var mj = { compareIdentifiers: bj, rcompareIdentifiers: mke };
const Bg = q1,
  { MAX_LENGTH: EC, MAX_SAFE_INTEGER: Dg } = G1,
  { safeRe: AC, t: IC } = Lp,
  wke = $T,
  { compareIdentifiers: Kc } = mj;
let vke = class is {
  constructor(t, n) {
    if (((n = wke(n)), t instanceof is)) {
      if (t.loose === !!n.loose && t.includePrerelease === !!n.includePrerelease) return t;
      t = t.version;
    } else if (typeof t != 'string')
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof t}".`);
    if (t.length > EC) throw new TypeError(`version is longer than ${EC} characters`);
    Bg('SemVer', t, n),
      (this.options = n),
      (this.loose = !!n.loose),
      (this.includePrerelease = !!n.includePrerelease);
    const r = t.trim().match(n.loose ? AC[IC.LOOSE] : AC[IC.FULL]);
    if (!r) throw new TypeError(`Invalid Version: ${t}`);
    if (
      ((this.raw = t),
      (this.major = +r[1]),
      (this.minor = +r[2]),
      (this.patch = +r[3]),
      this.major > Dg || this.major < 0)
    )
      throw new TypeError('Invalid major version');
    if (this.minor > Dg || this.minor < 0) throw new TypeError('Invalid minor version');
    if (this.patch > Dg || this.patch < 0) throw new TypeError('Invalid patch version');
    r[4]
      ? (this.prerelease = r[4].split('.').map((i) => {
          if (/^[0-9]+$/.test(i)) {
            const s = +i;
            if (s >= 0 && s < Dg) return s;
          }
          return i;
        }))
      : (this.prerelease = []),
      (this.build = r[5] ? r[5].split('.') : []),
      this.format();
  }
  format() {
    return (
      (this.version = `${this.major}.${this.minor}.${this.patch}`),
      this.prerelease.length && (this.version += `-${this.prerelease.join('.')}`),
      this.version
    );
  }
  toString() {
    return this.version;
  }
  compare(t) {
    if ((Bg('SemVer.compare', this.version, this.options, t), !(t instanceof is))) {
      if (typeof t == 'string' && t === this.version) return 0;
      t = new is(t, this.options);
    }
    return t.version === this.version ? 0 : this.compareMain(t) || this.comparePre(t);
  }
  compareMain(t) {
    return (
      t instanceof is || (t = new is(t, this.options)),
      Kc(this.major, t.major) || Kc(this.minor, t.minor) || Kc(this.patch, t.patch)
    );
  }
  comparePre(t) {
    if (
      (t instanceof is || (t = new is(t, this.options)),
      this.prerelease.length && !t.prerelease.length)
    )
      return -1;
    if (!this.prerelease.length && t.prerelease.length) return 1;
    if (!this.prerelease.length && !t.prerelease.length) return 0;
    let n = 0;
    do {
      const r = this.prerelease[n],
        i = t.prerelease[n];
      if ((Bg('prerelease compare', n, r, i), r === void 0 && i === void 0)) return 0;
      if (i === void 0) return 1;
      if (r === void 0) return -1;
      if (r === i) continue;
      return Kc(r, i);
    } while (++n);
  }
  compareBuild(t) {
    t instanceof is || (t = new is(t, this.options));
    let n = 0;
    do {
      const r = this.build[n],
        i = t.build[n];
      if ((Bg('prerelease compare', n, r, i), r === void 0 && i === void 0)) return 0;
      if (i === void 0) return 1;
      if (r === void 0) return -1;
      if (r === i) continue;
      return Kc(r, i);
    } while (++n);
  }
  inc(t, n, r) {
    switch (t) {
      case 'premajor':
        (this.prerelease.length = 0),
          (this.patch = 0),
          (this.minor = 0),
          this.major++,
          this.inc('pre', n, r);
        break;
      case 'preminor':
        (this.prerelease.length = 0), (this.patch = 0), this.minor++, this.inc('pre', n, r);
        break;
      case 'prepatch':
        (this.prerelease.length = 0), this.inc('patch', n, r), this.inc('pre', n, r);
        break;
      case 'prerelease':
        this.prerelease.length === 0 && this.inc('patch', n, r), this.inc('pre', n, r);
        break;
      case 'major':
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++,
          (this.minor = 0),
          (this.patch = 0),
          (this.prerelease = []);
        break;
      case 'minor':
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++,
          (this.patch = 0),
          (this.prerelease = []);
        break;
      case 'patch':
        this.prerelease.length === 0 && this.patch++, (this.prerelease = []);
        break;
      case 'pre': {
        const i = Number(r) ? 1 : 0;
        if (!n && r === !1) throw new Error('invalid increment argument: identifier is empty');
        if (this.prerelease.length === 0) this.prerelease = [i];
        else {
          let s = this.prerelease.length;
          for (; --s >= 0; )
            typeof this.prerelease[s] == 'number' && (this.prerelease[s]++, (s = -2));
          if (s === -1) {
            if (n === this.prerelease.join('.') && r === !1)
              throw new Error('invalid increment argument: identifier already exists');
            this.prerelease.push(i);
          }
        }
        if (n) {
          let s = [n, i];
          r === !1 && (s = [n]),
            Kc(this.prerelease[0], n) === 0
              ? isNaN(this.prerelease[1]) && (this.prerelease = s)
              : (this.prerelease = s);
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${t}`);
    }
    return (
      (this.raw = this.format()),
      this.build.length && (this.raw += `+${this.build.join('.')}`),
      this
    );
  }
};
var Sr = vke;
const TC = Sr,
  _ke = (e, t, n = !1) => {
    if (e instanceof TC) return e;
    try {
      return new TC(e, t);
    } catch (r) {
      if (!n) return null;
      throw r;
    }
  };
var dl = _ke;
const Ske = dl,
  Eke = (e, t) => {
    const n = Ske(e, t);
    return n ? n.version : null;
  };
var Ake = Eke;
const Ike = dl,
  Tke = (e, t) => {
    const n = Ike(e.trim().replace(/^[=v]+/, ''), t);
    return n ? n.version : null;
  };
var xke = Tke;
const xC = Sr,
  kke = (e, t, n, r, i) => {
    typeof n == 'string' && ((i = r), (r = n), (n = void 0));
    try {
      return new xC(e instanceof xC ? e.version : e, n).inc(t, r, i).version;
    } catch {
      return null;
    }
  };
var Cke = kke;
const kC = dl,
  Pke = (e, t) => {
    const n = kC(e, null, !0),
      r = kC(t, null, !0),
      i = n.compare(r);
    if (i === 0) return null;
    const s = i > 0,
      o = s ? n : r,
      a = s ? r : n,
      c = !!o.prerelease.length;
    if (!!a.prerelease.length && !c)
      return !a.patch && !a.minor ? 'major' : o.patch ? 'patch' : o.minor ? 'minor' : 'major';
    const l = c ? 'pre' : '';
    return n.major !== r.major
      ? l + 'major'
      : n.minor !== r.minor
        ? l + 'minor'
        : n.patch !== r.patch
          ? l + 'patch'
          : 'prerelease';
  };
var Mke = Pke;
const Oke = Sr,
  Bke = (e, t) => new Oke(e, t).major;
var Dke = Bke;
const Rke = Sr,
  Nke = (e, t) => new Rke(e, t).minor;
var jke = Nke;
const Lke = Sr,
  Uke = (e, t) => new Lke(e, t).patch;
var $ke = Uke;
const Fke = dl,
  zke = (e, t) => {
    const n = Fke(e, t);
    return n && n.prerelease.length ? n.prerelease : null;
  };
var Kke = zke;
const CC = Sr,
  Vke = (e, t, n) => new CC(e, n).compare(new CC(t, n));
var Gi = Vke;
const Wke = Gi,
  Hke = (e, t, n) => Wke(t, e, n);
var Gke = Hke;
const qke = Gi,
  Yke = (e, t) => qke(e, t, !0);
var Zke = Yke;
const PC = Sr,
  Jke = (e, t, n) => {
    const r = new PC(e, n),
      i = new PC(t, n);
    return r.compare(i) || r.compareBuild(i);
  };
var FT = Jke;
const Xke = FT,
  Qke = (e, t) => e.sort((n, r) => Xke(n, r, t));
var e2e = Qke;
const t2e = FT,
  n2e = (e, t) => e.sort((n, r) => t2e(r, n, t));
var r2e = n2e;
const i2e = Gi,
  s2e = (e, t, n) => i2e(e, t, n) > 0;
var Y1 = s2e;
const o2e = Gi,
  a2e = (e, t, n) => o2e(e, t, n) < 0;
var zT = a2e;
const c2e = Gi,
  u2e = (e, t, n) => c2e(e, t, n) === 0;
var wj = u2e;
const l2e = Gi,
  d2e = (e, t, n) => l2e(e, t, n) !== 0;
var vj = d2e;
const f2e = Gi,
  h2e = (e, t, n) => f2e(e, t, n) >= 0;
var KT = h2e;
const p2e = Gi,
  g2e = (e, t, n) => p2e(e, t, n) <= 0;
var VT = g2e;
const y2e = wj,
  b2e = vj,
  m2e = Y1,
  w2e = KT,
  v2e = zT,
  _2e = VT,
  S2e = (e, t, n, r) => {
    switch (t) {
      case '===':
        return (
          typeof e == 'object' && (e = e.version), typeof n == 'object' && (n = n.version), e === n
        );
      case '!==':
        return (
          typeof e == 'object' && (e = e.version), typeof n == 'object' && (n = n.version), e !== n
        );
      case '':
      case '=':
      case '==':
        return y2e(e, n, r);
      case '!=':
        return b2e(e, n, r);
      case '>':
        return m2e(e, n, r);
      case '>=':
        return w2e(e, n, r);
      case '<':
        return v2e(e, n, r);
      case '<=':
        return _2e(e, n, r);
      default:
        throw new TypeError(`Invalid operator: ${t}`);
    }
  };
var _j = S2e;
const E2e = Sr,
  A2e = dl,
  { safeRe: Rg, t: Ng } = Lp,
  I2e = (e, t) => {
    if (e instanceof E2e) return e;
    if ((typeof e == 'number' && (e = String(e)), typeof e != 'string')) return null;
    t = t || {};
    let n = null;
    if (!t.rtl) n = e.match(Rg[Ng.COERCE]);
    else {
      let r;
      for (; (r = Rg[Ng.COERCERTL].exec(e)) && (!n || n.index + n[0].length !== e.length); )
        (!n || r.index + r[0].length !== n.index + n[0].length) && (n = r),
          (Rg[Ng.COERCERTL].lastIndex = r.index + r[1].length + r[2].length);
      Rg[Ng.COERCERTL].lastIndex = -1;
    }
    return n === null ? null : A2e(`${n[2]}.${n[3] || '0'}.${n[4] || '0'}`, t);
  };
var T2e = I2e,
  G_,
  MC;
function x2e() {
  return (
    MC ||
      ((MC = 1),
      (G_ = function (e) {
        e.prototype[Symbol.iterator] = function* () {
          for (let t = this.head; t; t = t.next) yield t.value;
        };
      })),
    G_
  );
}
var k2e = Tt;
Tt.Node = vc;
Tt.create = Tt;
function Tt(e) {
  var t = this;
  if (
    (t instanceof Tt || (t = new Tt()),
    (t.tail = null),
    (t.head = null),
    (t.length = 0),
    e && typeof e.forEach == 'function')
  )
    e.forEach(function (i) {
      t.push(i);
    });
  else if (arguments.length > 0)
    for (var n = 0, r = arguments.length; n < r; n++) t.push(arguments[n]);
  return t;
}
Tt.prototype.removeNode = function (e) {
  if (e.list !== this) throw new Error('removing node which does not belong to this list');
  var t = e.next,
    n = e.prev;
  return (
    t && (t.prev = n),
    n && (n.next = t),
    e === this.head && (this.head = t),
    e === this.tail && (this.tail = n),
    e.list.length--,
    (e.next = null),
    (e.prev = null),
    (e.list = null),
    t
  );
};
Tt.prototype.unshiftNode = function (e) {
  if (e !== this.head) {
    e.list && e.list.removeNode(e);
    var t = this.head;
    (e.list = this),
      (e.next = t),
      t && (t.prev = e),
      (this.head = e),
      this.tail || (this.tail = e),
      this.length++;
  }
};
Tt.prototype.pushNode = function (e) {
  if (e !== this.tail) {
    e.list && e.list.removeNode(e);
    var t = this.tail;
    (e.list = this),
      (e.prev = t),
      t && (t.next = e),
      (this.tail = e),
      this.head || (this.head = e),
      this.length++;
  }
};
Tt.prototype.push = function () {
  for (var e = 0, t = arguments.length; e < t; e++) P2e(this, arguments[e]);
  return this.length;
};
Tt.prototype.unshift = function () {
  for (var e = 0, t = arguments.length; e < t; e++) M2e(this, arguments[e]);
  return this.length;
};
Tt.prototype.pop = function () {
  if (this.tail) {
    var e = this.tail.value;
    return (
      (this.tail = this.tail.prev),
      this.tail ? (this.tail.next = null) : (this.head = null),
      this.length--,
      e
    );
  }
};
Tt.prototype.shift = function () {
  if (this.head) {
    var e = this.head.value;
    return (
      (this.head = this.head.next),
      this.head ? (this.head.prev = null) : (this.tail = null),
      this.length--,
      e
    );
  }
};
Tt.prototype.forEach = function (e, t) {
  t = t || this;
  for (var n = this.head, r = 0; n !== null; r++) e.call(t, n.value, r, this), (n = n.next);
};
Tt.prototype.forEachReverse = function (e, t) {
  t = t || this;
  for (var n = this.tail, r = this.length - 1; n !== null; r--)
    e.call(t, n.value, r, this), (n = n.prev);
};
Tt.prototype.get = function (e) {
  for (var t = 0, n = this.head; n !== null && t < e; t++) n = n.next;
  if (t === e && n !== null) return n.value;
};
Tt.prototype.getReverse = function (e) {
  for (var t = 0, n = this.tail; n !== null && t < e; t++) n = n.prev;
  if (t === e && n !== null) return n.value;
};
Tt.prototype.map = function (e, t) {
  t = t || this;
  for (var n = new Tt(), r = this.head; r !== null; )
    n.push(e.call(t, r.value, this)), (r = r.next);
  return n;
};
Tt.prototype.mapReverse = function (e, t) {
  t = t || this;
  for (var n = new Tt(), r = this.tail; r !== null; )
    n.push(e.call(t, r.value, this)), (r = r.prev);
  return n;
};
Tt.prototype.reduce = function (e, t) {
  var n,
    r = this.head;
  if (arguments.length > 1) n = t;
  else if (this.head) (r = this.head.next), (n = this.head.value);
  else throw new TypeError('Reduce of empty list with no initial value');
  for (var i = 0; r !== null; i++) (n = e(n, r.value, i)), (r = r.next);
  return n;
};
Tt.prototype.reduceReverse = function (e, t) {
  var n,
    r = this.tail;
  if (arguments.length > 1) n = t;
  else if (this.tail) (r = this.tail.prev), (n = this.tail.value);
  else throw new TypeError('Reduce of empty list with no initial value');
  for (var i = this.length - 1; r !== null; i--) (n = e(n, r.value, i)), (r = r.prev);
  return n;
};
Tt.prototype.toArray = function () {
  for (var e = new Array(this.length), t = 0, n = this.head; n !== null; t++)
    (e[t] = n.value), (n = n.next);
  return e;
};
Tt.prototype.toArrayReverse = function () {
  for (var e = new Array(this.length), t = 0, n = this.tail; n !== null; t++)
    (e[t] = n.value), (n = n.prev);
  return e;
};
Tt.prototype.slice = function (e, t) {
  (t = t || this.length), t < 0 && (t += this.length), (e = e || 0), e < 0 && (e += this.length);
  var n = new Tt();
  if (t < e || t < 0) return n;
  e < 0 && (e = 0), t > this.length && (t = this.length);
  for (var r = 0, i = this.head; i !== null && r < e; r++) i = i.next;
  for (; i !== null && r < t; r++, i = i.next) n.push(i.value);
  return n;
};
Tt.prototype.sliceReverse = function (e, t) {
  (t = t || this.length), t < 0 && (t += this.length), (e = e || 0), e < 0 && (e += this.length);
  var n = new Tt();
  if (t < e || t < 0) return n;
  e < 0 && (e = 0), t > this.length && (t = this.length);
  for (var r = this.length, i = this.tail; i !== null && r > t; r--) i = i.prev;
  for (; i !== null && r > e; r--, i = i.prev) n.push(i.value);
  return n;
};
Tt.prototype.splice = function (e, t, ...n) {
  e > this.length && (e = this.length - 1), e < 0 && (e = this.length + e);
  for (var r = 0, i = this.head; i !== null && r < e; r++) i = i.next;
  for (var s = [], r = 0; i && r < t; r++) s.push(i.value), (i = this.removeNode(i));
  i === null && (i = this.tail), i !== this.head && i !== this.tail && (i = i.prev);
  for (var r = 0; r < n.length; r++) i = C2e(this, i, n[r]);
  return s;
};
Tt.prototype.reverse = function () {
  for (var e = this.head, t = this.tail, n = e; n !== null; n = n.prev) {
    var r = n.prev;
    (n.prev = n.next), (n.next = r);
  }
  return (this.head = t), (this.tail = e), this;
};
function C2e(e, t, n) {
  var r = t === e.head ? new vc(n, null, t, e) : new vc(n, t, t.next, e);
  return r.next === null && (e.tail = r), r.prev === null && (e.head = r), e.length++, r;
}
function P2e(e, t) {
  (e.tail = new vc(t, e.tail, null, e)), e.head || (e.head = e.tail), e.length++;
}
function M2e(e, t) {
  (e.head = new vc(t, null, e.head, e)), e.tail || (e.tail = e.head), e.length++;
}
function vc(e, t, n, r) {
  if (!(this instanceof vc)) return new vc(e, t, n, r);
  (this.list = r),
    (this.value = e),
    t ? ((t.next = this), (this.prev = t)) : (this.prev = null),
    n ? ((n.prev = this), (this.next = n)) : (this.next = null);
}
try {
  x2e()(Tt);
} catch {}
const O2e = k2e,
  La = Symbol('max'),
  zs = Symbol('length'),
  Vc = Symbol('lengthCalculator'),
  ql = Symbol('allowStale'),
  Ka = Symbol('maxAge'),
  Us = Symbol('dispose'),
  OC = Symbol('noDisposeOnSet'),
  $n = Symbol('lruList'),
  Si = Symbol('cache'),
  Sj = Symbol('updateAgeOnGet'),
  q_ = () => 1;
class B2e {
  constructor(t) {
    if (
      (typeof t == 'number' && (t = { max: t }),
      t || (t = {}),
      t.max && (typeof t.max != 'number' || t.max < 0))
    )
      throw new TypeError('max must be a non-negative number');
    this[La] = t.max || 1 / 0;
    const n = t.length || q_;
    if (
      ((this[Vc] = typeof n != 'function' ? q_ : n),
      (this[ql] = t.stale || !1),
      t.maxAge && typeof t.maxAge != 'number')
    )
      throw new TypeError('maxAge must be a number');
    (this[Ka] = t.maxAge || 0),
      (this[Us] = t.dispose),
      (this[OC] = t.noDisposeOnSet || !1),
      (this[Sj] = t.updateAgeOnGet || !1),
      this.reset();
  }
  set max(t) {
    if (typeof t != 'number' || t < 0) throw new TypeError('max must be a non-negative number');
    (this[La] = t || 1 / 0), Cl(this);
  }
  get max() {
    return this[La];
  }
  set allowStale(t) {
    this[ql] = !!t;
  }
  get allowStale() {
    return this[ql];
  }
  set maxAge(t) {
    if (typeof t != 'number') throw new TypeError('maxAge must be a non-negative number');
    (this[Ka] = t), Cl(this);
  }
  get maxAge() {
    return this[Ka];
  }
  set lengthCalculator(t) {
    typeof t != 'function' && (t = q_),
      t !== this[Vc] &&
        ((this[Vc] = t),
        (this[zs] = 0),
        this[$n].forEach((n) => {
          (n.length = this[Vc](n.value, n.key)), (this[zs] += n.length);
        })),
      Cl(this);
  }
  get lengthCalculator() {
    return this[Vc];
  }
  get length() {
    return this[zs];
  }
  get itemCount() {
    return this[$n].length;
  }
  rforEach(t, n) {
    n = n || this;
    for (let r = this[$n].tail; r !== null; ) {
      const i = r.prev;
      BC(this, t, r, n), (r = i);
    }
  }
  forEach(t, n) {
    n = n || this;
    for (let r = this[$n].head; r !== null; ) {
      const i = r.next;
      BC(this, t, r, n), (r = i);
    }
  }
  keys() {
    return this[$n].toArray().map((t) => t.key);
  }
  values() {
    return this[$n].toArray().map((t) => t.value);
  }
  reset() {
    this[Us] && this[$n] && this[$n].length && this[$n].forEach((t) => this[Us](t.key, t.value)),
      (this[Si] = new Map()),
      (this[$n] = new O2e()),
      (this[zs] = 0);
  }
  dump() {
    return this[$n]
      .map((t) => (lb(this, t) ? !1 : { k: t.key, v: t.value, e: t.now + (t.maxAge || 0) }))
      .toArray()
      .filter((t) => t);
  }
  dumpLru() {
    return this[$n];
  }
  set(t, n, r) {
    if (((r = r || this[Ka]), r && typeof r != 'number'))
      throw new TypeError('maxAge must be a number');
    const i = r ? Date.now() : 0,
      s = this[Vc](n, t);
    if (this[Si].has(t)) {
      if (s > this[La]) return au(this, this[Si].get(t)), !1;
      const c = this[Si].get(t).value;
      return (
        this[Us] && (this[OC] || this[Us](t, c.value)),
        (c.now = i),
        (c.maxAge = r),
        (c.value = n),
        (this[zs] += s - c.length),
        (c.length = s),
        this.get(t),
        Cl(this),
        !0
      );
    }
    const o = new D2e(t, n, s, i, r);
    return o.length > this[La]
      ? (this[Us] && this[Us](t, n), !1)
      : ((this[zs] += o.length), this[$n].unshift(o), this[Si].set(t, this[$n].head), Cl(this), !0);
  }
  has(t) {
    if (!this[Si].has(t)) return !1;
    const n = this[Si].get(t).value;
    return !lb(this, n);
  }
  get(t) {
    return Y_(this, t, !0);
  }
  peek(t) {
    return Y_(this, t, !1);
  }
  pop() {
    const t = this[$n].tail;
    return t ? (au(this, t), t.value) : null;
  }
  del(t) {
    au(this, this[Si].get(t));
  }
  load(t) {
    this.reset();
    const n = Date.now();
    for (let r = t.length - 1; r >= 0; r--) {
      const i = t[r],
        s = i.e || 0;
      if (s === 0) this.set(i.k, i.v);
      else {
        const o = s - n;
        o > 0 && this.set(i.k, i.v, o);
      }
    }
  }
  prune() {
    this[Si].forEach((t, n) => Y_(this, n, !1));
  }
}
const Y_ = (e, t, n) => {
    const r = e[Si].get(t);
    if (r) {
      const i = r.value;
      if (lb(e, i)) {
        if ((au(e, r), !e[ql])) return;
      } else n && (e[Sj] && (r.value.now = Date.now()), e[$n].unshiftNode(r));
      return i.value;
    }
  },
  lb = (e, t) => {
    if (!t || (!t.maxAge && !e[Ka])) return !1;
    const n = Date.now() - t.now;
    return t.maxAge ? n > t.maxAge : e[Ka] && n > e[Ka];
  },
  Cl = (e) => {
    if (e[zs] > e[La])
      for (let t = e[$n].tail; e[zs] > e[La] && t !== null; ) {
        const n = t.prev;
        au(e, t), (t = n);
      }
  },
  au = (e, t) => {
    if (t) {
      const n = t.value;
      e[Us] && e[Us](n.key, n.value), (e[zs] -= n.length), e[Si].delete(n.key), e[$n].removeNode(t);
    }
  };
class D2e {
  constructor(t, n, r, i, s) {
    (this.key = t), (this.value = n), (this.length = r), (this.now = i), (this.maxAge = s || 0);
  }
}
const BC = (e, t, n, r) => {
  let i = n.value;
  lb(e, i) && (au(e, n), e[ql] || (i = void 0)), i && t.call(r, i.value, i.key, e);
};
var R2e = B2e,
  Z_,
  DC;
function qi() {
  if (DC) return Z_;
  DC = 1;
  class e {
    constructor(S, T) {
      if (((T = r(T)), S instanceof e))
        return S.loose === !!T.loose && S.includePrerelease === !!T.includePrerelease
          ? S
          : new e(S.raw, T);
      if (S instanceof i) return (this.raw = S.value), (this.set = [[S]]), this.format(), this;
      if (
        ((this.options = T),
        (this.loose = !!T.loose),
        (this.includePrerelease = !!T.includePrerelease),
        (this.raw = S.trim().split(/\s+/).join(' ')),
        (this.set = this.raw
          .split('||')
          .map((M) => this.parseRange(M))
          .filter((M) => M.length)),
        !this.set.length)
      )
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const M = this.set[0];
        if (((this.set = this.set.filter((R) => !p(R[0]))), this.set.length === 0)) this.set = [M];
        else if (this.set.length > 1) {
          for (const R of this.set)
            if (R.length === 1 && b(R[0])) {
              this.set = [R];
              break;
            }
        }
      }
      this.format();
    }
    format() {
      return (
        (this.range = this.set
          .map((S) => S.join(' ').trim())
          .join('||')
          .trim()),
        this.range
      );
    }
    toString() {
      return this.range;
    }
    parseRange(S) {
      const M = ((this.options.includePrerelease && f) | (this.options.loose && h)) + ':' + S,
        R = n.get(M);
      if (R) return R;
      const L = this.options.loose,
        O = L ? a[c.HYPHENRANGELOOSE] : a[c.HYPHENRANGE];
      (S = S.replace(O, E(this.options.includePrerelease))),
        s('hyphen replace', S),
        (S = S.replace(a[c.COMPARATORTRIM], u)),
        s('comparator trim', S),
        (S = S.replace(a[c.TILDETRIM], l)),
        (S = S.replace(a[c.CARETTRIM], d));
      let I = S.split(' ')
        .map((J) => A(J, this.options))
        .join(' ')
        .split(/\s+/)
        .map((J) => B(J, this.options));
      L &&
        (I = I.filter(
          (J) => (s('loose invalid filter', J, this.options), !!J.match(a[c.COMPARATORLOOSE]))
        )),
        s('range list', I);
      const U = new Map(),
        H = I.map((J) => new i(J, this.options));
      for (const J of H) {
        if (p(J)) return [J];
        U.set(J.value, J);
      }
      U.size > 1 && U.has('') && U.delete('');
      const X = [...U.values()];
      return n.set(M, X), X;
    }
    intersects(S, T) {
      if (!(S instanceof e)) throw new TypeError('a Range is required');
      return this.set.some(
        (M) =>
          w(M, T) &&
          S.set.some((R) => w(R, T) && M.every((L) => R.every((O) => L.intersects(O, T))))
      );
    }
    test(S) {
      if (!S) return !1;
      if (typeof S == 'string')
        try {
          S = new o(S, this.options);
        } catch {
          return !1;
        }
      for (let T = 0; T < this.set.length; T++) if (y(this.set[T], S, this.options)) return !0;
      return !1;
    }
  }
  Z_ = e;
  const t = R2e,
    n = new t({ max: 1e3 }),
    r = $T,
    i = Z1(),
    s = q1,
    o = Sr,
    { safeRe: a, t: c, comparatorTrimReplace: u, tildeTrimReplace: l, caretTrimReplace: d } = Lp,
    { FLAG_INCLUDE_PRERELEASE: f, FLAG_LOOSE: h } = G1,
    p = (v) => v.value === '<0.0.0-0',
    b = (v) => v.value === '',
    w = (v, S) => {
      let T = !0;
      const M = v.slice();
      let R = M.pop();
      for (; T && M.length; ) (T = M.every((L) => R.intersects(L, S))), (R = M.pop());
      return T;
    },
    A = (v, S) => (
      s('comp', v, S),
      (v = j(v, S)),
      s('caret', v),
      (v = x(v, S)),
      s('tildes', v),
      (v = K(v, S)),
      s('xrange', v),
      (v = C(v, S)),
      s('stars', v),
      v
    ),
    _ = (v) => !v || v.toLowerCase() === 'x' || v === '*',
    x = (v, S) =>
      v
        .trim()
        .split(/\s+/)
        .map((T) => k(T, S))
        .join(' '),
    k = (v, S) => {
      const T = S.loose ? a[c.TILDELOOSE] : a[c.TILDE];
      return v.replace(T, (M, R, L, O, I) => {
        s('tilde', v, M, R, L, O, I);
        let U;
        return (
          _(R)
            ? (U = '')
            : _(L)
              ? (U = `>=${R}.0.0 <${+R + 1}.0.0-0`)
              : _(O)
                ? (U = `>=${R}.${L}.0 <${R}.${+L + 1}.0-0`)
                : I
                  ? (s('replaceTilde pr', I), (U = `>=${R}.${L}.${O}-${I} <${R}.${+L + 1}.0-0`))
                  : (U = `>=${R}.${L}.${O} <${R}.${+L + 1}.0-0`),
          s('tilde return', U),
          U
        );
      });
    },
    j = (v, S) =>
      v
        .trim()
        .split(/\s+/)
        .map((T) => F(T, S))
        .join(' '),
    F = (v, S) => {
      s('caret', v, S);
      const T = S.loose ? a[c.CARETLOOSE] : a[c.CARET],
        M = S.includePrerelease ? '-0' : '';
      return v.replace(T, (R, L, O, I, U) => {
        s('caret', v, R, L, O, I, U);
        let H;
        return (
          _(L)
            ? (H = '')
            : _(O)
              ? (H = `>=${L}.0.0${M} <${+L + 1}.0.0-0`)
              : _(I)
                ? L === '0'
                  ? (H = `>=${L}.${O}.0${M} <${L}.${+O + 1}.0-0`)
                  : (H = `>=${L}.${O}.0${M} <${+L + 1}.0.0-0`)
                : U
                  ? (s('replaceCaret pr', U),
                    L === '0'
                      ? O === '0'
                        ? (H = `>=${L}.${O}.${I}-${U} <${L}.${O}.${+I + 1}-0`)
                        : (H = `>=${L}.${O}.${I}-${U} <${L}.${+O + 1}.0-0`)
                      : (H = `>=${L}.${O}.${I}-${U} <${+L + 1}.0.0-0`))
                  : (s('no pr'),
                    L === '0'
                      ? O === '0'
                        ? (H = `>=${L}.${O}.${I}${M} <${L}.${O}.${+I + 1}-0`)
                        : (H = `>=${L}.${O}.${I}${M} <${L}.${+O + 1}.0-0`)
                      : (H = `>=${L}.${O}.${I} <${+L + 1}.0.0-0`)),
          s('caret return', H),
          H
        );
      });
    },
    K = (v, S) => (
      s('replaceXRanges', v, S),
      v
        .split(/\s+/)
        .map((T) => D(T, S))
        .join(' ')
    ),
    D = (v, S) => {
      v = v.trim();
      const T = S.loose ? a[c.XRANGELOOSE] : a[c.XRANGE];
      return v.replace(T, (M, R, L, O, I, U) => {
        s('xRange', v, M, R, L, O, I, U);
        const H = _(L),
          X = H || _(O),
          J = X || _(I),
          ie = J;
        return (
          R === '=' && ie && (R = ''),
          (U = S.includePrerelease ? '-0' : ''),
          H
            ? R === '>' || R === '<'
              ? (M = '<0.0.0-0')
              : (M = '*')
            : R && ie
              ? (X && (O = 0),
                (I = 0),
                R === '>'
                  ? ((R = '>='), X ? ((L = +L + 1), (O = 0), (I = 0)) : ((O = +O + 1), (I = 0)))
                  : R === '<=' && ((R = '<'), X ? (L = +L + 1) : (O = +O + 1)),
                R === '<' && (U = '-0'),
                (M = `${R + L}.${O}.${I}${U}`))
              : X
                ? (M = `>=${L}.0.0${U} <${+L + 1}.0.0-0`)
                : J && (M = `>=${L}.${O}.0${U} <${L}.${+O + 1}.0-0`),
          s('xRange return', M),
          M
        );
      });
    },
    C = (v, S) => (s('replaceStars', v, S), v.trim().replace(a[c.STAR], '')),
    B = (v, S) => (
      s('replaceGTE0', v, S), v.trim().replace(a[S.includePrerelease ? c.GTE0PRE : c.GTE0], '')
    ),
    E = (v) => (S, T, M, R, L, O, I, U, H, X, J, ie, Z) => (
      _(M)
        ? (T = '')
        : _(R)
          ? (T = `>=${M}.0.0${v ? '-0' : ''}`)
          : _(L)
            ? (T = `>=${M}.${R}.0${v ? '-0' : ''}`)
            : O
              ? (T = `>=${T}`)
              : (T = `>=${T}${v ? '-0' : ''}`),
      _(H)
        ? (U = '')
        : _(X)
          ? (U = `<${+H + 1}.0.0-0`)
          : _(J)
            ? (U = `<${H}.${+X + 1}.0-0`)
            : ie
              ? (U = `<=${H}.${X}.${J}-${ie}`)
              : v
                ? (U = `<${H}.${X}.${+J + 1}-0`)
                : (U = `<=${U}`),
      `${T} ${U}`.trim()
    ),
    y = (v, S, T) => {
      for (let M = 0; M < v.length; M++) if (!v[M].test(S)) return !1;
      if (S.prerelease.length && !T.includePrerelease) {
        for (let M = 0; M < v.length; M++)
          if ((s(v[M].semver), v[M].semver !== i.ANY && v[M].semver.prerelease.length > 0)) {
            const R = v[M].semver;
            if (R.major === S.major && R.minor === S.minor && R.patch === S.patch) return !0;
          }
        return !1;
      }
      return !0;
    };
  return Z_;
}
var J_, RC;
function Z1() {
  if (RC) return J_;
  RC = 1;
  const e = Symbol('SemVer ANY');
  class t {
    static get ANY() {
      return e;
    }
    constructor(l, d) {
      if (((d = n(d)), l instanceof t)) {
        if (l.loose === !!d.loose) return l;
        l = l.value;
      }
      (l = l.trim().split(/\s+/).join(' ')),
        o('comparator', l, d),
        (this.options = d),
        (this.loose = !!d.loose),
        this.parse(l),
        this.semver === e ? (this.value = '') : (this.value = this.operator + this.semver.version),
        o('comp', this);
    }
    parse(l) {
      const d = this.options.loose ? r[i.COMPARATORLOOSE] : r[i.COMPARATOR],
        f = l.match(d);
      if (!f) throw new TypeError(`Invalid comparator: ${l}`);
      (this.operator = f[1] !== void 0 ? f[1] : ''),
        this.operator === '=' && (this.operator = ''),
        f[2] ? (this.semver = new a(f[2], this.options.loose)) : (this.semver = e);
    }
    toString() {
      return this.value;
    }
    test(l) {
      if ((o('Comparator.test', l, this.options.loose), this.semver === e || l === e)) return !0;
      if (typeof l == 'string')
        try {
          l = new a(l, this.options);
        } catch {
          return !1;
        }
      return s(l, this.operator, this.semver, this.options);
    }
    intersects(l, d) {
      if (!(l instanceof t)) throw new TypeError('a Comparator is required');
      return this.operator === ''
        ? this.value === ''
          ? !0
          : new c(l.value, d).test(this.value)
        : l.operator === ''
          ? l.value === ''
            ? !0
            : new c(this.value, d).test(l.semver)
          : ((d = n(d)),
            (d.includePrerelease && (this.value === '<0.0.0-0' || l.value === '<0.0.0-0')) ||
            (!d.includePrerelease &&
              (this.value.startsWith('<0.0.0') || l.value.startsWith('<0.0.0')))
              ? !1
              : !!(
                  (this.operator.startsWith('>') && l.operator.startsWith('>')) ||
                  (this.operator.startsWith('<') && l.operator.startsWith('<')) ||
                  (this.semver.version === l.semver.version &&
                    this.operator.includes('=') &&
                    l.operator.includes('=')) ||
                  (s(this.semver, '<', l.semver, d) &&
                    this.operator.startsWith('>') &&
                    l.operator.startsWith('<')) ||
                  (s(this.semver, '>', l.semver, d) &&
                    this.operator.startsWith('<') &&
                    l.operator.startsWith('>'))
                ));
    }
  }
  J_ = t;
  const n = $T,
    { safeRe: r, t: i } = Lp,
    s = _j,
    o = q1,
    a = Sr,
    c = qi();
  return J_;
}
const N2e = qi(),
  j2e = (e, t, n) => {
    try {
      t = new N2e(t, n);
    } catch {
      return !1;
    }
    return t.test(e);
  };
var J1 = j2e;
const L2e = qi(),
  U2e = (e, t) =>
    new L2e(e, t).set.map((n) =>
      n
        .map((r) => r.value)
        .join(' ')
        .trim()
        .split(' ')
    );
var $2e = U2e;
const F2e = Sr,
  z2e = qi(),
  K2e = (e, t, n) => {
    let r = null,
      i = null,
      s = null;
    try {
      s = new z2e(t, n);
    } catch {
      return null;
    }
    return (
      e.forEach((o) => {
        s.test(o) && (!r || i.compare(o) === -1) && ((r = o), (i = new F2e(r, n)));
      }),
      r
    );
  };
var V2e = K2e;
const W2e = Sr,
  H2e = qi(),
  G2e = (e, t, n) => {
    let r = null,
      i = null,
      s = null;
    try {
      s = new H2e(t, n);
    } catch {
      return null;
    }
    return (
      e.forEach((o) => {
        s.test(o) && (!r || i.compare(o) === 1) && ((r = o), (i = new W2e(r, n)));
      }),
      r
    );
  };
var q2e = G2e;
const X_ = Sr,
  Y2e = qi(),
  NC = Y1,
  Z2e = (e, t) => {
    e = new Y2e(e, t);
    let n = new X_('0.0.0');
    if (e.test(n) || ((n = new X_('0.0.0-0')), e.test(n))) return n;
    n = null;
    for (let r = 0; r < e.set.length; ++r) {
      const i = e.set[r];
      let s = null;
      i.forEach((o) => {
        const a = new X_(o.semver.version);
        switch (o.operator) {
          case '>':
            a.prerelease.length === 0 ? a.patch++ : a.prerelease.push(0), (a.raw = a.format());
          case '':
          case '>=':
            (!s || NC(a, s)) && (s = a);
            break;
          case '<':
          case '<=':
            break;
          default:
            throw new Error(`Unexpected operation: ${o.operator}`);
        }
      }),
        s && (!n || NC(n, s)) && (n = s);
    }
    return n && e.test(n) ? n : null;
  };
var J2e = Z2e;
const X2e = qi(),
  Q2e = (e, t) => {
    try {
      return new X2e(e, t).range || '*';
    } catch {
      return null;
    }
  };
var e3e = Q2e;
const t3e = Sr,
  Ej = Z1(),
  { ANY: n3e } = Ej,
  r3e = qi(),
  i3e = J1,
  jC = Y1,
  LC = zT,
  s3e = VT,
  o3e = KT,
  a3e = (e, t, n, r) => {
    (e = new t3e(e, r)), (t = new r3e(t, r));
    let i, s, o, a, c;
    switch (n) {
      case '>':
        (i = jC), (s = s3e), (o = LC), (a = '>'), (c = '>=');
        break;
      case '<':
        (i = LC), (s = o3e), (o = jC), (a = '<'), (c = '<=');
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (i3e(e, t, r)) return !1;
    for (let u = 0; u < t.set.length; ++u) {
      const l = t.set[u];
      let d = null,
        f = null;
      if (
        (l.forEach((h) => {
          h.semver === n3e && (h = new Ej('>=0.0.0')),
            (d = d || h),
            (f = f || h),
            i(h.semver, d.semver, r) ? (d = h) : o(h.semver, f.semver, r) && (f = h);
        }),
        d.operator === a ||
          d.operator === c ||
          ((!f.operator || f.operator === a) && s(e, f.semver)))
      )
        return !1;
      if (f.operator === c && o(e, f.semver)) return !1;
    }
    return !0;
  };
var WT = a3e;
const c3e = WT,
  u3e = (e, t, n) => c3e(e, t, '>', n);
var l3e = u3e;
const d3e = WT,
  f3e = (e, t, n) => d3e(e, t, '<', n);
var h3e = f3e;
const UC = qi(),
  p3e = (e, t, n) => ((e = new UC(e, n)), (t = new UC(t, n)), e.intersects(t, n));
var g3e = p3e;
const y3e = J1,
  b3e = Gi;
var m3e = (e, t, n) => {
  const r = [];
  let i = null,
    s = null;
  const o = e.sort((l, d) => b3e(l, d, n));
  for (const l of o)
    y3e(l, t, n) ? ((s = l), i || (i = l)) : (s && r.push([i, s]), (s = null), (i = null));
  i && r.push([i, null]);
  const a = [];
  for (const [l, d] of r)
    l === d
      ? a.push(l)
      : !d && l === o[0]
        ? a.push('*')
        : d
          ? l === o[0]
            ? a.push(`<=${d}`)
            : a.push(`${l} - ${d}`)
          : a.push(`>=${l}`);
  const c = a.join(' || '),
    u = typeof t.raw == 'string' ? t.raw : String(t);
  return c.length < u.length ? c : t;
};
const $C = qi(),
  HT = Z1(),
  { ANY: Q_ } = HT,
  Pl = J1,
  GT = Gi,
  w3e = (e, t, n = {}) => {
    if (e === t) return !0;
    (e = new $C(e, n)), (t = new $C(t, n));
    let r = !1;
    e: for (const i of e.set) {
      for (const s of t.set) {
        const o = _3e(i, s, n);
        if (((r = r || o !== null), o)) continue e;
      }
      if (r) return !1;
    }
    return !0;
  },
  v3e = [new HT('>=0.0.0-0')],
  FC = [new HT('>=0.0.0')],
  _3e = (e, t, n) => {
    if (e === t) return !0;
    if (e.length === 1 && e[0].semver === Q_) {
      if (t.length === 1 && t[0].semver === Q_) return !0;
      n.includePrerelease ? (e = v3e) : (e = FC);
    }
    if (t.length === 1 && t[0].semver === Q_) {
      if (n.includePrerelease) return !0;
      t = FC;
    }
    const r = new Set();
    let i, s;
    for (const h of e)
      h.operator === '>' || h.operator === '>='
        ? (i = zC(i, h, n))
        : h.operator === '<' || h.operator === '<='
          ? (s = KC(s, h, n))
          : r.add(h.semver);
    if (r.size > 1) return null;
    let o;
    if (i && s) {
      if (((o = GT(i.semver, s.semver, n)), o > 0)) return null;
      if (o === 0 && (i.operator !== '>=' || s.operator !== '<=')) return null;
    }
    for (const h of r) {
      if ((i && !Pl(h, String(i), n)) || (s && !Pl(h, String(s), n))) return null;
      for (const p of t) if (!Pl(h, String(p), n)) return !1;
      return !0;
    }
    let a,
      c,
      u,
      l,
      d = s && !n.includePrerelease && s.semver.prerelease.length ? s.semver : !1,
      f = i && !n.includePrerelease && i.semver.prerelease.length ? i.semver : !1;
    d && d.prerelease.length === 1 && s.operator === '<' && d.prerelease[0] === 0 && (d = !1);
    for (const h of t) {
      if (
        ((l = l || h.operator === '>' || h.operator === '>='),
        (u = u || h.operator === '<' || h.operator === '<='),
        i)
      ) {
        if (
          (f &&
            h.semver.prerelease &&
            h.semver.prerelease.length &&
            h.semver.major === f.major &&
            h.semver.minor === f.minor &&
            h.semver.patch === f.patch &&
            (f = !1),
          h.operator === '>' || h.operator === '>=')
        ) {
          if (((a = zC(i, h, n)), a === h && a !== i)) return !1;
        } else if (i.operator === '>=' && !Pl(i.semver, String(h), n)) return !1;
      }
      if (s) {
        if (
          (d &&
            h.semver.prerelease &&
            h.semver.prerelease.length &&
            h.semver.major === d.major &&
            h.semver.minor === d.minor &&
            h.semver.patch === d.patch &&
            (d = !1),
          h.operator === '<' || h.operator === '<=')
        ) {
          if (((c = KC(s, h, n)), c === h && c !== s)) return !1;
        } else if (s.operator === '<=' && !Pl(s.semver, String(h), n)) return !1;
      }
      if (!h.operator && (s || i) && o !== 0) return !1;
    }
    return !((i && u && !s && o !== 0) || (s && l && !i && o !== 0) || f || d);
  },
  zC = (e, t, n) => {
    if (!e) return t;
    const r = GT(e.semver, t.semver, n);
    return r > 0 ? e : r < 0 || (t.operator === '>' && e.operator === '>=') ? t : e;
  },
  KC = (e, t, n) => {
    if (!e) return t;
    const r = GT(e.semver, t.semver, n);
    return r < 0 ? e : r > 0 || (t.operator === '<' && e.operator === '<=') ? t : e;
  };
var S3e = w3e;
const eS = Lp,
  VC = G1,
  E3e = Sr,
  WC = mj,
  A3e = dl,
  I3e = Ake,
  T3e = xke,
  x3e = Cke,
  k3e = Mke,
  C3e = Dke,
  P3e = jke,
  M3e = $ke,
  O3e = Kke,
  B3e = Gi,
  D3e = Gke,
  R3e = Zke,
  N3e = FT,
  j3e = e2e,
  L3e = r2e,
  U3e = Y1,
  $3e = zT,
  F3e = wj,
  z3e = vj,
  K3e = KT,
  V3e = VT,
  W3e = _j,
  H3e = T2e,
  G3e = Z1(),
  q3e = qi(),
  Y3e = J1,
  Z3e = $2e,
  J3e = V2e,
  X3e = q2e,
  Q3e = J2e,
  e8e = e3e,
  t8e = WT,
  n8e = l3e,
  r8e = h3e,
  i8e = g3e,
  s8e = m3e,
  o8e = S3e;
var a8e = {
  parse: A3e,
  valid: I3e,
  clean: T3e,
  inc: x3e,
  diff: k3e,
  major: C3e,
  minor: P3e,
  patch: M3e,
  prerelease: O3e,
  compare: B3e,
  rcompare: D3e,
  compareLoose: R3e,
  compareBuild: N3e,
  sort: j3e,
  rsort: L3e,
  gt: U3e,
  lt: $3e,
  eq: F3e,
  neq: z3e,
  gte: K3e,
  lte: V3e,
  cmp: W3e,
  coerce: H3e,
  Comparator: G3e,
  Range: q3e,
  satisfies: Y3e,
  toComparators: Z3e,
  maxSatisfying: J3e,
  minSatisfying: X3e,
  minVersion: Q3e,
  validRange: e8e,
  outside: t8e,
  gtr: n8e,
  ltr: r8e,
  intersects: i8e,
  simplifyRange: s8e,
  subset: o8e,
  SemVer: E3e,
  re: eS.re,
  src: eS.src,
  tokens: eS.t,
  SEMVER_SPEC_VERSION: VC.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: VC.RELEASE_TYPES,
  compareIdentifiers: WC.compareIdentifiers,
  rcompareIdentifiers: WC.rcompareIdentifiers,
};
const HC = Sc(a8e);
var eA = function () {
    return (
      (eA =
        Object.assign ||
        function (e) {
          for (var t, n = 1, r = arguments.length; n < r; n++) {
            t = arguments[n];
            for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
          }
          return e;
        }),
      eA.apply(this, arguments)
    );
  },
  Wc,
  Ur;
(function (e) {
  (e.blue = 'blue'), (e.nanoS = 'nanoS'), (e.nanoSP = 'nanoSP'), (e.nanoX = 'nanoX');
})(Ur || (Ur = {}));
var tA =
  ((Wc = {}),
  (Wc[Ur.blue] = {
    id: Ur.blue,
    productName: 'Ledger Blue',
    productIdMM: 0,
    legacyUsbProductId: 0,
    usbOnly: !0,
    memorySize: 480 * 1024,
    masks: [822083584, 822149120],
    getBlockSize: function (e) {
      return 4 * 1024;
    },
  }),
  (Wc[Ur.nanoS] = {
    id: Ur.nanoS,
    productName: 'Ledger Nano S',
    productIdMM: 16,
    legacyUsbProductId: 1,
    usbOnly: !0,
    memorySize: 320 * 1024,
    masks: [823132160],
    getBlockSize: function (e) {
      var t;
      return HC.lt((t = HC.coerce(e)) !== null && t !== void 0 ? t : '', '2.0.0')
        ? 4 * 1024
        : 2 * 1024;
    },
  }),
  (Wc[Ur.nanoSP] = {
    id: Ur.nanoSP,
    productName: 'Ledger Nano SP',
    productIdMM: 80,
    legacyUsbProductId: 5,
    usbOnly: !0,
    memorySize: 1533 * 1024,
    masks: [856686592],
    getBlockSize: function (e) {
      return 32;
    },
  }),
  (Wc[Ur.nanoX] = {
    id: Ur.nanoX,
    productName: 'Ledger Nano X',
    productIdMM: 64,
    legacyUsbProductId: 4,
    usbOnly: !1,
    memorySize: 2 * 1024 * 1024,
    masks: [855638016],
    getBlockSize: function (e) {
      return 4 * 1024;
    },
    bluetoothSpec: [
      {
        serviceUuid: 'd973f2e0-b19e-11e2-9e96-0800200c9a66',
        notifyUuid: 'd973f2e1-b19e-11e2-9e96-0800200c9a66',
        writeUuid: 'd973f2e2-b19e-11e2-9e96-0800200c9a66',
        writeCmdUuid: 'd973f2e3-b19e-11e2-9e96-0800200c9a66',
      },
      {
        serviceUuid: '13d63400-2c97-0004-0000-4c6564676572',
        notifyUuid: '13d63400-2c97-0004-0001-4c6564676572',
        writeUuid: '13d63400-2c97-0004-0002-4c6564676572',
        writeCmdUuid: '13d63400-2c97-0004-0003-4c6564676572',
      },
    ],
  }),
  Wc);
Ur.blue, Ur.nanoS, Ur.nanoX;
var GC = Object.values(tA),
  Aj = 11415,
  qC = function (e) {
    var t = GC.find(function (i) {
      return i.legacyUsbProductId === e;
    });
    if (t) return t;
    var n = e >> 8,
      r = GC.find(function (i) {
        return i.productIdMM === n;
      });
    return r;
  },
  c8e = [],
  YC = {};
for (var u8e in tA) {
  var ZC = tA[u8e],
    tS = ZC.bluetoothSpec;
  if (tS)
    for (var nS = 0; nS < tS.length; nS++) {
      var jg = tS[nS];
      c8e.push(jg.serviceUuid),
        (YC[jg.serviceUuid] = YC[jg.serviceUuid.replace(/-/g, '')] = eA({ deviceModel: ZC }, jg));
    }
}
var l8e = (function () {
    var e = function (t, n) {
      return (
        (e =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (r, i) {
              r.__proto__ = i;
            }) ||
          function (r, i) {
            for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (r[s] = i[s]);
          }),
        e(t, n)
      );
    };
    return function (t, n) {
      if (typeof n != 'function' && n !== null)
        throw new TypeError('Class extends value ' + String(n) + ' is not a constructor or null');
      e(t, n);
      function r() {
        this.constructor = t;
      }
      t.prototype = n === null ? Object.create(n) : ((r.prototype = n.prototype), new r());
    };
  })(),
  Ks = function (e, t, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(l) {
        try {
          u(r.next(l));
        } catch (d) {
          o(d);
        }
      }
      function c(l) {
        try {
          u(r.throw(l));
        } catch (d) {
          o(d);
        }
      }
      function u(l) {
        l.done ? s(l.value) : i(l.value).then(a, c);
      }
      u((r = r.apply(e, t || [])).next());
    });
  },
  Vs = function (e, t) {
    var n = {
        label: 0,
        sent: function () {
          if (s[0] & 1) throw s[1];
          return s[1];
        },
        trys: [],
        ops: [],
      },
      r,
      i,
      s,
      o;
    return (
      (o = { next: a(0), throw: a(1), return: a(2) }),
      typeof Symbol == 'function' &&
        (o[Symbol.iterator] = function () {
          return this;
        }),
      o
    );
    function a(u) {
      return function (l) {
        return c([u, l]);
      };
    }
    function c(u) {
      if (r) throw new TypeError('Generator is already executing.');
      for (; n; )
        try {
          if (
            ((r = 1),
            i &&
              (s =
                u[0] & 2
                  ? i.return
                  : u[0]
                    ? i.throw || ((s = i.return) && s.call(i), 0)
                    : i.next) &&
              !(s = s.call(i, u[1])).done)
          )
            return s;
          switch (((i = 0), s && (u = [u[0] & 2, s.value]), u[0])) {
            case 0:
            case 1:
              s = u;
              break;
            case 4:
              return n.label++, { value: u[1], done: !1 };
            case 5:
              n.label++, (i = u[1]), (u = [0]);
              continue;
            case 7:
              (u = n.ops.pop()), n.trys.pop();
              continue;
            default:
              if (
                ((s = n.trys), !(s = s.length > 0 && s[s.length - 1]) && (u[0] === 6 || u[0] === 2))
              ) {
                n = 0;
                continue;
              }
              if (u[0] === 3 && (!s || (u[1] > s[0] && u[1] < s[3]))) {
                n.label = u[1];
                break;
              }
              if (u[0] === 6 && n.label < s[1]) {
                (n.label = s[1]), (s = u);
                break;
              }
              if (s && n.label < s[2]) {
                (n.label = s[2]), n.ops.push(u);
                break;
              }
              s[2] && n.ops.pop(), n.trys.pop();
              continue;
          }
          u = t.call(e, n);
        } catch (l) {
          (u = [6, l]), (i = 0);
        } finally {
          r = s = 0;
        }
      if (u[0] & 5) throw u[1];
      return { value: u[0] ? u[1] : void 0, done: !0 };
    }
  },
  d8e = function (e, t) {
    var n = typeof Symbol == 'function' && e[Symbol.iterator];
    if (!n) return e;
    var r = n.call(e),
      i,
      s = [],
      o;
    try {
      for (; (t === void 0 || t-- > 0) && !(i = r.next()).done; ) s.push(i.value);
    } catch (a) {
      o = { error: a };
    } finally {
      try {
        i && !i.done && (n = r.return) && n.call(r);
      } finally {
        if (o) throw o.error;
      }
    }
    return s;
  },
  f8e = [{ vendorId: Aj }],
  h8e = function () {
    return Promise.resolve(!!(window.navigator && window.navigator.hid));
  },
  db = function () {
    var e = navigator.hid;
    if (!e) throw new za('navigator.hid is not supported', 'HIDNotSupported');
    return e;
  };
function Ij() {
  return Ks(this, void 0, void 0, function () {
    var e;
    return Vs(this, function (t) {
      switch (t.label) {
        case 0:
          return [4, db().requestDevice({ filters: f8e })];
        case 1:
          return (e = t.sent()), Array.isArray(e) ? [2, e] : [2, [e]];
      }
    });
  });
}
function nA() {
  return Ks(this, void 0, void 0, function () {
    var e;
    return Vs(this, function (t) {
      switch (t.label) {
        case 0:
          return [4, db().getDevices()];
        case 1:
          return (
            (e = t.sent()),
            [
              2,
              e.filter(function (n) {
                return n.vendorId === Aj;
              }),
            ]
          );
      }
    });
  });
}
function p8e() {
  return Ks(this, void 0, void 0, function () {
    var e, t;
    return Vs(this, function (n) {
      switch (n.label) {
        case 0:
          return [4, nA()];
        case 1:
          return (e = n.sent()), e.length > 0 ? [2, e[0]] : [4, Ij()];
        case 2:
          return (t = n.sent()), [2, t[0]];
      }
    });
  });
}
(function (e) {
  l8e(t, e);
  function t(n) {
    var r = e.call(this) || this;
    return (
      (r.channel = Math.floor(Math.random() * 65535)),
      (r.packetSize = 64),
      (r.inputs = []),
      (r.read = function () {
        return r.inputs.length
          ? Promise.resolve(r.inputs.shift())
          : new Promise(function (i) {
              r.inputCallback = i;
            });
      }),
      (r.onInputReport = function (i) {
        var s = z.from(i.data.buffer);
        r.inputCallback ? (r.inputCallback(s), (r.inputCallback = null)) : r.inputs.push(s);
      }),
      (r._disconnectEmitted = !1),
      (r._emitDisconnect = function (i) {
        r._disconnectEmitted || ((r._disconnectEmitted = !0), r.emit('disconnect', i));
      }),
      (r.exchange = function (i) {
        return Ks(r, void 0, void 0, function () {
          var s,
            o = this;
          return Vs(this, function (a) {
            switch (a.label) {
              case 0:
                return [
                  4,
                  this.exchangeAtomicImpl(function () {
                    return Ks(o, void 0, void 0, function () {
                      var c, u, l, d, f, h, p, b, w;
                      return Vs(this, function (A) {
                        switch (A.label) {
                          case 0:
                            (c = this),
                              (u = c.channel),
                              (l = c.packetSize),
                              R8('apdu', '=> ' + i.toString('hex')),
                              (d = cke(u, l)),
                              (f = d.makeBlocks(i)),
                              (h = 0),
                              (A.label = 1);
                          case 1:
                            return h < f.length ? [4, this.device.sendReport(0, f[h])] : [3, 4];
                          case 2:
                            A.sent(), (A.label = 3);
                          case 3:
                            return h++, [3, 1];
                          case 4:
                            return (p = d.getReducedResult(b)) ? [3, 6] : [4, this.read()];
                          case 5:
                            return (w = A.sent()), (b = d.reduceResponse(b, w)), [3, 4];
                          case 6:
                            return R8('apdu', '<= ' + p.toString('hex')), [2, p];
                        }
                      });
                    });
                  }).catch(function (c) {
                    throw c && c.message && c.message.includes('write')
                      ? (o._emitDisconnect(c), new YN(c.message))
                      : c;
                  }),
                ];
              case 1:
                return (s = a.sent()), [2, s];
            }
          });
        });
      }),
      (r.device = n),
      (r.deviceModel = typeof n.productId == 'number' ? qC(n.productId) : void 0),
      n.addEventListener('inputreport', r.onInputReport),
      r
    );
  }
  return (
    (t.request = function () {
      return Ks(this, void 0, void 0, function () {
        var n, r;
        return Vs(this, function (i) {
          switch (i.label) {
            case 0:
              return [4, Ij()];
            case 1:
              return (n = d8e.apply(void 0, [i.sent(), 1])), (r = n[0]), [2, t.open(r)];
          }
        });
      });
    }),
    (t.openConnected = function () {
      return Ks(this, void 0, void 0, function () {
        var n;
        return Vs(this, function (r) {
          switch (r.label) {
            case 0:
              return [4, nA()];
            case 1:
              return (n = r.sent()), n.length === 0 ? [2, null] : [2, t.open(n[0])];
          }
        });
      });
    }),
    (t.open = function (n) {
      return Ks(this, void 0, void 0, function () {
        var r, i;
        return Vs(this, function (s) {
          switch (s.label) {
            case 0:
              return [4, n.open()];
            case 1:
              return (
                s.sent(),
                (r = new t(n)),
                (i = function (o) {
                  n === o.device &&
                    (db().removeEventListener('disconnect', i), r._emitDisconnect(new qN()));
                }),
                db().addEventListener('disconnect', i),
                [2, r]
              );
          }
        });
      });
    }),
    (t.prototype.close = function () {
      return Ks(this, void 0, void 0, function () {
        return Vs(this, function (n) {
          switch (n.label) {
            case 0:
              return [4, this.exchangeBusyPromise];
            case 1:
              return (
                n.sent(),
                this.device.removeEventListener('inputreport', this.onInputReport),
                [4, this.device.close()]
              );
            case 2:
              return n.sent(), [2];
          }
        });
      });
    }),
    (t.prototype.setScrambleKey = function () {}),
    (t.isSupported = h8e),
    (t.list = nA),
    (t.listen = function (n) {
      var r = !1;
      p8e().then(
        function (s) {
          if (!s) n.error(new ZE('Access denied to use Ledger device'));
          else if (!r) {
            var o = typeof s.productId == 'number' ? qC(s.productId) : void 0;
            n.next({ type: 'add', descriptor: s, deviceModel: o }), n.complete();
          }
        },
        function (s) {
          n.error(new ZE(s.message));
        }
      );
      function i() {
        r = !0;
      }
      return { unsubscribe: i };
    }),
    t
  );
})(oke);
const g8e = { ledgerAppOverride: de.arbitrum.mainnetID, isLedgerEnabled: !0 },
  y8e = { ledgerAppOverride: de.ethereum.mainnetID, isLedgerEnabled: !0 },
  b8e = { isLedgerEnabled: !0 },
  m8e = { isLedgerEnabled: !0 },
  w8e = { ledgerAppOverride: de.ethereum.mainnetID, isLedgerEnabled: !0 },
  v8e = { isLedgerEnabled: !1 },
  _8e = { isLedgerEnabled: !0 },
  S8e = { isLedgerEnabled: !0 },
  E8e = { isLedgerEnabled: !1 },
  A8e = new Lu({
    [ze.Solana]: S8e,
    [ze.Ethereum]: m8e,
    [ze.Polygon]: _8e,
    [ze.Monad]: v8e,
    [ze.Base]: y8e,
    [ze.Arbitrum]: g8e,
    [ze.Bitcoin]: b8e,
    [ze.Sui]: E8e,
    [ze.Hypercore]: w8e,
  });
Uu(A8e);
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const rS = (e) =>
    new DataView(e.buffer, e.byteOffset, e.byteLength),
  rs = (e, t) => (e << (32 - t)) | (e >>> t),
  I8e = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!I8e) throw new Error('Non little-endian hardware is not supported');
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, '0'));
function T8e(e) {
  if (typeof e != 'string') throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function Tj(e) {
  if ((typeof e == 'string' && (e = T8e(e)), !(e instanceof Uint8Array)))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
  return e;
}
class x8e {
  clone() {
    return this._cloneInto();
  }
}
function xj(e) {
  const t = (r) => e().update(Tj(r)).digest(),
    n = e();
  return (t.outputLen = n.outputLen), (t.blockLen = n.blockLen), (t.create = () => e()), t;
}
function rA(e) {
  if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`);
}
function k8e(e) {
  if (typeof e != 'boolean') throw new Error(`Expected boolean, not ${e}`);
}
function kj(e, ...t) {
  if (!(e instanceof Uint8Array)) throw new TypeError('Expected Uint8Array');
  if (t.length > 0 && !t.includes(e.length))
    throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function C8e(e) {
  if (typeof e != 'function' || typeof e.create != 'function')
    throw new Error('Hash should be wrapped by utils.wrapConstructor');
  rA(e.outputLen), rA(e.blockLen);
}
function P8e(e, t = !0) {
  if (e.destroyed) throw new Error('Hash instance has been destroyed');
  if (t && e.finished) throw new Error('Hash#digest() has already been called');
}
function M8e(e, t) {
  kj(e);
  const n = t.outputLen;
  if (e.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`);
}
const iS = { number: rA, bool: k8e, bytes: kj, hash: C8e, exists: P8e, output: M8e };
function O8e(e, t, n, r) {
  if (typeof e.setBigUint64 == 'function') return e.setBigUint64(t, n, r);
  const i = BigInt(32),
    s = BigInt(4294967295),
    o = Number((n >> i) & s),
    a = Number(n & s),
    c = r ? 4 : 0,
    u = r ? 0 : 4;
  e.setUint32(t + c, o, r), e.setUint32(t + u, a, r);
}
class B8e extends x8e {
  constructor(t, n, r, i) {
    super(),
      (this.blockLen = t),
      (this.outputLen = n),
      (this.padOffset = r),
      (this.isLE = i),
      (this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.buffer = new Uint8Array(t)),
      (this.view = rS(this.buffer));
  }
  update(t) {
    iS.exists(this);
    const { view: n, buffer: r, blockLen: i } = this;
    t = Tj(t);
    const s = t.length;
    for (let o = 0; o < s; ) {
      const a = Math.min(i - this.pos, s - o);
      if (a === i) {
        const c = rS(t);
        for (; i <= s - o; o += i) this.process(c, o);
        continue;
      }
      r.set(t.subarray(o, o + a), this.pos),
        (this.pos += a),
        (o += a),
        this.pos === i && (this.process(n, 0), (this.pos = 0));
    }
    return (this.length += t.length), this.roundClean(), this;
  }
  digestInto(t) {
    iS.exists(this), iS.output(t, this), (this.finished = !0);
    const { buffer: n, view: r, blockLen: i, isLE: s } = this;
    let { pos: o } = this;
    (n[o++] = 128),
      this.buffer.subarray(o).fill(0),
      this.padOffset > i - o && (this.process(r, 0), (o = 0));
    for (let d = o; d < i; d++) n[d] = 0;
    O8e(r, i - 8, BigInt(this.length * 8), s), this.process(r, 0);
    const a = rS(t),
      c = this.outputLen;
    if (c % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
    const u = c / 4,
      l = this.get();
    if (u > l.length) throw new Error('_sha2: outputLen bigger than state');
    for (let d = 0; d < u; d++) a.setUint32(4 * d, l[d], s);
  }
  digest() {
    const { buffer: t, outputLen: n } = this;
    this.digestInto(t);
    const r = t.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: n, buffer: r, length: i, finished: s, destroyed: o, pos: a } = this;
    return (
      (t.length = i), (t.pos = a), (t.finished = s), (t.destroyed = o), i % n && t.buffer.set(r), t
    );
  }
}
const D8e = (e, t, n) => (e & t) ^ (~e & n),
  R8e = (e, t, n) => (e & t) ^ (e & n) ^ (t & n),
  N8e = new Uint32Array([
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221,
    3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580,
    3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895,
    666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037,
    2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
    1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298,
  ]),
  Vo = new Uint32Array([
    1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225,
  ]),
  Wo = new Uint32Array(64);
class Cj extends B8e {
  constructor() {
    super(64, 32, 8, !1),
      (this.A = Vo[0] | 0),
      (this.B = Vo[1] | 0),
      (this.C = Vo[2] | 0),
      (this.D = Vo[3] | 0),
      (this.E = Vo[4] | 0),
      (this.F = Vo[5] | 0),
      (this.G = Vo[6] | 0),
      (this.H = Vo[7] | 0);
  }
  get() {
    const { A: t, B: n, C: r, D: i, E: s, F: o, G: a, H: c } = this;
    return [t, n, r, i, s, o, a, c];
  }
  set(t, n, r, i, s, o, a, c) {
    (this.A = t | 0),
      (this.B = n | 0),
      (this.C = r | 0),
      (this.D = i | 0),
      (this.E = s | 0),
      (this.F = o | 0),
      (this.G = a | 0),
      (this.H = c | 0);
  }
  process(t, n) {
    for (let d = 0; d < 16; d++, n += 4) Wo[d] = t.getUint32(n, !1);
    for (let d = 16; d < 64; d++) {
      const f = Wo[d - 15],
        h = Wo[d - 2],
        p = rs(f, 7) ^ rs(f, 18) ^ (f >>> 3),
        b = rs(h, 17) ^ rs(h, 19) ^ (h >>> 10);
      Wo[d] = (b + Wo[d - 7] + p + Wo[d - 16]) | 0;
    }
    let { A: r, B: i, C: s, D: o, E: a, F: c, G: u, H: l } = this;
    for (let d = 0; d < 64; d++) {
      const f = rs(a, 6) ^ rs(a, 11) ^ rs(a, 25),
        h = (l + f + D8e(a, c, u) + N8e[d] + Wo[d]) | 0,
        b = ((rs(r, 2) ^ rs(r, 13) ^ rs(r, 22)) + R8e(r, i, s)) | 0;
      (l = u), (u = c), (c = a), (a = (o + h) | 0), (o = s), (s = i), (i = r), (r = (h + b) | 0);
    }
    (r = (r + this.A) | 0),
      (i = (i + this.B) | 0),
      (s = (s + this.C) | 0),
      (o = (o + this.D) | 0),
      (a = (a + this.E) | 0),
      (c = (c + this.F) | 0),
      (u = (u + this.G) | 0),
      (l = (l + this.H) | 0),
      this.set(r, i, s, o, a, c, u, l);
  }
  roundClean() {
    Wo.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
class j8e extends Cj {
  constructor() {
    super(),
      (this.A = -1056596264),
      (this.B = 914150663),
      (this.C = 812702999),
      (this.D = -150054599),
      (this.E = -4191439),
      (this.F = 1750603025),
      (this.G = 1694076839),
      (this.H = -1090891868),
      (this.outputLen = 28);
  }
}
xj(() => new Cj());
xj(() => new j8e());
parseInt(z.from(new Uint8Array(32).fill(255)).toString('hex'), 16);
const L8e = (e) => P.jsx(U8e, { ...e }),
  U8e = W.memo(({ title: e, description: t, onIntroComplete: n }) =>
    P.jsx(P.Fragment, {
      children: P.jsxs(ye, {
        flex: 1,
        alignItems: 'center',
        justifyContent: 'center',
        children: [
          P.jsx(i9, { autoPlay: !0, onIntroComplete: n }),
          P.jsxs(ye, {
            marginTop: 32,
            gap: 8,
            children: [
              P.jsx(je, { align: 'center', font: 'heading4Semibold', children: e }),
              P.jsx(je, { align: 'center', font: 'caption', color: 'textSecondary', children: t }),
            ],
          }),
        ],
      }),
    })
  );
var $8e = {};
const Pj = () => {
    const e = zM(),
      t = Es();
    return W.useCallback(
      async ({ entropy: n }) => {
        const r = await F8e(),
          i = n.fold(r.fromEntropy),
          s = Wb(n),
          o = [];
        try {
          const { walletAccounts: a } = await e.getSyncedAccounts();
          for (const c of a) {
            if (
              c.accountOrigin !== `seedless:${s}` ||
              c.derivationIndex === null ||
              c.derivationIndex < 0
            )
              continue;
            const u = c.addresses.reduce(
              (l, d) => (d.pathType !== 'privateKey' && l.push(d.pathType), l),
              []
            );
            o.push({ derivationIndex: c.derivationIndex, derivationPathTypes: u });
          }
        } catch (a) {
          re.captureError(
            a instanceof Error
              ? a
              : new Error('Unable to get synced accounts for deriving seedless accounts.'),
            ce.Auth
          );
        }
        if (o.length === 0) {
          const c = (await lA(t)).enabledAddressTypes,
            u = Ku(c);
          o.push({ derivationIndex: 0, derivationPathTypes: u });
        }
        return { mnemonic: i, accountCreationMetas: o };
      },
      [t, e]
    );
  },
  F8e = (() => {
    let e = null;
    return async () => (
      e ||
        (s9($8e.CUSTOM_CRYPTO_BIP39)
          ? (e = await gk.customCrypto('english', {
              random(t) {
                return crypto.getRandomValues(new Uint8Array(t));
              },
              async sha256(t) {
                return new Uint8Array(await crypto.subtle.digest('SHA-256', t));
              },
              pbkdf2(t, n, r, i, s) {
                return new Promise((o, a) => {
                  tL.pbkdf2(t, n, r, i, s, (c, u) => {
                    c ? a(c) : o(u);
                  });
                });
              },
            }))
          : (e = await gk.webCrypto('english'))),
      e
    );
  })();
function qT(e, t, n, r) {
  const i = new RegExp(`^[0-9]{${e},${t}}$`);
  return ({ value: s, isFocused: o }) => {
    const a = !o && s.length !== 0;
    return s.length < e || s.length > t || !i.test(s)
      ? (n(!1), { report: a, status: 'fail', message: r })
      : (n(!0), { status: 'accent' });
  };
}
const z8e = W.memo(
    ({
      isLoading: e,
      isError: t,
      isPinError: n,
      hasCooldownTimer: r,
      handleInput: i,
      onForgot: s,
      onSubmit: o,
      pinAttemptsLeft: a,
      disabled: c,
      pin: u,
      cooldownTimerText: l,
      continueButtonText: d,
      forgotButtonText: f,
      attemptsLeftText: h,
      invalidPinText: p,
      title: b,
      loadingTitle: w,
      loadingDescription: A,
      errorTitle: _,
      errorDescription: x,
      errorButtonText: k,
    }) => {
      const { t: j } = Ct(),
        F = j('seedlessEnterPinIncorrectLength'),
        [K, D] = W.useState(!1),
        C = W.useMemo(() => qT(t7, tb, D, F), [F]);
      return t
        ? P.jsxs(ye, {
            flex: 1,
            children: [
              P.jsxs(ye, {
                flex: 1,
                gap: 8,
                alignItems: 'center',
                justifyContent: 'center',
                children: [
                  P.jsx(je, { align: 'center', font: 'heading3Semibold', children: _ }),
                  P.jsx(je, { align: 'center', font: 'body', color: 'textSecondary', children: x }),
                ],
              }),
              k &&
                P.jsx(on, {
                  className: yr({ flex: 'none', marginTop: 'auto' }),
                  theme: 'primary',
                  onPress: o,
                  children: k,
                }),
            ],
          })
        : e
          ? P.jsx(L8e, { title: w, description: A })
          : P.jsxs(ye, {
              flex: 1,
              children: [
                P.jsx(ye, {
                  marginY: 28,
                  gap: 8,
                  children: P.jsx(je, { align: 'center', font: 'heading3Semibold', children: b }),
                }),
                P.jsx(ye, {
                  className: yr({
                    flexDirection: 'row',
                    justifyContent: 'center',
                    marginBottom: 'screen',
                  }),
                  children: P.jsx(yy, {
                    autoFocus: !0,
                    id: 'seedless-enter-pin',
                    label: 'Enter your PIN',
                    showLabel: !1,
                    maxLength: tb,
                    setValue: i,
                    validateOn: 'both',
                    validator: C,
                    validatorDebounce: 0,
                    value: u,
                    disabled: r,
                    onSubmit: o,
                  }),
                }),
                n || r
                  ? P.jsxs(ye, {
                      children: [
                        P.jsxs(ye, {
                          className: yr({ flexDirection: 'row', alignItems: 'center' }),
                          gap: 4,
                          children: [
                            P.jsx(ye, { children: P.jsx(oP, { size: 14, color: 'accentAlert' }) }),
                            P.jsx(je, { color: 'accentAlert', font: 'label', children: p }),
                          ],
                        }),
                        P.jsxs(ye, {
                          className: yr({ flexDirection: 'row', alignItems: 'center' }),
                          gap: 4,
                          children: [
                            a
                              ? P.jsx(je, {
                                  marginLeft: 'screen',
                                  color: 'accentAlert',
                                  font: 'label',
                                  children: h,
                                })
                              : null,
                            r
                              ? P.jsx(je, {
                                  marginLeft: a ? 0 : 'screen',
                                  color: 'accentAlert',
                                  font: 'label',
                                  children: l,
                                })
                              : null,
                          ],
                        }),
                      ],
                    })
                  : null,
                P.jsx(ye, {
                  marginTop: 'auto',
                  children: P.jsxs(Fi, {
                    children: [
                      P.jsx(on, { children: f, onPress: s }),
                      P.jsx(on, { children: d, onPress: o, disabled: c || !K }),
                    ],
                  }),
                }),
              ],
            });
    }
  ),
  K8e = ({ onCancel: e, onClose: t, onFinished: n, vault: r }) => {
    const { t: i } = Ct(),
      s = Pj(),
      { data: o } = oI(),
      { mutateAsync: a } = h4(),
      { mutateAsync: c } = f4(),
      u = t1e({
        hasEnrolledAuthentication: !1,
        onImportAndSyncAccounts: async (l) => {
          const { accountCreationMetas: d } = await s({ entropy: l }),
            f = i('onboardingImportAccountsAccountName', {
              walletIndex:
                o != null && o.length
                  ? (o == null ? void 0 : o.length) + 1
                  : d[0].derivationIndex + 1,
            }),
            h = await r.addSeedWithMultipleAccounts(l, f, d, !0),
            p = {};
          h.forEach((b, w) => {
            p[b.identifier] = {
              name: i('onboardingImportAccountsAccountName', { walletIndex: w + 1 }),
            };
          }),
            await c({ metadataBatch: p }),
            await a({ identifier: h[0].identifier });
        },
        onForgot: e,
        onOnboardingDone: n,
      });
    return P.jsx(aP, {
      hideBackButton: !0,
      onClose: t,
      children: [() => P.jsx(z8e, { ...u, onForgot: e, forgotButtonText: i('commandSignOut') })],
    });
  },
  V8e = ({ onClose: e }) => {
    const { t } = Ct();
    return P.jsxs(ye, {
      height: '100%',
      children: [
        P.jsxs(ye, {
          flexGrow: 1,
          direction: 'column',
          justifyContent: 'center',
          alignItems: 'center',
          children: [
            P.jsx(ye, { style: { marginTop: -120 }, children: P.jsx(o9, {}) }),
            P.jsx(je, { font: 'heading2', marginTop: 36, children: t('onboardingFinished') }),
            P.jsx(je, {
              font: 'title1',
              fontWeight: 'light',
              color: 'textSecondary',
              marginTop: 8,
              children: t('onboardingDoneDescription'),
            }),
          ],
        }),
        P.jsx(on, { theme: 'primary', onPress: e, children: t('onboardingDoneGetStarted') }),
      ],
    });
  },
  W8e = ({ onClose: e, onFinished: t, vault: n }) => {
    const { t: r } = Ct(),
      i = r('seedlessEnterPinMatch'),
      s = r('seedlessConfirmPinError'),
      o = r('seedlessEnterPinIncorrectLength'),
      a = 4,
      c = 4,
      [u, l] = W.useState(''),
      [d, f] = W.useState(!1),
      [h, p] = W.useState(''),
      [b, w] = W.useState(!1),
      { data: A } = oI(),
      _ = Pj(),
      { mutateAsync: x } = Mme(),
      { mutateAsync: k } = f4(),
      { mutateAsync: j } = h4(),
      [F, K] = W.useState(),
      [D, C] = W.useState(!1),
      B = async (R) => {
        K(void 0), C(!0);
        const L = await DG(),
          O = mr.from(MG(L));
        await x({ entropy: O, pin: R });
        const { accountCreationMetas: I } = await _({ entropy: O }),
          U = r('onboardingImportAccountsAccountName', {
            walletIndex:
              A != null && A.length
                ? (A == null ? void 0 : A.length) + 1
                : I[0].derivationIndex + 1,
          }),
          H = await n.addSeedWithMultipleAccounts(O, U, I, !0),
          X = {};
        H.forEach((J, ie) => {
          X[J.identifier] = {
            name: r('onboardingImportAccountsAccountName', { walletIndex: ie + 1 }),
          };
        }),
          await k({ metadataBatch: X }),
          await j({ identifier: H[0].identifier }),
          C(!1);
      },
      E = (R) => {
        K(R), C(!1);
      };
    W.useEffect(() => {
      p('');
    }, [u]);
    const y = qT(4, 4, f, o),
      v = W.useCallback(
        ({ value: R, isFocused: L }) =>
          R.length < u.length && L
            ? (w(!1), { status: 'neutral' })
            : u !== R
              ? (w(!1), { status: 'fail', message: s })
              : (w(!0), { status: 'pass', message: i }),
        [i, s, u]
      ),
      S = W.useRef(null),
      T = async (R, L) => {
        var O;
        (O = S.current) == null || O.start(),
          await B(R)
            .then(() => {
              L();
            })
            .catch((I) => {
              Mc(I) || a7(I) ? E(I) : E('unknown');
            })
            .finally(() => {
              var I;
              (I = S.current) == null || I.stop();
            });
      },
      M = D
        ? r('seedlessLoadingWalletPrimaryText')
        : F != null
          ? r('commandTryAgain')
          : r('seedlessContinueText');
    return P.jsx(aP, {
      onClose: e,
      children: [
        ({ nextStep: R }) =>
          P.jsxs(P.Fragment, {
            children: [
              P.jsxs(ye, {
                gap: 24,
                children: [
                  P.jsxs(ye, {
                    gap: 12,
                    marginY: 16,
                    alignItems: 'center',
                    justifyContent: 'center',
                    children: [
                      P.jsx(je, {
                        font: 'heading3Semibold',
                        children: r('seedlessCreateAPinPrimaryText'),
                      }),
                      P.jsx(je, {
                        align: 'center',
                        font: 'body',
                        color: 'textSecondary',
                        children: P.jsxs(dP, {
                          i18nKey: 'seedlessCreateAPinSecondaryText',
                          children: [
                            'This is used to secure your wallet on all your devices.',
                            P.jsx(je, {
                              font: 'body',
                              color: 'accentWarning',
                              children: 'This cannot be recovered.',
                            }),
                          ],
                        }),
                      }),
                    ],
                  }),
                  P.jsx(yy, {
                    autoFocus: !0,
                    id: 'create-pin',
                    label: 'Create a PIN',
                    showLabel: !1,
                    maxLength: c,
                    minLength: a,
                    setValue: (L) => {
                      l(L), L.length === c && R();
                    },
                    validateOn: 'both',
                    validator: y,
                    validatorDebounce: 0,
                    value: u,
                    onKeyDown: (L) => {
                      L.key === 'Enter' && R();
                    },
                  }),
                ],
              }),
              P.jsxs(ye, {
                gap: 20,
                children: [
                  P.jsx(on, {
                    onPress: R,
                    theme: 'primary',
                    disabled: !d,
                    children: r('commandContinue'),
                  }),
                  P.jsxs(je, {
                    font: 'labelMedium',
                    color: 'textSecondary',
                    display: 'flex',
                    direction: 'row',
                    justifyContent: 'center',
                    alignItems: 'center',
                    gap: 4,
                    marginBottom: 4,
                    children: ['Powered by ', P.jsx(ux, { size: 18 }), ' Phantom'],
                  }),
                ],
              }),
            ],
          }),
        ({ nextStep: R }) =>
          P.jsxs(P.Fragment, {
            children: [
              P.jsxs(ye, {
                gap: 24,
                children: [
                  P.jsxs(ye, {
                    gap: 12,
                    children: [
                      P.jsx(je, {
                        font: 'heading3Semibold',
                        children: r('seedlessConfirmPinPrimaryText'),
                      }),
                      P.jsx(je, {
                        color: 'textSecondary',
                        font: 'caption',
                        children: r('seedlessConfirmPinSecondaryText'),
                      }),
                    ],
                  }),
                  P.jsx(yy, {
                    autoFocus: !0,
                    id: 'confirm-pin',
                    label: 'Confirm your PIN',
                    showLabel: !1,
                    maxLength: c,
                    minLength: a,
                    setValue: p,
                    validateOn: 'both',
                    validator: v,
                    validatorDebounce: 0,
                    value: h,
                    shakeOnInvalid: !0,
                  }),
                ],
              }),
              P.jsxs(ye, {
                gap: 20,
                children: [
                  P.jsx(cP, {
                    ref: S,
                    theme: 'primary',
                    disabled: !b || D,
                    onClick: async () => await T(u, R),
                    children: M,
                  }),
                  P.jsxs(je, {
                    font: 'labelMedium',
                    color: 'textSecondary',
                    display: 'flex',
                    direction: 'row',
                    justifyContent: 'center',
                    alignItems: 'center',
                    gap: 4,
                    marginBottom: 4,
                    children: ['Powered by ', P.jsx(ux, { size: 18 }), ' Phantom'],
                  }),
                ],
              }),
            ],
          }),
        () => P.jsx(V8e, { onClose: t }),
      ],
    });
  },
  H8e = 4,
  G8e = ({ autoSubmit: e = !1, buttonRef: t, onSubmit: n, onSuccess: r }) => {
    const [i, s] = W.useState(''),
      [o, a] = W.useState(!1),
      [c, u] = W.useState(),
      l = W.useCallback(
        async (h) => {
          var p, b;
          (p = t.current) == null || p.start(), a(!0);
          try {
            await n(h), u(void 0), r();
          } catch (w) {
            Mc(w) || a7(w) ? u(w) : u('unknown');
          } finally {
            (b = t.current) == null || b.stop(), a(!1);
          }
        },
        [n, r, t]
      ),
      d = W.useCallback(async () => {
        await l(i);
      }, [i, l]),
      f = W.useCallback(
        async (h) => {
          s(h), e && h.length === H8e && (await l(h));
        },
        [e, s, l]
      );
    return { pin: i, pinSubmissionError: c, isSubmitting: o, handlePinChange: f, handleSubmit: d };
  },
  q8e = ({ error: e, cooldownTimer: t, showResetPinAttempts: n }) => {
    if (u7(e) && e.reasonCode === al.InvalidPin) return { message: 'seedlessConfirmPinError' };
    if (!Mc(e)) return { message: 'seedlessEnterPinUnknownError' };
    if (e1e(e)) return { message: 'seedlessEnterPinUnauthorizedError' };
    if (A7(e) && !n) {
      const { minutes: r, seconds: i } = S7(t);
      return parseInt(r) > 0 || parseInt(i) > 0
        ? { message: 'seedlessEnterPinCooldown', params: { minutesLeft: r, secondsLeft: i } }
        : { message: 'seedlessEnterPinCooldownTimerEnd' };
    }
    if (bT(e) && typeof e.result.guessesRemaining == 'number') {
      let r = e.result.guessesRemaining;
      return (
        n && (r = e.result.guessesRemaining - QR),
        r === XR
          ? { message: 'seedlessVerifyPinOneGuessRemaining' }
          : r >= e7
            ? { message: 'seedlessEnterPinIncorrectNumTriesLeft', params: { numTries: r } }
            : { message: 'seedlessEnterPinUnknownErrorReset' }
      );
    }
    return I7(e)
      ? { message: 'seedlessRecoverErrorUpgradeRequiredDescription' }
      : { message: 'seedlessEnterPinUnknownErrorReset' };
  },
  Y8e = ({ error: e, showResetPinAttempts: t = !1 }) => {
    const { t: n } = Ct(),
      { data: r = 0 } = h7(),
      { message: i, params: s } = q8e({ error: e, cooldownTimer: r, showResetPinAttempts: t });
    return e
      ? P.jsx(ye, {
          direction: 'row',
          gap: 4,
          alignItems: 'center',
          children:
            i === 'seedlessVerifyPinOneGuessRemaining'
              ? P.jsx(je, {
                  color: 'textSecondary',
                  font: 'caption',
                  align: 'left',
                  children: n(i, s),
                })
              : P.jsxs(P.Fragment, {
                  children: [
                    P.jsx(oP, { size: 16, color: 'accentAlert' }),
                    P.jsx(je, {
                      color: 'accentAlert',
                      font: 'caption',
                      align: 'left',
                      children: n(i, s),
                    }),
                  ],
                }),
        })
      : null;
  },
  Z8e = ({
    onSubmit: e,
    onSuccess: t,
    showResetPinAttempts: n = !1,
    title: r,
    onForgotPinPress: i,
  }) => {
    const { t: s } = Ct(),
      o = s('seedlessEnterPinIncorrectLength'),
      [a, c] = W.useState(!1),
      u = W.useMemo(() => qT(t7, tb, c, o), [o]),
      l = W.useRef(null),
      {
        pin: d,
        pinSubmissionError: f,
        isSubmitting: h,
        handlePinChange: p,
        handleSubmit: b,
      } = G8e({ autoSubmit: !0, buttonRef: l, onSubmit: e, onSuccess: t });
    return P.jsxs(ye, {
      flex: 1,
      justifyContent: 'space-between',
      children: [
        P.jsxs(ye, {
          gap: 32,
          children: [
            r &&
              P.jsx(ye, {
                gap: 8,
                marginTop: 'screen',
                children: P.jsx(je, { align: 'center', font: 'heading4Bold', children: r }),
              }),
            P.jsxs(ye, {
              gap: 8,
              children: [
                P.jsx(yy, {
                  autoFocus: !0,
                  id: 'seedless-enter-pin',
                  label: 'Enter your PIN',
                  showLabel: !1,
                  maxLength: tb,
                  setValue: p,
                  validateOn: 'both',
                  validator: u,
                  validatorDebounce: 0,
                  value: d,
                  disabled: h,
                }),
                P.jsx(Y8e, { error: f, showResetPinAttempts: n }),
              ],
            }),
          ],
        }),
        P.jsxs(Fi, {
          children: [
            i && P.jsx(on, { children: s('seedlessVerifyPinForgotButtonText'), onPress: i }),
            P.jsx(cP, {
              ref: l,
              theme: 'primary',
              disabled: !a || h,
              onClick: b,
              children: s('commandContinue'),
            }),
          ],
        }),
      ],
    });
  },
  J8e = W.memo(({ goToReset: e, goToComplete: t }) => {
    const { t: n } = Ct(),
      r = Un(),
      { mutateAsync: i } = Bme(),
      { mutateAsync: s } = p7();
    W.useEffect(() => {
      r.capture('seedlessVerifyPinOpen');
    }, [r]);
    const o = W.useCallback(
      async (a) => {
        try {
          await i(a), r.capture('seedlessVerifyPinSuccess'), await s();
        } catch (c) {
          throw (bT(c) && c.result.guessesRemaining && c.result.guessesRemaining <= QR && e(), c);
        }
      },
      [i, e, r, s]
    );
    return P.jsx(Z8e, {
      title: n('seedlessVerifyPinPrimaryText'),
      onSubmit: o,
      onSuccess: t,
      showResetPinAttempts: !0,
    });
  });
J8e.displayName = 'SeedlessVerifyPin';
const X8e = (e) => P.jsx(ye, { flex: 1, minHeight: 0, alignItems: 'center', height: '100%', ...e }),
  JC = {
    outer: yr({ display: 'column', flex: 1, maxWidth: 420, minHeight: 0, overflow: 'auto' }),
    inner: yr({
      alignItems: 'center',
      display: 'column',
      flexGrow: 1,
      gap: 'screen',
      justifyContent: 'center',
      paddingY: 24,
    }),
  },
  Q8e = W.memo(({ children: e }) =>
    P.jsx('div', {
      className: JC.outer,
      children: P.jsx('div', { className: JC.inner, children: e }),
    })
  ),
  eCe = yr({ justifyContent: 'flex-end', alignItems: 'center', display: 'column', width: '100%' }),
  tCe = W.memo(({ children: e }) => P.jsx('div', { className: eCe, children: e })),
  nCe = yr({
    alignItems: 'flex-start',
    display: 'column',
    gap: 'screen',
    paddingX: 'screen',
    width: '100%',
  }),
  rCe = W.memo(({ children: e }) => P.jsx('div', { className: nCe, children: e })),
  iCe = yr({ display: 'column', flex: 1, paddingTop: 2, gap: 4, paddingRight: 2 }),
  sCe = W.memo(({ children: e }) => P.jsx('div', { className: iCe, children: e })),
  oCe = ({ title: e, description: t, icon: n }) =>
    P.jsxs(ye, {
      direction: 'row',
      gap: 12,
      children: [
        n,
        P.jsxs(sCe, {
          children: [
            e && P.jsx(je, { font: t ? 'bodySemibold' : 'body', children: e }),
            t &&
              P.jsx(je, {
                paddingTop: 1,
                color: e ? 'textSecondary' : 'textPrimary',
                font: e ? 'caption' : 'body',
                children: t,
              }),
          ],
        }),
      ],
    }),
  aCe = Kn.memo(
    ({
      image: e,
      title: t,
      description: n,
      items: r,
      primaryButton: { analyticsEvent: i, onAction: s, ...o },
      secondaryButton: a,
      onDisplay: c,
      displayEvent: u,
      footer: l,
      onDismiss: d,
      mobileTitleSheetInset: f,
      dismissGestureDisabled: h,
      ...p
    }) => {
      var F;
      const b = Un();
      W.useEffect(() => {
        c && c(), b.capture(u.event, u.payload);
      }, []);
      const w = W.useCallback(() => {
          s(), i && b.capture(i.event, i.payload);
        }, [i, s, b]),
        {
          analyticsEvent: A,
          onAction: _,
          ...x
        } = W.useMemo(() => a || { analyticsEvent: void 0, onAction: void 0 }, [a]),
        k = W.useCallback(() => {
          _ && (_(), A && b.capture(A.event, A.payload));
        }, [A, _, b]),
        j = 'children' in x && x.children;
      return (
        W.useLayoutEffect(() => () => (d == null ? void 0 : d()), [d]),
        P.jsxs(X8e, {
          paddingTop: f ? 56 : 0,
          ...p,
          children: [
            P.jsxs(Q8e, {
              children: [
                P.jsx(tCe, { children: e }),
                P.jsxs(rCe, {
                  children: [
                    P.jsx(je, {
                      font: 'heading4Bold',
                      align: 'center',
                      maxWidth: 420,
                      width: '100%',
                      children: t,
                    }),
                    n && typeof n == 'string'
                      ? P.jsx(je, {
                          font: 'body',
                          align: 'center',
                          maxWidth: 420,
                          width: '100%',
                          children: n,
                        })
                      : n,
                    r.map((K) => W.createElement(oCe, { ...K, key: K.key })),
                  ],
                }),
              ],
            }),
            P.jsx(Fi, {
              padded: !0,
              type: 'solid',
              direction: 'column',
              ...l,
              ...((l == null ? void 0 : l.checkbox) && {
                ...l.checkbox,
                label: { ...((F = l.checkbox) == null ? void 0 : F.label), font: void 0 },
              }),
              children: P.jsxs(P.Fragment, {
                children: [
                  (l == null ? void 0 : l.direction) === 'row' &&
                    j &&
                    P.jsx(on, { theme: 'secondary', onPress: k, ...x }),
                  P.jsx(on, { theme: 'primary', onPress: w, ...o, 'data-testid': o.testID }),
                  ['column', void 0].includes(l == null ? void 0 : l.direction) &&
                    j &&
                    P.jsx(on, { onPress: k, theme: 'transparent', ...x, 'data-testid': x.testID }),
                ],
              }),
            }),
          ],
        })
      );
    }
  );
Kn.memo(({ onVerify: e, onReset: t, image: n, show: r }) => {
  const { t: i } = Ct(),
    s = Un(),
    [o, a] = W.useState(!1),
    c = W.useRef(!1);
  W.useEffect(() => {
    r && !c.current && (s.capture('seedlessVerifyPinInterstitialDisplayed'), (c.current = !0));
  }, [r, o, s]);
  const u = W.useCallback(() => {
      a(!0), e(), s.capture('seedlessVerifyPinInterstitialVerifyButtonClicked');
    }, [e, s]),
    l = W.useCallback(() => {
      a(!0), t(), s.capture('seedlessVerifyPinInterstitialResetButtonClicked');
    }, [t, s]),
    d = W.useMemo(
      () => ({
        title: i('seedlessVerifyPinInterstitialTitle'),
        items: [
          {
            key: 'pin-verification-interstitial-1',
            icon: P.jsx(Lg, {
              icon: 'Key',
              backgroundColor: 'bgWallet',
              color: 'white',
              shape: 'square',
            }),
            title: i('seedlessVerifyPinInterstitialProp1Title'),
            description: i('seedlessVerifyPinInterstitialProp1Description'),
          },
          {
            key: 'pin-verification-interstitial-2',
            icon: P.jsx(Lg, {
              icon: 'Leaf',
              backgroundColor: 'bgWallet',
              color: 'white',
              shape: 'square',
            }),
            title: i('seedlessVerifyPinInterstitialProp2Title'),
            description: i('seedlessVerifyPinInterstitialProp2Description'),
          },
          {
            key: 'pin-verification-interstitial-3',
            icon: P.jsx(Lg, {
              icon: 'BookOpen',
              backgroundColor: 'bgWallet',
              color: 'white',
              shape: 'square',
            }),
            title: i('seedlessVerifyPinInterstitialProp3Title'),
            description: i('seedlessVerifyPinInterstitialProp3Description'),
          },
        ],
        primaryButton: {
          theme: 'primary',
          children: i('seedlessVerifyPinInterstitialVerifyButtonText'),
          onAction: u,
          testID: 'verify-pin-interstitial-verify-button',
          analyticsEvent: { event: 'seedlessVerifyPinInterstitialVerifyButtonClicked' },
        },
        secondaryButton: {
          theme: 'secondary',
          children: i('seedlessVerifyPinInterstitialResetButtonText'),
          onAction: l,
          testID: 'verify-pin-interstitial-reset-button',
          analyticsEvent: { event: 'seedlessVerifyPinInterstitialResetButtonClicked' },
        },
        image: n,
        displayEvent: { event: 'seedlessVerifyPinInterstitialDisplayed' },
      }),
      [i, u, l, n]
    );
  return r ? P.jsx(aCe, { ...d, footer: { type: 'transparent' } }) : null;
});
const Mj = ({
  width: e,
  trackColor: t = Le.colors.legacy.bgArea,
  spinnerColor: n = Le.colors.legacy.accentPrimary,
}) =>
  P.jsxs('svg', {
    width: e,
    height: e,
    viewBox: '0 0 26 26',
    children: [
      P.jsx('g', {
        children: P.jsx('path', {
          fillRule: 'evenodd',
          clipRule: 'evenodd',
          d: 'M13 23.413c5.751 0 10.413-4.662 10.413-10.413S18.751 2.587 13 2.587 2.587 7.249 2.587 13 7.249 23.413 13 23.413zm0 2.315c7.03 0 12.727-5.699 12.727-12.728S20.03.273 13 .273C5.97.273.273 5.97.273 13 .273 20.03 5.97 25.728 13 25.728z',
          fill: t,
        }),
      }),
      P.jsx('g', {
        children: P.jsx('path', {
          fillRule: 'evenodd',
          clipRule: 'evenodd',
          d: 'M16.382 24.125a1.157 1.157 0 01.623-1.513 10.412 10.412 0 005.607-13.617 1.157 1.157 0 112.136-.89 12.726 12.726 0 01-6.853 16.643 1.157 1.157 0 01-1.513-.623z',
          fill: n,
        }),
      }),
    ],
  });
Mj.defaultProps = { width: 44 };
const Oj = ({ diameter: e, color: t, trackColor: n, position: r }) =>
  P.jsxs(P.Fragment, {
    children: [
      P.jsx('style', {
        children: `@keyframes rotate {
            100% {
              transform: rotate(360deg);
            }
          }`,
      }),
      P.jsx('div', {
        style: {
          position: r,
          width: `${e}px`,
          height: `${e}px`,
          animation: 'rotate 0.5s linear infinite',
        },
        children: P.jsx(Mj, { width: e, spinnerColor: t, trackColor: n }),
      }),
    ],
  });
Oj.defaultProps = { diameter: 44 };
var iA = ((e) => ((e.Open = 'Open'), (e.Closed = 'Closed'), (e.Reset = 'Reset'), e))(iA || {});
const XC = 'AUTH_CALLBACK:';
function cCe(e) {
  return e.startsWith(XC) ? e.slice(XC.length) : null;
}
const QC = { width: 500, height: 500 },
  uCe = (e, t) => {
    const n = setInterval(() => {
      e.closed && (clearInterval(n), t('Popup closed'));
    }, 1e3);
    return () => clearInterval(n);
  };
function lCe(e, t, n) {
  const r = screen.width,
    i = screen.height,
    s = r / 2 - t / 2,
    o = i / 2 - n / 2,
    a = window.open(
      e,
      '_blank',
      `scrollbars=yes, width=${t}, height=${n}, top=${o}, left=${s}, location=no, toolbar=no`
    );
  return a != null && a.focus && a.focus(), a;
}
const dCe = async (e, t, n) => {
    const r = lCe(t, QC.width, QC.height);
    if (!r) throw new Error('Login popup was blocked.');
    return new Promise((i, s) => {
      const o = uCe(r, s),
        a = (c) => {
          if (typeof c.data != 'string') return;
          const u = cCe(c.data);
          if (!u) return;
          const l = new URL(u);
          if (l.origin !== window.location.origin) throw new Error('Invalid redirect URL origin');
          const d = l.searchParams.get('code');
          d && (r.close(), o(), window.removeEventListener('message', a), i(d));
        };
      window.addEventListener('message', a);
    });
  },
  fCe = { getClientID: () => r4, redirectURL: t4, fetchAuthorizationCode: dCe },
  hCe = {
    storage: Xn,
    authConfig: fCe,
    queryClient: Ec,
    runExclusive: async (e) => window.navigator.locks.request('AUTH_LOCK', e),
    isServerTimeEnabled: () => !ms.isFeatureEnabled('kill-frontend-server-time'),
  },
  Bj = NM(hCe),
  pCe = (e, t) => {
    const n = new zP();
    n.load(e, t, { configUrl: `${t}/sourceConfig` });
    try {
      return new ZO(n);
    } catch {
      return console.error('Failed to initialize rudderstack.'), YO();
    }
  },
  X1 = qO({ storage: Xn, rudderStackKey: JO, createAnalytics: pCe });
Bj.subscribe(Yo.UserID, (e) => {
  re.addBreadcrumb(ce.Generic, `Auth userID: ${e}`, Ie.Info),
    X1.addUserProperties({ authUserId: e });
});
let sS;
const gCe = nc.getInstance(),
  yCe = async () => (sS || (sS = new l7(new rN())), Promise.resolve(sS)),
  bCe = { storage: gCe, authRepository: Bj, juiceboxClient: yCe },
  Q1 = V7(bCe);
Q1.subscribe(ys.RotationResult, ({ type: e, didRotate: t }) => {
  X1.capture('seedlessBundleRotationResult', { data: { type: e, didRotate: t } });
});
Q1.subscribe(ys.RecoverResult, ({ type: e, reason: t }) => {
  X1.capture('seedlessBundleRecoverResult', { data: { type: e, reason: t } });
});
Q1.subscribe(ys.BackupResult, ({ type: e, didBackup: t }) => {
  X1.capture('seedlessBundleBackupResult', { data: { type: e, didBackup: t } });
});
class mCe {
  constructor(t) {
    ae(this, 'storage');
    ae(this, 'seedlessRepository');
    (this.storage = t.storage), (this.seedlessRepository = t.seedlessRepository);
  }
  async getDeviceEncryptionKey() {
    return await this.seedlessRepository.getDeviceEncryptionKey();
  }
  async rotateEncryptionKey(t) {
    const n = await this.seedlessRepository.generateDeviceEncryptionKey();
    return t(
      n,
      async (r, i) => (
        await this.storage.setAll(r), await this.seedlessRepository.setDeviceEncryptionKey(n), !0
      )
    );
  }
}
let oS;
const wCe = nc.getInstance(),
  vCe = async () => (oS || (oS = new l7(new rN())), Promise.resolve(oS)),
  _Ce = { storage: wCe, authRepository: Ad, juiceboxClient: vCe },
  Up = V7(_Ce);
Up.subscribe(ys.RotationResult, ({ type: e, didRotate: t }) => {
  rc.capture('seedlessBundleRotationResult', { data: { type: e, didRotate: t } });
});
Up.subscribe(ys.RecoverResult, ({ type: e, reason: t }) => {
  rc.capture('seedlessBundleRecoverResult', { data: { type: e, reason: t } });
});
Up.subscribe(ys.BackupResult, ({ type: e, didBackup: t }) => {
  rc.capture('seedlessBundleBackupResult', { data: { type: e, didBackup: t } });
});
const SCe = ({ children: e }) => P.jsx(kme, { seedlessRepository: Up, children: e }),
  eP = nL.fromStorage(Xn, new mCe({ storage: Xn, seedlessRepository: Up }));
async function tP() {
  return Promise.resolve(an(at.UnsupportedOperation));
}
const ECe = (e) => {
    const t = new rL(),
      n = new CH({
        [Kr.KeyPair]: {
          [G.EVM]: tV(),
          [G.Solana]: HV(),
          [G.BitcoinTaproot]: Vp(),
          [G.BitcoinNativeSegwit]: Vp(),
          [G.BitcoinNestedSegwit]: Vp(),
          [G.BitcoinLegacy]: Vp(),
          [G.Sui]: kH(),
          JWT: WV(),
          Agent: KK(),
          Cash: eV(),
        },
        [Kr.Ledger]: { type: Kr.Ledger, sign: tP },
        [Kr.SeedVault]: { type: Kr.SeedVault, sign: tP },
      }),
      r = {
        generalStorage: e,
        secretsStorage: eP,
        secureCache: PH({ isEnabled: () => !0, generalStorage: e, secretsStorage: eP }),
        fetchChainAvailability: () => lA(e),
        keypairGenerator: t,
        vaultSigner: n,
      };
    return Wq(r);
  },
  Ht = ECe(Xn),
  ACe = {
    addAccountForSeed: async (e) => {
      const t = await Ht.fetchAllSeedMetas();
      if (t.length === 0) throw new Error('No se*d available in Vault');
      if (!t.find((r) => r.identifier === e))
        throw new Error(`No se*d available in Vault with ID: ${e}`);
      return Ht.addAccountForExistingSeed(e);
    },
    addReadonlyAccount: Ht.addReadonlyAccount,
    importPrivateKeyAccount: Ht.addPrivateKeyAccount,
    connectLedgerAccounts: Ht.addLedgerAccounts,
    connectSolanaSeedVaultAccounts: Ht.addSolanaSeedVaultAccounts,
    fetchAllAccounts: Ht.fetchAllAccounts,
    fetchAllSeedMetas: Ht.fetchAllSeedMetas,
    fetchAllSeedlessMetas: Ht.fetchAllSeedlessMetas,
    deriveAddresses: Ht.deriveAddresses,
    removeAccount: Ht.removeAccount,
    reorderAccount: Ht.reorderAccount,
    sign: Ht.sign,
    getAuthenticationPublicKey: Ht.getAuthenticationPublicKey,
    syncAccounts: Ht.syncAccounts,
    addAccountForSeedless: Ht.addAccountForExistingSeedless,
    checkVaultIntegrity: Ht.checkVaultIntegrity,
    getCashAddress: Ht.getCashAddress,
    getAgentAddress: Ht.getAgentAddress,
  };
function ICe({ children: e }) {
  return P.jsx(FY, { vault: ACe, children: e });
}
const nP = (e) => {
    window.parent.postMessage(e, '*');
  },
  Dj = ['embedded-wallet-recovery-flow-has-seedless-bundle'],
  TCe = () => Qt({ queryKey: Dj, queryFn: () => Q1.hasSeedlessBundle() }),
  xCe = () => {
    const { t: e } = Ct(),
      t = wA(),
      n = Un(),
      { data: r = !1, isLoading: i, isError: s } = TCe(),
      o = w4(),
      a = () => {
        Ht.deriveAddresses(),
          o({ result: { success: !0 } }),
          t.pop(),
          Ec.resetQueries({ queryKey: Dj }),
          r
            ? n.capture('reonboardingDone', { data: { onboardingType: ME.SeedlessRecover } })
            : n.capture('onboardingDone', { data: { onboardingType: ME.SeedlessBackup } });
      },
      c = () => {
        o({ error: iL(1).error }), t.pop();
      };
    return i || r === void 0
      ? P.jsx('div', {
          className: yr({
            display: 'flex',
            height: '100%',
            width: '100%',
            alignItems: 'center',
            justifyContent: 'center',
          }),
          children: P.jsx(Oj, {}),
        })
      : s
        ? P.jsxs(ye, {
            width: '100%',
            height: '100%',
            alignItems: 'center',
            justifyContent: 'center',
            gap: 'list',
            padding: 'screen',
            children: [
              P.jsx(je, {
                font: 'heading3Semibold',
                children: e('errorAndOfflineSomethingWentWrong'),
              }),
              P.jsx(je, {
                font: 'caption',
                color: 'textSecondary',
                align: 'center',
                children: e('seedlessAuthUnknownErrorTextRefresh'),
              }),
            ],
          })
        : r
          ? P.jsx(K8e, { onClose: () => nP(iA.Closed), onCancel: c, onFinished: a, vault: Ht })
          : P.jsx(W8e, { onClose: () => nP(iA.Closed), onFinished: a, vault: Ht });
  },
  kCe = () => {
    const e = wA(),
      t = KP(),
      { networkID: n, transactionUnitAmount: r } = t,
      i = () => {
        e.pop();
      };
    return n ? P.jsx(Gbe, { networkID: n, onClose: i, transactionUnitAmount: r }) : null;
  },
  CCe = XL({
    id: 'main',
    initialViewId: 'empty',
    views: [
      { id: 'empty', element: null },
      { id: 'notification', params: { userApproveRequest: g.any() }, element: P.jsx(hme, {}) },
      {
        id: 'transactionSettings',
        params: { networkID: g.string(), transactionUnitAmount: g.any() },
        element: P.jsx(kCe, {}),
      },
      { id: 'recover-account', element: P.jsx(xCe, {}) },
    ],
  }),
  PCe = () => P.jsx('div', { children: ' 404 Page not found ' }),
  Rj = QL({
    errorElement: P.jsx(PCe, {}),
    type: 'single',
    stack: CCe,
    css: { mainContent: yr({ height: '100%' }), root: yr({ height: '100%' }) },
  }),
  aS = tU(Rj),
  MCe = () => {
    const e = EZ();
    return W.useMemo(() => {
      const t = AJ.safeParse(e);
      return t.success ? t.data : (console.error('error parsing rpc message', t.error), null);
    }, [e]);
  },
  OCe = () => {
    const e = MCe();
    return (
      W.useEffect(() => {
        function t() {
          if (!e) {
            aS.to('empty');
            return;
          }
          switch (e == null ? void 0 : e.method) {
            case ci.recoverAccount:
              return void aS.to('recover-account');
            case ci.userApprove:
              return void aS.to('notification', { params: { userApproveRequest: e.params } });
            case ci.fetchAllAccounts:
            case ci.checkVaultIntegrity:
            case ci.sign:
              return null;
          }
        }
        t();
      }, [e]),
      P.jsxs(Kn.StrictMode, {
        children: [
          P.jsx('div', { className: IJ, children: P.jsx(eU, { router: Rj }) }),
          P.jsx(_J, {}),
        ],
      })
    );
  },
  BCe = ({ children: e }) => {
    const t = new URLSearchParams(window.location.search).get('dappURL');
    return (
      W.useEffect(() => {
        t && rc.addUserProperties({ embeddedDappOrigin: t });
      }, [t]),
      P.jsx(xz, { analytics: rc, children: e })
    );
  },
  DCe = async (e) => {
    try {
      const t = e[0];
      if (await Ad.getUser()) return { result: 'authorized' };
      const { url: r, codeVerifier: i } = await kM(Zb, Yb, {
          type: 'session',
          existingAccessToken: t,
        }),
        s = new URLSearchParams(window.location.search).get('dappURL');
      return (
        await Xn.set(i4, s),
        await Xn.set(US, i),
        (window.location.href = r),
        { result: 'authorization-started' }
      );
    } catch (t) {
      return t instanceof Error
        ? (re.captureError(t, ce.Auth), { error: { code: vx.Unauthorized, message: t.message } })
        : (re.captureError(new Error('Unable to authorize signer.'), ce.Auth),
          { error: { code: vx.Unauthorized, message: 'Unable to authorize signer.' } });
    }
  },
  RCe = async (e) => {
    const { accountIdentifier: t, vaultSignerParams: n } = e[0];
    return { result: await Ht.sign(t, n) };
  },
  NCe = async (e) => {
    if (e.method === ci.authorizeSigner) {
      const t = SJ.parse(e.params);
      return DCe(t);
    }
    if (e.method === ci.fetchAllAccounts) return { result: await Ht.fetchAllAccounts() };
    if (e.method === ci.checkVaultIntegrity) return { result: await Ht.checkVaultIntegrity() };
    if (e.method === ci.sign) {
      const t = EJ.parse(e.params);
      return RCe(t);
    }
    return e.method === ci.logOut
      ? (await Xn.clear(), Ec.clear(), { result: 'success' })
      : { error: { code: -32e3, message: 'Method not found' } };
  },
  fb = new _Z(() => window.parent, NCe, new URL(e4).origin, n4),
  jCe = async () => {
    const e = [...sL, 'enable-monad'],
      t = [];
    t.push(new oL(e)), ms.setProviders(t), await ms.initializeFeatureFlags();
  },
  LCe = {
    init: async () => {},
    downloadLog: async (e) => {},
    getRecentLogs: async () => Promise.resolve(''),
    write: (e, t, n, r) => {},
    getLogFilePaths: () => {
      throw new Error(_x);
    },
    sendLogFilesByEmail: (e) => {
      throw new Error(_x);
    },
  };
async function UCe() {
  await aL.init({ provider: LCe }),
    await re.init({
      appVersion: fd,
      sentry: { enabled: !1 },
      datadog: {
        enabled: !0,
        clientToken: 'pubf4dfb4e9016d7a11cef2cab4d41ee6ef',
        applicationId: '15db1fc2-d5c5-4a30-b635-cbfa642030c0',
        service: 'embedded-web',
        traceSampleRate: 100,
        sessionSampleRate: 100,
      },
    });
}
const $Ce = async (e) => {
  const t = new URL(e);
  if (t.pathname.startsWith('/callback'))
    try {
      rP('Authorizing signer from OAuth redirect.');
      const n = t.searchParams.get('error');
      if (n) {
        const c = t.searchParams.get('error_description');
        throw new Error(`Unable to authorize signer. Error: ${n} ${c}`);
      }
      const r = t.searchParams.get('code');
      if (!r) throw new Error('Unable to authorize signer. No authorization code found.');
      const i = await Xn.get(i4);
      if (!i) throw new Error('Unable to authorize signer. No dapp URL found.');
      const s = new URL(t.href.split('?')[0]);
      s.searchParams.append('dappURL', i), window.history.replaceState(null, '', s.toString());
      const o = await Xn.get(US);
      if (!o) throw new Error('Unable to authorize signer. No code verifier found.');
      const a = await BA({
        grantType: 'authorization_code',
        clientID: Zb,
        redirectURI: Yb,
        tokenEndpoint: OA(),
        code: r,
        codeVerifier: o,
      });
      rP('OAuth2 token authorization complete. Signer authorized.'),
        await Xn.set('.phantom.auth.tokens', a),
        await fb.authorizeSuccess(),
        await Tz(Ec);
    } catch (n) {
      re.captureError(n instanceof Error ? n : new Error('Unable to authorize signer.'), ce.Auth),
        await fb.authorizeFailed();
    } finally {
      await Xn.remove(US);
    }
};
function rP(e) {
  re.addBreadcrumb(ce.Auth, e, Ie.Debug);
}
const FCe = async () => {
    const e = KCe();
    zCe(), await e;
  },
  zCe = () => {
    IY();
  },
  KCe = async () => {
    await fb.start(),
      await UCe(),
      await jCe(),
      await $Ce(window.location.href),
      await Sx(ze.Monad, Xn),
      await Sx(ze.Sui, Xn),
      await cL(G.Sui, Xn);
  },
  Nj = {
    signMessages: function () {
      throw new Error('Function not implemented.');
    },
    getBatchAccountMetadata: function () {
      throw new Error('Function not implemented.');
    },
    getAccountMetadata: function () {
      throw new Error('Function not implemented.');
    },
    storeSyncedAccounts: function () {
      throw new Error('Function not implemented.');
    },
  },
  VCe = _$({ authRepository: Ad, claimUsernameSigner: Nj, queryClient: Ec }),
  WCe = ({ children: e }) =>
    P.jsx(kz, { userRepository: VCe, claimUsernameSigner: Nj, children: e });
FCe().finally(() => {
  const e = document.getElementById('root');
  VP(e).render(P.jsx(HCe, {}));
});
const HCe = () =>
  P.jsx(uL, {
    contexts: [[SP, cZ]],
    children: P.jsx(a9, {
      children: P.jsx(ICe, {
        children: P.jsx(BY, {
          children: P.jsx(WCe, {
            children: P.jsx(SCe, {
              children: P.jsx(CY, {
                children: P.jsx(lL, {
                  children: P.jsx(BCe, {
                    children: P.jsx(aZ, {
                      children: P.jsx(SZ, { receiver: fb, children: P.jsx(OCe, {}) }),
                    }),
                  }),
                }),
              }),
            }),
          }),
        }),
      }),
    }),
  });
