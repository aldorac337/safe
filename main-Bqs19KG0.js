const __vite__mapDeps = (
  i,
  m = __vite__mapDeps,
  d = m.f ||
    (m.f = [
      'assets/phantomRpc-roQOrxiJ.js',
      'assets/phantomUiDeps-DRT5vvX7.js',
      'assets/lodash-aFjP5OGs.js',
      'assets/chainSolana-C0WbUUwF.js',
      'assets/metaplex-DKWSQMdM.js',
      'assets/metaplexMplTokenMetadata-B1auuVGR.js',
      'assets/react-6iN9_IA6.js',
      'assets/phantomUi-BnOIPQCj.js',
      'assets/phantomUi-D1Ruostj.css',
      'assets/chainBitcoin-8-XOceRu.js',
      'assets/chainEthereum-DCLFWD03.js',
      'assets/metaplexUmi-B-YFAY88.js',
      'assets/metaplexMplCore-DwiB1C7D.js',
      'assets/analytics-CTNVS3Vq.js',
      'assets/Settings-BTUYJ3_j.js',
      'assets/stackRouter-nhyjVX3l.js',
      'assets/useResetApp-DlunfjX9.js',
      'assets/channel-CAyBJUId.js',
      'assets/chainSui-C-6FVPxt.js',
      'assets/Detail-DhR_E8Fp.js',
      'assets/Main-CCQne_M2.js',
      'assets/FiatRampFlow-Cnxiw7mF.js',
      'assets/FiatRampFormPage-CIxSaPC5.js',
      'assets/LocalizedPrice-D9CZ0cJH.js',
      'assets/fiatRamp.css-Dahi6964.js',
      'assets/fiatRamp-BC3m6p3j.css',
      'assets/FiatRampContainer-bdnLYjMB.js',
      'assets/FiatRampPaymentMethodsPage-BPFqGbbQ.js',
      'assets/FiatRampProvidersPage-BKDihMc9.js',
      'assets/FiatRampFlowPreselectedToken-Cmw5N1ME.js',
      'assets/FiatRampWaitingOnRamp-DDhePt7W.js',
      'assets/FiatRampRedirectToProvider-Bu1S6Nm9.js',
      'assets/Notification-CamjllPl.js',
      'assets/SignerView-1Sz2IcE5.js',
      'assets/Login-CR3QJ4Cf.js',
      'assets/Receive-CyVcfMeb.js',
      'assets/RestoreAccount-DQzzB3Yq.js',
      'assets/SendFungibleFlow-C3qfpO-l.js',
      'assets/browser-polyfill--SpK_K58.js',
      'assets/Detail-DYgNoey5.js',
      'assets/DeeperDetail-jCc0xBUN.js',
      'assets/Main-_NLdofUY.js',
      'assets/Detail-B4_T2DSY.js',
    ])
) => i.map((i) => d[i]);
var o3 = Object.defineProperty;
var Bw = (e) => {
  throw TypeError(e);
};
var a3 = (e, t, n) =>
  t in e ? o3(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (e[t] = n);
var Le = (e, t, n) => a3(e, typeof t != 'symbol' ? t + '' : t, n),
  jw = (e, t, n) => t.has(e) || Bw('Cannot ' + n);
var ue = (e, t, n) => (jw(e, t, 'read from private field'), n ? n.call(e) : t.get(e)),
  _t = (e, t, n) =>
    t.has(e)
      ? Bw('Cannot add the same private member more than once')
      : t instanceof WeakSet
        ? t.add(e)
        : t.set(e, n),
  mt = (e, t, n, r) => (jw(e, t, 'write to private field'), r ? r.call(e, n) : t.set(e, n), n);
import { p as s3 } from './channel-CAyBJUId.js';
import {
  h as cm,
  l as ic,
  V as vc,
  P as E0,
  m as c3,
  j as A,
  n as u3,
  g as l3,
  B as d3,
  S as Gh,
  o as f3,
  D as Ty,
  a as ft,
  I as h3,
  t as p3,
  p as g3,
  M as y3,
  q as T0,
  u as b3,
  r as m3,
  F as Dt,
  s as w3,
  v as _3,
  w as v3,
  T as Lt,
  x as S3,
  y as k0,
  z as A3,
  C as cc,
  E as I3,
  G as E3,
  H as T3,
  L as Nw,
  f as k3,
  J as C3,
  R as YA,
  K as M3,
  N as P3,
  O as O3,
  Q as Se,
  U as D3,
  W as R3,
  X as x3,
  Y as B3,
  Z as j3,
  $ as N3,
  a0 as U3,
  a1 as Uw,
  a2 as L3,
  a3 as z3,
  a4 as F3,
  a5 as $3,
} from './phantomUi-BnOIPQCj.js';
import { a as W3, r as G, R as Ue } from './react-6iN9_IA6.js';
import {
  z as h,
  i as Et,
  B as ZA,
  b as V3,
  c as K3,
  d as Ki,
  u as ia,
  Z as C0,
  W as H3,
  A as q3,
  L as G3,
} from './phantomUiDeps-DRT5vvX7.js';
import {
  A as Lw,
  B as zw,
  E as um,
  H as Fw,
  P as $w,
  S as Hi,
  a as Aa,
  C as Sc,
  b as Oe,
  c as Ac,
  t as ae,
  d as q,
  e as Cp,
  N as ce,
  D as ct,
  f as X,
  g as br,
  h as Y3,
  i as kh,
  M as ky,
  j as QA,
  k as JA,
  l as XA,
  m as Sn,
  n as Z3,
  o as eI,
  p as tI,
  q as Q3,
  r as oa,
  Z as M0,
  s as Mp,
  u as J3,
  v as Ic,
  w as Pp,
  x as nI,
  y as X3,
  z as Z,
  F as te,
  G as Te,
  I as P0,
  J as Xi,
  K as pt,
  L as Un,
  O as O0,
  Q as e2,
  R as t2,
  T as n2,
  U as r2,
  V as rI,
  W as Br,
  X as lm,
  Y as iI,
  _ as i2,
  $ as o2,
  a0 as so,
  a1 as D0,
  a2,
  a3 as R0,
  a4 as s2,
  a5 as c2,
  a6 as u2,
  a7 as Ww,
  a8 as oI,
  a9 as l2,
  aa as d2,
  ab as f2,
  ac as h2,
  ad as p2,
  ae as g2,
  af as Vw,
  ag as y2,
  ah as aI,
  ai as Kw,
  aj as sI,
  ak as Ec,
  al as Tc,
  am as b2,
  an as Yh,
  ao as An,
  ap as cI,
  aq as m2,
  ar as w2,
  as as _2,
  at as dm,
  au as uI,
  av as lI,
  aw as dI,
  ax as Zh,
  ay as sn,
  az as v2,
  aA as S2,
  aB as A2,
  aC as I2,
  aD as E2,
  aE as Xe,
  aF as Cy,
  aG as Dr,
  aH as Hw,
  aI as x0,
  aJ as eo,
  aK as T2,
  aL as k2,
  aM as C2,
  aN as M2,
  aO as P2,
  aP as O2,
  aQ as D2,
  aR as Op,
  aS as B0,
  aT as R2,
  aU as x2,
  aV as to,
  aW as B2,
  aX as Dp,
  aY as j2,
  aZ as Rp,
  a_ as fI,
  a$ as hI,
  b0 as pI,
  b1 as gI,
  b2 as qw,
  b3 as N2,
  b4 as U2,
  b5 as L2,
  b6 as Zr,
  b7 as Qh,
  b8 as z2,
  b9 as j0,
  ba as F2,
  bb as N0,
  bc as Gw,
  bd as My,
  be as $2,
  bf as W2,
  bg as V2,
  bh as K2,
  bi as U0,
  bj as H2,
  bk as q2,
  bl as G2,
  bm as Y2,
  bn as Z2,
  bo as Q2,
  bp as J2,
  bq as fm,
  br as yI,
  bs as Yw,
  bt as X2,
  bu as e4,
  bv as t4,
} from './phantomRpc-roQOrxiJ.js';
import {
  h as Ae,
  B as Y,
  ac as n4,
  ay as r4,
  az as bI,
  r as i4,
  f as o4,
  g as Jh,
  n as un,
  s as me,
  i as we,
  j as qn,
  u as et,
  k as fn,
  o as No,
  l as kc,
  q as L0,
  m as se,
  v as Mt,
  x as ne,
  z as ge,
  A as pe,
  y as U,
  C as Ce,
  E as mI,
  F as Pn,
  D as fi,
  H as ar,
  I as wI,
  b as It,
  K as Zw,
  p as z0,
  w as Cc,
  L as a4,
  G as le,
  P as s4,
  t as c4,
  a as _I,
  _ as F0,
  $ as u4,
  a0 as l4,
  a1 as d4,
  a2 as f4,
  a3 as h4,
  a4 as p4,
  a6 as W,
  a7 as st,
  aA as xe,
  aB as g4,
  J as rn,
  O as hm,
  af as y4,
} from './metaplex-DKWSQMdM.js';
import {
  P as Ye,
  C as Py,
  r as b4,
  A as Qw,
  t as $0,
  u as Mc,
  v as m4,
  V as xp,
  T as Pc,
  K as w4,
  w as Bp,
  q as jp,
  S as _4,
  x as v4,
  y as S4,
  z as vI,
  B as A4,
  D as I4,
  E as E4,
  F as T4,
  G as k4,
  H as C4,
} from './chainSolana-C0WbUUwF.js';
import {
  h as M4,
  a as P4,
  t as O4,
  s as Zt,
  f as D4,
  T as R4,
  b as SI,
  c as x4,
  d as B4,
} from './chainBitcoin-8-XOceRu.js';
import {
  n as j4,
  W as N4,
  C as Jw,
  V as U4,
  s as L4,
  a as z4,
  b as Xw,
} from './chainEthereum-DCLFWD03.js';
import { c as g, g as Oc, a as AI } from './lodash-aFjP5OGs.js';
import { _ as Rt, R as F4, y as $4 } from './analytics-CTNVS3Vq.js';
import { B as oe, r as gt } from './metaplexMplTokenMetadata-B1auuVGR.js';
import {
  S as II,
  T as fs,
  c as W4,
  H as EI,
  a as Oy,
  e as Xh,
  t as TI,
  o as V4,
  w as kI,
  u as We,
  r as CI,
  s as Oa,
  b as Sr,
  h as K4,
  d as H4,
  f as q4,
  g as Wa,
  i as pm,
  n as MI,
  j as PI,
  k as OI,
  l as no,
  P as G4,
  m as Vt,
  p as Y4,
  q as Z4,
} from './chainSui-C-6FVPxt.js';
import { t as Q4, c as J4 } from './metaplexUmi-B-YFAY88.js';
import { j as Ch, p as gm, k as X4, m as e6 } from './metaplexMplCore-DwiB1C7D.js';
import { u as W0, c as Qn, a as t6, b as n6, d as hs, S as r6 } from './stackRouter-nhyjVX3l.js';
var DI,
  e_ = W3;
(DI = e_.createRoot), e_.hydrateRoot;
const ps = {},
  i6 = {
    ...ps,
    defaultExplorer: 'arbiscan',
    getExplorerUrl: function (e) {
      let t;
      switch (e) {
        case Lw.Sepolia:
          t = 'sepolia.';
          break;
        case Lw.Mainnet:
        default:
          t = '';
      }
      return {
        arbiscan: (n, r) => {
          const i = Array.isArray(r) ? r.join('/') : r,
            o = { transaction: 'tx', address: 'address', token: 'token', nft: 'nft' }[n];
          return `https://${t}arbiscan.io/${o}/${i}`;
        },
      };
    },
  },
  o6 = {
    ...ps,
    defaultExplorer: 'basescan',
    getExplorerUrl: function (e) {
      let t;
      switch (e) {
        case zw.Sepolia:
          t = 'sepolia.';
          break;
        case zw.Mainnet:
        default:
          t = '';
      }
      return {
        basescan: (n, r) => {
          const i = Array.isArray(r) ? r.join('/') : r,
            o = { transaction: 'tx', address: 'address', token: 'token', nft: 'nft' }[n];
          return `https://${t}basescan.org/${o}/${i}`;
        },
      };
    },
  },
  a6 = {
    getExplorerUrl: function () {
      return {
        mempool: (e, t) =>
          `https://mempool.space/${{ transaction: 'tx', address: 'address' }[e]}/${t}`,
      };
    },
    defaultExplorer: 'mempool',
  },
  s6 = {
    ...ps,
    getExplorerUrl(e) {
      let t;
      switch (e) {
        case um.Sepolia:
          t = 'sepolia.';
          break;
        case um.Mainnet:
        default:
          t = '';
      }
      return {
        etherscan: (n, r) => {
          const i = Array.isArray(r) ? r.join('/') : r,
            o = { transaction: 'tx', address: 'address', token: 'token', nft: 'nft' }[n];
          return `https://${t}etherscan.io/${o}/${i}`;
        },
      };
    },
    defaultExplorer: 'etherscan',
  },
  c6 = {
    ...ps,
    defaultExplorer: 'hyperliquid',
    getExplorerUrl: function (e) {
      let t;
      switch (e) {
        case Fw.Testnet:
          t = 'app.hyperliquid-testnet.xyz';
          break;
        case Fw.Mainnet:
        default:
          t = 'app.hyperliquid.xyz';
      }
      return {
        hyperliquid: (n, r) => {
          const i = Array.isArray(r) ? r.join('/') : r,
            o = { transaction: 'tx', address: 'address' }[n];
          return `https://${t}/explorer/${o}/${i}`;
        },
      };
    },
  },
  u6 = {
    ...ps,
    getExplorerUrl: function () {
      return {
        monadexplorer: (e, t) => {
          const n = Array.isArray(t) ? t.join('/') : t;
          return `https://testnet.monadexplorer.com/${{ transaction: 'tx', address: 'address', token: 'token', nft: 'nft' }[e]}/${n}`;
        },
      };
    },
    defaultExplorer: 'monadexplorer',
    betaTagOverride: 'Testnet',
  },
  l6 = {
    ...ps,
    getExplorerUrl: function (e) {
      let t;
      switch (e) {
        case $w.Amoy:
          t = 'amoy.';
          break;
        case $w.Mainnet:
        default:
          t = '';
      }
      return {
        polygonscan: (n, r) => {
          const i = Array.isArray(r) ? r.join('/') : r,
            o = { transaction: 'tx', address: 'address', token: 'token', nft: 'nft' }[n];
          return `https://${t}polygonscan.com/${o}/${i}`;
        },
      };
    },
    defaultExplorer: 'polygonscan',
  },
  d6 = {
    getExplorerUrl: function (e) {
      let t;
      switch (e) {
        case Hi.Devnet:
          t = 'devnet';
          break;
        case Hi.Testnet:
          t = 'testnet';
          break;
        case Hi.Mainnet:
          t = 'mainnet-beta';
          break;
        case Hi.Localnet:
          t = 'mainnet-beta';
          break;
      }
      let n = '';
      return (
        ['devnet', 'testnet'].includes(t) && (n = `?cluster=${t}`),
        {
          'solana-beach': (r, i) => `https://solanabeach.io/${r}/${i}${n}`,
          solscan: (r, i) =>
            `https://solscan.io/${{ transaction: 'tx', address: 'account' }[r]}/${i}${n}`,
          'solana-explorer': (r, i) => `https://explorer.solana.com/${r}/${i}${n}`,
          'solana-fm': (r, i) => {
            const o = {
              'mainnet-beta': 'mainnet-qn1',
              testnet: 'testnet-solana',
              devnet: 'devnet-solana',
              localhost: 'localhost',
            }[t];
            return `https://solana.fm/${{ transaction: 'tx', address: 'address' }[r]}/${i}?cluster=${o}`;
          },
          xray: (r, i) =>
            `https://xray.helius.xyz/${{ transaction: 'tx', address: 'token' }[r]}/${i}${n}`,
        }
      );
    },
    defaultExplorer: 'solscan',
  },
  f6 = {
    getExplorerUrl: function (e) {
      return {
        suiscan: (t, n) => {
          let r;
          switch (e) {
            case Aa.Testnet:
              r = 'testnet';
              break;
            case Aa.Mainnet:
              r = 'mainnet';
              break;
          }
          const i = { transaction: 'tx', address: 'account', token: 'coin', nft: 'object' }[t];
          return `https://suiscan.xyz/${r}/${i}/${n}`;
        },
        suivision: (t, n) => {
          let r;
          switch (e) {
            case Aa.Testnet:
              r = 'testnet.';
              break;
            case Aa.Mainnet:
              r = '';
              break;
          }
          const i = { transaction: 'txblock', address: 'account', token: 'coin', nft: 'object' }[t];
          return `https://${r}suivision.xyz/${i}/${n}`;
        },
      };
    },
    defaultExplorer: 'suivision',
  },
  h6 = new Sc({
    [Oe.Solana]: d6,
    [Oe.Ethereum]: s6,
    [Oe.Polygon]: l6,
    [Oe.Monad]: u6,
    [Oe.Base]: o6,
    [Oe.Arbitrum]: i6,
    [Oe.Bitcoin]: a6,
    [Oe.Sui]: f6,
    [Oe.Hypercore]: c6,
  }),
  p6 = Ac(h6),
  mue = { version: 1, addresses: [] },
  wue = { version: 1, addresses: [] },
  _ue = 20,
  g6 = () => {
    const e = {};
    return (
      q.getAllNetworkIDs().forEach((t) => {
        const n = p6.get(t).defaultExplorer;
        n && (e[t] = n);
      }),
      e
    );
  },
  vue = { version: 1, explorers: g6() },
  y6 = { version: 1, apps: {} };
ae({ minutes: 15 });
const RI = [
  { value: 'en', displayValue: 'English', isLocale: !1 },
  { value: 'es', displayValue: 'Español', isLocale: !1 },
  { value: 'de', displayValue: 'Deutsch', isLocale: !1 },
  { value: 'fr', displayValue: 'Français', isLocale: !1 },
  { value: 'it', displayValue: 'Italiano', isLocale: !1 },
  { value: 'zh-CN', displayValue: '中文(简体)', isLocale: !0 },
  { value: 'zh-TW', displayValue: '中文(繁體)', isLocale: !0 },
  { value: 'bn', displayValue: 'বাংলা', isLocale: !1 },
  { value: 'ja', displayValue: '日本', isLocale: !1 },
  { value: 'ko', displayValue: '한국어', isLocale: !1 },
  { value: 'ru', displayValue: 'Pусский', isLocale: !1 },
  { value: 'hi', displayValue: 'हिंदी', isLocale: !1 },
  { value: 'id', displayValue: 'Indonesia', isLocale: !1 },
  { value: 'ms', displayValue: 'Melayu', isLocale: !1 },
  { value: 'th', displayValue: 'ไทย', isLocale: !1 },
  { value: 'vi', displayValue: 'Tiếng Việt', isLocale: !1 },
  { value: 'pt', displayValue: 'Português', isLocale: !1 },
  { value: 'tr', displayValue: 'Türkçe', isLocale: !1 },
  { value: 'fil', displayValue: 'Filipino', isLocale: !1 },
  { value: 'my', displayValue: 'မြန်မာဘာသာ', isLocale: !1 },
  { value: 'am', displayValue: 'አማርኛ', isLocale: !1 },
  { value: 'ar', displayValue: 'العربية', isLocale: !1 },
  { value: 'gu', displayValue: 'ગુજરાતી', isLocale: !1 },
  { value: 'ha', displayValue: 'Hausa', isLocale: !1 },
  { value: 'ig', displayValue: 'Ásụ̀sụ́ Ìgbò', isLocale: !1 },
  { value: 'pa', displayValue: 'ਪੰਜਾਬੀ', isLocale: !1 },
  { value: 'sw', displayValue: 'Kiswahili', isLocale: !1 },
  { value: 'ta', displayValue: 'தமிழ்', isLocale: !1 },
  { value: 'te', displayValue: 'తెలుగు', isLocale: !1 },
  { value: 'yo', displayValue: 'Èdè Yorùbá', isLocale: !1 },
];
Cp.UserExplorerPreferenceV2;
var V0 = ((e) => (
  (e.ApiEnvironment = 'apiEnvironment'),
  (e.EmojiSkinTone = 'emojiSkinTone'),
  (e.IsAnalyticsOptedOut = 'isAnalyticsOptedOut'),
  (e.SolanaActionsEnabled = 'solanaActionsEnabled'),
  (e.ShowWalletShortcuts = 'showWalletShortcuts'),
  (e.SelectedCurrency = 'selectedCurrency'),
  (e.SavedAddresses = 'savedAddresses'),
  (e.RecentAddressesBrowser = 'recentAddresses'),
  (e.RecentAddressesMobile = 'recentAddressesV2'),
  e
))(V0 || {});
V0.IsAnalyticsOptedOut;
var K0 = ((e) => (
  (e.Image = 'image'),
  (e.Emoji = 'emoji'),
  (e.ReadOnlyDefault = 'read-only-default'),
  (e.Default = 'default'),
  e
))(K0 || {});
const b6 = h.object({
  type: h.nativeEnum(K0),
  imageUrl: h.string().optional(),
  unicode: h.string().optional(),
});
var xI = ((e) => ((e.Ledger = 'ledger'), e))(xI || {}),
  BI = ((e) => ((e.BLE = 'ble'), e))(BI || {});
const m6 = h.object({
    version: h.literal(1),
    connectionType: h.nativeEnum(BI),
    deviceType: h.nativeEnum(xI),
    id: h.string().min(1),
    name: h.string().optional(),
    model: h.string().optional(),
  }),
  w6 = h.object({ value: h.number(), timestamp: h.number() });
h.object({
  name: h.string(),
  icon: b6.optional(),
  connectedDevices: m6.array().optional(),
  balance: w6.optional(),
});
K0.Default;
const _6 = { version: 1, isDeveloperMode: !1 },
  H0 = ce.Solana.Devnet,
  q0 = ce.Ethereum.Sepolia,
  jI = ce.Sui.Testnet;
function NI(e) {
  return { version: 1, setting: { [X.Solana]: H0, [X.EVM]: q0, ...(e ? { [X.Sui]: jI } : {}) } };
}
ct.Bip44RootSolana + '',
  ct.Bip44RootEthereum,
  ct.Bip44ChangeSolana + '',
  ct.Bip44Ethereum,
  ct.Bip44Solana + '',
  ct.Bip44EthereumSecondary,
  ct.DeprecatedSolana + '',
  ct.Bip44EthereumTertiary,
  ct.Bip44RootEthereum + '',
  ct.Bip44Ethereum + '',
  ct.Bip44EthereumSecondary + '',
  ct.Bip44EthereumTertiary + '',
  ct.BitcoinTaproot + '',
  ct.BitcoinNativeSegwit + '',
  ct.BitcoinNestedSegwit + '',
  ct.BitcoinLegacy + '',
  ct.Bip44Sui + '';
ct.Bip44RootSolana + '',
  ct.Bip44RootEthereum + '',
  ct.BitcoinTaproot + '',
  ct.BitcoinNativeSegwit + '',
  ct.BitcoinNestedSegwit + '',
  ct.BitcoinLegacy + '',
  ct.Bip44ChangeSolana + '',
  ct.Bip44Ethereum + '',
  ct.Bip44Solana + '',
  ct.Bip44EthereumSecondary + '',
  ct.DeprecatedSolana + '',
  ct.Bip44EthereumTertiary + '',
  ct.Bip44Sui + '';
const v6 = 'https://help.phantom.com/hc/en-us/articles/4406563212819',
  ym = (e, t) => {
    const n = br(e, t);
    switch (n) {
      case X.BitcoinTaproot:
      case X.BitcoinNativeSegwit:
      case X.BitcoinNestedSegwit:
      case X.BitcoinLegacy:
        return Y3.getDisplayName(n);
      default:
        return;
    }
  },
  S6 = {
    badge: (e, t, n) => (t.filter(kh).length <= 1 ? '' : (ym(e, n) ?? '')),
    showAddressTypeExplainer: (e) => e.filter(kh).length > 1,
    addressTooltipNetworkName: (e, t, n) =>
      n.filter(kh).length >= 2 ? (ym(e, t) ?? q.getChainName(e)) : q.getChainName(e),
  },
  A6 = {
    badge: (e, t) => {
      switch (e) {
        case ky.Devnet:
        case ky.Testnet:
          return q.getNetworkDefinition(e).shortName;
        case ky.Mainnet:
          return;
      }
    },
    networkNameOverride: () => 'Monad',
  },
  I6 = new Sc({
    [Oe.Solana]: {},
    [Oe.Ethereum]: {},
    [Oe.Polygon]: {},
    [Oe.Base]: {},
    [Oe.Arbitrum]: {},
    [Oe.Monad]: A6,
    [Oe.Bitcoin]: S6,
    [Oe.Sui]: {},
    [Oe.Hypercore]: {},
  }),
  E6 = Ac(I6);
h.string().regex(
  /^(root-derivation-path-group|(recommended|secondary|tertiary)-group:index-[0-9]+)$/,
  { message: 'Invalid derivation path group.' }
);
var ze = ((e) => (
  (e.Seed = 'seed'),
  (e.PrivateKey = 'privateKey'),
  (e.Ledger = 'ledger'),
  (e.SeedVault = 'seedVault'),
  (e.ReadOnly = 'readOnly'),
  (e.Seedless = 'seedless'),
  e
))(ze || {});
h.object({
  derivationIndex: h.number(),
  addresses: h.array(h.object({ pathType: h.union([QA, JA]), value: h.string() })),
  publicKeys: h.array(h.object({ pathType: XA, value: h.string() })),
});
const T6 = h.union([h.literal('unonboarded'), h.literal('unable-to-load-accounts')]),
  k6 = h.union([
    h.literal('invalid-identifier'),
    h.literal('fetch-integrity-storage-error'),
    h.literal('fetch-entropy-storage-error'),
    h.literal('fetch-pk-storage-error'),
    h.literal('invalid-entropy'),
    h.literal('invalid-entropy-bip-39'),
    h.literal('invalid-checksum-bits'),
    h.literal('invalid-entropy-bits'),
    h.literal('invalid-checksum'),
    h.literal('invalid-entropy-length-less-than-twelve'),
    h.literal('invalid-entropy-length-more-than-twenty-four'),
    h.literal('invalid-entropy-length-wrong-word'),
    h.literal('invalid-pk-address-type'),
    h.literal('invalid-pk-identifier'),
    h.literal('invalid-pk'),
    h.literal('internal-error'),
  ]),
  C6 = h.literal('safely-onboarded');
h.union([
  h.object({ status: T6, isOnboarded: h.literal(!1), reonboardingNeeded: h.literal(!1) }),
  h.object({ status: k6, isOnboarded: h.literal(!0), reonboardingNeeded: h.literal(!0) }),
  h.object({ status: C6, isOnboarded: h.literal(!0), reonboardingNeeded: h.literal(!1) }),
]);
const M6 = (e, t, n, r) => {
    const i = [];
    for (const o of t) {
      const a = q.getChainID(o);
      if (r.includes(a))
        for (const c of q[a].addressTypes) {
          if (!n.includes(c)) continue;
          const s = e.chains[c];
          if (s)
            switch (s.chainType) {
              case X.EVM:
              case X.Solana: {
                i.push({ networkID: o, addressType: c, address: s.address });
                break;
              }
              case X.BitcoinTaproot:
              case X.BitcoinNativeSegwit:
              case X.BitcoinNestedSegwit:
              case X.BitcoinLegacy: {
                i.push({
                  networkID: o,
                  addressType: c,
                  publicKey: s.publicKey,
                  address: s.addresses[o],
                });
                break;
              }
              case X.Sui: {
                i.push({
                  networkID: o,
                  addressType: c,
                  publicKey: s.publicKey,
                  address: s.address,
                });
                break;
              }
              default:
                Sn();
            }
        }
    }
    return i;
  },
  P6 = (e, t, n, r) => {
    const i = [];
    for (const o of t) {
      const a = q.getChainID(o);
      if (r.includes(a))
        for (const c of q[a].addressTypes) {
          if (!n.includes(c)) continue;
          const s = e.chains[c];
          if (s)
            switch (s.chainType) {
              case X.EVM:
              case X.Solana: {
                i.push({ networkID: o, addressType: c, address: s.address });
                break;
              }
              case X.BitcoinTaproot:
              case X.BitcoinNativeSegwit:
              case X.BitcoinNestedSegwit:
              case X.BitcoinLegacy: {
                i.push({
                  networkID: o,
                  addressType: c,
                  publicKey: s.publicKey,
                  address: s.addresses[o],
                });
                break;
              }
              case X.Sui: {
                i.push({
                  networkID: o,
                  addressType: c,
                  publicKey: s.publicKey,
                  address: s.address,
                });
                break;
              }
              default:
                Sn();
            }
        }
    }
    return i;
  },
  O6 = (e, t, n, r) => {
    const i = [];
    for (const o of t) {
      const a = q.getChainID(o);
      if (r.includes(a))
        for (const c of q[a].addressTypes)
          n.includes(c) &&
            e.chainType === c &&
            i.push({ networkID: o, addressType: c, address: e.address });
    }
    return i;
  },
  D6 = (e, t, n, r) => {
    const i = [];
    for (const o of t) {
      const a = q.getChainID(o);
      if (r.includes(a)) {
        for (const c of q[a].addressTypes)
          if (n.includes(c) && e.chainType === c)
            switch (e.chainType) {
              case X.EVM:
              case X.Solana: {
                i.push({ networkID: o, addressType: c, address: e.address });
                break;
              }
              case X.BitcoinTaproot:
              case X.BitcoinNativeSegwit:
              case X.BitcoinNestedSegwit:
              case X.BitcoinLegacy: {
                i.push({
                  networkID: o,
                  addressType: c,
                  publicKey: e.publicKey,
                  address: e.addresses[o],
                });
                break;
              }
              case X.Sui: {
                i.push({
                  networkID: o,
                  addressType: c,
                  publicKey: e.publicKey,
                  address: e.address,
                });
                break;
              }
              default:
                Sn();
            }
      }
    }
    return i;
  },
  R6 = (e, t, n, r) => {
    const i = [];
    for (const o of t) {
      const a = q.getChainID(o);
      if (r.includes(a)) {
        for (const c of q[a].addressTypes)
          if (n.includes(c))
            for (const [s, l] of Object.entries(e.addresses))
              s === c && i.push({ networkID: o, addressType: c, address: l });
      }
    }
    return i;
  },
  UI = (e, t, n, r, i, o) => {
    let a;
    switch (
      (o ? (a = Object.values(i.setting)) : (a = t),
      (a = a.sort((c, s) => q.compareNetworkID(c, s))),
      e.type)
    ) {
      case ze.Seedless:
      case ze.Seed:
        return M6(e, a, n, r);
      case ze.Ledger:
        return P6(e, a, n, r);
      case ze.SeedVault:
        return O6(e, a, n, r);
      case ze.PrivateKey:
        return D6(e, a, n, r);
      case ze.ReadOnly:
        return R6(e, a, n, r);
    }
  },
  LI = 'Trying to find a selected account, but there no accounts in the vault.',
  zI = 'Missing ChainAvailability.',
  x6 = new Error('The current account group has no valid bitcoin address'),
  B6 = new Error('The current account group has no valid EIP-155 address'),
  j6 = new Error('The current account group has no valid solana address'),
  FI = new Error('The current account group has no valid sui address'),
  N6 = new Error(
    'The current account group has no valid address or the the chain type was unsupported'
  );
var Jn = ((e) => (
  (e.TermsHaveBeenAcknowledgedLastSeenVersion = 'termsHaveBeenAcknowledgedLastSeenVersion'),
  (e.NetworkSetting = 'networkSetting'),
  (e.DeveloperMode = 'developerMode'),
  (e.SelectedAccount = '.phantom-labs.account.selectedAccount'),
  (e.AccountsMetadata = '.phantom-labs.account.accountMetadata'),
  (e.MigratedWithInvalidChecksum = '.phantom-labs.account.migratedWithInvalidChecksum'),
  (e.AccountMetas = 'accountMetas'),
  e
))(Jn || {});
async function U6(e) {
  try {
    const t = await e.get('.phantom-labs.account.selectedAccount');
    return (t == null ? void 0 : t.version) === 2 ? t.identifier : null;
  } catch {
    throw L6;
  }
}
const L6 = new Error('Failed to get selected account identifier');
async function z6(e, t) {
  try {
    const n = { version: 2, identifier: t };
    return await e.set('.phantom-labs.account.selectedAccount', n);
  } catch {
    throw F6;
  }
}
const F6 = new Error('Failed to set selected account identifier'),
  $I = async (e, t) => {
    if (e.length === 0) throw new Error(LI);
    const n = await U6(t),
      r = e.find((i) => i.identifier === n);
    return r || (await z6(t, e[0].identifier), e[0]);
  };
function WI(e, t) {
  const r = ((e == null ? void 0 : e.addresses) ?? []).find(({ addressType: i }) => i === t);
  if (!(e != null && e.addresses) || !r)
    switch (t) {
      case X.BitcoinTaproot:
      case X.BitcoinNativeSegwit:
      case X.BitcoinNestedSegwit:
      case X.BitcoinLegacy:
        throw x6;
      case X.EVM:
        throw B6;
      case X.Solana:
        throw j6;
      case X.Sui:
        throw FI;
      default:
        throw N6;
    }
  return r;
}
function Ln(e, t) {
  var n;
  return (n = WI(e, t)) == null ? void 0 : n.address;
}
const ep = (e, t = 5) => {
    const n = e.length,
      r = e.startsWith('0x') ? t + 2 : t;
    return `${e.substring(0, r)}...${e.substring(n - t, n)}`;
  },
  $6 = (e) =>
    e.includes('.') || e.includes('@')
      ? !1
      : Z3.safeParse(e).success ||
        eI.safeParse(e).success ||
        tI.safeParse(e).success ||
        Q3.safeParse(e).success,
  W6 = (e, t = 5) => ($6(e) ? ep(e, t) : e),
  V6 = (e, t, n, r = 4) => {
    const i = t ? t.name : n,
      o = W6(e, r);
    return i ? `${i} (${o})` : o;
  };
function K6(e) {
  const t = e.endsWith('.sol'),
    n = e === '@',
    r = e.startsWith('@') && e.length > 1;
  return [t, n, r];
}
function H6(e) {
  return [e.endsWith('.eth')];
}
let bm = null;
function q6(e) {
  bm = e;
}
async function G6() {
  if (!bm)
    throw new Error(
      'No fetch bearer token function registered. Register one with registerFetchBearerToken().'
    );
  return await bm();
}
function Y6(...e) {
  const t = new AbortController();
  for (const n of e) {
    const r = n instanceof AbortController ? n.signal : n;
    if (r != null && r.aborted) return t.abort(r.reason), t.signal;
    r == null ||
      r.addEventListener(
        'abort',
        () => {
          t.abort(r.reason);
        },
        { once: !0 }
      );
  }
  return t.signal;
}
const Z6 = 2 * 60 * 1e3,
  Q6 = [];
function J6(e, t) {
  const { fetchTimeout: n, retryDelays: r, ...i } = t || {},
    o = (t == null ? void 0 : t.fetchTimeout) ?? Z6,
    a = (t == null ? void 0 : t.retryDelays) ?? Q6;
  let c = 0,
    s = 0;
  return new Promise((l, u) => {
    function d() {
      c++, (s = Date.now());
      let y = !0;
      const b = new AbortController(),
        m = fetch(e, { ...i, signal: Y6(...(i.signal ? [i.signal, b.signal] : [b.signal])) }),
        w = setTimeout(() => {
          b.abort(),
            (y = !1),
            p(c)
              ? f()
              : u(
                  new Error(
                    `fetchWithTimeoutAndRetry(): Failed to get response from server due to timeout of ${o} ms, tried ${c} times.`
                  )
                );
        }, o);
      m.then((_) => {
        clearTimeout(w),
          y && (_.status >= 200 && _.status < 300 ? l(_) : p(c, _.status) ? f() : l(_));
      }).catch((_) => {
        clearTimeout(w), p(c) ? f() : u(_);
      });
    }
    function f() {
      const y = a[c - 1],
        b = s + y;
      setTimeout(d, Math.max(b - Date.now(), 0));
    }
    function p(y, b) {
      const m = b ? b >= 400 && b <= 499 : !1;
      return y <= a.length && !m;
    }
    d();
  });
}
const Dy = (e = {}, t = {}) => {
    const n = new Headers(e),
      r = new Headers(t);
    for (const [i, o] of r.entries()) o === void 0 || o === 'undefined' ? n.delete(i) : n.set(i, o);
    return n;
  },
  X6 = [
    86, 120, 48, 81, 89, 86, 110, 49, 100, 114, 111, 113, 49, 70, 56, 84, 77, 115, 80, 81, 66, 75,
    72, 51, 90, 83, 110, 100, 110, 116, 68, 88, 107, 118, 83, 53, 102, 80, 114, 89, 111, 88, 85, 75,
    57, 43, 67, 57, 97, 103, 74, 113, 68, 76, 112, 112, 100, 48, 102, 101, 80, 122, 83, 111, 108,
    113, 75, 90, 56, 114, 66, 70, 119, 87, 84, 104, 98, 57, 110, 119, 43, 79, 70, 51, 51, 65, 61,
    61,
  ],
  eD = [
    87, 67, 49, 81, 97, 71, 70, 117, 100, 71, 57, 116, 81, 88, 86, 48, 97, 70, 82, 118, 97, 50, 86,
    117,
  ],
  tD = [87, 67, 49, 81, 97, 71, 70, 117, 100, 71, 57, 116, 84, 109, 57, 117, 89, 50, 85, 61];
function nD(e) {
  const t = new URL(e);
  return t.pathname + t.search;
}
function rD(e, t) {
  const n = nD(e),
    r = JSON.stringify(Math.floor(Date.now() / 1e3)),
    i = n + r,
    o = M4(P4, Ae.from(String.fromCharCode(...X6)), Ae.from(i)),
    a = new Headers(t);
  return (
    a.set(
      Ae.from(String.fromCharCode(...eD), 'base64').toString(),
      encodeURIComponent(Ae.from(o).toString('base64'))
    ),
    a.set(Ae.from(String.fromCharCode(...tD), 'base64').toString(), r),
    a
  );
}
class Qs extends Error {
  constructor(n, r) {
    super(n);
    Le(this, 'response');
    this.response = r;
  }
}
const iD = {
    'Content-Type': 'application/json',
    'X-Phantom-Version': vc,
    'X-Phantom-Platform': E0,
  },
  ya = async (e) => {
    let t, n;
    try {
      n = await e.clone().blob();
    } catch {}
    try {
      t = await e.clone().json();
    } catch {}
    const { status: r, statusText: i } = e;
    return { blob: n, data: t, status: r, statusText: i };
  };
class Xr {
  constructor(t = {}) {
    Le(this, 'config');
    Le(this, 'fetch', async (t, n = {}) => {
      try {
        if (typeof t == 'function') {
          const s = cm() === ic.Production ? 'prod' : 'staging';
          t = t({ apiEnv: s });
        }
        let r = '';
        this.config.withApiEnvironment === 'prod'
          ? (r = ic.Production)
          : this.config.withApiEnvironment === 'staging'
            ? (r = ic.Staging)
            : this.config.withApiEnvironment === 'default'
              ? (r = cm())
              : this.config.withApiEnvironment === 'custom' &&
                this.config.customApiEnv &&
                (r = this.config.customApiEnv);
        const i = new URL(`${r}${t}`);
        n != null && n.params && (i.search = new URLSearchParams(n.params).toString());
        const o = n;
        (n.headers = Dy(this.config.headers, n.headers)),
          (n.headers = n.headers),
          this.config.withClientAuth && (n.headers = rD(i.toString(), n.headers));
        let a = this.config.validateStatus;
        if (
          (n != null && n.validateStatus && (a = n == null ? void 0 : n.validateStatus),
          o.body && typeof o.body != 'string' && (o.body = JSON.stringify(o.body)),
          this.config.timeoutMs && (o.fetchTimeout = this.config.timeoutMs),
          this.config.numRetries &&
            (o.retryDelays = Array(this.config.numRetries).fill(
              this.config.delayBetweenEachRetryMs
            )),
          this.config.fetchBearerToken)
        ) {
          const s = await G6();
          if (s) o.headers = Dy(o.headers, { authorization: `Bearer ${s}` });
          else throw new Qs('Unable to get bearer token. Full auth is required.');
        }
        const c = await J6(i.toString(), o);
        if (a && !c.ok) throw new Qs(`Request failed with status code ${c.status}`, await ya(c));
        return c;
      } catch (r) {
        throw r instanceof Qs
          ? r
          : new Qs(r == null ? void 0 : r.message, r == null ? void 0 : r.response);
      }
    });
    this.config = {
      withClientAuth: !0,
      numRetries: 0,
      delayBetweenEachRetryMs: 0,
      timeoutMs: null,
      validateStatus: !1,
      headers: iD,
      withApiEnvironment: 'none',
      fetchBearerToken: !1,
      ...t,
    };
  }
  auth(t) {
    return new Xr({ ...this.config, withClientAuth: t });
  }
  bearer(t) {
    return typeof t == 'string' && t
      ? this.headers({ authorization: `Bearer ${t}` })
      : typeof t == 'boolean' && t
        ? new Xr({ ...this.config, fetchBearerToken: !0 })
        : this;
  }
  headers(t, n) {
    const r = (n == null ? void 0 : n.mergeHeaders) === !1 ? t : Dy(this.config.headers, t);
    return new Xr({ ...this.config, headers: r });
  }
  timeout(t) {
    return new Xr({ ...this.config, timeoutMs: t });
  }
  retry(t, n) {
    return new Xr({ ...this.config, numRetries: t, delayBetweenEachRetryMs: n });
  }
  validateStatus(t) {
    return new Xr({ ...this.config, validateStatus: t });
  }
  api(t = 'default', n) {
    return new Xr({
      ...this.config,
      withApiEnvironment: t,
      customApiEnv: t === 'custom' ? n : void 0,
    });
  }
  async get(t, n = {}) {
    n.method = 'GET';
    const r = await this.fetch(t, n);
    return ya(r);
  }
  async post(t, n, r = {}) {
    r.method = 'POST';
    const i = await this.fetch(t, { ...r, body: n });
    return ya(i);
  }
  async put(t, n, r = {}) {
    r.method = 'PUT';
    const i = await this.fetch(t, { ...r, body: n });
    return ya(i);
  }
  async patch(t, n, r = {}) {
    r.method = 'PATCH';
    const i = await this.fetch(t, { ...r, body: n });
    return ya(i);
  }
  async delete(t, n, r = {}) {
    r.method = 'DELETE';
    const i = await this.fetch(t, { ...r, body: n });
    return ya(i);
  }
}
const ke = new Xr();
function oD(e) {
  if (e === void 0) throw new Error('rpcUrl undefined');
  return async (t, n) => {
    const r = { jsonrpc: '2.0', id: +new Date(), method: t, params: n },
      o = (await ke.post(e, r)).data;
    if ('error' in o) throw new Error(JSON.stringify(o.error));
    return o.result;
  };
}
async function aD(e, t = {}) {
  return ke.fetch(e, t);
}
function hn(e) {
  return e.status > 199 && e.status < 400;
}
function Np(e) {
  return e instanceof Qs;
}
const Dc = (e, t) =>
    t ? `/user/v1/users/${e}/wallet-accounts/${t}` : `/user/v1/users/${e}/wallet-accounts`,
  Up = (e) => `/user/v1/users/${e}/profile`,
  VI = (e) => `/user/v1/profiles/${e}`,
  sD = () => '/user/v1/profiles/creation-check',
  cD = (e) => `/v1/actors-search?query=${encodeURIComponent(e)}`,
  uD = ['seed', 'seedless', 'privateKey'],
  KI = 10,
  lD = 500,
  Vf = { seedless: 1, seed: 2, privateKey: 3 },
  Kf = '@phantom/users',
  tp = {
    checkUsernameAvailability(e) {
      return ['user', `${Kf}:check-username-availability`, { username: e }];
    },
    userProfile() {
      return ['user', `${Kf}:user-profile`];
    },
    userProfileAttributeEffect(e) {
      return ['user', `${Kf}:user-profile-attribute-effect`, { username: e }];
    },
    userSyncedAccounts() {
      return ['user', `${Kf}:user-synced-accounts`];
    },
  },
  HI = async (e) => {
    await e.invalidateQueries({ queryKey: tp.userSyncedAccounts() });
  };
var G0 = ((e) => (
  (e.PUBLIC = 'public'),
  (e.PRIVATE = 'private'),
  (e.INVISIBLE = 'invisible'),
  (e.HIDDEN = 'hidden'),
  e
))(G0 || {});
Object.values(G0);
const dD = h.string().brand('ProfileId'),
  qI = h.object({
    id: dD,
    username: h.string(),
    icon: h.string().nullish(),
    addresses: h.record(h.string(), h.string()),
    privacyState: h.nativeEnum(G0).optional().default('public'),
    biography: h.string().nullish(),
    phantomJoinDate: h.string().nullish(),
  }),
  GI = h.string().url().brand('ActorId'),
  fD = h.object({
    id: h.string().optional(),
    orderedItems: GI.array(),
    next: h.string().optional(),
  }),
  t_ = h.object({
    id: h.string().url(),
    current: fD.optional(),
    totalItems: h.number().optional(),
  }),
  n_ = h.object({ type: h.string(), value: h.string().optional(), name: h.string().optional() }),
  hD = h.object({ id: h.string().url().optional(), name: h.string().optional(), type: h.string() }),
  pD = h
    .object({
      id: GI,
      name: h.string(),
      preferredUsername: h.string(),
      manuallyApprovesFollowers: h.boolean(),
      followers: h.union([t_, h.string().url()]),
      following: h.union([t_, h.string().url()]),
      icon: hD.nullish(),
      attachment: h.union([n_, h.array(n_)]).optional(),
      summary: h.string().nullish(),
      published: h.string().nullish(),
    })
    .transform((e) => {
      const { attachment: t, ...n } = e,
        r = {};
      let i = !1,
        o = !1,
        a = !1,
        c = !1,
        s = !1;
      if (t) {
        const l = Array.isArray(t) ? t : [t];
        for (const u of l)
          if (!(!u.name || !u.value)) {
            if (u.name.endsWith(':address')) {
              const d = oa.safeParse(u.name.replace(':address', ''));
              if (d.success) {
                const f = d.data;
                r[f] = u.value;
              }
            }
            u.name === 'requesting' && (i = u.value === 'true'),
              u.name === 'requestedBy' && (o = u.value === 'true'),
              u.name === 'blocking' && (a = u.value === 'true'),
              u.name === 'following' && (c = u.value === 'true'),
              u.name === 'followedBy' && (s = u.value === 'true');
          }
      }
      return {
        ...n,
        addresses: r,
        isSentFollowRequestPending: i,
        hasPendingFollowRequest: o,
        isBlocking: a,
        isFollowing: c,
        isFollowedBy: s,
      };
    }),
  gD = h.object({ actors: pD.array() }),
  yD = { Image: 'image', Emoji: 'emoji', ReadOnlyDefault: 'read-only-default', Default: 'default' };
h.object({
  type: h.nativeEnum(yD),
  imageUrl: h.string().optional(),
  unicode: h.string().optional(),
});
const YI = h.object({ error: h.object({ message: h.string() }) }),
  r_ = async (e) => {
    const t = await ke.api().get(VI(e)),
      n = qI.safeParse(t.data);
    return n.success ? n.data : null;
  },
  bD = h.string().regex(/^https?:\/\/.+$/),
  mD = h.string(),
  Lp = h.literal('privateKey'),
  wD = h.object({ networkId: M0, publicKey: Mp, address: J3, pathType: JA.or(Lp) }),
  _D = h.object({ networkId: Ic, publicKey: Mp, address: eI, pathType: QA.or(Lp) }),
  vD = h.object({ networkId: Pp, publicKey: Mp, address: h.string(), pathType: XA.or(Lp) }),
  SD = h.object({ networkId: nI, publicKey: Mp, address: h.string(), pathType: X3.or(Lp) }),
  AD = h.union([wD, _D, vD, SD]),
  ZI = h.object({
    accountHash: h.string(),
    accountOrigin: h
      .string()
      .regex(/^(seed|privateKey|seedless):(.+)/)
      .catch('readOnly'),
    name: h.string().nullish().default(null).catch(null),
    icon: h.union([bD, mD]).nullish().default(null).catch(null),
    derivationIndex: h.number().nullish().default(null).catch(null),
    addresses: h.array(AD).min(1),
  }),
  ID = ZI.and(h.object({ id: h.string() })),
  Y0 = h.object({ walletAccounts: h.array(ID) });
h.record(h.string(), ZI);
const i_ = (e) => {
    var t;
    for (const n of uD)
      if (((t = e.accountOrigin) == null ? void 0 : t.split(':')[0]) === n) return n;
    return null;
  },
  o_ = (e) => {
    var t, n, r;
    return (r =
      (n = (t = e.accountOrigin) == null ? void 0 : t.replace('seed:', '')) == null
        ? void 0
        : n.replace('privateKey:', '')) == null
      ? void 0
      : r.replace('seedless:', '');
  },
  ED = (e = []) =>
    e.sort((t, n) => {
      const r = i_(t),
        i = i_(n);
      if (r === null && i === null) return 0;
      if (r === null) return 1;
      if (i === null) return -1;
      if (Vf[r] - Vf[i] !== 0) return Vf[r] - Vf[i];
      const o = o_(t),
        a = o_(n);
      if (o === null && a === null) return 0;
      if (o === null) return 1;
      if (a === null) return -1;
      const c = o.localeCompare(a);
      return c !== 0
        ? c
        : t.derivationIndex === null && n.derivationIndex === null
          ? 0
          : t.derivationIndex === null
            ? 1
            : n.derivationIndex === null
              ? -1
              : t.derivationIndex - n.derivationIndex;
    }),
  TD = (e) => ({
    getUsernameAvailability: (t) => kD(t),
    getUserProfile: () => CD(e),
    getUserProfileByUsername: (t) => r_(t),
    getUserProfileByUsernameOrUserProfileId: (t) => r_(t),
    searchForActor: (t, n, r) => UD(t, n),
    setUserProfile: ({ username: t, addresses: n, icon: r, signedMessages: i, privacyState: o }) =>
      MD(e, { username: t, addresses: n, signedMessages: i, icon: r, privacyState: o }),
    patchUserProfile: (t) => PD(e, t),
    deleteUserProfile: () => OD(e),
    isEligibleToClaim: (t) => DD(t),
    getSyncedAccounts: () => Z0(e),
    downloadSyncedAccounts: () => RD(e),
    uploadSyncedAccounts: (t) => xD(e, t),
    uploadSyncedAccount: (t) => BD(e, t),
    deleteSyncedAccounts: () => jD(e),
    deleteSyncedAccount: (t) => ND(e, t),
  }),
  kD = async (e) => {
    switch ((await ke.api().get(VI(e))).status) {
      case 200:
        return !1;
      case 403:
        return !1;
      case 404:
        return !0;
      default:
        throw new Error('Failed to check for username availability.');
    }
  },
  CD = async ({ authRepository: e }) => {
    const t = await e.getUser();
    if (!t) throw new Error('User is not logged in, unable to get user profile.');
    const { userID: n, accessToken: r } = t,
      i = await ke.api().bearer(r).get(Up(n)),
      o = qI.safeParse(i.data);
    return o.success ? o.data : null;
  },
  MD = async (
    { authRepository: e },
    { username: t, addresses: n, icon: r, signedMessages: i, privacyState: o }
  ) => {
    const a = await e.getUser();
    if (!a) throw new Error('User is not logged in, unable to claim username.');
    const { userID: c, accessToken: s } = a,
      l = await ke
        .api()
        .bearer(s)
        .post(Up(c), { username: t, signedMessages: i, icon: r, addresses: n, privacyState: o });
    if (l.status === 201) return;
    const u = YI.safeParse(l.data);
    throw u.success ? new Error(u.data.error.message) : new Error('Unknown error');
  },
  PD = async (
    { authRepository: e },
    { username: t, addresses: n, icon: r, privacyState: i, biography: o }
  ) => {
    const a = await e.getUser();
    if (!a) throw new Error('User is not logged in, unable to claim username.');
    const { userID: c, accessToken: s } = a,
      l = await ke
        .api()
        .bearer(s)
        .patch(Up(c), { username: t, addresses: n, icon: r, privacyState: i, biography: o });
    if (l.status === 200) return;
    Z.captureMessage(
      `Failed to patch user profile: ${l.status} ${JSON.stringify(l.data)}`,
      te.Auth
    );
    const u = YI.safeParse(l.data);
    throw u.success ? new Error(u.data.error.message) : new Error('Unknown error');
  },
  OD = async ({ authRepository: e }) => {
    const t = await e.getUser();
    if (!t) throw new Error('User is not logged in, unable to sync down accounts.');
    const { userID: n, accessToken: r } = t,
      i = await ke.api().bearer(r).delete(Up(n));
    return 200 <= i.status && i.status < 300;
  },
  DD = async (e) => {
    try {
      return (await ke.api().post(sD(), { addresses: e })).status === 200;
    } catch {
      return !1;
    }
  },
  Z0 = async ({ authRepository: e }) => {
    const t = await e.getUser();
    if (!t) throw new Error('User is not logged in, unable to sync down accounts.');
    const { userID: n, accessToken: r } = t,
      i = await ke.api().bearer(r).get(Dc(n)),
      o = Y0.safeParse(i.data);
    if (!o.success)
      throw new Error(
        'Unable to get synced accounts: unable to parse GET /wallet-accounts response.'
      );
    return { walletAccounts: ED(o.data.walletAccounts) };
  },
  RD = async (e) => {
    const { walletAccounts: t } = await Z0(e),
      n = t.reduce((r, i) => ((r[i.accountHash] = i), r), {});
    return await e.claimUsernameSigner.storeSyncedAccounts(n), !0;
  },
  QI = (e, t, n) => ke.api().bearer(e).post(Dc(t), n),
  xD = async (e, t) => {
    const { authRepository: n, claimUsernameSigner: r, queryClient: i } = e,
      o = await n.getUser();
    if (!o)
      return (
        Z.addBreadcrumb(te.Auth, 'User is not logged in, unable to sync up accounts.', Te.Info), !1
      );
    try {
      let a = t;
      a ||
        (Z.addBreadcrumb(te.Auth, 'Uploading all currently synced accounts...', Te.Info),
        (a = [
          ...(await Z0(e)).walletAccounts.reduce((p, y) => (p.add(y.accountHash), p), new Set()),
        ]));
      const c = await r.getBatchAccountMetadata(a),
        { userID: s, accessToken: l } = o,
        u = P0(Object.values(c), KI);
      for (const d of u) await Promise.all(d.map((f) => QI(l, s, f))), await Xi(lD);
      return (
        await HI(i),
        Z.addBreadcrumb(
          te.Auth,
          `✅ Uploaded synced accounts: ${t ? (t == null ? void 0 : t.join(' ')) : 'all currently synced accounts'}`,
          Te.Info
        ),
        !0
      );
    } catch (a) {
      throw (
        (Z.addBreadcrumb(
          te.Auth,
          `Unable to sync up accounts: ${t ? (t == null ? void 0 : t.join(' ')) : 'all currently synced accounts'}`,
          Te.Info
        ),
        Z.captureError(a, te.Auth),
        a)
      );
    }
  },
  BD = async ({ authRepository: e, claimUsernameSigner: t, queryClient: n }, r) => {
    const i = await e.getUser();
    if (!i)
      return (
        Z.addBreadcrumb(te.Auth, `User is not logged in, unable to sync up account: ${r}`, Te.Info),
        !1
      );
    try {
      Z.addBreadcrumb(te.Auth, `Syncing account... : ${r}`, Te.Info);
      const o = await t.getAccountMetadata(r),
        { userID: a, accessToken: c } = i;
      return (
        await QI(c, a, o),
        await HI(n),
        Z.addBreadcrumb(te.Auth, `✅ Synced account: ${r}`, Te.Info),
        !0
      );
    } catch (o) {
      throw (
        (Z.addBreadcrumb(te.Auth, `Unable to sync up account: ${r}`, Te.Info),
        Z.captureError(o, te.Auth),
        o)
      );
    }
  },
  JI = (e, t, n) => ke.api().bearer(e).delete(Dc(t, n.id), n),
  jD = async ({ authRepository: e }) => {
    const t = await e.getUser();
    if (!t) throw new Error('User is not logged in, unable to delete all synced accounts.');
    const { userID: n, accessToken: r } = t,
      i = await ke.api().bearer(r).get(Dc(n)),
      o = Y0.safeParse(i.data);
    if (!o.success)
      throw new Error(
        'Unable to delete all synced accounts => unable to parse GET /wallet-accounts response.'
      );
    const a = P0(o.data.walletAccounts, KI);
    for (const c of a) await Promise.all(c.map((s) => JI(r, n, s)));
    return !0;
  },
  ND = async ({ authRepository: e }, t) => {
    const n = await e.getUser();
    if (!n) throw new Error(`User is not logged in, unable to remove synced account: ${t}`);
    const { userID: r, accessToken: i } = n,
      o = await ke.api().bearer(i).get(Dc(r)),
      a = Y0.safeParse(o.data);
    if (!a.success)
      throw new Error(
        `Unable to delete synced account [${t}] => unable to parse GET /wallet-accounts response`
      );
    const c = a.data.walletAccounts.find((s) => s.accountHash === t);
    if (!c)
      return (
        Z.addBreadcrumb(
          te.Auth,
          `Calling deleteSyncedAccount on account that is not synced to begin with: ${t}`,
          Te.Info
        ),
        !1
      );
    try {
      await JI(i, r, c);
    } catch (s) {
      throw (
        (Z.addBreadcrumb(te.Auth, `Unable to delete synced account: ${t}`, Te.Info),
        Z.captureError(s, te.Auth),
        s)
      );
    }
    return !0;
  },
  UD = async (e, t, n) => {
    Z.addBreadcrumb(te.Network, 'User is searching for actors.', Te.Info, { query: e });
    const r = await ke.api().bearer(t).get(cD(e)),
      i = gD.safeParse(r.data);
    return i.success ? { actors: i.data.actors } : { actors: [] };
  };
tp.userProfile()[1], tp.userSyncedAccounts()[1];
const LD = 'https://phantom.app',
  zD = 'https://api.phantom.app/oauth2/auth',
  Ry = { prod: 'https://auth.phantom.app', staging: 'https://staging-auth.phantom.app' },
  FD = '/login/start',
  $D = '/oauth2/token';
var WD = ((e) => ((e.Apple = 'apple'), (e.Google = 'google'), e))(WD || {});
const VD = ae({ minutes: 60 }) - ae({ minutes: 15 }),
  Rc = '/v1/authentication-keys',
  mm = (e) =>
    Y.from(e).toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, ''),
  KD = 'https://time.phantom.app/utc',
  HD = h.number().int().positive();
async function qD() {
  let e;
  try {
    const t = await ke.get(KD);
    if (t.status !== 200) throw new Error('Failed to fetch time from server');
    e = HD.parse(t.data);
  } catch {
    e = Date.now();
  }
  return Math.floor(e / 1e3);
}
const GD = 60,
  YD = () => Math.floor(Date.now() / 1e3);
async function Q0(e = !0) {
  const t = { alg: 'ES256', type: 'JWT' },
    n = e ? await qD() : YD(),
    r = { iss: LD, aud: zD, nbf: n, exp: n + GD, iat: n };
  return { header: t, payload: r };
}
function J0(e) {
  const t = mm(Ae.from(JSON.stringify(e.header))),
    n = mm(Ae.from(JSON.stringify(e.payload)));
  return [t, n, e.signature].join('.');
}
const ZD = h.object({ alg: h.string(), type: h.string(), kid: h.string() }),
  QD = h.object({
    sub: h.string(),
    iss: h.string(),
    aud: h.string(),
    nbf: h.number(),
    exp: h.number(),
    iat: h.number(),
  }),
  JD = h.object({ header: ZD, payload: QD, signature: h.string() }),
  XD = h.object({ alg: h.string(), type: h.string() }),
  e8 = h.object({
    iss: h.string(),
    aud: h.string(),
    nbf: h.number(),
    exp: h.number(),
    iat: h.number(),
  }),
  t8 = h.object({ header: XD, payload: e8 }),
  n8 = h.object({
    id_token: h.string(),
    access_token: h.string(),
    refresh_token: h.string(),
    scope: h.string(),
    token_type: h.string(),
    expires_in: h.number().gte(0),
  });
h.object({ redirectTo: h.string() });
const r8 = h.object({
    at_hash: h.string(),
    aud: h.array(h.string()),
    auth_time: h.number(),
    exp: h.number(),
    iat: h.number(),
    iss: h.string(),
    jti: h.string(),
    rat: h.number(),
    sid: h.string(),
    sub: h.string(),
    email: h.string().optional(),
  }),
  XI = h.object({
    authenticationKeys: h
      .array(
        h.object({
          createdAt: h.string().datetime().nullish().default(null),
          updatedAt: h.string().datetime().nullish().default(null),
          id: h.string().uuid(),
          publicKey: h.string(),
          userId: h.string().uuid(),
        })
      )
      .optional(),
  });
var Ao = ((e) => (
    (e.User = 'user'),
    (e.UserID = 'userID'),
    (e.AccessToken = 'accessToken'),
    (e.Email = 'email'),
    (e.LoggedOut = 'loggedOut'),
    e
  ))(Ao || {}),
  Yi = {},
  xc = {},
  Yn = {},
  zp = {};
zp.byteLength = a8;
zp.toByteArray = c8;
zp.fromByteArray = d8;
var jr = [],
  Hn = [],
  i8 = typeof Uint8Array < 'u' ? Uint8Array : Array,
  xy = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var ba = 0, o8 = xy.length; ba < o8; ++ba) (jr[ba] = xy[ba]), (Hn[xy.charCodeAt(ba)] = ba);
Hn[45] = 62;
Hn[95] = 63;
function eE(e) {
  var t = e.length;
  if (t % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4');
  var n = e.indexOf('=');
  n === -1 && (n = t);
  var r = n === t ? 0 : 4 - (n % 4);
  return [n, r];
}
function a8(e) {
  var t = eE(e),
    n = t[0],
    r = t[1];
  return ((n + r) * 3) / 4 - r;
}
function s8(e, t, n) {
  return ((t + n) * 3) / 4 - n;
}
function c8(e) {
  var t,
    n = eE(e),
    r = n[0],
    i = n[1],
    o = new i8(s8(e, r, i)),
    a = 0,
    c = i > 0 ? r - 4 : r,
    s;
  for (s = 0; s < c; s += 4)
    (t =
      (Hn[e.charCodeAt(s)] << 18) |
      (Hn[e.charCodeAt(s + 1)] << 12) |
      (Hn[e.charCodeAt(s + 2)] << 6) |
      Hn[e.charCodeAt(s + 3)]),
      (o[a++] = (t >> 16) & 255),
      (o[a++] = (t >> 8) & 255),
      (o[a++] = t & 255);
  return (
    i === 2 &&
      ((t = (Hn[e.charCodeAt(s)] << 2) | (Hn[e.charCodeAt(s + 1)] >> 4)), (o[a++] = t & 255)),
    i === 1 &&
      ((t =
        (Hn[e.charCodeAt(s)] << 10) |
        (Hn[e.charCodeAt(s + 1)] << 4) |
        (Hn[e.charCodeAt(s + 2)] >> 2)),
      (o[a++] = (t >> 8) & 255),
      (o[a++] = t & 255)),
    o
  );
}
function u8(e) {
  return jr[(e >> 18) & 63] + jr[(e >> 12) & 63] + jr[(e >> 6) & 63] + jr[e & 63];
}
function l8(e, t, n) {
  for (var r, i = [], o = t; o < n; o += 3)
    (r = ((e[o] << 16) & 16711680) + ((e[o + 1] << 8) & 65280) + (e[o + 2] & 255)), i.push(u8(r));
  return i.join('');
}
function d8(e) {
  for (var t, n = e.length, r = n % 3, i = [], o = 16383, a = 0, c = n - r; a < c; a += o)
    i.push(l8(e, a, a + o > c ? c : a + o));
  return (
    r === 1
      ? ((t = e[n - 1]), i.push(jr[t >> 2] + jr[(t << 4) & 63] + '=='))
      : r === 2 &&
        ((t = (e[n - 2] << 8) + e[n - 1]),
        i.push(jr[t >> 10] + jr[(t >> 4) & 63] + jr[(t << 2) & 63] + '=')),
    i.join('')
  );
}
var co = {};
Object.defineProperty(co, '__esModule', { value: !0 });
co.AppAuthError = void 0;
var f8 = (function () {
  function e(t, n) {
    (this.message = t), (this.extras = n);
  }
  return e;
})();
co.AppAuthError = f8;
Object.defineProperty(Yn, '__esModule', { value: !0 });
Yn.DefaultCrypto = Yn.textEncodeLite = Yn.urlSafe = Yn.bufferToString = void 0;
var h8 = zp,
  a_ = co,
  tE = typeof window < 'u' && !!window.crypto,
  p8 = tE && !!window.crypto.subtle,
  wm = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
function nE(e) {
  for (var t = [], n = 0; n < e.byteLength; n += 1) {
    var r = e[n] % wm.length;
    t.push(wm[r]);
  }
  return t.join('');
}
Yn.bufferToString = nE;
function rE(e) {
  var t = h8.fromByteArray(new Uint8Array(e));
  return t.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
}
Yn.urlSafe = rE;
function iE(e) {
  for (var t = new ArrayBuffer(e.length), n = new Uint8Array(t), r = 0; r < e.length; r++)
    n[r] = e.charCodeAt(r);
  return n;
}
Yn.textEncodeLite = iE;
var g8 = (function () {
  function e() {}
  return (
    (e.prototype.generateRandom = function (t) {
      var n = new Uint8Array(t);
      if (tE) window.crypto.getRandomValues(n);
      else for (var r = 0; r < t; r += 1) n[r] = (Math.random() * wm.length) | 0;
      return nE(n);
    }),
    (e.prototype.deriveChallenge = function (t) {
      return t.length < 43 || t.length > 128
        ? Promise.reject(new a_.AppAuthError('Invalid code length.'))
        : p8
          ? new Promise(function (n, r) {
              crypto.subtle.digest('SHA-256', iE(t)).then(
                function (i) {
                  return n(rE(new Uint8Array(i)));
                },
                function (i) {
                  return r(i);
                }
              );
            })
          : Promise.reject(new a_.AppAuthError('window.crypto.subtle is unavailable.'));
    }),
    e
  );
})();
Yn.DefaultCrypto = g8;
var hi = {},
  X0 = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.IS_PROFILE = e.IS_LOG = e.setFlag = e.Flags = void 0),
    (e.Flags = { IS_LOG: !0, IS_PROFILE: !1 });
  function t(n, r) {
    e.Flags[n] = r;
  }
  (e.setFlag = t), (e.IS_LOG = e.Flags.IS_LOG), (e.IS_PROFILE = e.Flags.IS_PROFILE);
})(X0);
var _m =
  (g && g.__spreadArray) ||
  function (e, t, n) {
    if (n || arguments.length === 2)
      for (var r = 0, i = t.length, o; r < i; r++)
        (o || !(r in t)) && (o || (o = Array.prototype.slice.call(t, 0, r)), (o[r] = t[r]));
    return e.concat(o || Array.prototype.slice.call(t));
  };
Object.defineProperty(hi, '__esModule', { value: !0 });
hi.profile = hi.log = void 0;
var oE = X0;
function vm(e) {
  for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
  if (oE.Flags.IS_LOG) {
    var r = t ? t.length : 0;
    r > 0 ? console.log.apply(console, _m([e], t, !1)) : console.log(e);
  }
}
hi.log = vm;
var y8 = typeof window < 'u' && !!window.performance && !!console.profile;
function b8(e, t, n) {
  return oE.Flags.IS_PROFILE ? m8(e, t, n) : n;
}
hi.profile = b8;
function m8(e, t, n) {
  var r = n.value,
    i = r.name;
  return (
    i || (i = 'anonymous function'),
    y8
      ? (n.value = function (o) {
          console.profile(i);
          var a = window.performance.now(),
            c = r.call.apply(r, _m([this || window], o, !1)),
            s = window.performance.now() - a;
          return console.log(''.concat(i, ' took ').concat(s, ' ms')), console.profileEnd(), c;
        })
      : (n.value = function (o) {
          vm('Profile start '.concat(i));
          var a = Date.now(),
            c = r.call.apply(r, _m([this || window], o, !1)),
            s = Date.now() - a;
          return vm('Profile end '.concat(i, ' took ').concat(s, ' ms.')), c;
        }),
    n
  );
}
Object.defineProperty(xc, '__esModule', { value: !0 });
xc.AuthorizationRequest = void 0;
var w8 = Yn,
  _8 = hi,
  v8 = 10,
  S8 = function (e) {
    return e.generateRandom(v8);
  },
  A8 = (function () {
    function e(t, n, r) {
      n === void 0 && (n = new w8.DefaultCrypto()),
        r === void 0 && (r = !0),
        (this.crypto = n),
        (this.usePkce = r),
        (this.clientId = t.client_id),
        (this.redirectUri = t.redirect_uri),
        (this.scope = t.scope),
        (this.responseType = t.response_type || e.RESPONSE_TYPE_CODE),
        (this.state = t.state || S8(n)),
        (this.extras = t.extras),
        (this.internal = t.internal);
    }
    return (
      (e.prototype.setupCodeVerifier = function () {
        var t = this;
        if (this.usePkce) {
          var n = this.crypto.generateRandom(128),
            r = this.crypto.deriveChallenge(n).catch(function (i) {
              (0, _8.log)('Unable to generate PKCE challenge. Not using PKCE', i);
            });
          return r.then(function (i) {
            i &&
              ((t.internal = t.internal || {}),
              (t.internal.code_verifier = n),
              (t.extras = t.extras || {}),
              (t.extras.code_challenge = i),
              (t.extras.code_challenge_method = 'S256'));
          });
        } else return Promise.resolve();
      }),
      (e.prototype.toJson = function () {
        var t = this;
        return this.setupCodeVerifier().then(function () {
          return {
            response_type: t.responseType,
            client_id: t.clientId,
            redirect_uri: t.redirectUri,
            scope: t.scope,
            state: t.state,
            extras: t.extras,
            internal: t.internal,
          };
        });
      }),
      (e.RESPONSE_TYPE_TOKEN = 'token'),
      (e.RESPONSE_TYPE_CODE = 'code'),
      e
    );
  })();
xc.AuthorizationRequest = A8;
var e1 = {},
  Fp = {};
Object.defineProperty(Fp, '__esModule', { value: !0 });
Fp.requireValidUrl = void 0;
var I8 = co;
function E8(e) {
  try {
    return new URL(e), e;
  } catch {
    throw new I8.AppAuthError('Invalid input url '.concat(e));
  }
}
Fp.requireValidUrl = E8;
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.AuthorizationRequestHandler = e.BUILT_IN_PARAMETERS = e.AuthorizationNotifier = void 0);
  var t = hi,
    n = Fp,
    r = (function () {
      function o() {
        this.listener = null;
      }
      return (
        (o.prototype.setAuthorizationListener = function (a) {
          this.listener = a;
        }),
        (o.prototype.onAuthorizationComplete = function (a, c, s) {
          this.listener && this.listener(a, c, s);
        }),
        o
      );
    })();
  (e.AuthorizationNotifier = r),
    (e.BUILT_IN_PARAMETERS = ['redirect_uri', 'client_id', 'response_type', 'state', 'scope']);
  var i = (function () {
    function o(a, c) {
      (this.utils = a), (this.crypto = c), (this.notifier = null);
    }
    return (
      (o.prototype.buildRequestUrl = function (a, c) {
        var s = {
          redirect_uri: c.redirectUri,
          client_id: c.clientId,
          response_type: c.responseType,
          state: c.state,
          scope: c.scope,
        };
        if (c.extras)
          for (var l in c.extras)
            c.extras.hasOwnProperty(l) &&
              e.BUILT_IN_PARAMETERS.indexOf(l) < 0 &&
              (s[l] = c.extras[l]);
        var u = this.utils.stringify(s),
          d = (0, n.requireValidUrl)(a.authorizationEndpoint),
          f = ''.concat(d, '?').concat(u);
        return f;
      }),
      (o.prototype.completeAuthorizationRequestIfPossible = function () {
        var a = this;
        return (
          (0, t.log)('Checking to see if there is an authorization response to be delivered.'),
          this.notifier ||
            (0, t.log)(`Notifier is not present on AuthorizationRequest handler.
          No delivery of result will be possible`),
          this.completeAuthorizationRequest().then(function (c) {
            c || (0, t.log)('No result is available yet.'),
              c && a.notifier && a.notifier.onAuthorizationComplete(c.request, c.response, c.error);
          })
        );
      }),
      (o.prototype.setAuthorizationNotifier = function (a) {
        return (this.notifier = a), this;
      }),
      o
    );
  })();
  e.AuthorizationRequestHandler = i;
})(e1);
var zo = {};
Object.defineProperty(zo, '__esModule', { value: !0 });
zo.AuthorizationError = zo.AuthorizationResponse = void 0;
var T8 = (function () {
  function e(t) {
    (this.code = t.code), (this.state = t.state);
  }
  return (
    (e.prototype.toJson = function () {
      return { code: this.code, state: this.state };
    }),
    e
  );
})();
zo.AuthorizationResponse = T8;
var k8 = (function () {
  function e(t) {
    (this.error = t.error),
      (this.errorDescription = t.error_description),
      (this.errorUri = t.error_uri),
      (this.state = t.state);
  }
  return (
    (e.prototype.toJson = function () {
      return {
        error: this.error,
        error_description: this.errorDescription,
        error_uri: this.errorUri,
        state: this.state,
      };
    }),
    e
  );
})();
zo.AuthorizationError = k8;
var $p = {},
  Zn = {},
  t1 =
    (g && g.__extends) ||
    (function () {
      var e = function (t, n) {
        return (
          (e =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (r, i) {
                r.__proto__ = i;
              }) ||
            function (r, i) {
              for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (r[o] = i[o]);
            }),
          e(t, n)
        );
      };
      return function (t, n) {
        if (typeof n != 'function' && n !== null)
          throw new TypeError('Class extends value ' + String(n) + ' is not a constructor or null');
        e(t, n);
        function r() {
          this.constructor = t;
        }
        t.prototype = n === null ? Object.create(n) : ((r.prototype = n.prototype), new r());
      };
    })();
Object.defineProperty(Zn, '__esModule', { value: !0 });
Zn.TestRequestor = Zn.FetchRequestor = Zn.JQueryRequestor = Zn.Requestor = void 0;
var Sm = co,
  Wp = (function () {
    function e() {}
    return e;
  })();
Zn.Requestor = Wp;
var C8 = (function (e) {
  t1(t, e);
  function t() {
    return (e !== null && e.apply(this, arguments)) || this;
  }
  return (
    (t.prototype.xhr = function (n) {
      var r = $.ajax(n);
      return new Promise(function (i, o) {
        r.then(
          function (a, c, s) {
            i(a);
          },
          function (a, c, s) {
            o(new Sm.AppAuthError(s));
          }
        );
      });
    }),
    t
  );
})(Wp);
Zn.JQueryRequestor = C8;
var M8 = (function (e) {
  t1(t, e);
  function t() {
    return (e !== null && e.apply(this, arguments)) || this;
  }
  return (
    (t.prototype.xhr = function (n) {
      if (!n.url) return Promise.reject(new Sm.AppAuthError('A URL must be provided.'));
      var r = new URL(n.url),
        i = {};
      if (((i.method = n.method), (i.mode = 'cors'), n.data))
        if (n.method && n.method.toUpperCase() === 'POST') i.body = n.data;
        else {
          var o = new URLSearchParams(n.data);
          o.forEach(function (s, l) {
            r.searchParams.append(l, s);
          });
        }
      if (((i.headers = {}), n.headers))
        for (var a in n.headers) n.headers.hasOwnProperty(a) && (i.headers[a] = n.headers[a]);
      var c = n.dataType && n.dataType.toLowerCase() === 'json';
      return (
        c && (i.headers.Accept = 'application/json, text/javascript, */*; q=0.01'),
        fetch(r.toString(), i).then(function (s) {
          if (s.status >= 200 && s.status < 300) {
            var l = s.headers.get('content-type');
            return c || (l && l.indexOf('application/json') !== -1) ? s.json() : s.text();
          } else return Promise.reject(new Sm.AppAuthError(s.status.toString(), s.statusText));
        })
      );
    }),
    t
  );
})(Wp);
Zn.FetchRequestor = M8;
var P8 = (function (e) {
  t1(t, e);
  function t(n) {
    var r = e.call(this) || this;
    return (r.promise = n), r;
  }
  return (
    (t.prototype.xhr = function (n) {
      return this.promise;
    }),
    t
  );
})(Wp);
Zn.TestRequestor = P8;
Object.defineProperty($p, '__esModule', { value: !0 });
$p.AuthorizationServiceConfiguration = void 0;
var O8 = Zn,
  D8 = '.well-known',
  R8 = 'openid-configuration',
  x8 = (function () {
    function e(t) {
      (this.authorizationEndpoint = t.authorization_endpoint),
        (this.tokenEndpoint = t.token_endpoint),
        (this.revocationEndpoint = t.revocation_endpoint),
        (this.userInfoEndpoint = t.userinfo_endpoint),
        (this.endSessionEndpoint = t.end_session_endpoint);
    }
    return (
      (e.prototype.toJson = function () {
        return {
          authorization_endpoint: this.authorizationEndpoint,
          token_endpoint: this.tokenEndpoint,
          revocation_endpoint: this.revocationEndpoint,
          end_session_endpoint: this.endSessionEndpoint,
          userinfo_endpoint: this.userInfoEndpoint,
        };
      }),
      (e.fetchFromIssuer = function (t, n) {
        var r = ''.concat(t, '/').concat(D8, '/').concat(R8),
          i = n || new O8.JQueryRequestor();
        return i.xhr({ url: r, dataType: 'json', method: 'GET' }).then(function (o) {
          return new e(o);
        });
      }),
      e
    );
  })();
$p.AuthorizationServiceConfiguration = x8;
var gs = {};
Object.defineProperty(gs, '__esModule', { value: !0 });
gs.BasicQueryStringUtils = void 0;
var B8 = (function () {
  function e() {}
  return (
    (e.prototype.parse = function (t, n) {
      return n ? this.parseQueryString(t.hash) : this.parseQueryString(t.search);
    }),
    (e.prototype.parseQueryString = function (t) {
      var n = {};
      t = t.trim().replace(/^(\?|#|&)/, '');
      for (var r = t.split('&'), i = 0; i < r.length; i += 1) {
        var o = r[i],
          a = o.split('=');
        if (a.length >= 2) {
          var c = decodeURIComponent(a.shift()),
            s = a.length > 0 ? a.join('=') : null;
          s && (n[c] = decodeURIComponent(s));
        }
      }
      return n;
    }),
    (e.prototype.stringify = function (t) {
      var n = [];
      for (var r in t)
        t.hasOwnProperty(r) &&
          t[r] &&
          n.push(''.concat(encodeURIComponent(r), '=').concat(encodeURIComponent(t[r])));
      return n.join('&');
    }),
    e
  );
})();
gs.BasicQueryStringUtils = B8;
var Vp = {},
  Fo = {},
  j8 =
    (g && g.__extends) ||
    (function () {
      var e = function (t, n) {
        return (
          (e =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (r, i) {
                r.__proto__ = i;
              }) ||
            function (r, i) {
              for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (r[o] = i[o]);
            }),
          e(t, n)
        );
      };
      return function (t, n) {
        if (typeof n != 'function' && n !== null)
          throw new TypeError('Class extends value ' + String(n) + ' is not a constructor or null');
        e(t, n);
        function r() {
          this.constructor = t;
        }
        t.prototype = n === null ? Object.create(n) : ((r.prototype = n.prototype), new r());
      };
    })();
Object.defineProperty(Fo, '__esModule', { value: !0 });
Fo.LocalStorageBackend = Fo.StorageBackend = void 0;
var aE = (function () {
  function e() {}
  return e;
})();
Fo.StorageBackend = aE;
var N8 = (function (e) {
  j8(t, e);
  function t(n) {
    var r = e.call(this) || this;
    return (r.storage = n || window.localStorage), r;
  }
  return (
    (t.prototype.getItem = function (n) {
      var r = this;
      return new Promise(function (i, o) {
        var a = r.storage.getItem(n);
        i(a || null);
      });
    }),
    (t.prototype.removeItem = function (n) {
      var r = this;
      return new Promise(function (i, o) {
        r.storage.removeItem(n), i();
      });
    }),
    (t.prototype.clear = function () {
      var n = this;
      return new Promise(function (r, i) {
        n.storage.clear(), r();
      });
    }),
    (t.prototype.setItem = function (n, r) {
      var i = this;
      return new Promise(function (o, a) {
        i.storage.setItem(n, r), o();
      });
    }),
    t
  );
})(aE);
Fo.LocalStorageBackend = N8;
var U8 =
  (g && g.__extends) ||
  (function () {
    var e = function (t, n) {
      return (
        (e =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (r, i) {
              r.__proto__ = i;
            }) ||
          function (r, i) {
            for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (r[o] = i[o]);
          }),
        e(t, n)
      );
    };
    return function (t, n) {
      if (typeof n != 'function' && n !== null)
        throw new TypeError('Class extends value ' + String(n) + ' is not a constructor or null');
      e(t, n);
      function r() {
        this.constructor = t;
      }
      t.prototype = n === null ? Object.create(n) : ((r.prototype = n.prototype), new r());
    };
  })();
Object.defineProperty(Vp, '__esModule', { value: !0 });
Vp.RedirectRequestHandler = void 0;
var L8 = xc,
  z8 = e1,
  s_ = zo,
  F8 = Yn,
  Hf = hi,
  $8 = gs,
  W8 = Fo,
  By = function (e) {
    return ''.concat(e, '_appauth_authorization_request');
  },
  c_ = function (e) {
    return ''.concat(e, '_appauth_authorization_service_configuration');
  },
  jy = 'appauth_current_authorization_request',
  V8 = (function (e) {
    U8(t, e);
    function t(n, r, i, o) {
      n === void 0 && (n = new W8.LocalStorageBackend()),
        r === void 0 && (r = new $8.BasicQueryStringUtils()),
        i === void 0 && (i = window.location),
        o === void 0 && (o = new F8.DefaultCrypto());
      var a = e.call(this, r, o) || this;
      return (a.storageBackend = n), (a.locationLike = i), a;
    }
    return (
      (t.prototype.performAuthorizationRequest = function (n, r) {
        var i = this,
          o = this.crypto.generateRandom(10),
          a = Promise.all([
            this.storageBackend.setItem(jy, o),
            r.toJson().then(function (c) {
              return i.storageBackend.setItem(By(o), JSON.stringify(c));
            }),
            this.storageBackend.setItem(c_(o), JSON.stringify(n.toJson())),
          ]);
        a.then(function () {
          var c = i.buildRequestUrl(n, r);
          (0, Hf.log)('Making a request to ', r, c), i.locationLike.assign(c);
        });
      }),
      (t.prototype.completeAuthorizationRequest = function () {
        var n = this;
        return this.storageBackend.getItem(jy).then(function (r) {
          return r
            ? n.storageBackend
                .getItem(By(r))
                .then(function (i) {
                  return JSON.parse(i);
                })
                .then(function (i) {
                  return new L8.AuthorizationRequest(i);
                })
                .then(function (i) {
                  var o = ''.concat(n.locationLike.origin).concat(n.locationLike.pathname),
                    a = n.utils.parse(n.locationLike, !0),
                    c = a.state,
                    s = a.code,
                    l = a.error;
                  (0, Hf.log)('Potential authorization request ', o, a, c, s, l);
                  var u = c === i.state,
                    d = null,
                    f = null;
                  if (u) {
                    if (l) {
                      var p = a.error_uri,
                        y = a.error_description;
                      f = new s_.AuthorizationError({
                        error: l,
                        error_description: y,
                        error_uri: p,
                        state: c,
                      });
                    } else d = new s_.AuthorizationResponse({ code: s, state: c });
                    return Promise.all([
                      n.storageBackend.removeItem(jy),
                      n.storageBackend.removeItem(By(r)),
                      n.storageBackend.removeItem(c_(r)),
                    ]).then(function () {
                      return (
                        (0, Hf.log)('Delivering authorization response'),
                        { request: i, response: d, error: f }
                      );
                    });
                  } else
                    return (
                      (0, Hf.log)('Mismatched request (state and request_uri) dont match.'),
                      Promise.resolve(null)
                    );
                })
            : null;
        });
      }),
      t
    );
  })(z8.AuthorizationRequestHandler);
Vp.RedirectRequestHandler = V8;
var Kp = {};
Object.defineProperty(Kp, '__esModule', { value: !0 });
Kp.RevokeTokenRequest = void 0;
var K8 = (function () {
  function e(t) {
    (this.token = t.token),
      (this.tokenTypeHint = t.token_type_hint),
      (this.clientId = t.client_id),
      (this.clientSecret = t.client_secret);
  }
  return (
    (e.prototype.toJson = function () {
      var t = { token: this.token };
      return (
        this.tokenTypeHint && (t.token_type_hint = this.tokenTypeHint),
        this.clientId && (t.client_id = this.clientId),
        this.clientSecret && (t.client_secret = this.clientSecret),
        t
      );
    }),
    (e.prototype.toStringMap = function () {
      var t = this.toJson();
      return t;
    }),
    e
  );
})();
Kp.RevokeTokenRequest = K8;
var Zi = {};
Object.defineProperty(Zi, '__esModule', { value: !0 });
Zi.TokenRequest = Zi.GRANT_TYPE_REFRESH_TOKEN = Zi.GRANT_TYPE_AUTHORIZATION_CODE = void 0;
Zi.GRANT_TYPE_AUTHORIZATION_CODE = 'authorization_code';
Zi.GRANT_TYPE_REFRESH_TOKEN = 'refresh_token';
var H8 = (function () {
  function e(t) {
    (this.clientId = t.client_id),
      (this.redirectUri = t.redirect_uri),
      (this.grantType = t.grant_type),
      (this.code = t.code),
      (this.refreshToken = t.refresh_token),
      (this.extras = t.extras);
  }
  return (
    (e.prototype.toJson = function () {
      return {
        grant_type: this.grantType,
        code: this.code,
        refresh_token: this.refreshToken,
        redirect_uri: this.redirectUri,
        client_id: this.clientId,
        extras: this.extras,
      };
    }),
    (e.prototype.toStringMap = function () {
      var t = {
        grant_type: this.grantType,
        client_id: this.clientId,
        redirect_uri: this.redirectUri,
      };
      if (
        (this.code && (t.code = this.code),
        this.refreshToken && (t.refresh_token = this.refreshToken),
        this.extras)
      )
        for (var n in this.extras)
          this.extras.hasOwnProperty(n) && !t.hasOwnProperty(n) && (t[n] = this.extras[n]);
      return t;
    }),
    e
  );
})();
Zi.TokenRequest = H8;
var Hp = {},
  n1 = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.TokenError = e.TokenResponse = e.nowInSeconds = void 0);
  var t = 10 * 60 * -1,
    n = function () {
      return Math.round(new Date().getTime() / 1e3);
    };
  e.nowInSeconds = n;
  var r = (function () {
    function o(a) {
      (this.accessToken = a.access_token),
        (this.tokenType = a.token_type || 'bearer'),
        a.expires_in && (this.expiresIn = parseInt(a.expires_in, 10)),
        (this.refreshToken = a.refresh_token),
        (this.scope = a.scope),
        (this.idToken = a.id_token),
        (this.issuedAt = a.issued_at || (0, e.nowInSeconds)());
    }
    return (
      (o.prototype.toJson = function () {
        var a;
        return {
          access_token: this.accessToken,
          id_token: this.idToken,
          refresh_token: this.refreshToken,
          scope: this.scope,
          token_type: this.tokenType,
          issued_at: this.issuedAt,
          expires_in: (a = this.expiresIn) === null || a === void 0 ? void 0 : a.toString(),
        };
      }),
      (o.prototype.isValid = function (a) {
        if ((a === void 0 && (a = t), this.expiresIn)) {
          var c = (0, e.nowInSeconds)();
          return c < this.issuedAt + this.expiresIn + a;
        } else return !0;
      }),
      o
    );
  })();
  e.TokenResponse = r;
  var i = (function () {
    function o(a) {
      (this.error = a.error),
        (this.errorDescription = a.error_description),
        (this.errorUri = a.error_uri);
    }
    return (
      (o.prototype.toJson = function () {
        return {
          error: this.error,
          error_description: this.errorDescription,
          error_uri: this.errorUri,
        };
      }),
      o
    );
  })();
  e.TokenError = i;
})(n1);
Object.defineProperty(Hp, '__esModule', { value: !0 });
Hp.BaseTokenRequestHandler = void 0;
var q8 = co,
  G8 = gs,
  u_ = n1,
  Y8 = Zn,
  Z8 = (function () {
    function e(t, n) {
      t === void 0 && (t = new Y8.JQueryRequestor()),
        n === void 0 && (n = new G8.BasicQueryStringUtils()),
        (this.requestor = t),
        (this.utils = n);
    }
    return (
      (e.prototype.isTokenResponse = function (t) {
        return t.error === void 0;
      }),
      (e.prototype.performRevokeTokenRequest = function (t, n) {
        var r = this.requestor.xhr({
          url: t.revocationEndpoint,
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          data: this.utils.stringify(n.toStringMap()),
        });
        return r.then(function (i) {
          return !0;
        });
      }),
      (e.prototype.performTokenRequest = function (t, n) {
        var r = this,
          i = this.requestor.xhr({
            url: t.tokenEndpoint,
            method: 'POST',
            dataType: 'json',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            data: this.utils.stringify(n.toStringMap()),
          });
        return i.then(function (o) {
          return r.isTokenResponse(o)
            ? new u_.TokenResponse(o)
            : Promise.reject(new q8.AppAuthError(o.error, new u_.TokenError(o)));
        });
      }),
      e
    );
  })();
Hp.BaseTokenRequestHandler = Z8;
var sE = {};
Object.defineProperty(sE, '__esModule', { value: !0 });
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (r, i, o, a) {
            a === void 0 && (a = o);
            var c = Object.getOwnPropertyDescriptor(i, o);
            (!c || ('get' in c ? !i.__esModule : c.writable || c.configurable)) &&
              (c = {
                enumerable: !0,
                get: function () {
                  return i[o];
                },
              }),
              Object.defineProperty(r, a, c);
          }
        : function (r, i, o, a) {
            a === void 0 && (a = o), (r[a] = i[o]);
          }),
    n =
      (g && g.__exportStar) ||
      function (r, i) {
        for (var o in r)
          o !== 'default' && !Object.prototype.hasOwnProperty.call(i, o) && t(i, r, o);
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    n(xc, e),
    n(e1, e),
    n(zo, e),
    n($p, e),
    n(Yn, e),
    n(co, e),
    n(X0, e),
    n(hi, e),
    n(gs, e),
    n(Vp, e),
    n(Kp, e),
    n(Fo, e),
    n(Zi, e),
    n(Hp, e),
    n(n1, e),
    n(sE, e),
    n(Zn, e);
})(Yi);
function Am(e) {
  if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`);
}
function Q8(e) {
  if (typeof e != 'boolean') throw new Error(`Expected boolean, not ${e}`);
}
function cE(e, ...t) {
  if (!(e instanceof Uint8Array)) throw new TypeError('Expected Uint8Array');
  if (t.length > 0 && !t.includes(e.length))
    throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function J8(e) {
  if (typeof e != 'function' || typeof e.create != 'function')
    throw new Error('Hash should be wrapped by utils.wrapConstructor');
  Am(e.outputLen), Am(e.blockLen);
}
function X8(e, t = !0) {
  if (e.destroyed) throw new Error('Hash instance has been destroyed');
  if (t && e.finished) throw new Error('Hash#digest() has already been called');
}
function eR(e, t) {
  cE(e);
  const n = t.outputLen;
  if (e.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`);
}
const Ny = { number: Am, bool: Q8, bytes: cE, hash: J8, exists: X8, output: eR };
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Uy = (e) =>
    new DataView(e.buffer, e.byteOffset, e.byteLength),
  Ar = (e, t) => (e << (32 - t)) | (e >>> t),
  tR = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!tR) throw new Error('Non little-endian hardware is not supported');
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, '0'));
function nR(e) {
  if (typeof e != 'string') throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function uE(e) {
  if ((typeof e == 'string' && (e = nR(e)), !(e instanceof Uint8Array)))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
  return e;
}
let rR = class {
  clone() {
    return this._cloneInto();
  }
};
function lE(e) {
  const t = (r) => e().update(uE(r)).digest(),
    n = e();
  return (t.outputLen = n.outputLen), (t.blockLen = n.blockLen), (t.create = () => e()), t;
}
function iR(e, t, n, r) {
  if (typeof e.setBigUint64 == 'function') return e.setBigUint64(t, n, r);
  const i = BigInt(32),
    o = BigInt(4294967295),
    a = Number((n >> i) & o),
    c = Number(n & o),
    s = r ? 4 : 0,
    l = r ? 0 : 4;
  e.setUint32(t + s, a, r), e.setUint32(t + l, c, r);
}
let oR = class extends rR {
  constructor(t, n, r, i) {
    super(),
      (this.blockLen = t),
      (this.outputLen = n),
      (this.padOffset = r),
      (this.isLE = i),
      (this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.buffer = new Uint8Array(t)),
      (this.view = Uy(this.buffer));
  }
  update(t) {
    Ny.exists(this);
    const { view: n, buffer: r, blockLen: i } = this;
    t = uE(t);
    const o = t.length;
    for (let a = 0; a < o; ) {
      const c = Math.min(i - this.pos, o - a);
      if (c === i) {
        const s = Uy(t);
        for (; i <= o - a; a += i) this.process(s, a);
        continue;
      }
      r.set(t.subarray(a, a + c), this.pos),
        (this.pos += c),
        (a += c),
        this.pos === i && (this.process(n, 0), (this.pos = 0));
    }
    return (this.length += t.length), this.roundClean(), this;
  }
  digestInto(t) {
    Ny.exists(this), Ny.output(t, this), (this.finished = !0);
    const { buffer: n, view: r, blockLen: i, isLE: o } = this;
    let { pos: a } = this;
    (n[a++] = 128),
      this.buffer.subarray(a).fill(0),
      this.padOffset > i - a && (this.process(r, 0), (a = 0));
    for (let d = a; d < i; d++) n[d] = 0;
    iR(r, i - 8, BigInt(this.length * 8), o), this.process(r, 0);
    const c = Uy(t),
      s = this.outputLen;
    if (s % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
    const l = s / 4,
      u = this.get();
    if (l > u.length) throw new Error('_sha2: outputLen bigger than state');
    for (let d = 0; d < l; d++) c.setUint32(4 * d, u[d], o);
  }
  digest() {
    const { buffer: t, outputLen: n } = this;
    this.digestInto(t);
    const r = t.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: n, buffer: r, length: i, finished: o, destroyed: a, pos: c } = this;
    return (
      (t.length = i), (t.pos = c), (t.finished = o), (t.destroyed = a), i % n && t.buffer.set(r), t
    );
  }
};
const aR = (e, t, n) => (e & t) ^ (~e & n),
  sR = (e, t, n) => (e & t) ^ (e & n) ^ (t & n),
  cR = new Uint32Array([
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221,
    3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580,
    3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895,
    666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037,
    2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
    1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298,
  ]),
  wi = new Uint32Array([
    1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225,
  ]),
  _i = new Uint32Array(64);
let dE = class extends oR {
    constructor() {
      super(64, 32, 8, !1),
        (this.A = wi[0] | 0),
        (this.B = wi[1] | 0),
        (this.C = wi[2] | 0),
        (this.D = wi[3] | 0),
        (this.E = wi[4] | 0),
        (this.F = wi[5] | 0),
        (this.G = wi[6] | 0),
        (this.H = wi[7] | 0);
    }
    get() {
      const { A: t, B: n, C: r, D: i, E: o, F: a, G: c, H: s } = this;
      return [t, n, r, i, o, a, c, s];
    }
    set(t, n, r, i, o, a, c, s) {
      (this.A = t | 0),
        (this.B = n | 0),
        (this.C = r | 0),
        (this.D = i | 0),
        (this.E = o | 0),
        (this.F = a | 0),
        (this.G = c | 0),
        (this.H = s | 0);
    }
    process(t, n) {
      for (let d = 0; d < 16; d++, n += 4) _i[d] = t.getUint32(n, !1);
      for (let d = 16; d < 64; d++) {
        const f = _i[d - 15],
          p = _i[d - 2],
          y = Ar(f, 7) ^ Ar(f, 18) ^ (f >>> 3),
          b = Ar(p, 17) ^ Ar(p, 19) ^ (p >>> 10);
        _i[d] = (b + _i[d - 7] + y + _i[d - 16]) | 0;
      }
      let { A: r, B: i, C: o, D: a, E: c, F: s, G: l, H: u } = this;
      for (let d = 0; d < 64; d++) {
        const f = Ar(c, 6) ^ Ar(c, 11) ^ Ar(c, 25),
          p = (u + f + aR(c, s, l) + cR[d] + _i[d]) | 0,
          b = ((Ar(r, 2) ^ Ar(r, 13) ^ Ar(r, 22)) + sR(r, i, o)) | 0;
        (u = l), (l = s), (s = c), (c = (a + p) | 0), (a = o), (o = i), (i = r), (r = (p + b) | 0);
      }
      (r = (r + this.A) | 0),
        (i = (i + this.B) | 0),
        (o = (o + this.C) | 0),
        (a = (a + this.D) | 0),
        (c = (c + this.E) | 0),
        (s = (s + this.F) | 0),
        (l = (l + this.G) | 0),
        (u = (u + this.H) | 0),
        this.set(r, i, o, a, c, s, l, u);
    }
    roundClean() {
      _i.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
    }
  },
  uR = class extends dE {
    constructor() {
      super(),
        (this.A = -1056596264),
        (this.B = 914150663),
        (this.C = 812702999),
        (this.D = -150054599),
        (this.E = -4191439),
        (this.F = 1750603025),
        (this.G = 1694076839),
        (this.H = -1090891868),
        (this.outputLen = 28);
    }
  };
const lR = lE(() => new dE());
lE(() => new uR());
const dR = {
  generateRandom: (e) => {
    const t = j4.randomBytes(e);
    return Yi.bufferToString(t);
  },
  async deriveChallenge(e) {
    const t = lR(Yi.textEncodeLite(e));
    return Yi.urlSafe(t);
  },
};
var fR = {};
const uo = () => {
    const e = cm();
    return e === ic.Staging
      ? Ry.staging
      : e === ic.Production
        ? Ry.prod
        : fR.BASE_AUTH_ENDPOINT || Ry.staging;
  },
  hR = () => `${uo()}${FD}`,
  fE = () => `${uo()}${$D}`,
  hE = new Yi.BasicQueryStringUtils();
async function Ly(e, t) {
  const { url: n, codeVerifier: r } = await pR(e.getClientID(), e.redirectURL, t),
    i = t.type === 'email',
    o = await e.fetchAuthorizationCode(e.redirectURL, n, i);
  return await pE({
    grantType: 'authorization_code',
    clientID: e.getClientID(),
    redirectURI: e.redirectURL,
    tokenEndpoint: fE(),
    code: o,
    codeVerifier: r,
  });
}
async function pR(e, t, n) {
  var m, w, _;
  const r = hR();
  let i;
  const o = ['openid', 'offline_access', 'user', 'incognito', 'seedless'];
  let a;
  switch (n.type) {
    case 'key': {
      i = { type: 'key', jwt: J0(n.clientJWT) };
      break;
    }
    case 'email': {
      (i = { type: 'email', provider: n.provider, existingAccessToken: n.existingAccessToken }),
        (a = n.prompt),
        o.push('email');
      break;
    }
    case 'session': {
      i = { type: 'session', existingAccessToken: n.existingAccessToken };
      break;
    }
  }
  const s = await new Yi.AuthorizationRequest(
    { client_id: e, redirect_uri: t, scope: o.join(' '), response_type: 'code' },
    dR
  ).toJson();
  let l;
  switch (i.type) {
    case 'key':
      l = `jwt:${mm(Y.from(i.jwt, 'utf8'))}`;
      break;
    case 'email':
      (l = `sso:${i.provider}`), i.existingAccessToken && (l = `${l}:${i.existingAccessToken}`);
      break;
    case 'session':
      l = `session:${i.existingAccessToken}`;
      break;
  }
  const u = {
    redirect_uri: s.redirect_uri,
    client_id: s.client_id,
    response_type: s.response_type,
    state: s.state ?? '',
    scope: s.scope,
    login_hint: l,
  };
  a && (u.prompt = a);
  const d = (m = s.extras) == null ? void 0 : m.code_challenge,
    f = (w = s.extras) == null ? void 0 : w.code_challenge_method,
    p = (_ = s.internal) == null ? void 0 : _.code_verifier;
  if ((d && f && ((u.code_challenge = d), (u.code_challenge_method = f)), !d || !f || !p))
    throw new Error('Missing code challenge or code verifier for PKCE.');
  const y = hE.stringify(u);
  return { url: `${r}?${y}`, codeVerifier: p };
}
async function pE(e) {
  const { grantType: t, tokenEndpoint: n, clientID: r, redirectURI: i } = e;
  let o;
  t === 'authorization_code'
    ? (o = new Yi.TokenRequest({
        client_id: r,
        redirect_uri: i,
        grant_type: t,
        code: e.code,
        extras: { code_verifier: e.codeVerifier },
      }))
    : (o = new Yi.TokenRequest({
        client_id: r,
        redirect_uri: i,
        grant_type: t,
        refresh_token: e.refreshToken,
      }));
  const a = await ke
    .headers({ 'Content-Type': 'application/x-www-form-urlencoded' }, { mergeHeaders: !1 })
    .auth(c3())
    .post(n, hE.stringify(o.toStringMap()));
  gR(a, t);
  const c = n8.safeParse(a.data);
  if (!c.success) throw new Error('Invalid OAuth2Token response.');
  const { data: s } = c;
  return {
    idToken: s.id_token,
    accessToken: s.access_token,
    refreshToken: s.refresh_token,
    scope: s.scope,
    tokenType: s.token_type,
    expiresAt: Date.now() + s.expires_in * 1e3,
  };
}
async function gE(e, t) {
  return await pE({
    clientID: e.getClientID(),
    redirectURI: e.redirectURL,
    grantType: 'refresh_token',
    tokenEndpoint: fE(),
    refreshToken: t,
  });
}
function gR(e, t) {
  if ([401, 400].includes(e.status)) {
    let n = '';
    if (e.status === 401)
      switch (((n = 'Token Request Unauthorized (401): '), t)) {
        case 'authorization_code':
          n += 'Authorization code is expired or invalid.';
          break;
        case 'refresh_token':
          n += 'Refresh token is expired or invalid.';
          break;
        default:
          n += `Unknown grant type [${t}]. `;
      }
    if (e.status === 400)
      switch (((n = 'Bad Token Request (400): '), t)) {
        case 'authorization_code':
          n =
            'for [authorization_code]. Possible causes: 1. The authorization code is expired or invalid. 2. Redirect URI mismatch. 3. Code verifier mismatch (if using PKCE).';
          break;
        case 'refresh_token':
          n =
            'for [refresh_token]. Possible causes: 1. The refresh token is expired, invalid, or revoked. 2. Client ID mismatch. 3. Missing or malformed refresh token in the request.';
          break;
        default:
          n = `for unknown grant type [${t}]. Check the payload and OAuth provider documentation.`;
      }
    throw new Error(n);
  }
}
class yR {
  constructor() {
    Le(this, 'subscribers', {});
  }
  subscribe(t, n) {
    return (
      this.subscribers[t] || (this.subscribers[t] = []),
      this.subscribers[t].push(n),
      () => {
        this.subscribers[t].splice(this.subscribers[t].indexOf(n), 1);
      }
    );
  }
  emitEvent(t, ...n) {
    (this.subscribers[t] ?? []).forEach((i) => i(...n));
  }
}
class bR extends yR {
  emit(t) {
    t &&
      (this.emitEvent(Ao.User, t),
      this.emitEvent(Ao.UserID, t.userID),
      this.emitEvent(Ao.AccessToken, t.accessToken),
      t.email && this.emitEvent(Ao.Email, t.email));
  }
  emitLoggedOut() {
    this.emitEvent(Ao.LoggedOut);
  }
}
function Bc(e, t = 'expected value not found') {
  if (e == null) throw new Error(t);
  return e;
}
const yE = async (e, t) => {
    const n = uo(),
      r = Bc(e.signer, 'Signer is required for key-based auth.'),
      i = await r.getAuthenticationPublicKey(t),
      o = await Q0(e.isServerTimeEnabled()),
      a = await r.sign(o, t),
      c = await ke.get(`${n}${Rc}`, { params: { token: J0(a) } });
    if (!hn(c)) throw new Error('Failed to get authentication keys: response is not okay');
    const s = c.data;
    return (XI.parse(s).authenticationKeys ?? []).some((d) => d.publicKey === i);
  },
  mR = async (e) => {
    try {
      const t = await ke
        .headers({ 'Content-Type': 'application/x-www-form-urlencoded' }, { mergeHeaders: !1 })
        .bearer(e)
        .get(`${uo()}/userinfo`);
      return hn(t);
    } catch {
      return !1;
    }
  },
  bE = '.phantom.auth',
  Va = `${bE}.tokens`,
  wR = `${bE}.authentication-factors`,
  _R = (e) => Y.from(e.replace('-', '+').replace('_', '/').replace(/=+$/, ''), 'base64'),
  np = (e) => {
    const t = e.idToken.split('.');
    if (t.length !== 3)
      throw new Error('Malformed ID token. Expected 3 period-delimited parts to ID token.');
    let n;
    try {
      const r = _R(t[1]).toString('utf-8'),
        i = JSON.parse(r);
      n = r8.parse(i);
    } catch {
      throw new Error('Unable to parse ID token payload.');
    }
    return { accessToken: e.accessToken, userID: n.sub, email: n.email };
  },
  l_ = '@phantom/auth',
  r1 = { user: ['auth', `${l_}:user`], authFactors: ['auth', `${l_}:user-auth-factors`] },
  mE = async (e, t, n) => {
    const { storage: r, authConfig: i } = e;
    let o;
    const { type: a } = n;
    switch (a) {
      case 'key': {
        const s = Bc(e.signer, 'Signer is required for key-based auth.'),
          l = await Q0(e.isServerTimeEnabled()),
          u = await s.sign(l, n.secretIdentifier);
        o = await Ly(i, { type: a, clientJWT: u });
        break;
      }
      case 'email': {
        o = await Ly(i, { type: a, prompt: n.prompt, provider: n.provider });
        break;
      }
      case 'session': {
        o = await Ly(i, { type: a, existingAccessToken: n.accessToken });
        break;
      }
    }
    await r.set(Va, o);
    const c = np(o);
    return await e.queryClient.setQueryData(r1.user, c), t.emit(c), c;
  },
  wE = { queryKey: r1.user, gcTime: VD, staleTime: ae({ minutes: 5 }) },
  jc = async (e, t) => await e.queryClient.fetchQuery({ ...wE, queryFn: () => _E(e, t) }),
  vR = (e, t) =>
    pt({
      ...wE,
      queryFn: async () => {
        const n = await _E(e, t);
        if (!n) throw new Error('Unable to log in.');
        return n;
      },
      retryOnMount: !1,
    }),
  _E = async (e, t) => {
    const n = async () => {
      const r = await SR(e);
      return r || (e.signer ? await AR(e, t) : null);
    };
    return e.runExclusive(async () => {
      const r = await n();
      return t.emit(r), r;
    });
  };
async function SR({ storage: e, authConfig: t }) {
  const n = await e.get(Va);
  if (!n) return null;
  if (await mR(n.accessToken)) return np(n);
  if (n.refreshToken)
    try {
      const r = await gE(t, n.refreshToken);
      return await e.set(Va, r), np(r);
    } catch (r) {
      return (
        Z.addBreadcrumb('Error refreshing auth token.', te.Auth, Te.Error),
        Z.captureError(r, te.Auth),
        null
      );
    }
  return null;
}
async function AR(e, t) {
  const r = await Bc(
    e.signer,
    'Unable to log in with key-based auth. Signer is not available.'
  ).getAllSecretIdentifiers();
  if (r.length === 0)
    return (
      Z.addBreadcrumb(
        'Unable to log in with key-based auth. Vault is not yet onboarded or has no secrets that can perform key-based auth.',
        te.Auth,
        Te.Info
      ),
      null
    );
  let i;
  try {
    for (const o of r)
      if (await yE(e, o)) {
        i = o;
        break;
      }
  } catch (o) {
    throw (
      (Z.addBreadcrumb(
        'Unable to log in with key-based auth. Error checking auth factors.',
        te.Auth,
        Te.Error
      ),
      o)
    );
  }
  if (!i)
    return (
      Z.addBreadcrumb(
        'Unable to log in with key-based auth. No auth factor found for login.',
        te.Auth,
        Te.Info
      ),
      null
    );
  try {
    return await mE(e, t, { type: 'key', secretIdentifier: i });
  } catch (o) {
    throw (
      (Z.addBreadcrumb(
        'Unable to log in with key-based auth. Error performing auth.',
        te.Auth,
        Te.Error
      ),
      o)
    );
  }
}
const IR = (e) => {
    const t = new bR(),
      n = {
        getUser: () => jc(e, t),
        useUser: () => vR(e, t),
        refreshTokens: () => ER(e),
        logIn: (r) => mE(e, t, r),
        isExistingAuthFactor: (r) => yE(e, r),
        getAuthenticationKeys: () => TR(e, t),
        getLocalAuthenticationPublicKeys: () => kR(e),
        addAuthFactor: (r) => CR(e, t, r),
        deleteAuthFactor: (r) => MR(e, t, r),
        deleteAllAuthFactors: () => PR(e, t),
        subscribe: (r, i) => t.subscribe(r, i),
        logOut: () => OR(e, t),
      };
    return (
      q6(async () => {
        const r = await n.getUser();
        return (r == null ? void 0 : r.accessToken) ?? null;
      }),
      n
    );
  },
  ER = async (e) => {
    const t = await e.storage.get(Va);
    if (!t) return !1;
    const n = await gE(e.authConfig, t.refreshToken);
    return await e.storage.set(Va, n), await e.queryClient.setQueryData(r1.user, np(n)), !0;
  },
  TR = async (e, t) => ({ authenticationPublicKeys: (await vE(e, t)).map((r) => r.publicKey) }),
  vE = async (e, t) => {
    const n = uo(),
      r = await jc(e, t);
    if (!r) throw new Error('User not authenticated.');
    const { data: i } = await ke.bearer(r.accessToken).get(`${n}${Rc}`),
      o = XI.safeParse(i);
    if (!o.success) throw new Error('Unable to parse auth factors response.');
    return o.data.authenticationKeys ?? [];
  },
  kR = async (e) => {
    try {
      const t = Bc(e.signer, 'Signer is required for key-based auth.'),
        n = await t.getAllSecretIdentifiers(),
        r = {};
      for (const i of n) r[i] = await t.getAuthenticationPublicKey(i);
      return r;
    } catch {
      return {};
    }
  },
  CR = async (e, t, { secretIdentifier: n }) => {
    const r = uo(),
      i = Bc(e.signer, 'Signer is required for key-based auth.'),
      o = await jc(e, t);
    if (!o) throw new Error('User not authenticated.');
    const a = await Q0(e.isServerTimeEnabled()),
      c = await i.sign(a, n);
    await ke.bearer(o.accessToken).post(`${r}${Rc}`, { jwt: J0(c) });
  },
  MR = async (e, t, { authenticationPublicKey: n }) => {
    const r = uo(),
      i = await jc(e, t);
    if (!i) throw new Error('User not authenticated.');
    await ke.bearer(i.accessToken).delete(`${r}${Rc}/${encodeURIComponent(n)}`);
  },
  PR = async (e, t) => {
    const n = uo(),
      r = e.storage,
      i = await jc(e, t);
    if (!i) throw new Error('User not authenticated.');
    const o = await vE(e, t);
    await Promise.all(o.map((a) => ke.bearer(i.accessToken).delete(`${n}${Rc}/${a.id}`))),
      await r.remove(wR);
  },
  OR = async ({ storage: e }, t) => {
    await e.remove(Va), t.emitLoggedOut();
  },
  SE = G.createContext(null);
function DR({ children: e, authRepository: t }) {
  return A.jsx(SE.Provider, { value: t, children: e });
}
function RR() {
  const e = G.useContext(SE);
  if (!e) throw new Error('useAuthRepository must be used within an AuthProvider');
  return e;
}
function ys() {
  return RR().useUser();
}
const xR = () => {
    const { data: e } = ys();
    return !!e;
  },
  AE = G.createContext(null);
function BR({ children: e, analytics: t }) {
  return A.jsx(AE.Provider, { value: t, children: e });
}
function qp() {
  const e = G.useContext(AE);
  if (!e) throw new Error('useAnalytics must be used within a AnalyticsProvider');
  return e;
}
const IE = G.createContext(null);
function jR({ children: e, userRepository: t, claimUsernameSigner: n }) {
  return A.jsx(IE.Provider, { value: { userRepository: t, claimUsernameSigner: n }, children: e });
}
function NR() {
  const e = G.useContext(IE);
  if (!e) throw new Error('useUserContext must be used within a UserProvider');
  return e;
}
function EE() {
  return NR().userRepository;
}
class UR extends Error {
  constructor(t = 'No user profile.') {
    super(t), (this.name = 'NoUserProfileError');
  }
}
const LR = ae({ days: 1 }),
  zR = ae({ minutes: 1 });
function Tue() {
  const e = EE(),
    t = xR(),
    n = tp.userProfile();
  return pt({
    enabled: t,
    queryKey: n,
    queryFn: async () => {
      const i = await e.getUserProfile();
      if (!i) throw new UR();
      return i;
    },
    gcTime: LR,
    staleTime: zR,
  });
}
ae({ days: 1 });
ae({ minutes: 1 });
async function FR(e, t) {
  let n = await e.get(Jn.AccountsMetadata);
  n || (n = { version: 1, accounts: {} });
  let r = n.accounts[t];
  return r || (r = { name: Et.t('onboardingImportAccountsAccountName', { walletIndex: '' }) }), r;
}
async function $R(e) {
  const t = await e.get(Jn.AccountsMetadata);
  return t ? t.accounts : {};
}
const TE = async (e) => {
  const t = await e.get(Jn.NetworkSetting),
    n = await Un.isFeatureEnabledAsync('enable-sui-testnet');
  if (!t) return NI(n);
  const r = WR(t, n);
  return VR(e, r);
};
function WR(e, t) {
  const n = { ...e, setting: { ...e.setting } };
  return (
    t && !n.setting[X.Sui]
      ? (n.setting[X.Sui] = NI(t).setting[X.Sui])
      : !t && n.setting[X.Sui] && delete n.setting[X.Sui],
    n
  );
}
const VR = async (e, t) => {
    let n = !1;
    KR(t) && (n = !0);
    const r = t.setting[X.Solana];
    r && q.isMainnetNetworkID(r) && ((t.setting[X.Solana] = H0), (n = !0));
    const i = t.setting[X.EVM];
    return (
      i && q.isMainnetNetworkID(i) && ((t.setting[X.EVM] = q0), (n = !0)),
      n && (await e.set(Jn.NetworkSetting, t)),
      t
    );
  },
  KR = (e) => {
    let t = !1;
    const n = e.setting[X.EVM];
    return (
      n &&
        (n.toString() === 'eip155:5' && ((e.setting[X.EVM] = ce.Ethereum.Sepolia), (t = !0)),
        n.toString() === 'eip155:80001' && ((e.setting[X.EVM] = ce.Polygon.Amoy), (t = !0))),
      t
    );
  },
  HR = async (e, t, n) => {
    const r = await e.fetchAllAccounts();
    if (r.length === 0) return [];
    const i = t.get(Jn.DeveloperMode),
      o = TE(t),
      a = $R(t),
      [c, s, l] = await Promise.all([i, o, a]);
    return r.map((u) => {
      let d = l[u.identifier];
      d || (d = { name: Et.t('onboardingImportAccountsAccountName', { walletIndex: '' }) });
      const f = {
        name: d.name,
        icon: d.icon,
        identifier: u.identifier,
        addresses: UI(
          u,
          n.enabledMainnetOnlyNetworkIDs,
          n.enabledAddressTypes,
          n.enabledChainIDs,
          s,
          (c == null ? void 0 : c.isDeveloperMode) ?? !1
        ),
      };
      return u.type === ze.Seed
        ? { ...f, type: ze.Seed, seedIdentifier: u.seedIdentifier, isReadOnly: !1 }
        : u.type === ze.Seedless
          ? { ...f, type: ze.Seedless, seedIdentifier: u.seedIdentifier, isReadOnly: !1 }
          : u.type === ze.ReadOnly
            ? { ...f, type: ze.ReadOnly, isReadOnly: !0 }
            : u.type === ze.PrivateKey
              ? {
                  ...f,
                  privateKeyIdentifier: u.privateKeyIdentifier,
                  type: ze.PrivateKey,
                  isReadOnly: !1,
                }
              : { ...f, type: u.type, isReadOnly: !1 };
    });
  };
function qR(e) {
  return { version: 1, setting: { [X.Solana]: H0, [X.EVM]: q0, ...(e ? { [X.Sui]: jI } : {}) } };
}
var GR = u3,
  YR = 1,
  ZR = 4;
function QR(e) {
  return GR(e, YR | ZR);
}
var JR = QR;
const rp = Oc(JR),
  XR = h.array(
    h.object({
      address: h.string(),
      signingIndexes: h.array(h.number()),
      sigHash: h.number().optional(),
      isScriptSpend: h.boolean().optional(),
    })
  ),
  ex = h.object({
    chainType: O0,
    signingType: h.literal('transaction'),
    message: h.string().min(1),
    inputsToSign: XR.optional(),
    finalize: h.boolean(),
  }),
  tx = h.object({
    chainType: O0,
    signingType: h.literal('message'),
    message: h.instanceof(Uint8Array),
  }),
  nx = ex.or(tx),
  rx = h.object({
    chainType: h.literal(X.Sui),
    signingType: h.literal('transaction'),
    transaction: h.instanceof(Uint8Array),
  }),
  ix = h.object({
    chainType: h.literal(X.Sui),
    signingType: h.literal('personalMessage'),
    message: h.instanceof(Uint8Array),
  }),
  ox = rx.or(ix),
  ax = h.object({
    chainType: h.literal(X.Solana),
    signingType: h.literal('transaction'),
    message: h.union([h.string().min(1), h.instanceof(Uint8Array)]),
  }),
  sx = h.object({
    chainType: h.literal(X.Solana),
    signingType: h.literal('message'),
    message: h.string().min(1),
  }),
  kE = ax.or(sx),
  cx = h.object({
    chainType: h.literal(X.EVM),
    signingType: h.literal('transaction'),
    message: h.string().min(1),
  }),
  CE = h.object({
    chainType: h.literal(X.EVM),
    signingType: h.literal('message'),
    message: h.string().min(1),
  }),
  ME = h.object({
    chainType: h.literal(X.EVM),
    signingType: h.literal('typedData'),
    version: h.literal(1),
    data: e2,
  }),
  PE = h.object({
    chainType: h.literal(X.EVM),
    signingType: h.literal('typedData'),
    version: h.literal(3),
    data: t2,
  }),
  OE = h.object({
    chainType: h.literal(X.EVM),
    signingType: h.literal('typedData'),
    version: h.literal(4),
    data: n2,
  }),
  ux = cx.or(CE).or(ME).or(PE).or(OE),
  lx = h.object({ isJWT: h.literal(!0), data: t8 }),
  dx = h.object({ isCash: h.literal(!0), data: kE }),
  fx = CE.extend({ isAgentWallet: h.literal(!0) }),
  hx = ME.extend({ isAgentWallet: h.literal(!0) }),
  px = PE.extend({ isAgentWallet: h.literal(!0) }),
  gx = OE.extend({ isAgentWallet: h.literal(!0) }),
  yx = h.union([fx, hx, px, gx]),
  bx = h.object({ status: h.literal('success'), signature: h.string() }),
  DE = h.object({ status: h.literal('success'), signature: h.string() }),
  mx = h.object({
    status: h.literal('success'),
    signature: h.string(),
    message: h.instanceof(Uint8Array).optional(),
  }),
  wx = h.object({ status: h.literal('success'), signature: h.string() }),
  _x = h.object({ status: h.literal('success'), signature: h.string(), signedJWT: JD.optional() }),
  vx = DE;
kE.or(ux).or(nx).or(ox).or(lx).or(yx).or(dx);
var Kt = ((e) => (
  (e.InvalidInput = 'invalidInput'),
  (e.InvalidAccountId = 'invalidAccountId'),
  (e.InvalidAddressType = 'invalidAddressType'),
  (e.InvalidMessageEncoding = 'invalidMessageEncoding'),
  (e.InvalidDerivationPath = 'invalidDerivationPath'),
  (e.LedgerAppNotOpen = 'ledgerAppNotOpen'),
  (e.LedgerNotConnected = 'ledgerNotConnected'),
  (e.LedgerNeedPermission = 'ledgerNeedPermission'),
  (e.LedgerRejectAction = 'ledgerRejectAction'),
  (e.LedgerUnknownSignError = 'ledgerUnknownSignError'),
  (e.UnsupportedOperation = 'unsupportedOperation'),
  (e.InternalError = 'internalError'),
  (e.ExpiredTokenError = 'expiredToken'),
  (e.BeforeIATError = 'beforeTimeOfIssuance'),
  (e.InvalidClaimError = 'invalidClaim'),
  e
))(Kt || {});
const Sx = h.object({ status: h.literal('error'), type: h.nativeEnum(Kt), message: h.string() }),
  Ax = h.union([_x, vx, mx, bx, DE, wx, Sx]);
Kt.InvalidInput + '',
  Kt.InvalidAccountId + '',
  Kt.InvalidAddressType + '',
  Kt.InvalidMessageEncoding + '',
  Kt.InvalidDerivationPath + '',
  Kt.LedgerAppNotOpen + '',
  Kt.LedgerNotConnected + '',
  Kt.LedgerNeedPermission + '',
  Kt.LedgerRejectAction + '',
  Kt.LedgerUnknownSignError + '',
  Kt.UnsupportedOperation + '',
  Kt.InternalError + '',
  Kt.ExpiredTokenError + '',
  Kt.BeforeIATError + '',
  Kt.InvalidClaimError + '';
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const zy = (e) =>
    new DataView(e.buffer, e.byteOffset, e.byteLength),
  Ir = (e, t) => (e << (32 - t)) | (e >>> t),
  Ix = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!Ix) throw new Error('Non little-endian hardware is not supported');
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, '0'));
function Ex(e) {
  if (typeof e != 'string') throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function RE(e) {
  if ((typeof e == 'string' && (e = Ex(e)), !(e instanceof Uint8Array)))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
  return e;
}
let Tx = class {
  clone() {
    return this._cloneInto();
  }
};
function xE(e) {
  const t = (r) => e().update(RE(r)).digest(),
    n = e();
  return (t.outputLen = n.outputLen), (t.blockLen = n.blockLen), (t.create = () => e()), t;
}
function Im(e) {
  if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`);
}
function kx(e) {
  if (typeof e != 'boolean') throw new Error(`Expected boolean, not ${e}`);
}
function BE(e, ...t) {
  if (!(e instanceof Uint8Array)) throw new TypeError('Expected Uint8Array');
  if (t.length > 0 && !t.includes(e.length))
    throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function Cx(e) {
  if (typeof e != 'function' || typeof e.create != 'function')
    throw new Error('Hash should be wrapped by utils.wrapConstructor');
  Im(e.outputLen), Im(e.blockLen);
}
function Mx(e, t = !0) {
  if (e.destroyed) throw new Error('Hash instance has been destroyed');
  if (t && e.finished) throw new Error('Hash#digest() has already been called');
}
function Px(e, t) {
  BE(e);
  const n = t.outputLen;
  if (e.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`);
}
const Fy = { number: Im, bool: kx, bytes: BE, hash: Cx, exists: Mx, output: Px };
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const $y = (e) =>
    new DataView(e.buffer, e.byteOffset, e.byteLength),
  Er = (e, t) => (e << (32 - t)) | (e >>> t),
  Ox = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!Ox) throw new Error('Non little-endian hardware is not supported');
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, '0'));
function Dx(e) {
  if (typeof e != 'string') throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function jE(e) {
  if ((typeof e == 'string' && (e = Dx(e)), !(e instanceof Uint8Array)))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
  return e;
}
let Rx = class {
  clone() {
    return this._cloneInto();
  }
};
function bs(e) {
  const t = (r) => e().update(jE(r)).digest(),
    n = e();
  return (t.outputLen = n.outputLen), (t.blockLen = n.blockLen), (t.create = () => e()), t;
}
function xx(e, t, n, r) {
  if (typeof e.setBigUint64 == 'function') return e.setBigUint64(t, n, r);
  const i = BigInt(32),
    o = BigInt(4294967295),
    a = Number((n >> i) & o),
    c = Number(n & o),
    s = r ? 4 : 0,
    l = r ? 0 : 4;
  e.setUint32(t + s, a, r), e.setUint32(t + l, c, r);
}
let NE = class extends Rx {
  constructor(t, n, r, i) {
    super(),
      (this.blockLen = t),
      (this.outputLen = n),
      (this.padOffset = r),
      (this.isLE = i),
      (this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.buffer = new Uint8Array(t)),
      (this.view = $y(this.buffer));
  }
  update(t) {
    Fy.exists(this);
    const { view: n, buffer: r, blockLen: i } = this;
    t = jE(t);
    const o = t.length;
    for (let a = 0; a < o; ) {
      const c = Math.min(i - this.pos, o - a);
      if (c === i) {
        const s = $y(t);
        for (; i <= o - a; a += i) this.process(s, a);
        continue;
      }
      r.set(t.subarray(a, a + c), this.pos),
        (this.pos += c),
        (a += c),
        this.pos === i && (this.process(n, 0), (this.pos = 0));
    }
    return (this.length += t.length), this.roundClean(), this;
  }
  digestInto(t) {
    Fy.exists(this), Fy.output(t, this), (this.finished = !0);
    const { buffer: n, view: r, blockLen: i, isLE: o } = this;
    let { pos: a } = this;
    (n[a++] = 128),
      this.buffer.subarray(a).fill(0),
      this.padOffset > i - a && (this.process(r, 0), (a = 0));
    for (let d = a; d < i; d++) n[d] = 0;
    xx(r, i - 8, BigInt(this.length * 8), o), this.process(r, 0);
    const c = $y(t),
      s = this.outputLen;
    if (s % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
    const l = s / 4,
      u = this.get();
    if (l > u.length) throw new Error('_sha2: outputLen bigger than state');
    for (let d = 0; d < l; d++) c.setUint32(4 * d, u[d], o);
  }
  digest() {
    const { buffer: t, outputLen: n } = this;
    this.digestInto(t);
    const r = t.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: n, buffer: r, length: i, finished: o, destroyed: a, pos: c } = this;
    return (
      (t.length = i), (t.pos = c), (t.finished = o), (t.destroyed = a), i % n && t.buffer.set(r), t
    );
  }
};
const Bx = (e, t, n) => (e & t) ^ (~e & n),
  jx = (e, t, n) => (e & t) ^ (e & n) ^ (t & n),
  Nx = new Uint32Array([
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221,
    3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580,
    3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895,
    666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037,
    2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
    1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298,
  ]),
  vi = new Uint32Array([
    1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225,
  ]),
  Si = new Uint32Array(64);
let UE = class extends NE {
    constructor() {
      super(64, 32, 8, !1),
        (this.A = vi[0] | 0),
        (this.B = vi[1] | 0),
        (this.C = vi[2] | 0),
        (this.D = vi[3] | 0),
        (this.E = vi[4] | 0),
        (this.F = vi[5] | 0),
        (this.G = vi[6] | 0),
        (this.H = vi[7] | 0);
    }
    get() {
      const { A: t, B: n, C: r, D: i, E: o, F: a, G: c, H: s } = this;
      return [t, n, r, i, o, a, c, s];
    }
    set(t, n, r, i, o, a, c, s) {
      (this.A = t | 0),
        (this.B = n | 0),
        (this.C = r | 0),
        (this.D = i | 0),
        (this.E = o | 0),
        (this.F = a | 0),
        (this.G = c | 0),
        (this.H = s | 0);
    }
    process(t, n) {
      for (let d = 0; d < 16; d++, n += 4) Si[d] = t.getUint32(n, !1);
      for (let d = 16; d < 64; d++) {
        const f = Si[d - 15],
          p = Si[d - 2],
          y = Er(f, 7) ^ Er(f, 18) ^ (f >>> 3),
          b = Er(p, 17) ^ Er(p, 19) ^ (p >>> 10);
        Si[d] = (b + Si[d - 7] + y + Si[d - 16]) | 0;
      }
      let { A: r, B: i, C: o, D: a, E: c, F: s, G: l, H: u } = this;
      for (let d = 0; d < 64; d++) {
        const f = Er(c, 6) ^ Er(c, 11) ^ Er(c, 25),
          p = (u + f + Bx(c, s, l) + Nx[d] + Si[d]) | 0,
          b = ((Er(r, 2) ^ Er(r, 13) ^ Er(r, 22)) + jx(r, i, o)) | 0;
        (u = l), (l = s), (s = c), (c = (a + p) | 0), (a = o), (o = i), (i = r), (r = (p + b) | 0);
      }
      (r = (r + this.A) | 0),
        (i = (i + this.B) | 0),
        (o = (o + this.C) | 0),
        (a = (a + this.D) | 0),
        (c = (c + this.E) | 0),
        (s = (s + this.F) | 0),
        (l = (l + this.G) | 0),
        (u = (u + this.H) | 0),
        this.set(r, i, o, a, c, s, l, u);
    }
    roundClean() {
      Si.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
    }
  },
  Ux = class extends UE {
    constructor() {
      super(),
        (this.A = -1056596264),
        (this.B = 914150663),
        (this.C = 812702999),
        (this.D = -150054599),
        (this.E = -4191439),
        (this.F = 1750603025),
        (this.G = 1694076839),
        (this.H = -1090891868),
        (this.outputLen = 28);
    }
  };
bs(() => new UE());
bs(() => new Ux());
const qf = BigInt(2 ** 32 - 1),
  Em = BigInt(32);
function LE(e, t = !1) {
  return t
    ? { h: Number(e & qf), l: Number((e >> Em) & qf) }
    : { h: Number((e >> Em) & qf) | 0, l: Number(e & qf) | 0 };
}
function Lx(e, t = !1) {
  let n = new Uint32Array(e.length),
    r = new Uint32Array(e.length);
  for (let i = 0; i < e.length; i++) {
    const { h: o, l: a } = LE(e[i], t);
    [n[i], r[i]] = [o, a];
  }
  return [n, r];
}
const zx = (e, t) => (BigInt(e >>> 0) << Em) | BigInt(t >>> 0),
  Fx = (e, t, n) => e >>> n,
  $x = (e, t, n) => (e << (32 - n)) | (t >>> n),
  Wx = (e, t, n) => (e >>> n) | (t << (32 - n)),
  Vx = (e, t, n) => (e << (32 - n)) | (t >>> n),
  Kx = (e, t, n) => (e << (64 - n)) | (t >>> (n - 32)),
  Hx = (e, t, n) => (e >>> (n - 32)) | (t << (64 - n)),
  qx = (e, t) => t,
  Gx = (e, t) => e,
  Yx = (e, t, n) => (e << n) | (t >>> (32 - n)),
  Zx = (e, t, n) => (t << n) | (e >>> (32 - n)),
  Qx = (e, t, n) => (t << (n - 32)) | (e >>> (64 - n)),
  Jx = (e, t, n) => (e << (n - 32)) | (t >>> (64 - n));
function Xx(e, t, n, r) {
  const i = (t >>> 0) + (r >>> 0);
  return { h: (e + n + ((i / 2 ** 32) | 0)) | 0, l: i | 0 };
}
const eB = (e, t, n) => (e >>> 0) + (t >>> 0) + (n >>> 0),
  tB = (e, t, n, r) => (t + n + r + ((e / 2 ** 32) | 0)) | 0,
  nB = (e, t, n, r) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0),
  rB = (e, t, n, r, i) => (t + n + r + i + ((e / 2 ** 32) | 0)) | 0,
  iB = (e, t, n, r, i) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0) + (i >>> 0),
  oB = (e, t, n, r, i, o) => (t + n + r + i + o + ((e / 2 ** 32) | 0)) | 0,
  Ve = {
    fromBig: LE,
    split: Lx,
    toBig: zx,
    shrSH: Fx,
    shrSL: $x,
    rotrSH: Wx,
    rotrSL: Vx,
    rotrBH: Kx,
    rotrBL: Hx,
    rotr32H: qx,
    rotr32L: Gx,
    rotlSH: Yx,
    rotlSL: Zx,
    rotlBH: Qx,
    rotlBL: Jx,
    add: Xx,
    add3L: eB,
    add3H: tB,
    add4L: nB,
    add4H: rB,
    add5H: oB,
    add5L: iB,
  },
  [aB, sB] = Ve.split(
    [
      '0x428a2f98d728ae22',
      '0x7137449123ef65cd',
      '0xb5c0fbcfec4d3b2f',
      '0xe9b5dba58189dbbc',
      '0x3956c25bf348b538',
      '0x59f111f1b605d019',
      '0x923f82a4af194f9b',
      '0xab1c5ed5da6d8118',
      '0xd807aa98a3030242',
      '0x12835b0145706fbe',
      '0x243185be4ee4b28c',
      '0x550c7dc3d5ffb4e2',
      '0x72be5d74f27b896f',
      '0x80deb1fe3b1696b1',
      '0x9bdc06a725c71235',
      '0xc19bf174cf692694',
      '0xe49b69c19ef14ad2',
      '0xefbe4786384f25e3',
      '0x0fc19dc68b8cd5b5',
      '0x240ca1cc77ac9c65',
      '0x2de92c6f592b0275',
      '0x4a7484aa6ea6e483',
      '0x5cb0a9dcbd41fbd4',
      '0x76f988da831153b5',
      '0x983e5152ee66dfab',
      '0xa831c66d2db43210',
      '0xb00327c898fb213f',
      '0xbf597fc7beef0ee4',
      '0xc6e00bf33da88fc2',
      '0xd5a79147930aa725',
      '0x06ca6351e003826f',
      '0x142929670a0e6e70',
      '0x27b70a8546d22ffc',
      '0x2e1b21385c26c926',
      '0x4d2c6dfc5ac42aed',
      '0x53380d139d95b3df',
      '0x650a73548baf63de',
      '0x766a0abb3c77b2a8',
      '0x81c2c92e47edaee6',
      '0x92722c851482353b',
      '0xa2bfe8a14cf10364',
      '0xa81a664bbc423001',
      '0xc24b8b70d0f89791',
      '0xc76c51a30654be30',
      '0xd192e819d6ef5218',
      '0xd69906245565a910',
      '0xf40e35855771202a',
      '0x106aa07032bbd1b8',
      '0x19a4c116b8d2d0c8',
      '0x1e376c085141ab53',
      '0x2748774cdf8eeb99',
      '0x34b0bcb5e19b48a8',
      '0x391c0cb3c5c95a63',
      '0x4ed8aa4ae3418acb',
      '0x5b9cca4f7763e373',
      '0x682e6ff3d6b2b8a3',
      '0x748f82ee5defb2fc',
      '0x78a5636f43172f60',
      '0x84c87814a1f0ab72',
      '0x8cc702081a6439ec',
      '0x90befffa23631e28',
      '0xa4506cebde82bde9',
      '0xbef9a3f7b2c67915',
      '0xc67178f2e372532b',
      '0xca273eceea26619c',
      '0xd186b8c721c0c207',
      '0xeada7dd6cde0eb1e',
      '0xf57d4f7fee6ed178',
      '0x06f067aa72176fba',
      '0x0a637dc5a2c898a6',
      '0x113f9804bef90dae',
      '0x1b710b35131c471b',
      '0x28db77f523047d84',
      '0x32caab7b40c72493',
      '0x3c9ebe0a15c9bebc',
      '0x431d67c49c100d4c',
      '0x4cc5d4becb3e42b6',
      '0x597f299cfc657e2a',
      '0x5fcb6fab3ad6faec',
      '0x6c44198c4a475817',
    ].map((e) => BigInt(e))
  ),
  Ai = new Uint32Array(80),
  Ii = new Uint32Array(80);
let Gp = class extends NE {
    constructor() {
      super(128, 64, 16, !1),
        (this.Ah = 1779033703),
        (this.Al = -205731576),
        (this.Bh = -1150833019),
        (this.Bl = -2067093701),
        (this.Ch = 1013904242),
        (this.Cl = -23791573),
        (this.Dh = -1521486534),
        (this.Dl = 1595750129),
        (this.Eh = 1359893119),
        (this.El = -1377402159),
        (this.Fh = -1694144372),
        (this.Fl = 725511199),
        (this.Gh = 528734635),
        (this.Gl = -79577749),
        (this.Hh = 1541459225),
        (this.Hl = 327033209);
    }
    get() {
      const {
        Ah: t,
        Al: n,
        Bh: r,
        Bl: i,
        Ch: o,
        Cl: a,
        Dh: c,
        Dl: s,
        Eh: l,
        El: u,
        Fh: d,
        Fl: f,
        Gh: p,
        Gl: y,
        Hh: b,
        Hl: m,
      } = this;
      return [t, n, r, i, o, a, c, s, l, u, d, f, p, y, b, m];
    }
    set(t, n, r, i, o, a, c, s, l, u, d, f, p, y, b, m) {
      (this.Ah = t | 0),
        (this.Al = n | 0),
        (this.Bh = r | 0),
        (this.Bl = i | 0),
        (this.Ch = o | 0),
        (this.Cl = a | 0),
        (this.Dh = c | 0),
        (this.Dl = s | 0),
        (this.Eh = l | 0),
        (this.El = u | 0),
        (this.Fh = d | 0),
        (this.Fl = f | 0),
        (this.Gh = p | 0),
        (this.Gl = y | 0),
        (this.Hh = b | 0),
        (this.Hl = m | 0);
    }
    process(t, n) {
      for (let S = 0; S < 16; S++, n += 4)
        (Ai[S] = t.getUint32(n)), (Ii[S] = t.getUint32((n += 4)));
      for (let S = 16; S < 80; S++) {
        const E = Ai[S - 15] | 0,
          O = Ii[S - 15] | 0,
          N = Ve.rotrSH(E, O, 1) ^ Ve.rotrSH(E, O, 8) ^ Ve.shrSH(E, O, 7),
          F = Ve.rotrSL(E, O, 1) ^ Ve.rotrSL(E, O, 8) ^ Ve.shrSL(E, O, 7),
          D = Ai[S - 2] | 0,
          k = Ii[S - 2] | 0,
          K = Ve.rotrSH(D, k, 19) ^ Ve.rotrBH(D, k, 61) ^ Ve.shrSH(D, k, 6),
          M = Ve.rotrSL(D, k, 19) ^ Ve.rotrBL(D, k, 61) ^ Ve.shrSL(D, k, 6),
          C = Ve.add4L(F, M, Ii[S - 7], Ii[S - 16]),
          z = Ve.add4H(C, N, K, Ai[S - 7], Ai[S - 16]);
        (Ai[S] = z | 0), (Ii[S] = C | 0);
      }
      let {
        Ah: r,
        Al: i,
        Bh: o,
        Bl: a,
        Ch: c,
        Cl: s,
        Dh: l,
        Dl: u,
        Eh: d,
        El: f,
        Fh: p,
        Fl: y,
        Gh: b,
        Gl: m,
        Hh: w,
        Hl: _,
      } = this;
      for (let S = 0; S < 80; S++) {
        const E = Ve.rotrSH(d, f, 14) ^ Ve.rotrSH(d, f, 18) ^ Ve.rotrBH(d, f, 41),
          O = Ve.rotrSL(d, f, 14) ^ Ve.rotrSL(d, f, 18) ^ Ve.rotrBL(d, f, 41),
          N = (d & p) ^ (~d & b),
          F = (f & y) ^ (~f & m),
          D = Ve.add5L(_, O, F, sB[S], Ii[S]),
          k = Ve.add5H(D, w, E, N, aB[S], Ai[S]),
          K = D | 0,
          M = Ve.rotrSH(r, i, 28) ^ Ve.rotrBH(r, i, 34) ^ Ve.rotrBH(r, i, 39),
          C = Ve.rotrSL(r, i, 28) ^ Ve.rotrBL(r, i, 34) ^ Ve.rotrBL(r, i, 39),
          z = (r & o) ^ (r & c) ^ (o & c),
          I = (i & a) ^ (i & s) ^ (a & s);
        (w = b | 0),
          (_ = m | 0),
          (b = p | 0),
          (m = y | 0),
          (p = d | 0),
          (y = f | 0),
          ({ h: d, l: f } = Ve.add(l | 0, u | 0, k | 0, K | 0)),
          (l = c | 0),
          (u = s | 0),
          (c = o | 0),
          (s = a | 0),
          (o = r | 0),
          (a = i | 0);
        const T = Ve.add3L(K, C, I);
        (r = Ve.add3H(T, k, M, z)), (i = T | 0);
      }
      ({ h: r, l: i } = Ve.add(this.Ah | 0, this.Al | 0, r | 0, i | 0)),
        ({ h: o, l: a } = Ve.add(this.Bh | 0, this.Bl | 0, o | 0, a | 0)),
        ({ h: c, l: s } = Ve.add(this.Ch | 0, this.Cl | 0, c | 0, s | 0)),
        ({ h: l, l: u } = Ve.add(this.Dh | 0, this.Dl | 0, l | 0, u | 0)),
        ({ h: d, l: f } = Ve.add(this.Eh | 0, this.El | 0, d | 0, f | 0)),
        ({ h: p, l: y } = Ve.add(this.Fh | 0, this.Fl | 0, p | 0, y | 0)),
        ({ h: b, l: m } = Ve.add(this.Gh | 0, this.Gl | 0, b | 0, m | 0)),
        ({ h: w, l: _ } = Ve.add(this.Hh | 0, this.Hl | 0, w | 0, _ | 0)),
        this.set(r, i, o, a, c, s, l, u, d, f, p, y, b, m, w, _);
    }
    roundClean() {
      Ai.fill(0), Ii.fill(0);
    }
    destroy() {
      this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  },
  cB = class extends Gp {
    constructor() {
      super(),
        (this.Ah = -1942145080),
        (this.Al = 424955298),
        (this.Bh = 1944164710),
        (this.Bl = -1982016298),
        (this.Ch = 502970286),
        (this.Cl = 855612546),
        (this.Dh = 1738396948),
        (this.Dl = 1479516111),
        (this.Eh = 258812777),
        (this.El = 2077511080),
        (this.Fh = 2011393907),
        (this.Fl = 79989058),
        (this.Gh = 1067287976),
        (this.Gl = 1780299464),
        (this.Hh = 286451373),
        (this.Hl = -1848208735),
        (this.outputLen = 28);
    }
  },
  uB = class extends Gp {
    constructor() {
      super(),
        (this.Ah = 573645204),
        (this.Al = -64227540),
        (this.Bh = -1621794909),
        (this.Bl = -934517566),
        (this.Ch = 596883563),
        (this.Cl = 1867755857),
        (this.Dh = -1774684391),
        (this.Dl = 1497426621),
        (this.Eh = -1775747358),
        (this.El = -1467023389),
        (this.Fh = -1101128155),
        (this.Fl = 1401305490),
        (this.Gh = 721525244),
        (this.Gl = 746961066),
        (this.Hh = 246885852),
        (this.Hl = -2117784414),
        (this.outputLen = 32);
    }
  },
  lB = class extends Gp {
    constructor() {
      super(),
        (this.Ah = -876896931),
        (this.Al = -1056596264),
        (this.Bh = 1654270250),
        (this.Bl = 914150663),
        (this.Ch = -1856437926),
        (this.Cl = 812702999),
        (this.Dh = 355462360),
        (this.Dl = -150054599),
        (this.Eh = 1731405415),
        (this.El = -4191439),
        (this.Fh = -1900787065),
        (this.Fl = 1750603025),
        (this.Gh = -619958771),
        (this.Gl = 1694076839),
        (this.Hh = 1203062813),
        (this.Hl = -1090891868),
        (this.outputLen = 48);
    }
  };
bs(() => new Gp());
bs(() => new cB());
bs(() => new uB());
bs(() => new lB());
const dB = [
  'abandon',
  'ability',
  'able',
  'about',
  'above',
  'absent',
  'absorb',
  'abstract',
  'absurd',
  'abuse',
  'access',
  'accident',
  'account',
  'accuse',
  'achieve',
  'acid',
  'acoustic',
  'acquire',
  'across',
  'act',
  'action',
  'actor',
  'actress',
  'actual',
  'adapt',
  'add',
  'addict',
  'address',
  'adjust',
  'admit',
  'adult',
  'advance',
  'advice',
  'aerobic',
  'affair',
  'afford',
  'afraid',
  'again',
  'age',
  'agent',
  'agree',
  'ahead',
  'aim',
  'air',
  'airport',
  'aisle',
  'alarm',
  'album',
  'alcohol',
  'alert',
  'alien',
  'all',
  'alley',
  'allow',
  'almost',
  'alone',
  'alpha',
  'already',
  'also',
  'alter',
  'always',
  'amateur',
  'amazing',
  'among',
  'amount',
  'amused',
  'analyst',
  'anchor',
  'ancient',
  'anger',
  'angle',
  'angry',
  'animal',
  'ankle',
  'announce',
  'annual',
  'another',
  'answer',
  'antenna',
  'antique',
  'anxiety',
  'any',
  'apart',
  'apology',
  'appear',
  'apple',
  'approve',
  'april',
  'arch',
  'arctic',
  'area',
  'arena',
  'argue',
  'arm',
  'armed',
  'armor',
  'army',
  'around',
  'arrange',
  'arrest',
  'arrive',
  'arrow',
  'art',
  'artefact',
  'artist',
  'artwork',
  'ask',
  'aspect',
  'assault',
  'asset',
  'assist',
  'assume',
  'asthma',
  'athlete',
  'atom',
  'attack',
  'attend',
  'attitude',
  'attract',
  'auction',
  'audit',
  'august',
  'aunt',
  'author',
  'auto',
  'autumn',
  'average',
  'avocado',
  'avoid',
  'awake',
  'aware',
  'away',
  'awesome',
  'awful',
  'awkward',
  'axis',
  'baby',
  'bachelor',
  'bacon',
  'badge',
  'bag',
  'balance',
  'balcony',
  'ball',
  'bamboo',
  'banana',
  'banner',
  'bar',
  'barely',
  'bargain',
  'barrel',
  'base',
  'basic',
  'basket',
  'battle',
  'beach',
  'bean',
  'beauty',
  'because',
  'become',
  'beef',
  'before',
  'begin',
  'behave',
  'behind',
  'believe',
  'below',
  'belt',
  'bench',
  'benefit',
  'best',
  'betray',
  'better',
  'between',
  'beyond',
  'bicycle',
  'bid',
  'bike',
  'bind',
  'biology',
  'bird',
  'birth',
  'bitter',
  'black',
  'blade',
  'blame',
  'blanket',
  'blast',
  'bleak',
  'bless',
  'blind',
  'blood',
  'blossom',
  'blouse',
  'blue',
  'blur',
  'blush',
  'board',
  'boat',
  'body',
  'boil',
  'bomb',
  'bone',
  'bonus',
  'book',
  'boost',
  'border',
  'boring',
  'borrow',
  'boss',
  'bottom',
  'bounce',
  'box',
  'boy',
  'bracket',
  'brain',
  'brand',
  'brass',
  'brave',
  'bread',
  'breeze',
  'brick',
  'bridge',
  'brief',
  'bright',
  'bring',
  'brisk',
  'broccoli',
  'broken',
  'bronze',
  'broom',
  'brother',
  'brown',
  'brush',
  'bubble',
  'buddy',
  'budget',
  'buffalo',
  'build',
  'bulb',
  'bulk',
  'bullet',
  'bundle',
  'bunker',
  'burden',
  'burger',
  'burst',
  'bus',
  'business',
  'busy',
  'butter',
  'buyer',
  'buzz',
  'cabbage',
  'cabin',
  'cable',
  'cactus',
  'cage',
  'cake',
  'call',
  'calm',
  'camera',
  'camp',
  'can',
  'canal',
  'cancel',
  'candy',
  'cannon',
  'canoe',
  'canvas',
  'canyon',
  'capable',
  'capital',
  'captain',
  'car',
  'carbon',
  'card',
  'cargo',
  'carpet',
  'carry',
  'cart',
  'case',
  'cash',
  'casino',
  'castle',
  'casual',
  'cat',
  'catalog',
  'catch',
  'category',
  'cattle',
  'caught',
  'cause',
  'caution',
  'cave',
  'ceiling',
  'celery',
  'cement',
  'census',
  'century',
  'cereal',
  'certain',
  'chair',
  'chalk',
  'champion',
  'change',
  'chaos',
  'chapter',
  'charge',
  'chase',
  'chat',
  'cheap',
  'check',
  'cheese',
  'chef',
  'cherry',
  'chest',
  'chicken',
  'chief',
  'child',
  'chimney',
  'choice',
  'choose',
  'chronic',
  'chuckle',
  'chunk',
  'churn',
  'cigar',
  'cinnamon',
  'circle',
  'citizen',
  'city',
  'civil',
  'claim',
  'clap',
  'clarify',
  'claw',
  'clay',
  'clean',
  'clerk',
  'clever',
  'click',
  'client',
  'cliff',
  'climb',
  'clinic',
  'clip',
  'clock',
  'clog',
  'close',
  'cloth',
  'cloud',
  'clown',
  'club',
  'clump',
  'cluster',
  'clutch',
  'coach',
  'coast',
  'coconut',
  'code',
  'coffee',
  'coil',
  'coin',
  'collect',
  'color',
  'column',
  'combine',
  'come',
  'comfort',
  'comic',
  'common',
  'company',
  'concert',
  'conduct',
  'confirm',
  'congress',
  'connect',
  'consider',
  'control',
  'convince',
  'cook',
  'cool',
  'copper',
  'copy',
  'coral',
  'core',
  'corn',
  'correct',
  'cost',
  'cotton',
  'couch',
  'country',
  'couple',
  'course',
  'cousin',
  'cover',
  'coyote',
  'crack',
  'cradle',
  'craft',
  'cram',
  'crane',
  'crash',
  'crater',
  'crawl',
  'crazy',
  'cream',
  'credit',
  'creek',
  'crew',
  'cricket',
  'crime',
  'crisp',
  'critic',
  'crop',
  'cross',
  'crouch',
  'crowd',
  'crucial',
  'cruel',
  'cruise',
  'crumble',
  'crunch',
  'crush',
  'cry',
  'crystal',
  'cube',
  'culture',
  'cup',
  'cupboard',
  'curious',
  'current',
  'curtain',
  'curve',
  'cushion',
  'custom',
  'cute',
  'cycle',
  'dad',
  'damage',
  'damp',
  'dance',
  'danger',
  'daring',
  'dash',
  'daughter',
  'dawn',
  'day',
  'deal',
  'debate',
  'debris',
  'decade',
  'december',
  'decide',
  'decline',
  'decorate',
  'decrease',
  'deer',
  'defense',
  'define',
  'defy',
  'degree',
  'delay',
  'deliver',
  'demand',
  'demise',
  'denial',
  'dentist',
  'deny',
  'depart',
  'depend',
  'deposit',
  'depth',
  'deputy',
  'derive',
  'describe',
  'desert',
  'design',
  'desk',
  'despair',
  'destroy',
  'detail',
  'detect',
  'develop',
  'device',
  'devote',
  'diagram',
  'dial',
  'diamond',
  'diary',
  'dice',
  'diesel',
  'diet',
  'differ',
  'digital',
  'dignity',
  'dilemma',
  'dinner',
  'dinosaur',
  'direct',
  'dirt',
  'disagree',
  'discover',
  'disease',
  'dish',
  'dismiss',
  'disorder',
  'display',
  'distance',
  'divert',
  'divide',
  'divorce',
  'dizzy',
  'doctor',
  'document',
  'dog',
  'doll',
  'dolphin',
  'domain',
  'donate',
  'donkey',
  'donor',
  'door',
  'dose',
  'double',
  'dove',
  'draft',
  'dragon',
  'drama',
  'drastic',
  'draw',
  'dream',
  'dress',
  'drift',
  'drill',
  'drink',
  'drip',
  'drive',
  'drop',
  'drum',
  'dry',
  'duck',
  'dumb',
  'dune',
  'during',
  'dust',
  'dutch',
  'duty',
  'dwarf',
  'dynamic',
  'eager',
  'eagle',
  'early',
  'earn',
  'earth',
  'easily',
  'east',
  'easy',
  'echo',
  'ecology',
  'economy',
  'edge',
  'edit',
  'educate',
  'effort',
  'egg',
  'eight',
  'either',
  'elbow',
  'elder',
  'electric',
  'elegant',
  'element',
  'elephant',
  'elevator',
  'elite',
  'else',
  'embark',
  'embody',
  'embrace',
  'emerge',
  'emotion',
  'employ',
  'empower',
  'empty',
  'enable',
  'enact',
  'end',
  'endless',
  'endorse',
  'enemy',
  'energy',
  'enforce',
  'engage',
  'engine',
  'enhance',
  'enjoy',
  'enlist',
  'enough',
  'enrich',
  'enroll',
  'ensure',
  'enter',
  'entire',
  'entry',
  'envelope',
  'episode',
  'equal',
  'equip',
  'era',
  'erase',
  'erode',
  'erosion',
  'error',
  'erupt',
  'escape',
  'essay',
  'essence',
  'estate',
  'eternal',
  'ethics',
  'evidence',
  'evil',
  'evoke',
  'evolve',
  'exact',
  'example',
  'excess',
  'exchange',
  'excite',
  'exclude',
  'excuse',
  'execute',
  'exercise',
  'exhaust',
  'exhibit',
  'exile',
  'exist',
  'exit',
  'exotic',
  'expand',
  'expect',
  'expire',
  'explain',
  'expose',
  'express',
  'extend',
  'extra',
  'eye',
  'eyebrow',
  'fabric',
  'face',
  'faculty',
  'fade',
  'faint',
  'faith',
  'fall',
  'false',
  'fame',
  'family',
  'famous',
  'fan',
  'fancy',
  'fantasy',
  'farm',
  'fashion',
  'fat',
  'fatal',
  'father',
  'fatigue',
  'fault',
  'favorite',
  'feature',
  'february',
  'federal',
  'fee',
  'feed',
  'feel',
  'female',
  'fence',
  'festival',
  'fetch',
  'fever',
  'few',
  'fiber',
  'fiction',
  'field',
  'figure',
  'file',
  'film',
  'filter',
  'final',
  'find',
  'fine',
  'finger',
  'finish',
  'fire',
  'firm',
  'first',
  'fiscal',
  'fish',
  'fit',
  'fitness',
  'fix',
  'flag',
  'flame',
  'flash',
  'flat',
  'flavor',
  'flee',
  'flight',
  'flip',
  'float',
  'flock',
  'floor',
  'flower',
  'fluid',
  'flush',
  'fly',
  'foam',
  'focus',
  'fog',
  'foil',
  'fold',
  'follow',
  'food',
  'foot',
  'force',
  'forest',
  'forget',
  'fork',
  'fortune',
  'forum',
  'forward',
  'fossil',
  'foster',
  'found',
  'fox',
  'fragile',
  'frame',
  'frequent',
  'fresh',
  'friend',
  'fringe',
  'frog',
  'front',
  'frost',
  'frown',
  'frozen',
  'fruit',
  'fuel',
  'fun',
  'funny',
  'furnace',
  'fury',
  'future',
  'gadget',
  'gain',
  'galaxy',
  'gallery',
  'game',
  'gap',
  'garage',
  'garbage',
  'garden',
  'garlic',
  'garment',
  'gas',
  'gasp',
  'gate',
  'gather',
  'gauge',
  'gaze',
  'general',
  'genius',
  'genre',
  'gentle',
  'genuine',
  'gesture',
  'ghost',
  'giant',
  'gift',
  'giggle',
  'ginger',
  'giraffe',
  'girl',
  'give',
  'glad',
  'glance',
  'glare',
  'glass',
  'glide',
  'glimpse',
  'globe',
  'gloom',
  'glory',
  'glove',
  'glow',
  'glue',
  'goat',
  'goddess',
  'gold',
  'good',
  'goose',
  'gorilla',
  'gospel',
  'gossip',
  'govern',
  'gown',
  'grab',
  'grace',
  'grain',
  'grant',
  'grape',
  'grass',
  'gravity',
  'great',
  'green',
  'grid',
  'grief',
  'grit',
  'grocery',
  'group',
  'grow',
  'grunt',
  'guard',
  'guess',
  'guide',
  'guilt',
  'guitar',
  'gun',
  'gym',
  'habit',
  'hair',
  'half',
  'hammer',
  'hamster',
  'hand',
  'happy',
  'harbor',
  'hard',
  'harsh',
  'harvest',
  'hat',
  'have',
  'hawk',
  'hazard',
  'head',
  'health',
  'heart',
  'heavy',
  'hedgehog',
  'height',
  'hello',
  'helmet',
  'help',
  'hen',
  'hero',
  'hidden',
  'high',
  'hill',
  'hint',
  'hip',
  'hire',
  'history',
  'hobby',
  'hockey',
  'hold',
  'hole',
  'holiday',
  'hollow',
  'home',
  'honey',
  'hood',
  'hope',
  'horn',
  'horror',
  'horse',
  'hospital',
  'host',
  'hotel',
  'hour',
  'hover',
  'hub',
  'huge',
  'human',
  'humble',
  'humor',
  'hundred',
  'hungry',
  'hunt',
  'hurdle',
  'hurry',
  'hurt',
  'husband',
  'hybrid',
  'ice',
  'icon',
  'idea',
  'identify',
  'idle',
  'ignore',
  'ill',
  'illegal',
  'illness',
  'image',
  'imitate',
  'immense',
  'immune',
  'impact',
  'impose',
  'improve',
  'impulse',
  'inch',
  'include',
  'income',
  'increase',
  'index',
  'indicate',
  'indoor',
  'industry',
  'infant',
  'inflict',
  'inform',
  'inhale',
  'inherit',
  'initial',
  'inject',
  'injury',
  'inmate',
  'inner',
  'innocent',
  'input',
  'inquiry',
  'insane',
  'insect',
  'inside',
  'inspire',
  'install',
  'intact',
  'interest',
  'into',
  'invest',
  'invite',
  'involve',
  'iron',
  'island',
  'isolate',
  'issue',
  'item',
  'ivory',
  'jacket',
  'jaguar',
  'jar',
  'jazz',
  'jealous',
  'jeans',
  'jelly',
  'jewel',
  'job',
  'join',
  'joke',
  'journey',
  'joy',
  'judge',
  'juice',
  'jump',
  'jungle',
  'junior',
  'junk',
  'just',
  'kangaroo',
  'keen',
  'keep',
  'ketchup',
  'key',
  'kick',
  'kid',
  'kidney',
  'kind',
  'kingdom',
  'kiss',
  'kit',
  'kitchen',
  'kite',
  'kitten',
  'kiwi',
  'knee',
  'knife',
  'knock',
  'know',
  'lab',
  'label',
  'labor',
  'ladder',
  'lady',
  'lake',
  'lamp',
  'language',
  'laptop',
  'large',
  'later',
  'latin',
  'laugh',
  'laundry',
  'lava',
  'law',
  'lawn',
  'lawsuit',
  'layer',
  'lazy',
  'leader',
  'leaf',
  'learn',
  'leave',
  'lecture',
  'left',
  'leg',
  'legal',
  'legend',
  'leisure',
  'lemon',
  'lend',
  'length',
  'lens',
  'leopard',
  'lesson',
  'letter',
  'level',
  'liar',
  'liberty',
  'library',
  'license',
  'life',
  'lift',
  'light',
  'like',
  'limb',
  'limit',
  'link',
  'lion',
  'liquid',
  'list',
  'little',
  'live',
  'lizard',
  'load',
  'loan',
  'lobster',
  'local',
  'lock',
  'logic',
  'lonely',
  'long',
  'loop',
  'lottery',
  'loud',
  'lounge',
  'love',
  'loyal',
  'lucky',
  'luggage',
  'lumber',
  'lunar',
  'lunch',
  'luxury',
  'lyrics',
  'machine',
  'mad',
  'magic',
  'magnet',
  'maid',
  'mail',
  'main',
  'major',
  'make',
  'mammal',
  'man',
  'manage',
  'mandate',
  'mango',
  'mansion',
  'manual',
  'maple',
  'marble',
  'march',
  'margin',
  'marine',
  'market',
  'marriage',
  'mask',
  'mass',
  'master',
  'match',
  'material',
  'math',
  'matrix',
  'matter',
  'maximum',
  'maze',
  'meadow',
  'mean',
  'measure',
  'meat',
  'mechanic',
  'medal',
  'media',
  'melody',
  'melt',
  'member',
  'memory',
  'mention',
  'menu',
  'mercy',
  'merge',
  'merit',
  'merry',
  'mesh',
  'message',
  'metal',
  'method',
  'middle',
  'midnight',
  'milk',
  'million',
  'mimic',
  'mind',
  'minimum',
  'minor',
  'minute',
  'miracle',
  'mirror',
  'misery',
  'miss',
  'mistake',
  'mix',
  'mixed',
  'mixture',
  'mobile',
  'model',
  'modify',
  'mom',
  'moment',
  'monitor',
  'monkey',
  'monster',
  'month',
  'moon',
  'moral',
  'more',
  'morning',
  'mosquito',
  'mother',
  'motion',
  'motor',
  'mountain',
  'mouse',
  'move',
  'movie',
  'much',
  'muffin',
  'mule',
  'multiply',
  'muscle',
  'museum',
  'mushroom',
  'music',
  'must',
  'mutual',
  'myself',
  'mystery',
  'myth',
  'naive',
  'name',
  'napkin',
  'narrow',
  'nasty',
  'nation',
  'nature',
  'near',
  'neck',
  'need',
  'negative',
  'neglect',
  'neither',
  'nephew',
  'nerve',
  'nest',
  'net',
  'network',
  'neutral',
  'never',
  'news',
  'next',
  'nice',
  'night',
  'noble',
  'noise',
  'nominee',
  'noodle',
  'normal',
  'north',
  'nose',
  'notable',
  'note',
  'nothing',
  'notice',
  'novel',
  'now',
  'nuclear',
  'number',
  'nurse',
  'nut',
  'oak',
  'obey',
  'object',
  'oblige',
  'obscure',
  'observe',
  'obtain',
  'obvious',
  'occur',
  'ocean',
  'october',
  'odor',
  'off',
  'offer',
  'office',
  'often',
  'oil',
  'okay',
  'old',
  'olive',
  'olympic',
  'omit',
  'once',
  'one',
  'onion',
  'online',
  'only',
  'open',
  'opera',
  'opinion',
  'oppose',
  'option',
  'orange',
  'orbit',
  'orchard',
  'order',
  'ordinary',
  'organ',
  'orient',
  'original',
  'orphan',
  'ostrich',
  'other',
  'outdoor',
  'outer',
  'output',
  'outside',
  'oval',
  'oven',
  'over',
  'own',
  'owner',
  'oxygen',
  'oyster',
  'ozone',
  'pact',
  'paddle',
  'page',
  'pair',
  'palace',
  'palm',
  'panda',
  'panel',
  'panic',
  'panther',
  'paper',
  'parade',
  'parent',
  'park',
  'parrot',
  'party',
  'pass',
  'patch',
  'path',
  'patient',
  'patrol',
  'pattern',
  'pause',
  'pave',
  'payment',
  'peace',
  'peanut',
  'pear',
  'peasant',
  'pelican',
  'pen',
  'penalty',
  'pencil',
  'people',
  'pepper',
  'perfect',
  'permit',
  'person',
  'pet',
  'phone',
  'photo',
  'phrase',
  'physical',
  'piano',
  'picnic',
  'picture',
  'piece',
  'pig',
  'pigeon',
  'pill',
  'pilot',
  'pink',
  'pioneer',
  'pipe',
  'pistol',
  'pitch',
  'pizza',
  'place',
  'planet',
  'plastic',
  'plate',
  'play',
  'please',
  'pledge',
  'pluck',
  'plug',
  'plunge',
  'poem',
  'poet',
  'point',
  'polar',
  'pole',
  'police',
  'pond',
  'pony',
  'pool',
  'popular',
  'portion',
  'position',
  'possible',
  'post',
  'potato',
  'pottery',
  'poverty',
  'powder',
  'power',
  'practice',
  'praise',
  'predict',
  'prefer',
  'prepare',
  'present',
  'pretty',
  'prevent',
  'price',
  'pride',
  'primary',
  'print',
  'priority',
  'prison',
  'private',
  'prize',
  'problem',
  'process',
  'produce',
  'profit',
  'program',
  'project',
  'promote',
  'proof',
  'property',
  'prosper',
  'protect',
  'proud',
  'provide',
  'public',
  'pudding',
  'pull',
  'pulp',
  'pulse',
  'pumpkin',
  'punch',
  'pupil',
  'puppy',
  'purchase',
  'purity',
  'purpose',
  'purse',
  'push',
  'put',
  'puzzle',
  'pyramid',
  'quality',
  'quantum',
  'quarter',
  'question',
  'quick',
  'quit',
  'quiz',
  'quote',
  'rabbit',
  'raccoon',
  'race',
  'rack',
  'radar',
  'radio',
  'rail',
  'rain',
  'raise',
  'rally',
  'ramp',
  'ranch',
  'random',
  'range',
  'rapid',
  'rare',
  'rate',
  'rather',
  'raven',
  'raw',
  'razor',
  'ready',
  'real',
  'reason',
  'rebel',
  'rebuild',
  'recall',
  'receive',
  'recipe',
  'record',
  'recycle',
  'reduce',
  'reflect',
  'reform',
  'refuse',
  'region',
  'regret',
  'regular',
  'reject',
  'relax',
  'release',
  'relief',
  'rely',
  'remain',
  'remember',
  'remind',
  'remove',
  'render',
  'renew',
  'rent',
  'reopen',
  'repair',
  'repeat',
  'replace',
  'report',
  'require',
  'rescue',
  'resemble',
  'resist',
  'resource',
  'response',
  'result',
  'retire',
  'retreat',
  'return',
  'reunion',
  'reveal',
  'review',
  'reward',
  'rhythm',
  'rib',
  'ribbon',
  'rice',
  'rich',
  'ride',
  'ridge',
  'rifle',
  'right',
  'rigid',
  'ring',
  'riot',
  'ripple',
  'risk',
  'ritual',
  'rival',
  'river',
  'road',
  'roast',
  'robot',
  'robust',
  'rocket',
  'romance',
  'roof',
  'rookie',
  'room',
  'rose',
  'rotate',
  'rough',
  'round',
  'route',
  'royal',
  'rubber',
  'rude',
  'rug',
  'rule',
  'run',
  'runway',
  'rural',
  'sad',
  'saddle',
  'sadness',
  'safe',
  'sail',
  'salad',
  'salmon',
  'salon',
  'salt',
  'salute',
  'same',
  'sample',
  'sand',
  'satisfy',
  'satoshi',
  'sauce',
  'sausage',
  'save',
  'say',
  'scale',
  'scan',
  'scare',
  'scatter',
  'scene',
  'scheme',
  'school',
  'science',
  'scissors',
  'scorpion',
  'scout',
  'scrap',
  'screen',
  'script',
  'scrub',
  'sea',
  'search',
  'season',
  'seat',
  'second',
  'secret',
  'section',
  'security',
  'seed',
  'seek',
  'segment',
  'select',
  'sell',
  'seminar',
  'senior',
  'sense',
  'sentence',
  'series',
  'service',
  'session',
  'settle',
  'setup',
  'seven',
  'shadow',
  'shaft',
  'shallow',
  'share',
  'shed',
  'shell',
  'sheriff',
  'shield',
  'shift',
  'shine',
  'ship',
  'shiver',
  'shock',
  'shoe',
  'shoot',
  'shop',
  'short',
  'shoulder',
  'shove',
  'shrimp',
  'shrug',
  'shuffle',
  'shy',
  'sibling',
  'sick',
  'side',
  'siege',
  'sight',
  'sign',
  'silent',
  'silk',
  'silly',
  'silver',
  'similar',
  'simple',
  'since',
  'sing',
  'siren',
  'sister',
  'situate',
  'six',
  'size',
  'skate',
  'sketch',
  'ski',
  'skill',
  'skin',
  'skirt',
  'skull',
  'slab',
  'slam',
  'sleep',
  'slender',
  'slice',
  'slide',
  'slight',
  'slim',
  'slogan',
  'slot',
  'slow',
  'slush',
  'small',
  'smart',
  'smile',
  'smoke',
  'smooth',
  'snack',
  'snake',
  'snap',
  'sniff',
  'snow',
  'soap',
  'soccer',
  'social',
  'sock',
  'soda',
  'soft',
  'solar',
  'soldier',
  'solid',
  'solution',
  'solve',
  'someone',
  'song',
  'soon',
  'sorry',
  'sort',
  'soul',
  'sound',
  'soup',
  'source',
  'south',
  'space',
  'spare',
  'spatial',
  'spawn',
  'speak',
  'special',
  'speed',
  'spell',
  'spend',
  'sphere',
  'spice',
  'spider',
  'spike',
  'spin',
  'spirit',
  'split',
  'spoil',
  'sponsor',
  'spoon',
  'sport',
  'spot',
  'spray',
  'spread',
  'spring',
  'spy',
  'square',
  'squeeze',
  'squirrel',
  'stable',
  'stadium',
  'staff',
  'stage',
  'stairs',
  'stamp',
  'stand',
  'start',
  'state',
  'stay',
  'steak',
  'steel',
  'stem',
  'step',
  'stereo',
  'stick',
  'still',
  'sting',
  'stock',
  'stomach',
  'stone',
  'stool',
  'story',
  'stove',
  'strategy',
  'street',
  'strike',
  'strong',
  'struggle',
  'student',
  'stuff',
  'stumble',
  'style',
  'subject',
  'submit',
  'subway',
  'success',
  'such',
  'sudden',
  'suffer',
  'sugar',
  'suggest',
  'suit',
  'summer',
  'sun',
  'sunny',
  'sunset',
  'super',
  'supply',
  'supreme',
  'sure',
  'surface',
  'surge',
  'surprise',
  'surround',
  'survey',
  'suspect',
  'sustain',
  'swallow',
  'swamp',
  'swap',
  'swarm',
  'swear',
  'sweet',
  'swift',
  'swim',
  'swing',
  'switch',
  'sword',
  'symbol',
  'symptom',
  'syrup',
  'system',
  'table',
  'tackle',
  'tag',
  'tail',
  'talent',
  'talk',
  'tank',
  'tape',
  'target',
  'task',
  'taste',
  'tattoo',
  'taxi',
  'teach',
  'team',
  'tell',
  'ten',
  'tenant',
  'tennis',
  'tent',
  'term',
  'test',
  'text',
  'thank',
  'that',
  'theme',
  'then',
  'theory',
  'there',
  'they',
  'thing',
  'this',
  'thought',
  'three',
  'thrive',
  'throw',
  'thumb',
  'thunder',
  'ticket',
  'tide',
  'tiger',
  'tilt',
  'timber',
  'time',
  'tiny',
  'tip',
  'tired',
  'tissue',
  'title',
  'toast',
  'tobacco',
  'today',
  'toddler',
  'toe',
  'together',
  'toilet',
  'token',
  'tomato',
  'tomorrow',
  'tone',
  'tongue',
  'tonight',
  'tool',
  'tooth',
  'top',
  'topic',
  'topple',
  'torch',
  'tornado',
  'tortoise',
  'toss',
  'total',
  'tourist',
  'toward',
  'tower',
  'town',
  'toy',
  'track',
  'trade',
  'traffic',
  'tragic',
  'train',
  'transfer',
  'trap',
  'trash',
  'travel',
  'tray',
  'treat',
  'tree',
  'trend',
  'trial',
  'tribe',
  'trick',
  'trigger',
  'trim',
  'trip',
  'trophy',
  'trouble',
  'truck',
  'true',
  'truly',
  'trumpet',
  'trust',
  'truth',
  'try',
  'tube',
  'tuition',
  'tumble',
  'tuna',
  'tunnel',
  'turkey',
  'turn',
  'turtle',
  'twelve',
  'twenty',
  'twice',
  'twin',
  'twist',
  'two',
  'type',
  'typical',
  'ugly',
  'umbrella',
  'unable',
  'unaware',
  'uncle',
  'uncover',
  'under',
  'undo',
  'unfair',
  'unfold',
  'unhappy',
  'uniform',
  'unique',
  'unit',
  'universe',
  'unknown',
  'unlock',
  'until',
  'unusual',
  'unveil',
  'update',
  'upgrade',
  'uphold',
  'upon',
  'upper',
  'upset',
  'urban',
  'urge',
  'usage',
  'use',
  'used',
  'useful',
  'useless',
  'usual',
  'utility',
  'vacant',
  'vacuum',
  'vague',
  'valid',
  'valley',
  'valve',
  'van',
  'vanish',
  'vapor',
  'various',
  'vast',
  'vault',
  'vehicle',
  'velvet',
  'vendor',
  'venture',
  'venue',
  'verb',
  'verify',
  'version',
  'very',
  'vessel',
  'veteran',
  'viable',
  'vibrant',
  'vicious',
  'victory',
  'video',
  'view',
  'village',
  'vintage',
  'violin',
  'virtual',
  'virus',
  'visa',
  'visit',
  'visual',
  'vital',
  'vivid',
  'vocal',
  'voice',
  'void',
  'volcano',
  'volume',
  'vote',
  'voyage',
  'wage',
  'wagon',
  'wait',
  'walk',
  'wall',
  'walnut',
  'want',
  'warfare',
  'warm',
  'warrior',
  'wash',
  'wasp',
  'waste',
  'water',
  'wave',
  'way',
  'wealth',
  'weapon',
  'wear',
  'weasel',
  'weather',
  'web',
  'wedding',
  'weekend',
  'weird',
  'welcome',
  'west',
  'wet',
  'whale',
  'what',
  'wheat',
  'wheel',
  'when',
  'where',
  'whip',
  'whisper',
  'wide',
  'width',
  'wife',
  'wild',
  'will',
  'win',
  'window',
  'wine',
  'wing',
  'wink',
  'winner',
  'winter',
  'wire',
  'wisdom',
  'wise',
  'wish',
  'witness',
  'wolf',
  'woman',
  'wonder',
  'wood',
  'wool',
  'word',
  'work',
  'world',
  'worry',
  'worth',
  'wrap',
  'wreck',
  'wrestle',
  'wrist',
  'write',
  'wrong',
  'yard',
  'year',
  'yellow',
  'you',
  'young',
  'youth',
  'zebra',
  'zero',
  'zone',
  'zoo',
];
new Set(dB);
var fB = {},
  Ka = {},
  Ha = {};
Object.defineProperty(Ha, '__esModule', { value: !0 });
Ha.testnet = Ha.bitcoin = void 0;
Ha.bitcoin = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: 'bc',
  bip32: { public: 76067358, private: 76066276 },
  pubKeyHash: 0,
  scriptHash: 5,
  wif: 128,
};
Ha.testnet = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: 'tb',
  bip32: { public: 70617039, private: 70615956 },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239,
};
var zE = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.maybe = e.Boolean = e.Array = e.Buffer256bit = e.Network = e.typeforce = void 0),
    (e.typeforce = O4),
    (e.Network = e.typeforce.compile({
      messagePrefix: e.typeforce.oneOf(e.typeforce.Buffer, e.typeforce.String),
      bip32: { public: e.typeforce.UInt32, private: e.typeforce.UInt32 },
      pubKeyHash: e.typeforce.UInt8,
      scriptHash: e.typeforce.UInt8,
      wif: e.typeforce.UInt8,
    })),
    (e.Buffer256bit = e.typeforce.BufferN(32)),
    (e.Array = e.typeforce.Array),
    (e.Boolean = e.typeforce.Boolean),
    (e.maybe = e.typeforce.maybe);
})(zE);
var Yp = {};
Object.defineProperty(Yp, '__esModule', { value: !0 });
Yp.testEcc = void 0;
const Ee = (e) => Y.from(e, 'hex');
function hB(e) {
  vt(e.isPoint(Ee('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'))),
    vt(!e.isPoint(Ee('030000000000000000000000000000000000000000000000000000000000000005'))),
    vt(e.isPrivate(Ee('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'))),
    vt(e.isPrivate(Ee('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140'))),
    vt(!e.isPrivate(Ee('0000000000000000000000000000000000000000000000000000000000000000'))),
    vt(!e.isPrivate(Ee('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'))),
    vt(!e.isPrivate(Ee('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142'))),
    vt(
      Y.from(
        e.privateAdd(
          Ee('0000000000000000000000000000000000000000000000000000000000000001'),
          Ee('0000000000000000000000000000000000000000000000000000000000000000')
        )
      ).equals(Ee('0000000000000000000000000000000000000000000000000000000000000001'))
    ),
    vt(
      e.privateAdd(
        Ee('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e'),
        Ee('0000000000000000000000000000000000000000000000000000000000000003')
      ) === null
    ),
    vt(
      Y.from(
        e.privateAdd(
          Ee('e211078564db65c3ce7704f08262b1f38f1ef412ad15b5ac2d76657a63b2c500'),
          Ee('b51fbb69051255d1becbd683de5848242a89c229348dd72896a87ada94ae8665')
        )
      ).equals(Ee('9730c2ee69edbb958d42db7460bafa18fef9d955325aec99044c81c8282b0a24'))
    ),
    vt(
      Y.from(
        e.privateNegate(Ee('0000000000000000000000000000000000000000000000000000000000000001'))
      ).equals(Ee('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140'))
    ),
    vt(
      Y.from(
        e.privateNegate(Ee('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e'))
      ).equals(Ee('0000000000000000000000000000000000000000000000000000000000000003'))
    ),
    vt(
      Y.from(
        e.privateNegate(Ee('b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af'))
      ).equals(Ee('4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792'))
    ),
    vt(
      Y.from(
        e.pointCompress(
          Ee(
            '0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8'
          ),
          !0
        )
      ).equals(Ee('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'))
    ),
    vt(
      Y.from(
        e.pointCompress(
          Ee(
            '0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8'
          ),
          !1
        )
      ).equals(
        Ee(
          '0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8'
        )
      )
    ),
    vt(
      Y.from(
        e.pointCompress(
          Ee('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
          !0
        )
      ).equals(Ee('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'))
    ),
    vt(
      Y.from(
        e.pointCompress(
          Ee('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
          !1
        )
      ).equals(
        Ee(
          '0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8'
        )
      )
    ),
    vt(
      Y.from(
        e.pointFromScalar(Ee('b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af'))
      ).equals(Ee('02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99'))
    ),
    vt(
      e.xOnlyPointAddTweak(
        Ee('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
        Ee('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')
      ) === null
    );
  let t = e.xOnlyPointAddTweak(
    Ee('1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b'),
    Ee('a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac')
  );
  vt(
    Y.from(t.xOnlyPubkey).equals(
      Ee('e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf')
    ) && t.parity === 1
  ),
    (t = e.xOnlyPointAddTweak(
      Ee('2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991'),
      Ee('823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47')
    )),
    vt(
      Y.from(t.xOnlyPubkey).equals(
        Ee('9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c')
      ) && t.parity === 0
    ),
    vt(
      Y.from(
        e.sign(
          Ee('5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed'),
          Ee('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')
        )
      ).equals(
        Ee(
          '54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5'
        )
      )
    ),
    vt(
      e.verify(
        Ee('5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed'),
        Ee('0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
        Ee(
          '54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5'
        )
      )
    ),
    e.signSchnorr &&
      vt(
        Y.from(
          e.signSchnorr(
            Ee('7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c'),
            Ee('c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9'),
            Ee('c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906')
          )
        ).equals(
          Ee(
            '5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7'
          )
        )
      ),
    e.verifySchnorr &&
      vt(
        e.verifySchnorr(
          Ee('7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c'),
          Ee('dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8'),
          Ee(
            '5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7'
          )
        )
      );
}
Yp.testEcc = hB;
function vt(e) {
  if (!e) throw new Error('ecc library invalid');
}
Object.defineProperty(Ka, '__esModule', { value: !0 });
Ka.ECPairFactory = Ka.networks = void 0;
const Tm = Ha;
Ka.networks = Tm;
const yn = zE,
  pB = n4(),
  d_ = r2,
  gB = Yp,
  Wy = yn.typeforce.maybe(
    yn.typeforce.compile({ compressed: yn.maybe(yn.Boolean), network: yn.maybe(yn.Network) })
  ),
  yB = (e) => (e.length === 32 ? e : e.slice(1, 33));
function bB(e) {
  (0, gB.testEcc)(e);
  function t(c) {
    return e.isPoint(c);
  }
  function n(c, s) {
    if ((yn.typeforce(yn.Buffer256bit, c), !e.isPrivate(c)))
      throw new TypeError('Private key not in range [1, n)');
    return yn.typeforce(Wy, s), new a(c, void 0, s);
  }
  function r(c, s) {
    return yn.typeforce(e.isPoint, c), yn.typeforce(Wy, s), new a(void 0, c, s);
  }
  function i(c, s) {
    const l = d_.decode(c),
      u = l.version;
    if (yn.Array(s)) {
      if (((s = s.filter((d) => u === d.wif).pop()), !s))
        throw new Error('Unknown network version');
    } else if (((s = s || Tm.bitcoin), u !== s.wif)) throw new Error('Invalid network version');
    return n(l.privateKey, { compressed: l.compressed, network: s });
  }
  function o(c) {
    yn.typeforce(Wy, c), c === void 0 && (c = {});
    const s = c.rng || pB;
    let l;
    do (l = s(32)), yn.typeforce(yn.Buffer256bit, l);
    while (!e.isPrivate(l));
    return n(l, c);
  }
  class a {
    constructor(s, l, u) {
      Le(this, '__D');
      Le(this, '__Q');
      Le(this, 'compressed');
      Le(this, 'network');
      Le(this, 'lowR');
      (this.__D = s),
        (this.__Q = l),
        (this.lowR = !1),
        u === void 0 && (u = {}),
        (this.compressed = u.compressed === void 0 ? !0 : u.compressed),
        (this.network = u.network || Tm.bitcoin),
        l !== void 0 && (this.__Q = Y.from(e.pointCompress(l, this.compressed)));
    }
    get privateKey() {
      return this.__D;
    }
    get publicKey() {
      if (!this.__Q) {
        const s = e.pointFromScalar(this.__D, this.compressed);
        this.__Q = Y.from(s);
      }
      return this.__Q;
    }
    toWIF() {
      if (!this.__D) throw new Error('Missing private key');
      return d_.encode(this.network.wif, this.__D, this.compressed);
    }
    tweak(s) {
      return this.privateKey ? this.tweakFromPrivateKey(s) : this.tweakFromPublicKey(s);
    }
    sign(s, l) {
      if (!this.__D) throw new Error('Missing private key');
      if ((l === void 0 && (l = this.lowR), l === !1)) return Y.from(e.sign(s, this.__D));
      {
        let u = e.sign(s, this.__D);
        const d = Y.alloc(32, 0);
        let f = 0;
        for (; u[0] > 127; ) f++, d.writeUIntLE(f, 0, 6), (u = e.sign(s, this.__D, d));
        return Y.from(u);
      }
    }
    signSchnorr(s) {
      if (!this.privateKey) throw new Error('Missing private key');
      if (!e.signSchnorr) throw new Error('signSchnorr not supported by ecc library');
      return Y.from(e.signSchnorr(s, this.privateKey));
    }
    verify(s, l) {
      return e.verify(s, this.publicKey, l);
    }
    verifySchnorr(s, l) {
      if (!e.verifySchnorr) throw new Error('verifySchnorr not supported by ecc library');
      return e.verifySchnorr(s, this.publicKey.subarray(1, 33), l);
    }
    tweakFromPublicKey(s) {
      const l = yB(this.publicKey),
        u = e.xOnlyPointAddTweak(l, s);
      if (!u || u.xOnlyPubkey === null) throw new Error('Cannot tweak public key!');
      const d = Y.from([u.parity === 0 ? 2 : 3]);
      return r(Y.concat([d, u.xOnlyPubkey]), {
        network: this.network,
        compressed: this.compressed,
      });
    }
    tweakFromPrivateKey(s) {
      const u =
          this.publicKey[0] === 3 || (this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1)
            ? e.privateNegate(this.privateKey)
            : this.privateKey,
        d = e.privateAdd(u, s);
      if (!d) throw new Error('Invalid tweaked private key!');
      return n(Y.from(d), { network: this.network, compressed: this.compressed });
    }
  }
  return { isPoint: t, fromPrivateKey: n, fromPublicKey: r, fromWIF: i, makeRandom: o };
}
Ka.ECPairFactory = bB;
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.networks = e.ECPairFactory = e.default = void 0);
  var t = Ka;
  Object.defineProperty(e, 'default', {
    enumerable: !0,
    get: function () {
      return t.ECPairFactory;
    },
  }),
    Object.defineProperty(e, 'ECPairFactory', {
      enumerable: !0,
      get: function () {
        return t.ECPairFactory;
      },
    }),
    Object.defineProperty(e, 'networks', {
      enumerable: !0,
      get: function () {
        return t.networks;
      },
    });
})(fB);
function km(e) {
  if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`);
}
function mB(e) {
  if (typeof e != 'boolean') throw new Error(`Expected boolean, not ${e}`);
}
function FE(e, ...t) {
  if (!(e instanceof Uint8Array)) throw new TypeError('Expected Uint8Array');
  if (t.length > 0 && !t.includes(e.length))
    throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function wB(e) {
  if (typeof e != 'function' || typeof e.create != 'function')
    throw new Error('Hash should be wrapped by utils.wrapConstructor');
  km(e.outputLen), km(e.blockLen);
}
function _B(e, t = !0) {
  if (e.destroyed) throw new Error('Hash instance has been destroyed');
  if (t && e.finished) throw new Error('Hash#digest() has already been called');
}
function vB(e, t) {
  FE(e);
  const n = t.outputLen;
  if (e.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`);
}
const Vy = { number: km, bool: mB, bytes: FE, hash: wB, exists: _B, output: vB };
function SB(e, t, n, r) {
  if (typeof e.setBigUint64 == 'function') return e.setBigUint64(t, n, r);
  const i = BigInt(32),
    o = BigInt(4294967295),
    a = Number((n >> i) & o),
    c = Number(n & o),
    s = r ? 4 : 0,
    l = r ? 0 : 4;
  e.setUint32(t + s, a, r), e.setUint32(t + l, c, r);
}
let AB = class extends Tx {
  constructor(t, n, r, i) {
    super(),
      (this.blockLen = t),
      (this.outputLen = n),
      (this.padOffset = r),
      (this.isLE = i),
      (this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.buffer = new Uint8Array(t)),
      (this.view = zy(this.buffer));
  }
  update(t) {
    Vy.exists(this);
    const { view: n, buffer: r, blockLen: i } = this;
    t = RE(t);
    const o = t.length;
    for (let a = 0; a < o; ) {
      const c = Math.min(i - this.pos, o - a);
      if (c === i) {
        const s = zy(t);
        for (; i <= o - a; a += i) this.process(s, a);
        continue;
      }
      r.set(t.subarray(a, a + c), this.pos),
        (this.pos += c),
        (a += c),
        this.pos === i && (this.process(n, 0), (this.pos = 0));
    }
    return (this.length += t.length), this.roundClean(), this;
  }
  digestInto(t) {
    Vy.exists(this), Vy.output(t, this), (this.finished = !0);
    const { buffer: n, view: r, blockLen: i, isLE: o } = this;
    let { pos: a } = this;
    (n[a++] = 128),
      this.buffer.subarray(a).fill(0),
      this.padOffset > i - a && (this.process(r, 0), (a = 0));
    for (let d = a; d < i; d++) n[d] = 0;
    SB(r, i - 8, BigInt(this.length * 8), o), this.process(r, 0);
    const c = zy(t),
      s = this.outputLen;
    if (s % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
    const l = s / 4,
      u = this.get();
    if (l > u.length) throw new Error('_sha2: outputLen bigger than state');
    for (let d = 0; d < l; d++) c.setUint32(4 * d, u[d], o);
  }
  digest() {
    const { buffer: t, outputLen: n } = this;
    this.digestInto(t);
    const r = t.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: n, buffer: r, length: i, finished: o, destroyed: a, pos: c } = this;
    return (
      (t.length = i), (t.pos = c), (t.finished = o), (t.destroyed = a), i % n && t.buffer.set(r), t
    );
  }
};
const IB = (e, t, n) => (e & t) ^ (~e & n),
  EB = (e, t, n) => (e & t) ^ (e & n) ^ (t & n),
  TB = new Uint32Array([
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221,
    3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580,
    3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895,
    666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037,
    2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
    1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298,
  ]),
  Ei = new Uint32Array([
    1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225,
  ]),
  Ti = new Uint32Array(64);
let $E = class extends AB {
    constructor() {
      super(64, 32, 8, !1),
        (this.A = Ei[0] | 0),
        (this.B = Ei[1] | 0),
        (this.C = Ei[2] | 0),
        (this.D = Ei[3] | 0),
        (this.E = Ei[4] | 0),
        (this.F = Ei[5] | 0),
        (this.G = Ei[6] | 0),
        (this.H = Ei[7] | 0);
    }
    get() {
      const { A: t, B: n, C: r, D: i, E: o, F: a, G: c, H: s } = this;
      return [t, n, r, i, o, a, c, s];
    }
    set(t, n, r, i, o, a, c, s) {
      (this.A = t | 0),
        (this.B = n | 0),
        (this.C = r | 0),
        (this.D = i | 0),
        (this.E = o | 0),
        (this.F = a | 0),
        (this.G = c | 0),
        (this.H = s | 0);
    }
    process(t, n) {
      for (let d = 0; d < 16; d++, n += 4) Ti[d] = t.getUint32(n, !1);
      for (let d = 16; d < 64; d++) {
        const f = Ti[d - 15],
          p = Ti[d - 2],
          y = Ir(f, 7) ^ Ir(f, 18) ^ (f >>> 3),
          b = Ir(p, 17) ^ Ir(p, 19) ^ (p >>> 10);
        Ti[d] = (b + Ti[d - 7] + y + Ti[d - 16]) | 0;
      }
      let { A: r, B: i, C: o, D: a, E: c, F: s, G: l, H: u } = this;
      for (let d = 0; d < 64; d++) {
        const f = Ir(c, 6) ^ Ir(c, 11) ^ Ir(c, 25),
          p = (u + f + IB(c, s, l) + TB[d] + Ti[d]) | 0,
          b = ((Ir(r, 2) ^ Ir(r, 13) ^ Ir(r, 22)) + EB(r, i, o)) | 0;
        (u = l), (l = s), (s = c), (c = (a + p) | 0), (a = o), (o = i), (i = r), (r = (p + b) | 0);
      }
      (r = (r + this.A) | 0),
        (i = (i + this.B) | 0),
        (o = (o + this.C) | 0),
        (a = (a + this.D) | 0),
        (c = (c + this.E) | 0),
        (s = (s + this.F) | 0),
        (l = (l + this.G) | 0),
        (u = (u + this.H) | 0),
        this.set(r, i, o, a, c, s, l, u);
    }
    roundClean() {
      Ti.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
    }
  },
  kB = class extends $E {
    constructor() {
      super(),
        (this.A = -1056596264),
        (this.B = 914150663),
        (this.C = 812702999),
        (this.D = -150054599),
        (this.E = -4191439),
        (this.F = 1750603025),
        (this.G = 1694076839),
        (this.H = -1090891868),
        (this.outputLen = 28);
    }
  };
xE(() => new $E());
xE(() => new kB());
new Set(Object.values(ze));
const CB = () => rI(qp, (e) => new MB(e))();
var Ui;
class MB {
  constructor(t) {
    _t(this, Ui);
    Le(this, 'identifyAccount', async (t, n, r) => {
      const i = !!n.addresses.find((f) => q.isSolanaNetworkID(f.networkID)),
        o = !!n.addresses.find((f) => q.isEthereumNetworkID(f.networkID)),
        a = !!n.addresses.find((f) => q.isBitcoinNetworkID(f.networkID)),
        c = !!n.addresses.find((f) => q.isSuiNetworkID(f.networkID)),
        s = { hasSolanaAddress: i, hasEthereumAddress: o, hasBitcoinAddress: a, hasSuiAddress: c },
        l = r.enabledChainIDs.map((f) => q[f].name).join(', '),
        u = new Set(),
        d = new Set();
      for (const f of t)
        switch (f.type) {
          case ze.Seed:
          case ze.Seedless:
            u.add(f.seedIdentifier);
            break;
          case ze.ReadOnly:
            break;
          case ze.PrivateKey:
          case ze.Ledger:
          case ze.SeedVault:
            d.add(f.identifier);
            break;
          default:
            Sn();
            break;
        }
      switch (n.type) {
        case ze.Seed:
        case ze.Seedless:
          ue(this, Ui).identify(n.identifier, {
            ...s,
            accountType: n.type,
            rootID: n.seedIdentifier,
            rootIds: Array.from(u),
            accountIds: Array.from(d),
            isReadOnly: !1,
            enabledChains: l,
          });
          break;
        case ze.ReadOnly:
          ue(this, Ui).identify(n.identifier, {
            ...s,
            accountType: n.type,
            isReadOnly: !0,
            enabledChains: l,
          });
          break;
        case ze.PrivateKey:
        case ze.Ledger:
        case ze.SeedVault:
          ue(this, Ui).identify(n.identifier, {
            ...s,
            accountType: n.type,
            rootIds: Array.from(u),
            accountIds: Array.from(d),
            isReadOnly: !1,
            enabledChains: l,
          });
          break;
        default:
          Sn();
      }
    });
    Le(this, 'onAppSessionStart', (t) => {
      const n = new Map();
      for (const r of t) {
        if (r.type === ze.ReadOnly) continue;
        const { addresses: i, identifier: o } = r;
        for (const a of i) {
          const c = q.getChainName(a.networkID),
            s = { type: r.type, accountId: o, id: a.address };
          if (!n.get(c)) n.set(c, [s]);
          else {
            const l = n.get(c) ?? [];
            n.set(c, [...l, s]);
          }
        }
      }
      ue(this, Ui).capture('appSessionStart', { data: { ids: Object.fromEntries(n) } });
    });
    mt(this, Ui, t);
  }
}
Ui = new WeakMap();
const PB = () => {
    const e = [];
    return (
      RI.forEach((t) => {
        e.push(t.value), t.isLocale && e.push(t.value.substr(0, 2));
      }),
      [...new Set(e)]
    );
  },
  OB = (e, t) =>
    e.substr(0, 3) === 'fil'
      ? t === 'fil'
      : e.substr(0, 2) === 'zh'
        ? e === 'zh-TW'
          ? t === 'zh-TW'
          : t === 'zh-CN'
        : t === e.substr(0, 2),
  i1 = (e) => {
    var t;
    return (t = RI.find((n) => OB(e, n.value))) == null ? void 0 : t.value;
  };
async function DB(e) {
  for (const n of e) {
    const r = await n.get(Jn.NetworkSetting);
    if (r) return r.setting;
  }
  const t = await Un.isFeatureEnabledAsync('enable-sui-testnet');
  return qR(t).setting;
}
async function RB(e) {
  return (await e.get(WE)) ?? y6;
}
async function xB(e, t) {
  await e.set(WE, t);
}
const WE = Cp.UserTrustedApps,
  o1 = 7200,
  f_ = () => ({ networks: {}, maxSessionDuration: o1 }),
  BB = h.object({
    networks: h.record(oa, h.boolean()),
    sessionStartTime: h.number().optional(),
    maxSessionDuration: h.literal(o1),
  });
h.record(h.string(), BB);
function VE(e) {
  const { sessionStartTime: t = 0, maxSessionDuration: n = o1, networks: r = {} } = e ?? {};
  return Object.values(r).some((o) => o === !0) && t > Date.now() - n * 1e3;
}
async function h_(e, t, n) {
  var c, s;
  const r = n.replace(/\/$/, ''),
    i = await RB(e),
    o =
      ((s = (c = i == null ? void 0 : i.apps) == null ? void 0 : c[t]) == null ? void 0 : s[r]) ??
      {};
  let a = (o == null ? void 0 : o.autoConfirm) ?? f_();
  if (o != null && o.autoConfirm) {
    const l = Object.values(a.networks).some((d) => d === !0);
    VE(o == null ? void 0 : o.autoConfirm) === !1 &&
      l &&
      ((a = await jB(o.autoConfirm)), (a = a ?? f_()));
  }
  return (o.autoConfirm = a), await xB(e, i), o.autoConfirm;
}
async function jB(e) {
  if (!(e != null && e.networks)) return e;
  for (const t of Object.keys(e == null ? void 0 : e.networks)) e.networks[t] = !1;
  return e;
}
var p_ = {};
const NB = p_.RUDDERSTACK_DATAPLANE ?? p_.VITE_RUDDERSTACK_DATAPLANE ?? 'https://data.phantom.app';
function g_(e, { action: t, data: n }) {
  const r = { type: 'transaction', data: { ...n, chainId: n.chainId ?? n.networkId }, action: t };
  return (
    (!r.data.ids || r.data.ids.length === 0) &&
      Z.captureError(new Error('No ids found in transactionSubmitted payload'), te.Provider),
    e.capture('transactionSubmitted', r)
  );
}
function y_(e, t) {
  const n = { type: 'message', data: { ...t, chainId: t.chainId ?? t.networkId } };
  return e.capture('transactionSubmitted', n);
}
async function Gf(e, t, n) {
  const { origin: r } = t;
  switch (e.method) {
    case 'eth_sendTransaction': {
      const [i] = e.params,
        o = Br(i.chainId);
      return (o == null ? void 0 : o.chainType) !== 'eip155'
        ? {
            success: !1,
            error: `Unsupported Ethereum chain ID (${i.chainId}) for method "${e.method}"`,
          }
        : {
            success: !0,
            data: {
              ...o,
              origin: r,
              method: e.method,
              gas: i.gas,
              maxFeePerGas: i.maxFeePerGas,
              maxPriorityFeePerGas: i.maxPriorityFeePerGas,
              ids: n,
            },
          };
    }
    case 'sol_signTransaction': {
      const i = Br(t.chainId);
      return (i == null ? void 0 : i.chainType) !== 'solana'
        ? {
            success: !1,
            error: `Unsupported Solana chain ID (${t.chainId}) for method "${e.method}"`,
          }
        : { success: !0, data: { ...i, origin: r, method: 'signTransaction', ids: n } };
    }
    case 'sol_signAndSendTransaction': {
      const i = Br(t.chainId);
      return (i == null ? void 0 : i.chainType) !== 'solana'
        ? {
            success: !1,
            error: `Unsupported Solana chain ID (${t.chainId}) for method "${e.method}"`,
          }
        : { success: !0, data: { ...i, origin: r, method: 'signAndSendTransaction', ids: n } };
    }
    case 'sol_signAndSendAllTransactions': {
      const i = Br(t.chainId);
      return (i == null ? void 0 : i.chainType) !== 'solana'
        ? {
            success: !1,
            error: `Unsupported Solana chain ID (${t.chainId}) for method "${e.method}"`,
          }
        : { success: !0, data: { ...i, origin: r, method: 'signAndSendAllTransactions', ids: n } };
    }
    case 'sol_signAllTransactions': {
      const i = Br(t.chainId);
      return (i == null ? void 0 : i.chainType) !== 'solana'
        ? {
            success: !1,
            error: `Unsupported Solana chain ID (${t.chainId}) for method "${e.method}"`,
          }
        : { success: !0, data: { ...i, origin: r, method: 'signAllTransactions', ids: n } };
    }
  }
}
async function Yf(e, t) {
  const { origin: n } = t;
  switch (e.method) {
    case 'eth_sign':
    case 'personal_sign': {
      const r = t.chainId,
        i = Br(r);
      return (i == null ? void 0 : i.chainType) !== 'eip155'
        ? { success: !1, error: `Unsupported Ethereum chain ID (${r}) for method "${e.method}"` }
        : { success: !0, data: { ...i, method: e.method, origin: n } };
    }
    case 'eth_signTypedData': {
      const [r] = e.params;
      let i = t.chainId;
      for (const a of r)
        if (a.name === 'chainId') {
          i = a.value;
          break;
        }
      const o = Br(i);
      return (o == null ? void 0 : o.chainType) !== 'eip155'
        ? { success: !1, error: `Unsupported Ethereum chain ID (${i}) for method "${e.method}"` }
        : { success: !0, data: { ...o, method: e.method, origin: n } };
    }
    case 'eth_signTypedData_v3': {
      const [r, i] = e.params,
        o = i.domain.chainId ?? t.chainId,
        a = Br(o);
      return (a == null ? void 0 : a.chainType) !== 'eip155'
        ? { success: !1, error: `Unsupported Ethereum chain ID (${o}) for method "${e.method}"` }
        : { success: !0, data: { ...a, method: e.method, origin: n } };
    }
    case 'eth_signTypedData_v4': {
      const [r, i] = e.params;
      let o = t.chainId;
      (typeof i.domain.chainId == 'string' || typeof i.domain.chainId == 'number') &&
        (o = i.domain.chainId);
      const a = Br(o);
      return (a == null ? void 0 : a.chainType) !== 'eip155'
        ? { success: !1, error: `Unsupported Ethereum chain ID (${o}) for method "${e.method}"` }
        : { success: !0, data: { ...a, method: e.method, origin: n } };
    }
    case 'sol_signIn':
    case 'sol_signMessage': {
      const r = t.chainId,
        i = Br(r);
      return (i == null ? void 0 : i.chainType) !== 'solana'
        ? { success: !1, error: `Unsupported Solana chain ID (${r}) for method "${e.method}"` }
        : {
            success: !0,
            data: { ...i, method: e.method === 'sol_signIn' ? 'signIn' : 'signMessage', origin: n },
          };
    }
  }
}
var KE = { exports: {} };
(function (e) {
  (function (t, n) {
    e.exports ? (e.exports = n()) : (t.log = n());
  })(g, function () {
    var t = function () {},
      n = 'undefined',
      r =
        typeof window !== n &&
        typeof window.navigator !== n &&
        /Trident\/|MSIE /.test(window.navigator.userAgent),
      i = ['trace', 'debug', 'info', 'warn', 'error'],
      o = {},
      a = null;
    function c(b, m) {
      var w = b[m];
      if (typeof w.bind == 'function') return w.bind(b);
      try {
        return Function.prototype.bind.call(w, b);
      } catch {
        return function () {
          return Function.prototype.apply.apply(w, [b, arguments]);
        };
      }
    }
    function s() {
      console.log &&
        (console.log.apply
          ? console.log.apply(console, arguments)
          : Function.prototype.apply.apply(console.log, [console, arguments])),
        console.trace && console.trace();
    }
    function l(b) {
      return (
        b === 'debug' && (b = 'log'),
        typeof console === n
          ? !1
          : b === 'trace' && r
            ? s
            : console[b] !== void 0
              ? c(console, b)
              : console.log !== void 0
                ? c(console, 'log')
                : t
      );
    }
    function u() {
      for (var b = this.getLevel(), m = 0; m < i.length; m++) {
        var w = i[m];
        this[w] = m < b ? t : this.methodFactory(w, b, this.name);
      }
      if (((this.log = this.debug), typeof console === n && b < this.levels.SILENT))
        return 'No console available for logging';
    }
    function d(b) {
      return function () {
        typeof console !== n && (u.call(this), this[b].apply(this, arguments));
      };
    }
    function f(b, m, w) {
      return l(b) || d.apply(this, arguments);
    }
    function p(b, m) {
      var w = this,
        _,
        S,
        E,
        O = 'loglevel';
      typeof b == 'string' ? (O += ':' + b) : typeof b == 'symbol' && (O = void 0);
      function N(M) {
        var C = (i[M] || 'silent').toUpperCase();
        if (!(typeof window === n || !O)) {
          try {
            window.localStorage[O] = C;
            return;
          } catch {}
          try {
            window.document.cookie = encodeURIComponent(O) + '=' + C + ';';
          } catch {}
        }
      }
      function F() {
        var M;
        if (!(typeof window === n || !O)) {
          try {
            M = window.localStorage[O];
          } catch {}
          if (typeof M === n)
            try {
              var C = window.document.cookie,
                z = encodeURIComponent(O),
                I = C.indexOf(z + '=');
              I !== -1 && (M = /^([^;]+)/.exec(C.slice(I + z.length + 1))[1]);
            } catch {}
          return w.levels[M] === void 0 && (M = void 0), M;
        }
      }
      function D() {
        if (!(typeof window === n || !O)) {
          try {
            window.localStorage.removeItem(O);
          } catch {}
          try {
            window.document.cookie =
              encodeURIComponent(O) + '=; expires=Thu, 01 Jan 1970 00:00:00 UTC';
          } catch {}
        }
      }
      function k(M) {
        var C = M;
        if (
          (typeof C == 'string' &&
            w.levels[C.toUpperCase()] !== void 0 &&
            (C = w.levels[C.toUpperCase()]),
          typeof C == 'number' && C >= 0 && C <= w.levels.SILENT)
        )
          return C;
        throw new TypeError('log.setLevel() called with invalid level: ' + M);
      }
      (w.name = b),
        (w.levels = { TRACE: 0, DEBUG: 1, INFO: 2, WARN: 3, ERROR: 4, SILENT: 5 }),
        (w.methodFactory = m || f),
        (w.getLevel = function () {
          return E ?? S ?? _;
        }),
        (w.setLevel = function (M, C) {
          return (E = k(M)), C !== !1 && N(E), u.call(w);
        }),
        (w.setDefaultLevel = function (M) {
          (S = k(M)), F() || w.setLevel(M, !1);
        }),
        (w.resetLevel = function () {
          (E = null), D(), u.call(w);
        }),
        (w.enableAll = function (M) {
          w.setLevel(w.levels.TRACE, M);
        }),
        (w.disableAll = function (M) {
          w.setLevel(w.levels.SILENT, M);
        }),
        (w.rebuild = function () {
          if ((a !== w && (_ = k(a.getLevel())), u.call(w), a === w))
            for (var M in o) o[M].rebuild();
        }),
        (_ = k(a ? a.getLevel() : 'WARN'));
      var K = F();
      K != null && (E = k(K)), u.call(w);
    }
    (a = new p()),
      (a.getLogger = function (m) {
        if ((typeof m != 'symbol' && typeof m != 'string') || m === '')
          throw new TypeError('You must supply a name when creating a logger.');
        var w = o[m];
        return w || (w = o[m] = new p(m, a.methodFactory)), w;
      });
    var y = typeof window !== n ? window.log : void 0;
    return (
      (a.noConflict = function () {
        return typeof window !== n && window.log === a && (window.log = y), a;
      }),
      (a.getLoggers = function () {
        return o;
      }),
      (a.default = a),
      a
    );
  });
})(KE);
var UB = KE.exports;
const Qr = Oc(UB);
var LB = zB;
function zB(e) {
  var t, n, r;
  if (e) {
    if (Array.isArray(e)) {
      for (t = [], n = e.length, r = 0; r < n; r++) {
        var i = e[r];
        i != null && t.push(i);
      }
      return t;
    }
    if (typeof e == 'object') {
      t = {};
      var o = Object.keys(e);
      for (n = o.length, r = 0; r < n; r++) {
        var a = o[r],
          c = e[a];
        c != null && (t[a] = c);
      }
      return t;
    }
  }
}
const FB = h.object({
    chainType: h.union([h.literal('bip122_p2wpkh'), h.literal('bip122_p2tr')]),
    chainName: h.literal('bitcoin'),
    networkId: h.union([h.literal('128'), h.literal('239')]),
  }),
  $B = h.object({
    chainType: h.literal('eip155'),
    chainName: h.literal('ethereum'),
    networkId: h.union([h.literal('1'), h.literal('5'), h.literal('11155111')]),
  }),
  WB = h.object({
    chainType: h.literal('eip155'),
    chainName: h.literal('polygon'),
    networkId: h.union([h.literal('137'), h.literal('80002')]),
  }),
  VB = h.object({
    chainType: h.literal('eip155'),
    chainName: h.literal('base'),
    networkId: h.union([h.literal('8453'), h.literal('84532')]),
  }),
  KB = h.object({
    chainType: h.literal('eip155'),
    chainName: h.literal('arbitrum'),
    networkId: h.union([h.literal('42161'), h.literal('421614')]),
  }),
  HB = h.object({
    chainType: h.literal('eip155'),
    chainName: h.literal('monad'),
    networkId: h.union([h.literal('143'), h.literal('10143'), h.literal('41454')]),
  }),
  qB = h.object({
    chainType: h.literal('solana'),
    chainName: h.literal('solana'),
    networkId: h.union([
      h.literal('mainnet'),
      h.literal('testnet'),
      h.literal('devnet'),
      h.literal('localnet'),
    ]),
  }),
  GB = h.object({
    chainType: h.literal('sui'),
    chainName: h.literal('sui'),
    networkId: h.union([h.literal('mainnet'), h.literal('testnet')]),
  }),
  YB = h.union([FB, $B, VB, KB, HB, WB, qB, GB]);
var ZB = {};
const QB = () => (document == null ? void 0 : document.referrer) || '$direct',
  JB = () =>
    ['t', 'y', '1', 'true', 'yes'].some((e) => {
      var t;
      return ((t = ZB.DISABLE_ANALYTICS) == null ? void 0 : t.toLowerCase()) === e;
    }) ?? !1;
function HE(e) {
  var i;
  if (!e) return;
  let t = e.data ?? {},
    n = ((i = e.data) == null ? void 0 : i.asset) ?? {};
  try {
    (t = JSON.parse(JSON.stringify(t))), (n = JSON.parse(JSON.stringify(n)));
  } catch (o) {
    Qr.error('Failed to parse analytics payload', o);
    return;
  }
  const r = {
    ...t,
    ...(e.action ? { action: e.action } : {}),
    ...(n && typeof n == 'object' ? n : {}),
    ...(e.type ? { type: e.type } : {}),
  };
  if ('chainID' in r && !('chainType' in r) && !('chainName' in r) && !('networkId' in r)) {
    const o = oa.safeParse(r.chainID);
    o.success && Object.assign(r, XB(o.data));
  }
  return LB(r);
}
function XB(e) {
  const t = q.getChainDefinition(e);
  return YB.parse({
    chainType: t.addressTypes[0],
    chainName: t.id,
    networkId: t.networks[e].value.toString(),
  });
}
const e5 = [
    'enable-blocklist-metrics',
    'enable-blocklist-blowfish-logonly',
    'enable-force-upgrade',
  ],
  ki = '[Analytics Log]';
class t5 {
  constructor(t) {
    Le(this, 'storage');
    Le(this, 'rudderClient');
    this.storage = t;
  }
  async capture(t, n) {
    Qr.debug(ki, 'Capture Event:', t, HE(n));
  }
  async getFeatureFlags() {
    const {
        ENABLED_FLAGS: t,
        featureFlags: n,
        getFeatureFlagOverrides: r,
      } = await Rt(
        async () => {
          const {
            ENABLED_FLAGS: s,
            featureFlags: l,
            getFeatureFlagOverrides: u,
          } = await import('./phantomRpc-roQOrxiJ.js').then((d) => d.bO);
          return { ENABLED_FLAGS: s, featureFlags: l, getFeatureFlagOverrides: u };
        },
        __vite__mapDeps([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])
      ),
      i = n.filter((s) => !s.startsWith('kill') && !e5.includes(s)),
      o = Object.fromEntries(i.map((s) => [s, !0])),
      a = await r(this.storage),
      c = Object.fromEntries(t.map((s) => [s, !0]));
    return { ...o, ...c, ...a };
  }
  async addUserProperties(t) {
    Qr.debug(ki, 'User Properties:', JSON.stringify(t));
  }
  async identify(t, n) {
    Qr.debug(ki, 'Identify, accountID:', t, ' traits:', n);
  }
  async getDeviceId() {
    return 'mock-device-id';
  }
  setDeviceId(t) {
    Qr.debug(ki, `SetDeviceId: ${t}`);
  }
  async setAnalyticsOptedOut(t) {
    Qr.debug(ki, `SetAnalyticsOptedOut: ${t}`);
  }
  async setDisplayLanguage(t) {
    Qr.debug(ki, `SetDisplayLanguage: ${t}`);
  }
  screen(t, n) {
    Qr.debug(ki, `Screen: ${t}`, n);
  }
  page(t, n, r, i) {
    Qr.debug(ki, `Page: ${t}`, n, r, i);
  }
}
const n5 = () => NB,
  r5 = ({ storage: e, rudderStackKey: t, createAnalytics: n }) => {
    if (!t) throw new Error('RUDDERSTACK_KEY_[*] env variables required.');
    const r = n5();
    if (!r) throw new Error('[*]_RUDDERSTACK_DATAPLANE env variables required.');
    return JB() ? new t5(e) : n(t, r);
  };
async function Ci() {}
const i5 = () => ({
  capture: Ci,
  getFeatureFlags: async () => ({}),
  addUserProperties: Ci,
  identify: Ci,
  getDeviceId: async () => '',
  setDeviceId: Ci,
  setAnalyticsOptedOut: Ci,
  setDisplayLanguage: Ci,
  screen: Ci,
  page: Ci,
  rudderClient: {},
});
var Li, Ua, ir;
class o5 {
  constructor(t) {
    Le(this, 'rudderClient');
    _t(this, Li, null);
    _t(this, Ua, !1);
    _t(this, ir, {
      platform: 'browser-embedded',
      appVersion: vc,
      displayLanguage: Et.language,
      embeddedDappOrigin: '',
    });
    this.rudderClient = t;
  }
  identifyOnClientIfNeeded() {
    !ue(this, Ua) &&
      ue(this, Li) &&
      (this.rudderClient.identify(ue(this, Li), ue(this, ir)), mt(this, Ua, !0));
  }
  async capture(t, n) {
    (await this.getAnalyticsOptedOut()) ||
      (await this.identifyOnClientIfNeeded(),
      this.rudderClient.track(
        t,
        { ...HE(n) },
        { context: { referrer: lm(QB()), initialReferrer: null, traits: ue(this, ir) } }
      ));
  }
  async getFeatureFlags() {
    return Un.getFeatureFlags();
  }
  async addUserProperties(t) {
    (await this.getAnalyticsOptedOut()) ||
      (mt(this, ir, { ...ue(this, ir), ...t }),
      ue(this, Li) && (await this.identify(ue(this, Li), {})));
  }
  async identify(t, n = {}) {
    (await this.getAnalyticsOptedOut()) ||
      (mt(this, Li, t),
      mt(this, ir, { ...ue(this, ir), ...n }),
      n != null &&
        n.embeddedDappOrigin &&
        ((n.embeddedDappOrigin = lm(n.embeddedDappOrigin)),
        (ue(this, ir).embeddedDappOrigin = n.embeddedDappOrigin ?? '')),
      mt(this, Ua, !1));
  }
  getDeviceId() {
    return Promise.resolve(this.rudderClient.getAnonymousId() ?? '');
  }
  setDeviceId(t) {
    return this.rudderClient.setAnonymousId(t), Promise.resolve();
  }
  async setAnalyticsOptedOut(t) {
    return Promise.resolve();
  }
  setDisplayLanguage(t) {
    return (ue(this, ir).displayLanguage = t), Promise.resolve();
  }
  screen(t, n) {}
  page(t, n, r, i) {
    this.rudderClient.page(t, n || 'unknown', r, i);
  }
  async getAnalyticsOptedOut() {
    return Promise.resolve(!1);
  }
}
(Li = new WeakMap()), (Ua = new WeakMap()), (ir = new WeakMap());
const a5 = 'cc94b84a-50e8-4aae-8296-ac417de90524';
let At = {};
const qE = () => {
    var n, r, i;
    const e = (r = (n = globalThis.chrome) == null ? void 0 : n.storage) == null ? void 0 : r.local,
      t = (i = globalThis.window) == null ? void 0 : i.localStorage;
    return e || t;
  },
  s5 = async () => {
    if (typeof document > 'u') return !1;
    const e = document.createElement('div');
    (e.style.display = 'none'), document.body.appendChild(e);
    const t = getComputedStyle(e).getPropertyValue('--arc-palette-title');
    return document.body.removeChild(e), await qE().set({ isArcBrowser: !!t }), !!t;
  },
  GE = async () => {
    var e;
    return (e = await qE().get('isArcBrowser')) == null ? void 0 : e.isArcBrowser;
  },
  c5 = async () => {
    var n;
    const e = await ((n = navigator.userAgentData) == null
      ? void 0
      : n.getHighEntropyValues(['platform', 'platformVersion', 'brands']));
    if (!e) return;
    At = { ...(await f5(e.brands)), platform: e.platform, platformVersion: e.platformVersion };
  },
  u5 = async (e) => {
    var t, n;
    if (e.includes('Chrome/'))
      e.includes('Edg/')
        ? ((At.name = 'Microsoft Edge'), (At.version = e.split('Edg/')[1].split(' ')[0]))
        : e.includes('OPR/')
          ? ((At.name = 'Opera'), (At.version = e.split('OPR/')[1].split(' ')[0]))
          : ((t = navigator.brave) != null && t.isBrave()
              ? (At.name = 'Brave')
              : (At.name = 'Chrome'),
            (At.version = e.split('Chrome/')[1].split(' ')[0]));
    else if (e.includes('Firefox/'))
      (At.name = 'Firefox'), (At.version = e.split('Firefox/')[1].split(' ')[0]);
    else if (e.includes('Safari/') && !e.includes('Chrome/'))
      (At.name = 'Safari'), (At.version = e.split('Version/')[1].split(' ')[0]);
    else {
      const r = /(?:Mozilla|Opera|AppleWebKit)\/[\d.]+\s+\(.*?\)\s+(?!Version)([^/]+)\/([^ ]+)/,
        i = e.match(r);
      i && ((At.name = i[1]), (At.version = i[2]));
    }
    (n = At.name) != null && n.match(/Chrome/) && (At.name = (await GE()) ? 'Arc' : 'Chrome');
  },
  l5 = (e) => {
    const t = [
      { name: 'Windows', pattern: /Windows NT ([0-9._]+)/ },
      { name: 'Mac OS', pattern: /Mac OS X ([0-9._]+)/ },
      { name: 'Linux', pattern: /Linux/ },
      { name: 'Chrome OS', pattern: /CrOS/ },
    ];
    for (const n of t) {
      const r = e.match(n.pattern);
      r && ((At.platform = n.name), (At.platformVersion = r[1]));
    }
    At.platform || ((At.platform = 'Unknown'), (At.platformVersion = 'Unknown'));
  },
  d5 = async () => {
    const e = navigator.userAgent;
    await u5(e), l5(e);
  },
  f5 = async (e) => {
    if (!e || !e.length) return;
    let t;
    for (const n of e)
      if (!(n.brand.includes('Not') || n.brand.includes('Chromium'))) {
        t = { name: n.brand, version: n.version };
        break;
      }
    if (!(t != null && t.name)) {
      const n = e.find((r) => r.brand === 'Chromium');
      n
        ? (t = { name: (await GE()) ? 'Arc' : 'Chromium', version: n.version })
        : (t = { name: e[0].brand, version: e[0].version });
    }
    return t;
  },
  h5 = async () => {
    try {
      await s5();
    } catch {}
    await c5(), (At != null && At.name) || (await d5());
  };
var La, zi;
const Ep = class Ep {
  constructor() {
    _t(this, zi, new r4.EventEmitter());
  }
  static getInstance() {
    return ue(this, La) || mt(this, La, new Ep()), ue(this, La);
  }
  async get(t) {
    try {
      const n = window.localStorage.getItem(t);
      if (n == null) return Promise.resolve(null);
      const r = JSON.parse(n);
      return Promise.resolve(r.expiry ? r.value : r);
    } catch (n) {
      const r = `[WindowLocalStorage.get] Error getting key (${t}): ${n}`;
      throw new Error(r);
    }
  }
  async getAll(t = []) {
    try {
      const n = t.reduce((r, i) => {
        const o = window.localStorage.getItem(i);
        return o == null ? (r[i] = null) : (r[i] = JSON.parse(o)), r;
      }, {});
      return Promise.resolve(n);
    } catch (n) {
      const r = `[WindowLocalStorage.getAll] Error getting key(s) (${t}): ${n}`;
      throw new Error(r);
    }
  }
  async remove(t) {
    try {
      let n;
      Array.isArray(t) ? (n = t) : (n = [t]);
      for (const r of n) window.localStorage.removeItem(r);
      return Promise.resolve();
    } catch (n) {
      const r = `[WindowLocalStorage.remove] Error removing key(s) (${t}): ${n}`;
      throw new Error(r);
    }
  }
  async set(t, n) {
    try {
      return (
        window.localStorage.setItem(t, JSON.stringify(n)),
        ue(this, zi).emit('storageChanged', t),
        Promise.resolve()
      );
    } catch (r) {
      const i = `[WindowLocalStorage.set] Error setting key (${t}): ${r}`;
      throw new Error(i);
    }
  }
  async setAll(t) {
    try {
      for (const [n, r] of Object.entries(t)) window.localStorage.setItem(n, JSON.stringify(r));
      for (const n of Object.keys(t)) ue(this, zi).emit('storageChanged', n);
      return Promise.resolve();
    } catch (n) {
      const i = `[WindowLocalStorage.setAll] Error setting keys (${Object.keys(t)}): ${n}`;
      throw new Error(i);
    }
  }
  async clear() {
    try {
      const t = [];
      for (const n in localStorage) t.push(n);
      window.localStorage.clear();
      for (const n of t) ue(this, zi).emit('storageChanged', n);
      return Promise.resolve();
    } catch (t) {
      const n = `[WindowLocalStorage.clear] Error clearing storage: ${t}`;
      throw new Error(n);
    }
  }
  subscribe(t) {
    const n = (r) => void t(r);
    return (
      ue(this, zi).addListener('storageChanged', n),
      () => {
        ue(this, zi).removeListener('storageChanged', n);
      }
    );
  }
  async update(t, n) {
    try {
      await navigator.locks.request(`storage.${t}`, async (r) => {
        const i = await this.get(t),
          o = await n(i);
        await this.set(t, o);
      });
    } catch (r) {
      const i = `[WindowLocalStorage.update] Error updating key (${t}): ${r}`;
      throw new Error(i);
    }
  }
};
(La = new WeakMap()), (zi = new WeakMap()), _t(Ep, La);
let zn = Ep;
const Da = zn.getInstance(),
  b_ = { width: 500, height: 500 },
  p5 = (e, t) => {
    const n = setInterval(() => {
      e.closed && (clearInterval(n), t('Popup closed'));
    }, 1e3);
    return () => clearInterval(n);
  };
function g5(e, t, n) {
  const r = screen.width,
    i = screen.height,
    o = r / 2 - t / 2,
    a = i / 2 - n / 2,
    c = window.open(
      e,
      '_blank',
      `scrollbars=yes, width=${t}, height=${n}, top=${a}, left=${o}, location=no, toolbar=no`
    );
  return c != null && c.focus && c.focus(), c;
}
const y5 = async (e, t, n) => {
  const r = g5(t, b_.width, b_.height);
  if (!r) throw new Error('Login popup was blocked.');
  return new Promise((i, o) => {
    const a = p5(r, o),
      c = (s) => {
        if (typeof s.data != 'string') return;
        const l = s3(s.data);
        if (!l) return;
        const u = new URL(l);
        if (u.origin !== window.location.origin) throw new Error('Invalid redirect URL origin');
        const d = u.searchParams.get('code');
        d && (r.close(), a(), window.removeEventListener('message', c), i(d));
      };
    window.addEventListener('message', c);
  });
};
let YE = 'http://localhost:5173/callback',
  Zp = 'http://localhost:5174',
  ZE = '890b519a-206c-4fab-8083-5dbc32ba8a95';
(Zp = 'https://embedded-wallet-signer.phantom.app'),
  (YE = 'https://embedded-wallet.phantom.app/callback'),
  (ZE = 'c1cb1aea-b7fc-4350-bab9-73c8589ba3e2');
const a1 = new iI({
    defaultOptions: {
      mutations: { retry: !1, networkMode: 'offlineFirst' },
      queries: {
        retry: !1,
        staleTime: 1 / 0,
        gcTime: 1 / 0,
        refetchOnWindowFocus: !1,
        networkMode: 'offlineFirst',
      },
    },
  }),
  b5 = i2({ underlyingStorage: zn.getInstance(), throttleMs: 1e3, enableDebugLogs: l3() }),
  m5 = { shouldDehydrateQuery: () => !1 },
  w5 = (e) =>
    A.jsx(o2, {
      client: a1,
      persistOptions: { persister: b5, dehydrateOptions: m5, buster: _5, maxAge: 1 / 0 },
      children: e.children,
    }),
  _5 = '25.2.0',
  v5 = { getClientID: () => ZE, redirectURL: YE, fetchAuthorizationCode: y5 },
  S5 = {
    storage: Da,
    authConfig: v5,
    queryClient: a1,
    runExclusive: async (e) => window.navigator.locks.request('AUTH_LOCK', e),
    isServerTimeEnabled: () => !Un.isFeatureEnabled('kill-frontend-server-time'),
  },
  qa = IR(S5),
  A5 = ({ children: e }) => A.jsx(DR, { authRepository: qa, children: e }),
  I5 = (e, t) => {
    const n = new F4();
    n.load(e, t, { configUrl: `${t}/sourceConfig` });
    try {
      return new o5(n);
    } catch {
      return console.error('Failed to initialize rudderstack.'), i5();
    }
  },
  dn = r5({ storage: Da, rudderStackKey: a5, createAnalytics: I5 });
qa.subscribe(Ao.UserID, (e) => {
  Z.addBreadcrumb(te.Generic, `Auth userID: ${e}`, Te.Info),
    dn.addUserProperties({ authUserId: e });
});
const E5 = new ZA(null, {
  loadPath: (e) => {
    const t = e[0];
    return t.substring(0, 3) === 'fil'
      ? `/locales/${t.substring(0, 3)}/translation.json`
      : t.substring(0, 2) === 'zh'
        ? t === 'zh-CN' || t === 'zh-TW'
          ? `/locales/${t}/translation.json`
          : '/locales/zh-CN/translation.json'
        : `/locales/${t.substring(0, 2)}/translation.json`;
  },
  parse: (e) => JSON.parse(e),
});
Et.use(ZA)
  .use(d3)
  .use(V3)
  .use(E5)
  .init({
    supportedLngs: PB(),
    fallbackLng: 'en',
    nonExplicitSupportedLngs: !0,
    debug: !1,
    returnNull: !1,
    detection: {
      order: [
        'querystring',
        'localStorage',
        'cookie',
        'sessionStorage',
        'navigator',
        'htmlTag',
        'path',
        'subdomain',
      ],
      caches: ['localStorage'],
    },
    react: { useSuspense: !1 },
    interpolation: { escapeValue: !1 },
  });
Et.on('initialized', () => {
  dn.setDisplayLanguage(Et.language);
});
const gn = '@phantom/accounts',
  T5 = `${gn}:account-identifier`,
  k5 = `${gn}:selected-account`,
  C5 = `${gn}:all-accounts`,
  M5 = `${gn}:all-seeds`,
  P5 = `${gn}:all-secrets`,
  s1 = {
    accountBalance(e) {
      return [`${gn}:account-balance`, { identifier: e }];
    },
    allAccountBalances() {
      return [`${gn}:all-account-balances`];
    },
    allAccounts(e) {
      const t = e
        ? {
            chainAvailability: {
              enabledChainIDs: e.enabledChainIDs,
              enabledAddressTypes: e.enabledAddressTypes,
            },
          }
        : {};
      return [C5, { chainAvailabilityQueryObject: t }];
    },
    allSeeds(e) {
      return [M5, e];
    },
    allSecretIdentifiers() {
      return [P5];
    },
    developerMode() {
      return [`${gn}:developer-mode`];
    },
    accountIdentifier(e) {
      return [T5, { identifier: e }];
    },
    selectedAccount(e) {
      const t = e
        ? {
            chainAvailability: {
              enabledChainIDs: e.enabledChainIDs,
              enabledAddressTypes: e.enabledAddressTypes,
            },
          }
        : {};
      return [k5, t];
    },
    selectedAccountIdentifier() {
      return [`${gn}:selected-account-identifier`];
    },
    selectedNetworkSetting(e) {
      return [`${gn}:selected-network-setting`, { isSuiTestnetEnabled: e }];
    },
    trustedApps() {
      return [`${gn}:trusted-apps`];
    },
    migratedWithInvalidChecksum() {
      return [`${gn}:migrated-with-invalid-checksum`];
    },
    syncUserAccounts() {
      return [`${gn}:sync-user-accounts`];
    },
    accountsEligibleToClaim(e, t, n) {
      return [
        `${gn}:are-accounts-eligible-to-claim`,
        { username: e, selectedAccountIdentifier: t, solanaAddresses: n },
      ];
    },
    patchProfileAddresses(e) {
      return [`${gn}:patch-profile-addresses`, e];
    },
  },
  Qp = () => {
    const e = so(),
      {
        data: [t, n],
        isLoading: r,
      } = D0(['enable-monad', 'enable-arbitrum']);
    return pt({
      enabled: !r,
      queryKey: a2.chainAvailability({ isMonadEnabled: t, isArbitrumEnabled: n }),
      queryFn: () => R0(e, t, n),
    });
  },
  QE = G.createContext(null);
function O5({ children: e, vault: t }) {
  return A.jsx(QE.Provider, { value: t, children: e });
}
function JE() {
  const e = G.useContext(QE);
  if (!e) throw new Error('useVaultProxy must be used within a VaultProxyProvider');
  return e;
}
const XE = q.getAllChainIDs().filter((e) => q.isChainDefaultEnabled(e, !1)),
  D5 = XE.map((e) => q.getMainnetNetworkID(e)),
  R5 = D5.flatMap((e) => q.getAddressTypes(e)),
  x5 = () => {
    var e;
    return ((e = Qp().data) == null ? void 0 : e.enabledAddressTypes) ?? R5;
  },
  B5 = () => {
    var e;
    return ((e = Qp().data) == null ? void 0 : e.enabledChainIDs) ?? XE;
  },
  j5 = () => B5().length === 1;
function eT(e) {
  const { isSuccess: t, data: n } = Qp(),
    r = JE(),
    i = s1.allAccounts(n),
    o = so();
  return pt({
    enabled: t,
    queryKey: i,
    queryFn: async () => {
      if (!n) throw new Error(zI);
      const c = await HR(r, o, n);
      return (
        Z.addBreadcrumb(
          te.Account,
          `Finished fetching all accounts. Num accounts: ${c.length}`,
          Te.Info
        ),
        c
      );
    },
    select: e,
  });
}
const N5 = () => {
  const { isSuccess: e, isFetching: t, data: n = [] } = eT(),
    r = e && !t && !!n.length;
  return r ? { enabled: r, accounts: n } : { enabled: r };
};
function U5() {
  const e = so();
  return pt(L5(e));
}
function L5(e) {
  return {
    queryKey: s1.developerMode(),
    queryFn: async () => (await e.get(Jn.DeveloperMode)) || _6,
  };
}
const z5 = (e) => {
  if (e) {
    switch (e.type) {
      case ze.Seed:
      case ze.Seedless:
        return e.seedIdentifier;
      case ze.PrivateKey:
      case ze.Ledger:
      case ze.SeedVault:
      case ze.ReadOnly:
        return;
    }
    Sn();
  }
};
function ms({ select: e, updateESPUserProperties: t } = {}) {
  const n = G.useMemo(() => Un.isFeatureEnabled('frontend-enable-esp-user-properties-update'), []),
    { isSuccess: r, data: i } = Qp(),
    o = N5(),
    a = o.enabled && r,
    c = s2(),
    s = so(),
    l = CB(),
    u = s1.selectedAccount(i);
  return pt({
    queryKey: u,
    queryFn: async () => {
      try {
        if (!i) throw new Error(zI);
        if (!o.enabled) throw new Error(LI);
        const f = await $I(o.accounts, s);
        if (
          (Z.addBreadcrumb(
            te.Account,
            `Finished fetching selected account: ${f.identifier}`,
            Te.Info
          ),
          n && t)
        ) {
          const p = f.addresses.map((y) => y.address) ?? [];
          Promise.all(p.map((y) => t(y, Et.language)));
        }
        return (
          Un.setSubjectAttributes({ rootID: z5(f) }), c(), l.identifyAccount(o.accounts, f, i), f
        );
      } catch (f) {
        throw (f instanceof Error && Z.captureError(f, te.Account), f);
      }
    },
    enabled: a,
    select: e,
  });
}
Ue.createContext(null);
const F5 = () => {
    const { data: e } = U5();
    return !!(e != null && e.isDeveloperMode);
  },
  $5 = (e) => {
    const t = G.useMemo(() => {
      if (e) {
        if (W5(e)) return (r) => r.address === e.address && r.networkID === e.networkID;
        if (q.isNetworkID(e)) return (r) => r.networkID === e;
        if (c2(e)) return (r) => r.addressType === e;
        throw new Error(`Unrecognized filter type: ${e}`);
      } else return () => !1;
    }, [e]);
    return ms({
      select: (r) => {
        const i = r.addresses.filter(t);
        if (i.length > 1) throw new Error(`Multiple addresses match filter: ${e}`);
        return i[0];
      },
    });
  };
function W5(e) {
  return (
    typeof e == 'object' &&
    'address' in e &&
    (typeof e.address == 'string' || e.address === void 0) &&
    'networkID' in e
  );
}
function V5(e) {
  let t;
  const n = new Set(),
    r = (l, u) => {
      const d = typeof l == 'function' ? l(t) : l;
      if (d !== t) {
        const f = t;
        (t = u ? d : Object.assign({}, t, d)), n.forEach((p) => p(t, f));
      }
    },
    i = () => t,
    o = (l, u = i, d = Object.is) => {
      console.warn('[DEPRECATED] Please use `subscribeWithSelector` middleware');
      let f = u(t);
      function p() {
        const y = u(t);
        if (!d(f, y)) {
          const b = f;
          l((f = y), b);
        }
      }
      return n.add(p), () => n.delete(p);
    },
    s = {
      setState: r,
      getState: i,
      subscribe: (l, u, d) => (u || d ? o(l, u, d) : (n.add(l), () => n.delete(l))),
      destroy: () => n.clear(),
    };
  return (t = e(r, i, s)), s;
}
const K5 =
    typeof window > 'u' ||
    !window.navigator ||
    /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
  m_ = K5 ? G.useEffect : G.useLayoutEffect;
function aa(e) {
  const t = typeof e == 'function' ? V5(e) : e,
    n = (r = t.getState, i = Object.is) => {
      const [, o] = G.useReducer((m) => m + 1, 0),
        a = t.getState(),
        c = G.useRef(a),
        s = G.useRef(r),
        l = G.useRef(i),
        u = G.useRef(!1),
        d = G.useRef();
      d.current === void 0 && (d.current = r(a));
      let f,
        p = !1;
      (c.current !== a || s.current !== r || l.current !== i || u.current) &&
        ((f = r(a)), (p = !i(d.current, f))),
        m_(() => {
          p && (d.current = f), (c.current = a), (s.current = r), (l.current = i), (u.current = !1);
        });
      const y = G.useRef(a);
      m_(() => {
        const m = () => {
            try {
              const _ = t.getState(),
                S = s.current(_);
              l.current(d.current, S) || ((c.current = _), (d.current = S), o());
            } catch {
              (u.current = !0), o();
            }
          },
          w = t.subscribe(m);
        return t.getState() !== y.current && m(), w;
      }, []);
      const b = p ? f : d.current;
      return G.useDebugValue(b), b;
    };
  return (
    Object.assign(n, t),
    (n[Symbol.iterator] = function () {
      console.warn('[useStore, api] = create() is deprecated and will be removed in v4');
      const r = [n, t];
      return {
        next() {
          const i = r.length <= 0;
          return { value: r.shift(), done: i };
        },
      };
    }),
    n
  );
}
const H5 = { editableAccountMetadata: void 0, setEditableAccountMetadata: () => {} };
aa((e) => ({
  ...H5,
  setEditableAccountMetadata: (t) => {
    e({ editableAccountMetadata: t });
  },
}));
const w_ = {
  username: '',
  available: null,
  icon: null,
  secretIdentifiers: [],
  accountIdentifiersToSync: [],
  addresses: {},
};
aa((e, t) => ({
  ...w_,
  setUsername: (n) => e({ username: n }),
  setAvailable: (n) => e({ available: n }),
  setIcon: (n) => e({ icon: n }),
  addSecretIdentifier: (n) => {
    const r = [...t().secretIdentifiers];
    r.includes(n) || r.push(n), e({ secretIdentifiers: r });
  },
  removeSecretIdentifier: (n) => {
    e({ secretIdentifiers: t().secretIdentifiers.filter((r) => r !== n) });
  },
  addAccountIdentifierToSync: (n) => {
    const r = [...t().accountIdentifiersToSync];
    r.includes(n) || r.push(n), e({ accountIdentifiersToSync: r });
  },
  removeAccountIdentifierToSync: (n) => {
    e({ accountIdentifiersToSync: t().accountIdentifiersToSync.filter((r) => r !== n) });
  },
  clearAccountIdentifiersToSync: () => e({ accountIdentifiersToSync: [] }),
  setAccountIdentifiersToSync: (n) => e({ accountIdentifiersToSync: n }),
  addAddress: (n, r) => {
    const i = { ...t().addresses };
    (i[n] = r), e({ addresses: i });
  },
  removeAddress: (n, r) => {
    const i = { ...t().addresses };
    i[n] === r && delete i[n], e({ addresses: i });
  },
  clearAddresses: () => {
    e({ addresses: {} });
  },
  reset: () => {
    e(w_);
  },
}));
const q5 = async (e, t, n) => {
    const { enabledAddressTypes: r, enabledChainIDs: i, enabledMainnetOnlyNetworkIDs: o } = n,
      [a, c] = await Promise.all([t.get(Jn.DeveloperMode), TE(t)]),
      s = await e.fetchAllAccounts(),
      l = await $I(s, t),
      u = await FR(t, l.identifier),
      d = {
        name: u.name,
        icon: u.icon,
        identifier: l.identifier,
        addresses: UI(l, o, r, i, c, (a == null ? void 0 : a.isDeveloperMode) ?? !1),
      };
    return l.type === ze.Seed
      ? { ...d, type: ze.Seed, seedIdentifier: l.seedIdentifier, isReadOnly: !1 }
      : l.type === ze.Seedless
        ? { ...d, type: ze.Seedless, seedIdentifier: l.seedIdentifier, isReadOnly: !1 }
        : l.type === ze.ReadOnly
          ? { ...d, type: ze.ReadOnly, isReadOnly: !0 }
          : l.type === ze.PrivateKey
            ? {
                ...d,
                privateKeyIdentifier: l.privateKeyIdentifier,
                type: ze.PrivateKey,
                isReadOnly: !1,
              }
            : { ...d, type: l.type, isReadOnly: !1 };
  },
  si = {
    BASE_URL: '/',
    DEV: !1,
    MODE: 'production',
    PROD: !0,
    SSR: !1,
    VITE_DATADOG_CLIENT_TOKEN: 'pubf4dfb4e9016d7a11cef2cab4d41ee6ef',
    VITE_DEPLOY_ENVIRONMENT: 'production',
    VITE_RUDDERSTACK_KEY_BROWSER_EMBEDDED: 'cc94b84a-50e8-4aae-8296-ac417de90524',
  };
let G5 = 0;
function Je(e, t) {
  const n = `atom${++G5}`,
    r = {
      toString() {
        return (si ? 'production' : void 0) !== 'production' && this.debugLabel
          ? n + ':' + this.debugLabel
          : n;
      },
    };
  return (
    typeof e == 'function' ? (r.read = e) : ((r.init = e), (r.read = Y5), (r.write = Z5)),
    t && (r.write = t),
    r
  );
}
function Y5(e) {
  return e(this);
}
function Z5(e, t, n) {
  return t(this, typeof n == 'function' ? n(e(this)) : n);
}
const __ = (e, t) => (e.unstable_is ? e.unstable_is(t) : t === e),
  Cm = (e) => 'init' in e,
  Ky = (e) => !!e.write,
  ip = new WeakMap(),
  Mm = (e) => {
    var t;
    return Pm(e) && !((t = ip.get(e)) != null && t[1]);
  },
  Q5 = (e, t) => {
    const n = ip.get(e);
    if (n) (n[1] = !0), n[0].forEach((r) => r(t));
    else if ((si ? 'production' : void 0) !== 'production')
      throw new Error('[Bug] cancelable promise not found');
  },
  J5 = (e) => {
    if (ip.has(e)) return;
    const t = [new Set(), !1];
    ip.set(e, t);
    const n = () => {
      t[1] = !0;
    };
    e.then(n, n),
      (e.onCancel = (r) => {
        t[0].add(r);
      });
  },
  Pm = (e) => typeof (e == null ? void 0 : e.then) == 'function',
  v_ = (e) => 'v' in e || 'e' in e,
  Zf = (e) => {
    if ('e' in e) throw e.e;
    if ((si ? 'production' : void 0) !== 'production' && !('v' in e))
      throw new Error('[Bug] atom state is not initialized');
    return e.v;
  },
  tT = (e, t, n) => {
    n.p.has(e) ||
      (n.p.add(e),
      t.then(
        () => {
          n.p.delete(e);
        },
        () => {
          n.p.delete(e);
        }
      ));
  },
  X5 = (e, t, n, r) => {
    var i;
    if ((si ? 'production' : void 0) !== 'production' && n === e)
      throw new Error('[Bug] atom cannot depend on itself');
    t.d.set(n, r.n), Mm(t.v) && tT(e, t.v, r), (i = r.m) == null || i.t.add(e);
  },
  e7 = Symbol.for('JOTAI.EXPERIMENTAL.FLUSHSTOREHOOK'),
  nT = (...e) => {
    const [t, n, r, i, o, a] = e,
      c = (M) => {
        if ((si ? 'production' : void 0) !== 'production' && !M)
          throw new Error('Atom is undefined or null');
        let C = t(M);
        return C || ((C = { d: new Map(), p: new Set(), n: 0 }), n(M, C), o == null || o(M, K)), C;
      },
      s = new WeakMap(),
      l = new Map(),
      u = new Set(),
      d = new Set(),
      f = () => {
        var M;
        const C = [],
          z = (I) => {
            try {
              I();
            } catch (T) {
              C.push(T);
            }
          };
        do {
          (M = K[e7]) == null || M.call(K);
          const I = new Set(),
            T = I.add.bind(I);
          l.forEach((P) => {
            var R;
            return (R = P.m) == null ? void 0 : R.l.forEach(T);
          }),
            l.clear(),
            u.forEach(T),
            u.clear(),
            d.forEach(T),
            d.clear(),
            I.forEach(z),
            l.size && _();
        } while (l.size || u.size || d.size);
        if (C.length) throw C[0];
      },
      p = (M, C, z) => {
        const I = 'v' in C,
          T = C.v,
          P = Mm(C.v) ? C.v : null;
        if (Pm(z)) {
          J5(z);
          for (const R of C.d.keys()) tT(M, z, c(R));
          C.v = z;
        } else C.v = z;
        delete C.e, (!I || !Object.is(T, C.v)) && (++C.n, P && Q5(P, z));
      },
      y = (M) => {
        var C;
        const z = c(M);
        if (
          v_(z) &&
          ((z.m && s.get(M) !== z.n) || Array.from(z.d).every(([ie, he]) => y(ie).n === he))
        )
          return z;
        z.d.clear();
        let I = !0;
        const T = () => {
            z.m && (O(M, z), _(), f());
          },
          P = (ie) => {
            if (__(M, ie)) {
              const Q = c(ie);
              if (!v_(Q))
                if (Cm(ie)) p(ie, Q, ie.init);
                else throw new Error('no atom init');
              return Zf(Q);
            }
            const he = y(ie);
            try {
              return Zf(he);
            } finally {
              X5(M, z, ie, he), I || T();
            }
          };
        let R, L;
        const H = {
          get signal() {
            return R || (R = new AbortController()), R.signal;
          },
          get setSelf() {
            return (
              (si ? 'production' : void 0) !== 'production' &&
                !Ky(M) &&
                console.warn('setSelf function cannot be used with read-only atom'),
              !L &&
                Ky(M) &&
                (L = (...ie) => {
                  if (
                    ((si ? 'production' : void 0) !== 'production' &&
                      I &&
                      console.warn('setSelf function cannot be called in sync'),
                    !I)
                  )
                    return E(M, ...ie);
                }),
              L
            );
          },
        };
        try {
          const ie = r(M, P, H);
          return (
            p(M, z, ie),
            Pm(ie) &&
              ((C = ie.onCancel) == null || C.call(ie, () => (R == null ? void 0 : R.abort())),
              ie.then(T, T)),
            z
          );
        } catch (ie) {
          return delete z.v, (z.e = ie), ++z.n, z;
        } finally {
          I = !1;
        }
      },
      b = (M) => Zf(y(M)),
      m = (M) => {
        var C;
        const z = new Map();
        for (const I of ((C = M.m) == null ? void 0 : C.t) || []) {
          const T = c(I);
          T.m && z.set(I, T);
        }
        for (const I of M.p) z.set(I, c(I));
        return z;
      },
      w = (M) => {
        const C = [M];
        for (; C.length; ) {
          const z = C.pop();
          for (const [I, T] of m(z)) s.has(I) || (s.set(I, T.n), C.push(T));
        }
      },
      _ = () => {
        var M;
        const C = [],
          z = new WeakSet(),
          I = new WeakSet(),
          T = Array.from(l);
        for (; T.length; ) {
          const [P, R] = T[T.length - 1];
          if (I.has(P)) {
            T.pop();
            continue;
          }
          if (z.has(P)) {
            s.get(P) === R.n ? C.push([P, R, R.n]) : (s.delete(P), l.set(P, R)), I.add(P), T.pop();
            continue;
          }
          z.add(P);
          for (const [L, H] of m(R)) z.has(L) || T.push([L, H]);
        }
        for (let P = C.length - 1; P >= 0; --P) {
          const [R, L, H] = C[P];
          let ie = !1;
          for (const he of L.d.keys())
            if (he !== R && l.has(he)) {
              ie = !0;
              break;
            }
          ie && (y(R), O(R, L), H !== L.n && (l.set(R, L), (M = L.u) == null || M.call(L))),
            s.delete(R);
        }
      },
      S = (M, ...C) => {
        let z = !0;
        const I = (P) => Zf(y(P)),
          T = (P, ...R) => {
            var L;
            const H = c(P);
            try {
              if (__(M, P)) {
                if (!Cm(P)) throw new Error('atom not writable');
                const ie = H.n,
                  he = R[0];
                p(P, H, he),
                  O(P, H),
                  ie !== H.n && (l.set(P, H), (L = H.u) == null || L.call(H), w(H));
                return;
              } else return S(P, ...R);
            } finally {
              z || (_(), f());
            }
          };
        try {
          return i(M, I, T, ...C);
        } finally {
          z = !1;
        }
      },
      E = (M, ...C) => {
        try {
          return S(M, ...C);
        } finally {
          _(), f();
        }
      },
      O = (M, C) => {
        var z;
        if (C.m && !Mm(C.v)) {
          for (const [I, T] of C.d)
            if (!C.m.d.has(I)) {
              const P = c(I);
              N(I, P).t.add(M),
                C.m.d.add(I),
                T !== P.n && (l.set(I, P), (z = P.u) == null || z.call(P), w(P));
            }
          for (const I of C.m.d || [])
            if (!C.d.has(I)) {
              C.m.d.delete(I);
              const T = F(I, c(I));
              T == null || T.t.delete(M);
            }
        }
      },
      N = (M, C) => {
        var z;
        if (!C.m) {
          y(M);
          for (const I of C.d.keys()) N(I, c(I)).t.add(M);
          if (
            ((C.m = { l: new Set(), d: new Set(C.d.keys()), t: new Set() }),
            (z = C.h) == null || z.call(C),
            Ky(M))
          ) {
            const I = C.m,
              T = () => {
                let P = !0;
                const R = (...L) => {
                  try {
                    return S(M, ...L);
                  } finally {
                    P || (_(), f());
                  }
                };
                try {
                  const L = a(M, R);
                  L &&
                    (I.u = () => {
                      P = !0;
                      try {
                        L();
                      } finally {
                        P = !1;
                      }
                    });
                } finally {
                  P = !1;
                }
              };
            d.add(T);
          }
        }
        return C.m;
      },
      F = (M, C) => {
        var z;
        if (
          C.m &&
          !C.m.l.size &&
          !Array.from(C.m.t).some((I) => {
            var T;
            return (T = c(I).m) == null ? void 0 : T.d.has(M);
          })
        ) {
          const I = C.m.u;
          I && u.add(I), delete C.m, (z = C.h) == null || z.call(C);
          for (const T of C.d.keys()) {
            const P = F(T, c(T));
            P == null || P.t.delete(M);
          }
          return;
        }
        return C.m;
      },
      K = {
        get: b,
        set: E,
        sub: (M, C) => {
          const z = c(M),
            T = N(M, z).l;
          return (
            T.add(C),
            f(),
            () => {
              T.delete(C), F(M, z), f();
            }
          );
        },
        unstable_derive: (M) => nT(...M(...e)),
      };
    return K;
  },
  t7 = (e) => {
    const t = new Set();
    let n,
      r = 0;
    const i = e.unstable_derive((...c) => {
        const [s, l, , u] = c;
        return (
          (n = s),
          (c[1] = function (f, p) {
            l(f, p);
            const y = p.h;
            p.h = () => {
              y == null || y(), p.m ? t.add(f) : t.delete(f);
            };
          }),
          (c[3] = function (f, p, y, ...b) {
            return r ? y(f, ...b) : u(f, p, y, ...b);
          }),
          c
        );
      }),
      o = i.set;
    return Object.assign(i, {
      dev4_get_internal_weak_map: () => ({
        get: (c) => {
          const s = n(c);
          if (!(!s || s.n === 0)) return s;
        },
      }),
      dev4_get_mounted_atoms: () => t,
      dev4_restore_atoms: (c) => {
        o({
          read: () => null,
          write: (l, u) => {
            ++r;
            try {
              for (const [d, f] of c) Cm(d) && u(d, f);
            } finally {
              --r;
            }
          },
        });
      },
    });
  },
  n7 = () => {
    const e = new WeakMap(),
      t = nT(
        (n) => e.get(n),
        (n, r) => e.set(n, r).get(n),
        (n, ...r) => n.read(...r),
        (n, ...r) => n.write(...r),
        (n, ...r) => {
          var i;
          return (i = n.unstable_onInit) == null ? void 0 : i.call(n, ...r);
        },
        (n, ...r) => {
          var i;
          return (i = n.onMount) == null ? void 0 : i.call(n, ...r);
        }
      );
    return (si ? 'production' : void 0) !== 'production' ? t7(t) : t;
  };
let js;
const r7 = () => (
    js ||
      ((js = n7()),
      (si ? 'production' : void 0) !== 'production' &&
        (globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = js),
        globalThis.__JOTAI_DEFAULT_STORE__ !== js &&
          console.warn(
            'Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044'
          ))),
    js
  ),
  rT = {
    BASE_URL: '/',
    DEV: !1,
    MODE: 'production',
    PROD: !0,
    SSR: !1,
    VITE_DATADOG_CLIENT_TOKEN: 'pubf4dfb4e9016d7a11cef2cab4d41ee6ef',
    VITE_DEPLOY_ENVIRONMENT: 'production',
    VITE_RUDDERSTACK_KEY_BROWSER_EMBEDDED: 'cc94b84a-50e8-4aae-8296-ac417de90524',
  },
  i7 = G.createContext(void 0),
  iT = (e) => {
    const t = G.useContext(i7);
    return (e == null ? void 0 : e.store) || t || r7();
  },
  Om = (e) => typeof (e == null ? void 0 : e.then) == 'function',
  oT = (e) => {
    (e.status = 'pending'),
      e.then(
        (t) => {
          (e.status = 'fulfilled'), (e.value = t);
        },
        (t) => {
          (e.status = 'rejected'), (e.reason = t);
        }
      );
  },
  o7 =
    Ue.use ||
    ((e) => {
      if (e.status === 'pending') throw e;
      if (e.status === 'fulfilled') return e.value;
      throw e.status === 'rejected' ? e.reason : (oT(e), e);
    }),
  Hy = new WeakMap(),
  S_ = (e) => {
    let t = Hy.get(e);
    return (
      t ||
        ((t = new Promise((n, r) => {
          let i = e;
          const o = (s) => (l) => {
              i === s && n(l);
            },
            a = (s) => (l) => {
              i === s && r(l);
            },
            c = (s) => {
              'onCancel' in s &&
                typeof s.onCancel == 'function' &&
                s.onCancel((l) => {
                  if ((rT ? 'production' : void 0) !== 'production' && l === s)
                    throw new Error('[Bug] p is not updated even after cancelation');
                  Om(l) ? (Hy.set(l, t), (i = l), l.then(o(l), a(l)), c(l)) : n(l);
                });
            };
          e.then(o(e), a(e)), c(e);
        })),
        Hy.set(e, t)),
      t
    );
  };
function a7(e, t) {
  const n = iT(t),
    [[r, i, o], a] = G.useReducer(
      (l) => {
        const u = n.get(e);
        return Object.is(l[0], u) && l[1] === n && l[2] === e ? l : [u, n, e];
      },
      void 0,
      () => [n.get(e), n, e]
    );
  let c = r;
  (i !== n || o !== e) && (a(), (c = n.get(e)));
  const s = t == null ? void 0 : t.delay;
  if (
    (G.useEffect(() => {
      const l = n.sub(e, () => {
        if (typeof s == 'number') {
          const u = n.get(e);
          Om(u) && oT(S_(u)), setTimeout(a, s);
          return;
        }
        a();
      });
      return a(), l;
    }, [n, e, s]),
    G.useDebugValue(c),
    Om(c))
  ) {
    const l = S_(c);
    return o7(l);
  }
  return c;
}
function Dm(e, t) {
  const n = iT(t);
  return G.useCallback(
    (...i) => {
      if ((rT ? 'production' : void 0) !== 'production' && !('write' in e))
        throw new Error('not writable atom');
      return n.set(e, ...i);
    },
    [n, e]
  );
}
function Lue(e, t) {
  return [a7(e, t), Dm(e, t)];
}
const c1 = Je(null),
  aT = Je(null);
function s7({ children: e }) {
  const t = Dm(c1),
    n = Dm(aT),
    r = G.useRef(void 0),
    { data: i, isLoading: o } = ms();
  G.useEffect(() => {
    !o && i !== (r == null ? void 0 : r.current) && (t(i ?? null), (r.current = i));
  }, [i, o, t]);
  const a = so();
  return (
    G.useEffect(() => {
      a && n(a);
    }, [a, n]),
    e
  );
}
const c7 = G.memo(s7),
  u7 = '/currency_exchange/v1/rates',
  l7 = async () => {
    const e = await ke.api().get(`${u7}?from=USD&currencies=${Object.keys(Gh).join(',')}`);
    if (!hn(e)) throw new Error('Failed to fetch exchange rates');
    return await e.data;
  },
  d7 = ae({ hours: 2 }),
  f7 = (e) =>
    pt({
      queryKey: f3.currencyExchangeRates(),
      queryFn: l7,
      enabled: !!e,
      staleTime: d7,
      select(t) {
        return e ? (t == null ? void 0 : t.rates[e]) : 1;
      },
    });
h.enum(['ALWAYS_ASK', 'USE_PHANTOM', 'USE_METAMASK']);
h.boolean();
X.BitcoinNativeSegwit, X.BitcoinTaproot, X.BitcoinNestedSegwit, X.BitcoinLegacy;
const h7 = [
    'emojiSkinTone',
    'isAnalyticsOptedOut',
    'solanaActionsEnabled',
    'showWalletShortcuts',
    'selectedCurrency',
    'lockTimerMs',
    'reportedFeedTokens',
    'customGasControls',
    'dAppBrowserBookmarks',
    'RecentlyViewedSearchItems',
    'userRecentAddresses',
    'userSavedAddresses',
    'userTrustedApps',
    'userWhitelistedSubdomains',
    'userWhitelistedOrigins',
    'slippageTolerance',
    'priorityFee',
    'tipAmount',
    'lastSubmittedPairsV2',
    'lastSelectedTokens',
    'slippageSettings',
    'hasViewedAutoSlippageOptIn',
    'priorityFeeSettings',
    'tipSettings',
    'accountIdToHiddenMints',
    'accountIdToCollectibleVisibilitySettings',
  ],
  qy = (e, t) => `/user/v1/users/${e}/wallet-storage${t ? `/${encodeURIComponent(t)}` : ''}`,
  p7 = async (e, t) => {
    e &&
      typeof e == 'object' &&
      !Array.isArray(e) &&
      e !== null &&
      (Z.addBreadcrumb(te.Storage, `⏳ Synced data found in cloud: ${JSON.stringify(e)}`, Te.Debug),
      await Promise.all(
        Object.entries(e).map(([n, r]) => {
          if (h7.includes(n) && r) return t.set(n, r);
          Z.addBreadcrumb(te.Storage, `☣️ Incompatible Synced data found: ${n}`, Te.Debug);
        })
      )
        .then(() => {
          Z.addBreadcrumb(te.Storage, `✅ Synced data to disk: ${JSON.stringify(e)}`, Te.Debug);
        })
        .catch((n) => {
          Z.addBreadcrumb(
            te.Storage,
            `❌ Failed to sync data to disk => Data: ${JSON.stringify(e)} => Error: ${n}`,
            Te.Debug
          );
        }));
  };
var za, Fi, or, ln;
const Tp = class Tp {
  constructor(t) {
    _t(this, Fi, !1);
    _t(this, or);
    _t(this, ln, null);
    mt(this, or, t);
  }
  static getInstance(t) {
    return ue(this, za) || mt(this, za, new Tp(t)), ue(this, za);
  }
  initialize({ user: t, processor: n }) {
    (ue(this, Fi) && ue(this, ln) && ue(this, ln).userID === t.userID) ||
      (mt(this, ln, t), mt(this, Fi, !0), this.syncFromCloud({ processor: n }));
  }
  setUser(t) {
    mt(this, ln, t);
  }
  async syncFromCloud({ key: t, processor: n = p7 }) {
    if (!(!ue(this, Fi) || !ue(this, ln)))
      try {
        const r = qy(ue(this, ln).userID, t),
          i = await ke.api().bearer(ue(this, ln).accessToken).get(r);
        hn(i)
          ? await n(i.data, ue(this, or))
          : Z.addBreadcrumb(
              te.Storage,
              `❌ Failed to sync from cloud: ${JSON.stringify(i)}`,
              Te.Debug
            );
      } catch (r) {
        Z.addBreadcrumb(te.Storage, `❌ Failed to sync from cloud: ${JSON.stringify(r)}`, Te.Debug);
      }
  }
  async syncToCloud(t, n) {
    if (!(!ue(this, Fi) || !ue(this, ln)))
      try {
        const r = qy(ue(this, ln).userID, t),
          i = await ke.api().bearer(ue(this, ln).accessToken).put(r, { value: n });
        hn(i)
          ? Z.addBreadcrumb(
              te.Storage,
              `✅ Synced to cloud: ${t} => ${JSON.stringify(n)}`,
              Te.Debug
            )
          : Z.addBreadcrumb(
              te.Storage,
              `❌ Failed to sync to cloud: ${t} => ${JSON.stringify(n)} => Error: ${JSON.stringify(i)}`,
              Te.Debug
            );
      } catch (r) {
        Z.addBreadcrumb(te.Storage, `❌ Failed to sync to cloud: ${JSON.stringify(r)}`, Te.Debug);
      }
  }
  async get(t, n) {
    return await this.syncFromCloud({ key: t, processor: n }), ue(this, or).get(t);
  }
  async getAll(t, n) {
    return await this.syncFromCloud({ processor: n }), ue(this, or).getAll(t);
  }
  async remove(t) {
    if (Array.isArray(t))
      throw new Error(
        `[SyncedStorage.remove] Error removing keys (${t}): Batch removal not implemented`
      );
    if ((await ue(this, or).remove(t), !(!ue(this, Fi) || !ue(this, ln))))
      try {
        const n = qy(ue(this, ln).userID, t);
        await ke.api().bearer(ue(this, ln).accessToken).delete(n);
      } catch (n) {
        Z.addBreadcrumb(
          te.Storage,
          `❌ Failed to remove from cloud: ${JSON.stringify(n)}`,
          Te.Debug
        );
      }
  }
  async set(t, n) {
    await ue(this, or).set(t, n), await this.syncToCloud(t, n);
  }
  async setAll(t) {
    throw new Error(
      `[SyncedStorage.setAll] Error setting keys(s) (${Object.keys(t)}): Method not implemented`
    );
  }
  subscribe(t) {
    return ue(this, or).subscribe(t);
  }
  async update(t, n) {
    await ue(this, or).update(t, n);
    const r = await this.get(t);
    await this.syncToCloud(t, r);
  }
};
(za = new WeakMap()), (Fi = new WeakMap()), (or = new WeakMap()), (ln = new WeakMap()), _t(Tp, za);
let Rm = Tp;
const g7 = u2(null);
function y7() {
  const e = Ww(g7),
    t = Ww(oI);
  if (!t)
    throw new Error(
      'useSyncedStorage must be used within a ContextProvider with StorageContext set'
    );
  return e || t;
}
const A_ = new WeakMap(),
  b7 = () => {
    const e = d2(),
      t = y7();
    if (t instanceof Rm) {
      let n = A_.get(t);
      return n === void 0 && ((n = new f2(t)), A_.set(t, n)), n;
    }
    return e;
  },
  m7 = l2((e) => b7().get(e)),
  w7 = Gh.USD.value,
  _7 = () => {
    const { value: e, ...t } = m7(V0.SelectedCurrency),
      n = e ?? w7;
    return { ...t, result: n, data: n };
  },
  sT = G.createContext(null),
  v7 = ({ children: e }) => {
    const { data: t } = _7(),
      { data: n, isLoading: r } = f7(t),
      i = t && n ? Gh[t].languageCode : Ty.languageCode,
      o = t || Ty.value,
      a = t && n ? Gh[t].symbol : Ty.symbol,
      c = G.useCallback(
        (d, f) => Intl.NumberFormat(i, { style: 'currency', currency: o, ...f }).format(d),
        [o, i]
      ),
      s = G.useCallback((d) => (!t || !n ? Number(d) : oe(d).div(oe(n)).toNumber()), [t, n]),
      l = G.useCallback(
        (d, f) => {
          if (!t || !n) return Number(d);
          const p = oe(d).times(oe(n));
          return f === void 0 ? p.toNumber() : p.decimalPlaces(f).toNumber();
        },
        [t, n]
      ),
      u = {
        isLoading: r,
        currencyLocale: i,
        currencySymbol: a,
        currencyCode: o,
        toUsd: s,
        fromUsd: l,
        formatLocalizedPrice: c,
      };
    return A.jsx(sT.Provider, { value: u, children: e });
  },
  zue = () => {
    const e = G.useContext(sT);
    if (!e) throw new Error('useLocalizedCurrency must be used within a LocalizedCurrencyProvider');
    return e;
  },
  S7 = zn.getInstance();
h.object({
  width: h.string(),
  maxWidth: h.string(),
  height: h.string(),
  maxHeight: h.string(),
  position: h.string().optional(),
  transform: h.string().optional(),
  top: h.string().optional(),
  left: h.string().optional(),
  bottom: h.string().optional(),
  right: h.string().optional(),
  zIndex: h.string().optional(),
});
const u1 = 'RESIZE_DONE',
  A7 = 'GET_ORIGIN_MESSAGE',
  I7 = 'PROVIDE_ORIGIN_MESSAGE',
  E7 = () =>
    new Promise((e) => {
      window.addEventListener('message', function t(n) {
        n.data === I7 && (e(n.origin), window.removeEventListener('message', t));
      }),
        window.parent.postMessage(A7, '*');
    }),
  cT = G.createContext(null);
function T7({ children: e }) {
  const [t, n] = G.useState(void 0);
  return (
    G.useEffect(() => {
      (async () => {
        const i = await E7();
        n(i);
      })();
    }, []),
    t ? A.jsx(cT.Provider, { value: { dappURL: t }, children: e }) : null
  );
}
function uT() {
  const e = G.useContext(cT);
  if (!e) throw new Error('useDappConfig must be used within an DappConfigProvider');
  return e;
}
const k7 = ({ children: e }) => {
    const { dappURL: t } = uT();
    return (
      G.useEffect(() => {
        t && dn.addUserProperties({ embeddedDappOrigin: t });
      }, [t]),
      A.jsx(BR, { analytics: dn, children: e })
    );
  },
  C7 = ['t', 'y', '1', 'true', 'yes'];
function M7(e) {
  return !!e && C7.includes(e);
}
var Ia = ((e) => (
  (e.bottomRight = 'bottom-right'),
  (e.bottomLeft = 'bottom-left'),
  (e.topRight = 'top-right'),
  (e.topLeft = 'top-left'),
  e
))(Ia || {});
function P7(e) {
  return e.get('element')
    ? {
        renderMode: 'full-mode',
        colorScheme: e.get('colorScheme') ?? 'normal',
        initialState: e.get('initialState') ?? 'closed',
      }
    : {
        renderMode: 'button',
        hideLauncherBeforeOnboarded: M7(e.get('hideLauncherBeforeOnboarded') ?? 'false'),
        colorScheme: e.get('colorScheme') ?? 'normal',
        paddingBottom: e.get('paddingBottom') ? parseInt(e.get('paddingBottom')) : void 0,
        paddingRight: e.get('paddingRight') ? parseInt(e.get('paddingRight')) : void 0,
        paddingTop: e.get('paddingTop') ? parseInt(e.get('paddingTop')) : void 0,
        paddingLeft: e.get('paddingLeft') ? parseInt(e.get('paddingLeft')) : void 0,
        position: Object.values(Ia).includes(e.get('position'))
          ? e.get('position')
          : 'bottom-right',
        clientWidth: e.get('clientWidth') ?? void 0,
        clientHeight: e.get('clientHeight') ?? void 0,
        zIndex: e.get('zIndex') ?? '10000',
        initialState: e.get('initialState') ?? 'closed',
      };
}
const Qe = P7(new URL(window.location.href).searchParams);
var mn = ((e) => (
  (e.NAN = 'NAN'),
  (e.DATE = 'DATE'),
  (e.UINT8ARRAY = 'UINT8ARRAY'),
  (e.BIGINT = 'BIGINT'),
  (e.URL = 'URL'),
  e
))(mn || {});
const O7 = {
    canSerialize: (e) => typeof e == 'number' && Number.isNaN(e),
    serialize: (e) => ({ ['$' + mn.NAN]: 1 }),
    deserialize: (e) => NaN,
  },
  D7 = {
    canSerialize: (e) => e instanceof Date,
    serialize: (e) => ({ [`$${mn.DATE}`]: e.valueOf() }),
    deserialize: (e) => new Date(e[`$${mn.DATE}`]),
  },
  R7 = {
    canSerialize: (e) => e instanceof Uint8Array,
    serialize: (e) => ({ [`$${mn.UINT8ARRAY}`]: Array.from(e) }),
    deserialize: (e) => Uint8Array.from(e[`$${mn.UINT8ARRAY}`]),
  },
  x7 = {
    canSerialize: (e) => typeof e == 'bigint',
    serialize: (e) => ({ [`$${mn.BIGINT}`]: e.toString() }),
    deserialize: (e) => BigInt(e[`$${mn.BIGINT}`]),
  },
  B7 = {
    canSerialize: (e) => e instanceof URL,
    serialize: (e) => ({ [`$${mn.URL}`]: e.href }),
    deserialize: (e) => new URL(e[`$${mn.URL}`]),
  },
  xm = { [mn.NAN]: O7, [mn.DATE]: D7, [mn.UINT8ARRAY]: R7, [mn.BIGINT]: x7, [mn.URL]: B7 },
  j7 = function (e) {
    const t = this[e];
    for (const n of Object.values(xm)) if (n.canSerialize(t)) return n.serialize(t);
    return t;
  },
  N7 = (e, t) => {
    if (t && typeof t == 'object' && Object.keys(t)[0]) {
      const n = Object.keys(t)[0].slice(1);
      if (n in xm) return xm[n].deserialize(t);
    }
    return t;
  },
  lT = (e) => JSON.stringify(e, j7),
  l1 = (e) => JSON.parse(e, N7),
  Jt = [];
for (let e = 0; e < 256; ++e) Jt.push((e + 256).toString(16).slice(1));
function U7(e, t = 0) {
  return (
    Jt[e[t + 0]] +
    Jt[e[t + 1]] +
    Jt[e[t + 2]] +
    Jt[e[t + 3]] +
    '-' +
    Jt[e[t + 4]] +
    Jt[e[t + 5]] +
    '-' +
    Jt[e[t + 6]] +
    Jt[e[t + 7]] +
    '-' +
    Jt[e[t + 8]] +
    Jt[e[t + 9]] +
    '-' +
    Jt[e[t + 10]] +
    Jt[e[t + 11]] +
    Jt[e[t + 12]] +
    Jt[e[t + 13]] +
    Jt[e[t + 14]] +
    Jt[e[t + 15]]
  ).toLowerCase();
}
let Gy;
const L7 = new Uint8Array(16);
function z7() {
  if (!Gy) {
    if (typeof crypto > 'u' || !crypto.getRandomValues)
      throw new Error(
        'crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported'
      );
    Gy = crypto.getRandomValues.bind(crypto);
  }
  return Gy(L7);
}
const F7 = typeof crypto < 'u' && crypto.randomUUID && crypto.randomUUID.bind(crypto),
  I_ = { randomUUID: F7 };
function $7(e, t, n) {
  var i;
  if (I_.randomUUID && !t && !e) return I_.randomUUID();
  e = e || {};
  const r = e.random ?? ((i = e.rng) == null ? void 0 : i.call(e)) ?? z7();
  if (r.length < 16) throw new Error('Random bytes length must be >= 16');
  if (((r[6] = (r[6] & 15) | 64), (r[8] = (r[8] & 63) | 128), t)) {
    if (((n = n || 0), n < 0 || n + 16 > t.length))
      throw new RangeError(`UUID byte range ${n}:${n + 15} is out of buffer bounds`);
    for (let o = 0; o < 16; ++o) t[n + o] = r[o];
    return t;
  }
  return U7(r);
}
var bc, mc, Ro, xo, Fa;
class W7 {
  constructor(t, n, r) {
    _t(this, bc);
    _t(this, mc);
    _t(this, Ro, []);
    _t(this, xo, []);
    _t(this, Fa);
    mt(this, bc, t), mt(this, mc, n);
    const i = r ?? new RegExp(`^${n}$`);
    mt(this, Fa, (o) => {
      if (i.test(o.origin))
        try {
          const a = l1(o.data);
          'jsonrpc' in a && a.jsonrpc === '2.0' && ue(this, Ro).forEach((c) => c(a));
        } catch {}
    });
  }
  async start() {
    return window.addEventListener('message', ue(this, Fa)), Promise.resolve();
  }
  async close() {
    return (
      window.removeEventListener('message', ue(this, Fa)),
      ue(this, xo).forEach((t) => t()),
      Promise.resolve()
    );
  }
  postMessage(t) {
    ue(this, bc).call(this).postMessage(lT(t), ue(this, mc));
  }
  onMessage(t) {
    return (
      ue(this, Ro).push(t),
      () => {
        mt(
          this,
          Ro,
          ue(this, Ro).filter((n) => n !== t)
        );
      }
    );
  }
  onClose(t) {
    return (
      ue(this, xo).push(t),
      () => {
        mt(
          this,
          xo,
          ue(this, xo).filter((n) => n !== t)
        );
      }
    );
  }
}
(bc = new WeakMap()),
  (mc = new WeakMap()),
  (Ro = new WeakMap()),
  (xo = new WeakMap()),
  (Fa = new WeakMap());
function Qf() {
  let e, t;
  return {
    promise: new Promise((r, i) => {
      (e = r), (t = i);
    }),
    resolve: e,
    reject: t,
  };
}
var $i, Bo, wc, Wi, $a, kp;
class V7 {
  constructor(t, n) {
    _t(this, $i);
    _t(this, Bo, Qf());
    _t(this, wc, Qf());
    _t(this, Wi, null);
    _t(this, $a, new Map());
    _t(this, kp, (t) => {
      var r, i;
      if (t.id === null && 'result' in t) {
        switch (t.result) {
          case 'ready':
            ue(this, Bo).resolve();
            break;
          case 'authorized':
            (r = ue(this, Wi)) == null || r.resolve(t),
              mt(this, Wi, null),
              ue(this, Bo).resolve(),
              ue(this, wc).resolve();
            break;
          case 'authorization-failed':
            (i = ue(this, Wi)) == null ||
              i.resolve({
                jsonrpc: '2.0',
                id: null,
                error: { code: h2.Unauthorized, message: 'Authorization failed.' },
              }),
              mt(this, Wi, null);
            break;
        }
        return;
      }
      if (!t.id) {
        console.warn('Phantom: Received response without id, response: ' + JSON.stringify(t));
        return;
      }
      const n = ue(this, $a).get(t.id);
      n && (ue(this, $a).delete(t.id), n.resolve(t));
    });
    mt(this, $i, new W7(t, n)), ue(this, $i).onMessage(ue(this, kp));
  }
  async start() {
    await ue(this, $i).start();
  }
  async close() {
    await ue(this, $i).close();
  }
  async send(t) {
    const n = Qf(),
      r = t.id ?? $7();
    return (
      await ue(this, Bo).promise,
      t.method === 'authorizeSigner'
        ? (mt(this, Wi, n), mt(this, Bo, Qf()))
        : (await ue(this, wc).promise, ue(this, $a).set(r, n)),
      ue(this, $i).postMessage({ id: r, jsonrpc: '2.0', ...t }),
      n.promise
    );
  }
}
($i = new WeakMap()),
  (Bo = new WeakMap()),
  (wc = new WeakMap()),
  (Wi = new WeakMap()),
  ($a = new WeakMap()),
  (kp = new WeakMap());
const dT = G.createContext(null),
  fT = () => {
    const e = G.useContext(dT);
    if (!e) throw new Error('JsonRpcSender not provided');
    return e;
  },
  K7 = (e) => A.jsx(dT.Provider, { value: e.sender, children: e.children }),
  hT = G.createContext(null),
  Fue = () => {
    const e = G.useContext(hT);
    if (!e) throw new Error('Signer IFrame not provided');
    return e;
  },
  H7 = (e) => A.jsx(hT.Provider, { value: e.signerIFrameRef, children: e.children });
var Ga = ((e) => (
  (e.authorizeSigner = 'authorizeSigner'),
  (e.fetchAllAccounts = 'fetchAllAccounts'),
  (e.checkVaultIntegrity = 'checkVaultIntegrity'),
  (e.sign = 'sign'),
  (e.logOut = 'logOut'),
  (e.recoverAccount = 'recoverAccount'),
  (e.userApprove = 'userApprove'),
  (e.abort = 'abort'),
  e
))(Ga || {});
h.nativeEnum(Ga);
G.createContext(null);
const $ue = () => {
    const e = fT();
    return G.useCallback(async (t) => e.send({ ...t }), [e]);
  },
  pT = 'signerFrame',
  Mh = new V7(() => document.getElementById(pT).contentWindow, new URL(Zp).origin),
  q7 = ({ children: e }) => {
    G.useEffect(
      () => (
        Mh.start(),
        () => {
          Mh.close();
        }
      ),
      []
    );
    const { dappURL: t } = uT(),
      n = new URL(Zp);
    n.searchParams.set('dappURL', t);
    const r = Ue.useRef(null);
    return A.jsxs(A.Fragment, {
      children: [
        A.jsx('iframe', {
          ref: r,
          src: n.toString(),
          frameBorder: 0,
          id: pT,
          className: ft({ position: 'absolute', top: 0, left: 0, height: 1, width: 1 }),
        }),
        A.jsx(H7, { signerIFrameRef: r, children: A.jsx(K7, { sender: Mh, children: e }) }),
      ],
    });
  };
async function G7(e) {
  return window.navigator.locks.request('vault-sign-lock', e);
}
const Y7 = async (e, t, n) =>
    G7(async () => {
      const r = await e.send({
        method: Ga.sign,
        params: [{ accountIdentifier: t, vaultSignerParams: n }],
      });
      return 'result' in r
        ? Ax.parse(r.result)
        : { status: 'error', type: Kt.InternalError, message: r.error.message };
    }),
  Dn = (e) => () => {
    throw new Error(`${e} not implemented on Embedded VaultProxy`);
  },
  Z7 = (e) => ({
    addAccountForSeed: Dn('addAccountForSeed'),
    addAccountForSeedless: Dn('addAccountForSeedless'),
    addReadonlyAccount: Dn('addReadonlyAccount'),
    connectLedgerAccounts: Dn('connectLedgerAccounts'),
    connectSolanaSeedVaultAccounts: Dn('connectSolanaSeedVaultAccounts'),
    deriveAddresses: Dn('deriveAddresses'),
    async fetchAllAccounts() {
      if (!(await qa.getUser())) return [];
      const n = await e.send({ method: Ga.fetchAllAccounts, params: [] });
      if ('error' in n) throw new Error(n.error.message);
      return n.result;
    },
    async fetchAllSeedMetas() {
      return Promise.resolve([]);
    },
    async fetchAllSeedlessMetas() {
      return Promise.resolve([]);
    },
    getAuthenticationPublicKey: Dn('getAuthenticationPublicKey'),
    importPrivateKeyAccount: Dn('importPrivateKeyAccount'),
    removeAccount: Dn('removeAccount'),
    reorderAccount: Dn('reorderAccount'),
    sign: (t, n) => Y7(e, t, n),
    syncAccounts: Dn('syncAccounts'),
    checkVaultIntegrity: async () => {
      if (!(await qa.getUser()))
        return { status: 'unonboarded', isOnboarded: !1, reonboardingNeeded: !1 };
      const n = await e.send({ method: Ga.checkVaultIntegrity, params: [] });
      if ('error' in n) throw new Error(n.error.message);
      return n.result;
    },
    getCashAddress: Dn('getCashAddress'),
    getAgentAddress: Dn('getAgentAddress'),
  }),
  Xn = Z7(Mh);
function gT({ children: e }) {
  return A.jsx(O5, { vault: Xn, children: e });
}
const Q7 = async () => {
  const e = [...p2, 'enable-monad'],
    t = [];
  t.push(new g2(e)), Un.setProviders(t), await Un.initializeFeatureFlags();
};
function J7() {
  h3 && document.documentElement.classList.add('mac-scrollbar');
}
const X7 = {
  init: async () => {},
  downloadLog: async (e) => {},
  getRecentLogs: async () => Promise.resolve(''),
  write: (e, t, n, r) => {},
  getLogFilePaths: () => {
    throw new Error(Vw);
  },
  sendLogFilesByEmail: (e) => {
    throw new Error(Vw);
  },
};
async function ej() {
  await y2.init({ provider: X7 }),
    await Z.init({
      appVersion: vc,
      sentry: { enabled: !1 },
      datadog: {
        enabled: !0,
        clientToken: 'pubf4dfb4e9016d7a11cef2cab4d41ee6ef',
        applicationId: '15db1fc2-d5c5-4a30-b635-cbfa642030c0',
        service: 'embedded-web',
        traceSampleRate: 100,
        sessionSampleRate: 100,
      },
    });
}
var Gt = ((e) => ((e.Open = 'Open'), (e.Closed = 'Closed'), (e.Reset = 'Reset'), e))(Gt || {}),
  E_ = { exports: {} };
(function (e, t) {
  var n = typeof globalThis < 'u' ? globalThis : g,
    r = (function () {
      function o() {
        (this.fetch = !1), (this.DOMException = n.DOMException);
      }
      return (o.prototype = n), new o();
    })();
  (function (o) {
    (function (a) {
      var c = {
        searchParams: 'URLSearchParams' in o,
        iterable: 'Symbol' in o && 'iterator' in Symbol,
        blob:
          'FileReader' in o &&
          'Blob' in o &&
          (function () {
            try {
              return new Blob(), !0;
            } catch {
              return !1;
            }
          })(),
        formData: 'FormData' in o,
        arrayBuffer: 'ArrayBuffer' in o,
      };
      function s(I) {
        return I && DataView.prototype.isPrototypeOf(I);
      }
      if (c.arrayBuffer)
        var l = [
            '[object Int8Array]',
            '[object Uint8Array]',
            '[object Uint8ClampedArray]',
            '[object Int16Array]',
            '[object Uint16Array]',
            '[object Int32Array]',
            '[object Uint32Array]',
            '[object Float32Array]',
            '[object Float64Array]',
          ],
          u =
            ArrayBuffer.isView ||
            function (I) {
              return I && l.indexOf(Object.prototype.toString.call(I)) > -1;
            };
      function d(I) {
        if ((typeof I != 'string' && (I = String(I)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(I)))
          throw new TypeError('Invalid character in header field name');
        return I.toLowerCase();
      }
      function f(I) {
        return typeof I != 'string' && (I = String(I)), I;
      }
      function p(I) {
        var T = {
          next: function () {
            var P = I.shift();
            return { done: P === void 0, value: P };
          },
        };
        return (
          c.iterable &&
            (T[Symbol.iterator] = function () {
              return T;
            }),
          T
        );
      }
      function y(I) {
        (this.map = {}),
          I instanceof y
            ? I.forEach(function (T, P) {
                this.append(P, T);
              }, this)
            : Array.isArray(I)
              ? I.forEach(function (T) {
                  this.append(T[0], T[1]);
                }, this)
              : I &&
                Object.getOwnPropertyNames(I).forEach(function (T) {
                  this.append(T, I[T]);
                }, this);
      }
      (y.prototype.append = function (I, T) {
        (I = d(I)), (T = f(T));
        var P = this.map[I];
        this.map[I] = P ? P + ', ' + T : T;
      }),
        (y.prototype.delete = function (I) {
          delete this.map[d(I)];
        }),
        (y.prototype.get = function (I) {
          return (I = d(I)), this.has(I) ? this.map[I] : null;
        }),
        (y.prototype.has = function (I) {
          return this.map.hasOwnProperty(d(I));
        }),
        (y.prototype.set = function (I, T) {
          this.map[d(I)] = f(T);
        }),
        (y.prototype.forEach = function (I, T) {
          for (var P in this.map) this.map.hasOwnProperty(P) && I.call(T, this.map[P], P, this);
        }),
        (y.prototype.keys = function () {
          var I = [];
          return (
            this.forEach(function (T, P) {
              I.push(P);
            }),
            p(I)
          );
        }),
        (y.prototype.values = function () {
          var I = [];
          return (
            this.forEach(function (T) {
              I.push(T);
            }),
            p(I)
          );
        }),
        (y.prototype.entries = function () {
          var I = [];
          return (
            this.forEach(function (T, P) {
              I.push([P, T]);
            }),
            p(I)
          );
        }),
        c.iterable && (y.prototype[Symbol.iterator] = y.prototype.entries);
      function b(I) {
        if (I.bodyUsed) return Promise.reject(new TypeError('Already read'));
        I.bodyUsed = !0;
      }
      function m(I) {
        return new Promise(function (T, P) {
          (I.onload = function () {
            T(I.result);
          }),
            (I.onerror = function () {
              P(I.error);
            });
        });
      }
      function w(I) {
        var T = new FileReader(),
          P = m(T);
        return T.readAsArrayBuffer(I), P;
      }
      function _(I) {
        var T = new FileReader(),
          P = m(T);
        return T.readAsText(I), P;
      }
      function S(I) {
        for (var T = new Uint8Array(I), P = new Array(T.length), R = 0; R < T.length; R++)
          P[R] = String.fromCharCode(T[R]);
        return P.join('');
      }
      function E(I) {
        if (I.slice) return I.slice(0);
        var T = new Uint8Array(I.byteLength);
        return T.set(new Uint8Array(I)), T.buffer;
      }
      function O() {
        return (
          (this.bodyUsed = !1),
          (this._initBody = function (I) {
            (this._bodyInit = I),
              I
                ? typeof I == 'string'
                  ? (this._bodyText = I)
                  : c.blob && Blob.prototype.isPrototypeOf(I)
                    ? (this._bodyBlob = I)
                    : c.formData && FormData.prototype.isPrototypeOf(I)
                      ? (this._bodyFormData = I)
                      : c.searchParams && URLSearchParams.prototype.isPrototypeOf(I)
                        ? (this._bodyText = I.toString())
                        : c.arrayBuffer && c.blob && s(I)
                          ? ((this._bodyArrayBuffer = E(I.buffer)),
                            (this._bodyInit = new Blob([this._bodyArrayBuffer])))
                          : c.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(I) || u(I))
                            ? (this._bodyArrayBuffer = E(I))
                            : (this._bodyText = I = Object.prototype.toString.call(I))
                : (this._bodyText = ''),
              this.headers.get('content-type') ||
                (typeof I == 'string'
                  ? this.headers.set('content-type', 'text/plain;charset=UTF-8')
                  : this._bodyBlob && this._bodyBlob.type
                    ? this.headers.set('content-type', this._bodyBlob.type)
                    : c.searchParams &&
                      URLSearchParams.prototype.isPrototypeOf(I) &&
                      this.headers.set(
                        'content-type',
                        'application/x-www-form-urlencoded;charset=UTF-8'
                      ));
          }),
          c.blob &&
            ((this.blob = function () {
              var I = b(this);
              if (I) return I;
              if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
              if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              if (this._bodyFormData) throw new Error('could not read FormData body as blob');
              return Promise.resolve(new Blob([this._bodyText]));
            }),
            (this.arrayBuffer = function () {
              return this._bodyArrayBuffer
                ? b(this) || Promise.resolve(this._bodyArrayBuffer)
                : this.blob().then(w);
            })),
          (this.text = function () {
            var I = b(this);
            if (I) return I;
            if (this._bodyBlob) return _(this._bodyBlob);
            if (this._bodyArrayBuffer) return Promise.resolve(S(this._bodyArrayBuffer));
            if (this._bodyFormData) throw new Error('could not read FormData body as text');
            return Promise.resolve(this._bodyText);
          }),
          c.formData &&
            (this.formData = function () {
              return this.text().then(k);
            }),
          (this.json = function () {
            return this.text().then(JSON.parse);
          }),
          this
        );
      }
      var N = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];
      function F(I) {
        var T = I.toUpperCase();
        return N.indexOf(T) > -1 ? T : I;
      }
      function D(I, T) {
        T = T || {};
        var P = T.body;
        if (I instanceof D) {
          if (I.bodyUsed) throw new TypeError('Already read');
          (this.url = I.url),
            (this.credentials = I.credentials),
            T.headers || (this.headers = new y(I.headers)),
            (this.method = I.method),
            (this.mode = I.mode),
            (this.signal = I.signal),
            !P && I._bodyInit != null && ((P = I._bodyInit), (I.bodyUsed = !0));
        } else this.url = String(I);
        if (
          ((this.credentials = T.credentials || this.credentials || 'same-origin'),
          (T.headers || !this.headers) && (this.headers = new y(T.headers)),
          (this.method = F(T.method || this.method || 'GET')),
          (this.mode = T.mode || this.mode || null),
          (this.signal = T.signal || this.signal),
          (this.referrer = null),
          (this.method === 'GET' || this.method === 'HEAD') && P)
        )
          throw new TypeError('Body not allowed for GET or HEAD requests');
        this._initBody(P);
      }
      D.prototype.clone = function () {
        return new D(this, { body: this._bodyInit });
      };
      function k(I) {
        var T = new FormData();
        return (
          I.trim()
            .split('&')
            .forEach(function (P) {
              if (P) {
                var R = P.split('='),
                  L = R.shift().replace(/\+/g, ' '),
                  H = R.join('=').replace(/\+/g, ' ');
                T.append(decodeURIComponent(L), decodeURIComponent(H));
              }
            }),
          T
        );
      }
      function K(I) {
        var T = new y(),
          P = I.replace(/\r?\n[\t ]+/g, ' ');
        return (
          P.split(/\r?\n/).forEach(function (R) {
            var L = R.split(':'),
              H = L.shift().trim();
            if (H) {
              var ie = L.join(':').trim();
              T.append(H, ie);
            }
          }),
          T
        );
      }
      O.call(D.prototype);
      function M(I, T) {
        T || (T = {}),
          (this.type = 'default'),
          (this.status = T.status === void 0 ? 200 : T.status),
          (this.ok = this.status >= 200 && this.status < 300),
          (this.statusText = 'statusText' in T ? T.statusText : 'OK'),
          (this.headers = new y(T.headers)),
          (this.url = T.url || ''),
          this._initBody(I);
      }
      O.call(M.prototype),
        (M.prototype.clone = function () {
          return new M(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new y(this.headers),
            url: this.url,
          });
        }),
        (M.error = function () {
          var I = new M(null, { status: 0, statusText: '' });
          return (I.type = 'error'), I;
        });
      var C = [301, 302, 303, 307, 308];
      (M.redirect = function (I, T) {
        if (C.indexOf(T) === -1) throw new RangeError('Invalid status code');
        return new M(null, { status: T, headers: { location: I } });
      }),
        (a.DOMException = o.DOMException);
      try {
        new a.DOMException();
      } catch {
        (a.DOMException = function (T, P) {
          (this.message = T), (this.name = P);
          var R = Error(T);
          this.stack = R.stack;
        }),
          (a.DOMException.prototype = Object.create(Error.prototype)),
          (a.DOMException.prototype.constructor = a.DOMException);
      }
      function z(I, T) {
        return new Promise(function (P, R) {
          var L = new D(I, T);
          if (L.signal && L.signal.aborted) return R(new a.DOMException('Aborted', 'AbortError'));
          var H = new XMLHttpRequest();
          function ie() {
            H.abort();
          }
          (H.onload = function () {
            var he = {
              status: H.status,
              statusText: H.statusText,
              headers: K(H.getAllResponseHeaders() || ''),
            };
            he.url = 'responseURL' in H ? H.responseURL : he.headers.get('X-Request-URL');
            var Q = 'response' in H ? H.response : H.responseText;
            P(new M(Q, he));
          }),
            (H.onerror = function () {
              R(new TypeError('Network request failed'));
            }),
            (H.ontimeout = function () {
              R(new TypeError('Network request failed'));
            }),
            (H.onabort = function () {
              R(new a.DOMException('Aborted', 'AbortError'));
            }),
            H.open(L.method, L.url, !0),
            L.credentials === 'include'
              ? (H.withCredentials = !0)
              : L.credentials === 'omit' && (H.withCredentials = !1),
            'responseType' in H && c.blob && (H.responseType = 'blob'),
            L.headers.forEach(function (he, Q) {
              H.setRequestHeader(Q, he);
            }),
            L.signal &&
              (L.signal.addEventListener('abort', ie),
              (H.onreadystatechange = function () {
                H.readyState === 4 && L.signal.removeEventListener('abort', ie);
              })),
            H.send(typeof L._bodyInit > 'u' ? null : L._bodyInit);
        });
      }
      return (
        (z.polyfill = !0),
        o.fetch || ((o.fetch = z), (o.Headers = y), (o.Request = D), (o.Response = M)),
        (a.Headers = y),
        (a.Request = D),
        (a.Response = M),
        (a.fetch = z),
        Object.defineProperty(a, '__esModule', { value: !0 }),
        a
      );
    })({});
  })(r),
    (r.fetch.ponyfill = !0),
    delete r.fetch.polyfill;
  var i = r;
  (t = i.fetch),
    (t.default = i.fetch),
    (t.fetch = i.fetch),
    (t.Headers = i.Headers),
    (t.Request = i.Request),
    (t.Response = i.Response),
    (e.exports = t);
})(E_, E_.exports);
var yT = { exports: {} };
(function () {
  var e = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
    t = {
      rotl: function (n, r) {
        return (n << r) | (n >>> (32 - r));
      },
      rotr: function (n, r) {
        return (n << (32 - r)) | (n >>> r);
      },
      endian: function (n) {
        if (n.constructor == Number)
          return (t.rotl(n, 8) & 16711935) | (t.rotl(n, 24) & 4278255360);
        for (var r = 0; r < n.length; r++) n[r] = t.endian(n[r]);
        return n;
      },
      randomBytes: function (n) {
        for (var r = []; n > 0; n--) r.push(Math.floor(Math.random() * 256));
        return r;
      },
      bytesToWords: function (n) {
        for (var r = [], i = 0, o = 0; i < n.length; i++, o += 8)
          r[o >>> 5] |= n[i] << (24 - (o % 32));
        return r;
      },
      wordsToBytes: function (n) {
        for (var r = [], i = 0; i < n.length * 32; i += 8)
          r.push((n[i >>> 5] >>> (24 - (i % 32))) & 255);
        return r;
      },
      bytesToHex: function (n) {
        for (var r = [], i = 0; i < n.length; i++)
          r.push((n[i] >>> 4).toString(16)), r.push((n[i] & 15).toString(16));
        return r.join('');
      },
      hexToBytes: function (n) {
        for (var r = [], i = 0; i < n.length; i += 2) r.push(parseInt(n.substr(i, 2), 16));
        return r;
      },
      bytesToBase64: function (n) {
        for (var r = [], i = 0; i < n.length; i += 3)
          for (var o = (n[i] << 16) | (n[i + 1] << 8) | n[i + 2], a = 0; a < 4; a++)
            i * 8 + a * 6 <= n.length * 8
              ? r.push(e.charAt((o >>> (6 * (3 - a))) & 63))
              : r.push('=');
        return r.join('');
      },
      base64ToBytes: function (n) {
        n = n.replace(/[^A-Z0-9+\/]/gi, '');
        for (var r = [], i = 0, o = 0; i < n.length; o = ++i % 4)
          o != 0 &&
            r.push(
              ((e.indexOf(n.charAt(i - 1)) & (Math.pow(2, -2 * o + 8) - 1)) << (o * 2)) |
                (e.indexOf(n.charAt(i)) >>> (6 - o * 2))
            );
        return r;
      },
    };
  yT.exports = t;
})();
var tj = yT.exports,
  Bm = {
    utf8: {
      stringToBytes: function (e) {
        return Bm.bin.stringToBytes(unescape(encodeURIComponent(e)));
      },
      bytesToString: function (e) {
        return decodeURIComponent(escape(Bm.bin.bytesToString(e)));
      },
    },
    bin: {
      stringToBytes: function (e) {
        for (var t = [], n = 0; n < e.length; n++) t.push(e.charCodeAt(n) & 255);
        return t;
      },
      bytesToString: function (e) {
        for (var t = [], n = 0; n < e.length; n++) t.push(String.fromCharCode(e[n]));
        return t.join('');
      },
    },
  },
  T_ = Bm;
(function () {
  var e = tj,
    t = T_.utf8,
    n = T_.bin,
    r = function (o) {
      o.constructor == String
        ? (o = t.stringToBytes(o))
        : typeof Y < 'u' && typeof Y.isBuffer == 'function' && Y.isBuffer(o)
          ? (o = Array.prototype.slice.call(o, 0))
          : Array.isArray(o) || (o = o.toString());
      var a = e.bytesToWords(o),
        c = o.length * 8,
        s = [],
        l = 1732584193,
        u = -271733879,
        d = -1732584194,
        f = 271733878,
        p = -1009589776;
      (a[c >> 5] |= 128 << (24 - (c % 32))), (a[(((c + 64) >>> 9) << 4) + 15] = c);
      for (var y = 0; y < a.length; y += 16) {
        for (var b = l, m = u, w = d, _ = f, S = p, E = 0; E < 80; E++) {
          if (E < 16) s[E] = a[y + E];
          else {
            var O = s[E - 3] ^ s[E - 8] ^ s[E - 14] ^ s[E - 16];
            s[E] = (O << 1) | (O >>> 31);
          }
          var N =
            ((l << 5) | (l >>> 27)) +
            p +
            (s[E] >>> 0) +
            (E < 20
              ? ((u & d) | (~u & f)) + 1518500249
              : E < 40
                ? (u ^ d ^ f) + 1859775393
                : E < 60
                  ? ((u & d) | (u & f) | (d & f)) - 1894007588
                  : (u ^ d ^ f) - 899497514);
          (p = f), (f = d), (d = (u << 30) | (u >>> 2)), (u = l), (l = N);
        }
        (l += b), (u += m), (d += w), (f += _), (p += S);
      }
      return [l, u, d, f, p];
    },
    i = function (o, a) {
      var c = e.wordsToBytes(r(o));
      return a && a.asBytes ? c : a && a.asString ? n.bytesToString(c) : e.bytesToHex(c);
    };
  (i._blocksize = 16), (i._digestsize = 20);
})();
var op = { exports: {} };
const ei = new Uint32Array(65536),
  nj = (e, t) => {
    const n = e.length,
      r = t.length,
      i = 1 << (n - 1);
    let o = -1,
      a = 0,
      c = n,
      s = n;
    for (; s--; ) ei[e.charCodeAt(s)] |= 1 << s;
    for (s = 0; s < r; s++) {
      let l = ei[t.charCodeAt(s)];
      const u = l | a;
      (l |= ((l & o) + o) ^ o),
        (a |= ~(l | o)),
        (o &= l),
        a & i && c++,
        o & i && c--,
        (a = (a << 1) | 1),
        (o = (o << 1) | ~(u | a)),
        (a &= u);
    }
    for (s = n; s--; ) ei[e.charCodeAt(s)] = 0;
    return c;
  },
  rj = (e, t) => {
    const n = t.length,
      r = e.length,
      i = [],
      o = [],
      a = Math.ceil(n / 32),
      c = Math.ceil(r / 32);
    for (let y = 0; y < a; y++) (o[y] = -1), (i[y] = 0);
    let s = 0;
    for (; s < c - 1; s++) {
      let y = 0,
        b = -1;
      const m = s * 32,
        w = Math.min(32, r) + m;
      for (let _ = m; _ < w; _++) ei[e.charCodeAt(_)] |= 1 << _;
      for (let _ = 0; _ < n; _++) {
        const S = ei[t.charCodeAt(_)],
          E = (o[(_ / 32) | 0] >>> _) & 1,
          O = (i[(_ / 32) | 0] >>> _) & 1,
          N = S | y,
          F = ((((S | O) & b) + b) ^ b) | S | O;
        let D = y | ~(F | b),
          k = b & F;
        (D >>> 31) ^ E && (o[(_ / 32) | 0] ^= 1 << _),
          (k >>> 31) ^ O && (i[(_ / 32) | 0] ^= 1 << _),
          (D = (D << 1) | E),
          (k = (k << 1) | O),
          (b = k | ~(N | D)),
          (y = D & N);
      }
      for (let _ = m; _ < w; _++) ei[e.charCodeAt(_)] = 0;
    }
    let l = 0,
      u = -1;
    const d = s * 32,
      f = Math.min(32, r - d) + d;
    for (let y = d; y < f; y++) ei[e.charCodeAt(y)] |= 1 << y;
    let p = r;
    for (let y = 0; y < n; y++) {
      const b = ei[t.charCodeAt(y)],
        m = (o[(y / 32) | 0] >>> y) & 1,
        w = (i[(y / 32) | 0] >>> y) & 1,
        _ = b | l,
        S = ((((b | w) & u) + u) ^ u) | b | w;
      let E = l | ~(S | u),
        O = u & S;
      (p += (E >>> (r - 1)) & 1),
        (p -= (O >>> (r - 1)) & 1),
        (E >>> 31) ^ m && (o[(y / 32) | 0] ^= 1 << y),
        (O >>> 31) ^ w && (i[(y / 32) | 0] ^= 1 << y),
        (E = (E << 1) | m),
        (O = (O << 1) | w),
        (u = O | ~(_ | E)),
        (l = E & _);
    }
    for (let y = d; y < f; y++) ei[e.charCodeAt(y)] = 0;
    return p;
  },
  bT = (e, t) => {
    if (e.length < t.length) {
      const n = t;
      (t = e), (e = n);
    }
    return t.length === 0 ? e.length : e.length <= 32 ? nj(e, t) : rj(e, t);
  },
  ij = (e, t) => {
    let n = 1 / 0,
      r = 0;
    for (let i = 0; i < t.length; i++) {
      const o = bT(e, t[i]);
      o < n && ((n = o), (r = i));
    }
    return t[r];
  },
  oj = Object.freeze(
    Object.defineProperty({ __proto__: null, closest: ij, distance: bT }, Symbol.toStringTag, {
      value: 'Module',
    })
  ),
  aj = AI(oj);
op.exports;
(function (e, t) {
  (function () {
    var n;
    try {
      n =
        typeof Intl < 'u' && typeof Intl.Collator < 'u'
          ? Intl.Collator('generic', { sensitivity: 'base' })
          : null;
    } catch {
      console.log("Collator could not be initialized and wouldn't be used");
    }
    var r = aj,
      i = [],
      o = [],
      a = {
        get: function (c, s, l) {
          var u = l && n && l.useCollator;
          if (u) {
            var d = c.length,
              f = s.length;
            if (d === 0) return f;
            if (f === 0) return d;
            var p, y, b, m, w;
            for (b = 0; b < f; ++b) (i[b] = b), (o[b] = s.charCodeAt(b));
            i[f] = f;
            var _;
            for (b = 0; b < d; ++b) {
              for (y = b + 1, m = 0; m < f; ++m)
                (p = y),
                  (_ = n.compare(c.charAt(b), String.fromCharCode(o[m])) === 0),
                  (y = i[m] + (_ ? 0 : 1)),
                  (w = p + 1),
                  y > w && (y = w),
                  (w = i[m + 1] + 1),
                  y > w && (y = w),
                  (i[m] = p);
              i[m] = y;
            }
            return y;
          }
          return r.distance(c, s);
        },
      };
    e !== null && e.exports === t
      ? (e.exports = a)
      : typeof globalThis < 'u' &&
          typeof globalThis.postMessage == 'function' &&
          typeof globalThis.importScripts == 'function'
        ? (globalThis.Levenshtein = a)
        : typeof window < 'u' && window !== null && (window.Levenshtein = a);
  })();
})(op, op.exports);
op.exports;
const Wue = (e = 3) => ({ retry: e, retryDelay: (t) => Math.min(1e3 * 2 ** t, 3e4) });
var d1 = ((e) => (
  (e[(e.info = 5)] = 'info'),
  (e[(e.error = 4)] = 'error'),
  (e[(e.criticalError = 3)] = 'criticalError'),
  (e[(e.alert = 2)] = 'alert'),
  (e[(e.criticalAlert = 1)] = 'criticalAlert'),
  e
))(d1 || {});
h.object({
  type: h.union([
    h.literal('all'),
    h.literal('blocklist'),
    h.literal('whitelist'),
    h.literal('error'),
    h.literal('fuzzy'),
    h.literal('blowfishBloomFilter'),
  ]),
  result: h.boolean(),
  source: h.optional(h.string()),
  match: h.string().optional(),
  isSubdomainDomainWhitelisted: h.boolean().optional(),
});
h.object({ localHash: h.any(), cursor: h.any() });
const jm = h.object({
  bitVector: h.string(),
  k: h.number(),
  hash: h.string(),
  bits: h.number(),
  salt: h.string(),
});
h.union([
  h.object({
    bloomFilter: jm,
    bloomFilterHash: h.string(),
    recentlyAdded: h.array(h.string()),
    recentlyRemoved: h.array(h.string()),
    nextCursor: h.string(),
  }),
  h.object({
    bloomFilter: jm.optional(),
    bloomFilterHash: h.optional(h.string()),
    recentlyAdded: h.array(h.string()),
    recentlyRemoved: h.array(h.string()),
    nextCursor: h.string(),
  }),
]);
h.object({ bloomFilter: jm, lastUpdated: h.number() }).nullish();
h.object({
  recentlyAdded: h.array(h.string()),
  recentlyRemoved: h.array(h.string()),
  lastUpdated: h.number().optional(),
}).nullish();
const Tt = '@phantom/transactions',
  lo = {
    customGasControls() {
      return [`${Tt}:custom-gas-controls`];
    },
    gasEstimation(e, t, n, r) {
      return [
        `${Tt}:gas-estimation`,
        { networkID: e, multichainTransaction: t, transactionSpeed: n, additionalCosts: r },
      ];
    },
    solanaGasEstimation(e) {
      return [`${Tt}:solana-gas-estimation`, e || {}];
    },
    solanaComputeUnitPrice(e) {
      return [`${Tt}:compute-unit-price`, e || {}];
    },
    gasEstimationPrice(e, t) {
      return [`${Tt}:gas-estimation-price`, e ? { networkID: e } : {}, t || {}];
    },
    gasEstimationTimeToMine(e, t, n) {
      return [
        `${Tt}:gas-estimation-time-to-mine`,
        { networkID: e, maxFeePerGas: t, maxPriorityFeePerGas: n },
      ];
    },
    resolveDomainName(e, t) {
      return [`${Tt}:resolve-domain-name`, { name: e }, { networkID: t }];
    },
    waitForTransactionConfirmation(e) {
      return [`${Tt}:wait-for-transaction-confirmation`, e ? { transactionReceipt: e } : {}];
    },
    pendingTransactions(e) {
      return [`${Tt}:pending-transactions`, { accounts: e }];
    },
    pendingTransactionById(e) {
      return [`${Tt}:pending-transaction`, e];
    },
    transactionSpeedsToUnitCost(e) {
      return [`${Tt}:transaction-speeds-to-cost`, { networkID: e }];
    },
    evmGasEstimationFallback(e) {
      return [`${Tt}:evm-gas-estimation-fallback`, { networkID: e }];
    },
    erc20GasLimitEstimate(e, t) {
      return [`${Tt}:evm-erc20-gas-limit-estimation`, { networkID: e, args: t }];
    },
    erc721GasLimitEstimate(e, t) {
      return [`${Tt}:evm-erc721-gas-limit-estimation`, { networkID: e, args: t }];
    },
    erc1155GasLimitEstimate(e, t) {
      return [`${Tt}:evm-erc1155-gas-limit-estimation`, { networkID: e, args: t }];
    },
    nativeEvmGasLimit(e, t) {
      return [`${Tt}:native-evm-gas-limit`, { networkID: e, address: t }];
    },
    timestamps() {
      return [`${Tt}:timestamps`];
    },
    gasLimit(e) {
      return [`${Tt}:gas-limit`, { args: e }];
    },
    gasLimitByTransaction(e) {
      return [`${Tt}:gas-limit-by-transaction`, { multichainTransaction: e }];
    },
    transactionUnitAmount(e) {
      return [`${Tt}:network-unit-by-transaction`, { multichainTransaction: e }];
    },
    utxoState(e) {
      return [`${Tt}:utxo-state`, { address: e }];
    },
    transactionAdditionalCosts(e) {
      return [`${Tt}:additional-costs`, { transaction: e }];
    },
    suiTransaction(e) {
      return [`${Tt}:sui-transaction`, e];
    },
  };
h.object({ chainId: oa, address: h.string() });
var ci = ((e) => (
    (e.Send = 'send'),
    (e.Swap = 'swap'),
    (e.Sell = 'sell'),
    (e.UnwrapSOL = 'unwrapSOL'),
    (e.Unwrap = 'unwrap'),
    (e.DelegateStake = 'delegateStake'),
    (e.CreateAccountAndDelegateStake = 'createAccountAndDelegateStake'),
    (e.WithdrawStake = 'withdrawStake'),
    (e.DeactivateStake = 'deactivateState'),
    (e.CreateListing = 'createListing'),
    (e.EditListing = 'editListing'),
    (e.RemoveListing = 'removeListing'),
    (e.Burn = 'burn'),
    (e.DappInteraction = 'dappInteraction'),
    (e.CreateAssociatedTokenAccount = 'createAssociatedTokenAccount'),
    (e.Cancel = 'cancel'),
    (e.SolanaPayTransaction = 'solanaPayTransaction'),
    (e.ConvertStake = 'convertStake'),
    (e.Decompress = 'decompress'),
    e
  ))(ci || {}),
  mT = ((e) => (
    (e.TokenSend = 'TokenSend'),
    (e.Stake = 'Stake'),
    (e.Swap = 'Swap'),
    (e.DappInteraction = 'DappInteraction'),
    (e.Other = 'Other'),
    e
  ))(mT || {});
const sj = h.object({
    accounts: h.array(h.string()),
    chainId: h.enum([ce.Solana.Mainnet]),
    transactionType: h.nativeEnum(mT).optional(),
    computeUnitLimit: h.number().optional(),
    getBounds: h.boolean().optional(),
  }),
  wT = h.object({ networkID: M0 });
wT.extend({
  senderAddress: aI,
  type: h.literal('transferNativeSolana'),
  destination: h.string(),
  amount: h.union([h.instanceof(oe), h.string()]),
  references: h.array(h.string()).optional(),
  memo: h.string().optional(),
  computeUnitPrice: h.union([h.number(), h.undefined()]),
});
h.object({ compressed: h.boolean(), merkleTree: h.string(), leafIndex: h.number() });
const cj = wT.extend({
  type: h.literal('transferSPLToken'),
  senderAddress: aI,
  mint: h.string(),
  amount: h.union([h.instanceof(oe), h.string()]),
  memo: h.string().optional(),
});
cj.extend({
  destination: h.string(),
  senderAccount: h.string(),
  decimals: h.number(),
  references: h.array(h.string()).optional(),
  programId: h.string(),
  transferHookProgramId: h.union([h.string(), h.undefined(), h.null()]),
});
h.object({ networkID: M0, id: h.string() });
const uj = h.object({
  executable: h.literal(!1),
  lamports: h.number(),
  owner: h.instanceof(Ye),
  rentEpoch: h.number(),
  data: h.object({
    program: h.literal('spl-token'),
    space: h.number(),
    parsed: h.object({
      type: h.literal('account'),
      info: h.object({
        isNative: h.boolean(),
        mint: h.string(),
        owner: h.string(),
        state: h.string(),
        tokenAmount: h.object({
          amount: h.string(),
          decimals: h.number(),
          uiAmount: h.number(),
          uiAmountString: h.string(),
        }),
      }),
    }),
  }),
});
h.object({ txID: h.string(), psbtHex: h.string(), confirmations: h.number() });
h.object({ digest: h.string() });
h.object({ displayName: h.string(), logoURI: h.string() });
var _n = ((e) => ((e.fast = 'fast'), (e.standard = 'standard'), (e.slow = 'slow'), e))(_n || {});
h.object({
  networkID: Ic,
  gasLimit: h.instanceof(oe),
  maxFeePerGas: h.instanceof(oe),
  maxPriorityFeePerGas: h.instanceof(oe),
  l1Fee: h.instanceof(oe).optional(),
});
h.object({
  networkID: Pp,
  virtualBytes: h.instanceof(oe),
  btcPerKilobyte: h.instanceof(oe),
  additionalCosts: h.instanceof(oe),
});
h.object({ networkID: Ic, id: h.string() });
h.object({ txID: h.string(), psbtHex: h.string() });
h.object({ networkID: Pp, id: h.string() });
h.object({ digest: h.string() });
h.object({ networkID: nI, id: h.string() });
var pi = ((e) => ((e.History = 'history'), (e.Home = 'home'), e))(pi || {});
h.union([h.literal('UNSET'), h.literal('ECONOMICAL'), h.literal('CONSERVATIVE')]);
function lj(e) {
  return {
    getRawTransaction: (n) => t('getrawtransaction', [n, 2]),
    sendRawTransaction: (n) => t('sendrawtransaction', [n]),
    estimateSmartFee: (n, r) => t('estimatesmartfee', [n, r ?? 'CONSERVATIVE']),
  };
  async function t(n, r) {
    const i = await ke
      .headers({ 'Content-type': 'application/json' })
      .post(e, { method: n, params: r });
    if ('error' in i.data && i.data.error)
      throw new Error('bitcoin rpc error:' + JSON.stringify(i.data.error));
    return i.data.result;
  }
}
const dj = [
    'eth_blockNumber',
    'eth_call',
    'eth_cancelPrivateTransaction',
    'eth_estimateGas',
    'eth_feeHistory',
    'eth_gasPrice',
    'eth_getBalance',
    'eth_getBlockByHash',
    'eth_getBlockByNumber',
    'eth_getBlockReceipts',
    'eth_getBlockTransactionCountByHash',
    'eth_getBlockTransactionCountByNumber',
    'eth_getCode',
    'eth_getFilterChanges',
    'eth_getFilterLogs',
    'eth_getLogs',
    'eth_getProof',
    'eth_getStorageAt',
    'eth_getTransactionByBlockHashAndIndex',
    'eth_getTransactionByBlockNumberAndIndex',
    'eth_getTransactionByHash',
    'eth_getTransactionCount',
    'eth_getTransactionReceipt',
    'eth_getUncleByBlockHashAndIndex',
    'eth_getUncleByBlockNumberAndIndex',
    'eth_getUncleCountByBlockHash',
    'eth_getUncleCountByBlockNumber',
    'eth_maxPriorityFeePerGas',
    'eth_newBlockFilter',
    'eth_newFilter',
    'eth_newPendingTransactionFilter',
    'eth_protocolVersion',
    'eth_sendPrivateTransaction',
    'eth_sendRawTransaction',
    'eth_syncing',
    'eth_uninstallFilter',
    'net_listening',
    'net_version',
    'web3_clientVersion',
    'web3_sha3',
  ],
  $o = dj.reduce(
    (e, t) => ({
      ...e,
      [t]: async (n, r) => {
        let i;
        const o = JSON.stringify({
          jsonrpc: '2.0',
          id: 1,
          method: t,
          params: Kw[t].params.parse(r),
        });
        try {
          return (
            (i = (
              await ke
                .headers({ Accept: 'application/json', 'Content-type': 'application/json' })
                .post(n, o)
            ).data),
            Kw[t].response.parse(i)
          );
        } catch (a) {
          throw (console.error('RPC request failed', n, t, r, i), a);
        }
      },
    }),
    {}
  ),
  fj = new Error('Missing either handle, networkID, or userRepository.'),
  hj = new Error('Missing baseFeePerGas in eth_getBlockByNumber.'),
  f1 = new Error('This domain is not registered'),
  pj = new Error('Invalid Solana address'),
  gj = new Error('This Twitter handle is not registered'),
  _T = new Error('This username is not registered'),
  k_ = new Error('Domain names do not match'),
  ap = new Error('Transaction is null');
class yj extends Error {
  constructor(t, n) {
    super(t), (this.data = n);
  }
}
const Nc = (e) => {
    const t = q.getRpcProxyUrl(e);
    if (!t) throw Error(`No RPC URL found for chainID ${e}`);
    return t;
  },
  Jp = (e) => {
    const t = q.getEVMNetworkIDValue(e),
      n = q.getRpcProxyUrl(e);
    return new N4(oD(n), t);
  },
  Vue = async (e, t, n = 1) => {
    if ((await Jp(e).waitForTransaction(t, n)).status === 0) throw new Error('tx reverted');
    return !0;
  },
  bj = 2,
  mj = async (e) => {
    const t = Nc(e),
      n = await $o.eth_getBlockByNumber(t, ['latest', !1]);
    if ('error' in n) throw new Error(`[${n.error.code}] ${n.error.message}`);
    if (!n.result.baseFeePerGas) throw hj;
    return new oe(n.result.baseFeePerGas, 16).multipliedBy(bj).integerValue(oe.ROUND_DOWN);
  },
  wj = async (e) => {
    const t = Nc(e),
      n = await $o.eth_maxPriorityFeePerGas(t, []);
    if ('error' in n) throw new Error(`[${n.error.code}] ${n.error.message}`);
    return new oe(n.result, 16);
  },
  _j = 'https://gas-price-oracle.phantom.app',
  vj = h.object({ maxFeePerGas: h.string(), maxPriorityFeePerGas: h.string() }),
  Yy = h.record(h.string(), vj),
  Sj = h.object({
    gasPriceSources: h.object({
      recommended: h.object({ priceEstimates: Yy }),
      blocknative: h.object({ priceEstimates: Yy }).optional(),
      etherscan: h.object({ priceEstimates: Yy }).optional(),
    }),
  });
class vT extends Error {
  constructor() {
    super(...arguments);
    Le(this, 'message', 'Gas price oracle does not support this network');
  }
}
const Aj = async (e) => {
    if (!q.isMainnetNetworkID(e)) throw new vT();
    const t = `${_j}/?chainId=${e}`,
      r = (await ke.headers({ 'Content-Type': 'application/json' }).get(t)).data;
    try {
      const i = Sj.parse(r),
        o = Object.keys(i.gasPriceSources.recommended.priceEstimates),
        a = {};
      return (
        o.forEach((c) => {
          a[c] = {
            maxFeePerGas: new oe(i.gasPriceSources.recommended.priceEstimates[c].maxFeePerGas),
            maxPriorityFeePerGas: new oe(
              i.gasPriceSources.recommended.priceEstimates[c].maxPriorityFeePerGas
            ),
          };
        }),
        a
      );
    } catch (i) {
      throw new Error(`Ethereum Price oracle response: ${JSON.stringify(r)}, ${i}`, { cause: i });
    }
  },
  C_ = new oe(30 * 1e9),
  Ij = async (e) => {
    const t = await mj(e),
      n = await wj(e);
    let r = t.plus(n);
    return (
      r.lt(C_) && q.isPolygonNetworkID(e) && (r = C_), { maxFeePerGas: r, maxPriorityFeePerGas: n }
    );
  },
  ST = async (e, t = !0) => {
    if (q.isEVMNetworkID(e))
      try {
        return await Aj(e);
      } catch (n) {
        if (!t) throw n;
        const r = await Ij(e);
        return { [_n.fast]: r, [_n.standard]: r, [_n.slow]: r };
      }
    else throw new Error(`Estimating gas price for chainId:${e} is not supported.`);
  },
  Ej = new oe(0),
  Tj = new oe(1e-4),
  kj = new oe(0.01),
  Kue = (e) => {
    if (e.isEqualTo(Ej)) return '$0';
    if (e.isLessThan(Tj)) return '< $0.0001';
    const t = sI(e.toNumber());
    return e.isLessThan(kj) ? t.format('$0,0.0000') : t.format('$0,0.00');
  },
  Cj = 1.1,
  AT = (e) => e.times(Cj).toFixed(0);
new Ye('11111111111111111111111111111111');
new Ye('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');
new Ye('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');
const Mj = 'noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV';
new Ye(Mj);
const Pj = 'cmtDvXumGCrqC1Age74AVPhSRVXJMd8PJS91L8KbNCK';
new Ye(Pj);
new Ye('auth9SigNpDKz4sJJ1DfCTuZrZNSAgh9sFD3rboVmgg');
const Hue = new Ye('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'),
  Oj = 'BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY';
new Ye(Oj);
const Dj = 'CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d';
function Rj(e) {
  if (e.length >= 255) throw new TypeError('Alphabet too long');
  for (var t = new Uint8Array(256), n = 0; n < t.length; n++) t[n] = 255;
  for (var r = 0; r < e.length; r++) {
    var i = e.charAt(r),
      o = i.charCodeAt(0);
    if (t[o] !== 255) throw new TypeError(i + ' is ambiguous');
    t[o] = r;
  }
  var a = e.length,
    c = e.charAt(0),
    s = Math.log(a) / Math.log(256),
    l = Math.log(256) / Math.log(a);
  function u(p) {
    if (
      (p instanceof Uint8Array ||
        (ArrayBuffer.isView(p)
          ? (p = new Uint8Array(p.buffer, p.byteOffset, p.byteLength))
          : Array.isArray(p) && (p = Uint8Array.from(p))),
      !(p instanceof Uint8Array))
    )
      throw new TypeError('Expected Uint8Array');
    if (p.length === 0) return '';
    for (var y = 0, b = 0, m = 0, w = p.length; m !== w && p[m] === 0; ) m++, y++;
    for (var _ = ((w - m) * l + 1) >>> 0, S = new Uint8Array(_); m !== w; ) {
      for (var E = p[m], O = 0, N = _ - 1; (E !== 0 || O < b) && N !== -1; N--, O++)
        (E += (256 * S[N]) >>> 0), (S[N] = E % a >>> 0), (E = (E / a) >>> 0);
      if (E !== 0) throw new Error('Non-zero carry');
      (b = O), m++;
    }
    for (var F = _ - b; F !== _ && S[F] === 0; ) F++;
    for (var D = c.repeat(y); F < _; ++F) D += e.charAt(S[F]);
    return D;
  }
  function d(p) {
    if (typeof p != 'string') throw new TypeError('Expected String');
    if (p.length === 0) return new Uint8Array();
    for (var y = 0, b = 0, m = 0; p[y] === c; ) b++, y++;
    for (var w = ((p.length - y) * s + 1) >>> 0, _ = new Uint8Array(w); p[y]; ) {
      var S = t[p.charCodeAt(y)];
      if (S === 255) return;
      for (var E = 0, O = w - 1; (S !== 0 || E < m) && O !== -1; O--, E++)
        (S += (a * _[O]) >>> 0), (_[O] = S % 256 >>> 0), (S = (S / 256) >>> 0);
      if (S !== 0) throw new Error('Non-zero carry');
      (m = E), y++;
    }
    for (var N = w - m; N !== w && _[N] === 0; ) N++;
    for (var F = new Uint8Array(b + (w - N)), D = b; N !== w; ) F[D++] = _[N++];
    return F;
  }
  function f(p) {
    var y = d(p);
    if (y) return y;
    throw new Error('Non-base' + a + ' character');
  }
  return { encode: u, decodeUnsafe: d, decode: f };
}
var xj = Rj;
const Bj = xj,
  jj = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
Bj(jj);
var Nj = {},
  Xp = {},
  Zy = {};
function Nm(e) {
  if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`);
}
function Uj(e) {
  if (typeof e != 'boolean') throw new Error(`Expected boolean, not ${e}`);
}
function IT(e, ...t) {
  if (!(e instanceof Uint8Array)) throw new TypeError('Expected Uint8Array');
  if (t.length > 0 && !t.includes(e.length))
    throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function Lj(e) {
  if (typeof e != 'function' || typeof e.create != 'function')
    throw new Error('Hash should be wrapped by utils.wrapConstructor');
  Nm(e.outputLen), Nm(e.blockLen);
}
function zj(e, t = !0) {
  if (e.destroyed) throw new Error('Hash instance has been destroyed');
  if (t && e.finished) throw new Error('Hash#digest() has already been called');
}
function Fj(e, t) {
  IT(e);
  const n = t.outputLen;
  if (e.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`);
}
const Bn = { number: Nm, bool: Uj, bytes: IT, hash: Lj, exists: zj, output: Fj };
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const $j = (e) =>
    new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)),
  Qy = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength),
  Tr = (e, t) => (e << (32 - t)) | (e >>> t),
  Wj = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!Wj) throw new Error('Non little-endian hardware is not supported');
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, '0'));
function Vj(e) {
  if (typeof e != 'string') throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function Uc(e) {
  if ((typeof e == 'string' && (e = Vj(e)), !(e instanceof Uint8Array)))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
  return e;
}
class h1 {
  clone() {
    return this._cloneInto();
  }
}
function sa(e) {
  const t = (r) => e().update(Uc(r)).digest(),
    n = e();
  return (t.outputLen = n.outputLen), (t.blockLen = n.blockLen), (t.create = () => e()), t;
}
function Kj(e) {
  const t = (r, i) => e(i).update(Uc(r)).digest(),
    n = e({});
  return (t.outputLen = n.outputLen), (t.blockLen = n.blockLen), (t.create = (r) => e(r)), t;
}
function Hj(e, t, n, r) {
  if (typeof e.setBigUint64 == 'function') return e.setBigUint64(t, n, r);
  const i = BigInt(32),
    o = BigInt(4294967295),
    a = Number((n >> i) & o),
    c = Number(n & o),
    s = r ? 4 : 0,
    l = r ? 0 : 4;
  e.setUint32(t + s, a, r), e.setUint32(t + l, c, r);
}
class ET extends h1 {
  constructor(t, n, r, i) {
    super(),
      (this.blockLen = t),
      (this.outputLen = n),
      (this.padOffset = r),
      (this.isLE = i),
      (this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.buffer = new Uint8Array(t)),
      (this.view = Qy(this.buffer));
  }
  update(t) {
    Bn.exists(this);
    const { view: n, buffer: r, blockLen: i } = this;
    t = Uc(t);
    const o = t.length;
    for (let a = 0; a < o; ) {
      const c = Math.min(i - this.pos, o - a);
      if (c === i) {
        const s = Qy(t);
        for (; i <= o - a; a += i) this.process(s, a);
        continue;
      }
      r.set(t.subarray(a, a + c), this.pos),
        (this.pos += c),
        (a += c),
        this.pos === i && (this.process(n, 0), (this.pos = 0));
    }
    return (this.length += t.length), this.roundClean(), this;
  }
  digestInto(t) {
    Bn.exists(this), Bn.output(t, this), (this.finished = !0);
    const { buffer: n, view: r, blockLen: i, isLE: o } = this;
    let { pos: a } = this;
    (n[a++] = 128),
      this.buffer.subarray(a).fill(0),
      this.padOffset > i - a && (this.process(r, 0), (a = 0));
    for (let d = a; d < i; d++) n[d] = 0;
    Hj(r, i - 8, BigInt(this.length * 8), o), this.process(r, 0);
    const c = Qy(t),
      s = this.outputLen;
    if (s % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
    const l = s / 4,
      u = this.get();
    if (l > u.length) throw new Error('_sha2: outputLen bigger than state');
    for (let d = 0; d < l; d++) c.setUint32(4 * d, u[d], o);
  }
  digest() {
    const { buffer: t, outputLen: n } = this;
    this.digestInto(t);
    const r = t.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: n, buffer: r, length: i, finished: o, destroyed: a, pos: c } = this;
    return (
      (t.length = i), (t.pos = c), (t.finished = o), (t.destroyed = a), i % n && t.buffer.set(r), t
    );
  }
}
const Jf = BigInt(2 ** 32 - 1),
  Um = BigInt(32);
function TT(e, t = !1) {
  return t
    ? { h: Number(e & Jf), l: Number((e >> Um) & Jf) }
    : { h: Number((e >> Um) & Jf) | 0, l: Number(e & Jf) | 0 };
}
function qj(e, t = !1) {
  let n = new Uint32Array(e.length),
    r = new Uint32Array(e.length);
  for (let i = 0; i < e.length; i++) {
    const { h: o, l: a } = TT(e[i], t);
    [n[i], r[i]] = [o, a];
  }
  return [n, r];
}
const Gj = (e, t) => (BigInt(e >>> 0) << Um) | BigInt(t >>> 0),
  Yj = (e, t, n) => e >>> n,
  Zj = (e, t, n) => (e << (32 - n)) | (t >>> n),
  Qj = (e, t, n) => (e >>> n) | (t << (32 - n)),
  Jj = (e, t, n) => (e << (32 - n)) | (t >>> n),
  Xj = (e, t, n) => (e << (64 - n)) | (t >>> (n - 32)),
  e9 = (e, t, n) => (e >>> (n - 32)) | (t << (64 - n)),
  t9 = (e, t) => t,
  n9 = (e, t) => e,
  r9 = (e, t, n) => (e << n) | (t >>> (32 - n)),
  i9 = (e, t, n) => (t << n) | (e >>> (32 - n)),
  o9 = (e, t, n) => (t << (n - 32)) | (e >>> (64 - n)),
  a9 = (e, t, n) => (e << (n - 32)) | (t >>> (64 - n));
function s9(e, t, n, r) {
  const i = (t >>> 0) + (r >>> 0);
  return { h: (e + n + ((i / 2 ** 32) | 0)) | 0, l: i | 0 };
}
const c9 = (e, t, n) => (e >>> 0) + (t >>> 0) + (n >>> 0),
  u9 = (e, t, n, r) => (t + n + r + ((e / 2 ** 32) | 0)) | 0,
  l9 = (e, t, n, r) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0),
  d9 = (e, t, n, r, i) => (t + n + r + i + ((e / 2 ** 32) | 0)) | 0,
  f9 = (e, t, n, r, i) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0) + (i >>> 0),
  h9 = (e, t, n, r, i, o) => (t + n + r + i + o + ((e / 2 ** 32) | 0)) | 0,
  je = {
    fromBig: TT,
    split: qj,
    toBig: Gj,
    shrSH: Yj,
    shrSL: Zj,
    rotrSH: Qj,
    rotrSL: Jj,
    rotrBH: Xj,
    rotrBL: e9,
    rotr32H: t9,
    rotr32L: n9,
    rotlSH: r9,
    rotlSL: i9,
    rotlBH: o9,
    rotlBL: a9,
    add: s9,
    add3L: c9,
    add3H: u9,
    add4L: l9,
    add4H: d9,
    add5H: h9,
    add5L: f9,
  },
  [p9, g9] = je.split(
    [
      '0x428a2f98d728ae22',
      '0x7137449123ef65cd',
      '0xb5c0fbcfec4d3b2f',
      '0xe9b5dba58189dbbc',
      '0x3956c25bf348b538',
      '0x59f111f1b605d019',
      '0x923f82a4af194f9b',
      '0xab1c5ed5da6d8118',
      '0xd807aa98a3030242',
      '0x12835b0145706fbe',
      '0x243185be4ee4b28c',
      '0x550c7dc3d5ffb4e2',
      '0x72be5d74f27b896f',
      '0x80deb1fe3b1696b1',
      '0x9bdc06a725c71235',
      '0xc19bf174cf692694',
      '0xe49b69c19ef14ad2',
      '0xefbe4786384f25e3',
      '0x0fc19dc68b8cd5b5',
      '0x240ca1cc77ac9c65',
      '0x2de92c6f592b0275',
      '0x4a7484aa6ea6e483',
      '0x5cb0a9dcbd41fbd4',
      '0x76f988da831153b5',
      '0x983e5152ee66dfab',
      '0xa831c66d2db43210',
      '0xb00327c898fb213f',
      '0xbf597fc7beef0ee4',
      '0xc6e00bf33da88fc2',
      '0xd5a79147930aa725',
      '0x06ca6351e003826f',
      '0x142929670a0e6e70',
      '0x27b70a8546d22ffc',
      '0x2e1b21385c26c926',
      '0x4d2c6dfc5ac42aed',
      '0x53380d139d95b3df',
      '0x650a73548baf63de',
      '0x766a0abb3c77b2a8',
      '0x81c2c92e47edaee6',
      '0x92722c851482353b',
      '0xa2bfe8a14cf10364',
      '0xa81a664bbc423001',
      '0xc24b8b70d0f89791',
      '0xc76c51a30654be30',
      '0xd192e819d6ef5218',
      '0xd69906245565a910',
      '0xf40e35855771202a',
      '0x106aa07032bbd1b8',
      '0x19a4c116b8d2d0c8',
      '0x1e376c085141ab53',
      '0x2748774cdf8eeb99',
      '0x34b0bcb5e19b48a8',
      '0x391c0cb3c5c95a63',
      '0x4ed8aa4ae3418acb',
      '0x5b9cca4f7763e373',
      '0x682e6ff3d6b2b8a3',
      '0x748f82ee5defb2fc',
      '0x78a5636f43172f60',
      '0x84c87814a1f0ab72',
      '0x8cc702081a6439ec',
      '0x90befffa23631e28',
      '0xa4506cebde82bde9',
      '0xbef9a3f7b2c67915',
      '0xc67178f2e372532b',
      '0xca273eceea26619c',
      '0xd186b8c721c0c207',
      '0xeada7dd6cde0eb1e',
      '0xf57d4f7fee6ed178',
      '0x06f067aa72176fba',
      '0x0a637dc5a2c898a6',
      '0x113f9804bef90dae',
      '0x1b710b35131c471b',
      '0x28db77f523047d84',
      '0x32caab7b40c72493',
      '0x3c9ebe0a15c9bebc',
      '0x431d67c49c100d4c',
      '0x4cc5d4becb3e42b6',
      '0x597f299cfc657e2a',
      '0x5fcb6fab3ad6faec',
      '0x6c44198c4a475817',
    ].map((e) => BigInt(e))
  ),
  Mi = new Uint32Array(80),
  Pi = new Uint32Array(80);
let eg = class extends ET {
  constructor() {
    super(128, 64, 16, !1),
      (this.Ah = 1779033703),
      (this.Al = -205731576),
      (this.Bh = -1150833019),
      (this.Bl = -2067093701),
      (this.Ch = 1013904242),
      (this.Cl = -23791573),
      (this.Dh = -1521486534),
      (this.Dl = 1595750129),
      (this.Eh = 1359893119),
      (this.El = -1377402159),
      (this.Fh = -1694144372),
      (this.Fl = 725511199),
      (this.Gh = 528734635),
      (this.Gl = -79577749),
      (this.Hh = 1541459225),
      (this.Hl = 327033209);
  }
  get() {
    const {
      Ah: t,
      Al: n,
      Bh: r,
      Bl: i,
      Ch: o,
      Cl: a,
      Dh: c,
      Dl: s,
      Eh: l,
      El: u,
      Fh: d,
      Fl: f,
      Gh: p,
      Gl: y,
      Hh: b,
      Hl: m,
    } = this;
    return [t, n, r, i, o, a, c, s, l, u, d, f, p, y, b, m];
  }
  set(t, n, r, i, o, a, c, s, l, u, d, f, p, y, b, m) {
    (this.Ah = t | 0),
      (this.Al = n | 0),
      (this.Bh = r | 0),
      (this.Bl = i | 0),
      (this.Ch = o | 0),
      (this.Cl = a | 0),
      (this.Dh = c | 0),
      (this.Dl = s | 0),
      (this.Eh = l | 0),
      (this.El = u | 0),
      (this.Fh = d | 0),
      (this.Fl = f | 0),
      (this.Gh = p | 0),
      (this.Gl = y | 0),
      (this.Hh = b | 0),
      (this.Hl = m | 0);
  }
  process(t, n) {
    for (let S = 0; S < 16; S++, n += 4) (Mi[S] = t.getUint32(n)), (Pi[S] = t.getUint32((n += 4)));
    for (let S = 16; S < 80; S++) {
      const E = Mi[S - 15] | 0,
        O = Pi[S - 15] | 0,
        N = je.rotrSH(E, O, 1) ^ je.rotrSH(E, O, 8) ^ je.shrSH(E, O, 7),
        F = je.rotrSL(E, O, 1) ^ je.rotrSL(E, O, 8) ^ je.shrSL(E, O, 7),
        D = Mi[S - 2] | 0,
        k = Pi[S - 2] | 0,
        K = je.rotrSH(D, k, 19) ^ je.rotrBH(D, k, 61) ^ je.shrSH(D, k, 6),
        M = je.rotrSL(D, k, 19) ^ je.rotrBL(D, k, 61) ^ je.shrSL(D, k, 6),
        C = je.add4L(F, M, Pi[S - 7], Pi[S - 16]),
        z = je.add4H(C, N, K, Mi[S - 7], Mi[S - 16]);
      (Mi[S] = z | 0), (Pi[S] = C | 0);
    }
    let {
      Ah: r,
      Al: i,
      Bh: o,
      Bl: a,
      Ch: c,
      Cl: s,
      Dh: l,
      Dl: u,
      Eh: d,
      El: f,
      Fh: p,
      Fl: y,
      Gh: b,
      Gl: m,
      Hh: w,
      Hl: _,
    } = this;
    for (let S = 0; S < 80; S++) {
      const E = je.rotrSH(d, f, 14) ^ je.rotrSH(d, f, 18) ^ je.rotrBH(d, f, 41),
        O = je.rotrSL(d, f, 14) ^ je.rotrSL(d, f, 18) ^ je.rotrBL(d, f, 41),
        N = (d & p) ^ (~d & b),
        F = (f & y) ^ (~f & m),
        D = je.add5L(_, O, F, g9[S], Pi[S]),
        k = je.add5H(D, w, E, N, p9[S], Mi[S]),
        K = D | 0,
        M = je.rotrSH(r, i, 28) ^ je.rotrBH(r, i, 34) ^ je.rotrBH(r, i, 39),
        C = je.rotrSL(r, i, 28) ^ je.rotrBL(r, i, 34) ^ je.rotrBL(r, i, 39),
        z = (r & o) ^ (r & c) ^ (o & c),
        I = (i & a) ^ (i & s) ^ (a & s);
      (w = b | 0),
        (_ = m | 0),
        (b = p | 0),
        (m = y | 0),
        (p = d | 0),
        (y = f | 0),
        ({ h: d, l: f } = je.add(l | 0, u | 0, k | 0, K | 0)),
        (l = c | 0),
        (u = s | 0),
        (c = o | 0),
        (s = a | 0),
        (o = r | 0),
        (a = i | 0);
      const T = je.add3L(K, C, I);
      (r = je.add3H(T, k, M, z)), (i = T | 0);
    }
    ({ h: r, l: i } = je.add(this.Ah | 0, this.Al | 0, r | 0, i | 0)),
      ({ h: o, l: a } = je.add(this.Bh | 0, this.Bl | 0, o | 0, a | 0)),
      ({ h: c, l: s } = je.add(this.Ch | 0, this.Cl | 0, c | 0, s | 0)),
      ({ h: l, l: u } = je.add(this.Dh | 0, this.Dl | 0, l | 0, u | 0)),
      ({ h: d, l: f } = je.add(this.Eh | 0, this.El | 0, d | 0, f | 0)),
      ({ h: p, l: y } = je.add(this.Fh | 0, this.Fl | 0, p | 0, y | 0)),
      ({ h: b, l: m } = je.add(this.Gh | 0, this.Gl | 0, b | 0, m | 0)),
      ({ h: w, l: _ } = je.add(this.Hh | 0, this.Hl | 0, w | 0, _ | 0)),
      this.set(r, i, o, a, c, s, l, u, d, f, p, y, b, m, w, _);
  }
  roundClean() {
    Mi.fill(0), Pi.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
class y9 extends eg {
  constructor() {
    super(),
      (this.Ah = -1942145080),
      (this.Al = 424955298),
      (this.Bh = 1944164710),
      (this.Bl = -1982016298),
      (this.Ch = 502970286),
      (this.Cl = 855612546),
      (this.Dh = 1738396948),
      (this.Dl = 1479516111),
      (this.Eh = 258812777),
      (this.El = 2077511080),
      (this.Fh = 2011393907),
      (this.Fl = 79989058),
      (this.Gh = 1067287976),
      (this.Gl = 1780299464),
      (this.Hh = 286451373),
      (this.Hl = -1848208735),
      (this.outputLen = 28);
  }
}
class b9 extends eg {
  constructor() {
    super(),
      (this.Ah = 573645204),
      (this.Al = -64227540),
      (this.Bh = -1621794909),
      (this.Bl = -934517566),
      (this.Ch = 596883563),
      (this.Cl = 1867755857),
      (this.Dh = -1774684391),
      (this.Dl = 1497426621),
      (this.Eh = -1775747358),
      (this.El = -1467023389),
      (this.Fh = -1101128155),
      (this.Fl = 1401305490),
      (this.Gh = 721525244),
      (this.Gl = 746961066),
      (this.Hh = 246885852),
      (this.Hl = -2117784414),
      (this.outputLen = 32);
  }
}
class m9 extends eg {
  constructor() {
    super(),
      (this.Ah = -876896931),
      (this.Al = -1056596264),
      (this.Bh = 1654270250),
      (this.Bl = 914150663),
      (this.Ch = -1856437926),
      (this.Cl = 812702999),
      (this.Dh = 355462360),
      (this.Dl = -150054599),
      (this.Eh = 1731405415),
      (this.El = -4191439),
      (this.Fh = -1900787065),
      (this.Fl = 1750603025),
      (this.Gh = -619958771),
      (this.Gl = 1694076839),
      (this.Hh = 1203062813),
      (this.Hl = -1090891868),
      (this.outputLen = 48);
  }
}
const w9 = sa(() => new eg());
sa(() => new y9());
sa(() => new b9());
sa(() => new m9());
var _9 = bI,
  v9 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz',
  S9 = _9(v9);
const an = Oc(S9),
  A9 = (e, t, n) => (e & t) ^ (~e & n),
  I9 = (e, t, n) => (e & t) ^ (e & n) ^ (t & n),
  E9 = new Uint32Array([
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221,
    3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580,
    3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895,
    666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037,
    2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
    1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298,
  ]),
  Oi = new Uint32Array([
    1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225,
  ]),
  Di = new Uint32Array(64);
let kT = class extends ET {
  constructor() {
    super(64, 32, 8, !1),
      (this.A = Oi[0] | 0),
      (this.B = Oi[1] | 0),
      (this.C = Oi[2] | 0),
      (this.D = Oi[3] | 0),
      (this.E = Oi[4] | 0),
      (this.F = Oi[5] | 0),
      (this.G = Oi[6] | 0),
      (this.H = Oi[7] | 0);
  }
  get() {
    const { A: t, B: n, C: r, D: i, E: o, F: a, G: c, H: s } = this;
    return [t, n, r, i, o, a, c, s];
  }
  set(t, n, r, i, o, a, c, s) {
    (this.A = t | 0),
      (this.B = n | 0),
      (this.C = r | 0),
      (this.D = i | 0),
      (this.E = o | 0),
      (this.F = a | 0),
      (this.G = c | 0),
      (this.H = s | 0);
  }
  process(t, n) {
    for (let d = 0; d < 16; d++, n += 4) Di[d] = t.getUint32(n, !1);
    for (let d = 16; d < 64; d++) {
      const f = Di[d - 15],
        p = Di[d - 2],
        y = Tr(f, 7) ^ Tr(f, 18) ^ (f >>> 3),
        b = Tr(p, 17) ^ Tr(p, 19) ^ (p >>> 10);
      Di[d] = (b + Di[d - 7] + y + Di[d - 16]) | 0;
    }
    let { A: r, B: i, C: o, D: a, E: c, F: s, G: l, H: u } = this;
    for (let d = 0; d < 64; d++) {
      const f = Tr(c, 6) ^ Tr(c, 11) ^ Tr(c, 25),
        p = (u + f + A9(c, s, l) + E9[d] + Di[d]) | 0,
        b = ((Tr(r, 2) ^ Tr(r, 13) ^ Tr(r, 22)) + I9(r, i, o)) | 0;
      (u = l), (l = s), (s = c), (c = (a + p) | 0), (a = o), (o = i), (i = r), (r = (p + b) | 0);
    }
    (r = (r + this.A) | 0),
      (i = (i + this.B) | 0),
      (o = (o + this.C) | 0),
      (a = (a + this.D) | 0),
      (c = (c + this.E) | 0),
      (s = (s + this.F) | 0),
      (l = (l + this.G) | 0),
      (u = (u + this.H) | 0),
      this.set(r, i, o, a, c, s, l, u);
  }
  roundClean() {
    Di.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
class T9 extends kT {
  constructor() {
    super(),
      (this.A = -1056596264),
      (this.B = 914150663),
      (this.C = 812702999),
      (this.D = -150054599),
      (this.E = -4191439),
      (this.F = 1750603025),
      (this.G = 1694076839),
      (this.H = -1090891868),
      (this.outputLen = 28);
  }
}
const Lm = sa(() => new kT());
sa(() => new T9());
var nn = {},
  k9 = bI,
  C9 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz',
  M9 = k9(C9),
  P9 =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n),
            Object.defineProperty(e, r, {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            });
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  O9 =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  Vr =
    (g && g.__decorate) ||
    function (e, t, n, r) {
      var i = arguments.length,
        o = i < 3 ? t : r === null ? (r = Object.getOwnPropertyDescriptor(t, n)) : r,
        a;
      if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function')
        o = Reflect.decorate(e, t, n, r);
      else
        for (var c = e.length - 1; c >= 0; c--)
          (a = e[c]) && (o = (i < 3 ? a(o) : i > 3 ? a(t, n, o) : a(t, n)) || o);
      return i > 3 && o && Object.defineProperty(t, n, o), o;
    },
  D9 =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e) n !== 'default' && Object.hasOwnProperty.call(e, n) && P9(t, e, n);
      return O9(t, e), t;
    },
  CT =
    (g && g.__importDefault) ||
    function (e) {
      return e && e.__esModule ? e : { default: e };
    };
Object.defineProperty(nn, '__esModule', { value: !0 });
var MT =
  (nn.deserializeUnchecked =
  BT =
  nn.deserialize =
  xT =
  nn.serialize =
  nn.BinaryReader =
  nn.BinaryWriter =
  nn.BorshError =
  nn.baseDecode =
  nn.baseEncode =
    void 0);
const qi = CT(i4()),
  PT = CT(M9),
  R9 = D9(o4),
  x9 = typeof TextDecoder != 'function' ? R9.TextDecoder : TextDecoder,
  B9 = new x9('utf-8', { fatal: !0 });
function j9(e) {
  return typeof e == 'string' && (e = Y.from(e, 'utf8')), PT.default.encode(Y.from(e));
}
nn.baseEncode = j9;
function N9(e) {
  return Y.from(PT.default.decode(e));
}
nn.baseDecode = N9;
const Jy = 1024;
class wn extends Error {
  constructor(t) {
    super(t), (this.fieldPath = []), (this.originalMessage = t);
  }
  addToFieldPath(t) {
    this.fieldPath.splice(0, 0, t),
      (this.message = this.originalMessage + ': ' + this.fieldPath.join('.'));
  }
}
nn.BorshError = wn;
class OT {
  constructor() {
    (this.buf = Y.alloc(Jy)), (this.length = 0);
  }
  maybeResize() {
    this.buf.length < 16 + this.length && (this.buf = Y.concat([this.buf, Y.alloc(Jy)]));
  }
  writeU8(t) {
    this.maybeResize(), this.buf.writeUInt8(t, this.length), (this.length += 1);
  }
  writeU16(t) {
    this.maybeResize(), this.buf.writeUInt16LE(t, this.length), (this.length += 2);
  }
  writeU32(t) {
    this.maybeResize(), this.buf.writeUInt32LE(t, this.length), (this.length += 4);
  }
  writeU64(t) {
    this.maybeResize(), this.writeBuffer(Y.from(new qi.default(t).toArray('le', 8)));
  }
  writeU128(t) {
    this.maybeResize(), this.writeBuffer(Y.from(new qi.default(t).toArray('le', 16)));
  }
  writeU256(t) {
    this.maybeResize(), this.writeBuffer(Y.from(new qi.default(t).toArray('le', 32)));
  }
  writeU512(t) {
    this.maybeResize(), this.writeBuffer(Y.from(new qi.default(t).toArray('le', 64)));
  }
  writeBuffer(t) {
    (this.buf = Y.concat([Y.from(this.buf.subarray(0, this.length)), t, Y.alloc(Jy)])),
      (this.length += t.length);
  }
  writeString(t) {
    this.maybeResize();
    const n = Y.from(t, 'utf8');
    this.writeU32(n.length), this.writeBuffer(n);
  }
  writeFixedArray(t) {
    this.writeBuffer(Y.from(t));
  }
  writeArray(t, n) {
    this.maybeResize(), this.writeU32(t.length);
    for (const r of t) this.maybeResize(), n(r);
  }
  toArray() {
    return this.buf.subarray(0, this.length);
  }
}
nn.BinaryWriter = OT;
function Kr(e, t, n) {
  const r = n.value;
  n.value = function (...i) {
    try {
      return r.apply(this, i);
    } catch (o) {
      if (o instanceof RangeError) {
        const a = o.code;
        if (['ERR_BUFFER_OUT_OF_BOUNDS', 'ERR_OUT_OF_RANGE'].indexOf(a) >= 0)
          throw new wn('Reached the end of buffer when deserializing');
      }
      throw o;
    }
  };
}
class Fn {
  constructor(t) {
    (this.buf = t), (this.offset = 0);
  }
  readU8() {
    const t = this.buf.readUInt8(this.offset);
    return (this.offset += 1), t;
  }
  readU16() {
    const t = this.buf.readUInt16LE(this.offset);
    return (this.offset += 2), t;
  }
  readU32() {
    const t = this.buf.readUInt32LE(this.offset);
    return (this.offset += 4), t;
  }
  readU64() {
    const t = this.readBuffer(8);
    return new qi.default(t, 'le');
  }
  readU128() {
    const t = this.readBuffer(16);
    return new qi.default(t, 'le');
  }
  readU256() {
    const t = this.readBuffer(32);
    return new qi.default(t, 'le');
  }
  readU512() {
    const t = this.readBuffer(64);
    return new qi.default(t, 'le');
  }
  readBuffer(t) {
    if (this.offset + t > this.buf.length)
      throw new wn(`Expected buffer length ${t} isn't within bounds`);
    const n = this.buf.slice(this.offset, this.offset + t);
    return (this.offset += t), n;
  }
  readString() {
    const t = this.readU32(),
      n = this.readBuffer(t);
    try {
      return B9.decode(n);
    } catch (r) {
      throw new wn(`Error decoding UTF-8 string: ${r}`);
    }
  }
  readFixedArray(t) {
    return new Uint8Array(this.readBuffer(t));
  }
  readArray(t) {
    const n = this.readU32(),
      r = Array();
    for (let i = 0; i < n; ++i) r.push(t());
    return r;
  }
}
Vr([Kr], Fn.prototype, 'readU8', null);
Vr([Kr], Fn.prototype, 'readU16', null);
Vr([Kr], Fn.prototype, 'readU32', null);
Vr([Kr], Fn.prototype, 'readU64', null);
Vr([Kr], Fn.prototype, 'readU128', null);
Vr([Kr], Fn.prototype, 'readU256', null);
Vr([Kr], Fn.prototype, 'readU512', null);
Vr([Kr], Fn.prototype, 'readString', null);
Vr([Kr], Fn.prototype, 'readFixedArray', null);
Vr([Kr], Fn.prototype, 'readArray', null);
nn.BinaryReader = Fn;
function DT(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}
function Io(e, t, n, r, i) {
  try {
    if (typeof r == 'string') i[`write${DT(r)}`](n);
    else if (r instanceof Array)
      if (typeof r[0] == 'number') {
        if (n.length !== r[0])
          throw new wn(`Expecting byte array of length ${r[0]}, but got ${n.length} bytes`);
        i.writeFixedArray(n);
      } else if (r.length === 2 && typeof r[1] == 'number') {
        if (n.length !== r[1])
          throw new wn(`Expecting byte array of length ${r[1]}, but got ${n.length} bytes`);
        for (let o = 0; o < r[1]; o++) Io(e, null, n[o], r[0], i);
      } else
        i.writeArray(n, (o) => {
          Io(e, t, o, r[0], i);
        });
    else if (r.kind !== void 0)
      switch (r.kind) {
        case 'option': {
          n == null ? i.writeU8(0) : (i.writeU8(1), Io(e, t, n, r.type, i));
          break;
        }
        case 'map': {
          i.writeU32(n.size),
            n.forEach((o, a) => {
              Io(e, t, a, r.key, i), Io(e, t, o, r.value, i);
            });
          break;
        }
        default:
          throw new wn(`FieldType ${r} unrecognized`);
      }
    else RT(e, n, i);
  } catch (o) {
    throw (o instanceof wn && o.addToFieldPath(t), o);
  }
}
function RT(e, t, n) {
  if (typeof t.borshSerialize == 'function') {
    t.borshSerialize(n);
    return;
  }
  const r = e.get(t.constructor);
  if (!r) throw new wn(`Class ${t.constructor.name} is missing in schema`);
  if (r.kind === 'struct')
    r.fields.map(([i, o]) => {
      Io(e, i, t[i], o, n);
    });
  else if (r.kind === 'enum') {
    const i = t[r.field];
    for (let o = 0; o < r.values.length; ++o) {
      const [a, c] = r.values[o];
      if (a === i) {
        n.writeU8(o), Io(e, a, t[a], c, n);
        break;
      }
    }
  } else throw new wn(`Unexpected schema kind: ${r.kind} for ${t.constructor.name}`);
}
function U9(e, t, n = OT) {
  const r = new n();
  return RT(e, t, r), r.toArray();
}
var xT = (nn.serialize = U9);
function Eo(e, t, n, r) {
  try {
    if (typeof n == 'string') return r[`read${DT(n)}`]();
    if (n instanceof Array) {
      if (typeof n[0] == 'number') return r.readFixedArray(n[0]);
      if (typeof n[1] == 'number') {
        const i = [];
        for (let o = 0; o < n[1]; o++) i.push(Eo(e, null, n[0], r));
        return i;
      } else return r.readArray(() => Eo(e, t, n[0], r));
    }
    if (n.kind === 'option') return r.readU8() ? Eo(e, t, n.type, r) : void 0;
    if (n.kind === 'map') {
      let i = new Map();
      const o = r.readU32();
      for (let a = 0; a < o; a++) {
        const c = Eo(e, t, n.key, r),
          s = Eo(e, t, n.value, r);
        i.set(c, s);
      }
      return i;
    }
    return p1(e, n, r);
  } catch (i) {
    throw (i instanceof wn && i.addToFieldPath(t), i);
  }
}
function p1(e, t, n) {
  if (typeof t.borshDeserialize == 'function') return t.borshDeserialize(n);
  const r = e.get(t);
  if (!r) throw new wn(`Class ${t.name} is missing in schema`);
  if (r.kind === 'struct') {
    const i = {};
    for (const [o, a] of e.get(t).fields) i[o] = Eo(e, o, a, n);
    return new t(i);
  }
  if (r.kind === 'enum') {
    const i = n.readU8();
    if (i >= r.values.length) throw new wn(`Enum index: ${i} is out of range`);
    const [o, a] = r.values[i],
      c = Eo(e, o, a, n);
    return new t({ [o]: c });
  }
  throw new wn(`Unexpected schema kind: ${r.kind} for ${t.constructor.name}`);
}
function L9(e, t, n, r = Fn) {
  const i = new r(n),
    o = p1(e, t, i);
  if (i.offset < n.length)
    throw new wn(`Unexpected ${n.length - i.offset} bytes after deserialized data`);
  return o;
}
var BT = (nn.deserialize = L9);
function z9(e, t, n, r = Fn) {
  const i = new r(n);
  return p1(e, t, i);
}
MT = nn.deserializeUnchecked = z9;
const [jT, NT, UT] = [[], [], []],
  F9 = BigInt(0),
  Ns = BigInt(1),
  $9 = BigInt(2),
  W9 = BigInt(7),
  V9 = BigInt(256),
  K9 = BigInt(113);
for (let e = 0, t = Ns, n = 1, r = 0; e < 24; e++) {
  ([n, r] = [r, (2 * n + 3 * r) % 5]),
    jT.push(2 * (5 * r + n)),
    NT.push((((e + 1) * (e + 2)) / 2) % 64);
  let i = F9;
  for (let o = 0; o < 7; o++)
    (t = ((t << Ns) ^ ((t >> W9) * K9)) % V9), t & $9 && (i ^= Ns << ((Ns << BigInt(o)) - Ns));
  UT.push(i);
}
const [H9, q9] = je.split(UT, !0),
  M_ = (e, t, n) => (n > 32 ? je.rotlBH(e, t, n) : je.rotlSH(e, t, n)),
  P_ = (e, t, n) => (n > 32 ? je.rotlBL(e, t, n) : je.rotlSL(e, t, n));
function G9(e, t = 24) {
  const n = new Uint32Array(10);
  for (let r = 24 - t; r < 24; r++) {
    for (let a = 0; a < 10; a++) n[a] = e[a] ^ e[a + 10] ^ e[a + 20] ^ e[a + 30] ^ e[a + 40];
    for (let a = 0; a < 10; a += 2) {
      const c = (a + 8) % 10,
        s = (a + 2) % 10,
        l = n[s],
        u = n[s + 1],
        d = M_(l, u, 1) ^ n[c],
        f = P_(l, u, 1) ^ n[c + 1];
      for (let p = 0; p < 50; p += 10) (e[a + p] ^= d), (e[a + p + 1] ^= f);
    }
    let i = e[2],
      o = e[3];
    for (let a = 0; a < 24; a++) {
      const c = NT[a],
        s = M_(i, o, c),
        l = P_(i, o, c),
        u = jT[a];
      (i = e[u]), (o = e[u + 1]), (e[u] = s), (e[u + 1] = l);
    }
    for (let a = 0; a < 50; a += 10) {
      for (let c = 0; c < 10; c++) n[c] = e[a + c];
      for (let c = 0; c < 10; c++) e[a + c] ^= ~n[(c + 2) % 10] & n[(c + 4) % 10];
    }
    (e[0] ^= H9[r]), (e[1] ^= q9[r]);
  }
  n.fill(0);
}
class tg extends h1 {
  constructor(t, n, r, i = !1, o = 24) {
    if (
      (super(),
      (this.blockLen = t),
      (this.suffix = n),
      (this.outputLen = r),
      (this.enableXOF = i),
      (this.rounds = o),
      (this.pos = 0),
      (this.posOut = 0),
      (this.finished = !1),
      (this.destroyed = !1),
      Bn.number(r),
      0 >= this.blockLen || this.blockLen >= 200)
    )
      throw new Error('Sha3 supports only keccak-f1600 function');
    (this.state = new Uint8Array(200)), (this.state32 = $j(this.state));
  }
  keccak() {
    G9(this.state32, this.rounds), (this.posOut = 0), (this.pos = 0);
  }
  update(t) {
    Bn.exists(this);
    const { blockLen: n, state: r } = this;
    t = Uc(t);
    const i = t.length;
    for (let o = 0; o < i; ) {
      const a = Math.min(n - this.pos, i - o);
      for (let c = 0; c < a; c++) r[this.pos++] ^= t[o++];
      this.pos === n && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = !0;
    const { state: t, suffix: n, pos: r, blockLen: i } = this;
    (t[r] ^= n), n & 128 && r === i - 1 && this.keccak(), (t[i - 1] ^= 128), this.keccak();
  }
  writeInto(t) {
    Bn.exists(this, !1), Bn.bytes(t), this.finish();
    const n = this.state,
      { blockLen: r } = this;
    for (let i = 0, o = t.length; i < o; ) {
      this.posOut >= r && this.keccak();
      const a = Math.min(r - this.posOut, o - i);
      t.set(n.subarray(this.posOut, this.posOut + a), i), (this.posOut += a), (i += a);
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF) throw new Error('XOF is not possible for this instance');
    return this.writeInto(t);
  }
  xof(t) {
    return Bn.number(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if ((Bn.output(t, this), this.finished)) throw new Error('digest() was already called');
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    (this.destroyed = !0), this.state.fill(0);
  }
  _cloneInto(t) {
    const { blockLen: n, suffix: r, outputLen: i, rounds: o, enableXOF: a } = this;
    return (
      t || (t = new tg(n, r, i, a, o)),
      t.state32.set(this.state32),
      (t.pos = this.pos),
      (t.posOut = this.posOut),
      (t.finished = this.finished),
      (t.rounds = o),
      (t.suffix = r),
      (t.outputLen = i),
      (t.enableXOF = a),
      (t.destroyed = this.destroyed),
      t
    );
  }
}
const fo = (e, t, n) => sa(() => new tg(t, e, n));
fo(6, 144, 224 / 8);
fo(6, 136, 256 / 8);
fo(6, 104, 384 / 8);
fo(6, 72, 512 / 8);
fo(1, 144, 224 / 8);
const O_ = fo(1, 136, 256 / 8);
fo(1, 104, 384 / 8);
fo(1, 72, 512 / 8);
const LT = (e, t, n) => Kj((r = {}) => new tg(t, e, r.dkLen === void 0 ? n : r.dkLen, !0));
LT(31, 168, 128 / 8);
LT(31, 136, 256 / 8);
let zT = class extends h1 {
  constructor(t, n) {
    super(), (this.finished = !1), (this.destroyed = !1), Bn.hash(t);
    const r = Uc(n);
    if (((this.iHash = t.create()), typeof this.iHash.update != 'function'))
      throw new TypeError('Expected instance of class which extends utils.Hash');
    (this.blockLen = this.iHash.blockLen), (this.outputLen = this.iHash.outputLen);
    const i = this.blockLen,
      o = new Uint8Array(i);
    o.set(r.length > i ? t.create().update(r).digest() : r);
    for (let a = 0; a < o.length; a++) o[a] ^= 54;
    this.iHash.update(o), (this.oHash = t.create());
    for (let a = 0; a < o.length; a++) o[a] ^= 106;
    this.oHash.update(o), o.fill(0);
  }
  update(t) {
    return Bn.exists(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    Bn.exists(this),
      Bn.bytes(t, this.outputLen),
      (this.finished = !0),
      this.iHash.digestInto(t),
      this.oHash.update(t),
      this.oHash.digestInto(t),
      this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n, iHash: r, finished: i, destroyed: o, blockLen: a, outputLen: c } = this;
    return (
      (t = t),
      (t.finished = i),
      (t.destroyed = o),
      (t.blockLen = a),
      (t.outputLen = c),
      (t.oHash = n._cloneInto(t.oHash)),
      (t.iHash = r._cloneInto(t.iHash)),
      t
    );
  }
  destroy() {
    (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
  }
};
const FT = (e, t, n) => new zT(e, t).update(n).digest();
FT.create = (e, t) => new zT(e, t);
Jh.sha512Sync = (...e) => w9(Jh.concatBytes(...e));
const Y9 = Jh.randomPrivateKey,
  D_ = () => {
    const e = Jh.randomPrivateKey(),
      t = sp(e),
      n = new Uint8Array(64);
    return n.set(e), n.set(t, 32), { publicKey: t, secretKey: n };
  },
  sp = F0.getPublicKey;
function R_(e) {
  try {
    return s4.fromHex(e, !0), !0;
  } catch {
    return !1;
  }
}
const g1 = (e, t) => F0.sign(e, t.slice(0, 32)),
  Z9 = F0.verify,
  Ke = (e) =>
    Ae.isBuffer(e)
      ? e
      : e instanceof Uint8Array
        ? Ae.from(e.buffer, e.byteOffset, e.byteLength)
        : Ae.from(e);
class y1 {
  constructor(t) {
    Object.assign(this, t);
  }
  encode() {
    return Ae.from(xT(oc, this));
  }
  static decode(t) {
    return BT(oc, this, t);
  }
  static decodeUnchecked(t) {
    return MT(oc, this, t);
  }
}
class Q9 extends y1 {
  constructor(t) {
    if ((super(t), (this.enum = ''), Object.keys(t).length !== 1))
      throw new Error('Enum can only take single value');
    Object.keys(t).map((n) => {
      this.enum = n;
    });
  }
}
const oc = new Map();
let $T;
const WT = 32,
  Nn = 32;
function J9(e) {
  return e._bn !== void 0;
}
let x_ = 1;
$T = Symbol.toStringTag;
let de = class Sa extends y1 {
  constructor(t) {
    if ((super({}), (this._bn = void 0), J9(t))) this._bn = t._bn;
    else {
      if (typeof t == 'string') {
        const n = an.decode(t);
        if (n.length != Nn) throw new Error('Invalid public key input');
        this._bn = new Zw(n);
      } else this._bn = new Zw(t);
      if (this._bn.byteLength() > Nn) throw new Error('Invalid public key input');
    }
  }
  static unique() {
    const t = new Sa(x_);
    return (x_ += 1), new Sa(t.toBuffer());
  }
  equals(t) {
    return this._bn.eq(t._bn);
  }
  toBase58() {
    return an.encode(this.toBytes());
  }
  toJSON() {
    return this.toBase58();
  }
  toBytes() {
    const t = this.toBuffer();
    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  }
  toBuffer() {
    const t = this._bn.toArrayLike(Ae);
    if (t.length === Nn) return t;
    const n = Ae.alloc(32);
    return t.copy(n, 32 - t.length), n;
  }
  get [$T]() {
    return `PublicKey(${this.toString()})`;
  }
  toString() {
    return this.toBase58();
  }
  static async createWithSeed(t, n, r) {
    const i = Ae.concat([t.toBuffer(), Ae.from(n), r.toBuffer()]),
      o = Lm(i);
    return new Sa(o);
  }
  static createProgramAddressSync(t, n) {
    let r = Ae.alloc(0);
    t.forEach(function (o) {
      if (o.length > WT) throw new TypeError('Max seed length exceeded');
      r = Ae.concat([r, Ke(o)]);
    }),
      (r = Ae.concat([r, n.toBuffer(), Ae.from('ProgramDerivedAddress')]));
    const i = Lm(r);
    if (R_(i)) throw new Error('Invalid seeds, address must fall off the curve');
    return new Sa(i);
  }
  static async createProgramAddress(t, n) {
    return this.createProgramAddressSync(t, n);
  }
  static findProgramAddressSync(t, n) {
    let r = 255,
      i;
    for (; r != 0; ) {
      try {
        const o = t.concat(Ae.from([r]));
        i = this.createProgramAddressSync(o, n);
      } catch (o) {
        if (o instanceof TypeError) throw o;
        r--;
        continue;
      }
      return [i, r];
    }
    throw new Error('Unable to find a viable program address nonce');
  }
  static async findProgramAddress(t, n) {
    return this.findProgramAddressSync(t, n);
  }
  static isOnCurve(t) {
    const n = new Sa(t);
    return R_(n.toBytes());
  }
};
de.default = new de('11111111111111111111111111111111');
oc.set(de, { kind: 'struct', fields: [['_bn', 'u256']] });
class X9 {
  constructor(t) {
    if (((this._publicKey = void 0), (this._secretKey = void 0), t)) {
      const n = Ke(t);
      if (t.length !== 64) throw new Error('bad secret key size');
      (this._publicKey = n.slice(32, 64)), (this._secretKey = n.slice(0, 32));
    } else (this._secretKey = Ke(Y9())), (this._publicKey = Ke(sp(this._secretKey)));
  }
  get publicKey() {
    return new de(this._publicKey);
  }
  get secretKey() {
    return Ae.concat([this._secretKey, this._publicKey], 64);
  }
}
const eN = new de('BPFLoader1111111111111111111111111111111111'),
  Qi = 1232,
  ng = 127,
  Ya = 64;
class b1 extends Error {
  constructor(t) {
    super(`Signature ${t} has expired: block height exceeded.`),
      (this.signature = void 0),
      (this.signature = t);
  }
}
Object.defineProperty(b1.prototype, 'name', {
  value: 'TransactionExpiredBlockheightExceededError',
});
class m1 extends Error {
  constructor(t, n) {
    super(
      `Transaction was not confirmed in ${n.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${t} using the Solana Explorer or CLI tools.`
    ),
      (this.signature = void 0),
      (this.signature = t);
  }
}
Object.defineProperty(m1.prototype, 'name', { value: 'TransactionExpiredTimeoutError' });
class Ea extends Error {
  constructor(t) {
    super(`Signature ${t} has expired: the nonce is no longer valid.`),
      (this.signature = void 0),
      (this.signature = t);
  }
}
Object.defineProperty(Ea.prototype, 'name', { value: 'TransactionExpiredNonceInvalidError' });
class uc {
  constructor(t, n) {
    (this.staticAccountKeys = void 0),
      (this.accountKeysFromLookups = void 0),
      (this.staticAccountKeys = t),
      (this.accountKeysFromLookups = n);
  }
  keySegments() {
    const t = [this.staticAccountKeys];
    return (
      this.accountKeysFromLookups &&
        (t.push(this.accountKeysFromLookups.writable),
        t.push(this.accountKeysFromLookups.readonly)),
      t
    );
  }
  get(t) {
    for (const n of this.keySegments()) {
      if (t < n.length) return n[t];
      t -= n.length;
    }
  }
  get length() {
    return this.keySegments().flat().length;
  }
  compileInstructions(t) {
    if (this.length > 256) throw new Error('Account index overflow encountered during compilation');
    const r = new Map();
    this.keySegments()
      .flat()
      .forEach((o, a) => {
        r.set(o.toBase58(), a);
      });
    const i = (o) => {
      const a = r.get(o.toBase58());
      if (a === void 0)
        throw new Error('Encountered an unknown instruction account key during compilation');
      return a;
    };
    return t.map((o) => ({
      programIdIndex: i(o.programId),
      accountKeyIndexes: o.keys.map((a) => i(a.pubkey)),
      data: o.data,
    }));
  }
}
const Ge = (e = 'publicKey') => It(32, e),
  tN = (e = 'signature') => It(64, e),
  Oo = (e = 'string') => {
    const t = me([we('length'), we('lengthPadding'), It(No(we(), -8), 'chars')], e),
      n = t.decode.bind(t),
      r = t.encode.bind(t),
      i = t;
    return (
      (i.decode = (o, a) => n(o, a).chars.toString()),
      (i.encode = (o, a, c) => {
        const s = { chars: Ae.from(o, 'utf8') };
        return r(s, a, c);
      }),
      (i.alloc = (o) => we().span + we().span + Ae.from(o, 'utf8').length),
      i
    );
  },
  nN = (e = 'authorized') => me([Ge('staker'), Ge('withdrawer')], e),
  rN = (e = 'lockup') => me([qn('unixTimestamp'), qn('epoch'), Ge('custodian')], e),
  iN = (e = 'voteInit') =>
    me([Ge('nodePubkey'), Ge('authorizedVoter'), Ge('authorizedWithdrawer'), et('commission')], e),
  oN = (e = 'voteAuthorizeWithSeedArgs') =>
    me(
      [
        we('voteAuthorizationType'),
        Ge('currentAuthorityDerivedKeyOwnerPubkey'),
        Oo('currentAuthorityDerivedKeySeed'),
        Ge('newAuthorized'),
      ],
      e
    );
function VT(e, t) {
  const n = (i) => {
    if (i.span >= 0) return i.span;
    if (typeof i.alloc == 'function') return i.alloc(t[i.property]);
    if ('count' in i && 'elementLayout' in i) {
      const o = t[i.property];
      if (Array.isArray(o)) return o.length * n(i.elementLayout);
    } else if ('fields' in i) return VT({ layout: i }, t[i.property]);
    return 0;
  };
  let r = 0;
  return (
    e.layout.fields.forEach((i) => {
      r += n(i);
    }),
    r
  );
}
function kn(e) {
  let t = 0,
    n = 0;
  for (;;) {
    let r = e.shift();
    if (((t |= (r & 127) << (n * 7)), (n += 1), !(r & 128))) break;
  }
  return t;
}
function xn(e, t) {
  let n = t;
  for (;;) {
    let r = n & 127;
    if (((n >>= 7), n == 0)) {
      e.push(r);
      break;
    } else (r |= 128), e.push(r);
  }
}
function ot(e, t) {
  if (!e) throw new Error(t || 'Assertion failed');
}
class rg {
  constructor(t, n) {
    (this.payer = void 0), (this.keyMetaMap = void 0), (this.payer = t), (this.keyMetaMap = n);
  }
  static compile(t, n) {
    const r = new Map(),
      i = (a) => {
        const c = a.toBase58();
        let s = r.get(c);
        return (
          s === void 0 && ((s = { isSigner: !1, isWritable: !1, isInvoked: !1 }), r.set(c, s)), s
        );
      },
      o = i(n);
    (o.isSigner = !0), (o.isWritable = !0);
    for (const a of t) {
      i(a.programId).isInvoked = !0;
      for (const c of a.keys) {
        const s = i(c.pubkey);
        s.isSigner || (s.isSigner = c.isSigner), s.isWritable || (s.isWritable = c.isWritable);
      }
    }
    return new rg(n, r);
  }
  getMessageComponents() {
    const t = [...this.keyMetaMap.entries()];
    ot(t.length <= 256, 'Max static account keys length exceeded');
    const n = t.filter(([, s]) => s.isSigner && s.isWritable),
      r = t.filter(([, s]) => s.isSigner && !s.isWritable),
      i = t.filter(([, s]) => !s.isSigner && s.isWritable),
      o = t.filter(([, s]) => !s.isSigner && !s.isWritable),
      a = {
        numRequiredSignatures: n.length + r.length,
        numReadonlySignedAccounts: r.length,
        numReadonlyUnsignedAccounts: o.length,
      };
    {
      ot(n.length > 0, 'Expected at least one writable signer key');
      const [s] = n[0];
      ot(s === this.payer.toBase58(), 'Expected first writable signer key to be the fee payer');
    }
    const c = [
      ...n.map(([s]) => new de(s)),
      ...r.map(([s]) => new de(s)),
      ...i.map(([s]) => new de(s)),
      ...o.map(([s]) => new de(s)),
    ];
    return [a, c];
  }
  extractTableLookup(t) {
    const [n, r] = this.drainKeysFoundInLookupTable(
        t.state.addresses,
        (a) => !a.isSigner && !a.isInvoked && a.isWritable
      ),
      [i, o] = this.drainKeysFoundInLookupTable(
        t.state.addresses,
        (a) => !a.isSigner && !a.isInvoked && !a.isWritable
      );
    if (!(n.length === 0 && i.length === 0))
      return [
        { accountKey: t.key, writableIndexes: n, readonlyIndexes: i },
        { writable: r, readonly: o },
      ];
  }
  drainKeysFoundInLookupTable(t, n) {
    const r = new Array(),
      i = new Array();
    for (const [o, a] of this.keyMetaMap.entries())
      if (n(a)) {
        const c = new de(o),
          s = t.findIndex((l) => l.equals(c));
        s >= 0 &&
          (ot(s < 256, 'Max lookup table index exceeded'),
          r.push(s),
          i.push(c),
          this.keyMetaMap.delete(o));
      }
    return [r, i];
  }
}
class mr {
  constructor(t) {
    (this.header = void 0),
      (this.accountKeys = void 0),
      (this.recentBlockhash = void 0),
      (this.instructions = void 0),
      (this.indexToProgramIds = new Map()),
      (this.header = t.header),
      (this.accountKeys = t.accountKeys.map((n) => new de(n))),
      (this.recentBlockhash = t.recentBlockhash),
      (this.instructions = t.instructions),
      this.instructions.forEach((n) =>
        this.indexToProgramIds.set(n.programIdIndex, this.accountKeys[n.programIdIndex])
      );
  }
  get version() {
    return 'legacy';
  }
  get staticAccountKeys() {
    return this.accountKeys;
  }
  get compiledInstructions() {
    return this.instructions.map((t) => ({
      programIdIndex: t.programIdIndex,
      accountKeyIndexes: t.accounts,
      data: an.decode(t.data),
    }));
  }
  get addressTableLookups() {
    return [];
  }
  getAccountKeys() {
    return new uc(this.staticAccountKeys);
  }
  static compile(t) {
    const n = rg.compile(t.instructions, t.payerKey),
      [r, i] = n.getMessageComponents(),
      a = new uc(i)
        .compileInstructions(t.instructions)
        .map((c) => ({
          programIdIndex: c.programIdIndex,
          accounts: c.accountKeyIndexes,
          data: an.encode(c.data),
        }));
    return new mr({
      header: r,
      accountKeys: i,
      recentBlockhash: t.recentBlockhash,
      instructions: a,
    });
  }
  isAccountSigner(t) {
    return t < this.header.numRequiredSignatures;
  }
  isAccountWritable(t) {
    const n = this.header.numRequiredSignatures;
    if (t >= this.header.numRequiredSignatures) {
      const r = t - n,
        o = this.accountKeys.length - n - this.header.numReadonlyUnsignedAccounts;
      return r < o;
    } else {
      const r = n - this.header.numReadonlySignedAccounts;
      return t < r;
    }
  }
  isProgramId(t) {
    return this.indexToProgramIds.has(t);
  }
  programIds() {
    return [...this.indexToProgramIds.values()];
  }
  nonProgramIds() {
    return this.accountKeys.filter((t, n) => !this.isProgramId(n));
  }
  serialize() {
    const t = this.accountKeys.length;
    let n = [];
    xn(n, t);
    const r = this.instructions.map((d) => {
      const { accounts: f, programIdIndex: p } = d,
        y = Array.from(an.decode(d.data));
      let b = [];
      xn(b, f.length);
      let m = [];
      return (
        xn(m, y.length),
        {
          programIdIndex: p,
          keyIndicesCount: Ae.from(b),
          keyIndices: f,
          dataLength: Ae.from(m),
          data: y,
        }
      );
    });
    let i = [];
    xn(i, r.length);
    let o = Ae.alloc(Qi);
    Ae.from(i).copy(o);
    let a = i.length;
    r.forEach((d) => {
      const p = me([
        et('programIdIndex'),
        It(d.keyIndicesCount.length, 'keyIndicesCount'),
        fn(et('keyIndex'), d.keyIndices.length, 'keyIndices'),
        It(d.dataLength.length, 'dataLength'),
        fn(et('userdatum'), d.data.length, 'data'),
      ]).encode(d, o, a);
      a += p;
    }),
      (o = o.slice(0, a));
    const c = me([
        It(1, 'numRequiredSignatures'),
        It(1, 'numReadonlySignedAccounts'),
        It(1, 'numReadonlyUnsignedAccounts'),
        It(n.length, 'keyCount'),
        fn(Ge('key'), t, 'keys'),
        Ge('recentBlockhash'),
      ]),
      s = {
        numRequiredSignatures: Ae.from([this.header.numRequiredSignatures]),
        numReadonlySignedAccounts: Ae.from([this.header.numReadonlySignedAccounts]),
        numReadonlyUnsignedAccounts: Ae.from([this.header.numReadonlyUnsignedAccounts]),
        keyCount: Ae.from(n),
        keys: this.accountKeys.map((d) => Ke(d.toBytes())),
        recentBlockhash: an.decode(this.recentBlockhash),
      };
    let l = Ae.alloc(2048);
    const u = c.encode(s, l);
    return o.copy(l, u), l.slice(0, u + o.length);
  }
  static from(t) {
    let n = [...t];
    const r = n.shift();
    if (r !== (r & ng))
      throw new Error(
        'Versioned messages must be deserialized with VersionedMessage.deserialize()'
      );
    const i = n.shift(),
      o = n.shift(),
      a = kn(n);
    let c = [];
    for (let f = 0; f < a; f++) {
      const p = n.slice(0, Nn);
      (n = n.slice(Nn)), c.push(new de(Ae.from(p)));
    }
    const s = n.slice(0, Nn);
    n = n.slice(Nn);
    const l = kn(n);
    let u = [];
    for (let f = 0; f < l; f++) {
      const p = n.shift(),
        y = kn(n),
        b = n.slice(0, y);
      n = n.slice(y);
      const m = kn(n),
        w = n.slice(0, m),
        _ = an.encode(Ae.from(w));
      (n = n.slice(m)), u.push({ programIdIndex: p, accounts: b, data: _ });
    }
    const d = {
      header: {
        numRequiredSignatures: r,
        numReadonlySignedAccounts: i,
        numReadonlyUnsignedAccounts: o,
      },
      recentBlockhash: an.encode(Ae.from(s)),
      accountKeys: c,
      instructions: u,
    };
    return new mr(d);
  }
}
class Wo {
  constructor(t) {
    (this.header = void 0),
      (this.staticAccountKeys = void 0),
      (this.recentBlockhash = void 0),
      (this.compiledInstructions = void 0),
      (this.addressTableLookups = void 0),
      (this.header = t.header),
      (this.staticAccountKeys = t.staticAccountKeys),
      (this.recentBlockhash = t.recentBlockhash),
      (this.compiledInstructions = t.compiledInstructions),
      (this.addressTableLookups = t.addressTableLookups);
  }
  get version() {
    return 0;
  }
  get numAccountKeysFromLookups() {
    let t = 0;
    for (const n of this.addressTableLookups)
      t += n.readonlyIndexes.length + n.writableIndexes.length;
    return t;
  }
  getAccountKeys(t) {
    let n;
    if (t && 'accountKeysFromLookups' in t && t.accountKeysFromLookups) {
      if (
        this.numAccountKeysFromLookups !=
        t.accountKeysFromLookups.writable.length + t.accountKeysFromLookups.readonly.length
      )
        throw new Error(
          'Failed to get account keys because of a mismatch in the number of account keys from lookups'
        );
      n = t.accountKeysFromLookups;
    } else if (t && 'addressLookupTableAccounts' in t && t.addressLookupTableAccounts)
      n = this.resolveAddressTableLookups(t.addressLookupTableAccounts);
    else if (this.addressTableLookups.length > 0)
      throw new Error('Failed to get account keys because address table lookups were not resolved');
    return new uc(this.staticAccountKeys, n);
  }
  isAccountSigner(t) {
    return t < this.header.numRequiredSignatures;
  }
  isAccountWritable(t) {
    const n = this.header.numRequiredSignatures,
      r = this.staticAccountKeys.length;
    if (t >= r) {
      const i = t - r,
        o = this.addressTableLookups.reduce((a, c) => a + c.writableIndexes.length, 0);
      return i < o;
    } else if (t >= this.header.numRequiredSignatures) {
      const i = t - n,
        a = r - n - this.header.numReadonlyUnsignedAccounts;
      return i < a;
    } else {
      const i = n - this.header.numReadonlySignedAccounts;
      return t < i;
    }
  }
  resolveAddressTableLookups(t) {
    const n = { writable: [], readonly: [] };
    for (const r of this.addressTableLookups) {
      const i = t.find((o) => o.key.equals(r.accountKey));
      if (!i)
        throw new Error(
          `Failed to find address lookup table account for table key ${r.accountKey.toBase58()}`
        );
      for (const o of r.writableIndexes)
        if (o < i.state.addresses.length) n.writable.push(i.state.addresses[o]);
        else
          throw new Error(
            `Failed to find address for index ${o} in address lookup table ${r.accountKey.toBase58()}`
          );
      for (const o of r.readonlyIndexes)
        if (o < i.state.addresses.length) n.readonly.push(i.state.addresses[o]);
        else
          throw new Error(
            `Failed to find address for index ${o} in address lookup table ${r.accountKey.toBase58()}`
          );
    }
    return n;
  }
  static compile(t) {
    const n = rg.compile(t.instructions, t.payerKey),
      r = new Array(),
      i = { writable: new Array(), readonly: new Array() },
      o = t.addressLookupTableAccounts || [];
    for (const u of o) {
      const d = n.extractTableLookup(u);
      if (d !== void 0) {
        const [f, { writable: p, readonly: y }] = d;
        r.push(f), i.writable.push(...p), i.readonly.push(...y);
      }
    }
    const [a, c] = n.getMessageComponents(),
      l = new uc(c, i).compileInstructions(t.instructions);
    return new Wo({
      header: a,
      staticAccountKeys: c,
      recentBlockhash: t.recentBlockhash,
      compiledInstructions: l,
      addressTableLookups: r,
    });
  }
  serialize() {
    const t = Array();
    xn(t, this.staticAccountKeys.length);
    const n = this.serializeInstructions(),
      r = Array();
    xn(r, this.compiledInstructions.length);
    const i = this.serializeAddressTableLookups(),
      o = Array();
    xn(o, this.addressTableLookups.length);
    const a = me([
        et('prefix'),
        me(
          [
            et('numRequiredSignatures'),
            et('numReadonlySignedAccounts'),
            et('numReadonlyUnsignedAccounts'),
          ],
          'header'
        ),
        It(t.length, 'staticAccountKeysLength'),
        fn(Ge(), this.staticAccountKeys.length, 'staticAccountKeys'),
        Ge('recentBlockhash'),
        It(r.length, 'instructionsLength'),
        It(n.length, 'serializedInstructions'),
        It(o.length, 'addressTableLookupsLength'),
        It(i.length, 'serializedAddressTableLookups'),
      ]),
      c = new Uint8Array(Qi),
      l = a.encode(
        {
          prefix: 128,
          header: this.header,
          staticAccountKeysLength: new Uint8Array(t),
          staticAccountKeys: this.staticAccountKeys.map((u) => u.toBytes()),
          recentBlockhash: an.decode(this.recentBlockhash),
          instructionsLength: new Uint8Array(r),
          serializedInstructions: n,
          addressTableLookupsLength: new Uint8Array(o),
          serializedAddressTableLookups: i,
        },
        c
      );
    return c.slice(0, l);
  }
  serializeInstructions() {
    let t = 0;
    const n = new Uint8Array(Qi);
    for (const r of this.compiledInstructions) {
      const i = Array();
      xn(i, r.accountKeyIndexes.length);
      const o = Array();
      xn(o, r.data.length);
      const a = me([
        et('programIdIndex'),
        It(i.length, 'encodedAccountKeyIndexesLength'),
        fn(et(), r.accountKeyIndexes.length, 'accountKeyIndexes'),
        It(o.length, 'encodedDataLength'),
        It(r.data.length, 'data'),
      ]);
      t += a.encode(
        {
          programIdIndex: r.programIdIndex,
          encodedAccountKeyIndexesLength: new Uint8Array(i),
          accountKeyIndexes: r.accountKeyIndexes,
          encodedDataLength: new Uint8Array(o),
          data: r.data,
        },
        n,
        t
      );
    }
    return n.slice(0, t);
  }
  serializeAddressTableLookups() {
    let t = 0;
    const n = new Uint8Array(Qi);
    for (const r of this.addressTableLookups) {
      const i = Array();
      xn(i, r.writableIndexes.length);
      const o = Array();
      xn(o, r.readonlyIndexes.length);
      const a = me([
        Ge('accountKey'),
        It(i.length, 'encodedWritableIndexesLength'),
        fn(et(), r.writableIndexes.length, 'writableIndexes'),
        It(o.length, 'encodedReadonlyIndexesLength'),
        fn(et(), r.readonlyIndexes.length, 'readonlyIndexes'),
      ]);
      t += a.encode(
        {
          accountKey: r.accountKey.toBytes(),
          encodedWritableIndexesLength: new Uint8Array(i),
          writableIndexes: r.writableIndexes,
          encodedReadonlyIndexesLength: new Uint8Array(o),
          readonlyIndexes: r.readonlyIndexes,
        },
        n,
        t
      );
    }
    return n.slice(0, t);
  }
  static deserialize(t) {
    let n = [...t];
    const r = n.shift(),
      i = r & ng;
    ot(r !== i, 'Expected versioned message but received legacy message');
    const o = i;
    ot(o === 0, `Expected versioned message with version 0 but found version ${o}`);
    const a = {
        numRequiredSignatures: n.shift(),
        numReadonlySignedAccounts: n.shift(),
        numReadonlyUnsignedAccounts: n.shift(),
      },
      c = [],
      s = kn(n);
    for (let y = 0; y < s; y++) c.push(new de(n.splice(0, Nn)));
    const l = an.encode(n.splice(0, Nn)),
      u = kn(n),
      d = [];
    for (let y = 0; y < u; y++) {
      const b = n.shift(),
        m = kn(n),
        w = n.splice(0, m),
        _ = kn(n),
        S = new Uint8Array(n.splice(0, _));
      d.push({ programIdIndex: b, accountKeyIndexes: w, data: S });
    }
    const f = kn(n),
      p = [];
    for (let y = 0; y < f; y++) {
      const b = new de(n.splice(0, Nn)),
        m = kn(n),
        w = n.splice(0, m),
        _ = kn(n),
        S = n.splice(0, _);
      p.push({ accountKey: b, writableIndexes: w, readonlyIndexes: S });
    }
    return new Wo({
      header: a,
      staticAccountKeys: c,
      recentBlockhash: l,
      compiledInstructions: d,
      addressTableLookups: p,
    });
  }
}
const w1 = {
  deserializeMessageVersion(e) {
    const t = e[0],
      n = t & ng;
    return n === t ? 'legacy' : n;
  },
  deserialize: (e) => {
    const t = w1.deserializeMessageVersion(e);
    if (t === 'legacy') return mr.from(e);
    if (t === 0) return Wo.deserialize(e);
    throw new Error(`Transaction message version ${t} deserialization is not supported`);
  },
};
let rr;
(function (e) {
  (e[(e.BLOCKHEIGHT_EXCEEDED = 0)] = 'BLOCKHEIGHT_EXCEEDED'),
    (e[(e.PROCESSED = 1)] = 'PROCESSED'),
    (e[(e.TIMED_OUT = 2)] = 'TIMED_OUT'),
    (e[(e.NONCE_INVALID = 3)] = 'NONCE_INVALID');
})(rr || (rr = {}));
const aN = Ae.alloc(Ya).fill(0);
class bt {
  constructor(t) {
    (this.keys = void 0),
      (this.programId = void 0),
      (this.data = Ae.alloc(0)),
      (this.programId = t.programId),
      (this.keys = t.keys),
      t.data && (this.data = t.data);
  }
  toJSON() {
    return {
      keys: this.keys.map(({ pubkey: t, isSigner: n, isWritable: r }) => ({
        pubkey: t.toJSON(),
        isSigner: n,
        isWritable: r,
      })),
      programId: this.programId.toJSON(),
      data: [...this.data],
    };
  }
}
let yt = class zm {
  get signature() {
    return this.signatures.length > 0 ? this.signatures[0].signature : null;
  }
  constructor(t) {
    if (
      ((this.signatures = []),
      (this.feePayer = void 0),
      (this.instructions = []),
      (this.recentBlockhash = void 0),
      (this.lastValidBlockHeight = void 0),
      (this.nonceInfo = void 0),
      (this.minNonceContextSlot = void 0),
      (this._message = void 0),
      (this._json = void 0),
      !!t)
    )
      if (
        (t.feePayer && (this.feePayer = t.feePayer),
        t.signatures && (this.signatures = t.signatures),
        Object.prototype.hasOwnProperty.call(t, 'nonceInfo'))
      ) {
        const { minContextSlot: n, nonceInfo: r } = t;
        (this.minNonceContextSlot = n), (this.nonceInfo = r);
      } else if (Object.prototype.hasOwnProperty.call(t, 'lastValidBlockHeight')) {
        const { blockhash: n, lastValidBlockHeight: r } = t;
        (this.recentBlockhash = n), (this.lastValidBlockHeight = r);
      } else {
        const { recentBlockhash: n, nonceInfo: r } = t;
        r && (this.nonceInfo = r), (this.recentBlockhash = n);
      }
  }
  toJSON() {
    return {
      recentBlockhash: this.recentBlockhash || null,
      feePayer: this.feePayer ? this.feePayer.toJSON() : null,
      nonceInfo: this.nonceInfo
        ? {
            nonce: this.nonceInfo.nonce,
            nonceInstruction: this.nonceInfo.nonceInstruction.toJSON(),
          }
        : null,
      instructions: this.instructions.map((t) => t.toJSON()),
      signers: this.signatures.map(({ publicKey: t }) => t.toJSON()),
    };
  }
  add(...t) {
    if (t.length === 0) throw new Error('No instructions');
    return (
      t.forEach((n) => {
        'instructions' in n
          ? (this.instructions = this.instructions.concat(n.instructions))
          : 'data' in n && 'programId' in n && 'keys' in n
            ? this.instructions.push(n)
            : this.instructions.push(new bt(n));
      }),
      this
    );
  }
  compileMessage() {
    if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json))
      return this._message;
    let t, n;
    if (
      (this.nonceInfo
        ? ((t = this.nonceInfo.nonce),
          this.instructions[0] != this.nonceInfo.nonceInstruction
            ? (n = [this.nonceInfo.nonceInstruction, ...this.instructions])
            : (n = this.instructions))
        : ((t = this.recentBlockhash), (n = this.instructions)),
      !t)
    )
      throw new Error('Transaction recentBlockhash required');
    n.length < 1 && console.warn('No instructions provided');
    let r;
    if (this.feePayer) r = this.feePayer;
    else if (this.signatures.length > 0 && this.signatures[0].publicKey)
      r = this.signatures[0].publicKey;
    else throw new Error('Transaction fee payer required');
    for (let b = 0; b < n.length; b++)
      if (n[b].programId === void 0)
        throw new Error(`Transaction instruction index ${b} has undefined program id`);
    const i = [],
      o = [];
    n.forEach((b) => {
      b.keys.forEach((w) => {
        o.push({ ...w });
      });
      const m = b.programId.toString();
      i.includes(m) || i.push(m);
    }),
      i.forEach((b) => {
        o.push({ pubkey: new de(b), isSigner: !1, isWritable: !1 });
      });
    const a = [];
    o.forEach((b) => {
      const m = b.pubkey.toString(),
        w = a.findIndex((_) => _.pubkey.toString() === m);
      w > -1
        ? ((a[w].isWritable = a[w].isWritable || b.isWritable),
          (a[w].isSigner = a[w].isSigner || b.isSigner))
        : a.push(b);
    }),
      a.sort(function (b, m) {
        return b.isSigner !== m.isSigner
          ? b.isSigner
            ? -1
            : 1
          : b.isWritable !== m.isWritable
            ? b.isWritable
              ? -1
              : 1
            : b.pubkey.toBase58().localeCompare(m.pubkey.toBase58());
      });
    const c = a.findIndex((b) => b.pubkey.equals(r));
    if (c > -1) {
      const [b] = a.splice(c, 1);
      (b.isSigner = !0), (b.isWritable = !0), a.unshift(b);
    } else a.unshift({ pubkey: r, isSigner: !0, isWritable: !0 });
    for (const b of this.signatures) {
      const m = a.findIndex((w) => w.pubkey.equals(b.publicKey));
      if (m > -1)
        a[m].isSigner ||
          ((a[m].isSigner = !0),
          console.warn(
            'Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release.'
          ));
      else throw new Error(`unknown signer: ${b.publicKey.toString()}`);
    }
    let s = 0,
      l = 0,
      u = 0;
    const d = [],
      f = [];
    a.forEach(({ pubkey: b, isSigner: m, isWritable: w }) => {
      m ? (d.push(b.toString()), (s += 1), w || (l += 1)) : (f.push(b.toString()), w || (u += 1));
    });
    const p = d.concat(f),
      y = n.map((b) => {
        const { data: m, programId: w } = b;
        return {
          programIdIndex: p.indexOf(w.toString()),
          accounts: b.keys.map((_) => p.indexOf(_.pubkey.toString())),
          data: an.encode(m),
        };
      });
    return (
      y.forEach((b) => {
        ot(b.programIdIndex >= 0), b.accounts.forEach((m) => ot(m >= 0));
      }),
      new mr({
        header: {
          numRequiredSignatures: s,
          numReadonlySignedAccounts: l,
          numReadonlyUnsignedAccounts: u,
        },
        accountKeys: p,
        recentBlockhash: t,
        instructions: y,
      })
    );
  }
  _compile() {
    const t = this.compileMessage(),
      n = t.accountKeys.slice(0, t.header.numRequiredSignatures);
    return (
      (this.signatures.length === n.length &&
        this.signatures.every((i, o) => n[o].equals(i.publicKey))) ||
        (this.signatures = n.map((r) => ({ signature: null, publicKey: r }))),
      t
    );
  }
  serializeMessage() {
    return this._compile().serialize();
  }
  async getEstimatedFee(t) {
    return (await t.getFeeForMessage(this.compileMessage())).value;
  }
  setSigners(...t) {
    if (t.length === 0) throw new Error('No signers');
    const n = new Set();
    this.signatures = t
      .filter((r) => {
        const i = r.toString();
        return n.has(i) ? !1 : (n.add(i), !0);
      })
      .map((r) => ({ signature: null, publicKey: r }));
  }
  sign(...t) {
    if (t.length === 0) throw new Error('No signers');
    const n = new Set(),
      r = [];
    for (const o of t) {
      const a = o.publicKey.toString();
      n.has(a) || (n.add(a), r.push(o));
    }
    this.signatures = r.map((o) => ({ signature: null, publicKey: o.publicKey }));
    const i = this._compile();
    this._partialSign(i, ...r);
  }
  partialSign(...t) {
    if (t.length === 0) throw new Error('No signers');
    const n = new Set(),
      r = [];
    for (const o of t) {
      const a = o.publicKey.toString();
      n.has(a) || (n.add(a), r.push(o));
    }
    const i = this._compile();
    this._partialSign(i, ...r);
  }
  _partialSign(t, ...n) {
    const r = t.serialize();
    n.forEach((i) => {
      const o = g1(r, i.secretKey);
      this._addSignature(i.publicKey, Ke(o));
    });
  }
  addSignature(t, n) {
    this._compile(), this._addSignature(t, n);
  }
  _addSignature(t, n) {
    ot(n.length === 64);
    const r = this.signatures.findIndex((i) => t.equals(i.publicKey));
    if (r < 0) throw new Error(`unknown signer: ${t.toString()}`);
    this.signatures[r].signature = Ae.from(n);
  }
  verifySignatures(t) {
    return this._verifySignatures(this.serializeMessage(), t === void 0 ? !0 : t);
  }
  _verifySignatures(t, n) {
    for (const { signature: r, publicKey: i } of this.signatures)
      if (r === null) {
        if (n) return !1;
      } else if (!Z9(r, t, i.toBytes())) return !1;
    return !0;
  }
  serialize(t) {
    const { requireAllSignatures: n, verifySignatures: r } = Object.assign(
        { requireAllSignatures: !0, verifySignatures: !0 },
        t
      ),
      i = this.serializeMessage();
    if (r && !this._verifySignatures(i, n)) throw new Error('Signature verification failed');
    return this._serialize(i);
  }
  _serialize(t) {
    const { signatures: n } = this,
      r = [];
    xn(r, n.length);
    const i = r.length + n.length * 64 + t.length,
      o = Ae.alloc(i);
    return (
      ot(n.length < 256),
      Ae.from(r).copy(o, 0),
      n.forEach(({ signature: a }, c) => {
        a !== null &&
          (ot(a.length === 64, 'signature has invalid length'),
          Ae.from(a).copy(o, r.length + c * 64));
      }),
      t.copy(o, r.length + n.length * 64),
      ot(o.length <= Qi, `Transaction too large: ${o.length} > ${Qi}`),
      o
    );
  }
  get keys() {
    return ot(this.instructions.length === 1), this.instructions[0].keys.map((t) => t.pubkey);
  }
  get programId() {
    return ot(this.instructions.length === 1), this.instructions[0].programId;
  }
  get data() {
    return ot(this.instructions.length === 1), this.instructions[0].data;
  }
  static from(t) {
    let n = [...t];
    const r = kn(n);
    let i = [];
    for (let o = 0; o < r; o++) {
      const a = n.slice(0, Ya);
      (n = n.slice(Ya)), i.push(an.encode(Ae.from(a)));
    }
    return zm.populate(mr.from(n), i);
  }
  static populate(t, n = []) {
    const r = new zm();
    return (
      (r.recentBlockhash = t.recentBlockhash),
      t.header.numRequiredSignatures > 0 && (r.feePayer = t.accountKeys[0]),
      n.forEach((i, o) => {
        const a = {
          signature: i == an.encode(aN) ? null : an.decode(i),
          publicKey: t.accountKeys[o],
        };
        r.signatures.push(a);
      }),
      t.instructions.forEach((i) => {
        const o = i.accounts.map((a) => {
          const c = t.accountKeys[a];
          return {
            pubkey: c,
            isSigner:
              r.signatures.some((s) => s.publicKey.toString() === c.toString()) ||
              t.isAccountSigner(a),
            isWritable: t.isAccountWritable(a),
          };
        });
        r.instructions.push(
          new bt({ keys: o, programId: t.accountKeys[i.programIdIndex], data: an.decode(i.data) })
        );
      }),
      (r._message = t),
      (r._json = r.toJSON()),
      r
    );
  }
};
class _1 {
  constructor(t) {
    (this.payerKey = void 0),
      (this.instructions = void 0),
      (this.recentBlockhash = void 0),
      (this.payerKey = t.payerKey),
      (this.instructions = t.instructions),
      (this.recentBlockhash = t.recentBlockhash);
  }
  static decompile(t, n) {
    const { header: r, compiledInstructions: i, recentBlockhash: o } = t,
      {
        numRequiredSignatures: a,
        numReadonlySignedAccounts: c,
        numReadonlyUnsignedAccounts: s,
      } = r,
      l = a - c;
    ot(l > 0, 'Message header is invalid');
    const u = t.staticAccountKeys.length - a - s;
    ot(u >= 0, 'Message header is invalid');
    const d = t.getAccountKeys(n),
      f = d.get(0);
    if (f === void 0)
      throw new Error('Failed to decompile message because no account keys were found');
    const p = [];
    for (const y of i) {
      const b = [];
      for (const w of y.accountKeyIndexes) {
        const _ = d.get(w);
        if (_ === void 0) throw new Error(`Failed to find key for account key index ${w}`);
        const S = w < a;
        let E;
        S
          ? (E = w < l)
          : w < d.staticAccountKeys.length
            ? (E = w - a < u)
            : (E = w - d.staticAccountKeys.length < d.accountKeysFromLookups.writable.length),
          b.push({ pubkey: _, isSigner: w < r.numRequiredSignatures, isWritable: E });
      }
      const m = d.get(y.programIdIndex);
      if (m === void 0)
        throw new Error(`Failed to find program id for program id index ${y.programIdIndex}`);
      p.push(new bt({ programId: m, data: Ke(y.data), keys: b }));
    }
    return new _1({ payerKey: f, instructions: p, recentBlockhash: o });
  }
  compileToLegacyMessage() {
    return mr.compile({
      payerKey: this.payerKey,
      recentBlockhash: this.recentBlockhash,
      instructions: this.instructions,
    });
  }
  compileToV0Message(t) {
    return Wo.compile({
      payerKey: this.payerKey,
      recentBlockhash: this.recentBlockhash,
      instructions: this.instructions,
      addressLookupTableAccounts: t,
    });
  }
}
class v1 {
  get version() {
    return this.message.version;
  }
  constructor(t, n) {
    if (((this.signatures = void 0), (this.message = void 0), n !== void 0))
      ot(
        n.length === t.header.numRequiredSignatures,
        'Expected signatures length to be equal to the number of required signatures'
      ),
        (this.signatures = n);
    else {
      const r = [];
      for (let i = 0; i < t.header.numRequiredSignatures; i++) r.push(new Uint8Array(Ya));
      this.signatures = r;
    }
    this.message = t;
  }
  serialize() {
    const t = this.message.serialize(),
      n = Array();
    xn(n, this.signatures.length);
    const r = me([
        It(n.length, 'encodedSignaturesLength'),
        fn(tN(), this.signatures.length, 'signatures'),
        It(t.length, 'serializedMessage'),
      ]),
      i = new Uint8Array(2048),
      o = r.encode(
        {
          encodedSignaturesLength: new Uint8Array(n),
          signatures: this.signatures,
          serializedMessage: t,
        },
        i
      );
    return i.slice(0, o);
  }
  static deserialize(t) {
    let n = [...t];
    const r = [],
      i = kn(n);
    for (let a = 0; a < i; a++) r.push(new Uint8Array(n.splice(0, Ya)));
    const o = w1.deserialize(new Uint8Array(n));
    return new v1(o, r);
  }
  sign(t) {
    const n = this.message.serialize(),
      r = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
    for (const i of t) {
      const o = r.findIndex((a) => a.equals(i.publicKey));
      ot(o >= 0, `Cannot sign with non signer key ${i.publicKey.toBase58()}`),
        (this.signatures[o] = g1(n, i.secretKey));
    }
  }
  addSignature(t, n) {
    ot(n.byteLength === 64, 'Signature must be 64 bytes long');
    const i = this.message.staticAccountKeys
      .slice(0, this.message.header.numRequiredSignatures)
      .findIndex((o) => o.equals(t));
    ot(
      i >= 0,
      `Can not add signature; \`${t.toBase58()}\` is not required to sign this transaction`
    ),
      (this.signatures[i] = n);
  }
}
const Rr = new de('SysvarC1ock11111111111111111111111111111111'),
  sN = new de('SysvarEpochSchedu1e111111111111111111111111'),
  cN = new de('Sysvar1nstructions1111111111111111111111111'),
  Ph = new de('SysvarRecentB1ockHashes11111111111111111111'),
  Za = new de('SysvarRent111111111111111111111111111111111'),
  uN = new de('SysvarRewards111111111111111111111111111111'),
  lN = new de('SysvarS1otHashes111111111111111111111111111'),
  dN = new de('SysvarS1otHistory11111111111111111111111111'),
  Oh = new de('SysvarStakeHistory1111111111111111111111111');
async function Dh(e, t, n, r) {
  const i = r && {
      skipPreflight: r.skipPreflight,
      preflightCommitment: r.preflightCommitment || r.commitment,
      maxRetries: r.maxRetries,
      minContextSlot: r.minContextSlot,
    },
    o = await e.sendTransaction(t, n, i);
  let a;
  if (t.recentBlockhash != null && t.lastValidBlockHeight != null)
    a = (
      await e.confirmTransaction(
        {
          abortSignal: r == null ? void 0 : r.abortSignal,
          signature: o,
          blockhash: t.recentBlockhash,
          lastValidBlockHeight: t.lastValidBlockHeight,
        },
        r && r.commitment
      )
    ).value;
  else if (t.minNonceContextSlot != null && t.nonceInfo != null) {
    const { nonceInstruction: c } = t.nonceInfo,
      s = c.keys[0].pubkey;
    a = (
      await e.confirmTransaction(
        {
          abortSignal: r == null ? void 0 : r.abortSignal,
          minContextSlot: t.minNonceContextSlot,
          nonceAccountPubkey: s,
          nonceValue: t.nonceInfo.nonce,
          signature: o,
        },
        r && r.commitment
      )
    ).value;
  } else
    (r == null ? void 0 : r.abortSignal) != null &&
      console.warn(
        'sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.'
      ),
      (a = (await e.confirmTransaction(o, r && r.commitment)).value);
  if (a.err) throw new Error(`Transaction ${o} failed (${JSON.stringify(a)})`);
  return o;
}
function To(e) {
  return new Promise((t) => setTimeout(t, e));
}
function tt(e, t) {
  const n = e.layout.span >= 0 ? e.layout.span : VT(e, t),
    r = Ae.alloc(n),
    i = Object.assign({ instruction: e.index }, t);
  return e.layout.encode(i, r), r;
}
function ut(e, t) {
  let n;
  try {
    n = e.layout.decode(t);
  } catch (r) {
    throw new Error('invalid instruction; ' + r);
  }
  if (n.instruction !== e.index)
    throw new Error(
      `invalid instruction; instruction index mismatch ${n.instruction} != ${e.index}`
    );
  return n;
}
const KT = un('lamportsPerSignature'),
  HT = me([
    we('version'),
    we('state'),
    Ge('authorizedPubkey'),
    Ge('nonce'),
    me([KT], 'feeCalculator'),
  ]),
  Fm = HT.span;
class ig {
  constructor(t) {
    (this.authorizedPubkey = void 0),
      (this.nonce = void 0),
      (this.feeCalculator = void 0),
      (this.authorizedPubkey = t.authorizedPubkey),
      (this.nonce = t.nonce),
      (this.feeCalculator = t.feeCalculator);
  }
  static fromAccountData(t) {
    const n = HT.decode(Ke(t), 0);
    return new ig({
      authorizedPubkey: new de(n.authorizedPubkey),
      nonce: new de(n.nonce).toString(),
      feeCalculator: n.feeCalculator,
    });
  }
}
const fN = (e) => {
    const t = e.decode.bind(e),
      n = e.encode.bind(e);
    return { decode: t, encode: n };
  },
  hN = (e) => (t) => {
    const n = It(e, t),
      { encode: r, decode: i } = fN(n),
      o = n;
    return (
      (o.decode = (a, c) => {
        const s = i(a, c);
        return c4(Ae.from(s));
      }),
      (o.encode = (a, c, s) => {
        const l = _I(a, e);
        return r(l, c, s);
      }),
      o
    );
  },
  Qa = hN(8);
class pN {
  constructor() {}
  static decodeInstructionType(t) {
    this.checkProgramId(t.programId);
    const r = we('instruction').decode(t.data);
    let i;
    for (const [o, a] of Object.entries(wt))
      if (a.index == r) {
        i = o;
        break;
      }
    if (!i) throw new Error('Instruction type incorrect; not a SystemInstruction');
    return i;
  }
  static decodeCreateAccount(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
    const { lamports: n, space: r, programId: i } = ut(wt.Create, t.data);
    return {
      fromPubkey: t.keys[0].pubkey,
      newAccountPubkey: t.keys[1].pubkey,
      lamports: n,
      space: r,
      programId: new de(i),
    };
  }
  static decodeTransfer(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
    const { lamports: n } = ut(wt.Transfer, t.data);
    return { fromPubkey: t.keys[0].pubkey, toPubkey: t.keys[1].pubkey, lamports: n };
  }
  static decodeTransferWithSeed(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
    const { lamports: n, seed: r, programId: i } = ut(wt.TransferWithSeed, t.data);
    return {
      fromPubkey: t.keys[0].pubkey,
      basePubkey: t.keys[1].pubkey,
      toPubkey: t.keys[2].pubkey,
      lamports: n,
      seed: r,
      programId: new de(i),
    };
  }
  static decodeAllocate(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 1);
    const { space: n } = ut(wt.Allocate, t.data);
    return { accountPubkey: t.keys[0].pubkey, space: n };
  }
  static decodeAllocateWithSeed(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 1);
    const { base: n, seed: r, space: i, programId: o } = ut(wt.AllocateWithSeed, t.data);
    return {
      accountPubkey: t.keys[0].pubkey,
      basePubkey: new de(n),
      seed: r,
      space: i,
      programId: new de(o),
    };
  }
  static decodeAssign(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 1);
    const { programId: n } = ut(wt.Assign, t.data);
    return { accountPubkey: t.keys[0].pubkey, programId: new de(n) };
  }
  static decodeAssignWithSeed(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 1);
    const { base: n, seed: r, programId: i } = ut(wt.AssignWithSeed, t.data);
    return {
      accountPubkey: t.keys[0].pubkey,
      basePubkey: new de(n),
      seed: r,
      programId: new de(i),
    };
  }
  static decodeCreateWithSeed(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
    const { base: n, seed: r, lamports: i, space: o, programId: a } = ut(wt.CreateWithSeed, t.data);
    return {
      fromPubkey: t.keys[0].pubkey,
      newAccountPubkey: t.keys[1].pubkey,
      basePubkey: new de(n),
      seed: r,
      lamports: i,
      space: o,
      programId: new de(a),
    };
  }
  static decodeNonceInitialize(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
    const { authorized: n } = ut(wt.InitializeNonceAccount, t.data);
    return { noncePubkey: t.keys[0].pubkey, authorizedPubkey: new de(n) };
  }
  static decodeNonceAdvance(t) {
    return (
      this.checkProgramId(t.programId),
      this.checkKeyLength(t.keys, 3),
      ut(wt.AdvanceNonceAccount, t.data),
      { noncePubkey: t.keys[0].pubkey, authorizedPubkey: t.keys[2].pubkey }
    );
  }
  static decodeNonceWithdraw(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 5);
    const { lamports: n } = ut(wt.WithdrawNonceAccount, t.data);
    return {
      noncePubkey: t.keys[0].pubkey,
      toPubkey: t.keys[1].pubkey,
      authorizedPubkey: t.keys[4].pubkey,
      lamports: n,
    };
  }
  static decodeNonceAuthorize(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
    const { authorized: n } = ut(wt.AuthorizeNonceAccount, t.data);
    return {
      noncePubkey: t.keys[0].pubkey,
      authorizedPubkey: t.keys[1].pubkey,
      newAuthorizedPubkey: new de(n),
    };
  }
  static checkProgramId(t) {
    if (!t.equals(cn.programId))
      throw new Error('invalid instruction; programId is not SystemProgram');
  }
  static checkKeyLength(t, n) {
    if (t.length < n)
      throw new Error(`invalid instruction; found ${t.length} keys, expected at least ${n}`);
  }
}
const wt = Object.freeze({
  Create: {
    index: 0,
    layout: me([we('instruction'), qn('lamports'), qn('space'), Ge('programId')]),
  },
  Assign: { index: 1, layout: me([we('instruction'), Ge('programId')]) },
  Transfer: { index: 2, layout: me([we('instruction'), Qa('lamports')]) },
  CreateWithSeed: {
    index: 3,
    layout: me([
      we('instruction'),
      Ge('base'),
      Oo('seed'),
      qn('lamports'),
      qn('space'),
      Ge('programId'),
    ]),
  },
  AdvanceNonceAccount: { index: 4, layout: me([we('instruction')]) },
  WithdrawNonceAccount: { index: 5, layout: me([we('instruction'), qn('lamports')]) },
  InitializeNonceAccount: { index: 6, layout: me([we('instruction'), Ge('authorized')]) },
  AuthorizeNonceAccount: { index: 7, layout: me([we('instruction'), Ge('authorized')]) },
  Allocate: { index: 8, layout: me([we('instruction'), qn('space')]) },
  AllocateWithSeed: {
    index: 9,
    layout: me([we('instruction'), Ge('base'), Oo('seed'), qn('space'), Ge('programId')]),
  },
  AssignWithSeed: {
    index: 10,
    layout: me([we('instruction'), Ge('base'), Oo('seed'), Ge('programId')]),
  },
  TransferWithSeed: {
    index: 11,
    layout: me([we('instruction'), Qa('lamports'), Oo('seed'), Ge('programId')]),
  },
  UpgradeNonceAccount: { index: 12, layout: me([we('instruction')]) },
});
class cn {
  constructor() {}
  static createAccount(t) {
    const n = wt.Create,
      r = tt(n, { lamports: t.lamports, space: t.space, programId: Ke(t.programId.toBuffer()) });
    return new bt({
      keys: [
        { pubkey: t.fromPubkey, isSigner: !0, isWritable: !0 },
        { pubkey: t.newAccountPubkey, isSigner: !0, isWritable: !0 },
      ],
      programId: this.programId,
      data: r,
    });
  }
  static transfer(t) {
    let n, r;
    if ('basePubkey' in t) {
      const i = wt.TransferWithSeed;
      (n = tt(i, {
        lamports: BigInt(t.lamports),
        seed: t.seed,
        programId: Ke(t.programId.toBuffer()),
      })),
        (r = [
          { pubkey: t.fromPubkey, isSigner: !1, isWritable: !0 },
          { pubkey: t.basePubkey, isSigner: !0, isWritable: !1 },
          { pubkey: t.toPubkey, isSigner: !1, isWritable: !0 },
        ]);
    } else {
      const i = wt.Transfer;
      (n = tt(i, { lamports: BigInt(t.lamports) })),
        (r = [
          { pubkey: t.fromPubkey, isSigner: !0, isWritable: !0 },
          { pubkey: t.toPubkey, isSigner: !1, isWritable: !0 },
        ]);
    }
    return new bt({ keys: r, programId: this.programId, data: n });
  }
  static assign(t) {
    let n, r;
    if ('basePubkey' in t) {
      const i = wt.AssignWithSeed;
      (n = tt(i, {
        base: Ke(t.basePubkey.toBuffer()),
        seed: t.seed,
        programId: Ke(t.programId.toBuffer()),
      })),
        (r = [
          { pubkey: t.accountPubkey, isSigner: !1, isWritable: !0 },
          { pubkey: t.basePubkey, isSigner: !0, isWritable: !1 },
        ]);
    } else {
      const i = wt.Assign;
      (n = tt(i, { programId: Ke(t.programId.toBuffer()) })),
        (r = [{ pubkey: t.accountPubkey, isSigner: !0, isWritable: !0 }]);
    }
    return new bt({ keys: r, programId: this.programId, data: n });
  }
  static createAccountWithSeed(t) {
    const n = wt.CreateWithSeed,
      r = tt(n, {
        base: Ke(t.basePubkey.toBuffer()),
        seed: t.seed,
        lamports: t.lamports,
        space: t.space,
        programId: Ke(t.programId.toBuffer()),
      });
    let i = [
      { pubkey: t.fromPubkey, isSigner: !0, isWritable: !0 },
      { pubkey: t.newAccountPubkey, isSigner: !1, isWritable: !0 },
    ];
    return (
      t.basePubkey != t.fromPubkey &&
        i.push({ pubkey: t.basePubkey, isSigner: !0, isWritable: !1 }),
      new bt({ keys: i, programId: this.programId, data: r })
    );
  }
  static createNonceAccount(t) {
    const n = new yt();
    'basePubkey' in t && 'seed' in t
      ? n.add(
          cn.createAccountWithSeed({
            fromPubkey: t.fromPubkey,
            newAccountPubkey: t.noncePubkey,
            basePubkey: t.basePubkey,
            seed: t.seed,
            lamports: t.lamports,
            space: Fm,
            programId: this.programId,
          })
        )
      : n.add(
          cn.createAccount({
            fromPubkey: t.fromPubkey,
            newAccountPubkey: t.noncePubkey,
            lamports: t.lamports,
            space: Fm,
            programId: this.programId,
          })
        );
    const r = { noncePubkey: t.noncePubkey, authorizedPubkey: t.authorizedPubkey };
    return n.add(this.nonceInitialize(r)), n;
  }
  static nonceInitialize(t) {
    const n = wt.InitializeNonceAccount,
      r = tt(n, { authorized: Ke(t.authorizedPubkey.toBuffer()) }),
      i = {
        keys: [
          { pubkey: t.noncePubkey, isSigner: !1, isWritable: !0 },
          { pubkey: Ph, isSigner: !1, isWritable: !1 },
          { pubkey: Za, isSigner: !1, isWritable: !1 },
        ],
        programId: this.programId,
        data: r,
      };
    return new bt(i);
  }
  static nonceAdvance(t) {
    const n = wt.AdvanceNonceAccount,
      r = tt(n),
      i = {
        keys: [
          { pubkey: t.noncePubkey, isSigner: !1, isWritable: !0 },
          { pubkey: Ph, isSigner: !1, isWritable: !1 },
          { pubkey: t.authorizedPubkey, isSigner: !0, isWritable: !1 },
        ],
        programId: this.programId,
        data: r,
      };
    return new bt(i);
  }
  static nonceWithdraw(t) {
    const n = wt.WithdrawNonceAccount,
      r = tt(n, { lamports: t.lamports });
    return new bt({
      keys: [
        { pubkey: t.noncePubkey, isSigner: !1, isWritable: !0 },
        { pubkey: t.toPubkey, isSigner: !1, isWritable: !0 },
        { pubkey: Ph, isSigner: !1, isWritable: !1 },
        { pubkey: Za, isSigner: !1, isWritable: !1 },
        { pubkey: t.authorizedPubkey, isSigner: !0, isWritable: !1 },
      ],
      programId: this.programId,
      data: r,
    });
  }
  static nonceAuthorize(t) {
    const n = wt.AuthorizeNonceAccount,
      r = tt(n, { authorized: Ke(t.newAuthorizedPubkey.toBuffer()) });
    return new bt({
      keys: [
        { pubkey: t.noncePubkey, isSigner: !1, isWritable: !0 },
        { pubkey: t.authorizedPubkey, isSigner: !0, isWritable: !1 },
      ],
      programId: this.programId,
      data: r,
    });
  }
  static allocate(t) {
    let n, r;
    if ('basePubkey' in t) {
      const i = wt.AllocateWithSeed;
      (n = tt(i, {
        base: Ke(t.basePubkey.toBuffer()),
        seed: t.seed,
        space: t.space,
        programId: Ke(t.programId.toBuffer()),
      })),
        (r = [
          { pubkey: t.accountPubkey, isSigner: !1, isWritable: !0 },
          { pubkey: t.basePubkey, isSigner: !0, isWritable: !1 },
        ]);
    } else {
      const i = wt.Allocate;
      (n = tt(i, { space: t.space })),
        (r = [{ pubkey: t.accountPubkey, isSigner: !0, isWritable: !0 }]);
    }
    return new bt({ keys: r, programId: this.programId, data: n });
  }
}
cn.programId = new de('11111111111111111111111111111111');
const gN = Qi - 300;
class Vo {
  constructor() {}
  static getMinNumSignatures(t) {
    return 2 * (Math.ceil(t / Vo.chunkSize) + 1 + 1);
  }
  static async load(t, n, r, i, o) {
    {
      const d = await t.getMinimumBalanceForRentExemption(o.length),
        f = await t.getAccountInfo(r.publicKey, 'confirmed');
      let p = null;
      if (f !== null) {
        if (f.executable)
          return console.error('Program load failed, account is already executable'), !1;
        f.data.length !== o.length &&
          ((p = p || new yt()),
          p.add(cn.allocate({ accountPubkey: r.publicKey, space: o.length }))),
          f.owner.equals(i) ||
            ((p = p || new yt()), p.add(cn.assign({ accountPubkey: r.publicKey, programId: i }))),
          f.lamports < d &&
            ((p = p || new yt()),
            p.add(
              cn.transfer({
                fromPubkey: n.publicKey,
                toPubkey: r.publicKey,
                lamports: d - f.lamports,
              })
            ));
      } else
        p = new yt().add(
          cn.createAccount({
            fromPubkey: n.publicKey,
            newAccountPubkey: r.publicKey,
            lamports: d > 0 ? d : 1,
            space: o.length,
            programId: i,
          })
        );
      p !== null && (await Dh(t, p, [n, r], { commitment: 'confirmed' }));
    }
    const a = me([
        we('instruction'),
        we('offset'),
        we('bytesLength'),
        we('bytesLengthPadding'),
        fn(et('byte'), No(we(), -8), 'bytes'),
      ]),
      c = Vo.chunkSize;
    let s = 0,
      l = o,
      u = [];
    for (; l.length > 0; ) {
      const d = l.slice(0, c),
        f = Ae.alloc(c + 16);
      a.encode({ instruction: 0, offset: s, bytes: d, bytesLength: 0, bytesLengthPadding: 0 }, f);
      const p = new yt().add({
        keys: [{ pubkey: r.publicKey, isSigner: !0, isWritable: !0 }],
        programId: i,
        data: f,
      });
      u.push(Dh(t, p, [n, r], { commitment: 'confirmed' })),
        t._rpcEndpoint.includes('solana.com') && (await To(1e3 / 4)),
        (s += c),
        (l = l.slice(c));
    }
    await Promise.all(u);
    {
      const d = me([we('instruction')]),
        f = Ae.alloc(d.span);
      d.encode({ instruction: 1 }, f);
      const p = new yt().add({
        keys: [
          { pubkey: r.publicKey, isSigner: !0, isWritable: !0 },
          { pubkey: Za, isSigner: !1, isWritable: !1 },
        ],
        programId: i,
        data: f,
      });
      await Dh(t, p, [n, r], { commitment: 'confirmed' });
    }
    return !0;
  }
}
Vo.chunkSize = gN;
const yN = new de('BPFLoader2111111111111111111111111111111111');
class bN {
  static getMinNumSignatures(t) {
    return Vo.getMinNumSignatures(t);
  }
  static load(t, n, r, i, o) {
    return Vo.load(t, n, r, o, i);
  }
}
var mN = Object.prototype.toString,
  wN =
    Object.keys ||
    function (e) {
      var t = [];
      for (var n in e) t.push(n);
      return t;
    };
function Js(e, t) {
  var n, r, i, o, a, c, s;
  if (e === !0) return 'true';
  if (e === !1) return 'false';
  switch (typeof e) {
    case 'object':
      if (e === null) return null;
      if (e.toJSON && typeof e.toJSON == 'function') return Js(e.toJSON(), t);
      if (((s = mN.call(e)), s === '[object Array]')) {
        for (i = '[', r = e.length - 1, n = 0; n < r; n++) i += Js(e[n], !0) + ',';
        return r > -1 && (i += Js(e[n], !0)), i + ']';
      } else if (s === '[object Object]') {
        for (o = wN(e).sort(), r = o.length, i = '', n = 0; n < r; )
          (a = o[n]),
            (c = Js(e[a], !1)),
            c !== void 0 && (i && (i += ','), (i += JSON.stringify(a) + ':' + c)),
            n++;
        return '{' + i + '}';
      } else return JSON.stringify(e);
    case 'function':
    case 'undefined':
      return t ? null : void 0;
    case 'string':
      return JSON.stringify(e);
    default:
      return isFinite(e) ? e : null;
  }
}
var _N = function (e) {
    var t = Js(e, !1);
    if (t !== void 0) return '' + t;
  },
  B_ = _N;
const Us = 32;
function Xy(e) {
  let t = 0;
  for (; e > 1; ) (e /= 2), t++;
  return t;
}
function vN(e) {
  return e === 0
    ? 1
    : (e--,
      (e |= e >> 1),
      (e |= e >> 2),
      (e |= e >> 4),
      (e |= e >> 8),
      (e |= e >> 16),
      (e |= e >> 32),
      e + 1);
}
class qT {
  constructor(t, n, r, i, o) {
    (this.slotsPerEpoch = void 0),
      (this.leaderScheduleSlotOffset = void 0),
      (this.warmup = void 0),
      (this.firstNormalEpoch = void 0),
      (this.firstNormalSlot = void 0),
      (this.slotsPerEpoch = t),
      (this.leaderScheduleSlotOffset = n),
      (this.warmup = r),
      (this.firstNormalEpoch = i),
      (this.firstNormalSlot = o);
  }
  getEpoch(t) {
    return this.getEpochAndSlotIndex(t)[0];
  }
  getEpochAndSlotIndex(t) {
    if (t < this.firstNormalSlot) {
      const n = Xy(vN(t + Us + 1)) - Xy(Us) - 1,
        r = this.getSlotsInEpoch(n),
        i = t - (r - Us);
      return [n, i];
    } else {
      const n = t - this.firstNormalSlot,
        r = Math.floor(n / this.slotsPerEpoch),
        i = this.firstNormalEpoch + r,
        o = n % this.slotsPerEpoch;
      return [i, o];
    }
  }
  getFirstSlotInEpoch(t) {
    return t <= this.firstNormalEpoch
      ? (Math.pow(2, t) - 1) * Us
      : (t - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;
  }
  getLastSlotInEpoch(t) {
    return this.getFirstSlotInEpoch(t) + this.getSlotsInEpoch(t) - 1;
  }
  getSlotsInEpoch(t) {
    return t < this.firstNormalEpoch ? Math.pow(2, t + Xy(Us)) : this.slotsPerEpoch;
  }
}
class $m extends Error {
  constructor(t, n) {
    super(t), (this.logs = void 0), (this.logs = n);
  }
}
const SN = {
  JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
  JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,
  JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
  JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
  JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,
  JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
  JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
  JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
  JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
  JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
  JSON_RPC_SCAN_ERROR: -32012,
  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
  JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
  JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
  JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016,
};
class ve extends Error {
  constructor({ code: t, message: n, data: r }, i) {
    super(i != null ? `${i}: ${n}` : n),
      (this.code = void 0),
      (this.data = void 0),
      (this.code = t),
      (this.data = r),
      (this.name = 'SolanaJSONRPCError');
  }
}
var AN = globalThis.fetch;
class IN extends u4 {
  constructor(t, n, r) {
    const i = (o) => {
      const a = p4(o, {
        autoconnect: !0,
        max_reconnects: 5,
        reconnect: !0,
        reconnect_interval: 1e3,
        ...n,
      });
      return 'socket' in a ? (this.underlyingSocket = a.socket) : (this.underlyingSocket = a), a;
    };
    super(i, t, n, r), (this.underlyingSocket = void 0);
  }
  call(...t) {
    var r;
    const n = (r = this.underlyingSocket) == null ? void 0 : r.readyState;
    return n === 1
      ? super.call(...t)
      : Promise.reject(
          new Error(
            'Tried to call a JSON-RPC method `' +
              t[0] +
              '` but the socket was not `CONNECTING` or `OPEN` (`readyState` was ' +
              n +
              ')'
          )
        );
  }
  notify(...t) {
    var r;
    const n = (r = this.underlyingSocket) == null ? void 0 : r.readyState;
    return n === 1
      ? super.notify(...t)
      : Promise.reject(
          new Error(
            'Tried to send a JSON-RPC notification `' +
              t[0] +
              '` but the socket was not `CONNECTING` or `OPEN` (`readyState` was ' +
              n +
              ')'
          )
        );
  }
}
const EN = 160,
  TN = 64,
  kN = EN / TN,
  CN = 1e3 / kN;
function MN(e, t) {
  let n;
  try {
    n = e.layout.decode(t);
  } catch (r) {
    throw new Error('invalid instruction; ' + r);
  }
  if (n.typeIndex !== e.index)
    throw new Error(`invalid account data; account type mismatch ${n.typeIndex} != ${e.index}`);
  return n;
}
const j_ = 56;
class Wm {
  constructor(t) {
    (this.key = void 0), (this.state = void 0), (this.key = t.key), (this.state = t.state);
  }
  isActive() {
    const t = BigInt('0xffffffffffffffff');
    return this.state.deactivationSlot === t;
  }
  static deserialize(t) {
    const n = MN(PN, t),
      r = t.length - j_;
    ot(r >= 0, 'lookup table is invalid'), ot(r % 32 === 0, 'lookup table is invalid');
    const i = r / 32,
      { addresses: o } = me([fn(Ge(), i, 'addresses')]).decode(t.slice(j_));
    return {
      deactivationSlot: n.deactivationSlot,
      lastExtendedSlot: n.lastExtendedSlot,
      lastExtendedSlotStartIndex: n.lastExtendedStartIndex,
      authority: n.authority.length !== 0 ? new de(n.authority[0]) : void 0,
      addresses: o.map((a) => new de(a)),
    };
  }
}
const PN = {
    index: 1,
    layout: me([
      we('typeIndex'),
      Qa('deactivationSlot'),
      un('lastExtendedSlot'),
      et('lastExtendedStartIndex'),
      et(),
      fn(Ge(), No(et(), -1), 'authority'),
    ]),
  },
  ON = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
function DN(e) {
  const t = e.match(ON);
  if (t == null) throw TypeError(`Failed to validate endpoint URL \`${e}\``);
  const [n, r, i, o] = t,
    a = e.startsWith('https:') ? 'wss:' : 'ws:',
    c = i == null ? null : parseInt(i.slice(1), 10),
    s = c == null ? '' : `:${c + 1}`;
  return `${a}//${r}${s}${o}`;
}
const zt = kc(z0(de), se(), (e) => new de(e)),
  GT = L0([se(), Mt('base64')]),
  S1 = kc(z0(Ae), GT, (e) => Ae.from(e[0], 'base64')),
  YT = 30 * 1e3;
function RN(e) {
  if (/^https?:/.test(e) === !1)
    throw new TypeError('Endpoint URL must start with `http:` or `https:`.');
  return e;
}
function kt(e) {
  let t, n;
  if (typeof e == 'string') t = e;
  else if (e) {
    const { commitment: r, ...i } = e;
    (t = r), (n = i);
  }
  return { commitment: t, config: n };
}
function ZT(e) {
  return Pn([
    ne({ jsonrpc: Mt('2.0'), id: se(), result: e }),
    ne({ jsonrpc: Mt('2.0'), id: se(), error: ne({ code: Cc(), message: se(), data: Ce(a4()) }) }),
  ]);
}
const xN = ZT(Cc());
function He(e) {
  return kc(ZT(e), xN, (t) => ('error' in t ? t : { ...t, result: le(t.result, e) }));
}
function Ut(e) {
  return He(ne({ context: ne({ slot: U() }), value: e }));
}
function og(e) {
  return ne({ context: ne({ slot: U() }), value: e });
}
function eb(e, t) {
  return e === 0
    ? new Wo({
        header: t.header,
        staticAccountKeys: t.accountKeys.map((n) => new de(n)),
        recentBlockhash: t.recentBlockhash,
        compiledInstructions: t.instructions.map((n) => ({
          programIdIndex: n.programIdIndex,
          accountKeyIndexes: n.accounts,
          data: an.decode(n.data),
        })),
        addressTableLookups: t.addressTableLookups,
      })
    : new mr(t);
}
const BN = ne({ foundation: U(), foundationTerm: U(), initial: U(), taper: U(), terminal: U() }),
  jN = He(
    ge(
      pe(
        ne({
          epoch: U(),
          effectiveSlot: U(),
          amount: U(),
          postBalance: U(),
          commission: Ce(pe(U())),
        })
      )
    )
  ),
  NN = ne({ total: U(), validator: U(), foundation: U(), epoch: U() }),
  UN = ne({
    epoch: U(),
    slotIndex: U(),
    slotsInEpoch: U(),
    absoluteSlot: U(),
    blockHeight: Ce(U()),
    transactionCount: Ce(U()),
  }),
  LN = ne({
    slotsPerEpoch: U(),
    leaderScheduleSlotOffset: U(),
    warmup: fi(),
    firstNormalEpoch: U(),
    firstNormalSlot: U(),
  }),
  zN = mI(se(), ge(U())),
  ca = pe(Pn([ne({}), se()])),
  FN = ne({ err: ca }),
  $N = Mt('receivedSignature'),
  WN = ne({ 'solana-core': se(), 'feature-set': Ce(U()) }),
  N_ = Ut(
    ne({
      err: pe(Pn([ne({}), se()])),
      logs: pe(ge(se())),
      accounts: Ce(
        pe(
          ge(
            pe(
              ne({
                executable: fi(),
                owner: se(),
                lamports: U(),
                data: ge(se()),
                rentEpoch: Ce(U()),
              })
            )
          )
        )
      ),
      unitsConsumed: Ce(U()),
      returnData: Ce(pe(ne({ programId: se(), data: L0([se(), Mt('base64')]) }))),
    })
  ),
  VN = Ut(ne({ byIdentity: mI(se(), ge(U())), range: ne({ firstSlot: U(), lastSlot: U() }) }));
function KN(e, t, n, r, i, o) {
  const a = n || AN;
  let c;
  o != null &&
    console.warn(
      'You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.'
    );
  let s;
  return (
    r &&
      (s = async (u, d) => {
        const f = await new Promise((p, y) => {
          try {
            r(u, d, (b, m) => p([b, m]));
          } catch (b) {
            y(b);
          }
        });
        return await a(...f);
      }),
    new l4(async (u, d) => {
      const f = {
        method: 'POST',
        body: u,
        agent: c,
        headers: Object.assign({ 'Content-Type': 'application/json' }, t || {}, VU),
      };
      try {
        let p = 5,
          y,
          b = 500;
        for (
          ;
          s ? (y = await s(e, f)) : (y = await a(e, f)),
            !(y.status !== 429 || i === !0 || ((p -= 1), p === 0));

        )
          console.log(
            `Server responded with ${y.status} ${y.statusText}.  Retrying after ${b}ms delay...`
          ),
            await To(b),
            (b *= 2);
        const m = await y.text();
        y.ok ? d(null, m) : d(new Error(`${y.status} ${y.statusText}: ${m}`));
      } catch (p) {
        p instanceof Error && d(p);
      }
    }, {})
  );
}
function HN(e) {
  return (t, n) =>
    new Promise((r, i) => {
      e.request(t, n, (o, a) => {
        if (o) {
          i(o);
          return;
        }
        r(a);
      });
    });
}
function qN(e) {
  return (t) =>
    new Promise((n, r) => {
      t.length === 0 && n([]);
      const i = t.map((o) => e.request(o.methodName, o.args));
      e.request(i, (o, a) => {
        if (o) {
          r(o);
          return;
        }
        n(a);
      });
    });
}
const GN = He(BN),
  YN = He(NN),
  ZN = He(UN),
  QN = He(LN),
  JN = He(zN),
  XN = He(U()),
  eU = Ut(
    ne({ total: U(), circulating: U(), nonCirculating: U(), nonCirculatingAccounts: ge(zt) })
  ),
  Vm = ne({ amount: se(), uiAmount: pe(U()), decimals: U(), uiAmountString: Ce(se()) }),
  tU = Ut(
    ge(
      ne({ address: zt, amount: se(), uiAmount: pe(U()), decimals: U(), uiAmountString: Ce(se()) })
    )
  ),
  nU = Ut(
    ge(
      ne({
        pubkey: zt,
        account: ne({ executable: fi(), owner: zt, lamports: U(), data: S1, rentEpoch: U() }),
      })
    )
  ),
  Km = ne({ program: se(), parsed: Cc(), space: U() }),
  rU = Ut(
    ge(
      ne({
        pubkey: zt,
        account: ne({ executable: fi(), owner: zt, lamports: U(), data: Km, rentEpoch: U() }),
      })
    )
  ),
  iU = Ut(ge(ne({ lamports: U(), address: zt }))),
  lc = ne({ executable: fi(), owner: zt, lamports: U(), data: S1, rentEpoch: U() }),
  oU = ne({ pubkey: zt, account: lc }),
  aU = kc(Pn([z0(Ae), Km]), Pn([GT, Km]), (e) => (Array.isArray(e) ? le(e, S1) : e)),
  Hm = ne({ executable: fi(), owner: zt, lamports: U(), data: aU, rentEpoch: U() }),
  sU = ne({ pubkey: zt, account: Hm }),
  cU = ne({
    state: Pn([Mt('active'), Mt('inactive'), Mt('activating'), Mt('deactivating')]),
    active: U(),
    inactive: U(),
  }),
  uU = He(ge(ne({ signature: se(), slot: U(), err: ca, memo: pe(se()), blockTime: Ce(pe(U())) }))),
  lU = He(ge(ne({ signature: se(), slot: U(), err: ca, memo: pe(se()), blockTime: Ce(pe(U())) }))),
  dU = ne({ subscription: U(), result: og(lc) }),
  fU = ne({ pubkey: zt, account: lc }),
  hU = ne({ subscription: U(), result: og(fU) }),
  pU = ne({ parent: U(), slot: U(), root: U() }),
  gU = ne({ subscription: U(), result: pU }),
  yU = Pn([
    ne({
      type: Pn([
        Mt('firstShredReceived'),
        Mt('completed'),
        Mt('optimisticConfirmation'),
        Mt('root'),
      ]),
      slot: U(),
      timestamp: U(),
    }),
    ne({ type: Mt('createdBank'), parent: U(), slot: U(), timestamp: U() }),
    ne({
      type: Mt('frozen'),
      slot: U(),
      timestamp: U(),
      stats: ne({
        numTransactionEntries: U(),
        numSuccessfulTransactions: U(),
        numFailedTransactions: U(),
        maxTransactionsPerEntry: U(),
      }),
    }),
    ne({ type: Mt('dead'), slot: U(), timestamp: U(), err: se() }),
  ]),
  bU = ne({ subscription: U(), result: yU }),
  mU = ne({ subscription: U(), result: og(Pn([FN, $N])) }),
  wU = ne({ subscription: U(), result: U() }),
  _U = ne({ pubkey: se(), gossip: pe(se()), tpu: pe(se()), rpc: pe(se()), version: pe(se()) }),
  U_ = ne({
    votePubkey: se(),
    nodePubkey: se(),
    activatedStake: U(),
    epochVoteAccount: fi(),
    epochCredits: ge(L0([U(), U(), U()])),
    commission: U(),
    lastVote: U(),
    rootSlot: pe(U()),
  }),
  vU = He(ne({ current: ge(U_), delinquent: ge(U_) })),
  SU = Pn([Mt('processed'), Mt('confirmed'), Mt('finalized')]),
  AU = ne({ slot: U(), confirmations: pe(U()), err: ca, confirmationStatus: Ce(SU) }),
  IU = Ut(ge(pe(AU))),
  EU = He(U()),
  QT = ne({ accountKey: zt, writableIndexes: ge(U()), readonlyIndexes: ge(U()) }),
  A1 = ne({
    signatures: ge(se()),
    message: ne({
      accountKeys: ge(se()),
      header: ne({
        numRequiredSignatures: U(),
        numReadonlySignedAccounts: U(),
        numReadonlyUnsignedAccounts: U(),
      }),
      instructions: ge(ne({ accounts: ge(U()), data: se(), programIdIndex: U() })),
      recentBlockhash: se(),
      addressTableLookups: Ce(ge(QT)),
    }),
  }),
  JT = ne({
    pubkey: zt,
    signer: fi(),
    writable: fi(),
    source: Ce(Pn([Mt('transaction'), Mt('lookupTable')])),
  }),
  XT = ne({ accountKeys: ge(JT), signatures: ge(se()) }),
  ek = ne({ parsed: Cc(), program: se(), programId: zt }),
  tk = ne({ accounts: ge(zt), data: se(), programId: zt }),
  TU = Pn([tk, ek]),
  kU = Pn([
    ne({ parsed: Cc(), program: se(), programId: se() }),
    ne({ accounts: ge(se()), data: se(), programId: se() }),
  ]),
  nk = kc(TU, kU, (e) => ('accounts' in e ? le(e, tk) : le(e, ek))),
  rk = ne({
    signatures: ge(se()),
    message: ne({
      accountKeys: ge(JT),
      instructions: ge(nk),
      recentBlockhash: se(),
      addressTableLookups: Ce(pe(ge(QT))),
    }),
  }),
  cp = ne({ accountIndex: U(), mint: se(), owner: Ce(se()), uiTokenAmount: Vm }),
  ik = ne({ writable: ge(zt), readonly: ge(zt) }),
  ag = ne({
    err: ca,
    fee: U(),
    innerInstructions: Ce(
      pe(
        ge(
          ne({
            index: U(),
            instructions: ge(ne({ accounts: ge(U()), data: se(), programIdIndex: U() })),
          })
        )
      )
    ),
    preBalances: ge(U()),
    postBalances: ge(U()),
    logMessages: Ce(pe(ge(se()))),
    preTokenBalances: Ce(pe(ge(cp))),
    postTokenBalances: Ce(pe(ge(cp))),
    loadedAddresses: Ce(ik),
    computeUnitsConsumed: Ce(U()),
  }),
  I1 = ne({
    err: ca,
    fee: U(),
    innerInstructions: Ce(pe(ge(ne({ index: U(), instructions: ge(nk) })))),
    preBalances: ge(U()),
    postBalances: ge(U()),
    logMessages: Ce(pe(ge(se()))),
    preTokenBalances: Ce(pe(ge(cp))),
    postTokenBalances: Ce(pe(ge(cp))),
    loadedAddresses: Ce(ik),
    computeUnitsConsumed: Ce(U()),
  }),
  ws = Pn([Mt(0), Mt('legacy')]),
  ua = ne({
    pubkey: se(),
    lamports: U(),
    postBalance: pe(U()),
    rewardType: pe(se()),
    commission: Ce(pe(U())),
  }),
  CU = He(
    pe(
      ne({
        blockhash: se(),
        previousBlockhash: se(),
        parentSlot: U(),
        transactions: ge(ne({ transaction: A1, meta: pe(ag), version: Ce(ws) })),
        rewards: Ce(ge(ua)),
        blockTime: pe(U()),
        blockHeight: pe(U()),
      })
    )
  ),
  MU = He(
    pe(
      ne({
        blockhash: se(),
        previousBlockhash: se(),
        parentSlot: U(),
        rewards: Ce(ge(ua)),
        blockTime: pe(U()),
        blockHeight: pe(U()),
      })
    )
  ),
  PU = He(
    pe(
      ne({
        blockhash: se(),
        previousBlockhash: se(),
        parentSlot: U(),
        transactions: ge(ne({ transaction: XT, meta: pe(ag), version: Ce(ws) })),
        rewards: Ce(ge(ua)),
        blockTime: pe(U()),
        blockHeight: pe(U()),
      })
    )
  ),
  OU = He(
    pe(
      ne({
        blockhash: se(),
        previousBlockhash: se(),
        parentSlot: U(),
        transactions: ge(ne({ transaction: rk, meta: pe(I1), version: Ce(ws) })),
        rewards: Ce(ge(ua)),
        blockTime: pe(U()),
        blockHeight: pe(U()),
      })
    )
  ),
  DU = He(
    pe(
      ne({
        blockhash: se(),
        previousBlockhash: se(),
        parentSlot: U(),
        transactions: ge(ne({ transaction: XT, meta: pe(I1), version: Ce(ws) })),
        rewards: Ce(ge(ua)),
        blockTime: pe(U()),
        blockHeight: pe(U()),
      })
    )
  ),
  RU = He(
    pe(
      ne({
        blockhash: se(),
        previousBlockhash: se(),
        parentSlot: U(),
        rewards: Ce(ge(ua)),
        blockTime: pe(U()),
        blockHeight: pe(U()),
      })
    )
  ),
  xU = He(
    pe(
      ne({
        blockhash: se(),
        previousBlockhash: se(),
        parentSlot: U(),
        transactions: ge(ne({ transaction: A1, meta: pe(ag) })),
        rewards: Ce(ge(ua)),
        blockTime: pe(U()),
      })
    )
  ),
  L_ = He(
    pe(
      ne({
        blockhash: se(),
        previousBlockhash: se(),
        parentSlot: U(),
        signatures: ge(se()),
        blockTime: pe(U()),
      })
    )
  ),
  tb = He(
    pe(ne({ slot: U(), meta: ag, blockTime: Ce(pe(U())), transaction: A1, version: Ce(ws) }))
  ),
  Xf = He(
    pe(ne({ slot: U(), transaction: rk, meta: pe(I1), blockTime: Ce(pe(U())), version: Ce(ws) }))
  ),
  BU = Ut(ne({ blockhash: se(), feeCalculator: ne({ lamportsPerSignature: U() }) })),
  jU = Ut(ne({ blockhash: se(), lastValidBlockHeight: U() })),
  NU = ne({ slot: U(), numTransactions: U(), numSlots: U(), samplePeriodSecs: U() }),
  UU = He(ge(NU)),
  LU = Ut(pe(ne({ feeCalculator: ne({ lamportsPerSignature: U() }) }))),
  zU = He(se()),
  FU = He(se()),
  $U = ne({ err: ca, logs: ge(se()), signature: se() }),
  WU = ne({ result: og($U), subscription: U() }),
  VU = { 'solana-client': 'js/0.0.0-development' };
class KU {
  constructor(t, n) {
    (this._commitment = void 0),
      (this._confirmTransactionInitialTimeout = void 0),
      (this._rpcEndpoint = void 0),
      (this._rpcWsEndpoint = void 0),
      (this._rpcClient = void 0),
      (this._rpcRequest = void 0),
      (this._rpcBatchRequest = void 0),
      (this._rpcWebSocket = void 0),
      (this._rpcWebSocketConnected = !1),
      (this._rpcWebSocketHeartbeat = null),
      (this._rpcWebSocketIdleTimeout = null),
      (this._rpcWebSocketGeneration = 0),
      (this._disableBlockhashCaching = !1),
      (this._pollingBlockhash = !1),
      (this._blockhashInfo = {
        latestBlockhash: null,
        lastFetch: 0,
        transactionSignatures: [],
        simulatedSignatures: [],
      }),
      (this._nextClientSubscriptionId = 0),
      (this._subscriptionDisposeFunctionsByClientSubscriptionId = {}),
      (this._subscriptionHashByClientSubscriptionId = {}),
      (this._subscriptionStateChangeCallbacksByHash = {}),
      (this._subscriptionCallbacksByServerSubscriptionId = {}),
      (this._subscriptionsByHash = {}),
      (this._subscriptionsAutoDisposedByRpc = new Set()),
      (this.getBlockHeight = (() => {
        const l = {};
        return async (u) => {
          const { commitment: d, config: f } = kt(u),
            p = this._buildArgs([], d, void 0, f),
            y = B_(p);
          return (
            (l[y] =
              l[y] ??
              (async () => {
                try {
                  const b = await this._rpcRequest('getBlockHeight', p),
                    m = le(b, He(U()));
                  if ('error' in m) throw new ve(m.error, 'failed to get block height information');
                  return m.result;
                } finally {
                  delete l[y];
                }
              })()),
            await l[y]
          );
        };
      })());
    let r, i, o, a, c, s;
    n && typeof n == 'string'
      ? (this._commitment = n)
      : n &&
        ((this._commitment = n.commitment),
        (this._confirmTransactionInitialTimeout = n.confirmTransactionInitialTimeout),
        (r = n.wsEndpoint),
        (i = n.httpHeaders),
        (o = n.fetch),
        (a = n.fetchMiddleware),
        (c = n.disableRetryOnRateLimit),
        (s = n.httpAgent)),
      (this._rpcEndpoint = RN(t)),
      (this._rpcWsEndpoint = r || DN(t)),
      (this._rpcClient = KN(t, i, o, a, c, s)),
      (this._rpcRequest = HN(this._rpcClient)),
      (this._rpcBatchRequest = qN(this._rpcClient)),
      (this._rpcWebSocket = new IN(this._rpcWsEndpoint, {
        autoconnect: !1,
        max_reconnects: 1 / 0,
      })),
      this._rpcWebSocket.on('open', this._wsOnOpen.bind(this)),
      this._rpcWebSocket.on('error', this._wsOnError.bind(this)),
      this._rpcWebSocket.on('close', this._wsOnClose.bind(this)),
      this._rpcWebSocket.on('accountNotification', this._wsOnAccountNotification.bind(this)),
      this._rpcWebSocket.on('programNotification', this._wsOnProgramAccountNotification.bind(this)),
      this._rpcWebSocket.on('slotNotification', this._wsOnSlotNotification.bind(this)),
      this._rpcWebSocket.on(
        'slotsUpdatesNotification',
        this._wsOnSlotUpdatesNotification.bind(this)
      ),
      this._rpcWebSocket.on('signatureNotification', this._wsOnSignatureNotification.bind(this)),
      this._rpcWebSocket.on('rootNotification', this._wsOnRootNotification.bind(this)),
      this._rpcWebSocket.on('logsNotification', this._wsOnLogsNotification.bind(this));
  }
  get commitment() {
    return this._commitment;
  }
  get rpcEndpoint() {
    return this._rpcEndpoint;
  }
  async getBalanceAndContext(t, n) {
    const { commitment: r, config: i } = kt(n),
      o = this._buildArgs([t.toBase58()], r, void 0, i),
      a = await this._rpcRequest('getBalance', o),
      c = le(a, Ut(U()));
    if ('error' in c) throw new ve(c.error, `failed to get balance for ${t.toBase58()}`);
    return c.result;
  }
  async getBalance(t, n) {
    return await this.getBalanceAndContext(t, n)
      .then((r) => r.value)
      .catch((r) => {
        throw new Error('failed to get balance of account ' + t.toBase58() + ': ' + r);
      });
  }
  async getBlockTime(t) {
    const n = await this._rpcRequest('getBlockTime', [t]),
      r = le(n, He(pe(U())));
    if ('error' in r) throw new ve(r.error, `failed to get block time for slot ${t}`);
    return r.result;
  }
  async getMinimumLedgerSlot() {
    const t = await this._rpcRequest('minimumLedgerSlot', []),
      n = le(t, He(U()));
    if ('error' in n) throw new ve(n.error, 'failed to get minimum ledger slot');
    return n.result;
  }
  async getFirstAvailableBlock() {
    const t = await this._rpcRequest('getFirstAvailableBlock', []),
      n = le(t, XN);
    if ('error' in n) throw new ve(n.error, 'failed to get first available block');
    return n.result;
  }
  async getSupply(t) {
    let n = {};
    typeof t == 'string'
      ? (n = { commitment: t })
      : t
        ? (n = { ...t, commitment: (t && t.commitment) || this.commitment })
        : (n = { commitment: this.commitment });
    const r = await this._rpcRequest('getSupply', [n]),
      i = le(r, eU);
    if ('error' in i) throw new ve(i.error, 'failed to get supply');
    return i.result;
  }
  async getTokenSupply(t, n) {
    const r = this._buildArgs([t.toBase58()], n),
      i = await this._rpcRequest('getTokenSupply', r),
      o = le(i, Ut(Vm));
    if ('error' in o) throw new ve(o.error, 'failed to get token supply');
    return o.result;
  }
  async getTokenAccountBalance(t, n) {
    const r = this._buildArgs([t.toBase58()], n),
      i = await this._rpcRequest('getTokenAccountBalance', r),
      o = le(i, Ut(Vm));
    if ('error' in o) throw new ve(o.error, 'failed to get token account balance');
    return o.result;
  }
  async getTokenAccountsByOwner(t, n, r) {
    const { commitment: i, config: o } = kt(r);
    let a = [t.toBase58()];
    'mint' in n
      ? a.push({ mint: n.mint.toBase58() })
      : a.push({ programId: n.programId.toBase58() });
    const c = this._buildArgs(a, i, 'base64', o),
      s = await this._rpcRequest('getTokenAccountsByOwner', c),
      l = le(s, nU);
    if ('error' in l)
      throw new ve(l.error, `failed to get token accounts owned by account ${t.toBase58()}`);
    return l.result;
  }
  async getParsedTokenAccountsByOwner(t, n, r) {
    let i = [t.toBase58()];
    'mint' in n
      ? i.push({ mint: n.mint.toBase58() })
      : i.push({ programId: n.programId.toBase58() });
    const o = this._buildArgs(i, r, 'jsonParsed'),
      a = await this._rpcRequest('getTokenAccountsByOwner', o),
      c = le(a, rU);
    if ('error' in c)
      throw new ve(c.error, `failed to get token accounts owned by account ${t.toBase58()}`);
    return c.result;
  }
  async getLargestAccounts(t) {
    const n = { ...t, commitment: (t && t.commitment) || this.commitment },
      r = n.filter || n.commitment ? [n] : [],
      i = await this._rpcRequest('getLargestAccounts', r),
      o = le(i, iU);
    if ('error' in o) throw new ve(o.error, 'failed to get largest accounts');
    return o.result;
  }
  async getTokenLargestAccounts(t, n) {
    const r = this._buildArgs([t.toBase58()], n),
      i = await this._rpcRequest('getTokenLargestAccounts', r),
      o = le(i, tU);
    if ('error' in o) throw new ve(o.error, 'failed to get token largest accounts');
    return o.result;
  }
  async getAccountInfoAndContext(t, n) {
    const { commitment: r, config: i } = kt(n),
      o = this._buildArgs([t.toBase58()], r, 'base64', i),
      a = await this._rpcRequest('getAccountInfo', o),
      c = le(a, Ut(pe(lc)));
    if ('error' in c) throw new ve(c.error, `failed to get info about account ${t.toBase58()}`);
    return c.result;
  }
  async getParsedAccountInfo(t, n) {
    const { commitment: r, config: i } = kt(n),
      o = this._buildArgs([t.toBase58()], r, 'jsonParsed', i),
      a = await this._rpcRequest('getAccountInfo', o),
      c = le(a, Ut(pe(Hm)));
    if ('error' in c) throw new ve(c.error, `failed to get info about account ${t.toBase58()}`);
    return c.result;
  }
  async getAccountInfo(t, n) {
    try {
      return (await this.getAccountInfoAndContext(t, n)).value;
    } catch (r) {
      throw new Error('failed to get info about account ' + t.toBase58() + ': ' + r);
    }
  }
  async getMultipleParsedAccounts(t, n) {
    const { commitment: r, config: i } = kt(n),
      o = t.map((l) => l.toBase58()),
      a = this._buildArgs([o], r, 'jsonParsed', i),
      c = await this._rpcRequest('getMultipleAccounts', a),
      s = le(c, Ut(ge(pe(Hm))));
    if ('error' in s) throw new ve(s.error, `failed to get info for accounts ${o}`);
    return s.result;
  }
  async getMultipleAccountsInfoAndContext(t, n) {
    const { commitment: r, config: i } = kt(n),
      o = t.map((l) => l.toBase58()),
      a = this._buildArgs([o], r, 'base64', i),
      c = await this._rpcRequest('getMultipleAccounts', a),
      s = le(c, Ut(ge(pe(lc))));
    if ('error' in s) throw new ve(s.error, `failed to get info for accounts ${o}`);
    return s.result;
  }
  async getMultipleAccountsInfo(t, n) {
    return (await this.getMultipleAccountsInfoAndContext(t, n)).value;
  }
  async getStakeActivation(t, n, r) {
    const { commitment: i, config: o } = kt(n),
      a = this._buildArgs([t.toBase58()], i, void 0, {
        ...o,
        epoch: r ?? (o == null ? void 0 : o.epoch),
      }),
      c = await this._rpcRequest('getStakeActivation', a),
      s = le(c, He(cU));
    if ('error' in s) throw new ve(s.error, `failed to get Stake Activation ${t.toBase58()}`);
    return s.result;
  }
  async getProgramAccounts(t, n) {
    const { commitment: r, config: i } = kt(n),
      { encoding: o, ...a } = i || {},
      c = this._buildArgs([t.toBase58()], r, o || 'base64', a),
      s = await this._rpcRequest('getProgramAccounts', c),
      l = le(s, He(ge(oU)));
    if ('error' in l)
      throw new ve(l.error, `failed to get accounts owned by program ${t.toBase58()}`);
    return l.result;
  }
  async getParsedProgramAccounts(t, n) {
    const { commitment: r, config: i } = kt(n),
      o = this._buildArgs([t.toBase58()], r, 'jsonParsed', i),
      a = await this._rpcRequest('getProgramAccounts', o),
      c = le(a, He(ge(sU)));
    if ('error' in c)
      throw new ve(c.error, `failed to get accounts owned by program ${t.toBase58()}`);
    return c.result;
  }
  async confirmTransaction(t, n) {
    var o;
    let r;
    if (typeof t == 'string') r = t;
    else {
      const a = t;
      if ((o = a.abortSignal) != null && o.aborted) return Promise.reject(a.abortSignal.reason);
      r = a.signature;
    }
    let i;
    try {
      i = an.decode(r);
    } catch {
      throw new Error('signature must be base58 encoded: ' + r);
    }
    return (
      ot(i.length === 64, 'signature has invalid length'),
      typeof t == 'string'
        ? await this.confirmTransactionUsingLegacyTimeoutStrategy({
            commitment: n || this.commitment,
            signature: r,
          })
        : 'lastValidBlockHeight' in t
          ? await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
              commitment: n || this.commitment,
              strategy: t,
            })
          : await this.confirmTransactionUsingDurableNonceStrategy({
              commitment: n || this.commitment,
              strategy: t,
            })
    );
  }
  getCancellationPromise(t) {
    return new Promise((n, r) => {
      t != null &&
        (t.aborted
          ? r(t.reason)
          : t.addEventListener('abort', () => {
              r(t.reason);
            }));
    });
  }
  getTransactionConfirmationPromise({ commitment: t, signature: n }) {
    let r,
      i,
      o = !1;
    const a = new Promise((s, l) => {
      try {
        r = this.onSignature(
          n,
          (d, f) => {
            r = void 0;
            const p = { context: f, value: d };
            s({ __type: rr.PROCESSED, response: p });
          },
          t
        );
        const u = new Promise((d) => {
          r == null
            ? d()
            : (i = this._onSubscriptionStateChange(r, (f) => {
                f === 'subscribed' && d();
              }));
        });
        (async () => {
          if ((await u, o)) return;
          const d = await this.getSignatureStatus(n);
          if (o || d == null) return;
          const { context: f, value: p } = d;
          if (p != null)
            if (p != null && p.err) l(p.err);
            else {
              switch (t) {
                case 'confirmed':
                case 'single':
                case 'singleGossip': {
                  if (p.confirmationStatus === 'processed') return;
                  break;
                }
                case 'finalized':
                case 'max':
                case 'root': {
                  if (p.confirmationStatus === 'processed' || p.confirmationStatus === 'confirmed')
                    return;
                  break;
                }
                case 'processed':
                case 'recent':
              }
              (o = !0), s({ __type: rr.PROCESSED, response: { context: f, value: p } });
            }
        })();
      } catch (u) {
        l(u);
      }
    });
    return {
      abortConfirmation: () => {
        i && (i(), (i = void 0)), r != null && (this.removeSignatureListener(r), (r = void 0));
      },
      confirmationPromise: a,
    };
  }
  async confirmTransactionUsingBlockHeightExceedanceStrategy({
    commitment: t,
    strategy: { abortSignal: n, lastValidBlockHeight: r, signature: i },
  }) {
    let o = !1;
    const a = new Promise((d) => {
        const f = async () => {
          try {
            return await this.getBlockHeight(t);
          } catch {
            return -1;
          }
        };
        (async () => {
          let p = await f();
          if (!o) {
            for (; p <= r; ) if ((await To(1e3), o || ((p = await f()), o))) return;
            d({ __type: rr.BLOCKHEIGHT_EXCEEDED });
          }
        })();
      }),
      { abortConfirmation: c, confirmationPromise: s } = this.getTransactionConfirmationPromise({
        commitment: t,
        signature: i,
      }),
      l = this.getCancellationPromise(n);
    let u;
    try {
      const d = await Promise.race([l, s, a]);
      if (d.__type === rr.PROCESSED) u = d.response;
      else throw new b1(i);
    } finally {
      (o = !0), c();
    }
    return u;
  }
  async confirmTransactionUsingDurableNonceStrategy({
    commitment: t,
    strategy: {
      abortSignal: n,
      minContextSlot: r,
      nonceAccountPubkey: i,
      nonceValue: o,
      signature: a,
    },
  }) {
    let c = !1;
    const s = new Promise((p) => {
        let y = o,
          b = null;
        const m = async () => {
          try {
            const { context: w, value: _ } = await this.getNonceAndContext(i, {
              commitment: t,
              minContextSlot: r,
            });
            return (b = w.slot), _ == null ? void 0 : _.nonce;
          } catch {
            return y;
          }
        };
        (async () => {
          if (((y = await m()), !c))
            for (;;) {
              if (o !== y) {
                p({ __type: rr.NONCE_INVALID, slotInWhichNonceDidAdvance: b });
                return;
              }
              if ((await To(2e3), c || ((y = await m()), c))) return;
            }
        })();
      }),
      { abortConfirmation: l, confirmationPromise: u } = this.getTransactionConfirmationPromise({
        commitment: t,
        signature: a,
      }),
      d = this.getCancellationPromise(n);
    let f;
    try {
      const p = await Promise.race([d, u, s]);
      if (p.__type === rr.PROCESSED) f = p.response;
      else {
        let y;
        for (;;) {
          const b = await this.getSignatureStatus(a);
          if (b == null) break;
          if (b.context.slot < (p.slotInWhichNonceDidAdvance ?? r)) {
            await To(400);
            continue;
          }
          y = b;
          break;
        }
        if (y != null && y.value) {
          const b = t || 'finalized',
            { confirmationStatus: m } = y.value;
          switch (b) {
            case 'processed':
            case 'recent':
              if (m !== 'processed' && m !== 'confirmed' && m !== 'finalized') throw new Ea(a);
              break;
            case 'confirmed':
            case 'single':
            case 'singleGossip':
              if (m !== 'confirmed' && m !== 'finalized') throw new Ea(a);
              break;
            case 'finalized':
            case 'max':
            case 'root':
              if (m !== 'finalized') throw new Ea(a);
              break;
            default:
          }
          f = { context: y.context, value: { err: y.value.err } };
        } else throw new Ea(a);
      }
    } finally {
      (c = !0), l();
    }
    return f;
  }
  async confirmTransactionUsingLegacyTimeoutStrategy({ commitment: t, signature: n }) {
    let r;
    const i = new Promise((s) => {
        let l = this._confirmTransactionInitialTimeout || 6e4;
        switch (t) {
          case 'processed':
          case 'recent':
          case 'single':
          case 'confirmed':
          case 'singleGossip': {
            l = this._confirmTransactionInitialTimeout || 3e4;
            break;
          }
        }
        r = setTimeout(() => s({ __type: rr.TIMED_OUT, timeoutMs: l }), l);
      }),
      { abortConfirmation: o, confirmationPromise: a } = this.getTransactionConfirmationPromise({
        commitment: t,
        signature: n,
      });
    let c;
    try {
      const s = await Promise.race([a, i]);
      if (s.__type === rr.PROCESSED) c = s.response;
      else throw new m1(n, s.timeoutMs / 1e3);
    } finally {
      clearTimeout(r), o();
    }
    return c;
  }
  async getClusterNodes() {
    const t = await this._rpcRequest('getClusterNodes', []),
      n = le(t, He(ge(_U)));
    if ('error' in n) throw new ve(n.error, 'failed to get cluster nodes');
    return n.result;
  }
  async getVoteAccounts(t) {
    const n = this._buildArgs([], t),
      r = await this._rpcRequest('getVoteAccounts', n),
      i = le(r, vU);
    if ('error' in i) throw new ve(i.error, 'failed to get vote accounts');
    return i.result;
  }
  async getSlot(t) {
    const { commitment: n, config: r } = kt(t),
      i = this._buildArgs([], n, void 0, r),
      o = await this._rpcRequest('getSlot', i),
      a = le(o, He(U()));
    if ('error' in a) throw new ve(a.error, 'failed to get slot');
    return a.result;
  }
  async getSlotLeader(t) {
    const { commitment: n, config: r } = kt(t),
      i = this._buildArgs([], n, void 0, r),
      o = await this._rpcRequest('getSlotLeader', i),
      a = le(o, He(se()));
    if ('error' in a) throw new ve(a.error, 'failed to get slot leader');
    return a.result;
  }
  async getSlotLeaders(t, n) {
    const r = [t, n],
      i = await this._rpcRequest('getSlotLeaders', r),
      o = le(i, He(ge(zt)));
    if ('error' in o) throw new ve(o.error, 'failed to get slot leaders');
    return o.result;
  }
  async getSignatureStatus(t, n) {
    const { context: r, value: i } = await this.getSignatureStatuses([t], n);
    ot(i.length === 1);
    const o = i[0];
    return { context: r, value: o };
  }
  async getSignatureStatuses(t, n) {
    const r = [t];
    n && r.push(n);
    const i = await this._rpcRequest('getSignatureStatuses', r),
      o = le(i, IU);
    if ('error' in o) throw new ve(o.error, 'failed to get signature status');
    return o.result;
  }
  async getTransactionCount(t) {
    const { commitment: n, config: r } = kt(t),
      i = this._buildArgs([], n, void 0, r),
      o = await this._rpcRequest('getTransactionCount', i),
      a = le(o, He(U()));
    if ('error' in a) throw new ve(a.error, 'failed to get transaction count');
    return a.result;
  }
  async getTotalSupply(t) {
    return (await this.getSupply({ commitment: t, excludeNonCirculatingAccountsList: !0 })).value
      .total;
  }
  async getInflationGovernor(t) {
    const n = this._buildArgs([], t),
      r = await this._rpcRequest('getInflationGovernor', n),
      i = le(r, GN);
    if ('error' in i) throw new ve(i.error, 'failed to get inflation');
    return i.result;
  }
  async getInflationReward(t, n, r) {
    const { commitment: i, config: o } = kt(r),
      a = this._buildArgs([t.map((l) => l.toBase58())], i, void 0, {
        ...o,
        epoch: n ?? (o == null ? void 0 : o.epoch),
      }),
      c = await this._rpcRequest('getInflationReward', a),
      s = le(c, jN);
    if ('error' in s) throw new ve(s.error, 'failed to get inflation reward');
    return s.result;
  }
  async getInflationRate() {
    const t = await this._rpcRequest('getInflationRate', []),
      n = le(t, YN);
    if ('error' in n) throw new ve(n.error, 'failed to get inflation rate');
    return n.result;
  }
  async getEpochInfo(t) {
    const { commitment: n, config: r } = kt(t),
      i = this._buildArgs([], n, void 0, r),
      o = await this._rpcRequest('getEpochInfo', i),
      a = le(o, ZN);
    if ('error' in a) throw new ve(a.error, 'failed to get epoch info');
    return a.result;
  }
  async getEpochSchedule() {
    const t = await this._rpcRequest('getEpochSchedule', []),
      n = le(t, QN);
    if ('error' in n) throw new ve(n.error, 'failed to get epoch schedule');
    const r = n.result;
    return new qT(
      r.slotsPerEpoch,
      r.leaderScheduleSlotOffset,
      r.warmup,
      r.firstNormalEpoch,
      r.firstNormalSlot
    );
  }
  async getLeaderSchedule() {
    const t = await this._rpcRequest('getLeaderSchedule', []),
      n = le(t, JN);
    if ('error' in n) throw new ve(n.error, 'failed to get leader schedule');
    return n.result;
  }
  async getMinimumBalanceForRentExemption(t, n) {
    const r = this._buildArgs([t], n),
      i = await this._rpcRequest('getMinimumBalanceForRentExemption', r),
      o = le(i, EU);
    return 'error' in o
      ? (console.warn('Unable to fetch minimum balance for rent exemption'), 0)
      : o.result;
  }
  async getRecentBlockhashAndContext(t) {
    const n = this._buildArgs([], t),
      r = await this._rpcRequest('getRecentBlockhash', n),
      i = le(r, BU);
    if ('error' in i) throw new ve(i.error, 'failed to get recent blockhash');
    return i.result;
  }
  async getRecentPerformanceSamples(t) {
    const n = await this._rpcRequest('getRecentPerformanceSamples', t ? [t] : []),
      r = le(n, UU);
    if ('error' in r) throw new ve(r.error, 'failed to get recent performance samples');
    return r.result;
  }
  async getFeeCalculatorForBlockhash(t, n) {
    const r = this._buildArgs([t], n),
      i = await this._rpcRequest('getFeeCalculatorForBlockhash', r),
      o = le(i, LU);
    if ('error' in o) throw new ve(o.error, 'failed to get fee calculator');
    const { context: a, value: c } = o.result;
    return { context: a, value: c !== null ? c.feeCalculator : null };
  }
  async getFeeForMessage(t, n) {
    const r = Ke(t.serialize()).toString('base64'),
      i = this._buildArgs([r], n),
      o = await this._rpcRequest('getFeeForMessage', i),
      a = le(o, Ut(pe(U())));
    if ('error' in a) throw new ve(a.error, 'failed to get fee for message');
    if (a.result === null) throw new Error('invalid blockhash');
    return a.result;
  }
  async getRecentBlockhash(t) {
    try {
      return (await this.getRecentBlockhashAndContext(t)).value;
    } catch (n) {
      throw new Error('failed to get recent blockhash: ' + n);
    }
  }
  async getLatestBlockhash(t) {
    try {
      return (await this.getLatestBlockhashAndContext(t)).value;
    } catch (n) {
      throw new Error('failed to get recent blockhash: ' + n);
    }
  }
  async getLatestBlockhashAndContext(t) {
    const { commitment: n, config: r } = kt(t),
      i = this._buildArgs([], n, void 0, r),
      o = await this._rpcRequest('getLatestBlockhash', i),
      a = le(o, jU);
    if ('error' in a) throw new ve(a.error, 'failed to get latest blockhash');
    return a.result;
  }
  async getVersion() {
    const t = await this._rpcRequest('getVersion', []),
      n = le(t, He(WN));
    if ('error' in n) throw new ve(n.error, 'failed to get version');
    return n.result;
  }
  async getGenesisHash() {
    const t = await this._rpcRequest('getGenesisHash', []),
      n = le(t, He(se()));
    if ('error' in n) throw new ve(n.error, 'failed to get genesis hash');
    return n.result;
  }
  async getBlock(t, n) {
    const { commitment: r, config: i } = kt(n),
      o = this._buildArgsAtLeastConfirmed([t], r, void 0, i),
      a = await this._rpcRequest('getBlock', o);
    try {
      switch (i == null ? void 0 : i.transactionDetails) {
        case 'accounts': {
          const c = le(a, PU);
          if ('error' in c) throw c.error;
          return c.result;
        }
        case 'none': {
          const c = le(a, MU);
          if ('error' in c) throw c.error;
          return c.result;
        }
        default: {
          const c = le(a, CU);
          if ('error' in c) throw c.error;
          const { result: s } = c;
          return s
            ? {
                ...s,
                transactions: s.transactions.map(({ transaction: l, meta: u, version: d }) => ({
                  meta: u,
                  transaction: { ...l, message: eb(d, l.message) },
                  version: d,
                })),
              }
            : null;
        }
      }
    } catch (c) {
      throw new ve(c, 'failed to get confirmed block');
    }
  }
  async getParsedBlock(t, n) {
    const { commitment: r, config: i } = kt(n),
      o = this._buildArgsAtLeastConfirmed([t], r, 'jsonParsed', i),
      a = await this._rpcRequest('getBlock', o);
    try {
      switch (i == null ? void 0 : i.transactionDetails) {
        case 'accounts': {
          const c = le(a, DU);
          if ('error' in c) throw c.error;
          return c.result;
        }
        case 'none': {
          const c = le(a, RU);
          if ('error' in c) throw c.error;
          return c.result;
        }
        default: {
          const c = le(a, OU);
          if ('error' in c) throw c.error;
          return c.result;
        }
      }
    } catch (c) {
      throw new ve(c, 'failed to get block');
    }
  }
  async getBlockProduction(t) {
    let n, r;
    if (typeof t == 'string') r = t;
    else if (t) {
      const { commitment: c, ...s } = t;
      (r = c), (n = s);
    }
    const i = this._buildArgs([], r, 'base64', n),
      o = await this._rpcRequest('getBlockProduction', i),
      a = le(o, VN);
    if ('error' in a) throw new ve(a.error, 'failed to get block production information');
    return a.result;
  }
  async getTransaction(t, n) {
    const { commitment: r, config: i } = kt(n),
      o = this._buildArgsAtLeastConfirmed([t], r, void 0, i),
      a = await this._rpcRequest('getTransaction', o),
      c = le(a, tb);
    if ('error' in c) throw new ve(c.error, 'failed to get transaction');
    const s = c.result;
    return (
      s && {
        ...s,
        transaction: { ...s.transaction, message: eb(s.version, s.transaction.message) },
      }
    );
  }
  async getParsedTransaction(t, n) {
    const { commitment: r, config: i } = kt(n),
      o = this._buildArgsAtLeastConfirmed([t], r, 'jsonParsed', i),
      a = await this._rpcRequest('getTransaction', o),
      c = le(a, Xf);
    if ('error' in c) throw new ve(c.error, 'failed to get transaction');
    return c.result;
  }
  async getParsedTransactions(t, n) {
    const { commitment: r, config: i } = kt(n),
      o = t.map((s) => ({
        methodName: 'getTransaction',
        args: this._buildArgsAtLeastConfirmed([s], r, 'jsonParsed', i),
      }));
    return (await this._rpcBatchRequest(o)).map((s) => {
      const l = le(s, Xf);
      if ('error' in l) throw new ve(l.error, 'failed to get transactions');
      return l.result;
    });
  }
  async getTransactions(t, n) {
    const { commitment: r, config: i } = kt(n),
      o = t.map((s) => ({
        methodName: 'getTransaction',
        args: this._buildArgsAtLeastConfirmed([s], r, void 0, i),
      }));
    return (await this._rpcBatchRequest(o)).map((s) => {
      const l = le(s, tb);
      if ('error' in l) throw new ve(l.error, 'failed to get transactions');
      const u = l.result;
      return (
        u && {
          ...u,
          transaction: { ...u.transaction, message: eb(u.version, u.transaction.message) },
        }
      );
    });
  }
  async getConfirmedBlock(t, n) {
    const r = this._buildArgsAtLeastConfirmed([t], n),
      i = await this._rpcRequest('getConfirmedBlock', r),
      o = le(i, xU);
    if ('error' in o) throw new ve(o.error, 'failed to get confirmed block');
    const a = o.result;
    if (!a) throw new Error('Confirmed block ' + t + ' not found');
    const c = {
      ...a,
      transactions: a.transactions.map(({ transaction: s, meta: l }) => {
        const u = new mr(s.message);
        return { meta: l, transaction: { ...s, message: u } };
      }),
    };
    return {
      ...c,
      transactions: c.transactions.map(({ transaction: s, meta: l }) => ({
        meta: l,
        transaction: yt.populate(s.message, s.signatures),
      })),
    };
  }
  async getBlocks(t, n, r) {
    const i = this._buildArgsAtLeastConfirmed(n !== void 0 ? [t, n] : [t], r),
      o = await this._rpcRequest('getBlocks', i),
      a = le(o, He(ge(U())));
    if ('error' in a) throw new ve(a.error, 'failed to get blocks');
    return a.result;
  }
  async getBlockSignatures(t, n) {
    const r = this._buildArgsAtLeastConfirmed([t], n, void 0, {
        transactionDetails: 'signatures',
        rewards: !1,
      }),
      i = await this._rpcRequest('getBlock', r),
      o = le(i, L_);
    if ('error' in o) throw new ve(o.error, 'failed to get block');
    const a = o.result;
    if (!a) throw new Error('Block ' + t + ' not found');
    return a;
  }
  async getConfirmedBlockSignatures(t, n) {
    const r = this._buildArgsAtLeastConfirmed([t], n, void 0, {
        transactionDetails: 'signatures',
        rewards: !1,
      }),
      i = await this._rpcRequest('getConfirmedBlock', r),
      o = le(i, L_);
    if ('error' in o) throw new ve(o.error, 'failed to get confirmed block');
    const a = o.result;
    if (!a) throw new Error('Confirmed block ' + t + ' not found');
    return a;
  }
  async getConfirmedTransaction(t, n) {
    const r = this._buildArgsAtLeastConfirmed([t], n),
      i = await this._rpcRequest('getConfirmedTransaction', r),
      o = le(i, tb);
    if ('error' in o) throw new ve(o.error, 'failed to get transaction');
    const a = o.result;
    if (!a) return a;
    const c = new mr(a.transaction.message),
      s = a.transaction.signatures;
    return { ...a, transaction: yt.populate(c, s) };
  }
  async getParsedConfirmedTransaction(t, n) {
    const r = this._buildArgsAtLeastConfirmed([t], n, 'jsonParsed'),
      i = await this._rpcRequest('getConfirmedTransaction', r),
      o = le(i, Xf);
    if ('error' in o) throw new ve(o.error, 'failed to get confirmed transaction');
    return o.result;
  }
  async getParsedConfirmedTransactions(t, n) {
    const r = t.map((a) => ({
      methodName: 'getConfirmedTransaction',
      args: this._buildArgsAtLeastConfirmed([a], n, 'jsonParsed'),
    }));
    return (await this._rpcBatchRequest(r)).map((a) => {
      const c = le(a, Xf);
      if ('error' in c) throw new ve(c.error, 'failed to get confirmed transactions');
      return c.result;
    });
  }
  async getConfirmedSignaturesForAddress(t, n, r) {
    let i = {},
      o = await this.getFirstAvailableBlock();
    for (; !('until' in i) && (n--, !(n <= 0 || n < o)); )
      try {
        const s = await this.getConfirmedBlockSignatures(n, 'finalized');
        s.signatures.length > 0 && (i.until = s.signatures[s.signatures.length - 1].toString());
      } catch (s) {
        if (s instanceof Error && s.message.includes('skipped')) continue;
        throw s;
      }
    let a = await this.getSlot('finalized');
    for (; !('before' in i) && (r++, !(r > a)); )
      try {
        const s = await this.getConfirmedBlockSignatures(r);
        s.signatures.length > 0 && (i.before = s.signatures[s.signatures.length - 1].toString());
      } catch (s) {
        if (s instanceof Error && s.message.includes('skipped')) continue;
        throw s;
      }
    return (await this.getConfirmedSignaturesForAddress2(t, i)).map((s) => s.signature);
  }
  async getConfirmedSignaturesForAddress2(t, n, r) {
    const i = this._buildArgsAtLeastConfirmed([t.toBase58()], r, void 0, n),
      o = await this._rpcRequest('getConfirmedSignaturesForAddress2', i),
      a = le(o, uU);
    if ('error' in a) throw new ve(a.error, 'failed to get confirmed signatures for address');
    return a.result;
  }
  async getSignaturesForAddress(t, n, r) {
    const i = this._buildArgsAtLeastConfirmed([t.toBase58()], r, void 0, n),
      o = await this._rpcRequest('getSignaturesForAddress', i),
      a = le(o, lU);
    if ('error' in a) throw new ve(a.error, 'failed to get signatures for address');
    return a.result;
  }
  async getAddressLookupTable(t, n) {
    const { context: r, value: i } = await this.getAccountInfoAndContext(t, n);
    let o = null;
    return (
      i !== null && (o = new Wm({ key: t, state: Wm.deserialize(i.data) })),
      { context: r, value: o }
    );
  }
  async getNonceAndContext(t, n) {
    const { context: r, value: i } = await this.getAccountInfoAndContext(t, n);
    let o = null;
    return i !== null && (o = ig.fromAccountData(i.data)), { context: r, value: o };
  }
  async getNonce(t, n) {
    return await this.getNonceAndContext(t, n)
      .then((r) => r.value)
      .catch((r) => {
        throw new Error('failed to get nonce for account ' + t.toBase58() + ': ' + r);
      });
  }
  async requestAirdrop(t, n) {
    const r = await this._rpcRequest('requestAirdrop', [t.toBase58(), n]),
      i = le(r, zU);
    if ('error' in i) throw new ve(i.error, `airdrop to ${t.toBase58()} failed`);
    return i.result;
  }
  async _blockhashWithExpiryBlockHeight(t) {
    if (!t) {
      for (; this._pollingBlockhash; ) await To(100);
      const r = Date.now() - this._blockhashInfo.lastFetch >= YT;
      if (this._blockhashInfo.latestBlockhash !== null && !r)
        return this._blockhashInfo.latestBlockhash;
    }
    return await this._pollNewBlockhash();
  }
  async _pollNewBlockhash() {
    this._pollingBlockhash = !0;
    try {
      const t = Date.now(),
        n = this._blockhashInfo.latestBlockhash,
        r = n ? n.blockhash : null;
      for (let i = 0; i < 50; i++) {
        const o = await this.getLatestBlockhash('finalized');
        if (r !== o.blockhash)
          return (
            (this._blockhashInfo = {
              latestBlockhash: o,
              lastFetch: Date.now(),
              transactionSignatures: [],
              simulatedSignatures: [],
            }),
            o
          );
        await To(CN / 2);
      }
      throw new Error(`Unable to obtain a new blockhash after ${Date.now() - t}ms`);
    } finally {
      this._pollingBlockhash = !1;
    }
  }
  async getStakeMinimumDelegation(t) {
    const { commitment: n, config: r } = kt(t),
      i = this._buildArgs([], n, 'base64', r),
      o = await this._rpcRequest('getStakeMinimumDelegation', i),
      a = le(o, Ut(U()));
    if ('error' in a) throw new ve(a.error, 'failed to get stake minimum delegation');
    return a.result;
  }
  async simulateTransaction(t, n, r) {
    if ('message' in t) {
      const b = t.serialize(),
        m = Ae.from(b).toString('base64');
      if (Array.isArray(n) || r !== void 0) throw new Error('Invalid arguments');
      const w = n || {};
      (w.encoding = 'base64'), 'commitment' in w || (w.commitment = this.commitment);
      const _ = [m, w],
        S = await this._rpcRequest('simulateTransaction', _),
        E = le(S, N_);
      if ('error' in E) throw new Error('failed to simulate transaction: ' + E.error.message);
      return E.result;
    }
    let i;
    if (t instanceof yt) {
      let y = t;
      (i = new yt()),
        (i.feePayer = y.feePayer),
        (i.instructions = t.instructions),
        (i.nonceInfo = y.nonceInfo),
        (i.signatures = y.signatures);
    } else (i = yt.populate(t)), (i._message = i._json = void 0);
    if (n !== void 0 && !Array.isArray(n)) throw new Error('Invalid arguments');
    const o = n;
    if (i.nonceInfo && o) i.sign(...o);
    else {
      let y = this._disableBlockhashCaching;
      for (;;) {
        const b = await this._blockhashWithExpiryBlockHeight(y);
        if (
          ((i.lastValidBlockHeight = b.lastValidBlockHeight), (i.recentBlockhash = b.blockhash), !o)
        )
          break;
        if ((i.sign(...o), !i.signature)) throw new Error('!signature');
        const m = i.signature.toString('base64');
        if (
          !this._blockhashInfo.simulatedSignatures.includes(m) &&
          !this._blockhashInfo.transactionSignatures.includes(m)
        ) {
          this._blockhashInfo.simulatedSignatures.push(m);
          break;
        } else y = !0;
      }
    }
    const a = i._compile(),
      c = a.serialize(),
      l = i._serialize(c).toString('base64'),
      u = { encoding: 'base64', commitment: this.commitment };
    if (r) {
      const y = (Array.isArray(r) ? r : a.nonProgramIds()).map((b) => b.toBase58());
      u.accounts = { encoding: 'base64', addresses: y };
    }
    o && (u.sigVerify = !0);
    const d = [l, u],
      f = await this._rpcRequest('simulateTransaction', d),
      p = le(f, N_);
    if ('error' in p) {
      let y;
      if ('data' in p.error && ((y = p.error.data.logs), y && Array.isArray(y))) {
        const b = `
    `,
          m = b + y.join(b);
        console.error(p.error.message, m);
      }
      throw new $m('failed to simulate transaction: ' + p.error.message, y);
    }
    return p.result;
  }
  async sendTransaction(t, n, r) {
    if ('version' in t) {
      if (n && Array.isArray(n)) throw new Error('Invalid arguments');
      const a = t.serialize();
      return await this.sendRawTransaction(a, n);
    }
    if (n === void 0 || !Array.isArray(n)) throw new Error('Invalid arguments');
    const i = n;
    if (t.nonceInfo) t.sign(...i);
    else {
      let a = this._disableBlockhashCaching;
      for (;;) {
        const c = await this._blockhashWithExpiryBlockHeight(a);
        if (
          ((t.lastValidBlockHeight = c.lastValidBlockHeight),
          (t.recentBlockhash = c.blockhash),
          t.sign(...i),
          !t.signature)
        )
          throw new Error('!signature');
        const s = t.signature.toString('base64');
        if (this._blockhashInfo.transactionSignatures.includes(s)) a = !0;
        else {
          this._blockhashInfo.transactionSignatures.push(s);
          break;
        }
      }
    }
    const o = t.serialize();
    return await this.sendRawTransaction(o, r);
  }
  async sendRawTransaction(t, n) {
    const r = Ke(t).toString('base64');
    return await this.sendEncodedTransaction(r, n);
  }
  async sendEncodedTransaction(t, n) {
    const r = { encoding: 'base64' },
      i = n && n.skipPreflight,
      o = (n && n.preflightCommitment) || this.commitment;
    n && n.maxRetries != null && (r.maxRetries = n.maxRetries),
      n && n.minContextSlot != null && (r.minContextSlot = n.minContextSlot),
      i && (r.skipPreflight = i),
      o && (r.preflightCommitment = o);
    const a = [t, r],
      c = await this._rpcRequest('sendTransaction', a),
      s = le(c, FU);
    if ('error' in s) {
      let l;
      throw (
        ('data' in s.error && (l = s.error.data.logs),
        new $m('failed to send transaction: ' + s.error.message, l))
      );
    }
    return s.result;
  }
  _wsOnOpen() {
    (this._rpcWebSocketConnected = !0),
      (this._rpcWebSocketHeartbeat = setInterval(() => {
        (async () => {
          try {
            await this._rpcWebSocket.notify('ping');
          } catch {}
        })();
      }, 5e3)),
      this._updateSubscriptions();
  }
  _wsOnError(t) {
    (this._rpcWebSocketConnected = !1), console.error('ws error:', t.message);
  }
  _wsOnClose(t) {
    if (
      ((this._rpcWebSocketConnected = !1),
      (this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER),
      this._rpcWebSocketIdleTimeout &&
        (clearTimeout(this._rpcWebSocketIdleTimeout), (this._rpcWebSocketIdleTimeout = null)),
      this._rpcWebSocketHeartbeat &&
        (clearInterval(this._rpcWebSocketHeartbeat), (this._rpcWebSocketHeartbeat = null)),
      t === 1e3)
    ) {
      this._updateSubscriptions();
      return;
    }
    (this._subscriptionCallbacksByServerSubscriptionId = {}),
      Object.entries(this._subscriptionsByHash).forEach(([n, r]) => {
        this._setSubscription(n, { ...r, state: 'pending' });
      });
  }
  _setSubscription(t, n) {
    var i;
    const r = (i = this._subscriptionsByHash[t]) == null ? void 0 : i.state;
    if (((this._subscriptionsByHash[t] = n), r !== n.state)) {
      const o = this._subscriptionStateChangeCallbacksByHash[t];
      o &&
        o.forEach((a) => {
          try {
            a(n.state);
          } catch {}
        });
    }
  }
  _onSubscriptionStateChange(t, n) {
    var r;
    const i = this._subscriptionHashByClientSubscriptionId[t];
    if (i == null) return () => {};
    const o = (r = this._subscriptionStateChangeCallbacksByHash)[i] || (r[i] = new Set());
    return (
      o.add(n),
      () => {
        o.delete(n), o.size === 0 && delete this._subscriptionStateChangeCallbacksByHash[i];
      }
    );
  }
  async _updateSubscriptions() {
    if (Object.keys(this._subscriptionsByHash).length === 0) {
      this._rpcWebSocketConnected &&
        ((this._rpcWebSocketConnected = !1),
        (this._rpcWebSocketIdleTimeout = setTimeout(() => {
          this._rpcWebSocketIdleTimeout = null;
          try {
            this._rpcWebSocket.close();
          } catch (r) {
            r instanceof Error && console.log(`Error when closing socket connection: ${r.message}`);
          }
        }, 500)));
      return;
    }
    if (
      (this._rpcWebSocketIdleTimeout !== null &&
        (clearTimeout(this._rpcWebSocketIdleTimeout),
        (this._rpcWebSocketIdleTimeout = null),
        (this._rpcWebSocketConnected = !0)),
      !this._rpcWebSocketConnected)
    ) {
      this._rpcWebSocket.connect();
      return;
    }
    const t = this._rpcWebSocketGeneration,
      n = () => t === this._rpcWebSocketGeneration;
    await Promise.all(
      Object.keys(this._subscriptionsByHash).map(async (r) => {
        const i = this._subscriptionsByHash[r];
        if (i !== void 0)
          switch (i.state) {
            case 'pending':
            case 'unsubscribed':
              if (i.callbacks.size === 0) {
                delete this._subscriptionsByHash[r],
                  i.state === 'unsubscribed' &&
                    delete this._subscriptionCallbacksByServerSubscriptionId[
                      i.serverSubscriptionId
                    ],
                  await this._updateSubscriptions();
                return;
              }
              await (async () => {
                const { args: o, method: a } = i;
                try {
                  this._setSubscription(r, { ...i, state: 'subscribing' });
                  const c = await this._rpcWebSocket.call(a, o);
                  this._setSubscription(r, { ...i, serverSubscriptionId: c, state: 'subscribed' }),
                    (this._subscriptionCallbacksByServerSubscriptionId[c] = i.callbacks),
                    await this._updateSubscriptions();
                } catch (c) {
                  if (
                    (c instanceof Error && console.error(`${a} error for argument`, o, c.message),
                    !n())
                  )
                    return;
                  this._setSubscription(r, { ...i, state: 'pending' }),
                    await this._updateSubscriptions();
                }
              })();
              break;
            case 'subscribed':
              i.callbacks.size === 0 &&
                (await (async () => {
                  const { serverSubscriptionId: o, unsubscribeMethod: a } = i;
                  if (this._subscriptionsAutoDisposedByRpc.has(o))
                    this._subscriptionsAutoDisposedByRpc.delete(o);
                  else {
                    this._setSubscription(r, { ...i, state: 'unsubscribing' }),
                      this._setSubscription(r, { ...i, state: 'unsubscribing' });
                    try {
                      await this._rpcWebSocket.call(a, [o]);
                    } catch (c) {
                      if ((c instanceof Error && console.error(`${a} error:`, c.message), !n()))
                        return;
                      this._setSubscription(r, { ...i, state: 'subscribed' }),
                        await this._updateSubscriptions();
                      return;
                    }
                  }
                  this._setSubscription(r, { ...i, state: 'unsubscribed' }),
                    await this._updateSubscriptions();
                })());
              break;
          }
      })
    );
  }
  _handleServerNotification(t, n) {
    const r = this._subscriptionCallbacksByServerSubscriptionId[t];
    r !== void 0 &&
      r.forEach((i) => {
        try {
          i(...n);
        } catch (o) {
          console.error(o);
        }
      });
  }
  _wsOnAccountNotification(t) {
    const { result: n, subscription: r } = le(t, dU);
    this._handleServerNotification(r, [n.value, n.context]);
  }
  _makeSubscription(t, n) {
    const r = this._nextClientSubscriptionId++,
      i = B_([t.method, n]),
      o = this._subscriptionsByHash[i];
    return (
      o === void 0
        ? (this._subscriptionsByHash[i] = {
            ...t,
            args: n,
            callbacks: new Set([t.callback]),
            state: 'pending',
          })
        : o.callbacks.add(t.callback),
      (this._subscriptionHashByClientSubscriptionId[r] = i),
      (this._subscriptionDisposeFunctionsByClientSubscriptionId[r] = async () => {
        delete this._subscriptionDisposeFunctionsByClientSubscriptionId[r],
          delete this._subscriptionHashByClientSubscriptionId[r];
        const a = this._subscriptionsByHash[i];
        ot(
          a !== void 0,
          `Could not find a \`Subscription\` when tearing down client subscription #${r}`
        ),
          a.callbacks.delete(t.callback),
          await this._updateSubscriptions();
      }),
      this._updateSubscriptions(),
      r
    );
  }
  onAccountChange(t, n, r) {
    const i = this._buildArgs([t.toBase58()], r || this._commitment || 'finalized', 'base64');
    return this._makeSubscription(
      { callback: n, method: 'accountSubscribe', unsubscribeMethod: 'accountUnsubscribe' },
      i
    );
  }
  async removeAccountChangeListener(t) {
    await this._unsubscribeClientSubscription(t, 'account change');
  }
  _wsOnProgramAccountNotification(t) {
    const { result: n, subscription: r } = le(t, hU);
    this._handleServerNotification(r, [
      { accountId: n.value.pubkey, accountInfo: n.value.account },
      n.context,
    ]);
  }
  onProgramAccountChange(t, n, r, i) {
    const o = this._buildArgs(
      [t.toBase58()],
      r || this._commitment || 'finalized',
      'base64',
      i ? { filters: i } : void 0
    );
    return this._makeSubscription(
      { callback: n, method: 'programSubscribe', unsubscribeMethod: 'programUnsubscribe' },
      o
    );
  }
  async removeProgramAccountChangeListener(t) {
    await this._unsubscribeClientSubscription(t, 'program account change');
  }
  onLogs(t, n, r) {
    const i = this._buildArgs(
      [typeof t == 'object' ? { mentions: [t.toString()] } : t],
      r || this._commitment || 'finalized'
    );
    return this._makeSubscription(
      { callback: n, method: 'logsSubscribe', unsubscribeMethod: 'logsUnsubscribe' },
      i
    );
  }
  async removeOnLogsListener(t) {
    await this._unsubscribeClientSubscription(t, 'logs');
  }
  _wsOnLogsNotification(t) {
    const { result: n, subscription: r } = le(t, WU);
    this._handleServerNotification(r, [n.value, n.context]);
  }
  _wsOnSlotNotification(t) {
    const { result: n, subscription: r } = le(t, gU);
    this._handleServerNotification(r, [n]);
  }
  onSlotChange(t) {
    return this._makeSubscription(
      { callback: t, method: 'slotSubscribe', unsubscribeMethod: 'slotUnsubscribe' },
      []
    );
  }
  async removeSlotChangeListener(t) {
    await this._unsubscribeClientSubscription(t, 'slot change');
  }
  _wsOnSlotUpdatesNotification(t) {
    const { result: n, subscription: r } = le(t, bU);
    this._handleServerNotification(r, [n]);
  }
  onSlotUpdate(t) {
    return this._makeSubscription(
      {
        callback: t,
        method: 'slotsUpdatesSubscribe',
        unsubscribeMethod: 'slotsUpdatesUnsubscribe',
      },
      []
    );
  }
  async removeSlotUpdateListener(t) {
    await this._unsubscribeClientSubscription(t, 'slot update');
  }
  async _unsubscribeClientSubscription(t, n) {
    const r = this._subscriptionDisposeFunctionsByClientSubscriptionId[t];
    r
      ? await r()
      : console.warn(
          `Ignored unsubscribe request because an active subscription with id \`${t}\` for '${n}' events could not be found.`
        );
  }
  _buildArgs(t, n, r, i) {
    const o = n || this._commitment;
    if (o || r || i) {
      let a = {};
      r && (a.encoding = r), o && (a.commitment = o), i && (a = Object.assign(a, i)), t.push(a);
    }
    return t;
  }
  _buildArgsAtLeastConfirmed(t, n, r, i) {
    const o = n || this._commitment;
    if (o && !['confirmed', 'finalized'].includes(o))
      throw new Error(
        'Using Connection with default commitment: `' +
          this._commitment +
          '`, but method requires at least `confirmed`'
      );
    return this._buildArgs(t, n, r, i);
  }
  _wsOnSignatureNotification(t) {
    const { result: n, subscription: r } = le(t, mU);
    n.value !== 'receivedSignature' && this._subscriptionsAutoDisposedByRpc.add(r),
      this._handleServerNotification(
        r,
        n.value === 'receivedSignature'
          ? [{ type: 'received' }, n.context]
          : [{ type: 'status', result: n.value }, n.context]
      );
  }
  onSignature(t, n, r) {
    const i = this._buildArgs([t], r || this._commitment || 'finalized'),
      o = this._makeSubscription(
        {
          callback: (a, c) => {
            if (a.type === 'status') {
              n(a.result, c);
              try {
                this.removeSignatureListener(o);
              } catch {}
            }
          },
          method: 'signatureSubscribe',
          unsubscribeMethod: 'signatureUnsubscribe',
        },
        i
      );
    return o;
  }
  onSignatureWithOptions(t, n, r) {
    const { commitment: i, ...o } = {
        ...r,
        commitment: (r && r.commitment) || this._commitment || 'finalized',
      },
      a = this._buildArgs([t], i, void 0, o),
      c = this._makeSubscription(
        {
          callback: (s, l) => {
            n(s, l);
            try {
              this.removeSignatureListener(c);
            } catch {}
          },
          method: 'signatureSubscribe',
          unsubscribeMethod: 'signatureUnsubscribe',
        },
        a
      );
    return c;
  }
  async removeSignatureListener(t) {
    await this._unsubscribeClientSubscription(t, 'signature result');
  }
  _wsOnRootNotification(t) {
    const { result: n, subscription: r } = le(t, wU);
    this._handleServerNotification(r, [n]);
  }
  onRootChange(t) {
    return this._makeSubscription(
      { callback: t, method: 'rootSubscribe', unsubscribeMethod: 'rootUnsubscribe' },
      []
    );
  }
  async removeRootChangeListener(t) {
    await this._unsubscribeClientSubscription(t, 'root change');
  }
}
class Ra {
  constructor(t) {
    (this._keypair = void 0), (this._keypair = t ?? D_());
  }
  static generate() {
    return new Ra(D_());
  }
  static fromSecretKey(t, n) {
    if (t.byteLength !== 64) throw new Error('bad secret key size');
    const r = t.slice(32, 64);
    if (!n || !n.skipValidation) {
      const i = t.slice(0, 32),
        o = sp(i);
      for (let a = 0; a < 32; a++)
        if (r[a] !== o[a]) throw new Error('provided secretKey is invalid');
    }
    return new Ra({ publicKey: r, secretKey: t });
  }
  static fromSeed(t) {
    const n = sp(t),
      r = new Uint8Array(64);
    return r.set(t), r.set(n, 32), new Ra({ publicKey: n, secretKey: r });
  }
  get publicKey() {
    return new de(this._keypair.publicKey);
  }
  get secretKey() {
    return new Uint8Array(this._keypair.secretKey);
  }
}
const ni = Object.freeze({
  CreateLookupTable: {
    index: 0,
    layout: me([we('instruction'), Qa('recentSlot'), et('bumpSeed')]),
  },
  FreezeLookupTable: { index: 1, layout: me([we('instruction')]) },
  ExtendLookupTable: {
    index: 2,
    layout: me([we('instruction'), Qa(), fn(Ge(), No(we(), -8), 'addresses')]),
  },
  DeactivateLookupTable: { index: 3, layout: me([we('instruction')]) },
  CloseLookupTable: { index: 4, layout: me([we('instruction')]) },
});
class HU {
  constructor() {}
  static decodeInstructionType(t) {
    this.checkProgramId(t.programId);
    const r = we('instruction').decode(t.data);
    let i;
    for (const [o, a] of Object.entries(ni))
      if (a.index == r) {
        i = o;
        break;
      }
    if (!i) throw new Error('Invalid Instruction. Should be a LookupTable Instruction');
    return i;
  }
  static decodeCreateLookupTable(t) {
    this.checkProgramId(t.programId), this.checkKeysLength(t.keys, 4);
    const { recentSlot: n } = ut(ni.CreateLookupTable, t.data);
    return { authority: t.keys[1].pubkey, payer: t.keys[2].pubkey, recentSlot: Number(n) };
  }
  static decodeExtendLookupTable(t) {
    if ((this.checkProgramId(t.programId), t.keys.length < 2))
      throw new Error(`invalid instruction; found ${t.keys.length} keys, expected at least 2`);
    const { addresses: n } = ut(ni.ExtendLookupTable, t.data);
    return {
      lookupTable: t.keys[0].pubkey,
      authority: t.keys[1].pubkey,
      payer: t.keys.length > 2 ? t.keys[2].pubkey : void 0,
      addresses: n.map((r) => new de(r)),
    };
  }
  static decodeCloseLookupTable(t) {
    return (
      this.checkProgramId(t.programId),
      this.checkKeysLength(t.keys, 3),
      { lookupTable: t.keys[0].pubkey, authority: t.keys[1].pubkey, recipient: t.keys[2].pubkey }
    );
  }
  static decodeFreezeLookupTable(t) {
    return (
      this.checkProgramId(t.programId),
      this.checkKeysLength(t.keys, 2),
      { lookupTable: t.keys[0].pubkey, authority: t.keys[1].pubkey }
    );
  }
  static decodeDeactivateLookupTable(t) {
    return (
      this.checkProgramId(t.programId),
      this.checkKeysLength(t.keys, 2),
      { lookupTable: t.keys[0].pubkey, authority: t.keys[1].pubkey }
    );
  }
  static checkProgramId(t) {
    if (!t.equals(E1.programId))
      throw new Error('invalid instruction; programId is not AddressLookupTable Program');
  }
  static checkKeysLength(t, n) {
    if (t.length < n)
      throw new Error(`invalid instruction; found ${t.length} keys, expected at least ${n}`);
  }
}
class E1 {
  constructor() {}
  static createLookupTable(t) {
    const [n, r] = de.findProgramAddressSync(
        [t.authority.toBuffer(), _I(BigInt(t.recentSlot), 8)],
        this.programId
      ),
      i = ni.CreateLookupTable,
      o = tt(i, { recentSlot: BigInt(t.recentSlot), bumpSeed: r }),
      a = [
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: t.authority, isSigner: !0, isWritable: !1 },
        { pubkey: t.payer, isSigner: !0, isWritable: !0 },
        { pubkey: cn.programId, isSigner: !1, isWritable: !1 },
      ];
    return [new bt({ programId: this.programId, keys: a, data: o }), n];
  }
  static freezeLookupTable(t) {
    const n = ni.FreezeLookupTable,
      r = tt(n),
      i = [
        { pubkey: t.lookupTable, isSigner: !1, isWritable: !0 },
        { pubkey: t.authority, isSigner: !0, isWritable: !1 },
      ];
    return new bt({ programId: this.programId, keys: i, data: r });
  }
  static extendLookupTable(t) {
    const n = ni.ExtendLookupTable,
      r = tt(n, { addresses: t.addresses.map((o) => o.toBytes()) }),
      i = [
        { pubkey: t.lookupTable, isSigner: !1, isWritable: !0 },
        { pubkey: t.authority, isSigner: !0, isWritable: !1 },
      ];
    return (
      t.payer &&
        i.push(
          { pubkey: t.payer, isSigner: !0, isWritable: !0 },
          { pubkey: cn.programId, isSigner: !1, isWritable: !1 }
        ),
      new bt({ programId: this.programId, keys: i, data: r })
    );
  }
  static deactivateLookupTable(t) {
    const n = ni.DeactivateLookupTable,
      r = tt(n),
      i = [
        { pubkey: t.lookupTable, isSigner: !1, isWritable: !0 },
        { pubkey: t.authority, isSigner: !0, isWritable: !1 },
      ];
    return new bt({ programId: this.programId, keys: i, data: r });
  }
  static closeLookupTable(t) {
    const n = ni.CloseLookupTable,
      r = tt(n),
      i = [
        { pubkey: t.lookupTable, isSigner: !1, isWritable: !0 },
        { pubkey: t.authority, isSigner: !0, isWritable: !1 },
        { pubkey: t.recipient, isSigner: !1, isWritable: !0 },
      ];
    return new bt({ programId: this.programId, keys: i, data: r });
  }
}
E1.programId = new de('AddressLookupTab1e1111111111111111111111111');
class qU {
  constructor() {}
  static decodeInstructionType(t) {
    this.checkProgramId(t.programId);
    const r = et('instruction').decode(t.data);
    let i;
    for (const [o, a] of Object.entries(Nr))
      if (a.index == r) {
        i = o;
        break;
      }
    if (!i) throw new Error('Instruction type incorrect; not a ComputeBudgetInstruction');
    return i;
  }
  static decodeRequestUnits(t) {
    this.checkProgramId(t.programId);
    const { units: n, additionalFee: r } = ut(Nr.RequestUnits, t.data);
    return { units: n, additionalFee: r };
  }
  static decodeRequestHeapFrame(t) {
    this.checkProgramId(t.programId);
    const { bytes: n } = ut(Nr.RequestHeapFrame, t.data);
    return { bytes: n };
  }
  static decodeSetComputeUnitLimit(t) {
    this.checkProgramId(t.programId);
    const { units: n } = ut(Nr.SetComputeUnitLimit, t.data);
    return { units: n };
  }
  static decodeSetComputeUnitPrice(t) {
    this.checkProgramId(t.programId);
    const { microLamports: n } = ut(Nr.SetComputeUnitPrice, t.data);
    return { microLamports: n };
  }
  static checkProgramId(t) {
    if (!t.equals(T1.programId))
      throw new Error('invalid instruction; programId is not ComputeBudgetProgram');
  }
}
const Nr = Object.freeze({
  RequestUnits: { index: 0, layout: me([et('instruction'), we('units'), we('additionalFee')]) },
  RequestHeapFrame: { index: 1, layout: me([et('instruction'), we('bytes')]) },
  SetComputeUnitLimit: { index: 2, layout: me([et('instruction'), we('units')]) },
  SetComputeUnitPrice: { index: 3, layout: me([et('instruction'), Qa('microLamports')]) },
});
class T1 {
  constructor() {}
  static requestUnits(t) {
    const n = Nr.RequestUnits,
      r = tt(n, t);
    return new bt({ keys: [], programId: this.programId, data: r });
  }
  static requestHeapFrame(t) {
    const n = Nr.RequestHeapFrame,
      r = tt(n, t);
    return new bt({ keys: [], programId: this.programId, data: r });
  }
  static setComputeUnitLimit(t) {
    const n = Nr.SetComputeUnitLimit,
      r = tt(n, t);
    return new bt({ keys: [], programId: this.programId, data: r });
  }
  static setComputeUnitPrice(t) {
    const n = Nr.SetComputeUnitPrice,
      r = tt(n, { microLamports: BigInt(t.microLamports) });
    return new bt({ keys: [], programId: this.programId, data: r });
  }
}
T1.programId = new de('ComputeBudget111111111111111111111111111111');
const z_ = 64,
  F_ = 32,
  $_ = 64,
  W_ = me([
    et('numSignatures'),
    et('padding'),
    ar('signatureOffset'),
    ar('signatureInstructionIndex'),
    ar('publicKeyOffset'),
    ar('publicKeyInstructionIndex'),
    ar('messageDataOffset'),
    ar('messageDataSize'),
    ar('messageInstructionIndex'),
  ]);
class sg {
  constructor() {}
  static createInstructionWithPublicKey(t) {
    const { publicKey: n, message: r, signature: i, instructionIndex: o } = t;
    ot(n.length === F_, `Public Key must be ${F_} bytes but received ${n.length} bytes`),
      ot(i.length === $_, `Signature must be ${$_} bytes but received ${i.length} bytes`);
    const a = W_.span,
      c = a + n.length,
      s = c + i.length,
      l = 1,
      u = Ae.alloc(s + r.length),
      d = o ?? 65535;
    return (
      W_.encode(
        {
          numSignatures: l,
          padding: 0,
          signatureOffset: c,
          signatureInstructionIndex: d,
          publicKeyOffset: a,
          publicKeyInstructionIndex: d,
          messageDataOffset: s,
          messageDataSize: r.length,
          messageInstructionIndex: d,
        },
        u
      ),
      u.fill(n, a),
      u.fill(i, c),
      u.fill(r, s),
      new bt({ keys: [], programId: sg.programId, data: u })
    );
  }
  static createInstructionWithPrivateKey(t) {
    const { privateKey: n, message: r, instructionIndex: i } = t;
    ot(n.length === z_, `Private key must be ${z_} bytes but received ${n.length} bytes`);
    try {
      const o = Ra.fromSecretKey(n),
        a = o.publicKey.toBytes(),
        c = g1(r, o.secretKey);
      return this.createInstructionWithPublicKey({
        publicKey: a,
        message: r,
        signature: c,
        instructionIndex: i,
      });
    } catch (o) {
      throw new Error(`Error creating instruction; ${o}`);
    }
  }
}
sg.programId = new de('Ed25519SigVerify111111111111111111111111111');
wI.hmacSha256Sync = (e, ...t) => {
  const n = FT.create(Lm, e);
  return t.forEach((r) => n.update(r)), n.digest();
};
const GU = (e, t) => d4(e, t, { der: !1, recovered: !0 });
wI.isValidPrivateKey;
const YU = f4,
  V_ = 32,
  nb = 20,
  K_ = 64,
  ZU = 11,
  rb = me([
    et('numSignatures'),
    ar('signatureOffset'),
    et('signatureInstructionIndex'),
    ar('ethAddressOffset'),
    et('ethAddressInstructionIndex'),
    ar('messageDataOffset'),
    ar('messageDataSize'),
    et('messageInstructionIndex'),
    It(20, 'ethAddress'),
    It(64, 'signature'),
    et('recoveryId'),
  ]);
class xa {
  constructor() {}
  static publicKeyToEthAddress(t) {
    ot(t.length === K_, `Public key must be ${K_} bytes but received ${t.length} bytes`);
    try {
      return Ae.from(O_(Ke(t))).slice(-nb);
    } catch (n) {
      throw new Error(`Error constructing Ethereum address: ${n}`);
    }
  }
  static createInstructionWithPublicKey(t) {
    const { publicKey: n, message: r, signature: i, recoveryId: o, instructionIndex: a } = t;
    return xa.createInstructionWithEthAddress({
      ethAddress: xa.publicKeyToEthAddress(n),
      message: r,
      signature: i,
      recoveryId: o,
      instructionIndex: a,
    });
  }
  static createInstructionWithEthAddress(t) {
    const { ethAddress: n, message: r, signature: i, recoveryId: o, instructionIndex: a = 0 } = t;
    let c;
    typeof n == 'string'
      ? n.startsWith('0x')
        ? (c = Ae.from(n.substr(2), 'hex'))
        : (c = Ae.from(n, 'hex'))
      : (c = n),
      ot(c.length === nb, `Address must be ${nb} bytes but received ${c.length} bytes`);
    const s = 1 + ZU,
      l = s,
      u = s + c.length,
      d = u + i.length + 1,
      f = 1,
      p = Ae.alloc(rb.span + r.length);
    return (
      rb.encode(
        {
          numSignatures: f,
          signatureOffset: u,
          signatureInstructionIndex: a,
          ethAddressOffset: l,
          ethAddressInstructionIndex: a,
          messageDataOffset: d,
          messageDataSize: r.length,
          messageInstructionIndex: a,
          signature: Ke(i),
          ethAddress: Ke(c),
          recoveryId: o,
        },
        p
      ),
      p.fill(Ke(r), rb.span),
      new bt({ keys: [], programId: xa.programId, data: p })
    );
  }
  static createInstructionWithPrivateKey(t) {
    const { privateKey: n, message: r, instructionIndex: i } = t;
    ot(n.length === V_, `Private key must be ${V_} bytes but received ${n.length} bytes`);
    try {
      const o = Ke(n),
        a = YU(o, !1).slice(1),
        c = Ae.from(O_(Ke(r))),
        [s, l] = GU(c, o);
      return this.createInstructionWithPublicKey({
        publicKey: a,
        message: r,
        signature: s,
        recoveryId: l,
        instructionIndex: i,
      });
    } catch (o) {
      throw new Error(`Error creating instruction; ${o}`);
    }
  }
}
xa.programId = new de('KeccakSecp256k11111111111111111111111111111');
const ok = new de('StakeConfig11111111111111111111111111111111');
class ak {
  constructor(t, n) {
    (this.staker = void 0), (this.withdrawer = void 0), (this.staker = t), (this.withdrawer = n);
  }
}
class dc {
  constructor(t, n, r) {
    (this.unixTimestamp = void 0),
      (this.epoch = void 0),
      (this.custodian = void 0),
      (this.unixTimestamp = t),
      (this.epoch = n),
      (this.custodian = r);
  }
}
dc.default = new dc(0, 0, de.default);
class QU {
  constructor() {}
  static decodeInstructionType(t) {
    this.checkProgramId(t.programId);
    const r = we('instruction').decode(t.data);
    let i;
    for (const [o, a] of Object.entries(qt))
      if (a.index == r) {
        i = o;
        break;
      }
    if (!i) throw new Error('Instruction type incorrect; not a StakeInstruction');
    return i;
  }
  static decodeInitialize(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
    const { authorized: n, lockup: r } = ut(qt.Initialize, t.data);
    return {
      stakePubkey: t.keys[0].pubkey,
      authorized: new ak(new de(n.staker), new de(n.withdrawer)),
      lockup: new dc(r.unixTimestamp, r.epoch, new de(r.custodian)),
    };
  }
  static decodeDelegate(t) {
    return (
      this.checkProgramId(t.programId),
      this.checkKeyLength(t.keys, 6),
      ut(qt.Delegate, t.data),
      {
        stakePubkey: t.keys[0].pubkey,
        votePubkey: t.keys[1].pubkey,
        authorizedPubkey: t.keys[5].pubkey,
      }
    );
  }
  static decodeAuthorize(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
    const { newAuthorized: n, stakeAuthorizationType: r } = ut(qt.Authorize, t.data),
      i = {
        stakePubkey: t.keys[0].pubkey,
        authorizedPubkey: t.keys[2].pubkey,
        newAuthorizedPubkey: new de(n),
        stakeAuthorizationType: { index: r },
      };
    return t.keys.length > 3 && (i.custodianPubkey = t.keys[3].pubkey), i;
  }
  static decodeAuthorizeWithSeed(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
    const {
        newAuthorized: n,
        stakeAuthorizationType: r,
        authoritySeed: i,
        authorityOwner: o,
      } = ut(qt.AuthorizeWithSeed, t.data),
      a = {
        stakePubkey: t.keys[0].pubkey,
        authorityBase: t.keys[1].pubkey,
        authoritySeed: i,
        authorityOwner: new de(o),
        newAuthorizedPubkey: new de(n),
        stakeAuthorizationType: { index: r },
      };
    return t.keys.length > 3 && (a.custodianPubkey = t.keys[3].pubkey), a;
  }
  static decodeSplit(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
    const { lamports: n } = ut(qt.Split, t.data);
    return {
      stakePubkey: t.keys[0].pubkey,
      splitStakePubkey: t.keys[1].pubkey,
      authorizedPubkey: t.keys[2].pubkey,
      lamports: n,
    };
  }
  static decodeMerge(t) {
    return (
      this.checkProgramId(t.programId),
      this.checkKeyLength(t.keys, 3),
      ut(qt.Merge, t.data),
      {
        stakePubkey: t.keys[0].pubkey,
        sourceStakePubKey: t.keys[1].pubkey,
        authorizedPubkey: t.keys[4].pubkey,
      }
    );
  }
  static decodeWithdraw(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 5);
    const { lamports: n } = ut(qt.Withdraw, t.data),
      r = {
        stakePubkey: t.keys[0].pubkey,
        toPubkey: t.keys[1].pubkey,
        authorizedPubkey: t.keys[4].pubkey,
        lamports: n,
      };
    return t.keys.length > 5 && (r.custodianPubkey = t.keys[5].pubkey), r;
  }
  static decodeDeactivate(t) {
    return (
      this.checkProgramId(t.programId),
      this.checkKeyLength(t.keys, 3),
      ut(qt.Deactivate, t.data),
      { stakePubkey: t.keys[0].pubkey, authorizedPubkey: t.keys[2].pubkey }
    );
  }
  static checkProgramId(t) {
    if (!t.equals(cg.programId))
      throw new Error('invalid instruction; programId is not StakeProgram');
  }
  static checkKeyLength(t, n) {
    if (t.length < n)
      throw new Error(`invalid instruction; found ${t.length} keys, expected at least ${n}`);
  }
}
const qt = Object.freeze({
    Initialize: { index: 0, layout: me([we('instruction'), nN(), rN()]) },
    Authorize: {
      index: 1,
      layout: me([we('instruction'), Ge('newAuthorized'), we('stakeAuthorizationType')]),
    },
    Delegate: { index: 2, layout: me([we('instruction')]) },
    Split: { index: 3, layout: me([we('instruction'), qn('lamports')]) },
    Withdraw: { index: 4, layout: me([we('instruction'), qn('lamports')]) },
    Deactivate: { index: 5, layout: me([we('instruction')]) },
    Merge: { index: 7, layout: me([we('instruction')]) },
    AuthorizeWithSeed: {
      index: 8,
      layout: me([
        we('instruction'),
        Ge('newAuthorized'),
        we('stakeAuthorizationType'),
        Oo('authoritySeed'),
        Ge('authorityOwner'),
      ]),
    },
  }),
  JU = Object.freeze({ Staker: { index: 0 }, Withdrawer: { index: 1 } });
class cg {
  constructor() {}
  static initialize(t) {
    const { stakePubkey: n, authorized: r, lockup: i } = t,
      o = i || dc.default,
      a = qt.Initialize,
      c = tt(a, {
        authorized: { staker: Ke(r.staker.toBuffer()), withdrawer: Ke(r.withdrawer.toBuffer()) },
        lockup: {
          unixTimestamp: o.unixTimestamp,
          epoch: o.epoch,
          custodian: Ke(o.custodian.toBuffer()),
        },
      }),
      s = {
        keys: [
          { pubkey: n, isSigner: !1, isWritable: !0 },
          { pubkey: Za, isSigner: !1, isWritable: !1 },
        ],
        programId: this.programId,
        data: c,
      };
    return new bt(s);
  }
  static createAccountWithSeed(t) {
    const n = new yt();
    n.add(
      cn.createAccountWithSeed({
        fromPubkey: t.fromPubkey,
        newAccountPubkey: t.stakePubkey,
        basePubkey: t.basePubkey,
        seed: t.seed,
        lamports: t.lamports,
        space: this.space,
        programId: this.programId,
      })
    );
    const { stakePubkey: r, authorized: i, lockup: o } = t;
    return n.add(this.initialize({ stakePubkey: r, authorized: i, lockup: o }));
  }
  static createAccount(t) {
    const n = new yt();
    n.add(
      cn.createAccount({
        fromPubkey: t.fromPubkey,
        newAccountPubkey: t.stakePubkey,
        lamports: t.lamports,
        space: this.space,
        programId: this.programId,
      })
    );
    const { stakePubkey: r, authorized: i, lockup: o } = t;
    return n.add(this.initialize({ stakePubkey: r, authorized: i, lockup: o }));
  }
  static delegate(t) {
    const { stakePubkey: n, authorizedPubkey: r, votePubkey: i } = t,
      o = qt.Delegate,
      a = tt(o);
    return new yt().add({
      keys: [
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: i, isSigner: !1, isWritable: !1 },
        { pubkey: Rr, isSigner: !1, isWritable: !1 },
        { pubkey: Oh, isSigner: !1, isWritable: !1 },
        { pubkey: ok, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ],
      programId: this.programId,
      data: a,
    });
  }
  static authorize(t) {
    const {
        stakePubkey: n,
        authorizedPubkey: r,
        newAuthorizedPubkey: i,
        stakeAuthorizationType: o,
        custodianPubkey: a,
      } = t,
      c = qt.Authorize,
      s = tt(c, { newAuthorized: Ke(i.toBuffer()), stakeAuthorizationType: o.index }),
      l = [
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: Rr, isSigner: !1, isWritable: !0 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ];
    return (
      a && l.push({ pubkey: a, isSigner: !1, isWritable: !1 }),
      new yt().add({ keys: l, programId: this.programId, data: s })
    );
  }
  static authorizeWithSeed(t) {
    const {
        stakePubkey: n,
        authorityBase: r,
        authoritySeed: i,
        authorityOwner: o,
        newAuthorizedPubkey: a,
        stakeAuthorizationType: c,
        custodianPubkey: s,
      } = t,
      l = qt.AuthorizeWithSeed,
      u = tt(l, {
        newAuthorized: Ke(a.toBuffer()),
        stakeAuthorizationType: c.index,
        authoritySeed: i,
        authorityOwner: Ke(o.toBuffer()),
      }),
      d = [
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
        { pubkey: Rr, isSigner: !1, isWritable: !1 },
      ];
    return (
      s && d.push({ pubkey: s, isSigner: !1, isWritable: !1 }),
      new yt().add({ keys: d, programId: this.programId, data: u })
    );
  }
  static splitInstruction(t) {
    const { stakePubkey: n, authorizedPubkey: r, splitStakePubkey: i, lamports: o } = t,
      a = qt.Split,
      c = tt(a, { lamports: o });
    return new bt({
      keys: [
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: i, isSigner: !1, isWritable: !0 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ],
      programId: this.programId,
      data: c,
    });
  }
  static split(t) {
    const n = new yt();
    return (
      n.add(
        cn.createAccount({
          fromPubkey: t.authorizedPubkey,
          newAccountPubkey: t.splitStakePubkey,
          lamports: 0,
          space: this.space,
          programId: this.programId,
        })
      ),
      n.add(this.splitInstruction(t))
    );
  }
  static splitWithSeed(t) {
    const {
        stakePubkey: n,
        authorizedPubkey: r,
        splitStakePubkey: i,
        basePubkey: o,
        seed: a,
        lamports: c,
      } = t,
      s = new yt();
    return (
      s.add(
        cn.allocate({
          accountPubkey: i,
          basePubkey: o,
          seed: a,
          space: this.space,
          programId: this.programId,
        })
      ),
      s.add(
        this.splitInstruction({
          stakePubkey: n,
          authorizedPubkey: r,
          splitStakePubkey: i,
          lamports: c,
        })
      )
    );
  }
  static merge(t) {
    const { stakePubkey: n, sourceStakePubKey: r, authorizedPubkey: i } = t,
      o = qt.Merge,
      a = tt(o);
    return new yt().add({
      keys: [
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: r, isSigner: !1, isWritable: !0 },
        { pubkey: Rr, isSigner: !1, isWritable: !1 },
        { pubkey: Oh, isSigner: !1, isWritable: !1 },
        { pubkey: i, isSigner: !0, isWritable: !1 },
      ],
      programId: this.programId,
      data: a,
    });
  }
  static withdraw(t) {
    const { stakePubkey: n, authorizedPubkey: r, toPubkey: i, lamports: o, custodianPubkey: a } = t,
      c = qt.Withdraw,
      s = tt(c, { lamports: o }),
      l = [
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: i, isSigner: !1, isWritable: !0 },
        { pubkey: Rr, isSigner: !1, isWritable: !1 },
        { pubkey: Oh, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ];
    return (
      a && l.push({ pubkey: a, isSigner: !1, isWritable: !1 }),
      new yt().add({ keys: l, programId: this.programId, data: s })
    );
  }
  static deactivate(t) {
    const { stakePubkey: n, authorizedPubkey: r } = t,
      i = qt.Deactivate,
      o = tt(i);
    return new yt().add({
      keys: [
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: Rr, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ],
      programId: this.programId,
      data: o,
    });
  }
}
cg.programId = new de('Stake11111111111111111111111111111111111111');
cg.space = 200;
class sk {
  constructor(t, n, r, i) {
    (this.nodePubkey = void 0),
      (this.authorizedVoter = void 0),
      (this.authorizedWithdrawer = void 0),
      (this.commission = void 0),
      (this.nodePubkey = t),
      (this.authorizedVoter = n),
      (this.authorizedWithdrawer = r),
      (this.commission = i);
  }
}
class XU {
  constructor() {}
  static decodeInstructionType(t) {
    this.checkProgramId(t.programId);
    const r = we('instruction').decode(t.data);
    let i;
    for (const [o, a] of Object.entries(ri))
      if (a.index == r) {
        i = o;
        break;
      }
    if (!i) throw new Error('Instruction type incorrect; not a VoteInstruction');
    return i;
  }
  static decodeInitializeAccount(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 4);
    const { voteInit: n } = ut(ri.InitializeAccount, t.data);
    return {
      votePubkey: t.keys[0].pubkey,
      nodePubkey: t.keys[3].pubkey,
      voteInit: new sk(
        new de(n.nodePubkey),
        new de(n.authorizedVoter),
        new de(n.authorizedWithdrawer),
        n.commission
      ),
    };
  }
  static decodeAuthorize(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
    const { newAuthorized: n, voteAuthorizationType: r } = ut(ri.Authorize, t.data);
    return {
      votePubkey: t.keys[0].pubkey,
      authorizedPubkey: t.keys[2].pubkey,
      newAuthorizedPubkey: new de(n),
      voteAuthorizationType: { index: r },
    };
  }
  static decodeAuthorizeWithSeed(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
    const {
      voteAuthorizeWithSeedArgs: {
        currentAuthorityDerivedKeyOwnerPubkey: n,
        currentAuthorityDerivedKeySeed: r,
        newAuthorized: i,
        voteAuthorizationType: o,
      },
    } = ut(ri.AuthorizeWithSeed, t.data);
    return {
      currentAuthorityDerivedKeyBasePubkey: t.keys[2].pubkey,
      currentAuthorityDerivedKeyOwnerPubkey: new de(n),
      currentAuthorityDerivedKeySeed: r,
      newAuthorizedPubkey: new de(i),
      voteAuthorizationType: { index: o },
      votePubkey: t.keys[0].pubkey,
    };
  }
  static decodeWithdraw(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
    const { lamports: n } = ut(ri.Withdraw, t.data);
    return {
      votePubkey: t.keys[0].pubkey,
      authorizedWithdrawerPubkey: t.keys[2].pubkey,
      lamports: n,
      toPubkey: t.keys[1].pubkey,
    };
  }
  static checkProgramId(t) {
    if (!t.equals(_s.programId))
      throw new Error('invalid instruction; programId is not VoteProgram');
  }
  static checkKeyLength(t, n) {
    if (t.length < n)
      throw new Error(`invalid instruction; found ${t.length} keys, expected at least ${n}`);
  }
}
const ri = Object.freeze({
    InitializeAccount: { index: 0, layout: me([we('instruction'), iN()]) },
    Authorize: {
      index: 1,
      layout: me([we('instruction'), Ge('newAuthorized'), we('voteAuthorizationType')]),
    },
    Withdraw: { index: 3, layout: me([we('instruction'), qn('lamports')]) },
    AuthorizeWithSeed: { index: 10, layout: me([we('instruction'), oN()]) },
  }),
  eL = Object.freeze({ Voter: { index: 0 }, Withdrawer: { index: 1 } });
class _s {
  constructor() {}
  static initializeAccount(t) {
    const { votePubkey: n, nodePubkey: r, voteInit: i } = t,
      o = ri.InitializeAccount,
      a = tt(o, {
        voteInit: {
          nodePubkey: Ke(i.nodePubkey.toBuffer()),
          authorizedVoter: Ke(i.authorizedVoter.toBuffer()),
          authorizedWithdrawer: Ke(i.authorizedWithdrawer.toBuffer()),
          commission: i.commission,
        },
      }),
      c = {
        keys: [
          { pubkey: n, isSigner: !1, isWritable: !0 },
          { pubkey: Za, isSigner: !1, isWritable: !1 },
          { pubkey: Rr, isSigner: !1, isWritable: !1 },
          { pubkey: r, isSigner: !0, isWritable: !1 },
        ],
        programId: this.programId,
        data: a,
      };
    return new bt(c);
  }
  static createAccount(t) {
    const n = new yt();
    return (
      n.add(
        cn.createAccount({
          fromPubkey: t.fromPubkey,
          newAccountPubkey: t.votePubkey,
          lamports: t.lamports,
          space: this.space,
          programId: this.programId,
        })
      ),
      n.add(
        this.initializeAccount({
          votePubkey: t.votePubkey,
          nodePubkey: t.voteInit.nodePubkey,
          voteInit: t.voteInit,
        })
      )
    );
  }
  static authorize(t) {
    const {
        votePubkey: n,
        authorizedPubkey: r,
        newAuthorizedPubkey: i,
        voteAuthorizationType: o,
      } = t,
      a = ri.Authorize,
      c = tt(a, { newAuthorized: Ke(i.toBuffer()), voteAuthorizationType: o.index }),
      s = [
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: Rr, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ];
    return new yt().add({ keys: s, programId: this.programId, data: c });
  }
  static authorizeWithSeed(t) {
    const {
        currentAuthorityDerivedKeyBasePubkey: n,
        currentAuthorityDerivedKeyOwnerPubkey: r,
        currentAuthorityDerivedKeySeed: i,
        newAuthorizedPubkey: o,
        voteAuthorizationType: a,
        votePubkey: c,
      } = t,
      s = ri.AuthorizeWithSeed,
      l = tt(s, {
        voteAuthorizeWithSeedArgs: {
          currentAuthorityDerivedKeyOwnerPubkey: Ke(r.toBuffer()),
          currentAuthorityDerivedKeySeed: i,
          newAuthorized: Ke(o.toBuffer()),
          voteAuthorizationType: a.index,
        },
      }),
      u = [
        { pubkey: c, isSigner: !1, isWritable: !0 },
        { pubkey: Rr, isSigner: !1, isWritable: !1 },
        { pubkey: n, isSigner: !0, isWritable: !1 },
      ];
    return new yt().add({ keys: u, programId: this.programId, data: l });
  }
  static withdraw(t) {
    const { votePubkey: n, authorizedWithdrawerPubkey: r, lamports: i, toPubkey: o } = t,
      a = ri.Withdraw,
      c = tt(a, { lamports: i }),
      s = [
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: o, isSigner: !1, isWritable: !0 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ];
    return new yt().add({ keys: s, programId: this.programId, data: c });
  }
  static safeWithdraw(t, n, r) {
    if (t.lamports > n - r)
      throw new Error('Withdraw will leave vote account with insuffcient funds.');
    return _s.withdraw(t);
  }
}
_s.programId = new de('Vote111111111111111111111111111111111111111');
_s.space = 3731;
const ck = new de('Va1idator1nfo111111111111111111111111111111'),
  tL = ne({ name: se(), website: Ce(se()), details: Ce(se()), keybaseUsername: Ce(se()) });
class k1 {
  constructor(t, n) {
    (this.key = void 0), (this.info = void 0), (this.key = t), (this.info = n);
  }
  static fromConfigData(t) {
    let n = [...t];
    if (kn(n) !== 2) return null;
    const i = [];
    for (let o = 0; o < 2; o++) {
      const a = new de(n.slice(0, Nn));
      n = n.slice(Nn);
      const c = n.slice(0, 1)[0] === 1;
      (n = n.slice(1)), i.push({ publicKey: a, isSigner: c });
    }
    if (i[0].publicKey.equals(ck) && i[1].isSigner) {
      const o = Oo().decode(Ae.from(n)),
        a = JSON.parse(o);
      return h4(a, tL), new k1(i[1].publicKey, a);
    }
    return null;
  }
}
const nL = new de('Vote111111111111111111111111111111111111111'),
  rL = me([
    Ge('nodePubkey'),
    Ge('authorizedWithdrawer'),
    et('commission'),
    un(),
    fn(me([un('slot'), we('confirmationCount')]), No(we(), -8), 'votes'),
    et('rootSlotValid'),
    un('rootSlot'),
    un(),
    fn(me([un('epoch'), Ge('authorizedVoter')]), No(we(), -8), 'authorizedVoters'),
    me(
      [
        fn(
          me([Ge('authorizedPubkey'), un('epochOfLastAuthorizedSwitch'), un('targetEpoch')]),
          32,
          'buf'
        ),
        un('idx'),
        et('isEmpty'),
      ],
      'priorVoters'
    ),
    un(),
    fn(me([un('epoch'), un('credits'), un('prevCredits')]), No(we(), -8), 'epochCredits'),
    me([un('slot'), un('timestamp')], 'lastTimestamp'),
  ]);
class C1 {
  constructor(t) {
    (this.nodePubkey = void 0),
      (this.authorizedWithdrawer = void 0),
      (this.commission = void 0),
      (this.rootSlot = void 0),
      (this.votes = void 0),
      (this.authorizedVoters = void 0),
      (this.priorVoters = void 0),
      (this.epochCredits = void 0),
      (this.lastTimestamp = void 0),
      (this.nodePubkey = t.nodePubkey),
      (this.authorizedWithdrawer = t.authorizedWithdrawer),
      (this.commission = t.commission),
      (this.rootSlot = t.rootSlot),
      (this.votes = t.votes),
      (this.authorizedVoters = t.authorizedVoters),
      (this.priorVoters = t.priorVoters),
      (this.epochCredits = t.epochCredits),
      (this.lastTimestamp = t.lastTimestamp);
  }
  static fromAccountData(t) {
    const r = rL.decode(Ke(t), 4);
    let i = r.rootSlot;
    return (
      r.rootSlotValid || (i = null),
      new C1({
        nodePubkey: new de(r.nodePubkey),
        authorizedWithdrawer: new de(r.authorizedWithdrawer),
        commission: r.commission,
        votes: r.votes,
        rootSlot: i,
        authorizedVoters: r.authorizedVoters.map(iL),
        priorVoters: oL(r.priorVoters),
        epochCredits: r.epochCredits,
        lastTimestamp: r.lastTimestamp,
      })
    );
  }
}
function iL({ authorizedVoter: e, epoch: t }) {
  return { epoch: t, authorizedVoter: new de(e) };
}
function H_({ authorizedPubkey: e, epochOfLastAuthorizedSwitch: t, targetEpoch: n }) {
  return { authorizedPubkey: new de(e), epochOfLastAuthorizedSwitch: t, targetEpoch: n };
}
function oL({ buf: e, idx: t, isEmpty: n }) {
  return n ? [] : [...e.slice(t + 1).map(H_), ...e.slice(0, t).map(H_)];
}
const q_ = {
  http: {
    devnet: 'http://api.devnet.solana.com',
    testnet: 'http://api.testnet.solana.com',
    'mainnet-beta': 'http://api.mainnet-beta.solana.com/',
  },
  https: {
    devnet: 'https://api.devnet.solana.com',
    testnet: 'https://api.testnet.solana.com',
    'mainnet-beta': 'https://api.mainnet-beta.solana.com/',
  },
};
function aL(e, t) {
  const n = t === !1 ? 'http' : 'https';
  if (!e) return q_[n].devnet;
  const r = q_[n][e];
  if (!r) throw new Error(`Unknown ${n} cluster: ${e}`);
  return r;
}
async function sL(e, t, n, r) {
  let i, o;
  (n && Object.prototype.hasOwnProperty.call(n, 'lastValidBlockHeight')) ||
  (n && Object.prototype.hasOwnProperty.call(n, 'nonceValue'))
    ? ((i = n), (o = r))
    : (o = n);
  const a = o && {
      skipPreflight: o.skipPreflight,
      preflightCommitment: o.preflightCommitment || o.commitment,
      minContextSlot: o.minContextSlot,
    },
    c = await e.sendRawTransaction(t, a),
    s = o && o.commitment,
    u = (await (i ? e.confirmTransaction(i, s) : e.confirmTransaction(c, s))).value;
  if (u.err) throw new Error(`Raw transaction ${c} failed (${JSON.stringify(u)})`);
  return c;
}
const cL = 1e9,
  uL = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Account: X9,
        AddressLookupTableAccount: Wm,
        AddressLookupTableInstruction: HU,
        AddressLookupTableProgram: E1,
        Authorized: ak,
        BLOCKHASH_CACHE_TIMEOUT_MS: YT,
        BPF_LOADER_DEPRECATED_PROGRAM_ID: eN,
        BPF_LOADER_PROGRAM_ID: yN,
        BpfLoader: bN,
        COMPUTE_BUDGET_INSTRUCTION_LAYOUTS: Nr,
        ComputeBudgetInstruction: qU,
        ComputeBudgetProgram: T1,
        Connection: KU,
        Ed25519Program: sg,
        Enum: Q9,
        EpochSchedule: qT,
        FeeCalculatorLayout: KT,
        Keypair: Ra,
        LAMPORTS_PER_SOL: cL,
        LOOKUP_TABLE_INSTRUCTION_LAYOUTS: ni,
        Loader: Vo,
        Lockup: dc,
        MAX_SEED_LENGTH: WT,
        Message: mr,
        MessageAccountKeys: uc,
        MessageV0: Wo,
        NONCE_ACCOUNT_LENGTH: Fm,
        NonceAccount: ig,
        PACKET_DATA_SIZE: Qi,
        PUBLIC_KEY_LENGTH: Nn,
        PublicKey: de,
        SIGNATURE_LENGTH_IN_BYTES: Ya,
        SOLANA_SCHEMA: oc,
        STAKE_CONFIG_ID: ok,
        STAKE_INSTRUCTION_LAYOUTS: qt,
        SYSTEM_INSTRUCTION_LAYOUTS: wt,
        SYSVAR_CLOCK_PUBKEY: Rr,
        SYSVAR_EPOCH_SCHEDULE_PUBKEY: sN,
        SYSVAR_INSTRUCTIONS_PUBKEY: cN,
        SYSVAR_RECENT_BLOCKHASHES_PUBKEY: Ph,
        SYSVAR_RENT_PUBKEY: Za,
        SYSVAR_REWARDS_PUBKEY: uN,
        SYSVAR_SLOT_HASHES_PUBKEY: lN,
        SYSVAR_SLOT_HISTORY_PUBKEY: dN,
        SYSVAR_STAKE_HISTORY_PUBKEY: Oh,
        Secp256k1Program: xa,
        SendTransactionError: $m,
        SolanaJSONRPCError: ve,
        SolanaJSONRPCErrorCode: SN,
        StakeAuthorizationLayout: JU,
        StakeInstruction: QU,
        StakeProgram: cg,
        Struct: y1,
        SystemInstruction: pN,
        SystemProgram: cn,
        Transaction: yt,
        TransactionExpiredBlockheightExceededError: b1,
        TransactionExpiredNonceInvalidError: Ea,
        TransactionExpiredTimeoutError: m1,
        TransactionInstruction: bt,
        TransactionMessage: _1,
        get TransactionStatus() {
          return rr;
        },
        VALIDATOR_INFO_KEY: ck,
        VERSION_PREFIX_MASK: ng,
        VOTE_PROGRAM_ID: nL,
        ValidatorInfo: k1,
        VersionedMessage: w1,
        VersionedTransaction: v1,
        VoteAccount: C1,
        VoteAuthorizationLayout: eL,
        VoteInit: sk,
        VoteInstruction: XU,
        VoteProgram: _s,
        clusterApiUrl: aL,
        sendAndConfirmRawTransaction: sL,
        sendAndConfirmTransaction: Dh,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  V = AI(uL);
var ib = {},
  qm = {},
  pn = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (a, c, s, l) {
            l === void 0 && (l = s);
            var u = Object.getOwnPropertyDescriptor(c, s);
            (!u || ('get' in u ? !c.__esModule : u.writable || u.configurable)) &&
              (u = {
                enumerable: !0,
                get: function () {
                  return c[s];
                },
              }),
              Object.defineProperty(a, l, u);
          }
        : function (a, c, s, l) {
            l === void 0 && (l = s), (a[l] = c[s]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (g && g.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var s in a)
            s !== 'default' && Object.prototype.hasOwnProperty.call(a, s) && t(c, a, s);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }), (e.keyBeet = e.Key = void 0);
  const i = r(W);
  var o;
  (function (a) {
    (a[(a.Uninitialized = 0)] = 'Uninitialized'),
      (a[(a.EditionV1 = 1)] = 'EditionV1'),
      (a[(a.MasterEditionV1 = 2)] = 'MasterEditionV1'),
      (a[(a.ReservationListV1 = 3)] = 'ReservationListV1'),
      (a[(a.MetadataV1 = 4)] = 'MetadataV1'),
      (a[(a.ReservationListV2 = 5)] = 'ReservationListV2'),
      (a[(a.MasterEditionV2 = 6)] = 'MasterEditionV2'),
      (a[(a.EditionMarker = 7)] = 'EditionMarker'),
      (a[(a.UseAuthorityRecord = 8)] = 'UseAuthorityRecord'),
      (a[(a.CollectionAuthorityRecord = 9)] = 'CollectionAuthorityRecord'),
      (a[(a.TokenOwnedEscrow = 10)] = 'TokenOwnedEscrow'),
      (a[(a.TokenRecord = 11)] = 'TokenRecord'),
      (a[(a.MetadataDelegate = 12)] = 'MetadataDelegate');
  })((o = e.Key || (e.Key = {}))),
    (e.keyBeet = i.fixedScalarEnum(o));
})(pn);
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (l, u, d, f) {
            f === void 0 && (f = d);
            var p = Object.getOwnPropertyDescriptor(u, d);
            (!p || ('get' in p ? !u.__esModule : p.writable || p.configurable)) &&
              (p = {
                enumerable: !0,
                get: function () {
                  return u[d];
                },
              }),
              Object.defineProperty(l, f, p);
          }
        : function (l, u, d, f) {
            f === void 0 && (f = d), (l[f] = u[d]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (l, u) {
            Object.defineProperty(l, 'default', { enumerable: !0, value: u });
          }
        : function (l, u) {
            l.default = u;
          }),
    r =
      (g && g.__importStar) ||
      function (l) {
        if (l && l.__esModule) return l;
        var u = {};
        if (l != null)
          for (var d in l)
            d !== 'default' && Object.prototype.hasOwnProperty.call(l, d) && t(u, l, d);
        return n(u, l), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.collectionAuthorityRecordBeet = e.CollectionAuthorityRecord = void 0);
  const i = r(V),
    o = r(W),
    a = r(st),
    c = pn;
  class s {
    constructor(u, d, f) {
      (this.key = u), (this.bump = d), (this.updateAuthority = f);
    }
    static fromArgs(u) {
      return new s(u.key, u.bump, u.updateAuthority);
    }
    static fromAccountInfo(u, d = 0) {
      return s.deserialize(u.data, d);
    }
    static async fromAccountAddress(u, d, f) {
      const p = await u.getAccountInfo(d, f);
      if (p == null) throw new Error(`Unable to find CollectionAuthorityRecord account at ${d}`);
      return s.fromAccountInfo(p, 0)[0];
    }
    static gpaBuilder(u = new i.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
      return a.GpaBuilder.fromStruct(u, e.collectionAuthorityRecordBeet);
    }
    static deserialize(u, d = 0) {
      return e.collectionAuthorityRecordBeet.deserialize(u, d);
    }
    serialize() {
      return e.collectionAuthorityRecordBeet.serialize(this);
    }
    static byteSize(u) {
      const d = s.fromArgs(u);
      return e.collectionAuthorityRecordBeet.toFixedFromValue(d).byteSize;
    }
    static async getMinimumBalanceForRentExemption(u, d, f) {
      return d.getMinimumBalanceForRentExemption(s.byteSize(u), f);
    }
    pretty() {
      return {
        key: 'Key.' + c.Key[this.key],
        bump: this.bump,
        updateAuthority: this.updateAuthority,
      };
    }
  }
  (e.CollectionAuthorityRecord = s),
    (e.collectionAuthorityRecordBeet = new o.FixableBeetStruct(
      [
        ['key', c.keyBeet],
        ['bump', o.u8],
        ['updateAuthority', o.coption(a.publicKey)],
      ],
      s.fromArgs,
      'CollectionAuthorityRecord'
    ));
})(qm);
var Gm = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (l, u, d, f) {
            f === void 0 && (f = d);
            var p = Object.getOwnPropertyDescriptor(u, d);
            (!p || ('get' in p ? !u.__esModule : p.writable || p.configurable)) &&
              (p = {
                enumerable: !0,
                get: function () {
                  return u[d];
                },
              }),
              Object.defineProperty(l, f, p);
          }
        : function (l, u, d, f) {
            f === void 0 && (f = d), (l[f] = u[d]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (l, u) {
            Object.defineProperty(l, 'default', { enumerable: !0, value: u });
          }
        : function (l, u) {
            l.default = u;
          }),
    r =
      (g && g.__importStar) ||
      function (l) {
        if (l && l.__esModule) return l;
        var u = {};
        if (l != null)
          for (var d in l)
            d !== 'default' && Object.prototype.hasOwnProperty.call(l, d) && t(u, l, d);
        return n(u, l), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }), (e.editionBeet = e.Edition = void 0);
  const i = r(V),
    o = r(W),
    a = r(st),
    c = pn;
  class s {
    constructor(u, d, f) {
      (this.key = u), (this.parent = d), (this.edition = f);
    }
    static fromArgs(u) {
      return new s(u.key, u.parent, u.edition);
    }
    static fromAccountInfo(u, d = 0) {
      return s.deserialize(u.data, d);
    }
    static async fromAccountAddress(u, d, f) {
      const p = await u.getAccountInfo(d, f);
      if (p == null) throw new Error(`Unable to find Edition account at ${d}`);
      return s.fromAccountInfo(p, 0)[0];
    }
    static gpaBuilder(u = new i.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
      return a.GpaBuilder.fromStruct(u, e.editionBeet);
    }
    static deserialize(u, d = 0) {
      return e.editionBeet.deserialize(u, d);
    }
    serialize() {
      return e.editionBeet.serialize(this);
    }
    static get byteSize() {
      return e.editionBeet.byteSize;
    }
    static async getMinimumBalanceForRentExemption(u, d) {
      return u.getMinimumBalanceForRentExemption(s.byteSize, d);
    }
    static hasCorrectByteSize(u, d = 0) {
      return u.byteLength - d === s.byteSize;
    }
    pretty() {
      return {
        key: 'Key.' + c.Key[this.key],
        parent: this.parent.toBase58(),
        edition: (() => {
          const u = this.edition;
          if (typeof u.toNumber == 'function')
            try {
              return u.toNumber();
            } catch {
              return u;
            }
          return u;
        })(),
      };
    }
  }
  (e.Edition = s),
    (e.editionBeet = new o.BeetStruct(
      [
        ['key', c.keyBeet],
        ['parent', a.publicKey],
        ['edition', o.u64],
      ],
      s.fromArgs,
      'Edition'
    ));
})(Gm);
var Ym = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (l, u, d, f) {
            f === void 0 && (f = d);
            var p = Object.getOwnPropertyDescriptor(u, d);
            (!p || ('get' in p ? !u.__esModule : p.writable || p.configurable)) &&
              (p = {
                enumerable: !0,
                get: function () {
                  return u[d];
                },
              }),
              Object.defineProperty(l, f, p);
          }
        : function (l, u, d, f) {
            f === void 0 && (f = d), (l[f] = u[d]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (l, u) {
            Object.defineProperty(l, 'default', { enumerable: !0, value: u });
          }
        : function (l, u) {
            l.default = u;
          }),
    r =
      (g && g.__importStar) ||
      function (l) {
        if (l && l.__esModule) return l;
        var u = {};
        if (l != null)
          for (var d in l)
            d !== 'default' && Object.prototype.hasOwnProperty.call(l, d) && t(u, l, d);
        return n(u, l), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.editionMarkerBeet = e.EditionMarker = void 0);
  const i = r(W),
    o = r(V),
    a = r(st),
    c = pn;
  class s {
    constructor(u, d) {
      (this.key = u), (this.ledger = d);
    }
    static fromArgs(u) {
      return new s(u.key, u.ledger);
    }
    static fromAccountInfo(u, d = 0) {
      return s.deserialize(u.data, d);
    }
    static async fromAccountAddress(u, d, f) {
      const p = await u.getAccountInfo(d, f);
      if (p == null) throw new Error(`Unable to find EditionMarker account at ${d}`);
      return s.fromAccountInfo(p, 0)[0];
    }
    static gpaBuilder(u = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
      return a.GpaBuilder.fromStruct(u, e.editionMarkerBeet);
    }
    static deserialize(u, d = 0) {
      return e.editionMarkerBeet.deserialize(u, d);
    }
    serialize() {
      return e.editionMarkerBeet.serialize(this);
    }
    static get byteSize() {
      return e.editionMarkerBeet.byteSize;
    }
    static async getMinimumBalanceForRentExemption(u, d) {
      return u.getMinimumBalanceForRentExemption(s.byteSize, d);
    }
    static hasCorrectByteSize(u, d = 0) {
      return u.byteLength - d === s.byteSize;
    }
    pretty() {
      return { key: 'Key.' + c.Key[this.key], ledger: this.ledger };
    }
  }
  (e.EditionMarker = s),
    (e.editionMarkerBeet = new i.BeetStruct(
      [
        ['key', c.keyBeet],
        ['ledger', i.uniformFixedSizeArray(i.u8, 31)],
      ],
      s.fromArgs,
      'EditionMarker'
    ));
})(Ym);
var Zm = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (l, u, d, f) {
            f === void 0 && (f = d);
            var p = Object.getOwnPropertyDescriptor(u, d);
            (!p || ('get' in p ? !u.__esModule : p.writable || p.configurable)) &&
              (p = {
                enumerable: !0,
                get: function () {
                  return u[d];
                },
              }),
              Object.defineProperty(l, f, p);
          }
        : function (l, u, d, f) {
            f === void 0 && (f = d), (l[f] = u[d]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (l, u) {
            Object.defineProperty(l, 'default', { enumerable: !0, value: u });
          }
        : function (l, u) {
            l.default = u;
          }),
    r =
      (g && g.__importStar) ||
      function (l) {
        if (l && l.__esModule) return l;
        var u = {};
        if (l != null)
          for (var d in l)
            d !== 'default' && Object.prototype.hasOwnProperty.call(l, d) && t(u, l, d);
        return n(u, l), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.masterEditionV1Beet = e.MasterEditionV1 = void 0);
  const i = r(W),
    o = r(V),
    a = r(st),
    c = pn;
  class s {
    constructor(u, d, f, p, y) {
      (this.key = u),
        (this.supply = d),
        (this.maxSupply = f),
        (this.printingMint = p),
        (this.oneTimePrintingAuthorizationMint = y);
    }
    static fromArgs(u) {
      return new s(
        u.key,
        u.supply,
        u.maxSupply,
        u.printingMint,
        u.oneTimePrintingAuthorizationMint
      );
    }
    static fromAccountInfo(u, d = 0) {
      return s.deserialize(u.data, d);
    }
    static async fromAccountAddress(u, d, f) {
      const p = await u.getAccountInfo(d, f);
      if (p == null) throw new Error(`Unable to find MasterEditionV1 account at ${d}`);
      return s.fromAccountInfo(p, 0)[0];
    }
    static gpaBuilder(u = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
      return a.GpaBuilder.fromStruct(u, e.masterEditionV1Beet);
    }
    static deserialize(u, d = 0) {
      return e.masterEditionV1Beet.deserialize(u, d);
    }
    serialize() {
      return e.masterEditionV1Beet.serialize(this);
    }
    static byteSize(u) {
      const d = s.fromArgs(u);
      return e.masterEditionV1Beet.toFixedFromValue(d).byteSize;
    }
    static async getMinimumBalanceForRentExemption(u, d, f) {
      return d.getMinimumBalanceForRentExemption(s.byteSize(u), f);
    }
    pretty() {
      return {
        key: 'Key.' + c.Key[this.key],
        supply: (() => {
          const u = this.supply;
          if (typeof u.toNumber == 'function')
            try {
              return u.toNumber();
            } catch {
              return u;
            }
          return u;
        })(),
        maxSupply: this.maxSupply,
        printingMint: this.printingMint.toBase58(),
        oneTimePrintingAuthorizationMint: this.oneTimePrintingAuthorizationMint.toBase58(),
      };
    }
  }
  (e.MasterEditionV1 = s),
    (e.masterEditionV1Beet = new i.FixableBeetStruct(
      [
        ['key', c.keyBeet],
        ['supply', i.u64],
        ['maxSupply', i.coption(i.u64)],
        ['printingMint', a.publicKey],
        ['oneTimePrintingAuthorizationMint', a.publicKey],
      ],
      s.fromArgs,
      'MasterEditionV1'
    ));
})(Zm);
var Qm = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (l, u, d, f) {
            f === void 0 && (f = d);
            var p = Object.getOwnPropertyDescriptor(u, d);
            (!p || ('get' in p ? !u.__esModule : p.writable || p.configurable)) &&
              (p = {
                enumerable: !0,
                get: function () {
                  return u[d];
                },
              }),
              Object.defineProperty(l, f, p);
          }
        : function (l, u, d, f) {
            f === void 0 && (f = d), (l[f] = u[d]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (l, u) {
            Object.defineProperty(l, 'default', { enumerable: !0, value: u });
          }
        : function (l, u) {
            l.default = u;
          }),
    r =
      (g && g.__importStar) ||
      function (l) {
        if (l && l.__esModule) return l;
        var u = {};
        if (l != null)
          for (var d in l)
            d !== 'default' && Object.prototype.hasOwnProperty.call(l, d) && t(u, l, d);
        return n(u, l), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.masterEditionV2Beet = e.MasterEditionV2 = void 0);
  const i = r(W),
    o = r(V),
    a = r(st),
    c = pn;
  class s {
    constructor(u, d, f) {
      (this.key = u), (this.supply = d), (this.maxSupply = f);
    }
    static fromArgs(u) {
      return new s(u.key, u.supply, u.maxSupply);
    }
    static fromAccountInfo(u, d = 0) {
      return s.deserialize(u.data, d);
    }
    static async fromAccountAddress(u, d, f) {
      const p = await u.getAccountInfo(d, f);
      if (p == null) throw new Error(`Unable to find MasterEditionV2 account at ${d}`);
      return s.fromAccountInfo(p, 0)[0];
    }
    static gpaBuilder(u = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
      return a.GpaBuilder.fromStruct(u, e.masterEditionV2Beet);
    }
    static deserialize(u, d = 0) {
      return e.masterEditionV2Beet.deserialize(u, d);
    }
    serialize() {
      return e.masterEditionV2Beet.serialize(this);
    }
    static byteSize(u) {
      const d = s.fromArgs(u);
      return e.masterEditionV2Beet.toFixedFromValue(d).byteSize;
    }
    static async getMinimumBalanceForRentExemption(u, d, f) {
      return d.getMinimumBalanceForRentExemption(s.byteSize(u), f);
    }
    pretty() {
      return {
        key: 'Key.' + c.Key[this.key],
        supply: (() => {
          const u = this.supply;
          if (typeof u.toNumber == 'function')
            try {
              return u.toNumber();
            } catch {
              return u;
            }
          return u;
        })(),
        maxSupply: this.maxSupply,
      };
    }
  }
  (e.MasterEditionV2 = s),
    (e.masterEditionV2Beet = new i.FixableBeetStruct(
      [
        ['key', c.keyBeet],
        ['supply', i.u64],
        ['maxSupply', i.coption(i.u64)],
      ],
      s.fromArgs,
      'MasterEditionV2'
    ));
})(Qm);
var ob = {},
  la = {},
  da = {},
  lL =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  dL =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  uk =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && lL(t, e, n);
      return dL(t, e), t;
    };
Object.defineProperty(da, '__esModule', { value: !0 });
da.creatorBeet = void 0;
const fL = uk(st),
  ab = uk(W);
da.creatorBeet = new ab.BeetArgsStruct(
  [
    ['address', fL.publicKey],
    ['verified', ab.bool],
    ['share', ab.u8],
  ],
  'Creator'
);
var hL =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  pL =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  gL =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && hL(t, e, n);
      return pL(t, e), t;
    };
Object.defineProperty(la, '__esModule', { value: !0 });
la.dataBeet = void 0;
const bo = gL(W),
  yL = da;
la.dataBeet = new bo.FixableBeetArgsStruct(
  [
    ['name', bo.utf8String],
    ['symbol', bo.utf8String],
    ['uri', bo.utf8String],
    ['sellerFeeBasisPoints', bo.u16],
    ['creators', bo.coption(bo.array(yL.creatorBeet))],
  ],
  'Data'
);
var vs = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (a, c, s, l) {
            l === void 0 && (l = s);
            var u = Object.getOwnPropertyDescriptor(c, s);
            (!u || ('get' in u ? !c.__esModule : u.writable || u.configurable)) &&
              (u = {
                enumerable: !0,
                get: function () {
                  return c[s];
                },
              }),
              Object.defineProperty(a, l, u);
          }
        : function (a, c, s, l) {
            l === void 0 && (l = s), (a[l] = c[s]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (g && g.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var s in a)
            s !== 'default' && Object.prototype.hasOwnProperty.call(a, s) && t(c, a, s);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.tokenStandardBeet = e.TokenStandard = void 0);
  const i = r(W);
  var o;
  (function (a) {
    (a[(a.NonFungible = 0)] = 'NonFungible'),
      (a[(a.FungibleAsset = 1)] = 'FungibleAsset'),
      (a[(a.Fungible = 2)] = 'Fungible'),
      (a[(a.NonFungibleEdition = 3)] = 'NonFungibleEdition'),
      (a[(a.ProgrammableNonFungible = 4)] = 'ProgrammableNonFungible');
  })((o = e.TokenStandard || (e.TokenStandard = {}))),
    (e.tokenStandardBeet = i.fixedScalarEnum(o));
})(vs);
var bi = {},
  bL =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  mL =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  lk =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && bL(t, e, n);
      return mL(t, e), t;
    };
Object.defineProperty(bi, '__esModule', { value: !0 });
bi.collectionBeet = void 0;
const G_ = lk(W),
  wL = lk(st);
bi.collectionBeet = new G_.BeetArgsStruct(
  [
    ['verified', G_.bool],
    ['key', wL.publicKey],
  ],
  'Collection'
);
var mi = {},
  M1 = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (a, c, s, l) {
            l === void 0 && (l = s);
            var u = Object.getOwnPropertyDescriptor(c, s);
            (!u || ('get' in u ? !c.__esModule : u.writable || u.configurable)) &&
              (u = {
                enumerable: !0,
                get: function () {
                  return c[s];
                },
              }),
              Object.defineProperty(a, l, u);
          }
        : function (a, c, s, l) {
            l === void 0 && (l = s), (a[l] = c[s]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (g && g.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var s in a)
            s !== 'default' && Object.prototype.hasOwnProperty.call(a, s) && t(c, a, s);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }), (e.useMethodBeet = e.UseMethod = void 0);
  const i = r(W);
  var o;
  (function (a) {
    (a[(a.Burn = 0)] = 'Burn'), (a[(a.Multiple = 1)] = 'Multiple'), (a[(a.Single = 2)] = 'Single');
  })((o = e.UseMethod || (e.UseMethod = {}))),
    (e.useMethodBeet = i.fixedScalarEnum(o));
})(M1);
var _L =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  vL =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  SL =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && _L(t, e, n);
      return vL(t, e), t;
    };
Object.defineProperty(mi, '__esModule', { value: !0 });
mi.usesBeet = void 0;
const sb = SL(W),
  AL = M1;
mi.usesBeet = new sb.BeetArgsStruct(
  [
    ['useMethod', AL.useMethodBeet],
    ['remaining', sb.u64],
    ['total', sb.u64],
  ],
  'Uses'
);
var wr = {},
  IL =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  EL =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  TL =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && IL(t, e, n);
      return EL(t, e), t;
    };
Object.defineProperty(wr, '__esModule', { value: !0 });
wr.collectionDetailsBeet = wr.isCollectionDetailsV1 = void 0;
const cb = TL(W),
  kL = (e) => e.__kind === 'V1';
wr.isCollectionDetailsV1 = kL;
wr.collectionDetailsBeet = cb.dataEnum([
  ['V1', new cb.BeetArgsStruct([['size', cb.u64]], 'CollectionDetailsRecord["V1"]')],
]);
var ro = {},
  CL =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  ML =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  dk =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && CL(t, e, n);
      return ML(t, e), t;
    };
Object.defineProperty(ro, '__esModule', { value: !0 });
ro.programmableConfigBeet = ro.isProgrammableConfigV1 = void 0;
const ub = dk(W),
  PL = dk(st),
  OL = (e) => e.__kind === 'V1';
ro.isProgrammableConfigV1 = OL;
ro.programmableConfigBeet = ub.dataEnum([
  [
    'V1',
    new ub.FixableBeetArgsStruct(
      [['ruleSet', ub.coption(PL.publicKey)]],
      'ProgrammableConfigRecord["V1"]'
    ),
  ],
]);
var Ls = {},
  Y_;
function DL() {
  if (Y_) return Ls;
  Y_ = 1;
  var e =
      (g && g.__createBinding) ||
      (Object.create
        ? function (m, w, _, S) {
            S === void 0 && (S = _);
            var E = Object.getOwnPropertyDescriptor(w, _);
            (!E || ('get' in E ? !w.__esModule : E.writable || E.configurable)) &&
              (E = {
                enumerable: !0,
                get: function () {
                  return w[_];
                },
              }),
              Object.defineProperty(m, S, E);
          }
        : function (m, w, _, S) {
            S === void 0 && (S = _), (m[S] = w[_]);
          }),
    t =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (m, w) {
            Object.defineProperty(m, 'default', { enumerable: !0, value: w });
          }
        : function (m, w) {
            m.default = w;
          }),
    n =
      (g && g.__importStar) ||
      function (m) {
        if (m && m.__esModule) return m;
        var w = {};
        if (m != null)
          for (var _ in m)
            _ !== 'default' && Object.prototype.hasOwnProperty.call(m, _) && e(w, m, _);
        return t(w, m), w;
      };
  Object.defineProperty(Ls, '__esModule', { value: !0 }), (Ls.deserialize = void 0);
  const r = n(W),
    i = n(st),
    o = Jm(),
    a = bi,
    c = wr,
    s = ro,
    l = la,
    u = pn,
    d = vs,
    f = mi,
    p = r.coptionNone('').byteSize;
  function y(m, w = 0) {
    let _ = w;
    const S = u.keyBeet.read(m, _);
    _ += u.keyBeet.byteSize;
    const E = i.publicKey.read(m, _);
    _ += i.publicKey.byteSize;
    const O = i.publicKey.read(m, _);
    _ += i.publicKey.byteSize;
    const [N, F] = l.dataBeet.deserialize(m, _);
    _ = F;
    const D = r.bool.read(m, _);
    _ += r.bool.byteSize;
    const k = r.bool.read(m, _);
    _ += r.bool.byteSize;
    const K = r.coption(r.u8).toFixedFromData(m, _),
      M = K.read(m, _);
    _ += K.byteSize;
    const [C, z, I] = b(r.coption(d.tokenStandardBeet), m, _);
    _ += z;
    const [T, P, R] = I ? [null, p, !0] : b(r.coption(a.collectionBeet), m, _);
    _ += P;
    const [L, H, ie] = I || R ? [null, p, !0] : b(r.coption(f.usesBeet), m, _);
    _ += H;
    const [he, Q, ee] = I || R || ie ? [null, p, !0] : b(r.coption(c.collectionDetailsBeet), m, _);
    _ += Q;
    const [J, fe, j] = I || R || ie ? [null, p, !0] : b(r.coption(s.programmableConfigBeet), m, _);
    _ += fe;
    const Ie = I || R || ie || ee || j,
      re = {
        key: S,
        updateAuthority: E,
        mint: O,
        data: N,
        primarySaleHappened: D,
        isMutable: k,
        editionNonce: M,
        tokenStandard: Ie ? null : C,
        collection: Ie ? null : T,
        uses: Ie ? null : L,
        collectionDetails: Ie ? null : he,
        programmableConfig: Ie ? null : J,
      };
    return [o.Metadata.fromArgs(re), _];
  }
  Ls.deserialize = y;
  function b(m, w, _) {
    try {
      const S = m.toFixedFromData(w, _);
      return [S.read(w, _), S.byteSize, !1];
    } catch {
      return [null, p, !0];
    }
  }
  return Ls;
}
var Z_;
function Jm() {
  return (
    Z_ ||
      ((Z_ = 1),
      (function (e) {
        var t =
            (g && g.__createBinding) ||
            (Object.create
              ? function (S, E, O, N) {
                  N === void 0 && (N = O);
                  var F = Object.getOwnPropertyDescriptor(E, O);
                  (!F || ('get' in F ? !E.__esModule : F.writable || F.configurable)) &&
                    (F = {
                      enumerable: !0,
                      get: function () {
                        return E[O];
                      },
                    }),
                    Object.defineProperty(S, N, F);
                }
              : function (S, E, O, N) {
                  N === void 0 && (N = O), (S[N] = E[O]);
                }),
          n =
            (g && g.__setModuleDefault) ||
            (Object.create
              ? function (S, E) {
                  Object.defineProperty(S, 'default', { enumerable: !0, value: E });
                }
              : function (S, E) {
                  S.default = E;
                }),
          r =
            (g && g.__importStar) ||
            function (S) {
              if (S && S.__esModule) return S;
              var E = {};
              if (S != null)
                for (var O in S)
                  O !== 'default' && Object.prototype.hasOwnProperty.call(S, O) && t(E, S, O);
              return n(E, S), E;
            };
        Object.defineProperty(e, '__esModule', { value: !0 }),
          (e.metadataBeet = e.Metadata = void 0);
        const i = r(V),
          o = r(W),
          a = r(st),
          c = pn,
          s = la,
          l = vs,
          u = bi,
          d = mi,
          f = wr,
          p = ro,
          y = r(DL());
        class b {
          constructor(E, O, N, F, D, k, K, M, C, z, I, T) {
            (this.key = E),
              (this.updateAuthority = O),
              (this.mint = N),
              (this.data = F),
              (this.primarySaleHappened = D),
              (this.isMutable = k),
              (this.editionNonce = K),
              (this.tokenStandard = M),
              (this.collection = C),
              (this.uses = z),
              (this.collectionDetails = I),
              (this.programmableConfig = T);
          }
          static fromArgs(E) {
            return new b(
              E.key,
              E.updateAuthority,
              E.mint,
              E.data,
              E.primarySaleHappened,
              E.isMutable,
              E.editionNonce,
              E.tokenStandard,
              E.collection,
              E.uses,
              E.collectionDetails,
              E.programmableConfig
            );
          }
          static fromAccountInfo(E, O = 0) {
            return b.deserialize(E.data, O);
          }
          static async fromAccountAddress(E, O, N) {
            const F = await E.getAccountInfo(O, N);
            if (F == null) throw new Error(`Unable to find Metadata account at ${O}`);
            return b.fromAccountInfo(F, 0)[0];
          }
          static gpaBuilder(E = new i.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
            return a.GpaBuilder.fromStruct(E, e.metadataBeet);
          }
          static deserialize(E, O = 0) {
            return _(E, O);
          }
          serialize() {
            return w(this);
          }
          static byteSize(E) {
            const O = b.fromArgs(E);
            return e.metadataBeet.toFixedFromValue(O).byteSize;
          }
          static async getMinimumBalanceForRentExemption(E, O, N) {
            return O.getMinimumBalanceForRentExemption(b.byteSize(E), N);
          }
          pretty() {
            return {
              key: 'Key.' + c.Key[this.key],
              updateAuthority: this.updateAuthority.toBase58(),
              mint: this.mint.toBase58(),
              data: this.data,
              primarySaleHappened: this.primarySaleHappened,
              isMutable: this.isMutable,
              editionNonce: this.editionNonce,
              tokenStandard: this.tokenStandard,
              collection: this.collection,
              uses: this.uses,
              collectionDetails: this.collectionDetails,
              programmableConfig: this.programmableConfig,
            };
          }
        }
        (e.Metadata = b),
          (e.metadataBeet = new o.FixableBeetStruct(
            [
              ['key', c.keyBeet],
              ['updateAuthority', a.publicKey],
              ['mint', a.publicKey],
              ['data', s.dataBeet],
              ['primarySaleHappened', o.bool],
              ['isMutable', o.bool],
              ['editionNonce', o.coption(o.u8)],
              ['tokenStandard', o.coption(l.tokenStandardBeet)],
              ['collection', o.coption(u.collectionBeet)],
              ['uses', o.coption(d.usesBeet)],
              ['collectionDetails', o.coption(f.collectionDetailsBeet)],
              ['programmableConfig', o.coption(p.programmableConfigBeet)],
            ],
            b.fromArgs,
            'Metadata'
          ));
        const m = y,
          w =
            typeof m.serialize == 'function'
              ? m.serialize.bind(m)
              : e.metadataBeet.serialize.bind(e.metadataBeet),
          _ =
            typeof m.deserialize == 'function'
              ? m.deserialize.bind(m)
              : e.metadataBeet.deserialize.bind(e.metadataBeet);
      })(ob)),
    ob
  );
}
var Xm = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (l, u, d, f) {
            f === void 0 && (f = d);
            var p = Object.getOwnPropertyDescriptor(u, d);
            (!p || ('get' in p ? !u.__esModule : p.writable || p.configurable)) &&
              (p = {
                enumerable: !0,
                get: function () {
                  return u[d];
                },
              }),
              Object.defineProperty(l, f, p);
          }
        : function (l, u, d, f) {
            f === void 0 && (f = d), (l[f] = u[d]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (l, u) {
            Object.defineProperty(l, 'default', { enumerable: !0, value: u });
          }
        : function (l, u) {
            l.default = u;
          }),
    r =
      (g && g.__importStar) ||
      function (l) {
        if (l && l.__esModule) return l;
        var u = {};
        if (l != null)
          for (var d in l)
            d !== 'default' && Object.prototype.hasOwnProperty.call(l, d) && t(u, l, d);
        return n(u, l), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.metadataDelegateRecordBeet = e.MetadataDelegateRecord = void 0);
  const i = r(V),
    o = r(W),
    a = r(st),
    c = pn;
  class s {
    constructor(u, d, f, p, y) {
      (this.key = u),
        (this.bump = d),
        (this.mint = f),
        (this.delegate = p),
        (this.updateAuthority = y);
    }
    static fromArgs(u) {
      return new s(u.key, u.bump, u.mint, u.delegate, u.updateAuthority);
    }
    static fromAccountInfo(u, d = 0) {
      return s.deserialize(u.data, d);
    }
    static async fromAccountAddress(u, d, f) {
      const p = await u.getAccountInfo(d, f);
      if (p == null) throw new Error(`Unable to find MetadataDelegateRecord account at ${d}`);
      return s.fromAccountInfo(p, 0)[0];
    }
    static gpaBuilder(u = new i.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
      return a.GpaBuilder.fromStruct(u, e.metadataDelegateRecordBeet);
    }
    static deserialize(u, d = 0) {
      return e.metadataDelegateRecordBeet.deserialize(u, d);
    }
    serialize() {
      return e.metadataDelegateRecordBeet.serialize(this);
    }
    static get byteSize() {
      return e.metadataDelegateRecordBeet.byteSize;
    }
    static async getMinimumBalanceForRentExemption(u, d) {
      return u.getMinimumBalanceForRentExemption(s.byteSize, d);
    }
    static hasCorrectByteSize(u, d = 0) {
      return u.byteLength - d === s.byteSize;
    }
    pretty() {
      return {
        key: 'Key.' + c.Key[this.key],
        bump: this.bump,
        mint: this.mint.toBase58(),
        delegate: this.delegate.toBase58(),
        updateAuthority: this.updateAuthority.toBase58(),
      };
    }
  }
  (e.MetadataDelegateRecord = s),
    (e.metadataDelegateRecordBeet = new o.BeetStruct(
      [
        ['key', c.keyBeet],
        ['bump', o.u8],
        ['mint', a.publicKey],
        ['delegate', a.publicKey],
        ['updateAuthority', a.publicKey],
      ],
      s.fromArgs,
      'MetadataDelegateRecord'
    ));
})(Xm);
var e0 = {},
  Lc = {},
  RL =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  xL =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  fk =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && RL(t, e, n);
      return xL(t, e), t;
    };
Object.defineProperty(Lc, '__esModule', { value: !0 });
Lc.reservationV1Beet = void 0;
const BL = fk(st),
  lb = fk(W);
Lc.reservationV1Beet = new lb.BeetArgsStruct(
  [
    ['address', BL.publicKey],
    ['spotsRemaining', lb.u8],
    ['totalSpots', lb.u8],
  ],
  'ReservationV1'
);
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (u, d, f, p) {
            p === void 0 && (p = f);
            var y = Object.getOwnPropertyDescriptor(d, f);
            (!y || ('get' in y ? !d.__esModule : y.writable || y.configurable)) &&
              (y = {
                enumerable: !0,
                get: function () {
                  return d[f];
                },
              }),
              Object.defineProperty(u, p, y);
          }
        : function (u, d, f, p) {
            p === void 0 && (p = f), (u[p] = d[f]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (u, d) {
            Object.defineProperty(u, 'default', { enumerable: !0, value: d });
          }
        : function (u, d) {
            u.default = d;
          }),
    r =
      (g && g.__importStar) ||
      function (u) {
        if (u && u.__esModule) return u;
        var d = {};
        if (u != null)
          for (var f in u)
            f !== 'default' && Object.prototype.hasOwnProperty.call(u, f) && t(d, u, f);
        return n(d, u), d;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.reservationListV1Beet = e.ReservationListV1 = void 0);
  const i = r(V),
    o = r(W),
    a = r(st),
    c = pn,
    s = Lc;
  class l {
    constructor(d, f, p, y) {
      (this.key = d), (this.masterEdition = f), (this.supplySnapshot = p), (this.reservations = y);
    }
    static fromArgs(d) {
      return new l(d.key, d.masterEdition, d.supplySnapshot, d.reservations);
    }
    static fromAccountInfo(d, f = 0) {
      return l.deserialize(d.data, f);
    }
    static async fromAccountAddress(d, f, p) {
      const y = await d.getAccountInfo(f, p);
      if (y == null) throw new Error(`Unable to find ReservationListV1 account at ${f}`);
      return l.fromAccountInfo(y, 0)[0];
    }
    static gpaBuilder(d = new i.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
      return a.GpaBuilder.fromStruct(d, e.reservationListV1Beet);
    }
    static deserialize(d, f = 0) {
      return e.reservationListV1Beet.deserialize(d, f);
    }
    serialize() {
      return e.reservationListV1Beet.serialize(this);
    }
    static byteSize(d) {
      const f = l.fromArgs(d);
      return e.reservationListV1Beet.toFixedFromValue(f).byteSize;
    }
    static async getMinimumBalanceForRentExemption(d, f, p) {
      return f.getMinimumBalanceForRentExemption(l.byteSize(d), p);
    }
    pretty() {
      return {
        key: 'Key.' + c.Key[this.key],
        masterEdition: this.masterEdition.toBase58(),
        supplySnapshot: this.supplySnapshot,
        reservations: this.reservations,
      };
    }
  }
  (e.ReservationListV1 = l),
    (e.reservationListV1Beet = new o.FixableBeetStruct(
      [
        ['key', c.keyBeet],
        ['masterEdition', a.publicKey],
        ['supplySnapshot', o.coption(o.u64)],
        ['reservations', o.array(s.reservationV1Beet)],
      ],
      l.fromArgs,
      'ReservationListV1'
    ));
})(e0);
var t0 = {},
  zc = {},
  jL =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  NL =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  hk =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && jL(t, e, n);
      return NL(t, e), t;
    };
Object.defineProperty(zc, '__esModule', { value: !0 });
zc.reservationBeet = void 0;
const db = hk(W),
  UL = hk(st);
zc.reservationBeet = new db.BeetArgsStruct(
  [
    ['address', UL.publicKey],
    ['spotsRemaining', db.u64],
    ['totalSpots', db.u64],
  ],
  'Reservation'
);
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (u, d, f, p) {
            p === void 0 && (p = f);
            var y = Object.getOwnPropertyDescriptor(d, f);
            (!y || ('get' in y ? !d.__esModule : y.writable || y.configurable)) &&
              (y = {
                enumerable: !0,
                get: function () {
                  return d[f];
                },
              }),
              Object.defineProperty(u, p, y);
          }
        : function (u, d, f, p) {
            p === void 0 && (p = f), (u[p] = d[f]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (u, d) {
            Object.defineProperty(u, 'default', { enumerable: !0, value: d });
          }
        : function (u, d) {
            u.default = d;
          }),
    r =
      (g && g.__importStar) ||
      function (u) {
        if (u && u.__esModule) return u;
        var d = {};
        if (u != null)
          for (var f in u)
            f !== 'default' && Object.prototype.hasOwnProperty.call(u, f) && t(d, u, f);
        return n(d, u), d;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.reservationListV2Beet = e.ReservationListV2 = void 0);
  const i = r(V),
    o = r(W),
    a = r(st),
    c = pn,
    s = zc;
  class l {
    constructor(d, f, p, y, b, m) {
      (this.key = d),
        (this.masterEdition = f),
        (this.supplySnapshot = p),
        (this.reservations = y),
        (this.totalReservationSpots = b),
        (this.currentReservationSpots = m);
    }
    static fromArgs(d) {
      return new l(
        d.key,
        d.masterEdition,
        d.supplySnapshot,
        d.reservations,
        d.totalReservationSpots,
        d.currentReservationSpots
      );
    }
    static fromAccountInfo(d, f = 0) {
      return l.deserialize(d.data, f);
    }
    static async fromAccountAddress(d, f, p) {
      const y = await d.getAccountInfo(f, p);
      if (y == null) throw new Error(`Unable to find ReservationListV2 account at ${f}`);
      return l.fromAccountInfo(y, 0)[0];
    }
    static gpaBuilder(d = new i.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
      return a.GpaBuilder.fromStruct(d, e.reservationListV2Beet);
    }
    static deserialize(d, f = 0) {
      return e.reservationListV2Beet.deserialize(d, f);
    }
    serialize() {
      return e.reservationListV2Beet.serialize(this);
    }
    static byteSize(d) {
      const f = l.fromArgs(d);
      return e.reservationListV2Beet.toFixedFromValue(f).byteSize;
    }
    static async getMinimumBalanceForRentExemption(d, f, p) {
      return f.getMinimumBalanceForRentExemption(l.byteSize(d), p);
    }
    pretty() {
      return {
        key: 'Key.' + c.Key[this.key],
        masterEdition: this.masterEdition.toBase58(),
        supplySnapshot: this.supplySnapshot,
        reservations: this.reservations,
        totalReservationSpots: (() => {
          const d = this.totalReservationSpots;
          if (typeof d.toNumber == 'function')
            try {
              return d.toNumber();
            } catch {
              return d;
            }
          return d;
        })(),
        currentReservationSpots: (() => {
          const d = this.currentReservationSpots;
          if (typeof d.toNumber == 'function')
            try {
              return d.toNumber();
            } catch {
              return d;
            }
          return d;
        })(),
      };
    }
  }
  (e.ReservationListV2 = l),
    (e.reservationListV2Beet = new o.FixableBeetStruct(
      [
        ['key', c.keyBeet],
        ['masterEdition', a.publicKey],
        ['supplySnapshot', o.coption(o.u64)],
        ['reservations', o.array(s.reservationBeet)],
        ['totalReservationSpots', o.u64],
        ['currentReservationSpots', o.u64],
      ],
      l.fromArgs,
      'ReservationListV2'
    ));
})(t0);
var n0 = {},
  ui = {},
  LL =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  zL =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  pk =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && LL(t, e, n);
      return zL(t, e), t;
    };
Object.defineProperty(ui, '__esModule', { value: !0 });
ui.escrowAuthorityBeet = ui.isEscrowAuthorityCreator = ui.isEscrowAuthorityTokenOwner = void 0;
const eh = pk(W),
  FL = pk(st),
  $L = (e) => e.__kind === 'TokenOwner';
ui.isEscrowAuthorityTokenOwner = $L;
const WL = (e) => e.__kind === 'Creator';
ui.isEscrowAuthorityCreator = WL;
ui.escrowAuthorityBeet = eh.dataEnum([
  ['TokenOwner', eh.unit],
  [
    'Creator',
    new eh.BeetArgsStruct(
      [['fields', eh.fixedSizeTuple([FL.publicKey])]],
      'EscrowAuthorityRecord["Creator"]'
    ),
  ],
]);
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (u, d, f, p) {
            p === void 0 && (p = f);
            var y = Object.getOwnPropertyDescriptor(d, f);
            (!y || ('get' in y ? !d.__esModule : y.writable || y.configurable)) &&
              (y = {
                enumerable: !0,
                get: function () {
                  return d[f];
                },
              }),
              Object.defineProperty(u, p, y);
          }
        : function (u, d, f, p) {
            p === void 0 && (p = f), (u[p] = d[f]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (u, d) {
            Object.defineProperty(u, 'default', { enumerable: !0, value: d });
          }
        : function (u, d) {
            u.default = d;
          }),
    r =
      (g && g.__importStar) ||
      function (u) {
        if (u && u.__esModule) return u;
        var d = {};
        if (u != null)
          for (var f in u)
            f !== 'default' && Object.prototype.hasOwnProperty.call(u, f) && t(d, u, f);
        return n(d, u), d;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.tokenOwnedEscrowBeet = e.TokenOwnedEscrow = void 0);
  const i = r(V),
    o = r(st),
    a = r(W),
    c = pn,
    s = ui;
  class l {
    constructor(d, f, p, y) {
      (this.key = d), (this.baseToken = f), (this.authority = p), (this.bump = y);
    }
    static fromArgs(d) {
      return new l(d.key, d.baseToken, d.authority, d.bump);
    }
    static fromAccountInfo(d, f = 0) {
      return l.deserialize(d.data, f);
    }
    static async fromAccountAddress(d, f, p) {
      const y = await d.getAccountInfo(f, p);
      if (y == null) throw new Error(`Unable to find TokenOwnedEscrow account at ${f}`);
      return l.fromAccountInfo(y, 0)[0];
    }
    static gpaBuilder(d = new i.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
      return o.GpaBuilder.fromStruct(d, e.tokenOwnedEscrowBeet);
    }
    static deserialize(d, f = 0) {
      return e.tokenOwnedEscrowBeet.deserialize(d, f);
    }
    serialize() {
      return e.tokenOwnedEscrowBeet.serialize(this);
    }
    static byteSize(d) {
      const f = l.fromArgs(d);
      return e.tokenOwnedEscrowBeet.toFixedFromValue(f).byteSize;
    }
    static async getMinimumBalanceForRentExemption(d, f, p) {
      return f.getMinimumBalanceForRentExemption(l.byteSize(d), p);
    }
    pretty() {
      return {
        key: 'Key.' + c.Key[this.key],
        baseToken: this.baseToken.toBase58(),
        authority: this.authority.__kind,
        bump: this.bump,
      };
    }
  }
  (e.TokenOwnedEscrow = l),
    (e.tokenOwnedEscrowBeet = new a.FixableBeetStruct(
      [
        ['key', c.keyBeet],
        ['baseToken', o.publicKey],
        ['authority', s.escrowAuthorityBeet],
        ['bump', a.u8],
      ],
      l.fromArgs,
      'TokenOwnedEscrow'
    ));
})(n0);
var fb = {},
  P1 = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (a, c, s, l) {
            l === void 0 && (l = s);
            var u = Object.getOwnPropertyDescriptor(c, s);
            (!u || ('get' in u ? !c.__esModule : u.writable || u.configurable)) &&
              (u = {
                enumerable: !0,
                get: function () {
                  return c[s];
                },
              }),
              Object.defineProperty(a, l, u);
          }
        : function (a, c, s, l) {
            l === void 0 && (l = s), (a[l] = c[s]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (g && g.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var s in a)
            s !== 'default' && Object.prototype.hasOwnProperty.call(a, s) && t(c, a, s);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }), (e.tokenStateBeet = e.TokenState = void 0);
  const i = r(W);
  var o;
  (function (a) {
    (a[(a.Unlocked = 0)] = 'Unlocked'),
      (a[(a.Locked = 1)] = 'Locked'),
      (a[(a.Listed = 2)] = 'Listed');
  })((o = e.TokenState || (e.TokenState = {}))),
    (e.tokenStateBeet = i.fixedScalarEnum(o));
})(P1);
var O1 = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (a, c, s, l) {
            l === void 0 && (l = s);
            var u = Object.getOwnPropertyDescriptor(c, s);
            (!u || ('get' in u ? !c.__esModule : u.writable || u.configurable)) &&
              (u = {
                enumerable: !0,
                get: function () {
                  return c[s];
                },
              }),
              Object.defineProperty(a, l, u);
          }
        : function (a, c, s, l) {
            l === void 0 && (l = s), (a[l] = c[s]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (g && g.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var s in a)
            s !== 'default' && Object.prototype.hasOwnProperty.call(a, s) && t(c, a, s);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.tokenDelegateRoleBeet = e.TokenDelegateRole = void 0);
  const i = r(W);
  var o;
  (function (a) {
    (a[(a.Sale = 0)] = 'Sale'),
      (a[(a.Transfer = 1)] = 'Transfer'),
      (a[(a.Utility = 2)] = 'Utility'),
      (a[(a.Staking = 3)] = 'Staking'),
      (a[(a.Standard = 4)] = 'Standard'),
      (a[(a.LockedTransfer = 5)] = 'LockedTransfer'),
      (a[(a.Migration = 6)] = 'Migration');
  })((o = e.TokenDelegateRole || (e.TokenDelegateRole = {}))),
    (e.tokenDelegateRoleBeet = i.fixedScalarEnum(o));
})(O1);
var zs = {},
  ug = {},
  VL =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  KL =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  HL =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && VL(t, e, n);
      return KL(t, e), t;
    };
Object.defineProperty(ug, '__esModule', { value: !0 });
ug.tryReadOption = void 0;
const qL = HL(W),
  GL = qL.coptionNone('').byteSize;
function YL(e, t, n) {
  if (t.subarray(n).length == 0) return [null, GL, !0];
  const r = e.toFixedFromData(t, n);
  return [r.read(t, n), r.byteSize, !1];
}
ug.tryReadOption = YL;
var Q_;
function ZL() {
  if (Q_) return zs;
  Q_ = 1;
  var e =
      (g && g.__createBinding) ||
      (Object.create
        ? function (u, d, f, p) {
            p === void 0 && (p = f);
            var y = Object.getOwnPropertyDescriptor(d, f);
            (!y || ('get' in y ? !d.__esModule : y.writable || y.configurable)) &&
              (y = {
                enumerable: !0,
                get: function () {
                  return d[f];
                },
              }),
              Object.defineProperty(u, p, y);
          }
        : function (u, d, f, p) {
            p === void 0 && (p = f), (u[p] = d[f]);
          }),
    t =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (u, d) {
            Object.defineProperty(u, 'default', { enumerable: !0, value: d });
          }
        : function (u, d) {
            u.default = d;
          }),
    n =
      (g && g.__importStar) ||
      function (u) {
        if (u && u.__esModule) return u;
        var d = {};
        if (u != null)
          for (var f in u)
            f !== 'default' && Object.prototype.hasOwnProperty.call(u, f) && e(d, u, f);
        return t(d, u), d;
      };
  Object.defineProperty(zs, '__esModule', { value: !0 }), (zs.deserialize = void 0);
  const r = n(W),
    i = n(st),
    o = pn,
    a = r0(),
    c = W1(),
    s = ug;
  function l(u, d = 0) {
    let f = d;
    const p = o.keyBeet.read(u, f);
    f += o.keyBeet.byteSize;
    const y = r.u8.read(u, f);
    f += r.u8.byteSize;
    const b = c.tokenStateBeet.read(u, f);
    f += c.tokenStateBeet.byteSize;
    const [m, w] = (0, s.tryReadOption)(r.coption(r.u64), u, f);
    f += w;
    const [_, S] = (0, s.tryReadOption)(r.coption(i.publicKey), u, f);
    f += S;
    const [E, O] = (0, s.tryReadOption)(r.coption(c.tokenDelegateRoleBeet), u, f);
    f += O;
    const [N, F, D] = (0, s.tryReadOption)(r.coption(i.publicKey), u, f);
    f += F;
    const k = {
      key: p,
      bump: y,
      state: b,
      ruleSetRevision: m,
      delegate: _,
      delegateRole: E,
      lockedTransfer: D ? null : N,
    };
    return [a.TokenRecord.fromArgs(k), f];
  }
  return (zs.deserialize = l), zs;
}
var J_;
function r0() {
  return (
    J_ ||
      ((J_ = 1),
      (function (e) {
        var t =
            (g && g.__createBinding) ||
            (Object.create
              ? function (b, m, w, _) {
                  _ === void 0 && (_ = w);
                  var S = Object.getOwnPropertyDescriptor(m, w);
                  (!S || ('get' in S ? !m.__esModule : S.writable || S.configurable)) &&
                    (S = {
                      enumerable: !0,
                      get: function () {
                        return m[w];
                      },
                    }),
                    Object.defineProperty(b, _, S);
                }
              : function (b, m, w, _) {
                  _ === void 0 && (_ = w), (b[_] = m[w]);
                }),
          n =
            (g && g.__setModuleDefault) ||
            (Object.create
              ? function (b, m) {
                  Object.defineProperty(b, 'default', { enumerable: !0, value: m });
                }
              : function (b, m) {
                  b.default = m;
                }),
          r =
            (g && g.__importStar) ||
            function (b) {
              if (b && b.__esModule) return b;
              var m = {};
              if (b != null)
                for (var w in b)
                  w !== 'default' && Object.prototype.hasOwnProperty.call(b, w) && t(m, b, w);
              return n(m, b), m;
            };
        Object.defineProperty(e, '__esModule', { value: !0 }),
          (e.tokenRecordBeet = e.TokenRecord = void 0);
        const i = r(W),
          o = r(V),
          a = r(st),
          c = pn,
          s = P1,
          l = O1,
          u = r(ZL());
        class d {
          constructor(m, w, _, S, E, O, N) {
            (this.key = m),
              (this.bump = w),
              (this.state = _),
              (this.ruleSetRevision = S),
              (this.delegate = E),
              (this.delegateRole = O),
              (this.lockedTransfer = N);
          }
          static fromArgs(m) {
            return new d(
              m.key,
              m.bump,
              m.state,
              m.ruleSetRevision,
              m.delegate,
              m.delegateRole,
              m.lockedTransfer
            );
          }
          static fromAccountInfo(m, w = 0) {
            return d.deserialize(m.data, w);
          }
          static async fromAccountAddress(m, w, _) {
            const S = await m.getAccountInfo(w, _);
            if (S == null) throw new Error(`Unable to find TokenRecord account at ${w}`);
            return d.fromAccountInfo(S, 0)[0];
          }
          static gpaBuilder(m = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
            return a.GpaBuilder.fromStruct(m, e.tokenRecordBeet);
          }
          static deserialize(m, w = 0) {
            return y(m, w);
          }
          serialize() {
            return p(this);
          }
          static byteSize(m) {
            const w = d.fromArgs(m);
            return e.tokenRecordBeet.toFixedFromValue(w).byteSize;
          }
          static async getMinimumBalanceForRentExemption(m, w, _) {
            return w.getMinimumBalanceForRentExemption(d.byteSize(m), _);
          }
          pretty() {
            return {
              key: 'Key.' + c.Key[this.key],
              bump: this.bump,
              state: 'TokenState.' + s.TokenState[this.state],
              ruleSetRevision: this.ruleSetRevision,
              delegate: this.delegate,
              delegateRole: this.delegateRole,
              lockedTransfer: this.lockedTransfer,
            };
          }
        }
        (e.TokenRecord = d),
          (e.tokenRecordBeet = new i.FixableBeetStruct(
            [
              ['key', c.keyBeet],
              ['bump', i.u8],
              ['state', s.tokenStateBeet],
              ['ruleSetRevision', i.coption(i.u64)],
              ['delegate', i.coption(a.publicKey)],
              ['delegateRole', i.coption(l.tokenDelegateRoleBeet)],
              ['lockedTransfer', i.coption(a.publicKey)],
            ],
            d.fromArgs,
            'TokenRecord'
          ));
        const f = u,
          p =
            typeof f.serialize == 'function'
              ? f.serialize.bind(f)
              : e.tokenRecordBeet.serialize.bind(e.tokenRecordBeet),
          y =
            typeof f.deserialize == 'function'
              ? f.deserialize.bind(f)
              : e.tokenRecordBeet.deserialize.bind(e.tokenRecordBeet);
      })(fb)),
    fb
  );
}
var i0 = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (l, u, d, f) {
            f === void 0 && (f = d);
            var p = Object.getOwnPropertyDescriptor(u, d);
            (!p || ('get' in p ? !u.__esModule : p.writable || p.configurable)) &&
              (p = {
                enumerable: !0,
                get: function () {
                  return u[d];
                },
              }),
              Object.defineProperty(l, f, p);
          }
        : function (l, u, d, f) {
            f === void 0 && (f = d), (l[f] = u[d]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (l, u) {
            Object.defineProperty(l, 'default', { enumerable: !0, value: u });
          }
        : function (l, u) {
            l.default = u;
          }),
    r =
      (g && g.__importStar) ||
      function (l) {
        if (l && l.__esModule) return l;
        var u = {};
        if (l != null)
          for (var d in l)
            d !== 'default' && Object.prototype.hasOwnProperty.call(l, d) && t(u, l, d);
        return n(u, l), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.useAuthorityRecordBeet = e.UseAuthorityRecord = void 0);
  const i = r(W),
    o = r(V),
    a = r(st),
    c = pn;
  class s {
    constructor(u, d, f) {
      (this.key = u), (this.allowedUses = d), (this.bump = f);
    }
    static fromArgs(u) {
      return new s(u.key, u.allowedUses, u.bump);
    }
    static fromAccountInfo(u, d = 0) {
      return s.deserialize(u.data, d);
    }
    static async fromAccountAddress(u, d, f) {
      const p = await u.getAccountInfo(d, f);
      if (p == null) throw new Error(`Unable to find UseAuthorityRecord account at ${d}`);
      return s.fromAccountInfo(p, 0)[0];
    }
    static gpaBuilder(u = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
      return a.GpaBuilder.fromStruct(u, e.useAuthorityRecordBeet);
    }
    static deserialize(u, d = 0) {
      return e.useAuthorityRecordBeet.deserialize(u, d);
    }
    serialize() {
      return e.useAuthorityRecordBeet.serialize(this);
    }
    static get byteSize() {
      return e.useAuthorityRecordBeet.byteSize;
    }
    static async getMinimumBalanceForRentExemption(u, d) {
      return u.getMinimumBalanceForRentExemption(s.byteSize, d);
    }
    static hasCorrectByteSize(u, d = 0) {
      return u.byteLength - d === s.byteSize;
    }
    pretty() {
      return {
        key: 'Key.' + c.Key[this.key],
        allowedUses: (() => {
          const u = this.allowedUses;
          if (typeof u.toNumber == 'function')
            try {
              return u.toNumber();
            } catch {
              return u;
            }
          return u;
        })(),
        bump: this.bump,
      };
    }
  }
  (e.UseAuthorityRecord = s),
    (e.useAuthorityRecordBeet = new i.BeetStruct(
      [
        ['key', c.keyBeet],
        ['allowedUses', i.u64],
        ['bump', i.u8],
      ],
      s.fromArgs,
      'UseAuthorityRecord'
    ));
})(i0);
var X_;
function QL() {
  return (
    X_ ||
      ((X_ = 1),
      (function (e) {
        var t =
            (g && g.__createBinding) ||
            (Object.create
              ? function (b, m, w, _) {
                  _ === void 0 && (_ = w);
                  var S = Object.getOwnPropertyDescriptor(m, w);
                  (!S || ('get' in S ? !m.__esModule : S.writable || S.configurable)) &&
                    (S = {
                      enumerable: !0,
                      get: function () {
                        return m[w];
                      },
                    }),
                    Object.defineProperty(b, _, S);
                }
              : function (b, m, w, _) {
                  _ === void 0 && (_ = w), (b[_] = m[w]);
                }),
          n =
            (g && g.__exportStar) ||
            function (b, m) {
              for (var w in b)
                w !== 'default' && !Object.prototype.hasOwnProperty.call(m, w) && t(m, b, w);
            };
        Object.defineProperty(e, '__esModule', { value: !0 }),
          (e.accountProviders = void 0),
          n(qm, e),
          n(Gm, e),
          n(Ym, e),
          n(Zm, e),
          n(Qm, e),
          n(Jm(), e),
          n(Xm, e),
          n(e0, e),
          n(t0, e),
          n(n0, e),
          n(r0(), e),
          n(i0, e);
        const r = qm,
          i = Xm,
          o = Gm,
          a = Ym,
          c = n0,
          s = Qm,
          l = Zm,
          u = Jm(),
          d = r0(),
          f = t0,
          p = e0,
          y = i0;
        e.accountProviders = {
          CollectionAuthorityRecord: r.CollectionAuthorityRecord,
          MetadataDelegateRecord: i.MetadataDelegateRecord,
          Edition: o.Edition,
          EditionMarker: a.EditionMarker,
          TokenOwnedEscrow: c.TokenOwnedEscrow,
          MasterEditionV2: s.MasterEditionV2,
          MasterEditionV1: l.MasterEditionV1,
          Metadata: u.Metadata,
          TokenRecord: d.TokenRecord,
          ReservationListV2: f.ReservationListV2,
          ReservationListV1: p.ReservationListV1,
          UseAuthorityRecord: y.UseAuthorityRecord,
        };
      })(ib)),
    ib
  );
}
var v = {};
Object.defineProperty(v, '__esModule', { value: !0 });
v.ReservationAlreadyMadeError =
  v.ReservationNotSetError =
  v.ReservationDoesNotExistError =
  v.ReservationExistsError =
  v.ShareTotalMustBe100Error =
  v.NoBalanceInAccountForAuthorizationError =
  v.OwnerMismatchError =
  v.PrimarySaleCanOnlyBeFlippedToTrueError =
  v.InvalidBasisPointsError =
  v.CreatorNotFoundError =
  v.NoCreatorsPresentOnMetadataError =
  v.MustBeOneOfCreatorsError =
  v.CreatorsMustBeAtleastOneError =
  v.CreatorsTooLongError =
  v.DisabledError =
  v.AuthorizationTokenAccountOwnerMismatchError =
  v.PrintingMintAuthorizationAccountMismatchError =
  v.NotEnoughTokensError =
  v.TokenAccountMintMismatchV2Error =
  v.TokenAccountMintMismatchError =
  v.OneTimePrintingAuthMintMismatchError =
  v.PrintingMintMismatchError =
  v.DerivedKeyInvalidError =
  v.TokenAccountOneTimeAuthMintMismatchError =
  v.TokenBurnFailedError =
  v.EditionMintDecimalsShouldBeZeroError =
  v.OneTimePrintingAuthorizationMintDecimalsShouldBeZeroError =
  v.PrintingMintDecimalsShouldBeZeroError =
  v.EditionAlreadyMintedError =
  v.DestinationMintMismatchError =
  v.MasterRecordMismatchError =
  v.TokenMintToFailedError =
  v.MaxEditionsMintedAlreadyError =
  v.EditionsMustHaveExactlyOneTokenError =
  v.MintMismatchError =
  v.UpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError =
  v.UriTooLongError =
  v.SymbolTooLongError =
  v.NameTooLongError =
  v.InvalidMintAuthorityError =
  v.NotMintAuthorityError =
  v.UpdateAuthorityIsNotSignerError =
  v.UpdateAuthorityIncorrectError =
  v.InvalidEditionKeyError =
  v.InvalidMetadataKeyError =
  v.UninitializedError =
  v.AlreadyInitializedError =
  v.NotRentExemptError =
  v.InstructionPackErrorError =
  v.InstructionUnpackErrorError =
    void 0;
v.RevokeCollectionAuthoritySignerIncorrectError =
  v.InvalidUserError =
  v.EditionOverrideCannotBeZeroError =
  v.NotAllowedToChangeSellerFeeBasisPointsError =
  v.CannotWipeVerifiedCreatorsError =
  v.CannotRemoveVerifiedCreatorError =
  v.CannotAdjustVerifiedCreatorError =
  v.InvalidDelegateError =
  v.InvalidFreezeAuthorityError =
  v.InvalidCollectionAuthorityRecordError =
  v.InvalidUseAuthorityRecordError =
  v.CollectionAuthorityDoesNotExistError =
  v.CollectionAuthorityRecordAlreadyExistsError =
  v.NotEnoughUsesError =
  v.UnusableError =
  v.UseAuthorityRecordAlreadyRevokedError =
  v.UseAuthorityRecordAlreadyExistsError =
  v.CollectionMustBeAUniqueMasterEditionError =
  v.InvalidCollectionUpdateAuthorityError =
  v.CollectionNotFoundError =
  v.CannotChangeUsesAfterFirstUseError =
  v.CannotChangeUseMethodAfterFirstUseError =
  v.InvalidUseMethodError =
  v.MustBeBurnedError =
  v.RemovedError =
  v.CollectionCannotBeVerifiedInThisInstructionError =
  v.IsMutableCanOnlyBeFlippedToFalseError =
  v.ReservationArrayShouldBeSizeOneError =
  v.InvalidEditionIndexError =
  v.OneTimeAuthMintSupplyMustBeZeroForConversionError =
  v.PrintingMintSupplyMustBeZeroForConversionError =
  v.InvalidOwnerError =
  v.InvalidOperationError =
  v.TriedToReplaceAnExistingReservationError =
  v.ReservationNotCompleteError =
  v.BeyondAlottedAddressSizeError =
  v.DataTypeMismatchError =
  v.InvalidTokenProgramError =
  v.ReservationSpotsRemainingShouldMatchTotalSpotsAtStartError =
  v.DuplicateCreatorAddressError =
  v.DataIsImmutableError =
  v.PrintingWouldBreachMaximumSupplyError =
  v.IncorrectOwnerError =
  v.SpotMismatchError =
  v.CannotUnverifyAnotherCreatorError =
  v.CannotVerifyAnotherCreatorError =
  v.AddressNotInReservationError =
  v.ReservationBreachesMaximumSupplyError =
  v.NumericalOverflowErrorError =
  v.BeyondMaxAddressSizeError =
    void 0;
v.MissingSplTokenProgramError =
  v.MissingTokenAccountError =
  v.OnlySaleDelegateCanTransferError =
  v.InvalidSystemWalletError =
  v.FeatureNotSupportedError =
  v.MissingArgumentInBuilderError =
  v.MissingAccountInBuilderError =
  v.DelegateNotFoundError =
  v.DelegateAlreadyExistsError =
  v.InvalidProgrammableConfigError =
  v.MissingProgrammableConfigError =
  v.MissingAuthorizationRulesError =
  v.InvalidAuthorizationRulesError =
  v.InvalidMintForTokenStandardError =
  v.InvalidTokenStandardError =
  v.MintIsNotSignerError =
  v.EscrowParentHasDelegateError =
  v.InvalidBubblegumSignerError =
  v.InvalidCollectionSizeChangeError =
  v.NoFreezeAuthoritySetError =
  v.BorshSerializationErrorError =
  v.InsufficientTokensError =
  v.MustBeNonFungibleError =
  v.InvalidSystemProgramError =
  v.MustBeEscrowAuthorityError =
  v.InvalidEscrowBumpSeedError =
  v.MustUnverifyError =
  v.EditionNumberGreaterThanMaxSupplyError =
  v.PrintEditionDoesNotMatchMasterEditionError =
  v.ReservationListDeprecatedError =
  v.InvalidEditionMarkerError =
  v.InvalidPrintEditionError =
  v.InvalidMasterEditionError =
  v.NotAPrintEditionError =
  v.AlreadyUnverifiedError =
  v.AlreadyVerifiedError =
  v.CollectionMasterEditionAccountInvalidError =
  v.CannotUpdateVerifiedCollectionError =
  v.BorshDeserializationErrorError =
  v.MasterEditionHasPrintsError =
  v.NotAMasterEditionError =
  v.MissingEditionAccountError =
  v.CouldNotDetermineTokenStandardError =
  v.NotACollectionParentError =
  v.NotVerifiedMemberOfCollectionError =
  v.NotAMemberOfCollectionError =
  v.MissingCollectionMetadataError =
  v.SizedCollectionError =
  v.UnsizedCollectionError =
  v.TokenCloseFailedError =
    void 0;
v.errorFromName =
  v.errorFromCode =
  v.InvalidMetadataFlagsError =
  v.InvalidFeeAccountError =
  v.MissingDelegateRecordError =
  v.InvalidInstructionError =
  v.InvalidCloseAuthorityError =
  v.InvalidTokenRecordError =
  v.MissingCollectionMasterEditionError =
  v.MissingCollectionMintError =
  v.InsufficientTokenBalanceError =
  v.InvalidUpdateArgsError =
  v.InvalidParentAccountsError =
  v.InvalidInstructionsSysvarError =
  v.InvalidAssociatedTokenAccountProgramError =
  v.MissingEditionError =
  v.CannotBurnWithDelegateError =
  v.MissingEditionMarkerAccountError =
  v.MissingMasterEditionTokenAccountError =
  v.MissingMasterEditionMintAccountError =
  v.InvalidAmountError =
  v.CannotUpdateAssetWithDelegateError =
  v.DataIncrementLimitExceededError =
  v.InvalidLockedTransferAddressError =
  v.MissingLockedTransferAddressError =
  v.InvalidDelegateArgsError =
  v.AmountMustBeGreaterThanZeroError =
  v.MissingMasterEditionAccountError =
  v.MissingPrintSupplyError =
  v.InvalidDelegateRoleError =
  v.IncorrectTokenStateError =
  v.InvalidMasterEditionAccountLengthError =
  v.MissingTokenOwnerAccountError =
  v.DataIsEmptyOrZeroedError =
  v.MintSupplyMustBeZeroError =
  v.MissingTokenRecordError =
  v.InvalidAuthorityTypeError =
  v.MissingDelegateRoleError =
  v.UnlockedTokenError =
  v.LockedTokenError =
  v.KeyMismatchError =
  v.InstructionNotSupportedError =
  v.InvalidTransferAuthorityError =
  v.InvalidDelegateRoleForTransferError =
  v.MissingAuthorizationRulesProgramError =
    void 0;
const x = new Map(),
  B = new Map();
class Fc extends Error {
  constructor() {
    super('Failed to unpack instruction data'),
      (this.code = 0),
      (this.name = 'InstructionUnpackError'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Fc);
  }
}
v.InstructionUnpackErrorError = Fc;
x.set(0, () => new Fc());
B.set('InstructionUnpackError', () => new Fc());
class $c extends Error {
  constructor() {
    super('Failed to pack instruction data'),
      (this.code = 1),
      (this.name = 'InstructionPackError'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, $c);
  }
}
v.InstructionPackErrorError = $c;
x.set(1, () => new $c());
B.set('InstructionPackError', () => new $c());
class Wc extends Error {
  constructor() {
    super('Lamport balance below rent-exempt threshold'),
      (this.code = 2),
      (this.name = 'NotRentExempt'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Wc);
  }
}
v.NotRentExemptError = Wc;
x.set(2, () => new Wc());
B.set('NotRentExempt', () => new Wc());
class Vc extends Error {
  constructor() {
    super('Already initialized'),
      (this.code = 3),
      (this.name = 'AlreadyInitialized'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Vc);
  }
}
v.AlreadyInitializedError = Vc;
x.set(3, () => new Vc());
B.set('AlreadyInitialized', () => new Vc());
class Kc extends Error {
  constructor() {
    super('Uninitialized'),
      (this.code = 4),
      (this.name = 'Uninitialized'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Kc);
  }
}
v.UninitializedError = Kc;
x.set(4, () => new Kc());
B.set('Uninitialized', () => new Kc());
class Hc extends Error {
  constructor() {
    super(" Metadata's key must match seed of ['metadata', program id, mint] provided"),
      (this.code = 5),
      (this.name = 'InvalidMetadataKey'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Hc);
  }
}
v.InvalidMetadataKeyError = Hc;
x.set(5, () => new Hc());
B.set('InvalidMetadataKey', () => new Hc());
class qc extends Error {
  constructor() {
    super("Edition's key must match seed of ['metadata', program id, name, 'edition'] provided"),
      (this.code = 6),
      (this.name = 'InvalidEditionKey'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, qc);
  }
}
v.InvalidEditionKeyError = qc;
x.set(6, () => new qc());
B.set('InvalidEditionKey', () => new qc());
class Gc extends Error {
  constructor() {
    super('Update Authority given does not match'),
      (this.code = 7),
      (this.name = 'UpdateAuthorityIncorrect'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Gc);
  }
}
v.UpdateAuthorityIncorrectError = Gc;
x.set(7, () => new Gc());
B.set('UpdateAuthorityIncorrect', () => new Gc());
class Yc extends Error {
  constructor() {
    super('Update Authority needs to be signer to update metadata'),
      (this.code = 8),
      (this.name = 'UpdateAuthorityIsNotSigner'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Yc);
  }
}
v.UpdateAuthorityIsNotSignerError = Yc;
x.set(8, () => new Yc());
B.set('UpdateAuthorityIsNotSigner', () => new Yc());
class Zc extends Error {
  constructor() {
    super('You must be the mint authority and signer on this transaction'),
      (this.code = 9),
      (this.name = 'NotMintAuthority'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Zc);
  }
}
v.NotMintAuthorityError = Zc;
x.set(9, () => new Zc());
B.set('NotMintAuthority', () => new Zc());
class Qc extends Error {
  constructor() {
    super('Mint authority provided does not match the authority on the mint'),
      (this.code = 10),
      (this.name = 'InvalidMintAuthority'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Qc);
  }
}
v.InvalidMintAuthorityError = Qc;
x.set(10, () => new Qc());
B.set('InvalidMintAuthority', () => new Qc());
class Jc extends Error {
  constructor() {
    super('Name too long'),
      (this.code = 11),
      (this.name = 'NameTooLong'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Jc);
  }
}
v.NameTooLongError = Jc;
x.set(11, () => new Jc());
B.set('NameTooLong', () => new Jc());
class Xc extends Error {
  constructor() {
    super('Symbol too long'),
      (this.code = 12),
      (this.name = 'SymbolTooLong'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Xc);
  }
}
v.SymbolTooLongError = Xc;
x.set(12, () => new Xc());
B.set('SymbolTooLong', () => new Xc());
class eu extends Error {
  constructor() {
    super('URI too long'),
      (this.code = 13),
      (this.name = 'UriTooLong'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, eu);
  }
}
v.UriTooLongError = eu;
x.set(13, () => new eu());
B.set('UriTooLong', () => new eu());
class tu extends Error {
  constructor() {
    super(
      "Update authority must be equivalent to the metadata's authority and also signer of this transaction"
    ),
      (this.code = 14),
      (this.name = 'UpdateAuthorityMustBeEqualToMetadataAuthorityAndSigner'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, tu);
  }
}
v.UpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError = tu;
x.set(14, () => new tu());
B.set('UpdateAuthorityMustBeEqualToMetadataAuthorityAndSigner', () => new tu());
class nu extends Error {
  constructor() {
    super('Mint given does not match mint on Metadata'),
      (this.code = 15),
      (this.name = 'MintMismatch'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, nu);
  }
}
v.MintMismatchError = nu;
x.set(15, () => new nu());
B.set('MintMismatch', () => new nu());
class ru extends Error {
  constructor() {
    super('Editions must have exactly one token'),
      (this.code = 16),
      (this.name = 'EditionsMustHaveExactlyOneToken'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, ru);
  }
}
v.EditionsMustHaveExactlyOneTokenError = ru;
x.set(16, () => new ru());
B.set('EditionsMustHaveExactlyOneToken', () => new ru());
class iu extends Error {
  constructor() {
    super('Maximum editions printed already'),
      (this.code = 17),
      (this.name = 'MaxEditionsMintedAlready'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, iu);
  }
}
v.MaxEditionsMintedAlreadyError = iu;
x.set(17, () => new iu());
B.set('MaxEditionsMintedAlready', () => new iu());
class ou extends Error {
  constructor() {
    super('Token mint to failed'),
      (this.code = 18),
      (this.name = 'TokenMintToFailed'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, ou);
  }
}
v.TokenMintToFailedError = ou;
x.set(18, () => new ou());
B.set('TokenMintToFailed', () => new ou());
class au extends Error {
  constructor() {
    super('The master edition record passed must match the master record on the edition given'),
      (this.code = 19),
      (this.name = 'MasterRecordMismatch'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, au);
  }
}
v.MasterRecordMismatchError = au;
x.set(19, () => new au());
B.set('MasterRecordMismatch', () => new au());
class su extends Error {
  constructor() {
    super('The destination account does not have the right mint'),
      (this.code = 20),
      (this.name = 'DestinationMintMismatch'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, su);
  }
}
v.DestinationMintMismatchError = su;
x.set(20, () => new su());
B.set('DestinationMintMismatch', () => new su());
class cu extends Error {
  constructor() {
    super('An edition can only mint one of its kind!'),
      (this.code = 21),
      (this.name = 'EditionAlreadyMinted'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, cu);
  }
}
v.EditionAlreadyMintedError = cu;
x.set(21, () => new cu());
B.set('EditionAlreadyMinted', () => new cu());
class uu extends Error {
  constructor() {
    super('Printing mint decimals should be zero'),
      (this.code = 22),
      (this.name = 'PrintingMintDecimalsShouldBeZero'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, uu);
  }
}
v.PrintingMintDecimalsShouldBeZeroError = uu;
x.set(22, () => new uu());
B.set('PrintingMintDecimalsShouldBeZero', () => new uu());
class lu extends Error {
  constructor() {
    super('OneTimePrintingAuthorization mint decimals should be zero'),
      (this.code = 23),
      (this.name = 'OneTimePrintingAuthorizationMintDecimalsShouldBeZero'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, lu);
  }
}
v.OneTimePrintingAuthorizationMintDecimalsShouldBeZeroError = lu;
x.set(23, () => new lu());
B.set('OneTimePrintingAuthorizationMintDecimalsShouldBeZero', () => new lu());
class du extends Error {
  constructor() {
    super('EditionMintDecimalsShouldBeZero'),
      (this.code = 24),
      (this.name = 'EditionMintDecimalsShouldBeZero'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, du);
  }
}
v.EditionMintDecimalsShouldBeZeroError = du;
x.set(24, () => new du());
B.set('EditionMintDecimalsShouldBeZero', () => new du());
class fu extends Error {
  constructor() {
    super('Token burn failed'),
      (this.code = 25),
      (this.name = 'TokenBurnFailed'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, fu);
  }
}
v.TokenBurnFailedError = fu;
x.set(25, () => new fu());
B.set('TokenBurnFailed', () => new fu());
class hu extends Error {
  constructor() {
    super('The One Time authorization mint does not match that on the token account!'),
      (this.code = 26),
      (this.name = 'TokenAccountOneTimeAuthMintMismatch'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, hu);
  }
}
v.TokenAccountOneTimeAuthMintMismatchError = hu;
x.set(26, () => new hu());
B.set('TokenAccountOneTimeAuthMintMismatch', () => new hu());
class pu extends Error {
  constructor() {
    super('Derived key invalid'),
      (this.code = 27),
      (this.name = 'DerivedKeyInvalid'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, pu);
  }
}
v.DerivedKeyInvalidError = pu;
x.set(27, () => new pu());
B.set('DerivedKeyInvalid', () => new pu());
class gu extends Error {
  constructor() {
    super('The Printing mint does not match that on the master edition!'),
      (this.code = 28),
      (this.name = 'PrintingMintMismatch'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, gu);
  }
}
v.PrintingMintMismatchError = gu;
x.set(28, () => new gu());
B.set('PrintingMintMismatch', () => new gu());
class yu extends Error {
  constructor() {
    super('The One Time Printing Auth mint does not match that on the master edition!'),
      (this.code = 29),
      (this.name = 'OneTimePrintingAuthMintMismatch'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, yu);
  }
}
v.OneTimePrintingAuthMintMismatchError = yu;
x.set(29, () => new yu());
B.set('OneTimePrintingAuthMintMismatch', () => new yu());
class bu extends Error {
  constructor() {
    super('The mint of the token account does not match the Printing mint!'),
      (this.code = 30),
      (this.name = 'TokenAccountMintMismatch'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, bu);
  }
}
v.TokenAccountMintMismatchError = bu;
x.set(30, () => new bu());
B.set('TokenAccountMintMismatch', () => new bu());
class mu extends Error {
  constructor() {
    super('The mint of the token account does not match the master metadata mint!'),
      (this.code = 31),
      (this.name = 'TokenAccountMintMismatchV2'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, mu);
  }
}
v.TokenAccountMintMismatchV2Error = mu;
x.set(31, () => new mu());
B.set('TokenAccountMintMismatchV2', () => new mu());
class wu extends Error {
  constructor() {
    super('Not enough tokens to mint a limited edition'),
      (this.code = 32),
      (this.name = 'NotEnoughTokens'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, wu);
  }
}
v.NotEnoughTokensError = wu;
x.set(32, () => new wu());
B.set('NotEnoughTokens', () => new wu());
class _u extends Error {
  constructor() {
    super(
      'The mint on your authorization token holding account does not match your Printing mint!'
    ),
      (this.code = 33),
      (this.name = 'PrintingMintAuthorizationAccountMismatch'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, _u);
  }
}
v.PrintingMintAuthorizationAccountMismatchError = _u;
x.set(33, () => new _u());
B.set('PrintingMintAuthorizationAccountMismatch', () => new _u());
class vu extends Error {
  constructor() {
    super(
      'The authorization token account has a different owner than the update authority for the master edition!'
    ),
      (this.code = 34),
      (this.name = 'AuthorizationTokenAccountOwnerMismatch'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, vu);
  }
}
v.AuthorizationTokenAccountOwnerMismatchError = vu;
x.set(34, () => new vu());
B.set('AuthorizationTokenAccountOwnerMismatch', () => new vu());
class Su extends Error {
  constructor() {
    super('This feature is currently disabled.'),
      (this.code = 35),
      (this.name = 'Disabled'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Su);
  }
}
v.DisabledError = Su;
x.set(35, () => new Su());
B.set('Disabled', () => new Su());
class Au extends Error {
  constructor() {
    super('Creators list too long'),
      (this.code = 36),
      (this.name = 'CreatorsTooLong'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Au);
  }
}
v.CreatorsTooLongError = Au;
x.set(36, () => new Au());
B.set('CreatorsTooLong', () => new Au());
class Iu extends Error {
  constructor() {
    super('Creators must be at least one if set'),
      (this.code = 37),
      (this.name = 'CreatorsMustBeAtleastOne'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Iu);
  }
}
v.CreatorsMustBeAtleastOneError = Iu;
x.set(37, () => new Iu());
B.set('CreatorsMustBeAtleastOne', () => new Iu());
class Eu extends Error {
  constructor() {
    super('If using a creators array, you must be one of the creators listed'),
      (this.code = 38),
      (this.name = 'MustBeOneOfCreators'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Eu);
  }
}
v.MustBeOneOfCreatorsError = Eu;
x.set(38, () => new Eu());
B.set('MustBeOneOfCreators', () => new Eu());
class Tu extends Error {
  constructor() {
    super('This metadata does not have creators'),
      (this.code = 39),
      (this.name = 'NoCreatorsPresentOnMetadata'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Tu);
  }
}
v.NoCreatorsPresentOnMetadataError = Tu;
x.set(39, () => new Tu());
B.set('NoCreatorsPresentOnMetadata', () => new Tu());
class ku extends Error {
  constructor() {
    super('This creator address was not found'),
      (this.code = 40),
      (this.name = 'CreatorNotFound'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, ku);
  }
}
v.CreatorNotFoundError = ku;
x.set(40, () => new ku());
B.set('CreatorNotFound', () => new ku());
class Cu extends Error {
  constructor() {
    super('Basis points cannot be more than 10000'),
      (this.code = 41),
      (this.name = 'InvalidBasisPoints'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Cu);
  }
}
v.InvalidBasisPointsError = Cu;
x.set(41, () => new Cu());
B.set('InvalidBasisPoints', () => new Cu());
class Mu extends Error {
  constructor() {
    super('Primary sale can only be flipped to true and is immutable'),
      (this.code = 42),
      (this.name = 'PrimarySaleCanOnlyBeFlippedToTrue'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Mu);
  }
}
v.PrimarySaleCanOnlyBeFlippedToTrueError = Mu;
x.set(42, () => new Mu());
B.set('PrimarySaleCanOnlyBeFlippedToTrue', () => new Mu());
class Pu extends Error {
  constructor() {
    super('Owner does not match that on the account given'),
      (this.code = 43),
      (this.name = 'OwnerMismatch'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Pu);
  }
}
v.OwnerMismatchError = Pu;
x.set(43, () => new Pu());
B.set('OwnerMismatch', () => new Pu());
class Ou extends Error {
  constructor() {
    super('This account has no tokens to be used for authorization'),
      (this.code = 44),
      (this.name = 'NoBalanceInAccountForAuthorization'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Ou);
  }
}
v.NoBalanceInAccountForAuthorizationError = Ou;
x.set(44, () => new Ou());
B.set('NoBalanceInAccountForAuthorization', () => new Ou());
class Du extends Error {
  constructor() {
    super('Share total must equal 100 for creator array'),
      (this.code = 45),
      (this.name = 'ShareTotalMustBe100'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Du);
  }
}
v.ShareTotalMustBe100Error = Du;
x.set(45, () => new Du());
B.set('ShareTotalMustBe100', () => new Du());
class Ru extends Error {
  constructor() {
    super('This reservation list already exists!'),
      (this.code = 46),
      (this.name = 'ReservationExists'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Ru);
  }
}
v.ReservationExistsError = Ru;
x.set(46, () => new Ru());
B.set('ReservationExists', () => new Ru());
class xu extends Error {
  constructor() {
    super('This reservation list does not exist!'),
      (this.code = 47),
      (this.name = 'ReservationDoesNotExist'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, xu);
  }
}
v.ReservationDoesNotExistError = xu;
x.set(47, () => new xu());
B.set('ReservationDoesNotExist', () => new xu());
class Bu extends Error {
  constructor() {
    super('This reservation list exists but was never set with reservations'),
      (this.code = 48),
      (this.name = 'ReservationNotSet'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Bu);
  }
}
v.ReservationNotSetError = Bu;
x.set(48, () => new Bu());
B.set('ReservationNotSet', () => new Bu());
class ju extends Error {
  constructor() {
    super('This reservation list has already been set!'),
      (this.code = 49),
      (this.name = 'ReservationAlreadyMade'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, ju);
  }
}
v.ReservationAlreadyMadeError = ju;
x.set(49, () => new ju());
B.set('ReservationAlreadyMade', () => new ju());
class Nu extends Error {
  constructor() {
    super('Provided more addresses than max allowed in single reservation'),
      (this.code = 50),
      (this.name = 'BeyondMaxAddressSize'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Nu);
  }
}
v.BeyondMaxAddressSizeError = Nu;
x.set(50, () => new Nu());
B.set('BeyondMaxAddressSize', () => new Nu());
class Uu extends Error {
  constructor() {
    super('NumericalOverflowError'),
      (this.code = 51),
      (this.name = 'NumericalOverflowError'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Uu);
  }
}
v.NumericalOverflowErrorError = Uu;
x.set(51, () => new Uu());
B.set('NumericalOverflowError', () => new Uu());
class Lu extends Error {
  constructor() {
    super('This reservation would go beyond the maximum supply of the master edition!'),
      (this.code = 52),
      (this.name = 'ReservationBreachesMaximumSupply'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Lu);
  }
}
v.ReservationBreachesMaximumSupplyError = Lu;
x.set(52, () => new Lu());
B.set('ReservationBreachesMaximumSupply', () => new Lu());
class zu extends Error {
  constructor() {
    super('Address not in reservation!'),
      (this.code = 53),
      (this.name = 'AddressNotInReservation'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, zu);
  }
}
v.AddressNotInReservationError = zu;
x.set(53, () => new zu());
B.set('AddressNotInReservation', () => new zu());
class Fu extends Error {
  constructor() {
    super('You cannot unilaterally verify another creator, they must sign'),
      (this.code = 54),
      (this.name = 'CannotVerifyAnotherCreator'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Fu);
  }
}
v.CannotVerifyAnotherCreatorError = Fu;
x.set(54, () => new Fu());
B.set('CannotVerifyAnotherCreator', () => new Fu());
class $u extends Error {
  constructor() {
    super('You cannot unilaterally unverify another creator'),
      (this.code = 55),
      (this.name = 'CannotUnverifyAnotherCreator'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, $u);
  }
}
v.CannotUnverifyAnotherCreatorError = $u;
x.set(55, () => new $u());
B.set('CannotUnverifyAnotherCreator', () => new $u());
class Wu extends Error {
  constructor() {
    super('In initial reservation setting, spots remaining should equal total spots'),
      (this.code = 56),
      (this.name = 'SpotMismatch'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Wu);
  }
}
v.SpotMismatchError = Wu;
x.set(56, () => new Wu());
B.set('SpotMismatch', () => new Wu());
class Vu extends Error {
  constructor() {
    super('Incorrect account owner'),
      (this.code = 57),
      (this.name = 'IncorrectOwner'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Vu);
  }
}
v.IncorrectOwnerError = Vu;
x.set(57, () => new Vu());
B.set('IncorrectOwner', () => new Vu());
class Ku extends Error {
  constructor() {
    super('printing these tokens would breach the maximum supply limit of the master edition'),
      (this.code = 58),
      (this.name = 'PrintingWouldBreachMaximumSupply'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Ku);
  }
}
v.PrintingWouldBreachMaximumSupplyError = Ku;
x.set(58, () => new Ku());
B.set('PrintingWouldBreachMaximumSupply', () => new Ku());
class Hu extends Error {
  constructor() {
    super('Data is immutable'),
      (this.code = 59),
      (this.name = 'DataIsImmutable'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Hu);
  }
}
v.DataIsImmutableError = Hu;
x.set(59, () => new Hu());
B.set('DataIsImmutable', () => new Hu());
class qu extends Error {
  constructor() {
    super('No duplicate creator addresses'),
      (this.code = 60),
      (this.name = 'DuplicateCreatorAddress'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, qu);
  }
}
v.DuplicateCreatorAddressError = qu;
x.set(60, () => new qu());
B.set('DuplicateCreatorAddress', () => new qu());
class Gu extends Error {
  constructor() {
    super('Reservation spots remaining should match total spots when first being created'),
      (this.code = 61),
      (this.name = 'ReservationSpotsRemainingShouldMatchTotalSpotsAtStart'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Gu);
  }
}
v.ReservationSpotsRemainingShouldMatchTotalSpotsAtStartError = Gu;
x.set(61, () => new Gu());
B.set('ReservationSpotsRemainingShouldMatchTotalSpotsAtStart', () => new Gu());
class Yu extends Error {
  constructor() {
    super('Invalid token program'),
      (this.code = 62),
      (this.name = 'InvalidTokenProgram'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Yu);
  }
}
v.InvalidTokenProgramError = Yu;
x.set(62, () => new Yu());
B.set('InvalidTokenProgram', () => new Yu());
class Zu extends Error {
  constructor() {
    super('Data type mismatch'),
      (this.code = 63),
      (this.name = 'DataTypeMismatch'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Zu);
  }
}
v.DataTypeMismatchError = Zu;
x.set(63, () => new Zu());
B.set('DataTypeMismatch', () => new Zu());
class Qu extends Error {
  constructor() {
    super('Beyond alotted address size in reservation!'),
      (this.code = 64),
      (this.name = 'BeyondAlottedAddressSize'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Qu);
  }
}
v.BeyondAlottedAddressSizeError = Qu;
x.set(64, () => new Qu());
B.set('BeyondAlottedAddressSize', () => new Qu());
class Ju extends Error {
  constructor() {
    super('The reservation has only been partially alotted'),
      (this.code = 65),
      (this.name = 'ReservationNotComplete'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Ju);
  }
}
v.ReservationNotCompleteError = Ju;
x.set(65, () => new Ju());
B.set('ReservationNotComplete', () => new Ju());
class Xu extends Error {
  constructor() {
    super('You cannot splice over an existing reservation!'),
      (this.code = 66),
      (this.name = 'TriedToReplaceAnExistingReservation'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Xu);
  }
}
v.TriedToReplaceAnExistingReservationError = Xu;
x.set(66, () => new Xu());
B.set('TriedToReplaceAnExistingReservation', () => new Xu());
class el extends Error {
  constructor() {
    super('Invalid operation'),
      (this.code = 67),
      (this.name = 'InvalidOperation'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, el);
  }
}
v.InvalidOperationError = el;
x.set(67, () => new el());
B.set('InvalidOperation', () => new el());
class tl extends Error {
  constructor() {
    super('Invalid Owner'),
      (this.code = 68),
      (this.name = 'InvalidOwner'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, tl);
  }
}
v.InvalidOwnerError = tl;
x.set(68, () => new tl());
B.set('InvalidOwner', () => new tl());
class nl extends Error {
  constructor() {
    super('Printing mint supply must be zero for conversion'),
      (this.code = 69),
      (this.name = 'PrintingMintSupplyMustBeZeroForConversion'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, nl);
  }
}
v.PrintingMintSupplyMustBeZeroForConversionError = nl;
x.set(69, () => new nl());
B.set('PrintingMintSupplyMustBeZeroForConversion', () => new nl());
class rl extends Error {
  constructor() {
    super('One Time Auth mint supply must be zero for conversion'),
      (this.code = 70),
      (this.name = 'OneTimeAuthMintSupplyMustBeZeroForConversion'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, rl);
  }
}
v.OneTimeAuthMintSupplyMustBeZeroForConversionError = rl;
x.set(70, () => new rl());
B.set('OneTimeAuthMintSupplyMustBeZeroForConversion', () => new rl());
class il extends Error {
  constructor() {
    super('You tried to insert one edition too many into an edition mark pda'),
      (this.code = 71),
      (this.name = 'InvalidEditionIndex'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, il);
  }
}
v.InvalidEditionIndexError = il;
x.set(71, () => new il());
B.set('InvalidEditionIndex', () => new il());
class ol extends Error {
  constructor() {
    super('In the legacy system the reservation needs to be of size one for cpu limit reasons'),
      (this.code = 72),
      (this.name = 'ReservationArrayShouldBeSizeOne'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, ol);
  }
}
v.ReservationArrayShouldBeSizeOneError = ol;
x.set(72, () => new ol());
B.set('ReservationArrayShouldBeSizeOne', () => new ol());
class al extends Error {
  constructor() {
    super('Is Mutable can only be flipped to false'),
      (this.code = 73),
      (this.name = 'IsMutableCanOnlyBeFlippedToFalse'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, al);
  }
}
v.IsMutableCanOnlyBeFlippedToFalseError = al;
x.set(73, () => new al());
B.set('IsMutableCanOnlyBeFlippedToFalse', () => new al());
class sl extends Error {
  constructor() {
    super('Collection cannot be verified in this instruction'),
      (this.code = 74),
      (this.name = 'CollectionCannotBeVerifiedInThisInstruction'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, sl);
  }
}
v.CollectionCannotBeVerifiedInThisInstructionError = sl;
x.set(74, () => new sl());
B.set('CollectionCannotBeVerifiedInThisInstruction', () => new sl());
class cl extends Error {
  constructor() {
    super('This instruction was deprecated in a previous release and is now removed'),
      (this.code = 75),
      (this.name = 'Removed'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, cl);
  }
}
v.RemovedError = cl;
x.set(75, () => new cl());
B.set('Removed', () => new cl());
class ul extends Error {
  constructor() {
    super('This token use method is burn and there are no remaining uses, it must be burned'),
      (this.code = 76),
      (this.name = 'MustBeBurned'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, ul);
  }
}
v.MustBeBurnedError = ul;
x.set(76, () => new ul());
B.set('MustBeBurned', () => new ul());
class ll extends Error {
  constructor() {
    super('This use method is invalid'),
      (this.code = 77),
      (this.name = 'InvalidUseMethod'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, ll);
  }
}
v.InvalidUseMethodError = ll;
x.set(77, () => new ll());
B.set('InvalidUseMethod', () => new ll());
class dl extends Error {
  constructor() {
    super('Cannot Change Use Method after the first use'),
      (this.code = 78),
      (this.name = 'CannotChangeUseMethodAfterFirstUse'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, dl);
  }
}
v.CannotChangeUseMethodAfterFirstUseError = dl;
x.set(78, () => new dl());
B.set('CannotChangeUseMethodAfterFirstUse', () => new dl());
class fl extends Error {
  constructor() {
    super('Cannot Change Remaining or Available uses after the first use'),
      (this.code = 79),
      (this.name = 'CannotChangeUsesAfterFirstUse'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, fl);
  }
}
v.CannotChangeUsesAfterFirstUseError = fl;
x.set(79, () => new fl());
B.set('CannotChangeUsesAfterFirstUse', () => new fl());
class hl extends Error {
  constructor() {
    super('Collection Not Found on Metadata'),
      (this.code = 80),
      (this.name = 'CollectionNotFound'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, hl);
  }
}
v.CollectionNotFoundError = hl;
x.set(80, () => new hl());
B.set('CollectionNotFound', () => new hl());
class pl extends Error {
  constructor() {
    super('Collection Update Authority is invalid'),
      (this.code = 81),
      (this.name = 'InvalidCollectionUpdateAuthority'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, pl);
  }
}
v.InvalidCollectionUpdateAuthorityError = pl;
x.set(81, () => new pl());
B.set('InvalidCollectionUpdateAuthority', () => new pl());
class gl extends Error {
  constructor() {
    super('Collection Must Be a Unique Master Edition v2'),
      (this.code = 82),
      (this.name = 'CollectionMustBeAUniqueMasterEdition'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, gl);
  }
}
v.CollectionMustBeAUniqueMasterEditionError = gl;
x.set(82, () => new gl());
B.set('CollectionMustBeAUniqueMasterEdition', () => new gl());
class yl extends Error {
  constructor() {
    super('The Use Authority Record Already Exists, to modify it Revoke, then Approve'),
      (this.code = 83),
      (this.name = 'UseAuthorityRecordAlreadyExists'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, yl);
  }
}
v.UseAuthorityRecordAlreadyExistsError = yl;
x.set(83, () => new yl());
B.set('UseAuthorityRecordAlreadyExists', () => new yl());
class bl extends Error {
  constructor() {
    super('The Use Authority Record is empty or already revoked'),
      (this.code = 84),
      (this.name = 'UseAuthorityRecordAlreadyRevoked'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, bl);
  }
}
v.UseAuthorityRecordAlreadyRevokedError = bl;
x.set(84, () => new bl());
B.set('UseAuthorityRecordAlreadyRevoked', () => new bl());
class ml extends Error {
  constructor() {
    super('This token has no uses'),
      (this.code = 85),
      (this.name = 'Unusable'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, ml);
  }
}
v.UnusableError = ml;
x.set(85, () => new ml());
B.set('Unusable', () => new ml());
class wl extends Error {
  constructor() {
    super('There are not enough Uses left on this token.'),
      (this.code = 86),
      (this.name = 'NotEnoughUses'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, wl);
  }
}
v.NotEnoughUsesError = wl;
x.set(86, () => new wl());
B.set('NotEnoughUses', () => new wl());
class _l extends Error {
  constructor() {
    super('This Collection Authority Record Already Exists.'),
      (this.code = 87),
      (this.name = 'CollectionAuthorityRecordAlreadyExists'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, _l);
  }
}
v.CollectionAuthorityRecordAlreadyExistsError = _l;
x.set(87, () => new _l());
B.set('CollectionAuthorityRecordAlreadyExists', () => new _l());
class vl extends Error {
  constructor() {
    super('This Collection Authority Record Does Not Exist.'),
      (this.code = 88),
      (this.name = 'CollectionAuthorityDoesNotExist'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, vl);
  }
}
v.CollectionAuthorityDoesNotExistError = vl;
x.set(88, () => new vl());
B.set('CollectionAuthorityDoesNotExist', () => new vl());
class Sl extends Error {
  constructor() {
    super('This Use Authority Record is invalid.'),
      (this.code = 89),
      (this.name = 'InvalidUseAuthorityRecord'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Sl);
  }
}
v.InvalidUseAuthorityRecordError = Sl;
x.set(89, () => new Sl());
B.set('InvalidUseAuthorityRecord', () => new Sl());
class Al extends Error {
  constructor() {
    super('This Collection Authority Record is invalid.'),
      (this.code = 90),
      (this.name = 'InvalidCollectionAuthorityRecord'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Al);
  }
}
v.InvalidCollectionAuthorityRecordError = Al;
x.set(90, () => new Al());
B.set('InvalidCollectionAuthorityRecord', () => new Al());
class Il extends Error {
  constructor() {
    super('Metadata does not match the freeze authority on the mint'),
      (this.code = 91),
      (this.name = 'InvalidFreezeAuthority'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Il);
  }
}
v.InvalidFreezeAuthorityError = Il;
x.set(91, () => new Il());
B.set('InvalidFreezeAuthority', () => new Il());
class El extends Error {
  constructor() {
    super('All tokens in this account have not been delegated to this user.'),
      (this.code = 92),
      (this.name = 'InvalidDelegate'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, El);
  }
}
v.InvalidDelegateError = El;
x.set(92, () => new El());
B.set('InvalidDelegate', () => new El());
class Tl extends Error {
  constructor() {
    super('Creator can not be adjusted once they are verified.'),
      (this.code = 93),
      (this.name = 'CannotAdjustVerifiedCreator'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Tl);
  }
}
v.CannotAdjustVerifiedCreatorError = Tl;
x.set(93, () => new Tl());
B.set('CannotAdjustVerifiedCreator', () => new Tl());
class kl extends Error {
  constructor() {
    super('Verified creators cannot be removed.'),
      (this.code = 94),
      (this.name = 'CannotRemoveVerifiedCreator'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, kl);
  }
}
v.CannotRemoveVerifiedCreatorError = kl;
x.set(94, () => new kl());
B.set('CannotRemoveVerifiedCreator', () => new kl());
class Cl extends Error {
  constructor() {
    super('Can not wipe verified creators.'),
      (this.code = 95),
      (this.name = 'CannotWipeVerifiedCreators'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Cl);
  }
}
v.CannotWipeVerifiedCreatorsError = Cl;
x.set(95, () => new Cl());
B.set('CannotWipeVerifiedCreators', () => new Cl());
class Ml extends Error {
  constructor() {
    super('Not allowed to change seller fee basis points.'),
      (this.code = 96),
      (this.name = 'NotAllowedToChangeSellerFeeBasisPoints'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Ml);
  }
}
v.NotAllowedToChangeSellerFeeBasisPointsError = Ml;
x.set(96, () => new Ml());
B.set('NotAllowedToChangeSellerFeeBasisPoints', () => new Ml());
class Pl extends Error {
  constructor() {
    super('Edition override cannot be zero'),
      (this.code = 97),
      (this.name = 'EditionOverrideCannotBeZero'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Pl);
  }
}
v.EditionOverrideCannotBeZeroError = Pl;
x.set(97, () => new Pl());
B.set('EditionOverrideCannotBeZero', () => new Pl());
class Ol extends Error {
  constructor() {
    super('Invalid User'),
      (this.code = 98),
      (this.name = 'InvalidUser'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Ol);
  }
}
v.InvalidUserError = Ol;
x.set(98, () => new Ol());
B.set('InvalidUser', () => new Ol());
class Dl extends Error {
  constructor() {
    super('Revoke Collection Authority signer is incorrect'),
      (this.code = 99),
      (this.name = 'RevokeCollectionAuthoritySignerIncorrect'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Dl);
  }
}
v.RevokeCollectionAuthoritySignerIncorrectError = Dl;
x.set(99, () => new Dl());
B.set('RevokeCollectionAuthoritySignerIncorrect', () => new Dl());
class Rl extends Error {
  constructor() {
    super('Token close failed'),
      (this.code = 100),
      (this.name = 'TokenCloseFailed'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Rl);
  }
}
v.TokenCloseFailedError = Rl;
x.set(100, () => new Rl());
B.set('TokenCloseFailed', () => new Rl());
class xl extends Error {
  constructor() {
    super("Can't use this function on unsized collection"),
      (this.code = 101),
      (this.name = 'UnsizedCollection'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, xl);
  }
}
v.UnsizedCollectionError = xl;
x.set(101, () => new xl());
B.set('UnsizedCollection', () => new xl());
class Bl extends Error {
  constructor() {
    super("Can't use this function on a sized collection"),
      (this.code = 102),
      (this.name = 'SizedCollection'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Bl);
  }
}
v.SizedCollectionError = Bl;
x.set(102, () => new Bl());
B.set('SizedCollection', () => new Bl());
class jl extends Error {
  constructor() {
    super('Missing collection metadata account'),
      (this.code = 103),
      (this.name = 'MissingCollectionMetadata'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, jl);
  }
}
v.MissingCollectionMetadataError = jl;
x.set(103, () => new jl());
B.set('MissingCollectionMetadata', () => new jl());
class Nl extends Error {
  constructor() {
    super('This NFT is not a member of the specified collection.'),
      (this.code = 104),
      (this.name = 'NotAMemberOfCollection'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Nl);
  }
}
v.NotAMemberOfCollectionError = Nl;
x.set(104, () => new Nl());
B.set('NotAMemberOfCollection', () => new Nl());
class Ul extends Error {
  constructor() {
    super('This NFT is not a verified member of the specified collection.'),
      (this.code = 105),
      (this.name = 'NotVerifiedMemberOfCollection'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Ul);
  }
}
v.NotVerifiedMemberOfCollectionError = Ul;
x.set(105, () => new Ul());
B.set('NotVerifiedMemberOfCollection', () => new Ul());
class Ll extends Error {
  constructor() {
    super('This NFT is not a collection parent NFT.'),
      (this.code = 106),
      (this.name = 'NotACollectionParent'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Ll);
  }
}
v.NotACollectionParentError = Ll;
x.set(106, () => new Ll());
B.set('NotACollectionParent', () => new Ll());
class zl extends Error {
  constructor() {
    super('Could not determine a TokenStandard type.'),
      (this.code = 107),
      (this.name = 'CouldNotDetermineTokenStandard'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, zl);
  }
}
v.CouldNotDetermineTokenStandardError = zl;
x.set(107, () => new zl());
B.set('CouldNotDetermineTokenStandard', () => new zl());
class Fl extends Error {
  constructor() {
    super('This mint account has an edition but none was provided.'),
      (this.code = 108),
      (this.name = 'MissingEditionAccount'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Fl);
  }
}
v.MissingEditionAccountError = Fl;
x.set(108, () => new Fl());
B.set('MissingEditionAccount', () => new Fl());
class $l extends Error {
  constructor() {
    super('This edition is not a Master Edition'),
      (this.code = 109),
      (this.name = 'NotAMasterEdition'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, $l);
  }
}
v.NotAMasterEditionError = $l;
x.set(109, () => new $l());
B.set('NotAMasterEdition', () => new $l());
class Wl extends Error {
  constructor() {
    super('This Master Edition has existing prints'),
      (this.code = 110),
      (this.name = 'MasterEditionHasPrints'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Wl);
  }
}
v.MasterEditionHasPrintsError = Wl;
x.set(110, () => new Wl());
B.set('MasterEditionHasPrints', () => new Wl());
class Vl extends Error {
  constructor() {
    super('Borsh Deserialization Error'),
      (this.code = 111),
      (this.name = 'BorshDeserializationError'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Vl);
  }
}
v.BorshDeserializationErrorError = Vl;
x.set(111, () => new Vl());
B.set('BorshDeserializationError', () => new Vl());
class Kl extends Error {
  constructor() {
    super('Cannot update a verified collection in this command'),
      (this.code = 112),
      (this.name = 'CannotUpdateVerifiedCollection'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Kl);
  }
}
v.CannotUpdateVerifiedCollectionError = Kl;
x.set(112, () => new Kl());
B.set('CannotUpdateVerifiedCollection', () => new Kl());
class Hl extends Error {
  constructor() {
    super('Edition account doesnt match collection '),
      (this.code = 113),
      (this.name = 'CollectionMasterEditionAccountInvalid'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Hl);
  }
}
v.CollectionMasterEditionAccountInvalidError = Hl;
x.set(113, () => new Hl());
B.set('CollectionMasterEditionAccountInvalid', () => new Hl());
class ql extends Error {
  constructor() {
    super('Item is already verified.'),
      (this.code = 114),
      (this.name = 'AlreadyVerified'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, ql);
  }
}
v.AlreadyVerifiedError = ql;
x.set(114, () => new ql());
B.set('AlreadyVerified', () => new ql());
class Gl extends Error {
  constructor() {
    super('Item is already unverified.'),
      (this.code = 115),
      (this.name = 'AlreadyUnverified'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Gl);
  }
}
v.AlreadyUnverifiedError = Gl;
x.set(115, () => new Gl());
B.set('AlreadyUnverified', () => new Gl());
class Yl extends Error {
  constructor() {
    super('This edition is not a Print Edition'),
      (this.code = 116),
      (this.name = 'NotAPrintEdition'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Yl);
  }
}
v.NotAPrintEditionError = Yl;
x.set(116, () => new Yl());
B.set('NotAPrintEdition', () => new Yl());
class Zl extends Error {
  constructor() {
    super('Invalid Master Edition'),
      (this.code = 117),
      (this.name = 'InvalidMasterEdition'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Zl);
  }
}
v.InvalidMasterEditionError = Zl;
x.set(117, () => new Zl());
B.set('InvalidMasterEdition', () => new Zl());
class Ql extends Error {
  constructor() {
    super('Invalid Print Edition'),
      (this.code = 118),
      (this.name = 'InvalidPrintEdition'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Ql);
  }
}
v.InvalidPrintEditionError = Ql;
x.set(118, () => new Ql());
B.set('InvalidPrintEdition', () => new Ql());
class Jl extends Error {
  constructor() {
    super('Invalid Edition Marker'),
      (this.code = 119),
      (this.name = 'InvalidEditionMarker'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Jl);
  }
}
v.InvalidEditionMarkerError = Jl;
x.set(119, () => new Jl());
B.set('InvalidEditionMarker', () => new Jl());
class Xl extends Error {
  constructor() {
    super('Reservation List is Deprecated'),
      (this.code = 120),
      (this.name = 'ReservationListDeprecated'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Xl);
  }
}
v.ReservationListDeprecatedError = Xl;
x.set(120, () => new Xl());
B.set('ReservationListDeprecated', () => new Xl());
class ed extends Error {
  constructor() {
    super('Print Edition does not match Master Edition'),
      (this.code = 121),
      (this.name = 'PrintEditionDoesNotMatchMasterEdition'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, ed);
  }
}
v.PrintEditionDoesNotMatchMasterEditionError = ed;
x.set(121, () => new ed());
B.set('PrintEditionDoesNotMatchMasterEdition', () => new ed());
class td extends Error {
  constructor() {
    super('Edition Number greater than max supply'),
      (this.code = 122),
      (this.name = 'EditionNumberGreaterThanMaxSupply'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, td);
  }
}
v.EditionNumberGreaterThanMaxSupplyError = td;
x.set(122, () => new td());
B.set('EditionNumberGreaterThanMaxSupply', () => new td());
class nd extends Error {
  constructor() {
    super('Must unverify before migrating collections.'),
      (this.code = 123),
      (this.name = 'MustUnverify'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, nd);
  }
}
v.MustUnverifyError = nd;
x.set(123, () => new nd());
B.set('MustUnverify', () => new nd());
class rd extends Error {
  constructor() {
    super('Invalid Escrow Account Bump Seed'),
      (this.code = 124),
      (this.name = 'InvalidEscrowBumpSeed'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, rd);
  }
}
v.InvalidEscrowBumpSeedError = rd;
x.set(124, () => new rd());
B.set('InvalidEscrowBumpSeed', () => new rd());
class id extends Error {
  constructor() {
    super('Must Escrow Authority'),
      (this.code = 125),
      (this.name = 'MustBeEscrowAuthority'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, id);
  }
}
v.MustBeEscrowAuthorityError = id;
x.set(125, () => new id());
B.set('MustBeEscrowAuthority', () => new id());
class od extends Error {
  constructor() {
    super('Invalid System Program'),
      (this.code = 126),
      (this.name = 'InvalidSystemProgram'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, od);
  }
}
v.InvalidSystemProgramError = od;
x.set(126, () => new od());
B.set('InvalidSystemProgram', () => new od());
class ad extends Error {
  constructor() {
    super('Must be a Non Fungible Token'),
      (this.code = 127),
      (this.name = 'MustBeNonFungible'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, ad);
  }
}
v.MustBeNonFungibleError = ad;
x.set(127, () => new ad());
B.set('MustBeNonFungible', () => new ad());
class sd extends Error {
  constructor() {
    super('Insufficient tokens for transfer'),
      (this.code = 128),
      (this.name = 'InsufficientTokens'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, sd);
  }
}
v.InsufficientTokensError = sd;
x.set(128, () => new sd());
B.set('InsufficientTokens', () => new sd());
class cd extends Error {
  constructor() {
    super('Borsh Serialization Error'),
      (this.code = 129),
      (this.name = 'BorshSerializationError'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, cd);
  }
}
v.BorshSerializationErrorError = cd;
x.set(129, () => new cd());
B.set('BorshSerializationError', () => new cd());
class ud extends Error {
  constructor() {
    super('Cannot create NFT with no Freeze Authority.'),
      (this.code = 130),
      (this.name = 'NoFreezeAuthoritySet'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, ud);
  }
}
v.NoFreezeAuthoritySetError = ud;
x.set(130, () => new ud());
B.set('NoFreezeAuthoritySet', () => new ud());
class ld extends Error {
  constructor() {
    super('Invalid collection size change'),
      (this.code = 131),
      (this.name = 'InvalidCollectionSizeChange'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, ld);
  }
}
v.InvalidCollectionSizeChangeError = ld;
x.set(131, () => new ld());
B.set('InvalidCollectionSizeChange', () => new ld());
class dd extends Error {
  constructor() {
    super('Invalid bubblegum signer'),
      (this.code = 132),
      (this.name = 'InvalidBubblegumSigner'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, dd);
  }
}
v.InvalidBubblegumSignerError = dd;
x.set(132, () => new dd());
B.set('InvalidBubblegumSigner', () => new dd());
class fd extends Error {
  constructor() {
    super('Escrow parent cannot have a delegate'),
      (this.code = 133),
      (this.name = 'EscrowParentHasDelegate'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, fd);
  }
}
v.EscrowParentHasDelegateError = fd;
x.set(133, () => new fd());
B.set('EscrowParentHasDelegate', () => new fd());
class hd extends Error {
  constructor() {
    super('Mint needs to be signer to initialize the account'),
      (this.code = 134),
      (this.name = 'MintIsNotSigner'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, hd);
  }
}
v.MintIsNotSignerError = hd;
x.set(134, () => new hd());
B.set('MintIsNotSigner', () => new hd());
class pd extends Error {
  constructor() {
    super('Invalid token standard'),
      (this.code = 135),
      (this.name = 'InvalidTokenStandard'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, pd);
  }
}
v.InvalidTokenStandardError = pd;
x.set(135, () => new pd());
B.set('InvalidTokenStandard', () => new pd());
class gd extends Error {
  constructor() {
    super('Invalid mint account for specified token standard'),
      (this.code = 136),
      (this.name = 'InvalidMintForTokenStandard'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, gd);
  }
}
v.InvalidMintForTokenStandardError = gd;
x.set(136, () => new gd());
B.set('InvalidMintForTokenStandard', () => new gd());
class yd extends Error {
  constructor() {
    super('Invalid authorization rules account'),
      (this.code = 137),
      (this.name = 'InvalidAuthorizationRules'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, yd);
  }
}
v.InvalidAuthorizationRulesError = yd;
x.set(137, () => new yd());
B.set('InvalidAuthorizationRules', () => new yd());
class bd extends Error {
  constructor() {
    super('Missing authorization rules account'),
      (this.code = 138),
      (this.name = 'MissingAuthorizationRules'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, bd);
  }
}
v.MissingAuthorizationRulesError = bd;
x.set(138, () => new bd());
B.set('MissingAuthorizationRules', () => new bd());
class md extends Error {
  constructor() {
    super('Missing programmable configuration'),
      (this.code = 139),
      (this.name = 'MissingProgrammableConfig'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, md);
  }
}
v.MissingProgrammableConfigError = md;
x.set(139, () => new md());
B.set('MissingProgrammableConfig', () => new md());
class wd extends Error {
  constructor() {
    super('Invalid programmable configuration'),
      (this.code = 140),
      (this.name = 'InvalidProgrammableConfig'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, wd);
  }
}
v.InvalidProgrammableConfigError = wd;
x.set(140, () => new wd());
B.set('InvalidProgrammableConfig', () => new wd());
class _d extends Error {
  constructor() {
    super('Delegate already exists'),
      (this.code = 141),
      (this.name = 'DelegateAlreadyExists'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, _d);
  }
}
v.DelegateAlreadyExistsError = _d;
x.set(141, () => new _d());
B.set('DelegateAlreadyExists', () => new _d());
class vd extends Error {
  constructor() {
    super('Delegate not found'),
      (this.code = 142),
      (this.name = 'DelegateNotFound'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, vd);
  }
}
v.DelegateNotFoundError = vd;
x.set(142, () => new vd());
B.set('DelegateNotFound', () => new vd());
class Sd extends Error {
  constructor() {
    super('Required account not set in instruction builder'),
      (this.code = 143),
      (this.name = 'MissingAccountInBuilder'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Sd);
  }
}
v.MissingAccountInBuilderError = Sd;
x.set(143, () => new Sd());
B.set('MissingAccountInBuilder', () => new Sd());
class Ad extends Error {
  constructor() {
    super('Required argument not set in instruction builder'),
      (this.code = 144),
      (this.name = 'MissingArgumentInBuilder'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Ad);
  }
}
v.MissingArgumentInBuilderError = Ad;
x.set(144, () => new Ad());
B.set('MissingArgumentInBuilder', () => new Ad());
class Id extends Error {
  constructor() {
    super('Feature not supported currently'),
      (this.code = 145),
      (this.name = 'FeatureNotSupported'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Id);
  }
}
v.FeatureNotSupportedError = Id;
x.set(145, () => new Id());
B.set('FeatureNotSupported', () => new Id());
class Ed extends Error {
  constructor() {
    super('Invalid system wallet'),
      (this.code = 146),
      (this.name = 'InvalidSystemWallet'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Ed);
  }
}
v.InvalidSystemWalletError = Ed;
x.set(146, () => new Ed());
B.set('InvalidSystemWallet', () => new Ed());
class Td extends Error {
  constructor() {
    super('Only the sale delegate can transfer while its set'),
      (this.code = 147),
      (this.name = 'OnlySaleDelegateCanTransfer'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Td);
  }
}
v.OnlySaleDelegateCanTransferError = Td;
x.set(147, () => new Td());
B.set('OnlySaleDelegateCanTransfer', () => new Td());
class kd extends Error {
  constructor() {
    super('Missing token account'),
      (this.code = 148),
      (this.name = 'MissingTokenAccount'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, kd);
  }
}
v.MissingTokenAccountError = kd;
x.set(148, () => new kd());
B.set('MissingTokenAccount', () => new kd());
class Cd extends Error {
  constructor() {
    super('Missing SPL token program'),
      (this.code = 149),
      (this.name = 'MissingSplTokenProgram'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Cd);
  }
}
v.MissingSplTokenProgramError = Cd;
x.set(149, () => new Cd());
B.set('MissingSplTokenProgram', () => new Cd());
class Md extends Error {
  constructor() {
    super('Missing authorization rules program'),
      (this.code = 150),
      (this.name = 'MissingAuthorizationRulesProgram'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Md);
  }
}
v.MissingAuthorizationRulesProgramError = Md;
x.set(150, () => new Md());
B.set('MissingAuthorizationRulesProgram', () => new Md());
class Pd extends Error {
  constructor() {
    super('Invalid delegate role for transfer'),
      (this.code = 151),
      (this.name = 'InvalidDelegateRoleForTransfer'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Pd);
  }
}
v.InvalidDelegateRoleForTransferError = Pd;
x.set(151, () => new Pd());
B.set('InvalidDelegateRoleForTransfer', () => new Pd());
class Od extends Error {
  constructor() {
    super('Invalid transfer authority'),
      (this.code = 152),
      (this.name = 'InvalidTransferAuthority'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Od);
  }
}
v.InvalidTransferAuthorityError = Od;
x.set(152, () => new Od());
B.set('InvalidTransferAuthority', () => new Od());
class Dd extends Error {
  constructor() {
    super('Instruction not supported for ProgrammableNonFungible assets'),
      (this.code = 153),
      (this.name = 'InstructionNotSupported'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Dd);
  }
}
v.InstructionNotSupportedError = Dd;
x.set(153, () => new Dd());
B.set('InstructionNotSupported', () => new Dd());
class Rd extends Error {
  constructor() {
    super('Public key does not match expected value'),
      (this.code = 154),
      (this.name = 'KeyMismatch'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Rd);
  }
}
v.KeyMismatchError = Rd;
x.set(154, () => new Rd());
B.set('KeyMismatch', () => new Rd());
class xd extends Error {
  constructor() {
    super('Token is locked'),
      (this.code = 155),
      (this.name = 'LockedToken'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, xd);
  }
}
v.LockedTokenError = xd;
x.set(155, () => new xd());
B.set('LockedToken', () => new xd());
class Bd extends Error {
  constructor() {
    super('Token is unlocked'),
      (this.code = 156),
      (this.name = 'UnlockedToken'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Bd);
  }
}
v.UnlockedTokenError = Bd;
x.set(156, () => new Bd());
B.set('UnlockedToken', () => new Bd());
class jd extends Error {
  constructor() {
    super('Missing delegate role'),
      (this.code = 157),
      (this.name = 'MissingDelegateRole'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, jd);
  }
}
v.MissingDelegateRoleError = jd;
x.set(157, () => new jd());
B.set('MissingDelegateRole', () => new jd());
class Nd extends Error {
  constructor() {
    super('Invalid authority type'),
      (this.code = 158),
      (this.name = 'InvalidAuthorityType'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Nd);
  }
}
v.InvalidAuthorityTypeError = Nd;
x.set(158, () => new Nd());
B.set('InvalidAuthorityType', () => new Nd());
class Ud extends Error {
  constructor() {
    super('Missing token record account'),
      (this.code = 159),
      (this.name = 'MissingTokenRecord'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Ud);
  }
}
v.MissingTokenRecordError = Ud;
x.set(159, () => new Ud());
B.set('MissingTokenRecord', () => new Ud());
class Ld extends Error {
  constructor() {
    super('Mint supply must be zero for programmable assets'),
      (this.code = 160),
      (this.name = 'MintSupplyMustBeZero'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Ld);
  }
}
v.MintSupplyMustBeZeroError = Ld;
x.set(160, () => new Ld());
B.set('MintSupplyMustBeZero', () => new Ld());
class zd extends Error {
  constructor() {
    super('Data is empty or zeroed'),
      (this.code = 161),
      (this.name = 'DataIsEmptyOrZeroed'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, zd);
  }
}
v.DataIsEmptyOrZeroedError = zd;
x.set(161, () => new zd());
B.set('DataIsEmptyOrZeroed', () => new zd());
class Fd extends Error {
  constructor() {
    super('Missing token owner'),
      (this.code = 162),
      (this.name = 'MissingTokenOwnerAccount'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Fd);
  }
}
v.MissingTokenOwnerAccountError = Fd;
x.set(162, () => new Fd());
B.set('MissingTokenOwnerAccount', () => new Fd());
class $d extends Error {
  constructor() {
    super('Master edition account has an invalid length'),
      (this.code = 163),
      (this.name = 'InvalidMasterEditionAccountLength'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, $d);
  }
}
v.InvalidMasterEditionAccountLengthError = $d;
x.set(163, () => new $d());
B.set('InvalidMasterEditionAccountLength', () => new $d());
class Wd extends Error {
  constructor() {
    super('Incorrect token state'),
      (this.code = 164),
      (this.name = 'IncorrectTokenState'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Wd);
  }
}
v.IncorrectTokenStateError = Wd;
x.set(164, () => new Wd());
B.set('IncorrectTokenState', () => new Wd());
class Vd extends Error {
  constructor() {
    super('Invalid delegate role'),
      (this.code = 165),
      (this.name = 'InvalidDelegateRole'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Vd);
  }
}
v.InvalidDelegateRoleError = Vd;
x.set(165, () => new Vd());
B.set('InvalidDelegateRole', () => new Vd());
class Kd extends Error {
  constructor() {
    super('Print supply is required for non-fungibles'),
      (this.code = 166),
      (this.name = 'MissingPrintSupply'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Kd);
  }
}
v.MissingPrintSupplyError = Kd;
x.set(166, () => new Kd());
B.set('MissingPrintSupply', () => new Kd());
class Hd extends Error {
  constructor() {
    super('Missing master edition account'),
      (this.code = 167),
      (this.name = 'MissingMasterEditionAccount'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Hd);
  }
}
v.MissingMasterEditionAccountError = Hd;
x.set(167, () => new Hd());
B.set('MissingMasterEditionAccount', () => new Hd());
class qd extends Error {
  constructor() {
    super('Amount must be greater than zero'),
      (this.code = 168),
      (this.name = 'AmountMustBeGreaterThanZero'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, qd);
  }
}
v.AmountMustBeGreaterThanZeroError = qd;
x.set(168, () => new qd());
B.set('AmountMustBeGreaterThanZero', () => new qd());
class Gd extends Error {
  constructor() {
    super('Invalid delegate args'),
      (this.code = 169),
      (this.name = 'InvalidDelegateArgs'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Gd);
  }
}
v.InvalidDelegateArgsError = Gd;
x.set(169, () => new Gd());
B.set('InvalidDelegateArgs', () => new Gd());
class Yd extends Error {
  constructor() {
    super('Missing address for locked transfer'),
      (this.code = 170),
      (this.name = 'MissingLockedTransferAddress'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Yd);
  }
}
v.MissingLockedTransferAddressError = Yd;
x.set(170, () => new Yd());
B.set('MissingLockedTransferAddress', () => new Yd());
class Zd extends Error {
  constructor() {
    super('Invalid destination address for locked transfer'),
      (this.code = 171),
      (this.name = 'InvalidLockedTransferAddress'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Zd);
  }
}
v.InvalidLockedTransferAddressError = Zd;
x.set(171, () => new Zd());
B.set('InvalidLockedTransferAddress', () => new Zd());
class Qd extends Error {
  constructor() {
    super('Exceeded account realloc increase limit'),
      (this.code = 172),
      (this.name = 'DataIncrementLimitExceeded'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Qd);
  }
}
v.DataIncrementLimitExceededError = Qd;
x.set(172, () => new Qd());
B.set('DataIncrementLimitExceeded', () => new Qd());
class Jd extends Error {
  constructor() {
    super('Cannot update the rule set of a programmable asset that has a delegate'),
      (this.code = 173),
      (this.name = 'CannotUpdateAssetWithDelegate'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Jd);
  }
}
v.CannotUpdateAssetWithDelegateError = Jd;
x.set(173, () => new Jd());
B.set('CannotUpdateAssetWithDelegate', () => new Jd());
class Xd extends Error {
  constructor() {
    super('Invalid token amount for this operation or token standard'),
      (this.code = 174),
      (this.name = 'InvalidAmount'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Xd);
  }
}
v.InvalidAmountError = Xd;
x.set(174, () => new Xd());
B.set('InvalidAmount', () => new Xd());
class ef extends Error {
  constructor() {
    super('Missing master edition mint account'),
      (this.code = 175),
      (this.name = 'MissingMasterEditionMintAccount'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, ef);
  }
}
v.MissingMasterEditionMintAccountError = ef;
x.set(175, () => new ef());
B.set('MissingMasterEditionMintAccount', () => new ef());
class tf extends Error {
  constructor() {
    super('Missing master edition token account'),
      (this.code = 176),
      (this.name = 'MissingMasterEditionTokenAccount'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, tf);
  }
}
v.MissingMasterEditionTokenAccountError = tf;
x.set(176, () => new tf());
B.set('MissingMasterEditionTokenAccount', () => new tf());
class nf extends Error {
  constructor() {
    super('Missing edition marker account'),
      (this.code = 177),
      (this.name = 'MissingEditionMarkerAccount'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, nf);
  }
}
v.MissingEditionMarkerAccountError = nf;
x.set(177, () => new nf());
B.set('MissingEditionMarkerAccount', () => new nf());
class rf extends Error {
  constructor() {
    super('Cannot burn while persistent delegate is set'),
      (this.code = 178),
      (this.name = 'CannotBurnWithDelegate'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, rf);
  }
}
v.CannotBurnWithDelegateError = rf;
x.set(178, () => new rf());
B.set('CannotBurnWithDelegate', () => new rf());
class of extends Error {
  constructor() {
    super('Missing edition account'),
      (this.code = 179),
      (this.name = 'MissingEdition'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, of);
  }
}
v.MissingEditionError = of;
x.set(179, () => new of());
B.set('MissingEdition', () => new of());
class af extends Error {
  constructor() {
    super('Invalid Associated Token Account Program'),
      (this.code = 180),
      (this.name = 'InvalidAssociatedTokenAccountProgram'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, af);
  }
}
v.InvalidAssociatedTokenAccountProgramError = af;
x.set(180, () => new af());
B.set('InvalidAssociatedTokenAccountProgram', () => new af());
class sf extends Error {
  constructor() {
    super('Invalid InstructionsSysvar'),
      (this.code = 181),
      (this.name = 'InvalidInstructionsSysvar'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, sf);
  }
}
v.InvalidInstructionsSysvarError = sf;
x.set(181, () => new sf());
B.set('InvalidInstructionsSysvar', () => new sf());
class cf extends Error {
  constructor() {
    super('Invalid or Unneeded parent accounts'),
      (this.code = 182),
      (this.name = 'InvalidParentAccounts'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, cf);
  }
}
v.InvalidParentAccountsError = cf;
x.set(182, () => new cf());
B.set('InvalidParentAccounts', () => new cf());
class uf extends Error {
  constructor() {
    super('Authority cannot apply all update args'),
      (this.code = 183),
      (this.name = 'InvalidUpdateArgs'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, uf);
  }
}
v.InvalidUpdateArgsError = uf;
x.set(183, () => new uf());
B.set('InvalidUpdateArgs', () => new uf());
class lf extends Error {
  constructor() {
    super('Token account does not have enough tokens'),
      (this.code = 184),
      (this.name = 'InsufficientTokenBalance'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, lf);
  }
}
v.InsufficientTokenBalanceError = lf;
x.set(184, () => new lf());
B.set('InsufficientTokenBalance', () => new lf());
class df extends Error {
  constructor() {
    super('Missing collection account'),
      (this.code = 185),
      (this.name = 'MissingCollectionMint'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, df);
  }
}
v.MissingCollectionMintError = df;
x.set(185, () => new df());
B.set('MissingCollectionMint', () => new df());
class ff extends Error {
  constructor() {
    super('Missing collection master edition account'),
      (this.code = 186),
      (this.name = 'MissingCollectionMasterEdition'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, ff);
  }
}
v.MissingCollectionMasterEditionError = ff;
x.set(186, () => new ff());
B.set('MissingCollectionMasterEdition', () => new ff());
class hf extends Error {
  constructor() {
    super('Invalid token record account'),
      (this.code = 187),
      (this.name = 'InvalidTokenRecord'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, hf);
  }
}
v.InvalidTokenRecordError = hf;
x.set(187, () => new hf());
B.set('InvalidTokenRecord', () => new hf());
class pf extends Error {
  constructor() {
    super('The close authority needs to be revoked by the Utility Delegate'),
      (this.code = 188),
      (this.name = 'InvalidCloseAuthority'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, pf);
  }
}
v.InvalidCloseAuthorityError = pf;
x.set(188, () => new pf());
B.set('InvalidCloseAuthority', () => new pf());
class gf extends Error {
  constructor() {
    super('Invalid or removed instruction'),
      (this.code = 189),
      (this.name = 'InvalidInstruction'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, gf);
  }
}
v.InvalidInstructionError = gf;
x.set(189, () => new gf());
B.set('InvalidInstruction', () => new gf());
class yf extends Error {
  constructor() {
    super('Missing delegate record'),
      (this.code = 190),
      (this.name = 'MissingDelegateRecord'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, yf);
  }
}
v.MissingDelegateRecordError = yf;
x.set(190, () => new yf());
B.set('MissingDelegateRecord', () => new yf());
class bf extends Error {
  constructor() {
    super(''),
      (this.code = 191),
      (this.name = 'InvalidFeeAccount'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, bf);
  }
}
v.InvalidFeeAccountError = bf;
x.set(191, () => new bf());
B.set('InvalidFeeAccount', () => new bf());
class mf extends Error {
  constructor() {
    super(''),
      (this.code = 192),
      (this.name = 'InvalidMetadataFlags'),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, mf);
  }
}
v.InvalidMetadataFlagsError = mf;
x.set(192, () => new mf());
B.set('InvalidMetadataFlags', () => new mf());
function JL(e) {
  const t = x.get(e);
  return t != null ? t() : null;
}
v.errorFromCode = JL;
function XL(e) {
  const t = B.get(e);
  return t != null ? t() : null;
}
v.errorFromName = XL;
var gk = {},
  yk = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (c, s, l, u) {
            u === void 0 && (u = l);
            var d = Object.getOwnPropertyDescriptor(s, l);
            (!d || ('get' in d ? !s.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return s[l];
                },
              }),
              Object.defineProperty(c, u, d);
          }
        : function (c, s, l, u) {
            u === void 0 && (u = l), (c[u] = s[l]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (c, s) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: s });
          }
        : function (c, s) {
            c.default = s;
          }),
    r =
      (g && g.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var s = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(s, c, l);
        return n(s, c), s;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createApproveCollectionAuthorityInstruction =
      e.approveCollectionAuthorityInstructionDiscriminator =
      e.ApproveCollectionAuthorityStruct =
        void 0);
  const i = r(W),
    o = r(V);
  (e.ApproveCollectionAuthorityStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'ApproveCollectionAuthorityInstructionArgs'
  )),
    (e.approveCollectionAuthorityInstructionDiscriminator = 23);
  function a(c, s = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var l;
    const [u] = e.ApproveCollectionAuthorityStruct.serialize({
        instructionDiscriminator: e.approveCollectionAuthorityInstructionDiscriminator,
      }),
      d = [
        { pubkey: c.collectionAuthorityRecord, isWritable: !0, isSigner: !1 },
        { pubkey: c.newCollectionAuthority, isWritable: !1, isSigner: !1 },
        { pubkey: c.updateAuthority, isWritable: !0, isSigner: !0 },
        { pubkey: c.payer, isWritable: !0, isSigner: !0 },
        { pubkey: c.metadata, isWritable: !1, isSigner: !1 },
        { pubkey: c.mint, isWritable: !1, isSigner: !1 },
        {
          pubkey: (l = c.systemProgram) !== null && l !== void 0 ? l : o.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return (
      c.rent != null && d.push({ pubkey: c.rent, isWritable: !1, isSigner: !1 }),
      new o.TransactionInstruction({ programId: s, keys: d, data: u })
    );
  }
  e.createApproveCollectionAuthorityInstruction = a;
})(yk);
var bk = {},
  In = {},
  mk = {},
  lg = {},
  ye = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.programSupportsExtensions =
      e.NATIVE_MINT_2022 =
      e.NATIVE_MINT =
      e.ASSOCIATED_TOKEN_PROGRAM_ID =
      e.TOKEN_2022_PROGRAM_ID =
      e.TOKEN_PROGRAM_ID =
        void 0);
  const t = V;
  (e.TOKEN_PROGRAM_ID = new t.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA')),
    (e.TOKEN_2022_PROGRAM_ID = new t.PublicKey('TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb')),
    (e.ASSOCIATED_TOKEN_PROGRAM_ID = new t.PublicKey(
      'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'
    )),
    (e.NATIVE_MINT = new t.PublicKey('So11111111111111111111111111111111111111112')),
    (e.NATIVE_MINT_2022 = new t.PublicKey('9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP'));
  function n(r) {
    return r !== e.TOKEN_PROGRAM_ID;
  }
  e.programSupportsExtensions = n;
})(ye);
var dg = {},
  be = {};
Object.defineProperty(be, '__esModule', { value: !0 });
be.TokenUnsupportedInstructionError =
  be.TokenInvalidInstructionTypeError =
  be.TokenInvalidInstructionDataError =
  be.TokenInvalidInstructionKeysError =
  be.TokenInvalidInstructionProgramError =
  be.TokenOwnerOffCurveError =
  be.TokenInvalidOwnerError =
  be.TokenInvalidMintError =
  be.TokenInvalidAccountSizeError =
  be.TokenInvalidAccountOwnerError =
  be.TokenInvalidAccountError =
  be.TokenAccountNotFoundError =
  be.TokenError =
    void 0;
let $n = class extends Error {
  constructor(t) {
    super(t);
  }
};
be.TokenError = $n;
class ez extends $n {
  constructor() {
    super(...arguments), (this.name = 'TokenAccountNotFoundError');
  }
}
be.TokenAccountNotFoundError = ez;
class tz extends $n {
  constructor() {
    super(...arguments), (this.name = 'TokenInvalidAccountError');
  }
}
be.TokenInvalidAccountError = tz;
class nz extends $n {
  constructor() {
    super(...arguments), (this.name = 'TokenInvalidAccountOwnerError');
  }
}
be.TokenInvalidAccountOwnerError = nz;
class rz extends $n {
  constructor() {
    super(...arguments), (this.name = 'TokenInvalidAccountSizeError');
  }
}
be.TokenInvalidAccountSizeError = rz;
class iz extends $n {
  constructor() {
    super(...arguments), (this.name = 'TokenInvalidMintError');
  }
}
be.TokenInvalidMintError = iz;
class oz extends $n {
  constructor() {
    super(...arguments), (this.name = 'TokenInvalidOwnerError');
  }
}
be.TokenInvalidOwnerError = oz;
class az extends $n {
  constructor() {
    super(...arguments), (this.name = 'TokenOwnerOffCurveError');
  }
}
be.TokenOwnerOffCurveError = az;
class sz extends $n {
  constructor() {
    super(...arguments), (this.name = 'TokenInvalidInstructionProgramError');
  }
}
be.TokenInvalidInstructionProgramError = sz;
class cz extends $n {
  constructor() {
    super(...arguments), (this.name = 'TokenInvalidInstructionKeysError');
  }
}
be.TokenInvalidInstructionKeysError = cz;
class uz extends $n {
  constructor() {
    super(...arguments), (this.name = 'TokenInvalidInstructionDataError');
  }
}
be.TokenInvalidInstructionDataError = uz;
class lz extends $n {
  constructor() {
    super(...arguments), (this.name = 'TokenInvalidInstructionTypeError');
  }
}
be.TokenInvalidInstructionTypeError = lz;
class dz extends $n {
  constructor() {
    super(...arguments), (this.name = 'TokenUnsupportedInstructionError');
  }
}
be.TokenUnsupportedInstructionError = dz;
var Ze = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.TokenInstruction = void 0),
    (function (t) {
      (t[(t.InitializeMint = 0)] = 'InitializeMint'),
        (t[(t.InitializeAccount = 1)] = 'InitializeAccount'),
        (t[(t.InitializeMultisig = 2)] = 'InitializeMultisig'),
        (t[(t.Transfer = 3)] = 'Transfer'),
        (t[(t.Approve = 4)] = 'Approve'),
        (t[(t.Revoke = 5)] = 'Revoke'),
        (t[(t.SetAuthority = 6)] = 'SetAuthority'),
        (t[(t.MintTo = 7)] = 'MintTo'),
        (t[(t.Burn = 8)] = 'Burn'),
        (t[(t.CloseAccount = 9)] = 'CloseAccount'),
        (t[(t.FreezeAccount = 10)] = 'FreezeAccount'),
        (t[(t.ThawAccount = 11)] = 'ThawAccount'),
        (t[(t.TransferChecked = 12)] = 'TransferChecked'),
        (t[(t.ApproveChecked = 13)] = 'ApproveChecked'),
        (t[(t.MintToChecked = 14)] = 'MintToChecked'),
        (t[(t.BurnChecked = 15)] = 'BurnChecked'),
        (t[(t.InitializeAccount2 = 16)] = 'InitializeAccount2'),
        (t[(t.SyncNative = 17)] = 'SyncNative'),
        (t[(t.InitializeAccount3 = 18)] = 'InitializeAccount3'),
        (t[(t.InitializeMultisig2 = 19)] = 'InitializeMultisig2'),
        (t[(t.InitializeMint2 = 20)] = 'InitializeMint2'),
        (t[(t.GetAccountDataSize = 21)] = 'GetAccountDataSize'),
        (t[(t.InitializeImmutableOwner = 22)] = 'InitializeImmutableOwner'),
        (t[(t.AmountToUiAmount = 23)] = 'AmountToUiAmount'),
        (t[(t.UiAmountToAmount = 24)] = 'UiAmountToAmount'),
        (t[(t.InitializeMintCloseAuthority = 25)] = 'InitializeMintCloseAuthority'),
        (t[(t.TransferFeeExtension = 26)] = 'TransferFeeExtension'),
        (t[(t.ConfidentialTransferExtension = 27)] = 'ConfidentialTransferExtension'),
        (t[(t.DefaultAccountStateExtension = 28)] = 'DefaultAccountStateExtension'),
        (t[(t.Reallocate = 29)] = 'Reallocate'),
        (t[(t.MemoTransferExtension = 30)] = 'MemoTransferExtension'),
        (t[(t.CreateNativeMint = 31)] = 'CreateNativeMint'),
        (t[(t.InitializeNonTransferableMint = 32)] = 'InitializeNonTransferableMint'),
        (t[(t.InterestBearingMintExtension = 33)] = 'InterestBearingMintExtension'),
        (t[(t.CpiGuardExtension = 34)] = 'CpiGuardExtension'),
        (t[(t.InitializePermanentDelegate = 35)] = 'InitializePermanentDelegate');
    })(e.TokenInstruction || (e.TokenInstruction = {}));
})(Ze);
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeAmountToUiAmountInstructionUnchecked =
      e.decodeAmountToUiAmountInstruction =
      e.createAmountToUiAmountInstruction =
      e.amountToUiAmountInstructionData =
        void 0);
  const t = xe,
    n = gt,
    r = V,
    i = ye,
    o = be,
    a = Ze;
  e.amountToUiAmountInstructionData = (0, t.struct)([
    (0, t.u8)('instruction'),
    (0, n.u64)('amount'),
  ]);
  function c(u, d, f = i.TOKEN_PROGRAM_ID) {
    const p = [{ pubkey: u, isSigner: !1, isWritable: !1 }],
      y = Y.alloc(e.amountToUiAmountInstructionData.span);
    return (
      e.amountToUiAmountInstructionData.encode(
        { instruction: a.TokenInstruction.AmountToUiAmount, amount: BigInt(d) },
        y
      ),
      new r.TransactionInstruction({ keys: p, programId: f, data: y })
    );
  }
  e.createAmountToUiAmountInstruction = c;
  function s(u, d = i.TOKEN_PROGRAM_ID) {
    if (!u.programId.equals(d)) throw new o.TokenInvalidInstructionProgramError();
    if (u.data.length !== e.amountToUiAmountInstructionData.span)
      throw new o.TokenInvalidInstructionDataError();
    const {
      keys: { mint: f },
      data: p,
    } = l(u);
    if (p.instruction !== a.TokenInstruction.AmountToUiAmount)
      throw new o.TokenInvalidInstructionTypeError();
    if (!f) throw new o.TokenInvalidInstructionKeysError();
    return { programId: d, keys: { mint: f }, data: p };
  }
  e.decodeAmountToUiAmountInstruction = s;
  function l({ programId: u, keys: [d], data: f }) {
    return { programId: u, keys: { mint: d }, data: e.amountToUiAmountInstructionData.decode(f) };
  }
  e.decodeAmountToUiAmountInstructionUnchecked = l;
})(dg);
var fz =
  (g && g.__awaiter) ||
  function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (a) {
            a(o);
          });
    }
    return new (n || (n = Promise))(function (o, a) {
      function c(u) {
        try {
          l(r.next(u));
        } catch (d) {
          a(d);
        }
      }
      function s(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          a(d);
        }
      }
      function l(u) {
        u.done ? o(u.value) : i(u.value).then(c, s);
      }
      l((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(lg, '__esModule', { value: !0 });
lg.amountToUiAmount = void 0;
const hz = V,
  pz = ye,
  gz = dg;
function yz(e, t, n, r, i = pz.TOKEN_PROGRAM_ID) {
  return fz(this, void 0, void 0, function* () {
    const o = new hz.Transaction().add((0, gz.createAmountToUiAmountInstruction)(n, r, i)),
      { returnData: a, err: c } = (yield e.simulateTransaction(o, [t], !1)).value;
    return a != null && a.data ? Y.from(a.data[0], a.data[1]).toString('utf-8') : c;
  });
}
lg.amountToUiAmount = yz;
var fg = {},
  hg = {},
  xt = {};
Object.defineProperty(xt, '__esModule', { value: !0 });
xt.addSigners = void 0;
const bz = V;
function mz(e, t, n) {
  if (n.length) {
    e.push({ pubkey: t, isSigner: !1, isWritable: !1 });
    for (const r of n)
      e.push({ pubkey: r instanceof bz.PublicKey ? r : r.publicKey, isSigner: !0, isWritable: !1 });
  } else e.push({ pubkey: t, isSigner: !0, isWritable: !1 });
  return e;
}
xt.addSigners = mz;
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeApproveInstructionUnchecked =
      e.decodeApproveInstruction =
      e.createApproveInstruction =
      e.approveInstructionData =
        void 0);
  const t = xe,
    n = gt,
    r = V,
    i = ye,
    o = be,
    a = xt,
    c = Ze;
  e.approveInstructionData = (0, t.struct)([(0, t.u8)('instruction'), (0, n.u64)('amount')]);
  function s(d, f, p, y, b = [], m = i.TOKEN_PROGRAM_ID) {
    const w = (0, a.addSigners)(
        [
          { pubkey: d, isSigner: !1, isWritable: !0 },
          { pubkey: f, isSigner: !1, isWritable: !1 },
        ],
        p,
        b
      ),
      _ = Y.alloc(e.approveInstructionData.span);
    return (
      e.approveInstructionData.encode(
        { instruction: c.TokenInstruction.Approve, amount: BigInt(y) },
        _
      ),
      new r.TransactionInstruction({ keys: w, programId: m, data: _ })
    );
  }
  e.createApproveInstruction = s;
  function l(d, f = i.TOKEN_PROGRAM_ID) {
    if (!d.programId.equals(f)) throw new o.TokenInvalidInstructionProgramError();
    if (d.data.length !== e.approveInstructionData.span)
      throw new o.TokenInvalidInstructionDataError();
    const {
      keys: { account: p, delegate: y, owner: b, multiSigners: m },
      data: w,
    } = u(d);
    if (w.instruction !== c.TokenInstruction.Approve)
      throw new o.TokenInvalidInstructionTypeError();
    if (!p || !y || !b) throw new o.TokenInvalidInstructionKeysError();
    return { programId: f, keys: { account: p, delegate: y, owner: b, multiSigners: m }, data: w };
  }
  e.decodeApproveInstruction = l;
  function u({ programId: d, keys: [f, p, y, ...b], data: m }) {
    return {
      programId: d,
      keys: { account: f, delegate: p, owner: y, multiSigners: b },
      data: e.approveInstructionData.decode(m),
    };
  }
  e.decodeApproveInstructionUnchecked = u;
})(hg);
var Bt = {};
Object.defineProperty(Bt, '__esModule', { value: !0 });
Bt.getSigners = void 0;
const wz = V;
function _z(e, t) {
  return e instanceof wz.PublicKey ? [e, t] : [e.publicKey, [e]];
}
Bt.getSigners = _z;
var vz =
  (g && g.__awaiter) ||
  function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (a) {
            a(o);
          });
    }
    return new (n || (n = Promise))(function (o, a) {
      function c(u) {
        try {
          l(r.next(u));
        } catch (d) {
          a(d);
        }
      }
      function s(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          a(d);
        }
      }
      function l(u) {
        u.done ? o(u.value) : i(u.value).then(c, s);
      }
      l((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(fg, '__esModule', { value: !0 });
fg.approve = void 0;
const ev = V,
  Sz = ye,
  Az = hg,
  Iz = Bt;
function Ez(e, t, n, r, i, o, a = [], c, s = Sz.TOKEN_PROGRAM_ID) {
  return vz(this, void 0, void 0, function* () {
    const [l, u] = (0, Iz.getSigners)(i, a),
      d = new ev.Transaction().add((0, Az.createApproveInstruction)(n, r, l, o, a, s));
    return yield (0, ev.sendAndConfirmTransaction)(e, d, [t, ...u], c);
  });
}
fg.approve = Ez;
var pg = {},
  gg = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeApproveCheckedInstructionUnchecked =
      e.decodeApproveCheckedInstruction =
      e.createApproveCheckedInstruction =
      e.approveCheckedInstructionData =
        void 0);
  const t = xe,
    n = gt,
    r = V,
    i = ye,
    o = be,
    a = xt,
    c = Ze;
  e.approveCheckedInstructionData = (0, t.struct)([
    (0, t.u8)('instruction'),
    (0, n.u64)('amount'),
    (0, t.u8)('decimals'),
  ]);
  function s(d, f, p, y, b, m, w = [], _ = i.TOKEN_PROGRAM_ID) {
    const S = (0, a.addSigners)(
        [
          { pubkey: d, isSigner: !1, isWritable: !0 },
          { pubkey: f, isSigner: !1, isWritable: !1 },
          { pubkey: p, isSigner: !1, isWritable: !1 },
        ],
        y,
        w
      ),
      E = Y.alloc(e.approveCheckedInstructionData.span);
    return (
      e.approveCheckedInstructionData.encode(
        { instruction: c.TokenInstruction.ApproveChecked, amount: BigInt(b), decimals: m },
        E
      ),
      new r.TransactionInstruction({ keys: S, programId: _, data: E })
    );
  }
  e.createApproveCheckedInstruction = s;
  function l(d, f = i.TOKEN_PROGRAM_ID) {
    if (!d.programId.equals(f)) throw new o.TokenInvalidInstructionProgramError();
    if (d.data.length !== e.approveCheckedInstructionData.span)
      throw new o.TokenInvalidInstructionDataError();
    const {
      keys: { account: p, mint: y, delegate: b, owner: m, multiSigners: w },
      data: _,
    } = u(d);
    if (_.instruction !== c.TokenInstruction.ApproveChecked)
      throw new o.TokenInvalidInstructionTypeError();
    if (!p || !y || !b || !m) throw new o.TokenInvalidInstructionKeysError();
    return {
      programId: f,
      keys: { account: p, mint: y, delegate: b, owner: m, multiSigners: w },
      data: _,
    };
  }
  e.decodeApproveCheckedInstruction = l;
  function u({ programId: d, keys: [f, p, y, b, ...m], data: w }) {
    return {
      programId: d,
      keys: { account: f, mint: p, delegate: y, owner: b, multiSigners: m },
      data: e.approveCheckedInstructionData.decode(w),
    };
  }
  e.decodeApproveCheckedInstructionUnchecked = u;
})(gg);
var Tz =
  (g && g.__awaiter) ||
  function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (a) {
            a(o);
          });
    }
    return new (n || (n = Promise))(function (o, a) {
      function c(u) {
        try {
          l(r.next(u));
        } catch (d) {
          a(d);
        }
      }
      function s(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          a(d);
        }
      }
      function l(u) {
        u.done ? o(u.value) : i(u.value).then(c, s);
      }
      l((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(pg, '__esModule', { value: !0 });
pg.approveChecked = void 0;
const tv = V,
  kz = ye,
  Cz = gg,
  Mz = Bt;
function Pz(e, t, n, r, i, o, a, c, s = [], l, u = kz.TOKEN_PROGRAM_ID) {
  return Tz(this, void 0, void 0, function* () {
    const [d, f] = (0, Mz.getSigners)(o, s),
      p = new tv.Transaction().add((0, Cz.createApproveCheckedInstruction)(r, n, i, d, a, c, s, u));
    return yield (0, tv.sendAndConfirmTransaction)(e, p, [t, ...f], l);
  });
}
pg.approveChecked = Pz;
var yg = {},
  bg = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeBurnInstructionUnchecked =
      e.decodeBurnInstruction =
      e.createBurnInstruction =
      e.burnInstructionData =
        void 0);
  const t = xe,
    n = gt,
    r = V,
    i = ye,
    o = be,
    a = xt,
    c = Ze;
  e.burnInstructionData = (0, t.struct)([(0, t.u8)('instruction'), (0, n.u64)('amount')]);
  function s(d, f, p, y, b = [], m = i.TOKEN_PROGRAM_ID) {
    const w = (0, a.addSigners)(
        [
          { pubkey: d, isSigner: !1, isWritable: !0 },
          { pubkey: f, isSigner: !1, isWritable: !0 },
        ],
        p,
        b
      ),
      _ = Y.alloc(e.burnInstructionData.span);
    return (
      e.burnInstructionData.encode({ instruction: c.TokenInstruction.Burn, amount: BigInt(y) }, _),
      new r.TransactionInstruction({ keys: w, programId: m, data: _ })
    );
  }
  e.createBurnInstruction = s;
  function l(d, f = i.TOKEN_PROGRAM_ID) {
    if (!d.programId.equals(f)) throw new o.TokenInvalidInstructionProgramError();
    if (d.data.length !== e.burnInstructionData.span)
      throw new o.TokenInvalidInstructionDataError();
    const {
      keys: { account: p, mint: y, owner: b, multiSigners: m },
      data: w,
    } = u(d);
    if (w.instruction !== c.TokenInstruction.Burn) throw new o.TokenInvalidInstructionTypeError();
    if (!p || !y || !b) throw new o.TokenInvalidInstructionKeysError();
    return { programId: f, keys: { account: p, mint: y, owner: b, multiSigners: m }, data: w };
  }
  e.decodeBurnInstruction = l;
  function u({ programId: d, keys: [f, p, y, ...b], data: m }) {
    return {
      programId: d,
      keys: { account: f, mint: p, owner: y, multiSigners: b },
      data: e.burnInstructionData.decode(m),
    };
  }
  e.decodeBurnInstructionUnchecked = u;
})(bg);
var Oz =
  (g && g.__awaiter) ||
  function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (a) {
            a(o);
          });
    }
    return new (n || (n = Promise))(function (o, a) {
      function c(u) {
        try {
          l(r.next(u));
        } catch (d) {
          a(d);
        }
      }
      function s(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          a(d);
        }
      }
      function l(u) {
        u.done ? o(u.value) : i(u.value).then(c, s);
      }
      l((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(yg, '__esModule', { value: !0 });
yg.burn = void 0;
const nv = V,
  Dz = ye,
  Rz = bg,
  xz = Bt;
function Bz(e, t, n, r, i, o, a = [], c, s = Dz.TOKEN_PROGRAM_ID) {
  return Oz(this, void 0, void 0, function* () {
    const [l, u] = (0, xz.getSigners)(i, a),
      d = new nv.Transaction().add((0, Rz.createBurnInstruction)(n, r, l, o, a, s));
    return yield (0, nv.sendAndConfirmTransaction)(e, d, [t, ...u], c);
  });
}
yg.burn = Bz;
var mg = {},
  wg = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeBurnCheckedInstructionUnchecked =
      e.decodeBurnCheckedInstruction =
      e.createBurnCheckedInstruction =
      e.burnCheckedInstructionData =
        void 0);
  const t = xe,
    n = gt,
    r = V,
    i = ye,
    o = be,
    a = xt,
    c = Ze;
  e.burnCheckedInstructionData = (0, t.struct)([
    (0, t.u8)('instruction'),
    (0, n.u64)('amount'),
    (0, t.u8)('decimals'),
  ]);
  function s(d, f, p, y, b, m = [], w = i.TOKEN_PROGRAM_ID) {
    const _ = (0, a.addSigners)(
        [
          { pubkey: d, isSigner: !1, isWritable: !0 },
          { pubkey: f, isSigner: !1, isWritable: !0 },
        ],
        p,
        m
      ),
      S = Y.alloc(e.burnCheckedInstructionData.span);
    return (
      e.burnCheckedInstructionData.encode(
        { instruction: c.TokenInstruction.BurnChecked, amount: BigInt(y), decimals: b },
        S
      ),
      new r.TransactionInstruction({ keys: _, programId: w, data: S })
    );
  }
  e.createBurnCheckedInstruction = s;
  function l(d, f = i.TOKEN_PROGRAM_ID) {
    if (!d.programId.equals(f)) throw new o.TokenInvalidInstructionProgramError();
    if (d.data.length !== e.burnCheckedInstructionData.span)
      throw new o.TokenInvalidInstructionDataError();
    const {
      keys: { account: p, mint: y, owner: b, multiSigners: m },
      data: w,
    } = u(d);
    if (w.instruction !== c.TokenInstruction.BurnChecked)
      throw new o.TokenInvalidInstructionTypeError();
    if (!p || !y || !b) throw new o.TokenInvalidInstructionKeysError();
    return { programId: f, keys: { account: p, mint: y, owner: b, multiSigners: m }, data: w };
  }
  e.decodeBurnCheckedInstruction = l;
  function u({ programId: d, keys: [f, p, y, ...b], data: m }) {
    return {
      programId: d,
      keys: { account: f, mint: p, owner: y, multiSigners: b },
      data: e.burnCheckedInstructionData.decode(m),
    };
  }
  e.decodeBurnCheckedInstructionUnchecked = u;
})(wg);
var jz =
  (g && g.__awaiter) ||
  function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (a) {
            a(o);
          });
    }
    return new (n || (n = Promise))(function (o, a) {
      function c(u) {
        try {
          l(r.next(u));
        } catch (d) {
          a(d);
        }
      }
      function s(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          a(d);
        }
      }
      function l(u) {
        u.done ? o(u.value) : i(u.value).then(c, s);
      }
      l((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(mg, '__esModule', { value: !0 });
mg.burnChecked = void 0;
const rv = V,
  Nz = ye,
  Uz = wg,
  Lz = Bt;
function zz(e, t, n, r, i, o, a, c = [], s, l = Nz.TOKEN_PROGRAM_ID) {
  return jz(this, void 0, void 0, function* () {
    const [u, d] = (0, Lz.getSigners)(i, c),
      f = new rv.Transaction().add((0, Uz.createBurnCheckedInstruction)(n, r, u, o, a, c, l));
    return yield (0, rv.sendAndConfirmTransaction)(e, f, [t, ...d], s);
  });
}
mg.burnChecked = zz;
var _g = {},
  vg = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeCloseAccountInstructionUnchecked =
      e.decodeCloseAccountInstruction =
      e.createCloseAccountInstruction =
      e.closeAccountInstructionData =
        void 0);
  const t = xe,
    n = V,
    r = ye,
    i = be,
    o = xt,
    a = Ze;
  e.closeAccountInstructionData = (0, t.struct)([(0, t.u8)('instruction')]);
  function c(u, d, f, p = [], y = r.TOKEN_PROGRAM_ID) {
    const b = (0, o.addSigners)(
        [
          { pubkey: u, isSigner: !1, isWritable: !0 },
          { pubkey: d, isSigner: !1, isWritable: !0 },
        ],
        f,
        p
      ),
      m = Y.alloc(e.closeAccountInstructionData.span);
    return (
      e.closeAccountInstructionData.encode({ instruction: a.TokenInstruction.CloseAccount }, m),
      new n.TransactionInstruction({ keys: b, programId: y, data: m })
    );
  }
  e.createCloseAccountInstruction = c;
  function s(u, d = r.TOKEN_PROGRAM_ID) {
    if (!u.programId.equals(d)) throw new i.TokenInvalidInstructionProgramError();
    if (u.data.length !== e.closeAccountInstructionData.span)
      throw new i.TokenInvalidInstructionDataError();
    const {
      keys: { account: f, destination: p, authority: y, multiSigners: b },
      data: m,
    } = l(u);
    if (m.instruction !== a.TokenInstruction.CloseAccount)
      throw new i.TokenInvalidInstructionTypeError();
    if (!f || !p || !y) throw new i.TokenInvalidInstructionKeysError();
    return {
      programId: d,
      keys: { account: f, destination: p, authority: y, multiSigners: b },
      data: m,
    };
  }
  e.decodeCloseAccountInstruction = s;
  function l({ programId: u, keys: [d, f, p, ...y], data: b }) {
    return {
      programId: u,
      keys: { account: d, destination: f, authority: p, multiSigners: y },
      data: e.closeAccountInstructionData.decode(b),
    };
  }
  e.decodeCloseAccountInstructionUnchecked = l;
})(vg);
var Fz =
  (g && g.__awaiter) ||
  function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (a) {
            a(o);
          });
    }
    return new (n || (n = Promise))(function (o, a) {
      function c(u) {
        try {
          l(r.next(u));
        } catch (d) {
          a(d);
        }
      }
      function s(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          a(d);
        }
      }
      function l(u) {
        u.done ? o(u.value) : i(u.value).then(c, s);
      }
      l((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(_g, '__esModule', { value: !0 });
_g.closeAccount = void 0;
const iv = V,
  $z = ye,
  Wz = vg,
  Vz = Bt;
function Kz(e, t, n, r, i, o = [], a, c = $z.TOKEN_PROGRAM_ID) {
  return Fz(this, void 0, void 0, function* () {
    const [s, l] = (0, Vz.getSigners)(i, o),
      u = new iv.Transaction().add((0, Wz.createCloseAccountInstruction)(n, r, s, o, c));
    return yield (0, iv.sendAndConfirmTransaction)(e, u, [t, ...l], a);
  });
}
_g.closeAccount = Kz;
var wf = {},
  hb = {},
  pb = {},
  _f = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.ACCOUNT_TYPE_SIZE = e.AccountType = void 0),
    (function (t) {
      (t[(t.Uninitialized = 0)] = 'Uninitialized'),
        (t[(t.Mint = 1)] = 'Mint'),
        (t[(t.Account = 2)] = 'Account');
    })(e.AccountType || (e.AccountType = {})),
    (e.ACCOUNT_TYPE_SIZE = 1);
})(_f);
var Ss = {};
(function (e) {
  var t =
    (g && g.__awaiter) ||
    function (l, u, d, f) {
      function p(y) {
        return y instanceof d
          ? y
          : new d(function (b) {
              b(y);
            });
      }
      return new (d || (d = Promise))(function (y, b) {
        function m(S) {
          try {
            _(f.next(S));
          } catch (E) {
            b(E);
          }
        }
        function w(S) {
          try {
            _(f.throw(S));
          } catch (E) {
            b(E);
          }
        }
        function _(S) {
          S.done ? y(S.value) : p(S.value).then(m, w);
        }
        _((f = f.apply(l, u || [])).next());
      });
    };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.getMinimumBalanceForRentExemptMultisig =
      e.unpackMultisig =
      e.getMultisig =
      e.MULTISIG_SIZE =
      e.MultisigLayout =
        void 0);
  const n = xe,
    r = gt,
    i = ye,
    o = be;
  (e.MultisigLayout = (0, n.struct)([
    (0, n.u8)('m'),
    (0, n.u8)('n'),
    (0, r.bool)('isInitialized'),
    (0, r.publicKey)('signer1'),
    (0, r.publicKey)('signer2'),
    (0, r.publicKey)('signer3'),
    (0, r.publicKey)('signer4'),
    (0, r.publicKey)('signer5'),
    (0, r.publicKey)('signer6'),
    (0, r.publicKey)('signer7'),
    (0, r.publicKey)('signer8'),
    (0, r.publicKey)('signer9'),
    (0, r.publicKey)('signer10'),
    (0, r.publicKey)('signer11'),
  ])),
    (e.MULTISIG_SIZE = e.MultisigLayout.span);
  function a(l, u, d, f = i.TOKEN_PROGRAM_ID) {
    return t(this, void 0, void 0, function* () {
      const p = yield l.getAccountInfo(u, d);
      return c(u, p, f);
    });
  }
  e.getMultisig = a;
  function c(l, u, d = i.TOKEN_PROGRAM_ID) {
    if (!u) throw new o.TokenAccountNotFoundError();
    if (!u.owner.equals(d)) throw new o.TokenInvalidAccountOwnerError();
    if (u.data.length != e.MULTISIG_SIZE) throw new o.TokenInvalidAccountSizeError();
    const f = e.MultisigLayout.decode(u.data);
    return Object.assign({ address: l }, f);
  }
  e.unpackMultisig = c;
  function s(l, u) {
    return t(this, void 0, void 0, function* () {
      return yield l.getMinimumBalanceForRentExemption(e.MULTISIG_SIZE, u);
    });
  }
  e.getMinimumBalanceForRentExemptMultisig = s;
})(Ss);
var ov;
function vf() {
  return (
    ov ||
      ((ov = 1),
      (function (e) {
        var t =
          (g && g.__awaiter) ||
          function (b, m, w, _) {
            function S(E) {
              return E instanceof w
                ? E
                : new w(function (O) {
                    O(E);
                  });
            }
            return new (w || (w = Promise))(function (E, O) {
              function N(k) {
                try {
                  D(_.next(k));
                } catch (K) {
                  O(K);
                }
              }
              function F(k) {
                try {
                  D(_.throw(k));
                } catch (K) {
                  O(K);
                }
              }
              function D(k) {
                k.done ? E(k.value) : S(k.value).then(N, F);
              }
              D((_ = _.apply(b, m || [])).next());
            });
          };
        Object.defineProperty(e, '__esModule', { value: !0 }),
          (e.unpackAccount =
            e.getMinimumBalanceForRentExemptAccountWithExtensions =
            e.getMinimumBalanceForRentExemptAccount =
            e.getMultipleAccounts =
            e.getAccount =
            e.ACCOUNT_SIZE =
            e.AccountLayout =
            e.AccountState =
              void 0);
        const n = xe,
          r = gt,
          i = ye,
          o = be,
          a = _f,
          c = On(),
          s = Ss;
        var l;
        (function (b) {
          (b[(b.Uninitialized = 0)] = 'Uninitialized'),
            (b[(b.Initialized = 1)] = 'Initialized'),
            (b[(b.Frozen = 2)] = 'Frozen');
        })((l = e.AccountState || (e.AccountState = {}))),
          (e.AccountLayout = (0, n.struct)([
            (0, r.publicKey)('mint'),
            (0, r.publicKey)('owner'),
            (0, r.u64)('amount'),
            (0, n.u32)('delegateOption'),
            (0, r.publicKey)('delegate'),
            (0, n.u8)('state'),
            (0, n.u32)('isNativeOption'),
            (0, r.u64)('isNative'),
            (0, r.u64)('delegatedAmount'),
            (0, n.u32)('closeAuthorityOption'),
            (0, r.publicKey)('closeAuthority'),
          ])),
          (e.ACCOUNT_SIZE = e.AccountLayout.span);
        function u(b, m, w, _ = i.TOKEN_PROGRAM_ID) {
          return t(this, void 0, void 0, function* () {
            const S = yield b.getAccountInfo(m, w);
            return y(m, S, _);
          });
        }
        e.getAccount = u;
        function d(b, m, w, _ = i.TOKEN_PROGRAM_ID) {
          return t(this, void 0, void 0, function* () {
            const S = yield b.getMultipleAccountsInfo(m, w);
            return m.map((E, O) => y(E, S[O], _));
          });
        }
        e.getMultipleAccounts = d;
        function f(b, m) {
          return t(this, void 0, void 0, function* () {
            return yield p(b, [], m);
          });
        }
        e.getMinimumBalanceForRentExemptAccount = f;
        function p(b, m, w) {
          return t(this, void 0, void 0, function* () {
            const _ = (0, c.getAccountLen)(m);
            return yield b.getMinimumBalanceForRentExemption(_, w);
          });
        }
        e.getMinimumBalanceForRentExemptAccountWithExtensions = p;
        function y(b, m, w = i.TOKEN_PROGRAM_ID) {
          if (!m) throw new o.TokenAccountNotFoundError();
          if (!m.owner.equals(w)) throw new o.TokenInvalidAccountOwnerError();
          if (m.data.length < e.ACCOUNT_SIZE) throw new o.TokenInvalidAccountSizeError();
          const _ = e.AccountLayout.decode(m.data.slice(0, e.ACCOUNT_SIZE));
          let S = Y.alloc(0);
          if (m.data.length > e.ACCOUNT_SIZE) {
            if (m.data.length === s.MULTISIG_SIZE) throw new o.TokenInvalidAccountSizeError();
            if (m.data[e.ACCOUNT_SIZE] != a.AccountType.Account)
              throw new o.TokenInvalidAccountError();
            S = m.data.slice(e.ACCOUNT_SIZE + a.ACCOUNT_TYPE_SIZE);
          }
          return {
            address: b,
            mint: _.mint,
            owner: _.owner,
            amount: _.amount,
            delegate: _.delegateOption ? _.delegate : null,
            delegatedAmount: _.delegatedAmount,
            isInitialized: _.state !== l.Uninitialized,
            isFrozen: _.state === l.Frozen,
            isNative: !!_.isNativeOption,
            rentExemptReserve: _.isNativeOption ? _.isNative : null,
            closeAuthority: _.closeAuthorityOption ? _.closeAuthority : null,
            tlvData: S,
          };
        }
        e.unpackAccount = y;
      })(pb)),
    pb
  );
}
var gb = {},
  av;
function ho() {
  return (
    av ||
      ((av = 1),
      (function (e) {
        var t =
          (g && g.__awaiter) ||
          function (w, _, S, E) {
            function O(N) {
              return N instanceof S
                ? N
                : new S(function (F) {
                    F(N);
                  });
            }
            return new (S || (S = Promise))(function (N, F) {
              function D(M) {
                try {
                  K(E.next(M));
                } catch (C) {
                  F(C);
                }
              }
              function k(M) {
                try {
                  K(E.throw(M));
                } catch (C) {
                  F(C);
                }
              }
              function K(M) {
                M.done ? N(M.value) : O(M.value).then(D, k);
              }
              K((E = E.apply(w, _ || [])).next());
            });
          };
        Object.defineProperty(e, '__esModule', { value: !0 }),
          (e.getAssociatedTokenAddressSync =
            e.getAssociatedTokenAddress =
            e.getMinimumBalanceForRentExemptMintWithExtensions =
            e.getMinimumBalanceForRentExemptMint =
            e.unpackMint =
            e.getMint =
            e.MINT_SIZE =
            e.MintLayout =
              void 0);
        const n = xe,
          r = gt,
          i = V,
          o = ye,
          a = be,
          c = _f,
          s = On(),
          l = vf(),
          u = Ss;
        (e.MintLayout = (0, n.struct)([
          (0, n.u32)('mintAuthorityOption'),
          (0, r.publicKey)('mintAuthority'),
          (0, r.u64)('supply'),
          (0, n.u8)('decimals'),
          (0, r.bool)('isInitialized'),
          (0, n.u32)('freezeAuthorityOption'),
          (0, r.publicKey)('freezeAuthority'),
        ])),
          (e.MINT_SIZE = e.MintLayout.span);
        function d(w, _, S, E = o.TOKEN_PROGRAM_ID) {
          return t(this, void 0, void 0, function* () {
            const O = yield w.getAccountInfo(_, S);
            return f(_, O, E);
          });
        }
        e.getMint = d;
        function f(w, _, S = o.TOKEN_PROGRAM_ID) {
          if (!_) throw new a.TokenAccountNotFoundError();
          if (!_.owner.equals(S)) throw new a.TokenInvalidAccountOwnerError();
          if (_.data.length < e.MINT_SIZE) throw new a.TokenInvalidAccountSizeError();
          const E = e.MintLayout.decode(_.data.slice(0, e.MINT_SIZE));
          let O = Y.alloc(0);
          if (_.data.length > e.MINT_SIZE) {
            if (_.data.length <= l.ACCOUNT_SIZE) throw new a.TokenInvalidAccountSizeError();
            if (_.data.length === u.MULTISIG_SIZE) throw new a.TokenInvalidAccountSizeError();
            if (_.data[l.ACCOUNT_SIZE] != c.AccountType.Mint) throw new a.TokenInvalidMintError();
            O = _.data.slice(l.ACCOUNT_SIZE + c.ACCOUNT_TYPE_SIZE);
          }
          return {
            address: w,
            mintAuthority: E.mintAuthorityOption ? E.mintAuthority : null,
            supply: E.supply,
            decimals: E.decimals,
            isInitialized: E.isInitialized,
            freezeAuthority: E.freezeAuthorityOption ? E.freezeAuthority : null,
            tlvData: O,
          };
        }
        e.unpackMint = f;
        function p(w, _) {
          return t(this, void 0, void 0, function* () {
            return yield y(w, [], _);
          });
        }
        e.getMinimumBalanceForRentExemptMint = p;
        function y(w, _, S) {
          return t(this, void 0, void 0, function* () {
            const E = (0, s.getMintLen)(_);
            return yield w.getMinimumBalanceForRentExemption(E, S);
          });
        }
        e.getMinimumBalanceForRentExemptMintWithExtensions = y;
        function b(w, _, S = !1, E = o.TOKEN_PROGRAM_ID, O = o.ASSOCIATED_TOKEN_PROGRAM_ID) {
          return t(this, void 0, void 0, function* () {
            if (!S && !i.PublicKey.isOnCurve(_.toBuffer())) throw new a.TokenOwnerOffCurveError();
            const [N] = yield i.PublicKey.findProgramAddress(
              [_.toBuffer(), E.toBuffer(), w.toBuffer()],
              O
            );
            return N;
          });
        }
        e.getAssociatedTokenAddress = b;
        function m(w, _, S = !1, E = o.TOKEN_PROGRAM_ID, O = o.ASSOCIATED_TOKEN_PROGRAM_ID) {
          if (!S && !i.PublicKey.isOnCurve(_.toBuffer())) throw new a.TokenOwnerOffCurveError();
          const [N] = i.PublicKey.findProgramAddressSync(
            [_.toBuffer(), E.toBuffer(), w.toBuffer()],
            O
          );
          return N;
        }
        e.getAssociatedTokenAddressSync = m;
      })(gb)),
    gb
  );
}
var yb = {},
  Ja = {},
  D1 = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createDisableCpiGuardInstruction =
      e.createEnableCpiGuardInstruction =
      e.cpiGuardInstructionData =
      e.CpiGuardInstruction =
        void 0);
  const t = xe,
    n = V,
    r = ye,
    i = be,
    o = xt,
    a = Ze;
  var c;
  (function (d) {
    (d[(d.Enable = 0)] = 'Enable'), (d[(d.Disable = 1)] = 'Disable');
  })((c = e.CpiGuardInstruction || (e.CpiGuardInstruction = {}))),
    (e.cpiGuardInstructionData = (0, t.struct)([
      (0, t.u8)('instruction'),
      (0, t.u8)('cpiGuardInstruction'),
    ]));
  function s(d, f, p = [], y = r.TOKEN_2022_PROGRAM_ID) {
    return u(c.Enable, d, f, p, y);
  }
  e.createEnableCpiGuardInstruction = s;
  function l(d, f, p = [], y = r.TOKEN_2022_PROGRAM_ID) {
    return u(c.Disable, d, f, p, y);
  }
  e.createDisableCpiGuardInstruction = l;
  function u(d, f, p, y, b) {
    if (!(0, r.programSupportsExtensions)(b)) throw new i.TokenUnsupportedInstructionError();
    const m = (0, o.addSigners)([{ pubkey: f, isSigner: !1, isWritable: !0 }], p, y),
      w = Y.alloc(e.cpiGuardInstructionData.span);
    return (
      e.cpiGuardInstructionData.encode(
        { instruction: a.TokenInstruction.CpiGuardExtension, cpiGuardInstruction: d },
        w
      ),
      new n.TransactionInstruction({ keys: m, programId: b, data: w })
    );
  }
})(D1);
var wk =
  (g && g.__awaiter) ||
  function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (a) {
            a(o);
          });
    }
    return new (n || (n = Promise))(function (o, a) {
      function c(u) {
        try {
          l(r.next(u));
        } catch (d) {
          a(d);
        }
      }
      function s(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          a(d);
        }
      }
      function l(u) {
        u.done ? o(u.value) : i(u.value).then(c, s);
      }
      l((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(Ja, '__esModule', { value: !0 });
Ja.disableCpiGuard = Ja.enableCpiGuard = void 0;
const up = V,
  _k = Bt,
  vk = ye,
  Sk = D1;
function Hz(e, t, n, r, i = [], o, a = vk.TOKEN_2022_PROGRAM_ID) {
  return wk(this, void 0, void 0, function* () {
    const [c, s] = (0, _k.getSigners)(r, i),
      l = new up.Transaction().add((0, Sk.createEnableCpiGuardInstruction)(n, c, s, a));
    return yield (0, up.sendAndConfirmTransaction)(e, l, [t, ...s], o);
  });
}
Ja.enableCpiGuard = Hz;
function qz(e, t, n, r, i = [], o, a = vk.TOKEN_2022_PROGRAM_ID) {
  return wk(this, void 0, void 0, function* () {
    const [c, s] = (0, _k.getSigners)(r, i),
      l = new up.Transaction().add((0, Sk.createDisableCpiGuardInstruction)(n, c, s, a));
    return yield (0, up.sendAndConfirmTransaction)(e, l, [t, ...s], o);
  });
}
Ja.disableCpiGuard = qz;
var bb = {},
  sv;
function Gz() {
  return (
    sv ||
      ((sv = 1),
      (function (e) {
        Object.defineProperty(e, '__esModule', { value: !0 }),
          (e.getCpiGuard = e.CPI_GUARD_SIZE = e.CpiGuardLayout = void 0);
        const t = xe,
          n = gt,
          r = On();
        (e.CpiGuardLayout = (0, t.struct)([(0, n.bool)('lockCpi')])),
          (e.CPI_GUARD_SIZE = e.CpiGuardLayout.span);
        function i(o) {
          const a = (0, r.getExtensionData)(r.ExtensionType.CpiGuard, o.tlvData);
          return a !== null ? e.CpiGuardLayout.decode(a) : null;
        }
        e.getCpiGuard = i;
      })(bb)),
    bb
  );
}
var cv;
function Ak() {
  return (
    cv ||
      ((cv = 1),
      (function (e) {
        var t =
            (g && g.__createBinding) ||
            (Object.create
              ? function (r, i, o, a) {
                  a === void 0 && (a = o);
                  var c = Object.getOwnPropertyDescriptor(i, o);
                  (!c || ('get' in c ? !i.__esModule : c.writable || c.configurable)) &&
                    (c = {
                      enumerable: !0,
                      get: function () {
                        return i[o];
                      },
                    }),
                    Object.defineProperty(r, a, c);
                }
              : function (r, i, o, a) {
                  a === void 0 && (a = o), (r[a] = i[o]);
                }),
          n =
            (g && g.__exportStar) ||
            function (r, i) {
              for (var o in r)
                o !== 'default' && !Object.prototype.hasOwnProperty.call(i, o) && t(i, r, o);
            };
        Object.defineProperty(e, '__esModule', { value: !0 }), n(Ja, e), n(D1, e), n(Gz(), e);
      })(yb)),
    yb
  );
}
var mb = {},
  Xa = {},
  R1 = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createUpdateDefaultAccountStateInstruction =
      e.createInitializeDefaultAccountStateInstruction =
      e.defaultAccountStateInstructionData =
      e.DefaultAccountStateInstruction =
        void 0);
  const t = xe,
    n = V,
    r = ye,
    i = be,
    o = xt,
    a = Ze;
  var c;
  (function (u) {
    (u[(u.Initialize = 0)] = 'Initialize'), (u[(u.Update = 1)] = 'Update');
  })((c = e.DefaultAccountStateInstruction || (e.DefaultAccountStateInstruction = {}))),
    (e.defaultAccountStateInstructionData = (0, t.struct)([
      (0, t.u8)('instruction'),
      (0, t.u8)('defaultAccountStateInstruction'),
      (0, t.u8)('accountState'),
    ]));
  function s(u, d, f = r.TOKEN_2022_PROGRAM_ID) {
    if (!(0, r.programSupportsExtensions)(f)) throw new i.TokenUnsupportedInstructionError();
    const p = [{ pubkey: u, isSigner: !1, isWritable: !0 }],
      y = Y.alloc(e.defaultAccountStateInstructionData.span);
    return (
      e.defaultAccountStateInstructionData.encode(
        {
          instruction: a.TokenInstruction.DefaultAccountStateExtension,
          defaultAccountStateInstruction: c.Initialize,
          accountState: d,
        },
        y
      ),
      new n.TransactionInstruction({ keys: p, programId: f, data: y })
    );
  }
  e.createInitializeDefaultAccountStateInstruction = s;
  function l(u, d, f, p = [], y = r.TOKEN_2022_PROGRAM_ID) {
    if (!(0, r.programSupportsExtensions)(y)) throw new i.TokenUnsupportedInstructionError();
    const b = (0, o.addSigners)([{ pubkey: u, isSigner: !1, isWritable: !0 }], f, p),
      m = Y.alloc(e.defaultAccountStateInstructionData.span);
    return (
      e.defaultAccountStateInstructionData.encode(
        {
          instruction: a.TokenInstruction.DefaultAccountStateExtension,
          defaultAccountStateInstruction: c.Update,
          accountState: d,
        },
        m
      ),
      new n.TransactionInstruction({ keys: b, programId: y, data: m })
    );
  }
  e.createUpdateDefaultAccountStateInstruction = l;
})(R1);
var Ik =
  (g && g.__awaiter) ||
  function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (a) {
            a(o);
          });
    }
    return new (n || (n = Promise))(function (o, a) {
      function c(u) {
        try {
          l(r.next(u));
        } catch (d) {
          a(d);
        }
      }
      function s(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          a(d);
        }
      }
      function l(u) {
        u.done ? o(u.value) : i(u.value).then(c, s);
      }
      l((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(Xa, '__esModule', { value: !0 });
Xa.updateDefaultAccountState = Xa.initializeDefaultAccountState = void 0;
const lp = V,
  Yz = Bt,
  Ek = ye,
  Tk = R1;
function Zz(e, t, n, r, i, o = Ek.TOKEN_2022_PROGRAM_ID) {
  return Ik(this, void 0, void 0, function* () {
    const a = new lp.Transaction().add(
      (0, Tk.createInitializeDefaultAccountStateInstruction)(n, r, o)
    );
    return yield (0, lp.sendAndConfirmTransaction)(e, a, [t], i);
  });
}
Xa.initializeDefaultAccountState = Zz;
function Qz(e, t, n, r, i, o = [], a, c = Ek.TOKEN_2022_PROGRAM_ID) {
  return Ik(this, void 0, void 0, function* () {
    const [s, l] = (0, Yz.getSigners)(i, o),
      u = new lp.Transaction().add(
        (0, Tk.createUpdateDefaultAccountStateInstruction)(n, r, s, l, c)
      );
    return yield (0, lp.sendAndConfirmTransaction)(e, u, [t, ...l], a);
  });
}
Xa.updateDefaultAccountState = Qz;
var wb = {},
  uv;
function Jz() {
  return (
    uv ||
      ((uv = 1),
      (function (e) {
        Object.defineProperty(e, '__esModule', { value: !0 }),
          (e.getDefaultAccountState =
            e.DEFAULT_ACCOUNT_STATE_SIZE =
            e.DefaultAccountStateLayout =
              void 0);
        const t = xe,
          n = On();
        (e.DefaultAccountStateLayout = (0, t.struct)([(0, t.u8)('state')])),
          (e.DEFAULT_ACCOUNT_STATE_SIZE = e.DefaultAccountStateLayout.span);
        function r(i) {
          const o = (0, n.getExtensionData)(n.ExtensionType.DefaultAccountState, i.tlvData);
          return o !== null ? e.DefaultAccountStateLayout.decode(o) : null;
        }
        e.getDefaultAccountState = r;
      })(wb)),
    wb
  );
}
var lv;
function kk() {
  return (
    lv ||
      ((lv = 1),
      (function (e) {
        var t =
            (g && g.__createBinding) ||
            (Object.create
              ? function (r, i, o, a) {
                  a === void 0 && (a = o);
                  var c = Object.getOwnPropertyDescriptor(i, o);
                  (!c || ('get' in c ? !i.__esModule : c.writable || c.configurable)) &&
                    (c = {
                      enumerable: !0,
                      get: function () {
                        return i[o];
                      },
                    }),
                    Object.defineProperty(r, a, c);
                }
              : function (r, i, o, a) {
                  a === void 0 && (a = o), (r[a] = i[o]);
                }),
          n =
            (g && g.__exportStar) ||
            function (r, i) {
              for (var o in r)
                o !== 'default' && !Object.prototype.hasOwnProperty.call(i, o) && t(i, r, o);
            };
        Object.defineProperty(e, '__esModule', { value: !0 }), n(Xa, e), n(R1, e), n(Jz(), e);
      })(mb)),
    mb
  );
}
var _b = {},
  dv;
function Ck() {
  return (
    dv ||
      ((dv = 1),
      (function (e) {
        Object.defineProperty(e, '__esModule', { value: !0 }),
          (e.getImmutableOwner = e.IMMUTABLE_OWNER_SIZE = e.ImmutableOwnerLayout = void 0);
        const t = xe,
          n = On();
        (e.ImmutableOwnerLayout = (0, t.struct)([])),
          (e.IMMUTABLE_OWNER_SIZE = e.ImmutableOwnerLayout.span);
        function r(i) {
          const o = (0, n.getExtensionData)(n.ExtensionType.ImmutableOwner, i.tlvData);
          return o !== null ? e.ImmutableOwnerLayout.decode(o) : null;
        }
        e.getImmutableOwner = r;
      })(_b)),
    _b
  );
}
var vb = {},
  fv;
function Mk() {
  return (
    fv ||
      ((fv = 1),
      (function (e) {
        Object.defineProperty(e, '__esModule', { value: !0 }),
          (e.getInterestBearingMintConfigState =
            e.INTEREST_BEARING_MINT_CONFIG_STATE_SIZE =
            e.InterestBearingMintConfigStateLayout =
              void 0);
        const t = xe,
          n = gt,
          r = On();
        (e.InterestBearingMintConfigStateLayout = (0, t.struct)([
          (0, n.publicKey)('rateAuthority'),
          (0, t.ns64)('initializationTimestamp'),
          (0, t.s16)('preUpdateAverageRate'),
          (0, t.ns64)('lastUpdateTimestamp'),
          (0, t.s16)('currentRate'),
        ])),
          (e.INTEREST_BEARING_MINT_CONFIG_STATE_SIZE = e.InterestBearingMintConfigStateLayout.span);
        function i(o) {
          const a = (0, r.getExtensionData)(r.ExtensionType.InterestBearingConfig, o.tlvData);
          return a !== null ? e.InterestBearingMintConfigStateLayout.decode(a) : null;
        }
        e.getInterestBearingMintConfigState = i;
      })(vb)),
    vb
  );
}
var Sb = {},
  es = {},
  x1 = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createDisableRequiredMemoTransfersInstruction =
      e.createEnableRequiredMemoTransfersInstruction =
      e.memoTransferInstructionData =
      e.MemoTransferInstruction =
        void 0);
  const t = xe,
    n = V,
    r = ye,
    i = be,
    o = xt,
    a = Ze;
  var c;
  (function (d) {
    (d[(d.Enable = 0)] = 'Enable'), (d[(d.Disable = 1)] = 'Disable');
  })((c = e.MemoTransferInstruction || (e.MemoTransferInstruction = {}))),
    (e.memoTransferInstructionData = (0, t.struct)([
      (0, t.u8)('instruction'),
      (0, t.u8)('memoTransferInstruction'),
    ]));
  function s(d, f, p = [], y = r.TOKEN_2022_PROGRAM_ID) {
    return u(c.Enable, d, f, p, y);
  }
  e.createEnableRequiredMemoTransfersInstruction = s;
  function l(d, f, p = [], y = r.TOKEN_2022_PROGRAM_ID) {
    return u(c.Disable, d, f, p, y);
  }
  e.createDisableRequiredMemoTransfersInstruction = l;
  function u(d, f, p, y, b) {
    if (!(0, r.programSupportsExtensions)(b)) throw new i.TokenUnsupportedInstructionError();
    const m = (0, o.addSigners)([{ pubkey: f, isSigner: !1, isWritable: !0 }], p, y),
      w = Y.alloc(e.memoTransferInstructionData.span);
    return (
      e.memoTransferInstructionData.encode(
        { instruction: a.TokenInstruction.MemoTransferExtension, memoTransferInstruction: d },
        w
      ),
      new n.TransactionInstruction({ keys: m, programId: b, data: w })
    );
  }
})(x1);
var Pk =
  (g && g.__awaiter) ||
  function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (a) {
            a(o);
          });
    }
    return new (n || (n = Promise))(function (o, a) {
      function c(u) {
        try {
          l(r.next(u));
        } catch (d) {
          a(d);
        }
      }
      function s(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          a(d);
        }
      }
      function l(u) {
        u.done ? o(u.value) : i(u.value).then(c, s);
      }
      l((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(es, '__esModule', { value: !0 });
es.disableRequiredMemoTransfers = es.enableRequiredMemoTransfers = void 0;
const dp = V,
  Ok = Bt,
  Dk = ye,
  Rk = x1;
function Xz(e, t, n, r, i = [], o, a = Dk.TOKEN_2022_PROGRAM_ID) {
  return Pk(this, void 0, void 0, function* () {
    const [c, s] = (0, Ok.getSigners)(r, i),
      l = new dp.Transaction().add(
        (0, Rk.createEnableRequiredMemoTransfersInstruction)(n, c, s, a)
      );
    return yield (0, dp.sendAndConfirmTransaction)(e, l, [t, ...s], o);
  });
}
es.enableRequiredMemoTransfers = Xz;
function eF(e, t, n, r, i = [], o, a = Dk.TOKEN_2022_PROGRAM_ID) {
  return Pk(this, void 0, void 0, function* () {
    const [c, s] = (0, Ok.getSigners)(r, i),
      l = new dp.Transaction().add(
        (0, Rk.createDisableRequiredMemoTransfersInstruction)(n, c, s, a)
      );
    return yield (0, dp.sendAndConfirmTransaction)(e, l, [t, ...s], o);
  });
}
es.disableRequiredMemoTransfers = eF;
var Ab = {},
  hv;
function tF() {
  return (
    hv ||
      ((hv = 1),
      (function (e) {
        Object.defineProperty(e, '__esModule', { value: !0 }),
          (e.getMemoTransfer = e.MEMO_TRANSFER_SIZE = e.MemoTransferLayout = void 0);
        const t = xe,
          n = gt,
          r = On();
        (e.MemoTransferLayout = (0, t.struct)([(0, n.bool)('requireIncomingTransferMemos')])),
          (e.MEMO_TRANSFER_SIZE = e.MemoTransferLayout.span);
        function i(o) {
          const a = (0, r.getExtensionData)(r.ExtensionType.MemoTransfer, o.tlvData);
          return a !== null ? e.MemoTransferLayout.decode(a) : null;
        }
        e.getMemoTransfer = i;
      })(Ab)),
    Ab
  );
}
var pv;
function xk() {
  return (
    pv ||
      ((pv = 1),
      (function (e) {
        var t =
            (g && g.__createBinding) ||
            (Object.create
              ? function (r, i, o, a) {
                  a === void 0 && (a = o);
                  var c = Object.getOwnPropertyDescriptor(i, o);
                  (!c || ('get' in c ? !i.__esModule : c.writable || c.configurable)) &&
                    (c = {
                      enumerable: !0,
                      get: function () {
                        return i[o];
                      },
                    }),
                    Object.defineProperty(r, a, c);
                }
              : function (r, i, o, a) {
                  a === void 0 && (a = o), (r[a] = i[o]);
                }),
          n =
            (g && g.__exportStar) ||
            function (r, i) {
              for (var o in r)
                o !== 'default' && !Object.prototype.hasOwnProperty.call(i, o) && t(i, r, o);
            };
        Object.defineProperty(e, '__esModule', { value: !0 }), n(es, e), n(x1, e), n(tF(), e);
      })(Sb)),
    Sb
  );
}
var Ib = {},
  gv;
function Bk() {
  return (
    gv ||
      ((gv = 1),
      (function (e) {
        Object.defineProperty(e, '__esModule', { value: !0 }),
          (e.getMintCloseAuthority =
            e.MINT_CLOSE_AUTHORITY_SIZE =
            e.MintCloseAuthorityLayout =
              void 0);
        const t = xe,
          n = gt,
          r = On();
        (e.MintCloseAuthorityLayout = (0, t.struct)([(0, n.publicKey)('closeAuthority')])),
          (e.MINT_CLOSE_AUTHORITY_SIZE = e.MintCloseAuthorityLayout.span);
        function i(o) {
          const a = (0, r.getExtensionData)(r.ExtensionType.MintCloseAuthority, o.tlvData);
          return a !== null ? e.MintCloseAuthorityLayout.decode(a) : null;
        }
        e.getMintCloseAuthority = i;
      })(Ib)),
    Ib
  );
}
var Eb = {},
  yv;
function jk() {
  return (
    yv ||
      ((yv = 1),
      (function (e) {
        Object.defineProperty(e, '__esModule', { value: !0 }),
          (e.getNonTransferable = e.NON_TRANSFERABLE_SIZE = e.NonTransferableLayout = void 0);
        const t = xe,
          n = On();
        (e.NonTransferableLayout = (0, t.struct)([])),
          (e.NON_TRANSFERABLE_SIZE = e.NonTransferableLayout.span);
        function r(i) {
          const o = (0, n.getExtensionData)(n.ExtensionType.NonTransferable, i.tlvData);
          return o !== null ? e.NonTransferableLayout.decode(o) : null;
        }
        e.getNonTransferable = r;
      })(Eb)),
    Eb
  );
}
var Tb = {},
  bv;
function Nk() {
  return (
    bv ||
      ((bv = 1),
      (function (e) {
        Object.defineProperty(e, '__esModule', { value: !0 }),
          (e.getPermanentDelegate = e.PERMANENT_DELEGATE_SIZE = e.PermanentDelegateLayout = void 0);
        const t = xe,
          n = gt,
          r = On();
        (e.PermanentDelegateLayout = (0, t.struct)([(0, n.publicKey)('delegate')])),
          (e.PERMANENT_DELEGATE_SIZE = e.PermanentDelegateLayout.span);
        function i(o) {
          const a = (0, r.getExtensionData)(r.ExtensionType.PermanentDelegate, o.tlvData);
          return a !== null ? e.PermanentDelegateLayout.decode(a) : null;
        }
        e.getPermanentDelegate = i;
      })(Tb)),
    Tb
  );
}
var kb = {},
  zr = {},
  B1 = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeHarvestWithheldTokensToMintInstructionUnchecked =
      e.decodeHarvestWithheldTokensToMintInstruction =
      e.createHarvestWithheldTokensToMintInstruction =
      e.harvestWithheldTokensToMintInstructionData =
      e.decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked =
      e.decodeWithdrawWithheldTokensFromAccountsInstruction =
      e.createWithdrawWithheldTokensFromAccountsInstruction =
      e.withdrawWithheldTokensFromAccountsInstructionData =
      e.decodeWithdrawWithheldTokensFromMintInstructionUnchecked =
      e.decodeWithdrawWithheldTokensFromMintInstruction =
      e.createWithdrawWithheldTokensFromMintInstruction =
      e.withdrawWithheldTokensFromMintInstructionData =
      e.decodeTransferCheckedWithFeeInstructionUnchecked =
      e.decodeTransferCheckedWithFeeInstruction =
      e.createTransferCheckedWithFeeInstruction =
      e.transferCheckedWithFeeInstructionData =
      e.decodeInitializeTransferFeeConfigInstructionUnchecked =
      e.decodeInitializeTransferFeeConfigInstruction =
      e.createInitializeTransferFeeConfigInstruction =
      e.initializeTransferFeeConfigInstructionData =
      e.TransferFeeInstruction =
        void 0);
  const t = xe,
    n = gt,
    r = V,
    i = ye,
    o = be,
    a = xt,
    c = Ze;
  var s;
  (function (D) {
    (D[(D.InitializeTransferFeeConfig = 0)] = 'InitializeTransferFeeConfig'),
      (D[(D.TransferCheckedWithFee = 1)] = 'TransferCheckedWithFee'),
      (D[(D.WithdrawWithheldTokensFromMint = 2)] = 'WithdrawWithheldTokensFromMint'),
      (D[(D.WithdrawWithheldTokensFromAccounts = 3)] = 'WithdrawWithheldTokensFromAccounts'),
      (D[(D.HarvestWithheldTokensToMint = 4)] = 'HarvestWithheldTokensToMint'),
      (D[(D.SetTransferFee = 5)] = 'SetTransferFee');
  })((s = e.TransferFeeInstruction || (e.TransferFeeInstruction = {}))),
    (e.initializeTransferFeeConfigInstructionData = (0, t.struct)([
      (0, t.u8)('instruction'),
      (0, t.u8)('transferFeeInstruction'),
      (0, t.u8)('transferFeeConfigAuthorityOption'),
      (0, n.publicKey)('transferFeeConfigAuthority'),
      (0, t.u8)('withdrawWithheldAuthorityOption'),
      (0, n.publicKey)('withdrawWithheldAuthority'),
      (0, t.u16)('transferFeeBasisPoints'),
      (0, n.u64)('maximumFee'),
    ]));
  function l(D, k, K, M, C, z = i.TOKEN_2022_PROGRAM_ID) {
    if (!(0, i.programSupportsExtensions)(z)) throw new o.TokenUnsupportedInstructionError();
    const I = [{ pubkey: D, isSigner: !1, isWritable: !0 }],
      T = Y.alloc(e.initializeTransferFeeConfigInstructionData.span);
    return (
      e.initializeTransferFeeConfigInstructionData.encode(
        {
          instruction: c.TokenInstruction.TransferFeeExtension,
          transferFeeInstruction: s.InitializeTransferFeeConfig,
          transferFeeConfigAuthorityOption: k ? 1 : 0,
          transferFeeConfigAuthority: k || new r.PublicKey(0),
          withdrawWithheldAuthorityOption: K ? 1 : 0,
          withdrawWithheldAuthority: K || new r.PublicKey(0),
          transferFeeBasisPoints: M,
          maximumFee: C,
        },
        T
      ),
      new r.TransactionInstruction({ keys: I, programId: z, data: T })
    );
  }
  e.createInitializeTransferFeeConfigInstruction = l;
  function u(D, k) {
    if (!D.programId.equals(k)) throw new o.TokenInvalidInstructionProgramError();
    if (D.data.length !== e.initializeTransferFeeConfigInstructionData.span)
      throw new o.TokenInvalidInstructionDataError();
    const {
      keys: { mint: K },
      data: M,
    } = d(D);
    if (
      M.instruction !== c.TokenInstruction.TransferFeeExtension ||
      M.transferFeeInstruction !== s.InitializeTransferFeeConfig
    )
      throw new o.TokenInvalidInstructionTypeError();
    if (!K) throw new o.TokenInvalidInstructionKeysError();
    return { programId: k, keys: { mint: K }, data: M };
  }
  e.decodeInitializeTransferFeeConfigInstruction = u;
  function d({ programId: D, keys: [k], data: K }) {
    const {
      instruction: M,
      transferFeeInstruction: C,
      transferFeeConfigAuthorityOption: z,
      transferFeeConfigAuthority: I,
      withdrawWithheldAuthorityOption: T,
      withdrawWithheldAuthority: P,
      transferFeeBasisPoints: R,
      maximumFee: L,
    } = e.initializeTransferFeeConfigInstructionData.decode(K);
    return {
      programId: D,
      keys: { mint: k },
      data: {
        instruction: M,
        transferFeeInstruction: C,
        transferFeeConfigAuthority: z ? I : null,
        withdrawWithheldAuthority: T ? P : null,
        transferFeeBasisPoints: R,
        maximumFee: L,
      },
    };
  }
  (e.decodeInitializeTransferFeeConfigInstructionUnchecked = d),
    (e.transferCheckedWithFeeInstructionData = (0, t.struct)([
      (0, t.u8)('instruction'),
      (0, t.u8)('transferFeeInstruction'),
      (0, n.u64)('amount'),
      (0, t.u8)('decimals'),
      (0, n.u64)('fee'),
    ]));
  function f(D, k, K, M, C, z, I, T = [], P = i.TOKEN_2022_PROGRAM_ID) {
    if (!(0, i.programSupportsExtensions)(P)) throw new o.TokenUnsupportedInstructionError();
    const R = Y.alloc(e.transferCheckedWithFeeInstructionData.span);
    e.transferCheckedWithFeeInstructionData.encode(
      {
        instruction: c.TokenInstruction.TransferFeeExtension,
        transferFeeInstruction: s.TransferCheckedWithFee,
        amount: C,
        decimals: z,
        fee: I,
      },
      R
    );
    const L = (0, a.addSigners)(
      [
        { pubkey: D, isSigner: !1, isWritable: !0 },
        { pubkey: k, isSigner: !1, isWritable: !1 },
        { pubkey: K, isSigner: !1, isWritable: !0 },
      ],
      M,
      T
    );
    return new r.TransactionInstruction({ keys: L, programId: P, data: R });
  }
  e.createTransferCheckedWithFeeInstruction = f;
  function p(D, k) {
    if (!D.programId.equals(k)) throw new o.TokenInvalidInstructionProgramError();
    if (D.data.length !== e.transferCheckedWithFeeInstructionData.span)
      throw new o.TokenInvalidInstructionDataError();
    const {
      keys: { source: K, mint: M, destination: C, authority: z, signers: I },
      data: T,
    } = y(D);
    if (
      T.instruction !== c.TokenInstruction.TransferFeeExtension ||
      T.transferFeeInstruction !== s.TransferCheckedWithFee
    )
      throw new o.TokenInvalidInstructionTypeError();
    if (!M) throw new o.TokenInvalidInstructionKeysError();
    return {
      programId: k,
      keys: { source: K, mint: M, destination: C, authority: z, signers: I || null },
      data: T,
    };
  }
  e.decodeTransferCheckedWithFeeInstruction = p;
  function y({ programId: D, keys: [k, K, M, C, ...z], data: I }) {
    const {
      instruction: T,
      transferFeeInstruction: P,
      amount: R,
      decimals: L,
      fee: H,
    } = e.transferCheckedWithFeeInstructionData.decode(I);
    return {
      programId: D,
      keys: { source: k, mint: K, destination: M, authority: C, signers: z },
      data: { instruction: T, transferFeeInstruction: P, amount: R, decimals: L, fee: H },
    };
  }
  (e.decodeTransferCheckedWithFeeInstructionUnchecked = y),
    (e.withdrawWithheldTokensFromMintInstructionData = (0, t.struct)([
      (0, t.u8)('instruction'),
      (0, t.u8)('transferFeeInstruction'),
    ]));
  function b(D, k, K, M = [], C = i.TOKEN_2022_PROGRAM_ID) {
    if (!(0, i.programSupportsExtensions)(C)) throw new o.TokenUnsupportedInstructionError();
    const z = Y.alloc(e.withdrawWithheldTokensFromMintInstructionData.span);
    e.withdrawWithheldTokensFromMintInstructionData.encode(
      {
        instruction: c.TokenInstruction.TransferFeeExtension,
        transferFeeInstruction: s.WithdrawWithheldTokensFromMint,
      },
      z
    );
    const I = (0, a.addSigners)(
      [
        { pubkey: D, isSigner: !1, isWritable: !0 },
        { pubkey: k, isSigner: !1, isWritable: !0 },
      ],
      K,
      M
    );
    return new r.TransactionInstruction({ keys: I, programId: C, data: z });
  }
  e.createWithdrawWithheldTokensFromMintInstruction = b;
  function m(D, k) {
    if (!D.programId.equals(k)) throw new o.TokenInvalidInstructionProgramError();
    if (D.data.length !== e.withdrawWithheldTokensFromMintInstructionData.span)
      throw new o.TokenInvalidInstructionDataError();
    const {
      keys: { mint: K, destination: M, authority: C, signers: z },
      data: I,
    } = w(D);
    if (
      I.instruction !== c.TokenInstruction.TransferFeeExtension ||
      I.transferFeeInstruction !== s.WithdrawWithheldTokensFromMint
    )
      throw new o.TokenInvalidInstructionTypeError();
    if (!K) throw new o.TokenInvalidInstructionKeysError();
    return {
      programId: k,
      keys: { mint: K, destination: M, authority: C, signers: z || null },
      data: I,
    };
  }
  e.decodeWithdrawWithheldTokensFromMintInstruction = m;
  function w({ programId: D, keys: [k, K, M, ...C], data: z }) {
    const { instruction: I, transferFeeInstruction: T } =
      e.withdrawWithheldTokensFromMintInstructionData.decode(z);
    return {
      programId: D,
      keys: { mint: k, destination: K, authority: M, signers: C },
      data: { instruction: I, transferFeeInstruction: T },
    };
  }
  (e.decodeWithdrawWithheldTokensFromMintInstructionUnchecked = w),
    (e.withdrawWithheldTokensFromAccountsInstructionData = (0, t.struct)([
      (0, t.u8)('instruction'),
      (0, t.u8)('transferFeeInstruction'),
      (0, t.u8)('numTokenAccounts'),
    ]));
  function _(D, k, K, M, C, z = i.TOKEN_2022_PROGRAM_ID) {
    if (!(0, i.programSupportsExtensions)(z)) throw new o.TokenUnsupportedInstructionError();
    const I = Y.alloc(e.withdrawWithheldTokensFromAccountsInstructionData.span);
    e.withdrawWithheldTokensFromAccountsInstructionData.encode(
      {
        instruction: c.TokenInstruction.TransferFeeExtension,
        transferFeeInstruction: s.WithdrawWithheldTokensFromAccounts,
        numTokenAccounts: C.length,
      },
      I
    );
    const T = (0, a.addSigners)(
      [
        { pubkey: D, isSigner: !1, isWritable: !0 },
        { pubkey: k, isSigner: !1, isWritable: !0 },
      ],
      K,
      M
    );
    for (const P of C) T.push({ pubkey: P, isSigner: !1, isWritable: !0 });
    return new r.TransactionInstruction({ keys: T, programId: z, data: I });
  }
  e.createWithdrawWithheldTokensFromAccountsInstruction = _;
  function S(D, k) {
    if (!D.programId.equals(k)) throw new o.TokenInvalidInstructionProgramError();
    if (D.data.length !== e.withdrawWithheldTokensFromAccountsInstructionData.span)
      throw new o.TokenInvalidInstructionDataError();
    const {
      keys: { mint: K, destination: M, authority: C, signers: z, sources: I },
      data: T,
    } = E(D);
    if (
      T.instruction !== c.TokenInstruction.TransferFeeExtension ||
      T.transferFeeInstruction !== s.WithdrawWithheldTokensFromAccounts
    )
      throw new o.TokenInvalidInstructionTypeError();
    if (!K) throw new o.TokenInvalidInstructionKeysError();
    return {
      programId: k,
      keys: { mint: K, destination: M, authority: C, signers: z || null, sources: I || null },
      data: T,
    };
  }
  e.decodeWithdrawWithheldTokensFromAccountsInstruction = S;
  function E({ programId: D, keys: k, data: K }) {
    const {
        instruction: M,
        transferFeeInstruction: C,
        numTokenAccounts: z,
      } = e.withdrawWithheldTokensFromAccountsInstructionData.decode(K),
      [I, T, P, R, L] = [k[0], k[1], k[2], k.slice(3, 3 + z), k.slice(-1 * z)];
    return {
      programId: D,
      keys: { mint: I, destination: T, authority: P, signers: R, sources: L },
      data: { instruction: M, transferFeeInstruction: C, numTokenAccounts: z },
    };
  }
  (e.decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked = E),
    (e.harvestWithheldTokensToMintInstructionData = (0, t.struct)([
      (0, t.u8)('instruction'),
      (0, t.u8)('transferFeeInstruction'),
    ]));
  function O(D, k, K = i.TOKEN_2022_PROGRAM_ID) {
    if (!(0, i.programSupportsExtensions)(K)) throw new o.TokenUnsupportedInstructionError();
    const M = Y.alloc(e.harvestWithheldTokensToMintInstructionData.span);
    e.harvestWithheldTokensToMintInstructionData.encode(
      {
        instruction: c.TokenInstruction.TransferFeeExtension,
        transferFeeInstruction: s.HarvestWithheldTokensToMint,
      },
      M
    );
    const C = [];
    C.push({ pubkey: D, isSigner: !1, isWritable: !0 });
    for (const z of k) C.push({ pubkey: z, isSigner: !1, isWritable: !0 });
    return new r.TransactionInstruction({ keys: C, programId: K, data: M });
  }
  e.createHarvestWithheldTokensToMintInstruction = O;
  function N(D, k) {
    if (!D.programId.equals(k)) throw new o.TokenInvalidInstructionProgramError();
    if (D.data.length !== e.harvestWithheldTokensToMintInstructionData.span)
      throw new o.TokenInvalidInstructionDataError();
    const {
      keys: { mint: K, sources: M },
      data: C,
    } = F(D);
    if (
      C.instruction !== c.TokenInstruction.TransferFeeExtension ||
      C.transferFeeInstruction !== s.HarvestWithheldTokensToMint
    )
      throw new o.TokenInvalidInstructionTypeError();
    if (!K) throw new o.TokenInvalidInstructionKeysError();
    return { programId: k, keys: { mint: K, sources: M }, data: C };
  }
  e.decodeHarvestWithheldTokensToMintInstruction = N;
  function F({ programId: D, keys: [k, ...K], data: M }) {
    const { instruction: C, transferFeeInstruction: z } =
      e.harvestWithheldTokensToMintInstructionData.decode(M);
    return {
      programId: D,
      keys: { mint: k, sources: K },
      data: { instruction: C, transferFeeInstruction: z },
    };
  }
  e.decodeHarvestWithheldTokensToMintInstructionUnchecked = F;
})(B1);
var Sg =
  (g && g.__awaiter) ||
  function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (a) {
            a(o);
          });
    }
    return new (n || (n = Promise))(function (o, a) {
      function c(u) {
        try {
          l(r.next(u));
        } catch (d) {
          a(d);
        }
      }
      function s(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          a(d);
        }
      }
      function l(u) {
        u.done ? o(u.value) : i(u.value).then(c, s);
      }
      l((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(zr, '__esModule', { value: !0 });
zr.harvestWithheldTokensToMint =
  zr.withdrawWithheldTokensFromAccounts =
  zr.withdrawWithheldTokensFromMint =
  zr.transferCheckedWithFee =
    void 0;
const io = V,
  j1 = Bt,
  Ag = ye,
  Ig = B1;
function nF(e, t, n, r, i, o, a, c, s, l = [], u, d = Ag.TOKEN_2022_PROGRAM_ID) {
  return Sg(this, void 0, void 0, function* () {
    const [f, p] = (0, j1.getSigners)(o, l),
      y = new io.Transaction().add(
        (0, Ig.createTransferCheckedWithFeeInstruction)(n, r, i, f, a, c, s, l, d)
      );
    return yield (0, io.sendAndConfirmTransaction)(e, y, [t, ...p], u);
  });
}
zr.transferCheckedWithFee = nF;
function rF(e, t, n, r, i, o = [], a, c = Ag.TOKEN_2022_PROGRAM_ID) {
  return Sg(this, void 0, void 0, function* () {
    const [s, l] = (0, j1.getSigners)(i, o),
      u = new io.Transaction().add(
        (0, Ig.createWithdrawWithheldTokensFromMintInstruction)(n, r, s, l, c)
      );
    return yield (0, io.sendAndConfirmTransaction)(e, u, [t, ...l], a);
  });
}
zr.withdrawWithheldTokensFromMint = rF;
function iF(e, t, n, r, i, o, a, c, s = Ag.TOKEN_2022_PROGRAM_ID) {
  return Sg(this, void 0, void 0, function* () {
    const [l, u] = (0, j1.getSigners)(i, o),
      d = new io.Transaction().add(
        (0, Ig.createWithdrawWithheldTokensFromAccountsInstruction)(n, r, l, u, a, s)
      );
    return yield (0, io.sendAndConfirmTransaction)(e, d, [t, ...u], c);
  });
}
zr.withdrawWithheldTokensFromAccounts = iF;
function oF(e, t, n, r, i, o = Ag.TOKEN_2022_PROGRAM_ID) {
  return Sg(this, void 0, void 0, function* () {
    const a = new io.Transaction().add(
      (0, Ig.createHarvestWithheldTokensToMintInstruction)(n, r, o)
    );
    return yield (0, io.sendAndConfirmTransaction)(e, a, [t], i);
  });
}
zr.harvestWithheldTokensToMint = oF;
var Cb = {},
  mv;
function aF() {
  return (
    mv ||
      ((mv = 1),
      (function (e) {
        Object.defineProperty(e, '__esModule', { value: !0 }),
          (e.getTransferFeeAmount =
            e.getTransferFeeConfig =
            e.TRANSFER_FEE_AMOUNT_SIZE =
            e.TransferFeeAmountLayout =
            e.TRANSFER_FEE_CONFIG_SIZE =
            e.TransferFeeConfigLayout =
            e.transferFeeLayout =
            e.ONE_IN_BASIS_POINTS =
            e.MAX_FEE_BASIS_POINTS =
              void 0);
        const t = xe,
          n = gt,
          r = On();
        (e.MAX_FEE_BASIS_POINTS = 1e4), (e.ONE_IN_BASIS_POINTS = e.MAX_FEE_BASIS_POINTS);
        function i(c) {
          return (0, t.struct)(
            [(0, n.u64)('epoch'), (0, n.u64)('maximumFee'), (0, t.u16)('transferFeeBasisPoints')],
            c
          );
        }
        (e.transferFeeLayout = i),
          (e.TransferFeeConfigLayout = (0, t.struct)([
            (0, n.publicKey)('transferFeeConfigAuthority'),
            (0, n.publicKey)('withdrawWithheldAuthority'),
            (0, n.u64)('withheldAmount'),
            i('olderTransferFee'),
            i('newerTransferFee'),
          ])),
          (e.TRANSFER_FEE_CONFIG_SIZE = e.TransferFeeConfigLayout.span),
          (e.TransferFeeAmountLayout = (0, t.struct)([(0, n.u64)('withheldAmount')])),
          (e.TRANSFER_FEE_AMOUNT_SIZE = e.TransferFeeAmountLayout.span);
        function o(c) {
          const s = (0, r.getExtensionData)(r.ExtensionType.TransferFeeConfig, c.tlvData);
          return s !== null ? e.TransferFeeConfigLayout.decode(s) : null;
        }
        e.getTransferFeeConfig = o;
        function a(c) {
          const s = (0, r.getExtensionData)(r.ExtensionType.TransferFeeAmount, c.tlvData);
          return s !== null ? e.TransferFeeAmountLayout.decode(s) : null;
        }
        e.getTransferFeeAmount = a;
      })(Cb)),
    Cb
  );
}
var wv;
function Uk() {
  return (
    wv ||
      ((wv = 1),
      (function (e) {
        var t =
            (g && g.__createBinding) ||
            (Object.create
              ? function (r, i, o, a) {
                  a === void 0 && (a = o);
                  var c = Object.getOwnPropertyDescriptor(i, o);
                  (!c || ('get' in c ? !i.__esModule : c.writable || c.configurable)) &&
                    (c = {
                      enumerable: !0,
                      get: function () {
                        return i[o];
                      },
                    }),
                    Object.defineProperty(r, a, c);
                }
              : function (r, i, o, a) {
                  a === void 0 && (a = o), (r[a] = i[o]);
                }),
          n =
            (g && g.__exportStar) ||
            function (r, i) {
              for (var o in r)
                o !== 'default' && !Object.prototype.hasOwnProperty.call(i, o) && t(i, r, o);
            };
        Object.defineProperty(e, '__esModule', { value: !0 }), n(zr, e), n(B1, e), n(aF(), e);
      })(kb)),
    kb
  );
}
var _v;
function On() {
  return (
    _v ||
      ((_v = 1),
      (function (e) {
        Object.defineProperty(e, '__esModule', { value: !0 }),
          (e.getAccountLenForMint =
            e.getExtensionTypes =
            e.getExtensionData =
            e.getAccountLen =
            e.getMintLen =
            e.getAccountTypeOfMintType =
            e.isAccountExtension =
            e.isMintExtension =
            e.getTypeLen =
            e.LENGTH_SIZE =
            e.TYPE_SIZE =
            e.ExtensionType =
              void 0);
        const t = vf(),
          n = ho(),
          r = Ss,
          i = _f,
          o = Ak(),
          a = kk(),
          c = Ck(),
          s = Mk(),
          l = xk(),
          u = Bk(),
          d = jk(),
          f = Nk(),
          p = Uk();
        var y;
        (function (k) {
          (k[(k.Uninitialized = 0)] = 'Uninitialized'),
            (k[(k.TransferFeeConfig = 1)] = 'TransferFeeConfig'),
            (k[(k.TransferFeeAmount = 2)] = 'TransferFeeAmount'),
            (k[(k.MintCloseAuthority = 3)] = 'MintCloseAuthority'),
            (k[(k.ConfidentialTransferMint = 4)] = 'ConfidentialTransferMint'),
            (k[(k.ConfidentialTransferAccount = 5)] = 'ConfidentialTransferAccount'),
            (k[(k.DefaultAccountState = 6)] = 'DefaultAccountState'),
            (k[(k.ImmutableOwner = 7)] = 'ImmutableOwner'),
            (k[(k.MemoTransfer = 8)] = 'MemoTransfer'),
            (k[(k.NonTransferable = 9)] = 'NonTransferable'),
            (k[(k.InterestBearingConfig = 10)] = 'InterestBearingConfig'),
            (k[(k.CpiGuard = 11)] = 'CpiGuard'),
            (k[(k.PermanentDelegate = 12)] = 'PermanentDelegate');
        })((y = e.ExtensionType || (e.ExtensionType = {}))),
          (e.TYPE_SIZE = 2),
          (e.LENGTH_SIZE = 2);
        function b(k) {
          switch (k) {
            case y.Uninitialized:
              return 0;
            case y.TransferFeeConfig:
              return p.TRANSFER_FEE_CONFIG_SIZE;
            case y.TransferFeeAmount:
              return p.TRANSFER_FEE_AMOUNT_SIZE;
            case y.MintCloseAuthority:
              return u.MINT_CLOSE_AUTHORITY_SIZE;
            case y.ConfidentialTransferMint:
              return 97;
            case y.ConfidentialTransferAccount:
              return 286;
            case y.CpiGuard:
              return o.CPI_GUARD_SIZE;
            case y.DefaultAccountState:
              return a.DEFAULT_ACCOUNT_STATE_SIZE;
            case y.ImmutableOwner:
              return c.IMMUTABLE_OWNER_SIZE;
            case y.MemoTransfer:
              return l.MEMO_TRANSFER_SIZE;
            case y.NonTransferable:
              return d.NON_TRANSFERABLE_SIZE;
            case y.InterestBearingConfig:
              return s.INTEREST_BEARING_MINT_CONFIG_STATE_SIZE;
            case y.PermanentDelegate:
              return f.PERMANENT_DELEGATE_SIZE;
            default:
              throw Error(`Unknown extension type: ${k}`);
          }
        }
        e.getTypeLen = b;
        function m(k) {
          switch (k) {
            case y.TransferFeeConfig:
            case y.MintCloseAuthority:
            case y.ConfidentialTransferMint:
            case y.DefaultAccountState:
            case y.NonTransferable:
            case y.InterestBearingConfig:
            case y.PermanentDelegate:
              return !0;
            case y.Uninitialized:
            case y.TransferFeeAmount:
            case y.ConfidentialTransferAccount:
            case y.ImmutableOwner:
            case y.MemoTransfer:
            case y.CpiGuard:
              return !1;
            default:
              throw Error(`Unknown extension type: ${k}`);
          }
        }
        e.isMintExtension = m;
        function w(k) {
          switch (k) {
            case y.TransferFeeAmount:
            case y.ConfidentialTransferAccount:
            case y.ImmutableOwner:
            case y.MemoTransfer:
            case y.CpiGuard:
              return !0;
            case y.Uninitialized:
            case y.TransferFeeConfig:
            case y.MintCloseAuthority:
            case y.ConfidentialTransferMint:
            case y.DefaultAccountState:
            case y.NonTransferable:
            case y.InterestBearingConfig:
            case y.PermanentDelegate:
              return !1;
            default:
              throw Error(`Unknown extension type: ${k}`);
          }
        }
        e.isAccountExtension = w;
        function _(k) {
          switch (k) {
            case y.TransferFeeConfig:
              return y.TransferFeeAmount;
            case y.ConfidentialTransferMint:
              return y.ConfidentialTransferAccount;
            case y.TransferFeeAmount:
            case y.ConfidentialTransferAccount:
            case y.CpiGuard:
            case y.DefaultAccountState:
            case y.ImmutableOwner:
            case y.MemoTransfer:
            case y.MintCloseAuthority:
            case y.NonTransferable:
            case y.Uninitialized:
            case y.InterestBearingConfig:
            case y.PermanentDelegate:
              return y.Uninitialized;
          }
        }
        e.getAccountTypeOfMintType = _;
        function S(k, K) {
          if (k.length === 0) return K;
          {
            const M =
              t.ACCOUNT_SIZE +
              i.ACCOUNT_TYPE_SIZE +
              k
                .filter((C, z) => z === k.indexOf(C))
                .map((C) => b(C) + e.TYPE_SIZE + e.LENGTH_SIZE)
                .reduce((C, z) => C + z);
            return M === r.MULTISIG_SIZE ? M + e.TYPE_SIZE : M;
          }
        }
        function E(k) {
          return S(k, n.MINT_SIZE);
        }
        e.getMintLen = E;
        function O(k) {
          return S(k, t.ACCOUNT_SIZE);
        }
        e.getAccountLen = O;
        function N(k, K) {
          let M = 0;
          for (; M + e.TYPE_SIZE + e.LENGTH_SIZE <= K.length; ) {
            const C = K.readUInt16LE(M),
              z = K.readUInt16LE(M + e.TYPE_SIZE),
              I = M + e.TYPE_SIZE + e.LENGTH_SIZE;
            if (C == k) return K.slice(I, I + z);
            M = I + z;
          }
          return null;
        }
        e.getExtensionData = N;
        function F(k) {
          const K = [];
          let M = 0;
          for (; M < k.length; ) {
            const C = k.readUInt16LE(M);
            K.push(C);
            const z = k.readUInt16LE(M + e.TYPE_SIZE);
            M += e.TYPE_SIZE + e.LENGTH_SIZE + z;
          }
          return K;
        }
        e.getExtensionTypes = F;
        function D(k) {
          const M = F(k.tlvData).map(_);
          return O(M);
        }
        e.getAccountLenForMint = D;
      })(hb)),
    hb
  );
}
var Sf = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeInitializeAccountInstructionUnchecked =
      e.decodeInitializeAccountInstruction =
      e.createInitializeAccountInstruction =
      e.initializeAccountInstructionData =
        void 0);
  const t = xe,
    n = V,
    r = ye,
    i = be,
    o = Ze;
  e.initializeAccountInstructionData = (0, t.struct)([(0, t.u8)('instruction')]);
  function a(l, u, d, f = r.TOKEN_PROGRAM_ID) {
    const p = [
        { pubkey: l, isSigner: !1, isWritable: !0 },
        { pubkey: u, isSigner: !1, isWritable: !1 },
        { pubkey: d, isSigner: !1, isWritable: !1 },
        { pubkey: n.SYSVAR_RENT_PUBKEY, isSigner: !1, isWritable: !1 },
      ],
      y = Y.alloc(e.initializeAccountInstructionData.span);
    return (
      e.initializeAccountInstructionData.encode(
        { instruction: o.TokenInstruction.InitializeAccount },
        y
      ),
      new n.TransactionInstruction({ keys: p, programId: f, data: y })
    );
  }
  e.createInitializeAccountInstruction = a;
  function c(l, u = r.TOKEN_PROGRAM_ID) {
    if (!l.programId.equals(u)) throw new i.TokenInvalidInstructionProgramError();
    if (l.data.length !== e.initializeAccountInstructionData.span)
      throw new i.TokenInvalidInstructionDataError();
    const {
      keys: { account: d, mint: f, owner: p, rent: y },
      data: b,
    } = s(l);
    if (b.instruction !== o.TokenInstruction.InitializeAccount)
      throw new i.TokenInvalidInstructionTypeError();
    if (!d || !f || !p || !y) throw new i.TokenInvalidInstructionKeysError();
    return { programId: u, keys: { account: d, mint: f, owner: p, rent: y }, data: b };
  }
  e.decodeInitializeAccountInstruction = c;
  function s({ programId: l, keys: [u, d, f, p], data: y }) {
    return {
      programId: l,
      keys: { account: u, mint: d, owner: f, rent: p },
      data: e.initializeAccountInstructionData.decode(y),
    };
  }
  e.decodeInitializeAccountInstructionUnchecked = s;
})(Sf);
var Af = {},
  Wr = {};
Object.defineProperty(Wr, '__esModule', { value: !0 });
Wr.createAssociatedTokenAccountIdempotentInstruction = Wr.createAssociatedTokenAccountInstruction =
  void 0;
const vv = V,
  ts = ye;
function sF(e, t, n, r, i = ts.TOKEN_PROGRAM_ID, o = ts.ASSOCIATED_TOKEN_PROGRAM_ID) {
  return Lk(e, t, n, r, Y.alloc(0), i, o);
}
Wr.createAssociatedTokenAccountInstruction = sF;
function cF(e, t, n, r, i = ts.TOKEN_PROGRAM_ID, o = ts.ASSOCIATED_TOKEN_PROGRAM_ID) {
  return Lk(e, t, n, r, Y.from([1]), i, o);
}
Wr.createAssociatedTokenAccountIdempotentInstruction = cF;
function Lk(e, t, n, r, i, o = ts.TOKEN_PROGRAM_ID, a = ts.ASSOCIATED_TOKEN_PROGRAM_ID) {
  const c = [
    { pubkey: e, isSigner: !0, isWritable: !0 },
    { pubkey: t, isSigner: !1, isWritable: !0 },
    { pubkey: n, isSigner: !1, isWritable: !1 },
    { pubkey: r, isSigner: !1, isWritable: !1 },
    { pubkey: vv.SystemProgram.programId, isSigner: !1, isWritable: !1 },
    { pubkey: o, isSigner: !1, isWritable: !1 },
  ];
  return new vv.TransactionInstruction({ keys: c, programId: a, data: i });
}
var uF =
  (g && g.__awaiter) ||
  function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (a) {
            a(o);
          });
    }
    return new (n || (n = Promise))(function (o, a) {
      function c(u) {
        try {
          l(r.next(u));
        } catch (d) {
          a(d);
        }
      }
      function s(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          a(d);
        }
      }
      function l(u) {
        u.done ? o(u.value) : i(u.value).then(c, s);
      }
      l((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(Af, '__esModule', { value: !0 });
Af.createAssociatedTokenAccount = void 0;
const Sv = V,
  Av = ye,
  lF = Wr,
  dF = ho();
function fF(e, t, n, r, i, o = Av.TOKEN_PROGRAM_ID, a = Av.ASSOCIATED_TOKEN_PROGRAM_ID) {
  return uF(this, void 0, void 0, function* () {
    const c = yield (0, dF.getAssociatedTokenAddress)(n, r, !1, o, a),
      s = new Sv.Transaction().add(
        (0, lF.createAssociatedTokenAccountInstruction)(t.publicKey, c, r, n, o, a)
      );
    return yield (0, Sv.sendAndConfirmTransaction)(e, s, [t], i), c;
  });
}
Af.createAssociatedTokenAccount = fF;
var hF =
  (g && g.__awaiter) ||
  function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (a) {
            a(o);
          });
    }
    return new (n || (n = Promise))(function (o, a) {
      function c(u) {
        try {
          l(r.next(u));
        } catch (d) {
          a(d);
        }
      }
      function s(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          a(d);
        }
      }
      function l(u) {
        u.done ? o(u.value) : i(u.value).then(c, s);
      }
      l((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(wf, '__esModule', { value: !0 });
wf.createAccount = void 0;
const Mb = V,
  pF = ye,
  gF = On(),
  yF = Sf,
  bF = ho(),
  mF = Af;
function wF(e, t, n, r, i, o, a = pF.TOKEN_PROGRAM_ID) {
  return hF(this, void 0, void 0, function* () {
    if (!i) return yield (0, mF.createAssociatedTokenAccount)(e, t, n, r, o, a);
    const c = yield (0, bF.getMint)(e, n, o == null ? void 0 : o.commitment, a),
      s = (0, gF.getAccountLenForMint)(c),
      l = yield e.getMinimumBalanceForRentExemption(s),
      u = new Mb.Transaction().add(
        Mb.SystemProgram.createAccount({
          fromPubkey: t.publicKey,
          newAccountPubkey: i.publicKey,
          space: s,
          lamports: l,
          programId: a,
        }),
        (0, yF.createInitializeAccountInstruction)(i.publicKey, n, r, a)
      );
    return yield (0, Mb.sendAndConfirmTransaction)(e, u, [t, i], o), i.publicKey;
  });
}
wf.createAccount = wF;
var Eg = {},
  _F =
    (g && g.__awaiter) ||
    function (e, t, n, r) {
      function i(o) {
        return o instanceof n
          ? o
          : new n(function (a) {
              a(o);
            });
      }
      return new (n || (n = Promise))(function (o, a) {
        function c(u) {
          try {
            l(r.next(u));
          } catch (d) {
            a(d);
          }
        }
        function s(u) {
          try {
            l(r.throw(u));
          } catch (d) {
            a(d);
          }
        }
        function l(u) {
          u.done ? o(u.value) : i(u.value).then(c, s);
        }
        l((r = r.apply(e, t || [])).next());
      });
    };
Object.defineProperty(Eg, '__esModule', { value: !0 });
Eg.createAssociatedTokenAccountIdempotent = void 0;
const Iv = V,
  Ev = ye,
  vF = Wr,
  SF = ho();
function AF(e, t, n, r, i, o = Ev.TOKEN_PROGRAM_ID, a = Ev.ASSOCIATED_TOKEN_PROGRAM_ID) {
  return _F(this, void 0, void 0, function* () {
    const c = yield (0, SF.getAssociatedTokenAddress)(n, r, !1, o, a),
      s = new Iv.Transaction().add(
        (0, vF.createAssociatedTokenAccountIdempotentInstruction)(t.publicKey, c, r, n, o, a)
      );
    return yield (0, Iv.sendAndConfirmTransaction)(e, s, [t], i), c;
  });
}
Eg.createAssociatedTokenAccountIdempotent = AF;
var Tg = {},
  kg = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeInitializeMint2InstructionUnchecked =
      e.decodeInitializeMint2Instruction =
      e.createInitializeMint2Instruction =
      e.initializeMint2InstructionData =
        void 0);
  const t = xe,
    n = gt,
    r = V,
    i = ye,
    o = be,
    a = Ze;
  e.initializeMint2InstructionData = (0, t.struct)([
    (0, t.u8)('instruction'),
    (0, t.u8)('decimals'),
    (0, n.publicKey)('mintAuthority'),
    (0, t.u8)('freezeAuthorityOption'),
    (0, n.publicKey)('freezeAuthority'),
  ]);
  function c(u, d, f, p, y = i.TOKEN_PROGRAM_ID) {
    const b = [{ pubkey: u, isSigner: !1, isWritable: !0 }],
      m = Y.alloc(e.initializeMint2InstructionData.span);
    return (
      e.initializeMint2InstructionData.encode(
        {
          instruction: a.TokenInstruction.InitializeMint2,
          decimals: d,
          mintAuthority: f,
          freezeAuthorityOption: p ? 1 : 0,
          freezeAuthority: p || new r.PublicKey(0),
        },
        m
      ),
      new r.TransactionInstruction({ keys: b, programId: y, data: m })
    );
  }
  e.createInitializeMint2Instruction = c;
  function s(u, d = i.TOKEN_PROGRAM_ID) {
    if (!u.programId.equals(d)) throw new o.TokenInvalidInstructionProgramError();
    if (u.data.length !== e.initializeMint2InstructionData.span)
      throw new o.TokenInvalidInstructionDataError();
    const {
      keys: { mint: f },
      data: p,
    } = l(u);
    if (p.instruction !== a.TokenInstruction.InitializeMint2)
      throw new o.TokenInvalidInstructionTypeError();
    if (!f) throw new o.TokenInvalidInstructionKeysError();
    return { programId: d, keys: { mint: f }, data: p };
  }
  e.decodeInitializeMint2Instruction = s;
  function l({ programId: u, keys: [d], data: f }) {
    const {
      instruction: p,
      decimals: y,
      mintAuthority: b,
      freezeAuthorityOption: m,
      freezeAuthority: w,
    } = e.initializeMint2InstructionData.decode(f);
    return {
      programId: u,
      keys: { mint: d },
      data: { instruction: p, decimals: y, mintAuthority: b, freezeAuthority: m ? w : null },
    };
  }
  e.decodeInitializeMint2InstructionUnchecked = l;
})(kg);
var IF =
  (g && g.__awaiter) ||
  function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (a) {
            a(o);
          });
    }
    return new (n || (n = Promise))(function (o, a) {
      function c(u) {
        try {
          l(r.next(u));
        } catch (d) {
          a(d);
        }
      }
      function s(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          a(d);
        }
      }
      function l(u) {
        u.done ? o(u.value) : i(u.value).then(c, s);
      }
      l((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(Tg, '__esModule', { value: !0 });
Tg.createMint = void 0;
const th = V,
  EF = ye,
  TF = kg,
  Tv = ho();
function kF(e, t, n, r, i, o = th.Keypair.generate(), a, c = EF.TOKEN_PROGRAM_ID) {
  return IF(this, void 0, void 0, function* () {
    const s = yield (0, Tv.getMinimumBalanceForRentExemptMint)(e),
      l = new th.Transaction().add(
        th.SystemProgram.createAccount({
          fromPubkey: t.publicKey,
          newAccountPubkey: o.publicKey,
          space: Tv.MINT_SIZE,
          lamports: s,
          programId: c,
        }),
        (0, TF.createInitializeMint2Instruction)(o.publicKey, i, n, r, c)
      );
    return yield (0, th.sendAndConfirmTransaction)(e, l, [t, o], a), o.publicKey;
  });
}
Tg.createMint = kF;
var Cg = {},
  Mg = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeInitializeMultisigInstructionUnchecked =
      e.decodeInitializeMultisigInstruction =
      e.createInitializeMultisigInstruction =
      e.initializeMultisigInstructionData =
        void 0);
  const t = xe,
    n = V,
    r = ye,
    i = be,
    o = Ze;
  e.initializeMultisigInstructionData = (0, t.struct)([(0, t.u8)('instruction'), (0, t.u8)('m')]);
  function a(l, u, d, f = r.TOKEN_PROGRAM_ID) {
    const p = [
      { pubkey: l, isSigner: !1, isWritable: !0 },
      { pubkey: n.SYSVAR_RENT_PUBKEY, isSigner: !1, isWritable: !1 },
    ];
    for (const b of u)
      p.push({ pubkey: b instanceof n.PublicKey ? b : b.publicKey, isSigner: !1, isWritable: !1 });
    const y = Y.alloc(e.initializeMultisigInstructionData.span);
    return (
      e.initializeMultisigInstructionData.encode(
        { instruction: o.TokenInstruction.InitializeMultisig, m: d },
        y
      ),
      new n.TransactionInstruction({ keys: p, programId: f, data: y })
    );
  }
  e.createInitializeMultisigInstruction = a;
  function c(l, u = r.TOKEN_PROGRAM_ID) {
    if (!l.programId.equals(u)) throw new i.TokenInvalidInstructionProgramError();
    if (l.data.length !== e.initializeMultisigInstructionData.span)
      throw new i.TokenInvalidInstructionDataError();
    const {
      keys: { account: d, rent: f, signers: p },
      data: y,
    } = s(l);
    if (y.instruction !== o.TokenInstruction.InitializeMultisig)
      throw new i.TokenInvalidInstructionTypeError();
    if (!d || !f || !p.length) throw new i.TokenInvalidInstructionKeysError();
    return { programId: u, keys: { account: d, rent: f, signers: p }, data: y };
  }
  e.decodeInitializeMultisigInstruction = c;
  function s({ programId: l, keys: [u, d, ...f], data: p }) {
    return {
      programId: l,
      keys: { account: u, rent: d, signers: f },
      data: e.initializeMultisigInstructionData.decode(p),
    };
  }
  e.decodeInitializeMultisigInstructionUnchecked = s;
})(Mg);
var CF =
  (g && g.__awaiter) ||
  function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (a) {
            a(o);
          });
    }
    return new (n || (n = Promise))(function (o, a) {
      function c(u) {
        try {
          l(r.next(u));
        } catch (d) {
          a(d);
        }
      }
      function s(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          a(d);
        }
      }
      function l(u) {
        u.done ? o(u.value) : i(u.value).then(c, s);
      }
      l((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(Cg, '__esModule', { value: !0 });
Cg.createMultisig = void 0;
const nh = V,
  MF = ye,
  PF = Mg,
  kv = Ss;
function OF(e, t, n, r, i = nh.Keypair.generate(), o, a = MF.TOKEN_PROGRAM_ID) {
  return CF(this, void 0, void 0, function* () {
    const c = yield (0, kv.getMinimumBalanceForRentExemptMultisig)(e),
      s = new nh.Transaction().add(
        nh.SystemProgram.createAccount({
          fromPubkey: t.publicKey,
          newAccountPubkey: i.publicKey,
          space: kv.MULTISIG_SIZE,
          lamports: c,
          programId: a,
        }),
        (0, PF.createInitializeMultisigInstruction)(i.publicKey, n, r, a)
      );
    return yield (0, nh.sendAndConfirmTransaction)(e, s, [t, i], o), i.publicKey;
  });
}
Cg.createMultisig = OF;
var Pg = {},
  N1 = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createCreateNativeMintInstruction = e.createNativeMintInstructionData = void 0);
  const t = xe,
    n = V,
    r = ye,
    i = be,
    o = Ze;
  e.createNativeMintInstructionData = (0, t.struct)([(0, t.u8)('instruction')]);
  function a(c, s = r.NATIVE_MINT_2022, l = r.TOKEN_2022_PROGRAM_ID) {
    if (!(0, r.programSupportsExtensions)(l)) throw new i.TokenUnsupportedInstructionError();
    const u = [
        { pubkey: c, isSigner: !0, isWritable: !0 },
        { pubkey: s, isSigner: !1, isWritable: !0 },
        { pubkey: n.SystemProgram.programId, isSigner: !1, isWritable: !1 },
      ],
      d = Y.alloc(e.createNativeMintInstructionData.span);
    return (
      e.createNativeMintInstructionData.encode(
        { instruction: o.TokenInstruction.CreateNativeMint },
        d
      ),
      new n.TransactionInstruction({ keys: u, programId: l, data: d })
    );
  }
  e.createCreateNativeMintInstruction = a;
})(N1);
var DF =
  (g && g.__awaiter) ||
  function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (a) {
            a(o);
          });
    }
    return new (n || (n = Promise))(function (o, a) {
      function c(u) {
        try {
          l(r.next(u));
        } catch (d) {
          a(d);
        }
      }
      function s(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          a(d);
        }
      }
      function l(u) {
        u.done ? o(u.value) : i(u.value).then(c, s);
      }
      l((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(Pg, '__esModule', { value: !0 });
Pg.createNativeMint = void 0;
const Cv = V,
  Mv = ye,
  RF = N1;
function xF(e, t, n, r = Mv.NATIVE_MINT_2022, i = Mv.TOKEN_2022_PROGRAM_ID) {
  return DF(this, void 0, void 0, function* () {
    const o = new Cv.Transaction().add(
      (0, RF.createCreateNativeMintInstruction)(t.publicKey, r, i)
    );
    yield (0, Cv.sendAndConfirmTransaction)(e, o, [t], n);
  });
}
Pg.createNativeMint = xF;
var Og = {},
  If = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeSyncNativeInstructionUnchecked =
      e.decodeSyncNativeInstruction =
      e.createSyncNativeInstruction =
      e.syncNativeInstructionData =
        void 0);
  const t = xe,
    n = V,
    r = ye,
    i = be,
    o = Ze;
  e.syncNativeInstructionData = (0, t.struct)([(0, t.u8)('instruction')]);
  function a(l, u = r.TOKEN_PROGRAM_ID) {
    const d = [{ pubkey: l, isSigner: !1, isWritable: !0 }],
      f = Y.alloc(e.syncNativeInstructionData.span);
    return (
      e.syncNativeInstructionData.encode({ instruction: o.TokenInstruction.SyncNative }, f),
      new n.TransactionInstruction({ keys: d, programId: u, data: f })
    );
  }
  e.createSyncNativeInstruction = a;
  function c(l, u = r.TOKEN_PROGRAM_ID) {
    if (!l.programId.equals(u)) throw new i.TokenInvalidInstructionProgramError();
    if (l.data.length !== e.syncNativeInstructionData.span)
      throw new i.TokenInvalidInstructionDataError();
    const {
      keys: { account: d },
      data: f,
    } = s(l);
    if (f.instruction !== o.TokenInstruction.SyncNative)
      throw new i.TokenInvalidInstructionTypeError();
    if (!d) throw new i.TokenInvalidInstructionKeysError();
    return { programId: u, keys: { account: d }, data: f };
  }
  e.decodeSyncNativeInstruction = c;
  function s({ programId: l, keys: [u], data: d }) {
    return { programId: l, keys: { account: u }, data: e.syncNativeInstructionData.decode(d) };
  }
  e.decodeSyncNativeInstructionUnchecked = s;
})(If);
var BF =
  (g && g.__awaiter) ||
  function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (a) {
            a(o);
          });
    }
    return new (n || (n = Promise))(function (o, a) {
      function c(u) {
        try {
          l(r.next(u));
        } catch (d) {
          a(d);
        }
      }
      function s(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          a(d);
        }
      }
      function l(u) {
        u.done ? o(u.value) : i(u.value).then(c, s);
      }
      l((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(Og, '__esModule', { value: !0 });
Og.createWrappedNativeAccount = void 0;
const mo = V,
  rh = ye,
  jF = Wr,
  NF = Sf,
  UF = If,
  Pv = vf(),
  LF = ho(),
  zF = wf;
function FF(e, t, n, r, i, o, a = rh.TOKEN_PROGRAM_ID, c = rh.NATIVE_MINT) {
  return BF(this, void 0, void 0, function* () {
    if (!r) return yield (0, zF.createAccount)(e, t, c, n, i, o, a);
    if (!i) {
      const u = yield (0, LF.getAssociatedTokenAddress)(
          c,
          n,
          !1,
          a,
          rh.ASSOCIATED_TOKEN_PROGRAM_ID
        ),
        d = new mo.Transaction().add(
          (0, jF.createAssociatedTokenAccountInstruction)(
            t.publicKey,
            u,
            n,
            c,
            a,
            rh.ASSOCIATED_TOKEN_PROGRAM_ID
          ),
          mo.SystemProgram.transfer({ fromPubkey: t.publicKey, toPubkey: u, lamports: r }),
          (0, UF.createSyncNativeInstruction)(u, a)
        );
      return yield (0, mo.sendAndConfirmTransaction)(e, d, [t], o), u;
    }
    const s = yield (0, Pv.getMinimumBalanceForRentExemptAccount)(e),
      l = new mo.Transaction().add(
        mo.SystemProgram.createAccount({
          fromPubkey: t.publicKey,
          newAccountPubkey: i.publicKey,
          space: Pv.ACCOUNT_SIZE,
          lamports: s,
          programId: a,
        }),
        mo.SystemProgram.transfer({ fromPubkey: t.publicKey, toPubkey: i.publicKey, lamports: r }),
        (0, NF.createInitializeAccountInstruction)(i.publicKey, c, n, a)
      );
    return yield (0, mo.sendAndConfirmTransaction)(e, l, [t, i], o), i.publicKey;
  });
}
Og.createWrappedNativeAccount = FF;
var Dg = {},
  Rg = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeFreezeAccountInstructionUnchecked =
      e.decodeFreezeAccountInstruction =
      e.createFreezeAccountInstruction =
      e.freezeAccountInstructionData =
        void 0);
  const t = xe,
    n = V,
    r = ye,
    i = be,
    o = xt,
    a = Ze;
  e.freezeAccountInstructionData = (0, t.struct)([(0, t.u8)('instruction')]);
  function c(u, d, f, p = [], y = r.TOKEN_PROGRAM_ID) {
    const b = (0, o.addSigners)(
        [
          { pubkey: u, isSigner: !1, isWritable: !0 },
          { pubkey: d, isSigner: !1, isWritable: !1 },
        ],
        f,
        p
      ),
      m = Y.alloc(e.freezeAccountInstructionData.span);
    return (
      e.freezeAccountInstructionData.encode({ instruction: a.TokenInstruction.FreezeAccount }, m),
      new n.TransactionInstruction({ keys: b, programId: y, data: m })
    );
  }
  e.createFreezeAccountInstruction = c;
  function s(u, d = r.TOKEN_PROGRAM_ID) {
    if (!u.programId.equals(d)) throw new i.TokenInvalidInstructionProgramError();
    if (u.data.length !== e.freezeAccountInstructionData.span)
      throw new i.TokenInvalidInstructionDataError();
    const {
      keys: { account: f, mint: p, authority: y, multiSigners: b },
      data: m,
    } = l(u);
    if (m.instruction !== a.TokenInstruction.FreezeAccount)
      throw new i.TokenInvalidInstructionTypeError();
    if (!f || !p || !y) throw new i.TokenInvalidInstructionKeysError();
    return { programId: d, keys: { account: f, mint: p, authority: y, multiSigners: b }, data: m };
  }
  e.decodeFreezeAccountInstruction = s;
  function l({ programId: u, keys: [d, f, p, ...y], data: b }) {
    return {
      programId: u,
      keys: { account: d, mint: f, authority: p, multiSigners: y },
      data: e.freezeAccountInstructionData.decode(b),
    };
  }
  e.decodeFreezeAccountInstructionUnchecked = l;
})(Rg);
var $F =
  (g && g.__awaiter) ||
  function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (a) {
            a(o);
          });
    }
    return new (n || (n = Promise))(function (o, a) {
      function c(u) {
        try {
          l(r.next(u));
        } catch (d) {
          a(d);
        }
      }
      function s(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          a(d);
        }
      }
      function l(u) {
        u.done ? o(u.value) : i(u.value).then(c, s);
      }
      l((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(Dg, '__esModule', { value: !0 });
Dg.freezeAccount = void 0;
const Ov = V,
  WF = ye,
  VF = Rg,
  KF = Bt;
function HF(e, t, n, r, i, o = [], a, c = WF.TOKEN_PROGRAM_ID) {
  return $F(this, void 0, void 0, function* () {
    const [s, l] = (0, KF.getSigners)(i, o),
      u = new Ov.Transaction().add((0, VF.createFreezeAccountInstruction)(n, r, s, o, c));
    return yield (0, Ov.sendAndConfirmTransaction)(e, u, [t, ...l], a);
  });
}
Dg.freezeAccount = HF;
var xg = {},
  qF =
    (g && g.__awaiter) ||
    function (e, t, n, r) {
      function i(o) {
        return o instanceof n
          ? o
          : new n(function (a) {
              a(o);
            });
      }
      return new (n || (n = Promise))(function (o, a) {
        function c(u) {
          try {
            l(r.next(u));
          } catch (d) {
            a(d);
          }
        }
        function s(u) {
          try {
            l(r.throw(u));
          } catch (d) {
            a(d);
          }
        }
        function l(u) {
          u.done ? o(u.value) : i(u.value).then(c, s);
        }
        l((r = r.apply(e, t || [])).next());
      });
    };
Object.defineProperty(xg, '__esModule', { value: !0 });
xg.getOrCreateAssociatedTokenAccount = void 0;
const Dv = V,
  Rv = ye,
  ih = be,
  GF = Wr,
  xv = vf(),
  YF = ho();
function ZF(e, t, n, r, i = !1, o, a, c = Rv.TOKEN_PROGRAM_ID, s = Rv.ASSOCIATED_TOKEN_PROGRAM_ID) {
  return qF(this, void 0, void 0, function* () {
    const l = yield (0, YF.getAssociatedTokenAddress)(n, r, i, c, s);
    let u;
    try {
      u = yield (0, xv.getAccount)(e, l, o, c);
    } catch (d) {
      if (
        d instanceof ih.TokenAccountNotFoundError ||
        d instanceof ih.TokenInvalidAccountOwnerError
      ) {
        try {
          const f = new Dv.Transaction().add(
            (0, GF.createAssociatedTokenAccountInstruction)(t.publicKey, l, r, n, c, s)
          );
          yield (0, Dv.sendAndConfirmTransaction)(e, f, [t], a);
        } catch {}
        u = yield (0, xv.getAccount)(e, l, o, c);
      } else throw d;
    }
    if (!u.mint.equals(n)) throw new ih.TokenInvalidMintError();
    if (!u.owner.equals(r)) throw new ih.TokenInvalidOwnerError();
    return u;
  });
}
xg.getOrCreateAssociatedTokenAccount = ZF;
var Bg = {},
  jg = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeMintToInstructionUnchecked =
      e.decodeMintToInstruction =
      e.createMintToInstruction =
      e.mintToInstructionData =
        void 0);
  const t = xe,
    n = gt,
    r = V,
    i = ye,
    o = be,
    a = xt,
    c = Ze;
  e.mintToInstructionData = (0, t.struct)([(0, t.u8)('instruction'), (0, n.u64)('amount')]);
  function s(d, f, p, y, b = [], m = i.TOKEN_PROGRAM_ID) {
    const w = (0, a.addSigners)(
        [
          { pubkey: d, isSigner: !1, isWritable: !0 },
          { pubkey: f, isSigner: !1, isWritable: !0 },
        ],
        p,
        b
      ),
      _ = Y.alloc(e.mintToInstructionData.span);
    return (
      e.mintToInstructionData.encode(
        { instruction: c.TokenInstruction.MintTo, amount: BigInt(y) },
        _
      ),
      new r.TransactionInstruction({ keys: w, programId: m, data: _ })
    );
  }
  e.createMintToInstruction = s;
  function l(d, f = i.TOKEN_PROGRAM_ID) {
    if (!d.programId.equals(f)) throw new o.TokenInvalidInstructionProgramError();
    if (d.data.length !== e.mintToInstructionData.span)
      throw new o.TokenInvalidInstructionDataError();
    const {
      keys: { mint: p, destination: y, authority: b, multiSigners: m },
      data: w,
    } = u(d);
    if (w.instruction !== c.TokenInstruction.MintTo) throw new o.TokenInvalidInstructionTypeError();
    if (!p || !y || !b) throw new o.TokenInvalidInstructionKeysError();
    return {
      programId: f,
      keys: { mint: p, destination: y, authority: b, multiSigners: m },
      data: w,
    };
  }
  e.decodeMintToInstruction = l;
  function u({ programId: d, keys: [f, p, y, ...b], data: m }) {
    return {
      programId: d,
      keys: { mint: f, destination: p, authority: y, multiSigners: b },
      data: e.mintToInstructionData.decode(m),
    };
  }
  e.decodeMintToInstructionUnchecked = u;
})(jg);
var QF =
  (g && g.__awaiter) ||
  function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (a) {
            a(o);
          });
    }
    return new (n || (n = Promise))(function (o, a) {
      function c(u) {
        try {
          l(r.next(u));
        } catch (d) {
          a(d);
        }
      }
      function s(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          a(d);
        }
      }
      function l(u) {
        u.done ? o(u.value) : i(u.value).then(c, s);
      }
      l((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(Bg, '__esModule', { value: !0 });
Bg.mintTo = void 0;
const Bv = V,
  JF = ye,
  XF = jg,
  e$ = Bt;
function t$(e, t, n, r, i, o, a = [], c, s = JF.TOKEN_PROGRAM_ID) {
  return QF(this, void 0, void 0, function* () {
    const [l, u] = (0, e$.getSigners)(i, a),
      d = new Bv.Transaction().add((0, XF.createMintToInstruction)(n, r, l, o, a, s));
    return yield (0, Bv.sendAndConfirmTransaction)(e, d, [t, ...u], c);
  });
}
Bg.mintTo = t$;
var Ng = {},
  Ug = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeMintToCheckedInstructionUnchecked =
      e.decodeMintToCheckedInstruction =
      e.createMintToCheckedInstruction =
      e.mintToCheckedInstructionData =
        void 0);
  const t = xe,
    n = gt,
    r = V,
    i = ye,
    o = be,
    a = xt,
    c = Ze;
  e.mintToCheckedInstructionData = (0, t.struct)([
    (0, t.u8)('instruction'),
    (0, n.u64)('amount'),
    (0, t.u8)('decimals'),
  ]);
  function s(d, f, p, y, b, m = [], w = i.TOKEN_PROGRAM_ID) {
    const _ = (0, a.addSigners)(
        [
          { pubkey: d, isSigner: !1, isWritable: !0 },
          { pubkey: f, isSigner: !1, isWritable: !0 },
        ],
        p,
        m
      ),
      S = Y.alloc(e.mintToCheckedInstructionData.span);
    return (
      e.mintToCheckedInstructionData.encode(
        { instruction: c.TokenInstruction.MintToChecked, amount: BigInt(y), decimals: b },
        S
      ),
      new r.TransactionInstruction({ keys: _, programId: w, data: S })
    );
  }
  e.createMintToCheckedInstruction = s;
  function l(d, f = i.TOKEN_PROGRAM_ID) {
    if (!d.programId.equals(f)) throw new o.TokenInvalidInstructionProgramError();
    if (d.data.length !== e.mintToCheckedInstructionData.span)
      throw new o.TokenInvalidInstructionDataError();
    const {
      keys: { mint: p, destination: y, authority: b, multiSigners: m },
      data: w,
    } = u(d);
    if (w.instruction !== c.TokenInstruction.MintToChecked)
      throw new o.TokenInvalidInstructionTypeError();
    if (!p || !y || !b) throw new o.TokenInvalidInstructionKeysError();
    return {
      programId: f,
      keys: { mint: p, destination: y, authority: b, multiSigners: m },
      data: w,
    };
  }
  e.decodeMintToCheckedInstruction = l;
  function u({ programId: d, keys: [f, p, y, ...b], data: m }) {
    return {
      programId: d,
      keys: { mint: f, destination: p, authority: y, multiSigners: b },
      data: e.mintToCheckedInstructionData.decode(m),
    };
  }
  e.decodeMintToCheckedInstructionUnchecked = u;
})(Ug);
var n$ =
  (g && g.__awaiter) ||
  function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (a) {
            a(o);
          });
    }
    return new (n || (n = Promise))(function (o, a) {
      function c(u) {
        try {
          l(r.next(u));
        } catch (d) {
          a(d);
        }
      }
      function s(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          a(d);
        }
      }
      function l(u) {
        u.done ? o(u.value) : i(u.value).then(c, s);
      }
      l((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(Ng, '__esModule', { value: !0 });
Ng.mintToChecked = void 0;
const jv = V,
  r$ = ye,
  i$ = Ug,
  o$ = Bt;
function a$(e, t, n, r, i, o, a, c = [], s, l = r$.TOKEN_PROGRAM_ID) {
  return n$(this, void 0, void 0, function* () {
    const [u, d] = (0, o$.getSigners)(i, c),
      f = new jv.Transaction().add((0, i$.createMintToCheckedInstruction)(n, r, u, o, a, c, l));
    return yield (0, jv.sendAndConfirmTransaction)(e, f, [t, ...d], s);
  });
}
Ng.mintToChecked = a$;
var Lg = {},
  zg = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeRevokeInstructionUnchecked =
      e.decodeRevokeInstruction =
      e.createRevokeInstruction =
      e.revokeInstructionData =
        void 0);
  const t = xe,
    n = V,
    r = ye,
    i = be,
    o = xt,
    a = Ze;
  e.revokeInstructionData = (0, t.struct)([(0, t.u8)('instruction')]);
  function c(u, d, f = [], p = r.TOKEN_PROGRAM_ID) {
    const y = (0, o.addSigners)([{ pubkey: u, isSigner: !1, isWritable: !0 }], d, f),
      b = Y.alloc(e.revokeInstructionData.span);
    return (
      e.revokeInstructionData.encode({ instruction: a.TokenInstruction.Revoke }, b),
      new n.TransactionInstruction({ keys: y, programId: p, data: b })
    );
  }
  e.createRevokeInstruction = c;
  function s(u, d = r.TOKEN_PROGRAM_ID) {
    if (!u.programId.equals(d)) throw new i.TokenInvalidInstructionProgramError();
    if (u.data.length !== e.revokeInstructionData.span)
      throw new i.TokenInvalidInstructionDataError();
    const {
      keys: { account: f, owner: p, multiSigners: y },
      data: b,
    } = l(u);
    if (b.instruction !== a.TokenInstruction.Revoke) throw new i.TokenInvalidInstructionTypeError();
    if (!f || !p) throw new i.TokenInvalidInstructionKeysError();
    return { programId: d, keys: { account: f, owner: p, multiSigners: y }, data: b };
  }
  e.decodeRevokeInstruction = s;
  function l({ programId: u, keys: [d, f, ...p], data: y }) {
    return {
      programId: u,
      keys: { account: d, owner: f, multiSigners: p },
      data: e.revokeInstructionData.decode(y),
    };
  }
  e.decodeRevokeInstructionUnchecked = l;
})(zg);
var s$ =
  (g && g.__awaiter) ||
  function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (a) {
            a(o);
          });
    }
    return new (n || (n = Promise))(function (o, a) {
      function c(u) {
        try {
          l(r.next(u));
        } catch (d) {
          a(d);
        }
      }
      function s(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          a(d);
        }
      }
      function l(u) {
        u.done ? o(u.value) : i(u.value).then(c, s);
      }
      l((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(Lg, '__esModule', { value: !0 });
Lg.revoke = void 0;
const Nv = V,
  c$ = ye,
  u$ = zg,
  l$ = Bt;
function d$(e, t, n, r, i = [], o, a = c$.TOKEN_PROGRAM_ID) {
  return s$(this, void 0, void 0, function* () {
    const [c, s] = (0, l$.getSigners)(r, i),
      l = new Nv.Transaction().add((0, u$.createRevokeInstruction)(n, c, i, a));
    return yield (0, Nv.sendAndConfirmTransaction)(e, l, [t, ...s], o);
  });
}
Lg.revoke = d$;
var Fg = {},
  $g = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeSetAuthorityInstructionUnchecked =
      e.decodeSetAuthorityInstruction =
      e.createSetAuthorityInstruction =
      e.setAuthorityInstructionData =
      e.AuthorityType =
        void 0);
  const t = xe,
    n = gt,
    r = V,
    i = ye,
    o = be,
    a = xt,
    c = Ze;
  (function (d) {
    (d[(d.MintTokens = 0)] = 'MintTokens'),
      (d[(d.FreezeAccount = 1)] = 'FreezeAccount'),
      (d[(d.AccountOwner = 2)] = 'AccountOwner'),
      (d[(d.CloseAccount = 3)] = 'CloseAccount');
  })(e.AuthorityType || (e.AuthorityType = {})),
    (e.setAuthorityInstructionData = (0, t.struct)([
      (0, t.u8)('instruction'),
      (0, t.u8)('authorityType'),
      (0, t.u8)('newAuthorityOption'),
      (0, n.publicKey)('newAuthority'),
    ]));
  function s(d, f, p, y, b = [], m = i.TOKEN_PROGRAM_ID) {
    const w = (0, a.addSigners)([{ pubkey: d, isSigner: !1, isWritable: !0 }], f, b),
      _ = Y.alloc(e.setAuthorityInstructionData.span);
    return (
      e.setAuthorityInstructionData.encode(
        {
          instruction: c.TokenInstruction.SetAuthority,
          authorityType: p,
          newAuthorityOption: y ? 1 : 0,
          newAuthority: y || new r.PublicKey(0),
        },
        _
      ),
      new r.TransactionInstruction({ keys: w, programId: m, data: _ })
    );
  }
  e.createSetAuthorityInstruction = s;
  function l(d, f = i.TOKEN_PROGRAM_ID) {
    if (!d.programId.equals(f)) throw new o.TokenInvalidInstructionProgramError();
    if (d.data.length !== e.setAuthorityInstructionData.span)
      throw new o.TokenInvalidInstructionDataError();
    const {
      keys: { account: p, currentAuthority: y, multiSigners: b },
      data: m,
    } = u(d);
    if (m.instruction !== c.TokenInstruction.SetAuthority)
      throw new o.TokenInvalidInstructionTypeError();
    if (!p || !y) throw new o.TokenInvalidInstructionKeysError();
    return { programId: f, keys: { account: p, currentAuthority: y, multiSigners: b }, data: m };
  }
  e.decodeSetAuthorityInstruction = l;
  function u({ programId: d, keys: [f, p, ...y], data: b }) {
    const {
      instruction: m,
      authorityType: w,
      newAuthorityOption: _,
      newAuthority: S,
    } = e.setAuthorityInstructionData.decode(b);
    return {
      programId: d,
      keys: { account: f, currentAuthority: p, multiSigners: y },
      data: { instruction: m, authorityType: w, newAuthority: _ ? S : null },
    };
  }
  e.decodeSetAuthorityInstructionUnchecked = u;
})($g);
var f$ =
  (g && g.__awaiter) ||
  function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (a) {
            a(o);
          });
    }
    return new (n || (n = Promise))(function (o, a) {
      function c(u) {
        try {
          l(r.next(u));
        } catch (d) {
          a(d);
        }
      }
      function s(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          a(d);
        }
      }
      function l(u) {
        u.done ? o(u.value) : i(u.value).then(c, s);
      }
      l((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(Fg, '__esModule', { value: !0 });
Fg.setAuthority = void 0;
const Uv = V,
  h$ = ye,
  p$ = $g,
  g$ = Bt;
function y$(e, t, n, r, i, o, a = [], c, s = h$.TOKEN_PROGRAM_ID) {
  return f$(this, void 0, void 0, function* () {
    const [l, u] = (0, g$.getSigners)(r, a),
      d = new Uv.Transaction().add((0, p$.createSetAuthorityInstruction)(n, l, i, o, a, s));
    return yield (0, Uv.sendAndConfirmTransaction)(e, d, [t, ...u], c);
  });
}
Fg.setAuthority = y$;
var Wg = {},
  b$ =
    (g && g.__awaiter) ||
    function (e, t, n, r) {
      function i(o) {
        return o instanceof n
          ? o
          : new n(function (a) {
              a(o);
            });
      }
      return new (n || (n = Promise))(function (o, a) {
        function c(u) {
          try {
            l(r.next(u));
          } catch (d) {
            a(d);
          }
        }
        function s(u) {
          try {
            l(r.throw(u));
          } catch (d) {
            a(d);
          }
        }
        function l(u) {
          u.done ? o(u.value) : i(u.value).then(c, s);
        }
        l((r = r.apply(e, t || [])).next());
      });
    };
Object.defineProperty(Wg, '__esModule', { value: !0 });
Wg.syncNative = void 0;
const Lv = V,
  m$ = ye,
  w$ = If;
function _$(e, t, n, r, i = m$.TOKEN_PROGRAM_ID) {
  return b$(this, void 0, void 0, function* () {
    const o = new Lv.Transaction().add((0, w$.createSyncNativeInstruction)(n, i));
    return yield (0, Lv.sendAndConfirmTransaction)(e, o, [t], r);
  });
}
Wg.syncNative = _$;
var Vg = {},
  Kg = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeThawAccountInstructionUnchecked =
      e.decodeThawAccountInstruction =
      e.createThawAccountInstruction =
      e.thawAccountInstructionData =
        void 0);
  const t = xe,
    n = V,
    r = ye,
    i = be,
    o = xt,
    a = Ze;
  e.thawAccountInstructionData = (0, t.struct)([(0, t.u8)('instruction')]);
  function c(u, d, f, p = [], y = r.TOKEN_PROGRAM_ID) {
    const b = (0, o.addSigners)(
        [
          { pubkey: u, isSigner: !1, isWritable: !0 },
          { pubkey: d, isSigner: !1, isWritable: !1 },
        ],
        f,
        p
      ),
      m = Y.alloc(e.thawAccountInstructionData.span);
    return (
      e.thawAccountInstructionData.encode({ instruction: a.TokenInstruction.ThawAccount }, m),
      new n.TransactionInstruction({ keys: b, programId: y, data: m })
    );
  }
  e.createThawAccountInstruction = c;
  function s(u, d = r.TOKEN_PROGRAM_ID) {
    if (!u.programId.equals(d)) throw new i.TokenInvalidInstructionProgramError();
    if (u.data.length !== e.thawAccountInstructionData.span)
      throw new i.TokenInvalidInstructionDataError();
    const {
      keys: { account: f, mint: p, authority: y, multiSigners: b },
      data: m,
    } = l(u);
    if (m.instruction !== a.TokenInstruction.ThawAccount)
      throw new i.TokenInvalidInstructionTypeError();
    if (!f || !p || !y) throw new i.TokenInvalidInstructionKeysError();
    return { programId: d, keys: { account: f, mint: p, authority: y, multiSigners: b }, data: m };
  }
  e.decodeThawAccountInstruction = s;
  function l({ programId: u, keys: [d, f, p, ...y], data: b }) {
    return {
      programId: u,
      keys: { account: d, mint: f, authority: p, multiSigners: y },
      data: e.thawAccountInstructionData.decode(b),
    };
  }
  e.decodeThawAccountInstructionUnchecked = l;
})(Kg);
var v$ =
  (g && g.__awaiter) ||
  function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (a) {
            a(o);
          });
    }
    return new (n || (n = Promise))(function (o, a) {
      function c(u) {
        try {
          l(r.next(u));
        } catch (d) {
          a(d);
        }
      }
      function s(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          a(d);
        }
      }
      function l(u) {
        u.done ? o(u.value) : i(u.value).then(c, s);
      }
      l((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(Vg, '__esModule', { value: !0 });
Vg.thawAccount = void 0;
const zv = V,
  S$ = ye,
  A$ = Kg,
  I$ = Bt;
function E$(e, t, n, r, i, o = [], a, c = S$.TOKEN_PROGRAM_ID) {
  return v$(this, void 0, void 0, function* () {
    const [s, l] = (0, I$.getSigners)(i, o),
      u = new zv.Transaction().add((0, A$.createThawAccountInstruction)(n, r, s, o, c));
    return yield (0, zv.sendAndConfirmTransaction)(e, u, [t, ...l], a);
  });
}
Vg.thawAccount = E$;
var Hg = {},
  qg = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeTransferInstructionUnchecked =
      e.decodeTransferInstruction =
      e.createTransferInstruction =
      e.transferInstructionData =
        void 0);
  const t = xe,
    n = gt,
    r = V,
    i = ye,
    o = be,
    a = xt,
    c = Ze;
  e.transferInstructionData = (0, t.struct)([(0, t.u8)('instruction'), (0, n.u64)('amount')]);
  function s(d, f, p, y, b = [], m = i.TOKEN_PROGRAM_ID) {
    const w = (0, a.addSigners)(
        [
          { pubkey: d, isSigner: !1, isWritable: !0 },
          { pubkey: f, isSigner: !1, isWritable: !0 },
        ],
        p,
        b
      ),
      _ = Y.alloc(e.transferInstructionData.span);
    return (
      e.transferInstructionData.encode(
        { instruction: c.TokenInstruction.Transfer, amount: BigInt(y) },
        _
      ),
      new r.TransactionInstruction({ keys: w, programId: m, data: _ })
    );
  }
  e.createTransferInstruction = s;
  function l(d, f = i.TOKEN_PROGRAM_ID) {
    if (!d.programId.equals(f)) throw new o.TokenInvalidInstructionProgramError();
    if (d.data.length !== e.transferInstructionData.span)
      throw new o.TokenInvalidInstructionDataError();
    const {
      keys: { source: p, destination: y, owner: b, multiSigners: m },
      data: w,
    } = u(d);
    if (w.instruction !== c.TokenInstruction.Transfer)
      throw new o.TokenInvalidInstructionTypeError();
    if (!p || !y || !b) throw new o.TokenInvalidInstructionKeysError();
    return {
      programId: f,
      keys: { source: p, destination: y, owner: b, multiSigners: m },
      data: w,
    };
  }
  e.decodeTransferInstruction = l;
  function u({ programId: d, keys: [f, p, y, ...b], data: m }) {
    return {
      programId: d,
      keys: { source: f, destination: p, owner: y, multiSigners: b },
      data: e.transferInstructionData.decode(m),
    };
  }
  e.decodeTransferInstructionUnchecked = u;
})(qg);
var T$ =
  (g && g.__awaiter) ||
  function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (a) {
            a(o);
          });
    }
    return new (n || (n = Promise))(function (o, a) {
      function c(u) {
        try {
          l(r.next(u));
        } catch (d) {
          a(d);
        }
      }
      function s(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          a(d);
        }
      }
      function l(u) {
        u.done ? o(u.value) : i(u.value).then(c, s);
      }
      l((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(Hg, '__esModule', { value: !0 });
Hg.transfer = void 0;
const Fv = V,
  k$ = ye,
  C$ = qg,
  M$ = Bt;
function P$(e, t, n, r, i, o, a = [], c, s = k$.TOKEN_PROGRAM_ID) {
  return T$(this, void 0, void 0, function* () {
    const [l, u] = (0, M$.getSigners)(i, a),
      d = new Fv.Transaction().add((0, C$.createTransferInstruction)(n, r, l, o, a, s));
    return yield (0, Fv.sendAndConfirmTransaction)(e, d, [t, ...u], c);
  });
}
Hg.transfer = P$;
var Gg = {},
  Yg = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeTransferCheckedInstructionUnchecked =
      e.decodeTransferCheckedInstruction =
      e.createTransferCheckedInstruction =
      e.transferCheckedInstructionData =
        void 0);
  const t = xe,
    n = gt,
    r = V,
    i = ye,
    o = be,
    a = xt,
    c = Ze;
  e.transferCheckedInstructionData = (0, t.struct)([
    (0, t.u8)('instruction'),
    (0, n.u64)('amount'),
    (0, t.u8)('decimals'),
  ]);
  function s(d, f, p, y, b, m, w = [], _ = i.TOKEN_PROGRAM_ID) {
    const S = (0, a.addSigners)(
        [
          { pubkey: d, isSigner: !1, isWritable: !0 },
          { pubkey: f, isSigner: !1, isWritable: !1 },
          { pubkey: p, isSigner: !1, isWritable: !0 },
        ],
        y,
        w
      ),
      E = Y.alloc(e.transferCheckedInstructionData.span);
    return (
      e.transferCheckedInstructionData.encode(
        { instruction: c.TokenInstruction.TransferChecked, amount: BigInt(b), decimals: m },
        E
      ),
      new r.TransactionInstruction({ keys: S, programId: _, data: E })
    );
  }
  e.createTransferCheckedInstruction = s;
  function l(d, f = i.TOKEN_PROGRAM_ID) {
    if (!d.programId.equals(f)) throw new o.TokenInvalidInstructionProgramError();
    if (d.data.length !== e.transferCheckedInstructionData.span)
      throw new o.TokenInvalidInstructionDataError();
    const {
      keys: { source: p, mint: y, destination: b, owner: m, multiSigners: w },
      data: _,
    } = u(d);
    if (_.instruction !== c.TokenInstruction.TransferChecked)
      throw new o.TokenInvalidInstructionTypeError();
    if (!p || !y || !b || !m) throw new o.TokenInvalidInstructionKeysError();
    return {
      programId: f,
      keys: { source: p, mint: y, destination: b, owner: m, multiSigners: w },
      data: _,
    };
  }
  e.decodeTransferCheckedInstruction = l;
  function u({ programId: d, keys: [f, p, y, b, ...m], data: w }) {
    return {
      programId: d,
      keys: { source: f, mint: p, destination: y, owner: b, multiSigners: m },
      data: e.transferCheckedInstructionData.decode(w),
    };
  }
  e.decodeTransferCheckedInstructionUnchecked = u;
})(Yg);
var O$ =
  (g && g.__awaiter) ||
  function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (a) {
            a(o);
          });
    }
    return new (n || (n = Promise))(function (o, a) {
      function c(u) {
        try {
          l(r.next(u));
        } catch (d) {
          a(d);
        }
      }
      function s(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          a(d);
        }
      }
      function l(u) {
        u.done ? o(u.value) : i(u.value).then(c, s);
      }
      l((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(Gg, '__esModule', { value: !0 });
Gg.transferChecked = void 0;
const $v = V,
  D$ = ye,
  R$ = Yg,
  x$ = Bt;
function B$(e, t, n, r, i, o, a, c, s = [], l, u = D$.TOKEN_PROGRAM_ID) {
  return O$(this, void 0, void 0, function* () {
    const [d, f] = (0, x$.getSigners)(o, s),
      p = new $v.Transaction().add(
        (0, R$.createTransferCheckedInstruction)(n, r, i, d, a, c, s, u)
      );
    return yield (0, $v.sendAndConfirmTransaction)(e, p, [t, ...f], l);
  });
}
Gg.transferChecked = B$;
var Zg = {},
  $r = {};
Object.defineProperty($r, '__esModule', { value: !0 });
$r.decodeUiAmountToAmountInstructionUnchecked =
  $r.decodeUiAmountToAmountInstruction =
  $r.createUiAmountToAmountInstruction =
    void 0;
const li = xe,
  j$ = V,
  zk = ye,
  oh = be,
  Fk = Ze;
function N$(e, t, n = zk.TOKEN_PROGRAM_ID) {
  const r = [{ pubkey: e, isSigner: !1, isWritable: !1 }],
    i = Y.from(t, 'utf8'),
    o = (0, li.struct)([(0, li.u8)('instruction'), (0, li.blob)(i.length, 'amount')]),
    a = Y.alloc(o.span);
  return (
    o.encode({ instruction: Fk.TokenInstruction.UiAmountToAmount, amount: i }, a),
    new j$.TransactionInstruction({ keys: r, programId: n, data: a })
  );
}
$r.createUiAmountToAmountInstruction = N$;
function U$(e, t = zk.TOKEN_PROGRAM_ID) {
  if (!e.programId.equals(t)) throw new oh.TokenInvalidInstructionProgramError();
  const n = (0, li.struct)([(0, li.u8)('instruction'), (0, li.blob)(e.data.length - 1, 'amount')]);
  if (e.data.length !== n.span) throw new oh.TokenInvalidInstructionDataError();
  const {
    keys: { mint: r },
    data: i,
  } = $k(e);
  if (i.instruction !== Fk.TokenInstruction.UiAmountToAmount)
    throw new oh.TokenInvalidInstructionTypeError();
  if (!r) throw new oh.TokenInvalidInstructionKeysError();
  return { programId: t, keys: { mint: r }, data: i };
}
$r.decodeUiAmountToAmountInstruction = U$;
function $k({ programId: e, keys: [t], data: n }) {
  const r = (0, li.struct)([(0, li.u8)('instruction'), (0, li.blob)(n.length - 1, 'amount')]);
  return { programId: e, keys: { mint: t }, data: r.decode(n) };
}
$r.decodeUiAmountToAmountInstructionUnchecked = $k;
var L$ =
  (g && g.__awaiter) ||
  function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (a) {
            a(o);
          });
    }
    return new (n || (n = Promise))(function (o, a) {
      function c(u) {
        try {
          l(r.next(u));
        } catch (d) {
          a(d);
        }
      }
      function s(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          a(d);
        }
      }
      function l(u) {
        u.done ? o(u.value) : i(u.value).then(c, s);
      }
      l((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(Zg, '__esModule', { value: !0 });
Zg.uiAmountToAmount = void 0;
const z$ = gt,
  F$ = V,
  $$ = ye,
  W$ = $r;
function V$(e, t, n, r, i = $$.TOKEN_PROGRAM_ID) {
  return L$(this, void 0, void 0, function* () {
    const o = new F$.Transaction().add((0, W$.createUiAmountToAmountInstruction)(n, r, i)),
      { returnData: a, err: c } = (yield e.simulateTransaction(o, [t], !1)).value;
    if (a) {
      const s = Y.from(a.data[0], a.data[1]);
      return (0, z$.u64)().decode(s);
    }
    return c;
  });
}
Zg.uiAmountToAmount = V$;
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (r, i, o, a) {
            a === void 0 && (a = o);
            var c = Object.getOwnPropertyDescriptor(i, o);
            (!c || ('get' in c ? !i.__esModule : c.writable || c.configurable)) &&
              (c = {
                enumerable: !0,
                get: function () {
                  return i[o];
                },
              }),
              Object.defineProperty(r, a, c);
          }
        : function (r, i, o, a) {
            a === void 0 && (a = o), (r[a] = i[o]);
          }),
    n =
      (g && g.__exportStar) ||
      function (r, i) {
        for (var o in r)
          o !== 'default' && !Object.prototype.hasOwnProperty.call(i, o) && t(i, r, o);
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    n(lg, e),
    n(fg, e),
    n(pg, e),
    n(yg, e),
    n(mg, e),
    n(_g, e),
    n(wf, e),
    n(Af, e),
    n(Eg, e),
    n(Tg, e),
    n(Cg, e),
    n(Pg, e),
    n(Og, e),
    n(Dg, e),
    n(xg, e),
    n(Bg, e),
    n(Ng, e),
    n(Lg, e),
    n(Fg, e),
    n(Wg, e),
    n(Vg, e),
    n(Hg, e),
    n(Gg, e),
    n(Zg, e);
})(mk);
var Wk = {},
  Vk = {},
  ns = {},
  Qg = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeInitializeMintInstructionUnchecked =
      e.decodeInitializeMintInstruction =
      e.createInitializeMintInstruction =
      e.initializeMintInstructionData =
        void 0);
  const t = xe,
    n = gt,
    r = V,
    i = ye,
    o = be,
    a = Ze;
  e.initializeMintInstructionData = (0, t.struct)([
    (0, t.u8)('instruction'),
    (0, t.u8)('decimals'),
    (0, n.publicKey)('mintAuthority'),
    (0, t.u8)('freezeAuthorityOption'),
    (0, n.publicKey)('freezeAuthority'),
  ]);
  function c(u, d, f, p, y = i.TOKEN_PROGRAM_ID) {
    const b = [
        { pubkey: u, isSigner: !1, isWritable: !0 },
        { pubkey: r.SYSVAR_RENT_PUBKEY, isSigner: !1, isWritable: !1 },
      ],
      m = Y.alloc(e.initializeMintInstructionData.span);
    return (
      e.initializeMintInstructionData.encode(
        {
          instruction: a.TokenInstruction.InitializeMint,
          decimals: d,
          mintAuthority: f,
          freezeAuthorityOption: p ? 1 : 0,
          freezeAuthority: p || new r.PublicKey(0),
        },
        m
      ),
      new r.TransactionInstruction({ keys: b, programId: y, data: m })
    );
  }
  e.createInitializeMintInstruction = c;
  function s(u, d = i.TOKEN_PROGRAM_ID) {
    if (!u.programId.equals(d)) throw new o.TokenInvalidInstructionProgramError();
    if (u.data.length !== e.initializeMintInstructionData.span)
      throw new o.TokenInvalidInstructionDataError();
    const {
      keys: { mint: f, rent: p },
      data: y,
    } = l(u);
    if (y.instruction !== a.TokenInstruction.InitializeMint)
      throw new o.TokenInvalidInstructionTypeError();
    if (!f || !p) throw new o.TokenInvalidInstructionKeysError();
    return { programId: d, keys: { mint: f, rent: p }, data: y };
  }
  e.decodeInitializeMintInstruction = s;
  function l({ programId: u, keys: [d, f], data: p }) {
    const {
      instruction: y,
      decimals: b,
      mintAuthority: m,
      freezeAuthorityOption: w,
      freezeAuthority: _,
    } = e.initializeMintInstructionData.decode(p);
    return {
      programId: u,
      keys: { mint: d, rent: f },
      data: { instruction: y, decimals: b, mintAuthority: m, freezeAuthority: w ? _ : null },
    };
  }
  e.decodeInitializeMintInstructionUnchecked = l;
})(Qg);
var U1 = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createUpdateRateInterestBearingMintInstruction =
      e.createInitializeInterestBearingMintInstruction =
      e.interestBearingMintUpdateRateInstructionData =
      e.interestBearingMintInitializeInstructionData =
      e.InterestBearingMintInstruction =
        void 0);
  const t = xe,
    n = gt,
    r = V,
    i = ye,
    o = xt,
    a = Ze;
  var c;
  (function (u) {
    (u[(u.Initialize = 0)] = 'Initialize'), (u[(u.UpdateRate = 1)] = 'UpdateRate');
  })((c = e.InterestBearingMintInstruction || (e.InterestBearingMintInstruction = {}))),
    (e.interestBearingMintInitializeInstructionData = (0, t.struct)([
      (0, t.u8)('instruction'),
      (0, t.u8)('interestBearingMintInstruction'),
      (0, n.publicKey)('rateAuthority'),
      (0, t.s16)('rate'),
    ])),
    (e.interestBearingMintUpdateRateInstructionData = (0, t.struct)([
      (0, t.u8)('instruction'),
      (0, t.u8)('interestBearingMintInstruction'),
      (0, t.s16)('rate'),
    ]));
  function s(u, d, f, p = i.TOKEN_2022_PROGRAM_ID) {
    const y = [{ pubkey: u, isSigner: !1, isWritable: !0 }],
      b = Y.alloc(e.interestBearingMintInitializeInstructionData.span);
    return (
      e.interestBearingMintInitializeInstructionData.encode(
        {
          instruction: a.TokenInstruction.InterestBearingMintExtension,
          interestBearingMintInstruction: c.Initialize,
          rateAuthority: d,
          rate: f,
        },
        b
      ),
      new r.TransactionInstruction({ keys: y, programId: p, data: b })
    );
  }
  e.createInitializeInterestBearingMintInstruction = s;
  function l(u, d, f, p = [], y = i.TOKEN_2022_PROGRAM_ID) {
    const b = (0, o.addSigners)(
        [
          { pubkey: u, isSigner: !1, isWritable: !0 },
          { pubkey: d, isSigner: !p.length, isWritable: !1 },
        ],
        d,
        p
      ),
      m = Y.alloc(e.interestBearingMintUpdateRateInstructionData.span);
    return (
      e.interestBearingMintUpdateRateInstructionData.encode(
        {
          instruction: a.TokenInstruction.InterestBearingMintExtension,
          interestBearingMintInstruction: c.UpdateRate,
          rate: f,
        },
        m
      ),
      new r.TransactionInstruction({ keys: b, programId: y, data: m })
    );
  }
  e.createUpdateRateInterestBearingMintInstruction = l;
})(U1);
var Kk =
  (g && g.__awaiter) ||
  function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (a) {
            a(o);
          });
    }
    return new (n || (n = Promise))(function (o, a) {
      function c(u) {
        try {
          l(r.next(u));
        } catch (d) {
          a(d);
        }
      }
      function s(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          a(d);
        }
      }
      function l(u) {
        u.done ? o(u.value) : i(u.value).then(c, s);
      }
      l((r = r.apply(e, t || [])).next());
    });
  };
Object.defineProperty(ns, '__esModule', { value: !0 });
ns.updateRateInterestBearingMint = ns.createInterestBearingMint = void 0;
const Ta = V,
  K$ = Bt,
  Hk = ye,
  H$ = Qg,
  Wv = On(),
  qk = U1;
function q$(e, t, n, r, i, o, a, c = Ta.Keypair.generate(), s, l = Hk.TOKEN_2022_PROGRAM_ID) {
  return Kk(this, void 0, void 0, function* () {
    const u = (0, Wv.getMintLen)([Wv.ExtensionType.InterestBearingConfig]),
      d = yield e.getMinimumBalanceForRentExemption(u),
      f = new Ta.Transaction().add(
        Ta.SystemProgram.createAccount({
          fromPubkey: t.publicKey,
          newAccountPubkey: c.publicKey,
          space: u,
          lamports: d,
          programId: l,
        }),
        (0, qk.createInitializeInterestBearingMintInstruction)(c.publicKey, i, o, l),
        (0, H$.createInitializeMintInstruction)(c.publicKey, a, n, r, l)
      );
    return yield (0, Ta.sendAndConfirmTransaction)(e, f, [t, c], s), c.publicKey;
  });
}
ns.createInterestBearingMint = q$;
function G$(e, t, n, r, i, o = [], a, c = Hk.TOKEN_2022_PROGRAM_ID) {
  return Kk(this, void 0, void 0, function* () {
    const [s, l] = (0, K$.getSigners)(r, o),
      u = new Ta.Transaction().add(
        (0, qk.createUpdateRateInterestBearingMintInstruction)(n, s, i, l, c)
      );
    return yield (0, Ta.sendAndConfirmTransaction)(e, u, [t, r, ...l], a);
  });
}
ns.updateRateInterestBearingMint = G$;
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (r, i, o, a) {
            a === void 0 && (a = o);
            var c = Object.getOwnPropertyDescriptor(i, o);
            (!c || ('get' in c ? !i.__esModule : c.writable || c.configurable)) &&
              (c = {
                enumerable: !0,
                get: function () {
                  return i[o];
                },
              }),
              Object.defineProperty(r, a, c);
          }
        : function (r, i, o, a) {
            a === void 0 && (a = o), (r[a] = i[o]);
          }),
    n =
      (g && g.__exportStar) ||
      function (r, i) {
        for (var o in r)
          o !== 'default' && !Object.prototype.hasOwnProperty.call(i, o) && t(i, r, o);
      };
  Object.defineProperty(e, '__esModule', { value: !0 }), n(ns, e), n(U1, e), n(Mk(), e);
})(Vk);
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (r, i, o, a) {
            a === void 0 && (a = o);
            var c = Object.getOwnPropertyDescriptor(i, o);
            (!c || ('get' in c ? !i.__esModule : c.writable || c.configurable)) &&
              (c = {
                enumerable: !0,
                get: function () {
                  return i[o];
                },
              }),
              Object.defineProperty(r, a, c);
          }
        : function (r, i, o, a) {
            a === void 0 && (a = o), (r[a] = i[o]);
          }),
    n =
      (g && g.__exportStar) ||
      function (r, i) {
        for (var o in r)
          o !== 'default' && !Object.prototype.hasOwnProperty.call(i, o) && t(i, r, o);
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    n(_f, e),
    n(Ak(), e),
    n(kk(), e),
    n(On(), e),
    n(Ck(), e),
    n(Vk, e),
    n(xk(), e),
    n(Bk(), e),
    n(jk(), e),
    n(Uk(), e),
    n(Nk(), e);
})(Wk);
var Gk = {},
  Me = {},
  L1 = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeInitializeAccount2InstructionUnchecked =
      e.decodeInitializeAccount2Instruction =
      e.createInitializeAccount2Instruction =
      e.initializeAccount2InstructionData =
        void 0);
  const t = xe,
    n = gt,
    r = V,
    i = ye,
    o = be,
    a = Ze;
  e.initializeAccount2InstructionData = (0, t.struct)([
    (0, t.u8)('instruction'),
    (0, n.publicKey)('owner'),
  ]);
  function c(u, d, f, p = i.TOKEN_PROGRAM_ID) {
    const y = [
        { pubkey: u, isSigner: !1, isWritable: !0 },
        { pubkey: d, isSigner: !1, isWritable: !1 },
        { pubkey: r.SYSVAR_RENT_PUBKEY, isSigner: !1, isWritable: !1 },
      ],
      b = Y.alloc(e.initializeAccount2InstructionData.span);
    return (
      e.initializeAccount2InstructionData.encode(
        { instruction: a.TokenInstruction.InitializeAccount2, owner: f },
        b
      ),
      new r.TransactionInstruction({ keys: y, programId: p, data: b })
    );
  }
  e.createInitializeAccount2Instruction = c;
  function s(u, d = i.TOKEN_PROGRAM_ID) {
    if (!u.programId.equals(d)) throw new o.TokenInvalidInstructionProgramError();
    if (u.data.length !== e.initializeAccount2InstructionData.span)
      throw new o.TokenInvalidInstructionDataError();
    const {
      keys: { account: f, mint: p, rent: y },
      data: b,
    } = l(u);
    if (b.instruction !== a.TokenInstruction.InitializeAccount2)
      throw new o.TokenInvalidInstructionTypeError();
    if (!f || !p || !y) throw new o.TokenInvalidInstructionKeysError();
    return { programId: d, keys: { account: f, mint: p, rent: y }, data: b };
  }
  e.decodeInitializeAccount2Instruction = s;
  function l({ programId: u, keys: [d, f, p], data: y }) {
    return {
      programId: u,
      keys: { account: d, mint: f, rent: p },
      data: e.initializeAccount2InstructionData.decode(y),
    };
  }
  e.decodeInitializeAccount2InstructionUnchecked = l;
})(L1);
var z1 = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeInitializeAccount3InstructionUnchecked =
      e.decodeInitializeAccount3Instruction =
      e.createInitializeAccount3Instruction =
      e.initializeAccount3InstructionData =
        void 0);
  const t = xe,
    n = gt,
    r = V,
    i = ye,
    o = be,
    a = Ze;
  e.initializeAccount3InstructionData = (0, t.struct)([
    (0, t.u8)('instruction'),
    (0, n.publicKey)('owner'),
  ]);
  function c(u, d, f, p = i.TOKEN_PROGRAM_ID) {
    const y = [
        { pubkey: u, isSigner: !1, isWritable: !0 },
        { pubkey: d, isSigner: !1, isWritable: !1 },
      ],
      b = Y.alloc(e.initializeAccount3InstructionData.span);
    return (
      e.initializeAccount3InstructionData.encode(
        { instruction: a.TokenInstruction.InitializeAccount3, owner: f },
        b
      ),
      new r.TransactionInstruction({ keys: y, programId: p, data: b })
    );
  }
  e.createInitializeAccount3Instruction = c;
  function s(u, d = i.TOKEN_PROGRAM_ID) {
    if (!u.programId.equals(d)) throw new o.TokenInvalidInstructionProgramError();
    if (u.data.length !== e.initializeAccount3InstructionData.span)
      throw new o.TokenInvalidInstructionDataError();
    const {
      keys: { account: f, mint: p },
      data: y,
    } = l(u);
    if (y.instruction !== a.TokenInstruction.InitializeAccount3)
      throw new o.TokenInvalidInstructionTypeError();
    if (!f || !p) throw new o.TokenInvalidInstructionKeysError();
    return { programId: d, keys: { account: f, mint: p }, data: y };
  }
  e.decodeInitializeAccount3Instruction = s;
  function l({ programId: u, keys: [d, f], data: p }) {
    return {
      programId: u,
      keys: { account: d, mint: f },
      data: e.initializeAccount3InstructionData.decode(p),
    };
  }
  e.decodeInitializeAccount3InstructionUnchecked = l;
})(z1);
Object.defineProperty(Me, '__esModule', { value: !0 });
Me.isUiamountToAmountInstruction =
  Me.isAmountToUiAmountInstruction =
  Me.isInitializeMint2Instruction =
  Me.isInitializeAccount3Instruction =
  Me.isSyncNativeInstruction =
  Me.isInitializeAccount2Instruction =
  Me.isBurnCheckedInstruction =
  Me.isMintToCheckedInstruction =
  Me.isApproveCheckedInstruction =
  Me.isTransferCheckedInstruction =
  Me.isThawAccountInstruction =
  Me.isFreezeAccountInstruction =
  Me.isCloseAccountInstruction =
  Me.isBurnInstruction =
  Me.isMintToInstruction =
  Me.isSetAuthorityInstruction =
  Me.isRevokeInstruction =
  Me.isApproveInstruction =
  Me.isTransferInstruction =
  Me.isInitializeMultisigInstruction =
  Me.isInitializeAccountInstruction =
  Me.isInitializeMintInstruction =
  Me.decodeInstruction =
    void 0;
const Y$ = xe,
  Z$ = ye,
  Pb = be,
  Q$ = dg,
  J$ = hg,
  X$ = gg,
  eW = bg,
  tW = wg,
  nW = vg,
  rW = Rg,
  iW = Sf,
  oW = L1,
  aW = z1,
  sW = Qg,
  cW = kg,
  uW = Mg,
  lW = jg,
  dW = Ug,
  fW = zg,
  hW = $g,
  pW = If,
  gW = Kg,
  yW = qg,
  bW = Yg,
  Ne = Ze,
  mW = $r;
function wW(e, t = Z$.TOKEN_PROGRAM_ID) {
  if (!e.data.length) throw new Pb.TokenInvalidInstructionDataError();
  const n = (0, Y$.u8)().decode(e.data);
  if (n === Ne.TokenInstruction.InitializeMint)
    return (0, sW.decodeInitializeMintInstruction)(e, t);
  if (n === Ne.TokenInstruction.InitializeAccount)
    return (0, iW.decodeInitializeAccountInstruction)(e, t);
  if (n === Ne.TokenInstruction.InitializeMultisig)
    return (0, uW.decodeInitializeMultisigInstruction)(e, t);
  if (n === Ne.TokenInstruction.Transfer) return (0, yW.decodeTransferInstruction)(e, t);
  if (n === Ne.TokenInstruction.Approve) return (0, J$.decodeApproveInstruction)(e, t);
  if (n === Ne.TokenInstruction.Revoke) return (0, fW.decodeRevokeInstruction)(e, t);
  if (n === Ne.TokenInstruction.SetAuthority) return (0, hW.decodeSetAuthorityInstruction)(e, t);
  if (n === Ne.TokenInstruction.MintTo) return (0, lW.decodeMintToInstruction)(e, t);
  if (n === Ne.TokenInstruction.Burn) return (0, eW.decodeBurnInstruction)(e, t);
  if (n === Ne.TokenInstruction.CloseAccount) return (0, nW.decodeCloseAccountInstruction)(e, t);
  if (n === Ne.TokenInstruction.FreezeAccount) return (0, rW.decodeFreezeAccountInstruction)(e, t);
  if (n === Ne.TokenInstruction.ThawAccount) return (0, gW.decodeThawAccountInstruction)(e, t);
  if (n === Ne.TokenInstruction.TransferChecked)
    return (0, bW.decodeTransferCheckedInstruction)(e, t);
  if (n === Ne.TokenInstruction.ApproveChecked)
    return (0, X$.decodeApproveCheckedInstruction)(e, t);
  if (n === Ne.TokenInstruction.MintToChecked) return (0, dW.decodeMintToCheckedInstruction)(e, t);
  if (n === Ne.TokenInstruction.BurnChecked) return (0, tW.decodeBurnCheckedInstruction)(e, t);
  if (n === Ne.TokenInstruction.InitializeAccount2)
    return (0, oW.decodeInitializeAccount2Instruction)(e, t);
  if (n === Ne.TokenInstruction.SyncNative) return (0, pW.decodeSyncNativeInstruction)(e, t);
  if (n === Ne.TokenInstruction.InitializeAccount3)
    return (0, aW.decodeInitializeAccount3Instruction)(e, t);
  if (n === Ne.TokenInstruction.InitializeMint2)
    return (0, cW.decodeInitializeMint2Instruction)(e, t);
  if (n === Ne.TokenInstruction.AmountToUiAmount)
    return (0, Q$.decodeAmountToUiAmountInstruction)(e, t);
  if (n === Ne.TokenInstruction.UiAmountToAmount)
    return (0, mW.decodeUiAmountToAmountInstruction)(e, t);
  throw n === Ne.TokenInstruction.InitializeMultisig2
    ? new Pb.TokenInvalidInstructionTypeError()
    : new Pb.TokenInvalidInstructionTypeError();
}
Me.decodeInstruction = wW;
function _W(e) {
  return e.data.instruction === Ne.TokenInstruction.InitializeMint;
}
Me.isInitializeMintInstruction = _W;
function vW(e) {
  return e.data.instruction === Ne.TokenInstruction.InitializeAccount;
}
Me.isInitializeAccountInstruction = vW;
function SW(e) {
  return e.data.instruction === Ne.TokenInstruction.InitializeMultisig;
}
Me.isInitializeMultisigInstruction = SW;
function AW(e) {
  return e.data.instruction === Ne.TokenInstruction.Transfer;
}
Me.isTransferInstruction = AW;
function IW(e) {
  return e.data.instruction === Ne.TokenInstruction.Approve;
}
Me.isApproveInstruction = IW;
function EW(e) {
  return e.data.instruction === Ne.TokenInstruction.Revoke;
}
Me.isRevokeInstruction = EW;
function TW(e) {
  return e.data.instruction === Ne.TokenInstruction.SetAuthority;
}
Me.isSetAuthorityInstruction = TW;
function kW(e) {
  return e.data.instruction === Ne.TokenInstruction.MintTo;
}
Me.isMintToInstruction = kW;
function CW(e) {
  return e.data.instruction === Ne.TokenInstruction.Burn;
}
Me.isBurnInstruction = CW;
function MW(e) {
  return e.data.instruction === Ne.TokenInstruction.CloseAccount;
}
Me.isCloseAccountInstruction = MW;
function PW(e) {
  return e.data.instruction === Ne.TokenInstruction.FreezeAccount;
}
Me.isFreezeAccountInstruction = PW;
function OW(e) {
  return e.data.instruction === Ne.TokenInstruction.ThawAccount;
}
Me.isThawAccountInstruction = OW;
function DW(e) {
  return e.data.instruction === Ne.TokenInstruction.TransferChecked;
}
Me.isTransferCheckedInstruction = DW;
function RW(e) {
  return e.data.instruction === Ne.TokenInstruction.ApproveChecked;
}
Me.isApproveCheckedInstruction = RW;
function xW(e) {
  return e.data.instruction === Ne.TokenInstruction.MintToChecked;
}
Me.isMintToCheckedInstruction = xW;
function BW(e) {
  return e.data.instruction === Ne.TokenInstruction.BurnChecked;
}
Me.isBurnCheckedInstruction = BW;
function jW(e) {
  return e.data.instruction === Ne.TokenInstruction.InitializeAccount2;
}
Me.isInitializeAccount2Instruction = jW;
function NW(e) {
  return e.data.instruction === Ne.TokenInstruction.SyncNative;
}
Me.isSyncNativeInstruction = NW;
function UW(e) {
  return e.data.instruction === Ne.TokenInstruction.InitializeAccount3;
}
Me.isInitializeAccount3Instruction = UW;
function LW(e) {
  return e.data.instruction === Ne.TokenInstruction.InitializeMint2;
}
Me.isInitializeMint2Instruction = LW;
function zW(e) {
  return e.data.instruction === Ne.TokenInstruction.AmountToUiAmount;
}
Me.isAmountToUiAmountInstruction = zW;
function FW(e) {
  return e.data.instruction === Ne.TokenInstruction.UiAmountToAmount;
}
Me.isUiamountToAmountInstruction = FW;
var Yk = {};
Object.defineProperty(Yk, '__esModule', { value: !0 });
var Zk = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeInitializeImmutableOwnerInstructionUnchecked =
      e.decodeInitializeImmutableOwnerInstruction =
      e.createInitializeImmutableOwnerInstruction =
      e.initializeImmutableOwnerInstructionData =
        void 0);
  const t = xe,
    n = V,
    r = be,
    i = Ze;
  e.initializeImmutableOwnerInstructionData = (0, t.struct)([(0, t.u8)('instruction')]);
  function o(s, l) {
    const u = [{ pubkey: s, isSigner: !1, isWritable: !0 }],
      d = Y.alloc(e.initializeImmutableOwnerInstructionData.span);
    return (
      e.initializeImmutableOwnerInstructionData.encode(
        { instruction: i.TokenInstruction.InitializeImmutableOwner },
        d
      ),
      new n.TransactionInstruction({ keys: u, programId: l, data: d })
    );
  }
  e.createInitializeImmutableOwnerInstruction = o;
  function a(s, l) {
    if (!s.programId.equals(l)) throw new r.TokenInvalidInstructionProgramError();
    if (s.data.length !== e.initializeImmutableOwnerInstructionData.span)
      throw new r.TokenInvalidInstructionDataError();
    const {
      keys: { account: u },
      data: d,
    } = c(s);
    if (d.instruction !== i.TokenInstruction.InitializeImmutableOwner)
      throw new r.TokenInvalidInstructionTypeError();
    if (!u) throw new r.TokenInvalidInstructionKeysError();
    return { programId: l, keys: { account: u }, data: d };
  }
  e.decodeInitializeImmutableOwnerInstruction = a;
  function c({ programId: s, keys: [l], data: u }) {
    const { instruction: d } = e.initializeImmutableOwnerInstructionData.decode(u);
    return { programId: s, keys: { account: l }, data: { instruction: d } };
  }
  e.decodeInitializeImmutableOwnerInstructionUnchecked = c;
})(Zk);
var Qk = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeInitializeMintCloseAuthorityInstructionUnchecked =
      e.decodeInitializeMintCloseAuthorityInstruction =
      e.createInitializeMintCloseAuthorityInstruction =
      e.initializeMintCloseAuthorityInstructionData =
        void 0);
  const t = xe,
    n = gt,
    r = V,
    i = ye,
    o = be,
    a = Ze;
  e.initializeMintCloseAuthorityInstructionData = (0, t.struct)([
    (0, t.u8)('instruction'),
    (0, t.u8)('closeAuthorityOption'),
    (0, n.publicKey)('closeAuthority'),
  ]);
  function c(u, d, f) {
    if (!(0, i.programSupportsExtensions)(f)) throw new o.TokenUnsupportedInstructionError();
    const p = [{ pubkey: u, isSigner: !1, isWritable: !0 }],
      y = Y.alloc(e.initializeMintCloseAuthorityInstructionData.span);
    return (
      e.initializeMintCloseAuthorityInstructionData.encode(
        {
          instruction: a.TokenInstruction.InitializeMintCloseAuthority,
          closeAuthorityOption: d ? 1 : 0,
          closeAuthority: d || new r.PublicKey(0),
        },
        y
      ),
      new r.TransactionInstruction({ keys: p, programId: f, data: y })
    );
  }
  e.createInitializeMintCloseAuthorityInstruction = c;
  function s(u, d) {
    if (!u.programId.equals(d)) throw new o.TokenInvalidInstructionProgramError();
    if (u.data.length !== e.initializeMintCloseAuthorityInstructionData.span)
      throw new o.TokenInvalidInstructionDataError();
    const {
      keys: { mint: f },
      data: p,
    } = l(u);
    if (p.instruction !== a.TokenInstruction.InitializeMintCloseAuthority)
      throw new o.TokenInvalidInstructionTypeError();
    if (!f) throw new o.TokenInvalidInstructionKeysError();
    return { programId: d, keys: { mint: f }, data: p };
  }
  e.decodeInitializeMintCloseAuthorityInstruction = s;
  function l({ programId: u, keys: [d], data: f }) {
    const {
      instruction: p,
      closeAuthorityOption: y,
      closeAuthority: b,
    } = e.initializeMintCloseAuthorityInstructionData.decode(f);
    return {
      programId: u,
      keys: { mint: d },
      data: { instruction: p, closeAuthority: y ? b : null },
    };
  }
  e.decodeInitializeMintCloseAuthorityInstructionUnchecked = l;
})(Qk);
var Jg = {};
Object.defineProperty(Jg, '__esModule', { value: !0 });
Jg.createReallocateInstruction = void 0;
const ah = xe,
  Vv = V,
  Kv = ye,
  $W = be,
  WW = xt,
  VW = Ze;
function KW(e, t, n, r, i = [], o = Kv.TOKEN_2022_PROGRAM_ID) {
  if (!(0, Kv.programSupportsExtensions)(o)) throw new $W.TokenUnsupportedInstructionError();
  const a = [
      { pubkey: e, isSigner: !1, isWritable: !0 },
      { pubkey: t, isSigner: !0, isWritable: !0 },
      { pubkey: Vv.SystemProgram.programId, isSigner: !1, isWritable: !1 },
    ],
    c = (0, WW.addSigners)(a, r, i),
    s = (0, ah.struct)([
      (0, ah.u8)('instruction'),
      (0, ah.seq)((0, ah.u16)(), n.length, 'extensionTypes'),
    ]),
    l = Y.alloc(s.span);
  return (
    s.encode({ instruction: VW.TokenInstruction.Reallocate, extensionTypes: n }, l),
    new Vv.TransactionInstruction({ keys: c, programId: o, data: l })
  );
}
Jg.createReallocateInstruction = KW;
var Jk = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createInitializeNonTransferableMintInstruction =
      e.initializeNonTransferableMintInstructionData =
        void 0);
  const t = xe,
    n = V,
    r = ye,
    i = be,
    o = Ze;
  e.initializeNonTransferableMintInstructionData = (0, t.struct)([(0, t.u8)('instruction')]);
  function a(c, s) {
    if (!(0, r.programSupportsExtensions)(s)) throw new i.TokenUnsupportedInstructionError();
    const l = [{ pubkey: c, isSigner: !1, isWritable: !0 }],
      u = Y.alloc(e.initializeNonTransferableMintInstructionData.span);
    return (
      e.initializeNonTransferableMintInstructionData.encode(
        { instruction: o.TokenInstruction.InitializeNonTransferableMint },
        u
      ),
      new n.TransactionInstruction({ keys: l, programId: s, data: u })
    );
  }
  e.createInitializeNonTransferableMintInstruction = a;
})(Jk);
var Xk = {};
(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.decodeInitializePermanentDelegateInstructionUnchecked =
      e.decodeInitializePermanentDelegateInstruction =
      e.createInitializePermanentDelegateInstruction =
      e.initializePermanentDelegateInstructionData =
        void 0);
  const t = xe,
    n = gt,
    r = V,
    i = V,
    o = ye,
    a = be,
    c = Ze;
  e.initializePermanentDelegateInstructionData = (0, t.struct)([
    (0, t.u8)('instruction'),
    (0, n.publicKey)('delegate'),
  ]);
  function s(d, f, p) {
    if (!(0, o.programSupportsExtensions)(p)) throw new a.TokenUnsupportedInstructionError();
    const y = [{ pubkey: d, isSigner: !1, isWritable: !0 }],
      b = Y.alloc(e.initializePermanentDelegateInstructionData.span);
    return (
      e.initializePermanentDelegateInstructionData.encode(
        {
          instruction: c.TokenInstruction.InitializePermanentDelegate,
          delegate: f || new r.PublicKey(0),
        },
        b
      ),
      new i.TransactionInstruction({ keys: y, programId: p, data: b })
    );
  }
  e.createInitializePermanentDelegateInstruction = s;
  function l(d, f) {
    if (!d.programId.equals(f)) throw new a.TokenInvalidInstructionProgramError();
    if (d.data.length !== e.initializePermanentDelegateInstructionData.span)
      throw new a.TokenInvalidInstructionDataError();
    const {
      keys: { mint: p },
      data: y,
    } = u(d);
    if (y.instruction !== c.TokenInstruction.InitializePermanentDelegate)
      throw new a.TokenInvalidInstructionTypeError();
    if (!p) throw new a.TokenInvalidInstructionKeysError();
    return { programId: f, keys: { mint: p }, data: y };
  }
  e.decodeInitializePermanentDelegateInstruction = l;
  function u({ programId: d, keys: [f], data: p }) {
    const { instruction: y, delegate: b } = e.initializePermanentDelegateInstructionData.decode(p);
    return { programId: d, keys: { mint: f }, data: { instruction: y, delegate: b } };
  }
  e.decodeInitializePermanentDelegateInstructionUnchecked = u;
})(Xk);
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (r, i, o, a) {
            a === void 0 && (a = o);
            var c = Object.getOwnPropertyDescriptor(i, o);
            (!c || ('get' in c ? !i.__esModule : c.writable || c.configurable)) &&
              (c = {
                enumerable: !0,
                get: function () {
                  return i[o];
                },
              }),
              Object.defineProperty(r, a, c);
          }
        : function (r, i, o, a) {
            a === void 0 && (a = o), (r[a] = i[o]);
          }),
    n =
      (g && g.__exportStar) ||
      function (r, i) {
        for (var o in r)
          o !== 'default' && !Object.prototype.hasOwnProperty.call(i, o) && t(i, r, o);
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    n(Wr, e),
    n(Me, e),
    n(Ze, e),
    n(Qg, e),
    n(Sf, e),
    n(Mg, e),
    n(qg, e),
    n(hg, e),
    n(zg, e),
    n($g, e),
    n(jg, e),
    n(bg, e),
    n(vg, e),
    n(Rg, e),
    n(Kg, e),
    n(Yg, e),
    n(gg, e),
    n(Ug, e),
    n(wg, e),
    n(L1, e),
    n(If, e),
    n(z1, e),
    n(Yk, e),
    n(kg, e),
    n(Zk, e),
    n(dg, e),
    n($r, e),
    n(Qk, e),
    n(Jg, e),
    n(N1, e),
    n(Jk, e),
    n(Xk, e);
})(Gk);
var eC = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (r, i, o, a) {
            a === void 0 && (a = o);
            var c = Object.getOwnPropertyDescriptor(i, o);
            (!c || ('get' in c ? !i.__esModule : c.writable || c.configurable)) &&
              (c = {
                enumerable: !0,
                get: function () {
                  return i[o];
                },
              }),
              Object.defineProperty(r, a, c);
          }
        : function (r, i, o, a) {
            a === void 0 && (a = o), (r[a] = i[o]);
          }),
    n =
      (g && g.__exportStar) ||
      function (r, i) {
        for (var o in r)
          o !== 'default' && !Object.prototype.hasOwnProperty.call(i, o) && t(i, r, o);
      };
  Object.defineProperty(e, '__esModule', { value: !0 }), n(vf(), e), n(ho(), e), n(Ss, e);
})(eC);
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (r, i, o, a) {
            a === void 0 && (a = o);
            var c = Object.getOwnPropertyDescriptor(i, o);
            (!c || ('get' in c ? !i.__esModule : c.writable || c.configurable)) &&
              (c = {
                enumerable: !0,
                get: function () {
                  return i[o];
                },
              }),
              Object.defineProperty(r, a, c);
          }
        : function (r, i, o, a) {
            a === void 0 && (a = o), (r[a] = i[o]);
          }),
    n =
      (g && g.__exportStar) ||
      function (r, i) {
        for (var o in r)
          o !== 'default' && !Object.prototype.hasOwnProperty.call(i, o) && t(i, r, o);
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    n(mk, e),
    n(ye, e),
    n(be, e),
    n(Wk, e),
    n(Gk, e),
    n(eC, e);
})(In);
var Ef = {},
  HW =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  qW =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  GW =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && HW(t, e, n);
      return qW(t, e), t;
    };
Object.defineProperty(Ef, '__esModule', { value: !0 });
Ef.approveUseAuthorityArgsBeet = void 0;
const Hv = GW(W);
Ef.approveUseAuthorityArgsBeet = new Hv.BeetArgsStruct(
  [['numberOfUses', Hv.u64]],
  'ApproveUseAuthorityArgs'
);
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (l, u, d, f) {
            f === void 0 && (f = d);
            var p = Object.getOwnPropertyDescriptor(u, d);
            (!p || ('get' in p ? !u.__esModule : p.writable || p.configurable)) &&
              (p = {
                enumerable: !0,
                get: function () {
                  return u[d];
                },
              }),
              Object.defineProperty(l, f, p);
          }
        : function (l, u, d, f) {
            f === void 0 && (f = d), (l[f] = u[d]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (l, u) {
            Object.defineProperty(l, 'default', { enumerable: !0, value: u });
          }
        : function (l, u) {
            l.default = u;
          }),
    r =
      (g && g.__importStar) ||
      function (l) {
        if (l && l.__esModule) return l;
        var u = {};
        if (l != null)
          for (var d in l)
            d !== 'default' && Object.prototype.hasOwnProperty.call(l, d) && t(u, l, d);
        return n(u, l), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createApproveUseAuthorityInstruction =
      e.approveUseAuthorityInstructionDiscriminator =
      e.ApproveUseAuthorityStruct =
        void 0);
  const i = r(In),
    o = r(W),
    a = r(V),
    c = Ef;
  (e.ApproveUseAuthorityStruct = new o.BeetArgsStruct(
    [
      ['instructionDiscriminator', o.u8],
      ['approveUseAuthorityArgs', c.approveUseAuthorityArgsBeet],
    ],
    'ApproveUseAuthorityInstructionArgs'
  )),
    (e.approveUseAuthorityInstructionDiscriminator = 20);
  function s(l, u, d = new a.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var f, p;
    const [y] = e.ApproveUseAuthorityStruct.serialize({
        instructionDiscriminator: e.approveUseAuthorityInstructionDiscriminator,
        ...u,
      }),
      b = [
        { pubkey: l.useAuthorityRecord, isWritable: !0, isSigner: !1 },
        { pubkey: l.owner, isWritable: !0, isSigner: !0 },
        { pubkey: l.payer, isWritable: !0, isSigner: !0 },
        { pubkey: l.user, isWritable: !1, isSigner: !1 },
        { pubkey: l.ownerTokenAccount, isWritable: !0, isSigner: !1 },
        { pubkey: l.metadata, isWritable: !1, isSigner: !1 },
        { pubkey: l.mint, isWritable: !1, isSigner: !1 },
        { pubkey: l.burner, isWritable: !1, isSigner: !1 },
        {
          pubkey: (f = l.tokenProgram) !== null && f !== void 0 ? f : i.TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (p = l.systemProgram) !== null && p !== void 0 ? p : a.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return (
      l.rent != null && b.push({ pubkey: l.rent, isWritable: !1, isSigner: !1 }),
      new a.TransactionInstruction({ programId: d, keys: b, data: y })
    );
  }
  e.createApproveUseAuthorityInstruction = s;
})(bk);
var tC = {},
  As = {},
  YW =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  ZW =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  QW =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && YW(t, e, n);
      return ZW(t, e), t;
    };
Object.defineProperty(As, '__esModule', { value: !0 });
As.setCollectionSizeArgsBeet = void 0;
const qv = QW(W);
As.setCollectionSizeArgsBeet = new qv.BeetArgsStruct([['size', qv.u64]], 'SetCollectionSizeArgs');
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (s, l, u, d) {
            d === void 0 && (d = u);
            var f = Object.getOwnPropertyDescriptor(l, u);
            (!f || ('get' in f ? !l.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return l[u];
                },
              }),
              Object.defineProperty(s, d, f);
          }
        : function (s, l, u, d) {
            d === void 0 && (d = u), (s[d] = l[u]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (s, l) {
            Object.defineProperty(s, 'default', { enumerable: !0, value: l });
          }
        : function (s, l) {
            s.default = l;
          }),
    r =
      (g && g.__importStar) ||
      function (s) {
        if (s && s.__esModule) return s;
        var l = {};
        if (s != null)
          for (var u in s)
            u !== 'default' && Object.prototype.hasOwnProperty.call(s, u) && t(l, s, u);
        return n(l, s), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createBubblegumSetCollectionSizeInstruction =
      e.bubblegumSetCollectionSizeInstructionDiscriminator =
      e.BubblegumSetCollectionSizeStruct =
        void 0);
  const i = r(W),
    o = r(V),
    a = As;
  (e.BubblegumSetCollectionSizeStruct = new i.BeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['setCollectionSizeArgs', a.setCollectionSizeArgsBeet],
    ],
    'BubblegumSetCollectionSizeInstructionArgs'
  )),
    (e.bubblegumSetCollectionSizeInstructionDiscriminator = 36);
  function c(s, l, u = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [d] = e.BubblegumSetCollectionSizeStruct.serialize({
        instructionDiscriminator: e.bubblegumSetCollectionSizeInstructionDiscriminator,
        ...l,
      }),
      f = [
        { pubkey: s.collectionMetadata, isWritable: !0, isSigner: !1 },
        { pubkey: s.collectionAuthority, isWritable: !0, isSigner: !0 },
        { pubkey: s.collectionMint, isWritable: !1, isSigner: !1 },
        { pubkey: s.bubblegumSigner, isWritable: !1, isSigner: !0 },
      ];
    return (
      s.collectionAuthorityRecord != null &&
        f.push({ pubkey: s.collectionAuthorityRecord, isWritable: !1, isSigner: !1 }),
      new o.TransactionInstruction({ programId: u, keys: f, data: d })
    );
  }
  e.createBubblegumSetCollectionSizeInstruction = c;
})(tC);
var nC = {},
  Ko = {},
  JW =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  XW =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  eV =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && JW(t, e, n);
      return XW(t, e), t;
    };
Object.defineProperty(Ko, '__esModule', { value: !0 });
Ko.burnArgsBeet = Ko.isBurnArgsV1 = void 0;
const Ob = eV(W),
  tV = (e) => e.__kind === 'V1';
Ko.isBurnArgsV1 = tV;
Ko.burnArgsBeet = Ob.dataEnum([
  ['V1', new Ob.BeetArgsStruct([['amount', Ob.u64]], 'BurnArgsRecord["V1"]')],
]);
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (s, l, u, d) {
            d === void 0 && (d = u);
            var f = Object.getOwnPropertyDescriptor(l, u);
            (!f || ('get' in f ? !l.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return l[u];
                },
              }),
              Object.defineProperty(s, d, f);
          }
        : function (s, l, u, d) {
            d === void 0 && (d = u), (s[d] = l[u]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (s, l) {
            Object.defineProperty(s, 'default', { enumerable: !0, value: l });
          }
        : function (s, l) {
            s.default = l;
          }),
    r =
      (g && g.__importStar) ||
      function (s) {
        if (s && s.__esModule) return s;
        var l = {};
        if (s != null)
          for (var u in s)
            u !== 'default' && Object.prototype.hasOwnProperty.call(s, u) && t(l, s, u);
        return n(l, s), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createBurnInstruction = e.burnInstructionDiscriminator = e.BurnStruct = void 0);
  const i = r(W),
    o = r(V),
    a = Ko;
  (e.BurnStruct = new i.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['burnArgs', a.burnArgsBeet],
    ],
    'BurnInstructionArgs'
  )),
    (e.burnInstructionDiscriminator = 41);
  function c(s, l, u = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var d, f, p, y, b, m, w, _;
    const [S] = e.BurnStruct.serialize({
        instructionDiscriminator: e.burnInstructionDiscriminator,
        ...l,
      }),
      E = [
        { pubkey: s.authority, isWritable: !0, isSigner: !0 },
        {
          pubkey: (d = s.collectionMetadata) !== null && d !== void 0 ? d : u,
          isWritable: s.collectionMetadata != null,
          isSigner: !1,
        },
        { pubkey: s.metadata, isWritable: !0, isSigner: !1 },
        {
          pubkey: (f = s.edition) !== null && f !== void 0 ? f : u,
          isWritable: s.edition != null,
          isSigner: !1,
        },
        { pubkey: s.mint, isWritable: !0, isSigner: !1 },
        { pubkey: s.token, isWritable: !0, isSigner: !1 },
        {
          pubkey: (p = s.masterEdition) !== null && p !== void 0 ? p : u,
          isWritable: s.masterEdition != null,
          isSigner: !1,
        },
        {
          pubkey: (y = s.masterEditionMint) !== null && y !== void 0 ? y : u,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (b = s.masterEditionToken) !== null && b !== void 0 ? b : u,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (m = s.editionMarker) !== null && m !== void 0 ? m : u,
          isWritable: s.editionMarker != null,
          isSigner: !1,
        },
        {
          pubkey: (w = s.tokenRecord) !== null && w !== void 0 ? w : u,
          isWritable: s.tokenRecord != null,
          isSigner: !1,
        },
        {
          pubkey: (_ = s.systemProgram) !== null && _ !== void 0 ? _ : o.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: s.sysvarInstructions, isWritable: !1, isSigner: !1 },
        { pubkey: s.splTokenProgram, isWritable: !1, isSigner: !1 },
      ];
    return new o.TransactionInstruction({ programId: u, keys: E, data: S });
  }
  e.createBurnInstruction = c;
})(nC);
var rC = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (c, s, l, u) {
            u === void 0 && (u = l);
            var d = Object.getOwnPropertyDescriptor(s, l);
            (!d || ('get' in d ? !s.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return s[l];
                },
              }),
              Object.defineProperty(c, u, d);
          }
        : function (c, s, l, u) {
            u === void 0 && (u = l), (c[u] = s[l]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (c, s) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: s });
          }
        : function (c, s) {
            c.default = s;
          }),
    r =
      (g && g.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var s = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(s, c, l);
        return n(s, c), s;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createBurnEditionNftInstruction =
      e.burnEditionNftInstructionDiscriminator =
      e.BurnEditionNftStruct =
        void 0);
  const i = r(W),
    o = r(V);
  (e.BurnEditionNftStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'BurnEditionNftInstructionArgs'
  )),
    (e.burnEditionNftInstructionDiscriminator = 37);
  function a(c, s = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [l] = e.BurnEditionNftStruct.serialize({
        instructionDiscriminator: e.burnEditionNftInstructionDiscriminator,
      }),
      u = [
        { pubkey: c.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: c.owner, isWritable: !0, isSigner: !0 },
        { pubkey: c.printEditionMint, isWritable: !0, isSigner: !1 },
        { pubkey: c.masterEditionMint, isWritable: !1, isSigner: !1 },
        { pubkey: c.printEditionTokenAccount, isWritable: !0, isSigner: !1 },
        { pubkey: c.masterEditionTokenAccount, isWritable: !1, isSigner: !1 },
        { pubkey: c.masterEditionAccount, isWritable: !0, isSigner: !1 },
        { pubkey: c.printEditionAccount, isWritable: !0, isSigner: !1 },
        { pubkey: c.editionMarkerAccount, isWritable: !0, isSigner: !1 },
        { pubkey: c.splTokenProgram, isWritable: !1, isSigner: !1 },
      ];
    return new o.TransactionInstruction({ programId: s, keys: u, data: l });
  }
  e.createBurnEditionNftInstruction = a;
})(rC);
var iC = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (c, s, l, u) {
            u === void 0 && (u = l);
            var d = Object.getOwnPropertyDescriptor(s, l);
            (!d || ('get' in d ? !s.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return s[l];
                },
              }),
              Object.defineProperty(c, u, d);
          }
        : function (c, s, l, u) {
            u === void 0 && (u = l), (c[u] = s[l]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (c, s) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: s });
          }
        : function (c, s) {
            c.default = s;
          }),
    r =
      (g && g.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var s = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(s, c, l);
        return n(s, c), s;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createBurnNftInstruction = e.burnNftInstructionDiscriminator = e.BurnNftStruct = void 0);
  const i = r(W),
    o = r(V);
  (e.BurnNftStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'BurnNftInstructionArgs'
  )),
    (e.burnNftInstructionDiscriminator = 29);
  function a(c, s = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [l] = e.BurnNftStruct.serialize({
        instructionDiscriminator: e.burnNftInstructionDiscriminator,
      }),
      u = [
        { pubkey: c.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: c.owner, isWritable: !0, isSigner: !0 },
        { pubkey: c.mint, isWritable: !0, isSigner: !1 },
        { pubkey: c.tokenAccount, isWritable: !0, isSigner: !1 },
        { pubkey: c.masterEditionAccount, isWritable: !0, isSigner: !1 },
        { pubkey: c.splTokenProgram, isWritable: !1, isSigner: !1 },
      ];
    return (
      c.collectionMetadata != null &&
        u.push({ pubkey: c.collectionMetadata, isWritable: !0, isSigner: !1 }),
      new o.TransactionInstruction({ programId: s, keys: u, data: l })
    );
  }
  e.createBurnNftInstruction = a;
})(iC);
var oC = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (c, s, l, u) {
            u === void 0 && (u = l);
            var d = Object.getOwnPropertyDescriptor(s, l);
            (!d || ('get' in d ? !s.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return s[l];
                },
              }),
              Object.defineProperty(c, u, d);
          }
        : function (c, s, l, u) {
            u === void 0 && (u = l), (c[u] = s[l]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (c, s) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: s });
          }
        : function (c, s) {
            c.default = s;
          }),
    r =
      (g && g.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var s = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(s, c, l);
        return n(s, c), s;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createCloseEscrowAccountInstruction =
      e.closeEscrowAccountInstructionDiscriminator =
      e.CloseEscrowAccountStruct =
        void 0);
  const i = r(W),
    o = r(V);
  (e.CloseEscrowAccountStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'CloseEscrowAccountInstructionArgs'
  )),
    (e.closeEscrowAccountInstructionDiscriminator = 39);
  function a(c, s = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var l;
    const [u] = e.CloseEscrowAccountStruct.serialize({
        instructionDiscriminator: e.closeEscrowAccountInstructionDiscriminator,
      }),
      d = [
        { pubkey: c.escrow, isWritable: !0, isSigner: !1 },
        { pubkey: c.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: c.mint, isWritable: !1, isSigner: !1 },
        { pubkey: c.tokenAccount, isWritable: !1, isSigner: !1 },
        { pubkey: c.edition, isWritable: !1, isSigner: !1 },
        { pubkey: c.payer, isWritable: !0, isSigner: !0 },
        {
          pubkey: (l = c.systemProgram) !== null && l !== void 0 ? l : o.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: c.sysvarInstructions, isWritable: !1, isSigner: !1 },
      ];
    return new o.TransactionInstruction({ programId: s, keys: d, data: u });
  }
  e.createCloseEscrowAccountInstruction = a;
})(oC);
var aC = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (c, s, l, u) {
            u === void 0 && (u = l);
            var d = Object.getOwnPropertyDescriptor(s, l);
            (!d || ('get' in d ? !s.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return s[l];
                },
              }),
              Object.defineProperty(c, u, d);
          }
        : function (c, s, l, u) {
            u === void 0 && (u = l), (c[u] = s[l]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (c, s) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: s });
          }
        : function (c, s) {
            c.default = s;
          }),
    r =
      (g && g.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var s = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(s, c, l);
        return n(s, c), s;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createCollectInstruction = e.collectInstructionDiscriminator = e.CollectStruct = void 0);
  const i = r(W),
    o = r(V);
  (e.CollectStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'CollectInstructionArgs'
  )),
    (e.collectInstructionDiscriminator = 54);
  function a(c, s = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [l] = e.CollectStruct.serialize({
        instructionDiscriminator: e.collectInstructionDiscriminator,
      }),
      u = [
        { pubkey: c.authority, isWritable: !1, isSigner: !0 },
        { pubkey: c.pdaAccount, isWritable: !1, isSigner: !1 },
      ];
    return new o.TransactionInstruction({ programId: s, keys: u, data: l });
  }
  e.createCollectInstruction = a;
})(aC);
var sC = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (c, s, l, u) {
            u === void 0 && (u = l);
            var d = Object.getOwnPropertyDescriptor(s, l);
            (!d || ('get' in d ? !s.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return s[l];
                },
              }),
              Object.defineProperty(c, u, d);
          }
        : function (c, s, l, u) {
            u === void 0 && (u = l), (c[u] = s[l]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (c, s) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: s });
          }
        : function (c, s) {
            c.default = s;
          }),
    r =
      (g && g.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var s = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(s, c, l);
        return n(s, c), s;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createConvertMasterEditionV1ToV2Instruction =
      e.convertMasterEditionV1ToV2InstructionDiscriminator =
      e.ConvertMasterEditionV1ToV2Struct =
        void 0);
  const i = r(W),
    o = r(V);
  (e.ConvertMasterEditionV1ToV2Struct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'ConvertMasterEditionV1ToV2InstructionArgs'
  )),
    (e.convertMasterEditionV1ToV2InstructionDiscriminator = 12);
  function a(c, s = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [l] = e.ConvertMasterEditionV1ToV2Struct.serialize({
        instructionDiscriminator: e.convertMasterEditionV1ToV2InstructionDiscriminator,
      }),
      u = [
        { pubkey: c.masterEdition, isWritable: !0, isSigner: !1 },
        { pubkey: c.oneTimeAuth, isWritable: !0, isSigner: !1 },
        { pubkey: c.printingMint, isWritable: !0, isSigner: !1 },
      ];
    return new o.TransactionInstruction({ programId: s, keys: u, data: l });
  }
  e.createConvertMasterEditionV1ToV2Instruction = a;
})(sC);
var cC = {},
  Ho = {},
  Tf = {},
  nV =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  rV =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  uC =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && nV(t, e, n);
      return rV(t, e), t;
    };
Object.defineProperty(Tf, '__esModule', { value: !0 });
Tf.assetDataBeet = void 0;
const Rn = uC(W),
  iV = uC(st),
  oV = da,
  aV = vs,
  sV = bi,
  cV = mi,
  uV = wr;
Tf.assetDataBeet = new Rn.FixableBeetArgsStruct(
  [
    ['name', Rn.utf8String],
    ['symbol', Rn.utf8String],
    ['uri', Rn.utf8String],
    ['sellerFeeBasisPoints', Rn.u16],
    ['creators', Rn.coption(Rn.array(oV.creatorBeet))],
    ['primarySaleHappened', Rn.bool],
    ['isMutable', Rn.bool],
    ['tokenStandard', aV.tokenStandardBeet],
    ['collection', Rn.coption(sV.collectionBeet)],
    ['uses', Rn.coption(cV.usesBeet)],
    ['collectionDetails', Rn.coption(uV.collectionDetailsBeet)],
    ['ruleSet', Rn.coption(iV.publicKey)],
  ],
  'AssetData'
);
var ur = {},
  lV =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  dV =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  fV =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && lV(t, e, n);
      return dV(t, e), t;
    };
Object.defineProperty(ur, '__esModule', { value: !0 });
ur.printSupplyBeet =
  ur.isPrintSupplyUnlimited =
  ur.isPrintSupplyLimited =
  ur.isPrintSupplyZero =
    void 0;
const ma = fV(W),
  hV = (e) => e.__kind === 'Zero';
ur.isPrintSupplyZero = hV;
const pV = (e) => e.__kind === 'Limited';
ur.isPrintSupplyLimited = pV;
const gV = (e) => e.__kind === 'Unlimited';
ur.isPrintSupplyUnlimited = gV;
ur.printSupplyBeet = ma.dataEnum([
  ['Zero', ma.unit],
  [
    'Limited',
    new ma.BeetArgsStruct(
      [['fields', ma.fixedSizeTuple([ma.u64])]],
      'PrintSupplyRecord["Limited"]'
    ),
  ],
  ['Unlimited', ma.unit],
]);
var yV =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  bV =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  mV =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && yV(t, e, n);
      return bV(t, e), t;
    };
Object.defineProperty(Ho, '__esModule', { value: !0 });
Ho.createArgsBeet = Ho.isCreateArgsV1 = void 0;
const Fs = mV(W),
  wV = Tf,
  _V = ur,
  vV = (e) => e.__kind === 'V1';
Ho.isCreateArgsV1 = vV;
Ho.createArgsBeet = Fs.dataEnum([
  [
    'V1',
    new Fs.FixableBeetArgsStruct(
      [
        ['assetData', wV.assetDataBeet],
        ['decimals', Fs.coption(Fs.u8)],
        ['printSupply', Fs.coption(_V.printSupplyBeet)],
      ],
      'CreateArgsRecord["V1"]'
    ),
  ],
]);
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (s, l, u, d) {
            d === void 0 && (d = u);
            var f = Object.getOwnPropertyDescriptor(l, u);
            (!f || ('get' in f ? !l.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return l[u];
                },
              }),
              Object.defineProperty(s, d, f);
          }
        : function (s, l, u, d) {
            d === void 0 && (d = u), (s[d] = l[u]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (s, l) {
            Object.defineProperty(s, 'default', { enumerable: !0, value: l });
          }
        : function (s, l) {
            s.default = l;
          }),
    r =
      (g && g.__importStar) ||
      function (s) {
        if (s && s.__esModule) return s;
        var l = {};
        if (s != null)
          for (var u in s)
            u !== 'default' && Object.prototype.hasOwnProperty.call(s, u) && t(l, s, u);
        return n(l, s), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createCreateInstruction = e.createInstructionDiscriminator = e.CreateStruct = void 0);
  const i = r(W),
    o = r(V),
    a = Ho;
  (e.CreateStruct = new i.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['createArgs', a.createArgsBeet],
    ],
    'CreateInstructionArgs'
  )),
    (e.createInstructionDiscriminator = 42);
  function c(s, l, u = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var d, f;
    const [p] = e.CreateStruct.serialize({
        instructionDiscriminator: e.createInstructionDiscriminator,
        ...l,
      }),
      y = [
        { pubkey: s.metadata, isWritable: !0, isSigner: !1 },
        {
          pubkey: (d = s.masterEdition) !== null && d !== void 0 ? d : u,
          isWritable: s.masterEdition != null,
          isSigner: !1,
        },
        { pubkey: s.mint, isWritable: !0, isSigner: !1 },
        { pubkey: s.authority, isWritable: !1, isSigner: !0 },
        { pubkey: s.payer, isWritable: !0, isSigner: !0 },
        { pubkey: s.updateAuthority, isWritable: !1, isSigner: !1 },
        {
          pubkey: (f = s.systemProgram) !== null && f !== void 0 ? f : o.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: s.sysvarInstructions, isWritable: !1, isSigner: !1 },
        { pubkey: s.splTokenProgram, isWritable: !1, isSigner: !1 },
      ];
    return new o.TransactionInstruction({ programId: u, keys: y, data: p });
  }
  e.createCreateInstruction = c;
})(cC);
var lC = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (c, s, l, u) {
            u === void 0 && (u = l);
            var d = Object.getOwnPropertyDescriptor(s, l);
            (!d || ('get' in d ? !s.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return s[l];
                },
              }),
              Object.defineProperty(c, u, d);
          }
        : function (c, s, l, u) {
            u === void 0 && (u = l), (c[u] = s[l]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (c, s) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: s });
          }
        : function (c, s) {
            c.default = s;
          }),
    r =
      (g && g.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var s = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(s, c, l);
        return n(s, c), s;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createCreateEscrowAccountInstruction =
      e.createEscrowAccountInstructionDiscriminator =
      e.CreateEscrowAccountStruct =
        void 0);
  const i = r(W),
    o = r(V);
  (e.CreateEscrowAccountStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'CreateEscrowAccountInstructionArgs'
  )),
    (e.createEscrowAccountInstructionDiscriminator = 38);
  function a(c, s = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var l;
    const [u] = e.CreateEscrowAccountStruct.serialize({
        instructionDiscriminator: e.createEscrowAccountInstructionDiscriminator,
      }),
      d = [
        { pubkey: c.escrow, isWritable: !0, isSigner: !1 },
        { pubkey: c.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: c.mint, isWritable: !1, isSigner: !1 },
        { pubkey: c.tokenAccount, isWritable: !1, isSigner: !1 },
        { pubkey: c.edition, isWritable: !1, isSigner: !1 },
        { pubkey: c.payer, isWritable: !0, isSigner: !0 },
        {
          pubkey: (l = c.systemProgram) !== null && l !== void 0 ? l : o.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: c.sysvarInstructions, isWritable: !1, isSigner: !1 },
      ];
    return (
      c.authority != null && d.push({ pubkey: c.authority, isWritable: !1, isSigner: !0 }),
      new o.TransactionInstruction({ programId: s, keys: d, data: u })
    );
  }
  e.createCreateEscrowAccountInstruction = a;
})(lC);
var dC = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (s, l, u, d) {
            d === void 0 && (d = u);
            var f = Object.getOwnPropertyDescriptor(l, u);
            (!f || ('get' in f ? !l.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return l[u];
                },
              }),
              Object.defineProperty(s, d, f);
          }
        : function (s, l, u, d) {
            d === void 0 && (d = u), (s[d] = l[u]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (s, l) {
            Object.defineProperty(s, 'default', { enumerable: !0, value: l });
          }
        : function (s, l) {
            s.default = l;
          }),
    r =
      (g && g.__importStar) ||
      function (s) {
        if (s && s.__esModule) return s;
        var l = {};
        if (s != null)
          for (var u in s)
            u !== 'default' && Object.prototype.hasOwnProperty.call(s, u) && t(l, s, u);
        return n(l, s), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createCreateMasterEditionInstruction =
      e.createMasterEditionInstructionDiscriminator =
      e.CreateMasterEditionStruct =
        void 0);
  const i = r(In),
    o = r(W),
    a = r(V);
  (e.CreateMasterEditionStruct = new o.BeetArgsStruct(
    [['instructionDiscriminator', o.u8]],
    'CreateMasterEditionInstructionArgs'
  )),
    (e.createMasterEditionInstructionDiscriminator = 10);
  function c(s, l = new a.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var u, d, f;
    const [p] = e.CreateMasterEditionStruct.serialize({
        instructionDiscriminator: e.createMasterEditionInstructionDiscriminator,
      }),
      y = [
        { pubkey: s.edition, isWritable: !0, isSigner: !1 },
        { pubkey: s.mint, isWritable: !0, isSigner: !1 },
        { pubkey: s.updateAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: s.mintAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: s.payer, isWritable: !0, isSigner: !0 },
        { pubkey: s.metadata, isWritable: !1, isSigner: !1 },
        {
          pubkey: (u = s.tokenProgram) !== null && u !== void 0 ? u : i.TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (d = s.systemProgram) !== null && d !== void 0 ? d : a.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (f = s.rent) !== null && f !== void 0 ? f : a.SYSVAR_RENT_PUBKEY,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return new a.TransactionInstruction({ programId: l, keys: y, data: p });
  }
  e.createCreateMasterEditionInstruction = c;
})(dC);
var fC = {},
  kf = {},
  SV =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  AV =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  IV =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && SV(t, e, n);
      return AV(t, e), t;
    };
Object.defineProperty(kf, '__esModule', { value: !0 });
kf.createMasterEditionArgsBeet = void 0;
const Db = IV(W);
kf.createMasterEditionArgsBeet = new Db.FixableBeetArgsStruct(
  [['maxSupply', Db.coption(Db.u64)]],
  'CreateMasterEditionArgs'
);
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (l, u, d, f) {
            f === void 0 && (f = d);
            var p = Object.getOwnPropertyDescriptor(u, d);
            (!p || ('get' in p ? !u.__esModule : p.writable || p.configurable)) &&
              (p = {
                enumerable: !0,
                get: function () {
                  return u[d];
                },
              }),
              Object.defineProperty(l, f, p);
          }
        : function (l, u, d, f) {
            f === void 0 && (f = d), (l[f] = u[d]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (l, u) {
            Object.defineProperty(l, 'default', { enumerable: !0, value: u });
          }
        : function (l, u) {
            l.default = u;
          }),
    r =
      (g && g.__importStar) ||
      function (l) {
        if (l && l.__esModule) return l;
        var u = {};
        if (l != null)
          for (var d in l)
            d !== 'default' && Object.prototype.hasOwnProperty.call(l, d) && t(u, l, d);
        return n(u, l), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createCreateMasterEditionV3Instruction =
      e.createMasterEditionV3InstructionDiscriminator =
      e.CreateMasterEditionV3Struct =
        void 0);
  const i = r(In),
    o = r(W),
    a = r(V),
    c = kf;
  (e.CreateMasterEditionV3Struct = new o.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', o.u8],
      ['createMasterEditionArgs', c.createMasterEditionArgsBeet],
    ],
    'CreateMasterEditionV3InstructionArgs'
  )),
    (e.createMasterEditionV3InstructionDiscriminator = 17);
  function s(l, u, d = new a.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var f, p;
    const [y] = e.CreateMasterEditionV3Struct.serialize({
        instructionDiscriminator: e.createMasterEditionV3InstructionDiscriminator,
        ...u,
      }),
      b = [
        { pubkey: l.edition, isWritable: !0, isSigner: !1 },
        { pubkey: l.mint, isWritable: !0, isSigner: !1 },
        { pubkey: l.updateAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: l.mintAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: l.payer, isWritable: !0, isSigner: !0 },
        { pubkey: l.metadata, isWritable: !0, isSigner: !1 },
        {
          pubkey: (f = l.tokenProgram) !== null && f !== void 0 ? f : i.TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (p = l.systemProgram) !== null && p !== void 0 ? p : a.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return (
      l.rent != null && b.push({ pubkey: l.rent, isWritable: !1, isSigner: !1 }),
      new a.TransactionInstruction({ programId: d, keys: b, data: y })
    );
  }
  e.createCreateMasterEditionV3Instruction = s;
})(fC);
var hC = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (c, s, l, u) {
            u === void 0 && (u = l);
            var d = Object.getOwnPropertyDescriptor(s, l);
            (!d || ('get' in d ? !s.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return s[l];
                },
              }),
              Object.defineProperty(c, u, d);
          }
        : function (c, s, l, u) {
            u === void 0 && (u = l), (c[u] = s[l]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (c, s) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: s });
          }
        : function (c, s) {
            c.default = s;
          }),
    r =
      (g && g.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var s = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(s, c, l);
        return n(s, c), s;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createCreateMetadataAccountInstruction =
      e.createMetadataAccountInstructionDiscriminator =
      e.CreateMetadataAccountStruct =
        void 0);
  const i = r(W),
    o = r(V);
  (e.CreateMetadataAccountStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'CreateMetadataAccountInstructionArgs'
  )),
    (e.createMetadataAccountInstructionDiscriminator = 0);
  function a(c, s = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var l, u;
    const [d] = e.CreateMetadataAccountStruct.serialize({
        instructionDiscriminator: e.createMetadataAccountInstructionDiscriminator,
      }),
      f = [
        { pubkey: c.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: c.mint, isWritable: !1, isSigner: !1 },
        { pubkey: c.mintAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: c.payer, isWritable: !0, isSigner: !0 },
        { pubkey: c.updateAuthority, isWritable: !1, isSigner: !1 },
        {
          pubkey: (l = c.systemProgram) !== null && l !== void 0 ? l : o.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (u = c.rent) !== null && u !== void 0 ? u : o.SYSVAR_RENT_PUBKEY,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return new o.TransactionInstruction({ programId: s, keys: f, data: d });
  }
  e.createCreateMetadataAccountInstruction = a;
})(hC);
var pC = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (c, s, l, u) {
            u === void 0 && (u = l);
            var d = Object.getOwnPropertyDescriptor(s, l);
            (!d || ('get' in d ? !s.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return s[l];
                },
              }),
              Object.defineProperty(c, u, d);
          }
        : function (c, s, l, u) {
            u === void 0 && (u = l), (c[u] = s[l]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (c, s) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: s });
          }
        : function (c, s) {
            c.default = s;
          }),
    r =
      (g && g.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var s = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(s, c, l);
        return n(s, c), s;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createCreateMetadataAccountV2Instruction =
      e.createMetadataAccountV2InstructionDiscriminator =
      e.CreateMetadataAccountV2Struct =
        void 0);
  const i = r(W),
    o = r(V);
  (e.CreateMetadataAccountV2Struct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'CreateMetadataAccountV2InstructionArgs'
  )),
    (e.createMetadataAccountV2InstructionDiscriminator = 16);
  function a(c, s = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var l;
    const [u] = e.CreateMetadataAccountV2Struct.serialize({
        instructionDiscriminator: e.createMetadataAccountV2InstructionDiscriminator,
      }),
      d = [
        { pubkey: c.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: c.mint, isWritable: !1, isSigner: !1 },
        { pubkey: c.mintAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: c.payer, isWritable: !0, isSigner: !0 },
        { pubkey: c.updateAuthority, isWritable: !1, isSigner: !1 },
        {
          pubkey: (l = c.systemProgram) !== null && l !== void 0 ? l : o.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return (
      c.rent != null && d.push({ pubkey: c.rent, isWritable: !1, isSigner: !1 }),
      new o.TransactionInstruction({ programId: s, keys: d, data: u })
    );
  }
  e.createCreateMetadataAccountV2Instruction = a;
})(pC);
var gC = {},
  Cf = {},
  Is = {},
  EV =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  TV =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  kV =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && EV(t, e, n);
      return TV(t, e), t;
    };
Object.defineProperty(Is, '__esModule', { value: !0 });
Is.dataV2Beet = void 0;
const qr = kV(W),
  CV = da,
  MV = bi,
  PV = mi;
Is.dataV2Beet = new qr.FixableBeetArgsStruct(
  [
    ['name', qr.utf8String],
    ['symbol', qr.utf8String],
    ['uri', qr.utf8String],
    ['sellerFeeBasisPoints', qr.u16],
    ['creators', qr.coption(qr.array(CV.creatorBeet))],
    ['collection', qr.coption(MV.collectionBeet)],
    ['uses', qr.coption(PV.usesBeet)],
  ],
  'DataV2'
);
var OV =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  DV =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  RV =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && OV(t, e, n);
      return DV(t, e), t;
    };
Object.defineProperty(Cf, '__esModule', { value: !0 });
Cf.createMetadataAccountArgsV3Beet = void 0;
const Rb = RV(W),
  xV = Is,
  BV = wr;
Cf.createMetadataAccountArgsV3Beet = new Rb.FixableBeetArgsStruct(
  [
    ['data', xV.dataV2Beet],
    ['isMutable', Rb.bool],
    ['collectionDetails', Rb.coption(BV.collectionDetailsBeet)],
  ],
  'CreateMetadataAccountArgsV3'
);
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (s, l, u, d) {
            d === void 0 && (d = u);
            var f = Object.getOwnPropertyDescriptor(l, u);
            (!f || ('get' in f ? !l.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return l[u];
                },
              }),
              Object.defineProperty(s, d, f);
          }
        : function (s, l, u, d) {
            d === void 0 && (d = u), (s[d] = l[u]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (s, l) {
            Object.defineProperty(s, 'default', { enumerable: !0, value: l });
          }
        : function (s, l) {
            s.default = l;
          }),
    r =
      (g && g.__importStar) ||
      function (s) {
        if (s && s.__esModule) return s;
        var l = {};
        if (s != null)
          for (var u in s)
            u !== 'default' && Object.prototype.hasOwnProperty.call(s, u) && t(l, s, u);
        return n(l, s), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createCreateMetadataAccountV3Instruction =
      e.createMetadataAccountV3InstructionDiscriminator =
      e.CreateMetadataAccountV3Struct =
        void 0);
  const i = r(W),
    o = r(V),
    a = Cf;
  (e.CreateMetadataAccountV3Struct = new i.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['createMetadataAccountArgsV3', a.createMetadataAccountArgsV3Beet],
    ],
    'CreateMetadataAccountV3InstructionArgs'
  )),
    (e.createMetadataAccountV3InstructionDiscriminator = 33);
  function c(s, l, u = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var d;
    const [f] = e.CreateMetadataAccountV3Struct.serialize({
        instructionDiscriminator: e.createMetadataAccountV3InstructionDiscriminator,
        ...l,
      }),
      p = [
        { pubkey: s.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: s.mint, isWritable: !1, isSigner: !1 },
        { pubkey: s.mintAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: s.payer, isWritable: !0, isSigner: !0 },
        { pubkey: s.updateAuthority, isWritable: !1, isSigner: !1 },
        {
          pubkey: (d = s.systemProgram) !== null && d !== void 0 ? d : o.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return (
      s.rent != null && p.push({ pubkey: s.rent, isWritable: !1, isSigner: !1 }),
      new o.TransactionInstruction({ programId: u, keys: p, data: f })
    );
  }
  e.createCreateMetadataAccountV3Instruction = c;
})(gC);
var yC = {},
  at = {},
  _r = {},
  Mf = {},
  jn = {},
  Pf = {},
  jV =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  NV =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  UV =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && jV(t, e, n);
      return NV(t, e), t;
    };
Object.defineProperty(Pf, '__esModule', { value: !0 });
Pf.seedsVecBeet = void 0;
const xb = UV(W);
Pf.seedsVecBeet = new xb.FixableBeetArgsStruct([['seeds', xb.array(xb.bytes)]], 'SeedsVec');
var Of = {},
  LV =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  zV =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  FV =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && LV(t, e, n);
      return zV(t, e), t;
    };
Object.defineProperty(Of, '__esModule', { value: !0 });
Of.leafInfoBeet = void 0;
const wa = FV(W);
Of.leafInfoBeet = new wa.FixableBeetArgsStruct(
  [
    ['leaf', wa.uniformFixedSizeArray(wa.u8, 32)],
    ['proof', wa.array(wa.uniformFixedSizeArray(wa.u8, 32))],
  ],
  'LeafInfo'
);
var $V =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  WV =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  bC =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && $V(t, e, n);
      return WV(t, e), t;
    };
Object.defineProperty(jn, '__esModule', { value: !0 });
jn.payloadTypeBeet =
  jn.isPayloadTypeNumber =
  jn.isPayloadTypeMerkleProof =
  jn.isPayloadTypeSeeds =
  jn.isPayloadTypePubkey =
    void 0;
const kr = bC(W),
  VV = bC(st),
  KV = Pf,
  HV = Of,
  qV = (e) => e.__kind === 'Pubkey';
jn.isPayloadTypePubkey = qV;
const GV = (e) => e.__kind === 'Seeds';
jn.isPayloadTypeSeeds = GV;
const YV = (e) => e.__kind === 'MerkleProof';
jn.isPayloadTypeMerkleProof = YV;
const ZV = (e) => e.__kind === 'Number';
jn.isPayloadTypeNumber = ZV;
jn.payloadTypeBeet = kr.dataEnum([
  [
    'Pubkey',
    new kr.BeetArgsStruct(
      [['fields', kr.fixedSizeTuple([VV.publicKey])]],
      'PayloadTypeRecord["Pubkey"]'
    ),
  ],
  [
    'Seeds',
    new kr.FixableBeetArgsStruct(
      [['fields', kr.tuple([KV.seedsVecBeet])]],
      'PayloadTypeRecord["Seeds"]'
    ),
  ],
  [
    'MerkleProof',
    new kr.FixableBeetArgsStruct(
      [['fields', kr.tuple([HV.leafInfoBeet])]],
      'PayloadTypeRecord["MerkleProof"]'
    ),
  ],
  [
    'Number',
    new kr.BeetArgsStruct([['fields', kr.fixedSizeTuple([kr.u64])]], 'PayloadTypeRecord["Number"]'),
  ],
]);
var QV =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  JV =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  XV =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && QV(t, e, n);
      return JV(t, e), t;
    };
Object.defineProperty(Mf, '__esModule', { value: !0 });
Mf.payloadBeet = void 0;
const Bb = XV(W),
  eK = jn;
Mf.payloadBeet = new Bb.FixableBeetArgsStruct(
  [['map', Bb.map(Bb.utf8String, eK.payloadTypeBeet)]],
  'Payload'
);
var tK =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  nK =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  rK =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && tK(t, e, n);
      return nK(t, e), t;
    };
Object.defineProperty(_r, '__esModule', { value: !0 });
_r.authorizationDataBeet = void 0;
const iK = rK(W),
  oK = Mf;
_r.authorizationDataBeet = new iK.FixableBeetArgsStruct(
  [['payload', oK.payloadBeet]],
  'AuthorizationData'
);
var aK =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  sK =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  mC =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && aK(t, e, n);
      return sK(t, e), t;
    };
Object.defineProperty(at, '__esModule', { value: !0 });
at.delegateArgsBeet =
  at.isDelegateArgsProgrammableConfigItemV1 =
  at.isDelegateArgsCollectionItemV1 =
  at.isDelegateArgsDataItemV1 =
  at.isDelegateArgsAuthorityItemV1 =
  at.isDelegateArgsProgrammableConfigV1 =
  at.isDelegateArgsLockedTransferV1 =
  at.isDelegateArgsStandardV1 =
  at.isDelegateArgsStakingV1 =
  at.isDelegateArgsUtilityV1 =
  at.isDelegateArgsDataV1 =
  at.isDelegateArgsTransferV1 =
  at.isDelegateArgsSaleV1 =
  at.isDelegateArgsCollectionV1 =
    void 0;
const it = mC(W),
  cK = mC(st),
  Vn = _r,
  uK = (e) => e.__kind === 'CollectionV1';
at.isDelegateArgsCollectionV1 = uK;
const lK = (e) => e.__kind === 'SaleV1';
at.isDelegateArgsSaleV1 = lK;
const dK = (e) => e.__kind === 'TransferV1';
at.isDelegateArgsTransferV1 = dK;
const fK = (e) => e.__kind === 'DataV1';
at.isDelegateArgsDataV1 = fK;
const hK = (e) => e.__kind === 'UtilityV1';
at.isDelegateArgsUtilityV1 = hK;
const pK = (e) => e.__kind === 'StakingV1';
at.isDelegateArgsStakingV1 = pK;
const gK = (e) => e.__kind === 'StandardV1';
at.isDelegateArgsStandardV1 = gK;
const yK = (e) => e.__kind === 'LockedTransferV1';
at.isDelegateArgsLockedTransferV1 = yK;
const bK = (e) => e.__kind === 'ProgrammableConfigV1';
at.isDelegateArgsProgrammableConfigV1 = bK;
const mK = (e) => e.__kind === 'AuthorityItemV1';
at.isDelegateArgsAuthorityItemV1 = mK;
const wK = (e) => e.__kind === 'DataItemV1';
at.isDelegateArgsDataItemV1 = wK;
const _K = (e) => e.__kind === 'CollectionItemV1';
at.isDelegateArgsCollectionItemV1 = _K;
const vK = (e) => e.__kind === 'ProgrammableConfigItemV1';
at.isDelegateArgsProgrammableConfigItemV1 = vK;
at.delegateArgsBeet = it.dataEnum([
  [
    'CollectionV1',
    new it.FixableBeetArgsStruct(
      [['authorizationData', it.coption(Vn.authorizationDataBeet)]],
      'DelegateArgsRecord["CollectionV1"]'
    ),
  ],
  [
    'SaleV1',
    new it.FixableBeetArgsStruct(
      [
        ['amount', it.u64],
        ['authorizationData', it.coption(Vn.authorizationDataBeet)],
      ],
      'DelegateArgsRecord["SaleV1"]'
    ),
  ],
  [
    'TransferV1',
    new it.FixableBeetArgsStruct(
      [
        ['amount', it.u64],
        ['authorizationData', it.coption(Vn.authorizationDataBeet)],
      ],
      'DelegateArgsRecord["TransferV1"]'
    ),
  ],
  [
    'DataV1',
    new it.FixableBeetArgsStruct(
      [['authorizationData', it.coption(Vn.authorizationDataBeet)]],
      'DelegateArgsRecord["DataV1"]'
    ),
  ],
  [
    'UtilityV1',
    new it.FixableBeetArgsStruct(
      [
        ['amount', it.u64],
        ['authorizationData', it.coption(Vn.authorizationDataBeet)],
      ],
      'DelegateArgsRecord["UtilityV1"]'
    ),
  ],
  [
    'StakingV1',
    new it.FixableBeetArgsStruct(
      [
        ['amount', it.u64],
        ['authorizationData', it.coption(Vn.authorizationDataBeet)],
      ],
      'DelegateArgsRecord["StakingV1"]'
    ),
  ],
  ['StandardV1', new it.BeetArgsStruct([['amount', it.u64]], 'DelegateArgsRecord["StandardV1"]')],
  [
    'LockedTransferV1',
    new it.FixableBeetArgsStruct(
      [
        ['amount', it.u64],
        ['lockedAddress', cK.publicKey],
        ['authorizationData', it.coption(Vn.authorizationDataBeet)],
      ],
      'DelegateArgsRecord["LockedTransferV1"]'
    ),
  ],
  [
    'ProgrammableConfigV1',
    new it.FixableBeetArgsStruct(
      [['authorizationData', it.coption(Vn.authorizationDataBeet)]],
      'DelegateArgsRecord["ProgrammableConfigV1"]'
    ),
  ],
  [
    'AuthorityItemV1',
    new it.FixableBeetArgsStruct(
      [['authorizationData', it.coption(Vn.authorizationDataBeet)]],
      'DelegateArgsRecord["AuthorityItemV1"]'
    ),
  ],
  [
    'DataItemV1',
    new it.FixableBeetArgsStruct(
      [['authorizationData', it.coption(Vn.authorizationDataBeet)]],
      'DelegateArgsRecord["DataItemV1"]'
    ),
  ],
  [
    'CollectionItemV1',
    new it.FixableBeetArgsStruct(
      [['authorizationData', it.coption(Vn.authorizationDataBeet)]],
      'DelegateArgsRecord["CollectionItemV1"]'
    ),
  ],
  [
    'ProgrammableConfigItemV1',
    new it.FixableBeetArgsStruct(
      [['authorizationData', it.coption(Vn.authorizationDataBeet)]],
      'DelegateArgsRecord["ProgrammableConfigItemV1"]'
    ),
  ],
]);
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (s, l, u, d) {
            d === void 0 && (d = u);
            var f = Object.getOwnPropertyDescriptor(l, u);
            (!f || ('get' in f ? !l.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return l[u];
                },
              }),
              Object.defineProperty(s, d, f);
          }
        : function (s, l, u, d) {
            d === void 0 && (d = u), (s[d] = l[u]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (s, l) {
            Object.defineProperty(s, 'default', { enumerable: !0, value: l });
          }
        : function (s, l) {
            s.default = l;
          }),
    r =
      (g && g.__importStar) ||
      function (s) {
        if (s && s.__esModule) return s;
        var l = {};
        if (s != null)
          for (var u in s)
            u !== 'default' && Object.prototype.hasOwnProperty.call(s, u) && t(l, s, u);
        return n(l, s), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createDelegateInstruction = e.delegateInstructionDiscriminator = e.DelegateStruct = void 0);
  const i = r(W),
    o = r(V),
    a = at;
  (e.DelegateStruct = new i.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['delegateArgs', a.delegateArgsBeet],
    ],
    'DelegateInstructionArgs'
  )),
    (e.delegateInstructionDiscriminator = 44);
  function c(s, l, u = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var d, f, p, y, b, m, w, _;
    const [S] = e.DelegateStruct.serialize({
        instructionDiscriminator: e.delegateInstructionDiscriminator,
        ...l,
      }),
      E = [
        {
          pubkey: (d = s.delegateRecord) !== null && d !== void 0 ? d : u,
          isWritable: s.delegateRecord != null,
          isSigner: !1,
        },
        { pubkey: s.delegate, isWritable: !1, isSigner: !1 },
        { pubkey: s.metadata, isWritable: !0, isSigner: !1 },
        {
          pubkey: (f = s.masterEdition) !== null && f !== void 0 ? f : u,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (p = s.tokenRecord) !== null && p !== void 0 ? p : u,
          isWritable: s.tokenRecord != null,
          isSigner: !1,
        },
        { pubkey: s.mint, isWritable: !1, isSigner: !1 },
        {
          pubkey: (y = s.token) !== null && y !== void 0 ? y : u,
          isWritable: s.token != null,
          isSigner: !1,
        },
        { pubkey: s.authority, isWritable: !1, isSigner: !0 },
        { pubkey: s.payer, isWritable: !0, isSigner: !0 },
        {
          pubkey: (b = s.systemProgram) !== null && b !== void 0 ? b : o.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: s.sysvarInstructions, isWritable: !1, isSigner: !1 },
        {
          pubkey: (m = s.splTokenProgram) !== null && m !== void 0 ? m : u,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (w = s.authorizationRulesProgram) !== null && w !== void 0 ? w : u,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (_ = s.authorizationRules) !== null && _ !== void 0 ? _ : u,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return new o.TransactionInstruction({ programId: u, keys: E, data: S });
  }
  e.createDelegateInstruction = c;
})(yC);
var wC = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (s, l, u, d) {
            d === void 0 && (d = u);
            var f = Object.getOwnPropertyDescriptor(l, u);
            (!f || ('get' in f ? !l.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return l[u];
                },
              }),
              Object.defineProperty(s, d, f);
          }
        : function (s, l, u, d) {
            d === void 0 && (d = u), (s[d] = l[u]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (s, l) {
            Object.defineProperty(s, 'default', { enumerable: !0, value: l });
          }
        : function (s, l) {
            s.default = l;
          }),
    r =
      (g && g.__importStar) ||
      function (s) {
        if (s && s.__esModule) return s;
        var l = {};
        if (s != null)
          for (var u in s)
            u !== 'default' && Object.prototype.hasOwnProperty.call(s, u) && t(l, s, u);
        return n(l, s), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createDeprecatedCreateMasterEditionInstruction =
      e.deprecatedCreateMasterEditionInstructionDiscriminator =
      e.DeprecatedCreateMasterEditionStruct =
        void 0);
  const i = r(In),
    o = r(W),
    a = r(V);
  (e.DeprecatedCreateMasterEditionStruct = new o.BeetArgsStruct(
    [['instructionDiscriminator', o.u8]],
    'DeprecatedCreateMasterEditionInstructionArgs'
  )),
    (e.deprecatedCreateMasterEditionInstructionDiscriminator = 2);
  function c(s, l = new a.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var u, d, f;
    const [p] = e.DeprecatedCreateMasterEditionStruct.serialize({
        instructionDiscriminator: e.deprecatedCreateMasterEditionInstructionDiscriminator,
      }),
      y = [
        { pubkey: s.edition, isWritable: !0, isSigner: !1 },
        { pubkey: s.mint, isWritable: !0, isSigner: !1 },
        { pubkey: s.printingMint, isWritable: !0, isSigner: !1 },
        { pubkey: s.oneTimePrintingAuthorizationMint, isWritable: !0, isSigner: !1 },
        { pubkey: s.updateAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: s.printingMintAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: s.mintAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: s.metadata, isWritable: !1, isSigner: !1 },
        { pubkey: s.payer, isWritable: !1, isSigner: !0 },
        {
          pubkey: (u = s.tokenProgram) !== null && u !== void 0 ? u : i.TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (d = s.systemProgram) !== null && d !== void 0 ? d : a.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (f = s.rent) !== null && f !== void 0 ? f : a.SYSVAR_RENT_PUBKEY,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: s.oneTimePrintingAuthorizationMintAuthority, isWritable: !1, isSigner: !0 },
      ];
    return new a.TransactionInstruction({ programId: l, keys: y, data: p });
  }
  e.createDeprecatedCreateMasterEditionInstruction = c;
})(wC);
var _C = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (c, s, l, u) {
            u === void 0 && (u = l);
            var d = Object.getOwnPropertyDescriptor(s, l);
            (!d || ('get' in d ? !s.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return s[l];
                },
              }),
              Object.defineProperty(c, u, d);
          }
        : function (c, s, l, u) {
            u === void 0 && (u = l), (c[u] = s[l]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (c, s) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: s });
          }
        : function (c, s) {
            c.default = s;
          }),
    r =
      (g && g.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var s = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(s, c, l);
        return n(s, c), s;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createDeprecatedCreateReservationListInstruction =
      e.deprecatedCreateReservationListInstructionDiscriminator =
      e.DeprecatedCreateReservationListStruct =
        void 0);
  const i = r(W),
    o = r(V);
  (e.DeprecatedCreateReservationListStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'DeprecatedCreateReservationListInstructionArgs'
  )),
    (e.deprecatedCreateReservationListInstructionDiscriminator = 6);
  function a(c, s = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var l, u;
    const [d] = e.DeprecatedCreateReservationListStruct.serialize({
        instructionDiscriminator: e.deprecatedCreateReservationListInstructionDiscriminator,
      }),
      f = [
        { pubkey: c.reservationList, isWritable: !0, isSigner: !1 },
        { pubkey: c.payer, isWritable: !1, isSigner: !0 },
        { pubkey: c.updateAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: c.masterEdition, isWritable: !1, isSigner: !1 },
        { pubkey: c.resource, isWritable: !1, isSigner: !1 },
        { pubkey: c.metadata, isWritable: !1, isSigner: !1 },
        {
          pubkey: (l = c.systemProgram) !== null && l !== void 0 ? l : o.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (u = c.rent) !== null && u !== void 0 ? u : o.SYSVAR_RENT_PUBKEY,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return new o.TransactionInstruction({ programId: s, keys: f, data: d });
  }
  e.createDeprecatedCreateReservationListInstruction = a;
})(_C);
var vC = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (s, l, u, d) {
            d === void 0 && (d = u);
            var f = Object.getOwnPropertyDescriptor(l, u);
            (!f || ('get' in f ? !l.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return l[u];
                },
              }),
              Object.defineProperty(s, d, f);
          }
        : function (s, l, u, d) {
            d === void 0 && (d = u), (s[d] = l[u]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (s, l) {
            Object.defineProperty(s, 'default', { enumerable: !0, value: l });
          }
        : function (s, l) {
            s.default = l;
          }),
    r =
      (g && g.__importStar) ||
      function (s) {
        if (s && s.__esModule) return s;
        var l = {};
        if (s != null)
          for (var u in s)
            u !== 'default' && Object.prototype.hasOwnProperty.call(s, u) && t(l, s, u);
        return n(l, s), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createDeprecatedMintNewEditionFromMasterEditionViaPrintingTokenInstruction =
      e.deprecatedMintNewEditionFromMasterEditionViaPrintingTokenInstructionDiscriminator =
      e.DeprecatedMintNewEditionFromMasterEditionViaPrintingTokenStruct =
        void 0);
  const i = r(In),
    o = r(W),
    a = r(V);
  (e.DeprecatedMintNewEditionFromMasterEditionViaPrintingTokenStruct = new o.BeetArgsStruct(
    [['instructionDiscriminator', o.u8]],
    'DeprecatedMintNewEditionFromMasterEditionViaPrintingTokenInstructionArgs'
  )),
    (e.deprecatedMintNewEditionFromMasterEditionViaPrintingTokenInstructionDiscriminator = 3);
  function c(s, l = new a.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var u, d, f;
    const [p] = e.DeprecatedMintNewEditionFromMasterEditionViaPrintingTokenStruct.serialize({
        instructionDiscriminator:
          e.deprecatedMintNewEditionFromMasterEditionViaPrintingTokenInstructionDiscriminator,
      }),
      y = [
        { pubkey: s.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: s.edition, isWritable: !0, isSigner: !1 },
        { pubkey: s.masterEdition, isWritable: !0, isSigner: !1 },
        { pubkey: s.mint, isWritable: !0, isSigner: !1 },
        { pubkey: s.mintAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: s.printingMint, isWritable: !0, isSigner: !1 },
        { pubkey: s.masterTokenAccount, isWritable: !0, isSigner: !1 },
        { pubkey: s.editionMarker, isWritable: !0, isSigner: !1 },
        { pubkey: s.burnAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: s.payer, isWritable: !1, isSigner: !0 },
        { pubkey: s.masterUpdateAuthority, isWritable: !1, isSigner: !1 },
        { pubkey: s.masterMetadata, isWritable: !1, isSigner: !1 },
        {
          pubkey: (u = s.tokenProgram) !== null && u !== void 0 ? u : i.TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (d = s.systemProgram) !== null && d !== void 0 ? d : a.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (f = s.rent) !== null && f !== void 0 ? f : a.SYSVAR_RENT_PUBKEY,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return (
      s.reservationList != null &&
        y.push({ pubkey: s.reservationList, isWritable: !0, isSigner: !1 }),
      new a.TransactionInstruction({ programId: l, keys: y, data: p })
    );
  }
  e.createDeprecatedMintNewEditionFromMasterEditionViaPrintingTokenInstruction = c;
})(vC);
var SC = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (s, l, u, d) {
            d === void 0 && (d = u);
            var f = Object.getOwnPropertyDescriptor(l, u);
            (!f || ('get' in f ? !l.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return l[u];
                },
              }),
              Object.defineProperty(s, d, f);
          }
        : function (s, l, u, d) {
            d === void 0 && (d = u), (s[d] = l[u]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (s, l) {
            Object.defineProperty(s, 'default', { enumerable: !0, value: l });
          }
        : function (s, l) {
            s.default = l;
          }),
    r =
      (g && g.__importStar) ||
      function (s) {
        if (s && s.__esModule) return s;
        var l = {};
        if (s != null)
          for (var u in s)
            u !== 'default' && Object.prototype.hasOwnProperty.call(s, u) && t(l, s, u);
        return n(l, s), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createDeprecatedMintPrintingTokensInstruction =
      e.deprecatedMintPrintingTokensInstructionDiscriminator =
      e.DeprecatedMintPrintingTokensStruct =
        void 0);
  const i = r(In),
    o = r(W),
    a = r(V);
  (e.DeprecatedMintPrintingTokensStruct = new o.BeetArgsStruct(
    [['instructionDiscriminator', o.u8]],
    'DeprecatedMintPrintingTokensInstructionArgs'
  )),
    (e.deprecatedMintPrintingTokensInstructionDiscriminator = 9);
  function c(s, l = new a.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var u, d;
    const [f] = e.DeprecatedMintPrintingTokensStruct.serialize({
        instructionDiscriminator: e.deprecatedMintPrintingTokensInstructionDiscriminator,
      }),
      p = [
        { pubkey: s.destination, isWritable: !0, isSigner: !1 },
        { pubkey: s.printingMint, isWritable: !0, isSigner: !1 },
        { pubkey: s.updateAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: s.metadata, isWritable: !1, isSigner: !1 },
        { pubkey: s.masterEdition, isWritable: !1, isSigner: !1 },
        {
          pubkey: (u = s.tokenProgram) !== null && u !== void 0 ? u : i.TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (d = s.rent) !== null && d !== void 0 ? d : a.SYSVAR_RENT_PUBKEY,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return new a.TransactionInstruction({ programId: l, keys: p, data: f });
  }
  e.createDeprecatedMintPrintingTokensInstruction = c;
})(SC);
var AC = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (s, l, u, d) {
            d === void 0 && (d = u);
            var f = Object.getOwnPropertyDescriptor(l, u);
            (!f || ('get' in f ? !l.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return l[u];
                },
              }),
              Object.defineProperty(s, d, f);
          }
        : function (s, l, u, d) {
            d === void 0 && (d = u), (s[d] = l[u]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (s, l) {
            Object.defineProperty(s, 'default', { enumerable: !0, value: l });
          }
        : function (s, l) {
            s.default = l;
          }),
    r =
      (g && g.__importStar) ||
      function (s) {
        if (s && s.__esModule) return s;
        var l = {};
        if (s != null)
          for (var u in s)
            u !== 'default' && Object.prototype.hasOwnProperty.call(s, u) && t(l, s, u);
        return n(l, s), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createDeprecatedMintPrintingTokensViaTokenInstruction =
      e.deprecatedMintPrintingTokensViaTokenInstructionDiscriminator =
      e.DeprecatedMintPrintingTokensViaTokenStruct =
        void 0);
  const i = r(In),
    o = r(W),
    a = r(V);
  (e.DeprecatedMintPrintingTokensViaTokenStruct = new o.BeetArgsStruct(
    [['instructionDiscriminator', o.u8]],
    'DeprecatedMintPrintingTokensViaTokenInstructionArgs'
  )),
    (e.deprecatedMintPrintingTokensViaTokenInstructionDiscriminator = 8);
  function c(s, l = new a.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var u, d;
    const [f] = e.DeprecatedMintPrintingTokensViaTokenStruct.serialize({
        instructionDiscriminator: e.deprecatedMintPrintingTokensViaTokenInstructionDiscriminator,
      }),
      p = [
        { pubkey: s.destination, isWritable: !0, isSigner: !1 },
        { pubkey: s.token, isWritable: !0, isSigner: !1 },
        { pubkey: s.oneTimePrintingAuthorizationMint, isWritable: !0, isSigner: !1 },
        { pubkey: s.printingMint, isWritable: !0, isSigner: !1 },
        { pubkey: s.burnAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: s.metadata, isWritable: !1, isSigner: !1 },
        { pubkey: s.masterEdition, isWritable: !1, isSigner: !1 },
        {
          pubkey: (u = s.tokenProgram) !== null && u !== void 0 ? u : i.TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (d = s.rent) !== null && d !== void 0 ? d : a.SYSVAR_RENT_PUBKEY,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return new a.TransactionInstruction({ programId: l, keys: p, data: f });
  }
  e.createDeprecatedMintPrintingTokensViaTokenInstruction = c;
})(AC);
var IC = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (c, s, l, u) {
            u === void 0 && (u = l);
            var d = Object.getOwnPropertyDescriptor(s, l);
            (!d || ('get' in d ? !s.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return s[l];
                },
              }),
              Object.defineProperty(c, u, d);
          }
        : function (c, s, l, u) {
            u === void 0 && (u = l), (c[u] = s[l]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (c, s) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: s });
          }
        : function (c, s) {
            c.default = s;
          }),
    r =
      (g && g.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var s = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(s, c, l);
        return n(s, c), s;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createDeprecatedSetReservationListInstruction =
      e.deprecatedSetReservationListInstructionDiscriminator =
      e.DeprecatedSetReservationListStruct =
        void 0);
  const i = r(W),
    o = r(V);
  (e.DeprecatedSetReservationListStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'DeprecatedSetReservationListInstructionArgs'
  )),
    (e.deprecatedSetReservationListInstructionDiscriminator = 5);
  function a(c, s = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [l] = e.DeprecatedSetReservationListStruct.serialize({
        instructionDiscriminator: e.deprecatedSetReservationListInstructionDiscriminator,
      }),
      u = [
        { pubkey: c.masterEdition, isWritable: !0, isSigner: !1 },
        { pubkey: c.reservationList, isWritable: !0, isSigner: !1 },
        { pubkey: c.resource, isWritable: !1, isSigner: !0 },
      ];
    return new o.TransactionInstruction({ programId: s, keys: u, data: l });
  }
  e.createDeprecatedSetReservationListInstruction = a;
})(IC);
var EC = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (s, l, u, d) {
            d === void 0 && (d = u);
            var f = Object.getOwnPropertyDescriptor(l, u);
            (!f || ('get' in f ? !l.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return l[u];
                },
              }),
              Object.defineProperty(s, d, f);
          }
        : function (s, l, u, d) {
            d === void 0 && (d = u), (s[d] = l[u]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (s, l) {
            Object.defineProperty(s, 'default', { enumerable: !0, value: l });
          }
        : function (s, l) {
            s.default = l;
          }),
    r =
      (g && g.__importStar) ||
      function (s) {
        if (s && s.__esModule) return s;
        var l = {};
        if (s != null)
          for (var u in s)
            u !== 'default' && Object.prototype.hasOwnProperty.call(s, u) && t(l, s, u);
        return n(l, s), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createFreezeDelegatedAccountInstruction =
      e.freezeDelegatedAccountInstructionDiscriminator =
      e.FreezeDelegatedAccountStruct =
        void 0);
  const i = r(In),
    o = r(W),
    a = r(V);
  (e.FreezeDelegatedAccountStruct = new o.BeetArgsStruct(
    [['instructionDiscriminator', o.u8]],
    'FreezeDelegatedAccountInstructionArgs'
  )),
    (e.freezeDelegatedAccountInstructionDiscriminator = 26);
  function c(s, l = new a.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var u;
    const [d] = e.FreezeDelegatedAccountStruct.serialize({
        instructionDiscriminator: e.freezeDelegatedAccountInstructionDiscriminator,
      }),
      f = [
        { pubkey: s.delegate, isWritable: !0, isSigner: !0 },
        { pubkey: s.tokenAccount, isWritable: !0, isSigner: !1 },
        { pubkey: s.edition, isWritable: !1, isSigner: !1 },
        { pubkey: s.mint, isWritable: !1, isSigner: !1 },
        {
          pubkey: (u = s.tokenProgram) !== null && u !== void 0 ? u : i.TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return new a.TransactionInstruction({ programId: l, keys: f, data: d });
  }
  e.createFreezeDelegatedAccountInstruction = c;
})(EC);
var TC = {},
  qo = {},
  SK =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  AK =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  IK =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && SK(t, e, n);
      return AK(t, e), t;
    };
Object.defineProperty(qo, '__esModule', { value: !0 });
qo.lockArgsBeet = qo.isLockArgsV1 = void 0;
const jb = IK(W),
  EK = _r,
  TK = (e) => e.__kind === 'V1';
qo.isLockArgsV1 = TK;
qo.lockArgsBeet = jb.dataEnum([
  [
    'V1',
    new jb.FixableBeetArgsStruct(
      [['authorizationData', jb.coption(EK.authorizationDataBeet)]],
      'LockArgsRecord["V1"]'
    ),
  ],
]);
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (s, l, u, d) {
            d === void 0 && (d = u);
            var f = Object.getOwnPropertyDescriptor(l, u);
            (!f || ('get' in f ? !l.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return l[u];
                },
              }),
              Object.defineProperty(s, d, f);
          }
        : function (s, l, u, d) {
            d === void 0 && (d = u), (s[d] = l[u]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (s, l) {
            Object.defineProperty(s, 'default', { enumerable: !0, value: l });
          }
        : function (s, l) {
            s.default = l;
          }),
    r =
      (g && g.__importStar) ||
      function (s) {
        if (s && s.__esModule) return s;
        var l = {};
        if (s != null)
          for (var u in s)
            u !== 'default' && Object.prototype.hasOwnProperty.call(s, u) && t(l, s, u);
        return n(l, s), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createLockInstruction = e.lockInstructionDiscriminator = e.LockStruct = void 0);
  const i = r(W),
    o = r(V),
    a = qo;
  (e.LockStruct = new i.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['lockArgs', a.lockArgsBeet],
    ],
    'LockInstructionArgs'
  )),
    (e.lockInstructionDiscriminator = 46);
  function c(s, l, u = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var d, f, p, y, b, m, w;
    const [_] = e.LockStruct.serialize({
        instructionDiscriminator: e.lockInstructionDiscriminator,
        ...l,
      }),
      S = [
        { pubkey: s.authority, isWritable: !1, isSigner: !0 },
        {
          pubkey: (d = s.tokenOwner) !== null && d !== void 0 ? d : u,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: s.token, isWritable: !0, isSigner: !1 },
        { pubkey: s.mint, isWritable: !1, isSigner: !1 },
        { pubkey: s.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: (f = s.edition) !== null && f !== void 0 ? f : u, isWritable: !1, isSigner: !1 },
        {
          pubkey: (p = s.tokenRecord) !== null && p !== void 0 ? p : u,
          isWritable: s.tokenRecord != null,
          isSigner: !1,
        },
        { pubkey: s.payer, isWritable: !0, isSigner: !0 },
        {
          pubkey: (y = s.systemProgram) !== null && y !== void 0 ? y : o.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: s.sysvarInstructions, isWritable: !1, isSigner: !1 },
        {
          pubkey: (b = s.splTokenProgram) !== null && b !== void 0 ? b : u,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (m = s.authorizationRulesProgram) !== null && m !== void 0 ? m : u,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (w = s.authorizationRules) !== null && w !== void 0 ? w : u,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return new o.TransactionInstruction({ programId: u, keys: S, data: _ });
  }
  e.createLockInstruction = c;
})(TC);
var kC = {},
  Go = {},
  F1 = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (a, c, s, l) {
            l === void 0 && (l = s);
            var u = Object.getOwnPropertyDescriptor(c, s);
            (!u || ('get' in u ? !c.__esModule : u.writable || u.configurable)) &&
              (u = {
                enumerable: !0,
                get: function () {
                  return c[s];
                },
              }),
              Object.defineProperty(a, l, u);
          }
        : function (a, c, s, l) {
            l === void 0 && (l = s), (a[l] = c[s]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (g && g.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var s in a)
            s !== 'default' && Object.prototype.hasOwnProperty.call(a, s) && t(c, a, s);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.migrationTypeBeet = e.MigrationType = void 0);
  const i = r(W);
  var o;
  (function (a) {
    (a[(a.CollectionV1 = 0)] = 'CollectionV1'), (a[(a.ProgrammableV1 = 1)] = 'ProgrammableV1');
  })((o = e.MigrationType || (e.MigrationType = {}))),
    (e.migrationTypeBeet = i.fixedScalarEnum(o));
})(F1);
var kK =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  CK =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  CC =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && kK(t, e, n);
      return CK(t, e), t;
    };
Object.defineProperty(Go, '__esModule', { value: !0 });
Go.migrateArgsBeet = Go.isMigrateArgsV1 = void 0;
const Nb = CC(W),
  MK = CC(st),
  PK = F1,
  OK = (e) => e.__kind === 'V1';
Go.isMigrateArgsV1 = OK;
Go.migrateArgsBeet = Nb.dataEnum([
  [
    'V1',
    new Nb.FixableBeetArgsStruct(
      [
        ['migrationType', PK.migrationTypeBeet],
        ['ruleSet', Nb.coption(MK.publicKey)],
      ],
      'MigrateArgsRecord["V1"]'
    ),
  ],
]);
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (s, l, u, d) {
            d === void 0 && (d = u);
            var f = Object.getOwnPropertyDescriptor(l, u);
            (!f || ('get' in f ? !l.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return l[u];
                },
              }),
              Object.defineProperty(s, d, f);
          }
        : function (s, l, u, d) {
            d === void 0 && (d = u), (s[d] = l[u]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (s, l) {
            Object.defineProperty(s, 'default', { enumerable: !0, value: l });
          }
        : function (s, l) {
            s.default = l;
          }),
    r =
      (g && g.__importStar) ||
      function (s) {
        if (s && s.__esModule) return s;
        var l = {};
        if (s != null)
          for (var u in s)
            u !== 'default' && Object.prototype.hasOwnProperty.call(s, u) && t(l, s, u);
        return n(l, s), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createMigrateInstruction = e.migrateInstructionDiscriminator = e.MigrateStruct = void 0);
  const i = r(W),
    o = r(V),
    a = Go;
  (e.MigrateStruct = new i.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['migrateArgs', a.migrateArgsBeet],
    ],
    'MigrateInstructionArgs'
  )),
    (e.migrateInstructionDiscriminator = 48);
  function c(s, l, u = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var d, f, p;
    const [y] = e.MigrateStruct.serialize({
        instructionDiscriminator: e.migrateInstructionDiscriminator,
        ...l,
      }),
      b = [
        { pubkey: s.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: s.edition, isWritable: !0, isSigner: !1 },
        { pubkey: s.token, isWritable: !0, isSigner: !1 },
        { pubkey: s.tokenOwner, isWritable: !1, isSigner: !1 },
        { pubkey: s.mint, isWritable: !1, isSigner: !1 },
        { pubkey: s.payer, isWritable: !0, isSigner: !0 },
        { pubkey: s.authority, isWritable: !1, isSigner: !0 },
        { pubkey: s.collectionMetadata, isWritable: !1, isSigner: !1 },
        { pubkey: s.delegateRecord, isWritable: !1, isSigner: !1 },
        { pubkey: s.tokenRecord, isWritable: !0, isSigner: !1 },
        {
          pubkey: (d = s.systemProgram) !== null && d !== void 0 ? d : o.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: s.sysvarInstructions, isWritable: !1, isSigner: !1 },
        { pubkey: s.splTokenProgram, isWritable: !1, isSigner: !1 },
        {
          pubkey: (f = s.authorizationRulesProgram) !== null && f !== void 0 ? f : u,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (p = s.authorizationRules) !== null && p !== void 0 ? p : u,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return new o.TransactionInstruction({ programId: u, keys: b, data: y });
  }
  e.createMigrateInstruction = c;
})(kC);
var MC = {},
  Yo = {},
  DK =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  RK =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  xK =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && DK(t, e, n);
      return RK(t, e), t;
    };
Object.defineProperty(Yo, '__esModule', { value: !0 });
Yo.mintArgsBeet = Yo.isMintArgsV1 = void 0;
const sh = xK(W),
  BK = _r,
  jK = (e) => e.__kind === 'V1';
Yo.isMintArgsV1 = jK;
Yo.mintArgsBeet = sh.dataEnum([
  [
    'V1',
    new sh.FixableBeetArgsStruct(
      [
        ['amount', sh.u64],
        ['authorizationData', sh.coption(BK.authorizationDataBeet)],
      ],
      'MintArgsRecord["V1"]'
    ),
  ],
]);
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (s, l, u, d) {
            d === void 0 && (d = u);
            var f = Object.getOwnPropertyDescriptor(l, u);
            (!f || ('get' in f ? !l.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return l[u];
                },
              }),
              Object.defineProperty(s, d, f);
          }
        : function (s, l, u, d) {
            d === void 0 && (d = u), (s[d] = l[u]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (s, l) {
            Object.defineProperty(s, 'default', { enumerable: !0, value: l });
          }
        : function (s, l) {
            s.default = l;
          }),
    r =
      (g && g.__importStar) ||
      function (s) {
        if (s && s.__esModule) return s;
        var l = {};
        if (s != null)
          for (var u in s)
            u !== 'default' && Object.prototype.hasOwnProperty.call(s, u) && t(l, s, u);
        return n(l, s), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createMintInstruction = e.mintInstructionDiscriminator = e.MintStruct = void 0);
  const i = r(W),
    o = r(V),
    a = Yo;
  (e.MintStruct = new i.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['mintArgs', a.mintArgsBeet],
    ],
    'MintInstructionArgs'
  )),
    (e.mintInstructionDiscriminator = 43);
  function c(s, l, u = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var d, f, p, y, b, m, w;
    const [_] = e.MintStruct.serialize({
        instructionDiscriminator: e.mintInstructionDiscriminator,
        ...l,
      }),
      S = [
        { pubkey: s.token, isWritable: !0, isSigner: !1 },
        {
          pubkey: (d = s.tokenOwner) !== null && d !== void 0 ? d : u,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: s.metadata, isWritable: !1, isSigner: !1 },
        {
          pubkey: (f = s.masterEdition) !== null && f !== void 0 ? f : u,
          isWritable: s.masterEdition != null,
          isSigner: !1,
        },
        {
          pubkey: (p = s.tokenRecord) !== null && p !== void 0 ? p : u,
          isWritable: s.tokenRecord != null,
          isSigner: !1,
        },
        { pubkey: s.mint, isWritable: !0, isSigner: !1 },
        { pubkey: s.authority, isWritable: !1, isSigner: !0 },
        {
          pubkey: (y = s.delegateRecord) !== null && y !== void 0 ? y : u,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: s.payer, isWritable: !0, isSigner: !0 },
        {
          pubkey: (b = s.systemProgram) !== null && b !== void 0 ? b : o.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: s.sysvarInstructions, isWritable: !1, isSigner: !1 },
        { pubkey: s.splTokenProgram, isWritable: !1, isSigner: !1 },
        { pubkey: s.splAtaProgram, isWritable: !1, isSigner: !1 },
        {
          pubkey: (m = s.authorizationRulesProgram) !== null && m !== void 0 ? m : u,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (w = s.authorizationRules) !== null && w !== void 0 ? w : u,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return new o.TransactionInstruction({ programId: u, keys: S, data: _ });
  }
  e.createMintInstruction = c;
})(MC);
var PC = {},
  Es = {},
  NK =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  UK =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  LK =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && NK(t, e, n);
      return UK(t, e), t;
    };
Object.defineProperty(Es, '__esModule', { value: !0 });
Es.mintNewEditionFromMasterEditionViaTokenArgsBeet = void 0;
const Gv = LK(W);
Es.mintNewEditionFromMasterEditionViaTokenArgsBeet = new Gv.BeetArgsStruct(
  [['edition', Gv.u64]],
  'MintNewEditionFromMasterEditionViaTokenArgs'
);
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (l, u, d, f) {
            f === void 0 && (f = d);
            var p = Object.getOwnPropertyDescriptor(u, d);
            (!p || ('get' in p ? !u.__esModule : p.writable || p.configurable)) &&
              (p = {
                enumerable: !0,
                get: function () {
                  return u[d];
                },
              }),
              Object.defineProperty(l, f, p);
          }
        : function (l, u, d, f) {
            f === void 0 && (f = d), (l[f] = u[d]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (l, u) {
            Object.defineProperty(l, 'default', { enumerable: !0, value: u });
          }
        : function (l, u) {
            l.default = u;
          }),
    r =
      (g && g.__importStar) ||
      function (l) {
        if (l && l.__esModule) return l;
        var u = {};
        if (l != null)
          for (var d in l)
            d !== 'default' && Object.prototype.hasOwnProperty.call(l, d) && t(u, l, d);
        return n(u, l), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createMintNewEditionFromMasterEditionViaTokenInstruction =
      e.mintNewEditionFromMasterEditionViaTokenInstructionDiscriminator =
      e.MintNewEditionFromMasterEditionViaTokenStruct =
        void 0);
  const i = r(In),
    o = r(W),
    a = r(V),
    c = Es;
  (e.MintNewEditionFromMasterEditionViaTokenStruct = new o.BeetArgsStruct(
    [
      ['instructionDiscriminator', o.u8],
      [
        'mintNewEditionFromMasterEditionViaTokenArgs',
        c.mintNewEditionFromMasterEditionViaTokenArgsBeet,
      ],
    ],
    'MintNewEditionFromMasterEditionViaTokenInstructionArgs'
  )),
    (e.mintNewEditionFromMasterEditionViaTokenInstructionDiscriminator = 11);
  function s(l, u, d = new a.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var f, p;
    const [y] = e.MintNewEditionFromMasterEditionViaTokenStruct.serialize({
        instructionDiscriminator: e.mintNewEditionFromMasterEditionViaTokenInstructionDiscriminator,
        ...u,
      }),
      b = [
        { pubkey: l.newMetadata, isWritable: !0, isSigner: !1 },
        { pubkey: l.newEdition, isWritable: !0, isSigner: !1 },
        { pubkey: l.masterEdition, isWritable: !0, isSigner: !1 },
        { pubkey: l.newMint, isWritable: !0, isSigner: !1 },
        { pubkey: l.editionMarkPda, isWritable: !0, isSigner: !1 },
        { pubkey: l.newMintAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: l.payer, isWritable: !0, isSigner: !0 },
        { pubkey: l.tokenAccountOwner, isWritable: !1, isSigner: !0 },
        { pubkey: l.tokenAccount, isWritable: !1, isSigner: !1 },
        { pubkey: l.newMetadataUpdateAuthority, isWritable: !1, isSigner: !1 },
        { pubkey: l.metadata, isWritable: !1, isSigner: !1 },
        {
          pubkey: (f = l.tokenProgram) !== null && f !== void 0 ? f : i.TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (p = l.systemProgram) !== null && p !== void 0 ? p : a.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return (
      l.rent != null && b.push({ pubkey: l.rent, isWritable: !1, isSigner: !1 }),
      new a.TransactionInstruction({ programId: d, keys: b, data: y })
    );
  }
  e.createMintNewEditionFromMasterEditionViaTokenInstruction = s;
})(PC);
var OC = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (l, u, d, f) {
            f === void 0 && (f = d);
            var p = Object.getOwnPropertyDescriptor(u, d);
            (!p || ('get' in p ? !u.__esModule : p.writable || p.configurable)) &&
              (p = {
                enumerable: !0,
                get: function () {
                  return u[d];
                },
              }),
              Object.defineProperty(l, f, p);
          }
        : function (l, u, d, f) {
            f === void 0 && (f = d), (l[f] = u[d]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (l, u) {
            Object.defineProperty(l, 'default', { enumerable: !0, value: u });
          }
        : function (l, u) {
            l.default = u;
          }),
    r =
      (g && g.__importStar) ||
      function (l) {
        if (l && l.__esModule) return l;
        var u = {};
        if (l != null)
          for (var d in l)
            d !== 'default' && Object.prototype.hasOwnProperty.call(l, d) && t(u, l, d);
        return n(u, l), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createMintNewEditionFromMasterEditionViaVaultProxyInstruction =
      e.mintNewEditionFromMasterEditionViaVaultProxyInstructionDiscriminator =
      e.MintNewEditionFromMasterEditionViaVaultProxyStruct =
        void 0);
  const i = r(In),
    o = r(W),
    a = r(V),
    c = Es;
  (e.MintNewEditionFromMasterEditionViaVaultProxyStruct = new o.BeetArgsStruct(
    [
      ['instructionDiscriminator', o.u8],
      [
        'mintNewEditionFromMasterEditionViaTokenArgs',
        c.mintNewEditionFromMasterEditionViaTokenArgsBeet,
      ],
    ],
    'MintNewEditionFromMasterEditionViaVaultProxyInstructionArgs'
  )),
    (e.mintNewEditionFromMasterEditionViaVaultProxyInstructionDiscriminator = 13);
  function s(l, u, d = new a.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var f, p;
    const [y] = e.MintNewEditionFromMasterEditionViaVaultProxyStruct.serialize({
        instructionDiscriminator:
          e.mintNewEditionFromMasterEditionViaVaultProxyInstructionDiscriminator,
        ...u,
      }),
      b = [
        { pubkey: l.newMetadata, isWritable: !0, isSigner: !1 },
        { pubkey: l.newEdition, isWritable: !0, isSigner: !1 },
        { pubkey: l.masterEdition, isWritable: !0, isSigner: !1 },
        { pubkey: l.newMint, isWritable: !0, isSigner: !1 },
        { pubkey: l.editionMarkPda, isWritable: !0, isSigner: !1 },
        { pubkey: l.newMintAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: l.payer, isWritable: !0, isSigner: !0 },
        { pubkey: l.vaultAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: l.safetyDepositStore, isWritable: !1, isSigner: !1 },
        { pubkey: l.safetyDepositBox, isWritable: !1, isSigner: !1 },
        { pubkey: l.vault, isWritable: !1, isSigner: !1 },
        { pubkey: l.newMetadataUpdateAuthority, isWritable: !1, isSigner: !1 },
        { pubkey: l.metadata, isWritable: !1, isSigner: !1 },
        {
          pubkey: (f = l.tokenProgram) !== null && f !== void 0 ? f : i.TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: l.tokenVaultProgram, isWritable: !1, isSigner: !1 },
        {
          pubkey: (p = l.systemProgram) !== null && p !== void 0 ? p : a.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return (
      l.rent != null && b.push({ pubkey: l.rent, isWritable: !1, isSigner: !1 }),
      new a.TransactionInstruction({ programId: d, keys: b, data: y })
    );
  }
  e.createMintNewEditionFromMasterEditionViaVaultProxyInstruction = s;
})(OC);
var DC = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (c, s, l, u) {
            u === void 0 && (u = l);
            var d = Object.getOwnPropertyDescriptor(s, l);
            (!d || ('get' in d ? !s.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return s[l];
                },
              }),
              Object.defineProperty(c, u, d);
          }
        : function (c, s, l, u) {
            u === void 0 && (u = l), (c[u] = s[l]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (c, s) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: s });
          }
        : function (c, s) {
            c.default = s;
          }),
    r =
      (g && g.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var s = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(s, c, l);
        return n(s, c), s;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createPuffMetadataInstruction =
      e.puffMetadataInstructionDiscriminator =
      e.PuffMetadataStruct =
        void 0);
  const i = r(W),
    o = r(V);
  (e.PuffMetadataStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'PuffMetadataInstructionArgs'
  )),
    (e.puffMetadataInstructionDiscriminator = 14);
  function a(c, s = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [l] = e.PuffMetadataStruct.serialize({
        instructionDiscriminator: e.puffMetadataInstructionDiscriminator,
      }),
      u = [{ pubkey: c.metadata, isWritable: !0, isSigner: !1 }];
    return new o.TransactionInstruction({ programId: s, keys: u, data: l });
  }
  e.createPuffMetadataInstruction = a;
})(DC);
var RC = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (c, s, l, u) {
            u === void 0 && (u = l);
            var d = Object.getOwnPropertyDescriptor(s, l);
            (!d || ('get' in d ? !s.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return s[l];
                },
              }),
              Object.defineProperty(c, u, d);
          }
        : function (c, s, l, u) {
            u === void 0 && (u = l), (c[u] = s[l]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (c, s) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: s });
          }
        : function (c, s) {
            c.default = s;
          }),
    r =
      (g && g.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var s = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(s, c, l);
        return n(s, c), s;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createRemoveCreatorVerificationInstruction =
      e.removeCreatorVerificationInstructionDiscriminator =
      e.RemoveCreatorVerificationStruct =
        void 0);
  const i = r(W),
    o = r(V);
  (e.RemoveCreatorVerificationStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'RemoveCreatorVerificationInstructionArgs'
  )),
    (e.removeCreatorVerificationInstructionDiscriminator = 28);
  function a(c, s = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [l] = e.RemoveCreatorVerificationStruct.serialize({
        instructionDiscriminator: e.removeCreatorVerificationInstructionDiscriminator,
      }),
      u = [
        { pubkey: c.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: c.creator, isWritable: !1, isSigner: !0 },
      ];
    return new o.TransactionInstruction({ programId: s, keys: u, data: l });
  }
  e.createRemoveCreatorVerificationInstruction = a;
})(RC);
var xC = {},
  $1 = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (a, c, s, l) {
            l === void 0 && (l = s);
            var u = Object.getOwnPropertyDescriptor(c, s);
            (!u || ('get' in u ? !c.__esModule : u.writable || u.configurable)) &&
              (u = {
                enumerable: !0,
                get: function () {
                  return c[s];
                },
              }),
              Object.defineProperty(a, l, u);
          }
        : function (a, c, s, l) {
            l === void 0 && (l = s), (a[l] = c[s]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (g && g.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var s in a)
            s !== 'default' && Object.prototype.hasOwnProperty.call(a, s) && t(c, a, s);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }), (e.revokeArgsBeet = e.RevokeArgs = void 0);
  const i = r(W);
  var o;
  (function (a) {
    (a[(a.CollectionV1 = 0)] = 'CollectionV1'),
      (a[(a.SaleV1 = 1)] = 'SaleV1'),
      (a[(a.TransferV1 = 2)] = 'TransferV1'),
      (a[(a.DataV1 = 3)] = 'DataV1'),
      (a[(a.UtilityV1 = 4)] = 'UtilityV1'),
      (a[(a.StakingV1 = 5)] = 'StakingV1'),
      (a[(a.StandardV1 = 6)] = 'StandardV1'),
      (a[(a.LockedTransferV1 = 7)] = 'LockedTransferV1'),
      (a[(a.ProgrammableConfigV1 = 8)] = 'ProgrammableConfigV1'),
      (a[(a.MigrationV1 = 9)] = 'MigrationV1'),
      (a[(a.AuthorityItemV1 = 10)] = 'AuthorityItemV1'),
      (a[(a.DataItemV1 = 11)] = 'DataItemV1'),
      (a[(a.CollectionItemV1 = 12)] = 'CollectionItemV1'),
      (a[(a.ProgrammableConfigItemV1 = 13)] = 'ProgrammableConfigItemV1');
  })((o = e.RevokeArgs || (e.RevokeArgs = {}))),
    (e.revokeArgsBeet = i.fixedScalarEnum(o));
})($1);
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (s, l, u, d) {
            d === void 0 && (d = u);
            var f = Object.getOwnPropertyDescriptor(l, u);
            (!f || ('get' in f ? !l.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return l[u];
                },
              }),
              Object.defineProperty(s, d, f);
          }
        : function (s, l, u, d) {
            d === void 0 && (d = u), (s[d] = l[u]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (s, l) {
            Object.defineProperty(s, 'default', { enumerable: !0, value: l });
          }
        : function (s, l) {
            s.default = l;
          }),
    r =
      (g && g.__importStar) ||
      function (s) {
        if (s && s.__esModule) return s;
        var l = {};
        if (s != null)
          for (var u in s)
            u !== 'default' && Object.prototype.hasOwnProperty.call(s, u) && t(l, s, u);
        return n(l, s), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createRevokeInstruction = e.revokeInstructionDiscriminator = e.RevokeStruct = void 0);
  const i = r(W),
    o = r(V),
    a = $1;
  (e.RevokeStruct = new i.BeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['revokeArgs', a.revokeArgsBeet],
    ],
    'RevokeInstructionArgs'
  )),
    (e.revokeInstructionDiscriminator = 45);
  function c(s, l, u = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var d, f, p, y, b, m, w, _;
    const [S] = e.RevokeStruct.serialize({
        instructionDiscriminator: e.revokeInstructionDiscriminator,
        ...l,
      }),
      E = [
        {
          pubkey: (d = s.delegateRecord) !== null && d !== void 0 ? d : u,
          isWritable: s.delegateRecord != null,
          isSigner: !1,
        },
        { pubkey: s.delegate, isWritable: !1, isSigner: !1 },
        { pubkey: s.metadata, isWritable: !0, isSigner: !1 },
        {
          pubkey: (f = s.masterEdition) !== null && f !== void 0 ? f : u,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (p = s.tokenRecord) !== null && p !== void 0 ? p : u,
          isWritable: s.tokenRecord != null,
          isSigner: !1,
        },
        { pubkey: s.mint, isWritable: !1, isSigner: !1 },
        {
          pubkey: (y = s.token) !== null && y !== void 0 ? y : u,
          isWritable: s.token != null,
          isSigner: !1,
        },
        { pubkey: s.authority, isWritable: !1, isSigner: !0 },
        { pubkey: s.payer, isWritable: !0, isSigner: !0 },
        {
          pubkey: (b = s.systemProgram) !== null && b !== void 0 ? b : o.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: s.sysvarInstructions, isWritable: !1, isSigner: !1 },
        {
          pubkey: (m = s.splTokenProgram) !== null && m !== void 0 ? m : u,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (w = s.authorizationRulesProgram) !== null && w !== void 0 ? w : u,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (_ = s.authorizationRules) !== null && _ !== void 0 ? _ : u,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return new o.TransactionInstruction({ programId: u, keys: E, data: S });
  }
  e.createRevokeInstruction = c;
})(xC);
var BC = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (c, s, l, u) {
            u === void 0 && (u = l);
            var d = Object.getOwnPropertyDescriptor(s, l);
            (!d || ('get' in d ? !s.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return s[l];
                },
              }),
              Object.defineProperty(c, u, d);
          }
        : function (c, s, l, u) {
            u === void 0 && (u = l), (c[u] = s[l]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (c, s) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: s });
          }
        : function (c, s) {
            c.default = s;
          }),
    r =
      (g && g.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var s = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(s, c, l);
        return n(s, c), s;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createRevokeCollectionAuthorityInstruction =
      e.revokeCollectionAuthorityInstructionDiscriminator =
      e.RevokeCollectionAuthorityStruct =
        void 0);
  const i = r(W),
    o = r(V);
  (e.RevokeCollectionAuthorityStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'RevokeCollectionAuthorityInstructionArgs'
  )),
    (e.revokeCollectionAuthorityInstructionDiscriminator = 24);
  function a(c, s = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [l] = e.RevokeCollectionAuthorityStruct.serialize({
        instructionDiscriminator: e.revokeCollectionAuthorityInstructionDiscriminator,
      }),
      u = [
        { pubkey: c.collectionAuthorityRecord, isWritable: !0, isSigner: !1 },
        { pubkey: c.delegateAuthority, isWritable: !0, isSigner: !1 },
        { pubkey: c.revokeAuthority, isWritable: !0, isSigner: !0 },
        { pubkey: c.metadata, isWritable: !1, isSigner: !1 },
        { pubkey: c.mint, isWritable: !1, isSigner: !1 },
      ];
    return new o.TransactionInstruction({ programId: s, keys: u, data: l });
  }
  e.createRevokeCollectionAuthorityInstruction = a;
})(BC);
var jC = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (s, l, u, d) {
            d === void 0 && (d = u);
            var f = Object.getOwnPropertyDescriptor(l, u);
            (!f || ('get' in f ? !l.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return l[u];
                },
              }),
              Object.defineProperty(s, d, f);
          }
        : function (s, l, u, d) {
            d === void 0 && (d = u), (s[d] = l[u]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (s, l) {
            Object.defineProperty(s, 'default', { enumerable: !0, value: l });
          }
        : function (s, l) {
            s.default = l;
          }),
    r =
      (g && g.__importStar) ||
      function (s) {
        if (s && s.__esModule) return s;
        var l = {};
        if (s != null)
          for (var u in s)
            u !== 'default' && Object.prototype.hasOwnProperty.call(s, u) && t(l, s, u);
        return n(l, s), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createRevokeUseAuthorityInstruction =
      e.revokeUseAuthorityInstructionDiscriminator =
      e.RevokeUseAuthorityStruct =
        void 0);
  const i = r(In),
    o = r(W),
    a = r(V);
  (e.RevokeUseAuthorityStruct = new o.BeetArgsStruct(
    [['instructionDiscriminator', o.u8]],
    'RevokeUseAuthorityInstructionArgs'
  )),
    (e.revokeUseAuthorityInstructionDiscriminator = 21);
  function c(s, l = new a.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var u, d;
    const [f] = e.RevokeUseAuthorityStruct.serialize({
        instructionDiscriminator: e.revokeUseAuthorityInstructionDiscriminator,
      }),
      p = [
        { pubkey: s.useAuthorityRecord, isWritable: !0, isSigner: !1 },
        { pubkey: s.owner, isWritable: !0, isSigner: !0 },
        { pubkey: s.user, isWritable: !1, isSigner: !1 },
        { pubkey: s.ownerTokenAccount, isWritable: !0, isSigner: !1 },
        { pubkey: s.mint, isWritable: !1, isSigner: !1 },
        { pubkey: s.metadata, isWritable: !1, isSigner: !1 },
        {
          pubkey: (u = s.tokenProgram) !== null && u !== void 0 ? u : i.TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (d = s.systemProgram) !== null && d !== void 0 ? d : a.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return (
      s.rent != null && p.push({ pubkey: s.rent, isWritable: !1, isSigner: !1 }),
      new a.TransactionInstruction({ programId: l, keys: p, data: f })
    );
  }
  e.createRevokeUseAuthorityInstruction = c;
})(jC);
var NC = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (c, s, l, u) {
            u === void 0 && (u = l);
            var d = Object.getOwnPropertyDescriptor(s, l);
            (!d || ('get' in d ? !s.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return s[l];
                },
              }),
              Object.defineProperty(c, u, d);
          }
        : function (c, s, l, u) {
            u === void 0 && (u = l), (c[u] = s[l]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (c, s) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: s });
          }
        : function (c, s) {
            c.default = s;
          }),
    r =
      (g && g.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var s = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(s, c, l);
        return n(s, c), s;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createSetAndVerifyCollectionInstruction =
      e.setAndVerifyCollectionInstructionDiscriminator =
      e.SetAndVerifyCollectionStruct =
        void 0);
  const i = r(W),
    o = r(V);
  (e.SetAndVerifyCollectionStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'SetAndVerifyCollectionInstructionArgs'
  )),
    (e.setAndVerifyCollectionInstructionDiscriminator = 25);
  function a(c, s = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [l] = e.SetAndVerifyCollectionStruct.serialize({
        instructionDiscriminator: e.setAndVerifyCollectionInstructionDiscriminator,
      }),
      u = [
        { pubkey: c.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: c.collectionAuthority, isWritable: !0, isSigner: !0 },
        { pubkey: c.payer, isWritable: !0, isSigner: !0 },
        { pubkey: c.updateAuthority, isWritable: !1, isSigner: !1 },
        { pubkey: c.collectionMint, isWritable: !1, isSigner: !1 },
        { pubkey: c.collection, isWritable: !1, isSigner: !1 },
        { pubkey: c.collectionMasterEditionAccount, isWritable: !1, isSigner: !1 },
      ];
    return (
      c.collectionAuthorityRecord != null &&
        u.push({ pubkey: c.collectionAuthorityRecord, isWritable: !1, isSigner: !1 }),
      new o.TransactionInstruction({ programId: s, keys: u, data: l })
    );
  }
  e.createSetAndVerifyCollectionInstruction = a;
})(NC);
var UC = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (c, s, l, u) {
            u === void 0 && (u = l);
            var d = Object.getOwnPropertyDescriptor(s, l);
            (!d || ('get' in d ? !s.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return s[l];
                },
              }),
              Object.defineProperty(c, u, d);
          }
        : function (c, s, l, u) {
            u === void 0 && (u = l), (c[u] = s[l]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (c, s) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: s });
          }
        : function (c, s) {
            c.default = s;
          }),
    r =
      (g && g.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var s = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(s, c, l);
        return n(s, c), s;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createSetAndVerifySizedCollectionItemInstruction =
      e.setAndVerifySizedCollectionItemInstructionDiscriminator =
      e.SetAndVerifySizedCollectionItemStruct =
        void 0);
  const i = r(W),
    o = r(V);
  (e.SetAndVerifySizedCollectionItemStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'SetAndVerifySizedCollectionItemInstructionArgs'
  )),
    (e.setAndVerifySizedCollectionItemInstructionDiscriminator = 32);
  function a(c, s = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [l] = e.SetAndVerifySizedCollectionItemStruct.serialize({
        instructionDiscriminator: e.setAndVerifySizedCollectionItemInstructionDiscriminator,
      }),
      u = [
        { pubkey: c.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: c.collectionAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: c.payer, isWritable: !0, isSigner: !0 },
        { pubkey: c.updateAuthority, isWritable: !1, isSigner: !1 },
        { pubkey: c.collectionMint, isWritable: !1, isSigner: !1 },
        { pubkey: c.collection, isWritable: !0, isSigner: !1 },
        { pubkey: c.collectionMasterEditionAccount, isWritable: !0, isSigner: !1 },
      ];
    return (
      c.collectionAuthorityRecord != null &&
        u.push({ pubkey: c.collectionAuthorityRecord, isWritable: !1, isSigner: !1 }),
      new o.TransactionInstruction({ programId: s, keys: u, data: l })
    );
  }
  e.createSetAndVerifySizedCollectionItemInstruction = a;
})(UC);
var LC = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (s, l, u, d) {
            d === void 0 && (d = u);
            var f = Object.getOwnPropertyDescriptor(l, u);
            (!f || ('get' in f ? !l.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return l[u];
                },
              }),
              Object.defineProperty(s, d, f);
          }
        : function (s, l, u, d) {
            d === void 0 && (d = u), (s[d] = l[u]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (s, l) {
            Object.defineProperty(s, 'default', { enumerable: !0, value: l });
          }
        : function (s, l) {
            s.default = l;
          }),
    r =
      (g && g.__importStar) ||
      function (s) {
        if (s && s.__esModule) return s;
        var l = {};
        if (s != null)
          for (var u in s)
            u !== 'default' && Object.prototype.hasOwnProperty.call(s, u) && t(l, s, u);
        return n(l, s), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createSetCollectionSizeInstruction =
      e.setCollectionSizeInstructionDiscriminator =
      e.SetCollectionSizeStruct =
        void 0);
  const i = r(W),
    o = r(V),
    a = As;
  (e.SetCollectionSizeStruct = new i.BeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['setCollectionSizeArgs', a.setCollectionSizeArgsBeet],
    ],
    'SetCollectionSizeInstructionArgs'
  )),
    (e.setCollectionSizeInstructionDiscriminator = 34);
  function c(s, l, u = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [d] = e.SetCollectionSizeStruct.serialize({
        instructionDiscriminator: e.setCollectionSizeInstructionDiscriminator,
        ...l,
      }),
      f = [
        { pubkey: s.collectionMetadata, isWritable: !0, isSigner: !1 },
        { pubkey: s.collectionAuthority, isWritable: !0, isSigner: !0 },
        { pubkey: s.collectionMint, isWritable: !1, isSigner: !1 },
      ];
    return (
      s.collectionAuthorityRecord != null &&
        f.push({ pubkey: s.collectionAuthorityRecord, isWritable: !1, isSigner: !1 }),
      new o.TransactionInstruction({ programId: u, keys: f, data: d })
    );
  }
  e.createSetCollectionSizeInstruction = c;
})(LC);
var zC = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (c, s, l, u) {
            u === void 0 && (u = l);
            var d = Object.getOwnPropertyDescriptor(s, l);
            (!d || ('get' in d ? !s.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return s[l];
                },
              }),
              Object.defineProperty(c, u, d);
          }
        : function (c, s, l, u) {
            u === void 0 && (u = l), (c[u] = s[l]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (c, s) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: s });
          }
        : function (c, s) {
            c.default = s;
          }),
    r =
      (g && g.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var s = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(s, c, l);
        return n(s, c), s;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createSetTokenStandardInstruction =
      e.setTokenStandardInstructionDiscriminator =
      e.SetTokenStandardStruct =
        void 0);
  const i = r(W),
    o = r(V);
  (e.SetTokenStandardStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'SetTokenStandardInstructionArgs'
  )),
    (e.setTokenStandardInstructionDiscriminator = 35);
  function a(c, s = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [l] = e.SetTokenStandardStruct.serialize({
        instructionDiscriminator: e.setTokenStandardInstructionDiscriminator,
      }),
      u = [
        { pubkey: c.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: c.updateAuthority, isWritable: !0, isSigner: !0 },
        { pubkey: c.mint, isWritable: !1, isSigner: !1 },
      ];
    return (
      c.edition != null && u.push({ pubkey: c.edition, isWritable: !1, isSigner: !1 }),
      new o.TransactionInstruction({ programId: s, keys: u, data: l })
    );
  }
  e.createSetTokenStandardInstruction = a;
})(zC);
var FC = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (c, s, l, u) {
            u === void 0 && (u = l);
            var d = Object.getOwnPropertyDescriptor(s, l);
            (!d || ('get' in d ? !s.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return s[l];
                },
              }),
              Object.defineProperty(c, u, d);
          }
        : function (c, s, l, u) {
            u === void 0 && (u = l), (c[u] = s[l]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (c, s) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: s });
          }
        : function (c, s) {
            c.default = s;
          }),
    r =
      (g && g.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var s = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(s, c, l);
        return n(s, c), s;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createSignMetadataInstruction =
      e.signMetadataInstructionDiscriminator =
      e.SignMetadataStruct =
        void 0);
  const i = r(W),
    o = r(V);
  (e.SignMetadataStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'SignMetadataInstructionArgs'
  )),
    (e.signMetadataInstructionDiscriminator = 7);
  function a(c, s = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [l] = e.SignMetadataStruct.serialize({
        instructionDiscriminator: e.signMetadataInstructionDiscriminator,
      }),
      u = [
        { pubkey: c.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: c.creator, isWritable: !1, isSigner: !0 },
      ];
    return new o.TransactionInstruction({ programId: s, keys: u, data: l });
  }
  e.createSignMetadataInstruction = a;
})(FC);
var $C = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (s, l, u, d) {
            d === void 0 && (d = u);
            var f = Object.getOwnPropertyDescriptor(l, u);
            (!f || ('get' in f ? !l.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return l[u];
                },
              }),
              Object.defineProperty(s, d, f);
          }
        : function (s, l, u, d) {
            d === void 0 && (d = u), (s[d] = l[u]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (s, l) {
            Object.defineProperty(s, 'default', { enumerable: !0, value: l });
          }
        : function (s, l) {
            s.default = l;
          }),
    r =
      (g && g.__importStar) ||
      function (s) {
        if (s && s.__esModule) return s;
        var l = {};
        if (s != null)
          for (var u in s)
            u !== 'default' && Object.prototype.hasOwnProperty.call(s, u) && t(l, s, u);
        return n(l, s), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createThawDelegatedAccountInstruction =
      e.thawDelegatedAccountInstructionDiscriminator =
      e.ThawDelegatedAccountStruct =
        void 0);
  const i = r(In),
    o = r(W),
    a = r(V);
  (e.ThawDelegatedAccountStruct = new o.BeetArgsStruct(
    [['instructionDiscriminator', o.u8]],
    'ThawDelegatedAccountInstructionArgs'
  )),
    (e.thawDelegatedAccountInstructionDiscriminator = 27);
  function c(s, l = new a.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var u;
    const [d] = e.ThawDelegatedAccountStruct.serialize({
        instructionDiscriminator: e.thawDelegatedAccountInstructionDiscriminator,
      }),
      f = [
        { pubkey: s.delegate, isWritable: !0, isSigner: !0 },
        { pubkey: s.tokenAccount, isWritable: !0, isSigner: !1 },
        { pubkey: s.edition, isWritable: !1, isSigner: !1 },
        { pubkey: s.mint, isWritable: !1, isSigner: !1 },
        {
          pubkey: (u = s.tokenProgram) !== null && u !== void 0 ? u : i.TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return new a.TransactionInstruction({ programId: l, keys: f, data: d });
  }
  e.createThawDelegatedAccountInstruction = c;
})($C);
var WC = {},
  Zo = {},
  zK =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  FK =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  $K =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && zK(t, e, n);
      return FK(t, e), t;
    };
Object.defineProperty(Zo, '__esModule', { value: !0 });
Zo.transferArgsBeet = Zo.isTransferArgsV1 = void 0;
const ch = $K(W),
  WK = _r,
  VK = (e) => e.__kind === 'V1';
Zo.isTransferArgsV1 = VK;
Zo.transferArgsBeet = ch.dataEnum([
  [
    'V1',
    new ch.FixableBeetArgsStruct(
      [
        ['amount', ch.u64],
        ['authorizationData', ch.coption(WK.authorizationDataBeet)],
      ],
      'TransferArgsRecord["V1"]'
    ),
  ],
]);
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (s, l, u, d) {
            d === void 0 && (d = u);
            var f = Object.getOwnPropertyDescriptor(l, u);
            (!f || ('get' in f ? !l.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return l[u];
                },
              }),
              Object.defineProperty(s, d, f);
          }
        : function (s, l, u, d) {
            d === void 0 && (d = u), (s[d] = l[u]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (s, l) {
            Object.defineProperty(s, 'default', { enumerable: !0, value: l });
          }
        : function (s, l) {
            s.default = l;
          }),
    r =
      (g && g.__importStar) ||
      function (s) {
        if (s && s.__esModule) return s;
        var l = {};
        if (s != null)
          for (var u in s)
            u !== 'default' && Object.prototype.hasOwnProperty.call(s, u) && t(l, s, u);
        return n(l, s), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createTransferInstruction = e.transferInstructionDiscriminator = e.TransferStruct = void 0);
  const i = r(W),
    o = r(V),
    a = Zo;
  (e.TransferStruct = new i.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['transferArgs', a.transferArgsBeet],
    ],
    'TransferInstructionArgs'
  )),
    (e.transferInstructionDiscriminator = 49);
  function c(s, l, u = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var d, f, p, y, b, m;
    const [w] = e.TransferStruct.serialize({
        instructionDiscriminator: e.transferInstructionDiscriminator,
        ...l,
      }),
      _ = [
        { pubkey: s.token, isWritable: !0, isSigner: !1 },
        { pubkey: s.tokenOwner, isWritable: !1, isSigner: !1 },
        { pubkey: s.destination, isWritable: !0, isSigner: !1 },
        { pubkey: s.destinationOwner, isWritable: !1, isSigner: !1 },
        { pubkey: s.mint, isWritable: !1, isSigner: !1 },
        { pubkey: s.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: (d = s.edition) !== null && d !== void 0 ? d : u, isWritable: !1, isSigner: !1 },
        {
          pubkey: (f = s.ownerTokenRecord) !== null && f !== void 0 ? f : u,
          isWritable: s.ownerTokenRecord != null,
          isSigner: !1,
        },
        {
          pubkey: (p = s.destinationTokenRecord) !== null && p !== void 0 ? p : u,
          isWritable: s.destinationTokenRecord != null,
          isSigner: !1,
        },
        { pubkey: s.authority, isWritable: !1, isSigner: !0 },
        { pubkey: s.payer, isWritable: !0, isSigner: !0 },
        {
          pubkey: (y = s.systemProgram) !== null && y !== void 0 ? y : o.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: s.sysvarInstructions, isWritable: !1, isSigner: !1 },
        { pubkey: s.splTokenProgram, isWritable: !1, isSigner: !1 },
        { pubkey: s.splAtaProgram, isWritable: !1, isSigner: !1 },
        {
          pubkey: (b = s.authorizationRulesProgram) !== null && b !== void 0 ? b : u,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (m = s.authorizationRules) !== null && m !== void 0 ? m : u,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return new o.TransactionInstruction({ programId: u, keys: _, data: w });
  }
  e.createTransferInstruction = c;
})(WC);
var VC = {},
  Df = {},
  KK =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  HK =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  qK =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && KK(t, e, n);
      return HK(t, e), t;
    };
Object.defineProperty(Df, '__esModule', { value: !0 });
Df.transferOutOfEscrowArgsBeet = void 0;
const Yv = qK(W);
Df.transferOutOfEscrowArgsBeet = new Yv.BeetArgsStruct(
  [['amount', Yv.u64]],
  'TransferOutOfEscrowArgs'
);
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (l, u, d, f) {
            f === void 0 && (f = d);
            var p = Object.getOwnPropertyDescriptor(u, d);
            (!p || ('get' in p ? !u.__esModule : p.writable || p.configurable)) &&
              (p = {
                enumerable: !0,
                get: function () {
                  return u[d];
                },
              }),
              Object.defineProperty(l, f, p);
          }
        : function (l, u, d, f) {
            f === void 0 && (f = d), (l[f] = u[d]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (l, u) {
            Object.defineProperty(l, 'default', { enumerable: !0, value: u });
          }
        : function (l, u) {
            l.default = u;
          }),
    r =
      (g && g.__importStar) ||
      function (l) {
        if (l && l.__esModule) return l;
        var u = {};
        if (l != null)
          for (var d in l)
            d !== 'default' && Object.prototype.hasOwnProperty.call(l, d) && t(u, l, d);
        return n(u, l), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createTransferOutOfEscrowInstruction =
      e.transferOutOfEscrowInstructionDiscriminator =
      e.TransferOutOfEscrowStruct =
        void 0);
  const i = r(In),
    o = r(W),
    a = r(V),
    c = Df;
  (e.TransferOutOfEscrowStruct = new o.BeetArgsStruct(
    [
      ['instructionDiscriminator', o.u8],
      ['transferOutOfEscrowArgs', c.transferOutOfEscrowArgsBeet],
    ],
    'TransferOutOfEscrowInstructionArgs'
  )),
    (e.transferOutOfEscrowInstructionDiscriminator = 40);
  function s(l, u, d = new a.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var f, p, y;
    const [b] = e.TransferOutOfEscrowStruct.serialize({
        instructionDiscriminator: e.transferOutOfEscrowInstructionDiscriminator,
        ...u,
      }),
      m = [
        { pubkey: l.escrow, isWritable: !1, isSigner: !1 },
        { pubkey: l.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: l.payer, isWritable: !0, isSigner: !0 },
        { pubkey: l.attributeMint, isWritable: !1, isSigner: !1 },
        { pubkey: l.attributeSrc, isWritable: !0, isSigner: !1 },
        { pubkey: l.attributeDst, isWritable: !0, isSigner: !1 },
        { pubkey: l.escrowMint, isWritable: !1, isSigner: !1 },
        { pubkey: l.escrowAccount, isWritable: !1, isSigner: !1 },
        {
          pubkey: (f = l.systemProgram) !== null && f !== void 0 ? f : a.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (p = l.ataProgram) !== null && p !== void 0 ? p : i.ASSOCIATED_TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (y = l.tokenProgram) !== null && y !== void 0 ? y : i.TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: l.sysvarInstructions, isWritable: !1, isSigner: !1 },
      ];
    return (
      l.authority != null && m.push({ pubkey: l.authority, isWritable: !1, isSigner: !0 }),
      new a.TransactionInstruction({ programId: d, keys: m, data: b })
    );
  }
  e.createTransferOutOfEscrowInstruction = s;
})(VC);
var KC = {},
  Qo = {},
  GK =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  YK =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  ZK =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && GK(t, e, n);
      return YK(t, e), t;
    };
Object.defineProperty(Qo, '__esModule', { value: !0 });
Qo.unlockArgsBeet = Qo.isUnlockArgsV1 = void 0;
const Ub = ZK(W),
  QK = _r,
  JK = (e) => e.__kind === 'V1';
Qo.isUnlockArgsV1 = JK;
Qo.unlockArgsBeet = Ub.dataEnum([
  [
    'V1',
    new Ub.FixableBeetArgsStruct(
      [['authorizationData', Ub.coption(QK.authorizationDataBeet)]],
      'UnlockArgsRecord["V1"]'
    ),
  ],
]);
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (s, l, u, d) {
            d === void 0 && (d = u);
            var f = Object.getOwnPropertyDescriptor(l, u);
            (!f || ('get' in f ? !l.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return l[u];
                },
              }),
              Object.defineProperty(s, d, f);
          }
        : function (s, l, u, d) {
            d === void 0 && (d = u), (s[d] = l[u]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (s, l) {
            Object.defineProperty(s, 'default', { enumerable: !0, value: l });
          }
        : function (s, l) {
            s.default = l;
          }),
    r =
      (g && g.__importStar) ||
      function (s) {
        if (s && s.__esModule) return s;
        var l = {};
        if (s != null)
          for (var u in s)
            u !== 'default' && Object.prototype.hasOwnProperty.call(s, u) && t(l, s, u);
        return n(l, s), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createUnlockInstruction = e.unlockInstructionDiscriminator = e.UnlockStruct = void 0);
  const i = r(W),
    o = r(V),
    a = Qo;
  (e.UnlockStruct = new i.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['unlockArgs', a.unlockArgsBeet],
    ],
    'UnlockInstructionArgs'
  )),
    (e.unlockInstructionDiscriminator = 47);
  function c(s, l, u = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var d, f, p, y, b, m, w;
    const [_] = e.UnlockStruct.serialize({
        instructionDiscriminator: e.unlockInstructionDiscriminator,
        ...l,
      }),
      S = [
        { pubkey: s.authority, isWritable: !1, isSigner: !0 },
        {
          pubkey: (d = s.tokenOwner) !== null && d !== void 0 ? d : u,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: s.token, isWritable: !0, isSigner: !1 },
        { pubkey: s.mint, isWritable: !1, isSigner: !1 },
        { pubkey: s.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: (f = s.edition) !== null && f !== void 0 ? f : u, isWritable: !1, isSigner: !1 },
        {
          pubkey: (p = s.tokenRecord) !== null && p !== void 0 ? p : u,
          isWritable: s.tokenRecord != null,
          isSigner: !1,
        },
        { pubkey: s.payer, isWritable: !0, isSigner: !0 },
        {
          pubkey: (y = s.systemProgram) !== null && y !== void 0 ? y : o.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: s.sysvarInstructions, isWritable: !1, isSigner: !1 },
        {
          pubkey: (b = s.splTokenProgram) !== null && b !== void 0 ? b : u,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (m = s.authorizationRulesProgram) !== null && m !== void 0 ? m : u,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (w = s.authorizationRules) !== null && w !== void 0 ? w : u,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return new o.TransactionInstruction({ programId: u, keys: S, data: _ });
  }
  e.createUnlockInstruction = c;
})(KC);
var HC = {},
  Xg = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (a, c, s, l) {
            l === void 0 && (l = s);
            var u = Object.getOwnPropertyDescriptor(c, s);
            (!u || ('get' in u ? !c.__esModule : u.writable || u.configurable)) &&
              (u = {
                enumerable: !0,
                get: function () {
                  return c[s];
                },
              }),
              Object.defineProperty(a, l, u);
          }
        : function (a, c, s, l) {
            l === void 0 && (l = s), (a[l] = c[s]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (g && g.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var s in a)
            s !== 'default' && Object.prototype.hasOwnProperty.call(a, s) && t(c, a, s);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.verificationArgsBeet = e.VerificationArgs = void 0);
  const i = r(W);
  var o;
  (function (a) {
    (a[(a.CreatorV1 = 0)] = 'CreatorV1'), (a[(a.CollectionV1 = 1)] = 'CollectionV1');
  })((o = e.VerificationArgs || (e.VerificationArgs = {}))),
    (e.verificationArgsBeet = i.fixedScalarEnum(o));
})(Xg);
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (s, l, u, d) {
            d === void 0 && (d = u);
            var f = Object.getOwnPropertyDescriptor(l, u);
            (!f || ('get' in f ? !l.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return l[u];
                },
              }),
              Object.defineProperty(s, d, f);
          }
        : function (s, l, u, d) {
            d === void 0 && (d = u), (s[d] = l[u]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (s, l) {
            Object.defineProperty(s, 'default', { enumerable: !0, value: l });
          }
        : function (s, l) {
            s.default = l;
          }),
    r =
      (g && g.__importStar) ||
      function (s) {
        if (s && s.__esModule) return s;
        var l = {};
        if (s != null)
          for (var u in s)
            u !== 'default' && Object.prototype.hasOwnProperty.call(s, u) && t(l, s, u);
        return n(l, s), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createUnverifyInstruction = e.unverifyInstructionDiscriminator = e.UnverifyStruct = void 0);
  const i = r(W),
    o = r(V),
    a = Xg;
  (e.UnverifyStruct = new i.BeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['verificationArgs', a.verificationArgsBeet],
    ],
    'UnverifyInstructionArgs'
  )),
    (e.unverifyInstructionDiscriminator = 53);
  function c(s, l, u = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var d, f, p, y;
    const [b] = e.UnverifyStruct.serialize({
        instructionDiscriminator: e.unverifyInstructionDiscriminator,
        ...l,
      }),
      m = [
        { pubkey: s.authority, isWritable: !1, isSigner: !0 },
        {
          pubkey: (d = s.delegateRecord) !== null && d !== void 0 ? d : u,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: s.metadata, isWritable: !0, isSigner: !1 },
        {
          pubkey: (f = s.collectionMint) !== null && f !== void 0 ? f : u,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (p = s.collectionMetadata) !== null && p !== void 0 ? p : u,
          isWritable: s.collectionMetadata != null,
          isSigner: !1,
        },
        {
          pubkey: (y = s.systemProgram) !== null && y !== void 0 ? y : o.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: s.sysvarInstructions, isWritable: !1, isSigner: !1 },
      ];
    return new o.TransactionInstruction({ programId: u, keys: m, data: b });
  }
  e.createUnverifyInstruction = c;
})(HC);
var qC = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (c, s, l, u) {
            u === void 0 && (u = l);
            var d = Object.getOwnPropertyDescriptor(s, l);
            (!d || ('get' in d ? !s.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return s[l];
                },
              }),
              Object.defineProperty(c, u, d);
          }
        : function (c, s, l, u) {
            u === void 0 && (u = l), (c[u] = s[l]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (c, s) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: s });
          }
        : function (c, s) {
            c.default = s;
          }),
    r =
      (g && g.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var s = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(s, c, l);
        return n(s, c), s;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createUnverifyCollectionInstruction =
      e.unverifyCollectionInstructionDiscriminator =
      e.UnverifyCollectionStruct =
        void 0);
  const i = r(W),
    o = r(V);
  (e.UnverifyCollectionStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'UnverifyCollectionInstructionArgs'
  )),
    (e.unverifyCollectionInstructionDiscriminator = 22);
  function a(c, s = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [l] = e.UnverifyCollectionStruct.serialize({
        instructionDiscriminator: e.unverifyCollectionInstructionDiscriminator,
      }),
      u = [
        { pubkey: c.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: c.collectionAuthority, isWritable: !0, isSigner: !0 },
        { pubkey: c.collectionMint, isWritable: !1, isSigner: !1 },
        { pubkey: c.collection, isWritable: !1, isSigner: !1 },
        { pubkey: c.collectionMasterEditionAccount, isWritable: !1, isSigner: !1 },
      ];
    return (
      c.collectionAuthorityRecord != null &&
        u.push({ pubkey: c.collectionAuthorityRecord, isWritable: !1, isSigner: !1 }),
      new o.TransactionInstruction({ programId: s, keys: u, data: l })
    );
  }
  e.createUnverifyCollectionInstruction = a;
})(qC);
var GC = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (c, s, l, u) {
            u === void 0 && (u = l);
            var d = Object.getOwnPropertyDescriptor(s, l);
            (!d || ('get' in d ? !s.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return s[l];
                },
              }),
              Object.defineProperty(c, u, d);
          }
        : function (c, s, l, u) {
            u === void 0 && (u = l), (c[u] = s[l]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (c, s) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: s });
          }
        : function (c, s) {
            c.default = s;
          }),
    r =
      (g && g.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var s = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(s, c, l);
        return n(s, c), s;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createUnverifySizedCollectionItemInstruction =
      e.unverifySizedCollectionItemInstructionDiscriminator =
      e.UnverifySizedCollectionItemStruct =
        void 0);
  const i = r(W),
    o = r(V);
  (e.UnverifySizedCollectionItemStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'UnverifySizedCollectionItemInstructionArgs'
  )),
    (e.unverifySizedCollectionItemInstructionDiscriminator = 31);
  function a(c, s = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [l] = e.UnverifySizedCollectionItemStruct.serialize({
        instructionDiscriminator: e.unverifySizedCollectionItemInstructionDiscriminator,
      }),
      u = [
        { pubkey: c.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: c.collectionAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: c.payer, isWritable: !0, isSigner: !0 },
        { pubkey: c.collectionMint, isWritable: !1, isSigner: !1 },
        { pubkey: c.collection, isWritable: !0, isSigner: !1 },
        { pubkey: c.collectionMasterEditionAccount, isWritable: !1, isSigner: !1 },
      ];
    return (
      c.collectionAuthorityRecord != null &&
        u.push({ pubkey: c.collectionAuthorityRecord, isWritable: !1, isSigner: !1 }),
      new o.TransactionInstruction({ programId: s, keys: u, data: l })
    );
  }
  e.createUnverifySizedCollectionItemInstruction = a;
})(GC);
var YC = {},
  Ct = {},
  lr = {},
  XK =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  eH =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  tH =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && XK(t, e, n);
      return eH(t, e), t;
    };
Object.defineProperty(lr, '__esModule', { value: !0 });
lr.collectionToggleBeet =
  lr.isCollectionToggleSet =
  lr.isCollectionToggleClear =
  lr.isCollectionToggleNone =
    void 0;
const $s = tH(W),
  nH = bi,
  rH = (e) => e.__kind === 'None';
lr.isCollectionToggleNone = rH;
const iH = (e) => e.__kind === 'Clear';
lr.isCollectionToggleClear = iH;
const oH = (e) => e.__kind === 'Set';
lr.isCollectionToggleSet = oH;
lr.collectionToggleBeet = $s.dataEnum([
  ['None', $s.unit],
  ['Clear', $s.unit],
  [
    'Set',
    new $s.BeetArgsStruct(
      [['fields', $s.fixedSizeTuple([nH.collectionBeet])]],
      'CollectionToggleRecord["Set"]'
    ),
  ],
]);
var dr = {},
  aH =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  sH =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  cH =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && aH(t, e, n);
      return sH(t, e), t;
    };
Object.defineProperty(dr, '__esModule', { value: !0 });
dr.collectionDetailsToggleBeet =
  dr.isCollectionDetailsToggleSet =
  dr.isCollectionDetailsToggleClear =
  dr.isCollectionDetailsToggleNone =
    void 0;
const Ws = cH(W),
  uH = wr,
  lH = (e) => e.__kind === 'None';
dr.isCollectionDetailsToggleNone = lH;
const dH = (e) => e.__kind === 'Clear';
dr.isCollectionDetailsToggleClear = dH;
const fH = (e) => e.__kind === 'Set';
dr.isCollectionDetailsToggleSet = fH;
dr.collectionDetailsToggleBeet = Ws.dataEnum([
  ['None', Ws.unit],
  ['Clear', Ws.unit],
  [
    'Set',
    new Ws.FixableBeetArgsStruct(
      [['fields', Ws.tuple([uH.collectionDetailsBeet])]],
      'CollectionDetailsToggleRecord["Set"]'
    ),
  ],
]);
var fr = {},
  hH =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  pH =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  gH =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && hH(t, e, n);
      return pH(t, e), t;
    };
Object.defineProperty(fr, '__esModule', { value: !0 });
fr.usesToggleBeet = fr.isUsesToggleSet = fr.isUsesToggleClear = fr.isUsesToggleNone = void 0;
const Vs = gH(W),
  yH = mi,
  bH = (e) => e.__kind === 'None';
fr.isUsesToggleNone = bH;
const mH = (e) => e.__kind === 'Clear';
fr.isUsesToggleClear = mH;
const wH = (e) => e.__kind === 'Set';
fr.isUsesToggleSet = wH;
fr.usesToggleBeet = Vs.dataEnum([
  ['None', Vs.unit],
  ['Clear', Vs.unit],
  [
    'Set',
    new Vs.BeetArgsStruct(
      [['fields', Vs.fixedSizeTuple([yH.usesBeet])]],
      'UsesToggleRecord["Set"]'
    ),
  ],
]);
var hr = {},
  _H =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  vH =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  ZC =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && _H(t, e, n);
      return vH(t, e), t;
    };
Object.defineProperty(hr, '__esModule', { value: !0 });
hr.ruleSetToggleBeet =
  hr.isRuleSetToggleSet =
  hr.isRuleSetToggleClear =
  hr.isRuleSetToggleNone =
    void 0;
const Ks = ZC(W),
  SH = ZC(st),
  AH = (e) => e.__kind === 'None';
hr.isRuleSetToggleNone = AH;
const IH = (e) => e.__kind === 'Clear';
hr.isRuleSetToggleClear = IH;
const EH = (e) => e.__kind === 'Set';
hr.isRuleSetToggleSet = EH;
hr.ruleSetToggleBeet = Ks.dataEnum([
  ['None', Ks.unit],
  ['Clear', Ks.unit],
  [
    'Set',
    new Ks.BeetArgsStruct(
      [['fields', Ks.fixedSizeTuple([SH.publicKey])]],
      'RuleSetToggleRecord["Set"]'
    ),
  ],
]);
var TH =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  kH =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  QC =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && TH(t, e, n);
      return kH(t, e), t;
    };
Object.defineProperty(Ct, '__esModule', { value: !0 });
Ct.updateArgsBeet =
  Ct.isUpdateArgsAsProgrammableConfigItemDelegateV2 =
  Ct.isUpdateArgsAsCollectionItemDelegateV2 =
  Ct.isUpdateArgsAsDataItemDelegateV2 =
  Ct.isUpdateArgsAsProgrammableConfigDelegateV2 =
  Ct.isUpdateArgsAsDataDelegateV2 =
  Ct.isUpdateArgsAsCollectionDelegateV2 =
  Ct.isUpdateArgsAsAuthorityItemDelegateV2 =
  Ct.isUpdateArgsAsUpdateAuthorityV2 =
  Ct.isUpdateArgsV1 =
    void 0;
const $e = QC(W),
  Lb = QC(st),
  uh = la,
  lh = lr,
  Zv = dr,
  Qv = fr,
  dh = hr,
  Gr = _r,
  Jv = vs,
  CH = (e) => e.__kind === 'V1';
Ct.isUpdateArgsV1 = CH;
const MH = (e) => e.__kind === 'AsUpdateAuthorityV2';
Ct.isUpdateArgsAsUpdateAuthorityV2 = MH;
const PH = (e) => e.__kind === 'AsAuthorityItemDelegateV2';
Ct.isUpdateArgsAsAuthorityItemDelegateV2 = PH;
const OH = (e) => e.__kind === 'AsCollectionDelegateV2';
Ct.isUpdateArgsAsCollectionDelegateV2 = OH;
const DH = (e) => e.__kind === 'AsDataDelegateV2';
Ct.isUpdateArgsAsDataDelegateV2 = DH;
const RH = (e) => e.__kind === 'AsProgrammableConfigDelegateV2';
Ct.isUpdateArgsAsProgrammableConfigDelegateV2 = RH;
const xH = (e) => e.__kind === 'AsDataItemDelegateV2';
Ct.isUpdateArgsAsDataItemDelegateV2 = xH;
const BH = (e) => e.__kind === 'AsCollectionItemDelegateV2';
Ct.isUpdateArgsAsCollectionItemDelegateV2 = BH;
const jH = (e) => e.__kind === 'AsProgrammableConfigItemDelegateV2';
Ct.isUpdateArgsAsProgrammableConfigItemDelegateV2 = jH;
Ct.updateArgsBeet = $e.dataEnum([
  [
    'V1',
    new $e.FixableBeetArgsStruct(
      [
        ['newUpdateAuthority', $e.coption(Lb.publicKey)],
        ['data', $e.coption(uh.dataBeet)],
        ['primarySaleHappened', $e.coption($e.bool)],
        ['isMutable', $e.coption($e.bool)],
        ['collection', lh.collectionToggleBeet],
        ['collectionDetails', Zv.collectionDetailsToggleBeet],
        ['uses', Qv.usesToggleBeet],
        ['ruleSet', dh.ruleSetToggleBeet],
        ['authorizationData', $e.coption(Gr.authorizationDataBeet)],
      ],
      'UpdateArgsRecord["V1"]'
    ),
  ],
  [
    'AsUpdateAuthorityV2',
    new $e.FixableBeetArgsStruct(
      [
        ['newUpdateAuthority', $e.coption(Lb.publicKey)],
        ['data', $e.coption(uh.dataBeet)],
        ['primarySaleHappened', $e.coption($e.bool)],
        ['isMutable', $e.coption($e.bool)],
        ['collection', lh.collectionToggleBeet],
        ['collectionDetails', Zv.collectionDetailsToggleBeet],
        ['uses', Qv.usesToggleBeet],
        ['ruleSet', dh.ruleSetToggleBeet],
        ['tokenStandard', $e.coption(Jv.tokenStandardBeet)],
        ['authorizationData', $e.coption(Gr.authorizationDataBeet)],
      ],
      'UpdateArgsRecord["AsUpdateAuthorityV2"]'
    ),
  ],
  [
    'AsAuthorityItemDelegateV2',
    new $e.FixableBeetArgsStruct(
      [
        ['newUpdateAuthority', $e.coption(Lb.publicKey)],
        ['primarySaleHappened', $e.coption($e.bool)],
        ['isMutable', $e.coption($e.bool)],
        ['tokenStandard', $e.coption(Jv.tokenStandardBeet)],
        ['authorizationData', $e.coption(Gr.authorizationDataBeet)],
      ],
      'UpdateArgsRecord["AsAuthorityItemDelegateV2"]'
    ),
  ],
  [
    'AsCollectionDelegateV2',
    new $e.FixableBeetArgsStruct(
      [
        ['collection', lh.collectionToggleBeet],
        ['authorizationData', $e.coption(Gr.authorizationDataBeet)],
      ],
      'UpdateArgsRecord["AsCollectionDelegateV2"]'
    ),
  ],
  [
    'AsDataDelegateV2',
    new $e.FixableBeetArgsStruct(
      [
        ['data', $e.coption(uh.dataBeet)],
        ['authorizationData', $e.coption(Gr.authorizationDataBeet)],
      ],
      'UpdateArgsRecord["AsDataDelegateV2"]'
    ),
  ],
  [
    'AsProgrammableConfigDelegateV2',
    new $e.FixableBeetArgsStruct(
      [
        ['ruleSet', dh.ruleSetToggleBeet],
        ['authorizationData', $e.coption(Gr.authorizationDataBeet)],
      ],
      'UpdateArgsRecord["AsProgrammableConfigDelegateV2"]'
    ),
  ],
  [
    'AsDataItemDelegateV2',
    new $e.FixableBeetArgsStruct(
      [
        ['data', $e.coption(uh.dataBeet)],
        ['authorizationData', $e.coption(Gr.authorizationDataBeet)],
      ],
      'UpdateArgsRecord["AsDataItemDelegateV2"]'
    ),
  ],
  [
    'AsCollectionItemDelegateV2',
    new $e.FixableBeetArgsStruct(
      [
        ['collection', lh.collectionToggleBeet],
        ['authorizationData', $e.coption(Gr.authorizationDataBeet)],
      ],
      'UpdateArgsRecord["AsCollectionItemDelegateV2"]'
    ),
  ],
  [
    'AsProgrammableConfigItemDelegateV2',
    new $e.FixableBeetArgsStruct(
      [
        ['ruleSet', dh.ruleSetToggleBeet],
        ['authorizationData', $e.coption(Gr.authorizationDataBeet)],
      ],
      'UpdateArgsRecord["AsProgrammableConfigItemDelegateV2"]'
    ),
  ],
]);
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (s, l, u, d) {
            d === void 0 && (d = u);
            var f = Object.getOwnPropertyDescriptor(l, u);
            (!f || ('get' in f ? !l.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return l[u];
                },
              }),
              Object.defineProperty(s, d, f);
          }
        : function (s, l, u, d) {
            d === void 0 && (d = u), (s[d] = l[u]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (s, l) {
            Object.defineProperty(s, 'default', { enumerable: !0, value: l });
          }
        : function (s, l) {
            s.default = l;
          }),
    r =
      (g && g.__importStar) ||
      function (s) {
        if (s && s.__esModule) return s;
        var l = {};
        if (s != null)
          for (var u in s)
            u !== 'default' && Object.prototype.hasOwnProperty.call(s, u) && t(l, s, u);
        return n(l, s), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createUpdateInstruction = e.updateInstructionDiscriminator = e.UpdateStruct = void 0);
  const i = r(W),
    o = r(V),
    a = Ct;
  (e.UpdateStruct = new i.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['updateArgs', a.updateArgsBeet],
    ],
    'UpdateInstructionArgs'
  )),
    (e.updateInstructionDiscriminator = 50);
  function c(s, l, u = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var d, f, p, y, b, m;
    const [w] = e.UpdateStruct.serialize({
        instructionDiscriminator: e.updateInstructionDiscriminator,
        ...l,
      }),
      _ = [
        { pubkey: s.authority, isWritable: !1, isSigner: !0 },
        {
          pubkey: (d = s.delegateRecord) !== null && d !== void 0 ? d : u,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: (f = s.token) !== null && f !== void 0 ? f : u, isWritable: !1, isSigner: !1 },
        { pubkey: s.mint, isWritable: !1, isSigner: !1 },
        { pubkey: s.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: (p = s.edition) !== null && p !== void 0 ? p : u, isWritable: !1, isSigner: !1 },
        { pubkey: s.payer, isWritable: !0, isSigner: !0 },
        {
          pubkey: (y = s.systemProgram) !== null && y !== void 0 ? y : o.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: s.sysvarInstructions, isWritable: !1, isSigner: !1 },
        {
          pubkey: (b = s.authorizationRulesProgram) !== null && b !== void 0 ? b : u,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (m = s.authorizationRules) !== null && m !== void 0 ? m : u,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return new o.TransactionInstruction({ programId: u, keys: _, data: w });
  }
  e.createUpdateInstruction = c;
})(YC);
var JC = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (c, s, l, u) {
            u === void 0 && (u = l);
            var d = Object.getOwnPropertyDescriptor(s, l);
            (!d || ('get' in d ? !s.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return s[l];
                },
              }),
              Object.defineProperty(c, u, d);
          }
        : function (c, s, l, u) {
            u === void 0 && (u = l), (c[u] = s[l]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (c, s) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: s });
          }
        : function (c, s) {
            c.default = s;
          }),
    r =
      (g && g.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var s = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(s, c, l);
        return n(s, c), s;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createUpdateMetadataAccountInstruction =
      e.updateMetadataAccountInstructionDiscriminator =
      e.UpdateMetadataAccountStruct =
        void 0);
  const i = r(W),
    o = r(V);
  (e.UpdateMetadataAccountStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'UpdateMetadataAccountInstructionArgs'
  )),
    (e.updateMetadataAccountInstructionDiscriminator = 1);
  function a(c, s = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [l] = e.UpdateMetadataAccountStruct.serialize({
        instructionDiscriminator: e.updateMetadataAccountInstructionDiscriminator,
      }),
      u = [
        { pubkey: c.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: c.updateAuthority, isWritable: !1, isSigner: !0 },
      ];
    return new o.TransactionInstruction({ programId: s, keys: u, data: l });
  }
  e.createUpdateMetadataAccountInstruction = a;
})(JC);
var XC = {},
  Rf = {},
  NH =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  UH =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  eM =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && NH(t, e, n);
      return UH(t, e), t;
    };
Object.defineProperty(Rf, '__esModule', { value: !0 });
Rf.updateMetadataAccountArgsV2Beet = void 0;
const wo = eM(W),
  LH = eM(st),
  zH = Is;
Rf.updateMetadataAccountArgsV2Beet = new wo.FixableBeetArgsStruct(
  [
    ['data', wo.coption(zH.dataV2Beet)],
    ['updateAuthority', wo.coption(LH.publicKey)],
    ['primarySaleHappened', wo.coption(wo.bool)],
    ['isMutable', wo.coption(wo.bool)],
  ],
  'UpdateMetadataAccountArgsV2'
);
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (s, l, u, d) {
            d === void 0 && (d = u);
            var f = Object.getOwnPropertyDescriptor(l, u);
            (!f || ('get' in f ? !l.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return l[u];
                },
              }),
              Object.defineProperty(s, d, f);
          }
        : function (s, l, u, d) {
            d === void 0 && (d = u), (s[d] = l[u]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (s, l) {
            Object.defineProperty(s, 'default', { enumerable: !0, value: l });
          }
        : function (s, l) {
            s.default = l;
          }),
    r =
      (g && g.__importStar) ||
      function (s) {
        if (s && s.__esModule) return s;
        var l = {};
        if (s != null)
          for (var u in s)
            u !== 'default' && Object.prototype.hasOwnProperty.call(s, u) && t(l, s, u);
        return n(l, s), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createUpdateMetadataAccountV2Instruction =
      e.updateMetadataAccountV2InstructionDiscriminator =
      e.UpdateMetadataAccountV2Struct =
        void 0);
  const i = r(W),
    o = r(V),
    a = Rf;
  (e.UpdateMetadataAccountV2Struct = new i.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['updateMetadataAccountArgsV2', a.updateMetadataAccountArgsV2Beet],
    ],
    'UpdateMetadataAccountV2InstructionArgs'
  )),
    (e.updateMetadataAccountV2InstructionDiscriminator = 15);
  function c(s, l, u = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [d] = e.UpdateMetadataAccountV2Struct.serialize({
        instructionDiscriminator: e.updateMetadataAccountV2InstructionDiscriminator,
        ...l,
      }),
      f = [
        { pubkey: s.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: s.updateAuthority, isWritable: !1, isSigner: !0 },
      ];
    return new o.TransactionInstruction({ programId: u, keys: f, data: d });
  }
  e.createUpdateMetadataAccountV2Instruction = c;
})(XC);
var tM = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (c, s, l, u) {
            u === void 0 && (u = l);
            var d = Object.getOwnPropertyDescriptor(s, l);
            (!d || ('get' in d ? !s.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return s[l];
                },
              }),
              Object.defineProperty(c, u, d);
          }
        : function (c, s, l, u) {
            u === void 0 && (u = l), (c[u] = s[l]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (c, s) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: s });
          }
        : function (c, s) {
            c.default = s;
          }),
    r =
      (g && g.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var s = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(s, c, l);
        return n(s, c), s;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createUpdatePrimarySaleHappenedViaTokenInstruction =
      e.updatePrimarySaleHappenedViaTokenInstructionDiscriminator =
      e.UpdatePrimarySaleHappenedViaTokenStruct =
        void 0);
  const i = r(W),
    o = r(V);
  (e.UpdatePrimarySaleHappenedViaTokenStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'UpdatePrimarySaleHappenedViaTokenInstructionArgs'
  )),
    (e.updatePrimarySaleHappenedViaTokenInstructionDiscriminator = 4);
  function a(c, s = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [l] = e.UpdatePrimarySaleHappenedViaTokenStruct.serialize({
        instructionDiscriminator: e.updatePrimarySaleHappenedViaTokenInstructionDiscriminator,
      }),
      u = [
        { pubkey: c.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: c.owner, isWritable: !1, isSigner: !0 },
        { pubkey: c.token, isWritable: !1, isSigner: !1 },
      ];
    return new o.TransactionInstruction({ programId: s, keys: u, data: l });
  }
  e.createUpdatePrimarySaleHappenedViaTokenInstruction = a;
})(tM);
var nM = {},
  Jo = {},
  FH =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  $H =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  WH =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && FH(t, e, n);
      return $H(t, e), t;
    };
Object.defineProperty(Jo, '__esModule', { value: !0 });
Jo.useArgsBeet = Jo.isUseArgsV1 = void 0;
const zb = WH(W),
  VH = _r,
  KH = (e) => e.__kind === 'V1';
Jo.isUseArgsV1 = KH;
Jo.useArgsBeet = zb.dataEnum([
  [
    'V1',
    new zb.FixableBeetArgsStruct(
      [['authorizationData', zb.coption(VH.authorizationDataBeet)]],
      'UseArgsRecord["V1"]'
    ),
  ],
]);
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (s, l, u, d) {
            d === void 0 && (d = u);
            var f = Object.getOwnPropertyDescriptor(l, u);
            (!f || ('get' in f ? !l.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return l[u];
                },
              }),
              Object.defineProperty(s, d, f);
          }
        : function (s, l, u, d) {
            d === void 0 && (d = u), (s[d] = l[u]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (s, l) {
            Object.defineProperty(s, 'default', { enumerable: !0, value: l });
          }
        : function (s, l) {
            s.default = l;
          }),
    r =
      (g && g.__importStar) ||
      function (s) {
        if (s && s.__esModule) return s;
        var l = {};
        if (s != null)
          for (var u in s)
            u !== 'default' && Object.prototype.hasOwnProperty.call(s, u) && t(l, s, u);
        return n(l, s), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createUseInstruction = e.useInstructionDiscriminator = e.UseStruct = void 0);
  const i = r(W),
    o = r(V),
    a = Jo;
  (e.UseStruct = new i.FixableBeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['useArgs', a.useArgsBeet],
    ],
    'UseInstructionArgs'
  )),
    (e.useInstructionDiscriminator = 51);
  function c(s, l, u = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var d, f, p, y, b, m, w;
    const [_] = e.UseStruct.serialize({
        instructionDiscriminator: e.useInstructionDiscriminator,
        ...l,
      }),
      S = [
        { pubkey: s.authority, isWritable: !1, isSigner: !0 },
        {
          pubkey: (d = s.delegateRecord) !== null && d !== void 0 ? d : u,
          isWritable: s.delegateRecord != null,
          isSigner: !1,
        },
        {
          pubkey: (f = s.token) !== null && f !== void 0 ? f : u,
          isWritable: s.token != null,
          isSigner: !1,
        },
        { pubkey: s.mint, isWritable: !1, isSigner: !1 },
        { pubkey: s.metadata, isWritable: !0, isSigner: !1 },
        {
          pubkey: (p = s.edition) !== null && p !== void 0 ? p : u,
          isWritable: s.edition != null,
          isSigner: !1,
        },
        { pubkey: s.payer, isWritable: !1, isSigner: !0 },
        {
          pubkey: (y = s.systemProgram) !== null && y !== void 0 ? y : o.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: s.sysvarInstructions, isWritable: !1, isSigner: !1 },
        {
          pubkey: (b = s.splTokenProgram) !== null && b !== void 0 ? b : u,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (m = s.authorizationRulesProgram) !== null && m !== void 0 ? m : u,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (w = s.authorizationRules) !== null && w !== void 0 ? w : u,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    return new o.TransactionInstruction({ programId: u, keys: S, data: _ });
  }
  e.createUseInstruction = c;
})(nM);
var rM = {},
  xf = {},
  HH =
    (g && g.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n);
          var i = Object.getOwnPropertyDescriptor(t, n);
          (!i || ('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }),
            Object.defineProperty(e, r, i);
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  qH =
    (g && g.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  GH =
    (g && g.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && HH(t, e, n);
      return qH(t, e), t;
    };
Object.defineProperty(xf, '__esModule', { value: !0 });
xf.utilizeArgsBeet = void 0;
const Xv = GH(W);
xf.utilizeArgsBeet = new Xv.BeetArgsStruct([['numberOfUses', Xv.u64]], 'UtilizeArgs');
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (l, u, d, f) {
            f === void 0 && (f = d);
            var p = Object.getOwnPropertyDescriptor(u, d);
            (!p || ('get' in p ? !u.__esModule : p.writable || p.configurable)) &&
              (p = {
                enumerable: !0,
                get: function () {
                  return u[d];
                },
              }),
              Object.defineProperty(l, f, p);
          }
        : function (l, u, d, f) {
            f === void 0 && (f = d), (l[f] = u[d]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (l, u) {
            Object.defineProperty(l, 'default', { enumerable: !0, value: u });
          }
        : function (l, u) {
            l.default = u;
          }),
    r =
      (g && g.__importStar) ||
      function (l) {
        if (l && l.__esModule) return l;
        var u = {};
        if (l != null)
          for (var d in l)
            d !== 'default' && Object.prototype.hasOwnProperty.call(l, d) && t(u, l, d);
        return n(u, l), u;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createUtilizeInstruction = e.utilizeInstructionDiscriminator = e.UtilizeStruct = void 0);
  const i = r(In),
    o = r(W),
    a = r(V),
    c = xf;
  (e.UtilizeStruct = new o.BeetArgsStruct(
    [
      ['instructionDiscriminator', o.u8],
      ['utilizeArgs', c.utilizeArgsBeet],
    ],
    'UtilizeInstructionArgs'
  )),
    (e.utilizeInstructionDiscriminator = 19);
  function s(l, u, d = new a.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var f, p, y, b;
    const [m] = e.UtilizeStruct.serialize({
        instructionDiscriminator: e.utilizeInstructionDiscriminator,
        ...u,
      }),
      w = [
        { pubkey: l.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: l.tokenAccount, isWritable: !0, isSigner: !1 },
        { pubkey: l.mint, isWritable: !0, isSigner: !1 },
        { pubkey: l.useAuthority, isWritable: !0, isSigner: !0 },
        { pubkey: l.owner, isWritable: !1, isSigner: !1 },
        {
          pubkey: (f = l.tokenProgram) !== null && f !== void 0 ? f : i.TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (p = l.ataProgram) !== null && p !== void 0 ? p : i.ASSOCIATED_TOKEN_PROGRAM_ID,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (y = l.systemProgram) !== null && y !== void 0 ? y : a.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (b = l.rent) !== null && b !== void 0 ? b : a.SYSVAR_RENT_PUBKEY,
          isWritable: !1,
          isSigner: !1,
        },
      ];
    if (
      (l.useAuthorityRecord != null &&
        w.push({ pubkey: l.useAuthorityRecord, isWritable: !0, isSigner: !1 }),
      l.burner != null)
    ) {
      if (l.useAuthorityRecord == null)
        throw new Error(
          "When providing 'burner' then 'accounts.useAuthorityRecord' need(s) to be provided as well."
        );
      w.push({ pubkey: l.burner, isWritable: !1, isSigner: !1 });
    }
    return new a.TransactionInstruction({ programId: d, keys: w, data: m });
  }
  e.createUtilizeInstruction = s;
})(rM);
var iM = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (s, l, u, d) {
            d === void 0 && (d = u);
            var f = Object.getOwnPropertyDescriptor(l, u);
            (!f || ('get' in f ? !l.__esModule : f.writable || f.configurable)) &&
              (f = {
                enumerable: !0,
                get: function () {
                  return l[u];
                },
              }),
              Object.defineProperty(s, d, f);
          }
        : function (s, l, u, d) {
            d === void 0 && (d = u), (s[d] = l[u]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (s, l) {
            Object.defineProperty(s, 'default', { enumerable: !0, value: l });
          }
        : function (s, l) {
            s.default = l;
          }),
    r =
      (g && g.__importStar) ||
      function (s) {
        if (s && s.__esModule) return s;
        var l = {};
        if (s != null)
          for (var u in s)
            u !== 'default' && Object.prototype.hasOwnProperty.call(s, u) && t(l, s, u);
        return n(l, s), l;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createVerifyInstruction = e.verifyInstructionDiscriminator = e.VerifyStruct = void 0);
  const i = r(W),
    o = r(V),
    a = Xg;
  (e.VerifyStruct = new i.BeetArgsStruct(
    [
      ['instructionDiscriminator', i.u8],
      ['verificationArgs', a.verificationArgsBeet],
    ],
    'VerifyInstructionArgs'
  )),
    (e.verifyInstructionDiscriminator = 52);
  function c(s, l, u = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    var d, f, p, y, b;
    const [m] = e.VerifyStruct.serialize({
        instructionDiscriminator: e.verifyInstructionDiscriminator,
        ...l,
      }),
      w = [
        { pubkey: s.authority, isWritable: !1, isSigner: !0 },
        {
          pubkey: (d = s.delegateRecord) !== null && d !== void 0 ? d : u,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: s.metadata, isWritable: !0, isSigner: !1 },
        {
          pubkey: (f = s.collectionMint) !== null && f !== void 0 ? f : u,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (p = s.collectionMetadata) !== null && p !== void 0 ? p : u,
          isWritable: s.collectionMetadata != null,
          isSigner: !1,
        },
        {
          pubkey: (y = s.collectionMasterEdition) !== null && y !== void 0 ? y : u,
          isWritable: !1,
          isSigner: !1,
        },
        {
          pubkey: (b = s.systemProgram) !== null && b !== void 0 ? b : o.SystemProgram.programId,
          isWritable: !1,
          isSigner: !1,
        },
        { pubkey: s.sysvarInstructions, isWritable: !1, isSigner: !1 },
      ];
    return new o.TransactionInstruction({ programId: u, keys: w, data: m });
  }
  e.createVerifyInstruction = c;
})(iM);
var oM = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (c, s, l, u) {
            u === void 0 && (u = l);
            var d = Object.getOwnPropertyDescriptor(s, l);
            (!d || ('get' in d ? !s.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return s[l];
                },
              }),
              Object.defineProperty(c, u, d);
          }
        : function (c, s, l, u) {
            u === void 0 && (u = l), (c[u] = s[l]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (c, s) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: s });
          }
        : function (c, s) {
            c.default = s;
          }),
    r =
      (g && g.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var s = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(s, c, l);
        return n(s, c), s;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createVerifyCollectionInstruction =
      e.verifyCollectionInstructionDiscriminator =
      e.VerifyCollectionStruct =
        void 0);
  const i = r(W),
    o = r(V);
  (e.VerifyCollectionStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'VerifyCollectionInstructionArgs'
  )),
    (e.verifyCollectionInstructionDiscriminator = 18);
  function a(c, s = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [l] = e.VerifyCollectionStruct.serialize({
        instructionDiscriminator: e.verifyCollectionInstructionDiscriminator,
      }),
      u = [
        { pubkey: c.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: c.collectionAuthority, isWritable: !0, isSigner: !0 },
        { pubkey: c.payer, isWritable: !0, isSigner: !0 },
        { pubkey: c.collectionMint, isWritable: !1, isSigner: !1 },
        { pubkey: c.collection, isWritable: !1, isSigner: !1 },
        { pubkey: c.collectionMasterEditionAccount, isWritable: !1, isSigner: !1 },
      ];
    return (
      c.collectionAuthorityRecord != null &&
        u.push({ pubkey: c.collectionAuthorityRecord, isWritable: !1, isSigner: !1 }),
      new o.TransactionInstruction({ programId: s, keys: u, data: l })
    );
  }
  e.createVerifyCollectionInstruction = a;
})(oM);
var aM = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (c, s, l, u) {
            u === void 0 && (u = l);
            var d = Object.getOwnPropertyDescriptor(s, l);
            (!d || ('get' in d ? !s.__esModule : d.writable || d.configurable)) &&
              (d = {
                enumerable: !0,
                get: function () {
                  return s[l];
                },
              }),
              Object.defineProperty(c, u, d);
          }
        : function (c, s, l, u) {
            u === void 0 && (u = l), (c[u] = s[l]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (c, s) {
            Object.defineProperty(c, 'default', { enumerable: !0, value: s });
          }
        : function (c, s) {
            c.default = s;
          }),
    r =
      (g && g.__importStar) ||
      function (c) {
        if (c && c.__esModule) return c;
        var s = {};
        if (c != null)
          for (var l in c)
            l !== 'default' && Object.prototype.hasOwnProperty.call(c, l) && t(s, c, l);
        return n(s, c), s;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.createVerifySizedCollectionItemInstruction =
      e.verifySizedCollectionItemInstructionDiscriminator =
      e.VerifySizedCollectionItemStruct =
        void 0);
  const i = r(W),
    o = r(V);
  (e.VerifySizedCollectionItemStruct = new i.BeetArgsStruct(
    [['instructionDiscriminator', i.u8]],
    'VerifySizedCollectionItemInstructionArgs'
  )),
    (e.verifySizedCollectionItemInstructionDiscriminator = 30);
  function a(c, s = new o.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s')) {
    const [l] = e.VerifySizedCollectionItemStruct.serialize({
        instructionDiscriminator: e.verifySizedCollectionItemInstructionDiscriminator,
      }),
      u = [
        { pubkey: c.metadata, isWritable: !0, isSigner: !1 },
        { pubkey: c.collectionAuthority, isWritable: !1, isSigner: !0 },
        { pubkey: c.payer, isWritable: !0, isSigner: !0 },
        { pubkey: c.collectionMint, isWritable: !1, isSigner: !1 },
        { pubkey: c.collection, isWritable: !0, isSigner: !1 },
        { pubkey: c.collectionMasterEditionAccount, isWritable: !1, isSigner: !1 },
      ];
    return (
      c.collectionAuthorityRecord != null &&
        u.push({ pubkey: c.collectionAuthorityRecord, isWritable: !1, isSigner: !1 }),
      new o.TransactionInstruction({ programId: s, keys: u, data: l })
    );
  }
  e.createVerifySizedCollectionItemInstruction = a;
})(aM);
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (r, i, o, a) {
            a === void 0 && (a = o);
            var c = Object.getOwnPropertyDescriptor(i, o);
            (!c || ('get' in c ? !i.__esModule : c.writable || c.configurable)) &&
              (c = {
                enumerable: !0,
                get: function () {
                  return i[o];
                },
              }),
              Object.defineProperty(r, a, c);
          }
        : function (r, i, o, a) {
            a === void 0 && (a = o), (r[a] = i[o]);
          }),
    n =
      (g && g.__exportStar) ||
      function (r, i) {
        for (var o in r)
          o !== 'default' && !Object.prototype.hasOwnProperty.call(i, o) && t(i, r, o);
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    n(yk, e),
    n(bk, e),
    n(tC, e),
    n(nC, e),
    n(rC, e),
    n(iC, e),
    n(oC, e),
    n(aC, e),
    n(sC, e),
    n(cC, e),
    n(lC, e),
    n(dC, e),
    n(fC, e),
    n(hC, e),
    n(pC, e),
    n(gC, e),
    n(yC, e),
    n(wC, e),
    n(_C, e),
    n(vC, e),
    n(SC, e),
    n(AC, e),
    n(IC, e),
    n(EC, e),
    n(TC, e),
    n(kC, e),
    n(MC, e),
    n(PC, e),
    n(OC, e),
    n(DC, e),
    n(RC, e),
    n(xC, e),
    n(BC, e),
    n(jC, e),
    n(NC, e),
    n(UC, e),
    n(LC, e),
    n(zC, e),
    n(FC, e),
    n($C, e),
    n(WC, e),
    n(VC, e),
    n(KC, e),
    n(HC, e),
    n(qC, e),
    n(GC, e),
    n(YC, e),
    n(JC, e),
    n(XC, e),
    n(tM, e),
    n(nM, e),
    n(rM, e),
    n(iM, e),
    n(oM, e),
    n(aM, e);
})(gk);
var sM = {},
  cM = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (a, c, s, l) {
            l === void 0 && (l = s);
            var u = Object.getOwnPropertyDescriptor(c, s);
            (!u || ('get' in u ? !c.__esModule : u.writable || u.configurable)) &&
              (u = {
                enumerable: !0,
                get: function () {
                  return c[s];
                },
              }),
              Object.defineProperty(a, l, u);
          }
        : function (a, c, s, l) {
            l === void 0 && (l = s), (a[l] = c[s]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (g && g.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var s in a)
            s !== 'default' && Object.prototype.hasOwnProperty.call(a, s) && t(c, a, s);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.authorityTypeBeet = e.AuthorityType = void 0);
  const i = r(W);
  var o;
  (function (a) {
    (a[(a.None = 0)] = 'None'),
      (a[(a.Metadata = 1)] = 'Metadata'),
      (a[(a.Holder = 2)] = 'Holder'),
      (a[(a.MetadataDelegate = 3)] = 'MetadataDelegate'),
      (a[(a.TokenDelegate = 4)] = 'TokenDelegate');
  })((o = e.AuthorityType || (e.AuthorityType = {}))),
    (e.authorityTypeBeet = i.fixedScalarEnum(o));
})(cM);
var uM = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (a, c, s, l) {
            l === void 0 && (l = s);
            var u = Object.getOwnPropertyDescriptor(c, s);
            (!u || ('get' in u ? !c.__esModule : u.writable || u.configurable)) &&
              (u = {
                enumerable: !0,
                get: function () {
                  return c[s];
                },
              }),
              Object.defineProperty(a, l, u);
          }
        : function (a, c, s, l) {
            l === void 0 && (l = s), (a[l] = c[s]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (g && g.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var s in a)
            s !== 'default' && Object.prototype.hasOwnProperty.call(a, s) && t(c, a, s);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    (e.metadataDelegateRoleBeet = e.MetadataDelegateRole = void 0);
  const i = r(W);
  var o;
  (function (a) {
    (a[(a.AuthorityItem = 0)] = 'AuthorityItem'),
      (a[(a.Collection = 1)] = 'Collection'),
      (a[(a.Use = 2)] = 'Use'),
      (a[(a.Data = 3)] = 'Data'),
      (a[(a.ProgrammableConfig = 4)] = 'ProgrammableConfig'),
      (a[(a.DataItem = 5)] = 'DataItem'),
      (a[(a.CollectionItem = 6)] = 'CollectionItem'),
      (a[(a.ProgrammableConfigItem = 7)] = 'ProgrammableConfigItem');
  })((o = e.MetadataDelegateRole || (e.MetadataDelegateRole = {}))),
    (e.metadataDelegateRoleBeet = i.fixedScalarEnum(o));
})(uM);
var lM = {};
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (a, c, s, l) {
            l === void 0 && (l = s);
            var u = Object.getOwnPropertyDescriptor(c, s);
            (!u || ('get' in u ? !c.__esModule : u.writable || u.configurable)) &&
              (u = {
                enumerable: !0,
                get: function () {
                  return c[s];
                },
              }),
              Object.defineProperty(a, l, u);
          }
        : function (a, c, s, l) {
            l === void 0 && (l = s), (a[l] = c[s]);
          }),
    n =
      (g && g.__setModuleDefault) ||
      (Object.create
        ? function (a, c) {
            Object.defineProperty(a, 'default', { enumerable: !0, value: c });
          }
        : function (a, c) {
            a.default = c;
          }),
    r =
      (g && g.__importStar) ||
      function (a) {
        if (a && a.__esModule) return a;
        var c = {};
        if (a != null)
          for (var s in a)
            s !== 'default' && Object.prototype.hasOwnProperty.call(a, s) && t(c, a, s);
        return n(c, a), c;
      };
  Object.defineProperty(e, '__esModule', { value: !0 }), (e.payloadKeyBeet = e.PayloadKey = void 0);
  const i = r(W);
  var o;
  (function (a) {
    (a[(a.Amount = 0)] = 'Amount'),
      (a[(a.Authority = 1)] = 'Authority'),
      (a[(a.AuthoritySeeds = 2)] = 'AuthoritySeeds'),
      (a[(a.Delegate = 3)] = 'Delegate'),
      (a[(a.DelegateSeeds = 4)] = 'DelegateSeeds'),
      (a[(a.Destination = 5)] = 'Destination'),
      (a[(a.DestinationSeeds = 6)] = 'DestinationSeeds'),
      (a[(a.Holder = 7)] = 'Holder'),
      (a[(a.Source = 8)] = 'Source'),
      (a[(a.SourceSeeds = 9)] = 'SourceSeeds');
  })((o = e.PayloadKey || (e.PayloadKey = {}))),
    (e.payloadKeyBeet = i.fixedScalarEnum(o));
})(lM);
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (r, i, o, a) {
            a === void 0 && (a = o);
            var c = Object.getOwnPropertyDescriptor(i, o);
            (!c || ('get' in c ? !i.__esModule : c.writable || c.configurable)) &&
              (c = {
                enumerable: !0,
                get: function () {
                  return i[o];
                },
              }),
              Object.defineProperty(r, a, c);
          }
        : function (r, i, o, a) {
            a === void 0 && (a = o), (r[a] = i[o]);
          }),
    n =
      (g && g.__exportStar) ||
      function (r, i) {
        for (var o in r)
          o !== 'default' && !Object.prototype.hasOwnProperty.call(i, o) && t(i, r, o);
      };
  Object.defineProperty(e, '__esModule', { value: !0 }),
    n(Ef, e),
    n(Tf, e),
    n(cM, e),
    n(_r, e),
    n(Ko, e),
    n(bi, e),
    n(wr, e),
    n(dr, e),
    n(lr, e),
    n(Ho, e),
    n(kf, e),
    n(Cf, e),
    n(da, e),
    n(la, e),
    n(Is, e),
    n(at, e),
    n(ui, e),
    n(pn, e),
    n(Of, e),
    n(qo, e),
    n(uM, e),
    n(Go, e),
    n(F1, e),
    n(Yo, e),
    n(Es, e),
    n(Mf, e),
    n(lM, e),
    n(jn, e),
    n(ur, e),
    n(ro, e),
    n(zc, e),
    n(Lc, e),
    n($1, e),
    n(hr, e),
    n(Pf, e),
    n(As, e),
    n(O1, e),
    n(vs, e),
    n(P1, e),
    n(Zo, e),
    n(Df, e),
    n(Qo, e),
    n(Ct, e),
    n(Rf, e),
    n(Jo, e),
    n(M1, e),
    n(mi, e),
    n(fr, e),
    n(xf, e),
    n(Xg, e);
})(sM);
var eS;
function W1() {
  return (
    eS ||
      ((eS = 1),
      (function (e) {
        var t =
            (g && g.__createBinding) ||
            (Object.create
              ? function (i, o, a, c) {
                  c === void 0 && (c = a);
                  var s = Object.getOwnPropertyDescriptor(o, a);
                  (!s || ('get' in s ? !o.__esModule : s.writable || s.configurable)) &&
                    (s = {
                      enumerable: !0,
                      get: function () {
                        return o[a];
                      },
                    }),
                    Object.defineProperty(i, c, s);
                }
              : function (i, o, a, c) {
                  c === void 0 && (c = a), (i[c] = o[a]);
                }),
          n =
            (g && g.__exportStar) ||
            function (i, o) {
              for (var a in i)
                a !== 'default' && !Object.prototype.hasOwnProperty.call(o, a) && t(o, i, a);
            };
        Object.defineProperty(e, '__esModule', { value: !0 }),
          (e.PROGRAM_ID = e.PROGRAM_ADDRESS = void 0);
        const r = V;
        n(QL(), e),
          n(v, e),
          n(gk, e),
          n(sM, e),
          (e.PROGRAM_ADDRESS = 'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'),
          (e.PROGRAM_ID = new r.PublicKey(e.PROGRAM_ADDRESS));
      })(Zy)),
    Zy
  );
}
Object.defineProperty(Xp, '__esModule', { value: !0 });
Xp.cusper = void 0;
const YH = g4,
  ZH = W1();
Xp.cusper = (0, YH.initCusper)(ZH.errorFromCode);
(function (e) {
  var t =
      (g && g.__createBinding) ||
      (Object.create
        ? function (r, i, o, a) {
            a === void 0 && (a = o);
            var c = Object.getOwnPropertyDescriptor(i, o);
            (!c || ('get' in c ? !i.__esModule : c.writable || c.configurable)) &&
              (c = {
                enumerable: !0,
                get: function () {
                  return i[o];
                },
              }),
              Object.defineProperty(r, a, c);
          }
        : function (r, i, o, a) {
            a === void 0 && (a = o), (r[a] = i[o]);
          }),
    n =
      (g && g.__exportStar) ||
      function (r, i) {
        for (var o in r)
          o !== 'default' && !Object.prototype.hasOwnProperty.call(i, o) && t(i, r, o);
      };
  Object.defineProperty(e, '__esModule', { value: !0 }), n(Xp, e), n(W1(), e);
})(Nj);
new Ye('CMTQqjzH6Anr9XcPVt73EFDTjWkJWPzH7H6DtvhHcyzV');
const QH = new Ye('ocp4vWUzA2z2XMYJ3QhM9vWdyoyoQwAFJhRdVTbvo9E'),
  tS = [81, 17, 143, 120, 23, 57, 22, 117];
class ko {
  constructor(t, n, r, i, o, a, c, s) {
    (this.version = t),
      (this.bump = n),
      (this.mint = r),
      (this.policy = i),
      (this.lockedBy = o),
      (this.lastApprovedAt = a),
      (this.lastTransferredAt = c),
      (this.transferredCount = s);
  }
  static fromArgs(t) {
    return new ko(
      t.version,
      t.bump,
      t.mint,
      t.policy,
      t.lockedBy,
      t.lastApprovedAt,
      t.lastTransferredAt,
      t.transferredCount
    );
  }
  static fromAccountInfo(t, n = 0) {
    return ko.deserialize(t.data, n);
  }
  static async fromAccountAddress(t, n) {
    const r = await t.getAccountInfo(n);
    if (r == null) throw new Error(`Unable to find MintState account at ${n}`);
    return ko.fromAccountInfo(r, 0)[0];
  }
  static gpaBuilder(t = QH) {
    return st.GpaBuilder.fromStruct(t, fh);
  }
  static deserialize(t, n = 0) {
    return fh.deserialize(t, n);
  }
  serialize() {
    return fh.serialize({ accountDiscriminator: tS, ...this });
  }
  static byteSize(t) {
    const n = ko.fromArgs(t);
    return fh.toFixedFromValue({ accountDiscriminator: tS, ...n }).byteSize;
  }
  static async getMinimumBalanceForRentExemption(t, n, r) {
    return n.getMinimumBalanceForRentExemption(ko.byteSize(t), r);
  }
  pretty() {
    return {
      version: this.version,
      bump: this.bump,
      mint: this.mint.toBase58(),
      policy: this.policy.toBase58(),
      lockedBy: this.lockedBy,
      lastApprovedAt: (() => {
        const t = this.lastApprovedAt;
        if (typeof t.toNumber == 'function')
          try {
            return t.toNumber();
          } catch {
            return t;
          }
        return t;
      })(),
      lastTransferredAt: (() => {
        const t = this.lastTransferredAt;
        if (typeof t.toNumber == 'function')
          try {
            return t.toNumber();
          } catch {
            return t;
          }
        return t;
      })(),
      transferredCount: this.transferredCount,
    };
  }
}
const fh = new W.FixableBeetStruct(
  [
    ['accountDiscriminator', W.uniformFixedSizeArray(W.u8, 8)],
    ['version', W.u8],
    ['bump', W.uniformFixedSizeArray(W.u8, 1)],
    ['mint', st.publicKey],
    ['policy', st.publicKey],
    ['lockedBy', W.coption(st.publicKey)],
    ['lastApprovedAt', W.i64],
    ['lastTransferredAt', W.i64],
    ['transferredCount', W.u32],
  ],
  ko.fromArgs,
  'MintState'
);
new W.BeetArgsStruct(
  [['instructionDiscriminator', W.uniformFixedSizeArray(W.u8, 8)]],
  'InitAccountInstructionArgs'
);
new W.BeetArgsStruct(
  [['instructionDiscriminator', W.uniformFixedSizeArray(W.u8, 8)]],
  'TransferInstructionArgs'
);
const JH = 4294967293,
  XH = 4294967295,
  V1 = {
    [X.BitcoinLegacy]: { header: 10, perInput: 148, perOutput: 34 },
    [X.BitcoinNestedSegwit]: { header: 10.5, perInput: 91, perOutput: 32 },
    [X.BitcoinNativeSegwit]: { header: 10.5, perInput: 68, perOutput: 31 },
    [X.BitcoinTaproot]: { header: 10.5, perInput: 57.5, perOutput: 43 },
  },
  eq = 75,
  tq = {
    [X.BitcoinTaproot]: 330,
    [X.BitcoinNativeSegwit]: 294,
    [X.BitcoinNestedSegwit]: 540,
    [X.BitcoinLegacy]: 546,
  };
function Que({ btcPerKilobyte: e, virtualBytes: t, additionalCosts: n }) {
  return Bf(e).times(t).plus(n).integerValue(oe.ROUND_UP);
}
function Bf(e) {
  const t = new oe(0.001),
    n = Ec(q.getTokenDecimals(ce.Bitcoin.Mainnet));
  return e.times(n).times(t);
}
function dM(e) {
  const t = e.data.inputs[0];
  let n;
  if (t.witnessUtxo) n = t.witnessUtxo.script;
  else if (t.nonWitnessUtxo)
    n = Zt.Transaction.fromBuffer(t.nonWitnessUtxo).outs[e.txInputs[0].index].script;
  else throw new Error(`Unable to determine sender address from input: ${JSON.stringify(t)}`);
  return D4(n);
}
function nq(e) {
  const t = dM(e),
    n = br(ce.Bitcoin.Mainnet, t);
  if (kh(n)) return n;
  throw new Error(`Unknown address type for address: ${t}.`);
}
function fM(e) {
  return e.extractTransaction().getId();
}
const rq = (e) => q.isSolanaNetworkID(e.networkID),
  iq = (e) => q.isSuiNetworkID(e.networkID),
  oq = (e) => q.isEVMNetworkID(e.networkID),
  aq = (e) => q.isBitcoinNetworkID(e.networkID);
function hM(e) {
  return q.isBitcoinNetworkID(e.networkID);
}
function pM(e) {
  return q.isEVMNetworkID(e.networkID);
}
function sq(e) {
  return q.isSolanaNetworkID(e.networkID);
}
function cq(e) {
  return q.isSuiNetworkID(e.networkID);
}
const Xt = [];
for (let e = 0; e < 256; ++e) Xt.push((e + 256).toString(16).slice(1));
function uq(e, t = 0) {
  return (
    Xt[e[t + 0]] +
    Xt[e[t + 1]] +
    Xt[e[t + 2]] +
    Xt[e[t + 3]] +
    '-' +
    Xt[e[t + 4]] +
    Xt[e[t + 5]] +
    '-' +
    Xt[e[t + 6]] +
    Xt[e[t + 7]] +
    '-' +
    Xt[e[t + 8]] +
    Xt[e[t + 9]] +
    '-' +
    Xt[e[t + 10]] +
    Xt[e[t + 11]] +
    Xt[e[t + 12]] +
    Xt[e[t + 13]] +
    Xt[e[t + 14]] +
    Xt[e[t + 15]]
  ).toLowerCase();
}
let Fb;
const lq = new Uint8Array(16);
function dq() {
  if (!Fb) {
    if (typeof crypto > 'u' || !crypto.getRandomValues)
      throw new Error(
        'crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported'
      );
    Fb = crypto.getRandomValues.bind(crypto);
  }
  return Fb(lq);
}
const fq = typeof crypto < 'u' && crypto.randomUUID && crypto.randomUUID.bind(crypto),
  nS = { randomUUID: fq };
function hh(e, t, n) {
  var i;
  if (nS.randomUUID && !t && !e) return nS.randomUUID();
  e = e || {};
  const r = e.random ?? ((i = e.rng) == null ? void 0 : i.call(e)) ?? dq();
  if (r.length < 16) throw new Error('Random bytes length must be >= 16');
  if (((r[6] = (r[6] & 15) | 64), (r[8] = (r[8] & 63) | 128), t)) {
    if (((n = n || 0), n < 0 || n + 16 > t.length))
      throw new RangeError(`UUID byte range ${n}:${n + 15} is out of buffer bounds`);
    for (let o = 0; o < 16; ++o) t[n + o] = r[o];
    return t;
  }
  return uq(r);
}
const gM = (e, t, n, r) => {
    const i = Jp(e);
    return r ? new Jw(t, n, new U4(r, i)) : new Jw(t, n, i);
  },
  hq = '0x420000000000000000000000000000000000000F',
  pq = ['function getL1Fee(bytes memory _data) external view returns (uint256)'],
  yM = async ({ networkId: e, serializedUnsignedTransaction: t }) => {
    const r = await gM(e, hq, pq).getL1Fee(t);
    return new oe(r.toString());
  },
  ey = (e, t) => {
    const { gas: n, nonce: r, from: i, type: o, chainId: a, ...c } = e,
      s = 2,
      l = typeof r == 'string' ? parseInt(r, 16) : void 0,
      u = a ? parseInt(a) : void 0,
      d = { ...c, gasLimit: n, nonce: l, type: s, chainId: u };
    return L4(d, t);
  };
function gq(e, t) {
  const n = Tc.parse({ ...e.unsignedTransaction, ...yq(t) });
  return { ...e, unsignedTransaction: n };
}
function yq(e) {
  return e
    ? {
        gasLimit: `0x${e.gasLimit.toString(16)}`,
        maxFeePerGas: `0x${e.maxFeePerGas.toString(16)}`,
        maxPriorityFeePerGas: `0x${e.maxPriorityFeePerGas.toString(16)}`,
      }
    : {};
}
function bq(e, t = !1, n) {
  const r = n[e];
  return r ? (t ? r.descriptionAbbreviatedKey : r.descriptionKey) : '';
}
const ty = {
    transactionSpeedDescription: function (e, t) {
      return bq(e, t, this.transactionTimes);
    },
    transactionSpeedSeconds: function (e) {
      var t;
      return (t = this.transactionTimes[e]) == null ? void 0 : t.seconds;
    },
    transactionTimes: {},
    onBeforeSend: ({ multichainTransaction: e }) => Promise.resolve(e),
  },
  Ts = {
    ...ty,
    transactionSettingsRowFeeDescription: void 0,
    isPendingTransactionMined: function (e) {
      return e.data.transactions.some((t) => t.confirmations > 0);
    },
    networkFeeRowString: function (e, t) {
      return t ? (e ? K3('gasUpTo', { amount: e }) : '') : (e ?? '');
    },
    isPendingTransactionsEqual: ({ data: e }, { data: t }) =>
      e.nonce === t.nonce && e.transactions.every((n, r) => n.hash === t.transactions[r].hash),
    sendSuccessRedirect: () => pi.History,
    droppedTransactionThresholdMs: ae({ days: 2 }),
    onBeforeSend: ({ multichainTransaction: e, gasEstimation: t }) => {
      const n = t ? gq(e, t) : e;
      return Promise.resolve(n);
    },
    supportsNetworkSettings: !0,
  },
  mq = {
    ...Ts,
    isPendingTransactionConfirmed: function ({ data: e }) {
      return e.transactions.some((t) => t.confirmations > 5);
    },
    sendSuccessRedirect: (e) => (e ? pi.Home : pi.History),
    additionalTransactionCost: async ({ networkID: e, unsignedTransaction: t }) =>
      yM({ networkId: e, serializedUnsignedTransaction: ey(t) }),
    droppedTransactionThresholdMs: ae({ minutes: 5 }),
  },
  wq = {
    ...Ts,
    isPendingTransactionConfirmed: function ({ data: e }) {
      return e.transactions.some((t) => t.confirmations > 5);
    },
    sendSuccessRedirect: (e) => (e ? pi.Home : pi.History),
    additionalTransactionCost: async ({ networkID: e, unsignedTransaction: t }) =>
      yM({ networkId: e, serializedUnsignedTransaction: ey(t) }),
    droppedTransactionThresholdMs: ae({ minutes: 5 }),
  },
  _q = {
    descriptionKey: 'timeDescription1hour',
    descriptionAbbreviatedKey: 'timeDescriptionAbbrev1hour',
    seconds: 3600,
  },
  vq = {
    descriptionKey: 'timeDescription30minutes',
    descriptionAbbreviatedKey: 'timeDescriptionAbbrev30minutes',
    seconds: 1800,
  },
  Sq = {
    descriptionKey: 'timeDescription10minutes',
    descriptionAbbreviatedKey: 'timeDescriptionAbbrev10minutes',
    seconds: 600,
  },
  Aq = {
    descriptionKey: 'timeDescription2minutes',
    descriptionAbbreviatedKey: 'timeDescriptionAbbrev2minutes',
    seconds: 120,
  },
  Iq = {
    descriptionKey: 'timeDescription30seconds',
    descriptionAbbreviatedKey: 'timeDescriptionAbbrev30seconds',
    seconds: 30,
  },
  Eq = {
    descriptionKey: 'timeDescription15seconds',
    descriptionAbbreviatedKey: 'timeDescriptionAbbrev15seconds',
    seconds: 15,
  },
  Tq = {
    descriptionKey: 'timeDescription10seconds',
    descriptionAbbreviatedKey: 'timeDescriptionAbbrev10seconds',
    seconds: 10,
  },
  kq = {
    descriptionKey: 'timeDescription5seconds',
    descriptionAbbreviatedKey: 'timeDescriptionAbbrev5seconds',
    seconds: 5,
  },
  Cq = {
    descriptionKey: 'timeDescription1second',
    descriptionAbbreviatedKey: 'timeDescriptionAbbrev1second',
    seconds: 1,
  },
  vn = {
    TIME_1_HOUR: _q,
    TIME_30_MINUTES: vq,
    TIME_10_MINUTES: Sq,
    TIME_2_MINUTES: Aq,
    TIME_30_SECONDS: Iq,
    TIME_15_SECONDS: Eq,
    TIME_10_SECONDS: Tq,
    TIME_5_SECONDS: kq,
    TIME_1_SECOND: Cq,
  },
  Mq = 35e5,
  Pq = 'http://127.0.0.1:8899';
b2(5e-6);
const Oq = {
    ...ty,
    transactionSettingsRowFeeDescription: (e) =>
      `${Bf(e.btcPerKilobyte).decimalPlaces(1, oe.ROUND_HALF_UP)} sats/vB`,
    isPendingTransactionConfirmed: function (e) {
      return e.data.confirmations > 0;
    },
    isPendingTransactionMined: function (e) {
      return e.data.confirmations > 0;
    },
    networkFeeRowString: function (e) {
      return e || '';
    },
    transactionTimes: {
      slow: vn.TIME_10_MINUTES,
      standard: vn.TIME_10_MINUTES,
      fast: vn.TIME_10_MINUTES,
    },
    isPendingTransactionsEqual: (e, t) => e.data.txID === t.data.txID,
    sendSuccessRedirect: () => pi.History,
    droppedTransactionThresholdMs: ae({ hours: 3 }),
    supportsNetworkSettings: !0,
  },
  Dq = {
    ...Ts,
    isPendingTransactionConfirmed: function ({ data: e }) {
      return e.transactions.some((t) => t.confirmations > 0);
    },
    transactionTimes: {
      slow: vn.TIME_2_MINUTES,
      standard: vn.TIME_30_SECONDS,
      fast: vn.TIME_15_SECONDS,
    },
  },
  Rq = {
    ...Ts,
    isPendingTransactionConfirmed: function ({ data: e }) {
      return e.transactions.some((t) => t.confirmations > 5);
    },
    transactionTimes: {
      slow: vn.TIME_15_SECONDS,
      standard: vn.TIME_10_SECONDS,
      fast: vn.TIME_5_SECONDS,
    },
  },
  xq = {
    ...Ts,
    isPendingTransactionConfirmed: function ({ data: e }) {
      return e.transactions.some((t) => t.confirmations > 1);
    },
    transactionTimes: {
      slow: vn.TIME_1_SECOND,
      standard: vn.TIME_1_SECOND,
      fast: vn.TIME_1_SECOND,
    },
    supportsNetworkSettings: !1,
  },
  Bq = {
    ...Ts,
    isPendingTransactionConfirmed: function ({ data: e }) {
      return e.transactions.some((t) => t.confirmations > 5);
    },
    transactionTimes: {
      slow: vn.TIME_15_SECONDS,
      standard: vn.TIME_10_SECONDS,
      fast: vn.TIME_5_SECONDS,
    },
  },
  jq = {
    ...ty,
    transactionSettingsRowFeeDescription: void 0,
    isPendingTransactionConfirmed: function (e) {
      return e.data.confirmationStatus === 'confirmed';
    },
    isPendingTransactionMined: function (e) {
      return e.data.confirmationStatus === 'processed';
    },
    networkFeeRowString: function (e) {
      return e || '';
    },
    transactionTimes: {},
    isPendingTransactionsEqual: (e, t) => e.data.signature === t.data.signature,
    sendSuccessRedirect: () => pi.History,
    droppedTransactionThresholdMs: Number.POSITIVE_INFINITY,
    supportsNetworkSettings: !1,
  },
  ks = (e) => {
    const t = q.getRpcProxyUrl(e);
    if (!t) throw new Error(`Unable to instantiate client for ${e}`);
    return new II({ url: t });
  };
async function Nq({ multichainTransaction: e, gasEstimation: t }) {
  if (!t) return e;
  const { transaction: n, networkID: r } = e,
    i = fs.from(n);
  i.setGasBudget(BigInt(t.gasBudget.toString()));
  const o = await i.build({ client: ks(r) });
  return { ...e, transaction: o };
}
const Uq = {
    ...ty,
    transactionSettingsRowFeeDescription: void 0,
    isPendingTransactionConfirmed: function (e) {
      throw new Error('Function not implemented for Sui.');
    },
    isPendingTransactionMined: function (e) {
      throw new Error('Function not implemented for Sui.');
    },
    networkFeeRowString: function (e) {
      return e || '';
    },
    isPendingTransactionsEqual: function (e, t) {
      return e.data.digest === t.data.digest;
    },
    sendSuccessRedirect: () => pi.History,
    droppedTransactionThresholdMs: ae({ minutes: 5 }),
    amountForGasEstimation: 1,
    onBeforeSend: Nq,
    supportsNetworkSettings: !1,
  },
  Lq = new Sc({
    [Oe.Solana]: jq,
    [Oe.Ethereum]: Dq,
    [Oe.Polygon]: Bq,
    [Oe.Monad]: xq,
    [Oe.Base]: wq,
    [Oe.Arbitrum]: mq,
    [Oe.Bitcoin]: Oq,
    [Oe.Sui]: Uq,
    [Oe.Hypercore]: Rq,
  }),
  rs = Ac(Lq),
  zq = {
    [ce.Bitcoin.Mainnet]: 'https://btc-mainnet.phantom.app',
    [ce.Bitcoin.Testnet]: 'https://btc-mainnet.phantom.dev',
  },
  Cs = (e) => {
    if (!q.isBitcoinNetworkID(e)) throw new Error(`Unsupported network id: ${e}`);
    return lj(zq[e]);
  };
new Ye('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');
const bM = new Ye('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'),
  Fq = new Ye('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),
  $q = new Ye('DeJBGdMFa1uynnnKiwrVioatTuHmNLpyFKnmB5kaFdzQ'),
  mM = new Ye('11111111111111111111111111111111'),
  Wq = (e, t) => {
    if (!(e.toString() === mM.toString() || e.toString() === t.toString())) return e;
  },
  Vq = async (e, t, n) => {
    const r = { programId: n };
    return (await t.getParsedTokenAccountsByOwner(e, r, 'confirmed')).value.map(
      ({ pubkey: c, account: s }) => {
        const { mint: l, owner: u, tokenAmount: d, delegate: f } = s.data.parsed.info,
          p = new Ye(u),
          y = { pubkey: c, mintAddress: l, owner: p, tokenAmount: d };
        return f && (y.delegate = Wq(new Ye(f), p)), y;
      }
    );
  },
  fa = (e, t) => {
    const n = wM(e);
    return Co(n, t);
  },
  Co = (e, t) => {
    const n = { commitment: 'processed', fetch: aD };
    if ((t && (n.httpHeaders = t), e === 'localhost')) return new Py(Pq, n);
    if (e === 'mainnet-beta') {
      const r = q.getRpcProxyUrl(Hi.Mainnet);
      if (!r) throw new Error('Unable to find RPC Proxy Url for Solana Mainnet');
      return new Py(r, n);
    }
    return new Py(b4(e), n);
  },
  wM = (e) => {
    switch (e) {
      case ce.Solana.Mainnet:
        return 'mainnet-beta';
      case ce.Solana.Testnet:
        return 'testnet';
      case ce.Solana.Devnet:
        return 'devnet';
      case ce.Solana.Localnet:
        return 'localhost';
    }
  },
  Kq = (e) => {
    if (!e) return Co('mainnet-beta');
    switch (e) {
      case ce.Solana.Testnet:
        return Co('testnet');
      case ce.Solana.Devnet:
        return Co('devnet');
      case ce.Solana.Mainnet:
        return Co('mainnet-beta');
      case ce.Solana.Localnet:
        return Co('localhost');
    }
  },
  Rh = {
    [ce.Ethereum.Mainnet]: 5e3,
    [ce.Ethereum.Sepolia]: 5e3,
    [ce.Polygon.Mainnet]: 5e3,
    [ce.Polygon.Amoy]: 5e3,
    [ce.Base.Mainnet]: 5e3,
    [ce.Base.Sepolia]: 5e3,
    [ce.Monad.Mainnet]: 5e3,
    [ce.Monad.Testnet]: 5e3,
    [ce.Monad.Devnet]: 5e3,
    [ce.Bitcoin.Mainnet]: 5e3,
    [ce.Bitcoin.Testnet]: 5e3,
    [ce.Arbitrum.Mainnet]: 5e3,
    [ce.Arbitrum.Sepolia]: 5e3,
    [ce.Hypercore.Mainnet]: 5e3,
    [ce.Hypercore.Testnet]: 5e3,
  },
  Hq = [],
  qq = [],
  Ms = async (e) => (await e.get(Cp.PendingTransactions)) || {},
  oo = async (e, t) => {
    const r = (await Ms(t))[e.id];
    if (r) return r;
  },
  pr = async (e, t) => {
    try {
      await ny(t, async (n) => (n[e.id] && delete n[e.id], n)),
        qq.forEach((n) => {
          try {
            n(e, t);
          } catch {}
        });
    } catch (n) {
      Z.addBreadcrumb(te.Transaction, 'Error removing pending transaction', Te.Error),
        Z.captureError(n, te.Transaction);
    }
  },
  rS = async (e, t) => {
    const n = await Ms(t);
    return Object.values(n).filter(
      (i) => i.networkID === e.networkID && i.ownerAddress === e.ownerAddress && i.id !== e.id
    );
  },
  Xo = async (e, t) => {
    try {
      await ny(t, async (n) => (n[e.id] && (n[e.id] = e), n)),
        Hq.forEach((n) => {
          try {
            n(e, t);
          } catch {}
        });
    } catch (n) {
      Z.addBreadcrumb(te.Transaction, 'Error updating pending transaction', Te.Error),
        Z.captureError(n, te.Transaction);
    }
  },
  Gq = async (e, t, n) => {
    try {
      const r = _M(e);
      let i = !1;
      (r.networkID === Yh.Mainnet || r.networkID === Yh.Testnet) && (i = await Jq(r));
      let o = !1;
      if (
        (await ny(n, async (a) => {
          let c = !1;
          for (const s of Object.values(a))
            if (t(s, r)) {
              c = !0;
              break;
            }
          return !c && !i && ((a[r.id] = r), (o = !0)), a;
        }),
        o)
      )
        return jf(r, n), 1;
    } catch (r) {
      Z.captureError(r, te.Transaction);
    }
    return 0;
  },
  Hs = {},
  Yq = async (e, t, n) => {
    const r = await oo(t, n);
    if (!r) return !0;
    if (!r.networkID)
      return (
        Z.captureMessage('Removing pending tx where networkID is null', te.History),
        await pr(r, n),
        !0
      );
    const i = Jp(e);
    if (
      (await rS(r, n)).some(
        (s) => s.data.nonce < r.data.nonce && !rs.get(r.networkID).isPendingTransactionMined(s)
      )
    )
      return await gr(r, n, Rh[r.networkID]), !0;
    const c = r.data.transactions.find((s) => s.confirmations > 0);
    return (
      r.data.transactions.forEach(async (s) => {
        if ((c && s.hash !== c.hash) || Hs[s.hash] !== void 0) return;
        let l = null;
        try {
          let f = 0,
            p;
          for (; !l && f < 3; )
            try {
              (Hs[s.hash] = An(
                () => i.getTransactionReceipt(s.hash),
                () => !0
              )),
                (l = await Hs[s.hash]),
                await Xi(1e3);
            } catch (y) {
              p = y;
            } finally {
              ++f;
            }
          if (p && !l) throw p;
        } catch (f) {
          Z.captureError(f, te.Transaction), delete Hs[s.hash], await gr(r, n, Rh[r.networkID]);
          return;
        }
        delete Hs[s.hash];
        const u = await oo(r, n),
          d = u == null ? void 0 : u.data.transactions.find((f) => f.hash === s.hash);
        if (!l) {
          if (u && d) {
            if (d.confirmations > 0) (d.confirmations = 0), Xo(u, n);
            else if (
              Date.now() - u.data.transactions[u.data.transactions.length - 1].timestamp >
              rs.get(t.networkID).droppedTransactionThresholdMs
            ) {
              Z.addBreadcrumb(te.Transaction, 'Removing long age TX', Te.Debug), pr(u, n);
              return;
            } else
              try {
                if (
                  !(await rS(u, n)).some((w) => w.data.nonce < u.data.nonce) &&
                  (await An(
                    () => i.getTransactionCount(u.ownerAddress),
                    () => !0
                  )) !== u.data.nonce &&
                  u.data.transactions.every((_) => _.confirmations === 0)
                ) {
                  pr(u, n);
                  return;
                }
              } catch (b) {
                Z.captureError(b, te.Transaction);
              }
            const f = Date.now() - d.timestamp;
            let p = 30 * 60 * 1e3;
            f < 10 * 60 * 1e3
              ? (p = 5 * 1e3)
              : f < 20 * 60 * 1e3
                ? (p = 15 * 1e3)
                : f < 40 * 60 * 1e3
                  ? (p = 30 * 1e3)
                  : f < 2 * 60 * 60 * 1e3
                    ? (p = 1 * 60 * 1e3)
                    : f < 24 * 60 * 60 * 1e3 && (p = 5 * 60 * 1e3),
              await gr(r, n, p);
          }
          return;
        }
        l.confirmations >= m2[e]
          ? pr(r, n)
          : u &&
            d &&
            ((d.confirmations = l.confirmations),
            l.status === 0 && (d.error = { message: 'Reverted' }),
            Xo(u, n),
            await gr(r, n, Rh[r.networkID]));
      }),
      !0
    );
  },
  qs = {},
  Zq = async (e, t, n) => {
    var i, o, a, c;
    const r = await oo(t, n);
    if (!r) return !0;
    if (!qs[r.id]) {
      const s = Kq(e);
      let l;
      try {
        let u = 0,
          d;
        for (; (!l || l.value === null) && u < 10; )
          try {
            qs[r.id] = An(
              () => s.getSignatureStatuses([r.data.signature]),
              () => !0
            );
            const f = await qs[r.id];
            (l = { ...f, value: (i = f.value) == null ? void 0 : i[0] }), await Xi(2e3);
          } catch (f) {
            d = f;
          } finally {
            ++u;
          }
        if (d && (!l || l.value === null)) throw d;
      } catch (u) {
        return Z.captureError(u, te.Transaction), delete qs[r.id], await gr(r, n, 5e3), !0;
      }
      if ((delete qs[r.id], !l || l.value === null)) pr(r, n);
      else if (((o = l.value) == null ? void 0 : o.confirmationStatus) === 'finalized') pr(r, n);
      else {
        const u = await oo(r, n);
        u &&
          ((u.data.confirmationStatus = (a = l.value) == null ? void 0 : a.confirmationStatus),
          (c = l.value) != null && c.err && (u.data.error = { message: 'Error' }),
          Xo(u, n),
          await gr(r, n, 1e3));
      }
    }
    return !0;
  },
  Gs = {},
  Qq = async (e, t, n) => {
    const r = await oo(t, n);
    if (!r) return !0;
    if (!r.networkID)
      return (
        Z.captureMessage('Removing pending tx where networkID is null', te.History),
        await pr(r, n),
        !0
      );
    if (Gs[r.id] !== void 0) return !0;
    const i = Cs(e);
    let o;
    try {
      let c = 0,
        s;
      for (; (!o || (o == null ? void 0 : o.confirmations) === void 0) && c < 20; )
        try {
          (Gs[r.id] = An(
            () => i.getRawTransaction(r.data.txID),
            () => !0
          )),
            (o = await Gs[r.id]),
            await Xi(10 * 1e3);
        } catch (l) {
          s = l;
        } finally {
          ++c;
        }
      if (s && !o) throw s;
    } catch (c) {
      return Z.captureError(c, te.Transaction), delete Gs[r.id], await gr(r, n, 5e3), !0;
    }
    delete Gs[r.id];
    const a = await oo(t, n);
    if (!o || o.confirmations === void 0) {
      if (a) {
        const c = Date.now() - a.timestamp;
        if (c > rs.get(t.networkID).droppedTransactionThresholdMs)
          return (
            Z.addBreadcrumb(te.Transaction, 'Removing long age TX', Te.Debug), await pr(a, n), !0
          );
        let s = 30 * 60 * 1e3;
        c < 10 * 60 * 1e3
          ? (s = 5 * 1e3)
          : c < 20 * 60 * 1e3
            ? (s = 15 * 1e3)
            : c < 40 * 60 * 1e3
              ? (s = 30 * 1e3)
              : c < 2 * 60 * 60 * 1e3
                ? (s = 1 * 60 * 1e3)
                : c < 24 * 60 * 60 * 1e3 && (s = 5 * 60 * 1e3),
          await gr(r, n, s);
      }
      return !0;
    }
    return (
      (o == null ? void 0 : o.confirmations) >= cI[e]
        ? await pr(r, n)
        : a &&
          ((a.data.confirmations = o.confirmations),
          await Xo(a, n),
          await gr(r, n, Rh[r.networkID])),
      !0
    );
  },
  Jq = async (e) => {
    if (Date.now() - e.timestamp > 36e5 * 48) return !0;
    const n = Cs(e.networkID),
      r = await An(
        () => n.getRawTransaction(e.data.txID),
        () => !0
      );
    return (r == null ? void 0 : r.confirmations) !== void 0 && r.confirmations >= cI[e.networkID];
  },
  Ys = {},
  Xq = async (e, t, n) => {
    var i;
    const r = await oo(t, n);
    if (!r) return !0;
    if (!Ys[r.id]) {
      const o = ks(e);
      let a;
      try {
        let c = 0,
          s;
        for (; (!a || a.effects === null) && c < 10; )
          try {
            (Ys[r.id] = An(
              () => o.getTransactionBlock({ digest: r.data.digest, options: { showEffects: !0 } }),
              () => !0
            )),
              (a = await Ys[r.id]),
              await Xi(2e3);
          } catch (l) {
            s = l;
          } finally {
            ++c;
          }
        if (s && (!a || a.effects === null)) throw s;
      } catch (c) {
        return Z.captureError(c, te.Transaction), delete Ys[r.id], await gr(r, n, 5e3), !0;
      }
      if ((delete Ys[r.id], a && (i = a.effects) != null && i.status)) pr(r, n);
      else {
        const c = await oo(r, n);
        c && (Xo(c, n), await gr(r, n, 1e3));
      }
    }
    return !0;
  },
  jf = async (e, t) => {
    const n = e.networkID;
    if (!n)
      return (
        Z.captureMessage('Removing pending tx where networkID is null', te.History),
        await pr(e, t),
        !0
      );
    switch (n) {
      case ce.Base.Mainnet:
      case ce.Base.Sepolia:
      case ce.Arbitrum.Mainnet:
      case ce.Arbitrum.Sepolia:
      case ce.Hypercore.Mainnet:
      case ce.Hypercore.Testnet:
      case ce.Monad.Mainnet:
      case ce.Monad.Testnet:
      case ce.Monad.Devnet:
      case ce.Ethereum.Mainnet:
      case ce.Ethereum.Sepolia:
      case ce.Polygon.Mainnet:
      case ce.Polygon.Amoy:
        return Yq(n, e, t);
      case ce.Solana.Mainnet:
      case ce.Solana.Testnet:
      case ce.Solana.Devnet:
      case ce.Solana.Localnet:
        return Zq(n, e, t);
      case ce.Bitcoin.Mainnet:
      case ce.Bitcoin.Testnet:
        return Qq(n, e, t);
      case ce.Sui.Mainnet:
      case ce.Sui.Testnet:
        return Xq(n, e, t);
    }
  },
  gr = async (e, t, n) => (await Xi(n), jf(e, t));
async function ny(e, t) {
  return e.update(Cp.PendingTransactions, async (n) => {
    let r = n;
    return r === null && (r = {}), t(r);
  });
}
function _M(e) {
  let t;
  switch (e.networkID) {
    case ce.Base.Mainnet:
    case ce.Base.Sepolia:
    case ce.Arbitrum.Mainnet:
    case ce.Arbitrum.Sepolia:
    case ce.Hypercore.Mainnet:
    case ce.Hypercore.Testnet:
    case ce.Monad.Mainnet:
    case ce.Monad.Testnet:
    case ce.Monad.Devnet:
    case ce.Ethereum.Mainnet:
    case ce.Ethereum.Sepolia:
    case ce.Polygon.Mainnet:
    case ce.Polygon.Amoy: {
      const { networkID: n, display: r, ownerAddress: i, type: o } = e,
        {
          hash: a,
          nonce: c,
          unsignedTransaction: s,
          callPayload: l,
          estimatedTimeToMineInSeconds: u,
        } = e.data,
        d = Date.now();
      t = {
        id: hh(),
        ownerAddress: i,
        timestamp: d,
        networkID: n,
        type: o,
        display: r,
        data: {
          nonce: Number(c),
          transactions: [
            { hash: a, timestamp: d, unsignedTransaction: s, confirmations: 0, callPayload: l },
          ],
          estimatedTimeToMineInSeconds: u,
        },
      };
      break;
    }
    case ce.Solana.Mainnet:
    case ce.Solana.Testnet:
    case ce.Solana.Devnet:
    case ce.Solana.Localnet: {
      const { networkID: n, display: r, ownerAddress: i, type: o } = e,
        { signature: a } = e.data;
      t = {
        id: hh(),
        timestamp: Date.now(),
        ownerAddress: i,
        networkID: n,
        type: o,
        display: r,
        data: { signature: a },
      };
      break;
    }
    case ce.Sui.Mainnet:
    case ce.Sui.Testnet: {
      const { networkID: n, display: r, ownerAddress: i, type: o, data: a } = e,
        { digest: c } = a;
      t = {
        id: hh(),
        timestamp: Date.now(),
        ownerAddress: i,
        networkID: n,
        type: o,
        display: r,
        data: { digest: c },
      };
      break;
    }
    case ce.Bitcoin.Mainnet:
    case ce.Bitcoin.Testnet: {
      const { networkID: n, display: r, ownerAddress: i, type: o } = e,
        { txID: a, psbtHex: c } = e.data;
      t = {
        id: hh(),
        timestamp: Date.now(),
        ownerAddress: i,
        networkID: n,
        type: o,
        display: r,
        data: { txID: a, psbtHex: c, confirmations: 0 },
      };
      break;
    }
  }
  return t;
}
const ry = async (e, t) => {
    try {
      const n = _M(e);
      await ny(t, async (r) => ((r[n.id] = n), r)), jf(n, t);
    } catch {
      Z.captureMessage('Error adding pending transaction', te.Transaction);
    }
  },
  eG = async (e, t) => {
    const r = (await Ms(t))[e.pendingTransactionId];
    if (r) {
      r.data.transactions.push({
        hash: e.hash,
        timestamp: Date.now(),
        unsignedTransaction: e.unsignedTransaction,
        callPayload: e.callPayload,
        confirmations: 0,
      });
      let i = Et.t('transactionCanceling');
      return (
        r.type === ci.Send && (i = Et.t('transactionCancelingSend')),
        r.type === ci.Cancel && (i = Et.t('transactionPrioritizingCancel')),
        (r.display.summary = {
          topLeft: { text: i },
          topRight: { text: '' },
          bottomLeft: { text: '' },
          bottomRight: { text: '' },
        }),
        (r.type = ci.Cancel),
        await Xo(r, t),
        jf(r, t),
        !0
      );
    } else return !1;
  },
  tG = async (e, t) => {
    const r = (await Ms(t))[e.pendingTransactionId];
    return r
      ? (r.data.transactions.push({
          hash: e.hash,
          timestamp: Date.now(),
          unsignedTransaction: e.unsignedTransaction,
          callPayload: e.callPayload,
          confirmations: 0,
        }),
        await Xo(r, t),
        jf(r, t),
        !0)
      : !1;
  },
  nG = (e, t) =>
    Object.values(e)
      .filter((r) => {
        const i = t.map((a) => a.address.toLowerCase()).includes(r.ownerAddress.toLowerCase()),
          o = rs.get(r.networkID).isPendingTransactionConfirmed(r);
        return i && !o;
      })
      .sort((r, i) => i.timestamp - r.timestamp);
function rG(e, t, n) {
  return e === e && (n !== void 0 && (e = e <= n ? e : n), t !== void 0 && (e = e >= t ? e : t)), e;
}
var iG = rG,
  oG = iG,
  $b = p3;
function aG(e, t, n) {
  return (
    n === void 0 && ((n = t), (t = void 0)),
    n !== void 0 && ((n = $b(n)), (n = n === n ? n : 0)),
    t !== void 0 && ((t = $b(t)), (t = t === t ? t : 0)),
    oG($b(e), t, n)
  );
}
var sG = aG;
const fp = Oc(sG),
  hp = 2e5,
  cG = 500,
  vM = 500,
  SM = 14e5,
  uG = 1.25;
async function AM(e, t) {
  e.signatures;
  const n = await Promise.all(
    e.message.addressTableLookups.map(
      async (i) =>
        new Qw({
          key: i.accountKey,
          state: Qw.deserialize(await t.getAccountInfo(i.accountKey).then((o) => o.data)),
        })
    )
  );
  return {
    txMessage: $0.decompile(e.message, { addressLookupTableAccounts: n }),
    addressLookupTableAccounts: n,
    signatures: e.signatures,
  };
}
function IM(e, t) {
  return e.some((n) =>
    n.programId.toBase58() !== Mc.programId.toBase58() ? !1 : m4.decodeInstructionType(n) === t
  );
}
function K1(e) {
  return IM(e, 'SetComputeUnitLimit');
}
function iS(e) {
  return IM(e, 'SetComputeUnitPrice');
}
const lG = async (e, t) => {
  const { txMessage: n, addressLookupTableAccounts: r, signatures: i } = await AM(t, e);
  if (K1(n.instructions)) return t;
  const o = Mc.setComputeUnitLimit({ units: 14e5 }),
    a = new $0({ ...n, instructions: [o, ...n.instructions] });
  return new xp(a.compileToV0Message(r), i);
};
class H1 {
  constructor(t = hp, n = vM, r = SM) {
    (this.computeUnitsPerInstruction = t),
      (this.minimumComputeUnitLimit = n),
      (this.maximumComputeUnitLimit = r);
  }
  getNumberOfInstructions(t) {
    return t.message.compiledInstructions.length;
  }
  async getBudget(t, n) {
    const i = this.getNumberOfInstructions(n) * this.computeUnitsPerInstruction,
      o = await lG(t, n);
    try {
      const a = await An(
        () => t.simulateTransaction(o, { replaceRecentBlockhash: !0, sigVerify: !1 }),
        (s) =>
          s instanceof Error && s.message.includes('429')
            ? (Z.captureMessage('429 Too Many Requests in getBudget', te.Transaction), !0)
            : !1,
        3,
        1e3
      );
      if (a.value.err || !a.value.unitsConsumed)
        return fp(i, this.minimumComputeUnitLimit, this.maximumComputeUnitLimit);
      const c = a.value.unitsConsumed * uG;
      return fp(c, this.minimumComputeUnitLimit, this.maximumComputeUnitLimit);
    } catch (a) {
      Z.captureError(
        new Error(`Error during simulating transaction to calculate compute limit: ${a}}`),
        te.Transaction
      );
    }
    return i;
  }
}
const dG = new H1(),
  oS = 250,
  fG = 'https://gas-price-oracle.phantom.app/solana_prioritization_fee',
  hG = h.object({ recommendedComputeUnitPriceInMicrolamports: h.number().positive() });
h.object({
  min: h.number().positive(),
  low: h.number().positive(),
  high: h.number().positive(),
  max: h.number().positive(),
});
class pG {
  constructor(t = fG) {
    this.url = t;
  }
  async makeRequest(t) {
    return (await ke.post(this.url, t.body)).data;
  }
  async getPrice(t) {
    t.accounts.length > oS &&
      Z.captureMessage(
        `Transaction had ${t.accounts.length} accounts in the transaction`,
        te.Transaction
      );
    const n = t.accounts.slice(0, oS),
      r = sj.parse({
        accounts: n.map((c) => c.toBase58()),
        chainId: ce.Solana.Mainnet,
        transactionType: t.transactionType,
        computeUnitLimit: t.computeUnitLimit,
      }),
      i = {
        method: 'POST',
        body: JSON.stringify(r),
        headers: { 'Content-Type': 'application/json' },
      },
      o = await this.makeRequest(i),
      { recommendedComputeUnitPriceInMicrolamports: a } = hG.parse(o);
    return a;
  }
}
const EM = new pG(),
  TM = 1170,
  gG = 2,
  yG = 3,
  kM = 64,
  aS = { budget: dG, cost: EM },
  bG = { index: yG, layout: me([et('instruction'), w2('microLamports')]) },
  mG = { index: gG, layout: me([et('instruction'), we('units')]) };
function CM(e) {
  const t = uI(bG, { microLamports: BigInt(e) });
  return new Pc({ keys: [], programId: Mc.programId, data: t });
}
function MM(e) {
  if (e < vM || e > SM) throw new Error('Compute unit fee is too large');
  const t = uI(mG, { units: e });
  return new Pc({ keys: [], programId: Mc.programId, data: t });
}
function PM(e, t, n) {
  return new xp(
    new $0({
      instructions: e,
      payerKey: t || w4.generate().publicKey,
      recentBlockhash: Ye.default.toString(),
    }).compileToV0Message(n)
  );
}
async function wG(e, t, n) {
  const r = new Set();
  for (const f of e.instructions) {
    r.add(f.programId);
    for (const p of f.keys) r.add(p.pubkey);
  }
  const i = rp(e),
    o = PM(i.instructions, i.feePayer),
    a = await n.budget.getBudget(t.connection, o),
    c = await n.cost.getPrice({
      accounts: Array.from(r),
      transactionType: t.transactionType,
      computeUnitLimit: a,
    }),
    s = CM(c),
    l = MM(a);
  if (
    (K1(i.instructions) ? i.instructions.unshift(s) : i.instructions.unshift(s, l),
    i.recentBlockhash && i.feePayer)
  )
    try {
      if (i.serialize({ requireAllSignatures: !1, verifySignatures: !1 }).length >= TM) return e;
    } catch {
      return e;
    }
  return i.instructions.length > kM ? e : i;
}
async function _G(e, t, n, r, i, o) {
  const a = new Set([...e.message.staticAccountKeys]);
  for (const S of i) for (const E of S.state.addresses) a.add(E);
  const c = rp(r),
    s =
      e.message.staticAccountKeys && e.message.staticAccountKeys.length > 0
        ? e.message.staticAccountKeys[0]
        : void 0,
    l = PM(c.instructions, s, i),
    u = await n.budget.getBudget(t.connection, l),
    d = await n.cost.getPrice({
      accounts: Array.from(a),
      transactionType: t.transactionType,
      computeUnitLimit: u,
    }),
    f = CM(d),
    p = MM(u);
  K1(c.instructions) ? c.instructions.unshift(f) : c.instructions.unshift(f, p);
  const b = c.compileToV0Message(i),
    m = new xp(b, o);
  return m.serialize().length >= TM || m.message.compiledInstructions.length > kM ? e : m;
}
async function OM(e, t) {
  var r, i;
  const n = {
    budget: ((r = t.calculators) == null ? void 0 : r.budget) ?? aS.budget,
    cost: ((i = t.calculators) == null ? void 0 : i.cost) ?? aS.cost,
  };
  try {
    if (_2(e)) return e;
    if (dm(e)) {
      const {
        txMessage: o,
        addressLookupTableAccounts: a,
        signatures: c,
      } = await AM(e, t.connection);
      return (await iS(o.instructions)) ? e : await _G(e, t, n, o, a, c);
    } else return iS(e.instructions) ? e : await wG(e, t, n);
  } catch (o) {
    return Z.captureError(o, te.Transaction), e;
  }
}
function vG(e, t, n, r) {
  if (q.isBitcoinNetworkID(e)) {
    const { virtualBytes: i, additionalCosts: o } = n,
      { sats: a, vb: c } = o,
      s = t,
      u = Bf(s.btcPerKilobyte).times(c).plus(a);
    return { networkID: e, virtualBytes: i, btcPerKilobyte: s.btcPerKilobyte, additionalCosts: u };
  } else if (q.isEVMNetworkID(e)) {
    const i = t;
    return {
      networkID: e,
      gasLimit: n.gasLimit,
      maxFeePerGas: i.maxFeePerGas,
      maxPriorityFeePerGas: i.maxPriorityFeePerGas,
      l1Fee: r,
    };
  } else {
    if (q.isSolanaNetworkID(e))
      throw new Error(
        'Solana gas estimations are not constructed from transaction units and transaction unit costs.'
      );
    if (q.isSuiNetworkID(e)) throw new lI('create gas estimation');
    return Sn();
  }
}
const yr = {
    deserializeVersionedTransaction: (e) => {
      let t;
      try {
        t = rn.decode(e);
      } catch {
        t = Y.from(e, 'base64');
      }
      const n = xp.deserialize(t);
      return {
        transaction: n,
        metadata: { numInstructions: n.message.compiledInstructions.length, type: 0 },
      };
    },
    getTransactionClassType(e) {
      return dm(e) ? 'versioned' : 'legacy';
    },
    deserializeWithVersion: (e) => {
      const { transaction: t, type: n } = e;
      let r;
      try {
        r = rn.decode(t);
      } catch {
        r = Y.from(t, 'base64');
      }
      if (n === 'legacy') {
        const i = Bp.from(r);
        return { transaction: i, metadata: { numInstructions: i.instructions.length, type: n } };
      } else {
        if (n === 0) return yr.deserializeVersionedTransaction(t);
        throw new Error(`Unknown transaction type => ${n}`);
      }
    },
    deserializeWithMessage(e) {
      const { transaction: t, message: n } = e,
        r = rn.decode(n),
        i = jp.deserializeMessageVersion(r);
      return yr.deserializeWithVersion({ transaction: t, type: i });
    },
    serialize(e) {
      if (dm(e)) {
        const t = rn.encode(e.serialize()),
          n = rn.encode(e.message.serialize());
        return { transaction: t, message: n };
      } else {
        const t = rn.encode(e.serialize({ requireAllSignatures: !1, verifySignatures: !0 })),
          n = rn.encode(e.serializeMessage());
        return { transaction: t, message: n };
      }
    },
  },
  SG = ({ networkID: e, address: t }) => ({ chainId: e, address: t }),
  AG = 3;
Ki.extend(dI);
const IG = (e) =>
    h
      .array(h.unknown())
      .transform((t) => (t == null ? void 0 : t.filter((n) => e.safeParse(n).success))),
  EG = h.object({
    chainId: Pp,
    transaction: h.object({ txID: h.string() }),
    submittedAt: h.string().datetime(),
    utxos: h.array(h.object({ address: h.string() })),
  }),
  TG = h.object({ transactions: IG(EG) }),
  kG = '/pending-transactions/v1';
async function CG(e, t) {
  if (e.length === 0) return [];
  const n = await ke
    .api()
    .post(kG, {
      addresses: e.map((i) => ({
        chainId: i.networkID,
        address: q.isEVMNetworkID(i.networkID) ? i.address.toLowerCase() : i.address,
        resourceType: 'address',
      })),
    });
  if (n.status !== 200)
    return (
      n.status >= 400 &&
        n.status < 500 &&
        Z.captureError(
          new Error('Failed to fetch pending transactions, error code: ' + n.status),
          te.History
        ),
      []
    );
  const r = TG.safeParse(n.data);
  return r.success
    ? (
        await Promise.all(
          r.data.transactions
            .filter((i) => (i.submittedAt ? Ki(t()).diff(Ki(i.submittedAt), 'hours') < AG : !1))
            .map(async (i) => {
              if (i.chainId === Yh.Mainnet || i.chainId === Yh.Testnet) {
                const o = e.filter((l) => l.networkID === i.chainId).map((l) => l.address),
                  a = i.utxos.map((l) => l.address),
                  c = o.find((l) => a.includes(l));
                return c
                  ? {
                      ownerAddress: c,
                      networkID: i.chainId,
                      data: {
                        txID: i.transaction.txID,
                        psbtHex: Y.from(
                          R4.fromRaw(
                            Y.from(
                              (await Cs(i.chainId).getRawTransaction(i.transaction.txID)).hex ?? '',
                              'hex'
                            )
                          ).toPSBT()
                        ).toString('hex'),
                      },
                      type: ci.DappInteraction,
                      display: {
                        summary: {
                          topLeft: { text: Et.t('transactionsPendingBitcoinTransaction') },
                        },
                      },
                    }
                  : void 0;
              }
            })
        )
      ).filter((i) => i !== void 0)
    : (Z.captureError(new Error('Failed to parse pending transactions'), te.History), []);
}
const MG = (e, t) => {
  const n = e.networkID;
  return n !== t.networkID || !n ? !1 : rs.get(n).isPendingTransactionsEqual(e, t);
};
async function PG(e, t, n = () => new Date()) {
  let r = 0;
  try {
    const i = await CG(e, n);
    for (const o of i) r += await Gq(o, MG, t);
  } catch (i) {
    Z.captureError(
      new Error('encountered error adding pending transaction: ' + i.message),
      te.History
    );
  }
  return r;
}
function OG(e, t) {
  return {
    type: 'text',
    content: Y.from(`{"p":"brc-20","op":"transfer","tick":"${e}","amt":"${t.toString()}"}`),
  };
}
function DG(e, t) {
  const n = Zt.script.OPS;
  switch ((e.push(Y.from('ord')), e.push(n.OP_1), t.type)) {
    case 'text': {
      RG(e, t);
      break;
    }
    default:
      throw new Error(`Unsupported inscription type: ${JSON.stringify(t)}`);
  }
}
function RG(e, t) {
  const n = Zt.script.OPS;
  e.push(Y.from('text/plain;charset=utf-8')), e.push(n.OP_0);
  const r = 520,
    i = t.content,
    o = i.length;
  for (let a = 0; a < o; a += r) {
    let c = a + r;
    c > o && (c = o), e.push(i.slice(a, c));
  }
}
function xG(e, t) {
  const n = Zt.script.OPS,
    r = [];
  r.push(e), r.push(n.OP_CHECKSIG), BG(r, t);
  const i = Zt.script.compile(r);
  return jG(i);
}
function BG(e, t) {
  const n = Zt.script.OPS;
  e.push(n.OP_FALSE), e.push(n.OP_IF), DG(e, t), e.push(n.OP_ENDIF);
}
function jG(e) {
  return Y.from(e.toString('hex').replace('6f726451', '6f72640101'), 'hex');
}
const q1 = (e) => V1[e].perInput,
  xh = (e) => V1[e].perOutput,
  NG = (e) => V1[e].header,
  DM = (e, t, n) =>
    NG(e) + t * q1(e) + Xs(n.map((r) => ({ value: xh(br(ce.Bitcoin.Mainnet, r.address)) })));
function Xs(e) {
  return e.reduce((t, n) => t + (typeof n.value == 'string' ? parseFloat(n.value) : n.value), 0);
}
function UG(e, t, n, r) {
  let i = DM(e, t.length, n);
  const o = r * (i + xh(e)),
    a = Xs(t) - (Xs(n) + o),
    c = r * xh(e),
    s = tq[e];
  a > s && a > c && ((n = n.concat({ value: Math.ceil(a), address: t[0].owner })), (i += xh(e)));
  const l = Xs(t) - Xs(n);
  return { type: 'success', inputs: t, outputs: n, vb: i, fee: l };
}
function LG(e, t, n, r, i) {
  const o = q1(e),
    a = i * o,
    c = r.reduce((p, y) => p + y.value, 0);
  let s = DM(e, n.length, r),
    l = Zh(n.map((p) => parseFloat(p.value)));
  const u = [];
  for (let p = 0; p < t.length; p++) {
    const y = t[p],
      b = parseFloat(y.value);
    if (a > b) {
      if (p === t.length - 1) {
        const w = i * s;
        return { type: 'error', maxAmount: l - w, vb: s };
      }
      continue;
    }
    (s += o), (l += b), u.push(y);
    const m = i * s;
    if (l >= c + m) return UG(e, n.concat(u), r, i);
  }
  const d = i * s;
  return { type: 'error', maxAmount: l - d, vb: s };
}
function G1(e, t, n, r, i = []) {
  const a = zG(e, t, r).filter(
    (c) => !i.some((s) => s.transactionHash === c.transactionHash && s.index === c.index)
  );
  return LG(e, a, i, n, r);
}
function sS(e, t, n) {
  return parseFloat(t.value) - n * q1(e);
}
function zG(e, t, n) {
  return t.concat().sort((r, i) => sS(e, i, n) - sS(e, r, n));
}
var ac = ((e) => (
  (e.UnconfirmedOutput = 'UnconfirmedOutput'), (e.UnconfirmedInput = 'UnconfirmedInput'), e
))(ac || {});
const FG = h.object({ transactionHash: h.string(), index: h.number() }),
  $G = h.object({ id: h.string() });
FG.extend({
  value: h.string(),
  owner: h.string(),
  inscription: h.optional($G),
  isSafeToSend: h.boolean(),
});
var oi = ((e) => (
  (e.AddUtxo = 'AddUtxo'),
  (e.UpsertMeta = 'UpsertMeta'),
  (e.RemoveMeta = 'RemoveMeta'),
  (e.ReplaceUtxo = 'ReplaceUtxo'),
  e
))(oi || {});
const WG = h.object({
    value: h.string(),
    transactionHash: h.string(),
    index: h.string(),
    inscriptionId: h.string().nullish(),
    isSafeToSend: h.boolean(),
  }),
  VG = h.object({ utxos: h.array(WG) });
function Bh(e, t) {
  return e.transactionHash === t.transactionHash && e.index === t.index;
}
function KG(e) {
  const t = fM(e);
  return e.txInputs.map((n, r) => {
    if (typeof n.hash == 'string') throw new Error('Expected hash to be a Buffer');
    return {
      type: ac.UnconfirmedInput,
      unconfirmedTransactionHash: t,
      unconfirmedTransactionIndex: r,
      id: { index: n.index, transactionHash: HG(n.hash) },
    };
  });
}
function HG(e) {
  return Y.from(e).reverse().toString('hex');
}
function qG(e) {
  return Y.from(e, 'hex').reverse();
}
function GG(e) {
  const t = fM(e);
  return e.txOutputs.map((n, r) => ({
    transactionHash: t,
    index: r,
    value: n.value.toString(),
    owner: n.address ?? '',
    inscription: void 0,
    isSafeToSend: !1,
  }));
}
function RM(e, t, n = !0) {
  return {
    hash: qG(e.transactionHash),
    index: e.index,
    witnessUtxo: { script: SI(t), value: parseInt(e.value) },
    sequence: n ? JH : XH,
  };
}
const YG = 'utxos.v1',
  ZG = 'utxo_metadata.v1';
class QG {
  constructor(t) {
    Le(this, '_storage');
    this._storage = t;
  }
  getUtxoStorageKey(t) {
    return `${YG}.${t}`;
  }
  getMetadataStorageKey(t) {
    return `${ZG}.${t}`;
  }
  async getUtxos(t) {
    try {
      const n = await this._storage.get(this.getUtxoStorageKey(t));
      return n || [];
    } catch {
      return this.reset(t), [];
    }
  }
  async getMetadata(t) {
    try {
      const n = await this._storage.get(this.getMetadataStorageKey(t));
      return n || [];
    } catch {
      return this.reset(t), [];
    }
  }
  async getSafeToSendUtxos(t) {
    return (await this.getUtxos(t)).filter((r) => r.isSafeToSend);
  }
  async getInscribedUtxos(t) {
    return this.getUtxos(t).then((n) => n.filter((r) => r.inscription));
  }
  async getRareSatsUtxos(t) {
    return this.getUtxos(t).then((n) => n.filter((r) => !r.inscription && !r.isSafeToSend));
  }
  async apply(t, n) {
    let [r, i] = await Promise.all([this.getUtxos(t), this.getMetadata(t)]);
    for (const o of n)
      switch (o.type) {
        case oi.UpsertMeta:
          i = this.upsertMetadata(o, i);
          break;
        case oi.RemoveMeta:
          i = this.removeMetadata(o, i);
          break;
        case oi.AddUtxo:
          r = this.addUtxos(o, r);
          break;
        case oi.ReplaceUtxo:
          r = this.replaceUtxo(o, r);
          break;
      }
    return (
      await Promise.all([
        this._storage.set(this.getUtxoStorageKey(t), r),
        this._storage.set(this.getMetadataStorageKey(t), i),
      ]),
      r
    );
  }
  replaceUtxo(t, n) {
    return t.utxos;
  }
  removeMetadata(t, n) {
    return n.filter((r) => !t.metasToRemove.some((i) => Bh(i, r.id)));
  }
  upsertMetadata(t, n) {
    for (const r of t.metas) {
      const i = n.findIndex((o) => Bh(o.id, r.id) && o.type === r.type);
      i !== -1 ? (n[i] = r) : n.push(r);
    }
    return n;
  }
  addUtxos(t, n) {
    for (const r of t.utxos) n.some((o) => Bh(o, r)) || n.push(r);
    return n;
  }
  async reset(t) {
    return Promise.all([
      this._storage.remove(this.getUtxoStorageKey(t)),
      this._storage.remove(this.getMetadataStorageKey(t)),
    ]);
  }
}
const cS = new Error('Failed to get utxos for addresses'),
  JG = (e) => {
    async function t(c) {
      const s = dM(c),
        l = KG(c),
        u = GG(c).filter((p) => p.owner === s),
        d = u.map((p) => ({
          type: ac.UnconfirmedOutput,
          id: { transactionHash: p.transactionHash, index: p.index },
        })),
        f = [
          { type: oi.UpsertMeta, metas: [...l, ...d] },
          { type: oi.AddUtxo, utxos: u },
        ];
      return e.apply(s, f);
    }
    async function n(c) {
      const s = { address: c.address, chainId: c.networkID, resourceType: sn.address };
      try {
        const l = await ke.api().post('/bitcoin/v1/spendable-utxos', { address: s });
        if (l.status !== 200) throw cS;
        const u = VG.parse(l.data),
          d = u.utxos
            .map((f) => ({
              index: parseFloat(f.index),
              owner: c.address,
              transactionHash: f.transactionHash,
              value: f.value,
              inscription: f.inscriptionId ? { id: f.inscriptionId } : void 0,
              isSafeToSend: f.isSafeToSend,
            }))
            .sort((f, p) => new oe(p.value).comparedTo(new oe(f.value)));
        return await r(d), u.utxos;
      } catch {
        throw cS;
      }
    }
    async function r(c) {
      if (c.length === 0) return [];
      const s = c[0].owner,
        u = (await e.getMetadata(s)).reduce((d, f) => {
          const p = c.some((y) => Bh(y, f.id));
          return (
            ((f.type === ac.UnconfirmedOutput && p) || (f.type === ac.UnconfirmedInput && !p)) &&
              d.push(f.id),
            d
          );
        }, []);
      return e.apply(s, [
        { type: oi.RemoveMeta, metasToRemove: u },
        { type: oi.ReplaceUtxo, utxos: c },
      ]);
    }
    async function i(c) {
      return e.getSafeToSendUtxos(c);
    }
    async function o(c) {
      return e.getInscribedUtxos(c);
    }
    async function a(c) {
      return e.getRareSatsUtxos(c);
    }
    return {
      notifyPendingTransaction: t,
      refetchUtxos: n,
      getSafeToSendUtxos: i,
      getInscribedUtxos: o,
      getRareSatsUtxos: a,
    };
  };
h.union([h.literal('UNSET'), h.literal('ECONOMICAL'), h.literal('CONSERVATIVE')]);
class XG extends Error {}
class eY extends XG {
  constructor({ successfulTxIds: n, message: r }) {
    super();
    Le(this, 'successfulTxIds');
    const i = `Multi-transaction broadcast failed. The following transactions ids were successfully broadcast: ${n}`;
    (this.message = i + (r ? `: ${r}` : '.')), (this.successfulTxIds = n);
  }
}
const xM = (e, t, n, r, i = Te.Info, o = { minStatusCode: 400, maxStatusCode: 500 }) => {
    (!t || (t >= o.minStatusCode && t < o.maxStatusCode)) &&
      (Z.addBreadcrumb(n, e.message, i, r), Z.captureError(e, te.Transaction));
  },
  tY = 5,
  nY = ae({ seconds: 2 }),
  Jue = async (e) => {
    const {
        inputsToSign: t,
        accountSigner: n,
        accountIdentifier: r,
        psbt: i,
        psbtChain: o,
        pendingTransactionInput: a,
        storage: c,
      } = e,
      s = [],
      l = nq(i);
    let u = i;
    const d = await lS({
      accountSigner: n,
      accountIdentifier: r,
      addressType: l,
      psbt: i,
      inputsToSign: t,
    });
    if ((s.push({ signedPsbt: d, metadata: void 0 }), o))
      for (const { psbtFn: p, inputsToSign: y, metadata: b } of o) {
        const m = uS(s[s.length - 1].signedPsbt),
          w = p(m);
        u = w;
        const _ = await lS({
          accountSigner: n,
          accountIdentifier: r,
          addressType: l,
          psbt: w,
          inputsToSign: y,
        });
        s.push({ signedPsbt: _, metadata: b });
      }
    const f = [];
    for (const { signedPsbt: p, metadata: y } of s)
      try {
        const b = p.extractTransaction(),
          m = b.toHex(),
          w = b.getId();
        await An(
          () => Cs(a.networkID).sendRawTransaction(m),
          () => !0,
          tY,
          nY
        ),
          f.push(w);
      } catch (b) {
        if (Np(b) && (iY(b, y), b.response && b.response.status >= 500 && b.response.status < 600))
          throw new eY({ successfulTxIds: f, message: b.message });
      }
    if (f.length === s.length) {
      const { signedPsbt: p } = s[s.length - 1],
        y = uS(p);
      return rY(a, c, y, u.toHex()), y;
    } else
      throw new Error(`Unable to broadcast all signed transactions. 
      Successful transactions: ${f.join(', ')}, Transaction count: ${s.length}`);
  };
function uS(e) {
  return e.extractTransaction().getId();
}
async function lS({
  accountSigner: e,
  accountIdentifier: t,
  addressType: n,
  psbt: r,
  inputsToSign: i,
}) {
  const o = await e.sign(t, {
    chainType: n,
    signingType: 'transaction',
    message: r.toHex(),
    inputsToSign: i,
    finalize: !0,
  });
  if (o.status === 'error') throw new Error(o.message);
  const a = o.signature;
  return Zt.Psbt.fromHex(a, { network: Zt.networks.bitcoin });
}
async function rY(e, t, n, r) {
  (e.data.txID = n), (e.data.psbtHex = r), await ry(e, t);
}
function iY(e, t) {
  var r, i;
  const n = (r = e.response) == null ? void 0 : r.status;
  n &&
    xM(
      e,
      n,
      te.Transaction,
      { metadata: t ?? null, message: (i = e.response) == null ? void 0 : i.data },
      Te.Error,
      { minStatusCode: 400, maxStatusCode: 600 }
    );
}
const BM = async (e, t, n) => {
    let r = '0x0';
    try {
      const c = await Ms(n),
        s = Object.values(c)
          .filter((l) => l.networkID === e && l.ownerAddress === t)
          .sort((l, u) => u.timestamp - l.timestamp);
      s.length && (r = `0x${(s[0].data.nonce + 1).toString(16)}`);
    } catch {}
    let i = 0,
      o = 'Error getting transaction count',
      a = '';
    for (; i < 3 && !a; ) {
      try {
        const c = Nc(e),
          s = await $o.eth_getTransactionCount(c, [t, 'latest']);
        'error' in s ? (o = `[${s.error.code}] ${s.error.message}`) : (a = s.result);
      } catch {}
      ++i, await new Promise((c) => setTimeout(c, 200));
    }
    if (!a) {
      const c = new Error(o);
      throw (Z.captureMessage(o, te.Transaction), c);
    }
    return Number(r) > Number(a) ? r : a;
  },
  oY = h
    .string()
    .refine((e) => typeof e == 'string' && e.match(/^0x[0-9A-Fa-f]*$/), {
      message: 'Value is not a valid hex string.',
    }),
  aY = (e) => {
    if (oY.safeParse(e).success) {
      if (parseInt(e, 16) === 0) return '0x0';
      const n = e.replace('0x', '');
      let r = 0;
      for (; r < n.length && n[r] === '0'; ) r++;
      return '0x' + n.substring(r);
    } else throw new Error('string is not in hex encoding.');
  },
  jM = (e) => aY('0x' + e.toString(16));
jM(new oe('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'));
h.object({
  domain: h.object({
    chainId: h.number(),
    name: h.string(),
    verifyingContract: h.string(),
    version: h.string(),
  }),
  message: h.object({
    expiry: h.number(),
    nonce: h.number(),
    spender: h.string(),
    holder: h.string(),
    allowed: h.boolean(),
  }),
  primaryType: h.literal('Permit'),
  types: h.object({
    EIP712Domain: h.array(h.object({ name: h.string(), type: h.string() })),
    Permit: h.array(h.object({ name: h.string(), type: h.string() })),
  }),
});
h.object({
  domain: h.object({
    chainId: h.number(),
    name: h.string(),
    verifyingContract: h.string(),
    version: h.string(),
  }),
  message: h.object({
    deadline: h.number(),
    nonce: h.number(),
    spender: h.string(),
    holder: h.string(),
    value: h.number(),
  }),
  primaryType: h.literal('Permit'),
  types: h.object({
    EIP712Domain: h.array(h.object({ name: h.string(), type: h.string() })),
    Permit: h.array(h.object({ name: h.string(), type: h.string() })),
  }),
});
h.object({
  domain: h.object({
    chainId: h.string(),
    name: h.literal('Permit2'),
    verifyingContract: h.string(),
  }),
  message: h.object({
    details: h.object({
      token: h.string(),
      amount: h.string(),
      expiration: h.string(),
      nonce: h.string(),
    }),
    spender: h.string(),
    sigDeadline: h.string(),
  }),
  primaryType: h.literal('PermitSingle'),
  types: h.object({
    EIP712Domain: h.array(h.object({ name: h.string(), type: h.string() })),
    PermitSingle: h.array(h.object({ name: h.string(), type: h.string() })),
    PermitDetails: h.array(h.object({ name: h.string(), type: h.string() })),
  }),
});
h.object({
  domain: h.object({
    chainId: h.string(),
    name: h.literal('Permit2'),
    verifyingContract: h.string(),
  }),
  message: h.object({
    details: h.array(
      h.object({ token: h.string(), amount: h.string(), expiration: h.string(), nonce: h.string() })
    ),
    spender: h.string(),
    sigDeadline: h.string(),
  }),
  primaryType: h.literal('PermitBatch'),
  types: h.object({
    EIP712Domain: h.array(h.object({ name: h.string(), type: h.string() })),
    PermitBatch: h.array(h.object({ name: h.string(), type: h.string() })),
    PermitDetails: h.array(h.object({ name: h.string(), type: h.string() })),
  }),
});
const sY = h.object({
    results: h.array(
      h.object({
        id: h.string(),
        interactionData: h.object({
          dapp: h.union([h.null(), h.object({ displayName: h.string(), logoURI: h.string() })]),
        }),
      })
    ),
  }),
  cY = async (e) => {
    const t = {
        transactions: [
          {
            type: 'EvmType2',
            data: {
              type: 2,
              ...e,
              gasLimit: new oe(e.gasLimit).toString(),
              maxPriorityFeePerGas: new oe(e.maxPriorityFeePerGas).toString(),
              maxFeePerGas: new oe(e.maxFeePerGas).toString(),
              chainId: parseInt(e.networkID.split(':')[1], 10),
              value: e.value ? new oe(e.value).toString() : '0',
            },
          },
        ],
      },
      n = await ke.api().retry(3, 2e3).post('/transaction_input_parser/v1', t);
    if (n.status >= 300) throw new Error(`getPendingTransactionDapp: Status code: ${n.status}`);
    const r = n.data;
    try {
      return sY.parse(r).results[0].interactionData.dapp;
    } catch (i) {
      throw (
        (Z.captureMessage('getPendingTransactionDapp response is malformed', te.Transaction), i)
      );
    }
  },
  NM = async (e, t, n) => {
    let r = n.nonce,
      i = n;
    return r || ((r = await BM(e, n.from, t)), (i = Tc.parse({ ...n, nonce: r }))), i;
  },
  UM = async ({
    networkID: e,
    unsignedTransaction: t,
    callPayload: n,
    pendingTransactionInput: r,
    storage: i,
    signature: o,
  }) => {
    var d, f;
    const c = (await NM(e, i, t)).nonce;
    if (!c) throw new Error('Nonce is undefined when sending an EVM transaction.');
    n && (n = v2.parse({ ...n, nonce: c }));
    const s = Nc(e);
    if (n) {
      const p = await $o.eth_call(s, [n, 'latest']);
      if ('error' in p)
        throw new Error(`eth_call failed to simulate transaction. Reason: ${p.error.message}`);
    }
    const l = ey(t, o),
      u = await An(
        () => $o.eth_sendRawTransaction(s, [l]),
        (p) => {
          if (typeof p == 'object' && 'body' in p)
            try {
              if (JSON.parse(p.body).error.message.includes('transaction underpriced')) return !1;
            } catch {}
          return !0;
        }
      );
    if ('error' in u) throw new Error(`Failed to send transaction. Reason: ${u.error.message}`);
    {
      const p = u.result;
      if ('data' in r) {
        let y;
        try {
          r.type === ci.DappInteraction &&
            (y = await cY({
              networkID: e,
              value: t.value,
              gasLimit: t.gas || '',
              maxPriorityFeePerGas: t.maxPriorityFeePerGas || '',
              maxFeePerGas: t.maxFeePerGas || '',
              data: t.data || '',
              to: t.to || '',
              from: t.from,
              hash: p,
            }));
        } catch {}
        y &&
          ((r.display.summary.logoUri = y.logoURI),
          (r.display.summary.bottomLeft = { text: y.displayName }),
          r.display.detail &&
            ((r.display.detail.logoUri = y.logoURI),
            (r.display.detail.secondaryHeader = y.displayName))),
          (r.data.hash = p),
          (r.data.unsignedTransaction = t),
          (r.data.callPayload = n),
          (r.data.nonce = c),
          await ry(r, i);
      } else
        (r.hash = p),
          (r.unsignedTransaction = t),
          (r.callPayload = n),
          ((d = t.to) == null ? void 0 : d.toLowerCase()) ===
            ((f = n == null ? void 0 : n.from) == null ? void 0 : f.toLowerCase()) &&
          t.value !== void 0 &&
          parseInt(t.value, 16) === 0
            ? await eG(r, i)
            : await tG(r, i);
      return p;
    }
  },
  uY = async (e) => {
    const {
        networkID: t,
        storage: n,
        accountSigner: r,
        accountIdentifier: i,
        unsignedTransaction: o,
      } = e,
      a = await NM(t, n, o),
      c = await r.sign(i, { chainType: X.EVM, signingType: 'transaction', message: ey(a) });
    if (c.status === 'error') throw new Error(c.message);
    return UM({ ...e, unsignedTransaction: a, signature: c.signature });
  },
  dS = BigInt('2000'),
  lY = 5e10,
  dY = BigInt(1e3),
  fY = 1.2,
  hY = async ({ networkID: e, transaction: t }) => {
    const n = ks(e),
      r = gY(),
      i = fs.from(t);
    if (!i.getData().sender)
      throw new Error(
        `Transaction does not yet have a sender set: ${i.getData()}. Cannot dry run transaction.`
      );
    i.setGasBudgetIfNotSet(lY), i.setGasPayment([]);
    const o = await i.build({ client: n }),
      { effects: a } = await n.dryRunTransactionBlock({ transactionBlock: o }),
      c = a.gasUsed,
      s = pY(c),
      l = s > dS ? s : dS,
      u = BigInt(Math.ceil(Number(l) * r));
    return { networkID: e, gasBudget: oe(u.toString()) };
  },
  pY = ({ computationCost: e, storageCost: t, storageRebate: n }) => {
    const r = BigInt(e) + dY,
      i = r + BigInt(t) - BigInt(n);
    return i > r ? i : r;
  };
function gY() {
  const e = Un.getMultivariateAssignment('sui-gas-budget-multiplier'),
    t = e ? parseFloat(e) : NaN;
  return Number.isFinite(t) ? t : fY;
}
const yY = async ({ transaction: e, signature: t, pendingTransactionInput: n, storage: r }) => {
    const i = ks(n.networkID),
      { digest: o, rawEffects: a } = await An(
        () =>
          i.executeTransactionBlock({
            transactionBlock: e,
            signature: t,
            requestType: 'WaitForLocalExecution',
            options: { showRawEffects: !0, showEffects: !0 },
          }),
        () => !0
      );
    return (
      (n.data.digest = o),
      ry(n, r),
      { digest: o, effects: a ? Y.from(new Uint8Array(a)).toString('base64') : '' }
    );
  },
  bY = async (e) => {
    const { accountSigner: t, accountIdentifier: n, transaction: r } = e,
      i = { chainType: X.Sui, signingType: 'transaction', transaction: new Uint8Array(r) },
      o = await t.sign(n, i);
    if (o.status === 'error') throw new Error(o.message);
    return { signature: o.signature };
  },
  mY = async (e) => {
    const {
        accountSigner: t,
        accountIdentifier: n,
        transaction: r,
        pendingTransactionInput: i,
        storage: o,
      } = e,
      { signature: a } = await bY({ accountSigner: t, accountIdentifier: n, transaction: r }),
      c = await yY({ transaction: r, signature: a, pendingTransactionInput: i, storage: o });
    return { signature: a, digest: c.digest, effects: c.effects };
  },
  wY = 3,
  _Y = 1e3,
  vY = (e) => !0,
  SY = async (e, t) => {
    const n = ks(t);
    return An(() => e.build({ client: n }), vY, wY, _Y);
  },
  LM = async (e, t = { fallbackToProvider: !0 }) => {
    const { networkID: n, transaction: r, address: i } = e,
      o = fs.from(r);
    i && o.setSenderIfNotSet(i);
    try {
      return await o.build();
    } catch (a) {
      if (!t.fallbackToProvider) throw a;
      try {
        return await SY(o, n);
      } catch (c) {
        throw new Error(
          `Failed to build Sui transaction: ${c instanceof Error ? c.message : 'Unknown error'}`
        );
      }
    }
  };
/**
 * Support for translating between Buffer instances and JavaScript
 * native types.
 *
 * {@link module:Layout~Layout|Layout} is the basis of a class
 * hierarchy that associates property names with sequences of encoded
 * bytes.
 *
 * Layouts are supported for these scalar (numeric) types:
 * * {@link module:Layout~UInt|Unsigned integers in little-endian
 *   format} with {@link module:Layout.u8|8-bit}, {@link
 *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},
 *   {@link module:Layout.u32|32-bit}, {@link
 *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}
 *   representation ranges;
 * * {@link module:Layout~UIntBE|Unsigned integers in big-endian
 *   format} with {@link module:Layout.u16be|16-bit}, {@link
 *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},
 *   {@link module:Layout.u40be|40-bit}, and {@link
 *   module:Layout.u48be|48-bit} representation ranges;
 * * {@link module:Layout~Int|Signed integers in little-endian
 *   format} with {@link module:Layout.s8|8-bit}, {@link
 *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},
 *   {@link module:Layout.s32|32-bit}, {@link
 *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}
 *   representation ranges;
 * * {@link module:Layout~IntBE|Signed integers in big-endian format}
 *   with {@link module:Layout.s16be|16-bit}, {@link
 *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},
 *   {@link module:Layout.s40be|40-bit}, and {@link
 *   module:Layout.s48be|48-bit} representation ranges;
 * * 64-bit integral values that decode to an exact (if magnitude is
 *   less than 2^53) or nearby integral Number in {@link
 *   module:Layout.nu64|unsigned little-endian}, {@link
 *   module:Layout.nu64be|unsigned big-endian}, {@link
 *   module:Layout.ns64|signed little-endian}, and {@link
 *   module:Layout.ns64be|unsigned big-endian} encodings;
 * * 32-bit floating point values with {@link
 *   module:Layout.f32|little-endian} and {@link
 *   module:Layout.f32be|big-endian} representations;
 * * 64-bit floating point values with {@link
 *   module:Layout.f64|little-endian} and {@link
 *   module:Layout.f64be|big-endian} representations;
 * * {@link module:Layout.const|Constants} that take no space in the
 *   encoded expression.
 *
 * and for these aggregate types:
 * * {@link module:Layout.seq|Sequence}s of instances of a {@link
 *   module:Layout~Layout|Layout}, with JavaScript representation as
 *   an Array and constant or data-dependent {@link
 *   module:Layout~Sequence#count|length};
 * * {@link module:Layout.struct|Structure}s that aggregate a
 *   heterogeneous sequence of {@link module:Layout~Layout|Layout}
 *   instances, with JavaScript representation as an Object;
 * * {@link module:Layout.union|Union}s that support multiple {@link
 *   module:Layout~VariantLayout|variant layouts} over a fixed
 *   (padded) or variable (not padded) span of bytes, using an
 *   unsigned integer at the start of the data or a separate {@link
 *   module:Layout.unionLayoutDiscriminator|layout element} to
 *   determine which layout to use when interpreting the buffer
 *   contents;
 * * {@link module:Layout.bits|BitStructure}s that contain a sequence
 *   of individual {@link
 *   module:Layout~BitStructure#addField|BitField}s packed into an 8,
 *   16, 24, or 32-bit unsigned integer starting at the least- or
 *   most-significant bit;
 * * {@link module:Layout.cstr|C strings} of varying length;
 * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link
 *   module:Layout~Blob#length|length} raw data.
 *
 * All {@link module:Layout~Layout|Layout} instances are immutable
 * after construction, to prevent internal state from becoming
 * inconsistent.
 *
 * @local Layout
 * @local ExternalLayout
 * @local GreedyCount
 * @local OffsetLayout
 * @local UInt
 * @local UIntBE
 * @local Int
 * @local IntBE
 * @local NearUInt64
 * @local NearUInt64BE
 * @local NearInt64
 * @local NearInt64BE
 * @local Float
 * @local FloatBE
 * @local Double
 * @local DoubleBE
 * @local Sequence
 * @local Structure
 * @local UnionDiscriminator
 * @local UnionLayoutDiscriminator
 * @local Union
 * @local VariantLayout
 * @local BitStructure
 * @local BitField
 * @local Boolean
 * @local Blob
 * @local CString
 * @local Constant
 * @local bindConstructorLayout
 * @module Layout
 * @license MIT
 * @author Peter A. Bigot
 * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}
 */ class is {
  constructor(t, n) {
    if (!Number.isInteger(t)) throw new TypeError('span must be an integer');
    (this.span = t), (this.property = n);
  }
  makeDestinationObject() {
    return {};
  }
  decode(t, n) {
    throw new Error('Layout is abstract');
  }
  encode(t, n, r) {
    throw new Error('Layout is abstract');
  }
  getSpan(t, n) {
    if (0 > this.span) throw new RangeError('indeterminate span');
    return this.span;
  }
  replicate(t) {
    const n = Object.create(this.constructor.prototype);
    return Object.assign(n, this), (n.property = t), n;
  }
  fromArray(t) {}
}
function AY(e, t) {
  return t.property ? e + '[' + t.property + ']' : e;
}
class ph extends is {
  isCount() {
    throw new Error('ExternalLayout is abstract');
  }
}
class IY extends is {
  constructor(t, n) {
    if ((super(t, n), 6 < this.span)) throw new RangeError('span must not exceed 6 bytes');
  }
  decode(t, n) {
    return n === void 0 && (n = 0), t.readUIntLE(n, this.span);
  }
  encode(t, n, r) {
    return r === void 0 && (r = 0), n.writeUIntLE(t, r, this.span), this.span;
  }
}
const o0 = Math.pow(2, 32);
function EY(e) {
  const t = Math.floor(e / o0),
    n = e - t * o0;
  return { hi32: t, lo32: n };
}
function TY(e, t) {
  return e * o0 + t;
}
class kY extends is {
  constructor(t) {
    super(8, t);
  }
  decode(t, n) {
    n === void 0 && (n = 0);
    const r = t.readUInt32LE(n),
      i = t.readUInt32LE(n + 4);
    return TY(i, r);
  }
  encode(t, n, r) {
    r === void 0 && (r = 0);
    const i = EY(t);
    return n.writeUInt32LE(i.lo32, r), n.writeUInt32LE(i.hi32, r + 4), 8;
  }
}
class CY extends is {
  constructor(t, n, r) {
    if (!(Array.isArray(t) && t.reduce((o, a) => o && a instanceof is, !0)))
      throw new TypeError('fields must be array of Layout instances');
    typeof n == 'boolean' && r === void 0 && ((r = n), (n = void 0));
    for (const o of t)
      if (0 > o.span && o.property === void 0)
        throw new Error('fields cannot contain unnamed variable-length layout');
    let i = -1;
    try {
      i = t.reduce((o, a) => o + a.getSpan(), 0);
    } catch {}
    super(i, n), (this.fields = t), (this.decodePrefixes = !!r);
  }
  getSpan(t, n) {
    if (0 <= this.span) return this.span;
    n === void 0 && (n = 0);
    let r = 0;
    try {
      r = this.fields.reduce((i, o) => {
        const a = o.getSpan(t, n);
        return (n += a), i + a;
      }, 0);
    } catch {
      throw new RangeError('indeterminate span');
    }
    return r;
  }
  decode(t, n) {
    n === void 0 && (n = 0);
    const r = this.makeDestinationObject();
    for (const i of this.fields)
      if (
        (i.property !== void 0 && (r[i.property] = i.decode(t, n)),
        (n += i.getSpan(t, n)),
        this.decodePrefixes && t.length === n)
      )
        break;
    return r;
  }
  encode(t, n, r) {
    r === void 0 && (r = 0);
    const i = r;
    let o = 0,
      a = 0;
    for (const c of this.fields) {
      let s = c.span;
      if (((a = 0 < s ? s : 0), c.property !== void 0)) {
        const l = t[c.property];
        l !== void 0 && ((a = c.encode(l, n, r)), 0 > s && (s = c.getSpan(n, r)));
      }
      (o = r), (r += s);
    }
    return o + a - i;
  }
  fromArray(t) {
    const n = this.makeDestinationObject();
    for (const r of this.fields)
      r.property !== void 0 && 0 < t.length && (n[r.property] = t.shift());
    return n;
  }
  layoutFor(t) {
    if (typeof t != 'string') throw new TypeError('property must be string');
    for (const n of this.fields) if (n.property === t) return n;
  }
  offsetOf(t) {
    if (typeof t != 'string') throw new TypeError('property must be string');
    let n = 0;
    for (const r of this.fields) {
      if (r.property === t) return n;
      0 > r.span ? (n = -1) : 0 <= n && (n += r.span);
    }
  }
}
let zM = class extends is {
  constructor(t, n) {
    if (!((t instanceof ph && t.isCount()) || (Number.isInteger(t) && 0 <= t)))
      throw new TypeError('length must be positive integer or an unsigned integer ExternalLayout');
    let r = -1;
    t instanceof ph || (r = t), super(r, n), (this.length = t);
  }
  getSpan(t, n) {
    let r = this.span;
    return 0 > r && (r = this.length.decode(t, n)), r;
  }
  decode(t, n) {
    n === void 0 && (n = 0);
    let r = this.span;
    return 0 > r && (r = this.length.decode(t, n)), t.slice(n, n + r);
  }
  encode(t, n, r) {
    let i = this.length;
    if ((this.length instanceof ph && (i = t.length), !(Y.isBuffer(t) && i === t.length)))
      throw new TypeError(AY('Blob.encode', this) + ' requires (length ' + i + ') Buffer as src');
    if (r + i > n.length) throw new RangeError('encoding overruns Buffer');
    return (
      n.write(t.toString('hex'), r, i, 'hex'),
      this.length instanceof ph && this.length.encode(i, n, r),
      i
    );
  }
};
var MY = zM,
  ele = (e) => new IY(1, e),
  PY = (e) => new kY(e),
  FM = (e, t, n) => new CY(e, t, n),
  Wb = (e, t) => new zM(e, t);
class OY extends MY {
  constructor(t) {
    super(32, t);
  }
  decode(t, n) {
    return new Ye(super.decode(t, n));
  }
  encode(t, n, r) {
    return super.encode(t.toBuffer(), n, r);
  }
}
function DY(e) {
  return new OY(e);
}
const fS = FM([DY('account')]);
function RY(e) {
  const { account: t, owner: n } = e,
    r = [{ pubkey: t, isSigner: !1, isWritable: !1 }];
  return new Pc({ keys: r, data: xY(n), programId: $q });
}
function xY(e) {
  const t = { account: e },
    n = Y.alloc(fS.span),
    r = fS.encode(t, n);
  return n.slice(0, r);
}
function BY(e, t, n) {
  return Ye.findProgramAddressSync([e.toBuffer(), n.toBuffer(), t.toBuffer()], bM)[0];
}
async function jY(e, t, n, r) {
  const i = await BY(t, n, r),
    a = [
      { pubkey: e, isSigner: !0, isWritable: !0 },
      { pubkey: i, isSigner: !1, isWritable: !0 },
      { pubkey: t, isSigner: !1, isWritable: !1 },
      { pubkey: n, isSigner: !1, isWritable: !1 },
      { pubkey: mM, isSigner: !1, isWritable: !1 },
      { pubkey: r, isSigner: !1, isWritable: !1 },
      { pubkey: _4, isSigner: !1, isWritable: !1 },
    ];
  return [new Pc({ keys: a, programId: bM, data: Y.from([]) }), i];
}
const NY = async ({ owner: e, mint: t, connection: n }) => {
    const r = X4(gm(e)),
      i = J4(n).use(Ch.mplCore()).use(e6(r)),
      o = await Ch.fetchAsset(i, gm(t)),
      a = o.updateAuthority.type === 'Collection' ? o.updateAuthority.address : void 0,
      c = a ? await Ch.fetchCollectionV1(i, a) : void 0;
    return { umi: i, collection: c, asset: o };
  },
  UY = async ({ connection: e, mint: t, owner: n, destination: r }) => {
    const { umi: i, collection: o, asset: a } = await NY({ connection: e, mint: t, owner: n }),
      s = Ch.transfer(i, { asset: a, newOwner: gm(r), collection: o })
        .getInstructions()
        .map(Q4),
      l = new Bp();
    return s.forEach((u) => l.add(u)), l;
  },
  LY = async (e) => {
    const t = v4(
      e.source,
      e.mint,
      e.destination,
      e.owner,
      e.amount,
      e.decimals,
      [e.owner],
      e.programId
    );
    for (const n of e.references) t.keys.push({ pubkey: n, isWritable: !1, isSigner: !1 });
    return (
      e.transferHookProgramId &&
        (await S4(
          e.connection,
          t,
          new Ye(e.transferHookProgramId),
          e.source,
          e.mint,
          e.destination,
          e.owner,
          e.amount
        )),
      t
    );
  },
  zY = async ({ solanaConnection: e, destination: t, mint: n, programId: r }) => {
    var c;
    const i = await e.getParsedAccountInfo(t);
    if ((c = i.value) != null && c.owner.equals(r)) {
      const s = uj.safeParse(i.value);
      if (!s.success) throw new Error("The destination token account account data can't be parsed");
      const l = new Ye(s.data.data.parsed.info.mint);
      if (!n.equals(l))
        throw new Error(
          'The destination token account does not support the token you are sending to it.'
        );
      if (!s.data.data.parsed.info.owner)
        throw new Error('The destination token account does not have an owner');
      return { destinationAddress: new Ye(s.data.data.parsed.info.owner), destinationAccount: t };
    }
    const a = (await Vq(t, e, r))
      .filter((s) => s.mintAddress === n.toString())
      .sort((s, l) => l.tokenAmount.uiAmount - s.tokenAmount.uiAmount)[0];
    return a
      ? { destinationAddress: t, destinationAccount: a.pubkey }
      : { destinationAddress: t, destinationAccount: void 0 };
  };
function $M({ memoText: e }) {
  return new Pc({ keys: [], data: Y.from(e, 'utf-8'), programId: Fq });
}
async function FY(e) {
  const {
    connection: t,
    destination: n,
    senderAddress: r,
    senderAccount: i,
    mint: o,
    decimals: a,
    amount: c,
    references: s,
    memo: l,
    programId: u,
    transferHookProgramId: d,
  } = e;
  if (u === Dj) return await UY({ connection: t, destination: n, mint: o, owner: r.address });
  const f = new Ye(o),
    p = new Ye(u),
    { destinationAddress: y, destinationAccount: b } = await zY({
      solanaConnection: t,
      destination: new Ye(n),
      mint: new Ye(o),
      programId: p,
    });
  if (r.address === i)
    throw new Error(
      'When transferring tokens, sender account pubkey cannot be the sender address pubkey'
    );
  const m = new Ye(r.address),
    w = new Ye(i),
    _ = (s == null ? void 0 : s.map((N) => new Ye(N))) ?? [],
    S = (typeof c == 'string' ? new oe(c, 10) : c).toNumber(),
    E = new Bp();
  let O = b;
  if ((l && E.add($M({ memoText: l })), !O)) {
    const [N, F] = await jY(m, y, f, p);
    O = F;
    const D = q.getRpcProxyUrl(Hi.Mainnet);
    t.rpcEndpoint === D && E.add(RY({ account: y, owner: vI.programId })), E.add(N);
  }
  return (
    E.add(
      await LY({
        connection: t,
        source: w,
        mint: f,
        destination: O,
        owner: m,
        programId: p,
        amount: S,
        decimals: a,
        references: _,
        transferHookProgramId: d,
      })
    ),
    E
  );
}
function $Y(e) {
  const { fromPubkey: t, toPubkey: n, lamports: r, references: i, memo: o } = e,
    a = vI.transfer({ fromPubkey: t, toPubkey: n, lamports: r });
  for (const s of i) a.keys.push({ pubkey: s, isWritable: !1, isSigner: !1 });
  const c = new Bp();
  return o !== null && c.add($M({ memoText: o })), c.add(a), c;
}
const hS = 'estimate-fee-from-message',
  pS = 5e3,
  WY = async (e, t) => {
    const n = [];
    for (const o of t)
      n.push(
        (async () => {
          let a;
          try {
            a = await fa(e).getFeeForMessage(o, 'confirmed');
          } catch {
            return Z.addBreadcrumb(hS, 'rpc failed', Te.Info), o.header.numRequiredSignatures * pS;
          }
          return a.value === null
            ? (Z.addBreadcrumb(hS, 'null value returned from rpc', Te.Info),
              o.header.numRequiredSignatures * pS)
            : a.value;
        })()
      );
    const r = Zh(await Promise.all(n)),
      i = r / t.length > Mq;
    return { networkID: e, value: r, highFees: i };
  },
  VY = { skipPreflight: !1, preflightCommitment: 'confirmed' },
  WM = async ({ connection: e, signedTx: t, opts: n = {} }) => {
    const { skipPreflight: r, preflightCommitment: i } = { ...VY, ...n },
      o = t.serialize();
    return await An(
      () => e.sendRawTransaction(o, { preflightCommitment: i, skipPreflight: r }),
      (c) => c.message !== void 0 && c.message.includes('Node is behind')
    );
  },
  KY = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',
  HY = { 1: 'createAssociatedTokenAccountErrorInsufficientFunds' },
  qY = 'CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d',
  GY = { 9: 'cpeInvalidAuthority', 10: 'cpeAssetFrozen' },
  YY = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
  ZY = { 0: 'cpeBalanceBelowRent', 1: 'cpeInsufficientFunds', 17: 'cpeAccountFrozen' },
  QY = 'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb',
  JY = {
    0: 'cpeBalanceBelowRent',
    1: 'cpeInsufficientFunds',
    17: 'cpeAccountFrozen',
    24: 'cpeNotApprovedForConfidentialTransfers',
    25: 'cpeNotAcceptingDepositsOrTransfers',
    36: 'cpeNoMemoButRequired',
    37: 'cpeTransferDisabledForMint',
    40: 'cpeDepositAmountExceedsLimit',
    47: 'Account ownership cannot be changed while CPI Guard is enabled',
    49: 'Non-confidential transfers disabled',
  },
  XY = { [qY]: GY, [YY]: ZY, [QY]: JY, [KY]: HY };
function eZ(e, t) {
  const n = e.programId.toBase58(),
    r = t.message.startsWith('custom program error: ')
      ? t.message.replace('custom program error: ', '')
      : '',
    i = XY[n];
  if (i && r) {
    const o = i[r];
    return o
      ? { programId: n, customErrorCode: r, customErrorReason: o }
      : { programId: n, customErrorCode: r, customErrorReason: 'Unknown Error' };
  }
  return { programId: n, customErrorReason: 'Unknown Error', ...(r ? { customErrorCode: r } : {}) };
}
const Vb = new Map([
  ['GenericError', 'generic instruction error'],
  ['InvalidArgument', 'invalid program argument'],
  ['InvalidInstructionData', 'invalid instruction data'],
  ['InvalidAccountData', 'invalid account data for instruction'],
  ['AccountDataTooSmall', 'account data too small for instruction'],
  ['InsufficientFunds', 'insufficient funds for instruction'],
  ['IncorrectProgramId', 'incorrect program id for instruction'],
  ['MissingRequiredSignature', 'missing required signature for instruction'],
  ['AccountAlreadyInitialized', 'instruction requires an uninitialized account'],
  ['UninitializedAccount', 'instruction requires an initialized account'],
  ['UnbalancedInstruction', 'sum of account balances before and after instruction do not match'],
  ['ModifiedProgramId', 'instruction modified the program id of an account'],
  [
    'ExternalAccountLamportSpend',
    'instruction spent from the balance of an account it does not own',
  ],
  ['ExternalAccountDataModified', 'instruction modified data of an account it does not own'],
  ['ReadonlyLamportChange', 'instruction changed the balance of a read-only account'],
  ['ReadonlyDataModified', 'instruction modified data of a read-only account'],
  ['DuplicateAccountIndex', 'instruction contains duplicate accounts'],
  ['ExecutableModified', 'instruction changed executable bit of an account'],
  ['RentEpochModified', 'instruction modified rent epoch of an account'],
  ['NotEnoughAccountKeys', 'insufficient account keys for instruction'],
  ['AccountDataSizeChanged', 'non-system instruction changed account size'],
  ['AccountNotExecutable', 'instruction expected an executable account'],
  [
    'AccountBorrowFailed',
    'instruction tries to borrow reference for an account which is already borrowed',
  ],
  ['AccountBorrowOutstanding', 'instruction left account with an outstanding borrowed reference'],
  ['DuplicateAccountOutOfSync', 'instruction modifications of multiply-passed account differ'],
  ['Custom', 'custom program error: {0}'],
  ['InvalidError', 'program returned invalid error code'],
  ['ExecutableDataModified', 'instruction changed executable accounts data'],
  ['ExecutableLamportChange', 'instruction changed the balance of a executable account'],
  ['ExecutableAccountNotRentExempt', 'executable accounts must be rent exempt'],
  ['UnsupportedProgramId', 'Unsupported program id'],
  ['CallDepth', 'Cross-program invocation call depth too deep'],
  ['MissingAccount', 'An account required by the instruction is missing'],
  ['ReentrancyNotAllowed', 'Cross-program invocation reentrancy not allowed for this instruction'],
  ['MaxSeedLengthExceeded', 'Length of the seed is too long for address generation'],
  ['InvalidSeeds', 'Provided seeds do not result in a valid address'],
  ['InvalidRealloc', 'Failed to reallocate account data'],
  ['ComputationalBudgetExceeded', 'Computational budget exceeded'],
  ['PrivilegeEscalation', 'Cross-program invocation with unauthorized signer or writable account'],
  ['ProgramEnvironmentSetupFailure', 'Failed to create program execution environment'],
  ['ProgramFailedToComplete', 'Program failed to complete'],
  ['ProgramFailedToCompile', 'Program failed to compile'],
  ['Immutable', 'Account is immutable'],
  ['IncorrectAuthority', 'Incorrect authority provided'],
  ['BorshIoError', 'Failed to serialize or deserialize account data: {0}'],
  ['AccountNotRentExempt', 'An account does not have enough lamports to be rent-exempt'],
  ['InvalidAccountOwner', 'Invalid account owner'],
  ['ArithmeticOverflow', 'Program arithmetic overflowed'],
  ['UnsupportedSysvar', 'Unsupported sysvar'],
  ['IllegalOwner', 'Provided owner is not allowed'],
]);
function tZ(e) {
  if (e && typeof e == 'object' && 'InstructionError' in e) {
    const t = e.InstructionError,
      n = t[0],
      r = t[1];
    return { index: n, message: nZ(r) };
  }
}
function nZ(e) {
  let t, n;
  if (typeof e == 'string') {
    const r = Vb.get(e);
    if (r) return r;
  } else
    'Custom' in e
      ? ((t = Vb.get('Custom')), (n = e.Custom))
      : 'BorshIoError' in e && ((t = Vb.get('BorshIoError')), (n = e.BorshIoError));
  return t && n ? t.replace('{0}', n) : 'Unknown instruction error';
}
async function rZ(e, t) {
  const [n, r] = await Promise.all([
    iZ(e, t),
    e.getParsedTransaction(t, { commitment: 'confirmed', maxSupportedTransactionVersion: 0 }),
  ]);
  return n.result.err
    ? oZ(n, r == null ? void 0 : r.transaction)
    : (console.warn('Transaction was successful, no error to parse', t), null);
}
async function iZ(e, t) {
  const n = await e.getSignatureStatuses([t], { searchTransactionHistory: !0 }),
    [r] = n.value;
  if (r !== null) {
    let i;
    typeof r.confirmations == 'number' ? (i = r.confirmations) : (i = 'max');
    let o = null;
    try {
      o = await e.getBlockTime(r.slot);
    } catch (c) {
      i === 'max' && console.error(c, { slot: `${r.slot}` });
    }
    const a = o !== null ? o : 'unavailable';
    return {
      confirmationStatus: r.confirmationStatus,
      confirmations: i,
      result: { err: r.err },
      slot: r.slot,
      timestamp: a,
    };
  }
  throw new Error('Transaction not found');
}
function oZ(e, t) {
  if (typeof e.result.err == 'string') return { errorReason: `Runtime Error: "${e.result.err}"` };
  const n = tZ(e.result.err);
  if (n !== void 0)
    return {
      errorReason: `Program Error: "Instruction #${n.index + 1} Failed"`,
      ...(t ? eZ(t.message.instructions[n.index], n) : {}),
    };
  const { InsufficientFundsForRent: r } = e.result.err;
  return r !== void 0
    ? t
      ? { errorReason: 'cpeInsufficientFundsForRent' }
      : { errorReason: 'cpeInsufficientFundsForRent' }
    : { errorReason: `Unknown Error: "${JSON.stringify(e.result.err)}"` };
}
async function aZ(e, t) {
  var i;
  const n = { searchTransactionHistory: !0 },
    r = await e.getSignatureStatuses([t], n);
  if (
    ((i = r == null ? void 0 : r.value) == null ? void 0 : i[0]) == null ||
    !['confirmed', 'finalized'].includes(r.value[0].confirmationStatus ?? '')
  )
    throw ap;
  return r;
}
async function sZ(e) {
  var r;
  const { connection: t, signature: n } = e;
  try {
    const i = await An(
      () => aZ(t, n),
      (a) => a === ap,
      60,
      500,
      !0
    );
    if (((r = i == null ? void 0 : i.value) == null ? void 0 : r[0]) == null) throw ap;
    const o = i.value[0].err;
    if (o !== null) {
      const a = await rZ(t, n);
      throw a
        ? new yj(`Error confirming transaction: ${JSON.stringify(o)}`, a)
        : new Error(`Error confirming transaction: ${JSON.stringify(o)}`);
    }
    return { ...i, value: i.value[0] };
  } catch (i) {
    throw (i instanceof A4 && Z.captureError(i, te.Transaction), i);
  }
}
const cZ = async ({ connection: e, signedTxs: t, opts: n = {} }) =>
    await Promise.all(
      t.map(async (r) => {
        let i = null;
        try {
          const o = await An(
            () => WM({ connection: e, signedTx: r, opts: n }),
            (a) => a != null,
            4,
            100
          );
          return (
            (i = await An(
              async () => {
                if (((i = await sZ({ connection: e, signature: o })), i.value.err))
                  throw Error('Transaction confirmation failed.');
                return i;
              },
              () => !0,
              2,
              100
            )),
            o
          );
        } catch (o) {
          return Z.captureError(new Error(o), te.Transaction), null;
        }
      })
    ),
  uZ = { additionalSignerAccounts: [] },
  lZ = async ({
    accountIdentifier: e,
    feePayer: t,
    connection: n,
    accountSigner: r,
    transaction: i,
    pendingTransactionInput: o,
    storage: a,
    opts: c = {},
  }) => {
    const { additionalSignerAccounts: s } = { ...uZ, ...c };
    await S2(i, n), A2(i, t), s.length > 0 && I2(i, s);
    const l = await r.sign(e, { chainType: X.Solana, signingType: 'transaction', message: E2(i) });
    if (l.status === 'error') throw new Error(l.message);
    return i.addSignature(t, rn.decode(l.signature)), (o.data.signature = l.signature), ry(o, a), i;
  };
class xr extends Error {
  constructor(n, r, i) {
    const o = [r];
    i && o.push(JSON.stringify(i));
    super(o.join(':'));
    Le(this, 'kind');
    Le(this, 'meta');
    (this.meta = i), (this.kind = n);
  }
  static createUnknownError(n, r) {
    return So.UNKNOWN_ERROR(n, r);
  }
}
const So = {
  ATL_MISMATCH: () =>
    new xr('ATL_MISMATCH', 'Address table lookups do not match the initial transaction'),
  INSTRUCTION_MISMATCH: () =>
    new xr('INSTRUCTION_MISMATCH', 'Instructions do not match the initial transaction'),
  UNKNOWN_PROGRAM_INTERACTION: (e) =>
    new xr(
      'UNKNOWN_PROGRAM_INTERACTION',
      'Instruction is attempting to interact with an unknown program',
      { programId: e }
    ),
  MISSING_LIGHTHOUSE_PROGRAM_CALL: () =>
    new xr('MISSING_LIGHTHOUSE_PROGRAM_CALL', 'Instructions are missing Lighthouse program call'),
  TX_COUNT_MISMATCH: () =>
    new xr('TX_COUNT_MISMATCH', 'There are more original transactions than Safeguard transactions'),
  UNKNOWN_ERROR: (e, t) => new xr('UNKNOWN_ERROR', e, t),
};
function Ba(e, t, n) {
  if (e !== t) throw n();
}
function Kb(e, t) {
  if (!e) throw t();
}
function dZ(e, t) {
  if (e) throw t();
}
function fZ(e, t, n) {
  if (e.length !== t.length) throw n();
  for (const [r, i] of e.entries())
    Ba(i.pubkey.toString(), t[r].pubkey.toString(), n),
      Ba(i.isSigner, t[r].isSigner, n),
      Ba(i.isWritable, t[r].isWritable, n);
}
function hZ(e, t, n) {
  Ba(e.data.toString(), t.data.toString(), n),
    Ba(e.programId.toString(), t.programId.toString(), n),
    fZ(e.keys, t.keys, n);
}
const pp = [
    'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',
    'L2TExMFKdjpN9kozasaurPirfHy9P8sbXoAN1qA3S95',
  ],
  pZ = pp[pp.length - 1],
  gZ = { lighthouseIds: pp };
function yZ(e, t, { lighthouseIds: n = pp } = gZ) {
  Kb(t.length >= e.length, So.TX_COUNT_MISMATCH);
  const r = e.map((d) => yr.deserializeVersionedTransaction(d).transaction),
    i = t.map((d) => yr.deserializeVersionedTransaction(d).transaction),
    o = r
      .flatMap((d) => d.message.addressTableLookups)
      .map((d) => d.accountKey.toString())
      .sort(),
    a = i
      .flatMap((d) => d.message.addressTableLookups)
      .map((d) => d.accountKey.toString())
      .sort();
  for (const [d, f] of o.entries()) {
    const p = a[d];
    Ba(f, p, So.ATL_MISMATCH);
  }
  const c = r.flatMap((d) => gS(d)).filter((d) => !yS(d)),
    s = i.flatMap((d) => gS(d)).filter((d) => !yS(d));
  for (const [d, f] of c.entries()) {
    const p = s[d];
    Kb(p, So.INSTRUCTION_MISMATCH), hZ(f, p, So.INSTRUCTION_MISMATCH);
  }
  const l = s.slice(c.length);
  Kb(l.length > 0, So.MISSING_LIGHTHOUSE_PROGRAM_CALL);
  const u = l.find((d) => !n.includes(d.programId));
  dZ(u, So.UNKNOWN_PROGRAM_INTERACTION.bind(void 0, u == null ? void 0 : u.programId));
}
function gS(e) {
  return e.message.compiledInstructions.map((t) => bZ(t, e));
}
function bZ(e, t) {
  const n = [
      ...t.message.staticAccountKeys.map((i) => i.toBase58()),
      ...t.message.addressTableLookups.flatMap((i) =>
        i.writableIndexes.map(() => 'ATL_WRITABLE_ACC')
      ),
      ...t.message.addressTableLookups.flatMap((i) =>
        i.readonlyIndexes.map(() => 'ATL_READONLY_ACC')
      ),
    ],
    r = (i) => {
      const o = n[i];
      if (!o) throw new Error(`Failed to get account at index ${i}`);
      return o;
    };
  return {
    programId: r(e.programIdIndex),
    data: Ae.from(e.data),
    keys: e.accountKeyIndexes
      .map((i) => [r(i), i])
      .map(([i, o]) => ({
        pubkey: i,
        isSigner: t.message.isAccountSigner(o),
        isWritable: t.message.isAccountWritable(o),
      })),
  };
}
function yS(e) {
  return e.programId === Mc.programId.toString();
}
function mZ(e, t) {
  var n;
  if (
    e.params &&
    'safeguard' in e.params &&
    e.params.safeguard &&
    t != null &&
    t.advancedDetails &&
    'safeguard' in t.advancedDetails &&
    (n = t.advancedDetails.safeguard) != null &&
    n.transactions
  ) {
    const r = t.advancedDetails.safeguard;
    if (r.error) return r.error;
    const i = e.params.transactions,
      o = r.transactions;
    if (o) {
      let a;
      try {
        yZ(i, o);
      } catch (c) {
        c instanceof xr
          ? (a = c)
          : c instanceof Error
            ? (a = xr.createUnknownError(c.message))
            : (a = xr.createUnknownError('Non error type', c));
      }
      if (a) return (t.advancedDetails.safeguard.verifyError = a), a;
    }
  }
}
function wZ(e) {
  if (e.advancedDetails && 'requestId' in e.advancedDetails) return e.advancedDetails.requestId;
}
const _Z = async (e, t, n) => {
    const r = `/simulation/v1?language=${e}`,
      i = await ke
        .api()
        .post(r, { ...n, chainId: n.networkID, appVersion: vc, platform: E0, deviceId: t });
    if (!hn(i)) throw new Error('Failed to scan message');
    return i.data;
  },
  bS = async (e, t, n) => {
    const r = `/simulation/v1?language=${e}`,
      i = {
        ...n.params,
        ...(n.params && 'safeguard' in n.params
          ? { safeguard: { ...n.params.safeguard, lighthouseProgramId: pZ } }
          : {}),
      },
      o = await ke
        .api()
        .post(r, {
          ...n,
          chainId: n.networkID,
          params: i,
          metadata: n.metadata,
          appVersion: vc,
          platform: E0,
          deviceId: t,
        });
    if (!hn(o)) throw new Error('Failed to scan transaction');
    const a = o.data,
      c = mZ(n, a);
    if (c instanceof xr) {
      const s = wZ(a);
      Z.captureMessage(`Verify error ${s ?? ''}: ${c.message}`, te.Safeguard);
    }
    return a;
  };
h.union([
  h.literal('signTransaction'),
  h.literal('signAllTransactions'),
  h.literal('signAndSendTransaction'),
  h.literal('signAndSendAllTransactions'),
]);
const a0 = (e) => `/auto-confirm/v1/${e}`;
async function vZ(e) {
  if (q.isEVMNetworkID(e.chainId)) {
    const n = (
      await ke
        .api()
        .post(a0('transaction'), { txObjects: e.txObjects, chainId: e.chainId, domain: e.domain })
    ).data;
    return (n == null ? void 0 : n.isEligible) === !0;
  }
  if (q.isSolanaNetworkID(e.chainId)) {
    const n = (
      await ke
        .api()
        .post(a0('transaction'), {
          transactions: e.transactions,
          chainId: e.chainId,
          domain: e.domain,
        })
    ).data;
    return (n == null ? void 0 : n.isEligible) === !0;
  }
  return !1;
}
async function SZ(e) {
  if (q.isEVMNetworkID(e.chainId)) {
    const t = JSON.parse(JSON.stringify(e.data));
    delete t.message, delete t.primaryType, delete t.types;
    const r = await (
      await ke.api().post(a0('message'), { chainId: e.chainId, domain: e.domain, data: [t] })
    ).data;
    return (r == null ? void 0 : r.isEligible) === !0;
  }
  return !1;
}
const AZ = 10,
  gh = [];
class IZ {
  constructor(t) {
    Le(this, 'executedChecksAudit', []);
    Le(this, 'isDappWhitelistedForMessage', SZ);
    Le(this, 'isDappWhitelistedForTransaction', vZ);
    this.storage = t;
  }
  async isEthTransactionAutoConfirmable(t, n) {
    this.executedChecksAudit = [];
    const r = await this.didPassGenericChecks(t);
    if (r.status !== Xe.OK) return r;
    if (
      !(
        (await this.isDappWhitelistOverridden()) ||
        (await this.isDappWhitelistedForTransaction({
          chainId: t.networkID,
          domain: Cy(t.url.origin),
          txObjects: t.data,
        }))
      )
    )
      return { ...r, status: Xe.UnsupportedDapp, auditTrail: this.executedChecksAudit };
    const { success: o, ...a } = await this.didPassEthTransactionSimulation(t, n);
    return o
      ? { ...r, ...a, status: Xe.OK, auditTrail: this.executedChecksAudit }
      : { ...r, ...a, status: Xe.SimulationFailed, auditTrail: this.executedChecksAudit };
  }
  async isEthMessageAutoConfirmable(t, n) {
    this.executedChecksAudit = [];
    const r = await this.didPassGenericChecks(t);
    return r.status !== Xe.OK
      ? r
      : (await this.isDappWhitelistOverridden()) ||
          (await this.isDappWhitelistedForMessage({
            chainId: t.networkID,
            domain: Cy(t.url.origin),
            data: t.data,
          }))
        ? (await this.didPassEthMessageSimulation(t, n))
          ? { ...r, status: Xe.OK, auditTrail: this.executedChecksAudit }
          : { ...r, status: Xe.SimulationFailed, auditTrail: this.executedChecksAudit }
        : { ...r, status: Xe.UnsupportedDapp, auditTrail: this.executedChecksAudit };
  }
  async isSolTransactionAutoConfirmable(t, n) {
    this.executedChecksAudit = [];
    const r = await this.didPassGenericChecks(t);
    if (r.status !== Xe.OK) return r;
    if (
      !(
        (await this.isDappWhitelistOverridden()) ||
        (await this.isDappWhitelistedForTransaction({
          chainId: t.networkID,
          domain: Cy(t.url.origin),
          transactions: t.data,
        }))
      )
    )
      return { ...r, status: Xe.UnsupportedDapp, auditTrail: this.executedChecksAudit };
    const { success: o, ...a } = await this.didPassSolTransactionSimulation(t, n);
    return o
      ? { ...r, ...a, status: Xe.OK, auditTrail: this.executedChecksAudit }
      : { ...r, ...a, status: Xe.SimulationFailed, auditTrail: this.executedChecksAudit };
  }
  isSolMessageAutoConfirmable(t) {
    return (this.executedChecksAudit = []), Promise.resolve({ status: Xe.Unimplemented });
  }
  async didPassGenericChecks(t) {
    try {
      if (!(await this.isFeatureEnabled())) return { status: Xe.FeatureKilled };
      if (!(await this.isWalletUnlocked())) return { status: Xe.WalletLocked };
      if (!(await this.isTabFocused(t.url.origin))) return { status: Xe.TabNotFocused };
      if (
        !(await this.isAutoConfirmEnabledInUserSettings({
          origin: t.url.origin,
          networkID: t.networkID,
          accountIdentifier: t.accountIdentifier,
        }))
      )
        return { status: Xe.Disabled };
      const n = await this.isAutoConfirmSessionActive(t.accountIdentifier, t.url.origin);
      return n.success
        ? (await this.isNotRateLimited())
          ? {
              status: Xe.OK,
              sessionStartTime: n.sessionStartTime,
              sessionMaxDuration: n.sessionMaxDuration,
            }
          : {
              status: Xe.RateLimitExceeded,
              sessionStartTime: n.sessionStartTime,
              sessionMaxDuration: n.sessionMaxDuration,
            }
        : {
            status: Xe.SessionExpired,
            sessionStartTime: n.sessionStartTime,
            sessionMaxDuration: n.sessionMaxDuration,
          };
    } catch {
      return { status: Xe.Unknown };
    }
  }
  async isAutoConfirmEnabledInUserSettings({ origin: t, accountIdentifier: n, networkID: r }) {
    var o;
    this.executedChecksAudit.push(Dr.IsAutoConfirmEnabledInUserSettings);
    const i = await h_(this.storage, n, t);
    return ((o = i == null ? void 0 : i.networks) == null ? void 0 : o[r]) === !0;
  }
  isNotRateLimited() {
    this.executedChecksAudit.push(Dr.IsNotRateLimited);
    const t = gh.findIndex((n) => n <= Date.now() - 6e4);
    return t > -1 && gh.splice(t), gh.length >= AZ ? !1 : (gh.push(Date.now()), !0);
  }
  async isAutoConfirmSessionActive(t, n) {
    this.executedChecksAudit.push(Dr.IsAutoConfirmSessionActive);
    const r = await h_(this.storage, t, n),
      i = VE(r);
    return {
      sessionStartTime: r.sessionStartTime,
      sessionMaxDuration: r.maxSessionDuration,
      success: i,
    };
  }
  async didPassEthTransactionSimulation(t, n) {
    var r;
    this.executedChecksAudit.push(Dr.DidPassEthTransactionSimulation);
    try {
      const i = await bS(n.locale, n.deviceId, {
        networkID: t.networkID,
        type: 'transaction',
        url: (r = t.url) == null ? void 0 : r.href,
        userAccount: t.userAccountAddress,
        params: { transactions: t.data, userAddresses: [] },
      });
      return mS(i);
    } catch {
      return { success: !1 };
    }
  }
  async didPassSolTransactionSimulation(t, n) {
    this.executedChecksAudit.push(Dr.DidPassSolTransactionSimulation);
    try {
      const r = await bS(n.locale, n.deviceId, {
        networkID: t.networkID,
        type: 'transaction',
        url: t.url.href,
        userAccount: t.userAccountAddress,
        params: { transactions: t.data, method: 'signAndSendTransaction' },
      });
      return mS(r);
    } catch {
      return { success: !1 };
    }
  }
  async didPassEthMessageSimulation(t, n) {
    var r;
    this.executedChecksAudit.push(Dr.DidPassEthMessageSimulation);
    try {
      const i = await _Z(n.locale, n.deviceId, {
        params: { message: '0x' + Y.from(JSON.stringify(t.data)).toString('hex') },
        type: 'message',
        userAccount: t.userAccountAddress,
        networkID: t.networkID,
        url: (r = t.url) == null ? void 0 : r.href,
      });
      return EZ(i);
    } catch {
      return !1;
    }
  }
}
function mS(e) {
  const t = !!e.warnings.find((i) => i.severity <= d1.criticalError),
    n = !!e.block,
    r = e.expectedChanges
      .map((i) => (i.type === 'AssetChange' && i.asset.usdValue) || 0)
      .reduce((i, o) => i + o, 0);
  return { success: !t && !n && !e.error, dollarValue: parseFloat((r || 0).toFixed(6)) };
}
function EZ(e) {
  const t = !!e.warnings.find((r) => r.severity <= d1.criticalError),
    n = !!e.block;
  return !t && !n && !e.error;
}
const wS = 7;
var jo;
class yh {
  constructor(t) {
    _t(this, jo);
    mt(this, jo, t);
  }
  onAutoConfirmSettingsChanged({
    origin: t,
    networkID: n,
    enabled: r,
    sessionStartTime: i,
    maxSessionDuration: o,
    view: a,
  }) {
    Z.addBreadcrumb(
      `Auto-Confirm: ${r ? 'Enabling' : 'Disabling'} network ID ${n}`,
      te.AutoConfirm,
      Te.Info
    ),
      ue(this, jo).capture('autoConfirmSettingsChanged', {
        data: {
          origin: t,
          networkId: n,
          enabled: r,
          sessionStartTime: r ? i : void 0,
          maxSessionDuration: r ? o : void 0,
          view: a,
        },
      });
  }
  transactionAutoConfirmed(t) {
    var r;
    const n = { type: 'transaction', data: t };
    return (
      (r = t.autoConfirm.auditTrail) != null &&
        r.length &&
        t.autoConfirm.auditTrail.length < wS &&
        (t.autoConfirm.suspectSettingsTamper = !0),
      Z.addBreadcrumb(
        `Auto-Confirm: transaction on origin ${t.origin} for network ${t.networkId} auto-confirmed`,
        te.AutoConfirm,
        Te.Info
      ),
      t.autoConfirm.suspectSettingsTamper &&
        Z.addBreadcrumb(
          'Auto-Confirm: suspected tampering with settings...',
          te.AutoConfirm,
          Te.Info
        ),
      ue(this, jo).capture('transactionAutoConfirmed', n)
    );
  }
  messageAutoConfirmed(t) {
    var r;
    const n = { type: 'message', data: t };
    return (
      (r = t.autoConfirm.auditTrail) != null &&
        r.length &&
        t.autoConfirm.auditTrail.length < wS &&
        (t.autoConfirm.suspectSettingsTamper = !0),
      Z.addBreadcrumb(
        `Auto-Confirm: message on origin ${t.origin} for network ${t.networkId} auto-confirmed`,
        te.AutoConfirm,
        Te.Info
      ),
      t.autoConfirm.suspectSettingsTamper &&
        Z.addBreadcrumb(
          'Auto-Confirm: suspected tampering with settings...',
          te.AutoConfirm,
          Te.Info
        ),
      ue(this, jo).capture('transactionAutoConfirmed', n)
    );
  }
}
jo = new WeakMap();
Xe.UnsupportedDapp + '',
  Xe.Disabled + '',
  Xe.RateLimitExceeded + '',
  Xe.SimulationFailed + '',
  Xe.UnsupportedNetworkId + '',
  Xe.TabNotFocused + '',
  Xe.WalletLocked + '';
const Cr = (e) => (t) => {
    dn.capture(e, { data: t });
  },
  TZ = {
    deepLinkDetected: Cr('deepLinkDetected'),
    tokenDeepLink: Cr('deepLinkTokens'),
    userDeepLink: Cr('deepLinkUser'),
    metamaskOverrideSelection: Cr('notificationMetamaskOverrideSelection'),
    approveConnection: Cr('connectionConfirm'),
    declineConnection: Cr('connectionDeny'),
    approveSignMessage: Cr('signMessageConfirm'),
    declineSignMessage: Cr('signMessageDeny'),
    approveTransaction: Cr('transactionConfirm'),
    declineTransaction: Cr('transactionDeny'),
    eth: {
      submittedTransaction: async ({ origin: e, request: t, signatures: n }) => {
        try {
          const r = await Gf(t, { origin: e }, n);
          if (!r.success)
            throw new Error(`Failed to capture signature event analytics: ${r.error}`);
          await g_(dn, { data: { ...r.data, ids: r.data.ids ?? n }, action: 'dapp' });
        } catch (r) {
          Z.captureError(r, te.Provider);
        }
      },
      signedMessage: async ({ origin: e, request: t, chainId: n }) => {
        try {
          const r = await Yf(t, { origin: e, chainId: Hw(n) });
          if (!r.success)
            throw new Error(`Failed to capture signature event analytics: ${r.error}`);
          await y_(dn, r.data);
        } catch (r) {
          Z.captureError(r, te.Provider);
        }
      },
      autoConfirmedTransaction: async ({ origin: e, request: t, data: n }) => {
        try {
          const r = new yh(dn),
            i = await Gf(t, { origin: e });
          if (!i.success)
            throw new Error(`Failed to capture signature event analytics: ${i.error}`);
          await r.transactionAutoConfirmed({ ...i.data, autoConfirm: n });
        } catch (r) {
          Z.captureError(r, te.Provider);
        }
      },
      autoConfirmedMessage: async ({ origin: e, request: t, chainId: n, data: r }) => {
        try {
          const i = new yh(dn),
            o = await Yf(t, { origin: e, chainId: Hw(n) });
          if (!o.success)
            throw new Error(`Failed to capture signature event analytics: ${o.error}`);
          await i.messageAutoConfirmed({ ...o.data, autoConfirm: r });
        } catch (i) {
          Z.captureError(i, te.Provider);
        }
      },
      unsupportedChain: async ({ origin: e, data: t }) => {
        try {
          await dn.capture('unsupportedChainId', {
            data: {
              origin: e,
              chainType: 'eip155',
              chainId: x0(t.hexChainId),
              chainName: t.chainName,
              method: t.method,
            },
          });
        } catch (n) {
          Z.captureError(n, te.Provider);
        }
      },
    },
    sol: {
      submittedTransaction: async ({ origin: e, request: t, chainId: n, signatures: r }) => {
        try {
          const i = await Gf(t, { origin: e, chainId: n }, r);
          if (!i.success)
            throw new Error(`Failed to capture signature event analytics: ${i.error}`);
          await g_(dn, { data: { ...i.data, ids: i.data.ids ?? r }, action: 'dapp' });
        } catch (i) {
          Z.captureError(i, te.Provider);
        }
      },
      signedMessage: async ({ origin: e, request: t, chainId: n }) => {
        try {
          const r = await Yf(t, { origin: e, chainId: n });
          if (!r.success)
            throw new Error(`Failed to capture signature event analytics: ${r.error}`);
          await y_(dn, r.data);
        } catch (r) {
          Z.captureError(r, te.Provider);
        }
      },
      autoConfirmedTransaction: async ({ origin: e, request: t, data: n, chainId: r }) => {
        try {
          const i = new yh(dn),
            o = await Gf(t, { origin: e, chainId: r });
          if (!o.success)
            throw new Error(`Failed to capture signature event analytics: ${o.error}`);
          await i.transactionAutoConfirmed({ ...o.data, autoConfirm: n });
        } catch (i) {
          Z.captureError(i, te.Provider);
        }
      },
      autoConfirmedMessage: async ({ origin: e, request: t, chainId: n, data: r }) => {
        try {
          const i = new yh(dn),
            o = await Yf(t, { origin: e, chainId: n });
          if (!o.success)
            throw new Error(`Failed to capture signature event analytics: ${o.error}`);
          await i.messageAutoConfirmed({ ...o.data, autoConfirm: r });
        } catch (i) {
          Z.captureError(i, te.Provider);
        }
      },
    },
  },
  kZ = {
    env: 'production',
    logRequestMethods: new Set([
      'eth_requestAccounts',
      'eth_accounts',
      'eth_sendTransaction',
      'eth_sign',
      'personal_sign',
    ]),
    logRequestsOnError: !0,
  },
  CZ = { isEnabled: async (e) => (await Un.getFeatureFlags())[e] === !0 },
  MZ = {
    t(e) {
      return e;
    },
  },
  PZ = {
    debug(...e) {
      console.debug(...e);
    },
    warn(...e) {
      console.warn(...e);
    },
    error(...e) {
      Z.addBreadcrumb(te.Provider, e.join(', '), Te.Error);
    },
  },
  OZ = { eth: $o },
  DZ = {
    eth: {
      hexToCAIP2: (e) => `eip155:${parseInt(e, 16)}`,
      getBufferedGasLimit(e) {
        return '0x' + new oe(AT(new oe(e))).toString(16);
      },
    },
    sol: {
      chainIdToCAIP2: eo,
      chainIdToCluster: T2,
      serializeSolanaSignInMessage(e, { expectedChainId: t, expectedAddress: n, expectedURL: r }) {
        const i = e.domain || r.host,
          o = e.address || n;
        let a = `${i} wants you to sign in with your Solana account:
`;
        (a += `${o}`),
          e.statement &&
            (a += `

${e.statement}`);
        const c = [];
        if (
          (e.uri && c.push(`URI: ${e.uri}`),
          e.version && c.push(`Version: ${e.version}`),
          e.chainId && c.push(`Chain ID: ${e.chainId}`),
          e.nonce && c.push(`Nonce: ${e.nonce}`),
          e.issuedAt && c.push(`Issued At: ${e.issuedAt}`),
          e.expirationTime && c.push(`Expiration Time: ${e.expirationTime}`),
          e.notBefore && c.push(`Not Before: ${e.notBefore}`),
          e.requestId && c.push(`Request ID: ${e.requestId}`),
          e.resources)
        ) {
          c.push('Resources:');
          for (const d of e.resources) c.push(`- ${d}`);
        }
        c.length &&
          (a += `

${c.join(`
`)}`);
        const s = I4(E4.Solana, a);
        if (!s.success)
          return {
            type: 'fail',
            data: rn.encode(Y.from(a)),
            error: [{ label: 'PARSE_ERROR', message: s.error.message }],
          };
        const l = 1e3 * 60 * 10,
          u = T4(s.data, {
            expectedAddress: n,
            expectedURL: r,
            expectedChainId: t,
            issuedAtThreshold: l,
          });
        return u.length
          ? {
              type: 'fail',
              data: rn.encode(Y.from(a)),
              error: u.map((d) => ({ label: k4[d], message: `siwsErrorMessage_${d}` })),
            }
          : { type: 'success', data: rn.encode(Y.from(a)) };
      },
      base58Encode: (e) => rn.encode(e),
    },
    getFaviconURL: k2,
    parseURL: C2,
    getOrigin: lm,
    getHostname: M2,
    getOriginAndHostname: P2,
  },
  RZ = async (e, t) => {},
  xZ = async (e) => {},
  BZ = async () => {
    throw new Error('not implemented');
  },
  jZ = async (e) => !0;
let jh = null;
const NZ = (e) => {
    jh = e;
  },
  tle = (e) => {
    jh == null || jh(e);
  },
  UZ = (e) => (t, n, r) => {
    const i = r.subscribe;
    return (
      (r.subscribe = (a, c, s) => {
        let l = a;
        if (c) {
          const u = (s == null ? void 0 : s.equalityFn) || Object.is;
          let d = a(r.getState());
          (l = (f) => {
            const p = a(f);
            if (!u(d, p)) {
              const y = d;
              c((d = p), y);
            }
          }),
            s != null && s.fireImmediately && c(d, d);
        }
        return i(l);
      }),
      e(t, n, r)
    );
  };
var LZ = Object.defineProperty,
  _S = Object.getOwnPropertySymbols,
  zZ = Object.prototype.hasOwnProperty,
  FZ = Object.prototype.propertyIsEnumerable,
  vS = (e, t, n) =>
    t in e ? LZ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (e[t] = n),
  _a = (e, t) => {
    for (var n in t || (t = {})) zZ.call(t, n) && vS(e, n, t[n]);
    if (_S) for (var n of _S(t)) FZ.call(t, n) && vS(e, n, t[n]);
    return e;
  };
const gp = (e) => (t) => {
    try {
      const n = e(t);
      return n instanceof Promise
        ? n
        : {
            then(r) {
              return gp(r)(n);
            },
            catch(r) {
              return this;
            },
          };
    } catch (n) {
      return {
        then(r) {
          return this;
        },
        catch(r) {
          return gp(r)(n);
        },
      };
    }
  },
  nle = (e, t) => (n, r, i) => {
    let o = _a(
      {
        getStorage: () => localStorage,
        serialize: JSON.stringify,
        deserialize: JSON.parse,
        partialize: (m) => m,
        version: 0,
        merge: (m, w) => _a(_a({}, w), m),
      },
      t
    );
    (o.blacklist || o.whitelist) &&
      console.warn(
        `The ${o.blacklist ? 'blacklist' : 'whitelist'} option is deprecated and will be removed in the next version. Please use the 'partialize' option instead.`
      );
    let a = !1;
    const c = new Set(),
      s = new Set();
    let l;
    try {
      l = o.getStorage();
    } catch {}
    if (l)
      l.removeItem ||
        console.warn(
          `[zustand persist middleware] The given storage for item '${o.name}' does not contain a 'removeItem' method, which will be required in v4.`
        );
    else
      return e(
        (...m) => {
          console.warn(
            `[zustand persist middleware] Unable to update item '${o.name}', the given storage is currently unavailable.`
          ),
            n(...m);
        },
        r,
        i
      );
    const u = gp(o.serialize),
      d = () => {
        const m = o.partialize(_a({}, r()));
        o.whitelist &&
          Object.keys(m).forEach((S) => {
            var E;
            !((E = o.whitelist) != null && E.includes(S)) && delete m[S];
          }),
          o.blacklist && o.blacklist.forEach((S) => delete m[S]);
        let w;
        const _ = u({ state: m, version: o.version })
          .then((S) => l.setItem(o.name, S))
          .catch((S) => {
            w = S;
          });
        if (w) throw w;
        return _;
      },
      f = i.setState;
    i.setState = (m, w) => {
      f(m, w), d();
    };
    const p = e(
      (...m) => {
        n(...m), d();
      },
      r,
      i
    );
    let y;
    const b = () => {
      var m;
      if (!l) return;
      (a = !1), c.forEach((_) => _(r()));
      const w = ((m = o.onRehydrateStorage) == null ? void 0 : m.call(o, r())) || void 0;
      return gp(l.getItem.bind(l))(o.name)
        .then((_) => {
          if (_) return o.deserialize(_);
        })
        .then((_) => {
          if (_)
            if (typeof _.version == 'number' && _.version !== o.version) {
              if (o.migrate) return o.migrate(_.state, _.version);
              console.error(
                "State loaded from storage couldn't be migrated since no migrate function was provided"
              );
            } else return _.state;
        })
        .then((_) => {
          var S;
          return (y = o.merge(_, (S = r()) != null ? S : p)), n(y, !0), d();
        })
        .then(() => {
          w == null || w(y, void 0), (a = !0), s.forEach((_) => _(y));
        })
        .catch((_) => {
          w == null || w(void 0, _);
        });
    };
    return (
      (i.persist = {
        setOptions: (m) => {
          (o = _a(_a({}, o), m)), m.getStorage && (l = m.getStorage());
        },
        clearStorage: () => {
          var m;
          (m = l == null ? void 0 : l.removeItem) == null || m.call(l, o.name);
        },
        rehydrate: () => b(),
        hasHydrated: () => a,
        onHydrate: (m) => (
          c.add(m),
          () => {
            c.delete(m);
          }
        ),
        onFinishHydration: (m) => (
          s.add(m),
          () => {
            s.delete(m);
          }
        ),
      }),
      b(),
      y || p
    );
  },
  Y1 = async () => {
    const e = Xn,
      { isOnboarded: t } = await e.checkVaultIntegrity();
    return t;
  };
var VM = 80,
  KM = 80,
  $Z = 408,
  WZ = 712,
  Gi = '_1289qr81 _1289qr80 _16y4lb71c8 _16y4lb71du _16y4lb71kj',
  ka =
    '_1289qr83 _195nf5r0 _195nf5rf _195nf5r1 _195nf5r6 _195nf5re _1289qr82 _16y4lb7u1 _16y4lb7v1 _16y4lb7x1 _16y4lb7w1 _16y4lb7211 _16y4lb71b8 _16y4lb71cu _16y4lb71pl',
  VZ =
    '_1289qr85 _1289qr84 _16y4lb7qw _16y4lb7pq _16y4lb7s2 _16y4lb7ok _16y4lb7xb _16y4lb7x9 _16y4lb7xd _16y4lb7x7 _16y4lb73mj _16y4lb737j _16y4lb72dj _16y4lb72sj _16y4lb71c8 _16y4lb71du _16y4lb742s _16y4lb71wv _16y4lb71l6 _16y4lb71kj _16y4lb71nq',
  HM = 100,
  KZ =
    '_1289qr88 _1289qr85 _1289qr84 _16y4lb7qw _16y4lb7pq _16y4lb7s2 _16y4lb7ok _16y4lb7xb _16y4lb7x9 _16y4lb7xd _16y4lb7x7 _16y4lb73mj _16y4lb737j _16y4lb72dj _16y4lb72sj _16y4lb71c8 _16y4lb71du _16y4lb742s _16y4lb71wv _16y4lb71l6 _16y4lb71kj _16y4lb71nq _1289qr86 _1289qr87 _16y4lb7u4 _16y4lb7v4 _16y4lb7x4 _16y4lb7w4',
  HZ =
    '_1289qr8a _1289qr85 _1289qr84 _16y4lb7qw _16y4lb7pq _16y4lb7s2 _16y4lb7ok _16y4lb7xb _16y4lb7x9 _16y4lb7xd _16y4lb7x7 _16y4lb73mj _16y4lb737j _16y4lb72dj _16y4lb72sj _16y4lb71c8 _16y4lb71du _16y4lb742s _16y4lb71wv _16y4lb71l6 _16y4lb71kj _16y4lb71nq _1289qr86 _1289qr89 _16y4lb7u4 _16y4lb7v4 _16y4lb7x4 _16y4lb7w4',
  Nh =
    '_1289qr8b _1289qr8a _1289qr85 _1289qr84 _16y4lb7qw _16y4lb7pq _16y4lb7s2 _16y4lb7ok _16y4lb7xb _16y4lb7x9 _16y4lb7xd _16y4lb7x7 _16y4lb73mj _16y4lb737j _16y4lb72dj _16y4lb72sj _16y4lb71c8 _16y4lb71du _16y4lb742s _16y4lb71wv _16y4lb71l6 _16y4lb71kj _16y4lb71nq _1289qr86 _1289qr89 _16y4lb7u4 _16y4lb7v4 _16y4lb7x4 _16y4lb7w4',
  qZ =
    '_1289qr85 _1289qr84 _16y4lb7qw _16y4lb7pq _16y4lb7s2 _16y4lb7ok _16y4lb7xb _16y4lb7x9 _16y4lb7xd _16y4lb7x7 _16y4lb73mj _16y4lb737j _16y4lb72dj _16y4lb72sj _16y4lb71c8 _16y4lb71du _16y4lb742s _16y4lb71wv _16y4lb71l6 _16y4lb71kj _16y4lb71nq',
  GZ =
    '_1289qr8c _1289qr85 _1289qr84 _16y4lb7qw _16y4lb7pq _16y4lb7s2 _16y4lb7ok _16y4lb7xb _16y4lb7x9 _16y4lb7xd _16y4lb7x7 _16y4lb73mj _16y4lb737j _16y4lb72dj _16y4lb72sj _16y4lb71c8 _16y4lb71du _16y4lb742s _16y4lb71wv _16y4lb71l6 _16y4lb71kj _16y4lb71nq';
const YZ = 479,
  yp = () => {
    if (Qe.renderMode === 'full-mode') return !1;
    const e = parseInt(Qe.clientWidth ?? ''),
      t = parseInt(Qe.clientHeight ?? '');
    if (Number.isNaN(e) || Number.isNaN(t)) throw new Error('Missing screen size');
    return e < YZ;
  };
async function ZZ(e) {
  Qe.renderMode === 'full-mode'
    ? ((e.walletFrameClassname = KZ),
      (e.walletContainerClassname = Gi),
      (e.launcherButtonClassname = ft({ display: 'none' })),
      await SS({ centered: !1 }))
    : (yp()
        ? ((e.walletFrameClassname = qZ),
          (e.walletContainerClassname = Gi),
          (e.launcherButtonClassname = ft({ display: 'none' })))
        : ((e.walletFrameClassname = HZ),
          (e.walletContainerClassname = Gi),
          (e.launcherButtonClassname = ka)),
      await SS({ centered: yp() }));
}
async function QZ(e) {
  Qe.renderMode === 'full-mode'
    ? ((e.walletFrameClassname = Nh),
      (e.walletContainerClassname = Gi),
      (e.launcherButtonClassname = ka),
      await AS())
    : Qe.hideLauncherBeforeOnboarded && !(await Y1())
      ? ((e.walletFrameClassname = Nh),
        (e.walletContainerClassname = Gi),
        (e.launcherButtonClassname = ka),
        await AS())
      : yp()
        ? ((e.walletFrameClassname = GZ),
          (e.walletContainerClassname = Gi),
          (e.launcherButtonClassname = ka),
          await s0())
        : ((e.walletFrameClassname = Nh),
          (e.walletContainerClassname = `${Gi}`),
          (e.launcherButtonClassname = ka),
          setTimeout(() => void s0(), HM));
}
function JZ() {
  const e = Qe.initialState === 'closed' ? Gt.Closed : Gt.Open,
    t = Qe.initialState === 'closed' ? Nh : VZ,
    n = Gi,
    r = Qe.renderMode === 'full-mode' ? ft({ display: 'none' }) : ka;
  return {
    initialWalletState: e,
    initialWalletFrameClassname: t,
    initialWalletContainerClassname: n,
    initialLauncherButtonClassname: r,
  };
}
const Ur = aa(
    UZ((e) => {
      const {
        initialWalletState: t,
        initialWalletFrameClassname: n,
        initialWalletContainerClassname: r,
        initialLauncherButtonClassname: i,
      } = JZ();
      return {
        walletState: t,
        isAnimating: !1,
        walletFrameClassname: n,
        walletContainerClassname: r,
        launcherButtonClassname: i,
        setWalletState: async (o) => {
          const a = {
            walletFrameClassname: void 0,
            walletContainerClassname: void 0,
            launcherButtonClassname: void 0,
          };
          if (
            (o === Gt.Open && (await ZZ(a)),
            o === Gt.Closed && (await QZ(a)),
            a.walletFrameClassname === void 0 ||
              a.walletContainerClassname === void 0 ||
              a.launcherButtonClassname === void 0)
          )
            throw new Error('required classnames not set');
          e({
            walletState: o,
            walletFrameClassname: a.walletFrameClassname,
            walletContainerClassname: a.walletContainerClassname,
            launcherButtonClassname: a.launcherButtonClassname,
            isAnimating: !0,
          }),
            setTimeout(() => e((c) => ({ ...c, isAnimating: !1 })), HM);
        },
      };
    })
  ),
  XZ = () => Ur.getState().walletState,
  os = (e) => Ur.getState().setWalletState(e),
  eQ = (e) => Ur.subscribe((t) => t.walletState, e),
  tQ = () => {
    const e = (t) => {
      t.origin === new URL(Zp).origin && Object.values(Gt).includes(t.data) && os(t.data);
    };
    return (
      window.addEventListener('message', e),
      () => {
        window.removeEventListener('message', e);
      }
    );
  },
  qM =
    Qe.renderMode === 'button'
      ? {
          [Ia.bottomRight]: {
            bottom: (Qe.paddingBottom ?? '0') + 'px',
            right: (Qe.paddingRight ?? '0') + 'px',
            top: 'auto',
            left: 'auto',
          },
          [Ia.bottomLeft]: {
            bottom: (Qe.paddingBottom ?? '0') + 'px',
            left: (Qe.paddingLeft ?? '0') + 'px',
            top: 'auto',
            right: 'auto',
          },
          [Ia.topRight]: {
            top: (Qe.paddingTop ?? '0') + 'px',
            right: (Qe.paddingRight ?? '0') + 'px',
            bottom: 'auto',
            left: 'auto',
          },
          [Ia.topLeft]: {
            top: (Qe.paddingTop ?? '0') + 'px',
            left: (Qe.paddingLeft ?? '0') + 'px',
            bottom: 'auto',
            right: 'auto',
          },
        }[Qe.position]
      : {},
  Ca =
    Qe.renderMode === 'full-mode'
      ? {
          maxWidth: '0px',
          maxHeight: '0px',
          width: '100%',
          height: '100%',
          transform: 'none',
          position: 'absolute',
          top: '0',
          left: '0',
          right: '0',
          bottom: '0',
        }
      : {
          maxWidth: VM + 'px',
          maxHeight: KM + 'px',
          width: '100%',
          height: '100%',
          transform: 'none',
          position: 'fixed',
          ...qM,
          zIndex: Qe.zIndex,
        },
  nQ =
    Qe.renderMode === 'full-mode'
      ? {
          maxWidth: 'none',
          maxHeight: 'none',
          width: '100%',
          height: '100%',
          position: 'absolute',
          top: '0',
          left: '0',
          transform: 'none',
        }
      : {
          maxWidth: $Z + 'px',
          maxHeight: WZ + 'px',
          width: '100%',
          height: '100%',
          position: 'fixed',
          transform: 'none',
          ...qM,
          zIndex: Qe.zIndex,
        },
  rQ =
    Qe.renderMode === 'full-mode'
      ? {
          maxWidth: 'none',
          maxHeight: 'none',
          width: '100%',
          height: '100%',
          position: 'absolute',
          top: '0',
          left: '0',
          right: '0',
          bottom: '0',
        }
      : {
          maxWidth: 'none',
          maxHeight: 'none',
          width: '100%',
          height: '100%',
          position: 'fixed',
          transform: 'translate(-50%, -50%)',
          top: '50%',
          left: '50%',
          bottom: 'auto',
          right: 'auto',
          zIndex: Qe.zIndex,
        };
function SS({ centered: e }) {
  return new Promise((t) => {
    window.addEventListener('message', function n(r) {
      r.data === u1 && (window.removeEventListener('message', n), t());
    }),
      e ? window.parent.postMessage(rQ, '*') : window.parent.postMessage(nQ, '*');
  });
}
function s0() {
  return new Promise((e) => {
    window.addEventListener('message', function t(n) {
      n.data === u1 && (window.removeEventListener('message', t), e());
    }),
      window.parent.postMessage(Ca, '*');
  });
}
function AS() {
  return new Promise((e) => {
    window.addEventListener('message', function t(n) {
      n.data === u1 && (window.removeEventListener('message', t), e());
    }),
      window.parent.postMessage({ ...Ca, transform: 'scale(0)' }, '*');
  });
}
function iQ(e) {
  if (!yp()) return () => {};
  if (Qe.renderMode === 'full-mode') return () => {};
  e.addEventListener('touchstart', t);
  function t(o) {
    o.touches.length > 1 || (e.addEventListener('touchend', i), e.addEventListener('touchmove', r));
  }
  let n;
  function r(o) {
    var w, _;
    if (Qe.renderMode === 'full-mode') return;
    o.preventDefault();
    const a = o.touches[0];
    if (!o.touches) return;
    if (!n) {
      n = a;
      return;
    }
    const c = n.screenX - a.screenX,
      s = n.screenY - a.screenY,
      l = parseInt(((w = Ca.right) == null ? void 0 : w.slice(0, -2)) ?? '0'),
      u = parseInt(((_ = Ca.bottom) == null ? void 0 : _.slice(0, -2)) ?? '0');
    let d = l + c,
      f = u + s;
    const p = VM,
      y = KM,
      b = parseInt(Qe.clientWidth),
      m = parseInt(Qe.clientHeight);
    (d = fp(d, 0, b - p)),
      (f = fp(f, 0, m - y)),
      (Ca.right = d + 'px'),
      (Ca.bottom = f + 'px'),
      s0(),
      (n = a),
      (a.screenX < 0 || a.screenX > b || a.screenY < 0 || a.screenY > m) && i();
  }
  function i() {
    (n = void 0), e.removeEventListener('touchend', i), e.removeEventListener('touchmove', r);
  }
  return () => {
    e.removeEventListener('touchstart', t);
  };
}
var oQ = {
  root: '_6iv12n0 _16y4lb71kj _16y4lb71nq _16y4lb71du _16y4lb71c8',
  mainContent: '_6iv12n2 _6iv12n1 _16y4lb71nd _16y4lb71l9',
  menuBar:
    '_6iv12n3 _16y4lb73mj _16y4lb737j _16y4lb72dj _16y4lb72sj _16y4lb759 _16y4lb76v _16y4lb723 _16y4lb73p _16y4lb71xa _16y4lb7xd _16y4lb7s2',
  tabBar:
    '_6iv12n4 _16y4lb73mj _16y4lb737j _16y4lb72dj _16y4lb72sj _16y4lb71xa _16y4lb7xb _16y4lb71kj _16y4lb71nr _16y4lb7qw _16y4lb71lp',
  tabLink: '_6iv12n5 _16y4lb723 _16y4lb73p _16y4lb75b _16y4lb76x _16y4lb71pf _16y4lb72',
  modal:
    '_6iv12n6 _16y4lb7xf _16y4lb713m _16y4lb7xk _16y4lb710l _16y4lb716n _16y4lb71wv _16y4lb71ly',
  link: '_6iv12n7 _16y4lb7437',
};
const aQ = 'Icon type is Image, but no field: imageUrl found.',
  sQ = 'Icon type is Emoji, but no field: unicode found.';
var cQ = g3({
    defaultClassName:
      'f2sbbe3 _195nf5r0 _195nf5rf _195nf5r1 _195nf5r6 _195nf5re f2sbbe2 _16y4lb7u6 _16y4lb7v6 _16y4lb7x6 _16y4lb7w6 _16y4lb71kj _16y4lb71me _16y4lb71mr _16y4lb71pl _16y4lb71l6 _16y4lb75m9',
    variantClassNames: {
      theme: {
        primary: 'f2sbbe4 f2sbbe0 _16y4lb7211 _16y4lb73zv',
        secondary: 'f2sbbe5 f2sbbe1 _16y4lb71y4 _16y4lb742s',
      },
    },
    defaultVariants: {},
    compoundVariants: [],
  }),
  ec = ((e) => (
    (e.Image = 'image'),
    (e.Emoji = 'emoji'),
    (e.ReadOnlyDefault = 'read-only-default'),
    (e.Default = 'default'),
    e
  ))(ec || {});
const IS = new RegExp('(\\p{Emoji_Presentation}|\\p{Extended_Pictographic})', 'giu'),
  uQ = /[\p{Script=Latin}\p{Script=Cyrillic}]+/giu,
  lQ = (e = '', t) =>
    G.useMemo(() => {
      const n = e.split(' ');
      let r = n[0] ?? '';
      const i = new RegExp(IS).test(r),
        o = new RegExp(uQ).test(r),
        a = !i && !o,
        c = t !== void 0 ? t + 1 : '';
      if (i) {
        const s = Array.from(r);
        if (s.length > 1) {
          let l = '';
          for (const u of s)
            if (u.match(IS)) l += u;
            else break;
          r = l;
        }
      } else o && (r = O2(r).charAt(0));
      if (n.length > 1) {
        const s = Number(n[1]);
        if (Number.isInteger(s) && s >= 0) return a ? c : `${r}${s}`;
      }
      return a ? c : r;
    }, [e, t]),
  dQ = 5,
  GM = (e, t) => {
    const n = G.useRef(null),
      r = G.useRef(null);
    return (
      G.useEffect(() => {
        r.current && (r.current.style.fontSize = `${e}px`), n.current && r.current && YM(n, r, e);
      }, [t, e, n, r]),
      { containerRef: n, textRef: r }
    );
  },
  YM = (e, t, n) => {
    var o, a;
    const r = ((o = e.current) == null ? void 0 : o.clientWidth) || 0;
    (((a = t.current) == null ? void 0 : a.clientWidth) || 0) >= r - dQ &&
      t.current &&
      ((n = n - 1), (t.current.style.fontSize = `${n}px`), YM(e, t, n));
  },
  ZM = {
    24: { fontSize: 10, fontWeight: 600 },
    32: { fontSize: 12, fontWeight: 600 },
    48: { fontSize: 14, fontWeight: 700 },
    96: { fontSize: 28, fontWeight: 700 },
  },
  fQ = { 24: 14, 32: 18, 48: 24, 96: 48 },
  ES = Ue.memo(({ accountName: e, accountIndex: t, avatarSize: n }) => {
    const r = lQ(e, t),
      { fontSize: i, fontWeight: o } = ZM[n],
      { textRef: a } = GM(i, e);
    return A.jsx('span', { ref: a, style: { fontSize: i, fontWeight: o }, children: r });
  }),
  hQ = Ue.memo(
    ({
      accountIcon: e,
      accountIndex: t,
      accountName: n,
      avatarSize: r,
      emojiSize: i,
      onError: o,
    }) => {
      const a = { accountName: n, accountIndex: t, avatarSize: r };
      try {
        switch ((e == null ? void 0 : e.type) ?? ec.Default) {
          case ec.Image:
            if (e != null && e.imageUrl)
              return A.jsx(T0, { alt: n, height: r, width: r, src: e.imageUrl });
            throw new Error(aQ);
          case ec.Emoji:
            if (e != null && e.unicode)
              return A.jsx('span', { style: { fontSize: i }, children: e.unicode });
            throw new Error(sQ);
          case ec.ReadOnlyDefault:
            return A.jsx(y3, { size: i });
          default:
            return A.jsx(ES, { ...a });
        }
      } catch (c) {
        return o == null || o(c), A.jsx(ES, { ...a });
      }
    }
  ),
  QM = Ue.memo(
    ({
      accountName: e,
      accountIndex: t,
      accountIcon: n,
      size: r,
      testID: i,
      theme: o = 'secondary',
      onError: a,
      onPress: c,
    }) => {
      const s = fQ[r],
        { fontSize: l } = ZM[r],
        { containerRef: u } = GM(l, e),
        d = b3(cQ, { theme: o }),
        f = m3(d, ft({ size: r, cursor: c ? 'pointer' : 'inherit' }));
      return A.jsx(Dt, {
        ref: u,
        className: f,
        testID: i,
        onPress: c,
        children: A.jsx(hQ, {
          accountIcon: n,
          accountIndex: t,
          accountName: e,
          avatarSize: r,
          emojiSize: s,
          onError: a,
        }),
      });
    }
  );
var pQ =
    '_6dqsqn0 _16y4lb7u6 _16y4lb7v6 _16y4lb7x6 _16y4lb7w6 _16y4lb7qx _16y4lb7pr _16y4lb7s3 _16y4lb7ol _16y4lb7xb _16y4lb7x9 _16y4lb7xd _16y4lb7x7 _16y4lb73kv _16y4lb735v _16y4lb72bv _16y4lb72qv _16y4lb7xf _16y4lb718a _16y4lb7128 _16y4lb71b4 _16y4lb71cq _16y4lb71kj _16y4lb71me _16y4lb71mr _16y4lb71t4 _16y4lb71y4 _16y4lb7212 _16y4lb743m _16y4lb73zw',
  gQ = '_6dqsqn1 _16y4lb7xg';
const yQ = Ue.memo((e) => {
  const t = G.useCallback((n) => Z.captureError(n, te.Account), []);
  return A.jsx(QM, { ...e, onError: t });
});
Ue.memo(({ accountName: e, accountIndex: t, accountIcon: n, onPress: r, onClick: i = r }) => {
  const o = G.useCallback((a) => Z.captureError(a, te.Account), []);
  return A.jsxs('div', {
    className: gQ,
    children: [
      A.jsx(QM, { accountIndex: t, accountName: e, accountIcon: n, size: 96, onError: o }),
      A.jsx('button', {
        type: 'button',
        className: pQ,
        'data-testid': 'edit-avatar-icon',
        onClick: i,
        children: A.jsx(w3, { size: 20 }),
      }),
    ],
  });
});
Ue.memo(({ children: e, withMargin: t }) => {
  const n = t ? 20 : 'auto';
  return A.jsx(Dt, {
    direction: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    marginX: 'auto',
    marginY: n,
    children: e,
  });
});
const Z1 = Ue.memo(({ networkID: e, backgroundColor: t = 'white', ...n }) => {
    const i = `Network${q.getChainName(e)}`;
    return i in _3 ? A.jsx(v3, { ...n, icon: i, shape: 'square', backgroundColor: t }) : null;
  }),
  bQ = (e) => {
    const t = document.createElement('textarea');
    (t.value = e),
      t.setAttribute('readonly', ''),
      (t.style.position = 'absolute'),
      (t.style.left = '-9999px'),
      document.body.appendChild(t);
    const n = document.getSelection().rangeCount > 0 ? document.getSelection().getRangeAt(0) : !1;
    t.select();
    const r = document.execCommand('copy');
    return (
      document.body.removeChild(t),
      n && (document.getSelection().removeAllRanges(), document.getSelection().addRange(n)),
      r
    );
  },
  mQ = (e) => {
    const [t, n] = G.useState(!1),
      r = G.useCallback(() => {
        t || n(bQ(e));
      }, [e, t]);
    return G.useEffect(() => () => n(!1), [e]), [t, r, n];
  },
  JM = (e, t) => {
    const { t: n } = ia(),
      [r, i, o] = mQ(e ?? ''),
      a = r ? n('pastParticipleCopied') : t || n('commandCopy');
    return (
      G.useEffect(() => {
        let c;
        return (
          r &&
            (c = setTimeout(() => {
              o(!1);
            }, 3e3)),
          () => {
            c && clearTimeout(c);
          }
        );
      }, [r, o]),
      { buttonText: a, copied: r, copy: i }
    );
  };
var wQ =
    '_850ypz3 _850ypz2 _16y4lb7td _16y4lb7ud _16y4lb7wd _16y4lb7vd _16y4lb75a _16y4lb73o _16y4lb76w _16y4lb722 _16y4lb71kj _16y4lb71nq _16y4lb7kt',
  _Q = '_850ypz5 _16y4lb71z _16y4lb73l',
  vQ = '_850ypz6 _16y4lb71kj _16y4lb71me _16y4lb71mr',
  SQ =
    '_850ypz7 _16y4lb71kj _16y4lb71nr _16y4lb71t4 _16y4lb71mv _16y4lb71me _16y4lb743m _16y4lb7442';
const TS = 32,
  AQ = Ue.memo(({ chainAddress: e }) => {
    const t = ep(e.address, 4),
      { buttonText: n, copied: r, copy: i } = JM(e.address, t),
      o = G.useMemo(() => q.getNetworkName(e.networkID, !0), [e]);
    return A.jsxs('div', {
      className: SQ,
      onClick: i,
      children: [
        A.jsxs('div', {
          className: ft({ display: 'flex', flexDirection: 'row', alignItems: 'center' }),
          children: [
            A.jsx(Z1, { networkID: e.networkID, size: 24 }),
            A.jsx(Lt, {
              font: 'caption',
              color: 'white',
              style: { maxWidth: 100, marginLeft: 8 },
              children: o,
            }),
          ],
        }),
        A.jsxs('div', {
          className: ft({ display: 'flex', flexDirection: 'row', gap: 8, alignItems: 'center' }),
          children: [
            A.jsx(Lt, { font: 'caption', children: n }),
            r ? A.jsx(S3, { size: 10 }) : A.jsx(k0, { size: 12 }),
          ],
        }),
      ],
    });
  }),
  IQ = ({ account: e, accountName: t, username: n }) =>
    !e || e.addresses.length === 0
      ? A.jsx('div', {
          className: ft({ paddingLeft: 8 }),
          children: A.jsx(cc, { width: 100, font: 'captionSemibold' }),
        })
      : A.jsx(I3, {
          alignment: 'bottomLeft',
          paddingOffset: n ? 14 + TS : TS,
          index: 0,
          content: A.jsx('div', {
            className: wQ,
            children: e.addresses.map((r) =>
              A.jsx(
                AQ,
                { 'data-testid': `account-header-chain-${r.networkID}`, chainAddress: r },
                D2.toKey(r)
              )
            ),
          }),
          closeOnSecondClick: !1,
          children: A.jsxs(Dt, {
            direction: 'row',
            minWidth: 0,
            alignItems: 'center',
            overflow: 'hidden',
            children: [
              A.jsx(Lt, {
                testID: 'home-header-account-name',
                font: 'captionSemibold',
                className: _Q,
                children: t,
                color: 'textPrimary',
                truncate: 'ellipsis',
              }),
              A.jsx('div', { className: vQ, children: A.jsx(k0, { size: 14 }) }),
            ],
          }),
        }),
  EQ = () => {
    const e = W0(),
      { data: t } = ms(),
      { data: n = [] } = eT(),
      r = void 0,
      i = (t == null ? void 0 : t.name) ?? '',
      o = t == null ? void 0 : t.icon,
      a = G.useMemo(() => {
        const s = n.findIndex((l) => l.identifier === (t == null ? void 0 : t.identifier));
        return s === -1 ? void 0 : s;
      }, [t == null ? void 0 : t.identifier, n]),
      c = Ur((s) => s.setWalletState);
    return A.jsxs(Dt, {
      direction: 'row',
      width: '100%',
      gap: 4,
      alignItems: 'center',
      children: [
        A.jsx(yQ, {
          testID: 'settings-menu-open-button',
          accountIcon: o,
          accountIndex: a,
          accountName: i,
          size: 32,
          onPress: () => {
            e.toStack('settings');
          },
        }),
        A.jsxs(Dt, { minWidth: 0, children: [r, A.jsx(IQ, { account: t, accountName: i })] }),
        Qe.renderMode !== 'full-mode' &&
          A.jsx(A3, {
            icon: 'X',
            label: 'close',
            backgroundColor: 'bgTabBar',
            color: 'textSecondary',
            onClick: () => void c(Gt.Closed),
            className: ft({ marginLeft: 'auto' }),
          }),
      ],
    });
  };
function TQ(e, t) {
  if (e == null) throw new Error(t);
  return e;
}
var _c;
class kQ {
  constructor() {
    _t(this, _c, null);
  }
  registerNavigator(t) {
    mt(this, _c, t);
  }
  async navigateToOnboarding() {
    await this.navigator.navigateToOnboarding();
  }
  async navigateToRestoreAccount() {
    await this.navigator.navigateToRestoreAccount();
  }
  get navigator() {
    return TQ(
      ue(this, _c),
      '[WalletNavigator] Must register navigator with registerNavigator() before navigating.'
    );
  }
}
_c = new WeakMap();
const Uh = new kQ(),
  CQ = Ue.lazy(() =>
    Rt(
      () => import('./Settings-BTUYJ3_j.js'),
      __vite__mapDeps([14, 7, 6, 2, 1, 3, 4, 5, 8, 0, 9, 10, 11, 12, 13, 15, 16, 17, 18])
    ).then((e) => ({ default: e.Settings }))
  ),
  Q1 = Qn({
    id: 'settings',
    initialViewId: 'settings',
    display: 'modal',
    views: [{ id: 'settings', element: A.jsx(CQ, {}) }],
    stacks: [],
  }),
  MQ = Ue.lazy(() =>
    Rt(
      () => import('./Detail-DhR_E8Fp.js'),
      __vite__mapDeps([19, 7, 6, 2, 1, 3, 4, 5, 8, 15])
    ).then((e) => ({ default: e.Detail }))
  ),
  PQ = Ue.lazy(() =>
    Rt(() => import('./Main-CCQne_M2.js'), __vite__mapDeps([20, 7, 6, 2, 1, 3, 4, 5, 8])).then(
      (e) => ({ default: e.Main })
    )
  ),
  OQ = Qn({
    id: 'activity',
    initialViewId: 'main',
    views: [
      { id: 'main', element: A.jsx(PQ, {}) },
      { id: 'detail', element: A.jsx(MQ, {}) },
    ],
    stacks: [Q1],
  }),
  rle = {
    location: 0,
    distance: 50,
    threshold: 0.2,
    shouldSort: !0,
    keys: [
      { name: 'token.name', weight: 0.4 },
      { name: 'token.symbol', weight: 0.4 },
      { name: 'token.caip19.chainId', weight: 0.2 },
    ],
  },
  XM = 30,
  ile = 6,
  DQ = 3e4,
  RQ = 5,
  xQ = ['100', '500', '1000'],
  BQ = h.object({
    name: h.string().nullish().default(null),
    symbol: h.string().nullish().default(null),
    decimals: h.number(),
    caip19: Op,
    logoURI: h.string().nullish().default(null),
  }),
  jQ = h.object({ token: BQ, addressType: O0.optional() }),
  iy = h.object({
    id: h.string(),
    name: h.string(),
    tag: h.string(),
    logo: h.string(),
    quote: h
      .object({
        displaySourceAmount: h.string(),
        displayDestinationAmount: h.string(),
        displayFee: h.string(),
      })
      .optional(),
  });
var eP = ((e) => (
  (e.CARD = 'CARD'),
  (e.MOBILE_WALLET = 'MOBILE_WALLET'),
  (e.BANK_TRANSFER = 'BANK_TRANSFER'),
  (e.EXCHANGE = 'EXCHANGE'),
  (e.LOCAL = 'LOCAL'),
  e
))(eP || {});
const J1 = h.object({
  id: h.string(),
  type: h.nativeEnum(eP),
  name: h.string(),
  estimatedArrival: h.string(),
  assets: h.object({ icon: h.string(), roundIcon: h.string() }),
  description: h.string().optional(),
});
h.object({ groups: h.array(h.object({ groupName: h.string(), tokens: h.array(jQ) })) });
h.object({ paymentMethods: h.array(J1), provider: iy.optional() });
h.object({ providers: h.array(iy), paymentMethod: J1, token: Op });
h.object({
  provider: iy,
  paymentMethod: J1,
  location: h.object({ countryCode: h.string(), subdivision: h.string().optional() }).optional(),
  token: Op.optional(),
  tokenAmount: h.string().optional(),
  fiatAmount: h.string().optional(),
  fiatCurrencyCode: h.string().optional(),
  minPurchaseAmount: h.string().optional(),
  maxPurchaseAmount: h.string().optional(),
  quickSelectDenominations: h.array(h.string()).optional(),
});
h.object({ url: h.string(), sessionId: h.string() });
var tP = ((e) => ((e.PENDING = 'PENDING'), (e.COMPLETED = 'COMPLETED'), (e.FAILED = 'FAILED'), e))(
  tP || {}
);
h.object({
  status: h.nativeEnum(tP),
  tokenAmount: h.number().optional(),
  fiatCurrencyCode: h.string().optional(),
  usdFiatAmount: h.number().optional(),
  usdFiatFeeAmount: h.number().optional(),
  fiatFeeAmount: h.number().optional(),
  cryptoTransactionId: h.string().optional(),
  createdAt: h.date().optional(),
  updatedAt: h.date().optional(),
});
class ao extends Error {
  constructor(t) {
    super(t), (this.name = 'FiatRampError');
  }
}
const kS = {
    onClose: () => {},
    context: 'modal',
    fungible: void 0,
    purchaseAmount: '0',
    purchaseType: 'currency',
    isPurchaseAmountValid: !1,
    error: void 0,
    redirectErrorMessage: void 0,
    ownerPublicKey: '',
    price: 0,
    minPurchaseAmountUsd: RQ,
    maxPurchaseAmountUsd: DQ,
    quickSelectDenominations: xQ,
    paymentMethod: void 0,
    provider: void 0,
    checkoutQuoteType: 'recommended',
    redirectURL: void 0,
  },
  ole = aa((e) => ({
    ...kS,
    setState: (t) => e((n) => ({ ...n, ...t })),
    reset: () => {
      e(kS);
    },
  })),
  NQ = (e) => e.sort((t, n) => q.compareNetworkID(t.token.caip19.chainId, n.token.caip19.chainId)),
  CS = new ao('Failed to get FiatRampTokens'),
  UQ = async (e, t, n) => {
    try {
      const r = await ke.api().headers(e).bearer(n).post('/fiat_ramp/v2/onramp/tokens', t);
      if (!hn(r)) throw CS;
      return r.data;
    } catch {
      throw CS;
    }
  },
  Ps = '@phantom/fiat-ramp',
  LQ = `${Ps}:fungibles`,
  zQ = `${Ps}:payment-methods`,
  FQ = `${Ps}:providers`,
  $Q = `${Ps}:recommended-quote`,
  WQ = `${Ps}:status`,
  VQ = `${Ps}:completed`,
  Nf = {
    fiatRampTokens(e, t, n) {
      return [LQ, e, t, n];
    },
    fiatRampPaymentMethods(e, t, n) {
      return [zQ, e, t, n];
    },
    fiatRampProviders(e, t, n) {
      return [FQ, e, t, n];
    },
    fiatRampRecommendedQuote(e, t, n) {
      return [$Q, e, t, n];
    },
    fiatRampStatus(e, t, n) {
      return [WQ, e, t, n];
    },
    fiatRampCompleted(e, t, n) {
      return [VQ, e, t, n];
    },
  },
  KQ = ae({ days: 7 }),
  HQ = ae({ hours: 1 }),
  ale = (e, t, n, r = !0, i) => {
    var p, y;
    const { data: o } = ms(),
      a = Array.from(
        new Set((p = o == null ? void 0 : o.addresses) == null ? void 0 : p.map((b) => b.networkID))
      ),
      c = Array.from(
        new Set(
          (y = o == null ? void 0 : o.addresses) == null ? void 0 : y.map((b) => b.addressType)
        )
      ),
      s = { chainIDs: a },
      l = { 'x-client-platform': e, 'x-client-app-version': t, 'x-client-locale': n },
      { data: u } = ys(),
      d = u == null ? void 0 : u.userID,
      f = u == null ? void 0 : u.accessToken;
    return pt({
      queryKey: Nf.fiatRampTokens(l, s, d),
      queryFn: () => UQ(l, s, f),
      gcTime: KQ,
      staleTime: HQ,
      enabled: r && a.length > 0,
      select: (b) => {
        const m = {
          ...b,
          groups: b.groups.map((w) => ({
            ...w,
            tokens: NQ(w.tokens.filter((_) => (_.addressType ? c.includes(_.addressType) : !0))),
          })),
        };
        return i ? i(m) : m;
      },
    });
  },
  MS = new ao('Failed to get FiatRampPaymentMethods'),
  qQ = async (e, t, n) => {
    try {
      const r = await ke.api().headers(e).bearer(n).post('/fiat_ramp/v2/onramp/payment_methods', t);
      if (!hn(r)) throw MS;
      return r.data;
    } catch {
      throw MS;
    }
  },
  GQ = ae({ days: 7 }),
  YQ = ae({ hours: 1 }),
  sle = (e, t, n, r) => {
    const i = { 'x-client-platform': e, 'x-client-app-version': t, 'x-client-locale': n },
      { data: o } = ys(),
      a = o == null ? void 0 : o.userID,
      c = o == null ? void 0 : o.accessToken;
    return pt({
      queryKey: Nf.fiatRampPaymentMethods(i, r, a),
      queryFn: () => qQ(i, r, c),
      gcTime: GQ,
      staleTime: YQ,
    });
  },
  PS = new ao('Failed to get FiatRampProviders'),
  ZQ = async (e, t, n) => {
    try {
      const r = await ke.api().headers(e).bearer(n).post('/fiat_ramp/v2/onramp/providers', t);
      if (!hn(r)) throw PS;
      return r.data;
    } catch {
      throw PS;
    }
  },
  QQ = ae({ seconds: XM }),
  JQ = ae({ hours: 1 }),
  cle = (e, t, n, r) => {
    const i = { 'x-client-platform': e, 'x-client-app-version': t, 'x-client-locale': n },
      { data: o } = ys(),
      a = o == null ? void 0 : o.userID,
      c = o == null ? void 0 : o.accessToken;
    return pt({
      queryKey: Nf.fiatRampProviders(i, r, a),
      queryFn: () => ZQ(i, r, c),
      gcTime: JQ,
      staleTime: QQ,
      enabled: !!r.destinationAddress,
    });
  },
  OS = new ao('Failed to get FiatRampRecommendedQuote'),
  XQ = async (e, t, n) => {
    try {
      const r = await ke
        .api()
        .headers(e)
        .bearer(n)
        .post('/fiat_ramp/v2/onramp/recommended_quote', t);
      if (!hn(r)) throw OS;
      return r.data;
    } catch {
      throw OS;
    }
  },
  eJ = ae({ days: 7 }),
  tJ = ae({ hours: 1 }),
  ule = (e, t, n, r, i = !0) => {
    const o = { 'x-client-platform': e, 'x-client-app-version': t, 'x-client-locale': n },
      { data: a } = ys(),
      c = a == null ? void 0 : a.userID,
      s = a == null ? void 0 : a.accessToken;
    return pt({
      queryKey: Nf.fiatRampRecommendedQuote(o, r, c),
      queryFn: () => XQ(o, r, s),
      gcTime: eJ,
      staleTime: tJ,
      enabled: i,
    });
  },
  DS = new ao('Failed to get ramp status'),
  nJ = async (e, t, n) => {
    try {
      const r = await ke.api().headers(e).bearer(n).post('/fiat_ramp/v2/onramp/event_status', t);
      if (!hn(r)) throw DS;
      return r.data;
    } catch {
      throw DS;
    }
  },
  rJ = ae({ seconds: XM }),
  iJ = ae({ hours: 1 }),
  lle = (e, t, n, r) => {
    const i = { 'x-client-platform': e, 'x-client-app-version': t, 'x-client-locale': n },
      { data: o } = ys(),
      a = o == null ? void 0 : o.userID,
      c = o == null ? void 0 : o.accessToken;
    return pt({
      enabled: !!r,
      queryKey: Nf.fiatRampStatus(i, r, a),
      queryFn: () => nJ(i, { sessionId: r }, c),
      gcTime: iJ,
      staleTime: rJ,
      refetchInterval: 1e4,
    });
  },
  oJ = ({ marginBottom: e = 0 }) => {
    const { t } = ia(),
      {
        data: [n],
      } = D0(['enable-buy-flow-warning']);
    return n
      ? A.jsx(Dt, {
          marginBottom: e,
          children: A.jsx(E3, { level: '4-error', children: t('buyFlowHealthWarning') }),
        })
      : null;
  },
  aJ = ({ networkID: e, address: t }) => {
    const n = sJ({ networkID: e, address: t });
    return n ? A.jsx(T3, { children: n, size: 'small' }) : null;
  },
  sJ = ({ networkID: e, address: t }) => {
    var i, o;
    const n = x5();
    return ((o = (i = E6.get(e)).badge) == null ? void 0 : o.call(i, e, n, t)) ?? null;
  };
ae({ seconds: 10 });
const cJ = {
  location: 0,
  distance: 50,
  threshold: 0.2,
  shouldSort: !0,
  keys: [
    { name: 'data.name', weight: 0.4 },
    { name: 'data.symbol', weight: 0.4 },
    { name: 'data.chain.name', weight: 0.1 },
    { name: 'data.tokenAddress', weight: 0.1 },
  ],
};
({ ...cJ });
const dle = { maximumFractionDigits: 2, minimumFractionDigits: 2 };
var nP = ((e) => (
  (e.hiddenMints = 'hiddenMints'),
  (e.splTokenMap = 'splTokenMap'),
  (e.tokenPrices = 'tokenPrices'),
  (e.tokens = 'tokens'),
  (e.transferFungibleLoggingContext = 'transferFungibleLoggingContext'),
  (e.transferTransaction = 'transferTransaction'),
  (e.unwrapTransaction = 'unwrapTransaction'),
  (e.minimumRequiredBalance = 'minimumRequiredBalance'),
  (e.solanaBalance = 'solanaBalance'),
  (e.fungibleDetail = 'fungibleDetail'),
  (e.fungibleHoldings = 'fungibleHoldings'),
  (e.swapperDiscovery = 'swapperDiscovery'),
  e
))(nP || {});
function uJ(e) {
  return e.map((t) => `${t.networkID}/${t.address}`).sort();
}
function RS(e) {
  return ['tokens', uJ(e)];
}
const ea = {
    swapperDiscovery(e) {
      return ['swapperDiscovery', e];
    },
    hiddenMints(e) {
      return ['hiddenMints', { accountId: e }];
    },
    splTokenMap: ['splTokenMap'],
    tokenPrices(e) {
      return ['tokenPrices', { tokenIds: e }];
    },
    tokens(e) {
      return RS(e);
    },
    tokensErrorCount(e) {
      return [...RS(e), 'tokensError'];
    },
    minimumRequiredBalance(e) {
      return ['minimumRequiredBalance', { chainAddress: e }];
    },
    solanaBalance(e) {
      return ['solanaBalance', { chainAddress: e }];
    },
    transferFungibleLoggingContext(e) {
      return ['transferFungibleLoggingContext', { fungibleKey: e }];
    },
    transferTransaction(e) {
      return ['transferTransaction', e];
    },
    unwrapTransaction({ caip19: e, amount: t, owner: n }) {
      return ['unwrapTransaction', { caip19: e, amount: t, owner: n }];
    },
    fungibleDetail({ caip19: e }) {
      return ['fungibleDetail', { caip19: e }];
    },
    fungibleHoldings({ caip19: e, walletAddress: t }) {
      return ['fungibleHoldings', { caip19: e, walletAddress: t }];
    },
  },
  lJ = ['asc', 'desc'],
  dJ = h.enum(lJ),
  fJ = ['rank', 'volume', 'price', 'price-change', 'market-cap'],
  hJ = h.enum(fJ),
  pJ = ['1h', '24h', '7d', '30d'];
h.enum(pJ);
const gJ = h
  .object({
    chainId: oa,
    address: h.string(),
    name: h.string(),
    symbol: h.string().default(''),
    logoUrl: h.string().optional(),
    marketCap: h.number().optional(),
    volume: h.number().optional(),
    price: h.number().optional(),
    priceChange: h.number().optional(),
    volumeChange: h.number().optional(),
  })
  .transform((e) => ({ ...e, symbol: e.symbol || e.name }));
h.object({ items: B0(gJ), sortBy: hJ, sortDirection: dJ });
var oy = ((e) => (
  (e.Verified = 'VERIFIED'),
  (e.NotVerified = 'NOT_VERIFIED'),
  (e.PossibleSpam = 'POSSIBLE_SPAM'),
  (e.Spam = 'SPAM'),
  e
))(oy || {});
const rP = h.nativeEnum(oy),
  nt = h.object({
    chain: R2,
    decimals: h.number(),
    logoUri: h.string().nullish().default(null),
    name: h.string().nullish().default(null),
    symbol: h.string().nullish().default(null),
    spamStatus: rP.optional().default(oy.NotVerified),
    marketCap: h.number().optional(),
    volume24hUsd: h.number().optional(),
  });
var iP = ((e) => (
  (e.Website = 'website'), (e.Telegram = 'telegram'), (e.X = 'x'), (e.Discrod = 'discord'), e
))(iP || {});
const yJ = h.object({ type: h.nativeEnum(iP), url: h.string() });
var Uf = ((e) => (
  (e.transferFeeConfig = 'transferFeeConfig'),
  (e.interestBearingConfig = 'interestBearingConfig'),
  (e.permanentDelegate = 'permanentDelegate'),
  (e.transferHook = 'transferHook'),
  (e.tokenMetadata = 'tokenMetadata'),
  (e.mintCloseAuthority = 'mintCloseAuthority'),
  (e.metadataPointer = 'metadataPointer'),
  (e.groupMemberPointer = 'groupMemberPointer'),
  (e.nonTransferable = 'nonTransferable'),
  e
))(Uf || {});
const bJ = h.object({
    extension: h.literal('interestBearingConfig'),
    state: h.object({
      currentRate: h.number(),
      initializationTimestamp: h.number(),
      lastUpdateTimestamp: h.number(),
      preUpdateAverageRate: h.number(),
      rateAuthority: h.string(),
    }),
    meta: h.object({ amountPrincipal: h.string() }).optional(),
  }),
  mJ = h.object({
    extension: h.literal('transferFeeConfig'),
    state: h.object({ newerTransferFee: h.object({ transferFeeBasisPoints: h.number() }) }),
  }),
  wJ = h.object({
    extension: h.literal('permanentDelegate'),
    state: h.object({ delegate: h.string() }),
  }),
  _J = h.object({
    extension: h.literal('transferHook'),
    state: h.object({ authority: h.string(), programId: h.string() }),
  }),
  vJ = h.object({
    extension: h.literal('tokenMetadata'),
    state: h.object({
      additionalMetadata: h.array(h.array(h.string())),
      mint: h.string(),
      name: h.string(),
      symbol: h.string(),
      updateAuthority: h.string(),
      uri: h.string(),
    }),
  }),
  SJ = h.object({
    extension: h.literal('mintCloseAuthority'),
    state: h.object({ closeAuthority: h.string() }),
  }),
  AJ = h.object({
    extension: h.literal('groupMemberPointer'),
    state: h.object({ authority: h.string(), memberAddress: h.string() }),
  }),
  IJ = h.object({
    extension: h.literal('metadataPointer'),
    state: h.object({ authority: h.string(), metadataAddress: h.string() }),
  }),
  EJ = h.object({ extension: h.literal('nonTransferable') }),
  oP = h.union([bJ, mJ, wJ, _J, vJ, SJ, IJ, AJ, EJ]),
  fle = nt.merge(
    h.object({
      address: h.string().nullish(),
      description: h.string().nullish(),
      logoURI: h.string().nullish(),
      links: h.array(yJ).nullish(),
      marketCap: h.number({ coerce: !0 }).nullish(),
      totalSupply: h.number({ coerce: !0 }).nullish(),
      circulatingSupply: h.number({ coerce: !0 }).nullish(),
      maxSupply: h.number({ coerce: !0 }).nullish(),
      holders: h.number().nullish(),
      volume24hUSD: h.number({ coerce: !0 }).nullish(),
      volume24hUSDChangePercentage: h.number().nullish(),
      trades24h: h.number().nullish(),
      trades24hChangePercentage: h.number().nullish(),
      uniqueWallets24h: h.number().nullish(),
      uniqueWallets24hChangePercentage: h.number().nullish(),
      top10HoldersPercent: h.number().nullish(),
      mintable: h.boolean().nullish(),
      freezable: h.boolean().nullish(),
      mutableMetadata: h.boolean().nullish(),
      ownershipRenounced: h.boolean().nullish(),
      updateAuthority: h.string().nullish(),
      freezeAuthority: h.string().nullish(),
      spamStatus: rP.optional().default(oy.NotVerified),
      mintExtensions: B0(oP).nullish(),
      createdDate: h.string().datetime().nullish().default(null),
      categories: h
        .object({ id: h.string(), name: h.string(), imageUri: h.string(), numTokens: h.number() })
        .array()
        .optional(),
    })
  );
h.object({ code: h.string(), message: h.string() });
const TJ = h.object({
    usd: h.number().optional(),
    usd_24h_change: h.number().optional(),
    price: h.number().optional(),
    priceChange24h: h.number().optional(),
    currencyValue: h.number().optional(),
    currencyChange: h.number().optional(),
    lastUpdatedAt: h.string().datetime().optional(),
  }),
  kJ = [
    h.literal('1H'),
    h.literal('1D'),
    h.literal('1W'),
    h.literal('1M'),
    h.literal('YTD'),
    h.literal('ALL'),
  ];
h.union(kJ)
  .nullish()
  .transform((e) => e ?? '1D');
const CJ = [
  h.literal('1m'),
  h.literal('5m'),
  h.literal('1h'),
  h.literal('4h'),
  h.literal('1d'),
  h.literal('1w'),
  h.literal('4w'),
  h.literal('1mo'),
];
h.union(CJ)
  .nullish()
  .transform((e) => e ?? '1d');
const MJ = h.object({ unixTime: h.number(), value: h.string() });
h.object({ history: h.array(MJ) });
function PJ(e, t) {
  return +(((t - e) / e) * 100 || 0).toFixed(2);
}
function OJ({ balance: e, priceId: t, priceMap: n }) {
  var c, s;
  const r = t ? ((c = n[t]) == null ? void 0 : c.usd) : void 0,
    i = t ? ((s = n[t]) == null ? void 0 : s.usd_24h_change) : void 0;
  if (r === void 0) return { usd: void 0, usd_24h_change: void 0, price: r };
  const o = e.multipliedBy(r);
  let a;
  return (
    i !== void 0 && (a = o.minus(o.dividedBy(1 + i / 100))),
    {
      usd: o.toNumber(),
      usd_24h_change: a == null ? void 0 : a.toNumber(),
      price: r,
      priceChange24h: i,
      currencyValue: o.toNumber(),
      currencyChange: a == null ? void 0 : a.toNumber(),
    }
  );
}
const DJ = new Sc({
    [Oe.Solana]: {},
    [Oe.Ethereum]: {},
    [Oe.Polygon]: {},
    [Oe.Base]: {},
    [Oe.Arbitrum]: {},
    [Oe.Monad]: { pricesDisabled: !0 },
    [Oe.Bitcoin]: {},
    [Oe.Sui]: {},
    [Oe.Hypercore]: {},
  }),
  RJ = Ac(DJ);
var X1 = ((e) => (
    (e[(e.Always = 1 / 0)] = 'Always'),
    (e[(e.Short = ae({ days: 1 }))] = 'Short'),
    (e[(e.Medium = ae({ days: 3 }))] = 'Medium'),
    (e[(e.Long = ae({ days: 7 }))] = 'Long'),
    (e[(e.VeryLong = ae({ days: 30 }))] = 'VeryLong'),
    (e[(e.Never = 0)] = 'Never'),
    e
  ))(X1 || {}),
  ew = ((e) => (
    (e[(e.Immediate = 0)] = 'Immediate'),
    (e[(e.VeryShort = ae({ seconds: 1 }))] = 'VeryShort'),
    (e[(e.Short = ae({ seconds: 15 }))] = 'Short'),
    (e[(e.Medium = ae({ minutes: 3 }))] = 'Medium'),
    (e[(e.Long = ae({ minutes: 5 }))] = 'Long'),
    (e[(e.VeryLong = ae({ minutes: 10 }))] = 'VeryLong'),
    (e[(e.Never = 1 / 0)] = 'Never'),
    e
  ))(ew || {}),
  tw = ((e) => (
    (e[(e.VeryShort = ae({ seconds: 2 }))] = 'VeryShort'),
    (e[(e.Short = ae({ seconds: 15 }))] = 'Short'),
    (e[(e.Medium = ae({ minutes: 3 }))] = 'Medium'),
    (e[(e.Long = ae({ minutes: 5 }))] = 'Long'),
    e
  ))(tw || {});
const xJ = ae({ seconds: 10 }),
  BJ = { gcTime: X1.Short, staleTime: ew.Short },
  jJ = 'prices',
  aP = (e, t) => {
    var i;
    if (!Np(e)) return;
    const r = (i = e.response) == null ? void 0 : i.status;
    (!r || (r >= 400 && r < 500 && r !== 404)) &&
      (Z.addBreadcrumb(jJ, e.message, Te.Info, t), Z.captureError(e, te.Prices));
  },
  NJ = h.object({
    price: h.number(),
    priceChange24h: h.number(),
    lastUpdatedAt: h.string().datetime().optional(),
  }),
  xS = h.object({ prices: h.record(x2, NJ) });
async function UJ({ tokens: e }) {
  try {
    const t = e.filter((a) => {
        var c;
        return !((c = RJ.get(a.chainId)) != null && c.pricesDisabled);
      }),
      n = { tokens: t.map((a) => ({ token: a })) };
    let r = '/price/v1',
      i;
    const o = ke.timeout(xJ).retry(1, 200).validateStatus(!0).api();
    if (t.length === 0) return {};
    if (t.length === 1) {
      const a = t[0];
      (r += `/${a.chainId}`),
        a.resourceType === sn.nativeToken
          ? (r += `/nativeToken/${a.slip44}`)
          : (r += `/address/${a.address}`);
      const c = await o.get(r);
      i = xS.parse({ prices: { [to(a)]: c.data } });
    } else {
      const a = await o.post(r, n);
      i = xS.parse(a.data);
    }
    return LJ(i.prices);
  } catch (t) {
    throw (aP(t), t);
  }
}
function LJ(e) {
  const t = {};
  for (const n of Object.keys(e)) {
    const { price: r, priceChange24h: i, lastUpdatedAt: o } = e[n],
      a = { price: r, usd: r, usd_24h_change: i, lastUpdatedAt: o };
    t[n] = a;
  }
  return t;
}
const bh = 'prices',
  Mo = {
    price: (e) => [bh, { id: e }],
    priceError: () => [bh, 'error'],
    priceHistory: (e, t) => [bh, e, t],
    priceHistoryInterval: (e, t, n, r) => [bh, e, t, n, ...(r ? [r] : [])],
    tempPrices: (e) => ['tempPrices', e],
  };
ae({ minutes: 1 }),
  ae({ minutes: 5 }),
  ae({ hours: 1 }),
  ae({ hours: 4 }),
  ae({ days: 1 }),
  ae({ days: 7 }),
  ae({ days: 28 }),
  ae({ days: 30 });
var zJ = ((e) => (
    (e.NonFungible = 'NonFungible'),
    (e.SemiFungible = 'SemiFungible'),
    (e.Fungible = 'Fungible'),
    (e.NonFungibleEdition = 'NonFungibleEdition'),
    (e.ProgrammableNonFungible = 'ProgrammableNonFungible'),
    (e.ProgrammableNonFungibleEdition = 'ProgrammableNonFungibleEdition'),
    e
  ))(zJ || {}),
  FJ = ((e) => (
    (e.ERC20 = 'ERC20'),
    (e.ERC721 = 'ERC721'),
    (e.ERC777 = 'ERC777'),
    (e.ERC1155 = 'ERC1155'),
    (e.ERC4626 = 'ERC4626'),
    (e.unknown = 'unknown'),
    e
  ))(FJ || {}),
  Re = ((e) => (
    (e.BRC20 = 'BRC20'),
    (e.ERC20 = 'ERC20'),
    (e.SPL = 'SPL'),
    (e.CompressedSPL = 'CompressedSPL'),
    (e.SuiCoin = 'SuiCoin'),
    (e.SolanaNative = 'SolanaNative'),
    (e.EthereumNative = 'EthereumNative'),
    (e.PolygonNative = 'PolygonNative'),
    (e.MonadNative = 'MonadNative'),
    (e.BaseNative = 'BaseNative'),
    (e.ArbitrumNative = 'ArbitrumNative'),
    (e.BitcoinNative = 'BitcoinNative'),
    (e.SuiNative = 'SuiNative'),
    (e.HypercoreNative = 'HypercoreNative'),
    e
  ))(Re || {});
const $J = [
    'BitcoinNative',
    'EthereumNative',
    'PolygonNative',
    'MonadNative',
    'SolanaNative',
    'BaseNative',
    'ArbitrumNative',
    'SuiNative',
    'HypercoreNative',
  ],
  ht = h.object({ walletAddress: h.string(), amount: h.string() }),
  WJ = h.object({ type: h.literal('SolanaNative'), data: nt }),
  VJ = h.object({ type: h.literal('SolanaNative'), data: nt.merge(ht) }),
  KJ = h.object({ type: h.literal('EthereumNative'), data: nt }),
  HJ = h.object({ type: h.literal('EthereumNative'), data: nt.merge(ht) }),
  qJ = h.object({ type: h.literal('PolygonNative'), data: nt }),
  GJ = h.object({ type: h.literal('PolygonNative'), data: nt.merge(ht) }),
  YJ = h.object({ type: h.literal('BaseNative'), data: nt }),
  ZJ = h.object({ type: h.literal('BaseNative'), data: nt.merge(ht) }),
  QJ = h.object({ type: h.literal('ArbitrumNative'), data: nt }),
  JJ = h.object({ type: h.literal('ArbitrumNative'), data: nt.merge(ht) }),
  XJ = h.object({ type: h.literal('MonadNative'), data: nt }),
  eX = h.object({ type: h.literal('MonadNative'), data: nt.merge(ht) }),
  tX = h.object({ type: h.literal('SuiNative'), data: nt }),
  nX = h.object({ type: h.literal('SuiNative'), data: nt.merge(ht) }),
  rX = h.object({ type: h.literal('HypercoreNative'), data: nt }),
  iX = h.object({ type: h.literal('HypercoreNative'), data: nt.merge(ht) }),
  oX = h.object({ type: h.literal('BitcoinNative'), data: nt }),
  aX = h.object({ type: h.literal('BitcoinNative'), data: nt.merge(ht) });
var sP = ((e) => ((e.PreDeploy = 'preDeploy'), (e.Graduated = 'graduated'), e))(sP || {});
const sX = h.object({ programId: h.string(), status: h.nativeEnum(sP) }),
  as = nt.extend({
    mintAddress: h.string(),
    splTokenAccountPubkey: h.string(),
    programId: h.string(),
    mintExtensions: B0(oP).optional(),
    ugcTokenMeta: sX.optional(),
  });
h.object({ type: h.literal('SPL'), data: as });
const cX = h.object({ type: h.literal('SPL'), data: as.merge(ht) }),
  uX = h.object({
    type: h.literal('CompressedSPL'),
    data: as.merge(ht).omit({ splTokenAccountPubkey: !0 }),
  }),
  lX = h.object({
    type: h.literal('SPL'),
    data: as.omit({ splTokenAccountPubkey: !0, programId: !0 }),
  }),
  nw = nt.extend({ contractAddress: h.string() }),
  dX = h.object({ type: h.literal('ERC20'), data: nw }),
  fX = h.object({ type: h.literal('ERC20'), data: nw.merge(ht) }),
  rw = nt.extend({
    firstCreatedTransactionHash: h.string().optional(),
    firstCreatedInscriptionId: h.string(),
  }),
  hX = h.object({ type: h.literal('BRC20'), data: rw }),
  pX = h.object({ type: h.literal('BRC20'), data: rw.merge(ht) }),
  cP = nt.extend({ contractAddress: h.string() }),
  gX = h.object({ type: h.literal('SuiCoin'), data: cP }),
  uP = nt.extend({ contractAddress: h.string() });
h.object({ type: h.literal('SuiCoin'), data: uP });
const yX = h.object({ type: h.literal('SuiCoin'), data: uP.merge(ht) }),
  bX = h.discriminatedUnion('type', [pX, fX, cX, uX, yX, VJ, HJ, GJ, ZJ, JJ, eX, aX, nX, iX]);
h.union([hX, dX, lX, WJ, KJ, qJ, YJ, QJ, XJ, oX, tX, gX, rX]);
const mX = h.object({
    code: h.string(),
    message: h.string(),
    details: h.object({ chainId: oa, address: h.string() }),
  }),
  Cn = TJ.extend({
    balance: h.instanceof(oe),
    key: h.string(),
    tokenAddress: h.string().optional(),
    externalUrl: h.string().optional(),
  }),
  wX = h.union([
    h.object({ type: h.literal('SolanaNative'), data: h.intersection(nt.merge(ht), Cn) }),
    h.object({ type: h.literal('SPL'), data: h.intersection(as.merge(ht), Cn) }),
    h.object({
      type: h.literal('CompressedSPL'),
      data: h.intersection(as.merge(ht).omit({ splTokenAccountPubkey: !0 }), Cn),
    }),
  ]),
  _X = h.union([
    h.object({ type: h.literal('EthereumNative'), data: h.intersection(nt.merge(ht), Cn) }),
    h.object({ type: h.literal('ERC20'), data: h.intersection(nw.merge(ht), Cn) }),
    h.object({ type: h.literal('PolygonNative'), data: h.intersection(nt.merge(ht), Cn) }),
    h.object({ type: h.literal('BaseNative'), data: h.intersection(nt.merge(ht), Cn) }),
    h.object({ type: h.literal('ArbitrumNative'), data: h.intersection(nt.merge(ht), Cn) }),
    h.object({ type: h.literal('MonadNative'), data: h.intersection(nt.merge(ht), Cn) }),
    h.object({ type: h.literal('HypercoreNative'), data: h.intersection(nt.merge(ht), Cn) }),
  ]),
  vX = h.union([
    h.object({ type: h.literal('BitcoinNative'), data: h.intersection(nt.merge(ht), Cn) }),
    h.object({ type: h.literal('BRC20'), data: h.intersection(rw.merge(ht), Cn) }),
  ]),
  SX = h.union([
    h.object({ type: h.literal('SuiNative'), data: h.intersection(nt.merge(ht), Cn) }),
    h.object({ type: h.literal('SuiCoin'), data: h.intersection(cP.merge(ht), Cn) }),
  ]);
h.union([wX, _X, vX, SX]);
var lP = ((e) => (
  (e.NOT_ONBOARDED = 'not_onboarded'),
  (e.ONBOARDING = 'onboarding'),
  (e.ONBOARDED = 'onboarded'),
  (e.ONBOARDING_FAILED = 'onboarding_failed'),
  e
))(lP || {});
h.object({ status: h.nativeEnum(lP), averageCost: h.string({ coerce: !0 }).optional() });
let dP = class fP extends Error {
  constructor(n) {
    super(n);
    Le(this, 'statusCode', 400);
    Object.setPrototypeOf(this, fP.prototype), (this.name = 'FungibleError');
  }
  getMessage() {
    return `Something went wrong: ${this.message}`;
  }
};
var Lf = ((e) => ((e.CONFIRMATION = 'CONFIRMATION'), (e.SUBMISSION = 'SUBMISSION'), e))(Lf || {});
const Os = {
    sendSuccessCondition: Lf.CONFIRMATION,
    formDisplayPrecision: 4,
    minimumSendableCurrencyAmount: 0.01,
    nonNativeFungibleTokenType: Re.ERC20,
  },
  AX = {
    ...Os,
    nativeFungibleTokenType: Re.ArbitrumNative,
    nativeTokenFungibleBalanceKey: function (e) {
      return this.nativeFungibleTokenType;
    },
    alwaysShowNetworkBadge: !0,
  },
  IX = {
    ...Os,
    nativeFungibleTokenType: Re.BaseNative,
    nativeTokenFungibleBalanceKey: function (e) {
      return this.nativeFungibleTokenType;
    },
    alwaysShowNetworkBadge: !0,
  },
  EX = {
    sendSuccessCondition: Lf.SUBMISSION,
    formDisplayPrecision: 6,
    minimumSendableCurrencyAmount: 0.5,
    nativeFungibleTokenType: Re.BitcoinNative,
    nonNativeFungibleTokenType: Re.BRC20,
    nativeTokenFungibleBalanceKey: function (e, t) {
      if (t !== void 0) return `${Re.BitcoinNative}-${t}`;
    },
    alwaysShowNetworkBadge: !1,
  },
  TX = {
    ...Os,
    nativeFungibleTokenType: Re.EthereumNative,
    nativeTokenFungibleBalanceKey(e) {
      return this.nativeFungibleTokenType;
    },
    alwaysShowNetworkBadge: !1,
  },
  kX = {
    ...Os,
    nativeFungibleTokenType: Re.HypercoreNative,
    nativeTokenFungibleBalanceKey: function (e) {
      return this.nativeFungibleTokenType;
    },
    alwaysShowNetworkBadge: !1,
  },
  CX = {
    ...Os,
    nativeFungibleTokenType: Re.MonadNative,
    nativeTokenFungibleBalanceKey: function (e) {
      return this.nativeFungibleTokenType;
    },
    alwaysShowNetworkBadge: !1,
    isPriceDetailSupported: !1,
  },
  MX = {
    ...Os,
    nativeFungibleTokenType: Re.PolygonNative,
    nativeTokenFungibleBalanceKey: function (e) {
      return this.nativeFungibleTokenType;
    },
    alwaysShowNetworkBadge: !1,
  },
  PX = {
    sendSuccessCondition: Lf.CONFIRMATION,
    formDisplayPrecision: 4,
    minimumSendableCurrencyAmount: 0.01,
    nativeFungibleTokenType: Re.SolanaNative,
    nonNativeFungibleTokenType: Re.SPL,
    nativeTokenFungibleBalanceKey: function (e) {
      return this.nativeFungibleTokenType;
    },
    alwaysShowNetworkBadge: !1,
  },
  OX = {
    nativeFungibleTokenType: Re.SuiNative,
    nativeTokenFungibleBalanceKey: function (e) {
      return this.nativeFungibleTokenType;
    },
    alwaysShowNetworkBadge: !1,
    isPriceDetailSupported: !0,
    sendSuccessCondition: Lf.CONFIRMATION,
    formDisplayPrecision: 9,
    minimumSendableCurrencyAmount: 0,
    nonNativeFungibleTokenType: Re.SuiCoin,
  },
  DX = new Sc({
    [Oe.Solana]: PX,
    [Oe.Ethereum]: TX,
    [Oe.Polygon]: MX,
    [Oe.Base]: IX,
    [Oe.Arbitrum]: AX,
    [Oe.Bitcoin]: EX,
    [Oe.Monad]: CX,
    [Oe.Sui]: OX,
    [Oe.Hypercore]: kX,
  }),
  fc = Ac(DX);
function iw(e) {
  return e.resourceType === sn.nativeToken
    ? fc.get(e.chainId).nativeFungibleTokenType
    : fc.get(e.chainId).nonNativeFungibleTokenType;
}
function gi(e) {
  return !!e && $J.includes(e);
}
function ow(e) {
  if (gi(e.type))
    return e.type === Re.BitcoinNative
      ? `${e.type}-${br(e.data.chain.id, e.data.walletAddress)}`
      : e.type;
  switch (e.type) {
    case Re.SPL:
    case Re.CompressedSPL:
      return e.data.mintAddress ?? '';
    case Re.ERC20:
    case Re.SuiCoin:
      return e.data.contractAddress;
    case Re.BRC20: {
      const t = br(e.data.chain.id, e.data.walletAddress);
      return `${e.data.firstCreatedInscriptionId}-${t}`;
    }
  }
}
function RX(e, t) {
  const n = iw(e);
  if (gi(n)) return n === Re.BitcoinNative && t !== void 0 ? [`${n}-${br(e.chainId, t)}`] : [n];
  if (n === Re.SPL && e.resourceType === sn.address) return [e.address];
  if (n === Re.ERC20 && e.resourceType === sn.address) return [e.address];
  if (n === Re.BRC20 && e.resourceType === sn.address) return B2.map((r) => `${e.address}-${r}`);
  if (n === Re.SuiCoin && e.resourceType === sn.address) return [e.address];
}
var ay = ((e) => (
    (e[(e.Always = 1 / 0)] = 'Always'),
    (e[(e.Short = ae({ days: 1 }))] = 'Short'),
    (e[(e.Medium = ae({ days: 3 }))] = 'Medium'),
    (e[(e.Long = ae({ days: 7 }))] = 'Long'),
    e
  ))(ay || {}),
  sy = ((e) => (
    (e[(e.Immediate = 0)] = 'Immediate'),
    (e[(e.Short = ae({ minutes: 1 }))] = 'Short'),
    (e[(e.Medium = ae({ minutes: 2.5 }))] = 'Medium'),
    (e[(e.Long = ae({ minutes: 5 }))] = 'Long'),
    (e[(e.Never = 1 / 0)] = 'Never'),
    e
  ))(sy || {}),
  hP = ((e) => (
    (e[(e.Short = ae({ minutes: 1 }))] = 'Short'),
    (e[(e.Medium = ae({ minutes: 2.5 }))] = 'Medium'),
    (e[(e.Long = ae({ minutes: 5 }))] = 'Long'),
    e
  ))(hP || {});
const xX = (e, t, n, r) => {
    (!t || (t >= 400 && t < 500)) &&
      (Z.addBreadcrumb(n, e.message, Te.Info, r), Z.captureError(e, te.Fungibles));
  },
  BX = (e) => e / 100,
  jX = (e) => e.extension === Uf.transferFeeConfig,
  NX = (e) => e.extension === Uf.interestBearingConfig;
function UX(e) {
  return q.isSolanaNetworkID(e.data.chain.id);
}
function LX(e) {
  return q.isEVMNetworkID(e.data.chain.id);
}
function zX(e) {
  return q.isSuiNetworkID(e.data.chain.id);
}
function FX(e) {
  return q.isBitcoinNetworkID(e.data.chain.id);
}
const aw = (e) =>
  'data' in e && e.data && 'mintExtensions' in e.data
    ? e.data.mintExtensions || []
    : 'chainData' in e && e.chainData && 'mintExtensions' in e.chainData
      ? e.chainData.mintExtensions || []
      : [];
function hle(e) {
  var r;
  if (!e) return;
  const t = aw(e),
    n =
      (r = t == null ? void 0 : t.find(jX)) == null
        ? void 0
        : r.state.newerTransferFee.transferFeeBasisPoints;
  return n ? BX(n) : void 0;
}
function pP(e) {
  if (!e) return;
  const t = aw(e);
  return t == null ? void 0 : t.find(NX);
}
function $X(e) {
  return e
    ? aw(e).reduce((r, i) => (i.extension === Uf.transferHook ? i.state.programId : r), void 0)
    : void 0;
}
const BS = new oe('31556736'),
  jS = new oe('10000'),
  WX = 17,
  NS = (e) => new oe(Math.exp(e.toNumber()));
class VX {
  constructor(t) {
    Le(this, 'initializationTimestamp');
    Le(this, 'preUpdateAverageRate');
    Le(this, 'lastUpdateTimestamp');
    Le(this, 'currentRate');
    (this.initializationTimestamp = new oe(t.initializationTimestamp)),
      (this.preUpdateAverageRate = new oe(t.preUpdateAverageRate)),
      (this.lastUpdateTimestamp = new oe(t.lastUpdateTimestamp)),
      (this.currentRate = new oe(t.currentRate));
  }
  preUpdateTimespan() {
    return this.lastUpdateTimestamp.minus(this.initializationTimestamp);
  }
  preUpdateExp() {
    const n = new oe(this.preUpdateAverageRate).times(this.preUpdateTimespan()).div(BS).div(jS);
    return NS(n);
  }
  postUpdateTimespan(t) {
    return t.minus(this.lastUpdateTimestamp);
  }
  postUpdateExp(t) {
    const r = new oe(this.currentRate).times(this.postUpdateTimespan(t)).div(BS).div(jS);
    return NS(r);
  }
  totalScale(t, n) {
    var r;
    return (r = this.preUpdateExp()) == null ? void 0 : r.times(this.postUpdateExp(n)).div(Ec(t));
  }
  amountToUiAmount(t, n, r) {
    return new oe(t)
      .times(this.totalScale(n, new oe(r)))
      .precision(WX)
      .decimalPlaces(n)
      .toString();
  }
}
const KX = (e) => {
    var s;
    if (e.type !== Re.SPL) return e;
    const t = (s = pP(e)) == null ? void 0 : s.state;
    if (!t) return e;
    const { amount: n, mintExtensions: r } = e.data,
      i = new VX(t),
      o = Date.now() / 1e3,
      a = i.amountToUiAmount(n, 0, o),
      c = r
        ? r == null
          ? void 0
          : r.map((l) =>
              l.extension === Uf.interestBearingConfig ? { ...l, meta: { amountPrincipal: n } } : l
            )
        : void 0;
    return { ...e, data: { ...e.data, amount: a, mintExtensions: c } };
  },
  HX = (e, t) => {
    const n = pP(e);
    if (!n || !n.meta) return t;
    const r = new oe(e.data.amount),
      i = new oe(n.meta.amountPrincipal);
    return new oe(t).times(i).div(r).decimalPlaces(0);
  };
new dP('Failed to get fungible tokens for addresses');
async function qX(e) {
  const { addresses: t, analytics: n, enableSolCompressedTokens: r = !1 } = e;
  try {
    const i = await ke
      .api()
      .headers({ 'Content-Type': 'application/json' })
      .timeout(ae({ seconds: 20 }))
      .post(
        '/tokens/v1',
        { addresses: t },
        { params: r ? { isSolCompressedTokensEnabled: 'true' } : void 0 }
      );
    if (i.status !== 200) throw new Nw({ key: 'TokensNotLoading' });
    const o = await i.data,
      a = [],
      c = [];
    let s = !1;
    for (const l of o.tokens) {
      const u = bX.safeParse(l);
      if (u.success) {
        const d = KX(u.data);
        a.push(d);
      } else s = !0;
    }
    return (
      o.errors.forEach((l) => {
        const u = mX.safeParse(l);
        u.success && c.push(u.data);
      }),
      c.length === 0 &&
        o.isTrimmed &&
        c.push({
          code: 'TokensTrimmed',
          message: '',
          details: { chainId: Hi.Mainnet, address: 'unknown' },
        }),
      c.length &&
        n.capture('getBalanceRequestError', { data: { chains: c.map((l) => l.details.chainId) } }),
      s && Z.captureError(new Error('fungibles failed to parse some items'), te.Fungibles),
      { tokens: a, errors: c, isTrimmed: o.isTrimmed }
    );
  } catch {
    throw new Nw({ key: 'TokensNotLoading' });
  }
}
function gP({
  select: e,
  chainAddresses: t = [],
  queryOptions: n = { staleTime: sy.Short, refetchInterval: hP.Long },
}) {
  const r = ea.tokens(t),
    i = ea.tokensErrorCount(t),
    o = qp(),
    a = Dp(),
    {
      data: [c],
    } = D0(['enable-sol-compressed-tokens']);
  return pt({
    queryKey: r,
    enabled: t.length > 0 && t.every((s) => !q.isLocalNetworkID(s.networkID)),
    gcTime: ay.Medium,
    staleTime: n.staleTime,
    refetchInterval: n.refetchInterval,
    refetchOnReconnect: !0,
    networkMode: 'always',
    retry: !1,
    select: e,
    async queryFn({ queryKey: s }) {
      try {
        const l = t.map(SG),
          u = await qX({ addresses: l, analytics: o, enableSolCompressedTokens: k3() ? !1 : c });
        if (u.errors.length > 0 && !u.isTrimmed) {
          const d = a.getQueryData(s);
          if (d)
            for (const f of u.errors) {
              const p = d.tokens.filter((y) => y.data.chain.id === f.details.chainId);
              u.tokens.push(...p);
            }
        }
        return a.removeQueries({ queryKey: i }), u;
      } catch (l) {
        const u = a.getQueryData(i) ?? 0;
        throw (a.setQueryData(i, u + 1), l);
      }
    },
  });
}
function GX({ chainAddresses: e, keys: t, queryOptions: n }) {
  const r = G.useCallback(
    ({ tokens: i }) => (!t || !t.length ? i : i.filter((o) => t.includes(ow(o)))),
    [t]
  );
  return gP({ select: r, chainAddresses: e, queryOptions: n });
}
ae({ days: 30 });
FM([Wb(32, 'mint'), Wb(32, 'owner'), PY('amount'), Wb(93)]);
const Hb = h.object({ feerate: h.string() }),
  US = h.object({ conservative: Hb, economical: Hb, unset: Hb }),
  YX = h.object({
    recommended: h.object({ priceEstimates: US }),
    bitcoin_rpc: h.object({ priceEstimates: US }),
  }),
  ZX = h.object({ gasPriceSources: YX }),
  QX = new oe('1.25'),
  JX = new oe('1.5'),
  XX = async (e, t = !0) => {
    let n, r, i;
    try {
      const { priceEstimates: o } = (await eee(e)).gasPriceSources.recommended,
        { conservative: a, economical: c, unset: s } = o;
      (n = new oe(a.feerate)), (r = new oe(c.feerate)), (i = new oe(s.feerate));
    } catch (o) {
      if (!t) throw o;
      const a = await Cs(e).estimateSmartFee(2, 'ECONOMICAL');
      (i = new oe(a.feerate)), (r = i.times(QX)), (n = i.times(JX));
    }
    return {
      [_n.fast]: { btcPerKilobyte: n.multipliedBy(1) },
      [_n.standard]: { btcPerKilobyte: r.multipliedBy(1) },
      [_n.slow]: { btcPerKilobyte: i.multipliedBy(1) },
    };
  };
async function eee(e) {
  const t = `https://gas-price-oracle.phantom.app/?chainId=${e}`,
    n = await ke.headers({ 'Content-Type': 'application/json' }).get(t);
  return ZX.parse(n.data);
}
const sw = 'gas-estimation',
  tee = 3,
  nee = 600,
  ree = ae({ seconds: 30 }),
  yP = ({
    networkID: e,
    enableFallback: t = !1,
    retry: n = tee,
    retryDelay: r = nee,
    enabled: i = !0,
  }) =>
    pt({
      queryFn: async () => {
        try {
          if (!e) throw new Error('Missing networkID');
          if (q.isBitcoinNetworkID(e)) return await XX(e, t);
          if (q.isEVMNetworkID(e)) return await ST(e, t);
          if (q.isSolanaNetworkID(e))
            throw new Error('Transaction speeds is not supported for Solana.');
          if (q.isSuiNetworkID(e)) throw new lI('transaction speeds to unit cost');
          return Sn(e);
        } catch (o) {
          throw (
            (o instanceof vT ||
              (Z.addBreadcrumb(sw, `enableFallback: ${t}, networkID: ${e}`, Te.Info),
              Z.captureError(o, te.Transaction)),
            o)
          );
        }
      },
      queryKey: lo.transactionSpeedsToUnitCost(e),
      refetchOnMount: 'always',
      retry: n,
      retryDelay: r,
      staleTime: ree,
      enabled: i && !!e && (q.isEVMNetworkID(e) || q.isBitcoinNetworkID(e)),
      placeholderData: j2,
    }),
  iee = ae({ seconds: 30 }),
  oee = ae({ minutes: 5 }),
  aee = (e) =>
    pt({
      queryKey: lo.transactionAdditionalCosts(e),
      queryFn: async () => {
        if (!e) return new oe(0);
        const t = rs.get(e.networkID).additionalTransactionCost;
        return t ? await t(e) : new oe(0);
      },
      enabled: !!e,
      staleTime: iee,
      gcTime: oee,
    }),
  see = async (e, t) => {
    const n = Nc(e),
      r = await $o.eth_estimateGas(n, [t]);
    if ('error' in r) throw new Error(`[${r.error.code}] ${r.error.message}`);
    return new oe(r.result);
  };
new oe(21e3);
const cee = 6,
  uee = 600,
  lee = ae({ seconds: 5 }),
  dee = ae({ days: 1 }),
  fee = (e, t = !0) =>
    pt({
      queryFn: async () => {
        if (!e) throw new Error('Args is required for calculating transaction units.');
        try {
          return await hee(e);
        } catch (r) {
          throw (
            (Z.addBreadcrumb(sw, `networkId: ${e == null ? void 0 : e.networkID}`, Te.Info),
            Z.captureError(r, te.Transaction),
            r)
          );
        }
      },
      queryKey: lo.transactionUnitAmount(e),
      enabled: !!e && (q.isEVMNetworkID(e.networkID) || q.isBitcoinNetworkID(e.networkID)) && t,
      retry: cee,
      retryDelay: uee,
      staleTime: lee,
      gcTime: dee,
    }),
  hee = async (e) => {
    if (pM(e)) {
      const { gas: t } = e.unsignedTransaction;
      if (t) return { gasLimit: new oe(t, 16) };
      {
        const n = await see(e.networkID, e.unsignedTransaction);
        return { gasLimit: new oe(AT(n)) };
      }
    } else if (hM(e)) {
      const t = e.psbtChain,
        n = t ? new oe(Zh(t.map((i) => i.additionalCost.vb.toNumber()))) : new oe(0),
        r = t ? new oe(Zh(t.map((i) => i.additionalCost.sats.toNumber()))) : new oe(0);
      return { virtualBytes: new oe(e.vb), additionalCosts: { vb: n, sats: r } };
    } else
      throw new Error(
        `Unsupported transaction networkId: ${e.networkID} for calculating transaction units.`
      );
  },
  pee = 6,
  gee = 600,
  yee = ae({ seconds: 5 }),
  bee = ae({ days: 1 }),
  mee = [_n.fast, _n.standard, _n.slow],
  wee = (e) => {
    if (!e) return _n.fast;
    for (const t of mee) if (e[t]) return t;
    throw new Error('No valid transaction speeds found.');
  },
  ple = (e) => {
    var l;
    const t = See(e),
      n = (l = e == null ? void 0 : e.queryOptions) == null ? void 0 : l.refetchInterval,
      { data: r, isError: i } = fee(e == null ? void 0 : e.multichainTransaction, t),
      { data: o } = yP({
        networkID: e == null ? void 0 : e.networkID,
        enableFallback: !0,
        refetchInterval: n,
      }),
      { data: a } = aee(e == null ? void 0 : e.multichainTransaction),
      c = vee(e, r, o);
    return pt({
      queryFn: async () => {
        try {
          if (!e) throw new Error('Missing args');
          const { multichainTransaction: u, transactionSpeed: d = _n.standard } = e;
          if (!u) throw new Error('Multichain transaction is null.');
          if (i && cw(e.networkID))
            throw new Error('Transaction unit amount is required but errored.');
          if (pM(u) || hM(u)) {
            if (!o) throw new Error('Missing transactionSpeedsToUnitCost');
            if (!r) throw new Error('Missing transactionUnit');
            const f = d === 'fastest' ? wee(o) : d,
              p = o[f];
            if (!p) throw new Error(`Missing transactionSpeedsToUnitCost for ${d}`);
            return vG(u.networkID, p, r, a);
          }
          if (sq(u))
            return u.networkID === Hi.Localnet
              ? { networkID: u.networkID, value: 0, highFees: !1 }
              : await WY(
                  u.networkID,
                  u.transaction.map((p) => ('version' in p ? p.message : p.compileMessage()))
                );
          if (cq(u)) return await hY(u);
          Sn(u);
        } catch (u) {
          throw (
            (Z.addBreadcrumb(sw, `chainId: ${e == null ? void 0 : e.networkID}`, Te.Info),
            Z.captureError(u, te.Transaction),
            u)
          );
        }
      },
      queryKey: lo.gasEstimation(
        e == null ? void 0 : e.networkID,
        e == null ? void 0 : e.multichainTransaction,
        e == null ? void 0 : e.transactionSpeed,
        a
      ),
      enabled: c,
      retry: pee,
      retryDelay: gee,
      refetchInterval: n,
      staleTime: yee,
      gcTime: bee,
      placeholderData: (u) => u,
    });
  };
function cw(e) {
  return q.isBitcoinNetworkID(e) || q.isEVMNetworkID(e)
    ? !0
    : q.isSolanaNetworkID(e) || q.isSuiNetworkID(e)
      ? !1
      : Sn();
}
function _ee(e) {
  return q.isBitcoinNetworkID(e) || q.isEVMNetworkID(e)
    ? !0
    : q.isSolanaNetworkID(e) || q.isSuiNetworkID(e)
      ? !1
      : Sn();
}
function vee(e, t, n) {
  if (!e) return !1;
  const { networkID: r, multichainTransaction: i } = e;
  return i ? (!!t || !cw(r)) && (!!n || !_ee(r)) : !1;
}
function See(e) {
  return e ? cw(e.networkID) : !1;
}
const Aee = function (e, t = 0) {
  let n = 3735928559 ^ t,
    r = 1103547991 ^ t;
  for (let i = 0, o; i < e.length; i++)
    (o = e.charCodeAt(i)), (n = Math.imul(n ^ o, 2654435761)), (r = Math.imul(r ^ o, 1597334677));
  return (
    (n = Math.imul(n ^ (n >>> 16), 2246822507)),
    (n ^= Math.imul(r ^ (r >>> 13), 3266489909)),
    (r = Math.imul(r ^ (r >>> 16), 2246822507)),
    (r ^= Math.imul(n ^ (n >>> 13), 3266489909)),
    4294967296 * (2097151 & r) + (n >>> 0)
  );
};
function Iee(e) {
  return { caip19: Eee(e) };
}
function Eee(e) {
  return typeof e == 'string' ? Rp(e) : e;
}
function Tee(e) {
  return e.data.map(Iee);
}
const kee = 500;
async function Cee({ queryClient: e, queries: t }) {
  const n = {};
  try {
    const r = {},
      i = [];
    for (const l of t) {
      const u = l.caip19,
        d = to(u);
      if (r[d]) continue;
      r[d] = !0;
      const f = Mo.price(d),
        p = e.getQueryState(f);
      if (p && Date.now() - p.dataUpdatedAt < BJ.staleTime) {
        n[d] = p.data;
        continue;
      }
      i.push(u);
    }
    const o = await Promise.allSettled(P0(i, kee).map((l) => UJ({ tokens: l }))),
      a = [],
      c = o.some((l) => l.status === 'rejected'),
      s = o.reduce((l, u) => (u.status === 'rejected' ? l : { ...l, ...u.value }), {});
    for (const l of i) {
      const u = to(l);
      let d = s[u];
      const f = Mo.price(u);
      !d && c && (d = e.getQueryData(f)),
        d && (n[u] = d),
        a.push(() => {
          const p = d ?? null;
          e.setQueryData(f, p, { updatedAt: Date.now() });
        });
    }
    if (c) {
      const l = e.getQueryData(Mo.priceError()) ?? 0;
      e.setQueryData(Mo.priceError(), l + 1);
    } else e.removeQueries({ queryKey: Mo.priceError() });
    Mee(a, 50);
  } catch (r) {
    aP(r);
  }
  return n;
}
function Mee(e, t) {
  const n = e.length;
  let r = 0;
  function i() {
    const o = e.slice(r, r + t);
    fI.batch(() => {
      o.forEach((a) => a());
    }),
      (r += t),
      r < n && setTimeout(i, 0);
  }
  i();
}
const Pee = (e) =>
    typeof e == 'string' ? e : e.resourceType === 'nativeToken' ? e.slip44 : e.address,
  Oee = (e, t) => e.localeCompare(t),
  Dee = (e) => {
    const t = e.map(Pee).sort(Oee).join(',');
    return Aee(t);
  },
  Ree = ({
    query: e,
    enabled: t = !0,
    key: n,
    queryOptions: r = { refetchInterval: tw.Short },
    queryClient: i,
  }) => {
    const { refetchInterval: o } = r,
      a = Tee(e),
      c = t && e != null && e.data.length > 0;
    return {
      queryKey: Mo.tempPrices(n),
      staleTime: ew.Immediate,
      gcTime: X1.Never,
      refetchInterval: o,
      queryFn: () => Cee({ queryClient: i, queries: a }),
      enabled: c,
    };
  };
function xee({ query: e, enabled: t = !0, queryOptions: n = { refetchInterval: tw.Short } }) {
  const r = Dp(),
    i = G.useMemo(() => Dee(e.data), [e]);
  return pt(Ree({ query: e, enabled: t, key: i, queryOptions: n, queryClient: r }));
}
const Bee = () => pt({ queryKey: Mo.priceError(), initialData: 0 });
ae({ days: 5 });
const jee = (e, t, n = !1) => {
  const r = Dp();
  return G.useCallback(
    (o, a, c) => {
      if (o === void 0) return;
      const s = lo.timestamps(),
        u = r.getQueryData(s) || {
          [o]: { chainId: t, transactionType: e, isLedger: n, transactionId: o, timestamps: {} },
        },
        d = u[o];
      if (d != null && d.timestamps[a]) return;
      const f = {
        ...u,
        [o]: {
          ...(d || {
            chainId: t,
            transactionType: e,
            isLedger: n,
            transactionId: o,
            timestamps: {},
          }),
          timestamps: { ...((d == null ? void 0 : d.timestamps) ?? {}), [a]: c ?? Date.now() },
        },
      };
      r.setQueryData(s, f);
    },
    [t, n, r, e]
  );
};
var LS = Object.prototype.hasOwnProperty;
function zS(e, t, n) {
  for (n of e.keys()) if (ja(n, t)) return n;
}
function ja(e, t) {
  var n, r, i;
  if (e === t) return !0;
  if (e && t && (n = e.constructor) === t.constructor) {
    if (n === Date) return e.getTime() === t.getTime();
    if (n === RegExp) return e.toString() === t.toString();
    if (n === Array) {
      if ((r = e.length) === t.length) for (; r-- && ja(e[r], t[r]); );
      return r === -1;
    }
    if (n === Set) {
      if (e.size !== t.size) return !1;
      for (r of e)
        if (((i = r), (i && typeof i == 'object' && ((i = zS(t, i)), !i)) || !t.has(i))) return !1;
      return !0;
    }
    if (n === Map) {
      if (e.size !== t.size) return !1;
      for (r of e)
        if (
          ((i = r[0]), (i && typeof i == 'object' && ((i = zS(t, i)), !i)) || !ja(r[1], t.get(i)))
        )
          return !1;
      return !0;
    }
    if (n === ArrayBuffer) (e = new Uint8Array(e)), (t = new Uint8Array(t));
    else if (n === DataView) {
      if ((r = e.byteLength) === t.byteLength) for (; r-- && e.getInt8(r) === t.getInt8(r); );
      return r === -1;
    }
    if (ArrayBuffer.isView(e)) {
      if ((r = e.byteLength) === t.byteLength) for (; r-- && e[r] === t[r]; );
      return r === -1;
    }
    if (!n || typeof e == 'object') {
      r = 0;
      for (n in e)
        if ((LS.call(e, n) && ++r && !LS.call(t, n)) || !(n in t) || !ja(e[n], t[n])) return !1;
      return Object.keys(t).length === r;
    }
  }
  return e !== e && t !== t;
}
function Nee(e, t) {
  const n = G.useRef(Ki());
  pt({
    queryKey: ['PENDING-TX-POLLER', e],
    enabled: e.length > 0,
    queryFn: () => PG(e, t),
    refetchInterval: () =>
      Ki().diff(n.current, 'seconds') < 30
        ? 5 * 1e3
        : Ki().diff(n.current, 'minutes') < 2
          ? 15 * 1e3
          : Ki().diff(n.current, 'minutes') < 5
            ? 30 * 1e3
            : !1,
  });
}
Ki.extend(dI);
const gle = (e) => {
  const t = so(),
    n = G.useRef([]),
    r = G.useRef([]);
  G.useEffect(() => {
    (n.current = []), (r.current = []);
  }, [e]);
  const i = lo.pendingTransactions(e),
    o = async () => {
      const a = await Ms(t),
        c = nG(a, e);
      if (!ja(c, n.current)) {
        const s = n.current.filter((l) => !c.find((u) => u.id === l.id));
        ja(s, r.current) || (r.current = s), (n.current = c);
      }
      return { pendingTransaction: n.current, removedPendingTransactions: r.current };
    };
  return (
    Nee(e, t),
    pt({
      queryKey: i,
      queryFn: o,
      refetchInterval: 1e3,
      staleTime: 500,
      gcTime: 0,
      refetchOnMount: !0,
      enabled: !!e.length,
    })
  );
};
_n.fast + '', _n.standard + '', _n.slow + '';
const Uee = rI(so, (e) => JG(new QG(e))),
  Lee = 'transactions-utxo-state',
  zee = 6,
  Fee = 600,
  $ee = ae({ seconds: 30 }),
  Wee = ae({ seconds: 5 }),
  Vee = ae({ minutes: 10 }),
  bP = (e) => {
    const t = Uee();
    return pt({
      queryFn: Kee(e, t),
      queryKey: lo.utxoState(e),
      enabled: Hee(e),
      retry: zee,
      retryDelay: Fee,
      refetchInterval: $ee,
      staleTime: Wee,
      gcTime: Vee,
    });
  };
function Kee(e, t) {
  return async () => {
    var n;
    try {
      if (!e) throw new Error('chainAddress not provided when fetching utxo state.');
      if (hI(e)) {
        await t.refetchUtxos(e);
        const [r, i, o] = await Promise.all([
          t.getSafeToSendUtxos(e.address),
          t.getInscribedUtxos(e.address),
          t.getRareSatsUtxos(e.address),
        ]);
        return { safeToSendUtxos: r, inscribedUtxos: i, rareSatsUtxos: o };
      } else
        throw new Error(`Unsupported chain address type for fetching utxo state: ${e.addressType}`);
    } catch (r) {
      if (Np(r)) {
        const i = (n = r.response) == null ? void 0 : n.status;
        xM(r, i, Lee);
      }
      throw r;
    }
  };
}
function Hee(e) {
  return !!e && hI(e);
}
const qee = async (e) => {
    try {
      return await Jp(ce.Ethereum.Mainnet).resolveName(e);
    } catch (t) {
      return console.error(t), null;
    }
  },
  Gee = async (e, t) => {
    const n = '/uns/v1/resolve';
    try {
      const r = await ke
        .api()
        .headers({ 'Content-Type': 'application/json' })
        .post(n, { query: e, chainId: t });
      if (!hn(r)) throw k_;
      const i = r.data;
      if (i.address === '' || i.status !== 'OK') throw k_;
      return i.address;
    } catch {
      return null;
    }
  },
  Yee = async (e, t) => {
    try {
      if (!q.isSolanaNetworkID(t)) return null;
      const n = wM(t),
        r = Co(n),
        o = await new C4.TldParser(r).getOwnerFromDomainTld(e);
      return o ? o.toString() : null;
    } catch {
      return null;
    }
  },
  Zee = async (e, t) => {
    try {
      if (!q.isSuiNetworkID(t)) return null;
      const n = ks(t);
      return (
        (e.toLowerCase().endsWith('.sui') && (await n.resolveNameServiceAddress({ name: e }))) ||
        null
      );
    } catch {
      return null;
    }
  };
function yle(e, t) {
  const n = e == null ? void 0 : e.toLowerCase(),
    r = mP(n, t),
    i = r.error,
    o = G.useMemo(
      () =>
        i === f1
          ? Et.t('sendFormErrorInvalidDomain')
          : i === pj
            ? Et.t('sendFormErrorInvalidSolanaAddress')
            : i === gj
              ? Et.t('sendFormErrorInvalidTwitterHandle')
              : i === _T
                ? Et.t('sendFormErrorInvalidUsername')
                : '',
      [i]
    );
  return { ...r, error: o };
}
function mP(e, t) {
  const n = EE(),
    r = qp(),
    i = !!e && !!t,
    o = lo.resolveDomainName(e, t);
  return pt({
    queryKey: o,
    queryFn: async () => {
      if (!e || !t) throw fj;
      const c = await ete(e, t, n, r);
      return {
        address: (c == null ? void 0 : c.owner) ?? null,
        type: (c == null ? void 0 : c.type) ?? null,
        handle: e,
      };
    },
    enabled: i,
  });
}
const Qee = async (e, t) => {
    try {
      if (e.startsWith('@') || !q.isEVMNetworkID(t)) return null;
      const [n] = H6(e);
      if (n) {
        const r = await qee(e);
        if (!r) throw f1;
        return r;
      }
      return null;
    } catch (n) {
      return (
        Z.captureError(
          n instanceof Error ? n : new Error(`Unable to resolve EVM domain: ${e}`),
          te.Transaction
        ),
        null
      );
    }
  },
  Jee = async (e, t, n) => {
    try {
      if (e.startsWith('@') || !q.isSolanaNetworkID(t)) return null;
      const [r, i, o] = K6(e);
      (r || i || o) && n.capture('resolveDomainBonfida');
      const a = r || i || o;
      let c = null;
      if (a && ((c = await Gee(e, t)), !c)) throw f1;
      return c;
    } catch (r) {
      return (
        Z.captureError(
          r instanceof Error ? r : new Error(`Unable to resolve solana domain: ${e}`),
          te.Transaction
        ),
        null
      );
    }
  },
  Xee = async (e, t, n) => {
    var r, i;
    try {
      if (!e.startsWith('@')) return null;
      const o = e.slice(1),
        a = await n.getUserProfileByUsername(o),
        c =
          ((r = a == null ? void 0 : a.username) == null ? void 0 : r.toLowerCase()) ===
          o.toLowerCase(),
        s = a != null && a.addresses ? ((i = a.addresses) == null ? void 0 : i[t]) !== void 0 : !1,
        l = !!a && c && s;
      let u = null;
      if (l && ((u = a.addresses[t]), !u)) throw _T;
      return u;
    } catch (o) {
      return (
        Z.captureError(
          o instanceof Error ? o : new Error(`Unable to resolve username: ${e}`),
          te.Auth
        ),
        null
      );
    }
  };
async function ete(e, t, n, r) {
  const i = Un.isFeatureEnabled('kill-suins'),
    o = [
      { type: 'username', fetch: Xee(e, t, n) },
      { type: 'solana', fetch: Jee(e, t, r) },
      { type: 'evm', fetch: Qee(e, t) },
      { type: 'ans', fetch: Yee(e, t) },
    ];
  i || o.push({ type: 'suins', fetch: Zee(e, t) });
  const a = await Promise.all(o.map(({ fetch: s }) => s)),
    c = a.findIndex((s) => s !== null);
  return c === -1 ? null : { type: o[c].type, owner: a[c] };
}
function tte(e, t) {
  const n = e == null ? void 0 : e.toLowerCase(),
    { data: r } = mP(n, t);
  return (r == null ? void 0 : r.address) || e;
}
const nte = ae({ seconds: 5 }),
  FS = async (e, t, n = 1, r = nte, i = 2) => {
    try {
      const o = await Cs(e).getRawTransaction(t);
      return o.confirmations && (o == null ? void 0 : o.confirmations) >= n
        ? o
        : (await Xi(r), FS(e, t, n, r, i));
    } catch (o) {
      if (o instanceof Error && i > 0) return await Xi(r), await FS(e, t, n, r, i - 1);
      throw o;
    }
  };
var Mn = ((e) => (
    (e.Verified = 'VERIFIED'),
    (e.NotVerified = 'NOT_VERIFIED'),
    (e.PossibleSpam = 'POSSIBLE_SPAM'),
    (e.Spam = 'SPAM'),
    e
  ))(Mn || {}),
  yi = ((e) => (
    (e.Visible = 'visible'),
    (e.Hidden = 'hidden'),
    (e.VisibleNotSpam = 'visible:reported_notSpam'),
    (e.HiddenSpam = 'hidden:reported_spam'),
    e
  ))(yi || {});
class uw extends Error {
  constructor(t) {
    super(t), Object.setPrototypeOf(this, uw.prototype), (this.name = 'FungibleError');
  }
}
class wP extends Error {
  constructor(t) {
    super(t), Object.setPrototypeOf(this, wP.prototype), (this.name = 'CollectibleError');
  }
}
var _P = ((e) => ((e.AccountIdToHiddenMints = 'accountIdToHiddenMints'), e))(_P || {}),
  rte = ((e) => (
    (e.AccountIdToVisibilitySettings = 'accountIdToCollectibleVisibilitySettings'),
    (e.HiddenCollections = 'hiddenCollections'),
    (e.UnhiddenCollections = 'unhiddenCollections'),
    e
  ))(rte || {});
function ite(e) {
  return e.map((t) => (typeof t == 'string' ? { mintId: t, status: yi.Hidden } : t));
}
function ote(e) {
  return e
    ? e.version === 2
      ? e
      : {
          version: 2,
          value: Object.entries(e.value).reduce((t, [n, r]) => ((t[n] = ite(r)), t), {}),
        }
    : null;
}
async function ate(e) {
  try {
    return ote(await e.get(_P.AccountIdToHiddenMints));
  } catch {
    throw new uw('Failed to get visibility overrides');
  }
}
function ste(e) {
  return new Map(
    e.map((t) => (typeof t == 'string' ? [t, { mintId: t, status: yi.Hidden }] : [t.mintId, t]))
  );
}
async function vP(e, t) {
  var i;
  const r = (((i = await ate(e)) == null ? void 0 : i.value) ?? {})[t] ?? [];
  return ste(r);
}
function SP({ visibilityStatus: e, spamStatus: t }) {
  return e === yi.HiddenSpam ? Mn.PossibleSpam : e === yi.VisibleNotSpam ? Mn.NotVerified : t;
}
function cte(e, { spamStatus: t }) {
  if (!e) return t;
  const { status: n } = e;
  return SP({ visibilityStatus: n, spamStatus: t });
}
function ble(e, { key: t, spamStatus: n }) {
  const r = e == null ? void 0 : e.get(t);
  return ute(r, { spamStatus: n });
}
function ute(e, { spamStatus: t }) {
  if (!e) return t;
  const { status: n } = e;
  return SP({ visibilityStatus: n, spamStatus: t });
}
function mle(e) {
  return e === Mn.PossibleSpam || e === Mn.Spam;
}
function lte(e, { key: t, spamStatus: n }) {
  const r = e == null ? void 0 : e.get(t);
  return dte(r, { spamStatus: n });
}
function dte(e, { spamStatus: t }) {
  if (!e && (t === Mn.PossibleSpam || t === Mn.Spam)) return !0;
  if (!e) return !1;
  const { status: n } = e;
  return n === yi.Hidden || n === yi.HiddenSpam;
}
function fte(e, { key: t, spamStatus: n }) {
  return !lte(e, { key: t, spamStatus: n });
}
function wle(e, { key: t, spamStatus: n }) {
  const r = e == null ? void 0 : e.get(t);
  return hte(r, { spamStatus: n });
}
function hte(e, { spamStatus: t }) {
  if (!e && (t === Mn.PossibleSpam || t === Mn.Spam)) return !0;
  if (!e) return !1;
  const { status: n } = e;
  return pte(n);
}
function pte(e) {
  return e === yi.Hidden || e === yi.HiddenSpam;
}
function gte(e) {
  const t = so();
  return pt(yte(t, e ?? ''));
}
function yte(e, t) {
  return {
    gcTime: ay.Long,
    staleTime: sy.Never,
    enabled: !!t && !!e,
    queryKey: ea.hiddenMints(t ?? ''),
    async queryFn() {
      return !t || !e ? new Map() : await vP(e, t);
    },
  };
}
function bte(e) {
  let t, n;
  for (const { data: r } of e) {
    const { usd: i, usd_24h_change: o } = r;
    i !== void 0 && (t = t !== void 0 ? t + i : i), o !== void 0 && (n = n !== void 0 ? n + o : o);
  }
  return { value: t, earnings: n };
}
function mte(e, t) {
  return e
    .getQueriesData({ predicate: (r) => r.queryKey[0] === nP.transferFungibleLoggingContext })
    .map(([, r]) => r)
    .filter((r) => {
      if (!r) return !1;
      const { previousBalance: i, fungibleKey: o } = r,
        a = t.get(o);
      return a ? !a.data.balance.isEqualTo(i) : !1;
    });
}
const $S = [
    X.Solana,
    X.EVM,
    X.Sui,
    X.BitcoinTaproot,
    X.BitcoinNativeSegwit,
    X.BitcoinNestedSegwit,
    X.BitcoinLegacy,
  ],
  WS = pI(br);
function wte(e, t) {
  const n = WS(e.data.chain.id, e.data.walletAddress),
    r = WS(t.data.chain.id, t.data.walletAddress),
    i = $S.indexOf(n) - $S.indexOf(r);
  return i === 0 ? 0 : i < 0 ? -1 : 1;
}
const _te = pI(wte);
function vte(e, t) {
  return t.data.balance.comparedTo(e.data.balance);
}
const VS = '￿';
function Ste(e, t) {
  var i, o;
  const n = ((i = e.data.name) == null ? void 0 : i.toUpperCase()) ?? VS,
    r = ((o = t.data.name) == null ? void 0 : o.toUpperCase()) ?? VS;
  return n.localeCompare(r);
}
function Ate(e, t) {
  const n = e.data.usd ?? Number.NEGATIVE_INFINITY,
    r = t.data.usd ?? Number.NEGATIVE_INFINITY;
  return n > r ? -1 : n < r ? 1 : 0;
}
function Ite(e, t) {
  const n = e.data.spamStatus,
    r = t.data.spamStatus,
    i = (c) => {
      switch (c) {
        case Mn.Verified:
          return 4;
        case Mn.NotVerified:
          return 3;
        case Mn.PossibleSpam:
          return 2;
        case Mn.Spam:
          return 1;
      }
    },
    o = i(n),
    a = i(r);
  return o > a ? -1 : o < a ? 1 : 0;
}
const KS = '￿';
function Ete(e, t) {
  var i, o;
  const n = ((i = e.data.symbol) == null ? void 0 : i.toUpperCase()) ?? KS,
    r = ((o = t.data.symbol) == null ? void 0 : o.toUpperCase()) ?? KS;
  return n.localeCompare(r);
}
function Tte(e, t) {
  const n = gi(e.type),
    r = gi(t.type);
  return n !== r ? (n ? -1 : 1) : q.compareNetworkID(e.data.chain.id, t.data.chain.id);
}
const kte = (e, t) => {
    const n = Ate(e, t);
    if (n) return n;
    const r = Ite(e, t);
    if (r) return r;
    const i = vte(e, t);
    if (i) return i;
    const o = Tte(e, t);
    if (o) return o;
    const a = _te(e, t);
    if (a) return a;
    const c = Ste(e, t);
    return c || Ete(e, t);
  },
  lw = (e) => {
    const t = e.data.chain.id;
    if (gi(e.type)) return { chainId: t, slip44: q.getSlip44(t), resourceType: sn.nativeToken };
    {
      let n;
      switch (e.type) {
        case Re.SPL:
        case Re.CompressedSPL:
          n = e.data.mintAddress;
          break;
        case Re.ERC20:
        case Re.SuiCoin:
          n = e.data.contractAddress;
          break;
        case Re.BRC20:
          n = e.data.firstCreatedInscriptionId;
          break;
      }
      return { chainId: t, address: n, resourceType: sn.address };
    }
  },
  Cte = (e, t) => {
    const n = ea.transferFungibleLoggingContext(e);
    t.removeQueries({ queryKey: n });
  };
oe.config({ EXPONENTIAL_AT: 1e3, DECIMAL_PLACES: 78 });
const Mte = (e, t) => new oe(e).div(Ec(t));
function Pte({ tokens: e, priceMap: t }) {
  const n = [];
  for (const r of e) {
    const { amount: i, decimals: o } = r.data,
      a = lw(r),
      c = to(a),
      s = ow(r),
      l = Mte(i, o),
      u = { type: r.type, data: { ...r.data, balance: l, key: s } };
    let d;
    const f = OJ({ priceId: c, balance: l, priceMap: t });
    if (r.type === Re.SPL || r.type === Re.CompressedSPL) {
      const { mintAddress: p } = r.data;
      d = p;
    } else if (r.type === Re.ERC20 || r.type === Re.SuiCoin) {
      const { contractAddress: p } = r.data;
      d = p;
    } else if (r.type === Re.BRC20) {
      const { firstCreatedInscriptionId: p } = r.data;
      d = p;
    }
    (u.data.tokenAddress = d),
      (u.data.usd = f.usd),
      (u.data.price = f.price),
      (u.data.usd_24h_change = f.usd_24h_change),
      (u.data.priceChange24h = f.priceChange24h),
      (u.data.currencyChange = f.currencyChange),
      (u.data.currencyValue = f.currencyValue),
      n.push(u);
  }
  return n;
}
function AP({
  showHiddenMints: e = !1,
  keys: t,
  enablePrices: n = !0,
  enableSorting: r = !0,
  usePricesQueryOptions: i,
  useTokenQueryOptions: o,
} = {}) {
  const { data: a } = ms(),
    {
      data: c = [],
      isPending: s,
      isRefetching: l,
      refetch: u,
      isError: d,
      error: f,
    } = GX({ chainAddresses: a == null ? void 0 : a.addresses, keys: t, queryOptions: o }),
    { data: p, isPending: y, isRefetching: b } = gte(a == null ? void 0 : a.identifier),
    { query: m } = G.useMemo(() => ({ query: { data: c.map(lw) } }), [c]),
    {
      data: w,
      isPending: _,
      isRefetching: S,
      refetch: E,
      isError: O,
    } = xee({
      query: m,
      enabled: n && !s && (a == null ? void 0 : a.identifier) != null,
      queryOptions: i,
    }),
    { fungibles: N, fungibleMap: F } = G.useMemo(() => {
      const I = e
        ? c
        : c.filter((R) => {
            const L = ow(R),
              H = (t || []).includes(L),
              ie = fte(p, { key: L, spamStatus: R.data.spamStatus });
            return H || ie;
          });
      let T = Pte({ tokens: I, priceMap: w ?? {} });
      r &&
        (t === void 0
          ? (T = T.sort(kte))
          : (T = T.sort((R, L) => {
              const H = t.indexOf(R.data.key),
                ie = t.indexOf(L.data.key);
              return H < ie ? -1 : H > ie ? 1 : 0;
            })));
      const P = new Map();
      for (const R of T) P.set(R.data.key, R);
      return { fungibles: T, fungibleMap: P };
    }, [c, t, e, p, w, r]),
    D = G.useMemo(() => !!p && p.size > 0 && c.length > 0 && N.length === 0, [c, p, N]),
    k = Dp(),
    K = G.useMemo(() => mte(k, F), [F, k]),
    M = jee('send:fungible', ce.Solana.Mainnet);
  G.useEffect(() => {
    for (const I of K) M(I.transactionId, 'appUpdated'), Cte(I.fungibleKey, k);
  }, [K, M, k]);
  const C = G.useMemo(() => bte(N), [N]),
    z = G.useCallback(async () => {
      await Promise.all([u(), E()]);
    }, [u, E]);
  return {
    fungibles: N,
    portfolio: C,
    visibilityOverrides: p,
    isHidingAllFungibles: D,
    isLoadingTokens: s,
    isLoadingVisibilityOverrides: y,
    isLoadingPrices: n ? _ : !1,
    isRefetchingTokens: l,
    isRefetchingVisibilityOverrides: b,
    isRefetchingPrices: n ? S : !1,
    isErrorTokens: d,
    tokensError: f,
    isErrorPrices: O,
    refetch: z,
  };
}
function Ote({ key: e, splTokenAccount: t, ...n }) {
  const { fungibles: r, ...i } = AP({ ...n, keys: e ? [e] : [] });
  let o;
  return (
    r.length === 1
      ? (o = r[0])
      : r.length > 1 &&
        t &&
        (o = r.find((a) => a.type === Re.SPL && a.data.splTokenAccountPubkey === t)),
    { fungible: o, ...i }
  );
}
const IP = 151,
  EP = 111,
  c0 = 546;
function dw(e) {
  return e * EP + c0;
}
function TP(e) {
  return e * IP + dw(e);
}
function Dte({
  sender: e,
  feerate: t,
  taprootScriptSpendPath: n,
  utxoState: { safeToSendUtxos: r },
}) {
  const i = TP(t),
    { scriptTree: o, inscribeP2tr: a } = n,
    c = a.output;
  if (!c) throw new Error('Commit output script is undefined');
  const s = a.address;
  if (!s) throw new Error('Reveal address is undefined');
  const l = [
      {
        address: s,
        script: c,
        value: i,
        tapInternalKey: a.internalPubkey,
        tapTree: { leaves: x4(o) },
      },
    ],
    u = G1(br(ce.Bitcoin.Mainnet, e), r, l, t),
    d = new Zt.Psbt({ network: Zt.networks.bitcoin });
  if (u.type === 'success') {
    const { inputs: f, outputs: p } = u;
    d.addInputs(f.map((y) => RM(y, e, !0))), d.addOutputs(p);
  }
  return [d, d.data.inputs.map((f, p) => ({ address: e, signingIndexes: [p] })), u.vb];
}
function Rte({ sender: e, feerate: t, taprootScriptSpendPath: n }) {
  return {
    metadata: 'brc20_reveal',
    inputsToSign: [{ address: e, signingIndexes: [0], isScriptSpend: !0 }],
    psbtFn: (r) => {
      const { inscribeP2tr: i, tapLeafScript: o } = n,
        a = i.output;
      if (!a) throw new Error('Commit output script is undefined');
      const c = new Zt.Psbt({ network: Zt.networks.bitcoin }),
        s = TP(t),
        l = { hash: r, index: 0, value: s };
      c.addInput({
        hash: l.hash,
        index: l.index,
        witnessUtxo: { script: a, value: l.value },
        tapLeafScript: [o],
      });
      const u = dw(t);
      return c.addOutput({ address: e, value: u }), c;
    },
    additionalCost: { vb: new oe(IP), sats: new oe(0) },
  };
}
function xte({ sender: e, receiver: t, feerate: n }) {
  return {
    metadata: 'brc20_send',
    inputsToSign: [{ address: e, signingIndexes: [0] }],
    psbtFn: (r) => {
      const i = new Zt.Psbt({ network: Zt.networks.bitcoin }),
        o = dw(n),
        a = { hash: r, index: 0, value: o };
      return (
        i.addInput({
          hash: a.hash,
          index: a.index,
          witnessUtxo: { script: SI(e), value: a.value },
        }),
        i.addOutput({ address: t, value: c0 }),
        i
      );
    },
    additionalCost: { vb: new oe(EP), sats: new oe(c0) },
  };
}
function Bte(e, t, n) {
  const r = xG(e, OG(t, n)),
    i = { output: r },
    o = { output: r, redeemVersion: 192 },
    a = Zt.payments.p2tr({
      internalPubkey: e,
      scriptTree: i,
      network: Zt.networks.bitcoin,
      redeem: o,
    }),
    c = a.witness;
  if (!c) throw new Error('Witness is undefined');
  const s = { leafVersion: o.redeemVersion, script: o.output, controlBlock: c[c.length - 1] };
  return { scriptTree: i, inscribeLockRedeem: o, inscribeP2tr: a, tapLeafScript: s };
}
const jte = ({
    senderAddress: e,
    destination: t,
    tick: n,
    amount: r,
    scriptPublicKey: i,
    utxoState: o,
    feerate: a,
  }) => {
    const c = B4(Y.from(i)),
      s = Bte(c, n, r.toNumber()),
      [l, u, d] = Dte({ sender: e, feerate: a, taprootScriptSpendPath: s, utxoState: o }),
      f = Rte({ sender: e, feerate: a, taprootScriptSpendPath: s }),
      p = xte({ sender: e, receiver: t, feerate: a });
    return [l, [f, p], u, d];
  },
  Nte = ({
    senderAddress: e,
    destination: t,
    amount: n,
    utxoState: { safeToSendUtxos: r },
    feerate: i,
  }) => {
    const o = G1(br(ce.Bitcoin.Mainnet, e), r, [{ address: t, value: n.toNumber() }], i),
      a = new Zt.Psbt({ network: Zt.networks.bitcoin });
    if (o.type === 'success') {
      const { inputs: c, outputs: s } = o;
      a.addInputs(c.map((l) => RM(l, e, !0))), a.addOutputs(s);
    }
    return [a, a.data.inputs.map((c, s) => ({ address: e, signingIndexes: [s] })), o.vb];
  };
function Ute({ data: e, type: t }, { amountAsset: n, recipient: r, transactionSpeed: i }, o) {
  let a, c, s, l;
  const { transactionSpeedsToUnitCost: u, utxoState: d, chainAddress: f } = o,
    p = e.chain.id,
    y = u[i ?? 'standard'];
  if (!(y != null && y.btcPerKilobyte)) throw new Error('Transaction unit cost is required');
  const b = Math.round(y ? Bf(y.btcPerKilobyte).toNumber() : eq);
  switch (t) {
    case Re.BitcoinNative:
      [a, l, s] = Nte({
        senderAddress: e.walletAddress,
        destination: r,
        amount: n,
        utxoState: d,
        feerate: b,
      });
      break;
    case Re.BRC20: {
      if (!f) throw new Error('Cannot find chain address to sign with.');
      const m = f.publicKey;
      if (!m) throw new Error(`Public key does not exist for address ${e.walletAddress}`);
      [a, c, l, s] = jte({
        senderAddress: e.walletAddress,
        destination: r,
        amount: n,
        scriptPublicKey: m,
        tick: e.name ?? '',
        utxoState: d,
        feerate: b,
      });
      break;
    }
  }
  return { networkID: p, psbt: a, psbtChain: c, inputsToSign: l, vb: s };
}
const Lte = [
    'function allowance(address owner, address spender) view returns (uint256)',
    'function balanceOf(address owner) view returns (uint256)',
    'function decimals() view returns (uint8)',
    'function symbol() view returns (string)',
    'function approve(address spender, uint amount) returns (bool)',
    'function transfer(address to, uint amount) returns (bool)',
    'event Transfer(address indexed from, address indexed to, uint amount)',
  ],
  HS = new Error('Error populating ERC20 transaction data.'),
  zte = async (e) => {
    const {
        sender: t,
        networkID: n,
        destination: r,
        contractAddress: i,
        value: o,
        ethereumNetworkID: a,
      } = e,
      c = gM(n, i, Lte, t);
    let s;
    try {
      const u = await c.populateTransaction.transfer(r, jM(o), { from: t });
      if (u.data) s = u.data;
      else throw HS;
    } catch {
      throw HS;
    }
    return Tc.parse({
      type: gI.eip1559,
      to: i,
      from: t,
      chainId: typeof a == 'number' ? a : q.getEVMNetworkIDValue(a),
      data: s,
    });
  },
  Fte = (e) => {
    const { nonce: t, sender: n, destination: r, value: i, ethereumNetworkID: o } = e;
    return Tc.parse({
      type: gI.eip1559,
      nonce: t !== void 0 ? `0x${Number(t).toString(16)}` : void 0,
      from: n,
      to: r,
      chainId: typeof o == 'number' ? o : q.getEVMNetworkIDValue(o),
      value: `0x${i.toString(16)}`,
    });
  };
async function $te({ type: e, data: t }, { recipient: n, amountAsset: r }) {
  const { chain: i } = t,
    o = i.id;
  let a;
  if (gi(e)) a = Fte({ sender: t.walletAddress, destination: n, value: r, ethereumNetworkID: o });
  else if (e === Re.ERC20)
    a = await zte({
      sender: t.walletAddress,
      networkID: o,
      destination: n,
      contractAddress: t.contractAddress,
      value: r,
      ethereumNetworkID: o,
    });
  else return Sn();
  return { networkID: o, unsignedTransaction: a };
}
async function Wte(e, { amountAsset: t, recipient: n, solana: r }) {
  var y;
  const { type: i, data: o } = e,
    a = o.chain.id,
    { references: c, memo: s } = r,
    l = ((y = r.references) == null ? void 0 : y.map((b) => b.toString())) ?? [],
    { walletAddress: u } = o,
    d = fa(a);
  let f,
    p = hp;
  switch (i) {
    case Re.SolanaNative: {
      const b = new Ye(u),
        m = new Ye(n);
      (!l || !l.length) && !s && (p = cG),
        (f = $Y({
          fromPubkey: b,
          toPubkey: m,
          lamports: BigInt(t.toFixed()),
          references: (l == null ? void 0 : l.map((w) => new Ye(w))) ?? [],
          memo: s ?? null,
        }));
      break;
    }
    case Re.SPL: {
      f = await FY({
        connection: d,
        destination: n,
        senderAccount: o.splTokenAccountPubkey,
        mint: o.mintAddress,
        decimals: o.decimals,
        amount: HX(e, t),
        programId: o.programId,
        references: l,
        memo: s,
        networkID: a,
        senderAddress: { networkID: a, addressType: X.Solana, address: o.walletAddress },
        transferHookProgramId: $X(e),
      });
      break;
    }
    default:
      throw new Error('Unsupported solana transfer transaction');
  }
  if (!f) throw new Error('Unable to create transaction.');
  return (
    (f.feePayer = new Ye(u)),
    (f = await OM(f, { connection: d, calculators: { budget: new H1(p) } })),
    (f.recentBlockhash = (await d.getLatestBlockhash('confirmed')).blockhash),
    { networkID: a, transaction: [f] }
  );
}
const Vte = BigInt('4000000'),
  Kte = async ({ type: e, data: t }, n) => {
    const { walletAddress: r, chain: i } = t,
      o = i.id,
      { amountAsset: a, recipient: c } = n,
      s = q.getRpcProxyUrl(o);
    if (!s) throw new Error('Failed to get Sui RPC url');
    const l = new II({ url: s }),
      u = new fs();
    u.setSender(r), u.setGasBudget(Vte);
    const d = () => {
      const y = BigInt(a.toFixed());
      let b;
      switch (e) {
        case Re.SuiNative:
          b = { useGasCoin: !0 };
          break;
        case Re.SuiCoin:
          b = { type: t.contractAddress };
          break;
        default:
          Sn();
      }
      return W4({ balance: y, ...b });
    };
    u.transferObjects([d()], c);
    const f = await u.build({ client: l });
    return { networkID: o, transaction: f };
  };
async function Hte(e, t, n) {
  return UX(e) ? Wte(e, t) : LX(e) ? $te(e, t) : zX(e) ? Kte(e, t) : FX(e) ? Ute(e, t, n) : Sn();
}
const qte = 'fungible-transfer-tx',
  Gte = ae({ seconds: 30 });
function _le(e) {
  var p;
  const t = e == null ? void 0 : e.fungibleKey,
    { fungible: n } = Ote({ key: t, splTokenAccount: e == null ? void 0 : e.splTokenAccount }),
    r =
      tte(
        (p = e == null ? void 0 : e.sendFormValues) == null ? void 0 : p.recipient,
        n == null ? void 0 : n.data.chain.id
      ) ?? '',
    i = (e == null ? void 0 : e.sendSessionId) ?? '',
    { chain: o, walletAddress: a } = (n == null ? void 0 : n.data) ?? {},
    { data: c } = $5({ address: a, networkID: o == null ? void 0 : o.id }),
    { data: s } = bP(c),
    { data: l } = yP({ networkID: o == null ? void 0 : o.id, enableFallback: !0 }),
    u = Yte(o == null ? void 0 : o.id, l, s, c),
    d = u != null && u.sendContextRequired ? u.sendContext : void 0,
    f = e == null ? void 0 : e.sendFormValues;
  return pt({
    staleTime: Gte,
    enabled: !!n && !!e && !!u,
    queryKey: ea.transferTransaction({
      fungibleKey: t,
      fungibleSendFormValues: f,
      sendSessionId: i,
      sendContext: d,
    }),
    async queryFn() {
      var y;
      if (!n || !f || !u)
        throw new Error('Missing required data to construct fungible transfer transaction');
      try {
        return await Hte(n, { ...f, recipient: r }, d);
      } catch (b) {
        if (Np(b)) {
          const m = (y = b.response) == null ? void 0 : y.status;
          xX(b, m, qte);
        }
      }
      throw new Error('Failed to create transfer transaction');
    },
  });
}
function Yte(e, t, n, r) {
  if (e)
    return q.isBitcoinNetworkID(e)
      ? !t || !n || !r
        ? void 0
        : {
            sendContextRequired: !0,
            sendContext: { transactionSpeedsToUnitCost: t, utxoState: n, chainAddress: r },
          }
      : { sendContextRequired: !1 };
}
const Zte = [
    'receive',
    'send',
    'decompress',
    'swap',
    'buy',
    'stakeSol',
    'mintLST',
    'stake',
    'unstake',
    'viewOnExplorer',
    'copyTokenAddress',
    'unwrapWrappedSol',
    'share',
    'reportIssue',
  ],
  qS = new Map(Zte.map((e, t) => [e, t + 1])),
  Qte = (e) => {
    const t = q.getAllChainIDs().reduce((n, r) => ((n[`${r}WalletBalance`] = !1), n), {});
    for (const n of e) {
      const { balance: r, chain: i } = n.data,
        o = r.isGreaterThan(0),
        c = `${q.getChainName(i.id).toLowerCase()}WalletBalance`;
      if (!t[c] && ((t[c] = o), Object.values(t).every((s) => s))) break;
    }
    return t;
  },
  GS = 1e-5,
  Jte = '0,0.[00]a',
  Xte = 1e5,
  ene = (e, t = 5) => {
    const n = new oe(e);
    if (n.abs().isGreaterThan(0) && n.abs().isLessThan(GS))
      return `< ${n.isLessThan(0) ? '-' : ''}${GS}`;
    const r = sI(n.toNumber());
    return n.isGreaterThanOrEqualTo(Xte) ? r.format(Jte) : r.format(`0,0.[${'0'.repeat(t)}]`);
  },
  kP = [q.solana, q.ethereum, q.polygon, q.bitcoin, q.base, q.sui],
  tne = ({ chainName: e, address: t }) => {
    const n = kP.find((i) => i.id === e);
    if (!n) throw new Error(`Chain ${e} not supported`);
    const r = n.mainnetID;
    return typeof t != 'string'
      ? to({ chainId: r, resourceType: sn.nativeToken, slip44: n.slip44 })
      : to({ chainId: r, address: t, resourceType: sn.address });
  },
  nne = () => (Math.random() * Date.now()).toString(36).replace('.', ''),
  rne = ({ caip19: e, isAnalyticsOptedOut: t, isRelative: n }) => {
    const r = e.resourceType === sn.address ? e.address : void 0;
    return CP({ chainId: e.chainId, address: r, isAnalyticsOptedOut: t, isRelative: n });
  },
  CP = ({ chainId: e, address: t, isAnalyticsOptedOut: n, isRelative: r = !1 }) => {
    const i = kP.find((l) => l.mainnetID === e);
    if (!i) return null;
    const a = `${r ? '' : 'https://phantom.com'}/tokens/${i.id}`,
      c = t ? `${a}/${t}` : a,
      s = n ? '' : `?referralId=${nne()}`;
    return `${c}${s}`;
  },
  ine = { getCaip19FromUrlPath: tne, getUrlFromFungible: rne, getUrlForFungibleComponents: CP };
var Vi;
class one {
  constructor(t) {
    _t(this, Vi);
    Le(this, 'walletBalance', (t, n, r) => {
      const i = Qte(r),
        o = { accountId: t, selectedNetworks: n, ...i };
      ue(this, Vi).capture('walletBalance', { data: o });
    });
    Le(
      this,
      'ctaBarTrackPrimaryButtonsClick',
      ({
        uiContext: t,
        position: n,
        type: r,
        maxButtons: i,
        primaryActions: o,
        moreActions: a,
        shortcutActions: c,
        typeSpecificMetadata: s,
      }) => {
        const l = [...a, ...(c || [])],
          u = [...o, ...l].findIndex((p) => p.type === r),
          d = o.length + l.length,
          f = {
            type: r,
            typeSpecificMetadata: s,
            overallIndex: u,
            position: n,
            primaryButtons: o.map(({ type: p }) => ({ type: p })),
            moreButtons: l.map(({ type: p }) => ({ type: p })),
            uiContext: t,
            maxButtons: i,
            totalButtons: d,
          };
        ue(this, Vi).capture('ctaBarClickByUser', { data: { ctaBar: f } });
      }
    );
    Le(this, 'ctaBarTrackMoreButtonClick', ({ uiContext: t, maxButtons: n, totalButtons: r }) => {
      const i = { uiContext: t, maxButtons: n, totalButtons: r };
      ue(this, Vi).capture('ctaBarMoreClickByUser', { data: { ctaBar: i } });
    });
    Le(
      this,
      'onPublicFungiblePageOpen',
      ({ uiContext: t, caip19: n, address: r, symbol: i, hasBalance: o }) => {
        const a = { uiContext: t, caip19: n, address: r, symbol: i, hasBalance: o };
        ue(this, Vi).capture('onPublicFungiblePageOpen', { data: a });
      }
    );
    mt(this, Vi, t);
  }
}
Vi = new WeakMap();
const ane = (e) => sne[e],
  sne = {
    'shortcut-chat': 'MessageCircle',
    'shortcut-default': 'Link',
    'shortcut-discord': 'Discord',
    'shortcut-gaming': 'Joystick',
    'shortcut-gaming-2': 'PacMan',
    'shortcut-generic-add': 'Plus',
    'shortcut-generic-link': 'Link',
    'shortcut-instagram': 'Instagram',
    'shortcut-leaderboard': 'Crown',
    'shortcut-mint': 'Sparkle',
    'shortcut-mint-2': 'Leaf',
    'shortcut-stake': 'TrendingUp',
    'shortcut-stake-2': 'Star',
    'shortcut-telegram': 'Telegram',
    'shortcut-tip': 'DollarSign',
    'shortcut-twitter': 'XTwitter',
    'shortcut-twitter-2': 'XTwitter',
    'shortcut-view': 'Eye',
    'shortcut-vote': 'ThumbsUp',
    'shortcut-vote-2': 'CheckSquare',
    'shortcut-x': 'XTwitter',
    burnToken: 'Burn',
    buy: 'DollarSign',
    copyTokenAddress: 'Copy',
    hide: 'Eye',
    list: 'Tag2',
    mintLST: 'Droplet',
    more: 'MoreHorizontal',
    pin: 'PinRight',
    receive: 'Qr',
    reportIssue: 'Flag',
    reportAsNotSpam: 'Flag',
    reportAsSpam: 'Flag',
    saveToLibrary: 'Download',
    send: 'Send',
    setAsAvatar: 'Smile',
    share: 'Share',
    stake: 'TrendingUp',
    stakeSol: 'TrendingUp',
    swap: 'Swap',
    unhide: 'EyeOff',
    unpin: 'PinRightOff',
    unstake: 'MinusCircle',
    unwrapWrappedSol: 'WalletOpen',
    viewOnExplorer: 'ExternalLink',
    decompress: 'PlusCircle',
  },
  Lh = 48,
  YS = Ue.memo(({ networkId: e, logoURI: t, type: n }) => {
    const r = cne({ disableBadge: !1, tokenType: n, chain: q.getChainID(e) });
    return A.jsxs(Dt, {
      size: Lh,
      position: 'relative',
      children: [
        t
          ? A.jsx(T0, {
              src: t,
              height: Lh,
              width: Lh,
              borderRadius: 'circle',
              fallback: A.jsx(ZS, {}),
            })
          : A.jsx(ZS, {}),
        r ? A.jsx(une, { networkId: e }) : null,
      ],
    });
  }),
  ZS = () =>
    A.jsx(Dt, {
      alignItems: 'center',
      justifyContent: 'center',
      size: Lh,
      backgroundColor: 'bgWallet',
      borderRadius: 'circle',
      children: A.jsx(C3, { size: '50%', color: 'borderPrimary' }),
    }),
  cne = ({ disableBadge: e, tokenType: t, chain: n }) =>
    e ? !1 : fc.get(n).alwaysShowNetworkBadge ? !0 : !gi(t),
  une = ({ networkId: e }) =>
    A.jsx(Dt, {
      right: '-2',
      bottom: '-2',
      position: 'absolute',
      borderColor: 'bgRow',
      borderStyle: 'solid',
      borderWidth: 2,
      style: { borderRadius: 9 },
      children: A.jsx(Z1, { networkID: e, size: 18 }),
    }),
  lne = ({ image: e, name: t, symbol: n, onPress: r }) =>
    A.jsx(Dt, {
      backgroundColor: 'bgRow',
      borderRadius: 'row',
      padding: 16,
      onPress: r,
      children: A.jsxs(Dt, {
        gap: 12,
        children: [
          e,
          A.jsxs(Dt, {
            gap: 4,
            alignItems: 'flex-start',
            children: [
              A.jsx(Lt, { children: t }),
              A.jsx(Lt, { color: 'textSecondary', children: n }),
            ],
          }),
        ],
      }),
    }),
  u0 = Ue.memo(
    ({ enabledAddressTypes: e, selectedAccount: t, tokenWithMetadata: n, type: r, onPress: i }) => {
      const { token: o, addressType: a } = n,
        { caip19: c, logoURI: s, name: l, symbol: u } = o,
        { chainId: d } = c,
        f = iw(c),
        { t: p } = ia(),
        y = l ?? p('assetDetailUnknownToken'),
        b = G.useMemo(() => {
          var _;
          const w =
            ((_ =
              t == null
                ? void 0
                : t.addresses.find((S) =>
                    a ? S.addressType === a && S.networkID === d : S.networkID === d
                  )) == null
              ? void 0
              : _.address) ?? '';
          return q.isEVMNetworkID(d) ? w.toLowerCase() : w;
        }, [t, a, d]),
        m = G.useCallback(() => {
          i({ tokenWithMetadata: n, ownerPublicKey: b });
        }, [i, n, b]);
      return a && !e.includes(a)
        ? A.jsx(A.Fragment, {})
        : r === 'card'
          ? A.jsx(lne, {
              onPress: m,
              image: A.jsx(YS, { logoURI: s, networkId: c.chainId, type: f }),
              name: y,
              symbol: u,
            })
          : A.jsx(YA, {
              onPress: m,
              start: A.jsx(YS, { logoURI: s, networkId: c.chainId, type: f }),
              topLeft: { text: y, after: A.jsx(aJ, { networkID: c.chainId, address: b }) },
              bottomLeft: u,
            });
    }
  ),
  dne = ({
    enabledAddressTypes: e,
    group: t,
    groupIndex: n,
    selectedAccount: r,
    onTokenPress: i,
  }) => {
    const o = n === 0;
    return A.jsxs(
      Dt,
      {
        marginTop: o ? 8 : 24,
        children: [
          A.jsx(Lt, {
            font: M3 ? 'bodyMedium' : 'title3Semibold',
            color: 'textSecondary',
            marginBottom: 8,
            children: t.groupName,
          }),
          A.jsx(Dt, {
            flexWrap: 'wrap',
            direction: 'row',
            gap: o ? 0 : 'list',
            children: t.tokens.map((a, c) => {
              const { token: s, addressType: l } = a,
                u = `${s.symbol}-${s.caip19.chainId}-${c}`;
              return l && !e.includes(l)
                ? null
                : o
                  ? A.jsx(
                      Dt,
                      {
                        flexBasis: '50%',
                        paddingLeft: c % 2 === 0 ? 0 : 4,
                        paddingRight: c % 2 === 0 ? 4 : 0,
                        paddingBottom: c >= t.tokens.length - 2 ? 0 : 8,
                        children: A.jsx(u0, {
                          enabledAddressTypes: e,
                          selectedAccount: r,
                          tokenWithMetadata: t.tokens[c],
                          type: 'card',
                          onPress: i,
                        }),
                      },
                      u
                    )
                  : A.jsx(
                      u0,
                      {
                        tokenWithMetadata: t.tokens[c],
                        enabledAddressTypes: e,
                        selectedAccount: r,
                        type: 'row',
                        onPress: i,
                      },
                      u
                    );
            }),
          }),
        ],
      },
      t.groupName
    );
  };
Ue.memo(({ groupedTokens: e, enabledAddressTypes: t, selectedAccount: n, onTokenPress: r }) =>
  A.jsxs(A.Fragment, {
    children: [
      A.jsx(oJ, { marginBottom: 16 }),
      e.map((i, o) =>
        A.jsx(
          dne,
          { enabledAddressTypes: t, group: i, groupIndex: o, onTokenPress: r, selectedAccount: n },
          i.groupName
        )
      ),
    ],
  })
);
Ue.memo(({ enabledAddressTypes: e, searchedTokens: t, selectedAccount: n, onTokenPress: r }) =>
  A.jsx(A.Fragment, {
    children: t.map((i, o) =>
      A.jsx(
        Dt,
        {
          marginBottom: 8,
          children: A.jsx(u0, {
            enabledAddressTypes: e,
            selectedAccount: n,
            tokenWithMetadata: i,
            type: 'row',
            onPress: r,
          }),
        },
        `${i.token.symbol}-${i.token.caip19.chainId}-${o}`
      )
    ),
  })
);
const vle = Ue.memo((e) => {
    const { name: t, tag: n, logo: r, quote: i, onClick: o, index: a } = e,
      c = {
        start: A.jsx(T0, { width: 44, height: 44, borderRadius: 'circle', src: r }),
        topLeft: t,
        bottomLeft: n && { text: n, color: a === 0 ? 'accentSuccess' : 'textSecondary' },
        onPress: () => o(e),
      },
      s = i
        ? { ...c, topRight: i.displayDestinationAmount, bottomRight: `≈ ${i.displaySourceAmount}` }
        : {
            ...c,
            end: A.jsx(Dt, {
              direction: 'row',
              alignItems: 'center',
              gap: 4,
              children: A.jsx(P3, { color: 'textSecondary', size: 16 }),
            }),
          };
    return A.jsx(YA, { ...s });
  }),
  fne = new ao('Failed to get FiatRampProviderUrl'),
  Sle = async (e, t, n, r, i) => {
    try {
      const o = { 'x-client-platform': e, 'x-client-app-version': t, 'x-client-locale': n },
        a = await ke.api().headers(o).bearer(i).post('/fiat_ramp/v2/onramp/provider_url', r);
      if (!hn(a)) throw new ao(a.data.message);
      return a.data;
    } catch (o) {
      throw o instanceof ao ? o : fne;
    }
  },
  hne = Ue.lazy(() =>
    Rt(
      () => import('./FiatRampFlow-Cnxiw7mF.js'),
      __vite__mapDeps([
        21, 7, 6, 2, 1, 3, 4, 5, 8, 0, 9, 10, 11, 12, 13, 15, 22, 23, 24, 25, 26, 17, 18,
      ])
    ).then((e) => ({ default: e.FiatRampFlow }))
  ),
  pne = Ue.lazy(() =>
    Rt(
      () => import('./FiatRampPaymentMethodsPage-BPFqGbbQ.js'),
      __vite__mapDeps([27, 7, 6, 2, 1, 3, 4, 5, 8, 0, 9, 10, 11, 12, 13, 15, 26, 24, 25, 17, 18])
    ).then((e) => ({ default: e.FiatRampPaymentMethodsPage }))
  ),
  MP = Ue.lazy(() =>
    Rt(
      () => import('./FiatRampProvidersPage-BKDihMc9.js'),
      __vite__mapDeps([28, 7, 6, 2, 1, 3, 4, 5, 8, 0, 9, 10, 11, 12, 13, 15, 26, 24, 25, 17, 18])
    ).then((e) => ({ default: e.FiatRampProvidersPage }))
  ),
  gne = Ue.lazy(() =>
    Rt(
      () => import('./FiatRampFlowPreselectedToken-Cmw5N1ME.js'),
      __vite__mapDeps([
        29, 7, 6, 2, 1, 3, 4, 5, 8, 0, 9, 10, 11, 12, 13, 22, 23, 15, 24, 25, 17, 18,
      ])
    ).then((e) => ({ default: e.FiatRampFlowPreselectedToken }))
  ),
  yne = Ue.lazy(() =>
    Rt(
      () => import('./FiatRampFlowPreselectedToken-Cmw5N1ME.js'),
      __vite__mapDeps([
        29, 7, 6, 2, 1, 3, 4, 5, 8, 0, 9, 10, 11, 12, 13, 22, 23, 15, 24, 25, 17, 18,
      ])
    ).then((e) => ({ default: e.WrappedFiatRampFormPage }))
  ),
  bne = Ue.lazy(() =>
    Rt(
      () => import('./FiatRampWaitingOnRamp-DDhePt7W.js'),
      __vite__mapDeps([30, 7, 6, 2, 1, 3, 4, 5, 8, 0, 9, 10, 11, 12, 13, 15, 17, 18])
    ).then((e) => ({ default: e.FiatRampWaitingOnRamp }))
  ),
  mne = Ue.lazy(() =>
    Rt(
      () => import('./FiatRampRedirectToProvider-Bu1S6Nm9.js'),
      __vite__mapDeps([31, 7, 6, 2, 1, 3, 4, 5, 8, 15])
    ).then((e) => ({ default: e.FiatRampRedirectToProvider }))
  ),
  PP = Qn({
    id: 'fiat-ramp-detail',
    initialViewId: 'fiat-ramp-detail-providers',
    views: [
      { id: 'fiat-ramp-detail-providers', element: A.jsx(MP, {}) },
      { id: 'fiat-ramp-detail-payment-methods', element: A.jsx(pne, {}) },
    ],
    display: 'modal',
    stacks: [],
  }),
  wne = Qn({
    id: 'fiat-ramp-redirect-to-provider',
    initialViewId: 'main',
    views: [
      { id: 'main', element: A.jsx(A.Fragment, {}) },
      {
        id: 'fiat-ramp-redirect-to-provider',
        element: A.jsx(mne, {}),
        params: {
          url: h.string().url(),
          provider: iy.extend({ tag: h.string().optional() }),
          sessionId: h.string(),
          caip19: h.string(),
        },
      },
      {
        id: 'fiat-ramp-waiting-on-ramp',
        element: A.jsx(bne, {}),
        params: { sessionId: h.string(), caip19: h.string() },
      },
    ],
    display: 'modal',
    stacks: [],
  }),
  _ne = Qn({
    id: 'fiat-ramp',
    initialViewId: 'fiat-ramp-fungible-selection',
    views: [
      { id: 'fiat-ramp-fungible-selection', element: A.jsx(hne, {}) },
      {
        id: 'fiat-ramp-fungible-selected',
        element: A.jsx(gne, {}),
        params: {
          buy: h.string(),
          amount: h.string().optional(),
          redirectURL: h.string().url().optional(),
        },
      },
      { id: 'fiat-ramp-form', element: A.jsx(yne, {}) },
      { id: 'fiat-ramp-providers', element: A.jsx(MP, {}) },
    ],
    display: 'modal',
    stacks: [PP, wne],
  }),
  vne = Ue.lazy(() =>
    Rt(
      () => import('./Notification-CamjllPl.js'),
      __vite__mapDeps([32, 7, 6, 2, 1, 3, 4, 5, 8, 15, 33, 17, 0, 9, 10, 11, 12, 13, 18])
    ).then((e) => ({ default: e.Notification }))
  ),
  Sne = Qn({
    id: 'notification',
    initialViewId: 'notification',
    display: 'modal',
    views: [
      { id: 'notification', params: { userApproveRequest: h.any() }, element: A.jsx(vne, {}) },
    ],
    stacks: [],
  }),
  Ane = Ue.lazy(() =>
    Rt(
      () => import('./Login-CR3QJ4Cf.js'),
      __vite__mapDeps([34, 7, 6, 2, 1, 3, 4, 5, 8, 10, 0, 9, 11, 12, 13, 15, 17, 18])
    ).then((e) => ({ default: e.Login }))
  ),
  Ine = Qn({
    id: 'onboarding',
    initialViewId: 'login',
    display: 'modal',
    views: [{ id: 'login', element: A.jsx(Ane, {}) }],
    stacks: [],
  });
var OP = { MODE_NUMBER: 1, MODE_ALPHA_NUM: 2, MODE_8BIT_BYTE: 4, MODE_KANJI: 8 },
  Ene = OP;
function DP(e) {
  (this.mode = Ene.MODE_8BIT_BYTE), (this.data = e);
}
DP.prototype = {
  getLength: function (e) {
    return this.data.length;
  },
  write: function (e) {
    for (var t = 0; t < this.data.length; t++) e.put(this.data.charCodeAt(t), 8);
  },
};
var Tne = DP,
  RP = { L: 1, M: 0, Q: 3, H: 2 },
  mh = RP;
function Lr(e, t) {
  (this.totalCount = e), (this.dataCount = t);
}
Lr.RS_BLOCK_TABLE = [
  [1, 26, 19],
  [1, 26, 16],
  [1, 26, 13],
  [1, 26, 9],
  [1, 44, 34],
  [1, 44, 28],
  [1, 44, 22],
  [1, 44, 16],
  [1, 70, 55],
  [1, 70, 44],
  [2, 35, 17],
  [2, 35, 13],
  [1, 100, 80],
  [2, 50, 32],
  [2, 50, 24],
  [4, 25, 9],
  [1, 134, 108],
  [2, 67, 43],
  [2, 33, 15, 2, 34, 16],
  [2, 33, 11, 2, 34, 12],
  [2, 86, 68],
  [4, 43, 27],
  [4, 43, 19],
  [4, 43, 15],
  [2, 98, 78],
  [4, 49, 31],
  [2, 32, 14, 4, 33, 15],
  [4, 39, 13, 1, 40, 14],
  [2, 121, 97],
  [2, 60, 38, 2, 61, 39],
  [4, 40, 18, 2, 41, 19],
  [4, 40, 14, 2, 41, 15],
  [2, 146, 116],
  [3, 58, 36, 2, 59, 37],
  [4, 36, 16, 4, 37, 17],
  [4, 36, 12, 4, 37, 13],
  [2, 86, 68, 2, 87, 69],
  [4, 69, 43, 1, 70, 44],
  [6, 43, 19, 2, 44, 20],
  [6, 43, 15, 2, 44, 16],
  [4, 101, 81],
  [1, 80, 50, 4, 81, 51],
  [4, 50, 22, 4, 51, 23],
  [3, 36, 12, 8, 37, 13],
  [2, 116, 92, 2, 117, 93],
  [6, 58, 36, 2, 59, 37],
  [4, 46, 20, 6, 47, 21],
  [7, 42, 14, 4, 43, 15],
  [4, 133, 107],
  [8, 59, 37, 1, 60, 38],
  [8, 44, 20, 4, 45, 21],
  [12, 33, 11, 4, 34, 12],
  [3, 145, 115, 1, 146, 116],
  [4, 64, 40, 5, 65, 41],
  [11, 36, 16, 5, 37, 17],
  [11, 36, 12, 5, 37, 13],
  [5, 109, 87, 1, 110, 88],
  [5, 65, 41, 5, 66, 42],
  [5, 54, 24, 7, 55, 25],
  [11, 36, 12],
  [5, 122, 98, 1, 123, 99],
  [7, 73, 45, 3, 74, 46],
  [15, 43, 19, 2, 44, 20],
  [3, 45, 15, 13, 46, 16],
  [1, 135, 107, 5, 136, 108],
  [10, 74, 46, 1, 75, 47],
  [1, 50, 22, 15, 51, 23],
  [2, 42, 14, 17, 43, 15],
  [5, 150, 120, 1, 151, 121],
  [9, 69, 43, 4, 70, 44],
  [17, 50, 22, 1, 51, 23],
  [2, 42, 14, 19, 43, 15],
  [3, 141, 113, 4, 142, 114],
  [3, 70, 44, 11, 71, 45],
  [17, 47, 21, 4, 48, 22],
  [9, 39, 13, 16, 40, 14],
  [3, 135, 107, 5, 136, 108],
  [3, 67, 41, 13, 68, 42],
  [15, 54, 24, 5, 55, 25],
  [15, 43, 15, 10, 44, 16],
  [4, 144, 116, 4, 145, 117],
  [17, 68, 42],
  [17, 50, 22, 6, 51, 23],
  [19, 46, 16, 6, 47, 17],
  [2, 139, 111, 7, 140, 112],
  [17, 74, 46],
  [7, 54, 24, 16, 55, 25],
  [34, 37, 13],
  [4, 151, 121, 5, 152, 122],
  [4, 75, 47, 14, 76, 48],
  [11, 54, 24, 14, 55, 25],
  [16, 45, 15, 14, 46, 16],
  [6, 147, 117, 4, 148, 118],
  [6, 73, 45, 14, 74, 46],
  [11, 54, 24, 16, 55, 25],
  [30, 46, 16, 2, 47, 17],
  [8, 132, 106, 4, 133, 107],
  [8, 75, 47, 13, 76, 48],
  [7, 54, 24, 22, 55, 25],
  [22, 45, 15, 13, 46, 16],
  [10, 142, 114, 2, 143, 115],
  [19, 74, 46, 4, 75, 47],
  [28, 50, 22, 6, 51, 23],
  [33, 46, 16, 4, 47, 17],
  [8, 152, 122, 4, 153, 123],
  [22, 73, 45, 3, 74, 46],
  [8, 53, 23, 26, 54, 24],
  [12, 45, 15, 28, 46, 16],
  [3, 147, 117, 10, 148, 118],
  [3, 73, 45, 23, 74, 46],
  [4, 54, 24, 31, 55, 25],
  [11, 45, 15, 31, 46, 16],
  [7, 146, 116, 7, 147, 117],
  [21, 73, 45, 7, 74, 46],
  [1, 53, 23, 37, 54, 24],
  [19, 45, 15, 26, 46, 16],
  [5, 145, 115, 10, 146, 116],
  [19, 75, 47, 10, 76, 48],
  [15, 54, 24, 25, 55, 25],
  [23, 45, 15, 25, 46, 16],
  [13, 145, 115, 3, 146, 116],
  [2, 74, 46, 29, 75, 47],
  [42, 54, 24, 1, 55, 25],
  [23, 45, 15, 28, 46, 16],
  [17, 145, 115],
  [10, 74, 46, 23, 75, 47],
  [10, 54, 24, 35, 55, 25],
  [19, 45, 15, 35, 46, 16],
  [17, 145, 115, 1, 146, 116],
  [14, 74, 46, 21, 75, 47],
  [29, 54, 24, 19, 55, 25],
  [11, 45, 15, 46, 46, 16],
  [13, 145, 115, 6, 146, 116],
  [14, 74, 46, 23, 75, 47],
  [44, 54, 24, 7, 55, 25],
  [59, 46, 16, 1, 47, 17],
  [12, 151, 121, 7, 152, 122],
  [12, 75, 47, 26, 76, 48],
  [39, 54, 24, 14, 55, 25],
  [22, 45, 15, 41, 46, 16],
  [6, 151, 121, 14, 152, 122],
  [6, 75, 47, 34, 76, 48],
  [46, 54, 24, 10, 55, 25],
  [2, 45, 15, 64, 46, 16],
  [17, 152, 122, 4, 153, 123],
  [29, 74, 46, 14, 75, 47],
  [49, 54, 24, 10, 55, 25],
  [24, 45, 15, 46, 46, 16],
  [4, 152, 122, 18, 153, 123],
  [13, 74, 46, 32, 75, 47],
  [48, 54, 24, 14, 55, 25],
  [42, 45, 15, 32, 46, 16],
  [20, 147, 117, 4, 148, 118],
  [40, 75, 47, 7, 76, 48],
  [43, 54, 24, 22, 55, 25],
  [10, 45, 15, 67, 46, 16],
  [19, 148, 118, 6, 149, 119],
  [18, 75, 47, 31, 76, 48],
  [34, 54, 24, 34, 55, 25],
  [20, 45, 15, 61, 46, 16],
];
Lr.getRSBlocks = function (e, t) {
  var n = Lr.getRsBlockTable(e, t);
  if (n == null) throw new Error('bad rs block @ typeNumber:' + e + '/errorCorrectLevel:' + t);
  for (var r = n.length / 3, i = new Array(), o = 0; o < r; o++)
    for (var a = n[o * 3 + 0], c = n[o * 3 + 1], s = n[o * 3 + 2], l = 0; l < a; l++)
      i.push(new Lr(c, s));
  return i;
};
Lr.getRsBlockTable = function (e, t) {
  switch (t) {
    case mh.L:
      return Lr.RS_BLOCK_TABLE[(e - 1) * 4 + 0];
    case mh.M:
      return Lr.RS_BLOCK_TABLE[(e - 1) * 4 + 1];
    case mh.Q:
      return Lr.RS_BLOCK_TABLE[(e - 1) * 4 + 2];
    case mh.H:
      return Lr.RS_BLOCK_TABLE[(e - 1) * 4 + 3];
    default:
      return;
  }
};
var kne = Lr;
function xP() {
  (this.buffer = new Array()), (this.length = 0);
}
xP.prototype = {
  get: function (e) {
    var t = Math.floor(e / 8);
    return ((this.buffer[t] >>> (7 - (e % 8))) & 1) == 1;
  },
  put: function (e, t) {
    for (var n = 0; n < t; n++) this.putBit(((e >>> (t - n - 1)) & 1) == 1);
  },
  getLengthInBits: function () {
    return this.length;
  },
  putBit: function (e) {
    var t = Math.floor(this.length / 8);
    this.buffer.length <= t && this.buffer.push(0),
      e && (this.buffer[t] |= 128 >>> this.length % 8),
      this.length++;
  },
};
var Cne = xP,
  sr = {
    glog: function (e) {
      if (e < 1) throw new Error('glog(' + e + ')');
      return sr.LOG_TABLE[e];
    },
    gexp: function (e) {
      for (; e < 0; ) e += 255;
      for (; e >= 256; ) e -= 255;
      return sr.EXP_TABLE[e];
    },
    EXP_TABLE: new Array(256),
    LOG_TABLE: new Array(256),
  };
for (var on = 0; on < 8; on++) sr.EXP_TABLE[on] = 1 << on;
for (var on = 8; on < 256; on++)
  sr.EXP_TABLE[on] =
    sr.EXP_TABLE[on - 4] ^ sr.EXP_TABLE[on - 5] ^ sr.EXP_TABLE[on - 6] ^ sr.EXP_TABLE[on - 8];
for (var on = 0; on < 255; on++) sr.LOG_TABLE[sr.EXP_TABLE[on]] = on;
var BP = sr,
  _o = BP;
function zh(e, t) {
  if (e.length == null) throw new Error(e.length + '/' + t);
  for (var n = 0; n < e.length && e[n] == 0; ) n++;
  this.num = new Array(e.length - n + t);
  for (var r = 0; r < e.length - n; r++) this.num[r] = e[r + n];
}
zh.prototype = {
  get: function (e) {
    return this.num[e];
  },
  getLength: function () {
    return this.num.length;
  },
  multiply: function (e) {
    for (var t = new Array(this.getLength() + e.getLength() - 1), n = 0; n < this.getLength(); n++)
      for (var r = 0; r < e.getLength(); r++)
        t[n + r] ^= _o.gexp(_o.glog(this.get(n)) + _o.glog(e.get(r)));
    return new zh(t, 0);
  },
  mod: function (e) {
    if (this.getLength() - e.getLength() < 0) return this;
    for (
      var t = _o.glog(this.get(0)) - _o.glog(e.get(0)), n = new Array(this.getLength()), r = 0;
      r < this.getLength();
      r++
    )
      n[r] = this.get(r);
    for (var r = 0; r < e.getLength(); r++) n[r] ^= _o.gexp(_o.glog(e.get(r)) + t);
    return new zh(n, 0).mod(e);
  },
};
var jP = zh,
  Kn = OP,
  QS = jP,
  Mne = BP,
  Ri = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7,
  },
  en = {
    PATTERN_POSITION_TABLE: [
      [],
      [6, 18],
      [6, 22],
      [6, 26],
      [6, 30],
      [6, 34],
      [6, 22, 38],
      [6, 24, 42],
      [6, 26, 46],
      [6, 28, 50],
      [6, 30, 54],
      [6, 32, 58],
      [6, 34, 62],
      [6, 26, 46, 66],
      [6, 26, 48, 70],
      [6, 26, 50, 74],
      [6, 30, 54, 78],
      [6, 30, 56, 82],
      [6, 30, 58, 86],
      [6, 34, 62, 90],
      [6, 28, 50, 72, 94],
      [6, 26, 50, 74, 98],
      [6, 30, 54, 78, 102],
      [6, 28, 54, 80, 106],
      [6, 32, 58, 84, 110],
      [6, 30, 58, 86, 114],
      [6, 34, 62, 90, 118],
      [6, 26, 50, 74, 98, 122],
      [6, 30, 54, 78, 102, 126],
      [6, 26, 52, 78, 104, 130],
      [6, 30, 56, 82, 108, 134],
      [6, 34, 60, 86, 112, 138],
      [6, 30, 58, 86, 114, 142],
      [6, 34, 62, 90, 118, 146],
      [6, 30, 54, 78, 102, 126, 150],
      [6, 24, 50, 76, 102, 128, 154],
      [6, 28, 54, 80, 106, 132, 158],
      [6, 32, 58, 84, 110, 136, 162],
      [6, 26, 54, 82, 110, 138, 166],
      [6, 30, 58, 86, 114, 142, 170],
    ],
    G15: 1335,
    G18: 7973,
    G15_MASK: 21522,
    getBCHTypeInfo: function (e) {
      for (var t = e << 10; en.getBCHDigit(t) - en.getBCHDigit(en.G15) >= 0; )
        t ^= en.G15 << (en.getBCHDigit(t) - en.getBCHDigit(en.G15));
      return ((e << 10) | t) ^ en.G15_MASK;
    },
    getBCHTypeNumber: function (e) {
      for (var t = e << 12; en.getBCHDigit(t) - en.getBCHDigit(en.G18) >= 0; )
        t ^= en.G18 << (en.getBCHDigit(t) - en.getBCHDigit(en.G18));
      return (e << 12) | t;
    },
    getBCHDigit: function (e) {
      for (var t = 0; e != 0; ) t++, (e >>>= 1);
      return t;
    },
    getPatternPosition: function (e) {
      return en.PATTERN_POSITION_TABLE[e - 1];
    },
    getMask: function (e, t, n) {
      switch (e) {
        case Ri.PATTERN000:
          return (t + n) % 2 == 0;
        case Ri.PATTERN001:
          return t % 2 == 0;
        case Ri.PATTERN010:
          return n % 3 == 0;
        case Ri.PATTERN011:
          return (t + n) % 3 == 0;
        case Ri.PATTERN100:
          return (Math.floor(t / 2) + Math.floor(n / 3)) % 2 == 0;
        case Ri.PATTERN101:
          return ((t * n) % 2) + ((t * n) % 3) == 0;
        case Ri.PATTERN110:
          return (((t * n) % 2) + ((t * n) % 3)) % 2 == 0;
        case Ri.PATTERN111:
          return (((t * n) % 3) + ((t + n) % 2)) % 2 == 0;
        default:
          throw new Error('bad maskPattern:' + e);
      }
    },
    getErrorCorrectPolynomial: function (e) {
      for (var t = new QS([1], 0), n = 0; n < e; n++) t = t.multiply(new QS([1, Mne.gexp(n)], 0));
      return t;
    },
    getLengthInBits: function (e, t) {
      if (1 <= t && t < 10)
        switch (e) {
          case Kn.MODE_NUMBER:
            return 10;
          case Kn.MODE_ALPHA_NUM:
            return 9;
          case Kn.MODE_8BIT_BYTE:
            return 8;
          case Kn.MODE_KANJI:
            return 8;
          default:
            throw new Error('mode:' + e);
        }
      else if (t < 27)
        switch (e) {
          case Kn.MODE_NUMBER:
            return 12;
          case Kn.MODE_ALPHA_NUM:
            return 11;
          case Kn.MODE_8BIT_BYTE:
            return 16;
          case Kn.MODE_KANJI:
            return 10;
          default:
            throw new Error('mode:' + e);
        }
      else if (t < 41)
        switch (e) {
          case Kn.MODE_NUMBER:
            return 14;
          case Kn.MODE_ALPHA_NUM:
            return 13;
          case Kn.MODE_8BIT_BYTE:
            return 16;
          case Kn.MODE_KANJI:
            return 12;
          default:
            throw new Error('mode:' + e);
        }
      else throw new Error('type:' + t);
    },
    getLostPoint: function (e) {
      for (var t = e.getModuleCount(), n = 0, r = 0; r < t; r++)
        for (var i = 0; i < t; i++) {
          for (var o = 0, a = e.isDark(r, i), c = -1; c <= 1; c++)
            if (!(r + c < 0 || t <= r + c))
              for (var s = -1; s <= 1; s++)
                i + s < 0 ||
                  t <= i + s ||
                  (c == 0 && s == 0) ||
                  (a == e.isDark(r + c, i + s) && o++);
          o > 5 && (n += 3 + o - 5);
        }
      for (var r = 0; r < t - 1; r++)
        for (var i = 0; i < t - 1; i++) {
          var l = 0;
          e.isDark(r, i) && l++,
            e.isDark(r + 1, i) && l++,
            e.isDark(r, i + 1) && l++,
            e.isDark(r + 1, i + 1) && l++,
            (l == 0 || l == 4) && (n += 3);
        }
      for (var r = 0; r < t; r++)
        for (var i = 0; i < t - 6; i++)
          e.isDark(r, i) &&
            !e.isDark(r, i + 1) &&
            e.isDark(r, i + 2) &&
            e.isDark(r, i + 3) &&
            e.isDark(r, i + 4) &&
            !e.isDark(r, i + 5) &&
            e.isDark(r, i + 6) &&
            (n += 40);
      for (var i = 0; i < t; i++)
        for (var r = 0; r < t - 6; r++)
          e.isDark(r, i) &&
            !e.isDark(r + 1, i) &&
            e.isDark(r + 2, i) &&
            e.isDark(r + 3, i) &&
            e.isDark(r + 4, i) &&
            !e.isDark(r + 5, i) &&
            e.isDark(r + 6, i) &&
            (n += 40);
      for (var u = 0, i = 0; i < t; i++) for (var r = 0; r < t; r++) e.isDark(r, i) && u++;
      var d = Math.abs((100 * u) / t / t - 50) / 5;
      return (n += d * 10), n;
    },
  },
  Pne = en,
  One = Tne,
  NP = kne,
  UP = Cne,
  po = Pne,
  Dne = jP;
function Fr(e, t) {
  (this.typeNumber = e),
    (this.errorCorrectLevel = t),
    (this.modules = null),
    (this.moduleCount = 0),
    (this.dataCache = null),
    (this.dataList = []);
}
var Wn = Fr.prototype;
Wn.addData = function (e) {
  var t = new One(e);
  this.dataList.push(t), (this.dataCache = null);
};
Wn.isDark = function (e, t) {
  if (e < 0 || this.moduleCount <= e || t < 0 || this.moduleCount <= t)
    throw new Error(e + ',' + t);
  return this.modules[e][t];
};
Wn.getModuleCount = function () {
  return this.moduleCount;
};
Wn.make = function () {
  if (this.typeNumber < 1) {
    var e = 1;
    for (e = 1; e < 40; e++) {
      for (
        var t = NP.getRSBlocks(e, this.errorCorrectLevel), n = new UP(), r = 0, i = 0;
        i < t.length;
        i++
      )
        r += t[i].dataCount;
      for (var i = 0; i < this.dataList.length; i++) {
        var o = this.dataList[i];
        n.put(o.mode, 4), n.put(o.getLength(), po.getLengthInBits(o.mode, e)), o.write(n);
      }
      if (n.getLengthInBits() <= r * 8) break;
    }
    this.typeNumber = e;
  }
  this.makeImpl(!1, this.getBestMaskPattern());
};
Wn.makeImpl = function (e, t) {
  (this.moduleCount = this.typeNumber * 4 + 17), (this.modules = new Array(this.moduleCount));
  for (var n = 0; n < this.moduleCount; n++) {
    this.modules[n] = new Array(this.moduleCount);
    for (var r = 0; r < this.moduleCount; r++) this.modules[n][r] = null;
  }
  this.setupPositionProbePattern(0, 0),
    this.setupPositionProbePattern(this.moduleCount - 7, 0),
    this.setupPositionProbePattern(0, this.moduleCount - 7),
    this.setupPositionAdjustPattern(),
    this.setupTimingPattern(),
    this.setupTypeInfo(e, t),
    this.typeNumber >= 7 && this.setupTypeNumber(e),
    this.dataCache == null &&
      (this.dataCache = Fr.createData(this.typeNumber, this.errorCorrectLevel, this.dataList)),
    this.mapData(this.dataCache, t);
};
Wn.setupPositionProbePattern = function (e, t) {
  for (var n = -1; n <= 7; n++)
    if (!(e + n <= -1 || this.moduleCount <= e + n))
      for (var r = -1; r <= 7; r++)
        t + r <= -1 ||
          this.moduleCount <= t + r ||
          ((0 <= n && n <= 6 && (r == 0 || r == 6)) ||
          (0 <= r && r <= 6 && (n == 0 || n == 6)) ||
          (2 <= n && n <= 4 && 2 <= r && r <= 4)
            ? (this.modules[e + n][t + r] = !0)
            : (this.modules[e + n][t + r] = !1));
};
Wn.getBestMaskPattern = function () {
  for (var e = 0, t = 0, n = 0; n < 8; n++) {
    this.makeImpl(!0, n);
    var r = po.getLostPoint(this);
    (n == 0 || e > r) && ((e = r), (t = n));
  }
  return t;
};
Wn.createMovieClip = function (e, t, n) {
  var r = e.createEmptyMovieClip(t, n),
    i = 1;
  this.make();
  for (var o = 0; o < this.modules.length; o++)
    for (var a = o * i, c = 0; c < this.modules[o].length; c++) {
      var s = c * i,
        l = this.modules[o][c];
      l &&
        (r.beginFill(0, 100),
        r.moveTo(s, a),
        r.lineTo(s + i, a),
        r.lineTo(s + i, a + i),
        r.lineTo(s, a + i),
        r.endFill());
    }
  return r;
};
Wn.setupTimingPattern = function () {
  for (var e = 8; e < this.moduleCount - 8; e++)
    this.modules[e][6] == null && (this.modules[e][6] = e % 2 == 0);
  for (var t = 8; t < this.moduleCount - 8; t++)
    this.modules[6][t] == null && (this.modules[6][t] = t % 2 == 0);
};
Wn.setupPositionAdjustPattern = function () {
  for (var e = po.getPatternPosition(this.typeNumber), t = 0; t < e.length; t++)
    for (var n = 0; n < e.length; n++) {
      var r = e[t],
        i = e[n];
      if (this.modules[r][i] == null)
        for (var o = -2; o <= 2; o++)
          for (var a = -2; a <= 2; a++)
            o == -2 || o == 2 || a == -2 || a == 2 || (o == 0 && a == 0)
              ? (this.modules[r + o][i + a] = !0)
              : (this.modules[r + o][i + a] = !1);
    }
};
Wn.setupTypeNumber = function (e) {
  for (var t = po.getBCHTypeNumber(this.typeNumber), n = 0; n < 18; n++) {
    var r = !e && ((t >> n) & 1) == 1;
    this.modules[Math.floor(n / 3)][(n % 3) + this.moduleCount - 8 - 3] = r;
  }
  for (var n = 0; n < 18; n++) {
    var r = !e && ((t >> n) & 1) == 1;
    this.modules[(n % 3) + this.moduleCount - 8 - 3][Math.floor(n / 3)] = r;
  }
};
Wn.setupTypeInfo = function (e, t) {
  for (var n = (this.errorCorrectLevel << 3) | t, r = po.getBCHTypeInfo(n), i = 0; i < 15; i++) {
    var o = !e && ((r >> i) & 1) == 1;
    i < 6
      ? (this.modules[i][8] = o)
      : i < 8
        ? (this.modules[i + 1][8] = o)
        : (this.modules[this.moduleCount - 15 + i][8] = o);
  }
  for (var i = 0; i < 15; i++) {
    var o = !e && ((r >> i) & 1) == 1;
    i < 8
      ? (this.modules[8][this.moduleCount - i - 1] = o)
      : i < 9
        ? (this.modules[8][15 - i - 1 + 1] = o)
        : (this.modules[8][15 - i - 1] = o);
  }
  this.modules[this.moduleCount - 8][8] = !e;
};
Wn.mapData = function (e, t) {
  for (var n = -1, r = this.moduleCount - 1, i = 7, o = 0, a = this.moduleCount - 1; a > 0; a -= 2)
    for (a == 6 && a--; ; ) {
      for (var c = 0; c < 2; c++)
        if (this.modules[r][a - c] == null) {
          var s = !1;
          o < e.length && (s = ((e[o] >>> i) & 1) == 1);
          var l = po.getMask(t, r, a - c);
          l && (s = !s), (this.modules[r][a - c] = s), i--, i == -1 && (o++, (i = 7));
        }
      if (((r += n), r < 0 || this.moduleCount <= r)) {
        (r -= n), (n = -n);
        break;
      }
    }
};
Fr.PAD0 = 236;
Fr.PAD1 = 17;
Fr.createData = function (e, t, n) {
  for (var r = NP.getRSBlocks(e, t), i = new UP(), o = 0; o < n.length; o++) {
    var a = n[o];
    i.put(a.mode, 4), i.put(a.getLength(), po.getLengthInBits(a.mode, e)), a.write(i);
  }
  for (var c = 0, o = 0; o < r.length; o++) c += r[o].dataCount;
  if (i.getLengthInBits() > c * 8)
    throw new Error('code length overflow. (' + i.getLengthInBits() + '>' + c * 8 + ')');
  for (i.getLengthInBits() + 4 <= c * 8 && i.put(0, 4); i.getLengthInBits() % 8 != 0; )
    i.putBit(!1);
  for (; !(i.getLengthInBits() >= c * 8 || (i.put(Fr.PAD0, 8), i.getLengthInBits() >= c * 8)); )
    i.put(Fr.PAD1, 8);
  return Fr.createBytes(i, r);
};
Fr.createBytes = function (e, t) {
  for (
    var n = 0, r = 0, i = 0, o = new Array(t.length), a = new Array(t.length), c = 0;
    c < t.length;
    c++
  ) {
    var s = t[c].dataCount,
      l = t[c].totalCount - s;
    (r = Math.max(r, s)), (i = Math.max(i, l)), (o[c] = new Array(s));
    for (var u = 0; u < o[c].length; u++) o[c][u] = 255 & e.buffer[u + n];
    n += s;
    var d = po.getErrorCorrectPolynomial(l),
      f = new Dne(o[c], d.getLength() - 1),
      p = f.mod(d);
    a[c] = new Array(d.getLength() - 1);
    for (var u = 0; u < a[c].length; u++) {
      var y = u + p.getLength() - a[c].length;
      a[c][u] = y >= 0 ? p.get(y) : 0;
    }
  }
  for (var b = 0, u = 0; u < t.length; u++) b += t[u].totalCount;
  for (var m = new Array(b), w = 0, u = 0; u < r; u++)
    for (var c = 0; c < t.length; c++) u < o[c].length && (m[w++] = o[c][u]);
  for (var u = 0; u < i; u++)
    for (var c = 0; c < t.length; c++) u < a[c].length && (m[w++] = a[c][u]);
  return m;
};
var Rne = Fr;
function Fh(e) {
  return (
    typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
      ? (Fh = function (n) {
          return typeof n;
        })
      : (Fh = function (n) {
          return n &&
            typeof Symbol == 'function' &&
            n.constructor === Symbol &&
            n !== Symbol.prototype
            ? 'symbol'
            : typeof n;
        }),
    Fh(e)
  );
}
function bp() {
  return (
    (bp =
      Object.assign ||
      function (e) {
        for (var t = 1; t < arguments.length; t++) {
          var n = arguments[t];
          for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
        }
        return e;
      }),
    bp.apply(this, arguments)
  );
}
function JS(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable;
      })),
      n.push.apply(n, r);
  }
  return n;
}
function LP(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2
      ? JS(n, !0).forEach(function (r) {
          Do(e, r, n[r]);
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : JS(n).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
          });
  }
  return e;
}
function fw(e, t) {
  if (e == null) return {};
  var n = xne(e, t),
    r,
    i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (i = 0; i < o.length; i++)
      (r = o[i]),
        !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function xne(e, t) {
  if (e == null) return {};
  var n = {},
    r = Object.keys(e),
    i,
    o;
  for (o = 0; o < r.length; o++) (i = r[o]), !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function zP(e, t) {
  if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
}
function XS(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    (r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      'value' in r && (r.writable = !0),
      Object.defineProperty(e, r.key, r);
  }
}
function FP(e, t, n) {
  return t && XS(e.prototype, t), n && XS(e, n), e;
}
function $P(e, t) {
  return t && (Fh(t) === 'object' || typeof t == 'function') ? t : tc(e);
}
function mp(e) {
  return (
    (mp = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function (n) {
          return n.__proto__ || Object.getPrototypeOf(n);
        }),
    mp(e)
  );
}
function tc(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function WP(e, t) {
  if (typeof t != 'function' && t !== null)
    throw new TypeError('Super expression must either be null or a function');
  (e.prototype = Object.create(t && t.prototype, {
    constructor: { value: e, writable: !0, configurable: !0 },
  })),
    t && l0(e, t);
}
function l0(e, t) {
  return (
    (l0 =
      Object.setPrototypeOf ||
      function (r, i) {
        return (r.__proto__ = i), r;
      }),
    l0(e, t)
  );
}
function Do(e, t, n) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  );
}
var cr = G,
  VP = Rne,
  KP = RP;
function HP(e) {
  for (var t = '', n = 0; n < e.length; n++) {
    var r = e.charCodeAt(n);
    r < 128
      ? (t += String.fromCharCode(r))
      : r < 2048
        ? ((t += String.fromCharCode(192 | (r >> 6))), (t += String.fromCharCode(128 | (r & 63))))
        : r < 55296 || r >= 57344
          ? ((t += String.fromCharCode(224 | (r >> 12))),
            (t += String.fromCharCode(128 | ((r >> 6) & 63))),
            (t += String.fromCharCode(128 | (r & 63))))
          : (n++,
            (r = 65536 + (((r & 1023) << 10) | (e.charCodeAt(n) & 1023))),
            (t += String.fromCharCode(240 | (r >> 18))),
            (t += String.fromCharCode(128 | ((r >> 12) & 63))),
            (t += String.fromCharCode(128 | ((r >> 6) & 63))),
            (t += String.fromCharCode(128 | (r & 63))));
  }
  return t;
}
var hw = { size: 128, level: 'L', bgColor: '#FFFFFF', fgColor: '#000000', includeMargin: !1 },
  pw = 4,
  Bne = 0.1;
function qP(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
    n = [];
  return (
    e.forEach(function (r, i) {
      var o = null;
      r.forEach(function (a, c) {
        if (!a && o !== null) {
          n.push(
            'M'
              .concat(o + t, ' ')
              .concat(i + t, 'h')
              .concat(c - o, 'v1H')
              .concat(o + t, 'z')
          ),
            (o = null);
          return;
        }
        if (c === r.length - 1) {
          if (!a) return;
          o === null
            ? n.push(
                'M'
                  .concat(c + t, ',')
                  .concat(i + t, ' h1v1H')
                  .concat(c + t, 'z')
              )
            : n.push(
                'M'
                  .concat(o + t, ',')
                  .concat(i + t, ' h')
                  .concat(c + 1 - o, 'v1H')
                  .concat(o + t, 'z')
              );
          return;
        }
        a && o === null && (o = c);
      });
    }),
    n.join('')
  );
}
function GP(e, t) {
  return e.slice().map(function (n, r) {
    return r < t.y || r >= t.y + t.h
      ? n
      : n.map(function (i, o) {
          return o < t.x || o >= t.x + t.w ? i : !1;
        });
  });
}
function YP(e, t) {
  var n = e.imageSettings,
    r = e.size,
    i = e.includeMargin;
  if (n == null) return null;
  var o = i ? pw : 0,
    a = t.length + o * 2,
    c = Math.floor(r * Bne),
    s = a / r,
    l = (n.width || c) * s,
    u = (n.height || c) * s,
    d = n.x == null ? t.length / 2 - l / 2 : n.x * s,
    f = n.y == null ? t.length / 2 - u / 2 : n.y * s,
    p = null;
  if (n.excavate) {
    var y = Math.floor(d),
      b = Math.floor(f),
      m = Math.ceil(l + d - y),
      w = Math.ceil(u + f - b);
    p = { x: y, y: b, w: m, h: w };
  }
  return { x: d, y: f, h: u, w: l, excavation: p };
}
var jne = (function () {
    try {
      new Path2D().addPath(new Path2D());
    } catch {
      return !1;
    }
    return !0;
  })(),
  ZP = (function (e) {
    WP(t, e);
    function t() {
      var n, r;
      zP(this, t);
      for (var i = arguments.length, o = new Array(i), a = 0; a < i; a++) o[a] = arguments[a];
      return (
        (r = $P(this, (n = mp(t)).call.apply(n, [this].concat(o)))),
        Do(tc(r), '_canvas', void 0),
        Do(tc(r), '_image', void 0),
        Do(tc(r), 'state', { imgLoaded: !1 }),
        Do(tc(r), 'handleImageLoad', function () {
          r.setState({ imgLoaded: !0 });
        }),
        r
      );
    }
    return (
      FP(t, [
        {
          key: 'componentDidMount',
          value: function () {
            this._image && this._image.complete && this.handleImageLoad(), this.update();
          },
        },
        {
          key: 'componentWillReceiveProps',
          value: function (r) {
            var i,
              o,
              a = (i = this.props.imageSettings) === null || i === void 0 ? void 0 : i.src,
              c = (o = r.imageSettings) === null || o === void 0 ? void 0 : o.src;
            a !== c && this.setState({ imgLoaded: !1 });
          },
        },
        {
          key: 'componentDidUpdate',
          value: function () {
            this.update();
          },
        },
        {
          key: 'update',
          value: function () {
            var r = this.props,
              i = r.value,
              o = r.size,
              a = r.level,
              c = r.bgColor,
              s = r.fgColor,
              l = r.includeMargin,
              u = r.imageSettings,
              d = new VP(-1, KP[a]);
            if ((d.addData(HP(i)), d.make(), this._canvas != null)) {
              var f = this._canvas,
                p = f.getContext('2d');
              if (!p) return;
              var y = d.modules;
              if (y === null) return;
              var b = l ? pw : 0,
                m = y.length + b * 2,
                w = YP(this.props, y);
              u != null && w != null && w.excavation != null && (y = GP(y, w.excavation));
              var _ = window.devicePixelRatio || 1;
              f.height = f.width = o * _;
              var S = (o / m) * _;
              p.scale(S, S),
                (p.fillStyle = c),
                p.fillRect(0, 0, m, m),
                (p.fillStyle = s),
                jne
                  ? p.fill(new Path2D(qP(y, b)))
                  : y.forEach(function (E, O) {
                      E.forEach(function (N, F) {
                        N && p.fillRect(F + b, O + b, 1, 1);
                      });
                    }),
                this.state.imgLoaded &&
                  this._image &&
                  w != null &&
                  p.drawImage(this._image, w.x + b, w.y + b, w.w, w.h);
            }
          },
        },
        {
          key: 'render',
          value: function () {
            var r = this,
              i = this.props;
            i.value;
            var o = i.size;
            i.level, i.bgColor, i.fgColor;
            var a = i.style;
            i.includeMargin;
            var c = i.imageSettings,
              s = fw(i, [
                'value',
                'size',
                'level',
                'bgColor',
                'fgColor',
                'style',
                'includeMargin',
                'imageSettings',
              ]),
              l = LP({ height: o, width: o }, a),
              u = null,
              d = c && c.src;
            return (
              c != null &&
                d != null &&
                (u = cr.createElement('img', {
                  src: d,
                  style: { display: 'none' },
                  onLoad: this.handleImageLoad,
                  ref: function (p) {
                    return (r._image = p);
                  },
                })),
              cr.createElement(
                cr.Fragment,
                null,
                cr.createElement(
                  'canvas',
                  bp(
                    {
                      style: l,
                      height: o,
                      width: o,
                      ref: function (p) {
                        return (r._canvas = p);
                      },
                    },
                    s
                  )
                ),
                u
              )
            );
          },
        },
      ]),
      t
    );
  })(cr.PureComponent);
Do(ZP, 'defaultProps', hw);
var QP = (function (e) {
  WP(t, e);
  function t() {
    return zP(this, t), $P(this, mp(t).apply(this, arguments));
  }
  return (
    FP(t, [
      {
        key: 'render',
        value: function () {
          var r = this.props,
            i = r.value,
            o = r.size,
            a = r.level,
            c = r.bgColor,
            s = r.fgColor,
            l = r.includeMargin,
            u = r.imageSettings,
            d = fw(r, [
              'value',
              'size',
              'level',
              'bgColor',
              'fgColor',
              'includeMargin',
              'imageSettings',
            ]),
            f = new VP(-1, KP[a]);
          f.addData(HP(i)), f.make();
          var p = f.modules;
          if (p === null) return null;
          var y = l ? pw : 0,
            b = p.length + y * 2,
            m = YP(this.props, p),
            w = null;
          u != null &&
            m != null &&
            (m.excavation != null && (p = GP(p, m.excavation)),
            (w = cr.createElement('image', {
              xlinkHref: u.src,
              height: m.h,
              width: m.w,
              x: m.x + y,
              y: m.y + y,
              preserveAspectRatio: 'none',
            })));
          var _ = qP(p, y);
          return cr.createElement(
            'svg',
            bp(
              {
                shapeRendering: 'crispEdges',
                height: o,
                width: o,
                viewBox: '0 0 '.concat(b, ' ').concat(b),
              },
              d
            ),
            cr.createElement('path', { fill: c, d: 'M0,0 h'.concat(b, 'v').concat(b, 'H0z') }),
            cr.createElement('path', { fill: s, d: _ }),
            w
          );
        },
      },
    ]),
    t
  );
})(cr.PureComponent);
Do(QP, 'defaultProps', hw);
var JP = function (t) {
  var n = t.renderAs,
    r = fw(t, ['renderAs']),
    i = n === 'svg' ? QP : ZP;
  return cr.createElement(i, r);
};
JP.defaultProps = LP({ renderAs: 'canvas' }, hw);
var Nne = JP;
const Une = Oc(Nne),
  gw = { address: h.string(), networkID: oa },
  Lne = h.object(gw),
  zne = 48,
  Fne = () => {
    const { t: e } = ia(),
      t = t6(),
      n = W0(),
      r = G.useMemo(() => {
        try {
          return Lne.parse(t);
        } catch {
          return null;
        }
      }, [t]);
    if (!r) return null;
    const { address: i, networkID: o } = r;
    return A.jsxs(Dt, {
      className: ft({
        alignItems: 'center',
        textAlign: 'center',
        marginTop: 16,
        marginLeft: 16,
        marginRight: 16,
      }),
      children: [
        A.jsx(Lt, { font: 'heading3', children: e('depositAddress') }),
        A.jsxs('div', {
          className: ft({
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            marginTop: 32,
            marginBottom: 32,
          }),
          children: [
            A.jsx(Une, {
              value: i,
              size: 160,
              level: 'Q',
              className: ft({ padding: 8, backgroundColor: 'white', borderRadius: 6 }),
            }),
            A.jsx(Z1, {
              networkID: o,
              size: zne,
              borderColor: 'bgWallet',
              className: ft({ position: 'absolute' }),
            }),
          ],
        }),
        A.jsx(Lt, {
          font: 'bodySemibold',
          className: ft({ marginBottom: 8 }),
          children: e('depositAddressChainInterpolated', { chain: q.getNetworkName(o) }),
        }),
        A.jsx($ne, { value: i }),
        A.jsxs(Lt, {
          font: 'caption',
          color: 'textTertiary',
          className: ft({ marginTop: 8, marginBottom: 16 }),
          children: [
            e('depositAssetSecondaryText'),
            ' ',
            A.jsx('a', {
              href: v6,
              target: '_blank',
              rel: 'noopener noreferrer',
              className: ft({ color: 'accentPrimary' }),
              style: { textDecoration: 'none', fontWeight: 500 },
              children: e('commandLearnMore'),
            }),
          ],
        }),
        A.jsx(O3, {
          onClick: () => void n.pop(),
          theme: 'secondary',
          style: { width: '328px' },
          children: e('commandBack'),
        }),
      ],
    });
  },
  $ne = ({ value: e }) => {
    const { buttonText: t, copy: n } = JM(e);
    return A.jsxs('div', {
      children: [
        A.jsx(Dt, {
          padding: 14,
          backgroundColor: 'bgArea',
          width: 300,
          borderBottomRadius: 6,
          borderStyle: 'solid',
          borderWidth: 1,
          borderColor: 'borderSecondary',
          children: A.jsx(Lt, {
            font: 'body',
            width: '100%',
            overflowWrap: 'break-word',
            children: e,
          }),
        }),
        A.jsxs(Dt, {
          width: 300,
          direction: 'row',
          justifyContent: 'center',
          alignItems: 'center',
          cursor: 'pointer',
          borderBottomRadius: 6,
          borderStyle: 'solid',
          borderWidth: 1,
          borderColor: 'borderSecondary',
          backgroundColor: ['bgArea', 'black'],
          padding: 14,
          onPress: n,
          children: [
            A.jsx(k0, { size: 16 }),
            A.jsx(Lt, { font: 'body', marginLeft: 6, children: t }),
          ],
        }),
      ],
    });
  },
  Wne = Object.freeze(
    Object.defineProperty(
      { __proto__: null, DepositAddress: Fne, DepositAddressParams: gw },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  Vne = Ue.lazy(() =>
    Rt(
      () => import('./Receive-CyVcfMeb.js'),
      __vite__mapDeps([35, 7, 6, 2, 1, 3, 4, 5, 8, 0, 9, 10, 11, 12, 13, 15, 17, 18])
    ).then((e) => ({ default: e.Receive }))
  ),
  Kne = Ue.lazy(() =>
    Rt(() => Promise.resolve().then(() => Wne), void 0).then((e) => ({ default: e.DepositAddress }))
  ),
  Hne = Qn({
    id: 'receive',
    initialViewId: 'receive',
    display: 'modal',
    views: [
      { id: 'receive', element: A.jsx(Vne, {}) },
      { id: 'deposit-address', params: gw, element: A.jsx(Kne, {}) },
    ],
    stacks: [],
  }),
  qne = Ue.lazy(() =>
    Rt(
      () => import('./RestoreAccount-DQzzB3Yq.js'),
      __vite__mapDeps([36, 7, 6, 2, 1, 3, 4, 5, 8, 0, 9, 10, 11, 12, 13, 15, 33, 16, 17, 18])
    ).then((e) => ({ default: e.RestoreAccount }))
  ),
  Gne = Qn({
    id: 'restoreAccount',
    initialViewId: 'restore',
    display: 'modal',
    views: [{ id: 'restore', element: A.jsx(qne, {}) }],
    stacks: [],
  }),
  Yne = Ue.lazy(() =>
    Rt(
      () => import('./SendFungibleFlow-C3qfpO-l.js'),
      __vite__mapDeps([37, 7, 6, 2, 1, 3, 4, 5, 8, 15, 0, 9, 10, 11, 12, 13, 23, 17, 18])
    ).then((e) => ({ default: e.SendFungibleFlow }))
  ),
  Zne = Qn({
    id: 'send',
    initialViewId: 'send-fungible',
    views: [{ id: 'send-fungible', element: A.jsx(Yne, {}) }],
    display: 'modal',
    stacks: [],
  }),
  Qne = h.object({ data: h.string(), from: h.string(), to: h.string() });
h.object({ transaction: Qne });
const Jne = '25.13.0',
  Ds = `fungible-tokens-${Jne}`,
  Xne = [Ds, 'token-updates'],
  ere = [Ds, 'token-details'],
  tre = [Ds, 'portfolio-value'],
  nre = [Ds, 'token-balance'],
  rre = [Ds, 'infinite-token-balances'],
  ire = [Ds, 'visibility-overrides'],
  cy = {
    infiniteTokenBalances: ({ walletCaip19s: e }) => [...rre, { walletCaip19s: e }],
    tokenBalance: ({ wallets: e, encodedCaip19: t, isSplCompressed: n }) => {
      const r = e
        .map((i) =>
          typeof i == 'string'
            ? i
            : to({ chainId: i.networkID, address: i.address, resourceType: sn.address })
        )
        .sort();
      return [...nre, { walletCaip19s: r, encodedCaip19: t, isSplCompressed: n }];
    },
    tokenUpdates: ({ walletCaip19s: e, from: t }) => [...Xne, { walletCaip19s: e, from: t }],
    portfolioValue: ({ walletCaip19s: e, include: t, exclude: n, isMainnet: r }) => [
      ...tre,
      { walletCaip19s: e, include: t, exclude: n, isMainnet: r },
    ],
    visibilityOverrides: ({ accountId: e }) => [...ire, { accountId: e }],
    tokenDetails: ({ caip19: e, includePrice: t }) => [...ere, { caip19: e, includePrice: t }],
  },
  tn = [];
for (let e = 0; e < 256; ++e) tn.push((e + 256).toString(16).slice(1));
function ore(e, t = 0) {
  return (
    tn[e[t + 0]] +
    tn[e[t + 1]] +
    tn[e[t + 2]] +
    tn[e[t + 3]] +
    '-' +
    tn[e[t + 4]] +
    tn[e[t + 5]] +
    '-' +
    tn[e[t + 6]] +
    tn[e[t + 7]] +
    '-' +
    tn[e[t + 8]] +
    tn[e[t + 9]] +
    '-' +
    tn[e[t + 10]] +
    tn[e[t + 11]] +
    tn[e[t + 12]] +
    tn[e[t + 13]] +
    tn[e[t + 14]] +
    tn[e[t + 15]]
  ).toLowerCase();
}
let qb;
const are = new Uint8Array(16);
function sre() {
  if (!qb) {
    if (typeof crypto > 'u' || !crypto.getRandomValues)
      throw new Error(
        'crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported'
      );
    qb = crypto.getRandomValues.bind(crypto);
  }
  return qb(are);
}
const cre = typeof crypto < 'u' && crypto.randomUUID && crypto.randomUUID.bind(crypto),
  eA = { randomUUID: cre };
function ure(e, t, n) {
  var i;
  if (eA.randomUUID && !t && !e) return eA.randomUUID();
  e = e || {};
  const r = e.random ?? ((i = e.rng) == null ? void 0 : i.call(e)) ?? sre();
  if (r.length < 16) throw new Error('Random bytes length must be >= 16');
  if (((r[6] = (r[6] & 15) | 64), (r[8] = (r[8] & 63) | 128), t)) {
    if (((n = n || 0), n < 0 || n + 16 > t.length))
      throw new RangeError(`UUID byte range ${n}:${n + 15} is out of buffer bounds`);
    for (let o = 0; o < 16; ++o) t[n + o] = r[o];
    return t;
  }
  return ore(r);
}
const XP = {
  recipient: '',
  recipientHandle: '',
  addressBookRecipient: void 0,
  amountAsset: new oe(0),
  amountUsd: 0,
  transactionSpeed: 'standard',
  solana: { references: [] },
  multichainTransaction: void 0,
};
class Ale extends Error {
  constructor(t) {
    super(t), (this.name = 'SendFungibleFlowError');
  }
}
const tA = {
    sendSessionId: '',
    encodedCaip19: void 0,
    fungibleKey: void 0,
    splTokenAccount: void 0,
    analyticsRecipient: void 0,
    sendFormValues: XP,
    shouldShowFiatValues: !1,
    retryArgs: void 0,
    confirmedFungibleAndSender: null,
    gasEstimation: void 0,
  },
  Ile = aa((e, t) => ({
    ...rp(tA),
    resetSendSlice: () => {
      const n = rp(tA);
      (n.sendSessionId = ure()), e(n);
    },
    setAnalyticsRecipient: (n) => {
      e({ analyticsRecipient: n });
    },
    setSendFungibleKey: (n, r, i) => {
      e({ fungibleKey: n, splTokenAccount: r, encodedCaip19: i });
    },
    setSendFormValues: (n) => {
      e({ sendFormValues: n });
    },
    setInputAmount: (n) => {
      const r = t();
      e({ sendFormValues: { ...r.sendFormValues, inputAmount: n } });
    },
    setShouldShowFiatValues: (n) => {
      e({ shouldShowFiatValues: n });
    },
    setRetryArgs: (n) => {
      e({ retryArgs: n });
    },
    setGasEstimation: (n) => {
      e({ gasEstimation: n });
    },
  })),
  nA = { collectible: void 0, sendFormValues: XP, shouldRequireAmount: !1 };
aa((e) => ({
  ...nA,
  resetSendSlice: () => {
    e({ ...nA });
  },
  setSendCollectible: (t) => {
    e({ collectible: t });
  },
  setSendFormValues: (t) => {
    e({ sendFormValues: t });
  },
  setShouldRequireAmount: (t) => {
    e({ shouldRequireAmount: t });
  },
}));
const lre = { query: '' };
aa((e) => ({
  ...lre,
  setQuery: (t) => {
    e({ query: t });
  },
}));
const Gb = new oe(0),
  Ele = ({
    chainAddress: e,
    type: t,
    balance: n,
    decimals: r,
    recipient: i,
    gasEstimation: o,
    clampToZero: a = !0,
  }) => {
    const { data: c, isPending: s } = bP(e);
    if (!t || !n) return Gb;
    const l = new oe(n).multipliedBy(Ec(r));
    if (!gi(t)) return l;
    if (!o) return;
    let u = new oe(0);
    if (rq(o)) u = l.minus(new oe(o.value));
    else if (oq(o)) {
      const { gasLimit: d, maxFeePerGas: f, l1Fee: p = new oe(0) } = o,
        y = d.times(f).plus(p);
      u = l.minus(y);
    } else if (aq(o)) {
      if (!e || s) return;
      const d = e.addressType,
        f = (c == null ? void 0 : c.safeToSendUtxos) ?? [],
        p = Bf(o.btcPerKilobyte),
        y = i && tI.safeParse(i).success ? i : 'bc1p',
        m = [
          { value: f.reduce((_, S) => _.plus(new oe(S.value)), new oe(0)).toNumber(), address: y },
        ],
        w = G1(d, f, m, p.toNumber(), []);
      if (w.type === 'error') u = new oe(w.maxAmount).integerValue(oe.ROUND_DOWN);
      else {
        const { inputs: _, fee: S } = w;
        u = _.reduce((O, N) => O.plus(new oe(N.value)), new oe(0))
          .minus(S)
          .integerValue(oe.ROUND_DOWN);
      }
    } else if (iq(o)) u = l.minus(o.gasBudget);
    else return Sn();
    return u.isGreaterThan(Gb) ? u : a ? Gb : u;
  };
new dP('Unable to unwrap SOL. Wrapped SOL Token account does not exist.');
const rA = ae({ minutes: 1 }),
  Tle = (e, t = !0) => {
    const n = ea.solanaBalance(e);
    return pt({
      enabled: !!e && t && qw(e),
      gcTime: rA,
      staleTime: rA,
      queryKey: n,
      async queryFn() {
        if (!e) throw new Error('No chain address provided');
        if (qw(e)) return fa(e.networkID).getBalance(new Ye(e.address));
        throw new Error(`SOL balance not implemented for ${e.networkID}`);
      },
    });
  },
  yw = (e) => {
    var t;
    return (t = RX(e)) == null ? void 0 : t[0];
  },
  dre = (e) =>
    q.isBitcoinNetworkID(e.decodedCaip19.chainId) && e.decodedCaip19.resourceType === sn.nativeToken
      ? e.queriedWalletBalances.map((r) => {
          const i = br(e.decodedCaip19.chainId, r.address);
          return {
            ...e,
            queriedWalletBalances: [r],
            totalQuantity: r.quantity,
            totalQuantityString: r.quantityString,
            walletAddress: r.address,
            legacyKey: fc
              .get(e.decodedCaip19.chainId)
              .nativeTokenFungibleBalanceKey(e.decodedCaip19.chainId, i),
          };
        })
      : e,
  eO = (e) => (t) =>
    t.flatMap((n) => {
      const r = e(n);
      return dre(r);
    }),
  fre = (e) => {
    const { caip19: t, ...n } = e,
      r = Rp(t);
    return {
      ...n,
      type: t.includes('/nativeToken:') ? 'native' : 'fungible',
      chainName: q.getChainName(r.chainId),
      encodedCaip19: t,
      decodedCaip19: r,
      legacyKey: yw(r),
    };
  },
  hre = (e) => {
    const { caip19: t, timestamp: n, ...r } = e,
      i = Rp(t);
    return {
      ...r,
      type: t.includes('/nativeToken:') ? 'native' : 'fungible',
      encodedCaip19: t,
      decodedCaip19: i,
      chainName: q.getChainName(i.chainId),
      timestamp: n ?? void 0,
      legacyKey: yw(i),
      totalQuantity: e.postQuantity,
      totalQuantityString: e.postQuantityString,
    };
  },
  pre = eO(fre),
  gre = eO(hre),
  yre = h.object({ account: h.string(), quantity: h.number(), quantityString: h.string() }),
  bre = h.object({
    address: h.string(),
    quantity: h.number(),
    quantityString: h.string(),
    lastTransferredDate: h.coerce.date().nullish(),
    subaccounts: h.array(yre).optional(),
  }),
  tO = h
    .object({
      price: h.number(),
      priceChange24h: h.number().optional(),
      lastUpdatedAt: h.coerce.date(),
    })
    .nullish(),
  mre = h.object({
    price: h.number(),
    priceChange24h: h.number().optional(),
    lastUpdatedAt: h.coerce.date(),
  }),
  bw = {
    name: h.string().nullish(),
    symbol: h.string().nullish(),
    decimals: h.number(),
    spamStatus: h.enum(['VERIFIED', 'NOT_VERIFIED', 'POSSIBLE_SPAM', 'SPAM']).nullish(),
    logoUri: h.string().nullish(),
    price: tO,
    livePrice: mre.nullish().optional(),
    queriedWalletBalances: h.array(bre),
    extraMetadata: h
      .object({
        compression: h.object({ compressed: h.boolean() }).optional(),
        tokenProgram: h.string().nullish(),
        extensions: h.array(h.unknown()).nullish(),
      })
      .optional(),
  },
  mw = h.object({
    ...bw,
    type: h.enum(['native', 'fungible']),
    totalQuantity: h.number(),
    totalQuantityString: h.string(),
    encodedCaip19: h.string(),
    decodedCaip19: Op,
    chainName: h.string(),
    legacyKey: h.string().nullish(),
    timestamp: h.string().optional(),
    walletAddress: h.string().optional(),
  });
mw.omit({
  totalQuantity: !0,
  totalQuantityString: !0,
  queriedWalletBalances: !0,
  walletAddress: !0,
});
const nO = h.object({
  ...bw,
  caip19: h.string(),
  totalQuantity: h.number(),
  totalQuantityString: h.string(),
});
nO.omit({ totalQuantity: !0, totalQuantityString: !0, queriedWalletBalances: !0 });
const wre = h
    .object({ items: h.array(nO), cursor: h.string().nullish().default(null) })
    .transform((e) => {
      const { items: t, cursor: n, ...r } = e;
      return { ...r, nextCursor: n, tokens: t, updatedAt: Date.now() };
    }),
  _re = h.object({
    ...bw,
    caip19: h.string(),
    timestamp: h.string().nullish(),
    postQuantityString: h.string(),
    postQuantity: h.number(),
  }),
  vre = h
    .object({ cursor: h.string().nullish().default(null), items: h.array(_re) })
    .transform((e) => ({ nextCursor: e.cursor, transfers: e.items })),
  kle = h.object({
    totalValueUsdCentsCurrent: h.number(),
    totalValueUsdStringCurrent: h.string(),
    totalValueUsdCents24h: h.number(),
    totalValueUsdString24h: h.string(),
    totalPercentChange24h: h.number(),
  }),
  Cle = h.object({
    totalValueUsdCentsCurrent: h.number().optional(),
    totalValueUsdStringCurrent: h.string().optional(),
    totalValueUsdCents24h: h.number().optional(),
    totalValueUsdString24h: h.string().optional(),
    totalPercentChange24h: h.number().optional(),
  }),
  iA = h.object({
    caip19: h.string(),
    name: h.string(),
    symbol: h.string(),
    decimals: h.number(),
    logoUri: h.string().nullish().default(null),
    spamStatus: h
      .enum(['VERIFIED', 'NOT_VERIFIED', 'POSSIBLE_SPAM', 'SPAM'])
      .nullish()
      .transform((e) => e ?? 'NOT_VERIFIED'),
    createdDate: h.coerce.date().nullish().default(null),
    extraMetadata: h.object({
      isMutable: h.boolean().nullish().default(null),
      creators: h
        .array(h.object({ address: h.string(), share: h.number(), verified: h.boolean() }))
        .nullish(),
      tokenProgram: h.string().nullish(),
      extensions: h.array(h.unknown()).nullish(),
    }),
    categories: h
      .object({
        id: h.string(),
        name: h.string(),
        imageUri: h
          .string()
          .nullish()
          .transform((e) => e ?? ''),
        numTokens: h.number(),
      })
      .array()
      .optional(),
  }),
  Sre = iA.extend({
    price: tO,
    extraMetadata: iA.shape.extraMetadata.extend({
      id: h.string().nullish().default(null),
      description: h.string().nullish().default(null),
      marketCap: h.coerce.number().optional(),
      circulatingSupply: h.coerce.number().optional(),
      totalSupply: h.coerce.number().optional(),
      liquidity: h.coerce.number().optional(),
      holders: h.coerce.number().optional(),
      links: h.array(h.object({ type: h.string(), url: h.string() })).optional(),
      volume24hUSD: h.coerce.number().optional(),
      volume24hUSDChangePercentage: h.coerce.number().optional(),
      trades24h: h.coerce.number().optional(),
      trades24hChangePercentage: h.coerce.number().optional(),
      uniqueWallets24h: h.coerce.number().optional(),
      uniqueWallets24hChangePercentage: h.coerce.number().optional(),
      top10HoldersPercent: h.coerce.number().optional(),
      mintable: h.boolean().optional(),
      freezable: h.boolean().optional(),
      mutableMetadata: h.boolean().optional(),
      ownershipRenounced: h.boolean().optional(),
      updateAuthority: h.string().optional(),
    }),
  });
Sre.transform(({ caip19: e, ...t }) => {
  const n = Rp(e);
  return {
    ...t,
    type: e.includes('/nativeToken:') ? 'native' : 'fungible',
    chainName: q.getChainName(n.chainId),
    encodedCaip19: e,
    decodedCaip19: n,
    legacyKey: yw(n) ?? e,
  };
});
const Are = ae({ minutes: 10 });
async function rO({ walletCaip19s: e, fungibleCaip19s: t, cursor: n }) {
  const r = { walletAddresses: e.join(','), includePrices: 'true' };
  n && (r.cursor = n), t && t.length > 0 && (r.fungibleAddresses = t.sort().join(','));
  try {
    const i = await ke
        .api()
        .timeout(ae({ seconds: 30 }))
        .get('/portfolio/v1/fungibles/balances', { params: r })
        .then((a) => {
          var c, s, l;
          if (hn(a)) return a.data;
          throw new Error(
            ((c = a.data) == null ? void 0 : c.message) ||
              ((s = a.data) == null ? void 0 : s.error) ||
              a.statusText,
            { cause: (l = a.data) == null ? void 0 : l.code }
          );
        }),
      o = wre.parse(i);
    return { ...o, tokens: pre(o.tokens) };
  } catch (i) {
    throw (
      (i instanceof Error &&
        (Z.addBreadcrumb(te.Tokens, 'getTokenBalances', Te.Error, {
          ...r,
          message: i.message,
          ...(typeof i.cause == 'string' || typeof i.cause == 'number' ? { cause: i.cause } : {}),
        }),
        Z.captureError(i, te.Tokens)),
      i)
    );
  }
}
function Ire({ walletCaip19s: e, isEnabled: t = !0 }) {
  return {
    staleTime: Are,
    gcTime: ae({ days: 3 }),
    queryKey: cy.infiniteTokenBalances({ walletCaip19s: e }),
    enabled: t && !!e.length,
    queryFn: async ({ pageParam: n }) => rO({ walletCaip19s: e, cursor: n }),
    initialPageParam: '',
    getNextPageParam: (n) => (n == null ? void 0 : n.nextCursor) || void 0,
  };
}
function Mle(e) {
  const { walletCaip19s: t, encodedCaip19: n, queryOptions: r = { enabled: !0 } } = e;
  return {
    staleTime: ae({ seconds: 10 }),
    gcTime: ae({ days: 3 }),
    queryKey: cy.tokenBalance({ wallets: t, encodedCaip19: n }),
    enabled: r.enabled && !!t.length,
    queryFn: async () => (await rO({ walletCaip19s: t, fungibleCaip19s: [n] })).tokens,
  };
}
const uy = Je(new iI());
function d0() {
  return (
    (d0 = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
          }
          return e;
        }),
    d0.apply(this, arguments)
  );
}
const Ere = (e, t, n) => (e == null ? void 0 : e.suspense) && Tre(t, n),
  Tre = (e, t) => e.isPending && !t,
  kre = ({ result: e, throwOnError: t, query: n }) =>
    e.isError && !e.isFetching && Cre(t, [e.error, n]);
function Cre(e, t) {
  return typeof e == 'function' ? e(...t) : !!e;
}
const Mre = (e) =>
  e.suspense && typeof e.staleTime != 'number' ? d0({}, e, { staleTime: 1e3 }) : e;
function iO(e, t, n = (r) => r(uy)) {
  const r = Je(0),
    i = Je(n),
    o = Je(() => new WeakMap()),
    a = Je((l) => {
      const u = l(i),
        d = e(l),
        f = u.defaultQueryOptions(d),
        p = l(o).get(u);
      return (f._optimisticResults = 'optimistic'), p && p.setOptions(f, { listeners: !1 }), Mre(f);
    }),
    c = Je((l) => {
      const u = l(i),
        d = l(a),
        f = l(o),
        p = f.get(u);
      if (p) return p;
      const y = new t(u, d);
      return f.set(u, y), y;
    }),
    s = Je((l) => {
      const u = l(c),
        d = l(a),
        f = u.getOptimisticResult(d),
        p = Je(f);
      return (
        (p.onMount = (y) => {
          const b = u.subscribe(fI.batchCalls(y));
          return () => {
            u.getCurrentResult().isError && u.getCurrentQuery().reset(), b();
          };
        }),
        p
      );
    });
  return Je(
    (l) => {
      l(r);
      const u = l(c),
        d = l(a),
        f = l(l(s));
      if (Ere(d, f, !1)) return u.fetchOptimistic(d);
      if (kre({ result: f, query: u.getCurrentQuery(), throwOnError: d.throwOnError }))
        throw f.error;
      return f;
    },
    (l, u) => {
      u(r, (d) => d + 1);
    }
  );
}
function oO(e, t = (n) => n(uy)) {
  return iO(e, N2, t);
}
function Pre(e, t = (n) => n(uy)) {
  return iO(e, U2, t);
}
const Ore = {
    BASE_URL: '/',
    DEV: !1,
    MODE: 'production',
    PROD: !0,
    SSR: !1,
    VITE_DATADOG_CLIENT_TOKEN: 'pubf4dfb4e9016d7a11cef2cab4d41ee6ef',
    VITE_DEPLOY_ENVIRONMENT: 'production',
    VITE_RUDDERSTACK_KEY_BROWSER_EMBEDDED: 'cc94b84a-50e8-4aae-8296-ac417de90524',
  },
  Yb = (e, t, n) => (t.has(n) ? t : t.set(n, e())).get(n),
  Dre = new WeakMap(),
  Rre = (e, t, n, r) => {
    const i = Yb(() => new WeakMap(), Dre, t),
      o = Yb(() => new WeakMap(), i, n);
    return Yb(e, o, r);
  };
function Rs(e, t, n = Object.is) {
  return Rre(
    () => {
      const r = Symbol(),
        i = ([a, c]) => {
          if (c === r) return t(a);
          const s = t(a, c);
          return n(c, s) ? c : s;
        },
        o = Je((a) => {
          const c = a(o),
            s = a(e);
          return i([s, c]);
        });
      return (o.init = r), o;
    },
    e,
    t,
    n
  );
}
const xre = (e) => typeof (e == null ? void 0 : e.then) == 'function';
function Bre(
  e = () => {
    try {
      return window.localStorage;
    } catch (n) {
      (Ore ? 'production' : void 0) !== 'production' && typeof window < 'u' && console.warn(n);
      return;
    }
  },
  t
) {
  var n;
  let r, i;
  const o = {
      getItem: (s, l) => {
        var u, d;
        const f = (y) => {
            if (((y = y || ''), r !== y)) {
              try {
                i = JSON.parse(y, t == null ? void 0 : t.reviver);
              } catch {
                return l;
              }
              r = y;
            }
            return i;
          },
          p = (d = (u = e()) == null ? void 0 : u.getItem(s)) != null ? d : null;
        return xre(p) ? p.then(f) : f(p);
      },
      setItem: (s, l) => {
        var u;
        return (u = e()) == null
          ? void 0
          : u.setItem(s, JSON.stringify(l, t == null ? void 0 : t.replacer));
      },
      removeItem: (s) => {
        var l;
        return (l = e()) == null ? void 0 : l.removeItem(s);
      },
    },
    a = (s) => (l, u, d) =>
      s(l, (f) => {
        let p;
        try {
          p = JSON.parse(f || '');
        } catch {
          p = d;
        }
        u(p);
      });
  let c;
  try {
    c = (n = e()) == null ? void 0 : n.subscribe;
  } catch {}
  return (
    !c &&
      typeof window < 'u' &&
      typeof window.addEventListener == 'function' &&
      window.Storage &&
      (c = (s, l) => {
        if (!(e() instanceof window.Storage)) return () => {};
        const u = (d) => {
          d.storageArea === e() && d.key === s && l(d.newValue);
        };
        return (
          window.addEventListener('storage', u),
          () => {
            window.removeEventListener('storage', u);
          }
        );
      }),
    c && (o.subscribe = a(c)),
    o
  );
}
Bre();
function Uo(e) {
  const t = Je(0),
    n = Je(
      () => ({ i: 0 }),
      (s, l) => {
        const u = s(n);
        return (
          Object.assign(u, { m: !0, peek: s, set: l }),
          l(t, (d) => d + 1),
          () => {
            (u.m = !1), a(u), c(u);
          }
        );
      }
    );
  n.onMount = (s) => s();
  const r = Je((s) => {
      s(t);
      const l = s(n);
      if (!l.m || l.irc || (l.i && !l.irf)) return l.p;
      c(l);
      const u = new Map(),
        d = (b) => {
          const m = s(b);
          return u.set(b, m), m;
        };
      d.peek = l.peek;
      const f = (...b) => {
        try {
          return ++l.i, l.set(...b);
        } finally {
          Array.from(u.keys(), s), --l.i;
        }
      };
      f.recurse = (b, ...m) => {
        if (!l.fc)
          try {
            return (l.irc = !0), l.set(b, ...m);
          } finally {
            (l.irc = !1), Array.from(u).some(p) && o(l);
          }
      };
      function p([b, m]) {
        return s(b) !== m;
      }
      ++l.i;
      function y() {
        try {
          if (((l.irf = !1), !l.m)) return;
          a(l), (l.c = i.effect(d, f));
        } catch (b) {
          (l.e = b), o(l);
        } finally {
          (l.p = void 0), --l.i;
        }
      }
      return l.irf ? y() : (l.p = Promise.resolve().then(y));
    }),
    i = Je((s) => void s(r));
  return (i.effect = e), i;
  function o(s) {
    try {
      (s.irf = !0), s.set(t, (l) => l + 1);
    } finally {
      s.irf = !1;
    }
  }
  function a(s) {
    if (typeof s.c == 'function')
      try {
        (s.fc = !0), s.c();
      } finally {
        (s.fc = !1), (s.c = void 0);
      }
  }
  function c(s) {
    if ('e' in s) {
      const l = s.e;
      throw (delete s.e, l);
    }
  }
}
const jre = () => {
  var e;
  try {
    return (
      typeof chrome < 'u' &&
      (((e = chrome.runtime) == null ? void 0 : e.id) !== void 0 || typeof browser < 'u')
    );
  } catch (t) {
    return console.error('Error checking for extension context:', t), !1;
  }
};
class Nre {
  constructor(t) {
    Le(this, 'browser');
    Le(this, 'storage');
    if (!t || !t.storage || !t.storage.local)
      throw new Error("[ExtensionStorage] Invalid 'browser' object received.");
    (this.browser = t), (this.storage = this.browser.storage.local);
  }
  async get(t) {
    try {
      const r = (await this.storage.get(t))[t];
      return r == null || typeof r != 'string' ? null : JSON.parse(r);
    } catch (n) {
      return console.error(`[ExtensionStorage.get] Error getting/parsing key (${t}):`, n), null;
    }
  }
  async getAll(t) {
    try {
      const n = await this.storage.get(t),
        r = {};
      for (const i in n)
        if (Object.prototype.hasOwnProperty.call(n, i)) {
          const o = n[i];
          if (o == null || typeof o != 'string') r[i] = null;
          else
            try {
              r[i] = JSON.parse(o);
            } catch (a) {
              console.error(`[ExtensionStorage.getAll] Error parsing key (${i}):`, a),
                (r[i] = null);
            }
        }
      return r;
    } catch (n) {
      const r = `[ExtensionStorage.getAll] Error getting keys (${t}): ${n}`;
      throw (console.error(r), new Error(r));
    }
  }
  async remove(t) {
    try {
      await this.storage.remove(t);
    } catch (n) {
      const r = `[ExtensionStorage.remove] Error removing key(s) (${t}): ${n}`;
      throw (console.error(r), new Error(r));
    }
  }
  async set(t, n) {
    try {
      const r = JSON.stringify(n);
      await this.storage.set({ [t]: r });
    } catch (r) {
      const i = `[ExtensionStorage.set] Error setting/stringifying key (${t}): ${r}`;
      throw (console.error(i), new Error(i));
    }
  }
  async setAll(t) {
    try {
      const n = {};
      for (const r in t)
        Object.prototype.hasOwnProperty.call(t, r) && (n[r] = JSON.stringify(t[r]));
      await this.storage.set(n);
    } catch (n) {
      const i = `[ExtensionStorage.setAll] Error setting/stringifying keys (${Object.keys(t)}): ${n}`;
      throw (console.error(i), new Error(i));
    }
  }
  async update(t, n) {
    if (!navigator.locks) {
      const r = await this.get(t),
        i = await n(r);
      i === null ? await this.remove(t) : await this.set(t, i);
      return;
    }
    try {
      await navigator.locks.request(`storage.${t}`, async (r) => {
        const i = await this.get(t),
          o = await n(i);
        o === null ? await this.remove(t) : await this.set(t, o);
      });
    } catch (r) {
      const i = `[ExtensionStorage.update] Error updating key (${t}): ${r}`;
      throw (console.error(i), new Error(i));
    }
  }
  async clear() {
    try {
      await this.storage.clear();
    } catch (t) {
      const n = `[ExtensionStorage.clear] Error clearing storage: ${t}`;
      throw (console.error(n), new Error(n));
    }
  }
}
class oA {
  constructor() {
    Le(this, 'storage', window.localStorage);
  }
  async get(t) {
    try {
      const n = this.storage.getItem(t);
      return n === null || typeof n != 'string' ? null : JSON.parse(n);
    } catch (n) {
      return console.error(`[WebLocalStorage.get] Error getting/parsing key (${t}):`, n), null;
    }
  }
  async getAll(t) {
    const n = {},
      r = t ?? Object.keys(this.storage);
    for (const i of r)
      try {
        const o = this.storage.getItem(i);
        if (t && o === null) continue;
        if (o === null || typeof o != 'string') n[i] = null;
        else
          try {
            n[i] = JSON.parse(o);
          } catch (a) {
            console.error(`[WebLocalStorage.getAll] Error parsing key (${i}):`, a), (n[i] = null);
          }
      } catch (o) {
        console.error(`[WebLocalStorage.getAll] Error reading key (${i}) from storage:`, o),
          t || (n[i] = null);
      }
    return n;
  }
  async remove(t) {
    try {
      const n = Array.isArray(t) ? t : [t];
      for (const r of n) this.storage.removeItem(r);
    } catch (n) {
      const r = `[WebLocalStorage.remove] Error removing key(s) (${t}): ${n}`;
      throw (console.error(r), new Error(r));
    }
  }
  async set(t, n) {
    try {
      const r = JSON.stringify(n);
      this.storage.setItem(t, r);
    } catch (r) {
      const i = `[WebLocalStorage.set] Error setting/stringifying key (${t}): ${r}`;
      throw (console.error(i), new Error(i));
    }
  }
  async setAll(t) {
    let n = !1;
    const r = Object.keys(t);
    for (const i in t)
      if (Object.prototype.hasOwnProperty.call(t, i))
        try {
          await this.set(i, t[i]);
        } catch {
          n = !0;
        }
    if (n)
      throw new Error(
        `[WebLocalStorage.setAll] One or more errors occurred while setting keys (${r})`
      );
  }
  async update(t, n) {
    if (!navigator.locks) {
      const r = await this.get(t),
        i = await n(r);
      i === null ? await this.remove(t) : await this.set(t, i);
      return;
    }
    try {
      await navigator.locks.request(`storage.${t}`, async (r) => {
        const i = await this.get(t),
          o = await n(i);
        o === null ? await this.remove(t) : await this.set(t, o);
      });
    } catch (r) {
      const i = `[WebLocalStorage.update] Error updating key (${t}): ${r}`;
      throw (console.error(i), new Error(i));
    }
  }
  async clear() {
    try {
      this.storage.clear();
    } catch (t) {
      const n = `[WebLocalStorage.clear] Error clearing storage: ${t}`;
      throw (console.error(n), new Error(n));
    }
  }
}
class Ure {
  constructor() {
    Le(this, 'initPromise');
    Le(this, 'storageImpl', null);
    (this.initPromise = this._initialize()),
      this.initPromise.catch((t) => {
        console.error('LocalStorage initialization failed:', t);
      });
  }
  async _initialize() {
    if (!this.storageImpl)
      if (jre())
        try {
          const n = (
            await Rt(
              () => import('./browser-polyfill--SpK_K58.js').then((r) => r.b),
              __vite__mapDeps([38, 2])
            )
          ).default;
          if (!n || !n.storage || !n.storage.local)
            throw new Error('webextension-polyfill loaded but missing storage.local API.');
          this.storageImpl = new Nre(n);
        } catch {
          this.storageImpl = new oA();
        }
      else this.storageImpl = new oA();
  }
  async ensureInitialized() {
    if ((await this.initPromise, !this.storageImpl))
      throw new Error('LocalStorage is not initialized. Initialization may have failed.');
  }
  async get(t) {
    return await this.ensureInitialized(), this.storageImpl.get(t);
  }
  async getAll(t) {
    return await this.ensureInitialized(), this.storageImpl.getAll(t);
  }
  async remove(t) {
    return await this.ensureInitialized(), this.storageImpl.remove(t);
  }
  async set(t, n) {
    return await this.ensureInitialized(), this.storageImpl.set(t, n);
  }
  async setAll(t) {
    return await this.ensureInitialized(), this.storageImpl.setAll(t);
  }
  async update(t, n) {
    return await this.ensureInitialized(), this.storageImpl.update(t, n);
  }
  async clear() {
    return await this.ensureInitialized(), this.storageImpl.clear();
  }
}
const aA = new Ure();
class Lre {
  constructor(t) {
    Le(this, 'namespaceKey');
    Le(this, 'ttlMilliseconds');
    Le(this, 'storage');
    Le(this, 'onError');
    Le(this, 'data', {});
    Le(this, 'isLoaded', !1);
    (this.namespaceKey = t.namespaceKey),
      (this.ttlMilliseconds = t.ttlMilliseconds),
      (this.storage = t.storage),
      (this.onError = t.onError),
      this._load()
        .then(() => {
          if (this._cleanupExpired()) return this._save();
        })
        .catch((n) => {
          console.error('Failed to load data', n);
        });
  }
  async _load() {
    var t, n;
    if (!this.isLoaded) {
      try {
        const r = await this.storage.get(this.namespaceKey);
        r
          ? ((this.data = r),
            (typeof this.data != 'object' || this.data === null) &&
              ((t = this.onError) == null ||
                t.call(this, new Error('Stored data is not a valid object.'), 'load'),
              (this.data = {})))
          : (this.data = {});
      } catch (r) {
        (n = this.onError) == null ||
          n.call(this, r instanceof Error ? r : new Error('Failed to parse stored data'), 'load'),
          (this.data = {});
      }
      this.isLoaded = !0;
    }
  }
  async _save() {
    var t;
    try {
      await this.storage.set(this.namespaceKey, this.data);
    } catch (n) {
      (t = this.onError) == null ||
        t.call(
          this,
          n instanceof Error ? n : new Error('Failed to serialize data for storage'),
          'save'
        );
    }
  }
  _cleanupExpired() {
    const t = Date.now();
    let n = !1;
    for (const r in this.data)
      Object.prototype.hasOwnProperty.call(this.data, r) &&
        this.data[r].expiresAt <= t &&
        (delete this.data[r], (n = !0));
    return n;
  }
  _updateExpiration(t) {
    return this.data[t] ? ((this.data[t].expiresAt = Date.now() + this.ttlMilliseconds), !0) : !1;
  }
  async set(t, n) {
    this.isLoaded || (await this._load()),
      this._cleanupExpired(),
      (this.data[t] = { value: n, expiresAt: Date.now() + this.ttlMilliseconds }),
      await this._save();
  }
  async get(t, n) {
    var c;
    this.isLoaded || (await this._load());
    const r = this._cleanupExpired(),
      i = this.data[t];
    if (!i) return r && (await this._save()), null;
    const o = this._updateExpiration(t),
      a = n.safeParse(i.value);
    return a.success
      ? ((r || o) && (await this._save()), a.data)
      : ((c = this.onError) == null ||
          c.call(this, new C0(a.error.issues), `get (validation failed for key: ${t})`),
        delete this.data[t],
        await this._save(),
        null);
  }
  async remove(t) {
    const n = this._cleanupExpired();
    let r = !1;
    Object.prototype.hasOwnProperty.call(this.data, t) && (delete this.data[t], (r = !0)),
      (n || r) && (await this._save());
  }
  async clear() {
    (this.data = {}), await this._save();
  }
}
const sA = new Map();
function cA({ storage: e, namespaceKey: t, ttlMs: n }) {
  const r = sA.get(t);
  if (r) return r;
  if (!e) throw new Error('Storage is required');
  const i = new Lre({
    storage: e,
    namespaceKey: t,
    ttlMilliseconds: n,
    onError: (o, a) => {
      console.error(`[PersistentStore Error - ${a}]:`, o.message),
        o instanceof C0 && console.error('Zod Issues:', o.issues);
    },
  });
  return sA.set(t, i), i;
}
function aO({
  atomToStoreOffline: e,
  namespaceKey: t,
  ttlMs: n,
  initialValue: r,
  schema: i,
  ...o
}) {
  const a = Je({ status: 'pending', value: r }),
    c = Je((d) => {
      if ('offlineKey' in o) return d(o.offlineKey);
      const f = d(e);
      if ('offlineKey' in f && typeof f.offlineKey == 'string') return f.offlineKey;
      throw new Error('No key provided');
    }),
    s = Uo((d, f) => {
      cA({ storage: aA, namespaceKey: `.offline.${t}`, ttlMs: n })
        .get(d(c), i)
        .then((p) => {
          p && f(a, { status: 'offline', value: p });
        })
        .catch((p) => {
          console.error(p);
        });
    }),
    l = Uo((d, f) => {
      d(c), f(a, { status: 'pending', value: r });
    }),
    u = Uo((d, f) => {
      const p = d(e),
        y = d(c);
      p.status === 'success' &&
        p.data &&
        p.data !== d(a).value &&
        cA({ storage: aA, namespaceKey: `.offline.${t}`, ttlMs: n })
          .set(y, p.data)
          .then(() => {
            p.data && f(a, { status: 'live', value: p.data });
          })
          .catch((b) => {
            console.error(b);
          });
    });
  return Rs(
    Je((d) => {
      const f = d(e);
      d(l), d(s), d(u);
      const p = d(a);
      return f.data ? { status: 'live', value: f.data } : { status: 'offline', value: p.value };
    }),
    (d) => d.value
  );
}
async function zre(e) {
  const t = { walletAddresses: e.walletCaip19s.join(','), includePrices: 'true' };
  'cursor' in e && (t.cursor = e.cursor),
    'fromMicroseconds' in e
      ? (t.fromTimestamp = e.fromMicroseconds.toString())
      : 'from' in e && (t.fromTimestamp = e.from.toString());
  const n = await ke
    .api()
    .timeout(ae({ seconds: 30 }))
    .get('/portfolio/v1/fungibles/updates', { params: t })
    .then((r) => {
      var i, o, a, c;
      if (hn(r)) return r.data;
      throw new Error(
        ((i = r.data) == null ? void 0 : i.message) ||
          ((o = r.data) == null ? void 0 : o.error) ||
          r.statusText,
        {
          cause:
            ((a = r.data) == null ? void 0 : a.code) ?? ((c = r.data) == null ? void 0 : c.name),
        }
      );
    })
    .catch((r) => {
      throw (
        (Z.addBreadcrumb(te.Tokens, 'getTokenBalanceUpdates', Te.Error, {
          message: r.message,
          cause: r.cause,
          ...t,
        }),
        Z.captureError(r, te.Tokens),
        r)
      );
    });
  try {
    return vre.parse(n);
  } catch (r) {
    throw (
      (r instanceof C0 &&
        Z.addBreadcrumb(te.Tokens, 'getTokenBalanceUpdates parse error', Te.Error, {
          message: r.message,
          ...(r.issues ? { issues: JSON.stringify(r.issues) } : {}),
          result: JSON.stringify(n),
        }),
      r)
    );
  }
}
async function Fre(e) {
  const t = [],
    n = () => {
      var r;
      return (r = t.at(-1)) == null ? void 0 : r.nextCursor;
    };
  do {
    const r = n(),
      i = await zre(r ? { walletCaip19s: e.walletCaip19s, cursor: r } : e);
    t.push(i);
  } while (n());
  return gre(t.flatMap((r) => r.transfers));
}
function $re({ newUpdates: e, existingUpdates: t = {} }) {
  return e.reduce((n, r) => {
    var i;
    return ((i = n[r.encodedCaip19]) == null ? void 0 : i.totalQuantityString) ===
      r.totalQuantityString
      ? n
      : r.chainName === 'Solana' &&
          r.decodedCaip19.resourceType === sn.address &&
          r.queriedWalletBalances.some((o) => {
            var a;
            return !((a = o.subaccounts) != null && a.length);
          })
        ? { ...n, [`${r.encodedCaip19}-compressed`]: r }
        : r
          ? { ...n, [r.encodedCaip19]: r }
          : n;
  }, t);
}
function sO(e) {
  var c;
  const t = e.match(/(.*\d{2}:\d{2}:\d{2})\.(?<fraction>\d+)Z/);
  if (!t || !((c = t.groups) != null && c.fraction)) throw new Error('Invalid date format');
  const n = new Date(e).getTime(),
    o = t.groups.fraction.padEnd(6, '0').slice(-3);
  return n * 1e3 + parseInt(o, 10);
}
const Wre = Je(!1),
  cO = Je((e) => {
    const t = e(c1);
    return t
      ? t.addresses
          .map((n) => to({ chainId: n.networkID, address: n.address, resourceType: sn.address }))
          .sort()
      : [];
  }),
  zf = Pre((e) => {
    const t = e(cO);
    return Ire({ walletCaip19s: t });
  }),
  Vre = Je((e) => {
    const { data: t } = e(zf),
      n = t == null ? void 0 : t.pages[0];
    return !n || !n.tokens.length ? 0 : n.updatedAt;
  }),
  ly = Rs(c1, (e) => (e == null ? void 0 : e.identifier)),
  Kre = 1e3,
  uO = 5e3,
  lO = Math.ceil(uO * 2.25);
function dO(e) {
  return ae(e) * 1e3;
}
function Hre(e) {
  if (!(e != null && e.length)) return null;
  const t = new Date(Date.now() - lO).toISOString();
  return Math.floor(Math.max(...e.map(({ timestamp: n }) => sO(n || t))));
}
function qre(e) {
  const t = Hre(e);
  return t ? t - dO({ seconds: 1 }) : null;
}
const Gre = oO((e) => {
    const t = e(uy),
      n = e(Vre),
      r = Math.floor(n - ae({ minutes: 10 })),
      i = e(cO),
      o = e(Wre),
      a = r > Date.now() - ae({ days: 10 }),
      c = cy.tokenUpdates({ walletCaip19s: i, from: r }),
      s = async () => {
        var p, y;
        const l = (p = t.getQueryData(c)) == null ? void 0 : p.lastTimestamp;
        if (!l) {
          const b = new Date(r - lO).toISOString();
          return { updates: {}, lastTimestamp: sO(b) };
        }
        const u = await Fre({ walletCaip19s: i, fromMicroseconds: l - dO({ seconds: 30 }) }),
          d = ((y = t.getQueryData(c)) == null ? void 0 : y.updates) ?? {};
        return {
          updates: $re({ newUpdates: u, existingUpdates: d }),
          lastTimestamp: Math.max(qre(u) ?? 0, l),
        };
      };
    return {
      meta: { fetchCount: 0 },
      enabled: a && !o && i.length > 0,
      queryKey: c,
      refetchInterval: (l) => {
        var d;
        const u = Number(((d = l.meta) == null ? void 0 : d.fetchCount) ?? 0);
        return l.meta && (l.meta.fetchCount = u + 1), Math.min(Math.max(u * 250, Kre), uO);
      },
      queryFn: s,
    };
  }),
  Yre = aO({
    atomToStoreOffline: Gre,
    offlineKey: Je((e) => `${e(ly) ?? ''}:token-balance-updates`),
    namespaceKey: 'fungible-tokens',
    ttlMs: ae({ days: 10 }),
    initialValue: { updates: {}, lastTimestamp: 0 },
    schema: h.object({ updates: h.record(h.string(), mw), lastTimestamp: h.number() }),
  }),
  fO = Rs(
    Yre,
    (e) => (e == null ? void 0 : e.updates) ?? {},
    (e, t) => JSON.stringify(e) === JSON.stringify(t)
  );
function hO(e) {
  return (t) => {
    var i, o;
    let n = !1;
    const r = { ...t };
    for (const [a, c] of Object.entries(e)) {
      const s = c == null ? void 0 : c.price,
        l = c != null && c.lastUpdatedAt ? new Date(c.lastUpdatedAt) : null;
      if (!s || !l) continue;
      const u =
        ((i = t[a]) == null ? void 0 : i.price) !== s &&
        (!((o = t[a]) != null && o.lastUpdatedAt) || l > t[a].lastUpdatedAt);
      (n = n || u),
        u && (r[a] = { price: c.price, priceChange24h: c.priceChange24h, lastUpdatedAt: l });
    }
    return n ? r : t;
  };
}
const Zre = Je((e) => {
    const { data: t, status: n } = e(zf);
    return { data: t == null ? void 0 : t.pages.flatMap((r) => r.tokens), status: n };
  }),
  dy = aO({
    atomToStoreOffline: Zre,
    offlineKey: Je((e) => `${e(ly) ?? ''}:infinite-tokens`),
    namespaceKey: 'fungible-tokens',
    ttlMs: ae({ days: 10 }),
    initialValue: [],
    schema: h.array(mw),
  }),
  wp = Je({}),
  Qre = Je((e) =>
    e(dy)
      .slice(-100)
      .reduce((r, i) => (i.price && (r[i.encodedCaip19] = i.price), r), {})
  ),
  Jre = Uo((e, t) => {
    const n = e(Qre);
    !n || Object.keys(n).length === 0 || t(wp, hO(n));
  }),
  Xre = Je((e) => {
    const t = e(fO);
    return Object.values(t).reduce((r, i) => (i.price && (r[i.encodedCaip19] = i.price), r), {});
  }),
  eie = Uo((e, t) => {
    const n = e(Xre);
    !n || Object.keys(n).length === 0 || t(wp, hO(n));
  }),
  pO = Je(
    (e) => (e(Jre), e(eie), e(wp)),
    (e, t, n) => {
      t(wp, n);
    }
  ),
  tie = Rs(zf, (e) => e.hasNextPage),
  Zs = Je(1 / 0),
  _p = Je(
    (e) => (e(nie), e(rie), e(tie) ? e(Zs) : 0),
    (e, t, n) => {
      if (n === null) {
        t(Zs, 1 / 0);
        return;
      }
      const r = Math.min(e(Zs), n);
      r !== e(Zs) && t(Zs, r);
    }
  ),
  nie = Uo((e, t) => {
    const { hasNextPage: n } = e(zf),
      r = e(dy),
      i = e(pO);
    if (r.length > 0 && !n) {
      t(_p, 0);
      return;
    }
    const o = r
      .slice(-100)
      .filter((a) => a.type === 'fungible')
      .map((a) => {
        const c = i[a.encodedCaip19] ?? a.price;
        return c ? (a.totalQuantity * c.price) / 10 ** a.decimals : 1 / 0;
      });
    t(_p, Math.min(...o));
  }),
  rie = Uo((e, t) => {
    e(ly) && t(_p, 1 / 0);
  });
function iie(e, t) {
  if (e.type === 'native' && t.type !== 'native') return -1;
  if (e.type !== 'native' && t.type === 'native') return 1;
  if (e.type === 'native' && t.type === 'native')
    return e.name && t.name ? e.name.localeCompare(t.name) : 0;
}
function oie(e, t) {
  if (!e && t) return 1;
  if (e && !t) return -1;
}
function uA(e, t) {
  if (e && t) return e.localeCompare(t);
  if (e && !t) return -1;
  if (!e && t) return 1;
}
function lA(e, t) {
  if (e !== t) return t - e;
}
function aie(e) {
  return { totalQuantity: e.totalQuantity, totalQuantityString: e.totalQuantityString };
}
const sie = Je((e) => {
    const t = e(dy),
      n = e(fO),
      r = new Set(Object.keys(n));
    if (t.length === 0) return [];
    const i = t.map((o) => {
      var s, l;
      const a =
          (l = (s = o.extraMetadata) == null ? void 0 : s.compression) != null && l.compressed
            ? `${o.encodedCaip19}-compressed`
            : o.encodedCaip19,
        c = n[a];
      return c ? (r.delete(a), { ...o, ...aie(c) }) : o;
    });
    return (
      r.forEach((o) => {
        const a = n[o];
        a && i.push(a);
      }),
      i
    );
  }),
  Ple = Je((e) => {
    const t = e(pO),
      n = e(sie),
      r = e(_p),
      i = n
        .filter((o) => o.totalQuantity > 0 || o.type === 'native')
        .map((o) => ({ ...o, livePrice: t[o.encodedCaip19] ?? o.price }))
        .sort((o, a) => {
          var b, m;
          const c = (b = o.livePrice) == null ? void 0 : b.price,
            s = (m = a.livePrice) == null ? void 0 : m.price,
            l = oie(c, s);
          if (l) return l;
          const u = o.totalQuantity / 10 ** o.decimals,
            d = a.totalQuantity / 10 ** a.decimals;
          if (!c && !s) {
            const w = iie(o, a);
            if (w) return w;
            const _ = lA(u, d);
            if (_) return _;
            const S = uA(o.name, a.name);
            return S || 0;
          }
          const f = (c ?? 0) * u,
            p = (s ?? 0) * d,
            y = lA(f, p);
          return y || (uA(o.name, a.name) ?? 0);
        });
    return r
      ? i.filter((o) => {
          var l;
          const a = (l = o.livePrice) == null ? void 0 : l.price,
            c = o.totalQuantity / 10 ** o.decimals;
          return (a ?? 0) * c >= r;
        })
      : i;
  });
function cie(e, t) {
  return {
    gcTime: ay.Long,
    staleTime: sy.Never,
    enabled: !!t && !!e,
    queryKey: cy.visibilityOverrides({ accountId: t ?? '' }),
    async queryFn() {
      return !t || !e ? new Map() : await vP(e, t);
    },
  };
}
const uie = new Map(),
  gO = oO((e) => {
    const t = e(aT),
      n = e(ly);
    return cie(t, n);
  }),
  lie = Rs(gO, (e) => e.status),
  Ole = Je((e) => e(gO).data ?? uie),
  die = Je((e) => {
    const { isLoading: t } = e(zf),
      n = e(dy),
      r = e(lie);
    return (t && n.length === 0) || r === 'pending';
  }),
  Dle = Rs(die, (e) => e),
  fie = ({ chainAddresses: e = [] }) => {
    const t = ea.tokensErrorCount(e);
    return pt({ queryKey: t, initialData: 0 });
  },
  hie = ({ errors: e }) => e;
function pie({ chainAddresses: e, queryOptions: t }) {
  return gP({ select: hie, chainAddresses: e, queryOptions: t });
}
const dA = 3,
  gie = 1,
  yie = ({ networkID: e, chainAddresses: t = [] }) => {
    const { data: n = [] } = pie({ chainAddresses: t }),
      { data: r = 0 } = fie({ chainAddresses: t }),
      i = r >= dA,
      { data: o = 0 } = Bee(),
      a = o >= dA,
      c = n.length === gie && n.some((u) => u.code === 'TokensTrimmed'),
      { t: s } = ia(),
      l = G.useMemo(() => {
        if (i) return s('partialErrorGeneric');
        const u = n.filter((f) => (e ? f.details.chainId === e : !0)),
          d = u.length + (a ? 1 : 0);
        return d
          ? d > 1
            ? s('partialErrorGeneric')
            : a
              ? s('partialErrorTokenPrices')
              : c
                ? s('partialErrorTokensTrimmed')
                : e
                  ? s('partialErrorTokenDetail')
                  : s('partialErrorBalanceChainName', {
                      chainName: q.getChainName(u[0].details.chainId),
                    })
          : '';
      }, [i, n, a, e, c, s]);
    return G.useMemo(() => ({ partialErrorMessage: l, shouldShowPartialError: l !== '' }), [l]);
  };
function bie(e) {
  const {
      onTappingBuy: t,
      onTappingReceive: n,
      onTappingSend: r,
      onTappingSwap: i,
      account: o,
    } = e,
    { shouldShowPartialError: a, partialErrorMessage: c } = yie({
      chainAddresses: o == null ? void 0 : o.addresses,
    });
  return {
    ctaActions: mie({ onTappingBuy: t, onTappingReceive: n, onTappingSend: r, onTappingSwap: i }),
    shouldShowPartialError: a,
    partialErrorMessage: c,
  };
}
function mie(e) {
  const { t } = ia();
  return G.useMemo(() => {
    const r = [];
    return (
      r.push({ text: t('commandSend'), type: 'send', onClick: e.onTappingSend }),
      r.push({ text: t('commandSwap'), type: 'swap', onClick: e.onTappingSwap }),
      r.push({ text: t('commandReceive'), type: 'receive', onClick: e.onTappingReceive }),
      r.push({ text: t('commandBuy'), type: 'buy', onClick: e.onTappingBuy }),
      r.sort((i, o) => (qS.get(i.type) ?? 100) - (qS.get(o.type) ?? 100)),
      { primary: r, more: [] }
    );
  }, [t, e.onTappingSend, e.onTappingSwap, e.onTappingReceive, e.onTappingBuy]);
}
const yO = ['embedded-wallet-onboarding-status'],
  wie = () => {
    const e = fT(),
      t = JE(),
      n = qp();
    return pt({
      queryKey: yO,
      queryFn: async () => {
        try {
          vo('Checking if users is logged in.');
          const r = await qa.getUser();
          return r
            ? (vo('Authorizing signer iframe.'),
              'error' in (await e.send({ method: Ga.authorizeSigner, params: [r.accessToken] }))
                ? (vo('Signer authorization failed, showing onboarding.'),
                  await Uh.navigateToOnboarding(),
                  !0)
                : (vo('Checking onboarding status.'),
                  (await t.checkVaultIntegrity()).isOnboarded
                    ? (vo('Wallet onboarded. Showing balances.'), n.capture('popupOpen'), !0)
                    : (vo('Onboarding needed, show restore account flow.'),
                      await Uh.navigateToRestoreAccount(),
                      !0)))
            : (vo('User not logged in, showing onboarding.'), await Uh.navigateToOnboarding(), !0);
        } catch (r) {
          let i;
          throw (
            (r instanceof Error
              ? (i = r)
              : (i = new Error('Unable to determine embedded wallet onboarding state.')),
            Z.captureError(i, te.Auth),
            i)
          );
        }
      },
    });
  },
  Rle = async (e) => {
    await e.refetchQueries({ queryKey: yO });
  },
  vo = (e) => {
    Z.addBreadcrumb(te.Auth, e, Te.Info);
  };
oe.config({ EXPONENTIAL_AT: 1e3, DECIMAL_PLACES: 78 });
const xle = (e, t) => new oe(e).div(Ec(t)),
  ww = 1e18;
function ss(e) {
  return BigInt(Math.round(e * ww));
}
function _w(e) {
  return Number(e) / ww;
}
function Ble(e, t) {
  return _w(ss(e) + ss(t));
}
function _ie(e, t) {
  return _w(ss(e) - ss(t));
}
function vie(e, t) {
  return _w((ss(e) * BigInt(ww)) / ss(t));
}
function Sie(e, t) {
  if (t === -100) return -1 * e;
  const n = vie(e, 1 + t / 100);
  return _ie(e, n);
}
function Aie(e) {
  var r, i, o, a, c;
  const t = oe(e.totalQuantity).div(10 ** e.decimals),
    n =
      (i = (r = e.extraMetadata) == null ? void 0 : r.compression) != null && i.compressed
        ? Re.CompressedSPL
        : iw(e.decodedCaip19);
  return {
    balance: t,
    type: n,
    chain: L2(e.decodedCaip19.chainId),
    logoUri: e.logoUri ?? null,
    name: e.name || Et.t('assetVisibilityUnknownToken'),
    chainName: e.chainName,
    symbol: e.symbol ?? e.legacyKey ?? '',
    tokenAddress:
      e.decodedCaip19.resourceType === sn.address
        ? e.decodedCaip19.address
        : e.decodedCaip19.slip44,
    walletAddress: e.walletAddress,
    spamStatus: e.spamStatus,
    key: e.legacyKey ?? e.encodedCaip19,
    usd: (o = e.price) != null && o.price ? t.times(e.price.price).toNumber() : void 0,
    usd_24h_change:
      ((a = e.price) == null ? void 0 : a.priceChange24h) !== void 0
        ? Sie(t.times(e.price.price).toNumber(), (c = e.price) == null ? void 0 : c.priceChange24h)
        : void 0,
  };
}
function Iie(e, t) {
  if ('data' in e) {
    const {
        balance: w,
        chain: _,
        name: S,
        symbol: E,
        logoUri: O,
        tokenAddress: N,
        usd: F,
        usd_24h_change: D,
        walletAddress: k,
        spamStatus: K,
        key: M,
      } = e.data,
      C = S || Et.t('assetDetailUnknownToken'),
      z = t == null ? void 0 : t.get(M);
    return {
      balance: w,
      networkID: _.id,
      chainMetadata: _,
      currencyChange: D,
      currencyValue: F,
      logoUri: O,
      name: C,
      symbol: E,
      tokenAddress: N,
      walletAddress: k,
      spamStatus: K,
      visibilityOverrideValue: z,
      type: e.type,
    };
  }
  const n = Aie(e),
    {
      balance: r,
      chain: i,
      name: o,
      symbol: a,
      logoUri: c,
      tokenAddress: s,
      usd: l,
      usd_24h_change: u,
      walletAddress: d,
      spamStatus: f,
      key: p,
      type: y,
    } = n,
    b = o || Et.t('assetDetailUnknownToken'),
    m = t == null ? void 0 : t.get(p);
  return {
    networkID: i.id,
    balance: r,
    type: y,
    chainMetadata: i,
    currencyChange: u,
    currencyValue: l,
    logoUri: c,
    name: b,
    symbol: a,
    tokenAddress: s,
    walletAddress: d,
    spamStatus: f,
    visibilityOverrideValue: m,
  };
}
const vw = { small: 44, medium: 72, large: 128 };
var bO = { exports: {} },
  dt = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Sw = Symbol.for('react.element'),
  Aw = Symbol.for('react.portal'),
  fy = Symbol.for('react.fragment'),
  hy = Symbol.for('react.strict_mode'),
  py = Symbol.for('react.profiler'),
  gy = Symbol.for('react.provider'),
  yy = Symbol.for('react.context'),
  Eie = Symbol.for('react.server_context'),
  by = Symbol.for('react.forward_ref'),
  my = Symbol.for('react.suspense'),
  wy = Symbol.for('react.suspense_list'),
  _y = Symbol.for('react.memo'),
  vy = Symbol.for('react.lazy'),
  Tie = Symbol.for('react.offscreen'),
  mO;
mO = Symbol.for('react.module.reference');
function er(e) {
  if (typeof e == 'object' && e !== null) {
    var t = e.$$typeof;
    switch (t) {
      case Sw:
        switch (((e = e.type), e)) {
          case fy:
          case py:
          case hy:
          case my:
          case wy:
            return e;
          default:
            switch (((e = e && e.$$typeof), e)) {
              case Eie:
              case yy:
              case by:
              case vy:
              case _y:
              case gy:
                return e;
              default:
                return t;
            }
        }
      case Aw:
        return t;
    }
  }
}
dt.ContextConsumer = yy;
dt.ContextProvider = gy;
dt.Element = Sw;
dt.ForwardRef = by;
dt.Fragment = fy;
dt.Lazy = vy;
dt.Memo = _y;
dt.Portal = Aw;
dt.Profiler = py;
dt.StrictMode = hy;
dt.Suspense = my;
dt.SuspenseList = wy;
dt.isAsyncMode = function () {
  return !1;
};
dt.isConcurrentMode = function () {
  return !1;
};
dt.isContextConsumer = function (e) {
  return er(e) === yy;
};
dt.isContextProvider = function (e) {
  return er(e) === gy;
};
dt.isElement = function (e) {
  return typeof e == 'object' && e !== null && e.$$typeof === Sw;
};
dt.isForwardRef = function (e) {
  return er(e) === by;
};
dt.isFragment = function (e) {
  return er(e) === fy;
};
dt.isLazy = function (e) {
  return er(e) === vy;
};
dt.isMemo = function (e) {
  return er(e) === _y;
};
dt.isPortal = function (e) {
  return er(e) === Aw;
};
dt.isProfiler = function (e) {
  return er(e) === py;
};
dt.isStrictMode = function (e) {
  return er(e) === hy;
};
dt.isSuspense = function (e) {
  return er(e) === my;
};
dt.isSuspenseList = function (e) {
  return er(e) === wy;
};
dt.isValidElementType = function (e) {
  return (
    typeof e == 'string' ||
    typeof e == 'function' ||
    e === fy ||
    e === py ||
    e === hy ||
    e === my ||
    e === wy ||
    e === Tie ||
    (typeof e == 'object' &&
      e !== null &&
      (e.$$typeof === vy ||
        e.$$typeof === _y ||
        e.$$typeof === gy ||
        e.$$typeof === yy ||
        e.$$typeof === by ||
        e.$$typeof === mO ||
        e.getModuleId !== void 0))
  );
};
dt.typeOf = er;
bO.exports = dt;
var wO = bO.exports;
function kie(e) {
  function t(Q, ee, J, fe, j) {
    for (
      var Ie = 0,
        re = 0,
        Fe = 0,
        De = 0,
        Be,
        _e,
        lt = 0,
        jt = 0,
        qe,
        Wt = (qe = Be = 0),
        rt = 0,
        Ft = 0,
        go = 0,
        Nt = 0,
        yo = J.length,
        Hr = yo - 1,
        En,
        Pe = '',
        St = '',
        pa = '',
        ga = '',
        vr;
      rt < yo;

    ) {
      if (
        ((_e = J.charCodeAt(rt)),
        rt === Hr &&
          re + De + Fe + Ie !== 0 &&
          (re !== 0 && (_e = re === 47 ? 10 : 47), (De = Fe = Ie = 0), yo++, Hr++),
        re + De + Fe + Ie === 0)
      ) {
        if (rt === Hr && (0 < Ft && (Pe = Pe.replace(f, '')), 0 < Pe.trim().length)) {
          switch (_e) {
            case 32:
            case 9:
            case 59:
            case 13:
            case 10:
              break;
            default:
              Pe += J.charAt(rt);
          }
          _e = 59;
        }
        switch (_e) {
          case 123:
            for (Pe = Pe.trim(), Be = Pe.charCodeAt(0), qe = 1, Nt = ++rt; rt < yo; ) {
              switch ((_e = J.charCodeAt(rt))) {
                case 123:
                  qe++;
                  break;
                case 125:
                  qe--;
                  break;
                case 47:
                  switch ((_e = J.charCodeAt(rt + 1))) {
                    case 42:
                    case 47:
                      e: {
                        for (Wt = rt + 1; Wt < Hr; ++Wt)
                          switch (J.charCodeAt(Wt)) {
                            case 47:
                              if (_e === 42 && J.charCodeAt(Wt - 1) === 42 && rt + 2 !== Wt) {
                                rt = Wt + 1;
                                break e;
                              }
                              break;
                            case 10:
                              if (_e === 47) {
                                rt = Wt + 1;
                                break e;
                              }
                          }
                        rt = Wt;
                      }
                  }
                  break;
                case 91:
                  _e++;
                case 40:
                  _e++;
                case 34:
                case 39:
                  for (; rt++ < Hr && J.charCodeAt(rt) !== _e; );
              }
              if (qe === 0) break;
              rt++;
            }
            switch (
              ((qe = J.substring(Nt, rt)),
              Be === 0 && (Be = (Pe = Pe.replace(d, '').trim()).charCodeAt(0)),
              Be)
            ) {
              case 64:
                switch ((0 < Ft && (Pe = Pe.replace(f, '')), (_e = Pe.charCodeAt(1)), _e)) {
                  case 100:
                  case 109:
                  case 115:
                  case 45:
                    Ft = ee;
                    break;
                  default:
                    Ft = P;
                }
                if (
                  ((qe = t(ee, Ft, qe, _e, j + 1)),
                  (Nt = qe.length),
                  0 < L &&
                    ((Ft = n(P, Pe, go)),
                    (vr = c(3, qe, Ft, ee, z, C, Nt, _e, j, fe)),
                    (Pe = Ft.join('')),
                    vr !== void 0 && (Nt = (qe = vr.trim()).length) === 0 && ((_e = 0), (qe = ''))),
                  0 < Nt)
                )
                  switch (_e) {
                    case 115:
                      Pe = Pe.replace(N, a);
                    case 100:
                    case 109:
                    case 45:
                      qe = Pe + '{' + qe + '}';
                      break;
                    case 107:
                      (Pe = Pe.replace(_, '$1 $2')),
                        (qe = Pe + '{' + qe + '}'),
                        (qe =
                          T === 1 || (T === 2 && o('@' + qe, 3))
                            ? '@-webkit-' + qe + '@' + qe
                            : '@' + qe);
                      break;
                    default:
                      (qe = Pe + qe), fe === 112 && (qe = ((St += qe), ''));
                  }
                else qe = '';
                break;
              default:
                qe = t(ee, n(ee, Pe, go), qe, fe, j + 1);
            }
            (pa += qe), (qe = go = Ft = Wt = Be = 0), (Pe = ''), (_e = J.charCodeAt(++rt));
            break;
          case 125:
          case 59:
            if (((Pe = (0 < Ft ? Pe.replace(f, '') : Pe).trim()), 1 < (Nt = Pe.length)))
              switch (
                (Wt === 0 &&
                  ((Be = Pe.charCodeAt(0)), Be === 45 || (96 < Be && 123 > Be)) &&
                  (Nt = (Pe = Pe.replace(' ', ':')).length),
                0 < L &&
                  (vr = c(1, Pe, ee, Q, z, C, St.length, fe, j, fe)) !== void 0 &&
                  (Nt = (Pe = vr.trim()).length) === 0 &&
                  (Pe = '\0\0'),
                (Be = Pe.charCodeAt(0)),
                (_e = Pe.charCodeAt(1)),
                Be)
              ) {
                case 0:
                  break;
                case 64:
                  if (_e === 105 || _e === 99) {
                    ga += Pe + J.charAt(rt);
                    break;
                  }
                default:
                  Pe.charCodeAt(Nt - 1) !== 58 && (St += i(Pe, Be, _e, Pe.charCodeAt(2)));
              }
            (go = Ft = Wt = Be = 0), (Pe = ''), (_e = J.charCodeAt(++rt));
        }
      }
      switch (_e) {
        case 13:
        case 10:
          re === 47
            ? (re = 0)
            : 1 + Be === 0 && fe !== 107 && 0 < Pe.length && ((Ft = 1), (Pe += '\0')),
            0 < L * ie && c(0, Pe, ee, Q, z, C, St.length, fe, j, fe),
            (C = 1),
            z++;
          break;
        case 59:
        case 125:
          if (re + De + Fe + Ie === 0) {
            C++;
            break;
          }
        default:
          switch ((C++, (En = J.charAt(rt)), _e)) {
            case 9:
            case 32:
              if (De + Ie + re === 0)
                switch (lt) {
                  case 44:
                  case 58:
                  case 9:
                  case 32:
                    En = '';
                    break;
                  default:
                    _e !== 32 && (En = ' ');
                }
              break;
            case 0:
              En = '\\0';
              break;
            case 12:
              En = '\\f';
              break;
            case 11:
              En = '\\v';
              break;
            case 38:
              De + re + Ie === 0 && ((Ft = go = 1), (En = '\f' + En));
              break;
            case 108:
              if (De + re + Ie + I === 0 && 0 < Wt)
                switch (rt - Wt) {
                  case 2:
                    lt === 112 && J.charCodeAt(rt - 3) === 58 && (I = lt);
                  case 8:
                    jt === 111 && (I = jt);
                }
              break;
            case 58:
              De + re + Ie === 0 && (Wt = rt);
              break;
            case 44:
              re + Fe + De + Ie === 0 && ((Ft = 1), (En += '\r'));
              break;
            case 34:
            case 39:
              re === 0 && (De = De === _e ? 0 : De === 0 ? _e : De);
              break;
            case 91:
              De + re + Fe === 0 && Ie++;
              break;
            case 93:
              De + re + Fe === 0 && Ie--;
              break;
            case 41:
              De + re + Ie === 0 && Fe--;
              break;
            case 40:
              if (De + re + Ie === 0) {
                if (Be === 0)
                  switch (2 * lt + 3 * jt) {
                    case 533:
                      break;
                    default:
                      Be = 1;
                  }
                Fe++;
              }
              break;
            case 64:
              re + Fe + De + Ie + Wt + qe === 0 && (qe = 1);
              break;
            case 42:
            case 47:
              if (!(0 < De + Ie + Fe))
                switch (re) {
                  case 0:
                    switch (2 * _e + 3 * J.charCodeAt(rt + 1)) {
                      case 235:
                        re = 47;
                        break;
                      case 220:
                        (Nt = rt), (re = 42);
                    }
                    break;
                  case 42:
                    _e === 47 &&
                      lt === 42 &&
                      Nt + 2 !== rt &&
                      (J.charCodeAt(Nt + 2) === 33 && (St += J.substring(Nt, rt + 1)),
                      (En = ''),
                      (re = 0));
                }
          }
          re === 0 && (Pe += En);
      }
      (jt = lt), (lt = _e), rt++;
    }
    if (((Nt = St.length), 0 < Nt)) {
      if (
        ((Ft = ee),
        0 < L &&
          ((vr = c(2, St, Ft, Q, z, C, Nt, fe, j, fe)), vr !== void 0 && (St = vr).length === 0))
      )
        return ga + St + pa;
      if (((St = Ft.join(',') + '{' + St + '}'), T * I !== 0)) {
        switch ((T !== 2 || o(St, 2) || (I = 0), I)) {
          case 111:
            St = St.replace(E, ':-moz-$1') + St;
            break;
          case 112:
            St =
              St.replace(S, '::-webkit-input-$1') +
              St.replace(S, '::-moz-$1') +
              St.replace(S, ':-ms-input-$1') +
              St;
        }
        I = 0;
      }
    }
    return ga + St + pa;
  }
  function n(Q, ee, J) {
    var fe = ee.trim().split(m);
    ee = fe;
    var j = fe.length,
      Ie = Q.length;
    switch (Ie) {
      case 0:
      case 1:
        var re = 0;
        for (Q = Ie === 0 ? '' : Q[0] + ' '; re < j; ++re) ee[re] = r(Q, ee[re], J).trim();
        break;
      default:
        var Fe = (re = 0);
        for (ee = []; re < j; ++re)
          for (var De = 0; De < Ie; ++De) ee[Fe++] = r(Q[De] + ' ', fe[re], J).trim();
    }
    return ee;
  }
  function r(Q, ee, J) {
    var fe = ee.charCodeAt(0);
    switch ((33 > fe && (fe = (ee = ee.trim()).charCodeAt(0)), fe)) {
      case 38:
        return ee.replace(w, '$1' + Q.trim());
      case 58:
        return Q.trim() + ee.replace(w, '$1' + Q.trim());
      default:
        if (0 < 1 * J && 0 < ee.indexOf('\f'))
          return ee.replace(w, (Q.charCodeAt(0) === 58 ? '' : '$1') + Q.trim());
    }
    return Q + ee;
  }
  function i(Q, ee, J, fe) {
    var j = Q + ';',
      Ie = 2 * ee + 3 * J + 4 * fe;
    if (Ie === 944) {
      Q = j.indexOf(':', 9) + 1;
      var re = j.substring(Q, j.length - 1).trim();
      return (
        (re = j.substring(0, Q).trim() + re + ';'),
        T === 1 || (T === 2 && o(re, 1)) ? '-webkit-' + re + re : re
      );
    }
    if (T === 0 || (T === 2 && !o(j, 1))) return j;
    switch (Ie) {
      case 1015:
        return j.charCodeAt(10) === 97 ? '-webkit-' + j + j : j;
      case 951:
        return j.charCodeAt(3) === 116 ? '-webkit-' + j + j : j;
      case 963:
        return j.charCodeAt(5) === 110 ? '-webkit-' + j + j : j;
      case 1009:
        if (j.charCodeAt(4) !== 100) break;
      case 969:
      case 942:
        return '-webkit-' + j + j;
      case 978:
        return '-webkit-' + j + '-moz-' + j + j;
      case 1019:
      case 983:
        return '-webkit-' + j + '-moz-' + j + '-ms-' + j + j;
      case 883:
        if (j.charCodeAt(8) === 45) return '-webkit-' + j + j;
        if (0 < j.indexOf('image-set(', 11)) return j.replace(M, '$1-webkit-$2') + j;
        break;
      case 932:
        if (j.charCodeAt(4) === 45)
          switch (j.charCodeAt(5)) {
            case 103:
              return (
                '-webkit-box-' +
                j.replace('-grow', '') +
                '-webkit-' +
                j +
                '-ms-' +
                j.replace('grow', 'positive') +
                j
              );
            case 115:
              return '-webkit-' + j + '-ms-' + j.replace('shrink', 'negative') + j;
            case 98:
              return '-webkit-' + j + '-ms-' + j.replace('basis', 'preferred-size') + j;
          }
        return '-webkit-' + j + '-ms-' + j + j;
      case 964:
        return '-webkit-' + j + '-ms-flex-' + j + j;
      case 1023:
        if (j.charCodeAt(8) !== 99) break;
        return (
          (re = j
            .substring(j.indexOf(':', 15))
            .replace('flex-', '')
            .replace('space-between', 'justify')),
          '-webkit-box-pack' + re + '-webkit-' + j + '-ms-flex-pack' + re + j
        );
      case 1005:
        return y.test(j) ? j.replace(p, ':-webkit-') + j.replace(p, ':-moz-') + j : j;
      case 1e3:
        switch (
          ((re = j.substring(13).trim()),
          (ee = re.indexOf('-') + 1),
          re.charCodeAt(0) + re.charCodeAt(ee))
        ) {
          case 226:
            re = j.replace(O, 'tb');
            break;
          case 232:
            re = j.replace(O, 'tb-rl');
            break;
          case 220:
            re = j.replace(O, 'lr');
            break;
          default:
            return j;
        }
        return '-webkit-' + j + '-ms-' + re + j;
      case 1017:
        if (j.indexOf('sticky', 9) === -1) break;
      case 975:
        switch (
          ((ee = (j = Q).length - 10),
          (re = (j.charCodeAt(ee) === 33 ? j.substring(0, ee) : j)
            .substring(Q.indexOf(':', 7) + 1)
            .trim()),
          (Ie = re.charCodeAt(0) + (re.charCodeAt(7) | 0)))
        ) {
          case 203:
            if (111 > re.charCodeAt(8)) break;
          case 115:
            j = j.replace(re, '-webkit-' + re) + ';' + j;
            break;
          case 207:
          case 102:
            j =
              j.replace(re, '-webkit-' + (102 < Ie ? 'inline-' : '') + 'box') +
              ';' +
              j.replace(re, '-webkit-' + re) +
              ';' +
              j.replace(re, '-ms-' + re + 'box') +
              ';' +
              j;
        }
        return j + ';';
      case 938:
        if (j.charCodeAt(5) === 45)
          switch (j.charCodeAt(6)) {
            case 105:
              return (
                (re = j.replace('-items', '')),
                '-webkit-' + j + '-webkit-box-' + re + '-ms-flex-' + re + j
              );
            case 115:
              return '-webkit-' + j + '-ms-flex-item-' + j.replace(D, '') + j;
            default:
              return (
                '-webkit-' +
                j +
                '-ms-flex-line-pack' +
                j.replace('align-content', '').replace(D, '') +
                j
              );
          }
        break;
      case 973:
      case 989:
        if (j.charCodeAt(3) !== 45 || j.charCodeAt(4) === 122) break;
      case 931:
      case 953:
        if (K.test(Q) === !0)
          return (re = Q.substring(Q.indexOf(':') + 1)).charCodeAt(0) === 115
            ? i(Q.replace('stretch', 'fill-available'), ee, J, fe).replace(
                ':fill-available',
                ':stretch'
              )
            : j.replace(re, '-webkit-' + re) + j.replace(re, '-moz-' + re.replace('fill-', '')) + j;
        break;
      case 962:
        if (
          ((j = '-webkit-' + j + (j.charCodeAt(5) === 102 ? '-ms-' + j : '') + j),
          J + fe === 211 && j.charCodeAt(13) === 105 && 0 < j.indexOf('transform', 10))
        )
          return j.substring(0, j.indexOf(';', 27) + 1).replace(b, '$1-webkit-$2') + j;
    }
    return j;
  }
  function o(Q, ee) {
    var J = Q.indexOf(ee === 1 ? ':' : '{'),
      fe = Q.substring(0, ee !== 3 ? J : 10);
    return (J = Q.substring(J + 1, Q.length - 1)), H(ee !== 2 ? fe : fe.replace(k, '$1'), J, ee);
  }
  function a(Q, ee) {
    var J = i(ee, ee.charCodeAt(0), ee.charCodeAt(1), ee.charCodeAt(2));
    return J !== ee + ';' ? J.replace(F, ' or ($1)').substring(4) : '(' + ee + ')';
  }
  function c(Q, ee, J, fe, j, Ie, re, Fe, De, Be) {
    for (var _e = 0, lt = ee, jt; _e < L; ++_e)
      switch ((jt = R[_e].call(u, Q, lt, J, fe, j, Ie, re, Fe, De, Be))) {
        case void 0:
        case !1:
        case !0:
        case null:
          break;
        default:
          lt = jt;
      }
    if (lt !== ee) return lt;
  }
  function s(Q) {
    switch (Q) {
      case void 0:
      case null:
        L = R.length = 0;
        break;
      default:
        if (typeof Q == 'function') R[L++] = Q;
        else if (typeof Q == 'object') for (var ee = 0, J = Q.length; ee < J; ++ee) s(Q[ee]);
        else ie = !!Q | 0;
    }
    return s;
  }
  function l(Q) {
    return (
      (Q = Q.prefix),
      Q !== void 0 &&
        ((H = null), Q ? (typeof Q != 'function' ? (T = 1) : ((T = 2), (H = Q))) : (T = 0)),
      l
    );
  }
  function u(Q, ee) {
    var J = Q;
    if ((33 > J.charCodeAt(0) && (J = J.trim()), (he = J), (J = [he]), 0 < L)) {
      var fe = c(-1, ee, J, J, z, C, 0, 0, 0, 0);
      fe !== void 0 && typeof fe == 'string' && (ee = fe);
    }
    var j = t(P, J, ee, 0, 0);
    return (
      0 < L && ((fe = c(-2, j, J, J, z, C, j.length, 0, 0, 0)), fe !== void 0 && (j = fe)),
      (he = ''),
      (I = 0),
      (C = z = 1),
      j
    );
  }
  var d = /^\0+/g,
    f = /[\0\r\f]/g,
    p = /: */g,
    y = /zoo|gra/,
    b = /([,: ])(transform)/g,
    m = /,\r+?/g,
    w = /([\t\r\n ])*\f?&/g,
    _ = /@(k\w+)\s*(\S*)\s*/,
    S = /::(place)/g,
    E = /:(read-only)/g,
    O = /[svh]\w+-[tblr]{2}/,
    N = /\(\s*(.*)\s*\)/g,
    F = /([\s\S]*?);/g,
    D = /-self|flex-/g,
    k = /[^]*?(:[rp][el]a[\w-]+)[^]*/,
    K = /stretch|:\s*\w+\-(?:conte|avail)/,
    M = /([^-])(image-set\()/,
    C = 1,
    z = 1,
    I = 0,
    T = 1,
    P = [],
    R = [],
    L = 0,
    H = null,
    ie = 0,
    he = '';
  return (u.use = s), (u.set = l), e !== void 0 && l(e), u;
}
var Cie = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1,
};
function Mie(e) {
  var t = {};
  return function (n) {
    return t[n] === void 0 && (t[n] = e(n)), t[n];
  };
}
var Pie =
    /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,
  fA = Mie(function (e) {
    return (
      Pie.test(e) || (e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91)
    );
  }),
  Or = {};
function ai() {
  return (ai =
    Object.assign ||
    function (e) {
      for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t];
        for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
      }
      return e;
    }).apply(this, arguments);
}
var hA = function (e, t) {
    for (var n = [e[0]], r = 0, i = t.length; r < i; r += 1) n.push(t[r], e[r + 1]);
    return n;
  },
  f0 = function (e) {
    return (
      e !== null &&
      typeof e == 'object' &&
      (e.toString ? e.toString() : Object.prototype.toString.call(e)) === '[object Object]' &&
      !wO.typeOf(e)
    );
  },
  vp = Object.freeze([]),
  Ji = Object.freeze({});
function hc(e) {
  return typeof e == 'function';
}
function pA(e) {
  return e.displayName || e.name || 'Component';
}
function Iw(e) {
  return e && typeof e.styledComponentId == 'string';
}
var cs = (typeof hm < 'u' && (Or.REACT_APP_SC_ATTR || Or.SC_ATTR)) || 'data-styled',
  Ew = typeof window < 'u' && 'HTMLElement' in window,
  Oie = !!(typeof SC_DISABLE_SPEEDY == 'boolean'
    ? SC_DISABLE_SPEEDY
    : typeof hm < 'u' &&
        Or.REACT_APP_SC_DISABLE_SPEEDY !== void 0 &&
        Or.REACT_APP_SC_DISABLE_SPEEDY !== ''
      ? Or.REACT_APP_SC_DISABLE_SPEEDY !== 'false' && Or.REACT_APP_SC_DISABLE_SPEEDY
      : typeof hm < 'u' &&
        Or.SC_DISABLE_SPEEDY !== void 0 &&
        Or.SC_DISABLE_SPEEDY !== '' &&
        Or.SC_DISABLE_SPEEDY !== 'false' &&
        Or.SC_DISABLE_SPEEDY);
function Ff(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  throw new Error(
    'An error occurred. See https://git.io/JUIaE#' +
      e +
      ' for more information.' +
      (n.length > 0 ? ' Args: ' + n.join(', ') : '')
  );
}
var Die = (function () {
    function e(n) {
      (this.groupSizes = new Uint32Array(512)), (this.length = 512), (this.tag = n);
    }
    var t = e.prototype;
    return (
      (t.indexOfGroup = function (n) {
        for (var r = 0, i = 0; i < n; i++) r += this.groupSizes[i];
        return r;
      }),
      (t.insertRules = function (n, r) {
        if (n >= this.groupSizes.length) {
          for (var i = this.groupSizes, o = i.length, a = o; n >= a; )
            (a <<= 1) < 0 && Ff(16, '' + n);
          (this.groupSizes = new Uint32Array(a)), this.groupSizes.set(i), (this.length = a);
          for (var c = o; c < a; c++) this.groupSizes[c] = 0;
        }
        for (var s = this.indexOfGroup(n + 1), l = 0, u = r.length; l < u; l++)
          this.tag.insertRule(s, r[l]) && (this.groupSizes[n]++, s++);
      }),
      (t.clearGroup = function (n) {
        if (n < this.length) {
          var r = this.groupSizes[n],
            i = this.indexOfGroup(n),
            o = i + r;
          this.groupSizes[n] = 0;
          for (var a = i; a < o; a++) this.tag.deleteRule(i);
        }
      }),
      (t.getGroup = function (n) {
        var r = '';
        if (n >= this.length || this.groupSizes[n] === 0) return r;
        for (var i = this.groupSizes[n], o = this.indexOfGroup(n), a = o + i, c = o; c < a; c++)
          r +=
            this.tag.getRule(c) +
            `/*!sc*/
`;
        return r;
      }),
      e
    );
  })(),
  $h = new Map(),
  Sp = new Map(),
  sc = 1,
  wh = function (e) {
    if ($h.has(e)) return $h.get(e);
    for (; Sp.has(sc); ) sc++;
    var t = sc++;
    return $h.set(e, t), Sp.set(t, e), t;
  },
  Rie = function (e) {
    return Sp.get(e);
  },
  xie = function (e, t) {
    t >= sc && (sc = t + 1), $h.set(e, t), Sp.set(t, e);
  },
  Bie = 'style[' + cs + '][data-styled-version="5.3.3"]',
  jie = new RegExp('^' + cs + '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)'),
  Nie = function (e, t, n) {
    for (var r, i = n.split(','), o = 0, a = i.length; o < a; o++)
      (r = i[o]) && e.registerName(t, r);
  },
  Uie = function (e, t) {
    for (
      var n = (t.textContent || '').split(`/*!sc*/
`),
        r = [],
        i = 0,
        o = n.length;
      i < o;
      i++
    ) {
      var a = n[i].trim();
      if (a) {
        var c = a.match(jie);
        if (c) {
          var s = 0 | parseInt(c[1], 10),
            l = c[2];
          s !== 0 && (xie(l, s), Nie(e, l, c[3]), e.getTag().insertRules(s, r)), (r.length = 0);
        } else r.push(a);
      }
    }
  },
  Lie = function () {
    return typeof window < 'u' && window.__webpack_nonce__ !== void 0
      ? window.__webpack_nonce__
      : null;
  },
  _O = function (e) {
    var t = document.head,
      n = e || t,
      r = document.createElement('style'),
      i = (function (c) {
        for (var s = c.childNodes, l = s.length; l >= 0; l--) {
          var u = s[l];
          if (u && u.nodeType === 1 && u.hasAttribute(cs)) return u;
        }
      })(n),
      o = i !== void 0 ? i.nextSibling : null;
    r.setAttribute(cs, 'active'), r.setAttribute('data-styled-version', '5.3.3');
    var a = Lie();
    return a && r.setAttribute('nonce', a), n.insertBefore(r, o), r;
  },
  zie = (function () {
    function e(n) {
      var r = (this.element = _O(n));
      r.appendChild(document.createTextNode('')),
        (this.sheet = (function (i) {
          if (i.sheet) return i.sheet;
          for (var o = document.styleSheets, a = 0, c = o.length; a < c; a++) {
            var s = o[a];
            if (s.ownerNode === i) return s;
          }
          Ff(17);
        })(r)),
        (this.length = 0);
    }
    var t = e.prototype;
    return (
      (t.insertRule = function (n, r) {
        try {
          return this.sheet.insertRule(r, n), this.length++, !0;
        } catch {
          return !1;
        }
      }),
      (t.deleteRule = function (n) {
        this.sheet.deleteRule(n), this.length--;
      }),
      (t.getRule = function (n) {
        var r = this.sheet.cssRules[n];
        return r !== void 0 && typeof r.cssText == 'string' ? r.cssText : '';
      }),
      e
    );
  })(),
  Fie = (function () {
    function e(n) {
      var r = (this.element = _O(n));
      (this.nodes = r.childNodes), (this.length = 0);
    }
    var t = e.prototype;
    return (
      (t.insertRule = function (n, r) {
        if (n <= this.length && n >= 0) {
          var i = document.createTextNode(r),
            o = this.nodes[n];
          return this.element.insertBefore(i, o || null), this.length++, !0;
        }
        return !1;
      }),
      (t.deleteRule = function (n) {
        this.element.removeChild(this.nodes[n]), this.length--;
      }),
      (t.getRule = function (n) {
        return n < this.length ? this.nodes[n].textContent : '';
      }),
      e
    );
  })(),
  $ie = (function () {
    function e(n) {
      (this.rules = []), (this.length = 0);
    }
    var t = e.prototype;
    return (
      (t.insertRule = function (n, r) {
        return n <= this.length && (this.rules.splice(n, 0, r), this.length++, !0);
      }),
      (t.deleteRule = function (n) {
        this.rules.splice(n, 1), this.length--;
      }),
      (t.getRule = function (n) {
        return n < this.length ? this.rules[n] : '';
      }),
      e
    );
  })(),
  gA = Ew,
  Wie = { isServer: !Ew, useCSSOMInjection: !Oie },
  vO = (function () {
    function e(n, r, i) {
      n === void 0 && (n = Ji),
        r === void 0 && (r = {}),
        (this.options = ai({}, Wie, {}, n)),
        (this.gs = r),
        (this.names = new Map(i)),
        (this.server = !!n.isServer),
        !this.server &&
          Ew &&
          gA &&
          ((gA = !1),
          (function (o) {
            for (var a = document.querySelectorAll(Bie), c = 0, s = a.length; c < s; c++) {
              var l = a[c];
              l &&
                l.getAttribute(cs) !== 'active' &&
                (Uie(o, l), l.parentNode && l.parentNode.removeChild(l));
            }
          })(this));
    }
    e.registerId = function (n) {
      return wh(n);
    };
    var t = e.prototype;
    return (
      (t.reconstructWithOptions = function (n, r) {
        return (
          r === void 0 && (r = !0),
          new e(ai({}, this.options, {}, n), this.gs, (r && this.names) || void 0)
        );
      }),
      (t.allocateGSInstance = function (n) {
        return (this.gs[n] = (this.gs[n] || 0) + 1);
      }),
      (t.getTag = function () {
        return (
          this.tag ||
          (this.tag =
            ((i = (r = this.options).isServer),
            (o = r.useCSSOMInjection),
            (a = r.target),
            (n = i ? new $ie(a) : o ? new zie(a) : new Fie(a)),
            new Die(n)))
        );
        var n, r, i, o, a;
      }),
      (t.hasNameForId = function (n, r) {
        return this.names.has(n) && this.names.get(n).has(r);
      }),
      (t.registerName = function (n, r) {
        if ((wh(n), this.names.has(n))) this.names.get(n).add(r);
        else {
          var i = new Set();
          i.add(r), this.names.set(n, i);
        }
      }),
      (t.insertRules = function (n, r, i) {
        this.registerName(n, r), this.getTag().insertRules(wh(n), i);
      }),
      (t.clearNames = function (n) {
        this.names.has(n) && this.names.get(n).clear();
      }),
      (t.clearRules = function (n) {
        this.getTag().clearGroup(wh(n)), this.clearNames(n);
      }),
      (t.clearTag = function () {
        this.tag = void 0;
      }),
      (t.toString = function () {
        return (function (n) {
          for (var r = n.getTag(), i = r.length, o = '', a = 0; a < i; a++) {
            var c = Rie(a);
            if (c !== void 0) {
              var s = n.names.get(c),
                l = r.getGroup(a);
              if (s && l && s.size) {
                var u = cs + '.g' + a + '[id="' + c + '"]',
                  d = '';
                s !== void 0 &&
                  s.forEach(function (f) {
                    f.length > 0 && (d += f + ',');
                  }),
                  (o +=
                    '' +
                    l +
                    u +
                    '{content:"' +
                    d +
                    `"}/*!sc*/
`);
              }
            }
          }
          return o;
        })(this);
      }),
      e
    );
  })(),
  Vie = /(a)(d)/gi,
  yA = function (e) {
    return String.fromCharCode(e + (e > 25 ? 39 : 97));
  };
function h0(e) {
  var t,
    n = '';
  for (t = Math.abs(e); t > 52; t = (t / 52) | 0) n = yA(t % 52) + n;
  return (yA(t % 52) + n).replace(Vie, '$1-$2');
}
var Ma = function (e, t) {
    for (var n = t.length; n; ) e = (33 * e) ^ t.charCodeAt(--n);
    return e;
  },
  SO = function (e) {
    return Ma(5381, e);
  };
function Kie(e) {
  for (var t = 0; t < e.length; t += 1) {
    var n = e[t];
    if (hc(n) && !Iw(n)) return !1;
  }
  return !0;
}
var Hie = SO('5.3.3'),
  qie = (function () {
    function e(t, n, r) {
      (this.rules = t),
        (this.staticRulesId = ''),
        (this.isStatic = (r === void 0 || r.isStatic) && Kie(t)),
        (this.componentId = n),
        (this.baseHash = Ma(Hie, n)),
        (this.baseStyle = r),
        vO.registerId(n);
    }
    return (
      (e.prototype.generateAndInjectStyles = function (t, n, r) {
        var i = this.componentId,
          o = [];
        if (
          (this.baseStyle && o.push(this.baseStyle.generateAndInjectStyles(t, n, r)),
          this.isStatic && !r.hash)
        )
          if (this.staticRulesId && n.hasNameForId(i, this.staticRulesId))
            o.push(this.staticRulesId);
          else {
            var a = us(this.rules, t, n, r).join(''),
              c = h0(Ma(this.baseHash, a) >>> 0);
            if (!n.hasNameForId(i, c)) {
              var s = r(a, '.' + c, void 0, i);
              n.insertRules(i, c, s);
            }
            o.push(c), (this.staticRulesId = c);
          }
        else {
          for (
            var l = this.rules.length, u = Ma(this.baseHash, r.hash), d = '', f = 0;
            f < l;
            f++
          ) {
            var p = this.rules[f];
            if (typeof p == 'string') d += p;
            else if (p) {
              var y = us(p, t, n, r),
                b = Array.isArray(y) ? y.join('') : y;
              (u = Ma(u, b + f)), (d += b);
            }
          }
          if (d) {
            var m = h0(u >>> 0);
            if (!n.hasNameForId(i, m)) {
              var w = r(d, '.' + m, void 0, i);
              n.insertRules(i, m, w);
            }
            o.push(m);
          }
        }
        return o.join(' ');
      }),
      e
    );
  })(),
  Gie = /^\s*\/\/.*$/gm,
  Yie = [':', '[', '.', '#'];
function Zie(e) {
  var t,
    n,
    r,
    i,
    o = e === void 0 ? Ji : e,
    a = o.options,
    c = a === void 0 ? Ji : a,
    s = o.plugins,
    l = s === void 0 ? vp : s,
    u = new kie(c),
    d = [],
    f = (function (b) {
      function m(w) {
        if (w)
          try {
            b(w + '}');
          } catch {}
      }
      return function (w, _, S, E, O, N, F, D, k, K) {
        switch (w) {
          case 1:
            if (k === 0 && _.charCodeAt(0) === 64) return b(_ + ';'), '';
            break;
          case 2:
            if (D === 0) return _ + '/*|*/';
            break;
          case 3:
            switch (D) {
              case 102:
              case 112:
                return b(S[0] + _), '';
              default:
                return _ + (K === 0 ? '/*|*/' : '');
            }
          case -2:
            _.split('/*|*/}').forEach(m);
        }
      };
    })(function (b) {
      d.push(b);
    }),
    p = function (b, m, w) {
      return (m === 0 && Yie.indexOf(w[n.length]) !== -1) || w.match(i) ? b : '.' + t;
    };
  function y(b, m, w, _) {
    _ === void 0 && (_ = '&');
    var S = b.replace(Gie, ''),
      E = m && w ? w + ' ' + m + ' { ' + S + ' }' : S;
    return (
      (t = _),
      (n = m),
      (r = new RegExp('\\' + n + '\\b', 'g')),
      (i = new RegExp('(\\' + n + '\\b){2,}')),
      u(w || !m ? '' : m, E)
    );
  }
  return (
    u.use(
      [].concat(l, [
        function (b, m, w) {
          b === 2 && w.length && w[0].lastIndexOf(n) > 0 && (w[0] = w[0].replace(r, p));
        },
        f,
        function (b) {
          if (b === -2) {
            var m = d;
            return (d = []), m;
          }
        },
      ])
    ),
    (y.hash = l.length
      ? l
          .reduce(function (b, m) {
            return m.name || Ff(15), Ma(b, m.name);
          }, 5381)
          .toString()
      : ''),
    y
  );
}
var AO = Ue.createContext();
AO.Consumer;
var IO = Ue.createContext(),
  Qie = (IO.Consumer, new vO()),
  p0 = Zie();
function Jie() {
  return G.useContext(AO) || Qie;
}
function Xie() {
  return G.useContext(IO) || p0;
}
var eoe = (function () {
    function e(t, n) {
      var r = this;
      (this.inject = function (i, o) {
        o === void 0 && (o = p0);
        var a = r.name + o.hash;
        i.hasNameForId(r.id, a) || i.insertRules(r.id, a, o(r.rules, a, '@keyframes'));
      }),
        (this.toString = function () {
          return Ff(12, String(r.name));
        }),
        (this.name = t),
        (this.id = 'sc-keyframes-' + t),
        (this.rules = n);
    }
    return (
      (e.prototype.getName = function (t) {
        return t === void 0 && (t = p0), this.name + t.hash;
      }),
      e
    );
  })(),
  toe = /([A-Z])/,
  noe = /([A-Z])/g,
  roe = /^ms-/,
  ioe = function (e) {
    return '-' + e.toLowerCase();
  };
function bA(e) {
  return toe.test(e) ? e.replace(noe, ioe).replace(roe, '-ms-') : e;
}
var mA = function (e) {
  return e == null || e === !1 || e === '';
};
function us(e, t, n, r) {
  if (Array.isArray(e)) {
    for (var i, o = [], a = 0, c = e.length; a < c; a += 1)
      (i = us(e[a], t, n, r)) !== '' && (Array.isArray(i) ? o.push.apply(o, i) : o.push(i));
    return o;
  }
  if (mA(e)) return '';
  if (Iw(e)) return '.' + e.styledComponentId;
  if (hc(e)) {
    if (typeof (l = e) != 'function' || (l.prototype && l.prototype.isReactComponent) || !t)
      return e;
    var s = e(t);
    return us(s, t, n, r);
  }
  var l;
  return e instanceof eoe
    ? n
      ? (e.inject(n, r), e.getName(r))
      : e
    : f0(e)
      ? (function u(d, f) {
          var p,
            y,
            b = [];
          for (var m in d)
            d.hasOwnProperty(m) &&
              !mA(d[m]) &&
              ((Array.isArray(d[m]) && d[m].isCss) || hc(d[m])
                ? b.push(bA(m) + ':', d[m], ';')
                : f0(d[m])
                  ? b.push.apply(b, u(d[m], m))
                  : b.push(
                      bA(m) +
                        ': ' +
                        ((p = m),
                        (y = d[m]) == null || typeof y == 'boolean' || y === ''
                          ? ''
                          : typeof y != 'number' || y === 0 || p in Cie
                            ? String(y).trim()
                            : y + 'px') +
                        ';'
                    ));
          return f ? [f + ' {'].concat(b, ['}']) : b;
        })(e)
      : e.toString();
}
var wA = function (e) {
  return Array.isArray(e) && (e.isCss = !0), e;
};
function ooe(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  return hc(e) || f0(e)
    ? wA(us(hA(vp, [e].concat(n))))
    : n.length === 0 && e.length === 1 && typeof e[0] == 'string'
      ? e
      : wA(us(hA(e, n)));
}
var aoe = function (e, t, n) {
    return n === void 0 && (n = Ji), (e.theme !== n.theme && e.theme) || t || n.theme;
  },
  soe = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g,
  coe = /(^-|-$)/g;
function Zb(e) {
  return e.replace(soe, '-').replace(coe, '');
}
var uoe = function (e) {
  return h0(SO(e) >>> 0);
};
function _h(e) {
  return typeof e == 'string' && !0;
}
var g0 = function (e) {
    return typeof e == 'function' || (typeof e == 'object' && e !== null && !Array.isArray(e));
  },
  loe = function (e) {
    return e !== '__proto__' && e !== 'constructor' && e !== 'prototype';
  };
function doe(e, t, n) {
  var r = e[n];
  g0(t) && g0(r) ? EO(r, t) : (e[n] = t);
}
function EO(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  for (var i = 0, o = n; i < o.length; i++) {
    var a = o[i];
    if (g0(a)) for (var c in a) loe(c) && doe(e, a[c], c);
  }
  return e;
}
var TO = Ue.createContext();
TO.Consumer;
var Qb = {};
function kO(e, t, n) {
  var r = Iw(e),
    i = !_h(e),
    o = t.attrs,
    a = o === void 0 ? vp : o,
    c = t.componentId,
    s =
      c === void 0
        ? (function (_, S) {
            var E = typeof _ != 'string' ? 'sc' : Zb(_);
            Qb[E] = (Qb[E] || 0) + 1;
            var O = E + '-' + uoe('5.3.3' + E + Qb[E]);
            return S ? S + '-' + O : O;
          })(t.displayName, t.parentComponentId)
        : c,
    l = t.displayName,
    u =
      l === void 0
        ? (function (_) {
            return _h(_) ? 'styled.' + _ : 'Styled(' + pA(_) + ')';
          })(e)
        : l,
    d =
      t.displayName && t.componentId ? Zb(t.displayName) + '-' + t.componentId : t.componentId || s,
    f = r && e.attrs ? Array.prototype.concat(e.attrs, a).filter(Boolean) : a,
    p = t.shouldForwardProp;
  r &&
    e.shouldForwardProp &&
    (p = t.shouldForwardProp
      ? function (_, S, E) {
          return e.shouldForwardProp(_, S, E) && t.shouldForwardProp(_, S, E);
        }
      : e.shouldForwardProp);
  var y,
    b = new qie(n, d, r ? e.componentStyle : void 0),
    m = b.isStatic && a.length === 0,
    w = function (_, S) {
      return (function (E, O, N, F) {
        var D = E.attrs,
          k = E.componentStyle,
          K = E.defaultProps,
          M = E.foldedComponentIds,
          C = E.shouldForwardProp,
          z = E.styledComponentId,
          I = E.target,
          T = (function (fe, j, Ie) {
            fe === void 0 && (fe = Ji);
            var re = ai({}, j, { theme: fe }),
              Fe = {};
            return (
              Ie.forEach(function (De) {
                var Be,
                  _e,
                  lt,
                  jt = De;
                for (Be in (hc(jt) && (jt = jt(re)), jt))
                  re[Be] = Fe[Be] =
                    Be === 'className'
                      ? ((_e = Fe[Be]), (lt = jt[Be]), _e && lt ? _e + ' ' + lt : _e || lt)
                      : jt[Be];
              }),
              [re, Fe]
            );
          })(aoe(O, G.useContext(TO), K) || Ji, O, D),
          P = T[0],
          R = T[1],
          L = (function (fe, j, Ie, re) {
            var Fe = Jie(),
              De = Xie(),
              Be = j
                ? fe.generateAndInjectStyles(Ji, Fe, De)
                : fe.generateAndInjectStyles(Ie, Fe, De);
            return Be;
          })(k, F, P),
          H = N,
          ie = R.$as || O.$as || R.as || O.as || I,
          he = _h(ie),
          Q = R !== O ? ai({}, O, {}, R) : O,
          ee = {};
        for (var J in Q)
          J[0] !== '$' &&
            J !== 'as' &&
            (J === 'forwardedAs'
              ? (ee.as = Q[J])
              : (C ? C(J, fA, ie) : !he || fA(J)) && (ee[J] = Q[J]));
        return (
          O.style && R.style !== O.style && (ee.style = ai({}, O.style, {}, R.style)),
          (ee.className = Array.prototype
            .concat(M, z, L !== z ? L : null, O.className, R.className)
            .filter(Boolean)
            .join(' ')),
          (ee.ref = H),
          G.createElement(ie, ee)
        );
      })(y, _, S, m);
    };
  return (
    (w.displayName = u),
    ((y = Ue.forwardRef(w)).attrs = f),
    (y.componentStyle = b),
    (y.displayName = u),
    (y.shouldForwardProp = p),
    (y.foldedComponentIds = r
      ? Array.prototype.concat(e.foldedComponentIds, e.styledComponentId)
      : vp),
    (y.styledComponentId = d),
    (y.target = r ? e.target : e),
    (y.withComponent = function (_) {
      var S = t.componentId,
        E = (function (N, F) {
          if (N == null) return {};
          var D,
            k,
            K = {},
            M = Object.keys(N);
          for (k = 0; k < M.length; k++) (D = M[k]), F.indexOf(D) >= 0 || (K[D] = N[D]);
          return K;
        })(t, ['componentId']),
        O = S && S + '-' + (_h(_) ? _ : Zb(pA(_)));
      return kO(_, ai({}, E, { attrs: f, componentId: O }), n);
    }),
    Object.defineProperty(y, 'defaultProps', {
      get: function () {
        return this._foldedDefaultProps;
      },
      set: function (_) {
        this._foldedDefaultProps = r ? EO({}, e.defaultProps, _) : _;
      },
    }),
    (y.toString = function () {
      return '.' + y.styledComponentId;
    }),
    i &&
      $4(y, e, {
        attrs: !0,
        componentStyle: !0,
        displayName: !0,
        foldedComponentIds: !0,
        shouldForwardProp: !0,
        styledComponentId: !0,
        target: !0,
        withComponent: !0,
      }),
    y
  );
}
var pc = function (e) {
  return (function t(n, r, i) {
    if ((i === void 0 && (i = Ji), !wO.isValidElementType(r))) return Ff(1, String(r));
    var o = function () {
      return n(r, i, ooe.apply(void 0, arguments));
    };
    return (
      (o.withConfig = function (a) {
        return t(n, r, ai({}, i, {}, a));
      }),
      (o.attrs = function (a) {
        return t(n, r, ai({}, i, { attrs: Array.prototype.concat(i.attrs, a).filter(Boolean) }));
      }),
      o
    );
  })(kO, e);
};
[
  'a',
  'abbr',
  'address',
  'area',
  'article',
  'aside',
  'audio',
  'b',
  'base',
  'bdi',
  'bdo',
  'big',
  'blockquote',
  'body',
  'br',
  'button',
  'canvas',
  'caption',
  'cite',
  'code',
  'col',
  'colgroup',
  'data',
  'datalist',
  'dd',
  'del',
  'details',
  'dfn',
  'dialog',
  'div',
  'dl',
  'dt',
  'em',
  'embed',
  'fieldset',
  'figcaption',
  'figure',
  'footer',
  'form',
  'h1',
  'h2',
  'h3',
  'h4',
  'h5',
  'h6',
  'head',
  'header',
  'hgroup',
  'hr',
  'html',
  'i',
  'iframe',
  'img',
  'input',
  'ins',
  'kbd',
  'keygen',
  'label',
  'legend',
  'li',
  'link',
  'main',
  'map',
  'mark',
  'marquee',
  'menu',
  'menuitem',
  'meta',
  'meter',
  'nav',
  'noscript',
  'object',
  'ol',
  'optgroup',
  'option',
  'output',
  'p',
  'param',
  'picture',
  'pre',
  'progress',
  'q',
  'rp',
  'rt',
  'ruby',
  's',
  'samp',
  'script',
  'section',
  'select',
  'small',
  'source',
  'span',
  'strong',
  'style',
  'sub',
  'summary',
  'sup',
  'table',
  'tbody',
  'td',
  'textarea',
  'tfoot',
  'th',
  'thead',
  'time',
  'title',
  'tr',
  'track',
  'u',
  'ul',
  'var',
  'video',
  'wbr',
  'circle',
  'clipPath',
  'defs',
  'ellipse',
  'foreignObject',
  'g',
  'image',
  'line',
  'linearGradient',
  'marker',
  'mask',
  'path',
  'pattern',
  'polygon',
  'polyline',
  'radialGradient',
  'rect',
  'stop',
  'svg',
  'text',
  'textPath',
  'tspan',
].forEach(function (e) {
  pc[e] = pc(e);
});
const Ap = (e, t, n = !1) => {
    const r = Math.max(t, vw.large);
    return e.endsWith('.ico') ? e : D3(e, r, r, !n);
  },
  CO = pc.svg`
  display: inline-flex;
  width: ${({ responsive: e, size: t }) => (e ? '100%' : t)};

  g {
    transform-origin: center;
  }

  g,
  rect,
  circle,
  use,
  symbol {
    transition-property: fill, stroke, opacity, filter;
    transition-timing-function: cubic-bezier(0.16, 1, 0.3, 1); // ease-out-expo https://easings.net/#easeOutExpo
    transition-duration: 500ms;
  }

  @keyframes opacity {
    0% {
      opacity: 1;
    }
    100% {
      opacity: 0.5;
    }
  }

  .background.loading {
    animation: opacity 1s ease-in-out alternate infinite;
    fill: rgba(from ${Se.colors.legacy.white} r g b / 10%);
  }

  img {
    transition:
      filter 200ms ease-out,
      opacity 100ms ease-out;
  }

  img.loading {
    opacity: 0;
    filter: blur(6px);
  }
`,
  MO = (e, t) => `
@keyframes rotation-${e} {
  0% {
    stroke-dashoffset: ${t(0)};
  }
  100% {
    stroke-dashoffset: -${t(100)};
  }
}

@keyframes size-${e} {
  0%,
  100% {
    stroke-dasharray: ${t(10)}, ${t(90)};
  }
  33% {
    stroke-dasharray: ${t(75)}, ${t(25)};
  }
}

.${e} {
  animation: rotation-${e} 1s linear infinite, size-${e} 3s ease-in-out infinite;
}
`,
  foe = pc.span`
  box-sizing: border-box;
  color: ${({ color: e }) => e};
  display: inline-block;
  font-size: ${({ size: e }) => Math.round(e / 4)}px;
  font-weight: 600;
  letter-spacing: -0.05em;
  line-height: ${({ size: e }) => e}px;
  overflow: hidden;
  padding: 0 ${({ size: e }) => Math.round(e * 0.1)}px;
  text-align: center;
  text-overflow: ellipsis;
  user-select: none;
  white-space: nowrap;
  width: 100%;
`,
  hoe = G.memo(({ content: e, size: t, color: n }) =>
    A.jsx('foreignObject', {
      width: '100%',
      height: '100%',
      children: A.jsx(foe, {
        size: t,
        color: n,
        children: e.replaceAll(' ', '').slice(0, 5).trim(),
      }),
    })
  ),
  _A = (e, t, n, r = !1) => {
    const [i, o] = G.useState(void 0),
      [a, c] = G.useState(Ap(e, t, r)),
      [s, l] = G.useState(e);
    e !== s && (l(e), o(void 0), c(Ap(e, t, r)));
    const u = G.useCallback(() => {
        o('fail'), n && n();
      }, [n]),
      d = G.useCallback(() => o('success'), []);
    return { src: a, status: i, handleError: u, handleLoad: d };
  },
  vA = {
    18: 'M0 9C0 6.20435 0 4.80653 0.456723 3.7039C1.06569 2.23373 2.23373 1.06569 3.7039 0.456723C4.80653 0 6.20435 0 9 0C11.7956 0 13.1935 0 14.2961 0.456723C15.7663 1.06569 16.9343 2.23373 17.5433 3.7039C18 4.80653 18 6.20435 18 9C18 11.7956 18 13.1935 17.5433 14.2961C16.9343 15.7663 15.7663 16.9343 14.2961 17.5433C13.1935 18 11.7956 18 9 18C6.20435 18 4.80653 18 3.7039 17.5433C2.23373 16.9343 1.06569 15.7663 0.456723 14.2961C0 13.1935 0 11.7956 0 9Z',
    24: 'M0 12C0 8.27247 0 6.4087 0.608964 4.93853C1.42092 2.97831 2.97831 1.42092 4.93853 0.608964C6.4087 0 8.27247 0 12 0C15.7275 0 17.5913 0 19.0615 0.608964C21.0217 1.42092 22.5791 2.97831 23.391 4.93853C24 6.4087 24 8.27247 24 12C24 15.7275 24 17.5913 23.391 19.0615C22.5791 21.0217 21.0217 22.5791 19.0615 23.391C17.5913 24 15.7275 24 12 24C8.27247 24 6.4087 24 4.93853 23.391C2.97831 22.5791 1.42092 21.0217 0.608964 19.0615C0 17.5913 0 15.7275 0 12Z',
    40: 'M0 19.2C0 12.4794 0 9.11906 1.30792 6.55211C2.4584 4.29417 4.29417 2.4584 6.55211 1.30792C9.11906 0 12.4794 0 19.2 0H20.8C27.5206 0 30.8809 0 33.4479 1.30792C35.7058 2.4584 37.5416 4.29417 38.6921 6.55211C40 9.11906 40 12.4794 40 19.2V20.8C40 27.5206 40 30.8809 38.6921 33.4479C37.5416 35.7058 35.7058 37.5416 33.4479 38.6921C30.8809 40 27.5206 40 20.8 40H19.2C12.4794 40 9.11906 40 6.55211 38.6921C4.29417 37.5416 2.4584 35.7058 1.30792 33.4479C0 30.8809 0 27.5206 0 20.8V19.2Z',
    48: 'M0 24C0 16.5449 0 12.8174 1.21793 9.87706C2.84183 5.95662 5.95662 2.84183 9.87706 1.21793C12.8174 0 16.5449 0 24 0C31.4551 0 35.1826 0 38.1229 1.21793C42.0434 2.84183 45.1582 5.95662 46.7821 9.87706C48 12.8174 48 16.5449 48 24C48 31.4551 48 35.1826 46.7821 38.1229C45.1582 42.0434 42.0434 45.1582 38.1229 46.7821C35.1826 48 31.4551 48 24 48C16.5449 48 12.8174 48 9.87706 46.7821C5.95662 45.1582 2.84183 42.0434 1.21793 38.1229C0 35.1826 0 31.4551 0 24Z',
    64: 'M0 32C0 22.6872 0 18.0308 1.38711 14.3118C3.61706 8.33304 8.33304 3.61706 14.3118 1.38711C18.0308 0 22.6872 0 32 0C41.3128 0 45.9692 0 49.6882 1.38711C55.667 3.61706 60.3829 8.33304 62.6129 14.3118C64 18.0308 64 22.6872 64 32C64 41.3128 64 45.9692 62.6129 49.6882C60.3829 55.667 55.667 60.3829 49.6882 62.6129C45.9692 64 41.3128 64 32 64C22.6872 64 18.0308 64 14.3118 62.6129C8.33304 60.3829 3.61706 55.667 1.38711 49.6882C0 45.9692 0 41.3128 0 32Z',
  },
  poe = `rgba(from ${Se.colors.legacy.white} r g b / 4%)`,
  goe = Se.colors.legacy.white,
  yoe = Se.colors.legacy.white,
  boe = Se.colors.legacy.black,
  PO = (e) => {
    const t = y4(),
      n = `img-m-${t}`,
      r = `img-s-${t}`,
      i = `bdg-s-${t}`,
      o = `bdg-m-${t}`,
      a = `spnr-r-${t}`,
      c = Math.max(8, Math.round(e * 0.2)),
      s = 1 + c / 10,
      l = s + c / 20,
      u = (e / 3) * 2,
      d = Math.round(c * 0.75 * 2),
      f = e / 2,
      p = (e - u) / 2,
      y = f,
      b = c * 2,
      m = e - b + l,
      w = e - c + l,
      _ = m + (b - d) / 2,
      S = m - s,
      E = 2 * s + b,
      O = s + b,
      N = (k) => {
        const K = parseInt(
          Object.keys(vA).reduce((M, C) =>
            Math.abs(parseInt(C) - k) < Math.abs(parseInt(M) - k) ? C : M
          )
        );
        return { viewBox: `0 0 ${K} ${K}`, path: vA[K] };
      },
      F = N(e),
      D = N(b);
    return {
      badgeBorder: s,
      badgeBoxXY: m,
      badgeCXY: w,
      badgeIconOffset: _,
      badgeIconSize: d,
      badgeMaskBoxXY: S,
      badgeMaskId: o,
      badgeMaskSize: E,
      badgeOvershoot: l,
      badgeRadius: c,
      badgeRect: D,
      badgeShapeId: i,
      badgeSize: b,
      badgeSpinnerSize: O,
      fallbackBadgeBgColor: yoe,
      fallbackBadgeFgColor: boe,
      fallbackBgColor: poe,
      fallbackFgColor: goe,
      imageCXY: f,
      imageIconOffset: p,
      imageIconSize: u,
      imageMaskId: n,
      imageRadius: y,
      imageRect: F,
      imageShapeId: r,
      spinnerId: a,
    };
  },
  moe = G.memo(
    ({
      size: e = vw.small,
      image: t,
      badge: n,
      responsive: r = !1,
      loading: i = !1,
      dimmed: o = !1,
      enableAnimations: a = !1,
      onError: c,
      className: s,
      onClick: l,
    }) => {
      const {
          badgeBorder: u,
          badgeBoxXY: d,
          badgeIconOffset: f,
          badgeIconSize: p,
          badgeMaskBoxXY: y,
          badgeMaskId: b,
          badgeMaskSize: m,
          badgeRadius: w,
          badgeRect: _,
          badgeShapeId: S,
          badgeSize: E,
          badgeSpinnerSize: O,
          fallbackBadgeBgColor: N,
          fallbackBadgeFgColor: F,
          fallbackBgColor: D,
          fallbackFgColor: k,
          imageCXY: K,
          imageIconOffset: M,
          imageIconSize: C,
          imageMaskId: z,
          imageRadius: I,
          imageRect: T,
          imageShapeId: P,
          spinnerId: R,
        } = PO(e),
        L = _A(typeof t.src == 'string' ? t.src : '', e, c, a),
        H = _A(typeof (n == null ? void 0 : n.src) == 'string' ? n.src : '', E),
        ie = (J) => {
          if ((n == null ? void 0 : n.shape) === 'square') return E * (4 - e / 60) * (J / 100);
          {
            const fe = n ? w : C / 2;
            return 2 * Math.PI * fe * (J / 100);
          }
        },
        he = G.useCallback((J) => {
          J.preventDefault();
        }, []),
        Q = R3,
        ee = G.useCallback(
          (J) => {
            l && l(J);
          },
          [l]
        );
      return A.jsxs(CO, {
        className: s,
        fill: 'none',
        overflow: 'visible',
        responsive: r,
        size: e,
        viewBox: `0 0 ${e} ${e}`,
        width: e,
        xmlns: 'http://www.w3.org/2000/svg',
        onClick: ee,
        style: { cursor: l ? 'pointer' : 'default' },
        children: [
          A.jsxs('defs', {
            children: [
              A.jsx('style', { children: MO(R, ie) }),
              i &&
                A.jsxs('symbol', {
                  id: R,
                  viewBox: `0 0 ${e} ${e}`,
                  overflow: 'visible',
                  children: [
                    !n &&
                      A.jsxs(A.Fragment, {
                        children: [
                          A.jsx('circle', {
                            cx: K,
                            cy: K,
                            fill: 'none',
                            r: C / 2,
                            stroke:
                              typeof t.src == 'function' ? (t == null ? void 0 : t.fgColor) : k,
                            strokeLinecap: 'round',
                            strokeOpacity: '0.25',
                            strokeWidth: u,
                          }),
                          A.jsx('circle', {
                            className: R,
                            cx: K,
                            cy: K,
                            fill: 'none',
                            r: C / 2,
                            stroke:
                              typeof t.src == 'function' ? (t == null ? void 0 : t.fgColor) : k,
                            strokeLinecap: 'round',
                            strokeWidth: u,
                          }),
                        ],
                      }),
                    n &&
                      A.jsx('use', {
                        className: R,
                        fill: 'none',
                        height: O,
                        href: `#${S}`,
                        strokeWidth: u,
                        stroke: (n && 'bgColor' in n && n.bgColor) || t.fgColor || k,
                        strokeLinecap: 'round',
                        width: O,
                        x: y + u / 2,
                        y: y + u / 2,
                      }),
                  ],
                }),
              t.shape === 'circle' &&
                A.jsx('symbol', {
                  id: P,
                  viewBox: `0 0 ${e} ${e}`,
                  overflow: 'visible',
                  children: A.jsx('circle', { cx: I, cy: I, r: I }),
                }),
              t.shape === 'square' &&
                A.jsx('symbol', {
                  id: P,
                  viewBox: T.viewBox,
                  overflow: 'visible',
                  children: A.jsx('path', { d: T.path }),
                }),
              n &&
                H.status !== 'fail' &&
                A.jsxs(A.Fragment, {
                  children: [
                    n.shape === 'circle' &&
                      A.jsx('symbol', {
                        id: S,
                        viewBox: `0 0 ${E} ${E}`,
                        overflow: 'visible',
                        children: A.jsx('circle', { cx: w, cy: w, r: w }),
                      }),
                    n.shape === 'square' &&
                      A.jsx('symbol', {
                        id: S,
                        viewBox: _.viewBox,
                        overflow: 'visible',
                        children: A.jsx('path', { d: _.path }),
                      }),
                  ],
                }),
              A.jsxs('mask', {
                id: z,
                x: '0',
                y: '0',
                width: e,
                height: e,
                children: [
                  A.jsx('use', { href: `#${P}`, width: e, height: e, fill: 'white' }),
                  n &&
                    H.status !== 'fail' &&
                    A.jsx('use', { href: `#${S}`, x: y, y, width: m, height: m, fill: 'black' }),
                ],
              }),
              typeof (n == null ? void 0 : n.src) == 'string' &&
                A.jsx('mask', {
                  id: b,
                  children: A.jsx('use', {
                    href: `#${S}`,
                    x: d,
                    y: d,
                    width: E,
                    height: E,
                    fill: 'white',
                  }),
                }),
            ],
          }),
          A.jsxs('g', {
            mask: `url(#${z})`,
            opacity: i || o ? 0.5 : 1,
            style: { filter: o ? 'grayscale(100%)' : i ? 'grayscale(25%)' : '' },
            children: [
              !('fullSize' in t && t.fullSize) &&
                A.jsx('use', {
                  href: `#${P}`,
                  width: e,
                  height: e,
                  fill: t.bgColor || D,
                  className: `${L.status} background`,
                }),
              (L.status === 'fail' || t.src === null || t.src === void 0) &&
                ('fallback' in t && t.fallback
                  ? typeof t.fallback == 'string'
                    ? A.jsx(hoe, { content: t.fallback, size: e, color: t.fgColor || k })
                    : A.jsx('g', {
                        transform: `scale(${i ? 0.66 : 0.75}) translate(${M},${M})`,
                        opacity: '0.25',
                        children: t.fallback({ width: C, fill: t.fgColor || k }),
                      })
                  : A.jsxs('g', {
                      color: 'black',
                      width: 56,
                      children: [
                        A.jsx('use', { href: `#${P}`, width: e, height: e, fill: 'black' }),
                        A.jsx(Q, { size: '50%', color: 'gray', x: '25%', y: '25%' }),
                      ],
                    })),
              typeof t.src == 'string' &&
                L.status !== 'fail' &&
                A.jsx('foreignObject', {
                  width: e,
                  height: e,
                  children: A.jsx('img', {
                    className: L.status,
                    crossOrigin: 'anonymous',
                    height: e,
                    onError: L.handleError,
                    onLoad: L.handleLoad,
                    src: L.src,
                    width: e,
                    onDragStart: he,
                  }),
                }),
              typeof t.src == 'function' &&
                ('fullSize' in t && t.fullSize
                  ? t.src({ width: e, height: e })
                  : A.jsx('g', {
                      transform: `${i && !n ? 'scale(0.66) ' : ''}translate(${M},${M})`,
                      children: t.src({
                        width: C,
                        height: C,
                        fill: ('fgColor' in t && t.fgColor) || k,
                      }),
                    })),
            ],
          }),
          n &&
            H.status !== 'fail' &&
            A.jsxs('g', {
              children: [
                A.jsx('use', {
                  href: `#${S}`,
                  opacity: i ? 0.2 : 1,
                  fill: i
                    ? 'transparent'
                    : typeof n.src == 'string' && H.status === 'success'
                      ? D
                      : n.bgColor || N,
                  x: d,
                  y: d,
                  width: E,
                  height: E,
                  className: `${H.status} background`,
                }),
                typeof n.src == 'string' &&
                  A.jsx('g', {
                    mask: `url(#${b})`,
                    children: A.jsx('foreignObject', {
                      x: d,
                      y: d,
                      width: E,
                      height: E,
                      children: A.jsx('img', {
                        className: H.status,
                        crossOrigin: 'anonymous',
                        height: E,
                        onError: H.handleError,
                        onLoad: H.handleLoad,
                        src: H.src,
                        width: E,
                      }),
                    }),
                  }),
                typeof n.src == 'function' &&
                  A.jsx('g', {
                    transform: `translate(${f},${f})`,
                    children: n.src({
                      width: p,
                      height: p,
                      fill: i
                        ? ('bgColor' in n && (n == null ? void 0 : n.bgColor)) || N
                        : ('fgColor' in n && n.fgColor) || F,
                    }),
                  }),
              ],
            }),
          i && A.jsx('use', { href: `#${R}`, x: '0', y: '0', width: e, height: e }),
        ],
      });
    }
  ),
  woe = G.memo(
    ({
      size: e = vw.small,
      bgToken: t,
      fgToken: n,
      badge: r,
      responsive: i = !1,
      loading: o = !1,
      onError: a,
      className: c,
      onClick: s,
    }) => {
      const {
          badgeBorder: l,
          fallbackBgColor: u,
          fallbackFgColor: d,
          imageMaskId: f,
          badgeMaskId: p,
          spinnerId: y,
        } = PO(e),
        [b, m] = G.useState(void 0),
        [w, _] = G.useState(void 0),
        S = G.useCallback(
          (C) => {
            b === void 0 && m(C != null && C.complete ? 'success' : 'loading');
          },
          [b]
        ),
        E = G.useCallback(
          (C) => {
            w === void 0 && _(C != null && C.complete ? 'success' : 'loading');
          },
          [w]
        );
      if (b === 'fail' || w === 'fail')
        return A.jsx(Tw, {
          className: c,
          image: { type: 'icon', preset: 'swap' },
          badge: r,
          loading: o,
          onError: a,
          responsive: i,
          size: e,
        });
      const O = Math.round(e / 3.25),
        N = Math.round(e / 2.75),
        F = 2 * O,
        D = 2 * N,
        k = e - D,
        K = e - N,
        M = (C) => {
          const z = N + l / 2;
          return 2 * Math.PI * z * (C / 100);
        };
      return A.jsxs(CO, {
        className: c,
        fill: 'none',
        overflow: 'visible',
        responsive: i,
        size: e,
        viewBox: `0 0 ${e} ${e}`,
        width: e,
        xmlns: 'http://www.w3.org/2000/svg',
        onClick: s,
        style: { cursor: s ? 'pointer' : 'default' },
        children: [
          A.jsxs('defs', {
            children: [
              A.jsx('style', { children: MO(y, M) }),
              o &&
                A.jsx('symbol', {
                  id: y,
                  viewBox: `0 0 ${e} ${e}`,
                  overflow: 'visible',
                  children: A.jsx('circle', {
                    className: y,
                    cx: K,
                    cy: K,
                    fill: 'none',
                    r: N + l / 2,
                    stroke: d,
                    strokeLinecap: 'round',
                    strokeWidth: l,
                  }),
                }),
              A.jsxs('mask', {
                id: f,
                x: '0',
                y: '0',
                width: '100%',
                height: '100%',
                children: [
                  A.jsx('circle', { cx: O, cy: O, r: O, fill: 'white' }),
                  A.jsx('circle', { cx: K, cy: K, r: N + l, fill: 'black' }),
                ],
              }),
              A.jsx('mask', {
                id: p,
                x: '0',
                y: '0',
                width: '100%',
                height: '100%',
                children: A.jsx('circle', { cx: K, cy: K, r: N, fill: 'white' }),
              }),
            ],
          }),
          A.jsxs('g', {
            opacity: o ? 0.5 : 1,
            style: { filter: o ? 'grayscale(25%)' : '' },
            children: [
              A.jsxs('g', {
                mask: `url(#${f})`,
                children: [
                  A.jsx('circle', {
                    r: O,
                    cx: O,
                    cy: O,
                    fill: t.bgColor || u,
                    className: `${b} background`,
                  }),
                  typeof t.src == 'string'
                    ? A.jsx('foreignObject', {
                        width: F,
                        height: F,
                        children: A.jsx('img', {
                          width: F,
                          height: F,
                          src: Ap(t.src, F),
                          ref: S,
                          onError: () => {
                            m('fail'), a && a();
                          },
                          onLoad: () => m('success'),
                          className: b,
                        }),
                      })
                    : A.jsx('g', {
                        transform: `translate(${Math.floor(F / 6)}, ${Math.floor(F / 6)})`,
                        children: t.src({
                          width: Math.ceil(F / 3) * 2,
                          fill: ('fgColor' in t && t.fgColor) || d,
                        }),
                      }),
                ],
              }),
              A.jsx('g', {
                mask: `url(#${p})`,
                children: A.jsxs('g', {
                  transform: `translate(${k}, ${k})`,
                  children: [
                    A.jsx('circle', {
                      r: N,
                      cx: N,
                      cy: N,
                      fill: n.bgColor || u,
                      style: { filter: 'drop-shadow(-2px -2px 5px rgba(0, 0, 0, 0.33))' },
                      className: `${w} background`,
                    }),
                    typeof n.src == 'string'
                      ? A.jsx('foreignObject', {
                          width: D,
                          height: D,
                          children: A.jsx('img', {
                            src: Ap(n.src, D),
                            width: D,
                            height: D,
                            ref: E,
                            onError: () => {
                              _('fail'), a && a();
                            },
                            onLoad: () => _('success'),
                            className: w,
                          }),
                        })
                      : A.jsx('g', {
                          transform: `translate(${Math.floor(D / 6)}, ${Math.floor(D / 6)})`,
                          children: n.src({
                            width: Math.ceil(D / 3) * 2,
                            fill: ('fgColor' in n && n.fgColor) || d,
                          }),
                        }),
                  ],
                }),
              }),
            ],
          }),
          o && A.jsx('use', { href: `#${y}`, x: '0', y: '0', width: e, height: e }),
        ],
      });
    }
  ),
  _oe = pc.div`
  position: relative;
  height: ${(e) => e.diameter};
  width: ${(e) => e.diameter};
  background-color: ${(e) => e.color};
  border-radius: ${(e) => (e.shape === 'square' ? 20 : 50)}%;
  border: ${(e) => e.border};
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  opacity: ${(e) => e.opacity};
  mask: ${(e) => e.mask};
`;
_oe.defaultProps = { color: 'blue', shape: 'circle', diameter: '100%', border: 'none' };
const voe = ({ width: e = 94 }) =>
    A.jsxs('svg', {
      width: e,
      height: e,
      viewBox: '0 0 94 94',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: [
        A.jsx('g', {
          filter: 'url(#filter0_i)',
          children: A.jsx('circle', { cx: '47', cy: '47', r: '47', fill: '#000000' }),
        }),
        A.jsx('path', {
          d: 'M32.1506 56.7183C32.4198 56.4452 32.7848 56.2919 33.1654 56.2919H68.2807C68.9203 56.2919 69.2406 57.077 68.788 57.536L61.8494 64.5735C61.5801 64.8466 61.2151 65 60.8345 65H25.7193C25.0796 65 24.7594 64.2148 25.2119 63.7558L32.1506 56.7183Z',
          fill: 'url(#paint0_linear)',
        }),
        A.jsx('path', {
          d: 'M32.1507 30.4265C32.4199 30.1534 32.7849 30 33.1655 30H68.2807C68.9204 30 69.2406 30.7852 68.7881 31.2442L61.8494 38.2817C61.5802 38.5548 61.2152 38.7081 60.8346 38.7081H25.7194C25.0797 38.7081 24.7595 37.9229 25.2119 37.464L32.1507 30.4265Z',
          fill: 'url(#paint1_linear)',
        }),
        A.jsx('path', {
          d: 'M61.8494 43.4886C61.5801 43.2156 61.2151 43.0622 60.8345 43.0622H25.7193C25.0796 43.0622 24.7594 43.8474 25.2119 44.3063L32.1506 51.3439C32.4198 51.617 32.7848 51.7704 33.1654 51.7704H68.2807C68.9203 51.7704 69.2406 50.9852 68.788 50.5262L61.8494 43.4886Z',
          fill: 'url(#paint2_linear)',
        }),
        A.jsxs('defs', {
          children: [
            A.jsxs('filter', {
              id: 'filter0_i',
              x: '0',
              y: '0',
              width: '94',
              height: '94',
              filterUnits: 'userSpaceOnUse',
              colorInterpolationFilters: 'sRGB',
              children: [
                A.jsx('feFlood', { floodOpacity: '0', result: 'BackgroundImageFix' }),
                A.jsx('feBlend', {
                  mode: 'normal',
                  in: 'SourceGraphic',
                  in2: 'BackgroundImageFix',
                  result: 'shape',
                }),
                A.jsx('feColorMatrix', {
                  in: 'SourceAlpha',
                  type: 'matrix',
                  values: '0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0',
                  result: 'hardAlpha',
                }),
                A.jsx('feOffset', {}),
                A.jsx('feGaussianBlur', { stdDeviation: '2' }),
                A.jsx('feComposite', {
                  in2: 'hardAlpha',
                  operator: 'arithmetic',
                  k2: '-1',
                  k3: '1',
                }),
                A.jsx('feColorMatrix', {
                  type: 'matrix',
                  values: '0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0',
                }),
                A.jsx('feBlend', { mode: 'normal', in2: 'shape', result: 'effect1_innerShadow' }),
              ],
            }),
            A.jsxs('linearGradient', {
              id: 'paint0_linear',
              x1: '54.7466',
              y1: '20.3993',
              x2: '29.8682',
              y2: '67.3446',
              gradientUnits: 'userSpaceOnUse',
              children: [
                A.jsx('stop', { stopColor: '#00FFA3' }),
                A.jsx('stop', { offset: '1', stopColor: '#DC1FFF' }),
              ],
            }),
            A.jsxs('linearGradient', {
              id: 'paint1_linear',
              x1: '54.7466',
              y1: '20.3993',
              x2: '29.8682',
              y2: '67.3446',
              gradientUnits: 'userSpaceOnUse',
              children: [
                A.jsx('stop', { stopColor: '#00FFA3' }),
                A.jsx('stop', { offset: '1', stopColor: '#DC1FFF' }),
              ],
            }),
            A.jsxs('linearGradient', {
              id: 'paint2_linear',
              x1: '54.7466',
              y1: '20.3993',
              x2: '29.8682',
              y2: '67.3446',
              gradientUnits: 'userSpaceOnUse',
              children: [
                A.jsx('stop', { stopColor: '#00FFA3' }),
                A.jsx('stop', { offset: '1', stopColor: '#DC1FFF' }),
              ],
            }),
          ],
        }),
      ],
    }),
  Soe = ({ width: e, fill: t = 'white' }) =>
    A.jsxs('svg', {
      width: e,
      height: e,
      viewBox: '0 0 24 24',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: [
        A.jsx('path', {
          d: 'M12 15.8204L18.1317 12.2036L12 2.00002L5.86826 12.2036L12 15.8204Z',
          fill: t,
        }),
        A.jsx('path', { d: 'M12 22L18.1317 13.3533L12 16.9701L5.86826 13.3533L12 22Z', fill: t }),
      ],
    }),
  Aoe = ({ width: e, fill: t = 'white' }) =>
    A.jsx('svg', {
      width: e,
      height: e,
      viewBox: '0 0 24 24',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: A.jsx('path', {
        d: 'M17.1436 8.57817C16.7781 8.36929 16.3081 8.36929 15.8904 8.57817L12.9661 10.3014L10.9817 11.398L8.10968 13.1212C7.74414 13.3301 7.27417 13.3301 6.85641 13.1212L4.61098 11.7635C4.24545 11.5547 3.98435 11.1369 3.98435 10.6669V8.05597C3.98435 7.63822 4.19323 7.22047 4.61098 6.95937L6.85641 5.65389C7.22195 5.44501 7.69192 5.44501 8.10968 5.65389L10.3551 7.01159C10.7206 7.22047 10.9817 7.63822 10.9817 8.10819V9.83143L12.9661 8.68261V6.90715C12.9661 6.4894 12.7572 6.07164 12.3394 5.81055L8.1619 3.35624C7.79636 3.14737 7.32639 3.14737 6.90863 3.35624L2.62665 5.86277C2.20889 6.07164 2.00002 6.4894 2.00002 6.90715V11.8158C2.00002 12.2335 2.20889 12.6513 2.62665 12.9124L6.85641 15.3667C7.22195 15.5755 7.69192 15.5755 8.10968 15.3667L10.9817 13.6957L12.9661 12.5468L15.8381 10.8758C16.2037 10.6669 16.6736 10.6669 17.0914 10.8758L19.3368 12.1813C19.7024 12.3902 19.9635 12.8079 19.9635 13.2779V15.8889C19.9635 16.3066 19.7546 16.7244 19.3368 16.9855L17.1436 18.2909C16.7781 18.4998 16.3081 18.4998 15.8904 18.2909L13.6449 16.9855C13.2794 16.7766 13.0183 16.3588 13.0183 15.8889V14.2178L11.034 15.3667V17.0899C11.034 17.5077 11.2428 17.9254 11.6606 18.1865L15.8904 20.6408C16.2559 20.8497 16.7259 20.8497 17.1436 20.6408L21.3734 18.1865C21.7389 17.9776 22 17.5599 22 17.0899V12.1291C22 11.7113 21.7911 11.2936 21.3734 11.0325L17.1436 8.57817Z',
        fill: t,
      }),
    }),
  SA = ({ width: e, fill: t = 'white' }) =>
    A.jsx('svg', {
      width: e,
      height: e,
      viewBox: '0 0 24 24',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: A.jsx('path', {
        d: 'M20.9073 16.5239L17.9359 19.6285C17.8713 19.6959 17.7931 19.7497 17.7063 19.7864C17.6194 19.8232 17.5257 19.8421 17.4311 19.8421H3.34497C3.27776 19.8421 3.21201 19.8229 3.15581 19.787C3.0996 19.7511 3.05539 19.7 3.0286 19.6399C3.00181 19.5799 2.99361 19.5135 3.005 19.449C3.0164 19.3845 3.0469 19.3246 3.09276 19.2767L6.06644 16.1722C6.13086 16.1049 6.20876 16.0513 6.29532 16.0145C6.3819 15.9778 6.47529 15.9588 6.56973 15.9586H20.655C20.7222 15.9586 20.788 15.9777 20.8442 16.0136C20.9004 16.0495 20.9446 16.1007 20.9715 16.1607C20.9982 16.2208 21.0064 16.2871 20.995 16.3517C20.9836 16.4162 20.9531 16.4761 20.9073 16.5239ZM17.9359 10.2723C17.8713 10.2049 17.7931 10.1511 17.7063 10.1144C17.6194 10.0776 17.5257 10.0587 17.4311 10.0588H3.34497C3.27776 10.0588 3.21201 10.0779 3.15581 10.1138C3.0996 10.1497 3.05539 10.2008 3.0286 10.2609C3.00181 10.3209 2.99361 10.3873 3.005 10.4518C3.0164 10.5163 3.0469 10.5762 3.09276 10.6241L6.06644 13.7286C6.13086 13.7959 6.20876 13.8495 6.29532 13.8863C6.3819 13.923 6.47529 13.942 6.56973 13.9422H20.655C20.7222 13.9422 20.788 13.9231 20.8442 13.8872C20.9004 13.8512 20.9446 13.8001 20.9715 13.7401C20.9982 13.68 21.0064 13.6137 20.995 13.5491C20.9836 13.4846 20.9531 13.4247 20.9073 13.3768L17.9359 10.2723ZM3.34497 8.04234H17.4311C17.5257 8.04238 17.6194 8.02345 17.7063 7.9867C17.7931 7.94996 17.8713 7.89619 17.9359 7.82875L20.9073 4.72423C20.9531 4.67636 20.9836 4.61648 20.995 4.55195C21.0064 4.48742 20.9982 4.42105 20.9715 4.361C20.9446 4.30095 20.9004 4.24983 20.8442 4.21393C20.788 4.17802 20.7222 4.15889 20.655 4.15889H6.56973C6.47529 4.15905 6.3819 4.17808 6.29532 4.21482C6.20876 4.25156 6.13086 4.30522 6.06644 4.37248L3.09352 7.477C3.04771 7.52482 3.01723 7.58465 3.0058 7.64909C2.99438 7.71355 3.00251 7.77986 3.02921 7.83989C3.05591 7.89991 3.1 7.95103 3.15609 7.98699C3.21218 8.02295 3.27782 8.04218 3.34497 8.04234Z',
        fill: t,
      }),
    }),
  AA = ({ width: e, fill: t = 'white' }) =>
    A.jsxs('svg', {
      width: e,
      height: e,
      viewBox: '0 0 24 24',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: [
        A.jsx('path', {
          d: 'M12 15.8204L18.1317 12.2036L12 2.00002L5.86826 12.2036L12 15.8204Z',
          fill: t,
        }),
        A.jsx('path', { d: 'M12 22L18.1317 13.3533L12 16.9701L5.86826 13.3533L12 22Z', fill: t }),
      ],
    }),
  IA = ({ width: e, fill: t = 'white' }) =>
    A.jsx('svg', {
      width: e,
      height: e,
      viewBox: '0 0 24 24',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: A.jsx('path', {
        d: 'M17.1436 8.57817C16.7781 8.36929 16.3081 8.36929 15.8904 8.57817L12.9661 10.3014L10.9817 11.398L8.10968 13.1212C7.74414 13.3301 7.27417 13.3301 6.85641 13.1212L4.61098 11.7635C4.24545 11.5547 3.98435 11.1369 3.98435 10.6669V8.05597C3.98435 7.63822 4.19323 7.22047 4.61098 6.95937L6.85641 5.65389C7.22195 5.44501 7.69192 5.44501 8.10968 5.65389L10.3551 7.01159C10.7206 7.22047 10.9817 7.63822 10.9817 8.10819V9.83143L12.9661 8.68261V6.90715C12.9661 6.4894 12.7572 6.07164 12.3394 5.81055L8.1619 3.35624C7.79636 3.14737 7.32639 3.14737 6.90863 3.35624L2.62665 5.86277C2.20889 6.07164 2.00002 6.4894 2.00002 6.90715V11.8158C2.00002 12.2335 2.20889 12.6513 2.62665 12.9124L6.85641 15.3667C7.22195 15.5755 7.69192 15.5755 8.10968 15.3667L10.9817 13.6957L12.9661 12.5468L15.8381 10.8758C16.2037 10.6669 16.6736 10.6669 17.0914 10.8758L19.3368 12.1813C19.7024 12.3902 19.9635 12.8079 19.9635 13.2779V15.8889C19.9635 16.3066 19.7546 16.7244 19.3368 16.9855L17.1436 18.2909C16.7781 18.4998 16.3081 18.4998 15.8904 18.2909L13.6449 16.9855C13.2794 16.7766 13.0183 16.3588 13.0183 15.8889V14.2178L11.034 15.3667V17.0899C11.034 17.5077 11.2428 17.9254 11.6606 18.1865L15.8904 20.6408C16.2559 20.8497 16.7259 20.8497 17.1436 20.6408L21.3734 18.1865C21.7389 17.9776 22 17.5599 22 17.0899V12.1291C22 11.7113 21.7911 11.2936 21.3734 11.0325L17.1436 8.57817Z',
        fill: t,
      }),
    }),
  EA = ({ width: e, fill: t = 'white' }) =>
    A.jsx('svg', {
      width: e,
      height: e,
      viewBox: '0 0 16 16',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: A.jsx('path', {
        d: 'M7.99996 1C5.97853 1 1 5.97836 1 7.99988C1 10.0214 5.97853 14.9998 7.99996 14.9998C10.0214 14.9998 15 10.0213 15 7.99988C15 5.97844 10.0215 1 7.99996 1ZM6.90913 12.0026C6.05671 11.7704 3.76491 7.76146 3.99723 6.90905C4.22955 6.0566 8.23842 3.76487 9.09083 3.99719C9.94328 4.22947 12.2351 8.2383 12.0028 9.09075C11.7704 9.9432 7.76154 12.235 6.90913 12.0026Z',
        fill: t,
      }),
    }),
  Jb = ({ width: e, height: t, fill: n = 'white' }) =>
    A.jsx('svg', {
      width: e,
      height: t,
      viewBox: '0 0 18 26',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: A.jsx('path', {
        d: 'M14.5119 12.0902C15.807 11.4229 16.6173 10.2476 16.428 8.28976C16.1731 5.61412 13.889 4.71692 11.0056 4.46141L11.005 0.750082H8.77096L8.77034 4.36381C8.18254 4.36381 7.58334 4.37549 6.98685 4.38759L6.98637 0.750575L4.75431 0.750364L4.7539 4.46078C4.27016 4.47077 3.79511 4.48027 3.33125 4.48027V4.46929L0.249756 4.46802L0.250173 6.88041C0.250173 6.88041 1.89999 6.84903 1.87281 6.8795C2.77737 6.88013 3.07273 7.41142 3.15768 7.87001L3.15837 12.098V18.0369C3.11854 18.3247 2.95095 18.7846 2.31845 18.7854C2.34723 18.811 0.693316 18.7851 0.693316 18.7851L0.250173 21.4827H3.15698C3.69863 21.4834 4.23081 21.4919 4.75292 21.4961L4.75487 25.2494L6.98637 25.2501L6.98574 21.5361C7.59968 21.5487 8.19227 21.5542 8.7711 21.5535L8.77048 25.2501H11.0045L11.0057 21.503C14.7609 21.2849 17.3899 20.3281 17.7168 16.7612C17.9802 13.8895 16.6439 12.6077 14.5119 12.0902ZM7.04024 7.04325C8.30022 7.04325 12.2629 6.63743 12.2634 9.29956C12.2629 11.8518 8.30148 11.5536 7.04024 11.5536V7.04325ZM7.03926 18.8037L7.04024 13.8306C8.55408 13.8302 13.3023 13.39 13.3029 16.316C13.3035 19.1221 8.55408 18.8026 7.03926 18.8037Z',
        fill: n,
      }),
    }),
  TA = ({ width: e, height: t, fill: n = Se.colors.legacy.textPrimary }) => {
    const r = e || t || 17;
    return A.jsx('svg', {
      width: r,
      height: r,
      viewBox: '0 0 24 24',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: A.jsx('path', {
        fillRule: 'evenodd',
        clipRule: 'evenodd',
        d: 'M9.51948 13.9003L17.4173 6.26045C17.7763 5.91318 18.3546 5.91318 18.7136 6.26045L19.7308 7.24437C20.0897 7.59164 20.0897 8.15113 19.7308 8.4791L10.1776 17.7395C9.81863 18.0868 9.24026 18.0868 8.88127 17.7395L4.25428 13.2637C3.91524 12.9357 3.91524 12.3762 4.25428 12.0289L5.29137 11.045C5.63041 10.6977 6.20879 10.6977 6.56778 11.045L9.51948 13.9003Z',
        fill: n,
      }),
    });
  },
  Xb = ({ width: e = 16, height: t = 16, fill: n = Se.colors.legacy.textPrimary }) =>
    A.jsx('svg', {
      width: e,
      height: t,
      viewBox: '0 0 16 16',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: A.jsx('path', {
        d: 'M3.69466 12.3154C3.97135 12.5921 4.4362 12.5811 4.70182 12.321L8 9.02279L11.2926 12.321C11.5638 12.5921 12.0286 12.5921 12.2998 12.3154C12.571 12.0387 12.5765 11.5794 12.3053 11.3083L9.0127 8.01009L12.3053 4.71745C12.5765 4.44629 12.5765 3.98698 12.2998 3.71029C12.0231 3.43913 11.5638 3.43359 11.2926 3.70475L8 7.00293L4.70182 3.70475C4.4362 3.44466 3.96582 3.43359 3.69466 3.71029C3.4235 3.98698 3.42904 4.45182 3.68913 4.71191L6.9873 8.01009L3.68913 11.3138C3.42904 11.5739 3.41797 12.0443 3.69466 12.3154Z',
        fill: n,
      }),
    }),
  kA = ({ width: e, height: t, fill: n = Se.colors.legacy.bgRow }) => {
    const r = e || t || 62;
    return A.jsx('svg', {
      width: r,
      height: r,
      viewBox: '0 0 24 24',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: A.jsx('path', {
        d: 'M5.70147 4.0003C5.58476 4.00441 5.47074 4.03658 5.36909 4.0941C5.26743 4.15162 5.18113 4.23278 5.11747 4.33074C5.05382 4.42869 5.01469 4.54054 5.0034 4.65682C4.99212 4.7731 5.009 4.89039 5.05262 4.99876L7.56284 11.2736H13.0007C13.1937 11.2736 13.3788 11.3503 13.5152 11.4868C13.6517 11.6233 13.7283 11.8084 13.7283 12.0015C13.7283 12.1945 13.6517 12.3797 13.5152 12.5162C13.3788 12.6527 13.1937 12.7294 13.0007 12.7294H7.56142L5.05262 19.0042C4.99813 19.1414 4.98666 19.2919 5.01974 19.4358C5.05283 19.5797 5.1289 19.71 5.23785 19.8096C5.3468 19.9092 5.48346 19.9733 5.62968 19.9933C5.77589 20.0133 5.92474 19.9883 6.05642 19.9217L20.5938 12.6541C20.7157 12.5941 20.8184 12.5012 20.8902 12.3859C20.9619 12.2705 21 12.1374 21 12.0015C21 11.8656 20.9619 11.7324 20.8902 11.6171C20.8184 11.5017 20.7157 11.4088 20.5938 11.3489L6.05642 4.08126C5.94689 4.0246 5.82474 3.99674 5.70147 4.0003V4.0003Z',
        fill: n,
      }),
    });
  },
  Ioe = ({ width: e, height: t, fill: n = 'none' }) => {
    const r = e || t || 32;
    return A.jsxs('svg', {
      width: r,
      height: r,
      viewBox: '0 0 24 24',
      xmlns: 'http://www.w3.org/2000/svg',
      children: [
        A.jsx('path', {
          d: 'M16.1121 20L19.7726 16.3439C19.9182 16.1983 20 16.0009 20 15.795C20 15.5892 19.9182 15.3917 19.7726 15.2461L16.1121 11.59L15.0129 12.6879L17.3461 15.0182H6.74062V16.5718H17.3461L15.0129 18.9021L16.1121 20Z',
          fill: n,
        }),
        A.jsx('path', {
          d: 'M7.88794 4L4.22745 7.65606C4.08181 7.8017 4 7.99914 4 8.20498C4 8.41083 4.08181 8.60826 4.22745 8.75391L7.88794 12.41L8.98712 11.3121L6.65395 8.98177H17.2594V7.4282H6.65395L8.98712 5.09785L7.88794 4Z',
          fill: n,
        }),
      ],
    });
  },
  CA = ({ width: e, height: t, fill: n = Se.colors.legacy.textSecondary }) => {
    const r = e || t || 16;
    return A.jsx('svg', {
      width: r,
      height: r,
      viewBox: '0 0 24 24',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: A.jsx('path', {
        d: 'M11.0737 19.4932L4.89026 13.7049L6.76695 11.9256L10.6888 15.6193V3.75H13.3354V15.6193L17.2572 11.9256L19.1339 13.7049L12.9504 19.4932L12.0121 20.3265L11.0737 19.4932Z',
        fill: n,
      }),
    });
  },
  MA = ({ width: e = 20, fill: t = Se.colors.legacy.accentWarning }) => {
    const n = e;
    return A.jsx('svg', {
      width: n,
      height: n,
      viewBox: '0 0 24 24',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: A.jsx('path', {
        d: 'M13.0831 4.76662L14.3 8.46686C14.4444 8.93706 14.8776 9.24371 15.3726 9.24371H19.2917C20.3849 9.24371 20.8387 10.6339 19.9518 11.2676L16.7752 13.5777C16.3833 13.8639 16.2183 14.375 16.3627 14.8247L17.5797 18.525C17.9097 19.5676 16.734 20.4262 15.847 19.772L12.6705 17.4824C12.2786 17.1962 11.7423 17.1962 11.3504 17.4824L8.15327 19.772C7.26632 20.4058 6.06997 19.5471 6.42063 18.525L7.6376 14.8247C7.78199 14.3545 7.61698 13.8639 7.22507 13.5777L4.04856 11.288C3.16161 10.6543 3.61539 9.26415 4.70861 9.26415H8.62769C9.12273 9.26415 9.55589 8.9575 9.70028 8.48731L10.9173 4.76662C11.2679 3.74446 12.7324 3.74446 13.0831 4.76662Z',
        fill: t,
      }),
    });
  },
  PA = ({ width: e, height: t, fill: n = Se.colors.legacy.bgRow }) => {
    const r = e || t || 16;
    return A.jsx('svg', {
      width: r,
      height: r,
      viewBox: '0 0 24 24',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: A.jsx('path', {
        d: 'M10.7984 3.36833C10.7984 3.36833 8.52118 5.53552 6.92542 7.13129C3.88627 10.1704 4.00056 13.0106 4.00056 14.0688C4.00056 15.635 4.91907 17.5059 6.32436 18.9111C7.53917 20.126 8.90213 20.9894 11.6407 20.9894C14.3794 20.9894 15.8524 20.0371 16.8682 19.0339C18.2143 17.709 19.3317 16.0159 19.3317 13.5567C19.3317 10.9196 18.4428 9.41276 17.7995 8.82017C17.4354 8.48578 16.936 8.21488 16.4661 8.63393C15.9963 9.05297 15.6196 9.39583 15.463 9.53128C15.3063 9.66673 15.0651 9.5863 15.137 9.27308C15.209 8.95985 15.4291 8.8625 15.4291 8.06673C15.4291 7.27097 14.9635 6.24663 14.2016 5.31965L12.6651 3.46145C12.191 2.88579 11.3233 2.84347 10.79 3.3641L10.7984 3.36833Z',
        fill: n,
      }),
    });
  },
  em = ({ width: e = 22, fill: t = 'white' }) =>
    A.jsx('svg', {
      width: e,
      height: e,
      viewBox: '0 0 16 16',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: A.jsx('path', {
        d: 'M7.98768 15C11.8606 15 15 11.8662 15 8C15 4.13376 11.8606 1 7.98768 1C4.31352 1 1.2996 3.82128 1 7.41144H10.2686V8.58856H1C1.2996 12.1787 4.31352 15 7.98768 15Z',
        fill: t,
      }),
    }),
  tm = ({ width: e = 22, fill: t = 'white' }) =>
    A.jsx('svg', {
      width: e,
      height: e,
      viewBox: '0 0 14 14',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: A.jsx('path', {
        'fill-rule': 'evenodd',
        'clip-rule': 'evenodd',
        d: 'M12.8019 10.8873L7.54184 13.8568C7.37489 13.9513 7.18743 14 7 14C6.81257 14 6.62511 13.9513 6.45816 13.8568L1.19808 10.8873C0.864194 10.6983 0.65625 10.3461 0.65625 9.96809V4.02905C0.65625 3.65106 0.864194 3.3017 1.19808 3.1127L6.45816 0.143178C6.62511 0.0486806 6.81257 0 7 0C7.18743 0 7.37489 0.0486806 7.54478 0.143178L12.8019 3.10984C13.1358 3.29883 13.3438 3.65106 13.3438 4.02905V9.96809C13.3438 10.3489 13.1387 10.6983 12.8019 10.8873ZM7 0.867663C7.03513 0.867663 7.06738 0.876251 7.09958 0.893436L12.3597 3.86296C12.4212 3.89732 12.4593 3.96032 12.4593 4.02905V9.96809C12.4593 10.0368 12.4212 10.0998 12.3597 10.1342L11.5587 10.5868L9.45113 4.9368C9.41306 4.83373 9.26663 4.83373 9.22857 4.9368L8.53443 6.79526C8.51391 6.84684 8.51391 6.90411 8.53443 6.95565L10.1795 11.3662L9.63248 11.6753L8.2861 8.06388C8.24799 7.9608 8.10156 7.9608 8.0635 8.06388L7.36936 9.92233C7.34889 9.97387 7.34889 10.0311 7.36936 10.0827L8.25329 12.4546L7.09958 13.1066C7.07031 13.1237 7.03513 13.1323 7 13.1323C6.96487 13.1323 6.93262 13.1237 6.90042 13.1066L5.75819 12.4614L9.00287 3.76272C9.03214 3.6854 8.97361 3.60522 8.89157 3.60522H7.55899C7.45942 3.60522 7.36859 3.66536 7.33639 3.75699L4.51511 11.3174L4.00718 10.9045L3.83211 11.3734L6.67195 3.75986C6.69829 3.68541 6.64264 3.60522 6.55772 3.60522H5.22514C5.12557 3.60522 5.03474 3.66536 5.00254 3.75699L2.45214 10.594L1.64325 10.1371C1.58175 10.1027 1.54367 10.0397 1.54367 9.97097V4.02905C1.54367 3.96032 1.58175 3.89732 1.64325 3.86296L6.90336 0.893436C6.93263 0.876251 6.9678 0.867663 7 0.867663Z',
        fill: t,
      }),
    }),
  nm = ({ width: e = 16, fill: t = 'white' }) =>
    A.jsx('svg', {
      width: e,
      height: e,
      viewBox: '0 0 16 16',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: A.jsx('path', {
        d: 'M13.333 8.00031C13.333 6.89574 12.4376 6.00031 11.333 6.00031C10.7822 6.00039 10.2598 6.22726 9.88477 6.6214L9.7334 6.80011L8.83301 7.99933L9.7334 9.19952C10.111 9.70305 10.7036 10.0002 11.333 10.0003C12.4375 10.0003 13.3328 9.10472 13.333 8.00031ZM2.66699 8.00031C2.66717 9.10473 3.56253 10.0003 4.66699 10.0003C5.29639 10.0002 5.88896 9.70305 6.2666 9.19952L7.16602 7.99933L6.2666 6.80011C5.88896 6.29659 5.29639 6.00041 4.66699 6.00031C3.56242 6.00031 2.66699 6.89574 2.66699 8.00031ZM14.667 8.00031C14.6668 9.8411 13.1738 11.3333 11.333 11.3333C10.2841 11.3332 9.29645 10.8393 8.66699 10.0003L8 9.11066L7.33301 10.0003C6.70355 10.8393 5.71591 11.3332 4.66699 11.3333C2.82615 11.3333 1.33318 9.8411 1.33301 8.00031C1.33301 6.15936 2.82604 4.66632 4.66699 4.66632C5.71606 4.66642 6.70356 5.16104 7.33301 6.00031L8 6.88898L8.66699 6.00031L8.78906 5.84698C9.42008 5.10115 10.3495 4.66642 11.333 4.66632C13.174 4.66632 14.667 6.15936 14.667 8.00031Z',
        fill: t,
      }),
    }),
  rm = ({ width: e, fill: t = 'white' }) =>
    A.jsx('svg', {
      width: e,
      height: e,
      viewBox: '0 0 16 16',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: A.jsx('path', {
        d: 'M11.2833 6.8302C11.8536 7.5462 12.1946 8.45172 12.1946 9.43671C12.1946 10.4217 11.8432 11.3549 11.258 12.0749L11.2073 12.1371L11.194 12.0582C11.1825 11.9913 11.1693 11.9234 11.1537 11.8554C10.8605 10.5674 9.90549 9.46322 8.33352 8.56864C7.27189 7.96613 6.6642 7.24148 6.50466 6.4172C6.40156 5.8844 6.47816 5.34926 6.62618 4.89072C6.77423 4.4328 6.99426 4.0486 7.18147 3.81761L7.79321 3.06994C7.90036 2.9386 8.10139 2.9386 8.2085 3.06994L11.2839 6.8302H11.2833ZM12.2505 6.08309L8.15148 1.07171C8.07317 0.976095 7.92683 0.976095 7.84852 1.07171L3.75011 6.08309L3.73687 6.09983C2.98285 7.03586 2.53125 8.22535 2.53125 9.52024C2.53125 12.5357 4.97992 14.9803 8 14.9803C11.0201 14.9803 13.4688 12.5357 13.4688 9.52024C13.4688 8.22535 13.0171 7.03586 12.2631 6.10038L12.2499 6.08368L12.2505 6.08309ZM4.73108 6.81408L5.09743 6.36535L5.10837 6.4483C5.11701 6.51396 5.12795 6.57962 5.14063 6.64586C5.37795 7.89066 6.22528 8.92808 7.64172 9.73163C8.87325 10.4326 9.59038 11.2385 9.79659 12.1221C9.883 12.4908 9.89798 12.8537 9.86054 13.1711L9.85824 13.1906L9.84038 13.1993C9.28454 13.4706 8.65953 13.6232 7.99942 13.6232C5.68324 13.6232 3.80541 11.7489 3.80541 9.43613C3.80541 8.44308 4.1516 7.53122 4.72992 6.81292L4.73108 6.81408Z',
        fill: t,
      }),
    }),
  vh = {
    icon: {
      badge: {
        x: { bgColor: Se.colors.legacy.accentAlert, shape: 'circle', src: Xb },
        send: { bgColor: Se.colors.legacy.accentPrimary, shape: 'circle', src: kA },
        receive: { bgColor: Se.colors.legacy.accentPrimary, shape: 'circle', src: CA },
        star: { bgColor: Se.colors.legacy.accentWarning, shape: 'circle', src: MA },
        burn: { bgColor: Se.colors.legacy.accentAlert, shape: 'circle', src: PA },
        check: { bgColor: Se.colors.legacy.accentSuccess, shape: 'circle', src: TA },
      },
      image: {
        x: {
          bgColor: Zr(Se.colors.legacy.accentAlert, 0.1),
          fgColor: Se.colors.legacy.accentAlert,
          shape: 'circle',
          src: Xb,
        },
        'x-bold': {
          bgColor: Se.colors.legacy.accentAlert,
          fgColor: Zr(Se.colors.legacy.black, 0.75),
          shape: 'circle',
          src: Xb,
        },
        send: {
          bgColor: Zr(Se.colors.legacy.accentPrimary, 0.1),
          fgColor: Se.colors.legacy.accentPrimary,
          shape: 'circle',
          src: kA,
        },
        receive: {
          bgColor: Zr(Se.colors.legacy.accentPrimary, 0.1),
          fgColor: Se.colors.legacy.accentPrimary,
          shape: 'circle',
          src: CA,
        },
        swap: {
          bgColor: Zr(Se.colors.legacy.accentSuccess, 0.1),
          fgColor: Se.colors.legacy.accentSuccess,
          shape: 'circle',
          src: Ioe,
        },
        star: {
          bgColor: Zr(Se.colors.legacy.accentWarning, 0.1),
          fgColor: Se.colors.legacy.accentWarning,
          shape: 'circle',
          src: MA,
        },
        burn: {
          bgColor: Zr(Se.colors.legacy.accentAlert, 0.1),
          fgColor: Se.colors.legacy.accentAlert,
          shape: 'circle',
          src: PA,
        },
        check: {
          bgColor: Zr(Se.colors.legacy.accentSuccess, 0.1),
          fgColor: Se.colors.legacy.accentSuccess,
          shape: 'circle',
          src: TA,
        },
      },
    },
    network: {
      badge: {
        solana: { src: SA, shape: 'square' },
        ethereum: { src: AA, shape: 'square' },
        polygon: { src: IA, shape: 'square' },
        monad: { src: EA, shape: 'square' },
        bitcoin: { src: Jb, shape: 'square' },
        base: { src: em, shape: 'square' },
        arbitrum: { src: tm, shape: 'square' },
        sui: { src: rm, shape: 'square' },
        hypercore: { src: nm, shape: 'square' },
      },
      image: {
        solana: {
          src: SA,
          shape: 'square',
          fgColor: Se.colors.legacy.black,
          bgColor: Se.colors.legacy.white,
        },
        ethereum: {
          src: AA,
          shape: 'square',
          fgColor: Se.colors.legacy.black,
          bgColor: Se.colors.legacy.white,
        },
        polygon: {
          src: IA,
          shape: 'square',
          fgColor: Se.colors.legacy.black,
          bgColor: Se.colors.legacy.white,
        },
        monad: {
          src: EA,
          shape: 'square',
          fgColor: Se.colors.legacy.black,
          bgColor: Se.colors.legacy.white,
        },
        bitcoin: {
          src: Jb,
          shape: 'square',
          fgColor: Se.colors.legacy.black,
          bgColor: Se.colors.legacy.white,
        },
        base: {
          src: em,
          shape: 'square',
          fgColor: Se.colors.legacy.black,
          bgColor: Se.colors.legacy.white,
        },
        arbitrum: {
          src: tm,
          shape: 'square',
          fgColor: Se.colors.legacy.black,
          bgColor: Se.colors.legacy.white,
        },
        sui: {
          src: rm,
          shape: 'square',
          fgColor: Se.colors.legacy.black,
          bgColor: Se.colors.legacy.white,
        },
        hypercore: {
          src: nm,
          shape: 'square',
          fgColor: Se.colors.legacy.black,
          bgColor: Se.colors.legacy.white,
        },
      },
    },
    fungible: {
      image: {
        sol: { src: voe, shape: 'circle', fullSize: !0 },
        eth: { src: Soe, shape: 'circle' },
        matic: { src: Aoe, shape: 'circle' },
        btc: { src: Jb, shape: 'circle' },
        base: { src: em, shape: 'circle' },
        arbitrum: { src: tm, shape: 'circle' },
        sui: { src: rm, shape: 'circle' },
        hypercore: { src: nm, shape: 'circle' },
      },
    },
  },
  Eoe = ['collectible', 'dapp', 'network'],
  Tw = G.memo((e) => {
    if ('tokenSell' in e) {
      const a = typeof e.tokenSell == 'string' ? vh.fungible.image[e.tokenSell] : e.tokenSell,
        c = typeof e.tokenBuy == 'string' ? vh.fungible.image[e.tokenBuy] : e.tokenBuy,
        { image: s, tokenBuy: l, tokenSell: u, onClick: d, ...f } = e;
      return A.jsx(woe, { bgToken: a, fgToken: c, onClick: d, ...f });
    }
    if ('tokenType' in e) return A.jsx(Toe, { ...e });
    let t, n;
    if ('preset' in e.image) {
      const a = e.image.type,
        c = e.image.preset;
      t = vh[a].image[c];
    } else {
      const a = Eoe.includes(e.image.type) ? 'square' : 'circle';
      t = { ...e.image, shape: a };
    }
    if ('badge' in e && e.badge)
      if ('preset' in e.badge) {
        const a = e.badge.type,
          c = e.badge.preset;
        n = vh[a].badge[c];
      } else n = { ...e.badge, shape: 'square' };
    const { image: r, badge: i, ...o } = e;
    return A.jsx(moe, { image: t, badge: n, ...o });
  }),
  Toe = G.memo(({ image: e, tokenType: t, chainMeta: n, ...r }) => {
    const i = j5(),
      o = q.getChainID(n.id),
      a = koe(i, t, o) ? o : void 0;
    return A.jsx(Tw, { image: e, badge: a && { type: 'network', preset: a }, ...r });
  }),
  koe = (e, t, n) => (e ? !1 : fc.get(n).alwaysShowNetworkBadge ? !0 : !gi(t)),
  Coe = 74,
  Moe = (e) => {
    if (!e) return Se.colors.legacy.textTertiary;
    if (e > 0) return Se.colors.legacy.accentSuccess;
    if (e < 0) return Se.colors.legacy.accentAlert;
  },
  Poe = Ue.memo((e) => {
    const {
        tokenAddress: t,
        walletAddress: n,
        balance: r,
        chainMetadata: i,
        currencyValue: o,
        currencyChange: a,
        isLoadingPrices: c,
        logoUri: s,
        name: l,
        onClick: u,
        onMouseEnter: d,
        showCurrencyValues: f = !0,
        hideEmptyCurrency: p = !1,
        showBalance: y = !0,
        symbol: b,
        type: m,
        tooltip: w,
        spamStatus: _,
        visibilityOverrideValue: S,
      } = e,
      E = t ? ep(t) : void 0,
      O = b ?? E ?? '',
      N = o !== void 0 ? Qh(o) : p ? '' : '–',
      F = a !== void 0 ? Qh(a, { includePlusPrefix: !0 }) : p ? '' : '-',
      D = y ? `${ene(r)} ${O}` : O,
      k = `${b ?? (t && ep(t))}`;
    let K = `fungible-token-row-${q.getChainName(i.id).toLowerCase()}-${k}`;
    return (
      n && ym(i.id, n) && (K += `-${br(i.id, n)}`),
      cte(S, { spamStatus: _ }),
      Mn.PossibleSpam,
      A.jsxs('div', {
        className: Mr.container,
        'data-testid': K,
        onMouseEnter: d,
        onClick: u,
        role: 'button',
        children: [
          A.jsx(Tw, {
            image: { type: 'fungible', src: s, fallback: b || t },
            tokenType: m,
            chainMeta: i,
          }),
          A.jsxs('div', {
            className: Mr.tokenDetailContainer,
            children: [
              A.jsxs('div', {
                className: Mr.styledRowTop,
                children: [
                  A.jsx(Lt, {
                    className: Mr.textLeft,
                    font: 'body',
                    style: Mr.textLeftStyles,
                    children: l,
                  }),
                  f
                    ? c
                      ? A.jsx(cc, { font: 'caption', width: 75, height: 8, borderRadius: 8 })
                      : A.jsx(Lt, {
                          font: 'caption',
                          className: Mr.formattedCurrencyValueText,
                          children: N,
                        })
                    : null,
                ],
              }),
              A.jsxs('div', {
                className: Mr.styledRowBottom,
                children: [
                  A.jsx(Lt, {
                    font: 'caption',
                    className: Mr.textLeft,
                    style: { ...Mr.textLeftStyles, color: Se.colors.legacy.textSecondary },
                    children: D,
                  }),
                  f
                    ? c
                      ? A.jsx(cc, { font: 'caption', width: 35, height: 8, borderRadius: 8 })
                      : A.jsx(Lt, {
                          font: 'caption',
                          className: Mr.formattedCurrencyChangeText,
                          style: { color: Moe(a) },
                          children: F,
                        })
                    : null,
                ],
              }),
            ],
          }),
        ],
      })
    );
  }),
  OA = { display: 'flex', flexDirection: 'row', justifyContent: 'space-between', gap: 16 },
  Mr = {
    container: ft({
      backgroundColor: { base: 'bgRow', hover: 'bgButton' },
      cursor: 'pointer',
      borderRadius: 16,
      alignItems: 'center',
      justifyContent: 'center',
      display: 'flex',
      flexDirection: 'row',
      gap: 12,
      padding: 'base',
    }),
    tokenDetailContainer: ft({
      flex: 1,
      display: 'flex',
      flexDirection: 'column',
      justifyContent: 'space-between',
      overflow: 'hidden',
    }),
    styledRow: ft({
      display: 'flex',
      flexDirection: 'row',
      justifyContent: 'space-between',
      gap: 16,
    }),
    styledRowTop: ft({ ...OA, marginBottom: 2 }),
    styledRowBottom: ft({ ...OA, marginTop: 2 }),
    textLeft: ft({
      textAlign: 'left',
      overflow: 'hidden',
      wordBreak: 'break-all',
      whiteSpace: 'nowrap',
    }),
    textLeftStyles: { WebkitLineClamp: 1, WebkitBoxOrient: 'vertical', textOverflow: 'ellipsis' },
    formattedCurrencyValueText: ft({ textAlign: 'right', fontWeight: 'medium' }),
    formattedCurrencyChangeText: ft({ textAlign: 'right' }),
  },
  Ooe = Ue.memo(({ visibilityOverrides: e, fungibles: t, isMainnet: n, onMouseEnter: r }) => {
    const { t: i } = ia(),
      o = G.useRef(document.getElementById('home-tab'));
    G.useEffect(() => {
      const s = document.getElementById('home-tab');
      s && (o.current = s);
    }, []);
    const a = G.useCallback(
        ({
          networkID: s,
          chainName: l,
          fungibleKey: u,
          name: d,
          symbol: f,
          tokenAddress: p,
          type: y,
          walletAddress: b,
          spamStatus: m,
          webTokenPageURL: w,
        }) => {
          dn.capture('assetDetailClick', {
            data: {
              address: p,
              chain: l,
              chainId: q.getChainID(s),
              isNativeOfType: l,
              networkId: s,
              type: 'fungible',
              spamStatus: m,
              name: d,
            },
          }),
            w && window.open(w, '_blank');
        },
        []
      ),
      c = G.useCallback(
        ({ key: s, index: l, style: u }) => {
          const f = Math.min(l + 1, t.length),
            p = [];
          for (let y = l; y < f; y++) {
            const b = t[y],
              m = b.type,
              { chain: w, name: _, symbol: S, key: E, tokenAddress: O, walletAddress: N } = b.data,
              F = _ ?? i('assetDetailUnknownToken'),
              D = ine.getUrlFromFungible({ caip19: lw(b), isAnalyticsOptedOut: !0 });
            p.push(
              G.createElement(Poe, {
                ...Iie(b, e),
                key: `${E}-${l}`,
                onClick: () =>
                  a({
                    networkID: w.id,
                    chainName: w.name,
                    fungibleKey: E,
                    name: F,
                    symbol: S,
                    tokenAddress: O,
                    type: m,
                    walletAddress: N,
                    spamStatus: b.data.spamStatus,
                    webTokenPageURL: D,
                  }),
                onMouseEnter: r,
                showBalance: !0,
                showCurrencyValues: n,
              })
            );
          }
          return A.jsx('div', { style: u, children: p }, s);
        },
        [t, n, a, r, i, e]
      );
    return A.jsx(H3, {
      scrollElement: o.current ?? void 0,
      children: ({ height: s = 0, isScrolling: l, registerChild: u, scrollTop: d }) =>
        A.jsx(q3, {
          disableHeight: !0,
          style: { width: '100' },
          children: ({ width: f }) =>
            A.jsx('div', {
              ref: u,
              children: A.jsx(G3, {
                autoHeight: !0,
                width: f,
                height: s,
                scrollTop: d,
                isScrolling: l,
                rowCount: t.length,
                rowHeight: Coe + 10,
                rowRenderer: c,
                className: ft({ paddingX: 'screen' }),
              }),
            }),
        }),
    });
  }),
  Doe = new one(dn);
function Roe({ actions: e, maxButtons: t, uiContextName: n, disabled: r = !1 }) {
  const i = G.useCallback(
    (o, a) => {
      Doe.ctaBarTrackPrimaryButtonsClick({
        uiContext: { name: n },
        position: a,
        type: o.type,
        typeSpecificMetadata: o.typeSpecificMetadata,
        maxButtons: t,
        primaryActions: e.primary,
        moreActions: e.more,
      });
    },
    [t, e.more, e.primary, n]
  );
  return A.jsx(Dt, {
    gap: 8,
    direction: 'row',
    width: '100%',
    children: e.primary.map((o) =>
      A.jsx(
        x3,
        {
          label: o.singleWordAltText ?? o.text,
          disabled: r,
          icon: ane(o.type),
          onClick: () => {
            i(o, 'primary'), o.onClick(o.type);
          },
        },
        o.type
      )
    ),
  });
}
const DA = 20,
  RA = 100,
  xoe = 5,
  Boe = () => {
    const e = G.useRef(null),
      [t, n] = G.useState({ fontSize: RA, fontSizePrev: DA, fontSizeMax: RA, fontSizeMin: DA }),
      { fontSize: r, fontSizeMax: i, fontSizeMin: o, fontSizePrev: a } = t;
    return (
      G.useEffect(() => {
        const c = Math.abs(r - a) <= xoe,
          s =
            e.current !== null &&
            (e.current.scrollHeight > e.current.offsetHeight ||
              e.current.scrollWidth > e.current.offsetWidth),
          l = r > a;
        if (c) {
          if (s) {
            const p = a < r ? a : r - (a - r);
            n({ fontSize: p, fontSizeMax: i, fontSizeMin: o, fontSizePrev: a });
          }
          return;
        }
        let u,
          d = i,
          f = o;
        s
          ? ((u = l ? a - r : o - r), (d = Math.min(i, r)))
          : ((u = l ? i - r : a - r), (f = Math.max(o, r))),
          n({ fontSize: r + u / 2, fontSizeMax: d, fontSizeMin: f, fontSizePrev: r });
      }, [r, i, o, a, e]),
      [`${r}%`, e]
    );
  },
  joe = Ue.memo(({ children: e, maxFontSize: t, fontWeight: n = 500 }) => {
    const [r, i] = Boe();
    return A.jsx('div', {
      className: ft({
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        width: '100%',
      }),
      style: { fontSize: t },
      ref: i,
      children: A.jsx(Lt, {
        style: { fontSize: r, fontWeight: n, lineHeight: '120%' },
        children: e,
      }),
    });
  });
var Noe = '_1kggvq10 _16y4lb75b _16y4lb73p _16y4lb76n _16y4lb723',
  Uoe =
    '_1kggvq11 _16y4lb7tk _16y4lb7uk _16y4lb7wk _16y4lb7vk _16y4lb75b _16y4lb73p _16y4lb76x _16y4lb723 _16y4lb71kj _16y4lb71me _16y4lb71xp',
  Loe = '_1kggvq13 _1kggvq12 _16y4lb7437 _16y4lb71 _16y4lb78f',
  zoe = '_1kggvq15 _1kggvq14 _16y4lb71me _16y4lb75h',
  xA =
    '_1kggvq16 _16y4lb71kj _16y4lb71nq _16y4lb71me _16y4lb71mr _16y4lb71c8 _16y4lb7kv _16y4lb76x',
  Foe = '_1kggvq17 _16y4lb71b5 _16y4lb71cr _16y4lb71g _16y4lb743m',
  $oe = '_1kggvq18 _16y4lb71kj _16y4lb71nr _16y4lb71me _16y4lb71mr',
  Woe = '_1kggvq19 _16y4lb7bi',
  Voe =
    '_1kggvq1a _16y4lb7td _16y4lb7ud _16y4lb7wd _16y4lb7vd _16y4lb71y _16y4lb73k _16y4lb753 _16y4lb76p',
  Koe = '_1kggvq1b _16y4lb75b _16y4lb773 _16y4lb723 _16y4lb73p';
const Hoe = Ue.memo(
    ({
      hasFungibles: e,
      isErrorTokens: t,
      isLoading: n,
      isHidingAllFungibles: r,
      value: i,
      earnings: o,
      showDollarValues: a,
      shouldShowPartialError: c,
      partialErrorMessage: s,
      ctaActions: l,
    }) => {
      const u = qoe(o),
        d = Goe(i),
        f = Yoe(o),
        p = Zoe(i, o),
        { buttonDisabled: y } = Qoe({ isLoading: n, isEnabled: e || r, isErrorTokens: t });
      return A.jsxs('div', {
        children: [
          c
            ? A.jsx('div', {
                className: Noe,
                children: A.jsxs('div', {
                  className: Uoe,
                  children: [
                    A.jsx(B3, { size: 18 }),
                    A.jsx(Lt, { font: 'caption', className: Loe, children: s }),
                  ],
                }),
              })
            : null,
          A.jsx('div', {
            className: zoe,
            children: a
              ? n
                ? A.jsxs('div', {
                    className: xA,
                    children: [
                      A.jsx(cc, { font: 'caption', width: 184 }),
                      A.jsx(cc, { font: 'caption', width: 112 }),
                    ],
                  })
                : e || r
                  ? A.jsxs(A.Fragment, {
                      children: [
                        A.jsx(joe, { maxFontSize: 38, fontWeight: 600, children: d }),
                        A.jsxs('div', {
                          className: $oe,
                          children: [
                            A.jsx(Lt, {
                              className: Woe,
                              font: 'title1',
                              style: { color: u },
                              children: f,
                            }),
                            A.jsx(Lt, {
                              className: Voe,
                              font: 'title1',
                              style: { color: u, backgroundColor: Zr(u, 0.1) },
                              children: p,
                            }),
                          ],
                        }),
                      ],
                    })
                  : null
              : A.jsx('div', {
                  className: xA,
                  children: A.jsx(Lt, { className: Foe, children: '–' }),
                }),
          }),
          A.jsx('div', {
            className: Koe,
            children: A.jsx(Roe, { disabled: y, actions: l, uiContextName: 'home', maxButtons: 4 }),
          }),
        ],
      });
    }
  ),
  qoe = (e) =>
    e === void 0 || e === 0
      ? Se.colors.legacy.textSecondary
      : e > 0
        ? Se.colors.legacy.accentSuccess
        : Se.colors.legacy.accentAlert,
  Goe = (e) => (e === void 0 ? '-' : e === 0 ? '$0.00' : Qh(e)),
  Yoe = (e) => (e === void 0 ? '-' : e === 0 ? '+$0.00' : Qh(e, { includePlusPrefix: !0 })),
  Zoe = (e, t) => {
    const n = e === void 0,
      r = t === void 0,
      i = r || t >= 0 ? '+' : '-';
    return n || r ? '-' : `${i}${Math.abs(PJ(e - t, e)).toFixed(2)}%`;
  },
  Qoe = ({ isLoading: e, isEnabled: t, isErrorTokens: n }) => {
    let r = 'primary',
      i = !1;
    switch (!0) {
      case e:
        (r = 'secondary'), (i = !0);
        break;
      case t:
        (r = 'primary'), (i = !1);
        break;
      case n:
        (r = 'secondary'), (i = !0);
    }
    return { buttonTheme: r, buttonDisabled: i };
  },
  Joe = ae({ seconds: 5 }),
  Xoe = ae({ seconds: 10 }),
  eae = () => {
    wie();
    const { data: e } = ms(),
      t = !F5(),
      {
        fungibles: n,
        visibilityOverrides: r,
        portfolio: i,
        isHidingAllFungibles: o,
        isLoadingVisibilityOverrides: a,
        isLoadingTokens: c,
        isLoadingPrices: s,
        isErrorTokens: l,
        refetch: u,
      } = AP({ useTokenQueryOptions: { staleTime: Joe, refetchInterval: Xoe } }),
      d = n.length > 0,
      f = a || c || s,
      p = W0(),
      {
        ctaActions: y,
        shouldShowPartialError: b,
        partialErrorMessage: m,
      } = bie({
        onTappingBuy: () => {
          p.toStack('fiat-ramp');
        },
        onTappingReceive: () => {
          p.toStack('receive');
        },
        onTappingSend: () => {
          p.toStack('send');
        },
        onTappingSwap: () => {},
        account: e,
      }),
      w = G.useMemo(
        () => ({
          primary: y.primary.filter((S) => ['receive', 'send', 'buy'].includes(S.type)),
          more: [],
        }),
        [y]
      ),
      _ = Ur((S) => S.isAnimating);
    return A.jsxs('div', {
      id: 'home-tab',
      className: tae.homeTabStyle,
      children: [
        A.jsx(Hoe, {
          earnings: i.earnings,
          value: i.value,
          hasFungibles: d,
          isErrorTokens: l,
          isLoading: f,
          isHidingAllFungibles: o,
          isReadOnlyAccount: e == null ? void 0 : e.isReadOnly,
          showDollarValues: t,
          shouldShowPartialError: b,
          partialErrorMessage: m,
          ctaActions: w,
        }),
        f || _
          ? A.jsx(Dt, {
              direction: 'column',
              paddingX: 16,
              paddingRight: 16,
              gap: 8,
              children: [1, 2, 3].map((S) => A.jsx(j3, {}, `fungible-token-row-loader-${S}`)),
            })
          : d
            ? A.jsx(Ooe, { visibilityOverrides: r, fungibles: n, isMainnet: t })
            : null,
      ],
    });
  },
  tae = {
    homeTabStyle: ft({ display: 'column', minHeight: 0, size: '100%', flex: 1, overflow: 'auto' }),
  },
  nae = Ue.lazy(() =>
    Rt(
      () => import('./Detail-DYgNoey5.js'),
      __vite__mapDeps([39, 7, 6, 2, 1, 3, 4, 5, 8, 15])
    ).then((e) => ({ default: e.Detail }))
  ),
  rae = Ue.lazy(() =>
    Rt(
      () => import('./DeeperDetail-jCc0xBUN.js'),
      __vite__mapDeps([40, 7, 6, 2, 1, 3, 4, 5, 8, 15])
    ).then((e) => ({ default: e.DeeperDetail }))
  ),
  iae = Qn({
    id: 'balances',
    initialViewId: 'main',
    views: [
      { id: 'main', element: A.jsx(eae, {}) },
      { id: 'detail', element: A.jsx(nae, {}) },
      { id: 'deeper-detail', element: A.jsx(rae, {}) },
    ],
    stacks: [Ine, Hne, Zne, _ne, PP, Q1, Gne, Sne],
  }),
  oae = Ue.lazy(() =>
    Rt(() => import('./Main-_NLdofUY.js'), __vite__mapDeps([41, 7, 6, 2, 1, 3, 4, 5, 8])).then(
      (e) => ({ default: e.Main })
    )
  ),
  aae = Ue.lazy(() =>
    Rt(
      () => import('./Detail-B4_T2DSY.js'),
      __vite__mapDeps([42, 7, 6, 2, 1, 3, 4, 5, 8, 15])
    ).then((e) => ({ default: e.Detail }))
  ),
  sae = Qn({
    id: 'swapper',
    initialViewId: 'main',
    views: [
      {
        id: 'main',
        params: {
          buyFungible: h.string().optional(),
          sellFungible: h.string().optional(),
          sellAmount: h.string().optional(),
        },
        element: A.jsx(oae, {}),
      },
      { id: 'detail', element: A.jsx(aae, {}) },
    ],
    stacks: [Q1],
  }),
  cae = () => A.jsx('div', { children: ' 404 Page not found ' }),
  uae = ({ isActive: e }) =>
    e
      ? A.jsx(N3, { color: 'accentPrimary', size: 24 })
      : A.jsx(U3, { color: 'textSecondary', size: 24 }),
  lae = ({ isActive: e }) =>
    e
      ? A.jsx(Uw, { color: 'accentPrimary', size: 24 })
      : A.jsx(Uw, { color: 'textSecondary', size: 24 }),
  dae = ({ isActive: e }) =>
    e
      ? A.jsx(L3, { color: 'accentPrimary', size: 24 })
      : A.jsx(z3, { color: 'textSecondary', size: 24 }),
  bn = n6({
    css: oQ,
    type: 'tabbed',
    tabs: [
      { id: 'balances', renderTabButton: (e) => A.jsx(uae, { isActive: e }), stack: iae },
      { id: 'swapper', renderTabButton: (e) => A.jsx(lae, { isActive: e }), stack: sae },
      { id: 'activity', renderTabButton: (e) => A.jsx(dae, { isActive: e }), stack: OQ },
    ],
    menuBarElement: A.jsx(EQ, {}),
    errorElement: A.jsx(cae, {}),
  }),
  fae = () => {
    const e = hs(bn);
    return {
      async navigateToOnboarding() {
        await e.toStack('onboarding');
      },
      async navigateToRestoreAccount() {
        await e.toStack('restoreAccount');
      },
    };
  };
Uh.registerNavigator(fae());
const hae = hs(bn),
  pae = async (e) => {
    const t = XZ();
    t !== Gt.Open && (await os(Gt.Open));
    try {
      switch (e.method) {
        case 'user_approveSolConnect':
          return z2(e.id, null);
        case 'user_approveSolSignAndSendTransaction':
        case 'user_approveSolSignAndSendAllTransactions':
        case 'user_approveSolSignAllTransactions':
        case 'user_approveSolSignTransaction':
        case 'user_approveSolSignIn':
        case 'user_approveSolSignMessage':
        case 'user_approveEthSendTransaction':
        case 'user_approveEthSignMessage':
        case 'user_approveSuiSignMessage':
        case 'user_approveSuiSignTransaction': {
          const n = new Promise((r) => {
            NZ((i) => {
              r({ ...i, id: e.id });
            });
          });
          return await hae.toStack('notification', { params: { userApproveRequest: e } }), await n;
        }
        case 'user_confirmIncorrectMode':
        case 'user_confirmDisabledNetwork':
        case 'user_confirmUnsupportedAccount':
        case 'user_confirmEIP712IncorrectChainId':
        case 'user_confirmUnsupportedNetwork':
        case 'user_approveSolPayTransaction':
        case 'user_approveBtcRequestAccounts':
        case 'user_approveBtcSignMessage':
        case 'user_approveBtcSignPSBT':
        case 'user_selectEthWallet':
        case 'user_approveEthRequestAccounts':
        case 'user_approveWalletRequestPermissions':
        default:
          throw new Error('Not implemented');
      }
    } finally {
      await os(t);
    }
  },
  gae = async (e) => {
    throw new Error('not implemented');
  },
  yae = hs(bn),
  BA = hs(bn),
  jA = hs(bn),
  bae = hs(bn),
  mae = (e, t) => {
    if ((os(Gt.Open), e === 'SwapTab')) {
      const n = t == null ? void 0 : t.params,
        r = n == null ? void 0 : n.buyFungible,
        i = n == null ? void 0 : n.sellFungible,
        o = n == null ? void 0 : n.sellAmount;
      bn.setCurrentTab('swapper'),
        yae.to('main', { params: { buyFungible: r, sellFungible: i, sellAmount: o } });
    } else if (e === 'FiatRampStack') {
      const n = t == null ? void 0 : t.params,
        r = n == null ? void 0 : n.sessionId,
        i = n == null ? void 0 : n.caip19;
      if (r && i)
        bn.setCurrentTab('balances'),
          jA.toStack('fiat-ramp'),
          BA.toStack('fiat-ramp-redirect-to-provider'),
          bae.to('fiat-ramp-waiting-on-ramp', { params: { sessionId: r, caip19: i } });
      else {
        const o = n == null ? void 0 : n.buy,
          a = n == null ? void 0 : n.amount,
          c = n == null ? void 0 : n.redirectURL;
        bn.setCurrentTab('balances'),
          jA.toStack('fiat-ramp'),
          o &&
            BA.to('fiat-ramp-fungible-selected', { params: { buy: o, amount: a, redirectURL: c } });
      }
    } else
      e === 'HomePage' &&
        (bn.hasModal && (bn.canPopStack ? bn.popStack() : bn.popView()),
        bn.setCurrentTab('balances'));
  },
  wae = () => {
    throw new Error('This method is unsupported on embedded.');
  },
  _ae = () => {
    throw new Error('This method is unsupported on embedded.');
  },
  vae = async () => {
    const e = zn.getInstance();
    let t, n;
    await new Promise((r, i) => {
      os(Gt.Open),
        (t = e.subscribe(async (o) => {
          o === Jn.SelectedAccount && (await Y1()) && r('User has onboarded');
        })),
        (n = eQ((o) => {
          o === Gt.Closed && i('User closed the wallet');
        }));
    }).finally(() => {
      t == null || t(), n == null || n();
    });
  },
  Sae = () => Promise.resolve(null),
  Aae = () => Promise.resolve(),
  Iae = () => Promise.resolve(),
  Eae = new Error('There is no currently selected account'),
  NA = zn.getInstance(),
  Tae = Xn,
  Qt = async () => {
    const e = await q5(Tae, NA, await R0(NA));
    if (!e) throw Eae;
    return e;
  },
  ha = async () => {
    const e = await Qt(),
      t = WI(e, X.Solana).networkID;
    return q.getSolanaNetworkIDValue(t);
  },
  kae = async (e) => {
    let { transaction: t } = yr.deserializeVersionedTransaction(e);
    t.version === 'legacy' &&
      (t = yr.deserializeWithVersion({ transaction: e, type: 'legacy' }).transaction);
    const n = await ha(),
      r = await OM(t, { connection: fa(eo(n)), calculators: { cost: EM, budget: new H1(hp, hp) } });
    return yr.serialize(r).transaction;
  };
class Cae extends IZ {
  constructor() {
    super(Da);
    Le(this, 'isAutoConfirmSessionActive', () =>
      Promise.resolve({
        sessionStartTime: Date.now() - 1e4,
        sessionMaxDuration: 864e5,
        success: !0,
      })
    );
  }
  async isTabFocused(n) {
    return this.executedChecksAudit.push(Dr.IsTabFocused), Promise.resolve(!0);
  }
  async isFeatureEnabled() {
    return (
      this.executedChecksAudit.push(Dr.IsFeatureFlagEnabled),
      (await Un.getFeatureFlags())['kill-automatic-approval'] !== !0
    );
  }
  async isWalletUnlocked() {
    return (
      this.executedChecksAudit.push(Dr.IsWalletUnlocked),
      (await Xn.checkVaultIntegrity()).isOnboarded
    );
  }
  async isDappWhitelistOverridden() {
    return (
      this.executedChecksAudit.push(Dr.IsDappWhitelistOverridden),
      (await Un.getFeatureFlags())['enable-automatic-approval-for-all-dapps'] === !0
    );
  }
}
const Sy = new Cae(),
  Mae = async (e, t) => {
    const n = await ha();
    if (n === 'localnet') return { status: Xe.UnsupportedNetworkId };
    const r = await Qt(),
      i = await Ln(r, X.Solana);
    return Sy.isSolMessageAutoConfirmable({
      url: e,
      data: t,
      networkID: eo(n),
      account: r,
      userAccountAddress: i,
      accountIdentifier: r.identifier ?? '',
    });
  },
  Pae = async (e, t) => {
    const n = await ha();
    if (n === 'localnet') return { status: Xe.UnsupportedNetworkId };
    const r = await Qt(),
      i = await Ln(r, X.Solana),
      o = i1(Et.language) ?? 'en';
    return Sy.isSolTransactionAutoConfirmable(
      {
        url: e,
        networkID: eo(n),
        data: t,
        account: r,
        userAccountAddress: i,
        accountIdentifier: r.identifier ?? '',
      },
      { locale: o, deviceId: 'test-device-id' }
    );
  },
  Oae = async () => {
    const e = await Qt();
    return Ln(e, X.Solana);
  },
  Dae = async (e, t) => {
    const n = await ha(),
      r = jp.deserializeMessageVersion(rn.decode(j0(e))),
      i = yr.deserializeWithVersion({ transaction: e, type: r });
    let o;
    t != null && t.method && (o = { 'x-phantom-method': t.method }),
      await WM({ connection: fa(eo(n), o), signedTx: i.transaction, opts: t });
  },
  Rae = async (e, t) => {
    const n = await ha(),
      r = fa(eo(n)),
      i = e.map((o) => {
        const a = jp.deserializeMessageVersion(rn.decode(j0(o)));
        return yr.deserializeWithVersion({ transaction: o, type: a }).transaction;
      });
    return await cZ({ connection: r, signedTxs: i, opts: t });
  },
  xae = Xn,
  Bae = async (e) => {
    const t = await Qt();
    Ln(t, X.Solana);
    const n = rn.decode(e).toString('utf-8'),
      r = await xae.sign(t.identifier, { chainType: X.Solana, signingType: 'message', message: n });
    if (r.status !== 'success') throw new Error(`[${r.type}] ${r.message}`);
    return r.signature;
  },
  jae = Xn,
  Nae = zn.getInstance(),
  OO = async (e) => {
    const t = await Qt();
    Ln(t, X.Solana);
    const n = Ln(t, X.Solana),
      r = await ha(),
      i = {
        ownerAddress: n,
        networkID: eo(r),
        data: { signature: '' },
        type: ci.DappInteraction,
        display: { summary: { topLeft: { text: Et.t('transactionsPendingAppInteraction') } } },
      };
    return (async () => {
      const a = [];
      for (let c = 0; c < e.length; c++) {
        const s = e[c],
          l = jp.deserializeMessageVersion(rn.decode(j0(s))),
          u = yr.deserializeWithVersion({ transaction: s, type: l }),
          d = await lZ({
            pendingTransactionInput: i,
            accountIdentifier: t.identifier,
            feePayer: new Ye(n),
            connection: fa(eo(r)),
            accountSigner: jae,
            transaction: u.transaction,
            storage: Nae,
          }),
          f = yr.serialize(d);
        a.push({
          transaction: f.transaction,
          signature: rn.encode(F2(d)[0]),
          version: 'version' in d ? d.version : 'legacy',
        });
      }
      return a;
    })();
  },
  Uae = async (e) => (await OO([e]))[0],
  Lae = async () => {},
  zae = async () => !1,
  Fae = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        addPriorityFee: kae,
        autoConfirmValidateMessage: Mae,
        autoConfirmValidateTransaction: Pae,
        getNetworkId: ha,
        getSelectedAccount: Oae,
        handleSolanaPayTransaction: Lae,
        handleSolanaPayTransfer: zae,
        sendAllTransactions: Rae,
        sendTransaction: Dae,
        signAllTransactions: OO,
        signMessage: Bae,
        signTransaction: Uae,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  $ae = async (e) => {
    const t = parseInt(e.chainId.substring(2), 16);
    return !!N0(t);
  },
  DO = {},
  RO = [zn.getInstance()];
async function Wae() {
  for (const e of RO) {
    const t = await e.get(Jn.DeveloperMode);
    if (t) return t.isDeveloperMode;
  }
  return !1;
}
const xO = async (e) => {
    if (await Wae()) {
      const o = (await DB(RO)).eip155;
      if (!o) throw new Error('No evm developer mode chainId set');
      const a = o.replace('eip155:', '');
      return Gw(a);
    }
    const n = DO[e] ?? um.Mainnet,
      r = q.getEVMNetworkIDValue(n);
    return Gw(r.toString());
  },
  Vae = async (e, t) => {
    const n = await xO(e.origin);
    if (!n) return { status: Xe.UnsupportedNetworkId };
    const r = x0(n);
    if (!q.isEVMNetworkID(r)) return { status: Xe.UnsupportedNetworkId };
    const i = await Qt(),
      o = await Ln(i, X.EVM),
      a = i1(Et.language) ?? 'en';
    return await Sy.isEthMessageAutoConfirmable(
      {
        url: e,
        networkID: r,
        data: t,
        account: i,
        userAccountAddress: o,
        accountIdentifier: i.identifier,
      },
      { locale: a, deviceId: 'test-device-id' }
    );
  },
  Kae = async (e, t) => {
    var s;
    const n = (s = t[0]) == null ? void 0 : s.chainId;
    if (!n) return { status: Xe.UnsupportedNetworkId };
    const r = x0(n);
    if (!q.isEVMNetworkID(r)) return { status: Xe.UnsupportedNetworkId };
    const i = await Qt(),
      o = await Ln(i, X.EVM),
      a = i1(Et.language) ?? 'en';
    return Sy.isEthTransactionAutoConfirmable(
      {
        url: e,
        networkID: r,
        data: t,
        account: i,
        userAccountAddress: o,
        accountIdentifier: i.identifier,
      },
      { locale: a, deviceId: 'test-device-id' }
    );
  },
  Hae = async () => (await Qt()).addresses.some((t) => t.addressType === X.EVM),
  qae = async (e, t) => {
    const n = parseInt(e.replace('0x', ''), 16),
      r = N0(n);
    if (!r) throw new Error(`Unsupported EVM Network ID: ${n}`);
    return BM(r, t, zn.getInstance());
  },
  Gae = async () => {
    const e = await Qt();
    return [Ln(e, X.EVM).toLowerCase()];
  },
  Yae = async (e = !1) => {
    const t = zn.getInstance(),
      n = await R0(t),
      r = await t.get(Jn.DeveloperMode);
    return e
      ? n.enabledNetworkIDs.map(My)
      : (r == null ? void 0 : r.isDeveloperMode) === !0
        ? n.enabledTestnetOnlyNetworkIDs.map(My)
        : n.enabledMainnetOnlyNetworkIDs.map(My);
  },
  Zae = async (e) => {
    const t = Ic.parse(`eip155:${parseInt(e, 16)}`);
    if (!q.isEVMNetworkID(t)) throw new Error(`Invalid EVM NetworkID for chainID: ${e}`);
    const n = q.getRpcProxyUrl(t);
    if (!n) throw new Error(`No RPC URL found for chainID ${e}`);
    return n;
  },
  Qae = async () => {
    const e = await Qt();
    return Ln(e, X.EVM).toLowerCase();
  },
  Jae = () => $2(),
  Xae = zn.getInstance(),
  BO = async (e, t) => {
    const n = await Qt();
    Ln(n, X.EVM);
    const r = Et.t('transactionsAppInteraction'),
      i = Ic.parse(`eip155:${e.chainId ? parseInt(e.chainId, 16) : void 0}`),
      o = V6(e.to ?? '', void 0, void 0, 5),
      a = W2(e.value ?? '', q.getTokenDecimals(i)),
      c = q.getTokenSymbol(i);
    if (e.nonce === void 0) throw new Error('nonce missing on unsigned transaction');
    if (e.maxFeePerGas == null || e.maxPriorityFeePerGas == null) {
      const l = await ST(i, !0),
        u = l == null ? void 0 : l.standard;
      if (u)
        e.maxFeePerGas == null &&
          (e.maxFeePerGas = `0x${u.maxFeePerGas.integerValue(oe.ROUND_CEIL).toString(16)}`),
          e.maxPriorityFeePerGas == null &&
            (e.maxPriorityFeePerGas = `0x${u.maxPriorityFeePerGas.integerValue(oe.ROUND_CEIL).toString(16)}`);
      else throw new Error('Standard transaction speed price information is missing.');
    }
    const s = {
      accountSigner: Xn,
      accountIdentifier: n.identifier,
      networkID: i,
      unsignedTransaction: e,
      callPayload: void 0,
      pendingTransactionInput: {
        ownerAddress: e.from,
        networkID: i,
        data: { nonce: e.nonce, hash: '', unsignedTransaction: Tc.parse({ from: e.from }) },
        type: ci.DappInteraction,
        display: {
          summary: { topLeft: { text: r }, topRight: { text: a ? `- ${a} ${c}` : '' } },
          detail: { uiRecipient: o },
        },
      },
      storage: Xae,
    };
    return t ? await UM({ ...s, signature: t }) : await uY(s);
  },
  ese = BO,
  tse = BO,
  nse = /^[0-9A-Fa-f]+$/gu;
function rse(e) {
  try {
    const t = z4(e);
    if (t.match(nse)) return ise(t);
  } catch {
    return Xw.bufferToHex(Y.from(e, 'utf8'));
  }
  return Xw.bufferToHex(Y.from(e, 'utf8'));
}
const ise = (e) =>
    typeof e != 'string' || e.match(/^-?0x/u)
      ? e
      : e.match(/^-?0X/u)
        ? e.replace('0X', '0x')
        : e.startsWith('-')
          ? e.replace('-', '-0x')
          : `0x${e}`,
  ose = async (e) => {
    const t = rse(e),
      n = await Qt();
    Ln(n, X.EVM);
    const r = await Xn.sign(n.identifier, { chainType: X.EVM, signingType: 'message', message: t });
    if (r.status === 'error') throw new Error(`[${r.type}] ${r.message}`);
    return r.signature;
  },
  ase = async (e) => {
    const t = await Qt();
    Ln(t, X.EVM);
    const n = await Xn.sign(t.identifier, { chainType: X.EVM, signingType: 'typedData', ...e });
    if (n.status === 'error') throw new Error(`[${n.type}] ${n.message}`);
    return n.signature;
  },
  sse = async (e, t) => {
    const n = parseInt(e.substring(2), 16),
      r = N0(n);
    return r ? ((DO[t] = r), !0) : !1;
  },
  cse = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        addChain: $ae,
        autoConfirmValidateMessage: Vae,
        autoConfirmValidateTransaction: Kae,
        doesSupportEth: Hae,
        getAccountNonce: qae,
        getAccounts: Gae,
        getEnabledChains: Yae,
        getNetworkId: xO,
        getRpcURL: Zae,
        getSelectedAccount: Qae,
        getSupportedNetworks: Jae,
        sendTransaction: ese,
        signAndSendTransaction: tse,
        signMessage: ose,
        signTypedData: ase,
        switchChain: sse,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  );
function use(e, t, n, r) {
  if (typeof e.setBigUint64 == 'function') return e.setBigUint64(t, n, r);
  const i = BigInt(32),
    o = BigInt(4294967295),
    a = Number((n >> i) & o),
    c = Number(n & o),
    s = r ? 4 : 0,
    l = r ? 0 : 4;
  e.setUint32(t + s, a, r), e.setUint32(t + l, c, r);
}
const lse = (e, t, n) => (e & t) ^ (~e & n),
  dse = (e, t, n) => (e & t) ^ (e & n) ^ (t & n);
class jO extends EI {
  constructor(t, n, r, i) {
    super(),
      (this.blockLen = t),
      (this.outputLen = n),
      (this.padOffset = r),
      (this.isLE = i),
      (this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.buffer = new Uint8Array(t)),
      (this.view = Oy(this.buffer));
  }
  update(t) {
    Xh(this);
    const { view: n, buffer: r, blockLen: i } = this;
    t = TI(t);
    const o = t.length;
    for (let a = 0; a < o; ) {
      const c = Math.min(i - this.pos, o - a);
      if (c === i) {
        const s = Oy(t);
        for (; i <= o - a; a += i) this.process(s, a);
        continue;
      }
      r.set(t.subarray(a, a + c), this.pos),
        (this.pos += c),
        (a += c),
        this.pos === i && (this.process(n, 0), (this.pos = 0));
    }
    return (this.length += t.length), this.roundClean(), this;
  }
  digestInto(t) {
    Xh(this), V4(t, this), (this.finished = !0);
    const { buffer: n, view: r, blockLen: i, isLE: o } = this;
    let { pos: a } = this;
    (n[a++] = 128),
      this.buffer.subarray(a).fill(0),
      this.padOffset > i - a && (this.process(r, 0), (a = 0));
    for (let d = a; d < i; d++) n[d] = 0;
    use(r, i - 8, BigInt(this.length * 8), o), this.process(r, 0);
    const c = Oy(t),
      s = this.outputLen;
    if (s % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
    const l = s / 4,
      u = this.get();
    if (l > u.length) throw new Error('_sha2: outputLen bigger than state');
    for (let d = 0; d < l; d++) c.setUint32(4 * d, u[d], o);
  }
  digest() {
    const { buffer: t, outputLen: n } = this;
    this.digestInto(t);
    const r = t.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: n, buffer: r, length: i, finished: o, destroyed: a, pos: c } = this;
    return (
      (t.length = i), (t.pos = c), (t.finished = o), (t.destroyed = a), i % n && t.buffer.set(r), t
    );
  }
}
const [fse, hse] = We.split(
    [
      '0x428a2f98d728ae22',
      '0x7137449123ef65cd',
      '0xb5c0fbcfec4d3b2f',
      '0xe9b5dba58189dbbc',
      '0x3956c25bf348b538',
      '0x59f111f1b605d019',
      '0x923f82a4af194f9b',
      '0xab1c5ed5da6d8118',
      '0xd807aa98a3030242',
      '0x12835b0145706fbe',
      '0x243185be4ee4b28c',
      '0x550c7dc3d5ffb4e2',
      '0x72be5d74f27b896f',
      '0x80deb1fe3b1696b1',
      '0x9bdc06a725c71235',
      '0xc19bf174cf692694',
      '0xe49b69c19ef14ad2',
      '0xefbe4786384f25e3',
      '0x0fc19dc68b8cd5b5',
      '0x240ca1cc77ac9c65',
      '0x2de92c6f592b0275',
      '0x4a7484aa6ea6e483',
      '0x5cb0a9dcbd41fbd4',
      '0x76f988da831153b5',
      '0x983e5152ee66dfab',
      '0xa831c66d2db43210',
      '0xb00327c898fb213f',
      '0xbf597fc7beef0ee4',
      '0xc6e00bf33da88fc2',
      '0xd5a79147930aa725',
      '0x06ca6351e003826f',
      '0x142929670a0e6e70',
      '0x27b70a8546d22ffc',
      '0x2e1b21385c26c926',
      '0x4d2c6dfc5ac42aed',
      '0x53380d139d95b3df',
      '0x650a73548baf63de',
      '0x766a0abb3c77b2a8',
      '0x81c2c92e47edaee6',
      '0x92722c851482353b',
      '0xa2bfe8a14cf10364',
      '0xa81a664bbc423001',
      '0xc24b8b70d0f89791',
      '0xc76c51a30654be30',
      '0xd192e819d6ef5218',
      '0xd69906245565a910',
      '0xf40e35855771202a',
      '0x106aa07032bbd1b8',
      '0x19a4c116b8d2d0c8',
      '0x1e376c085141ab53',
      '0x2748774cdf8eeb99',
      '0x34b0bcb5e19b48a8',
      '0x391c0cb3c5c95a63',
      '0x4ed8aa4ae3418acb',
      '0x5b9cca4f7763e373',
      '0x682e6ff3d6b2b8a3',
      '0x748f82ee5defb2fc',
      '0x78a5636f43172f60',
      '0x84c87814a1f0ab72',
      '0x8cc702081a6439ec',
      '0x90befffa23631e28',
      '0xa4506cebde82bde9',
      '0xbef9a3f7b2c67915',
      '0xc67178f2e372532b',
      '0xca273eceea26619c',
      '0xd186b8c721c0c207',
      '0xeada7dd6cde0eb1e',
      '0xf57d4f7fee6ed178',
      '0x06f067aa72176fba',
      '0x0a637dc5a2c898a6',
      '0x113f9804bef90dae',
      '0x1b710b35131c471b',
      '0x28db77f523047d84',
      '0x32caab7b40c72493',
      '0x3c9ebe0a15c9bebc',
      '0x431d67c49c100d4c',
      '0x4cc5d4becb3e42b6',
      '0x597f299cfc657e2a',
      '0x5fcb6fab3ad6faec',
      '0x6c44198c4a475817',
    ].map((e) => BigInt(e))
  ),
  xi = new Uint32Array(80),
  Bi = new Uint32Array(80);
class pse extends jO {
  constructor() {
    super(128, 64, 16, !1),
      (this.Ah = 1779033703),
      (this.Al = -205731576),
      (this.Bh = -1150833019),
      (this.Bl = -2067093701),
      (this.Ch = 1013904242),
      (this.Cl = -23791573),
      (this.Dh = -1521486534),
      (this.Dl = 1595750129),
      (this.Eh = 1359893119),
      (this.El = -1377402159),
      (this.Fh = -1694144372),
      (this.Fl = 725511199),
      (this.Gh = 528734635),
      (this.Gl = -79577749),
      (this.Hh = 1541459225),
      (this.Hl = 327033209);
  }
  get() {
    const {
      Ah: t,
      Al: n,
      Bh: r,
      Bl: i,
      Ch: o,
      Cl: a,
      Dh: c,
      Dl: s,
      Eh: l,
      El: u,
      Fh: d,
      Fl: f,
      Gh: p,
      Gl: y,
      Hh: b,
      Hl: m,
    } = this;
    return [t, n, r, i, o, a, c, s, l, u, d, f, p, y, b, m];
  }
  set(t, n, r, i, o, a, c, s, l, u, d, f, p, y, b, m) {
    (this.Ah = t | 0),
      (this.Al = n | 0),
      (this.Bh = r | 0),
      (this.Bl = i | 0),
      (this.Ch = o | 0),
      (this.Cl = a | 0),
      (this.Dh = c | 0),
      (this.Dl = s | 0),
      (this.Eh = l | 0),
      (this.El = u | 0),
      (this.Fh = d | 0),
      (this.Fl = f | 0),
      (this.Gh = p | 0),
      (this.Gl = y | 0),
      (this.Hh = b | 0),
      (this.Hl = m | 0);
  }
  process(t, n) {
    for (let S = 0; S < 16; S++, n += 4) (xi[S] = t.getUint32(n)), (Bi[S] = t.getUint32((n += 4)));
    for (let S = 16; S < 80; S++) {
      const E = xi[S - 15] | 0,
        O = Bi[S - 15] | 0,
        N = We.rotrSH(E, O, 1) ^ We.rotrSH(E, O, 8) ^ We.shrSH(E, O, 7),
        F = We.rotrSL(E, O, 1) ^ We.rotrSL(E, O, 8) ^ We.shrSL(E, O, 7),
        D = xi[S - 2] | 0,
        k = Bi[S - 2] | 0,
        K = We.rotrSH(D, k, 19) ^ We.rotrBH(D, k, 61) ^ We.shrSH(D, k, 6),
        M = We.rotrSL(D, k, 19) ^ We.rotrBL(D, k, 61) ^ We.shrSL(D, k, 6),
        C = We.add4L(F, M, Bi[S - 7], Bi[S - 16]),
        z = We.add4H(C, N, K, xi[S - 7], xi[S - 16]);
      (xi[S] = z | 0), (Bi[S] = C | 0);
    }
    let {
      Ah: r,
      Al: i,
      Bh: o,
      Bl: a,
      Ch: c,
      Cl: s,
      Dh: l,
      Dl: u,
      Eh: d,
      El: f,
      Fh: p,
      Fl: y,
      Gh: b,
      Gl: m,
      Hh: w,
      Hl: _,
    } = this;
    for (let S = 0; S < 80; S++) {
      const E = We.rotrSH(d, f, 14) ^ We.rotrSH(d, f, 18) ^ We.rotrBH(d, f, 41),
        O = We.rotrSL(d, f, 14) ^ We.rotrSL(d, f, 18) ^ We.rotrBL(d, f, 41),
        N = (d & p) ^ (~d & b),
        F = (f & y) ^ (~f & m),
        D = We.add5L(_, O, F, hse[S], Bi[S]),
        k = We.add5H(D, w, E, N, fse[S], xi[S]),
        K = D | 0,
        M = We.rotrSH(r, i, 28) ^ We.rotrBH(r, i, 34) ^ We.rotrBH(r, i, 39),
        C = We.rotrSL(r, i, 28) ^ We.rotrBL(r, i, 34) ^ We.rotrBL(r, i, 39),
        z = (r & o) ^ (r & c) ^ (o & c),
        I = (i & a) ^ (i & s) ^ (a & s);
      (w = b | 0),
        (_ = m | 0),
        (b = p | 0),
        (m = y | 0),
        (p = d | 0),
        (y = f | 0),
        ({ h: d, l: f } = We.add(l | 0, u | 0, k | 0, K | 0)),
        (l = c | 0),
        (u = s | 0),
        (c = o | 0),
        (s = a | 0),
        (o = r | 0),
        (a = i | 0);
      const T = We.add3L(K, C, I);
      (r = We.add3H(T, k, M, z)), (i = T | 0);
    }
    ({ h: r, l: i } = We.add(this.Ah | 0, this.Al | 0, r | 0, i | 0)),
      ({ h: o, l: a } = We.add(this.Bh | 0, this.Bl | 0, o | 0, a | 0)),
      ({ h: c, l: s } = We.add(this.Ch | 0, this.Cl | 0, c | 0, s | 0)),
      ({ h: l, l: u } = We.add(this.Dh | 0, this.Dl | 0, l | 0, u | 0)),
      ({ h: d, l: f } = We.add(this.Eh | 0, this.El | 0, d | 0, f | 0)),
      ({ h: p, l: y } = We.add(this.Fh | 0, this.Fl | 0, p | 0, y | 0)),
      ({ h: b, l: m } = We.add(this.Gh | 0, this.Gl | 0, b | 0, m | 0)),
      ({ h: w, l: _ } = We.add(this.Hh | 0, this.Hl | 0, w | 0, _ | 0)),
      this.set(r, i, o, a, c, s, l, u, d, f, p, y, b, m, w, _);
  }
  roundClean() {
    xi.fill(0), Bi.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const gse = kI(() => new pse());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const kw = BigInt(0),
  Ay = BigInt(1),
  yse = BigInt(2);
function ta(e) {
  return (
    e instanceof Uint8Array ||
    (e != null && typeof e == 'object' && e.constructor.name === 'Uint8Array')
  );
}
function $f(e) {
  if (!ta(e)) throw new Error('Uint8Array expected');
}
function di(e, t) {
  if (typeof t != 'boolean') throw new Error(`${e} must be valid boolean, got "${t}".`);
}
const bse = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, '0'));
function na(e) {
  $f(e);
  let t = '';
  for (let n = 0; n < e.length; n++) t += bse[e[n]];
  return t;
}
function Pa(e) {
  const t = e.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
function Cw(e) {
  if (typeof e != 'string') throw new Error('hex string expected, got ' + typeof e);
  return BigInt(e === '' ? '0' : `0x${e}`);
}
const Yr = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function UA(e) {
  if (e >= Yr._0 && e <= Yr._9) return e - Yr._0;
  if (e >= Yr._A && e <= Yr._F) return e - (Yr._A - 10);
  if (e >= Yr._a && e <= Yr._f) return e - (Yr._a - 10);
}
function ls(e) {
  if (typeof e != 'string') throw new Error('hex string expected, got ' + typeof e);
  const t = e.length,
    n = t / 2;
  if (t % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + t);
  const r = new Uint8Array(n);
  for (let i = 0, o = 0; i < n; i++, o += 2) {
    const a = UA(e.charCodeAt(o)),
      c = UA(e.charCodeAt(o + 1));
    if (a === void 0 || c === void 0) {
      const s = e[o] + e[o + 1];
      throw new Error('hex string expected, got non-hex character "' + s + '" at index ' + o);
    }
    r[i] = a * 16 + c;
  }
  return r;
}
function Lo(e) {
  return Cw(na(e));
}
function Na(e) {
  return $f(e), Cw(na(Uint8Array.from(e).reverse()));
}
function ds(e, t) {
  return ls(e.toString(16).padStart(t * 2, '0'));
}
function gc(e, t) {
  return ds(e, t).reverse();
}
function mse(e) {
  return ls(Pa(e));
}
function $t(e, t, n) {
  let r;
  if (typeof t == 'string')
    try {
      r = ls(t);
    } catch (o) {
      throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${o}`);
    }
  else if (ta(t)) r = Uint8Array.from(t);
  else throw new Error(`${e} must be hex string or Uint8Array`);
  const i = r.length;
  if (typeof n == 'number' && i !== n) throw new Error(`${e} expected ${n} bytes, got ${i}`);
  return r;
}
function ra(...e) {
  let t = 0;
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    $f(i), (t += i.length);
  }
  const n = new Uint8Array(t);
  for (let r = 0, i = 0; r < e.length; r++) {
    const o = e[r];
    n.set(o, i), (i += o.length);
  }
  return n;
}
function wse(e, t) {
  if (e.length !== t.length) return !1;
  let n = 0;
  for (let r = 0; r < e.length; r++) n |= e[r] ^ t[r];
  return n === 0;
}
function _se(e) {
  if (typeof e != 'string') throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
const im = (e) => typeof e == 'bigint' && kw <= e;
function Iy(e, t, n) {
  return im(e) && im(t) && im(n) && t <= e && e < n;
}
function Gn(e, t, n, r) {
  if (!Iy(t, n, r)) throw new Error(`expected valid ${e}: ${n} <= n < ${r}, got ${typeof t} ${t}`);
}
function NO(e) {
  let t;
  for (t = 0; e > kw; e >>= Ay, t += 1);
  return t;
}
function vse(e, t) {
  return (e >> BigInt(t)) & Ay;
}
function Sse(e, t, n) {
  return e | ((n ? Ay : kw) << BigInt(t));
}
const Mw = (e) => (yse << BigInt(e - 1)) - Ay,
  om = (e) => new Uint8Array(e),
  LA = (e) => Uint8Array.from(e);
function UO(e, t, n) {
  if (typeof e != 'number' || e < 2) throw new Error('hashLen must be a number');
  if (typeof t != 'number' || t < 2) throw new Error('qByteLen must be a number');
  if (typeof n != 'function') throw new Error('hmacFn must be a function');
  let r = om(e),
    i = om(e),
    o = 0;
  const a = () => {
      r.fill(1), i.fill(0), (o = 0);
    },
    c = (...d) => n(i, r, ...d),
    s = (d = om()) => {
      (i = c(LA([0]), d)), (r = c()), d.length !== 0 && ((i = c(LA([1]), d)), (r = c()));
    },
    l = () => {
      if (o++ >= 1e3) throw new Error('drbg: tried 1000 values');
      let d = 0;
      const f = [];
      for (; d < t; ) {
        r = c();
        const p = r.slice();
        f.push(p), (d += r.length);
      }
      return ra(...f);
    };
  return (d, f) => {
    a(), s(d);
    let p;
    for (; !(p = f(l())); ) s();
    return a(), p;
  };
}
const Ase = {
  bigint: (e) => typeof e == 'bigint',
  function: (e) => typeof e == 'function',
  boolean: (e) => typeof e == 'boolean',
  string: (e) => typeof e == 'string',
  stringOrUint8Array: (e) => typeof e == 'string' || ta(e),
  isSafeInteger: (e) => Number.isSafeInteger(e),
  array: (e) => Array.isArray(e),
  field: (e, t) => t.Fp.isValid(e),
  hash: (e) => typeof e == 'function' && Number.isSafeInteger(e.outputLen),
};
function xs(e, t, n = {}) {
  const r = (i, o, a) => {
    const c = Ase[o];
    if (typeof c != 'function') throw new Error(`Invalid validator "${o}", expected function`);
    const s = e[i];
    if (!(a && s === void 0) && !c(s, e))
      throw new Error(`Invalid param ${String(i)}=${s} (${typeof s}), expected ${o}`);
  };
  for (const [i, o] of Object.entries(t)) r(i, o, !1);
  for (const [i, o] of Object.entries(n)) r(i, o, !0);
  return e;
}
const Ise = () => {
  throw new Error('not implemented');
};
function yc(e) {
  const t = new WeakMap();
  return (n, ...r) => {
    const i = t.get(n);
    if (i !== void 0) return i;
    const o = e(n, ...r);
    return t.set(n, o), o;
  };
}
const Ese = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      aInRange: Gn,
      abool: di,
      abytes: $f,
      bitGet: vse,
      bitLen: NO,
      bitMask: Mw,
      bitSet: Sse,
      bytesToHex: na,
      bytesToNumberBE: Lo,
      bytesToNumberLE: Na,
      concatBytes: ra,
      createHmacDrbg: UO,
      ensureBytes: $t,
      equalBytes: wse,
      hexToBytes: ls,
      hexToNumber: Cw,
      inRange: Iy,
      isBytes: ta,
      memoized: yc,
      notImplemented: Ise,
      numberToBytesBE: ds,
      numberToBytesLE: gc,
      numberToHexUnpadded: Pa,
      numberToVarBytesBE: mse,
      utf8ToBytes: _se,
      validateObject: xs,
    },
    Symbol.toStringTag,
    { value: 'Module' }
  )
);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Yt = BigInt(0),
  Pt = BigInt(1),
  Po = BigInt(2),
  Tse = BigInt(3),
  y0 = BigInt(4),
  zA = BigInt(5),
  FA = BigInt(8);
BigInt(9);
BigInt(16);
function Ot(e, t) {
  const n = e % t;
  return n >= Yt ? n : t + n;
}
function kse(e, t, n) {
  if (n <= Yt || t < Yt) throw new Error('Expected power/modulo > 0');
  if (n === Pt) return Yt;
  let r = Pt;
  for (; t > Yt; ) t & Pt && (r = (r * e) % n), (e = (e * e) % n), (t >>= Pt);
  return r;
}
function Pr(e, t, n) {
  let r = e;
  for (; t-- > Yt; ) (r *= r), (r %= n);
  return r;
}
function b0(e, t) {
  if (e === Yt || t <= Yt)
    throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
  let n = Ot(e, t),
    r = t,
    i = Yt,
    o = Pt;
  for (; n !== Yt; ) {
    const c = r / n,
      s = r % n,
      l = i - o * c;
    (r = n), (n = s), (i = o), (o = l);
  }
  if (r !== Pt) throw new Error('invert: does not exist');
  return Ot(i, t);
}
function Cse(e) {
  const t = (e - Pt) / Po;
  let n, r, i;
  for (n = e - Pt, r = 0; n % Po === Yt; n /= Po, r++);
  for (i = Po; i < e && kse(i, t, e) !== e - Pt; i++);
  if (r === 1) {
    const a = (e + Pt) / y0;
    return function (s, l) {
      const u = s.pow(l, a);
      if (!s.eql(s.sqr(u), l)) throw new Error('Cannot find square root');
      return u;
    };
  }
  const o = (n + Pt) / Po;
  return function (c, s) {
    if (c.pow(s, t) === c.neg(c.ONE)) throw new Error('Cannot find square root');
    let l = r,
      u = c.pow(c.mul(c.ONE, i), n),
      d = c.pow(s, o),
      f = c.pow(s, n);
    for (; !c.eql(f, c.ONE); ) {
      if (c.eql(f, c.ZERO)) return c.ZERO;
      let p = 1;
      for (let b = c.sqr(f); p < l && !c.eql(b, c.ONE); p++) b = c.sqr(b);
      const y = c.pow(u, Pt << BigInt(l - p - 1));
      (u = c.sqr(y)), (d = c.mul(d, y)), (f = c.mul(f, u)), (l = p);
    }
    return d;
  };
}
function Mse(e) {
  if (e % y0 === Tse) {
    const t = (e + Pt) / y0;
    return function (r, i) {
      const o = r.pow(i, t);
      if (!r.eql(r.sqr(o), i)) throw new Error('Cannot find square root');
      return o;
    };
  }
  if (e % FA === zA) {
    const t = (e - zA) / FA;
    return function (r, i) {
      const o = r.mul(i, Po),
        a = r.pow(o, t),
        c = r.mul(i, a),
        s = r.mul(r.mul(c, Po), a),
        l = r.mul(c, r.sub(s, r.ONE));
      if (!r.eql(r.sqr(l), i)) throw new Error('Cannot find square root');
      return l;
    };
  }
  return Cse(e);
}
const Pse = (e, t) => (Ot(e, t) & Pt) === Pt,
  Ose = [
    'create',
    'isValid',
    'is0',
    'neg',
    'inv',
    'sqrt',
    'sqr',
    'eql',
    'add',
    'sub',
    'mul',
    'pow',
    'div',
    'addN',
    'subN',
    'mulN',
    'sqrN',
  ];
function Dse(e) {
  const t = { ORDER: 'bigint', MASK: 'bigint', BYTES: 'isSafeInteger', BITS: 'isSafeInteger' },
    n = Ose.reduce((r, i) => ((r[i] = 'function'), r), t);
  return xs(e, n);
}
function Rse(e, t, n) {
  if (n < Yt) throw new Error('Expected power > 0');
  if (n === Yt) return e.ONE;
  if (n === Pt) return t;
  let r = e.ONE,
    i = t;
  for (; n > Yt; ) n & Pt && (r = e.mul(r, i)), (i = e.sqr(i)), (n >>= Pt);
  return r;
}
function xse(e, t) {
  const n = new Array(t.length),
    r = t.reduce((o, a, c) => (e.is0(a) ? o : ((n[c] = o), e.mul(o, a))), e.ONE),
    i = e.inv(r);
  return t.reduceRight((o, a, c) => (e.is0(a) ? o : ((n[c] = e.mul(o, n[c])), e.mul(o, a))), i), n;
}
function LO(e, t) {
  const n = t !== void 0 ? t : e.toString(2).length,
    r = Math.ceil(n / 8);
  return { nBitLength: n, nByteLength: r };
}
function Ey(e, t, n = !1, r = {}) {
  if (e <= Yt) throw new Error(`Expected Field ORDER > 0, got ${e}`);
  const { nBitLength: i, nByteLength: o } = LO(e, t);
  if (o > 2048) throw new Error('Field lengths over 2048 bytes are not supported');
  const a = Mse(e),
    c = Object.freeze({
      ORDER: e,
      BITS: i,
      BYTES: o,
      MASK: Mw(i),
      ZERO: Yt,
      ONE: Pt,
      create: (s) => Ot(s, e),
      isValid: (s) => {
        if (typeof s != 'bigint')
          throw new Error(`Invalid field element: expected bigint, got ${typeof s}`);
        return Yt <= s && s < e;
      },
      is0: (s) => s === Yt,
      isOdd: (s) => (s & Pt) === Pt,
      neg: (s) => Ot(-s, e),
      eql: (s, l) => s === l,
      sqr: (s) => Ot(s * s, e),
      add: (s, l) => Ot(s + l, e),
      sub: (s, l) => Ot(s - l, e),
      mul: (s, l) => Ot(s * l, e),
      pow: (s, l) => Rse(c, s, l),
      div: (s, l) => Ot(s * b0(l, e), e),
      sqrN: (s) => s * s,
      addN: (s, l) => s + l,
      subN: (s, l) => s - l,
      mulN: (s, l) => s * l,
      inv: (s) => b0(s, e),
      sqrt: r.sqrt || ((s) => a(c, s)),
      invertBatch: (s) => xse(c, s),
      cmov: (s, l, u) => (u ? l : s),
      toBytes: (s) => (n ? gc(s, o) : ds(s, o)),
      fromBytes: (s) => {
        if (s.length !== o) throw new Error(`Fp.fromBytes: expected ${o}, got ${s.length}`);
        return n ? Na(s) : Lo(s);
      },
    });
  return Object.freeze(c);
}
function zO(e) {
  if (typeof e != 'bigint') throw new Error('field order must be bigint');
  const t = e.toString(2).length;
  return Math.ceil(t / 8);
}
function FO(e) {
  const t = zO(e);
  return t + Math.ceil(t / 2);
}
function Bse(e, t, n = !1) {
  const r = e.length,
    i = zO(t),
    o = FO(t);
  if (r < 16 || r < o || r > 1024) throw new Error(`expected ${o}-1024 bytes of input, got ${r}`);
  const a = n ? Lo(e) : Na(e),
    c = Ot(a, t - Pt) + Pt;
  return n ? gc(c, i) : ds(c, i);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const jse = BigInt(0),
  am = BigInt(1),
  sm = new WeakMap(),
  $A = new WeakMap();
function $O(e, t) {
  const n = (o, a) => {
      const c = a.negate();
      return o ? c : a;
    },
    r = (o) => {
      if (!Number.isSafeInteger(o) || o <= 0 || o > t)
        throw new Error(`Wrong window size=${o}, should be [1..${t}]`);
    },
    i = (o) => {
      r(o);
      const a = Math.ceil(t / o) + 1,
        c = 2 ** (o - 1);
      return { windows: a, windowSize: c };
    };
  return {
    constTimeNegate: n,
    unsafeLadder(o, a) {
      let c = e.ZERO,
        s = o;
      for (; a > jse; ) a & am && (c = c.add(s)), (s = s.double()), (a >>= am);
      return c;
    },
    precomputeWindow(o, a) {
      const { windows: c, windowSize: s } = i(a),
        l = [];
      let u = o,
        d = u;
      for (let f = 0; f < c; f++) {
        (d = u), l.push(d);
        for (let p = 1; p < s; p++) (d = d.add(u)), l.push(d);
        u = d.double();
      }
      return l;
    },
    wNAF(o, a, c) {
      const { windows: s, windowSize: l } = i(o);
      let u = e.ZERO,
        d = e.BASE;
      const f = BigInt(2 ** o - 1),
        p = 2 ** o,
        y = BigInt(o);
      for (let b = 0; b < s; b++) {
        const m = b * l;
        let w = Number(c & f);
        (c >>= y), w > l && ((w -= p), (c += am));
        const _ = m,
          S = m + Math.abs(w) - 1,
          E = b % 2 !== 0,
          O = w < 0;
        w === 0 ? (d = d.add(n(E, a[_]))) : (u = u.add(n(O, a[S])));
      }
      return { p: u, f: d };
    },
    wNAFCached(o, a, c) {
      const s = $A.get(o) || 1;
      let l = sm.get(o);
      return (
        l || ((l = this.precomputeWindow(o, s)), s !== 1 && sm.set(o, c(l))), this.wNAF(s, l, a)
      );
    },
    setWindowSize(o, a) {
      r(a), $A.set(o, a), sm.delete(o);
    },
  };
}
function WO(e, t, n, r) {
  if (!Array.isArray(n) || !Array.isArray(r) || r.length !== n.length)
    throw new Error('arrays of points and scalars must have equal length');
  r.forEach((u, d) => {
    if (!t.isValid(u)) throw new Error(`wrong scalar at index ${d}`);
  }),
    n.forEach((u, d) => {
      if (!(u instanceof e)) throw new Error(`wrong point at index ${d}`);
    });
  const i = NO(BigInt(n.length)),
    o = i > 12 ? i - 3 : i > 4 ? i - 2 : i ? 2 : 1,
    a = (1 << o) - 1,
    c = new Array(a + 1).fill(e.ZERO),
    s = Math.floor((t.BITS - 1) / o) * o;
  let l = e.ZERO;
  for (let u = s; u >= 0; u -= o) {
    c.fill(e.ZERO);
    for (let f = 0; f < r.length; f++) {
      const p = r[f],
        y = Number((p >> BigInt(u)) & BigInt(a));
      c[y] = c[y].add(n[f]);
    }
    let d = e.ZERO;
    for (let f = c.length - 1, p = e.ZERO; f > 0; f--) (p = p.add(c[f])), (d = d.add(p));
    if (((l = l.add(d)), u !== 0)) for (let f = 0; f < o; f++) l = l.double();
  }
  return l;
}
function Pw(e) {
  return (
    Dse(e.Fp),
    xs(
      e,
      { n: 'bigint', h: 'bigint', Gx: 'field', Gy: 'field' },
      { nBitLength: 'isSafeInteger', nByteLength: 'isSafeInteger' }
    ),
    Object.freeze({ ...LO(e.n, e.nBitLength), ...e, p: e.Fp.ORDER })
  );
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const tr = BigInt(0),
  Tn = BigInt(1),
  Sh = BigInt(2),
  Nse = BigInt(8),
  Use = { zip215: !0 };
function Lse(e) {
  const t = Pw(e);
  return (
    xs(
      e,
      { hash: 'function', a: 'bigint', d: 'bigint', randomBytes: 'function' },
      {
        adjustScalarBytes: 'function',
        domain: 'function',
        uvRatio: 'function',
        mapToCurve: 'function',
      }
    ),
    Object.freeze({ ...t })
  );
}
function zse(e) {
  const t = Lse(e),
    { Fp: n, n: r, prehash: i, hash: o, randomBytes: a, nByteLength: c, h: s } = t,
    l = Sh << (BigInt(c * 8) - Tn),
    u = n.create,
    d = Ey(t.n, t.nBitLength),
    f =
      t.uvRatio ||
      ((P, R) => {
        try {
          return { isValid: !0, value: n.sqrt(P * n.inv(R)) };
        } catch {
          return { isValid: !1, value: tr };
        }
      }),
    p = t.adjustScalarBytes || ((P) => P),
    y =
      t.domain ||
      ((P, R, L) => {
        if ((di('phflag', L), R.length || L))
          throw new Error('Contexts/pre-hash are not supported');
        return P;
      });
  function b(P, R) {
    Gn('coordinate ' + P, R, tr, l);
  }
  function m(P) {
    if (!(P instanceof S)) throw new Error('ExtendedPoint expected');
  }
  const w = yc((P, R) => {
      const { ex: L, ey: H, ez: ie } = P,
        he = P.is0();
      R == null && (R = he ? Nse : n.inv(ie));
      const Q = u(L * R),
        ee = u(H * R),
        J = u(ie * R);
      if (he) return { x: tr, y: Tn };
      if (J !== Tn) throw new Error('invZ was invalid');
      return { x: Q, y: ee };
    }),
    _ = yc((P) => {
      const { a: R, d: L } = t;
      if (P.is0()) throw new Error('bad point: ZERO');
      const { ex: H, ey: ie, ez: he, et: Q } = P,
        ee = u(H * H),
        J = u(ie * ie),
        fe = u(he * he),
        j = u(fe * fe),
        Ie = u(ee * R),
        re = u(fe * u(Ie + J)),
        Fe = u(j + u(L * u(ee * J)));
      if (re !== Fe) throw new Error('bad point: equation left != right (1)');
      const De = u(H * ie),
        Be = u(he * Q);
      if (De !== Be) throw new Error('bad point: equation left != right (2)');
      return !0;
    });
  class S {
    constructor(R, L, H, ie) {
      (this.ex = R),
        (this.ey = L),
        (this.ez = H),
        (this.et = ie),
        b('x', R),
        b('y', L),
        b('z', H),
        b('t', ie),
        Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(R) {
      if (R instanceof S) throw new Error('extended point not allowed');
      const { x: L, y: H } = R || {};
      return b('x', L), b('y', H), new S(L, H, Tn, u(L * H));
    }
    static normalizeZ(R) {
      const L = n.invertBatch(R.map((H) => H.ez));
      return R.map((H, ie) => H.toAffine(L[ie])).map(S.fromAffine);
    }
    static msm(R, L) {
      return WO(S, d, R, L);
    }
    _setWindowSize(R) {
      N.setWindowSize(this, R);
    }
    assertValidity() {
      _(this);
    }
    equals(R) {
      m(R);
      const { ex: L, ey: H, ez: ie } = this,
        { ex: he, ey: Q, ez: ee } = R,
        J = u(L * ee),
        fe = u(he * ie),
        j = u(H * ee),
        Ie = u(Q * ie);
      return J === fe && j === Ie;
    }
    is0() {
      return this.equals(S.ZERO);
    }
    negate() {
      return new S(u(-this.ex), this.ey, this.ez, u(-this.et));
    }
    double() {
      const { a: R } = t,
        { ex: L, ey: H, ez: ie } = this,
        he = u(L * L),
        Q = u(H * H),
        ee = u(Sh * u(ie * ie)),
        J = u(R * he),
        fe = L + H,
        j = u(u(fe * fe) - he - Q),
        Ie = J + Q,
        re = Ie - ee,
        Fe = J - Q,
        De = u(j * re),
        Be = u(Ie * Fe),
        _e = u(j * Fe),
        lt = u(re * Ie);
      return new S(De, Be, lt, _e);
    }
    add(R) {
      m(R);
      const { a: L, d: H } = t,
        { ex: ie, ey: he, ez: Q, et: ee } = this,
        { ex: J, ey: fe, ez: j, et: Ie } = R;
      if (L === BigInt(-1)) {
        const Nt = u((he - ie) * (fe + J)),
          yo = u((he + ie) * (fe - J)),
          Hr = u(yo - Nt);
        if (Hr === tr) return this.double();
        const En = u(Q * Sh * Ie),
          Pe = u(ee * Sh * j),
          St = Pe + En,
          pa = yo + Nt,
          ga = Pe - En,
          vr = u(St * Hr),
          n3 = u(pa * ga),
          r3 = u(St * ga),
          i3 = u(Hr * pa);
        return new S(vr, n3, i3, r3);
      }
      const re = u(ie * J),
        Fe = u(he * fe),
        De = u(ee * H * Ie),
        Be = u(Q * j),
        _e = u((ie + he) * (J + fe) - re - Fe),
        lt = Be - De,
        jt = Be + De,
        qe = u(Fe - L * re),
        Wt = u(_e * lt),
        rt = u(jt * qe),
        Ft = u(_e * qe),
        go = u(lt * jt);
      return new S(Wt, rt, go, Ft);
    }
    subtract(R) {
      return this.add(R.negate());
    }
    wNAF(R) {
      return N.wNAFCached(this, R, S.normalizeZ);
    }
    multiply(R) {
      const L = R;
      Gn('scalar', L, Tn, r);
      const { p: H, f: ie } = this.wNAF(L);
      return S.normalizeZ([H, ie])[0];
    }
    multiplyUnsafe(R) {
      const L = R;
      return (
        Gn('scalar', L, tr, r),
        L === tr
          ? O
          : this.equals(O) || L === Tn
            ? this
            : this.equals(E)
              ? this.wNAF(L).p
              : N.unsafeLadder(this, L)
      );
    }
    isSmallOrder() {
      return this.multiplyUnsafe(s).is0();
    }
    isTorsionFree() {
      return N.unsafeLadder(this, r).is0();
    }
    toAffine(R) {
      return w(this, R);
    }
    clearCofactor() {
      const { h: R } = t;
      return R === Tn ? this : this.multiplyUnsafe(R);
    }
    static fromHex(R, L = !1) {
      const { d: H, a: ie } = t,
        he = n.BYTES;
      (R = $t('pointHex', R, he)), di('zip215', L);
      const Q = R.slice(),
        ee = R[he - 1];
      Q[he - 1] = ee & -129;
      const J = Na(Q),
        fe = L ? l : n.ORDER;
      Gn('pointHex.y', J, tr, fe);
      const j = u(J * J),
        Ie = u(j - Tn),
        re = u(H * j - ie);
      let { isValid: Fe, value: De } = f(Ie, re);
      if (!Fe) throw new Error('Point.fromHex: invalid y coordinate');
      const Be = (De & Tn) === Tn,
        _e = (ee & 128) !== 0;
      if (!L && De === tr && _e) throw new Error('Point.fromHex: x=0 and x_0=1');
      return _e !== Be && (De = u(-De)), S.fromAffine({ x: De, y: J });
    }
    static fromPrivateKey(R) {
      return k(R).point;
    }
    toRawBytes() {
      const { x: R, y: L } = this.toAffine(),
        H = gc(L, n.BYTES);
      return (H[H.length - 1] |= R & Tn ? 128 : 0), H;
    }
    toHex() {
      return na(this.toRawBytes());
    }
  }
  (S.BASE = new S(t.Gx, t.Gy, Tn, u(t.Gx * t.Gy))), (S.ZERO = new S(tr, Tn, Tn, tr));
  const { BASE: E, ZERO: O } = S,
    N = $O(S, c * 8);
  function F(P) {
    return Ot(P, r);
  }
  function D(P) {
    return F(Na(P));
  }
  function k(P) {
    const R = c;
    P = $t('private key', P, R);
    const L = $t('hashed private key', o(P), 2 * R),
      H = p(L.slice(0, R)),
      ie = L.slice(R, 2 * R),
      he = D(H),
      Q = E.multiply(he),
      ee = Q.toRawBytes();
    return { head: H, prefix: ie, scalar: he, point: Q, pointBytes: ee };
  }
  function K(P) {
    return k(P).pointBytes;
  }
  function M(P = new Uint8Array(), ...R) {
    const L = ra(...R);
    return D(o(y(L, $t('context', P), !!i)));
  }
  function C(P, R, L = {}) {
    (P = $t('message', P)), i && (P = i(P));
    const { prefix: H, scalar: ie, pointBytes: he } = k(R),
      Q = M(L.context, H, P),
      ee = E.multiply(Q).toRawBytes(),
      J = M(L.context, ee, he, P),
      fe = F(Q + J * ie);
    Gn('signature.s', fe, tr, r);
    const j = ra(ee, gc(fe, n.BYTES));
    return $t('result', j, c * 2);
  }
  const z = Use;
  function I(P, R, L, H = z) {
    const { context: ie, zip215: he } = H,
      Q = n.BYTES;
    (P = $t('signature', P, 2 * Q)),
      (R = $t('message', R)),
      he !== void 0 && di('zip215', he),
      i && (R = i(R));
    const ee = Na(P.slice(Q, 2 * Q));
    let J, fe, j;
    try {
      (J = S.fromHex(L, he)), (fe = S.fromHex(P.slice(0, Q), he)), (j = E.multiplyUnsafe(ee));
    } catch {
      return !1;
    }
    if (!he && J.isSmallOrder()) return !1;
    const Ie = M(ie, fe.toRawBytes(), J.toRawBytes(), R);
    return fe.add(J.multiplyUnsafe(Ie)).subtract(j).clearCofactor().equals(S.ZERO);
  }
  return (
    E._setWindowSize(8),
    {
      CURVE: t,
      getPublicKey: K,
      sign: C,
      verify: I,
      ExtendedPoint: S,
      utils: {
        getExtendedPublicKey: k,
        randomPrivateKey: () => a(n.BYTES),
        precompute(P = 8, R = S.BASE) {
          return R._setWindowSize(P), R.multiply(BigInt(3)), R;
        },
      },
    }
  );
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Ow = BigInt(
    '57896044618658097711785492504343953926634992332820282019728792003956564819949'
  ),
  WA = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');
BigInt(0);
const Fse = BigInt(1),
  VA = BigInt(2);
BigInt(3);
const $se = BigInt(5),
  Wse = BigInt(8);
function Vse(e) {
  const t = BigInt(10),
    n = BigInt(20),
    r = BigInt(40),
    i = BigInt(80),
    o = Ow,
    c = (((e * e) % o) * e) % o,
    s = (Pr(c, VA, o) * c) % o,
    l = (Pr(s, Fse, o) * e) % o,
    u = (Pr(l, $se, o) * l) % o,
    d = (Pr(u, t, o) * u) % o,
    f = (Pr(d, n, o) * d) % o,
    p = (Pr(f, r, o) * f) % o,
    y = (Pr(p, i, o) * p) % o,
    b = (Pr(y, i, o) * p) % o,
    m = (Pr(b, t, o) * u) % o;
  return { pow_p_5_8: (Pr(m, VA, o) * e) % o, b2: c };
}
function Kse(e) {
  return (e[0] &= 248), (e[31] &= 127), (e[31] |= 64), e;
}
function Hse(e, t) {
  const n = Ow,
    r = Ot(t * t * t, n),
    i = Ot(r * r * t, n),
    o = Vse(e * i).pow_p_5_8;
  let a = Ot(e * r * o, n);
  const c = Ot(t * a * a, n),
    s = a,
    l = Ot(a * WA, n),
    u = c === e,
    d = c === Ot(-e, n),
    f = c === Ot(-e * WA, n);
  return (
    u && (a = s), (d || f) && (a = l), Pse(a, n) && (a = Ot(-a, n)), { isValid: u || d, value: a }
  );
}
const qse = Ey(Ow, void 0, !0),
  Gse = {
    a: BigInt(-1),
    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),
    Fp: qse,
    n: BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989'),
    h: Wse,
    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),
    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),
    hash: gse,
    randomBytes: CI,
    adjustScalarBytes: Kse,
    uvRatio: Hse,
  },
  Yse = zse(Gse);
function Zse(e, t) {
  return Oa.IntentMessage(Oa.fixedArray(t.length, Oa.u8()))
    .serialize({
      intent: { scope: { [e]: !0 }, version: { V0: !0 }, appId: { Sui: !0 } },
      value: t,
    })
    .toBytes();
}
const Wf = { ED25519: 0, Secp256k1: 1, Secp256r1: 2, MultiSig: 3, ZkLogin: 5, Passkey: 6 },
  Qse = { ED25519: 32, Secp256k1: 33, Secp256r1: 33 },
  Jse = { 0: 'ED25519', 1: 'Secp256k1', 2: 'Secp256r1', 3: 'MultiSig', 5: 'ZkLogin', 6: 'Passkey' },
  Xse = new Uint32Array([
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221,
    3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580,
    3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895,
    666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037,
    2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
    1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298,
  ]),
  ji = new Uint32Array([
    1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225,
  ]),
  Ni = new Uint32Array(64);
class ece extends jO {
  constructor() {
    super(64, 32, 8, !1),
      (this.A = ji[0] | 0),
      (this.B = ji[1] | 0),
      (this.C = ji[2] | 0),
      (this.D = ji[3] | 0),
      (this.E = ji[4] | 0),
      (this.F = ji[5] | 0),
      (this.G = ji[6] | 0),
      (this.H = ji[7] | 0);
  }
  get() {
    const { A: t, B: n, C: r, D: i, E: o, F: a, G: c, H: s } = this;
    return [t, n, r, i, o, a, c, s];
  }
  set(t, n, r, i, o, a, c, s) {
    (this.A = t | 0),
      (this.B = n | 0),
      (this.C = r | 0),
      (this.D = i | 0),
      (this.E = o | 0),
      (this.F = a | 0),
      (this.G = c | 0),
      (this.H = s | 0);
  }
  process(t, n) {
    for (let d = 0; d < 16; d++, n += 4) Ni[d] = t.getUint32(n, !1);
    for (let d = 16; d < 64; d++) {
      const f = Ni[d - 15],
        p = Ni[d - 2],
        y = Sr(f, 7) ^ Sr(f, 18) ^ (f >>> 3),
        b = Sr(p, 17) ^ Sr(p, 19) ^ (p >>> 10);
      Ni[d] = (b + Ni[d - 7] + y + Ni[d - 16]) | 0;
    }
    let { A: r, B: i, C: o, D: a, E: c, F: s, G: l, H: u } = this;
    for (let d = 0; d < 64; d++) {
      const f = Sr(c, 6) ^ Sr(c, 11) ^ Sr(c, 25),
        p = (u + f + lse(c, s, l) + Xse[d] + Ni[d]) | 0,
        b = ((Sr(r, 2) ^ Sr(r, 13) ^ Sr(r, 22)) + dse(r, i, o)) | 0;
      (u = l), (l = s), (s = c), (c = (a + p) | 0), (a = o), (o = i), (i = r), (r = (p + b) | 0);
    }
    (r = (r + this.A) | 0),
      (i = (i + this.B) | 0),
      (o = (o + this.C) | 0),
      (a = (a + this.D) | 0),
      (c = (c + this.E) | 0),
      (s = (s + this.F) | 0),
      (l = (l + this.G) | 0),
      (u = (u + this.H) | 0),
      this.set(r, i, o, a, c, s, l, u);
  }
  roundClean() {
    Ni.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
const m0 = kI(() => new ece());
class VO extends EI {
  constructor(t, n) {
    super(), (this.finished = !1), (this.destroyed = !1), K4(t);
    const r = TI(n);
    if (((this.iHash = t.create()), typeof this.iHash.update != 'function'))
      throw new Error('Expected instance of class which extends utils.Hash');
    (this.blockLen = this.iHash.blockLen), (this.outputLen = this.iHash.outputLen);
    const i = this.blockLen,
      o = new Uint8Array(i);
    o.set(r.length > i ? t.create().update(r).digest() : r);
    for (let a = 0; a < o.length; a++) o[a] ^= 54;
    this.iHash.update(o), (this.oHash = t.create());
    for (let a = 0; a < o.length; a++) o[a] ^= 106;
    this.oHash.update(o), o.fill(0);
  }
  update(t) {
    return Xh(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    Xh(this),
      H4(t, this.outputLen),
      (this.finished = !0),
      this.iHash.digestInto(t),
      this.oHash.update(t),
      this.oHash.digestInto(t),
      this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n, iHash: r, finished: i, destroyed: o, blockLen: a, outputLen: c } = this;
    return (
      (t = t),
      (t.finished = i),
      (t.destroyed = o),
      (t.blockLen = a),
      (t.outputLen = c),
      (t.oHash = n._cloneInto(t.oHash)),
      (t.iHash = r._cloneInto(t.iHash)),
      t
    );
  }
  destroy() {
    (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
  }
}
const KO = (e, t, n) => new VO(e, t).update(n).digest();
KO.create = (e, t) => new VO(e, t);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function KA(e) {
  e.lowS !== void 0 && di('lowS', e.lowS), e.prehash !== void 0 && di('prehash', e.prehash);
}
function tce(e) {
  const t = Pw(e);
  xs(
    t,
    { a: 'field', b: 'field' },
    {
      allowedPrivateKeyLengths: 'array',
      wrapPrivateKey: 'boolean',
      isTorsionFree: 'function',
      clearCofactor: 'function',
      allowInfinityPoint: 'boolean',
      fromBytes: 'function',
      toBytes: 'function',
    }
  );
  const { endo: n, Fp: r, a: i } = t;
  if (n) {
    if (!r.eql(i, r.ZERO))
      throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');
    if (typeof n != 'object' || typeof n.beta != 'bigint' || typeof n.splitScalar != 'function')
      throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');
  }
  return Object.freeze({ ...t });
}
const { bytesToNumberBE: nce, hexToBytes: rce } = Ese,
  ti = {
    Err: class extends Error {
      constructor(t = '') {
        super(t);
      }
    },
    _tlv: {
      encode: (e, t) => {
        const { Err: n } = ti;
        if (e < 0 || e > 256) throw new n('tlv.encode: wrong tag');
        if (t.length & 1) throw new n('tlv.encode: unpadded data');
        const r = t.length / 2,
          i = Pa(r);
        if ((i.length / 2) & 128) throw new n('tlv.encode: long form length too big');
        const o = r > 127 ? Pa((i.length / 2) | 128) : '';
        return `${Pa(e)}${o}${i}${t}`;
      },
      decode(e, t) {
        const { Err: n } = ti;
        let r = 0;
        if (e < 0 || e > 256) throw new n('tlv.encode: wrong tag');
        if (t.length < 2 || t[r++] !== e) throw new n('tlv.decode: wrong tlv');
        const i = t[r++],
          o = !!(i & 128);
        let a = 0;
        if (!o) a = i;
        else {
          const s = i & 127;
          if (!s) throw new n('tlv.decode(long): indefinite length not supported');
          if (s > 4) throw new n('tlv.decode(long): byte length is too big');
          const l = t.subarray(r, r + s);
          if (l.length !== s) throw new n('tlv.decode: length bytes not complete');
          if (l[0] === 0) throw new n('tlv.decode(long): zero leftmost byte');
          for (const u of l) a = (a << 8) | u;
          if (((r += s), a < 128)) throw new n('tlv.decode(long): not minimal encoding');
        }
        const c = t.subarray(r, r + a);
        if (c.length !== a) throw new n('tlv.decode: wrong value length');
        return { v: c, l: t.subarray(r + a) };
      },
    },
    _int: {
      encode(e) {
        const { Err: t } = ti;
        if (e < ii) throw new t('integer: negative integers are not allowed');
        let n = Pa(e);
        if ((Number.parseInt(n[0], 16) & 8 && (n = '00' + n), n.length & 1))
          throw new t('unexpected assertion');
        return n;
      },
      decode(e) {
        const { Err: t } = ti;
        if (e[0] & 128) throw new t('Invalid signature integer: negative');
        if (e[0] === 0 && !(e[1] & 128))
          throw new t('Invalid signature integer: unnecessary leading zero');
        return nce(e);
      },
    },
    toSig(e) {
      const { Err: t, _int: n, _tlv: r } = ti,
        i = typeof e == 'string' ? rce(e) : e;
      $f(i);
      const { v: o, l: a } = r.decode(48, i);
      if (a.length) throw new t('Invalid signature: left bytes after parsing');
      const { v: c, l: s } = r.decode(2, o),
        { v: l, l: u } = r.decode(2, s);
      if (u.length) throw new t('Invalid signature: left bytes after parsing');
      return { r: n.decode(c), s: n.decode(l) };
    },
    hexFromSig(e) {
      const { _tlv: t, _int: n } = ti,
        r = `${t.encode(2, n.encode(e.r))}${t.encode(2, n.encode(e.s))}`;
      return t.encode(48, r);
    },
  },
  ii = BigInt(0),
  Ht = BigInt(1);
BigInt(2);
const HA = BigInt(3);
BigInt(4);
function ice(e) {
  const t = tce(e),
    { Fp: n } = t,
    r = Ey(t.n, t.nBitLength),
    i =
      t.toBytes ||
      ((b, m, w) => {
        const _ = m.toAffine();
        return ra(Uint8Array.from([4]), n.toBytes(_.x), n.toBytes(_.y));
      }),
    o =
      t.fromBytes ||
      ((b) => {
        const m = b.subarray(1),
          w = n.fromBytes(m.subarray(0, n.BYTES)),
          _ = n.fromBytes(m.subarray(n.BYTES, 2 * n.BYTES));
        return { x: w, y: _ };
      });
  function a(b) {
    const { a: m, b: w } = t,
      _ = n.sqr(b),
      S = n.mul(_, b);
    return n.add(n.add(S, n.mul(b, m)), w);
  }
  if (!n.eql(n.sqr(t.Gy), a(t.Gx))) throw new Error('bad generator point: equation left != right');
  function c(b) {
    return Iy(b, Ht, t.n);
  }
  function s(b) {
    const { allowedPrivateKeyLengths: m, nByteLength: w, wrapPrivateKey: _, n: S } = t;
    if (m && typeof b != 'bigint') {
      if ((ta(b) && (b = na(b)), typeof b != 'string' || !m.includes(b.length)))
        throw new Error('Invalid key');
      b = b.padStart(w * 2, '0');
    }
    let E;
    try {
      E = typeof b == 'bigint' ? b : Lo($t('private key', b, w));
    } catch {
      throw new Error(`private key must be ${w} bytes, hex or bigint, not ${typeof b}`);
    }
    return _ && (E = Ot(E, S)), Gn('private key', E, Ht, S), E;
  }
  function l(b) {
    if (!(b instanceof f)) throw new Error('ProjectivePoint expected');
  }
  const u = yc((b, m) => {
      const { px: w, py: _, pz: S } = b;
      if (n.eql(S, n.ONE)) return { x: w, y: _ };
      const E = b.is0();
      m == null && (m = E ? n.ONE : n.inv(S));
      const O = n.mul(w, m),
        N = n.mul(_, m),
        F = n.mul(S, m);
      if (E) return { x: n.ZERO, y: n.ZERO };
      if (!n.eql(F, n.ONE)) throw new Error('invZ was invalid');
      return { x: O, y: N };
    }),
    d = yc((b) => {
      if (b.is0()) {
        if (t.allowInfinityPoint && !n.is0(b.py)) return;
        throw new Error('bad point: ZERO');
      }
      const { x: m, y: w } = b.toAffine();
      if (!n.isValid(m) || !n.isValid(w)) throw new Error('bad point: x or y not FE');
      const _ = n.sqr(w),
        S = a(m);
      if (!n.eql(_, S)) throw new Error('bad point: equation left != right');
      if (!b.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');
      return !0;
    });
  class f {
    constructor(m, w, _) {
      if (((this.px = m), (this.py = w), (this.pz = _), m == null || !n.isValid(m)))
        throw new Error('x required');
      if (w == null || !n.isValid(w)) throw new Error('y required');
      if (_ == null || !n.isValid(_)) throw new Error('z required');
      Object.freeze(this);
    }
    static fromAffine(m) {
      const { x: w, y: _ } = m || {};
      if (!m || !n.isValid(w) || !n.isValid(_)) throw new Error('invalid affine point');
      if (m instanceof f) throw new Error('projective point not allowed');
      const S = (E) => n.eql(E, n.ZERO);
      return S(w) && S(_) ? f.ZERO : new f(w, _, n.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(m) {
      const w = n.invertBatch(m.map((_) => _.pz));
      return m.map((_, S) => _.toAffine(w[S])).map(f.fromAffine);
    }
    static fromHex(m) {
      const w = f.fromAffine(o($t('pointHex', m)));
      return w.assertValidity(), w;
    }
    static fromPrivateKey(m) {
      return f.BASE.multiply(s(m));
    }
    static msm(m, w) {
      return WO(f, r, m, w);
    }
    _setWindowSize(m) {
      y.setWindowSize(this, m);
    }
    assertValidity() {
      d(this);
    }
    hasEvenY() {
      const { y: m } = this.toAffine();
      if (n.isOdd) return !n.isOdd(m);
      throw new Error("Field doesn't support isOdd");
    }
    equals(m) {
      l(m);
      const { px: w, py: _, pz: S } = this,
        { px: E, py: O, pz: N } = m,
        F = n.eql(n.mul(w, N), n.mul(E, S)),
        D = n.eql(n.mul(_, N), n.mul(O, S));
      return F && D;
    }
    negate() {
      return new f(this.px, n.neg(this.py), this.pz);
    }
    double() {
      const { a: m, b: w } = t,
        _ = n.mul(w, HA),
        { px: S, py: E, pz: O } = this;
      let N = n.ZERO,
        F = n.ZERO,
        D = n.ZERO,
        k = n.mul(S, S),
        K = n.mul(E, E),
        M = n.mul(O, O),
        C = n.mul(S, E);
      return (
        (C = n.add(C, C)),
        (D = n.mul(S, O)),
        (D = n.add(D, D)),
        (N = n.mul(m, D)),
        (F = n.mul(_, M)),
        (F = n.add(N, F)),
        (N = n.sub(K, F)),
        (F = n.add(K, F)),
        (F = n.mul(N, F)),
        (N = n.mul(C, N)),
        (D = n.mul(_, D)),
        (M = n.mul(m, M)),
        (C = n.sub(k, M)),
        (C = n.mul(m, C)),
        (C = n.add(C, D)),
        (D = n.add(k, k)),
        (k = n.add(D, k)),
        (k = n.add(k, M)),
        (k = n.mul(k, C)),
        (F = n.add(F, k)),
        (M = n.mul(E, O)),
        (M = n.add(M, M)),
        (k = n.mul(M, C)),
        (N = n.sub(N, k)),
        (D = n.mul(M, K)),
        (D = n.add(D, D)),
        (D = n.add(D, D)),
        new f(N, F, D)
      );
    }
    add(m) {
      l(m);
      const { px: w, py: _, pz: S } = this,
        { px: E, py: O, pz: N } = m;
      let F = n.ZERO,
        D = n.ZERO,
        k = n.ZERO;
      const K = t.a,
        M = n.mul(t.b, HA);
      let C = n.mul(w, E),
        z = n.mul(_, O),
        I = n.mul(S, N),
        T = n.add(w, _),
        P = n.add(E, O);
      (T = n.mul(T, P)), (P = n.add(C, z)), (T = n.sub(T, P)), (P = n.add(w, S));
      let R = n.add(E, N);
      return (
        (P = n.mul(P, R)),
        (R = n.add(C, I)),
        (P = n.sub(P, R)),
        (R = n.add(_, S)),
        (F = n.add(O, N)),
        (R = n.mul(R, F)),
        (F = n.add(z, I)),
        (R = n.sub(R, F)),
        (k = n.mul(K, P)),
        (F = n.mul(M, I)),
        (k = n.add(F, k)),
        (F = n.sub(z, k)),
        (k = n.add(z, k)),
        (D = n.mul(F, k)),
        (z = n.add(C, C)),
        (z = n.add(z, C)),
        (I = n.mul(K, I)),
        (P = n.mul(M, P)),
        (z = n.add(z, I)),
        (I = n.sub(C, I)),
        (I = n.mul(K, I)),
        (P = n.add(P, I)),
        (C = n.mul(z, P)),
        (D = n.add(D, C)),
        (C = n.mul(R, P)),
        (F = n.mul(T, F)),
        (F = n.sub(F, C)),
        (C = n.mul(T, z)),
        (k = n.mul(R, k)),
        (k = n.add(k, C)),
        new f(F, D, k)
      );
    }
    subtract(m) {
      return this.add(m.negate());
    }
    is0() {
      return this.equals(f.ZERO);
    }
    wNAF(m) {
      return y.wNAFCached(this, m, f.normalizeZ);
    }
    multiplyUnsafe(m) {
      Gn('scalar', m, ii, t.n);
      const w = f.ZERO;
      if (m === ii) return w;
      if (m === Ht) return this;
      const { endo: _ } = t;
      if (!_) return y.unsafeLadder(this, m);
      let { k1neg: S, k1: E, k2neg: O, k2: N } = _.splitScalar(m),
        F = w,
        D = w,
        k = this;
      for (; E > ii || N > ii; )
        E & Ht && (F = F.add(k)),
          N & Ht && (D = D.add(k)),
          (k = k.double()),
          (E >>= Ht),
          (N >>= Ht);
      return (
        S && (F = F.negate()),
        O && (D = D.negate()),
        (D = new f(n.mul(D.px, _.beta), D.py, D.pz)),
        F.add(D)
      );
    }
    multiply(m) {
      const { endo: w, n: _ } = t;
      Gn('scalar', m, Ht, _);
      let S, E;
      if (w) {
        const { k1neg: O, k1: N, k2neg: F, k2: D } = w.splitScalar(m);
        let { p: k, f: K } = this.wNAF(N),
          { p: M, f: C } = this.wNAF(D);
        (k = y.constTimeNegate(O, k)),
          (M = y.constTimeNegate(F, M)),
          (M = new f(n.mul(M.px, w.beta), M.py, M.pz)),
          (S = k.add(M)),
          (E = K.add(C));
      } else {
        const { p: O, f: N } = this.wNAF(m);
        (S = O), (E = N);
      }
      return f.normalizeZ([S, E])[0];
    }
    multiplyAndAddUnsafe(m, w, _) {
      const S = f.BASE,
        E = (N, F) => (F === ii || F === Ht || !N.equals(S) ? N.multiplyUnsafe(F) : N.multiply(F)),
        O = E(this, w).add(E(m, _));
      return O.is0() ? void 0 : O;
    }
    toAffine(m) {
      return u(this, m);
    }
    isTorsionFree() {
      const { h: m, isTorsionFree: w } = t;
      if (m === Ht) return !0;
      if (w) return w(f, this);
      throw new Error('isTorsionFree() has not been declared for the elliptic curve');
    }
    clearCofactor() {
      const { h: m, clearCofactor: w } = t;
      return m === Ht ? this : w ? w(f, this) : this.multiplyUnsafe(t.h);
    }
    toRawBytes(m = !0) {
      return di('isCompressed', m), this.assertValidity(), i(f, this, m);
    }
    toHex(m = !0) {
      return di('isCompressed', m), na(this.toRawBytes(m));
    }
  }
  (f.BASE = new f(t.Gx, t.Gy, n.ONE)), (f.ZERO = new f(n.ZERO, n.ONE, n.ZERO));
  const p = t.nBitLength,
    y = $O(f, t.endo ? Math.ceil(p / 2) : p);
  return {
    CURVE: t,
    ProjectivePoint: f,
    normPrivateKeyToScalar: s,
    weierstrassEquation: a,
    isWithinCurveOrder: c,
  };
}
function oce(e) {
  const t = Pw(e);
  return (
    xs(
      t,
      { hash: 'hash', hmac: 'function', randomBytes: 'function' },
      { bits2int: 'function', bits2int_modN: 'function', lowS: 'boolean' }
    ),
    Object.freeze({ lowS: !0, ...t })
  );
}
function ace(e) {
  const t = oce(e),
    { Fp: n, n: r } = t,
    i = n.BYTES + 1,
    o = 2 * n.BYTES + 1;
  function a(I) {
    return Ot(I, r);
  }
  function c(I) {
    return b0(I, r);
  }
  const {
      ProjectivePoint: s,
      normPrivateKeyToScalar: l,
      weierstrassEquation: u,
      isWithinCurveOrder: d,
    } = ice({
      ...t,
      toBytes(I, T, P) {
        const R = T.toAffine(),
          L = n.toBytes(R.x),
          H = ra;
        return (
          di('isCompressed', P),
          P
            ? H(Uint8Array.from([T.hasEvenY() ? 2 : 3]), L)
            : H(Uint8Array.from([4]), L, n.toBytes(R.y))
        );
      },
      fromBytes(I) {
        const T = I.length,
          P = I[0],
          R = I.subarray(1);
        if (T === i && (P === 2 || P === 3)) {
          const L = Lo(R);
          if (!Iy(L, Ht, n.ORDER)) throw new Error('Point is not on curve');
          const H = u(L);
          let ie;
          try {
            ie = n.sqrt(H);
          } catch (ee) {
            const J = ee instanceof Error ? ': ' + ee.message : '';
            throw new Error('Point is not on curve' + J);
          }
          const he = (ie & Ht) === Ht;
          return ((P & 1) === 1) !== he && (ie = n.neg(ie)), { x: L, y: ie };
        } else if (T === o && P === 4) {
          const L = n.fromBytes(R.subarray(0, n.BYTES)),
            H = n.fromBytes(R.subarray(n.BYTES, 2 * n.BYTES));
          return { x: L, y: H };
        } else
          throw new Error(
            `Point of length ${T} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`
          );
      },
    }),
    f = (I) => na(ds(I, t.nByteLength));
  function p(I) {
    const T = r >> Ht;
    return I > T;
  }
  function y(I) {
    return p(I) ? a(-I) : I;
  }
  const b = (I, T, P) => Lo(I.slice(T, P));
  class m {
    constructor(T, P, R) {
      (this.r = T), (this.s = P), (this.recovery = R), this.assertValidity();
    }
    static fromCompact(T) {
      const P = t.nByteLength;
      return (T = $t('compactSignature', T, P * 2)), new m(b(T, 0, P), b(T, P, 2 * P));
    }
    static fromDER(T) {
      const { r: P, s: R } = ti.toSig($t('DER', T));
      return new m(P, R);
    }
    assertValidity() {
      Gn('r', this.r, Ht, r), Gn('s', this.s, Ht, r);
    }
    addRecoveryBit(T) {
      return new m(this.r, this.s, T);
    }
    recoverPublicKey(T) {
      const { r: P, s: R, recovery: L } = this,
        H = N($t('msgHash', T));
      if (L == null || ![0, 1, 2, 3].includes(L)) throw new Error('recovery id invalid');
      const ie = L === 2 || L === 3 ? P + t.n : P;
      if (ie >= n.ORDER) throw new Error('recovery id 2 or 3 invalid');
      const he = L & 1 ? '03' : '02',
        Q = s.fromHex(he + f(ie)),
        ee = c(ie),
        J = a(-H * ee),
        fe = a(R * ee),
        j = s.BASE.multiplyAndAddUnsafe(Q, J, fe);
      if (!j) throw new Error('point at infinify');
      return j.assertValidity(), j;
    }
    hasHighS() {
      return p(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new m(this.r, a(-this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return ls(this.toDERHex());
    }
    toDERHex() {
      return ti.hexFromSig({ r: this.r, s: this.s });
    }
    toCompactRawBytes() {
      return ls(this.toCompactHex());
    }
    toCompactHex() {
      return f(this.r) + f(this.s);
    }
  }
  const w = {
    isValidPrivateKey(I) {
      try {
        return l(I), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: l,
    randomPrivateKey: () => {
      const I = FO(t.n);
      return Bse(t.randomBytes(I), t.n);
    },
    precompute(I = 8, T = s.BASE) {
      return T._setWindowSize(I), T.multiply(BigInt(3)), T;
    },
  };
  function _(I, T = !0) {
    return s.fromPrivateKey(I).toRawBytes(T);
  }
  function S(I) {
    const T = ta(I),
      P = typeof I == 'string',
      R = (T || P) && I.length;
    return T ? R === i || R === o : P ? R === 2 * i || R === 2 * o : I instanceof s;
  }
  function E(I, T, P = !0) {
    if (S(I)) throw new Error('first arg must be private key');
    if (!S(T)) throw new Error('second arg must be public key');
    return s.fromHex(T).multiply(l(I)).toRawBytes(P);
  }
  const O =
      t.bits2int ||
      function (I) {
        const T = Lo(I),
          P = I.length * 8 - t.nBitLength;
        return P > 0 ? T >> BigInt(P) : T;
      },
    N =
      t.bits2int_modN ||
      function (I) {
        return a(O(I));
      },
    F = Mw(t.nBitLength);
  function D(I) {
    return Gn(`num < 2^${t.nBitLength}`, I, ii, F), ds(I, t.nByteLength);
  }
  function k(I, T, P = K) {
    if (['recovered', 'canonical'].some((re) => re in P))
      throw new Error('sign() legacy options not supported');
    const { hash: R, randomBytes: L } = t;
    let { lowS: H, prehash: ie, extraEntropy: he } = P;
    H == null && (H = !0), (I = $t('msgHash', I)), KA(P), ie && (I = $t('prehashed msgHash', R(I)));
    const Q = N(I),
      ee = l(T),
      J = [D(ee), D(Q)];
    if (he != null && he !== !1) {
      const re = he === !0 ? L(n.BYTES) : he;
      J.push($t('extraEntropy', re));
    }
    const fe = ra(...J),
      j = Q;
    function Ie(re) {
      const Fe = O(re);
      if (!d(Fe)) return;
      const De = c(Fe),
        Be = s.BASE.multiply(Fe).toAffine(),
        _e = a(Be.x);
      if (_e === ii) return;
      const lt = a(De * a(j + _e * ee));
      if (lt === ii) return;
      let jt = (Be.x === _e ? 0 : 2) | Number(Be.y & Ht),
        qe = lt;
      return H && p(lt) && ((qe = y(lt)), (jt ^= 1)), new m(_e, qe, jt);
    }
    return { seed: fe, k2sig: Ie };
  }
  const K = { lowS: t.lowS, prehash: !1 },
    M = { lowS: t.lowS, prehash: !1 };
  function C(I, T, P = K) {
    const { seed: R, k2sig: L } = k(I, T, P),
      H = t;
    return UO(H.hash.outputLen, H.nByteLength, H.hmac)(R, L);
  }
  s.BASE._setWindowSize(8);
  function z(I, T, P, R = M) {
    var Be;
    const L = I;
    if (((T = $t('msgHash', T)), (P = $t('publicKey', P)), 'strict' in R))
      throw new Error('options.strict was renamed to lowS');
    KA(R);
    const { lowS: H, prehash: ie } = R;
    let he, Q;
    try {
      if (typeof L == 'string' || ta(L))
        try {
          he = m.fromDER(L);
        } catch (_e) {
          if (!(_e instanceof ti.Err)) throw _e;
          he = m.fromCompact(L);
        }
      else if (typeof L == 'object' && typeof L.r == 'bigint' && typeof L.s == 'bigint') {
        const { r: _e, s: lt } = L;
        he = new m(_e, lt);
      } else throw new Error('PARSE');
      Q = s.fromHex(P);
    } catch (_e) {
      if (_e.message === 'PARSE')
        throw new Error('signature must be Signature instance, Uint8Array or hex string');
      return !1;
    }
    if (H && he.hasHighS()) return !1;
    ie && (T = t.hash(T));
    const { r: ee, s: J } = he,
      fe = N(T),
      j = c(J),
      Ie = a(fe * j),
      re = a(ee * j),
      Fe = (Be = s.BASE.multiplyAndAddUnsafe(Q, Ie, re)) == null ? void 0 : Be.toAffine();
    return Fe ? a(Fe.x) === ee : !1;
  }
  return {
    CURVE: t,
    getPublicKey: _,
    getSharedSecret: E,
    sign: C,
    verify: z,
    ProjectivePoint: s,
    Signature: m,
    utils: w,
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function sce(e) {
  return { hash: e, hmac: (t, ...n) => KO(e, t, q4(...n)), randomBytes: CI };
}
function cce(e, t) {
  const n = (r) => ace({ ...e, ...sce(r) });
  return Object.freeze({ ...n(t), create: n });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const HO = Ey(
    BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff')
  ),
  uce = HO.create(BigInt('-3')),
  lce = BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b'),
  dce = cce(
    {
      a: uce,
      b: lce,
      Fp: HO,
      n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),
      Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),
      Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),
      h: BigInt(1),
      lowS: !1,
    },
    m0
  ),
  fce = dce;
function Ip(e, t) {
  if (e === t) return !0;
  if (e.length !== t.length) return !1;
  for (let n = 0; n < e.length; n++) if (e[n] !== t[n]) return !1;
  return !0;
}
class Dw {
  equals(t) {
    return Ip(this.toRawBytes(), t.toRawBytes());
  }
  toBase64() {
    return Wa(this.toRawBytes());
  }
  toString() {
    throw new Error(
      '`toString` is not implemented on public keys. Use `toBase64()` or `toRawBytes()` instead.'
    );
  }
  toSuiPublicKey() {
    const t = this.toSuiBytes();
    return Wa(t);
  }
  verifyWithIntent(t, n, r) {
    const i = Zse(r, t),
      o = pm(i, { dkLen: 32 });
    return this.verify(o, n);
  }
  verifyPersonalMessage(t, n) {
    return this.verifyWithIntent(Oa.vector(Oa.u8()).serialize(t).toBytes(), n, 'PersonalMessage');
  }
  verifyTransaction(t, n) {
    return this.verifyWithIntent(t, n, 'TransactionData');
  }
  verifyAddress(t) {
    return this.toSuiAddress() === t;
  }
  toSuiBytes() {
    const t = this.toRawBytes(),
      n = new Uint8Array(t.length + 1);
    return n.set([this.flag()]), n.set(t, 1), n;
  }
  toSuiAddress() {
    return MI(PI(pm(this.toSuiBytes(), { dkLen: 32 })).slice(0, OI * 2));
  }
}
const w0 = 33,
  _0 = 64;
class hce extends Dw {
  constructor(t) {
    if (
      (super(),
      typeof t == 'string'
        ? (this.data = no(t))
        : t instanceof Uint8Array
          ? (this.data = t)
          : (this.data = Uint8Array.from(t)),
      this.data.length !== w0)
    )
      throw new Error(`Invalid public key input. Expected ${w0} bytes, got ${this.data.length}`);
  }
  equals(t) {
    return super.equals(t);
  }
  toRawBytes() {
    return this.data;
  }
  flag() {
    return Wf.Passkey;
  }
  async verify(t, n) {
    const r = qO(n),
      i = JSON.parse(r.clientDataJson);
    if (i.type !== 'webauthn.get') return !1;
    const o = no(i.challenge.replace(/-/g, '+').replace(/_/g, '/'));
    if (!Ip(t, o)) return !1;
    const a = r.userSignature.slice(1 + _0);
    if (!Ip(this.toRawBytes(), a)) return !1;
    const c = new Uint8Array([...r.authenticatorData, ...m0(r.clientDataJson)]),
      s = r.userSignature.slice(1, _0 + 1);
    return fce.verify(s, m0(c), a);
  }
}
hce.SIZE = w0;
function qO(e) {
  const t = typeof e == 'string' ? no(e) : e;
  if (t[0] !== Wf.Passkey) throw new Error('Invalid signature scheme');
  const n = G4.parse(t.slice(1));
  return {
    signatureScheme: 'Passkey',
    serializedSignature: Wa(t),
    signature: t,
    authenticatorData: n.authenticatorData,
    clientDataJson: n.clientDataJson,
    userSignature: new Uint8Array(n.userSignature),
    publicKey: new Uint8Array(n.userSignature.slice(1 + _0)),
  };
}
var GO = (e) => {
    throw TypeError(e);
  },
  YO = (e, t, n) => t.has(e) || GO('Cannot ' + n),
  Ah = (e, t, n) => (YO(e, t, 'read from private field'), n ? n.call(e) : t.get(e)),
  Ih = (e, t, n) =>
    t.has(e)
      ? GO('Cannot add the same private member more than once')
      : t instanceof WeakSet
        ? t.add(e)
        : t.set(e, n),
  Eh = (e, t, n, r) => (YO(e, t, 'write to private field'), r ? r.call(e, n) : t.set(e, n), n),
  Wh,
  Vh,
  Kh,
  Hh;
class pce extends Error {}
class gce {
  constructor({ url: t, fetch: n = fetch, headers: r = {}, queries: i = {} }) {
    Ih(this, Wh),
      Ih(this, Vh),
      Ih(this, Kh),
      Ih(this, Hh),
      Eh(this, Wh, t),
      Eh(this, Vh, i),
      Eh(this, Kh, r),
      Eh(this, Hh, (...o) => n(...o));
  }
  async query(t) {
    const n = await Ah(this, Hh).call(this, Ah(this, Wh), {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...Ah(this, Kh) },
      body: JSON.stringify({
        query: typeof t.query == 'string' ? String(t.query) : V2(t.query),
        variables: t.variables,
        extensions: t.extensions,
        operationName: t.operationName,
      }),
    });
    if (!n.ok) throw new pce(`GraphQL request failed: ${n.statusText} (${n.status})`);
    return await n.json();
  }
  async execute(t, n) {
    return this.query({ ...n, query: Ah(this, Vh)[t] });
  }
}
Wh = new WeakMap();
Vh = new WeakMap();
Kh = new WeakMap();
Hh = new WeakMap();
const yce = K2();
function bce(e) {
  if (e.length !== 1) throw new Error('Invalid base64Url character: ' + e);
  const n = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'.indexOf(e);
  if (n === -1) throw new Error('Invalid base64Url character: ' + e);
  const r = n.toString(2).padStart(6, '0');
  return Array.from(r).map(Number);
}
function mce(e) {
  let t = [];
  for (let n = 0; n < e.length; n++) {
    const r = e.charAt(n),
      i = bce(r);
    t = t.concat(i);
  }
  return t;
}
function wce(e, t) {
  if (e.length < 2) throw new Error(`Input (s = ${e}) is not tightly packed because s.length < 2`);
  let n = mce(e);
  const r = t % 4;
  if (r !== 0)
    if (r === 1) n = n.slice(2);
    else if (r === 2) n = n.slice(4);
    else throw new Error(`Input (s = ${e}) is not tightly packed because i%4 = 3 (i = ${t}))`);
  const i = (t + e.length - 1) % 4;
  if (i !== 3)
    if (i === 2) n = n.slice(0, n.length - 2);
    else if (i === 1) n = n.slice(0, n.length - 4);
    else
      throw new Error(
        `Input (s = ${e}) is not tightly packed because (i + s.length - 1)%4 = 0 (i = ${t}))`
      );
  if (n.length % 8 !== 0) throw new Error('We should never reach here...');
  const o = new Uint8Array(Math.floor(n.length / 8));
  let a = 0;
  for (let c = 0; c < n.length; c += 8) {
    const s = n.slice(c, c + 8),
      l = parseInt(s.join(''), 2);
    o[a++] = l;
  }
  return new TextDecoder().decode(o);
}
function _ce(e) {
  if (!(e.slice(-1) === '}' || e.slice(-1) === ',')) throw new Error('Invalid claim');
  const t = JSON.parse('{' + e.slice(0, -1) + '}');
  if (Object.keys(t).length !== 1) throw new Error('Invalid claim');
  const n = Object.keys(t)[0];
  return [n, t[n]];
}
function vce(e, t) {
  const n = wce(e.value, e.indexMod4),
    [r, i] = _ce(n);
  if (r !== t) throw new Error(`Invalid field name: found ${r} expected ${t}`);
  return i;
}
const Sce = Vt.struct('ZkLoginSignature', {
  inputs: Vt.struct('ZkLoginSignatureInputs', {
    proofPoints: Vt.struct('ZkLoginSignatureInputsProofPoints', {
      a: Vt.vector(Vt.string()),
      b: Vt.vector(Vt.vector(Vt.string())),
      c: Vt.vector(Vt.string()),
    }),
    issBase64Details: Vt.struct('ZkLoginSignatureInputsClaim', {
      value: Vt.string(),
      indexMod4: Vt.u8(),
    }),
    headerBase64: Vt.string(),
    addressSeed: Vt.string(),
  }),
  maxEpoch: Vt.u64(),
  userSignature: Vt.vector(Vt.u8()),
});
function Ace(e) {
  return Sce.parse(typeof e == 'string' ? no(e) : e);
}
function Ice(e) {
  for (let t = 0; t < e.length; t++) if (e[t] !== 0) return t;
  return -1;
}
function Rw(e, t) {
  const n = e.toString(16);
  return Y4(n.padStart(t * 2, '0').slice(-t * 2));
}
function ZO(e, t) {
  const n = Rw(e, t),
    r = Ice(n);
  return r === -1 ? new Uint8Array([0]) : n.slice(r);
}
var QO = (e) => {
    throw TypeError(e);
  },
  xw = (e, t, n) => t.has(e) || QO('Cannot ' + n),
  Jr = (e, t, n) => (xw(e, t, 'read from private field'), n ? n.call(e) : t.get(e)),
  Th = (e, t, n) =>
    t.has(e)
      ? QO('Cannot add the same private member more than once')
      : t instanceof WeakSet
        ? t.add(e)
        : t.set(e, n),
  va = (e, t, n, r) => (xw(e, t, 'write to private field'), r ? r.call(e, n) : t.set(e, n), n),
  qA = (e, t, n) => (xw(e, t, 'access private method'), n),
  nr,
  nc,
  rc,
  qh,
  v0;
const Ece = class S0 extends Dw {
  constructor(t, { client: n } = {}) {
    super(),
      Th(this, qh),
      Th(this, nr),
      Th(this, nc),
      Th(this, rc),
      va(this, nc, n),
      typeof t == 'string'
        ? va(this, nr, no(t))
        : t instanceof Uint8Array
          ? va(this, nr, t)
          : va(this, nr, Uint8Array.from(t)),
      va(this, rc, Jr(this, nr).length !== Jr(this, nr)[0] + 1 + 32),
      Jr(this, rc) && va(this, nr, JO(Jr(this, nr)));
  }
  equals(t) {
    return super.equals(t);
  }
  toSuiAddress() {
    return Jr(this, rc) ? qA(this, qh, v0).call(this) : super.toSuiAddress();
  }
  toRawBytes() {
    return Jr(this, nr);
  }
  flag() {
    return Wf.ZkLogin;
  }
  async verify(t, n) {
    throw Error('does not support');
  }
  verifyPersonalMessage(t, n) {
    const r = A0(n),
      i = new S0(r.publicKey).toSuiAddress();
    return GA({
      address: i,
      bytes: Wa(t),
      signature: r.serializedSignature,
      intentScope: 'PERSONAL_MESSAGE',
      client: Jr(this, nc),
    });
  }
  verifyTransaction(t, n) {
    const r = A0(n),
      i = new S0(r.publicKey).toSuiAddress();
    return GA({
      address: i,
      bytes: Wa(t),
      signature: r.serializedSignature,
      intentScope: 'TRANSACTION_DATA',
      client: Jr(this, nc),
    });
  }
  verifyAddress(t) {
    return t === super.toSuiAddress() || t === qA(this, qh, v0).call(this);
  }
};
nr = new WeakMap();
nc = new WeakMap();
rc = new WeakMap();
qh = new WeakSet();
v0 = function () {
  const e = JO(Jr(this, nr), !0),
    t = new Uint8Array(e.length + 1);
  return (t[0] = this.flag()), t.set(e, 1), MI(PI(pm(t, { dkLen: 32 })).slice(0, OI * 2));
};
let Tce = Ece;
function kce(e, t, n) {
  const r = n != null && n.legacyAddress ? ZO(e, 32) : Rw(e, 32),
    i = new TextEncoder().encode(t),
    o = new Uint8Array(1 + i.length + r.length);
  return o.set([i.length], 0), o.set(i, 1), o.set(r, 1 + i.length), new Tce(o, n);
}
const Cce = yce(`
	query Zklogin(
		$bytes: Base64!
		$signature: Base64!
		$intentScope: ZkLoginIntentScope!
		$author: SuiAddress!
	) {
		verifyZkloginSignature(
			bytes: $bytes
			signature: $signature
			intentScope: $intentScope
			author: $author
		) {
			success
			errors
		}
	}
`);
function JO(e, t = !1) {
  const n = e[0] + 1,
    r = BigInt(`0x${Z4(e.slice(n))}`),
    i = t ? ZO(r, 32) : Rw(r, 32),
    o = new Uint8Array(n + i.length);
  return o.set(e.slice(0, n), 0), o.set(i, n), o;
}
async function GA({
  address: e,
  bytes: t,
  signature: n,
  intentScope: r,
  client: i = new gce({ url: 'https://sui-mainnet.mystenlabs.com/graphql' }),
}) {
  var a, c;
  const o = await i.query({
    query: Cce,
    variables: { bytes: t, signature: n, intentScope: r, author: e },
  });
  return (
    ((a = o.data) == null ? void 0 : a.verifyZkloginSignature.success) === !0 &&
    ((c = o.data) == null ? void 0 : c.verifyZkloginSignature.errors.length) === 0
  );
}
function A0(e) {
  const t = typeof e == 'string' ? no(e) : e;
  if (t[0] !== Wf.ZkLogin) throw new Error('Invalid signature scheme');
  const n = t.slice(1),
    { inputs: r, maxEpoch: i, userSignature: o } = Ace(n),
    { issBase64Details: a, addressSeed: c } = r,
    s = vce(a, 'iss'),
    l = kce(BigInt(c), s);
  return {
    serializedSignature: Wa(t),
    signatureScheme: 'ZkLogin',
    zkLogin: { inputs: r, maxEpoch: i, userSignature: o, iss: s, addressSeed: BigInt(c) },
    signature: t,
    publicKey: l.toRawBytes(),
  };
}
function Mce(e) {
  const t = no(e),
    n = Jse[t[0]];
  switch (n) {
    case 'Passkey':
      return qO(e);
    case 'MultiSig':
      const r = Oa.MultiSig.parse(t.slice(1));
      return { serializedSignature: e, signatureScheme: n, multisig: r, bytes: t };
    case 'ZkLogin':
      return A0(e);
    case 'ED25519':
    case 'Secp256k1':
    case 'Secp256r1':
      const i = Qse[n],
        o = t.slice(1, t.length - i),
        a = t.slice(1 + o.length);
      return { serializedSignature: e, signatureScheme: n, signature: o, publicKey: a, bytes: t };
    default:
      throw new Error('Unsupported signature scheme');
  }
}
const I0 = 32;
class XO extends Dw {
  constructor(t) {
    if (
      (super(),
      typeof t == 'string'
        ? (this.data = no(t))
        : t instanceof Uint8Array
          ? (this.data = t)
          : (this.data = Uint8Array.from(t)),
      this.data.length !== I0)
    )
      throw new Error(`Invalid public key input. Expected ${I0} bytes, got ${this.data.length}`);
  }
  equals(t) {
    return super.equals(t);
  }
  toRawBytes() {
    return this.data;
  }
  flag() {
    return Wf.ED25519;
  }
  async verify(t, n) {
    let r;
    if (typeof n == 'string') {
      const i = Mce(n);
      if (i.signatureScheme !== 'ED25519') throw new Error('Invalid signature scheme');
      if (!Ip(this.toRawBytes(), i.publicKey))
        throw new Error('Signature does not match public key');
      r = i.signature;
    } else r = n;
    return Yse.verify(r, t, this.toRawBytes());
  }
}
XO.SIZE = I0;
const Pce = async () => {
    const e = await Qt();
    return e3(e);
  },
  e3 = (e) => {
    const t = e.addresses.filter((n) => n.networkID === Aa.Mainnet || n.networkID === Aa.Testnet);
    if (t.length === 0) throw FI;
    if (t.length === 1) {
      const [n] = t;
      if (!(n != null && n.publicKey))
        throw new Error('[sui provider] selected account account does not have a public key');
      const { publicKey: r, address: i } = n;
      return { address: i, publicKey: new XO(r).toSuiBytes().toString() };
    }
    throw new Error('[sui provider] multiple accounts provided');
  },
  Oce = async (e, t, n) => {
    const r = await Qt(),
      i = fs.from(t);
    i.setSenderIfNotSet(e);
    const o = await LM({ transaction: i, networkID: n }),
      a = await Xn.sign(r.identifier, {
        chainType: X.Sui,
        signingType: 'transaction',
        transaction: new Uint8Array(o),
      });
    if (a.status === 'error') throw new Error(`[sui provider][${a.type}] ${a.message}`);
    const c = a.signature;
    if (!c) throw new Error('[sui provider] no message on vault response');
    return { signature: c, transaction: U0(o) };
  },
  Dce = async (e, t) => {
    const n = await Qt(),
      r = await Xn.sign(n.identifier, {
        chainType: X.Sui,
        signingType: 'personalMessage',
        message: t,
      });
    if (r.status === 'error') throw new Error(`[sui provider][${r.type}] ${r.message}`);
    if (!r.signature) throw new Error('[sui provider] no message on vault response');
    return { signature: r.signature, message: U0(t) };
  },
  Rce = zn.getInstance(),
  xce = async (e, t, n) => {
    const r = await Qt(),
      i = fs.from(t);
    i.setSenderIfNotSet(e);
    const o = await LM({ transaction: i, networkID: n }),
      a = {
        ownerAddress: e,
        networkID: n,
        data: { digest: '' },
        type: ci.DappInteraction,
        display: { summary: { topLeft: { text: Et.t('transactionsPendingAppInteraction') } } },
      },
      {
        signature: c,
        digest: s,
        effects: l,
      } = await mY({
        accountSigner: Xn,
        accountIdentifier: r.identifier,
        transaction: o,
        pendingTransactionInput: a,
        storage: Rce,
      });
    return { signature: c, transaction: U0(o), digest: s, effects: l };
  },
  Bce = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        getSelectedAccount: Pce,
        getSuiAddressWithPubkey: e3,
        signAndExecuteTransaction: xce,
        signMessage: Dce,
        signTransaction: Oce,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  jce = void 0,
  Nce = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        addTrustedApp: RZ,
        btc: jce,
        deleteTrustedApp: xZ,
        eth: cse,
        getMetaMaskOverrideSetting: BZ,
        getUser: Sae,
        isTrustedApp: jZ,
        isUserOnboarded: Y1,
        login: Aae,
        logout: Iae,
        navigate: mae,
        onboardQuickly: wae,
        openUserProfile: _ae,
        requestUserApproval: pae,
        requestUserOnboard: vae,
        setMetaMaskOverrideSetting: gae,
        sol: Fae,
        sui: Bce,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  Bs = {
    analytics: TZ,
    config: kZ,
    i18n: MZ,
    logger: PZ,
    rpc: OZ,
    utils: DZ,
    wallet: Nce,
    featureFlags: CZ,
    secrets: {
      setSharedSecret: () => {
        throw new Error('unimplemented');
      },
      encryptDeepLinkDappPayload: () => {
        throw new Error('unimplemented');
      },
      deleteSharedSecret: () => {
        throw new Error('unimplemented');
      },
      generateSharedSecret: () => {
        throw new Error('unimplemented');
      },
      generateSession: () => {
        throw new Error('unimplemented');
      },
      decryptDeepLinkDappPayload: () => {
        throw new Error('unimplemented');
      },
    },
  },
  Uce = H2(Bs),
  Lce = q2(Bs),
  zce = G2(Bs),
  Fce = Y2(Bs),
  $ce = Z2(Bs),
  Wce = Q2(Bs),
  Vce = { ...zce, ...Uce, ...Lce, ...Fce, ...$ce, ...Wce },
  Kce = () => {
    const e = [],
      t = (o) => {
        const a = { type: 'BrowserTabRpcRequestSource', url: new URL(o.origin), icon: void 0 };
        if (typeof o.data == 'string')
          try {
            const c = yI.parse(l1(o.data));
            e.push(fm(c, a));
          } catch {}
      };
    window.addEventListener('message', t);
    const n = Hce(e),
      r = qce(),
      i = new J2({ routes: Vce }).init(n, r);
    return window.removeEventListener('message', t), i;
  };
function Hce(e = []) {
  let t;
  return new ReadableStream(
    {
      start(n) {
        for (const r of e) n.enqueue(fm(r.request, r.source));
        (t = (r) => {
          let i = null;
          const o = r.data;
          try {
            i = yI.parse(l1(o));
          } catch {}
          if (i)
            try {
              const a = {
                type: 'BrowserTabRpcRequestSource',
                url: new URL(r.origin),
                icon: void 0,
              };
              n.enqueue(fm(i, a));
            } catch (a) {
              Z.captureError(new Error(`Stream enqueue failure (${a})`), te.Provider);
            }
        }),
          window.addEventListener('message', t);
      },
      cancel() {
        t && window.removeEventListener('message', t);
      },
    },
    new CountQueuingStrategy({ highWaterMark: 1 / 0 })
  );
}
function qce() {
  return new WritableStream({
    write([e, t]) {
      window.parent.postMessage(lT(t), '*');
    },
  });
}
const Gce = async () => {
    Yce(), await Zce();
  },
  Yce = () => {
    h5(), ej(), J7(), Kce().start(), os(Qe.renderMode === 'full-mode' ? Gt.Open : Gt.Closed);
  },
  Zce = async () => {
    await Q7(), await Yw(Oe.Monad, Da), await Yw(Oe.Sui, Da), await X2(X.Sui, Da);
  },
  t3 = {
    signMessages: function () {
      throw new Error('Function not implemented.');
    },
    getBatchAccountMetadata: function () {
      throw new Error('Function not implemented.');
    },
    getAccountMetadata: function () {
      throw new Error('Function not implemented.');
    },
    storeSyncedAccounts: function () {
      throw new Error('Function not implemented.');
    },
  },
  Qce = TD({ authRepository: qa, claimUsernameSigner: t3, queryClient: a1 }),
  Jce = ({ children: e }) =>
    A.jsx(jR, { userRepository: Qce, claimUsernameSigner: t3, children: e }),
  Xce = () => {
    const e = Ur((s) => s.setWalletState),
      t = Ur((s) => s.walletState),
      n = Ur((s) => s.walletContainerClassname),
      r = Ur((s) => s.walletFrameClassname),
      i = Ur((s) => s.launcherButtonClassname),
      o = async () => {
        t === Gt.Open ? await e(Gt.Closed) : t === Gt.Closed && (await e(Gt.Open));
      };
    G.useEffect(() => tQ(), []);
    const a = G.useRef(null);
    G.useEffect(() => {
      if (a.current) return iQ(a.current);
    }, []);
    const c = Qe.renderMode === 'full-mode' ? 'relative' : Qe.position;
    return A.jsxs('div', {
      id: 'wallet-container',
      className: n,
      'data-position': c,
      children: [
        A.jsx('div', {
          id: 'walletFrame',
          className: r,
          'data-position': c,
          children: A.jsx(Ue.StrictMode, {
            children: A.jsx(q7, {
              children: A.jsx(gT, {
                children: A.jsx(G.Suspense, {
                  fallback: null,
                  children: A.jsx(r6, { router: bn }),
                }),
              }),
            }),
          }),
        }),
        Qe.renderMode === 'button' &&
          A.jsx('button', {
            ref: a,
            className: i,
            onClick: () => void o(),
            'data-position': c,
            children: A.jsx(F3, { color: 'textPrimary', size: 32 }),
          }),
      ],
    });
  };
Gce().finally(() => {
  const e = document.getElementById('root');
  DI(e).render(A.jsx(eue, {})), (document.documentElement.style.colorScheme = Qe.colorScheme);
});
const eue = () =>
  A.jsx(e4, {
    contexts: [[oI, S7]],
    children: A.jsx(T7, {
      children: A.jsx($3, {
        className: ft({ width: '100%', height: '100%' }),
        children: A.jsx(A5, {
          children: A.jsx(Jce, {
            children: A.jsx(w5, {
              children: A.jsx(t4, {
                children: A.jsx(v7, {
                  children: A.jsx(k7, {
                    children: A.jsx(gT, { children: A.jsx(c7, { children: A.jsx(Xce, {}) }) }),
                  }),
                }),
              }),
            }),
          }),
        }),
      }),
    }),
  });
export {
  vue as $,
  yQ as A,
  oJ as B,
  uT as C,
  XM as D,
  Tw as E,
  rle as F,
  Qe as G,
  yp as H,
  kS as I,
  x5 as J,
  E6 as K,
  WD as L,
  JM as M,
  Z1 as N,
  M5 as O,
  C5 as P,
  T5 as Q,
  Ga as R,
  k5 as S,
  s1 as T,
  zn as U,
  fT as V,
  Gt as W,
  Fue as X,
  $ue as Y,
  $7 as Z,
  p6 as _,
  ms as a,
  _le as a$,
  Qp as a0,
  zI as a1,
  mue as a2,
  wue as a3,
  _ue as a4,
  rq as a5,
  oq as a6,
  aq as a7,
  Que as a8,
  iq as a9,
  JE as aA,
  XG as aB,
  AP as aC,
  gi as aD,
  ea as aE,
  a7 as aF,
  cO as aG,
  Ple as aH,
  Mle as aI,
  Dm as aJ,
  pO as aK,
  UJ as aL,
  Dle as aM,
  tie as aN,
  Ole as aO,
  Ele as aP,
  i1 as aQ,
  bS as aR,
  Wue as aS,
  oP as aT,
  xle as aU,
  Ale as aV,
  Ote as aW,
  $5 as aX,
  lw as aY,
  hle as aZ,
  Tle as a_,
  ks as aa,
  lZ as ab,
  WM as ac,
  fa as ad,
  uY as ae,
  Jue as af,
  mY as ag,
  Kue as ah,
  lo as ai,
  wM as aj,
  gle as ak,
  rs as al,
  yle as am,
  sZ as an,
  Vue as ao,
  FS as ap,
  yj as aq,
  rte as ar,
  wP as as,
  yi as at,
  ci as au,
  _n as av,
  Ile as aw,
  eY as ax,
  Re as ay,
  Uee as az,
  eT as b,
  Mo as b$,
  GX as b0,
  Tue as b1,
  ke as b2,
  hn as b3,
  yP as b4,
  fee as b5,
  ple as b6,
  sq as b7,
  EE as b8,
  fle as b9,
  SG as bA,
  Np as bB,
  wle as bC,
  ble as bD,
  mle as bE,
  FM as bF,
  Wb as bG,
  PY as bH,
  ele as bI,
  c1 as bJ,
  _ie as bK,
  aO as bL,
  Cle as bM,
  Sie as bN,
  Ble as bO,
  ly as bP,
  vie as bQ,
  Lue as bR,
  Are as bS,
  dle as bT,
  Poe as bU,
  Iie as bV,
  bQ as bW,
  tw as bX,
  ew as bY,
  Iee as bZ,
  RJ as b_,
  pD as ba,
  aa as bb,
  nle as bc,
  dD as bd,
  cJ as be,
  fB as bf,
  XB as bg,
  ze as bh,
  jee as bi,
  Lf as bj,
  kle as bk,
  oO as bl,
  Je as bm,
  aT as bn,
  L5 as bo,
  Rs as bp,
  fte as bq,
  Mn as br,
  Wre as bs,
  cy as bt,
  Uo as bu,
  zf as bv,
  Gre as bw,
  FJ as bx,
  zJ as by,
  Hue as bz,
  ene as c,
  Eee as c0,
  iw as d,
  ole as e,
  ep as f,
  ym as g,
  qp as h,
  ale as i,
  zue as j,
  sle as k,
  vle as l,
  cle as m,
  fc as n,
  ule as o,
  ile as p,
  Sle as q,
  lle as r,
  NQ as s,
  tP as t,
  ys as u,
  tle as v,
  RR as w,
  Rle as x,
  a1 as y,
  Ur as z,
};
